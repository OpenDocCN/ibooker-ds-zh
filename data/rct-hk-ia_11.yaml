- en: 10 Using third-party hooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用第三方钩子
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Making the most of third-party hooks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用第三方钩子
- en: Accessing state in the URL with React Router’s `useParams` and `useSearchParams`
    hooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的`useParams`和`useSearchParams`钩子访问URL中的状态
- en: Switching to a new route with React Router’s `useNavigate` hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的`useNavigate`钩子切换到新路由
- en: Efficiently fetching and caching data with React Query’s `useQuery` hook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query的`useQuery`钩子高效获取和缓存数据
- en: Updating data on the server with React Query’s `useMutation` hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query的`useMutation`钩子更新服务器上的数据
- en: Chapter 9 introduced custom hooks as a way to extract functionality from components,
    making the functionality reusable and simplifying the components. Custom hooks
    provide a simple, readable way to access all kinds of functionality from a function
    component, whether that’s simple tasks like changing the document title or managing
    a state value with local storage, or increasingly complex tasks like fetching
    data or working with an application state manager. Many existing libraries have
    been quick to provide hooks to allow function components to make the most of the
    libraries’ features, and this chapter tries some out to improve the bookings example
    app.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章介绍了自定义钩子作为从组件中提取功能的一种方式，使功能可重用并简化组件。自定义钩子提供了一种简单、易读的方式来从函数组件访问各种功能，无论是简单的任务，如更改文档标题或使用本地存储管理状态值，还是越来越复杂的任务，如获取数据或与应用程序状态管理器一起工作。许多现有的库都迅速提供了钩子，允许函数组件充分利用库的功能，本章尝试了一些钩子来改进预订示例应用。
- en: The bookings app has been using React Router to switch between its page components
    for bookings, bookables, and users. But React Router can handle more complicated
    scenarios, and in sections 10.1 and 10.2 we introduce three of its hooks. The
    first, `useParams`, lets us specify the bookable to show on the Bookables page
    by including its ID in the URL path. The second, `useNavigate`, lets us navigate
    to a new URL when a user clicks the Next button or selects a different group.
    The third, `useSearchParams`, lets us get and set search parameters in a URL’s
    query string to specify a bookable ID and date on the Bookings page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 预订应用一直使用React Router在预订、可预订和用户页面组件之间切换。但React Router可以处理更复杂的场景，在第10.1节和第10.2节中，我们介绍了其三个钩子。第一个是`useParams`，它允许我们通过在URL路径中包含其ID来指定要在可预订页面上显示的可预订项。第二个是`useNavigate`，它允许我们在用户点击“下一步”按钮或选择不同的组时导航到新的URL。第三个是`useSearchParams`，它允许我们在URL的查询字符串中获取和设置搜索参数，以指定预订页面上可预订的ID和日期。
- en: We’ve been loading data with our own `useFetch` hook without considering caching
    or re-fetching, techniques that help us more efficiently retrieve data and update
    the UI. It’s time to up our data game, and the React Query library can do some
    great things for us with minimal setup. In section 10.3, we have a go at using
    its `useQuery` hook and pave the way for sending changes to the server via the
    `useMutation` hook.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用自己的`useFetch`钩子来加载数据，而没有考虑缓存或重新获取数据，这些技术可以帮助我们更有效地检索数据并更新UI。是时候提升我们的数据游戏了，React
    Query库可以通过最小的设置为我们做一些很棒的事情。在第10.3节中，我们尝试使用其`useQuery`钩子，并为通过`useMutation`钩子发送更改到服务器铺平道路。
- en: Let’s introduce our first third-party custom hook and see how we can access
    state that’s specified in a URL.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍我们的第一个第三方自定义钩子，并看看我们如何访问在URL中指定的状态。
- en: 10.1 Accessing state in the URL with React Router
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 使用React Router访问URL中的状态
- en: React Router gives us navigational components (`Router`, `Routes`, `Route`,
    and `Link`, for example) that we use to match UI with URL routes. When a user
    navigates to a URL, React Router displays the associated React component for that
    route and, as you’ll see, makes any parameters in the URL available to nested
    components via hooks. Figure 10.1 shows the home page at [https://reactrouter.com](https://reactrouter.com/),
    where you can find out more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: React Router为我们提供了导航组件（例如`Router`、`Routes`、`Route`和`Link`），我们使用这些组件将UI与URL路由相匹配。当用户导航到一个URL时，React
    Router会显示该路由关联的React组件，并且，正如您将看到的，通过钩子使URL中的任何参数对嵌套组件可用。图10.1显示了[https://reactrouter.com](https://reactrouter.com/)的首页，在那里您可以了解更多信息。
- en: '![](../Images/10-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-1.png)'
- en: 'Figure 10.1 The web page for React Router: Learn Once, Route Anywhere'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 React Router的网页：一次学习，任意路由
- en: 'The bookings app includes three pages—for Bookings, Bookables, and Users—and
    we already use React Router to show the appropriate page depending on the URL:
    /bookings, /bookables and /users. The association of the URL with the page component
    is in the App.js file, which includes this code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 预订应用包括三个页面——预订、Bookables和用户，并且我们已经使用React Router根据URL显示相应的页面：/bookings、/bookables和/users。URL与页面组件的关联在App.js文件中，该文件包含以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But your boss is back and has decided it would be great if visitors could navigate
    directly to specific bookables and dates. For example, to show the bookable with
    an ID of 3, a visitor would use this URL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但你的老板回来了，并决定如果访客可以直接导航到特定的预订和日期，那会很好。例如，要显示ID为3的预订，访客将使用这个URL：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see the bookings for the same bookable on June 24, 2020, the visitor would
    use this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看2020年6月24日同一预订的预订情况，访客将使用这个：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These URLs contain state for the application, either as part of the URL path
    (`/bookables/3`) or as search parameters in the query string (`bookableId=3&date=2020-06-24`).
    In section 10.2, we’ll update the Bookings page to work with the query string
    and the `useSearchParams` hook. In this section, we start with the Bookables page
    and focus on the URL path and the `useParams` and `useNavigate` hooks. The section
    is split into four subsections, each working with one component, as shown in table
    10.1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些URL包含应用程序的状态，无论是作为URL路径的一部分（`/bookables/3`）还是作为查询字符串中的搜索参数（`bookableId=3&date=2020-06-24`）。在第10.2节中，我们将更新预订页面以使用查询字符串和`useSearchParams`钩子。在本节中，我们从Bookables页面开始，关注URL路径和`useParams`以及`useNavigate`钩子。本节分为四个小节，每个小节处理一个组件，如表10.1所示。
- en: Table 10.1 The four components we’ll change in this section
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 本节中我们将更改的四个组件
- en: '| Section | Component | Change |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 部分 | 组件 | 更改 |'
- en: '| 10.1.1 | `App` | Setting up routes to enable nesting |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 10.1.1 | `App` | 设置路由以启用嵌套 |'
- en: '| 10.1.2 | `BookablesPage` | Adding nested routes to the Bookables page |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 10.1.2 | `BookablesPage` | 向“Bookables”页面添加嵌套路由 |'
- en: '| 10.1.3 | `BookablesView` | Accessing URL parameters with the `useParams`
    hook |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 10.1.3 | `BookablesView` | 使用`useParams`钩子访问URL参数 |'
- en: '| 10.1.4 | `BookablesList` | Navigating with the `useNavigate` hook |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 10.1.4 | `BookablesList` | 使用`useNavigate`钩子进行导航 |'
- en: Let’s take our first steps on the path to parameters by updating App.js to accept
    the new routes we’re going to add.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新App.js以接受我们即将添加的新路由，开始参数化路径的第一步。
- en: 10.1.1 Setting up routes to enable nesting
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 设置路由以启用嵌套
- en: 'To display the details of a bookable and to edit and create bookables, users
    will navigate to URLs like these:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示预订的详细信息以及编辑和创建预订，用户将导航到如下URL：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Display the details for the bookable with an ID of 3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示ID为3的预订的详细信息。
- en: ❷ Edit the bookable with an ID of 3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 编辑ID为3的预订。
- en: ❸ Create a new bookable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个新的预订。
- en: 'Two of the three components associated with the three routes are in figure
    10.2: the details view for the bookable with an ID of 3, and the form for creating
    a new bookable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与三个路由关联的三个组件中的两个在图10.2中：具有ID为3的预订的详细信息视图和创建新预订的表单。
- en: '![](../Images/10-2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-2.png)'
- en: Figure 10.2 Different views are associated with different URLs. `/bookables/3`
    shows the details of the bookable with an ID of 3, and `/bookables/new` shows
    the form for creating a new bookable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 不同的视图与不同的URL相关联。`/bookables/3`显示了ID为3的预订的详细信息，而`/bookables/new`显示了创建新预订的表单。
- en: Now that we have multiple routes that start with `/bookables`, we need to update
    App.js to make sure the `BookablesPage` component is rendered for all of them.
    The following listing shows the changed `path` attribute for the `/bookables`
    route with its appended `/*`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有多个以“/bookables”开头的路由，我们需要更新App.js以确保为所有这些路由渲染`BookablesPage`组件。以下列表显示了更改后的`path`属性，包括附加的`/*`。
- en: 'Branch: 1001-bookables-routes, File: /src/components/App.js'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1001-bookables-routes，文件：/src/components/App.js
- en: Listing 10.1 Extending the `BookablesPage` route in the `App` component
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 在`App`组件中扩展`BookablesPage`路由
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Match any URL that starts with “bookables.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配以“bookables”开头的任何URL。
- en: Now, any path that starts with `/bookables/` will render the `BookablesPage`
    component. That small change lets the component set up the three nested routes
    we need.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何以`/bookables/`开头的路径都将渲染`BookablesPage`组件。这个小小的改动使得组件能够设置我们需要的三个嵌套路由。
- en: 10.1.2 Adding nested routes to the Bookables page
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 向“Bookables”页面添加嵌套路由
- en: React Router lets us render different components depending on the *location*
    or URL. We use `Route` components to match a `path` with a component to render.
    In listing 10.1, we specified that any path starting with `/bookables` should
    render the `BookablesPage` component. Listing 10.2 sets up some nested routes
    to show more-specific components on the Bookables page. (We’ve also added `BookableEdit`
    and `BookableNew` components to the repo so that the app will compile. We’ll discuss
    them in section 10.3.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 允许我们根据 *位置* 或 URL 来渲染不同的组件。我们使用 `Route` 组件来匹配一个 `path` 与一个要渲染的组件。在列表
    10.1 中，我们指定了任何以 `/bookables` 开头的路径都应该渲染 `BookablesPage` 组件。列表 10.2 设置了一些嵌套路由，以在
    Bookables 页面上显示更具体的组件。（我们还在存储库中添加了 `BookableEdit` 和 `BookableNew` 组件，以便应用程序可以编译。我们将在第
    10.3 节中讨论它们。）
- en: 'Branch: 1001-bookables-routes, File: /src/components/Bookables/BookablesPage.js'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1001-bookables-routes，文件：/src/components/Bookables/BookablesPage.js
- en: Listing 10.2 Nested routes in the `BookablesPage` component
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 `BookablesPage` 组件中的嵌套路由
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Specify a set of nested routes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定一组嵌套路由。
- en: ❷ Use a parameter to catch the specified bookable ID.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用参数来捕获指定的可预订 ID。
- en: ❸ Render the BookablesView component even when no ID is specified.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 即使没有指定 ID，也渲染 `BookablesView` 组件。
- en: ❹ Use a parameter to show an edit form for the specified bookable ID.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用参数来显示指定可预订 ID 的编辑表单。
- en: ❺ Include a separate route for the new bookables form.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 包含一个用于新可预订表单的单独路由。
- en: 'In the listing, we use opening and closing `Route` tags, rather than an `element`
    prop, just to show that you can specify the UI for a matching route as enclosed
    JSX rather than as a prop. We add two routes that render the `BookablesView` component
    and two more routes for creating and editing bookables. The first `Route` in listing
    10.2 includes a parameter to catch the ID of the bookable to display:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，我们使用开闭 `Route` 标签，而不是 `element` 属性，只是为了显示你可以将匹配路由的 UI 指定为封装的 JSX，而不是作为属性。我们添加了两个渲染
    `BookablesView` 组件的路由和两个用于创建和编辑可预订项目的路由。列表 10.2 中的第一个 `Route` 包含一个用于捕获要显示的可预订
    ID 的参数：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Match URLs of the form /bookables/:id.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配形式为 /bookables/:id 的 URL。
- en: Because these routes are nested within the `BookablesPage` component, which
    is rendered by React Router when the URL matches `/bookables/*`, this route is
    rendered for URLs of the form `/bookables/:id`. For example, when navigating to
    `/bookables/3`, React Router will render the `BookablesPage` component and then
    the `BookablesView` component within it. React Router will also set the `id` parameter
    to `3`. So, how do we access that parameter from within a rendered component?
    Here comes our first third-party custom hook!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些路由嵌套在 `BookablesPage` 组件中，该组件在 URL 匹配 `/bookables/*` 时由 React Router 渲染，所以这个路由会为形式为
    `/bookables/:id` 的 URL 进行渲染。例如，当导航到 `/bookables/3` 时，React Router 将渲染 `BookablesPage`
    组件，然后渲染其中的 `BookablesView` 组件。React Router 还会将 `id` 参数设置为 `3`。那么，我们如何在渲染的组件中访问这个参数呢？这就是我们的第一个第三方自定义钩子！
- en: 10.1.3 Accessing URL parameters with the useParams hook
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3 使用 `useParams` 钩子访问 URL 参数
- en: 'React Router’s `useParams` hook returns an object with properties corresponding
    to URL parameters set up in a `Route` component’s `path` attribute. Say we have
    a `Route` component like this one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的 `useParams` 钩子返回一个对象，其属性对应于在 `Route` 组件的 `path` 属性中设置的 URL 参数。比如说，我们有一个像这样的
    `Route` 组件：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Its `path` attribute includes two parameters, `flavor` and `size`. Say, also,
    that a shake enthusiast visits this URL:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `path` 属性包括两个参数，`flavor` 和 `size`。比如说，一个喜欢鸡尾酒的人会访问这个网址：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'React Router will render the `Milkshake` component. When the `Milkshake` component
    calls `useParams`, the hook will return an object with properties corresponding
    to the two parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 将渲染 `Milkshake` 组件。当 `Milkshake` 组件调用 `useParams` 时，钩子将返回一个对象，其属性对应于两个参数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Milkshake` component could access the parameters by assigning them to
    local variables:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Milkshake` 组件可以通过将它们分配给局部变量来访问这些参数：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Mmmm, now I want a milkshake. It’ll have to wait; we have bookables to view.
    . . .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 嘘，现在我想要一杯奶昔。我得等一下；我们还有可预订的项目要看……
- en: The Bookables page renders one of three components. Two of them, `BookablesView`
    and `BookableEdit`, need to know which bookable they’re working with. That bookable’s
    ID is specified in the URL. Listing 10.3 shows the `BookablesView` component.
    It used to manage just the *selected* bookable with `useState`, but now fetches
    the data for *all* bookables with our `useFetch` hook from chapter 9 and manages
    the selected bookable by accessing the `id` parameter from the URL. (These changes
    will temporarily break the application.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookables` 页面渲染三个组件中的一个。其中两个组件，`BookablesView` 和 `BookableEdit`，需要知道它们正在处理哪个可预订项。该可预订项的
    ID 在 URL 中指定。列表 10.3 展示了 `BookablesView` 组件。它过去只使用 `useState` 管理所选的可预订项，但现在使用第
    9 章中的 `useFetch` 钩子获取所有可预订项的数据，并通过访问 URL 中的 `id` 参数来管理所选的可预订项。（这些更改将暂时破坏应用程序。）'
- en: 'Branch: 1001-bookables-routes, File: /src/components/Bookables/BookablesView.js'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1001-bookables-routes，文件：/src/components/Bookables/BookablesView.js
- en: Listing 10.3 `BookablesView` accessing ID from the URL
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.3 `BookablesView` 从 URL 获取 ID
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Import the useParams hook.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 `useParams` 钩子。
- en: ❷ Import our useFetch custom hook.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入我们自定义的 `useFetch` 钩子。
- en: ❸ Retrieve the bookables with useFetch.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `useFetch` 获取可预订项。
- en: ❹ Assign the ID parameter value to a local variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 ID 参数值分配给本地变量。
- en: ❺ Use the ID to get the specified bookable.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 ID 获取指定的可预订项。
- en: ❻ Provide a function to generate URLs for bookables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 提供一个生成可预订项 URL 的函数。
- en: ❼ Include a link to the form for creating new bookables.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在表单中包含创建新可预订项的链接。
- en: 'The `BookablesView` component calls React Router’s `useParams` custom hook
    to get an object with all the parameters set in the URL. It uses object destructuring
    to assign the `id` parameter to a local variable with the same name:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView` 组件调用 React Router 的 `useParams` 钩子来获取一个包含 URL 中设置的所有参数的对象。它使用对象解构将
    `id` 参数分配给具有相同名称的本地变量：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The parameters are returned as strings, but each bookable’s `id` property is
    a number, so `parseInt` is used when finding the specified bookable in the collection
    of all bookables:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 参数作为字符串返回，但每个可预订项的 `id` 属性是数字，因此在查找所有可预订项集合中指定的可预订项时使用 `parseInt`：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the bookable can’t be found, the first bookable in the collection, `bookables[0]`,
    is selected instead. Once the bookables have loaded, and assuming there are no
    errors, `BookablesView` renders the `BookablesList` and `BookableDetails` components.
    It passes `BookablesList` a function for generating URLs for each bookable. Let’s
    see how that function is used and introduce a second React Router custom hook,
    `useNavigate`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到可预订项，则选择集合中的第一个可预订项，即 `bookables[0]`。一旦可预订项加载完成，并且假设没有错误，`BookablesView`
    将渲染 `BookablesList` 和 `BookableDetails` 组件。它将用于生成每个可预订项 URL 的函数传递给 `BookablesList`。让我们看看这个函数是如何使用的，并介绍第二个
    React Router 自定义钩子 `useNavigate`。
- en: 10.1.4 Navigating with the useNavigate hook
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4 使用 `useNavigate` 钩子进行导航
- en: 'React Router’s `useNavigate` hook returns a function we can use to set a new
    URL, prompting the router to render whichever UI has been associated with the
    new path. (Remember, we’re using the beta version of React Router 6, so it’s possible
    the API may change. If that happens, I’ll add some extra, updated listings to
    the GitHub repo.) Say an app is currently showing a `Milkshake` component. (Sorry,
    I just can’t get them out of my head. So . . . creamy . . .) Say, also, that the
    user is a neuralgia-phobe and prefers bubble tea. To provide a way to navigate
    from the milkshake page to the bubble tea page, the `Milkshake` component could
    do this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 的 `useNavigate` 钩子返回一个函数，我们可以使用它来设置一个新的 URL，提示路由器渲染与新的路径相关联的任何
    UI。（记住，我们正在使用 React Router 6 的测试版，因此 API 可能会发生变化。如果发生这种情况，我将在 GitHub 仓库中添加一些额外的更新列表。）假设一个应用当前显示的是
    `Milkshake` 组件。（抱歉，我实在无法将这些从我的脑海中排除出去。所以……奶油……）假设，用户是一个神经痛恐惧者，更喜欢珍珠奶茶。为了提供一个从奶昔页面导航到珍珠奶茶页面的方式，`Milkshake`
    组件可以这样做：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Assign a URL-setting function to the navigate variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 URL 设置函数分配给 `navigate` 变量。
- en: ❷ Use the function to set a new URL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用该函数设置一个新的 URL。
- en: Assigning the URL-setting function to the local `navigate` variable gives the
    component a way to set the URL, in event handlers, for example. It could also
    render some links that point to the new URLs. Let’s use both approaches in the
    bookings app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将 URL 设置函数分配给本地 `navigate` 变量，给组件提供了一个在事件处理程序中设置 URL 的方法。它也可以渲染一些指向新 URL 的链接。让我们在预订应用中使用这两种方法。
- en: 'In the `BookablesView` component, rather than getting the selected bookable
    and its updater function with a call to `useState`, we now specify the selection
    in the URL. Here’s the URL for the bookable with an ID of 1:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BookablesView` 组件中，我们不再通过调用 `useState` 来获取选定的可预订项及其更新函数，而是现在在 URL 中指定选择项。以下是具有
    ID 为 1 的可预订项的 URL：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To switch to a new bookable, we set a new URL:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到新的可预订项，我们设置一个新的 URL：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To update the state, we either need a link that points to a new URL or a function
    that navigates to the new URL (fired by the Next button, for example):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新状态，我们需要一个指向新 URL 的链接或一个导航到新 URL 的函数（例如，由下一个按钮触发）：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Use React Router’s Link component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 React Router 的 Link 组件。
- en: ❷ Use the function that React Router’s useNavigate hook returns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 React Router 的 useNavigate 钩子返回的函数。
- en: Figure 10.3 shows the app after a user has navigated to `/bookables/1`. The
    `BookablesList` component on the left shows the group selector, the list of bookable
    links in the current group, and the Next button. The `BookablesView` component
    also renders a New button outside `BookablesList`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 显示了用户导航到 `/bookables/1` 后的应用程序。左侧的 `BookablesList` 组件显示了组选择器、当前组中的可预订项链接列表和下一个按钮。`BookablesView`
    组件还渲染了一个位于 `BookablesList` 外部的“新建”按钮。
- en: '![](../Images/10-3.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-3.png)'
- en: Figure 10.3 The `BookablesView` component displays the New button and each bookable
    as links that lead to a new URL. The Next button and the group selector change
    the URL by calling a function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 `BookablesView` 组件显示“新建”按钮和每个可预订项作为链接，这些链接指向新的 URL。通过调用函数，下一个按钮和组选择器会更改
    URL。
- en: The bookable links and the New button are rendered using `Link` components,
    and the group drop-down and Next buttons navigate within event handlers. Table
    10.2 lists the elements and how they function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订项链接和“新建”按钮使用 `Link` 组件渲染，组下拉菜单和下一个按钮在事件处理程序中导航。表 10.2 列出了元素及其功能。
- en: Table 10.2 Elements and components used in navigation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2 导航中使用的元素和组件
- en: '| Element/component | Text | Action |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 元素/组件 | 文本 | 操作 |'
- en: '| `select` | e.g., `Rooms` | Call navigate function |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 例如，`房间` | 调用导航函数 |'
- en: '| `Link` | `Meeting Room` | Set link to `/bookables/1` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Link` | `会议室` | 设置链接到 `/bookables/1` |'
- en: '| `Link` | `Lecture Hall` | Set link to `/bookables/2` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Link` | `讲堂` | 设置链接到 `/bookables/2` |'
- en: '| `Link` | `Games Room` | Set link to `/bookables/3` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Link` | `游戏室` | 设置链接到 `/bookables/3` |'
- en: '| `Link` | `Lounge` | Set link to `/bookables/4` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Link` | `休息室` | 设置链接到 `/bookables/4` |'
- en: '| `button` | `Next` | Call navigate function |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `button` | `下一个` | 调用导航函数 |'
- en: '| `Link` | `New` | Set link to `/bookables/new` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Link` | `新建` | 设置链接到 `/bookables/new` |'
- en: Listing 10.4 shows the `BookablesList` component using both approaches. The
    `BookablesList` component is used on different pages (the Bookables page and the
    Bookings page) that use different structures for their URLs. The component needs
    to know how to generate the URL from a bookable ID, so its parent component has
    to pass it a function, `getUrl`, for that purpose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 展示了 `BookablesList` 组件使用两种导航方法。`BookablesList` 组件用于不同的页面（可预订页面和预订页面），它们使用不同的
    URL 结构。该组件需要知道如何从可预订项 ID 生成 URL，因此其父组件必须传递一个 `getUrl` 函数用于此目的。
- en: 'Branch: 1001-bookables-routes, File: /src/components/Bookables/BookablesList.js'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1001-bookables-routes，文件：/src/components/Bookables/BookablesList.js
- en: Listing 10.4 `BookablesList` using two approaches for navigation
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 使用两种导航方法的 `BookablesList`
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Import the useNavigate hook.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useNavigate 钩子。
- en: ❷ Accept the current bookable, list of bookables, and getUrl function as props.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 接受当前的可预订项、可预订项列表和 getUrl 函数作为 props。
- en: ❸ Call the useNavigate hook, assigning the navigation function to a variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 useNavigate 钩子，将导航函数分配给一个变量。
- en: ❹ Navigate to the URL for the first bookable in the new group.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 导航到新组中第一个可预订项的 URL。
- en: ❺ Navigate to the URL for the next bookable in the current group.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 导航到当前组中下一个可预订项的 URL。
- en: ❻ Specify links with React Router’s Link component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用 React Router 的 Link 组件指定链接。
- en: ❼ Use the getUrl function to generate the URL for each link.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用 getUrl 函数生成每个链接的 URL。
- en: '(At this point, you should be able to load the Bookables page and the Users
    page but not the Bookings page.) React Router’s `useNavigate` hook returns a function
    we use to update the URL, switching to the selected bookable. Listing 10.4 assigns
    the function to a local variable called `navigate`, and the `changeGroup` and
    `nextBookable` functions call `navigate` (rather than the `setBookable` updater
    function from previous incarnations of `BookablesList`). For example, here’s the
    `changeGroup` function calling `navigate` with the URL for the first bookable
    in the newly selected group:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: （在此阶段，你应该能够加载 Bookables 页面和 Users 页面，但不能加载 Bookings 页面。）React Router 的 `useNavigate`
    钩子返回一个函数，我们使用该函数来更新 URL，切换到选定的可预订项。列表 10.4 将该函数分配给一个名为 `navigate` 的局部变量，`changeGroup`
    和 `nextBookable` 函数调用 `navigate`（而不是来自先前 `BookablesList` 版本的 `setBookable` 更新函数）。例如，以下是
    `changeGroup` 函数调用 `navigate` 并传递新选定组中第一个可预订项的 URL：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`changeGroup` uses the `getUrl` function we pass to `BookablesList` as a prop.
    On the Bookables page, the `getUrl` function looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeGroup` 使用我们传递给 `BookablesList` 的 `getUrl` 函数作为属性。在 Bookables 页面上，`getUrl`
    函数看起来像这样：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It just appends the `id` to the end of the URL. The Bookings page will use
    a different `getUrl` prop that matches that page’s use of URLs to specify state.
    It uses query strings and React Router’s `useSearchParams` hook. Let’s go there
    now:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是将 `id` 追加到 URL 的末尾。Bookings 页面将使用不同的 `getUrl` 属性，该属性与该页面使用 URL 指定状态的方式相匹配。它使用查询字符串和
    React Router 的 `useSearchParams` 钩子。现在让我们去那里：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Go to section 10.2 of this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 前往本章的 10.2 节。
- en: 10.2 Getting and setting query string search parameters
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 获取和设置查询字符串搜索参数
- en: 'In the preceding section, you saw how to use the `path` attributes for `Route`
    components to extract state values for our app. This section introduces another
    approach for storing state in the URL: *search parameters* in the *query string*.
    Here’s a URL with two search parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了如何使用 `Route` 组件的 `path` 属性来提取我们应用的状态值。本节介绍另一种在 URL 中存储状态的方法：*查询字符串*中的*搜索参数*。这是一个带有两个搜索参数的
    URL：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The query string, in bold, is at the end of the URL and starts with a question
    mark. The search parameters are `key1` and `key2`. The key-value pairs specifying
    the values for each parameter are separated by the `&` character. We can append
    further parameters if necessary, and it’s easy to include or omit them. Bear in
    mind these three points when specifying state in the URL:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串（粗体）位于 URL 的末尾，以问号开头。搜索参数是 `key1` 和 `key2`。指定每个参数值的键值对由 `&` 字符分隔。如果需要，我们可以附加更多参数，并且很容易包含或省略它们。在指定
    URL 中的状态时，请记住以下三点：
- en: Which state values you want as parameters
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望将哪些状态值作为参数
- en: How to cope with missing or invalid parameters
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理缺失或无效的参数
- en: How to update the URL when the state needs to change
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当状态需要改变时如何更新 URL
- en: Before you see how React Router lets us work with search parameters (getting
    them in section 10.2.1 and setting them in section 10.2.2), let’s briefly consider
    how the three points just listed relate to our needs for the Bookings page in
    the example app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到 React Router 如何让我们处理搜索参数（在第 10.2.1 节中获取它们，在第 10.2.2 节中设置它们）之前，让我们简要地考虑一下上面列出的三个点如何与示例应用中
    Bookings 页面的需求相关。
- en: 'On the Bookings page, to show the grid of bookings for the Meeting Room (the
    bookable with an ID of 1) for the week containing June 24, 2020 (specified as
    2020-06-24), we want to navigate to the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bookings 页面上，为了显示包含 2020 年 6 月 24 日（指定为 2020-06-24）的周会议室的预订网格（ID 为 1 的可预订项），我们希望导航到以下位置：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, our search parameters in the URL are `date` and `bookableId`. Figure 10.4
    shows the Bookings page for that URL with the specified bookable highlighted on
    the left and the specified date present in the bookings grid.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们 URL 中的搜索参数是 `date` 和 `bookableId`。图 10.4 展示了该 URL 的 Bookings 页面，左侧突出显示了指定的可预订项，并在预订网格中显示了指定的日期。
- en: '![](../Images/10-4.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-4.png)'
- en: Figure 10.4 The Bookings page using key-value pairs in the URL to specify bookable
    and date
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 使用 URL 中的键值对指定可预订项和日期的 Bookings 页面
- en: But the URL a user enters might not include the date or the bookable ID, so
    we need to either throw or report an error when parameters are missing or use
    sensible default values. We’ll use the state value policy set out in table 10.3.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但用户输入的 URL 可能不包括日期或可预订项 ID，因此我们需要在参数缺失或使用合理的默认值时抛出或报告错误。我们将使用表 10.3 中概述的状态值策略。
- en: Table 10.3 The state value policy for different URLs
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.3 不同 URL 的状态值策略
- en: '| URL | State |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| URL | 状态 |'
- en: '| `/bookings?bookableId=1&date=2020-06-24` | Use the specified date and bookable.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `/bookings?bookableId=1&date=2020-06-24` | 使用指定的日期和可预订项。|'
- en: '| `/bookings?date=2020-06-24` | Use the specified date and the first bookable.
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `/bookings?date=2020-06-24` | 使用指定的日期和第一个可预订项。|'
- en: '| `/bookings?bookableId=1` | Use today’s date and the specified bookable. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `/bookings?bookableId=1` | 使用今天的日期和指定的可预订项。|'
- en: '| `/bookings` | Use today’s date and the first bookable. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `/bookings` | 使用今天的日期和第一个可预订项。|'
- en: As with any user-entered state, we need to make sure it’s valid. The `date`
    parameter must be a date, and the `bookableId` must be an integer. We’ll treat
    invalid values as missing values and follow the policy set out in the table.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何用户输入的状态一样，我们需要确保它是有效的。`date`参数必须是一个日期，而`bookableId`必须是一个整数。我们将把无效值视为缺失值，并遵循表中规定的政策。
- en: Choosing a bookable (by clicking one in the list, switching groups, or clicking
    the Next button) or moving to a different week (by clicking one of the buttons
    in the week picker) should update the URL, to set the appropriate `date` and `bookableId`
    state values, and re-render the page.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击列表中的一个可预订项、切换组或点击“下一步”按钮来选择一个可预订项，或者通过点击周选择器中的按钮移动到不同的周，应该更新URL，以设置适当的`date`和`bookableId`状态值，并重新渲染页面。
- en: Working with the query string involves getting and setting the search parameter
    values. React Router provides the `useSearchParams` hook for both actions, and
    we explore the details of first getting and then setting in the next two subsections
    as we update the Bookings page to use state from the URL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询字符串一起工作涉及获取和设置搜索参数值。React Router提供了`useSearchParams`钩子用于这两个操作，我们将在更新Bookings页面以使用URL中的状态时，在接下来的两个小节中探讨获取和设置细节。
- en: 10.2.1 Getting search parameters from the query string
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 从查询字符串获取搜索参数
- en: 'To do its job, the `BookingsPage` component needs to know the selected bookable
    and a date in the week of bookings the user wants to see. Both of those state
    values will be in the page’s URL, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成其工作，`BookingsPage`组件需要知道用户想要查看的选定可预订项和一周中的日期。这两个状态值都将包含在页面的URL中，如下所示：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We want to access each parameter in the query string by the names in bold:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过加粗的名称访问查询字符串中的每个参数：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'How do we get access to the `searchParams` object? React Router provides the
    `useSearchParams` hook that returns an array containing an object with the `get`
    method for accessing the search parameters and a function for setting them:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取访问`searchParams`对象？React Router提供了`useSearchParams`钩子，该钩子返回一个包含一个具有`get`方法的对象数组和用于设置它们的函数：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because we no longer manage the state with `useState` and are giving users the
    ability to enter state in the URL, we need to check the validity of that state
    more carefully. Rather than accessing the parameters directly from a component,
    let’s create a custom hook to get and sanitize them before using that hook in
    the `BookingsPage` and `Bookings` components.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用`useState`管理状态，并允许用户在URL中输入状态，我们需要更仔细地检查该状态的有效性。而不是直接从组件中访问参数，让我们创建一个自定义钩子来获取和清理它们，在将此钩子用于`BookingsPage`和`Bookings`组件之前。
- en: Creating a useBookingsParams hook
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`useBookingsParams`钩子
- en: In the following listing, our new hook, `useBookingsParams`, looks for the `date`
    and `bookableId` parameters in the URL and checks to make sure `date` is a valid
    date and `bookableId` is an integer. We add the hook to the bookingsHooks.js file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们的新钩子`useBookingsParams`在URL中查找`date`和`bookableId`参数，并检查`date`是否是一个有效的日期，以及`bookableId`是否是一个整数。我们将此钩子添加到`bookingsHooks.js`文件中。
- en: 'Branch: 1002-get-querystring, File: /src/components/Bookings/bookingsHooks.js'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1002-get-querystring，文件：/src/components/Bookings/bookingsHooks.js
- en: Listing 10.5 Accessing search parameters with the `useBookingsParams` hook
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 使用`useBookingsParams`钩子访问搜索参数
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Get a searchParams object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取一个`searchParams`对象。
- en: ❷ Use the searchParams object to access the date parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用`searchParams`对象来访问日期参数。
- en: ❸ Use the searchParams object to access the bookableId parameter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用`searchParams`对象来访问`bookableId`参数。
- en: ❹ Check that the date parameter is a valid date.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查日期参数是否是一个有效的日期。
- en: ❺ Use today’s date if the date parameter is invalid.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果日期参数无效，请使用今天的日期。
- en: ❻ Try converting bookableId to an integer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 尝试将`bookableId`转换为整数。
- en: ❼ Set bookableId to undefined if it’s not an integer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果`bookableId`不是整数，则将其设置为`undefined`。
- en: 'We upgrade the `useBookingsParams` hook to *set* query string parameters in
    section 10.2.2\. For now, we don’t need to set the query string, so the hook code
    in listing 10.5 destructures only the first element from the array that `useSearchParams`
    returns:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 10.2.2 节中将 `useBookingsParams` 钩子升级为 *设置* 查询字符串参数。目前我们不需要设置查询字符串，所以列表 10.5
    中的钩子代码只解构了 `useSearchParams` 返回的数组中的第一个元素：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we have the `searchParams` object, we call its `get` method to retrieve
    the value for any parameter in the query string. To get the value for the two
    keys we’re interested in, we use the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `searchParams` 对象，我们调用它的 `get` 方法来检索查询字符串中任何参数的值。为了获取我们感兴趣的键的值，我们使用以下方法：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Having checked the validity of the two values, the new hook returns an object
    with `date` and `bookableId` properties. Components that call the hook can destructure
    the return value:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查了两个值的有效性之后，新的钩子返回一个包含 `date` 和 `bookableId` 属性的对象。调用钩子的组件可以解构返回值：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using the query parameters in the BookingsPage component
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在预订页面组件中使用查询参数
- en: For example, the `BookingsPage` component must add only that single line of
    code to access the two query string search parameters it needs, as shown in the
    following listing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`BookingsPage` 组件必须添加以下单行代码来访问它需要的两个查询字符串搜索参数，如下所示列表。
- en: 'Branch: 1002-get-querystring, File: /src/components/Bookings/BookingsPage.js'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1002-get-querystring，文件：/src/components/Bookings/BookingsPage.js
- en: Listing 10.6 `BookingsPage` accessing query string search parameters
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 `BookingsPage` 访问查询字符串搜索参数
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Import the useBookingsParams custom hook.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useBookingsParams 自定义钩子。
- en: ❷ Call useBookingsParams and destructure the object it returns.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 useBookingsParams 并解构它返回的对象。
- en: ❸ Use the bookableId parameter to find the selected bookable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 bookableId 参数查找选定的可预订项。
- en: ❹ Check the date value is defined before using it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在使用之前检查日期值是否已定义。
- en: 'If the `bookableId` value is `undefined` (it’s missing from the URL or can’t
    be parsed as an integer) or there’s no booking with that ID, we fall back to the
    first bookable in the list of bookables returned by the server:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `bookableId` 值是 `undefined`（它未出现在 URL 中或无法解析为整数）或者没有带有该 ID 的预订，我们将回退到服务器返回的可预订列表中的第一个可预订项：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you find users are confused when they specify an ID that is invalid but are
    still presented with bookings for a default bookable, you could choose to throw
    or report an error for invalid values instead.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现当用户指定一个无效的 ID 时，用户会感到困惑，但他们仍然看到了默认可预订的预订，你可以选择对无效值抛出错误或报告错误。
- en: 'The `BookingsPage` component passes a `getUrl` function to the `BookablesList`
    component (which we updated to accept such a prop in section 10.1), so the list
    can generate URLs in the correct format for the current page:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsPage` 组件将 `getUrl` 函数传递给 `BookablesList` 组件（我们在第 10.1 节中更新了该组件以接受此类属性），因此列表可以生成当前页面的正确格式的
    URL：'
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`getUrl` uses the `date` value derived from the URL search parameter, so it
    makes sure `date` is not falsy before including it in the generated URL.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUrl` 使用从 URL 搜索参数派生的 `date` 值，因此在将其包含在生成的 URL 中之前确保 `date` 不是假值。'
- en: Using the date query parameter in the Bookings component
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在预订组件中使用日期查询参数
- en: 'The `Bookings` component also uses the specified date; it generates an object
    that represents the week containing the date. It then uses the `week` object in
    three ways:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookings` 组件也使用指定的日期；它生成一个表示包含日期的周的对象。然后它以三种方式使用 `week` 对象：'
- en: It fetches the bookings for the specified week.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它获取指定周的预订。
- en: It sets the selected booking to `null` if the user switches to another week.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户切换到另一个周，它将选定的预订设置为 `null`。
- en: It passes the week object to the `BookingsGrid` component.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将周对象传递给 `BookingsGrid` 组件。
- en: The following listing shows the `Bookings` component calling the new `useBookingsParams`
    hook to get the date from the URL and highlights the week-related code in bold.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `Bookings` 组件调用新的 `useBookingsParams` 钩子以从 URL 获取日期，并突出显示与周相关的代码，加粗显示。
- en: 'Branch: 1002-get-querystring, File: /src/components/Bookings/Bookings.js'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1002-get-querystring，文件：/src/components/Bookings/Bookings.js
- en: Listing 10.7 Bookings accessing query string search parameters
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 `Bookings` 组件访问查询字符串搜索参数
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Import the useBookingsParams custom hook.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useBookingsParams 自定义钩子。
- en: ❷ Call useBookingsParams and assign the date to a local variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 useBookingsParams 并将日期分配给局部变量。
- en: ❸ Use the date to generate a week object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用日期生成一个周对象。
- en: ❹ Create a date string to use as a dependency.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个日期字符串作为依赖项。
- en: ❺ Get bookings for the specified week.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取指定周的预订。
- en: ❻ Set the currently selected booking to null if the start date changes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开始日期发生变化，将当前选定的预订设置为null。
- en: ❼ Remove props from WeekPicker.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从WeekPicker中移除props。
- en: ❽ Pass the week object to BookingsGrid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将周对象传递给BookingsGrid。
- en: If a user has selected a booking in the grid and then switches to another bookable
    or week, the effect in the listing sets the selected booking back to null. It
    uses a simple date string, `weekStart`, in the dependency list rather than the
    `Date` object assigned to `week.start`. A new `Date` object is assigned to `week.start`
    on every render and, even though the object might represent the same date, the
    effect will see it as a new object when it compares its dependency list elements.
    We don’t want the selected booking set to `null` after every render! Have a go
    at changing `weekStart` to `week.start` in the dependency list to see the problem
    for yourself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在网格中选中了一个预订，然后切换到另一个可预订项或周，列表中的效果会将选定的预订重新设置为null。它使用依赖列表中的简单日期字符串`weekStart`，而不是分配给`week.start`的`Date`对象。每次渲染都会分配一个新的`Date`对象给`week.start`，即使对象可能代表相同的日期，效果在比较其依赖列表元素时也会将其视为新对象。我们不希望在每次渲染后都将选定的预订设置为`null`！尝试将依赖列表中的`weekStart`更改为`week.start`，以亲自查看问题。
- en: The `Bookings` and `BookingsPage` components can now continue to do their jobs
    by grabbing state from the URL. If you try switching bookables or manually updating
    the URL to new dates, you should see the page load the appropriate bookings. But
    switching dates in the UI is managed by the `WeekPicker` component. It used to
    manage its state with a reducer. Let’s see how to update it to work with the query
    string when a user clicks one of its buttons.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookings`和`BookingsPage`组件现在可以通过从URL中获取状态来继续执行其工作。如果你尝试切换可预订项或手动更新URL到新日期，你应该看到页面加载适当的预订。但是，在UI中切换日期是由`WeekPicker`组件管理的。它过去使用reducer来管理其状态。让我们看看如何更新它，以便在用户点击其按钮时与查询字符串一起工作。'
- en: 10.2.2 Setting the query string
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 设置查询字符串
- en: The `WeekPicker` component lets the user move to the previous week, the next
    week, the week containing a specific date, or the week containing today’s date.
    Figure 10.5 shows the `WeekPicker` UI with its four buttons and text box.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeekPicker`组件允许用户移动到上一周、下一周、包含特定日期的那一周，或者包含今天日期的那一周。图10.5显示了带有其四个按钮和文本框的`WeekPicker`
    UI。'
- en: '![](../Images/10-5.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图10-5](../Images/10-5.png)'
- en: Figure 10.5 The `WeekPicker` component has buttons for switching to different
    weeks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 `WeekPicker`组件具有用于切换到不同周的按钮。
- en: 'The state for the currently selected date is stored in the query string. Say
    it’s 2020 and the user navigates to the Bookings page to show bookings for the
    week containing July 20\. The URL is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选定日期的状态存储在查询字符串中。比如说，是2020年，用户导航到预订页面以显示包含7月20日的周的预订。URL如下所示：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If today’s date is September 1 and the date in the week picker text box is June
    24, we want the `WeekPicker` buttons to set the URL to the values shown in table
    10.4.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果今天是9月1日，而周选择器文本框中的日期是6月24日，我们希望`WeekPicker`按钮将URL设置为表10.4中显示的值。
- en: Table 10.4 Matching URLs with buttons
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.4 按钮与URL的匹配
- en: '| Button | URL |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 按钮 | URL |'
- en: '| Prev | `/bookings?bookableId=1&date=2020-07-13` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 上一个 | `/bookings?bookableId=1&date=2020-07-13` |'
- en: '| Next | `/bookings?bookableId=1&date=2020-07-27` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 下一个 | `/bookings?bookableId=1&date=2020-07-27` |'
- en: '| Today | `/bookings?bookableId=1&date=2020-09-01` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 今天 | `/bookings?bookableId=1&date=2020-09-01` |'
- en: '| Go | `/bookings?bookableId=1&date=2020-06-24` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 前往 | `/bookings?bookableId=1&date=2020-06-24` |'
- en: 'We could convert the `WeekPicker` buttons to links that point to the URLs in
    the table. But we don’t know the date for the Go button until the user types it
    into the text box. As an alternative to links, we’ll keep all of the buttons and
    set the query string by using a function when the buttons are clicked. In section
    10.1.4, you saw how React Router’s `useNavigate` hook returns a function we use
    to set the whole URL. The `useSearchParams` hook provides a way to set just the
    query string. It returns an array whose second element is a function we can use
    for that purpose. For example, here we assign the setter function to a variable
    called `setSearchParams`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`WeekPicker`按钮转换为指向表中URL的链接。但是，我们不知道“前往”按钮的日期，直到用户将其输入到文本框中。作为链接的替代方案，我们将保留所有按钮，并在按钮被点击时使用函数设置查询字符串。在第10.1.4节中，你看到了React
    Router的`useNavigate`钩子返回一个函数，我们使用该函数来设置整个URL。`useSearchParams`钩子提供了一种仅设置查询字符串的方法。它返回一个数组，其第二个元素是一个我们可以用于此目的的函数。例如，在这里，我们将设置函数分配给一个名为`setSearchParams`的变量：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To update the URL with new search parameters in the query string, we pass `setSearchParams`
    an object with properties that will make up the parameters. For example, to produce
    this URL
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过查询字符串更新 URL 中的新搜索参数，我们传递 `setSearchParams` 一个具有将构成参数的属性的对象。例如，要生成此 URL
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'we would pass `setSearchParams` this object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递 `setSearchParams` 这个对象：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At the beginning of section 10.2.1, we created the `useBookingsParams` hook
    to get the `date` and `bookableId` parameters (with some simple validation mixed
    in for good measure). Now that we want to set the `date` parameter, we need to
    update the hook. The following listing adds a `setBookingsDate` function to the
    hook, making the new function available as a property on the object the hook returns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10.2.1 节的开始，我们创建了 `useBookingsParams` 钩子以获取 `date` 和 `bookableId` 参数（为了确保质量，其中混合了一些简单的验证）。现在我们想要设置
    `date` 参数，我们需要更新钩子。以下列表向钩子添加了一个 `setBookingsDate` 函数，使新的函数作为钩子返回的对象上的一个属性可用。
- en: 'Branch: 1003-set-querystring, File: /src/components/Bookings/bookingsHooks.js'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1003-set-querystring，文件：/src/components/Bookings/bookingsHooks.js
- en: Listing 10.8 Providing a way to set search parameters with `useBookingsParams`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 使用 `useBookingsParams` 提供设置搜索参数的方法
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Create a function to update the parameters with a new date.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个函数以更新参数为新日期。
- en: ❷ Create an empty object to hold the parameters.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个空对象来保存参数。
- en: ❸ Include parameters only for valid values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅包含有效值作为参数。
- en: ❹ Update the URL with the new parameters.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用新参数更新 URL。
- en: ❺ Include the new function in the hook’s return value.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将新函数包含在钩子的返回值中。
- en: 'The new `setBookingsDate` function creates a parameters object and adds properties
    for the specified date and existing `bookableId` value, if they’re valid. If it
    sets at least one property, the function passes the parameters object to `setSearchParams`,
    updating the URL with a query string that matches the new parameters:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `setBookingsDate` 函数创建一个参数对象，并为指定的日期和现有的 `bookableId` 值添加属性（如果它们有效）。如果它至少设置了一个属性，该函数将参数对象传递给
    `setSearchParams`，更新 URL 以匹配新参数的查询字符串：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Components that consume the search parameters will re-render, using the fresh
    values as the latest state. The `{replace: true}` option causes the browser to
    replace the current URL in its history with the new one. This will prevent each
    visited date from appearing in the browser’s history. The browser’s Back button
    won’t step back through each date selected in the `WeekPicker`. If you think it
    would be useful for your app’s users to be able to navigate back through each
    selected date, you can omit the option argument.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '消费搜索参数的组件将重新渲染，使用最新的值作为最新状态。`{replace: true}` 选项导致浏览器用新 URL 替换其历史记录中的当前 URL。这将防止每个访问的日期出现在浏览器的历史记录中。浏览器的后退按钮不会通过在
    `WeekPicker` 中选择的每个日期进行回退。如果您认为对于您的应用程序用户来说，能够通过每个选定的日期导航回退会有用，则可以省略选项参数。'
- en: Listing 10.9 shows the `WeekPicker` component calling `useBookingsParams` to
    get the `date` parameter and the setter function, `setBookingsDate`. It uses the
    setter function (that it renames `goToDate`) to update the query string when a
    user clicks one of its buttons.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 显示 `WeekPicker` 组件调用 `useBookingsParams` 以获取 `date` 参数和设置函数 `setBookingsDate`。它使用设置函数（将其重命名为
    `goToDate`）来更新查询字符串，当用户点击其按钮之一时。
- en: 'Branch: 1003-set-querystring, File: /src/components/Bookings/WeekPicker.js'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1003-set-querystring，文件：/src/components/Bookings/WeekPicker.js
- en: Listing 10.9 `WeekPicker` getting and setting search parameters
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 `WeekPicker` 获取和设置搜索参数
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Import the useBookingsParams custom hook.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useBookingsParams 自定义钩子。
- en: ❷ Call the hook to get the date and setter function.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用钩子以获取日期和设置函数
- en: ❸ Create a dates lookup for the previous, next, and today’s weeks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为前一周、下一周和今天的周创建日期查找。
- en: ❹ Call the setter function with the appropriate date.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用适当的日期调用设置函数
- en: ❺ Call the setter function with the text box date.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用文本框日期调用设置函数
- en: Both the Bookables and the Bookings pages now manage some of their state in
    the URL. The Bookables page uses separate URLs for creating and editing bookables.
    The Bookings page, however, doesn’t use separate URLs for creating and editing
    bookings. That’s because the interconnections among booking, bookable, and date
    are a little more complicated, and the user may not need to navigate directly
    to the edit form for an individual booking. If you feel it would be useful for
    users to navigate directly to the views for particular states in your app, you
    now have the tools to implement that functionality.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订项和预订页面现在都在URL中管理它们的一些状态。可预订项页面使用不同的URL来创建和编辑可预订项。然而，预订页面并没有为创建和编辑预订使用不同的URL。这是因为预订、可预订项和日期之间的相互关系稍微复杂一些，用户可能不需要直接导航到单个预订的编辑表单。如果您认为用户直接导航到应用中特定状态视图会有所帮助，您现在有工具来实现这一功能。
- en: Whatever path you take for specifying bookables, dates, and bookings, you’ll
    need to load in the relevant data. Up to now, we’ve been using our own, fairly
    naïve `useFetch` hook to get ahold of data. It’s time to up our data game with
    a couple more third-party hooks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种路径来指定可预订项、日期和预订，您都需要加载相关数据。到目前为止，我们一直在使用我们自己的、相当天真的`useFetch`钩子来获取数据。是时候通过添加更多第三方钩子来提升我们的数据处理能力了。
- en: 10.3 Streamlining data-fetching with React Query
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 使用 React Query 简化数据获取
- en: The data needs of the bookings app are pretty modest. The most data-intensive
    component is the bookings grid, and even that loads only one grid of bookings
    at a time. But we can make improvements that will make the app feel more responsive
    when the network is slow. And, if your app’s data needs increase, these kinds
    of improvements can make a big difference in your users’ perceptions of your app’s
    performance—no one wants a slew of loading spinners strewn across their screen
    after every interaction!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 预订应用的数据需求相当有限。数据最密集的组件是预订网格，但即使是它也一次只加载一个预订网格。但我们可以进行改进，使应用在网络速度慢时感觉更响应。而且，如果您的应用数据需求增加，这类改进可以在用户对应用性能的看法上产生重大影响——没有人希望在每次交互后都在屏幕上看到一串加载指示器！
- en: 'The bookings app is a single-page application—although we call our three main
    views (Bookings, Bookables, and Users) pages within the app. It uses React Router
    to display different components for different URLs. Some of those components use
    the same data; the `BookablesList` fetches all the bookables from the database
    on both the Bookings page and the Bookables page, and both the user picker and
    the Users page fetch all the users. If the Bookables page has already loaded the
    bookables, we shouldn’t need to wait for them to load again when switching to
    the Bookings page. This section introduces React Query and makes use of its `useQuery`
    and `useMutation` hooks. There are four subsections:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 预订应用是一个单页应用——尽管我们称我们的三个主要视图（预订、可预订项和用户）为应用内的页面。它使用 React Router 来显示不同URL的不同组件。其中一些组件使用相同的数据；`BookablesList`在预订页面和可预订项页面都从数据库中获取所有可预订项，用户选择器和用户页面都获取所有用户。如果可预订项页面已经加载了可预订项，那么在切换到预订页面时，我们就不需要等待它们再次加载。本节介绍了
    React Query 并使用其`useQuery`和`useMutation`钩子。有四个子节：
- en: '*Introducing React Query*—What is it? Why is it helpful? Where do we get it?'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍 React Query*——它是什么？为什么它有帮助？我们从哪里获取它？'
- en: '*Giving components access to a React Query client*—Creating a client instance
    and setting it as a prop on a provider component that wraps the component tree.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使组件能够访问 React Query 客户端*——创建客户端实例并将其设置为包裹组件树的提供者组件的属性。'
- en: '*Fetching data with* `useQuery`—Defining queries, specifying query keys, and
    using status and error properties. Background re-fetching and request deduping.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`useQuery`获取数据*——定义查询、指定查询键，并使用状态和错误属性。后台重新获取和请求去重。'
- en: '*Updating server state with* `useMutation`—Defining mutations, taking action
    when mutations are complete, and working with the query cache.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`useMutation`更新服务器状态*——定义突变、在突变完成后采取行动，以及与查询缓存一起工作。'
- en: 10.3.1 Introducing React Query
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 介绍 React Query
- en: '*React Query* is a library for managing server state from your React apps.
    It has defaults that produce great results with no configuration. Figure 10.6
    shows the home page for the React Query website, [https://react-query.tanstack.com/](https://react-query.tanstack.com/),
    where you can find docs, examples, and links to further learning resources. (React
    Query’s author, Tanner Linsley, has created open source React packages to help
    with forms, tables, charts, and more. Check out his GitHub pages at [https://github.com/tannerlinsley](https://github.com/tannerlinsley).)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*React Query* 是一个用于管理 React 应用程序中服务器状态的库。它具有默认设置，无需配置即可产生出色的结果。图 10.6 显示了 React
    Query 网站的首页，[https://react-query.tanstack.com/](https://react-query.tanstack.com/)，在那里您可以找到文档、示例以及进一步学习资源的链接。（React
    Query 的作者，Tanner Linsley，创建了开源的 React 包，以帮助处理表单、表格、图表等。查看他的 GitHub 页面 [https://github.com/tannerlinsley](https://github.com/tannerlinsley)。）'
- en: '![](../Images/10-6.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-6.png)'
- en: 'Figure 10.6 The web page for React Query: Performant and powerful data synchronization
    for React'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 React Query 的网页：为 React 提供高性能和强大的数据同步
- en: 'React Query’s docs list some of the ways it can improve on our own `useFetch`
    hook. They include the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 的文档列出了一些它可以改进我们自己的 `useFetch` 钩子的方式。包括以下内容：
- en: Caching
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Deduping multiple requests for the same data into a single request
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对同一数据的多个请求去重为单个请求
- en: Updating out-of-date data in the background
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台更新过时的数据
- en: Knowing when data is out of date
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数据何时过时
- en: Reflecting updates to data as quickly as possible
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快反映数据更新
- en: 'Switching from our `useFetch` to React Query’s `useQuery` is simple. First,
    we need to get ahold of the React Query package. You can use the npm package manager
    to install it, like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `useFetch` 切换到 React Query 的 `useQuery` 是简单的。首先，我们需要掌握 React Query 包。您可以使用
    npm 包管理器来安装它，如下所示：
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For the bookings app, React Query will provide caching, merging of multiple
    requests, background fetching to get the latest data, and useful status codes
    and flags for keeping users informed. If you need them, it has a whole host of
    configuration options to help you create powerful but streamlined data-driven
    applications. But why do we need something like React Query for our bookings app?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预订应用程序，React Query 将提供缓存、合并多个请求、后台获取最新数据以及用于让用户了解的有用状态码和标志。如果您需要，它有一系列配置选项，可以帮助您创建强大但精简的数据驱动应用程序。但为什么我们需要像
    React Query 这样的东西来为我们的预订应用程序服务？
- en: 'If you haven’t been running `json-server` with a delay, you may not have noticed
    any issues. Switching from page to page and bookable to bookable is swift and
    snappy—what a great application! But try adding in that delay; restart `json-server`
    like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有延迟运行 `json-server`，你可能没有注意到任何问题。从一页切换到另一页，从可预订切换到可预订，都是迅速而敏捷的——多么棒的应用！但尝试添加那个延迟；像这样重新启动
    `json-server`：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the delay, when we click the link for the Bookables page, we get the loading
    indicator shown in figure 10.7.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟的情况下，当我们点击可预订页面的链接时，我们会得到图 10.7 中所示的加载指示器。
- en: '![](../Images/10-7.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-7.png)'
- en: Figure 10.7 When navigating to the Bookables page, we get a loading indicator
    as the bookables data loads.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 当导航到可预订页面时，随着可预订数据的加载，我们会得到一个加载指示器。
- en: 'After three seconds, the bookables have loaded, and the expected display appears
    with the `BookablesList` and `BookableDetails` components. If the network is slow,
    there’s no problem having a loading indicator; we just need to be patient. But,
    if from the Bookables page we navigate to the Bookings page, we get the loading
    indicator again as the Bookings page reloads the bookables. In fact, every page
    reloads existing data. Here’s a list of some of the ways the three main types
    of data are reloaded following user interactions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 三秒后，可预订内容已加载，预期的显示出现了 `BookablesList` 和 `BookableDetails` 组件。如果网络速度慢，有一个加载指示器没有问题；我们只需要耐心等待。但是，如果我们从可预订页面导航到预订页面，我们会再次得到加载指示器，因为预订页面正在重新加载可预订内容。实际上，每个页面都会在用户交互后重新加载现有数据。以下是一些用户交互后三种主要数据类型重新加载的方式列表：
- en: '*Bookables*—Both the Bookings page and the Bookables page fetch the full list
    of bookables.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可预订内容*——预订页面和可预订页面都会获取完整的可预订内容列表。'
- en: '*Bookings*—The `Bookings` and `BookingsGrid` components load the same list
    of bookings. On the Bookings page, switching from one bookable to another and
    then back again reloads the bookings for the first bookable, and switching from
    one week to the next and back again reloads the bookings for the first week.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预订*—`Bookings` 和 `BookingsGrid` 组件加载相同的预订列表。在预订页面上，从一本书切换到另一本书然后再切换回来会重新加载第一本书的预订，而从一周切换到下一周然后再切换回来会重新加载第一周的预订。'
- en: '*Users*—Even after the `UserPicker` component has loaded the list of users,
    switching to the Users page will load them again.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户*—即使 `UserPicker` 组件已经加载了用户列表，切换到用户页面也会再次加载它们。'
- en: To prevent this data-fetching duplication, should we move all the data-fetching
    code into a central store and access that single source from the components that
    need it? With React Query, we don’t need to do any of the work involved in creating
    such a store. It lets us keep the data-fetching code in the components that need
    the data, but behind the scenes it manages a data cache, passing already-fetched
    data to components when they ask for them. Let’s see how to give our components
    access to that cache.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种数据获取重复，我们应该将所有数据获取代码移动到一个中央存储中，并从需要它的组件中访问这个单一来源吗？使用 React Query，我们不需要做创建此类存储所涉及的所有工作。它让我们将数据获取代码保留在需要数据的组件中，但在幕后它管理数据缓存，当组件请求时传递已获取的数据。让我们看看如何让我们的组件访问这个缓存。
- en: 10.3.2 Giving components access to a React Query client
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 通过 React Query 客户端给组件提供访问权限
- en: For components to access a shared React Query cache, we make the cache available
    by wrapping our app JSX in a provider component. React Query uses a *client* object
    to hold the cache and configuration and to provide further functionality. The
    following listing shows how to create a client and pass it to the provider component
    that wraps the app’s component tree.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让组件访问共享的 React Query 缓存，我们通过将我们的应用 JSX 包裹在提供者组件中来提供缓存。React Query 使用 *客户端*
    对象来持有缓存和配置，并提供进一步的功能。以下列表显示了如何创建客户端并将其传递给包裹应用组件树的提供者组件。
- en: 'Branch: 1004-use-query, File: /src/components/App.js'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1004-use-query，文件：/src/components/App.js
- en: Listing 10.10 Wrapping the app in a `QueryClientProvider` component
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10 将应用包裹在 `QueryClientProvider` 组件中
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Import the client constructor and provider component from React Query.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 React Query 导入客户端构造函数和提供者组件。
- en: ❷ Create a client instance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建客户端实例。
- en: ❸ Wrap the app in the provider, setting the client as a prop.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将应用包裹在提供者中，设置客户端作为属性。
- en: Wrapping the component tree in the provider makes the client object available
    to React Query’s hooks when we call the hooks from descendant components. Let’s
    start by fetching data with the `useQuery` hook.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件树包裹在提供者中，使得当我们在子组件中调用钩子时，客户端对象对 React Query 的钩子可用。让我们从使用 `useQuery` 钩子获取数据开始。
- en: 10.3.3 Fetching data with useQuery
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 使用 useQuery 获取数据
- en: Our own `useFetch` custom hook is a simple solution to data fetching that works
    well when network speeds are fast but shows its limitations when latency is introduced.
    To create apps that consistently feel responsive and avoid unnecessary loading
    states, we want a way for components to fetch data from the server that doesn’t
    make us wait for previously fetched data. React Query will manage caching for
    us and provides the `useQuery` hook for fetching data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的 `useFetch` 自定义钩子是一个简单的数据获取解决方案，在网络速度快时效果很好，但当引入延迟时显示出其局限性。为了创建始终感觉响应的应用程序并避免不必要的加载状态，我们希望组件能够从服务器获取数据，而无需等待之前获取的数据。React
    Query 将为我们管理缓存并提供 `useQuery` 钩子用于获取数据。
- en: 'React Query’s `useQuery` hook is similar to our own `useFetch` hook in that
    it returns an object with properties for the data, status, and error object. But
    where we passed `useFetch` a URL, we pass `useQuery` a key and an asynchronous
    function that returns the data:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 的 `useQuery` 钩子与我们的 `useFetch` 钩子类似，因为它返回一个包含数据、状态和错误对象的属性对象。但与我们传递给
    `useFetch` 的 URL 不同，我们传递给 `useQuery` 的是一个键和一个异步函数，该函数返回数据：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`useQuery` uses the key to identify the data in its cache; it can return the
    data corresponding to existing keys straightaway and then fetch the latest data
    from the server in the background. The key can be a string or a more complicated
    array or object that can be serialized.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`useQuery` 使用键来识别其缓存中的数据；它可以立即返回对应现有键的数据，然后在后台从服务器获取最新数据。键可以是一个字符串，也可以是一个更复杂的数组或对象，它可以被序列化。'
- en: Using a string as the query key
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串作为查询键
- en: 'The simplest key we can pass to `useQuery` is a primitive value like a string.
    For example, in the bookings app, we can fetch the list of bookables like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `useQuery` 传递的最简单的键是像字符串这样的原始值。例如，在预订应用中，我们可以这样获取 bookables 列表：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Specify a key for the query.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为查询指定一个键。
- en: ❷ Provide an asynchronous data-fetching function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供一个异步数据获取函数。
- en: We use the string `"bookables"` as the key. Whenever any component subsequently
    calls `useQuery` with `"bookables"` as the key, React Query will return the previously
    fetched bookables data from its cache and then fetch the latest data in the background.
    That behavior makes the UI seem super-responsive. You’ll be able to see the behavior
    in action after we update both `BookablesView` and `BookingsPage` to call `useQuery`
    rather than `useFetch` to retrieve the list of bookables from the server. The
    following listing updates the `BookablesView` component first.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字符串 `"bookables"` 作为键。每当任何组件随后调用 `useQuery` 并将 `"bookables"` 作为键时，React
    Query 将从其缓存中返回之前获取的 bookables 数据，然后在后台获取最新数据。这种行为使得 UI 看起来超级响应。在我们更新 `BookablesView`
    和 `BookingsPage` 以调用 `useQuery` 而不是 `useFetch` 来从服务器获取 bookables 列表之后，你将能够看到这种行为。以下列表首先更新
    `BookablesView` 组件。
- en: 'Branch: 1004-use-query, File: /src/components/Bookables/BookablesView.js'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1004-use-query，文件：/src/components/Bookables/BookablesView.js
- en: Listing 10.11 `BookablesView` with `useQuery`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 使用 `useQuery` 的 `BookablesView`
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Import the useQuery hook.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useQuery 钩子。
- en: ❷ Import our data-fetching utility function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入我们的数据获取实用函数。
- en: ❸ Call the useQuery hook.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 useQuery 钩子。
- en: ❹ Specify a key for the query.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为查询指定一个键。
- en: ❺ Provide an asynchronous data-fetching function.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 提供一个异步数据获取函数。
- en: The only change to `BookablesView` in listing 10.11 is the switch from `useFetch`
    to `useQuery`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 中对 `BookablesView` 的唯一更改是从 `useFetch` 切换到 `useQuery`。
- en: Challenge 10.1
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 10.1
- en: This is an easy one! Change the `BookingsPage` component so that it calls `useQuery`
    to load the bookables. Use `bookables` as the query key. This change has already
    been made on the 1004-use-query branch.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子！将 `BookingsPage` 组件修改为调用 `useQuery` 来加载 bookables。使用 `bookables` 作为查询键。此更改已在
    1004-use-query 分支上完成。
- en: 'Because the Bookables page and the Bookings page use the same query key, whichever
    is loaded second will be able to grab the bookables data from the cache. With
    `BookablesView` and `BookingsPage` both calling `useQuery` with the same key,
    to see the cache in action, follow these steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Bookables 页面和 Bookings 页面使用相同的查询键，无论哪个先加载，都将能够从缓存中获取 bookables 数据。当 `BookablesView`
    和 `BookingsPage` 都使用相同的键调用 `useQuery` 时，要查看缓存的作用，请按照以下步骤操作：
- en: Start `json-server` with a delay of two or three seconds.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以两到三秒的延迟启动 `json-server`。
- en: Navigate to the Bookables page at /bookables. You should see the page-level
    loading spinner and then the list of bookables with the first bookable selected.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 /bookables 下的 Bookables 页面。你应该会看到页面级加载指示器，然后是带有第一个可预订项的 bookables 列表。
- en: Click the Bookings link at the top left of the page. The Bookings page will
    be rendered straightaway, without a page-level loading spinner. React Query has
    used the bookables data from its cache.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左上角的“Bookings”链接。Bookings 页面将立即渲染，无需页面级加载指示器。React Query 已使用其缓存中的 bookables
    数据。
- en: Click the Bookables link at the top left of the page. The Bookables page will
    be rendered straightaway. Again, React Query provides the bookables data from
    its cache.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面左上角的“Bookables”链接。Bookables 页面将立即渲染。同样，React Query 会从其缓存中提供 bookables 数据。
- en: Because the Bookings page and the Bookables page use the same query key, `bookables`,
    when calling the `useQuery` hook, React Query knows to return the existing data
    for that key immediately. It re-fetches the data in the background and re-renders
    the component when the latest data arrives. The `useQuery` hook accepts more-complicated
    keys. For example, the `Bookings` and `BookingsGrid` components fetch bookings
    data dependent on a number of variables. Let’s see how to fold multiple variables
    into the query key we pass to `useQuery`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Bookings 页面和 Bookables 页面使用相同的查询键 `bookables`，在调用 `useQuery` 钩子时，React Query
    会立即返回该键的现有数据。当最新数据到达时，它会在后台重新获取数据并重新渲染组件。`useQuery` 钩子可以接受更复杂的键。例如，`Bookings`
    和 `BookingsGrid` 组件根据多个变量获取预订数据。让我们看看如何将多个变量折叠到传递给 `useQuery` 的查询键中。
- en: Using an array as the query key
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组作为查询键
- en: 'The Bookings page fetches booking data for a bookable between a start date
    and an end date. React Query needs to be able to track cached data for each combination
    of bookable, start date, and end date, so, when fetching bookings, we specify
    the query key as an array like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 预订页面在开始日期和结束日期之间获取可预订项的预订数据。React Query 需要能够跟踪每个可预订项、开始日期和结束日期组合的缓存数据，因此，在获取预订时，我们指定查询键为一个数组，如下所示：
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we specify a key that has previously been used (say, by clicking a bookable),
    then a second bookable, and then back to the first bookable, React Query can return
    data from the cache that matches the key.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了一个之前已经使用过的键（比如点击一个可预订项），然后是第二个可预订项，然后又回到第一个可预订项，React Query 可以从缓存中返回与该键匹配的数据。
- en: The following listing shows the updated `useBookings` custom hook that `Bookings`
    and `BookingsGrid` use to fetch bookings.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `Bookings` 和 `BookingsGrid` 使用来获取预订的更新后的 `useBookings` 自定义钩子。
- en: 'Branch: 1004-use-query, File: /src/components/Bookings/bookingsHooks.js'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1004-use-query，文件：/src/components/Bookings/bookingsHooks.js
- en: Listing 10.12 `useBookings` calling `useQuery`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 `useBookings` 调用 `useQuery`
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Call the useQuery hook.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 useQuery 钩子。
- en: ❷ Specify an array as the query key.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将数组指定为查询键。
- en: ❸ Provide an asynchronous data-fetching function.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提供一个异步的数据获取函数。
- en: The `Bookings` and `BookingsGrid` components call `useBookings` with the same
    arguments, resulting in equal keys. Now that we’ve switched to calling `useQuery`
    instead of `useFetch`, React Query sees that the keys are equal and merges the
    duplicate requests into one.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookings` 和 `BookingsGrid` 组件使用相同的参数调用 `useBookings`，导致键相等。现在我们已经切换到调用 `useQuery`
    而不是 `useFetch`，React Query 会看到键相等并将重复的请求合并为一个。'
- en: Navigate to the Bookings page and have a go at switching from one bookable to
    another and back again or from one week to another and back again. Because the
    query cache already contains the requested data, switching back to a previously
    selected bookable or week should instantly render the bookings for that selection.
    Such UI snappiness leads to user happiness!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到预订页面，尝试在可预订项之间或在一周与另一周之间切换，然后再切回来。因为查询缓存已经包含了请求的数据，所以切换回之前选定的可预订项或周应该会立即渲染该选择的预订。这种用户界面的流畅性会导致用户满意度提升！
- en: Challenge 10.2
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 10.2
- en: The `UserPicker` and `UsersList` components both fetch the list of users from
    the database. Update their code to call `useQuery` instead of `useFetch`. Test
    the change by navigating to the Bookables page and then clicking the Users link.
    The Users page on the 1005-query-users branch should render immediately, without
    a loading spinner.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserPicker` 和 `UsersList` 组件都从数据库中获取用户列表。更新它们的代码以调用 `useQuery` 而不是 `useFetch`。通过导航到可预订页面然后点击用户链接来测试这个更改。在
    1005-query-users 分支上的用户页面应该立即渲染，没有加载指示器。'
- en: 10.3.4 Accessing data in the query cache
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 查询缓存中的数据访问
- en: The Bookables page now fetches the full list of bookables by calling the `useQuery`
    hook with a query key of `bookables`. For a period of time, React Query associates
    the key with the bookables data in its cache (check the docs for details on how
    and when the cached data is marked as stale). React Query makes the cache available
    should you want to access the fetched data directly or manipulate it in some way.
    In section 10.3.4, we update the cache when mutating the server state. In this
    section, we access the cache to improve the responsiveness of the Edit Bookable
    form.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可预订页面现在通过调用 `useQuery` 钩子并使用查询键 `bookables` 来获取可预订项的完整列表。在一段时间内，React Query
    将该键与其缓存中的可预订项数据关联起来（请查阅文档以了解有关如何以及何时将缓存数据标记为过时的详细信息）。如果需要直接访问获取的数据或以某种方式操作它，React
    Query 会使缓存可用。在 10.3.4 节中，我们更新缓存以突变服务器状态。在本节中，我们访问缓存以提高编辑可预订表单的响应性。
- en: 'In section 10.1, we used React Router to set up nested routes on the Bookables
    page. The routes let users view bookables, create new bookables, and edit existing
    bookables. To edit the bookable with an ID of 3, the user navigates to /bookables/3/edit.
    There are two ways of navigating:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在 10.1 节中，我们使用 React Router 在可预订页面设置嵌套路由。这些路由允许用户查看可预订项、创建新的可预订项以及编辑现有的可预订项。要编辑
    ID 为 3 的可预订项，用户需要导航到 /bookables/3/edit。有两种导航方式：
- en: On the Bookables page, select a bookable and click the Edit button.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可预订页面，选择一个可预订项并点击编辑按钮。
- en: Enter the URL directly in the browser’s address bar.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接在浏览器地址栏中输入 URL。
- en: Both options display the `BookableEdit` component, with the details of the specified
    bookable filled in and Delete, Cancel, and Save buttons, as shown in figure 10.8\.
    The second option will need to load the bookable data from the server, showing
    a loading spinner while the bookable loads. But for the first option, the Bookables
    page will already have loaded the full list of bookables. Can the form just grab
    the existing data from the cache, avoiding the loading spinner?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 两种选项都显示了 `BookableEdit` 组件，其中填充了指定可预订项的详细信息以及删除、取消和保存按钮，如图 10.8 所示。第二种选项将需要从服务器加载可预订项数据，在可预订项加载时显示加载指示器。但第一种选项，可预订项页面已经加载了可预订项的完整列表。表单能否直接从缓存中获取现有数据，从而避免加载指示器？
- en: '![](../Images/10-8.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-8.png)'
- en: Figure 10.8 The Edit Bookable form is populated with data from the selected
    bookable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 编辑可预订项表单填充了所选可预订项的数据。
- en: 'React Query makes the cache available to components via the client object that
    we assigned to the provider in section 10.3.2\. Call React Query’s `useQueryClient`
    hook to get ahold of the client object:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 通过我们分配给 10.3.2 节中提供者的客户端对象使缓存对组件可用。调用 React Query 的 `useQueryClient`
    钩子以获取客户端对象：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use the associated query key and the `getQueryData` method to access
    already-fetched data. For example, to get the list of bookables in the cache:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相关的查询键和 `getQueryData` 方法来访问已获取的数据。例如，要获取缓存中的可预订项列表：
- en: '[PRE51]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we want a bookable with a specified ID, we call the `find` array method,
    like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个具有指定 ID 的可预订项，我们调用 `find` 数组方法，如下所示：
- en: '[PRE52]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, we can retrieve a particular booking from the cache, but how do we tell
    `useQuery` to return the existing booking rather than fetching it from the server?
    The following listing shows the `BookableEdit` component calling `useQuery` with
    a third argument, a config object that includes an `initialData` property. We
    discuss it after the listing.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从缓存中检索特定的预订，但如何告诉 `useQuery` 返回现有的预订而不是从服务器获取它？以下列表显示了 `BookableEdit`
    组件调用 `useQuery` 并带有第三个参数，一个包含 `initialData` 属性的配置对象。我们将在列表之后讨论它。
- en: 'Branch: 1006-query-cache, File: /src/components/Bookables/BookableEdit.js'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1006-query-cache，文件：/src/components/Bookables/BookableEdit.js
- en: Listing 10.13 The `BookableEdit` component accessing the cache
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 `BookableEdit` 组件访问缓存
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Import the useQueryClient hook.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useQueryClient 钩子。
- en: ❷ Call the hook and assign the client to a variable.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用钩子并将客户端分配给一个变量。
- en: ❸ Assign the initial data and subsequent fetched data to the data variable.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将初始数据和后续获取的数据分配给数据变量。
- en: ❹ Use the initialData property to assign an initial value to data.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 initialData 属性为数据分配一个初始值。
- en: ❺ Use a key to get specific data from the cache.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用键从缓存中获取特定数据。
- en: ❻ Find the bookable for the specified ID.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 查找指定 ID 的可预订项。
- en: ❼ Set the bookable data as the state for the form.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将可预订项数据设置为表单的状态。
- en: ❽ Use the isLoading Boolean returned by useQuery.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用由 useQuery 返回的 isLoading 布尔值。
- en: 'React Query’s `useQuery` hook accepts a config object as a third argument:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 的 `useQuery` 钩子接受一个配置对象作为第三个参数：
- en: '[PRE54]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The config lets the calling code control all kinds of query-related functionality,
    such as cache expiry, retry policies when fetching-errors occur, callback functions,
    whether to work with `Suspense` and error boundaries (see chapter 11), and the
    setting of initial data. `BookableEdit` sets the `initialData` config property
    so that, when first called, and if the initial data exists, `useQuery` won’t bother
    fetching the data from the server:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 配置允许调用代码控制各种查询相关功能，例如缓存过期、在发生获取错误时的重试策略、回调函数、是否与 `Suspense` 和错误边界（见第 11 章）一起工作，以及设置初始数据。`BookableEdit`
    设置 `initialData` 配置属性，以便在首次调用时，如果存在初始数据，`useQuery` 就不会麻烦从服务器获取数据：
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the initial data is undefined (when a user loads the bookings app by navigating
    directly to the Edit Bookable form, for example) or on subsequent renders, `useQuery`
    will go ahead and fetch the data. `useQuery` sets properties on the object it
    returns, including Booleans for different status values. Just as an example, the
    `BookableEdit` component uses the `isLoading` Boolean to check for `status ===
    "loading"`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始数据为 undefined（例如，当用户通过直接导航到编辑可预订项表单来加载预订应用时）或在下一次渲染中，`useQuery` 将继续获取数据。`useQuery`
    在它返回的对象上设置属性，包括不同状态值的布尔值。例如，`BookableEdit` 组件使用 `isLoading` 布尔值来检查 `status ===
    "loading"`。
- en: The Edit Bookable and New Bookable forms use a custom `useFormState` hook and
    `BookableForm` component to manage and display the form fields. Fleshing out the
    forms here won’t teach us anything new about hooks, so this is one of those moments
    where I ask you to take a look in the repo to get the necessary code and to see
    how they do their jobs. Notice also that the `BookableDetails` component now includes
    an Edit button to open the Edit Bookable form. Feel free to see the changes as
    a challenge and try implementing the forms before checking the repo.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑可预订和新可预订表单使用自定义的 `useFormState` 钩子和 `BookableForm` 组件来管理和显示表单字段。在这里完善表单不会教给我们任何关于钩子的新知识，所以这是那种我要求你查看存储库以获取必要代码并了解它们如何工作的时刻。注意，`BookableDetails`
    组件现在还包括一个编辑按钮，用于打开编辑可预订表单。请随意将更改视为挑战，并在检查存储库之前尝试实现表单。
- en: So, we have an edit form that shows the existing bookable data. But how do we
    save any changes we make to the database? Instead of calling `useQuery`, we call
    `useMutation`. Let’s get it working for new bookables.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个显示现有可预订数据的编辑表单。但我们如何将我们对数据库所做的任何更改保存到数据库中？我们不是调用 `useQuery`，而是调用 `useMutation`。让我们让它为新可预订工作。
- en: 10.3.5 Updating server state with useMutation
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 使用 useMutation 更新服务器状态
- en: React Query helps us synchronize our React app UI with state stored on a server.
    We’ve seen how `useQuery` simplifies the process of fetching that state, caching
    it temporarily in the browser. We also want to update state on the server, and
    React Query provides the `useMutation` hook for that purpose.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 帮助我们同步我们的 React 应用程序 UI 与服务器上存储的状态。我们已经看到了 `useQuery` 如何简化获取该状态的过程，并在浏览器中临时将其缓存。我们还想在服务器上更新状态，React
    Query 提供了 `useMutation` 钩子来实现这个目的。
- en: 'On the Bookables page, we can bring up the New Bookable form and enter information
    in its fields, but we can’t save our creations. We want to mutate that state!
    We need a function that’ll send the new bookable to the server, something like
    this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bookables 页面上，我们可以打开新的可预订表单并在其字段中输入信息，但我们无法保存我们的创建。我们想要突变那个状态！我们需要一个将新的可预订发送到服务器的函数，类似于以下内容：
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The following listing shows the `BookableNew` component calling `createBookable`
    in its `handleSubmit` function. It gets the `createBookable` mutation function
    by calling `useMutation`, and we discuss the necessary syntax after the listing.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `BookableNew` 组件在其 `handleSubmit` 函数中调用 `createBookable`。它通过调用 `useMutation`
    获取 `createBookable` 突变函数，我们将在列表之后讨论必要的语法。
- en: 'Branch: 1007-use-mutation, File: /src/components/Bookables/BookableNew.js'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1007-use-mutation，文件：/src/components/Bookables/BookableNew.js
- en: Listing 10.14 `BookableNew` saving data to the server with `useMutation`
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.14 `BookableNew` 使用 `useMutation` 将数据保存到服务器
- en: '[PRE57]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Import React Query hooks.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 React Query 钩子。
- en: ❷ Import the createItem API function.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入 createItem API 函数。
- en: ❸ Call useMutation, assigning the mutation function to the createBookable variable.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用 useMutation，将突变函数分配给 createBookable 变量。
- en: ❹ Pass useMutation an asynchronous function.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 向 useMutation 传递一个异步函数。
- en: ❺ Set an onSuccess callback.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 设置一个 onSuccess 回调。
- en: ❻ Add the new bookable to the “bookables” query cache.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将新的可预订添加到“bookables”查询缓存中。
- en: ❼ Navigate to the newly created bookable.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 导航到新创建的可预订。
- en: ❽ Call the createBookable mutation function with the fields for the new bookable.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用新可预订的字段调用 createBookable 突变函数。
- en: 'The `useMutation` hook returns an object containing the `mutate` function and
    status values:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`useMutation` 钩子返回一个包含 `mutate` 函数和状态值的对象：'
- en: '[PRE58]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When you call `mutate`, React Query runs `asyncFunction` and updates the status
    properties (for example, `status`, `error`, `data`, and `isLoading`). When calling
    `useMutation`, the `BookableNew` component assigns the mutation function to a
    variable called `createBookable`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `mutate` 时，React Query 会运行 `asyncFunction` 并更新状态属性（例如，`status`、`error`、`data`
    和 `isLoading`）。当调用 `useMutation` 时，`BookableNew` 组件将突变函数分配给一个名为 `createBookable`
    的变量：
- en: '[PRE59]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`BookableNew` passes `useMutation` an asynchronous function to post the fields
    for the new bookable to the server. It uses the `createItem` function from /src/utils/api.js:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookableNew` 将一个异步函数传递给 `useMutation`，用于将新可预订的字段发布到服务器。它使用来自 /src/utils/api.js
    的 `createItem` 函数：'
- en: '[PRE60]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The config object includes an `onSuccess` property, a function that runs after
    the server state has been successfully changed. The function adds the new bookable
    to the `bookables` cache and navigates to the new bookable:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对象包括一个 `onSuccess` 属性，一个在服务器状态成功更改后运行的函数。该函数将新的可预订添加到 `bookables` 缓存中，并导航到新的可预订：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Receive the newly created bookable from the server.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从服务器接收新创建的可预订。
- en: ❷ Append the new bookable to the cache of bookables.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将新的可预订项追加到可预订项的缓存中。
- en: ❸ Navigate to the new bookable in the UI.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在UI中导航到新的可预订项。
- en: Challenge 10.3
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战10.3
- en: Hook up the `BookableEdit` component so that it saves changes to bookables and
    allows the deletion of bookables. Create separate mutations for each action and
    call them from the `handleSave` and `handleDelete` functions. (You could add `editItem`
    and `deleteItem` methods to api.js and call those in the mutations.) The 1008-edit-bookable
    branch has solution code with lots of comments.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 将`BookableEdit`组件连接起来，以便它保存对可预订项的更改并允许删除可预订项。为每个操作创建单独的突变，并在`handleSave`和`handleDelete`函数中调用它们。（您可以在api.js中添加`editItem`和`deleteItem`方法，并在突变中调用这些方法。）1008-edit-bookable分支包含带有大量注释的解决方案代码。
- en: Challenge 10.4
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战10.4
- en: This is a big one! Implement a `BookingForm` component so users can create,
    edit, and delete bookings on the Bookings page. The `BookingDetails` component
    should show either a `Booking` component with non-editable details of the selected
    booking, or the `BookingForm` component when a user wants to edit or create a
    booking. The solution branch, 1009-booking-form, creates custom hooks for the
    three mutations (`useCreateBooking`, `useUpdateBooking`, and `useDeleteBooking`)
    in the bookingsHooks.js file.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大项目！实现一个`BookingForm`组件，以便用户可以在预订页面创建、编辑和删除预订。`BookingDetails`组件应显示选定的预订的非可编辑详情的`Booking`组件，或者当用户想要编辑或创建预订时显示`BookingForm`组件。解决方案分支1009-booking-form在bookingsHooks.js文件中创建了三个自定义钩子（`useCreateBooking`、`useUpdateBooking`和`useDeleteBooking`）。
- en: Note I haven’t implemented any form validation in the bookings app. In a real
    app, we’d add validation on both the client and the server.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我在预订应用中尚未实现任何表单验证。在实际应用中，我们会在客户端和服务器上添加验证。
- en: Note The repo has two more branches for this chapter, 1010-react-spring and
    1011-spring-challenge, that use the React Spring library to add animated transitions
    to the Bookings page, sliding the bookings grid down for switched bookables and
    across for switched dates. It’s one fun extra use of third-party hooks.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：该仓库有两个更多分支用于本章，1010-react-spring和1011-spring-challenge，它们使用React Spring库为预订页面添加动画过渡，滑动预订网格以切换预订项和日期。这是第三方钩子的一个有趣额外用途。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'With React Router, render the same component for routes that start with a specified
    path. For example, render `BookablesPage` for URLs that start with /bookables/:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router，为以指定路径开始的路线渲染相同的组件。例如，为以/bookables/开始的URL渲染`BookablesPage`：
- en: '[PRE62]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As an alternative to the `element` prop, wrap JSX within opening and closing
    `Route` tags:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`element`属性的替代，将JSX包裹在打开和关闭`Route`标签之间：
- en: '[PRE63]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Nest routes by including a `Routes` component in a component already matched
    by a `Route` higher up the component tree. For example, `BookablesPage` can include
    its own nested routes, with URLs /bookables and /bookables/new by returning UI
    like this:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在组件树中更高位置的`Route`组件中包含`Routes`组件来嵌套路由。例如，`BookablesPage`可以包含其自己的嵌套路由，URL为/bookables和/bookables/new，通过返回如下UI：
- en: '[PRE64]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use parameters in routes by prepending parameter names with a colon:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由中使用参数，通过在参数名称前加冒号：
- en: '[PRE65]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Access the parameter in a component by calling React Router’s `useParams` hook.
    `useParams` returns an object with parameters and their values. Destructure the
    parameters from the object:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用React Router的`useParams`钩子来在组件中访问参数。`useParams`返回一个包含参数及其值的对象。从对象中解构参数：
- en: '[PRE66]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Navigate with React Router’s `useNavigate` hook:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的`useNavigate`钩子进行导航：
- en: '[PRE67]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Access search parameters in a URL’s query string with React Router’s `useSearchParams`
    hook:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Router的`useSearchParams`钩子访问URL查询字符串中的搜索参数：
- en: '[PRE68]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For the URL /bookings?bookableId=1&date=2020-08-20, access the parameters like
    this:'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于URL /bookings?bookableId=1&date=2020-08-20，可以这样访问参数：
- en: '[PRE69]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Set the query string by passing an object to `setSearchParams`:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将对象传递给`setSearchParams`来设置查询字符串：
- en: '[PRE70]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Use React Query to efficiently fetch and cache server state on the browser.
    Wrap your app JSX in a provider and pass the provider a client object:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Query在浏览器中高效地获取和缓存服务器状态。将您的app JSX包裹在一个提供者中，并将客户端对象传递给提供者：
- en: '[PRE71]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To fetch data, pass a key and a fetch function to the `useQuery` hook:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取数据，将键和获取函数传递给`useQuery`钩子：
- en: '[PRE72]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Pass a configuration object to `useQuery` as a third argument:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置对象作为第三个参数传递给`useQuery`：
- en: '[PRE73]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Set initial data by using the config object:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用配置对象来设置初始数据：
- en: '[PRE74]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the `getQueryData` method and a key to access previously fetched data from
    the `queryClient` object:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getQueryData`方法和键从`queryClient`对象访问之前获取的数据：
- en: '[PRE75]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a mutation function for updating server state by calling React Query’s
    `useMutation` function:'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于通过调用 React Query 的 `useMutation` 函数来更新服务器状态的突变函数：
- en: '[PRE76]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use the mutation function to update state on the server:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用突变函数在服务器上更新状态：
- en: '[PRE77]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
