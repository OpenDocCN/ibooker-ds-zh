- en: Unit 2\. Types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2单元\. 类型
- en: The text `"Go"` and the number `28487` are both represented with the same zeros
    and ones on an x86 computer (`0110111101000111`). The *type* establishes what
    those bits and bytes mean. One is a *string* of two characters, the other is a
    16-bit *integer* (2 bytes). The string type is used for multilingual text, and
    16-bit integers are one of many numeric types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86计算机上，文本`"Go"`和数字`28487`都使用相同的零和一(`0110111101000111`)表示。*类型*确定了这些位和字节的意义。一个是两个字符的*字符串*，另一个是16位的*整数*（2字节）。字符串类型用于多语言文本，16位整数是许多数字类型之一。
- en: '[Unit 2](#part03) covers the primitive types that Go provides for text, characters,
    numbers, and other simple values. When appropriate, these lessons reveal the benefits
    and drawbacks to help you select the most appropriate type.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2单元](#part03)涵盖了Go提供的原始类型，包括文本、字符、数字和其他简单值。在适当的时候，这些课程会揭示其优缺点，帮助你选择最合适的类型。'
- en: Lesson 6\. Real numbers
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6课\. 实数
- en: After reading [lesson 6](#ch06), you’ll be able to
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第6课](#ch06)后，你将能够
- en: Use two types of real numbers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两种实数类型
- en: Understand the memory-versus-precision trade-off
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存与精度的权衡
- en: Work around rounding errors in your piggy bank
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的储蓄罐中解决舍入误差
- en: 'Computers store and manipulate real numbers like 3.14159 using the IEEE-754
    floating-point standard. *Floating-point* numbers can be very large or incredibly
    small: think galaxies and atoms. With such versatility, programming languages
    like JavaScript and Lua get by using floating-point numbers exclusively. Computers
    also support *integers* for whole numbers, the subject of the next lesson.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用IEEE-754浮点标准存储和处理像3.14159这样的实数。*浮点数*可以非常大或非常小：想想星系和原子。具有这种多功能性，像JavaScript和Lua这样的编程语言完全使用浮点数。计算机还支持*整数*，这是下一课的主题。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Imagine a carnival game with three cups. The nearest cup is worth $0.10 to $1.00,
    the next is worth $1 to $10, and the farthest cup is worth $10 to $100\. Choose
    one cup and toss as many as 10 coins. If landing four coins in the middle cup
    is worth $4, how would you win $100?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个有三个杯子的游乐场游戏。最近的杯子价值0.10到1.00美元，下一个杯子价值1到10美元，最远的杯子价值10到100美元。选择一个杯子，投掷多达10枚硬币。如果中间的杯子落地四枚硬币价值4美元，你将如何赢得100美元？
- en: To represent many possible real numbers with a fixed amount of space, a floating-point
    number is like choosing 1 of 2,048 cups and placing anywhere from one to several
    trillion coins in it. Some bits represent a cup or *bucket*, and other bits represent
    the coins or *offset* within that bucket.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用固定数量的空间表示许多可能的实数，浮点数就像选择2,048个杯子中的一个，并在其中放置从一枚到数万亿枚硬币。一些位代表一个杯子或*桶*，而其他位代表该桶内的硬币或*偏移量*。
- en: One cup may represent very tiny numbers, and another represent huge numbers.
    Though every cup fits the same number of coins, some cups represent a smaller
    range of numbers more precisely than others, which represent a larger range of
    numbers with less precision.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个杯子可能代表非常小的数字，另一个代表非常大的数字。尽管每个杯子可以容纳相同数量的硬币，但一些杯子比其他杯子更精确地代表较小的数字范围，而其他杯子则代表较大的数字范围但精度较低。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1\. Declaring floating-point variables
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 声明浮点变量
- en: 'Every variable has a type. When you declare and initialize a variable with
    a real number, you’re using a floating-point type. The following three lines of
    code are equivalent, because the Go compiler will infer that `days` is a `float64`,
    even if you don’t specify it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个类型。当你用实数声明和初始化一个变量时，你正在使用浮点类型。以下三行代码是等效的，因为Go编译器会推断出`days`是`float64`，即使你没有指定它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Short declaration (covered in [lesson 4](kindle_split_013.html#ch04))**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 短声明（在第4课中介绍过[lesson 4](kindle_split_013.html#ch04))**'
- en: It’s valuable to know that `days` has a `float64` type, but it’s superfluous
    to specify `float64`. You, me, and the Go compiler can all infer the type of `days`
    by looking at the value to the right. Whenever the value is a number with a decimal
    point, the type will be `float64`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`days`具有`float64`类型是有价值的，但指定`float64`是多余的。你、我和Go编译器都可以通过查看右侧的值来推断`days`的类型。只要值是一个带小数点的数字，类型就会是`float64`。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `golint` tool provides hints for coding style. It discourages the clutter
    with the following message:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`golint`工具提供关于编码风格的提示。它通过以下消息来劝阻杂乱：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you initialize a variable with a whole number, Go won’t know you want floating-point
    unless you explicitly specify a floating-point type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个整数初始化一个变量，Go不知道你想要浮点数，除非你明确指定浮点类型：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.1**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.1**'
- en: '**[Q1:](#ch06qa2q0a1)**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa2q0a1)**'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What type is inferred for `answer := 42.0`?
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`answer := 42.0`推断的类型是什么？'
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.1 answer**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.1 答案**'
- en: '**[1:](#ch06qa1q1)**'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa1q1)**'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Real numbers are inferred as `float64`.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实数被推断为`float64`。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1.1\. Single precision floating-point numbers
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 单精度浮点数
- en: Go has two floating-point types. The default floating-point type is `float64`,
    a 64-bit floating-point type that uses eight bytes of memory. Some languages use
    the term *double precision* to describe the 64-bit floating-point type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种浮点数类型。默认浮点数类型是`float64`，这是一个64位浮点数类型，使用8个字节的内存。某些语言使用*双精度*一词来描述64位浮点数类型。
- en: The `float32` type uses half the memory of `float64` but offers less precision.
    This type is sometimes called *single precision*. To use `float32`, you must specify
    the type when declaring a variable. The following listing shows `float32` in use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`float32`类型使用的内存是`float64`的一半，但精度较低。这种类型有时被称为*单精度*。要使用`float32`，必须在声明变量时指定类型。以下列表显示了`float32`的使用。'
- en: 'Listing 6.1\. 64-bit vs. 32-bit floating-point: pi.go'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 64位与32位浮点数：pi.go
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Prints 3.141592653589793**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 3.141592653589793**'
- en: '***2* Prints 3.1415927**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 3.1415927**'
- en: When working with a large amount of data, such as thousands of vertices in a
    3D game, it may make sense to sacrifice precision for memory savings by using
    `float32`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量数据时，例如3D游戏中的数千个顶点，使用`float32`来牺牲精度以节省内存可能是有意义的。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Functions in the `math` package operate on `float64` types, so prefer `float64`
    unless you have a good reason to do otherwise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`math` 包中的函数在`float64`类型上操作，所以除非你有充分的理由，否则请优先使用`float64`。'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.2**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.2**'
- en: '**[Q1:](#ch06qa4q0a1)**'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa4q0a1)**'
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many bytes of memory does a single precision `float32` use?
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 单精度`float32`使用多少字节的内存？
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.2 answer**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.2 答案**'
- en: '**[1:](#ch06qa3q1)**'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa3q1)**'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `float32` uses 4 bytes (or 32 bits).
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`float32`使用4个字节（或32位）。'
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.1.2\. The zero value
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 零值
- en: In Go, each type has a default value, called the *zero value*. The default applies
    when you declare a variable but don’t initialize it with a value, as you can see
    in the next listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，每种类型都有一个默认值，称为*零值*。当你声明一个变量但没有用值初始化它时，就会应用这个默认值，如下一个列表所示。
- en: 'Listing 6.2\. Declaring a variable without a value: default.go'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 声明一个没有值的变量：default.go
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Prints 0**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0**'
- en: 'The previous listing declares `price` with no value, so Go initializes it with
    zero. To the computer, it’s identical to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表声明了没有值的`price`，因此Go将其初始化为零。对计算机来说，它与以下内容相同：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To the programmer, the difference is subtle. When you declare `price := 0.0`,
    it’s like saying the price is free. Not specifying a value for `price`, as in
    [listing 6.2](#ch06ex02), hints that the real value is yet to come.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序员来说，这种差异很微妙。当你声明`price := 0.0`时，就像说价格是免费的。在[列表 6.2](#ch06ex02)中未指定`price`的值，暗示实际值尚未到来。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.3**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.3**'
- en: '**[Q1:](#ch06qa6q0a1)**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa6q0a1)**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the zero value for a `float32`?
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`float32`的零值是多少？'
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.3 answer**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.3 答案**'
- en: '**[1:](#ch06qa5q1)**'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa5q1)**'
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The default value is zero (`0.0`).
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认值是零（`0.0`）。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2\. Displaying floating-point types
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 显示浮点数类型
- en: When using `Print` or `Println` with floating-point types, the default behavior
    is to display as many digits as possible. If that’s not what you want, you can
    use `Printf` with the `%f` formatting verb to specify the number of digits, as
    the following listing shows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Print`或`Println`与浮点数类型一起时，默认行为是显示尽可能多的数字。如果你不希望这样，你可以使用带有`%f`格式动词的`Printf`来指定数字的数量，如下一个列表所示。
- en: 'Listing 6.3\. Formatted print for floating-point: third.go'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.3\. 浮点数格式化打印：third.go
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Prints 0.3333333333333333**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0.3333333333333333**'
- en: '***2* Prints 0.333333**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 0.333333**'
- en: '***3* Prints 0.333**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 0.333**'
- en: '***4* Prints 0.33**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印 0.33**'
- en: The `%f` verb formats the value of `third` with a width and with precision,
    as shown in [figure 6.1](#ch06fig01).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`%f` 动词以宽度和精度格式化`third`的值，如图 6.1 所示。'
- en: Figure 6.1\. The `%f` format verb
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. `%f` 格式动词
- en: '![](06fig01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01.jpg)'
- en: '*Precision* specifies how many digits should appear after the decimal point;
    two digits for `%.2f`, for example, as shown in [figure 6.2](#ch06fig02).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*精度*指定小数点后应出现多少位数字；例如，`%.2f`为两位数字，如图 6.2 所示。'
- en: Figure 6.2\. Output formatted with a width of 4, precision of 2
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 以宽度为4，精度为2格式化的输出
- en: '![](06fig02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig02.jpg)'
- en: '*Width* specifies the minimum number of characters to display, including the
    decimal point and the digits before and after the decimal (for example, 0.33 has
    a width of 4). If the width is larger than the number of characters needed, `Printf`
    will pad the left with spaces. If the width is unspecified, `Printf` will use
    the number of characters necessary to display the value.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽度* 指定要显示的最小字符数，包括小数点以及小数点前后的数字（例如，0.33 的宽度为 4）。如果宽度大于所需字符数，`Printf` 将用空格填充左侧。如果未指定宽度，`Printf`
    将使用显示值所需的字符数。'
- en: To left-pad with zeros instead of spaces, prefix the width with a zero, as in
    the following listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要用零而不是空格左对齐，请在宽度前加一个零，如下面的列表所示。
- en: 'Listing 6.4\. Zero padding: third.go'
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. 零填充：third.go
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Prints 00.33**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 00.33**'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.4**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.4**'
- en: '**[1](#ch06qa8q0a1)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch06qa8q0a1)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Type [listing 6.3](#ch06ex03) into the body of a main function in the Go playground.
    Try different values for the width and precision in the `Printf` statement.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 [列表 6.3](#ch06ex03) 输入 Go 演示场 main 函数的主体中。尝试在 `Printf` 语句中为宽度和精度设置不同的值。
- en: '**[2](#ch06qa8q0a2)**'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch06qa8q0a2)**'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the width and precision of 0015.1021?
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 0015.1021 的宽度和精度是多少？
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.4 answer**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.4 答案**'
- en: '**[1](#ch06qa7q1)**'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch06qa7q1)**'
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints 0.333333**'
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0.333333**'
- en: '***2* Prints 0.3333**'
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 0.3333**'
- en: '***3* Prints 000.33**'
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 000.33**'
- en: '**[2](#ch06qa7q2)**'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch06qa7q2)**'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The width is 9 and the precision is 4, with zero padding `"%09.4f"`.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 宽度为 9，精度为 4，使用零填充 `"%09.4f"`。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.3\. Floating-point accuracy
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 浮点精度
- en: 'In mathematics, some rational numbers can’t be accurately represented in decimal
    form. The number 0.33 is only an approximation of ⅓. Unsurprisingly, a calculation
    on approximate values has an approximate result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，一些有理数不能在十进制形式中准确表示。数字 0.33 只是 ⅓ 的近似值。不出所料，对近似值进行计算的结果也是近似的：
- en: ⅓ + ⅓ + ⅓ = 1
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⅓ + ⅓ + ⅓ = 1
- en: 0.33 + 0.33 + 0.33 = 0.99
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.33 + 0.33 + 0.33 = 0.99
- en: Floating-point numbers suffer from rounding errors too, except floating-point
    hardware uses a binary representation (using only 0s and 1s) instead of decimal
    (using 1–9). The consequence is that computers can accurately represent ⅓ but
    have rounding errors with other numbers, as the following listing illustrates.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数也受到舍入误差的影响，除了浮点硬件使用二进制表示（仅使用 0 和 1）而不是十进制（使用 1–9）。结果是，计算机可以准确地表示 ⅓，但其他数字会有舍入误差，如下面的列表所示。
- en: '![](f0050-01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0050-01.jpg)'
- en: 'Listing 6.5\. Floating-point inaccuracies: float.go'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 浮点不精确：float.go
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Prints 1**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1**'
- en: '***2* Prints 0.30000000000000004**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 0.30000000000000004**'
- en: As you can see, floating-point isn’t the best choice for representing money.
    One alternative is to store the number of cents with an integer type, which is
    covered in the next lesson.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，浮点数不是表示金钱的最佳选择。一个替代方案是使用整型存储美分的数量，这将在下一课中介绍。
- en: On the other hand, even if your `piggyBank` were off by a penny, well, it isn’t
    mission critical. As long as you’ve saved enough for the trip to Mars, you’re
    happy. To sweep the rounding errors under the rug, you can use `Printf` with a
    precision of two digits.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，即使你的 `piggyBank` 差了一分，嗯，那也不是关键任务。只要你能为火星之旅存够钱，你就满意了。为了把舍入误差扫到地毯下，你可以使用
    `Printf` 并设置两位数的精度。
- en: To minimize rounding errors, we recommend that you perform multiplication before
    division. The result tends to be more accurate that way, as demonstrated in the
    temperature conversion examples in the next two listings.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化舍入误差，我们建议你在除法之前进行乘法。这样结果往往更准确，如以下两个列表中的温度转换示例所示。
- en: 'Listing 6.6\. Division first: rounding-error.go'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 除法优先：rounding-error.go
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Prints 69.80000000000001° F**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 69.80000000000001° F**'
- en: 'Listing 6.7\. Multiplication first: temperature.go'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 乘法优先：temperature.go
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Prints 69.8° F**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 69.8° F**'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 6.5**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.5**'
- en: '**[Q1:](#ch06qa10q0a1)**'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa10q0a1)**'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the best way to avoid rounding errors?
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 避免舍入误差的最佳方法是什么？
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 6.5 answer**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.5 答案**'
- en: '**[1:](#ch06qa9q1)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa9q1)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t use a floating-point.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要使用浮点数。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.4\. Comparing floating-point numbers
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 比较浮点数
- en: 'In [listing 6.5](#ch06ex05), the `piggyBank` contained 0.30000000000000004,
    rather than the desired 0.30\. Keep this in mind any time you need to compare
    floating-point numbers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.5](#ch06ex05) 中，`piggyBank` 包含了 0.30000000000000004，而不是期望的 0.30\. 在需要比较浮点数时请记住这一点：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Prints false**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 false**'
- en: 'Instead of comparing floating-point numbers directly, determine the absolute
    difference between two numbers and then ensure the difference isn’t too big. To
    take the absolute value of a `float64`, the `math` package provides an `Abs` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接比较浮点数，确定两个数字之间的绝对差异，然后确保差异不是太大。为了取`float64`的绝对值，`math`包提供了一个`Abs`函数：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Prints true**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印为 true**'
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The upper bound for a floating-point error for a single operation is known as
    the machine epsilon, which is 2^(-52) for `float64` and 2^(-23) for `float32`.
    Unfortunately, floating-point errors accumulate rather quickly. Add 11 dimes ($0.10
    each) to a fresh `piggyBank`, and the rounding errors exceed 2^(-52) when compared
    to $1.10\. That means you’re better off picking a tolerance specific to your application—in
    this case, 0.0001.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 单个操作浮点误差的上限称为机器epsilon，对于`float64`是 2^(-52)，对于`float32`是 2^(-23)。不幸的是，浮点误差会迅速累积。向一个空的`piggyBank`中添加
    11 个一角硬币（每个 0.10 美元），与 1.10 美元相比，舍入误差超过了 2^(-52)。这意味着你最好选择一个针对你应用程序的特定容差——在这种情况下，0.0001。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 6.6**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 6.6**'
- en: '**[Q1:](#ch06qa12q0a1)**'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch06qa12q0a1)**'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you add 11 dimes ($0.10 each) to an empty `piggyBank` of type `float64`,
    what is the final balance?
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你向一个空的`piggyBank`类型为`float64`中添加 11 个一角硬币（每个 0.10 美元），最终余额是多少？
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 6.6 answer**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 6.6 答案**'
- en: '**[1:](#ch06qa11q1)**'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch06qa11q1)**'
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints 1.0999999999999999**'
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1.0999999999999999**'
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Go can infer types for you. In particular, Go will infer `float64` for variables
    initialized with real numbers.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 可以为你推断类型。特别是，Go 将为用实数初始化的变量推断`float64`。
- en: Floating-point types are versatile but not always accurate.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型用途广泛但并不总是准确。
- en: You used 2 of Go’s 15 numeric types (`float64`, `float32`).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用了 Go 的 15 种数值类型中的 2 种（`float64`，`float32`）。
- en: Let’s see if you got this...
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些...
- en: 'Experiment: piggy.go'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：piggy.go
- en: Save some money to buy a gift for your friend. Write a program that randomly
    places nickels ($0.05), dimes ($0.10), and quarters ($0.25) into an empty piggy
    bank until it contains at least $20.00\. Display the running balance of the piggy
    bank after each deposit, formatting it with an appropriate width and precision.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的朋友存一些钱买礼物。编写一个程序，将镍币（$0.05）、一角硬币（$0.10）和quarter（$0.25）随机放入一个空的猪储蓄罐中，直到它包含至少
    $20.00。在每次存款后显示猪储蓄罐的运行余额，并使用适当的宽度和精度进行格式化。
- en: Lesson 7\. Whole numbers
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 课：整数
- en: After reading [lesson 7](#ch07), you’ll be able to
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第 7 课](#ch07)之后，你将能够
- en: Use 10 types of whole numbers
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 10 种整数类型
- en: Choose the right type
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的类型
- en: Use hexadecimal and binary representations
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用十六进制和二进制表示
- en: Go offers 10 different types for whole numbers, collectively called *integers*.
    Integers don’t suffer from the accuracy issues of floating-point types, but they
    can’t store fractional numbers and they have a limited range. The integer type
    you choose will depend on the range of values needed for a given situation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 10 种不同的整数类型，统称为**整数**。整数不会受到浮点类型精度问题的困扰，但它们不能存储分数数字，并且它们的范围有限。你选择的整数类型将取决于特定情况下所需值的范围。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: How many numbers can you represent with two tokens?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用两个符号表示多少个数字？
- en: If the tokens are individually identifiable by position, there are four possible
    permutations. Both tokens, neither token, one token, or the other token. You could
    represent four numbers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号可以通过位置单独识别，那么有四种可能的排列。两个符号，没有符号，一个符号，或者另一个符号。你可以表示四个数字。
- en: Computers are based on bits. A bit can either be off or on—0 or 1\. Eight bits
    can represent 256 different values. How many bits would it take to represent the
    number 4,000,000,000?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机基于位。位可以是关闭的或开启的——0 或 1。八个位可以表示 256 个不同的值。要表示数字 4,000,000,000 需要多少位？
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.1\. Declaring integer variables
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 声明整数变量
- en: 'Five integer types are *signed*, meaning they can represent both positive and
    negative whole numbers. The most common integer type is a signed integer abbreviated
    `int`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 五种整数类型是**有符号的**，这意味着它们可以表示正负整数。最常见的整数类型是有符号整数，缩写为`int`：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The other five integer types are *unsigned*, meaning they’re for positive numbers
    only. The abbreviation for unsigned integer is `uint`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其他五种整数类型是**无符号的**，这意味着它们仅用于正数。无符号整数的缩写为`uint`：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When using type inference, Go will always pick the `int` type for a literal
    whole number. The following three lines are equivalent:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类型推断时，Go 总是为字面量整数选择`int`类型。以下三行是等效的：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: As with the floating-point types in [lesson 6](kindle_split_016.html#ch06),
    it’s preferable to not specify the `int` type when it can be inferred.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 6 课](kindle_split_016.html#ch06) 中的浮点类型一样，当可以推断时，最好不指定 `int` 类型。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.1**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.1**'
- en: '**[Q1:](#ch07qa2q0a1)**'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa2q0a1)**'
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If your glass is half full, which integer type would you use to represent the
    number of milliliters of water in your glass?
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的杯子里的水是半满的，你会使用哪种整型来表示杯中水的毫升数？
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.1 answer**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.1 答案**'
- en: '**[1:](#ch07qa1q1)**'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa1q1)**'
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `uint` type (unsigned integer) is for positive integers only.
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`uint` 类型（无符号整数）仅用于正整数。'
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.1.1\. Integer types for every occasion
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 适用于各种场合的整型
- en: Integers, whether signed or unsigned, come in a variety of sizes. The size affects
    their minimum and maximum values and how much memory they consume. There are eight
    architecture-independent types suffixed with the number of bits they need, as
    summarized in [table 7.1](#ch07table01).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 整数，无论是带符号的还是无符号的，都有各种大小。大小影响它们的最大和最小值以及它们消耗的内存量。有八种与架构无关的类型，后缀为它们所需的位数，总结在 [表
    7.1](#ch07table01) 中。
- en: '![](f0054-01.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![f0054-01.jpg](f0054-01.jpg)'
- en: Table 7.1\. Architecture-independent integer types
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 架构无关的整型
- en: '| Type | Range | Storage |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 范围 | 存储空间 |'
- en: '| --- | --- | --- |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| int8 | –128 to 127 | 8-bit (one byte) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| int8 | –128 到 127 | 8 位（一个字节）|'
- en: '| uint8 | 0 to 255 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 0 到 255 |'
- en: '| int16 | –32,768 to 32,767 | 16-bit (two bytes) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| int16 | –32,768 到 32,767 | 16 位（两个字节）|'
- en: '| uint16 | 0 to 65535 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| uint16 | 0 到 65535 |'
- en: '| int32 | –2,147,483,648 to 2,147,483,647 | 32-bit (four bytes) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| int32 | –2,147,483,648 到 2,147,483,647 | 32 位（四个字节）|'
- en: '| uint32 | 0 to 4,294,967,295 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 0 到 4,294,967,295 |'
- en: '| int64 | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 64-bit
    (eight bytes) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| int64 | –9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 64 位（八字节）|'
- en: '| uint64 | 0 to 18,446,744,073,709,551,615 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 0 到 18,446,744,073,709,551,615 |'
- en: That’s a lot of types to choose from! Later in this lesson, we’ll show some
    examples where specific integer types make sense, along with what happens if your
    program exceeds the available range.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多类型可供选择！在本课的后面部分，我们将展示一些示例，说明特定整型何时适用，以及如果程序超出可用范围会发生什么。
- en: There are two integer types not listed in [table 7.1](#ch07table01). The `int`
    and `uint` types are optimal for the target device. The Go Playground, Raspberry
    Pi 2, and older mobile phones provide a 32-bit environment where both `int` and
    `uint` are 32-bit values. Any recent computer will provide a 64-bit environment
    where `int` and `uint` will be 64-bit values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 7.1](#ch07table01) 中未列出两种整型。`int` 和 `uint` 类型针对目标设备是最佳选择。Go Playground、Raspberry
    Pi 2 和旧款手机提供 32 位环境，其中 `int` 和 `uint` 都是 32 位值。任何近期计算机都将提供 64 位环境，其中 `int` 和 `uint`
    将是 64 位值。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re operating on numbers larger than two billion, and if the code could
    be run on older 32-bit hardware, be sure to use `int64` or `uint64` instead of
    `int` and `uint`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理大于二十亿的数字，并且如果代码可以在旧款 32 位硬件上运行，请确保使用 `int64` 或 `uint64` 而不是 `int` 和 `uint`。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although it’s tempting to think of `int` as an `int32` on some devices and an
    `int64` on other devices, these are three distinct types. The `int` type isn’t
    an alias for another type.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些设备上可能会认为 `int` 是 `int32` 而在其他设备上是 `int64`，但这些都是三种不同的类型。`int` 类型不是其他类型的别名。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.2**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.2**'
- en: '**[Q1:](#ch07qa4q0a1)**'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa4q0a1)**'
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which integer types support the value –20,151,021?
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪些整型支持值 –20,151,021？
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 7.2 answer**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.2 答案**'
- en: '**[1:](#ch07qa3q1)**'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa3q1)**'
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `int32`, `int64`, and `int` types would work.
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`int32`、`int64` 和 `int` 类型都可以使用。'
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.1.2\. Knowing your type
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 了解你的类型
- en: If you’re ever curious about which type the Go compiler inferred, the `Printf`
    function provides the `%T` format verb to display a variable’s type, as shown
    in the following listing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇 Go 编译器推断出的类型，`Printf` 函数提供了 `%T` 格式说明符来显示变量的类型，如下面的列表所示。
- en: 'Listing 7.1\. Inspect a variable’s type: inspect.go'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 检查变量的类型：inspect.go
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Prints Type int for 2018**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印出类型 int 对 2018**'
- en: 'Instead of repeating the variable twice, you can tell `Printf` to use the first
    argument `[1]` for the second format verb:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以告诉 `Printf` 使用第一个参数 `[1]` 作为第二个格式说明符，而不是重复变量两次：
- en: '[PRE19]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Prints Type float64 for 365.2425**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印出类型 float64 对 365.2425**'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.3**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.3**'
- en: '**[Q1:](#ch07qa6q0a1)**'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa6q0a1)**'
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which types does Go infer for text between quotes, a whole number, a real number,
    and the word `true` (without quotes)? Expand [listing 7.1](#ch07ex01) to declare
    variables with different values and run the program to see which types Go infers.
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go如何推断引号之间的文本、整数、实数和单词`true`（不带引号）的类型？将[列表7.1](#ch07ex01)扩展以声明具有不同值的变量，并运行程序以查看Go推断的类型。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.3 answer**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.3 答案**'
- en: '**[1:](#ch07qa5q1)**'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa5q1)**'
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints Type string for text**'
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印类型为string的文本**'
- en: '***2* Prints Type int for 42**'
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印类型为int的42**'
- en: '***3* Prints Type float64 for 3.14**'
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印类型为float64的3.14**'
- en: '***4* Prints Type bool for true**'
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印类型为bool的true**'
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. The uint8 type for 8-bit colors
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2. 用于8位颜色的`uint8`类型
- en: 'In Cascading Style Sheets (CSS), colors on screen are specified as a red, green,
    blue triplet, each with a range of 0–255. It’s the perfect situation to use the
    `uint8` type, an 8-bit unsigned integer able to represent values from 0–255:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在层叠样式表（CSS）中，屏幕上的颜色被指定为红、绿、蓝三元组，每个范围都是0-255。这是使用`uint8`类型的完美情况，它是一个8位无符号整数，能够表示0-255的值：
- en: '[PRE21]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here are the benefits of `uint8` instead of a regular `int` for this case:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，使用`uint8`而不是常规的`int`有以下好处：
- en: With a `uint8`, the variables are restricted to the range of valid values, eliminating
    over four billion incorrect possibilities compared to a 32-bit integer.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`uint8`，变量被限制在有效值的范围内，与32位整数相比，消除了超过四十亿个错误的可能性。
- en: If there are a lot of colors to store sequentially, such as in an uncompressed
    image, you could achieve considerable memory savings by using 8-bit integers.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要存储大量的颜色，例如在未压缩的图像中，使用8位整数可以实现相当大的内存节省。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hexadecimal in Go**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go中的十六进制**'
- en: Colors in CSS are specified in hexadecimal instead of decimal. *Hexadecimal*
    represents numbers using 6 (*hexa-*) more digits than decimal’s 10\. The first
    10 digits are the same 0 through 9, but they’re followed by A through F. A in
    hexadecimal is equivalent to 10 in decimal, B to 11, and so on up to F, which
    is 15.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中的颜色以十六进制而不是十进制指定。*十六进制*使用比十进制的10个数字多6个数字来表示数字。前10个数字与相同的0到9相同，但之后是A到F。十六进制中的A相当于十进制的10，B相当于11，依此类推，直到F，它是15。
- en: Decimal is a great system for 10-fingered organisms, but hexadecimal is better
    suited to computers. A single hexadecimal digit consumes four bits, called a *nibble*.
    Two hexadecimal digits require precisely eight bits, or one *byte*, making hexadecimal
    a convenient way to specify values for a `uint8`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制对于十指生物来说是一个很好的系统，但十六进制更适合计算机。一个十六进制数字消耗四个位，称为*nibble*。两个十六进制数字需要精确的八个位，即一个*字节*，这使得十六进制成为为`uint8`指定值的方便方式。
- en: The following table shows some hexadecimal numbers and their equivalent numbers
    in decimal.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了一些十六进制数及其等效的十进制数。
- en: Hexadecimal and decimal values
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 十六进制和十进制值
- en: '| Hexadecimal | Decimal |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 十进制 |'
- en: '| --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A | 10 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| A | 10 |'
- en: '| F | 15 |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| F | 15 |'
- en: '| 10 | 16 |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 16 |'
- en: '| FF | 255 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| FF | 255 |'
- en: 'To distinguish between decimal and hexadecimal, Go requires a `0x` prefix for
    hexadecimal. These two lines of code are equivalent:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要区分十进制和十六进制，Go需要十六进制的前缀`0x`。这两行代码是等效的：
- en: '[PRE22]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To display numbers in hexadecimal, you can use the `%x` or `%X` format verbs
    with `Printf`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要以十六进制显示数字，可以使用`Printf`中的`%x`或`%X`格式动词：
- en: '[PRE23]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Prints 0 8d d5**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0 8d d5**'
- en: 'To output a color that would feel at home in a .css file, the hexadecimal values
    need some padding. As with the `%v` and `%f` format verbs, you can specify a minimum
    number of digits (2) and zero padding with `%02x`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要输出在.css文件中感觉自然的颜色，十六进制值需要一些填充。与`%v`和`%f`格式动词一样，你可以指定最小位数（2位）并使用`%02x`进行零填充：
- en: '[PRE24]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Prints color: #008dd5;**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印颜色：#008dd5；**'
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 7.4**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查7.4**'
- en: '**[Q1:](#ch07qa8q0a1)**'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa8q0a1)**'
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many bytes are required to store a value of type `uint8`?
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 存储类型为`uint8`的值需要多少字节？
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 7.4 answer**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.4 答案**'
- en: '**[1:](#ch07qa7q1)**'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa7q1)**'
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An 8-bit (unsigned) integer only requires a single byte.
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8位（无符号）整数只需要一个字节。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3\. Integers wrap around
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 整数环绕
- en: 'Integers are free of the rounding errors that make floating-point inaccurate,
    but all integer types have a different problem: a limited range. When that range
    is exceeded, integer types in Go *wrap around*.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 整数没有使浮点数不准确的舍入错误，但所有整数类型都有不同的问题：范围有限。当超出该范围时，Go中的整数类型会*环绕*。
- en: An 8-bit unsigned integer (`uint8`) has a range of 0–255\. Incrementing beyond
    255 will wrap back to 0\. The following listing increments both signed and unsigned
    8-bit integers, causing them to wrap around.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 8 位无符号整数 (`uint8`) 的范围是 0-255。超过 255 的增量将回绕到 0。以下列表递增了有符号和无符号 8 位整数，导致它们回绕。
- en: 'Listing 7.2\. Integers wrap around: integers-wrap.go'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 整数环绕：integers-wrap.go
- en: '[PRE25]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Prints 0**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 0**'
- en: '***2* Prints –128**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 -128**'
- en: 7.3.1\. Looking at the bits
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 查看位
- en: To understand why integers wrap, take a look at the bits. The `%b` format verb
    will show you the bits for an integer value. Like other format verbs, `%b` can
    be zero padded to a minimum length, as you can see in this listing.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解整数为什么回绕，请查看位。`%b` 格式动词将显示整数值的位。像其他格式动词一样，`%b` 可以用零填充到最小长度，如本列表所示。
- en: 'Listing 7.3\. Display the bits: bits.go'
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 显示位：bits.go
- en: '[PRE26]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Prints 00000011**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 00000011**'
- en: '***2* Prints 00000100**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 00000100**'
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.5**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.5**'
- en: 'Use the Go Playground to experiment with the wrapping behavior of integers:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go Playground 来实验整数的包装行为：
- en: '**[1](#ch07qa10q0a1)**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch07qa10q0a1)**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [listing 7.2](#ch07ex02), the code increments `red` and `number` by 1\. What
    happens when you add a larger number to either variable?
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 [列表 7.2](#ch07ex02) 中，代码将 `red` 和 `number` 增加 1。当你向任一变量添加更大的数字时会发生什么？
- en: '**[2](#ch07qa10q0a2)**'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch07qa10q0a2)**'
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go the other way. What happens if you decrement `red` when it’s 0 or `number`
    when it’s equal to –128?
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 `red` 为 0 或 `number` 为 -128 时，递减会发生什么？
- en: '**[3](#ch07qa10q0a3)**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch07qa10q0a3)**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Wrapping applies to 16-bit, 32-bit, and 64-bit integers too. What happens if
    you declare a `uint16` assigned to the maximum value of 65535 and then increment
    it by 1?
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包装也适用于 16 位、32 位和 64 位整数。如果你声明一个赋值为 65535 的最大值的 `uint16`，然后加 1，会发生什么？
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 7.5 answer**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.5 答案**'
- en: '**[1](#ch07qa9q1)**'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch07qa9q1)**'
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**[2](#ch07qa9q2)**'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch07qa9q2)**'
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**[3](#ch07qa9q3)**'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch07qa9q3)**'
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints 1**'
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 1**'
- en: '***2* Prints -126**'
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 -126**'
- en: '***3* Prints 255**'
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 255**'
- en: '***4* Prints 127**'
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印 127**'
- en: '***5* Prints 0**'
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 打印 0**'
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The math package defines `math.MaxUint16` as 65535 and similar min/max constants
    for each architecture-independent integer type. Remember that `int` and `uint`
    could be either 32-bit or 64-bit, depending on the underlying hardware.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 数学包将 `math.MaxUint16` 定义为 65535，并为每个架构无关的整数类型定义了类似的 min/max 常量。记住，`int` 和 `uint`
    可能是 32 位或 64 位，这取决于底层硬件。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [listing 7.3](#ch07ex03), incrementing `green` causes the 1 to be carried,
    leaving zeros to the right. The result is `00000100` in binary, or 4 in decimal,
    as shown in [figure 7.1](#ch07fig01).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 7.3](#ch07ex03) 中，增加 `green` 导致 1 被进位，留下右边的零。结果是二进制的 `00000100`，或十进制的
    4，如图 [7.1](#ch07fig01) 所示。
- en: Figure 7.1\. Carrying the 1 in binary addition
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 二进制加法中的进位
- en: '![](07fig01.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01.jpg)'
- en: 'The same thing happens when incrementing 255, with one critical difference:
    with only eight bits available, the 1 that’s carried has nowhere to go, so the
    value of `blue` is left as 0, as shown in the next listing and illustrated in
    [figure 7.2](#ch07fig02).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当增加 255 时，也会发生相同的事情，但有一个关键的区别：只有八个位可用，所以被进位的 1 没有地方去，因此 `blue` 的值保持为 0，如图 [7.2](#ch07fig02)
    所示。
- en: 'Listing 7.4\. The bits when integers wrap: bits-wrap.go'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 整数环绕时的位：bits-wrap.go
- en: '[PRE30]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Prints 11111111**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 11111111**'
- en: '***2* Prints 00000000**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 00000000**'
- en: Figure 7.2\. Where should the carry go?
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 进位应该去哪里？
- en: '![](07fig02.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02.jpg)'
- en: Wrapping may be what you want in some situations, but not always. The simplest
    way to avoid wrapping is to use an integer type large enough to hold the values
    you expect to store.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，包装可能正是你想要的，但并不总是如此。避免包装的最简单方法是使用足够大的整数类型来存储你期望存储的值。
- en: '|  |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.6**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.6**'
- en: '**[Q1:](#ch07qa12q0a1)**'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa12q0a1)**'
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which format verb lets you look at the bits?
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个格式动词可以让你查看位？
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 7.6 answer**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.6 答案**'
- en: '**[1:](#ch07qa11q1)**'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa11q1)**'
- en: ''
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `%b` format verb outputs integers in base 2.
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`%b` 格式动词以二进制形式输出整数。'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.2\. Avoid wrapping around time
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 避免时间回绕
- en: On Unix-based operating systems, time is represented as the number of seconds
    since January 1, 1970 UTC (Coordinated Universal Time). In the year 2038, the
    number of seconds since January 1, 1970 will exceed two billion, the capacity
    of an `int32`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Unix 的操作系统上，时间表示为自 1970 年 1 月 1 日 UTC（协调世界时）以来的秒数。到 2038 年，自 1970 年 1 月
    1 日以来的秒数将超过 20 亿，这是 `int32` 的容量。
- en: Thankfully, `int64` can support dates well beyond 2038\. This is a situation
    where `int32` or `int` simply won’t do. Only the `int64` and `uint64` integer
    types are able to store numbers well beyond two billion on all platforms.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`int64` 可以支持远超过 2038 年的日期。在这种情况下，`int32` 或 `int` 简直无法胜任。只有 `int64` 和 `uint64`
    整数类型能够在所有平台上存储超过二十亿的数字。
- en: The code in [listing 7.5](#ch07ex05) uses the `Unix` function from the `time`
    package. It accepts two `int64` parameters, corresponding to the number of seconds
    and the number of nanoseconds since January 1, 1970\. Using a suitably large value
    (over 12 billion) demonstrates that dates beyond 2038 work just fine in Go.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.5](#ch07ex05) 中的代码使用了 `time` 包中的 `Unix` 函数。它接受两个 `int64` 参数，对应于自 1970
    年 1 月 1 日以来的秒数和纳秒数。使用一个足够大的值（超过 120 亿）可以证明在 Go 中日期超过 2038 年仍然可以正常工作。'
- en: 'Listing 7.5\. 64-bit integers: time.go'
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 64 位整数：time.go
- en: '[PRE31]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Prints 2370-01-01 00:00:00 +0000 UTC in the Go Playground**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 Go 操场中打印 2370-01-01 00:00:00 +0000 UTC**'
- en: '|  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 7.7**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 7.7**'
- en: '**[Q1:](#ch07qa14q0a1)**'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch07qa14q0a1)**'
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which integer type should you choose to avoid wrapping?
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该选择哪种整数类型来避免溢出？
- en: '|  |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 7.7 answer**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 7.7 答案**'
- en: '**[1:](#ch07qa13q1)**'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch07qa13q1)**'
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use an integer type large enough to hold the values you expect to store.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用足够大的整数类型来存储你期望存储的值。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The most common integer types are `int` and `uint`, but some situations call
    for smaller or larger types.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常见的整数类型是 `int` 和 `uint`，但有些情况下需要更小或更大的类型。
- en: Integer types need to be chosen carefully to avoid wrapping around, unless wrapping
    is what you want.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型需要仔细选择，以避免溢出，除非溢出是你想要的。
- en: You looked at 10 more of the 15 numeric types in Go (`int`, `int8`, `int16`,
    `int32`, `int64`, `uint`, `uint8`, `uint16`, `uint32`, `uint64`).
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经了解了 Go 中 15 种数字类型中的 10 种（`int`、`int8`、`int16`、`int32`、`int64`、`uint`、`uint8`、`uint16`、`uint32`、`uint64`）。
- en: Let’s see if you got this...
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: piggy.go'
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：piggy.go
- en: Write a new piggy bank program that uses integers to track the number of cents
    rather than dollars. Randomly place nickels (5¢), dimes (10¢), and quarters (25¢)
    into an empty piggy bank until it contains at least $20.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个新的猪储蓄罐程序，使用整数来跟踪美分而不是美元的数量。随机将五分镍币（5¢）、一角硬币（10¢）和二十五分硬币（25¢）放入空的猪储蓄罐中，直到它包含至少
    $20。
- en: Display the running balance of the piggy bank after each deposit in dollars
    (for example, $1.05).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次存款后显示猪储蓄罐的运行余额（例如，$1.05）。
- en: '|  |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to find the remainder of dividing two numbers, use modulus (`%`).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要找到两个数字相除的余数，请使用取模运算符（`%`）。
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 8\. Big numbers
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 课\. 大数
- en: After reading [lesson 8](#ch08), you’ll be able to
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第 8 课](#ch08) 之后，你将能够
- en: Save your zero key by specifying an exponent
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定指数来保存零键
- en: Use Go’s `big` package for really big numbers
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 的 `big` 包处理非常大的数字
- en: Use big constants and literal values
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大常量和字面值
- en: Computer programming is full of trade-offs. Floating-point types can store numbers
    of any size, but they lack precision and accuracy at times. Integers are accurate
    but have a limited range. What if you need a really big, accurate number? This
    lesson explores two alternatives to the native `float64` and `int` types.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机编程充满了权衡。浮点数类型可以存储任何大小的数字，但它们有时会缺乏精度和准确性。整数是准确的，但范围有限。如果你需要一个非常大且准确的数字怎么办？本课探讨了两种替代原生
    `float64` 和 `int` 类型的方案。
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: CPUs are optimized for integer and floating-point math, but other numeric representations
    are possible. When you need to go big, Go has you covered.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 优化了整数和浮点数数学，但其他数字表示也是可能的。当你需要处理大数时，Go 有你需要的支持。
- en: What are some situations where integers are too small, floating-point too imprecise,
    or another numeric type would be more suitable?
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些情况下整数太小，浮点数不够精确，或者另一种数字类型会更合适？
- en: '|  |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1\. Hitting the ceiling
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 达到上限
- en: If you haven’t realized it yet, 64-bit integers are mind-bogglingly big—much
    bigger than their 32-bit counterparts.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到，64 位整数非常巨大——比它们的 32 位对应物大得多。
- en: 'For some perspective, the nearest star, Alpha Centauri, is 41.3 trillion kilometers
    away. A trillion: that’s one followed by 12 zeros, or 10^(12). Rather than painstakingly
    typing every zero, you can write such numbers in Go with an exponent, like so:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一些视角，最近的恒星，半人马座阿尔法星，距离我们 41.3 万亿公里。万亿：这是一个后面跟着 12 个零的数字，或者 10^(12)。你不需要费力地输入每个零，你可以在
    Go 中使用指数来表示这样的数字，如下所示：
- en: '[PRE32]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: An `int32` or `uint32` can’t contain such a large number, but an `int64` doesn’t
    break a sweat. Now you can go about your business, perhaps calculating how many
    days it would take to travel to Alpha Centauri, a task tackled in the following
    listing.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`int32`或`uint32`无法包含如此大的数字，但`int64`并不费力。现在你可以继续你的业务，也许计算一下到达半人马座α星需要多少天，这个任务将在下面的列表中解决。'
- en: 'Listing 8.1\. Days to Alpha Centauri: alpha.go'
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1. 到半人马座α星需要的天数：alpha.go
- en: '[PRE33]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Prints Alpha Centauri is 41300000000000 km away**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印半人马座α星距离41300000000000公里。**'
- en: '***2* Prints That is 1594 days of travel at light speed**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印这是以光速旅行1594天。**'
- en: 'As big as 64-bit integers are, there’s something bigger: space. The Andromeda
    Galaxy is 24 quintillion (10^(18)) kilometers away. Even the largest unsigned
    integer (`uint64`) can only contain numbers up to 18 quintillion. Attempting to
    declare a variable beyond 18 quintillion reports an overflow error:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 即使64位整数很大，还有更大的东西：空间。仙女座星系距离我们24千万亿（10^(18)）公里。即使是最大的无符号整数（`uint64`）也只能包含高达18千万亿的数量。尝试声明一个超过18千万亿的变量会报告溢出错误：
- en: '[PRE34]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* 24000000000000000000 overflows uint64**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 24000000000000000000超过uint64的容量**'
- en: But don’t panic—there are still a few options. You could use floating-point
    math. That’s not a bad idea, and you already know how floating-point works. But
    there’s another way. The next section takes a look at Go’s `big` package.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 但别慌——还有一些选择。你可以使用浮点数数学。这并不是一个坏主意，你已经知道浮点数是如何工作的。但还有另一种方法。下一节将探讨Go的`big`包。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If a variable doesn’t have an explicit type, Go will infer `float64` for numbers
    containing exponents.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个变量没有显式的类型，Go将为包含指数的数字推断`float64`。
- en: '|  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.1**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.1**'
- en: '**[Q1:](#ch08qa2q0a1)**'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa2q0a1)**'
- en: ''
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The distance between Mars and Earth ranges from 56,000,000 km to 401,000,000
    km. Express these two values as integers with the exponent (`e`) syntax.
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 火星与地球之间的距离在5600万公里到4010万公里之间。使用指数（`e`）语法将这些两个值表示为整数。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 8.1 answer**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.1 答案**'
- en: '**[1:](#ch08qa1q1)**'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa1q1)**'
- en: ''
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|  |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.2\. The big package
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 大包
- en: 'The `big` package provides three types:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`big`包提供了三种类型：'
- en: '`big.Int` is for big integers, when 18 quintillion isn’t enough.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`big.Int`用于大整数，当18千万亿不够用时。'
- en: '`big.Float` is for arbitrary-precision floating-point numbers.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`big.Float`用于任意精度的浮点数。'
- en: '`big.Rat` is for fractions like ⅓.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`big.Rat`用于分数，如1/3。'
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Your code can declare new types too, but we’ll come back to that in [lesson
    13](kindle_split_024.html#ch13).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码也可以声明新的类型，但我们在第13课（[kindle_split_024.html#ch13]）再回到这个话题。
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `big.Int` type can happily store and operate on the distance to Andromeda
    Galaxy, a mere 24 quintillion kilometers.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`big.Int`类型可以愉快地存储和操作到仙女座星系的距离，仅仅24千万亿公里。'
- en: 'Opting to use `big.Int` requires that you use it for everything in your equation,
    even the constants you had before. The `NewInt` function takes an `int64` and
    returns a `big.Int`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用`big.Int`要求你在方程中的所有地方都使用它，甚至包括你之前有的常数。`NewInt`函数接受一个`int64`并返回一个`big.Int`：
- en: '[PRE36]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`NewInt` isn’t going to help for a number like 24 quintillion. It won’t fit
    in an `int64`, so instead you can create a `big.Int` from a `string`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewInt`对于像24千万亿这样的数字没有帮助。它不会适合在`int64`中，所以你可以从字符串创建一个`big.Int`：'
- en: '[PRE37]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After creating a new `big.Int`, set its value to 24 quintillion by calling the
    `SetString` method. The number 24 quintillion is in base 10 (decimal), so the
    second argument is 10.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`big.Int`后，通过调用`SetString`方法将其值设置为24千万亿。24千万亿这个数字是以10（十进制）为基数的，所以第二个参数是10。
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Methods are similar to functions. You’ll learn all about them in [lesson 13](kindle_split_024.html#ch13).
    The `new` built-in function is for pointers, which are covered in [lesson 26](kindle_split_040.html#ch26).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与函数类似。你将在第13课（[kindle_split_024.html#ch13]）中了解所有关于它们的内容。`new`内置函数用于指针，这在第26课（[kindle_split_040.html#ch26]）中有介绍。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With all the values in place, the `Div` method performs the necessary division
    so the result can be displayed, as shown in the following listing.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有值就绪后，`Div`方法执行必要的除法，以便结果可以显示，如下面的列表所示。
- en: 'Listing 8.2\. Days to Andromeda Galaxy: andromeda.go'
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2. 到仙女座星系的距离：andromeda.go
- en: '[PRE38]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Prints Andromeda Galaxy is 24000000000000000000 km away.**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印仙女座星系距离24000000000000000000公里。**'
- en: '***2* Prints That is 926568346 days of travel at light speed.**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印这是以光速旅行926568346天。**'
- en: As you can see, these big types are more cumbersome to work with than the native
    `int` and `float64` types. They’re also slower. Those are the trade-offs for being
    able to accurately represent numbers of any size.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这些大型类型与原生的`int`和`float64`类型相比，更难以处理。它们也运行得更慢。这是为了能够准确表示任何大小的数字所做出的权衡。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 8.2**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.2**'
- en: '**[Q1:](#ch08qa4q0a1)**'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa4q0a1)**'
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are two ways to make a `big.Int` with the number 86,400?
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有两种方法可以创建包含数字86,400的`big.Int`？
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 8.2 answer**'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.2 答案**'
- en: '**[1:](#ch08qa3q1)**'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa3q1)**'
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Construct a `big.Int` with the `NewInt` function:'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`NewInt`函数构建`big.Int`：
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Or use the `SetString` method:'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 或者使用`SetString`方法：
- en: ''
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.3\. Constants of unusual size
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 不寻常大小的常量
- en: 'Constants can be declared with a type, just like variables. And just like variables,
    a `uint64` constant can’t possibly contain a number like 24 quintillion:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 常量可以像变量一样声明类型。就像变量一样，一个`uint64`常量不可能包含像24千兆这样的数字：
- en: '[PRE41]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Constant 24000000000000000000 overflows uint64**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 常量24000000000000000000溢出uint64**'
- en: 'It gets interesting when you declare a constant without a type. For variables,
    Go uses type inference to determine the type, and in the case of 24 quintillion,
    overflows the `int` type. Constants are different. Rather than infer a type, constants
    can be *untyped*. The following line doesn’t cause an overflow error:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个没有类型的常量时，事情变得有趣。对于变量，Go使用类型推断来确定类型，在24千兆的情况下，会溢出`int`类型。常量是不同的。常量不是推断类型，而是可以是*未类型化的*。以下行不会引发溢出错误：
- en: '[PRE42]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Constants are declared with the `const` keyword, but every literal value in
    your program is a constant too. That means unusually sized numbers can be used
    directly, as shown in the following listing.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 常量使用`const`关键字声明，但你的程序中的每个字面量值也是一个常量。这意味着可以直接使用不寻常大小的数字，如下所示。
- en: '![](f0066-01.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](f0066-01.jpg)'
- en: 'Listing 8.3\. Literals of unusual size: constant.go'
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 不寻常大小的字面量：constant.go
- en: '[PRE43]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Prints Andromeda Galaxy is 926568346 light days away.**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印仙女座星系距离为926568346光日。**'
- en: Calculations on constants and literals are performed during compilation rather
    than while the program is running. The Go compiler is written in Go. Under the
    hood, untyped numeric constants are backed by the `big` package, enabling all
    the usual operations with numbers well beyond 18 quintillion, as shown in the
    following listing.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和字面量的计算是在编译期间而不是在程序运行时进行的。Go编译器是用Go编写的。在底层，未类型化的数值常量由`big`包支持，使得可以进行所有常规操作，包括超过18千兆的数字，如下所示。
- en: 'Listing 8.4\. Constants of unusual size: constant.go'
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 不寻常大小的常量：constant.go
- en: '[PRE44]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Prints Andromeda Galaxy is 926568346 light days away.**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印仙女座星系距离为926568346光日。**'
- en: 'Constant values can be assigned to variables so long as they fit. An `int`
    can’t contain 24 quintillion, but 926,568,346 fits just fine:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 只要适合，常量值可以分配给变量。`int`不能包含24千兆，但926,568,346可以很好地放入：
- en: '[PRE45]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Constant 24000000000000000000 overflows int.**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 常量24000000000000000000溢出int。**'
- en: '***2* 926568346 fits into an int.**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 926568346可以放入int中。**'
- en: 'There’s a caveat to constants of unusual size. Though the Go compiler utilizes
    the `big` package for untyped numeric constants, constants and `big.Int` values
    aren’t interchangeable. [Listing 8.2](#ch08ex02) displayed a `big.Int` containing
    24 quintillion, but you can’t display the `distance` constant due to an overflow
    error:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不寻常大小的常量有一些注意事项。尽管Go编译器利用`big`包来处理未类型化的数值常量，但常量和`big.Int`值并不是可互换的。[列表8.2](#ch08ex02)显示了一个包含24千兆的`big.Int`，但你不能显示`distance`常量，因为会引发溢出错误：
- en: '[PRE46]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Constant 24000000000000000000 overflows int.**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 常量24000000000000000000溢出int。**'
- en: Very large constants are certainly useful, but they aren’t a replacement for
    the `big` package.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 非常大的常量当然很有用，但它们不能替代`big`包。
- en: '|  |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 8.3**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.3**'
- en: '**[Q1:](#ch08qa6q0a1)**'
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch08qa6q0a1)**'
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When are calculations on constants and literals performed?
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 常量和字面量的计算何时进行？
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 8.3 answer**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 8.3 答案**'
- en: '**[1:](#ch08qa5q1)**'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch08qa5q1)**'
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Go compiler simplifies equations containing constants and literals during
    compilation.
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go编译器在编译过程中会简化包含常量和字面量的等式。
- en: '|  |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: When the native types can’t go the distance, the `big` package has you covered.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当原生类型无法满足需求时，`big`包为你提供了保障。
- en: Big things are possible with constants that are untyped, and all numeric literals
    are untyped constants too.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未类型化的常量，可以实现大事，而且所有数值字面量也是未类型化的常量。
- en: Untyped constants must be converted to typed variables when passed to functions.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无类型常量在传递给函数时必须转换为有类型变量。
- en: Let’s see if you got this...
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: canis.go'
  id: totrans-547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：canis.go
- en: Canis Major Dwarf is the closest known galaxy to Earth at 236,000,000,000,000,000
    km from our Sun (though some dispute that it is a galaxy). Use constants to convert
    this distance to light years.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 大犬座矮星系是距离我们太阳最近的已知星系，距离为236,000,000,000,000,000公里（尽管有些人争论它是否是一个星系）。使用常量将这个距离转换为光年。
- en: Lesson 9\. Multilingual text
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9课. 多语言文本
- en: After reading [lesson 9](#ch09), you’ll be able to
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第9课](#ch09)后，你将能够
- en: Access and manipulate individual letters
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和操作单个字母
- en: Cipher and decipher secret messages
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密和解密秘密信息
- en: Write your programs for a multilingual world
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多语言世界编写你的程序
- en: From `"Hello, playground"` at the beginning, you’ve been using text in your
    programs. The individual letters, digits, and symbols are called *characters*.
    When you *string* together characters and place them between quotes, it’s called
    a *literal string*.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 从“Hello, playground”开始，你一直在你的程序中使用文本。单个字母、数字和符号被称为*字符*。当你将字符*连接*在一起并将它们放在引号之间时，它被称为*字面字符串*。
- en: '![](f0068-01.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](f0068-01.jpg)'
- en: '|  |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You know computers represent numbers with 1s and 0s. If you were a computer,
    how would you represent the alphabet and human language?
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道计算机用1和0表示数字。如果你是一台计算机，你会如何表示字母表和人类语言？
- en: If you said with numbers, you’re right. Characters of the alphabet have numeric
    values, which means you can manipulate them like numbers.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说是用数字，你是对的。字母表的字符有数值，这意味着你可以像操作数字一样操作它们。
- en: It’s not entirely straightforward, though. The characters from every written
    language and countless emoji add up to thousands of characters. There are some
    tricks to representing text in a space-efficient and flexible manner.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非完全直接，但每个书写语言的字符和无数的emoji加起来有数千个字符。有一些技巧可以以空间高效和灵活的方式表示文本。
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.1\. Declaring string variables
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 声明字符串变量
- en: 'Literal values wrapped in quotes are inferred to be of the type `string`, so
    the following three lines are equivalent:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 用引号包裹的字面值被推断为`string`类型，所以以下三行是等效的：
- en: '[PRE47]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you declare a variable without providing a value, it will be initialized
    with the zero value for its type. The *zero value* for the `string` type is an
    empty string (`""`):'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个变量而没有提供值，它将使用其类型的零值初始化。`string`类型的*零值*是一个空字符串（`""`）：
- en: '[PRE48]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 9.1.1\. Raw string literals
  id: totrans-567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 原始字符串字面量
- en: String literals may contain *escape sequences*, such as the `\n` mentioned in
    [lesson 2](kindle_split_011.html#ch02). To avoid substituting `\n` for a new line,
    you can wrap text in backticks (`) instead of quotes (`"`), as shown in the following
    listing. Backticks indicate a *raw* string literal.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可能包含*转义序列*，如[第2课](kindle_split_011.html#ch02)中提到的`\n`。为了避免将`\n`替换为新行，你可以用反引号（`）而不是引号（`"`）包裹文本，如下面的列表所示。反引号表示*原始*字符串字面量。
- en: 'Listing 9.1\. Raw string literals: raw.go'
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1. 原始字符串字面量：raw.go
- en: '[PRE49]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous listing displays this output:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的列表显示了以下输出：
- en: '[PRE50]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unlike conventional string literals, raw string literals can span multiple lines
    of source code, as shown in the next listing.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的字符串字面量不同，原始字符串字面量可以跨越多行源代码，如下一个列表所示。
- en: 'Listing 9.2\. Multiple-line raw string literals: raw-lines.go'
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2. 多行原始字符串字面量：raw-lines.go
- en: '[PRE51]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Running [listing 9.2](#ch09ex02) will produce the following output, including
    the tabs used for indentation:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[列表9.2](#ch09ex02)将产生以下输出，包括用于缩进的制表符：
- en: '[PRE52]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Literal strings and raw strings both result in strings, as the following listing
    shows.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如下列表所示，字面字符串和原始字符串都产生字符串。
- en: 'Listing 9.3\. String type: raw-type.go'
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3. 字符串类型：raw-type.go
- en: '[PRE53]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Prints literal string is a string**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印字面字符串是字符串**'
- en: '***2* Prints raw string literal is a string**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印原始字符串字面量是字符串**'
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.1**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查9.1**'
- en: '**[Q1:](#ch09qa2q0a1)**'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa2q0a1)**'
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the Windows file path `C:\go`, would you use a string literal or a raw string
    literal, and why?
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于Windows文件路径`C:\go`，你会使用字符串字面量还是原始字符串字面量，为什么？
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.1 answer**'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.1 答案**'
- en: '**[1:](#ch09qa1q1)**'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa1q1)**'
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use a raw string literal `` `C:\go` `` because `"C:\go"` fails with an unknown
    escape sequence error.
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量`` `C:\go` ``，因为`"C:\go"`会因为未知转义序列错误而失败。
- en: '|  |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.2\. Characters, code points, runes, and bytes
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 字符、码点、符文和字节
- en: The Unicode Consortium assigns numeric values, called *code points*, to over
    one million unique characters. For example, 65 is the code point for the capital
    letter A, and 128515 is a smiley face ![](smile.jpg).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 联盟为超过一百万个独特的字符分配了数字值，称为 *码点*。例如，65 是大写字母 A 的码点，128515 是一个笑脸 ![](smile.jpg)。
- en: To represent a single Unicode code point, Go provides `rune`, which is an alias
    for the `int32` type.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示单个 Unicode 码点，Go 提供了 `rune`，它是 `int32` 类型的别名。
- en: A `byte` is an alias for the `uint8` type. It’s intended for binary data, though
    `byte` can be used for English characters defined by ASCII, an older 128-character
    subset of Unicode.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` 是 `uint8` 类型的别名。它旨在用于二进制数据，尽管 `byte` 可以用于由 ASCII 定义的英语字符，ASCII 是 Unicode
    的一个较老的 128 个字符子集。'
- en: '|  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Type aliases**'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名**'
- en: 'An alias is another name for the same type, so `rune` and `int32` are interchangeable.
    Though `byte` and `rune` have been in Go from the beginning, Go 1.9 introduced
    the ability to declare your own type aliases. The syntax looks like this:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是同一类型的另一个名称，因此 `rune` 和 `int32` 可以互换。尽管 `byte` 和 `rune` 从 Go 的开始就存在了，但 Go
    1.9 引入了声明自己的类型别名的功能。语法如下所示：
- en: '[PRE54]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Both `byte` and `rune` behave like the integer types they are aliases for, as
    shown in the following listing.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` 和 `rune` 的行为与它们所代表的整数类型相同，如下所示。'
- en: 'Listing 9.4\. `rune` and `byte`: rune.go'
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. `rune` 和 `byte`：rune.go
- en: '[PRE55]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Prints 960 940 969 33**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 960 940 969 33**'
- en: 'To display the characters rather than their numeric values, the `%c` format
    verb can be used with `Printf`:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示字符而不是它们的数值，可以使用 `%c` 格式说明符与 `Printf` 一起使用：
- en: '[PRE56]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Prints πάω!**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 πάω!**'
- en: '|  |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Any integer type will work with `%c`, but the `rune` alias indicates that the
    number 960 represents a character.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 任何整数类型都可以与 `%c` 一起使用，但 `rune` 别名表明数字 960 代表一个字符。
- en: '|  |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Rather than memorize Unicode code points, Go provides a character literal.
    Just enclose a character in single quotes `''A''`. If no type is specified, Go
    will infer a `rune`, so the following three lines are equivalent:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 与记住 Unicode 码点相比，Go 提供了字符字面量。只需将字符用单引号 `'A'` 括起来即可。如果没有指定类型，Go 将推断为 `rune`，因此以下三行是等效的：
- en: '[PRE57]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `grade` variable still contains a numeric value, in this case 65, the code
    point for a capital `''A''`. Character literals can also be used with the `byte`
    alias:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '`grade` 变量仍然包含一个数值，在这种情况下是 65，即大写 `''A''` 的码点。字符字面量也可以与 `byte` 别名一起使用：'
- en: '[PRE58]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.2**'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.2**'
- en: '**[1](#ch09qa4q0a1)**'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa4q0a1)**'
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many characters does ASCII encode?
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ASCII 编码了多少个字符？
- en: '**[2](#ch09qa4q0a2)**'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa4q0a2)**'
- en: ''
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What type is `byte` an alias for? What about `rune`?
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`byte` 是哪种类型的别名？`rune` 呢？'
- en: '**[3](#ch09qa4q0a3)**'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch09qa4q0a3)**'
- en: ''
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the code points for an asterisk (`*`), a smiley ![](smile.jpg), and
    an acute é?
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 破折号 (`*`)、笑脸 ![](smile.jpg) 和重音符号 é 的码点是什么？
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 9.2 answer**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.2 答案**'
- en: '**[1](#ch09qa3q1)**'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa3q1)**'
- en: ''
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 128 characters.
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 128 个字符。
- en: '**[2](#ch09qa3q2)**'
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa3q2)**'
- en: ''
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A `byte` is an alias for the `uint8` type. A `rune` is an alias for the `int32`
    type.
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`byte` 是 `uint8` 类型的别名。`rune` 是 `int32` 类型的别名。'
- en: '**[3](#ch09qa3q3)**'
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch09qa3q3)**'
- en: ''
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***2* Prints * 42**'
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 * 42**'
- en: '***2* Prints** ![](smile.jpg) **128515**'
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印** ![](smile.jpg) **128515**'
- en: '***3* Prints é 233**'
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印 é 233**'
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3\. Pulling the strings
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 拉动字符串
- en: 'A puppeteer manipulates a marionette by pulling on strings, but strings in
    Go aren’t susceptible to manipulation. A variable can be assigned to a different
    string, but strings themselves can’t be altered:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 提线木偶师通过拉动线来操纵木偶，但 Go 中的字符串并不容易受到操纵。可以将变量分配给不同的字符串，但字符串本身不能被更改：
- en: '[PRE60]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Your program can access individual characters, but it can’t alter the characters
    of a string. The following listing uses square brackets `[]` to specify an index
    into a string, which accesses a single byte (ASCII character). The index starts
    from zero.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序可以访问单个字符，但不能修改字符串中的字符。以下列表使用方括号 `[]` 来指定字符串的索引，它访问单个字节（ASCII 字符）。索引从零开始。
- en: 'Listing 9.5\. Indexing into a string: index.go'
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 字符串索引：index.go
- en: '[PRE61]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Prints m**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 m**'
- en: 'Strings in Go are *immutable*, as they are in Python, Java, and JavaScript.
    Unlike strings in Ruby and character arrays in C, you can’t modify a string in
    Go:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的字符串是 *不可变的*，就像 Python、Java 和 JavaScript 中的字符串一样。与 Ruby 中的字符串和 C 中的字符数组不同，你无法在
    Go 中修改字符串：
- en: '[PRE62]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Cannot assign to message[5]**'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无法分配给消息[5]**'
- en: '|  |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 9.3**'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.3**'
- en: '**[Q1:](#ch09qa6q0a1)**'
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa6q0a1)**'
- en: ''
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program to print each byte (ASCII character) of `"shalom"`, one character
    per line.
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序来打印`"shalom"`字符串的每个字节（ASCII字符），每行一个字符。
- en: '|  |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.3 answer**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.3 答案**'
- en: '**[1:](#ch09qa5q1)**'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa5q1)**'
- en: ''
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.4\. Manipulating characters with Caesar cipher
  id: totrans-669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 使用凯撒密码操作字符
- en: 'One effective method of sending secret messages in the second century was to
    shift every letter, so `''a''` becomes `''d''`, `''b''` becomes `''e''`, and so
    on. The result might pass for a foreign language:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在公元2世纪，发送秘密信息的一种有效方法是将每个字母都进行位移，所以`'a'`变成`'d'`，`'b'`变成`'e'`，以此类推。结果可能看起来像外语：
- en: '*L fdph, L vdz, L frqtxhuhg.*'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*L fdph, L vdz, L frqtxhuhg.*'
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Julius Caesar*'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尤利乌斯·凯撒*'
- en: It turns out that manipulating characters as numeric values is really easy with
    computers, as shown in the following listing.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，使用计算机操作字符作为数值是非常容易的，如下面的列表所示。
- en: '![](f0073-01.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![](f0073-01.jpg)'
- en: 'Listing 9.6\. Manipulate a single character: caesar.go'
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 操作单个字符：caesar.go
- en: '[PRE64]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Prints d**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印d**'
- en: 'The code in [listing 9.6](#ch09ex06) has one problem, though. It doesn’t account
    for all the messages about xylophones, yaks, and zebras. To address this need,
    the original Caesar cipher wraps around, so `''x''` becomes `''a''`, `''y''` becomes
    `''b''`, and `''z''` becomes `''c''`. With 26 characters in the English alphabet,
    it’s a simple matter:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6中的代码有一个问题。它没有考虑到所有关于xylophones、yaks和zebras的消息。为了满足这一需求，原始的凯撒密码会回绕，所以`'x'`变成`'a'`，`'y'`变成`'b'`，`'z'`变成`'c'`。由于英语字母表中有26个字母，这是一个简单的问题：
- en: '[PRE65]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To *decipher* this Caesar cipher, subtract 3 instead of adding 3\. But then
    you need to account for `c < 'a'` by adding 26\. What a pain.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密这个凯撒密码，应该减去3而不是加3。但是，你需要考虑到`c < 'a'`的情况，通过加26来处理。真麻烦。
- en: '|  |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.4**'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查9.4**'
- en: '**[Q1:](#ch09qa8q0a1)**'
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch09qa8q0a1)**'
- en: ''
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the result of the expression `c = c - 'a' + 'A'` if `c` is a lowercase
    `'g'`?
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`c`是小写字母`'g'`，表达式`c = c - 'a' + 'A'`的结果是什么？
- en: '|  |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.4 answer**'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.4 答案**'
- en: '**[1:](#ch09qa7q1)**'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch09qa7q1)**'
- en: ''
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The letter is converted to uppercase:'
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字母被转换为大写：
- en: ''
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ''
  id: totrans-695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints G**'
  id: totrans-696
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印G**'
- en: '|  |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.4.1\. A modern variant
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 一种现代变体
- en: 'ROT13 (rotate 13) is a 20th century variant of Caesar cipher. It has one difference:
    it adds 13 instead of 3\. With ROT13, ciphering and deciphering are the same convenient
    operation.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13（旋转13）是20世纪的一种凯撒密码变体。它有一个区别：它加13而不是3。使用ROT13，加密和解密是同一个方便的操作。
- en: 'Let’s suppose, while scanning the heavens for alien communications, the SETI
    Institute received a transmission with the following message:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在扫描天空中寻找外星通讯的过程中，SETI研究所接收到了以下信息的传输：
- en: '[PRE67]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We suspect this `message` is actually English text that was ciphered with ROT13\.
    Call it a hunch. Before you can crack the code, there’s one more thing you need
    to know. This `message` is 30 characters long, which can be determined with the
    built-in `len` function:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怀疑这条`message`实际上是用ROT13加密的英文文本。姑且称之为一种直觉。在你能够破解这个密码之前，还有一件事你需要知道。这条`message`长度为30个字符，这可以通过内置的`len`函数来确定：
- en: '[PRE68]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Prints 30**'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印30**'
- en: '|  |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Go has a handful of built-in functions that don’t require an import statement.
    The `len` function can determine the length for a variety of types. In this case,
    `len` returns the length of a `string` in bytes.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一系列内置函数，不需要导入语句。`len`函数可以确定各种类型的长度。在这种情况下，`len`返回字符串的字节长度。
- en: '|  |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following listing will decipher a message from space. Run it in the Go Playground
    to find out what the aliens are saying.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表将解密来自太空的信息。在Go游乐场中运行它，以找出外星人说了什么。
- en: 'Listing 9.7\. ROT13 cipher: rot13.go'
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. ROT13密码：rot13.go
- en: '[PRE69]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Iterates through each ASCII character**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历每个ASCII字符**'
- en: '***2* Leaves spaces and punctuation as they are**'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 保持空格和标点符号不变**'
- en: Note that the ROT13 implementation in the previous listing is only intended
    for ASCII characters (bytes). It will get confused by a message written in Spanish
    or Russian. The next section looks at a solution for this issue.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面列表中的ROT13实现仅适用于ASCII字符（字节）。它会在西班牙语或俄语的消息中产生混淆。下一节将探讨解决这个问题的方法。
- en: '|  |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.5**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查9.5**'
- en: '**[1](#ch09qa10q0a1)**'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa10q0a1)**'
- en: ''
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the built-in `len` function do when passed a string?
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当内置的`len`函数传递一个字符串时，它会做什么？
- en: '**[2](#ch09qa10q0a2)**'
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa10q0a2)**'
- en: ''
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Type [listing 9.7](#ch09ex07) into the Go Playground. What does the message
    say?
  id: totrans-722
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将[列表9.7](#ch09ex07)输入到Go游乐场。这条信息说了什么？
- en: '|  |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.5 answer**'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.5 答案**'
- en: '**[1](#ch09qa9q1)**'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa9q1)**'
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `len` function returns the length of a string in bytes.
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len` 函数返回字符串的字节长度。'
- en: '**[2](#ch09qa9q2)**'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa9q2)**'
- en: ''
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: hi international space station
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: hi 国际空间站
- en: '|  |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.5\. Decoding strings into runes
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 将字符串解码为符文
- en: Strings in Go are encoded with UTF-8, one of several encodings for Unicode code
    points. UTF-8 is an efficient variable length encoding where a single code point
    may use 8 bits, 16 bits, or 32 bits. By using a variable length encoding, UTF-8
    makes the transition from ASCII straightforward, because ASCII characters are
    identical to their UTF-8 encoded counterparts.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的字符串使用 UTF-8 编码，这是 Unicode 代码点的几种编码之一。UTF-8 是一种有效的可变长度编码，其中单个代码点可能使用 8 位、16
    位或 32 位。通过使用可变长度编码，UTF-8 使得从 ASCII 到 UTF-8 的转换变得简单，因为 ASCII 字符与其 UTF-8 编码的对应字符相同。
- en: '|  |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: UTF-8 is the dominant character encoding for the World Wide Web. It was invented
    in 1992 by Ken Thompson, one of the designers of Go.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是万维网占主导地位的字符编码。它由 Go 的设计者之一 Ken Thompson 在 1992 年发明。
- en: '|  |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The ROT13 program in [listing 9.7](#ch09ex07) accessed the individual bytes
    (8-bit) of the `message` string without accounting for characters that are multiple
    bytes long (16-bit or 32-bit). This is why it works fine for English characters
    (ASCII), but produces garbled results for Russian and Spanish. You can do better,
    *amigo*.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.7](#ch09ex07) 中的 ROT13 程序访问了 `message` 字符串的各个字节（8 位），而没有考虑到多字节字符（16 位或
    32 位）。这就是为什么它对英语字符（ASCII）工作得很好，但对于俄语和西班牙语会产生混乱的结果。你可以做得更好，*朋友*。'
- en: The first step to supporting other languages is to decode characters to the
    `rune` type before manipulating them. Fortunately, Go has functions and language
    features for decoding UTF-8 encoded strings.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 支持其他语言的第一步是在操作之前将字符解码为 `rune` 类型。幸运的是，Go 提供了解码 UTF-8 编码字符串的函数和语言特性。
- en: The `utf8` package provides functions to determine the length of a string in
    runes rather than bytes and to decode the first character of a string. The `DecodeRuneInString`
    function returns the first character and the number of bytes the character consumed,
    as shown in [listing 9.8](#ch09ex08).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`utf8` 包提供了确定字符串在符文长度而不是字节长度以及解码字符串的第一个字符的函数。`DecodeRuneInString` 函数返回第一个字符和该字符消耗的字节数，如
    [列表 9.8](#ch09ex08) 所示。'
- en: '|  |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike many programming languages, functions in Go can return multiple values.
    Multiple return values are discussed in [lesson 12](kindle_split_023.html#ch12).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多编程语言不同，Go 中的函数可以返回多个值。多个返回值将在第 12 节中讨论。
- en: '|  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Listing 9.8\. The `utf8` package: spanish.go'
  id: totrans-746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. `utf8` 包：spanish.go
- en: '[PRE70]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Prints 15 bytes**'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 15 个字节**'
- en: '***2* Prints 12 runes**'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 12 个符文**'
- en: '***3* Prints First rune: ¿ 2 bytes**'
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印第一个符文：¿ 2 个字节**'
- en: The Go language provides the `range` keyword to iterate over a variety of collections
    (covered in [unit 4](kindle_split_027.html#part05)). It can also decode UTF-8
    encoded strings, as shown in the following listing.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言提供了 `range` 关键字来遍历各种集合（在第 4 单元中介绍）。它还可以解码 UTF-8 编码的字符串，如下所示。
- en: 'Listing 9.9\. Decoding runes: spanish-range.go'
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 解码符文：spanish-range.go
- en: '[PRE71]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: On each iteration, the variables `i` and `c` are assigned to an index into the
    string and the code point (`rune`) at that position.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，变量 `i` 和 `c` 被分配给字符串中的索引和该位置的代码点（符文）。
- en: 'If you don’t need the index, the blank identifier (an underscore) allows you
    to ignore it:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要索引，空白标识符（下划线）允许您忽略它：
- en: '[PRE72]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Prints ¿ C ó m o e s t á s ?**'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 ¿ C ó m o e s t á s ?**'
- en: '|  |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 9.6**'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 9.6**'
- en: '**[1](#ch09qa12q0a1)**'
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa12q0a1)**'
- en: ''
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many runes are in the English alphabet `"abcdefghijklmnopqrstuvwxyz"`? How
    many bytes?
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 英语字母表 `"abcdefghijklmnopqrstuvwxyz"` 中有多少个符文？有多少个字节？
- en: '**[2](#ch09qa12q0a2)**'
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa12q0a2)**'
- en: ''
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many bytes are in the rune `'¿'`?
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符文 `'¿'` 中有多少个字节？
- en: '|  |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 9.6 answer**'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 9.6 答案**'
- en: '**[1](#ch09qa11q1)**'
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch09qa11q1)**'
- en: ''
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are 26 runes and 26 bytes in the English alphabet.
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 英语字母表中包含 26 个符文和 26 个字节。
- en: '**[2](#ch09qa11q2)**'
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch09qa11q2)**'
- en: ''
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are 2 bytes in the rune `'¿'`.
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符文 `'¿'` 中有 2 个字节。
- en: '|  |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Escape sequences like `\n` are ignored in raw string literals (`).
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始字符串字面量（`'`）中，转义序列如 `\n` 被忽略。
- en: Strings are immutable. Individual characters can be accessed but not altered.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的。可以访问单个字符，但不能更改。
- en: Strings use a variable length encoding called UTF-8, where each character consumes
    1–4 bytes.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串使用一种称为 UTF-8 的可变长度编码，其中每个字符占用 1-4 个字节。
- en: A `byte` is an alias for the `uint8` type, and `rune` is an alias for the `int32`
    type.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 是 `uint8` 类型的别名，而 `rune` 是 `int32` 类型的别名。'
- en: The `range` keyword can decode a UTF-8 encoded string into runes.
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` 关键字可以将 UTF-8 编码的字符串解码为 runes。'
- en: Let’s see if you got this...
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这一点...
- en: 'Experiment: caesar.go'
  id: totrans-783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：caesar.go
- en: 'Decipher the quote from Julius Caesar:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 解密朱利叶斯·凯撒的引言：
- en: '*L fdph, L vdz, L frqtxhuhg.*'
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*L fdph, L vdz, L frqtxhuhg.*'
- en: ''
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Julius Caesar*'
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**朱利叶斯·凯撒**'
- en: Your program will need to shift uppercase and lowercase letters by –3\. Remember
    that `'a'` becomes `'x'`, `'b'` becomes `'y'`, and `'c'` becomes `'z'`, and likewise
    for uppercase letters.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序需要将大写和小写字母向左或向右移动 -3 位。记住，`'a'` 变成 `'x'`，`'b'` 变成 `'y'`，`'c'` 变成 `'z'`，同样适用于大写字母。
- en: 'Experiment: international.go'
  id: totrans-789
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：international.go
- en: Cipher the Spanish message “Hola Estación Espacial Internacional” with ROT13\.
    Modify [listing 9.7](#ch09ex07) to use the `range` keyword. Now when you use ROT13
    on Spanish text, characters with accents are preserved.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ROT13 对西班牙语信息“Hola Estación Espacial Internacional”进行加密。修改[列表 9.7](#ch09ex07)以使用`range`关键字。现在当你对西班牙语文本使用
    ROT13 时，带重音的字符会被保留。
- en: Lesson 10\. Converting between types
  id: totrans-791
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 课。类型之间的转换
- en: After reading [lesson 10](#ch10), you’ll be able to
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第 10 课](#ch10)后，你将能够
- en: Convert between numeric, string, and Boolean types
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数值、字符串和布尔值类型之间进行转换
- en: Previous lessons covered Booleans, strings, and a dozen different numeric types.
    If you have variables of different types, you must convert the values to the same
    type before they can be used together.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的课程涵盖了布尔值、字符串和十几种不同的数值类型。如果你有不同的类型变量，你必须在使用前将它们的值转换为相同的类型。
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Say you’re at the grocery store with a shopping list from your spouse. The first
    item is milk, but should you get cow’s milk, almond, or soy? Should it be organic,
    skim, 1%, 2%, whole, evaporated, or condensed? How many gallons? Do you call your
    spouse to ask or just pick something?
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在杂货店，手里拿着配偶给你的购物清单。第一项是牛奶，但你应该买牛奶、杏仁奶还是大豆奶？应该是有机的、脱脂的、1%、2%、全脂的、蒸发奶还是炼乳？需要多少加仑？你是打电话给配偶询问，还是随便挑一样？
- en: Your spouse may get annoyed if you keep calling to ask for each detail. Iceberg
    or romaine lettuce? Russet or red potatoes? Oh, and was that 5 lbs. or 10? On
    the other hand, if you “think for yourself” and return with chocolate milk and
    french fries, that may not go over so well.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直打电话询问每个细节，你的配偶可能会感到厌烦。是冰山生菜还是罗马生菜？是红皮土豆还是黄皮土豆？哦，那5磅还是10磅？另一方面，如果你“自己思考”并带回来巧克力牛奶和薯条，那可能不会那么顺利。
- en: If your spouse is a programmer and you’re a compiler in this scenario, what
    do you think Go’s approach would be?
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的配偶是程序员，而你在这个场景中是编译器，你认为 Go 的方法会是什么？
- en: '|  |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. Types don’t mix
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 类型不混合
- en: 'A variable’s *type* establishes the behavior that’s appropriate for it. Numbers
    can be added, strings can be joined. To join two strings together, use the plus
    operator:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的 *类型* 确定了适合它的行为。数字可以相加，字符串可以连接。要连接两个字符串，请使用加号运算符：
- en: '[PRE73]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you try to join a number to a string, the Go compiler will report an error:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将数字与字符串连接，Go 编译器将报告错误：
- en: '[PRE74]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Invalid operation: mismatched types string and int**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 无效操作：字符串和整型不匹配'
- en: '|  |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mixing types in other languages**'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '**在其他语言中混合类型**'
- en: 'When presented with two or more different types, some programming languages
    make a best effort to guess the programmer’s intentions. Both JavaScript and PHP
    can subtract 1 from the string `"10"`:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对两种或更多不同类型时，一些编程语言会尽力猜测程序员的意图。JavaScript 和 PHP 都可以从字符串 `"10"` 中减去 1：
- en: '[PRE75]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* 9 in JavaScript and PHP**'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 JavaScript 和 PHP 中实现 1 到 9**'
- en: The Go compiler rejects `"10" - 1` with a mismatched types error. In Go, you
    first need to convert `"10"` to an integer. The `Atoi` function in the `strconv`
    package will do the conversion, but it will return an error if the `string` doesn’t
    contain a valid number. By the time you handle errors, the Go version is four
    lines long, which isn’t exactly convenient.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器会因类型不匹配错误而拒绝 `"10" - 1`。在 Go 中，你首先需要将 `"10"` 转换为整数。`strconv` 包中的 `Atoi`
    函数可以进行转换，但如果 `string` 不包含有效的数字，它将返回错误。在你处理错误的时候，Go 版本已经是四行长，这并不十分方便。
- en: That said, if `"10"` is user input or came from an external source, the JavaScript
    and PHP versions should check whether it’s a valid number too.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果 `"10"` 是用户输入或来自外部来源，JavaScript 和 PHP 版本也应该检查它是否是一个有效的数字。
- en: 'In languages that *coerce* types, the code’s behavior is less predictable to
    anyone who hasn’t memorized a myriad of implicit behaviors. The plus operator
    (+) in both Java and JavaScript coerces numbers to strings to be joined, whereas
    PHP coerces the values to numbers and does the math:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些*强制类型转换*的语言中，对于没有记住大量隐式行为的任何人来说，代码的行为都难以预测。在 Java 和 JavaScript 中，加号运算符 (+)
    都会将数字强制转换为字符串以进行连接，而 PHP 则将值强制转换为数字并执行数学运算：
- en: '[PRE76]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* “102” in JavaScript or Java, 12 in PHP**'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 JavaScript 或 Java 中是“102”，在 PHP 中是 12**'
- en: Once again, Go would report a mismatched types error.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Go 会报告类型不匹配错误。
- en: '|  |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another example of mismatched types occurs when attempting a calculation with
    a mix of integer and floating-point types. Real numbers like 365.2425 are represented
    with a floating-point type, and Go infers that whole numbers are integers:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用整数和浮点数类型的混合进行计算时，也会发生类型不匹配的例子。像 365.2425 这样的实数使用浮点类型表示，而 Go 推断整数是整数：
- en: '[PRE77]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* age and marsDays are integers.**'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 年龄和火星日数是整数。**'
- en: '***2* earthDays is a floating point type.**'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* earthDays 是浮点类型。**'
- en: '***3* Invalid operation: mismatched types**'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 无效操作：类型不匹配**'
- en: If all three variables were integers, the calculation would succeed, but then
    `earthDays` would need to be 365 instead of the more accurate 365.2425\. Alternatively,
    the calculation would succeed if `age` and `marsDays` were floating-point types
    (41.0 and 687.0 respectively). Go doesn’t make assumptions about which you’d prefer,
    but you can explicitly convert between types, which is covered in the next section.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有三个变量都是整数，计算将成功，但此时 `earthDays` 需要为 365 而不是更准确的 365.2425。或者，如果 `age` 和 `marsDays`
    是浮点类型（分别为 41.0 和 687.0），计算也将成功。Go 不会假设你更喜欢哪种类型，但你可以在下一节中显式地在类型之间进行转换。
- en: '|  |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.1**'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.1**'
- en: '**[Q1:](#ch10qa2q0a1)**'
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa2q0a1)**'
- en: ''
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is `"10" - 1` in Go?
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Go 中 `"10" - 1` 是什么？
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-831
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.1 answer**'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.1 答案**'
- en: '**[1:](#ch10qa1q1)**'
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa1q1)**'
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A compiler error: invalid operation: “10” - 1 (mismatched types string and
    int)'
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器错误：无效操作：“10” - 1（类型不匹配）
- en: '|  |'
  id: totrans-836
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2\. Numeric type conversions
  id: totrans-837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 数字类型转换
- en: '*Type conversion* is straightforward. If you need the integer `age` to be a
    floating-point type for a calculation, wrap the variable with the new type:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*很简单。如果你需要将整数 `age` 转换为浮点类型进行计算，可以用新类型包裹变量：'
- en: '[PRE78]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Variables of different types don’t mix, but with type conversion, the calculation
    in the following listing works.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的变量不能混合，但通过类型转换，以下列表中的计算可以完成。
- en: 'Listing 10.1\. Mars age: mars-age.go'
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 10.1\. 火星年龄: mars-age.go'
- en: '[PRE79]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Prints I am 21.797587336244543 years old on Mars.**'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印我在火星上 21.797587336244543 年。**'
- en: 'You can convert from a floating-point type to an integer as well, though the
    digits after the decimal point will be truncated without any rounding:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将浮点类型转换为整数，尽管小数点后的数字将被截断，而不进行四舍五入：
- en: '[PRE80]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Prints 365**'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 365**'
- en: Type conversions are required between unsigned and signed integer types, and
    between types of different sizes. It’s always safe to convert to a type with a
    larger range, such as from an `int8` to an `int32`. Other integer conversions
    come with some risks. A `uint32` could contain a value of 4 billion, but an `int32`
    only supports numbers to just over 2 billion. Likewise, an `int` may contain a
    negative number, but a `uint` can’t.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 在无符号整数类型和有符号整数类型之间，以及在不同大小的类型之间进行类型转换是必要的。将类型转换为范围更大的类型，例如从 `int8` 到 `int32`，总是安全的。其他整数转换存在一些风险。`uint32`
    可以包含 40 亿的值，但 `int32` 只支持略超过 20 亿的数字。同样，`int` 可能包含负数，但 `uint` 不能。
- en: There’s a reason why Go requires type conversions to be explicitly stated in
    the code. Every time you use a type conversion, consider the possible consequences.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: Go 要求在代码中显式声明类型转换的原因是，每次使用类型转换时，都要考虑可能的后果。
- en: '|  |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.2**'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.2**'
- en: '**[1](#ch10qa4q0a1)**'
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch10qa4q0a1)**'
- en: ''
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What code would convert the variable `red` to an unsigned 8-bit integer?
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将变量 `red` 转换为无符号 8 位整数的代码是什么？
- en: '**[2](#ch10qa4q0a2)**'
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch10qa4q0a2)**'
- en: ''
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the result of the comparison `age > marsAge`?
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 比较 `age > marsAge` 的结果是什么？
- en: '|  |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.2 answer**'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.2 答案**'
- en: '**[1](#ch10qa3q1)**'
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch10qa3q1)**'
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The type conversion would be `uint8(red)`.
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型转换将是 `uint8(red)`。
- en: '**[2](#ch10qa3q2)**'
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch10qa3q2)**'
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mismatched types `int` and `float64`
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类型不匹配 `int` 和 `float64`
- en: '|  |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.3\. Convert types with caution
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 小心转换类型
- en: In 1996, the unmanned Arianne 5 rocket veered off its flight path, broke up,
    and exploded just 40 seconds after launch. The reported cause was a type conversion
    error from a `float64` to an `int16` with a value that exceeded 32,767—the maximum
    value an `int16` can hold. The unhandled failure left the flight control system
    without orientation data, causing it to veer off course, break apart, and ultimately
    self-destruct.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 1996 年，无人驾驶的 Arianne 5 火箭在发射后 40 秒偏离了飞行路径，解体并爆炸。据报道，原因是 `float64` 到 `int16`
    的类型转换错误，其值超过了 32,767——这是 `int16` 可以持有的最大值。未处理的故障导致飞行控制系统失去了方向数据，使其偏离航线，解体并最终自毁。
- en: We haven’t seen the Arianne 5 code, nor are we rocket scientists, but let’s
    look at how Go handles the same type conversion. If the value is in range, as
    in the following listing, no problem.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到 Arianne 5 的代码，也不是火箭科学家，但让我们看看 Go 如何处理相同的类型转换。如果值在范围内，如下面的列表所示，则没有问题。
- en: '![](f0082-01.jpg)'
  id: totrans-870
  prefs: []
  type: TYPE_IMG
  zh: '![](f0082-01.jpg)'
- en: 'Listing 10.2\. Ariane type conversion: ariane.go'
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. Ariane 类型转换：ariane.go
- en: '[PRE81]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* To-do: add rocket science**'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 待办事项：添加火箭科学**'
- en: 'If the value of `bh` is 32,768, which is too big for an `int16`, the result
    is what we’ve come to expect of integers in Go: it wraps around, becoming the
    lowest possible number for an `int16`, –32768.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `bh` 的值为 32,768，这超出了 `int16` 的范围，结果就是我们已经在 Go 中的整数中看到的那样：它会回绕，成为 `int16`
    可能的最小数字，-32768。
- en: The Ada language used for the Arianne 5 behaves differently. The type conversion
    from `float64` to `int16` with an out-of-range value caused a software exception.
    According to the report, this particular calculation was only meaningful prior
    to liftoff, so Go’s approach may have been better in this instance, but usually
    it’s best to avoid incorrect data.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Arianne 5 的 Ada 语言表现不同。`float64` 到 `int16` 的类型转换，其值超出范围，导致软件异常。根据报告，这个特定的计算仅在起飞前有意义，因此在这种情况下，Go
    的方法可能更好，但通常最好避免错误的数据。
- en: 'To detect whether converting a type to `int16` will result in an invalid value,
    the `math` package provides min/max constants:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测将类型转换为 `int16` 是否会导致无效值，`math` 包提供了 min/max 常量：
- en: '[PRE82]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '|  |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These min/max constants are untyped, allowing the comparison of `bh`, a floating-point
    value, to `MaxInt16`. [Lesson 8](kindle_split_018.html#ch08) talks more about
    untyped constants.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 min/max 常量是无类型的，允许将浮点值 `bh` 与 `MaxInt16` 进行比较。[第 8 节](kindle_split_018.html#ch08)
    讨论了无类型常量更多内容。
- en: '|  |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.3**'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.3**'
- en: '**[Q1:](#ch10qa6q0a1)**'
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa6q0a1)**'
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What code will determine if the variable `v` is within the range of an 8-bit
    unsigned integer?
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么代码将确定变量 `v` 是否在 8 位无符号整数的范围内？
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.3 answer**'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 10.3 答案**'
- en: '**[1:](#ch10qa5q1)**'
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa5q1)**'
- en: ''
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ''
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints converted: 42**'
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印转换结果：42**'
- en: '|  |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.4\. String conversions
  id: totrans-896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 字符串转换
- en: To convert a `rune` or `byte` to a `string`, you can use the same type conversion
    syntax as numeric conversions, as shown in the next listing. This gives the same
    result using the `%c` format verb introduced in [lesson 9](kindle_split_019.html#ch09)
    to display runes and bytes as characters.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `rune` 或 `byte` 转换为 `string` 时，可以使用与数值转换相同的类型转换语法，如下面的列表所示。这会得到与在 [第 9 节](kindle_split_019.html#ch09)
    中引入的 `%c` 格式说明符相同的结果，用于显示 runes 和 bytes 作为字符。
- en: 'Listing 10.3\. Converting `rune` to `string`: rune-convert.go'
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 将 `rune` 转换为 `string`：rune-convert.go
- en: '[PRE84]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Prints πάω!**'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 πάω!**'
- en: Converting a numeric code point to a string works the same with any integer
    type. After all, `rune` and `byte` are just aliases for `int32` and `uint8`.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 将数值代码点转换为字符串与任何整数类型的工作方式相同。毕竟，`rune` 和 `byte` 只是 `int32` 和 `uint8` 的别名。
- en: To convert digits to a `string`, each digit must be converted to a code point,
    starting at 48 for the *0* character, through 57 for the *9* character. Thankfully,
    the `Itoa` function in the `strconv` (string conversion) package does this for
    you, as shown in the next listing.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为 `string` 时，每个数字都必须转换为代码点，从 *0* 字符的 48 开始，到 *9* 字符的 57 结束。幸运的是，`strconv`（字符串转换）包中的
    `Itoa` 函数会为你完成这项工作，如下面的列表所示。
- en: 'Listing 10.4\. Integer to ASCII: itoa.go'
  id: totrans-903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 整数到 ASCII：itoa.go
- en: '[PRE85]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Prints Launch in T minus 10 seconds.**'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印“发射倒计时 10 秒。”**'
- en: '|  |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`Itoa` is short for integer to ASCII. Unicode is a superset of the old ASCII
    standard. The first 128 code points are the same, which includes digits (used
    here), English letters, and common punctuation.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '`Itoa` 是整数到 ASCII 的缩写。Unicode 是旧 ASCII 标准的超集。前 128 个代码点相同，包括数字（在此处使用）、英语字母和常用标点符号。'
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another way to convert a number to a string is to use `Sprintf`, a cousin of
    `Printf` that returns a `string` rather than displaying it:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字转换为字符串的另一种方法是使用 `Sprintf`，它是 `Printf` 的一个堂兄弟，返回一个 `string` 而不是显示它：
- en: '[PRE86]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Prints Launch in T minus 9 seconds.**'
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 T 减 9 秒准备发射。**'
- en: 'To go the other way, the `strconv` package provides the `Atoi` function (ASCII
    to integer). Because a string may contain gibberish or a number that’s too big,
    the `Atoi` function may return an error:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行相反的转换，`strconv` 包提供了 `Atoi` 函数（ASCII 到整数）。由于字符串可能包含垃圾数据或太大的数字，`Atoi` 函数可能会返回一个错误：
- en: '[PRE87]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Prints 10**'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 10**'
- en: A `nil` value for `err` indicates that no error occurred and everything is A-OK.
    [Lesson 28](kindle_split_042.html#ch28) navigates the perilous topic of errors.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`err` 的 `nil` 值表示没有发生错误，一切正常。[课程 28](kindle_split_042.html#ch28) 讲解了关于错误的风险话题。'
- en: '|  |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.4**'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.4**'
- en: '**[Q1:](#ch10qa8q0a1)**'
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa8q0a1)**'
- en: ''
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Name two functions that can convert an integer to a string.
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列举两个可以将整数转换为字符串的函数。
- en: '|  |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.4 answer**'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.4 答案**'
- en: '**[1:](#ch10qa7q1)**'
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa7q1)**'
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Both `Itoa` and `Sprintf` will convert a whole number to a string.
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Itoa` 和 `Sprintf` 都可以将整数转换为字符串。'
- en: '|  |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Types are static**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型是静态的**'
- en: 'In Go, once a variable is declared, it has a type and the type cannot be changed.
    This is known as *static typing*, which is easier for the compiler to optimize,
    so your programs run fast. But attempting to use a variable with a value of a
    different type will cause the Go compiler to report an error:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，一旦声明了一个变量，它就有了一个类型，并且这个类型不能被改变。这被称为 *静态类型*，这使得编译器更容易优化，因此你的程序运行得更快。但是尝试使用不同类型的值来使用变量会导致
    Go 编译器报告错误：
- en: '[PRE88]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Error: countdown can only store integers.**'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：倒计时只能存储整数。**'
- en: Languages such as JavaScript, Python, and Ruby use *dynamic typing* instead
    of static typing. In those languages, each value has an associated type, and variables
    can hold values of any type. They would allow the type of `countdown` to change
    as the program executes.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态类型而不是静态类型的语言，如 JavaScript、Python 和 Ruby。在这些语言中，每个值都有一个关联的类型，变量可以持有任何类型的值。它们会允许
    `countdown` 的类型在程序执行过程中改变。
- en: Go does have an escape hatch for situations where the type is uncertain. For
    example, the `Println` function will accept both strings and numeric types. [Lesson
    12](kindle_split_023.html#ch12) explores the `Println` function in more detail.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言在类型不确定的情况下有一个逃生门。例如，`Println` 函数可以接受字符串和数值类型。[课程 12](kindle_split_023.html#ch12)
    更详细地探讨了 `Println` 函数。
- en: '|  |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.5\. Converting Boolean values
  id: totrans-937
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 将布尔值转换为
- en: The `Print` family of functions displays the Boolean values `true` and `false`
    as text. As such, the next listing uses the `Sprintf` function to convert the
    Boolean variable `launch` to text. If you want to convert to numeric values or
    different text, a humble `if` statement works best.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print` 函数族将布尔值 `true` 和 `false` 显示为文本。因此，下面的列表使用 `Sprintf` 函数将布尔变量 `launch`
    转换为文本。如果你想要转换为数值或不同的文本，一个简单的 `if` 语句效果最好。'
- en: 'Listing 10.5\. Converting a Boolean to a string: launch.go'
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 将布尔值转换为字符串：launch.go
- en: '[PRE89]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* Prints Ready for launch: false**'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印准备发射：false**'
- en: '***2* Prints Ready for launch: no**'
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印准备发射：no**'
- en: The inverse conversion requires less code because you can assign the result
    of a condition directly to a variable, as in the following listing.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 逆转换需要更少的代码，因为你可以直接将条件的结果分配给变量，如下面的列表所示。
- en: 'Listing 10.6\. Converting a string to a Boolean: tobool.go'
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 将字符串转换为布尔值：tobool.go
- en: '[PRE90]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Prints Ready for launch: false**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印准备发射：false**'
- en: The Go compiler will report an error if you attempt to convert a Boolean with
    `string(false)`, `int(false)`, or similar, and likewise for `bool(1)` or `bool("yes")`.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用 `string(false)`、`int(false)` 或类似的方式转换布尔值，或者对于 `bool(1)` 或 `bool("yes")`，Go
    编译器会报告错误。
- en: '|  |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In programming languages without a dedicated `bool` type, the values 1 and 0
    often stand in for `true` and `false`, respectively. Booleans in Go don’t have
    a numeric equivalent.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有专用 `bool` 类型的编程语言中，1 和 0 通常分别代表 `true` 和 `false`。Go 中的布尔值没有数值等价物。
- en: '|  |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.5**'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.5**'
- en: '**[Q1:](#ch10qa10q0a1)**'
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch10qa10q0a1)**'
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you convert a Boolean to an integer, with 1 for true and 0 for false?
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何将布尔值转换为整数，其中 1 表示真，0 表示假？
- en: '|  |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 10.5 answer**'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.5 答案**'
- en: '**[1:](#ch10qa9q1)**'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch10qa9q1)**'
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'With a humble `if` statement:'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用一个简单的 `if` 语句：
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ''
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***1* Prints Ready for launch: 1**'
  id: totrans-966
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印准备发射：1**'
- en: '|  |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Conversion between types is explicit to avoid ambiguity.
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型之间的转换是显式的，以避免歧义。
- en: The `strconv` package provides functions for converting strings to and from
    other types.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv`包提供了将字符串转换为其他类型以及从其他类型转换为字符串的函数。'
- en: Let’s see if you got this...
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: 'Experiment: input.go'
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：input.go
- en: 'Write a program that converts strings to Booleans:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，将字符串转换为布尔值：
- en: The strings “true”, “yes”, or “1” are `true`.
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串“true”，“yes”或“1”是`true`。
- en: The strings “false”, “no”, or “0” are `false`.
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串“false”，“no”或“0”是`false`。
- en: Display an error message for any other values.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何其他值，显示错误信息。
- en: '|  |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `switch` statement accepts multiple values per `case`, as covered in [lesson
    3](kindle_split_012.html#ch03).
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句在每个`case`中接受多个值，如[第3课](kindle_split_012.html#ch03)中所述。'
- en: '|  |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 11\. Capstone: The Vigenère cipher'
  id: totrans-981
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11课：总结：维吉尼亚密码
- en: The Vigenère cipher (see [en.wikipedia.org/wiki/Vigenere_cipher](http://en.wikipedia.org/wiki/Vigenere_cipher))
    is a 16th century variant of the Caesar cipher. For this challenge, you will write
    a program to decipher text using a keyword.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码（见[en.wikipedia.org/wiki/Vigenere_cipher](http://en.wikipedia.org/wiki/Vigenere_cipher)）是16世纪凯撒密码的一个变体。在这个挑战中，你需要编写一个程序来使用密钥解密文本。
- en: Before describing the Vigenère cipher, allow us to reframe the Caesar cipher,
    which you’ve already worked with. With the Caesar cipher, a plain text message
    is ciphered by shifting each letter ahead by three. The direction is reversed
    to decipher the resulting message.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述维吉尼亚密码之前，让我们重新审视一下你已经使用过的凯撒密码。在凯撒密码中，明文消息通过将每个字母向前移动三个位置来加密。解密结果消息的方向相反。
- en: Assign each English letter a numeric value, where A = 0, B = 1, all the way
    to Z = 25\. With this in mind, a shift by 3 can be represented by the letter D
    (D = 3).
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个英语字母分配一个数值，其中A = 0，B = 1，一直到Z = 25。考虑到这一点，移动3可以表示为字母D（D = 3）。
- en: To decipher the text in [table 11.1](#ch11table01), start with the letter L
    and shift it by D. Because L = 11 and D = 3, the result of 11–3 is 8, or the letter
    I. Should you need to decipher the letter A, it should wrap around to become X,
    as you saw in [lesson 9](kindle_split_019.html#ch09).
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密[表11.1](#ch11table01)中的文本，从字母L开始，向D方向移动。因为L = 11，D = 3，所以11 - 3的结果是8，即字母I。如果你需要解密字母A，它应该绕回到X，就像你在[第9课](kindle_split_019.html#ch09)中看到的那样。
- en: '![](f0088-01.jpg)'
  id: totrans-986
  prefs: []
  type: TYPE_IMG
  zh: '![](f0088-01.jpg)'
- en: Table 11.1\. Caesar cipher
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.1. 凯撒密码
- en: '| L | F | D | P | H | L | V | D | Z | L | F | R | Q | T | X | H | U | H | G
    |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
  zh: '| L | F | D | P | H | L | V | D | Z | L | F | R | Q | T | X | H | U | H | G
    |'
- en: '| D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D
    |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '| D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D | D
    |'
- en: The Caesar cipher and ROT13 are susceptible to what’s called *frequency analysis*.
    Letters that occur frequently in the English language, such as E, will occur frequently
    in the ciphered text as well. By looking for patterns in the ciphered text, the
    code can be cracked.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码和ROT13容易受到所谓的*频率分析*的影响。在英语中经常出现的字母，如E，在加密文本中也会频繁出现。通过在加密文本中寻找模式，可以破解密码。
- en: To thwart would-be code crackers, the Vigenère cipher shifts each letter based
    on a repeating keyword, rather than a constant like 3 or 13\. The keyword repeats
    until the end of the message, as shown for the keyword GOLANG in [table 11.2](#ch11table02).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止潜在的密码破解者，维吉尼亚密码根据重复的密钥而不是像3或13这样的常数来移动每个字母。密钥会一直重复到消息的末尾，就像[表11.2](#ch11table02)中显示的GOLANG密钥一样。
- en: Table 11.2\. Vigenère cipher
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.2. 维吉尼亚密码
- en: '| C | S | O | I | T | E | U | I | W | U | I | Z | N | S | R | O | C | N | K
    | F | D |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '| C | S | O | I | T | E | U | I | W | U | I | Z | N | S | R | O | C | N | K
    | F | D |'
- en: '| G | O | L | A | N | G | G | O | L | A | N | G | G | O | L | A | N | G | G
    | O | L |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
  zh: '| G | O | L | A | N | G | G | O | L | A | N | G | G | O | L | A | N | G | G
    | O | L |'
- en: Now that you know what the Vigenère cipher is, you may notice that Vigenère
    with the keyword D is equivalent to the Caesar cipher. Likewise, ROT13 has a keyword
    of N (N = 13). Longer keywords are needed to be of any benefit.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了维吉尼亚密码是什么，你可能注意到，使用密钥D的维吉尼亚密码等同于凯撒密码。同样，ROT13的密钥是N（N = 13）。需要更长的密钥才能发挥作用。
- en: 'Experiment: decipher.go'
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验：decipher.go
- en: 'Write a program to decipher the ciphered text shown in [table 11.2](#ch11table02).
    To keep it simple, all characters are uppercase English letters for both the text
    and keyword:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序来解密[表11.2](#ch11table02)中显示的加密文本。为了简化，文本和密钥都是大写英文字母：
- en: '[PRE92]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `strings.Repeat` function may come in handy. Give it a try, but also complete
    this exercise without importing any packages other than `fmt` to print the deciphered
    message.
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.Repeat` 函数可能会很有用。试一试，但也尝试在不导入任何其他包（除了 `fmt` 用于打印解密消息）的情况下完成这个练习。'
- en: Try this exercise using `range` in a loop and again without it. Remember that
    the `range` keyword splits a string into runes, whereas an index like `keyword[0]`
    results in a byte.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用循环中的 `range` 关键字来完成这个练习，然后再不使用它。记住，`range` 关键字将字符串拆分为 runes，而像 `keyword[0]`
    这样的索引会产生一个 byte。
- en: '|  |'
  id: totrans-1001
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can only perform operations on values of the same type, but you can convert
    one type to the other (`string`, `byte`, `rune`).
  id: totrans-1003
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你只能对相同类型的值执行操作，但你可以将一种类型转换为另一种类型（`string`、`byte`、`rune`）。
- en: '|  |'
  id: totrans-1004
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|'
- en: To wrap around at the edges of the alphabet, the Caesar cipher exercise made
    use of a comparison. Solve this exercise without any `if` statements by using
    modulus (`%`).
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在字母表的边缘循环，凯撒密码练习使用了比较。通过使用模运算符（`%`）而不使用任何 `if` 语句来解决这个练习。
- en: '|  |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you recall, modulus gives the remainder of dividing two numbers. For example,
    `27 % 26` is `1`, keeping numbers within the 0–25 range. Be careful with negative
    numbers, though, as `-3 % 26` is still `-3`.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，模运算给出了两个数相除的余数。例如，`27 % 26` 的结果是 `1`，将数字保持在 0–25 的范围内。但是要注意负数，因为 `-3
    % 26` 仍然是 `-3`。
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After you complete the exercise, take a look at our solution in the appendix.
    How do they compare? Use the Go Playground’s Share button and post a link to your
    solution in the Get Programming with Go forum.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习后，查看附录中的我们的解决方案。它们如何比较？使用 Go Playground 的分享按钮，并在 Get Programming with Go
    论坛上发布你的解决方案的链接。
- en: Ciphering text with Vigenère isn’t any more difficult than deciphering text.
    Just add letters of the keyword to letters of a plain text message instead of
    subtracting.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 使用维吉尼亚密码加密文本并不比解密文本更困难。只需将密钥字的字母添加到纯文本消息的字母中，而不是从中减去。
- en: 'Experiment: cipher.go'
  id: totrans-1012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验：cipher.go
- en: 'To send ciphered messages, write a program that ciphers plain text using a
    keyword:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送加密消息，编写一个程序，使用密钥字加密纯文本：
- en: '[PRE93]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Bonus: rather than write your plain text message in uppercase letters with
    no spaces, use the `strings.Replace` and `strings.ToUpper` functions to remove
    spaces and uppercase the string before you cipher it.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励：与其将你的纯文本消息全部大写且没有空格，不如使用 `strings.Replace` 和 `strings.ToUpper` 函数在加密之前删除空格并将字符串转换为大写。
- en: Once you’ve ciphered a plain text message, check your work by deciphering the
    ciphered text with the same keyword.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你加密了一条纯文本消息，通过使用相同的密钥字解密加密文本来检查你的工作。
- en: Use the keyword `"GOLANG"` to cipher a message and post it to the forums for
    Get Programming with Go at [forums.manning.com/forums/get-programming-with-go](http://forums.manning.com/forums/get-programming-with-go).
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥字 `"GOLANG"` 加密一条消息并将其发布到 [forums.manning.com/forums/get-programming-with-go](http://forums.manning.com/forums/get-programming-with-go)
    的论坛上。
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1019
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Disclaimer: Vigenère cipher is all in good fun, but don’t use it for important
    secrets. There are more secure ways to send messages in the 21st century.'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 声明：维吉尼亚密码只是好玩，但不要用它来发送重要的秘密。21 世纪有更安全的发送消息的方式。
- en: '|  |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '|'
