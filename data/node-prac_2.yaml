- en: Part 3\. Writing modules
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分：编写模块
- en: 'As we dove deep into Node’s core libraries and looked into real-world recipes,
    we’ve been building a narrative that leads to the biggest part of the Node ecosystem:
    community-driven innovation through third-party module development. As the core
    provides the Legos with which we build, and the recipes provide the tooling and
    insight to build confidently, what we ultimately build is up to us!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 Node 的核心库并探讨现实世界的解决方案时，我们一直在构建一个故事，这个故事引导我们进入 Node 生态系统最大的部分：通过第三方模块开发推动的社区驱动创新。核心提供了我们构建的乐高积木，而解决方案提供了构建时的工具和洞察力，因此我们最终构建的内容取决于我们自己！
- en: We have one last chapter that will take you through the ins and outs of building
    a module and contributing it back to the community.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一章，将带您了解构建模块并将其贡献给社区的所有细节。
- en: 'Chapter 13\. Writing modules: Mastering what Node is all about'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章：编写模块：掌握 Node 的核心
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Planning a module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划模块
- en: Setting up a package.json file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 package.json 文件
- en: Working with dependencies and semantic versioning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与依赖和语义版本一起工作
- en: Adding executable scripts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可执行脚本
- en: Testing out a module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模块
- en: Publishing modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布模块
- en: The Node package manager (npm) is arguably the *best* package manager any platform
    has seen to date. npm at its core is a set of tools for installing, managing,
    and creating Node modules. The barrier to entry is low and uncluttered with ceremony.
    Things “just work” and work well. If you aren’t convinced yet, we hope this chapter
    will encourage you to take another look.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，Node 的包管理器（npm）可能是迄今为止任何平台所拥有的 *最佳* 包管理器。npm 的核心是一套用于安装、管理和创建 Node 模块的工具。入门门槛低，没有繁琐的仪式。事情“自然而然”地“工作”得很好。如果您还没有被说服，我们希望这一章能鼓励您再次审视。
- en: The subtitle for this chapter is “Mastering what Node is all about.” We chose
    this because user-contributed modules *make up the vast majority of the Node ecosystem*.
    The core team decided early on that Node would have a *small* standard library,
    containing just enough core functionality to build great modules upon. We knew
    understanding this core functionality was paramount to building modules, so we
    saved this chapter for the end. In Node, you may find 5 or 10 different implementations
    for a particular protocol or client, and we’re *OK* with that because it allows
    experimentation to drive innovation in the space.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的副标题是“掌握 Node 的核心”。我们选择这个标题是因为用户贡献的模块构成了 Node 生态系统的绝大多数。核心团队早期就决定 Node 将有一个
    *小* 的标准库，其中包含构建优秀模块所需的核心功能。我们知道理解这些核心功能对于构建模块至关重要，因此我们将这一章留到了最后。在 Node 中，您可能会发现针对特定协议或客户端的
    5 或 10 种不同的实现，我们对此表示 *无妨*，因为这允许在该领域通过实验推动创新。
- en: One thing we’ve learned through our experimentation is that *smaller modules
    matter*. Larger modules tend to be hard to maintain and test. Node enables smaller
    modules to be stuck together simply to solve more and more complex problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的实验，我们学到的一点是 *小型模块很重要*。大型模块往往难以维护和测试。Node 允许小型模块简单地组合在一起，以解决更多和更复杂的问题。
- en: Node’s require system (based on CommonJS; [http://wiki.commonjs.org/wiki/Modules/1.1](http://wiki.commonjs.org/wiki/Modules/1.1))
    manages those dependencies in a way that avoids dependency hell. It’s perfectly
    fine for modules to depend on different versions of the same module, as shown
    in [figure 13.1](#ch13fig01).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 require 系统基于 CommonJS（[http://wiki.commonjs.org/wiki/Modules/1.1](http://wiki.commonjs.org/wiki/Modules/1.1)），以避免依赖地狱的方式管理这些依赖。模块依赖于同一模块的不同版本是完全正常的，正如[图
    13.1](#ch13fig01)所示。
- en: Figure 13.1\. Node avoids dependency hell
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1\. Node 避免依赖地狱
- en: '![](13fig01_alt.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig01_alt.jpg)'
- en: In addition to standard dependencies, you can specify development and peer dependencies
    (more on that later) and have npm keep those in check for you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准依赖之外，您还可以指定开发和同伴依赖（稍后详述），并让 npm 帮您检查这些依赖。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Dependency graphs
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 依赖图
- en: If you ever want to see a dependency graph for your project, just type npm ls
    at the project root to get a listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看项目的依赖图，只需在项目根目录下输入 npm ls 即可获取列表。
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Another difference that was decided early on in the history of npm was to manage
    dependencies at a *local level by default* as popularized by the bundler Ruby
    gem. This bundles modules *inside* your project (sitting in the node_modules folder),
    making dependency hell a non-issue across multiple projects since there’s no globally
    shared module state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在npm的历史早期，就决定了一个差异，即默认在本地级别管理依赖项，这是由Ruby gem bundler推广的。这将在你的项目内部捆绑模块（位于node_modules文件夹中），使得在多个项目中依赖地狱成为一个非问题，因为没有全局共享的模块状态。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Installing global modules
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装全局模块
- en: You can still install global modules if you want with npm install -g module-name,
    which can be useful when you need a system-wide executable, for instance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要安装全局模块，可以使用npm install -g module-name，这在需要系统级可执行文件时非常有用，例如。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Hopefully we’ve whetted your appetite for exploring a range of module-authoring
    techniques! In this chapter we’ll focus on a variety of techniques that center
    around
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们已经激起了你对探索各种模块创建技术的兴趣！在本章中，我们将关注围绕以下内容的各种技术
- en: Effectively making the most of the package.json file
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地利用package.json文件
- en: Using npm for various module-authoring tasks
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm进行各种模块创建任务
- en: Best practices for developing modules
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模块的最佳实践
- en: Our techniques will follow a logical order from an empty project directory to
    a completed and published npm module. Although we tried to stuff as many concepts
    as possible into one module, you may find your module may only need a handful
    of these steps. When we can’t fit a concept into the module, we’ll focus on an
    isolated use case to illustrate the point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的技术将按照从空项目目录到完成并发布的npm模块的逻辑顺序进行。尽管我们试图将尽可能多的概念放入一个模块中，但你可能会发现你的模块可能只需要这些步骤中的一小部分。当我们无法将一个概念放入模块中时，我们将专注于一个隔离的使用案例来说明这一点。
- en: 13.1\. Brainstorming
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 思考
- en: What kind of API do we want to build? How should someone consume it? Does it
    have a clear purpose? These are some of the questions we need to ask as we begin
    to write a module. In this section we’ll walk through researching and proving
    out a module idea. But first, let’s introduce a problem we want to solve, which
    will provide a context as we progress.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建什么样的API？人们应该如何使用它？它有一个明确的目的吗？在我们开始编写模块时，我们需要问一些问题。在本节中，我们将探讨研究和验证模块想法的过程。但首先，让我们介绍一个我们想要解决的问题，这将为我们后续的进展提供背景。
- en: 13.1.1\. A faster Fibonacci module
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1. 更快的斐波那契模块
- en: One of the most famous Node critiques (although arguably misguided) early on
    in its history was “Node.js is Cancer” ([http://pages.citebite.com/b2x0j8q1megb](http://pages.citebite.com/b2x0j8q1megb)),
    where the author argued that a CPU-bound task on a running web server was miserably
    handled in Node’s single-threaded system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js早期历史中，最著名的批评之一（尽管可能有些误导）是“Node.js是癌症”（[http://pages.citebite.com/b2x0j8q1megb](http://pages.citebite.com/b2x0j8q1megb)），作者认为在运行中的Web服务器上，Node的单线程系统对CPU密集型任务的处理非常糟糕。
- en: 'The implementation was a common recursive approach to calculating a Fibonacci
    sequence ([http://en.wikipedia.org/wiki/Fibonacci_number](http://en.wikipedia.org/wiki/Fibonacci_number)),
    which could be implemented as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实现是一个常见的递归方法来计算斐波那契数列（[http://en.wikipedia.org/wiki/Fibonacci_number](http://en.wikipedia.org/wiki/Fibonacci_number)），可以如下实现：
- en: '![](363fig01_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](363fig01_alt.jpg)'
- en: This implementation is slow in V8, and since proper tail calls don’t yet exist
    in JavaScript, it wouldn’t be able to calculate very high numbers due to a stack
    overflow.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方法在V8中速度较慢，并且由于JavaScript中还没有适当的尾调用，它无法计算非常大的数字，因为会导致栈溢出。
- en: Let’s write a module to help rid the world of slow Fibonacci calculations in
    order to learn about module development from start to finish.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个模块，帮助世界摆脱缓慢的斐波那契计算，以便从头到尾学习模块开发。
- en: Technique 106 Planning for our module
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧106 为我们的模块规划
- en: So we want to start writing a module. How should we approach it? Is there anything
    we can do before we even start writing a line of code? It turns out that planning
    ahead of time can be extremely helpful and save pain down the road. Let’s take
    a peek on how to do that well.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要开始编写一个模块。我们应该如何着手？在我们开始编写代码之前，我们能做些什么？事实证明，提前规划可以非常有帮助，并能在未来节省痛苦。让我们看看如何做好这一点。
- en: Problem
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write a module. What steps should you take in planning?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要编写一个模块。在规划阶段，你应该采取哪些步骤？
- en: Solution
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Research what already exists, and ensure that your module does just one thing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 研究现有内容，并确保你的模块只做一件事。
- en: Discussion
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It’s important to clearly articulate the purpose of your module. If you can’t
    boil it down to one sentence, it may be doing too much. Here’s where an important
    aspect of the Unix philosophy comes in: *make each program do one thing well*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 明确阐述你模块的目的非常重要。如果你不能将其简化为一句话，它可能做得太多。这就是 Unix 哲学的一个重要方面发挥作用的地方：*让每个程序只做一件事，并且做好*。
- en: Surveying the landscape
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概览格局
- en: 'First, it’s good to know what exists already. Has someone else implemented
    a solution to my problem? Can I contribute there? How did others approach this?
    A great way to do that is searching on npmjs.org or doing a search from the command
    line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解已经存在什么是有好处的。有人为我的问题实现了解决方案吗？我可以贡献那里吗？其他人是如何处理的？一个很好的方法是搜索 npmjs.org 或从命令行进行搜索：
- en: '![](364fig01_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![364fig01_alt.jpg](364fig01_alt.jpg)'
- en: 'Let’s look at some of the more interesting results:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更有趣的结果：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here we can see the names and descriptions of three different implementations.
    We also see what version was released last and on what date. It looks like a couple
    are older and have a lower version number, which may mean the API is in flux or
    still in progress. But the top result looks pretty mature at version 1.2.3 and
    has been updated most recently. Let’s get more information on that by running
    the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到三个不同实现的名称和描述。我们还看到了最后一次发布的版本和日期。看起来有几个版本较旧，版本号较低，这可能意味着 API 正在变化或仍在进行中。但顶部结果看起来在
    1.2.3 版本下相当成熟，并且最近进行了更新。让我们通过运行以下命令来获取更多信息：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The npm docs command will load the module’s homepage if specified, or the npmjs
    search result, which looks like [figure 13.2](#ch13fig02).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了，npm 文档命令将加载模块的主页，或者 npmjs 搜索结果，看起来像[图 13.2](#ch13fig02)。
- en: Figure 13.2\. npmjs.com package details page
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. npmjs.com 包详情页面
- en: '![](13fig02_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![13fig02_alt.jpg](13fig02_alt.jpg)'
- en: The npmjs result page helps give you an overall picture for a module. We can
    see this module depends on the bignum module and was updated a year ago, and we
    can view its readme to get a sense of the API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: npmjs 结果页面有助于给出一个模块的整体印象。我们可以看到这个模块依赖于 bignum 模块，并且一年前进行了更新，我们可以查看其 README 以了解
    API。
- en: Although this module looks pretty good, let’s create a module as an experiment
    to try out some other ideas for handling Fibonacci sequences. In our case, let’s
    create a module where we’ll experiment with different implementations and benchmark
    our results using straight JavaScript with no required bignum dependency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个模块看起来相当不错，但让我们创建一个模块作为实验，尝试一些处理斐波那契数列的其他想法。在我们的案例中，让我们创建一个模块，我们将在这个模块中尝试不同的实现，并使用纯
    JavaScript（没有所需的 bignum 依赖项）来基准测试我们的结果。
- en: Embrace doing one thing well
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 拥抱做好一件事
- en: 'A module should be simple and pluggable. In this case, let’s try to define
    our module’s purpose in one phrase:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块应该是简单且可插入的。在这种情况下，让我们尝试用一句话定义我们模块的目的：
- en: '*Calculates a Fibonacci number as quickly as possible with only JavaScript*'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*尽可能快地使用 JavaScript 计算斐波那契数*'
- en: 'That’s a pretty good start: it’s clear and succinct. When that concept doesn’t
    ring true anymore, we’ve blown our scope, and it may be time to write another
    module that extends this one rather than adding more to it. For this project,
    adding a web server endpoint that returns the result of this function may be better
    served in a new module that depends on this one.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个相当不错的开始：它清晰且简洁。当这个概念不再适用时，我们就超出了我们的范围，可能需要写另一个扩展这个模块而不是添加更多内容的模块。对于这个项目，添加一个返回此函数结果的
    Web 服务器端点可能更适合在一个依赖于这个模块的新模块中完成。
- en: Of course, this isn’t a rigid requirement, but it helps us clarify the module’s
    purpose and makes it clear for our end users. This statement will be great to
    add to our package.json (which we’ll look at later) and to the top of our readme
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是一个严格的要求，但它有助于我们明确模块的目的，并使我们的最终用户清楚。这个声明非常适合添加到我们的 package.json（我们稍后会看到）和我们的
    README 文件顶部。
- en: 'We’ll eventually need a module name, which isn’t vital at the start, but in
    order to refer to it in future techniques, let’s call ours fastfib. Go ahead and
    make a fastfib directory that will serve as our project directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终需要一个模块名称，虽然一开始不是必要的，但为了在未来的技术中引用它，让我们称我们的模块为 fastfib。现在就创建一个名为 fastfib 的目录，它将作为我们的项目目录：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we’ve defined our “one thing” we want our module to do and have our
    bare project directory, let’s prove out our module idea in the next technique
    to see if it will actually work.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们希望我们的模块做到的“一件事”，并且有了我们的裸项目目录，让我们通过下一个技术来验证我们的模块想法，看看它是否真的可行。
- en: Technique 107 Proving our module idea
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧107证明我们的模块想法
- en: So we have a focus now; what next? Time to prove our idea. This is the step
    where we think about the API surface of our module. Is it usable? Does it accomplish
    its purpose? Let’s look at this next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了重点；接下来是什么？是时候证明我们的想法了。这是我们思考模块API表面的步骤。它是可用的吗？它是否实现了其目的？让我们看看这一点。
- en: Problem
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: What should you code first when proving out your module idea?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在证明模块想法时，你应该先编写什么代码？
- en: Solution
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Look at the API surface through TDD.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TDD查看API表面。
- en: Discussion
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s important to know how you want your module to function. In fastfib, we’ll
    calculate a Fibonacci sequence synchronously. What would be the simplest and easiest-to-use
    API we can think of?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你希望你的模块如何工作是很重要的。在fastfib中，我们将同步计算斐波那契序列。我们能想到的最简单、最容易使用的API是什么？
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Right, just a simple function call that returns the result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对，只是一个简单的函数调用，返回结果。
- en: 'When building an asynchronous API, it’s recommended to use the Node callback
    signature, as it will work well with pretty much any control flow library. If
    our module were asynchronous, it would look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建异步API时，建议使用Node回调签名，因为它将很好地与几乎任何控制流库一起工作。如果我们的模块是异步的，它将看起来像这样：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have our synchronous API. In the beginning of this chapter, we showed you
    an implementation that we wanted to improve on. Since we want a baseline to compare
    other implementations, let’s bring that recursive implementation into our project
    by creating a lib folder with a file called recurse.js with the following content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有同步API。在本章的开头，我们向您展示了一个我们想要改进的实现。由于我们想要一个基线来比较其他实现，让我们通过创建一个名为recurse.js的文件并将其放入lib文件夹中，将这个递归实现引入我们的项目中：
- en: '![](366fig01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](366fig01.jpg)'
- en: Defining an entry point
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义入口点
- en: 'Every module has an *entry point*: the object/function/constructor that we
    get when it’s required elsewhere using the require keyword. Since we know that
    we’ll be trying different implementations inside our lib directory, we don’t want
    lib/recurse.js to be the entry point, as it may change.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个*入口点*：当我们使用require关键字在其他地方调用它时得到的对象/函数/构造函数。由于我们知道我们将在lib目录内尝试不同的实现，我们不希望lib/recurse.js成为入口点，因为它可能会改变。
- en: 'Usually index.js in the project root makes the most sense as an entry point.
    Many times it makes sense to have the entry point be minimal in nature and just
    tie together the parts needed to provide the API to the end user. Let’s create
    that file now:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，项目根目录下的index.js是最有意义的入口点。很多时候，让入口点尽可能最小化，仅将提供API所需的部分连接起来是有意义的。现在让我们创建这个文件：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now when a consumer of the module does a `require('fastfib')`, they will get
    this file and in turn get our recursive implementation. We can then just switch
    this file whenever we need to change the exposed implementation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当模块的消费者执行`require('fastfib')`时，他们将得到这个文件，进而得到我们的递归实现。然后我们只需在需要更改公开实现时切换这个文件。
- en: Testing our implementation
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试我们的实现
- en: 'Now that we have our first implementation of fastfib, let’s ensure that we
    actually have a legit Fibonacci implementation. For that, let’s make a folder
    called test with a single index.js file inside:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了fastfib的第一个实现，让我们确保我们实际上有一个合法的斐波那契实现。为此，让我们创建一个名为test的文件夹，并在其中添加一个名为index.js的单个文件：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can run our test suite to see if we’re on track:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的测试套件，看看我们是否在正确的轨道上：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We didn’t get any errors thrown, so it looks like we’re at least accurate in
    our implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有抛出任何错误，所以看起来我们的实现至少是准确的。
- en: Benchmarking our implementation
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对我们的实现进行基准测试
- en: 'Now that we have a well-defined API and tests around our implementation of
    fastfib, how do we determine how fast it is? For this we’ll use a reliable JavaScript
    benchmarking tool behind the jsperf.com project called Benchmark.js ([http://benchmarkjs.com/](http://benchmarkjs.com/)).
    Let’s include it in our project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了fastfib实现的API和测试，我们该如何确定它的速度有多快呢？为此，我们将使用jsperf.com项目背后的一个可靠JavaScript基准测试工具，称为Benchmark.js（[http://benchmarkjs.com/](http://benchmarkjs.com/)）。让我们将其包含到我们的项目中：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s create another folder called benchmark and add an index.js file inside
    of it with the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为benchmark的文件夹，并在其中添加一个index.js文件，代码如下：
- en: '![](367fig01_alt.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](367fig01_alt.jpg)'
- en: 'Let’s run our benchmark now from the root module directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在从根模块目录运行我们的基准测试：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Looks like we were able to calculate recurse(20) 392 times in ~5.5 seconds.
    Let’s see if we can improve on that. The original recursive implementation wasn’t
    tail call optimized, so we should be able to get a boost there. Let’s add another
    implementation to the lib folder called tail.js with the following content:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们能够计算 recurse(20) 392 次在 ~5.5 秒内。让我们看看我们是否可以改进这一点。原始的递归实现没有尾调用优化，所以我们应该能够在这里获得提升。让我们在
    lib 文件夹中添加另一个名为 tail.js 的实现，内容如下：
- en: '![](368fig01_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](368fig01_alt.jpg)'
- en: 'Now, add the test to our benchmark/index.js file and see if we did any better
    by adding the implementation to the top of the file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将测试添加到 benchmark/index.js 文件中，看看通过在文件顶部添加实现我们是否做得更好：
- en: '![](368fig02_alt.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](368fig02_alt.jpg)'
- en: 'Let’s see how we did:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做得怎么样：
- en: '![](369fig01_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](369fig01_alt.jpg)'
- en: 'Wow! Tail position really helped speed up our Fibonacci calculation. So let’s
    switch that to be our default implementation in our main index.js file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！尾递归真的帮助加快了我们的斐波那契计算。所以让我们将其切换为我们的默认实现，并在我们的主 index.js 文件中：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And make sure our tests pass:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 并确保我们的测试通过：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'No errors; it looks like we’re still good. As noted earlier, a proper tail
    call implementation will still blow our stack when it gets too large, due to it
    not being supported yet in JavaScript. So let’s try one more implementation and
    see if we can get any better. To avoid a stack overflow on larger sequences of
    numbers, let’s make an iterative implementation and create it at lib/iter.js:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误；看起来我们仍然没问题。如前所述，由于 JavaScript 中尚未支持，适当的尾调用实现仍然会在堆栈太大时崩溃。所以让我们再尝试一个实现，看看我们是否能做得更好。为了避免在较大的数字序列上发生堆栈溢出，让我们创建一个迭代实现，并在
    lib/iter.js 中创建它：
- en: '![](369fig02_alt.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](369fig02_alt.jpg)'
- en: 'Let’s add this implementation to the benchmark/index.js file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个实现添加到 benchmark/index.js 文件中：
- en: '![](369fig03_alt.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](369fig03_alt.jpg)'
- en: 'Let’s see how we did:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做得怎么样：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An iterative approach turns out to be 4x faster than the tail version, and
    2830x faster than the original function. Looks like we have a fastfib indeed,
    and have proven our implementation. Let’s update our benchmark/index.js file to
    assert that iter should be the fastest now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代方法比尾递归版本快 4 倍，比原始函数快 2830 倍。看起来我们确实有一个快速斐波那契算法，并且已经证明了我们的实现。让我们更新 benchmark/index.js
    文件以断言 iter 现在应该是最快的：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then update our main index.js to point to our fastest version:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新我们的主 index.js 以指向我们最快的版本：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And test that our implementation is still correct:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 并测试我们的实现是否仍然正确：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'No errors still, so we’re good! If we later find that V8 optimizes tail call
    flows to be even faster than our iterative approach, our benchmark test will fail
    and we can switch implementations. Let’s review our overall module structure at
    this point:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然没有错误，所以我们没问题！如果我们后来发现 V8 优化尾调用流程比我们的迭代方法更快，我们的基准测试将失败，我们可以切换实现。现在让我们回顾一下我们的整体模块结构：
- en: '![](370fig01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](370fig01.jpg)'
- en: Looks like we’ve proved our idea. What’s important to take away is to experiment!
    Try different implementations! You likely won’t get it right initially, so take
    this time to experiment until you’re satisfied. In this particular technique,
    we tried three different implementations until we landed one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经证明了我们的想法。重要的是要吸取的教训是实验！尝试不同的实现！你很可能一开始不会做对，所以利用这个时间来实验，直到你满意为止。在这个特定的技术中，我们尝试了三种不同的实现，直到我们找到了一个。
- en: 'Time to look at the next step in module development: setting up a package.json
    file.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看模块开发的下一步：设置 package.json 文件。
- en: 13.2\. Building out the package.json file
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 构建 package.json 文件
- en: Now we have an idea we like and we’ve proven that our idea does what we intend
    it to do, we’ll turn to describing that module though a package.json file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个我们喜欢的想法，并且我们已经证明我们的想法确实做了我们想要的事情，我们将通过 package.json 文件来描述这个模块。
- en: Technique 108 Setting up a package.json file
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 108 设置 package.json 文件
- en: A package.json is the central file for managing core data about your module,
    common scripts, and dependencies. Whether you ultimately publish your module or
    simply use it to manage your internal projects, setting up a package.json will
    help drive your development. In this technique we’ll talk about how to get a package.json
    set up and how to populate your package json using npm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: package.json 是管理你的模块核心数据、常用脚本和依赖项的中心文件。无论你最终是否发布你的模块，或者只是用它来管理你的内部项目，设置 package.json
    都将有助于推动你的开发。在这个技术中，我们将讨论如何设置 package.json 以及如何使用 npm 来填充你的 package.json。
- en: Problem
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a package.json file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个 package.json 文件。
- en: Solution
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the built-in npm tools.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的 npm 工具。
- en: Discussion
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The npm init command provides a nice step-by-step interface for setting up
    a package.json. Let’s run this command on our fastfib project directory:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: npm init命令提供了一个很好的逐步界面来设置package.json。让我们在我们的fastfib项目目录中运行此命令：
- en: '![](371fig01_alt.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](371fig01_alt.jpg)'
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Package options
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包选项
- en: For extensive detail on each package option, view the official documentation
    ([https://www.npmjs.org/doc/json.html](https://www.npmjs.org/doc/json.html)) by
    running npm help json.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解每个包选项的详细信息，请运行npm help json查看官方文档([https://www.npmjs.org/doc/json.html](https://www.npmjs.org/doc/json.html))。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Running npm init gets even simpler when you set up your user config ($HOME/.npmrc)
    to prepopulate the values for you. Here are all the options you can set:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置用户配置($HOME/.npmrc)以预先填充值时，运行npm init会变得更加简单。以下是你可以设置的所有选项：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these options, npm init won’t ask you for an author, but instead autopopulate
    the values. It will also default the license to MIT.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项，npm init不会询问你作者，而是自动填充值。它还将默认许可协议为MIT。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A note about existing modules
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于现有模块的说明
- en: If you already have modules that you installed prior to setting up your package.json
    file, npm init is smart enough to add them to package.json with the correct versions!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在设置package.json文件之前安装了模块，npm init足够智能，可以将它们添加到package.json中，并使用正确的版本！
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Once you’ve finished initializing, you’ll have a nice package.json file in
    your directory that looks something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完成初始化后，你将在目录中拥有一个看起来像这样的漂亮的package.json文件：
- en: '![](372fig01_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](372fig01_alt.jpg)'
- en: Now that we have a good start on a package.json file, we can add more properties
    by either directly modifying the JSON file or using other npm commands that modify
    different parts of the file for you. The npm init command just scratches the surface
    on what we can do with a package.json file. We’ll look at more things we can add
    as we continue.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对package.json文件有了良好的开端，我们可以通过直接修改JSON文件或使用其他npm命令来修改文件的不同部分来添加更多属性。npm
    init命令只是触及了我们可以用package.json文件做的事情的表面。随着我们继续前进，我们将查看我们可以添加的更多内容。
- en: In order to look at more package.json configuration and other aspects of module
    development, let’s head to the next technique.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看更多的package.json配置和模块开发的其它方面，让我们转到下一个技巧。
- en: Technique 109 Working with dependencies
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧109：处理依赖项
- en: 'Node has over 80,000 published modules on npm. In our fastfib module, we’ve
    already tapped into one of those: the benchmark module. Having dependencies well
    defined in our package.json file helps maintain the integrity of our module when
    it’s installed and worked on by ourselves and others. A package.json file tells
    npm what to fetch and *at what version* to fetch our dependencies when using npm
    install. Failing to include dependencies inside our package.json file will result
    in errors.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Node在npm上发布了超过80,000个模块。在我们的fastfib模块中，我们已经利用了其中之一：基准模块。在package.json文件中明确定义依赖项有助于维护我们模块的完整性，无论是我们自己还是其他人安装和修改时。package.json文件告诉npm在运行npm
    install时需要获取哪些依赖项以及获取哪个版本的依赖项。如果在package.json文件中未包含依赖项，将导致错误。
- en: Problem
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: How do you effectively manage dependencies?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如何有效地管理依赖项？
- en: Solution
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Keep the package.json file in sync with your module requirements using npm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm保持package.json文件与模块需求同步。
- en: Discussion
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The package.json file allows you to define four types of dependency objects,
    shown in [figure 13.3](#ch13fig03).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: package.json文件允许你定义四种类型的依赖项对象，如图13.3所示。
- en: Figure 13.3\. The different types of dependencies
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.3. 依赖项的不同类型
- en: '![](13fig03_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig03_alt.jpg)'
- en: 'The types of dependencies are as listed here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的类型如下所示：
- en: '***dependencies*** —Required for your module to function properly'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***dependencies*** —模块正常工作所必需的'
- en: '***devDependencies*** —Required solely for development, like testing, benchmarking,
    and server reloading tools'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***devDependencies*** —仅用于开发，如测试、基准测试和服务器重新加载工具'
- en: '***optionalDependencies*** —Not required for your module to work, but may enhance
    the functionality in some way'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***optionalDependencies*** —不是你的模块正常工作所必需的，但可能在某些方面增强功能'
- en: '***peerDependencies*** —Requires another module to be installed in order to
    run properly'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***peerDependencies*** —为了正常运行，需要安装另一个模块'
- en: Let’s look at these in turn with our project and talk about adding and removing
    within your package.json file as we go.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看我们的项目，并在进行过程中讨论在package.json文件中添加和删除的内容。
- en: Main and development dependencies
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主依赖项和开发依赖项
- en: 'Currently the package.json file that was generated with npm init has benchmark
    listed in the dependencies object. If we look at our list, that doesn’t hold true
    for a couple reasons. The first is because our main entry point (index.js) will
    never require benchmark in its require chain, so an end user has no need for it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目前使用npm init生成的package.json文件在dependencies对象中列出了benchmark。如果我们查看我们的列表，由于几个原因，这并不成立。第一个原因是，我们的主入口点（index.js）在其require链中永远不会需要benchmark，所以最终用户不需要它：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second reason is because benchmarking is typically a development-only thing
    for those who work on our module. To remove that out of our dependencies, we can
    use npm remove and have it removed from our package.json file using the --save
    flag:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是，基准测试通常只是那些在我们模块上工作的人的开发专属事情。为了从我们的依赖中移除它，我们可以使用npm remove命令，并通过使用--save标志将其从package.json文件中移除：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we can install it into our development dependencies using npm install
    with the --save-dev flag:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用带有--save-dev标志的npm install将其安装到我们的开发依赖中：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now if we look at our package.json file, we’ll see that benchmark is now a
    part of the devDependencies object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们查看我们的package.json文件，我们会看到benchmark现在是devDependencies对象的一部分：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This was somewhat of a brute force way to show you the commands to remove and
    install with npm. We could have also just moved benchmark inside the package.json
    file in our text editor, avoiding the uninstall and re-install.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强制方式来展示如何使用npm移除和安装命令。我们也可以只是将benchmark移动到我们的文本编辑器中的package.json文件内，避免卸载和重新安装。
- en: Now we have benchmark in the right spot, so it won’t be installed when others
    want to use our module.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将benchmark放在了正确的位置，所以当其他人想要使用我们的模块时，它不会安装。
- en: Optional dependencies
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可选依赖
- en: Optional dependencies aren’t required for a project to run, but they will be
    installed along with the regular dependencies. The only difference from normal
    dependencies is that if an optional dependency *fails* to install, it will be
    ignored and the module should continue to install properly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可选依赖不是项目运行的必需品，但它们将与常规依赖项一起安装。与常规依赖项的唯一区别是，如果可选依赖*安装失败*，它将被忽略，并且模块应该继续正确安装。
- en: 'This typically plays out for modules that can get a boost by including a native
    add-on. For example, hiredis is a native C add-on to boost performance for the
    redis module. But it can’t be installed everywhere, so it *attempts* to install,
    but if it fails, the redis module falls back to a JavaScript implementation. A
    typical pattern to check for the dependency in the parent module is this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常适用于可以通过包含原生插件来获得提升的模块。例如，hiredis是用于提升redis模块性能的原生C插件。但它不能在所有地方安装，所以它*尝试*安装，但如果安装失败，redis模块将回退到JavaScript实现。在父模块中检查依赖项的典型模式如下：
- en: '![](374fig01_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](374fig01_alt.jpg)'
- en: Let’s say we wanted to support a larger set of sequence numbers for our fastfib.
    We could add the bignum native add-on to enable that functionality by running
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要支持fastfib的更大范围的序列号。我们可以通过运行以下命令添加bignum原生插件来启用该功能：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we could optionally use that iteration instead if we detect the bignum
    module was able to be installed in our index.js file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们检测到bignum模块能够在我们的index.js文件中安装，我们可以选择性地使用那个迭代：
- en: '![](375fig01_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](375fig01_alt.jpg)'
- en: Unfortunately, the bignum implementation would be much slower, as it can’t be
    optimized by the V8 compiler. We’d be violating our goal of having the fastest
    Fibonacci if we included that optional dependency and implementation, so we’ll
    scratch it out for now. But this illustrates how you may want to use optional
    dependencies (for example, if you wanted to support the highest possible Fibonacci
    numbers as your goal).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，bignum实现会慢得多，因为它不能被V8编译器优化。如果我们包含了这个可选依赖和实现，我们将违反我们拥有最快斐波那契的目标，所以现在我们先将其删除。但这说明了你可能想要如何使用可选依赖（例如，如果你想要支持尽可能高的斐波那契数作为目标）。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Homework
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 家庭作业
- en: The code and tests were intentionally left out for the bignum implementation;
    try implementing a version that uses bignum and see what performance benchmarks
    you get from our test suite.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 故意省略了bignum实现的代码和测试；尝试实现一个使用bignum的版本，并查看从我们的测试套件中获得什么性能基准。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Peer dependencies
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 同级依赖
- en: 'Peer dependencies ([http://blog.nodejs.org/2013/02/07/peer-dependencies/](http://blog.nodejs.org/2013/02/07/peer-dependencies/))
    are the newest to the dependency scene. Peer dependencies say to someone installing
    your module: *I expect this module to exist in your project and to be at this
    version in order for my module to work*. The most common type of this dependency
    is a plugin.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项（[http://blog.nodejs.org/2013/02/07/peer-dependencies/](http://blog.nodejs.org/2013/02/07/peer-dependencies/））是依赖项场景中的最新成员。依赖项告诉安装你的模块的人：“我期望这个模块存在于你的项目中，并且是这个版本，以便我的模块能够工作”。这种依赖项最常见的类型是插件。
- en: Some popular modules that have plugins are
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有插件的流行模块包括
- en: Grunt
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt
- en: Connect
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Connect
- en: winston
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: winston
- en: Mongoose
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose
- en: 'Let’s say we *really* wanted to add a Connect middleware component that calculates
    a Fibonacci number on each request; who wouldn’t, right? In order for that to
    work, we need to make sure the API we write will work against the right version
    of Connect. For example, we may trust that for Connect 2 we can reliably say our
    module will work, but we can’t speak for Connect 1 or 3\. To do this we can add
    the following to our package.json file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们真的想添加一个Connect中间件组件，该组件在每个请求上计算一个斐波那契数；谁不会呢，对吧？为了使它工作，我们需要确保我们编写的API将针对正确的Connect版本工作。例如，我们可能相信对于Connect
    2，我们可以可靠地说我们的模块将工作，但我们不能为Connect 1或3做出保证。为此，我们可以在package.json文件中添加以下内容：
- en: '![](376fig01.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](376fig01.jpg)'
- en: In this technique we looked at the four types of dependencies you can define
    in your package.json file. If you’re wondering what ^1.0.0 or 2.x means, we’ll
    cover that in depth in the next technique, but let’s first talk about updating
    existing dependencies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们探讨了在package.json文件中可以定义的四种依赖类型。如果你想知道^1.0.0或2.x代表什么，我们将在下一个技术中深入探讨，但让我们首先谈谈更新现有依赖项。
- en: Keeping dependencies up to date
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保持依赖项更新
- en: Keeping a module healthy also means keeping your dependencies up to date. Thankfully
    there are tools to help with that. One built-in tool is npm outdated, which will
    strictly match your package.json file as well as all the package.json files in
    your dependencies, to see if any newer versions match.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 保持模块健康也意味着保持你的依赖项更新。幸运的是，有一些工具可以帮助你做到这一点。一个内置的工具是npm outdated，它将严格匹配你的package.json文件以及你依赖项中的所有package.json文件，以查看是否有任何更新的版本匹配。
- en: 'Let’s purposely change our package.json file to make the benchmark module out
    of date, since npm install gave us the latest version:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们故意修改package.json文件，使基准模块过时，因为npm install给我们的是最新版本：
- en: '![](376fig02.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](376fig02.jpg)'
- en: 'Then let’s run npm outdated and see what we get:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们运行npm outdated看看我们得到什么：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looks like we have 1.0.0 currently installed, but according to our package.json
    we just changed, we want the latest package matching ^0.2.0, which will give us
    version 0.2.2\. We also see the latest package available is 1.0.0\. The location
    line will tell us where it found the outdated dependencies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们目前安装的是1.0.0，但根据我们刚刚修改的package.json，我们想要匹配^0.2.0的最新包，这将给我们版本0.2.2。我们还可以看到可用的最新包是1.0.0。位置行将告诉我们它在哪里找到了过时的依赖项。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Outdated dependencies that you directly require
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你直接需要的过时依赖项
- en: Often it’s nice to see just your outdated dependencies, not your subdependencies
    (which can get very large on bigger projects). You can do that by running `npm
    outdated --depth 0`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，只查看你的过时依赖项，而不是子依赖项（在大型项目中可能会变得非常大），会更好。你可以通过运行`npm outdated --depth 0`来实现这一点。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If we want to update to the wanted version, we can run
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更新到期望的版本，我们可以运行
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will install 0.2.2 and update our package.json file to ^0.2.2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装0.2.2并更新我们的package.json文件到^0.2.2。
- en: 'Let’s run npm outdated again:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行npm outdated：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Looks like our current and our desired versions match now. What if we wanted
    to update to the latest? That’s easy: we can install just the latest and save
    it to our package.json by running'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们现在和我们的期望版本匹配了。如果我们想更新到最新版本怎么办？这很简单：我们可以安装最新的版本，并通过运行以下命令将其保存到我们的package.json中：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Version tags and ranges
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 版本标签和范围
- en: Note the use of the @latest tag in order to get the latest published version
    of a module. npm also supports the ability to specify versions and version ranges,
    too! ([https://www.npmjs.org/doc/cli/npm-install.html](https://www.npmjs.org/doc/cli/npm-install.html))
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用@latest标签来获取模块的最新发布版本。npm还支持指定版本和版本范围的能力！([https://www.npmjs.org/doc/cli/npm-install.html](https://www.npmjs.org/doc/cli/npm-install.html))
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve talked a little about version numbers so far, but they really need a technique
    unto their own, as it’s important to understand what they mean and how to use
    them effectively. Understanding semantic versioning will help you define versions
    better for your module and for your dependencies.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止已经谈了一些关于版本号的内容，但它们确实需要一种独特的技巧，因为理解它们的意义和如何有效地使用它们非常重要。理解语义版本控制将帮助你更好地为你的模块和依赖项定义版本。
- en: Technique 110 Semantic versioning
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧110语义版本控制
- en: If you’re not familiar with semantic versioning, you can read up on it at [http://semver.org](http://semver.org).
    [Figure 13.4](#ch13fig04) captures the major points.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉语义版本控制，你可以在[http://semver.org](http://semver.org)上了解更多信息。[图13.4](#ch13fig04)捕捉了主要观点。
- en: Figure 13.4\. Semantic versioning
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4\. 语义版本控制
- en: '![](13fig04_alt.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig04_alt.jpg)'
- en: Here is how it’s described in the official documentation:^([[1](#ch13fn01)])
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在官方文档中描述的：^([[1](#ch13fn01)])
- en: ¹ From [http://semver.org/](http://semver.org/).
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 来自 [http://semver.org/](http://semver.org/).
- en: '*Given a version number MAJOR.MINOR.PATCH, increment the:*'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*给定版本号MAJOR.MINOR.PATCH，增加以下：*'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**1**.  *MAJOR version when you make incompatible API changes,*'
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *当进行不兼容的API更改时，使用MAJOR版本。*'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**2**.  *MINOR version when you add functionality in a backwards-compatible
    manner, and*'
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *当以向后兼容的方式添加功能时，使用MINOR版本。*'
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**3**.  *PATCH version when you make backwards-compatible bug fixes.*'
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *当进行向后兼容的bug修复时，使用PATCH版本。*'
- en: In practice, these rules can be ignored or loosely followed, since, after all,
    *nobody is mandating* your version numbers. Also, many authors like to play around
    with their API in the early stages and would prefer not to be at version 24.0.0
    right away! But semver can give you, as a module author and as a module consumer,
    clues within the version number itself as to what may have happened since the
    last release.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些规则可以被忽略或松散地遵循，因为毕竟，*没有人强制*你的版本号。此外，许多作者喜欢在早期阶段玩弄他们的API，并希望不要立即达到版本24.0.0！但semver可以给你，作为模块作者和模块消费者，在版本号本身中提供关于自上次发布以来可能发生了什么的线索。
- en: In this technique we’ll look at how to use semver effectively within our fastfib
    library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧中，我们将探讨如何在fastfib库中有效地使用semver。
- en: Problem
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use semver effectively in your module and when including dependencies.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在你的模块和依赖项中有效地使用semver。
- en: Solution
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Understand your underlying projects in order to have a safe upgrade path, and
    clearly communicate the intent of your module version.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个安全的升级路径，并清楚地传达你的模块版本意图，你需要了解你底层项目。
- en: Discussion
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'We currently have one development dependency in our project, which looks like
    this in the package.json file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前在项目中有一个开发依赖项，这在package.json文件中看起来像这样：
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is how npm, by default, will include the version inside the package.json
    file. This plays nice for how most modules authors behave:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是npm默认如何在package.json文件中包含版本的方式。这对于大多数模块作者的行为来说是个好主意：
- en: If the version is less than 1.0.0, like ^0.2.0, then allow any greater PATCH
    version to be installed. In the previous technique, we saw this ended up being
    0.2.2 for the benchmark module.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果版本小于1.0.0，例如^0.2.0，那么允许安装任何更高的PATCH版本。在先前的技巧中，我们看到这最终变成了benchmark模块的0.2.2版本。
- en: If the version is 1.0.0 or greater, like ^1.0.0, then allow any greater MINOR
    version to be installed. Typically 1.0.0 is considered stable and MINOR versions
    aren’t breaking in nature.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果版本是1.0.0或更高版本，例如^1.0.0，那么允许安装任何更高的MINOR版本。通常，1.0.0被认为是稳定的，MINOR版本在本质上不会破坏。
- en: This means that when another user installs your module dependencies, they’ll
    get the latest version that’s allowed in your version range. For example, if Benchmark.js
    released version 1.1.0 tomorrow, although you currently have 1.0.0 on your machine,
    they would get version 1.1.0, since it still matches the version range.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当另一个用户安装你的模块依赖项时，他们将会得到你版本范围内允许的最新版本。例如，如果Benchmark.js明天发布了1.1.0版本，尽管你目前机器上有1.0.0版本，但他们将会得到1.1.0版本，因为它仍然匹配版本范围。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Version operators
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 版本运算符
- en: Node supports a whole host of special operators to customize multiple versions
    or version ranges. You can view them in the semver documentation ([https://www.npmjs.org/doc/misc/semver.html](https://www.npmjs.org/doc/misc/semver.html)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Node支持一系列特殊运算符来定制多个版本或版本范围。你可以在semver文档中查看它们（[https://www.npmjs.org/doc/misc/semver.html](https://www.npmjs.org/doc/misc/semver.html))。
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Versioning dependencies
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 依赖项版本控制
- en: 'When writing modules, it can increase the confidence in your dependencies to
    use a specific version number a user will install along with your module. This
    way, you know what you’ve tested will run the same down the dependency chain.
    Since we know our test suite works with benchmark 1.0.0, let’s lock it in to be
    only that version by running the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写模块时，使用用户将安装的特定版本号可以增加对依赖项的信心。这样，你知道你测试过的版本将在依赖链中运行相同。由于我们知道我们的测试套件与基准1.0.0兼容，让我们通过以下命令将其锁定为仅该版本：
- en: '![](378fig01_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](378fig01_alt.jpg)'
- en: 'We could’ve so updated our package.json manually. Let’s take a look at what
    it looks like now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以手动更新我们的package.json。让我们看看它现在的样子：
- en: '![](378fig02.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](378fig02.jpg)'
- en: Now that we’ve locked in our dependency, we can always use npm outdated to see
    if a new version exists and then npm install using the --save-exact flag to update
    our package.json!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经锁定我们的依赖项，我们可以始终使用npm outdated来查看是否存在新版本，然后使用--save-exact标志通过npm install来更新我们的package.json！
- en: Versioning the module
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模块版本化
- en: As already noted, many module authors use versions less than 1.0.0 to indicate
    that the API hasn’t been fully implemented yet and may change in subsequent versions.
    Typically, when the version number hits 1.0.0, there’s some good stability to
    the module, and although the API surface may grow, existing functionality shouldn’t
    change that much. This matches how npm behaves when a module is saved to the package.json
    file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，许多模块作者使用小于1.0.0的版本来表示API尚未完全实现，并且可能在后续版本中发生变化。通常，当版本号达到1.0.0时，模块将具有一定的稳定性，尽管API表面可能会增长，但现有功能不应有太大变化。这符合当模块保存到package.json文件时npm的行为。
- en: Currently we have our fastfib module at version 0.1.0 in the package.json file.
    It’s pretty stable, but there may be other changes we want to make before we give
    it the 1.0.0 status, so we’ll leave it at 0.1.0.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们在package.json文件中将我们的fastfib模块版本设为0.1.0。它相当稳定，但在我们将其提升到1.0.0状态之前，可能还有其他我们想要做出的更改，所以我们将它保持在0.1.0。
- en: The change log
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变更日志
- en: 'It’s also helpful for module authors to have a change log summarizing anything
    users should be aware of when new releases happen. Here’s one such format:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块作者来说，有一个变更日志总结用户在发布新版本时应注意的内容也是有帮助的。以下是一个这样的格式：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Breaking changes, especially in a minor version, should be noted clearly in
    the change log so users know how to prepare for the update. Some authors like
    to keep a change log inside their main readme or have a separate change log file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在变更日志中应清楚地注明重大变更，特别是对于小版本，以便用户知道如何为更新做准备。一些作者喜欢在他们的主要README中保留变更日志或有一个单独的变更日志文件。
- en: We’ve covered some understanding and tooling around versioning our dependencies
    and our module; let’s look at what else we can expose to the consumers of our
    modules.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了关于版本化我们的依赖项和模块的一些理解和工具；让我们看看我们还能向模块的消费者暴露什么。
- en: 13.3\. The end user experience
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3. 最终用户体验
- en: Before we push our module out for consumption, it would be nice to test that
    it actually works. Of course, we already have a test suite, so we know our logic
    is sound, but what is the experience of an end user installing the module? How
    do we expose executable scripts to a user in addition to an API? What versions
    of Node can we support? In this section we’ll take a look at those questions,
    starting with adding executable scripts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将模块推出去供消费之前，测试它实际上是否工作会很好。当然，我们已经有了一个测试套件，所以我们知道我们的逻辑是合理的，但最终用户安装模块时的体验是什么？我们如何除了API之外向用户暴露可执行脚本？我们可以支持哪些版本的Node？在本节中，我们将探讨这些问题，从添加可执行脚本开始。
- en: Technique 111 Adding executable scripts
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧111 添加可执行脚本
- en: 'Want to expose an executable when your module is installed? Express, for example,
    includes an express executable you can run from the command line to help initialize
    new projects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 想要在模块安装时暴露一个可执行文件吗？例如，Express包括一个可以从命令行运行的express可执行文件，可以帮助初始化新项目：
- en: '![](380fig01.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](380fig01.jpg)'
- en: npm itself is an installable module with an npm executable, which we’ve been
    using all over in this chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: npm本身是一个可安装的模块，具有npm可执行文件，我们已经在本章的各个地方使用过它。
- en: Executables can help end users use your module in different ways. In this technique
    we’ll look at adding an executable script to fastfib and include it in our package.json
    to be installed along with our module.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件可以帮助最终用户以不同的方式使用你的模块。在本技巧中，我们将查看如何向fastfib添加一个可执行脚本，并将其包含在我们的package.json中，以便与我们的模块一起安装。
- en: Problem
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: How do you add an executable script?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如何添加一个可执行脚本？
- en: Solution
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: How do you add command-line tools and scripts for a package and link it inside
    the package.json file?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何为包添加命令行工具和脚本，并在package.json文件中链接它们？
- en: Discussion
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: We have our fastfib module built, but what if we wanted to expose a fastfib
    executable to the end user where they could run a command like fastfib 40 and
    get the 40th Fibonacci number printed out? This would allow our module to be used
    on the command line as well as programmatically.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了fastfib模块，但如果我们想向最终用户公开fastfib可执行文件，让他们能够运行类似fastfib 40的命令并打印出第40个斐波那契数，会怎么样？这将允许我们的模块在命令行以及程序化方式下使用。
- en: 'In order to do this, let’s create a bin directory with an index.js file inside
    containing the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们创建一个包含index.js文件的bin目录，其中包含以下内容：
- en: '![](380fig02_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](380fig02_alt.jpg)'
- en: 'Now that we have our application executable, how do we expose it as the fastfib
    command when someone installs our module? For that, we need to update our package.json
    file. Add the following lines underneath main:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的应用程序可执行文件，我们如何将其作为fastfib命令公开，以便有人安装我们的模块时可以使用？为此，我们需要更新我们的package.json文件。在main下面添加以下行：
- en: '![](380fig03_alt.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](380fig03_alt.jpg)'
- en: Testing executables with npm link
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用npm link测试可执行文件
- en: We can test our executable by using npm link. The link command will create a
    global symbolic link to our live module, simulating installing the package globally,
    as a user would if they installed the module globally.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用npm link来测试我们的可执行文件。link命令将创建一个指向我们的实时模块的全局符号链接，模拟全局安装包，就像用户全局安装模块一样。
- en: 'Let’s run npm link from our fastfib directory:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从fastfib目录运行npm link：
- en: '![](381fig01_alt.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](381fig01_alt.jpg)'
- en: 'Now that we’ve globally linked up our executable, let’s try it out:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全局链接了我们的可执行文件，让我们试试它：
- en: '[PRE28]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since these links are in place now, any edits will be reflected globally. Let’s
    update the last line of our bin/index.js file to announce our result:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些链接已经就位，任何编辑都会在全局范围内反映出来。让我们更新bin/index.js文件的最后一行来宣布我们的结果：
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the fastfib executable again, we get our update immediately:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行fastfib可执行文件，我们会立即得到更新：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We’ve added a fastfib executable to our module. It’s important to note that
    everything discussed in this technique is completely cross-platform compatible.
    Windows doesn’t have symbolic links or #! statements, but npm wraps the executable
    with additional code to get the same behavior when you run npm link or npm install.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的模块中添加了一个fastfib可执行文件。重要的是要注意，本技术中讨论的所有内容都是完全跨平台兼容的。Windows没有符号链接或#!语句，但npm通过额外的代码包装可执行文件，以便在运行npm
    link或npm install时获得相同的行为。
- en: Linking is such a powerful tool, we’ve devoted the next technique to it!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是一个如此强大的工具，我们将在下一个技术中专门介绍它！
- en: Technique 112 Trying out a module
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号112：尝试模块
- en: Besides using npm link to test our executables globally, we can use npm link
    to try out our module elsewhere. Say we wanted to try out our shiny new module
    in another project and see if it’ll work out. Instead of publishing our module
    and installing it, we can just link to it and play around with the module as we
    see it used in the context of another project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用npm link在全局范围内测试我们的可执行文件外，我们还可以使用npm link在其他地方尝试我们的模块。比如说，我们想在另一个项目中尝试我们闪亮的新模块，看看它是否适用。我们不必发布我们的模块并安装它，我们只需链接到它，并像在另一个项目的上下文中使用它一样玩弄模块。
- en: Problem
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to try out your module before publishing it *or* you want to make changes
    to your module and test them in another project without having to republish first.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在发布模块之前尝试它，或者你想要修改你的模块并在另一个项目中测试这些更改，而不必首先重新发布。
- en: Solution
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use npm link
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm link
- en: Discussion
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: In the previous technique we showed how to use npm link to test an executable
    script’s behavior. This showed that we can test our executables while we’re developing,
    but now we want to simulate a local install of our module, not a global one.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种技术中，我们展示了如何使用npm link来测试可执行脚本的运行行为。这表明我们可以在开发过程中测试我们的可执行文件，但现在我们想要模拟模块的本地安装，而不是全局安装。
- en: Let’s start by setting up another project. Since we started this chapter with
    our cancerous implementation of a Fibonacci web server, let’s go full circle and
    make a little project that exposes fastfib as a web service.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置另一个项目开始。由于我们本章从我们癌症般的斐波那契网络服务器实现开始，让我们从头到尾，创建一个小项目，将fastfib作为Web服务公开。
- en: 'Create a new project called fastfibserver and put a single server.js file inside
    with the following content:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为fastfibserver的新项目，并在其中放入一个名为server.js的单个文件，内容如下：
- en: '![](382fig01_alt.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](382fig01_alt.jpg)'
- en: 'We have our server set up, but if we were to run node server, it wouldn’t work
    yet because we haven’t installed the fastfib module in this project yet. To do
    that we use npm link:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了服务器，但如果我们要运行node server，它现在还不会工作，因为我们还没有在这个项目中安装fastfib模块。为此，我们使用npm
    link：
- en: '![](382fig02_alt.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](382fig02_alt.jpg)'
- en: 'Now if we run our web server, it will run successfully:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们运行我们的Web服务器，它将成功运行：
- en: '[PRE31]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: And a visit to our site will give us the 40th Fibonacci number, as shown in
    [figure 13.5](#ch13fig05).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们的网站将给出第40个斐波那契数，如图13.5所示。
- en: Figure 13.5\. Sample output from fastfibserver
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.5\. fastfibserver的示例输出
- en: '![](13fig05.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](13fig05.jpg)'
- en: '|  |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Another way to link
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 另一种链接方式
- en: Since we already linked our module globally in the previous technique running
    npm link inside the fastfib project, we could’ve also run npm link fastfib in
    our fastfibserver project to set up the link.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在之前的技术中已经将我们的模块全局链接到package.json中，在fastfib项目中运行npm link，我们也可以在fastfibserver项目中运行npm
    link fastfib来设置链接。
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using npm link also helps a lot in debugging your module in the context of another
    module. Edge cases come up that can best be debugged while running the project
    that’s requiring your module. Once you npm link the module, any changes will take
    effect immediately without the need to republish and re-install. This allows you
    to fix the problem in your module’s code base as you debug.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用npm link也有助于在另一个模块的上下文中调试你的模块。在运行需要你的模块的项目时，会出现一些边缘情况，这些情况最好在运行项目时调试。一旦你npm
    link了模块，任何更改将立即生效，无需重新发布和重新安装。这允许你在调试时修复模块代码库中的问题。
- en: So far we’ve defined and implemented our module with tests, set up our dependencies,
    locked our versions down for our dependencies and our module, added a command-line
    executable, and practiced using our module. Next we’ll look at another aspect
    of the package.json file—the engines section, and testing our module across multiple
    versions of Node.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义并实现了我们的模块，包括测试，设置了我们的依赖项，锁定了我们依赖项和模块的版本，添加了命令行可执行文件，并练习了使用我们的模块。接下来，我们将看看package.json文件的另一个方面——engines部分，以及跨多个Node版本测试我们的模块。
- en: Technique 113 Testing across multiple Node versions
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧113 在多个Node版本上测试
- en: Unfortunately, not everybody is able to upgrade to the latest and greatest Node
    version when it comes on the scene. It takes time for companies to adapt all their
    code to newer versions, and some may never update. It’s important that we know
    what versions of Node our module can run on so npm knows who can install and run
    it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，并不是每个人都能在Node版本发布时升级到最新版本。公司需要时间来适应所有代码到新版本，有些可能永远不会更新。了解我们的模块可以在哪些版本的Node上运行，以便npm知道谁可以安装和运行它，这一点很重要。
- en: Problem
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test your module across multiple versions of Node, and you want
    your application to be installed only for those versions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在多个版本的Node上测试你的模块，并且只想为这些版本安装你的应用程序。
- en: Solution
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Keep the engines object accurate in the package.json file by running tests across
    multiple versions of Node.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在多个版本的Node上运行测试，确保package.json文件中的engines对象准确无误。
- en: Discussion
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The npm init script we ran when first setting up our package.json doesn’t include
    an engines section, which means that npm will install it on *any* version of Node.
    At first glance, we may think that’s OK, since we’re running pretty vanilla JavaScript
    code. But we don’t really know that without actually testing it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在首次设置package.json时运行的npm init脚本不包括engines部分，这意味着npm将在任何版本的Node上安装它。乍一看，我们可能会认为这没问题，因为我们运行的是相当原始的JavaScript代码。但如果没有实际测试，我们真的不知道。
- en: 'Typically patch version updates (Node 0.10.2 to 0.10.3, for instance) shouldn’t
    break your modules. But it’s a good idea at a minimum to test your modules across
    minor and major version updates, as V8 receives a decent upgrade and Node’s APIs
    can change. Currently, we’ve been working off 0.10 branch of Node and things have
    been working well. So let’s start with that. Let’s add the following to the end
    of our package.json file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，补丁版本更新（例如Node 0.10.2到0.10.3）不应该破坏你的模块。但至少测试你的模块在次要和主要版本更新之间是一个好主意，因为V8得到了相当大的升级，Node的API可能会发生变化。目前，我们一直在使用Node的0.10分支，一切运行良好。所以，让我们从以下内容开始，将其添加到package.json文件的末尾：
- en: '![](383fig01.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](383fig01.jpg)'
- en: That’s a start, but it really seems like we should be able to support earlier
    versions of Node. How do we test for that?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开始，但实际情况似乎我们应该能够支持更早版本的Node。我们如何测试这一点呢？
- en: 'A variety of popular options are available:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的流行选项有很多：
- en: Install multiple versions of Node on your machine
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的机器上安装多个 Node 版本
- en: Use Travis CI’s multi-Node version support ([https://travis-ci.org/](https://travis-ci.org/))
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Travis CI 的多 Node 版本支持 ([https://travis-ci.org/](https://travis-ci.org/))
- en: Use a third-party multiversion test module that works for your environment (like
    dnt—[https://github.com/rvagg/dnt](https://github.com/rvagg/dnt))
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适用于您环境的第三方多版本测试模块（如 dnt—[https://github.com/rvagg/dnt](https://github.com/rvagg/dnt))
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: About Node versions
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于 Node 版本
- en: In Node, all odd-numbered minor versions are considered unstable. So 0.11.0
    is the unstable version for 0.12.0, and so on. You shouldn’t need to test any
    existing unstable releases. Typically, module authors will only test the latest
    unstable release as it nears completion.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，所有奇数版本的次要版本都被视为不稳定。因此，0.11.0 是 0.12.0 的不稳定版本，依此类推。您通常不需要测试任何现有的不稳定发布版本。通常，模块作者只会测试即将完成的最新不稳定版本。
- en: '|  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For our technique we’ll focus on installing multiple versions of Node, as that
    can come in handy for testing new features in upcoming versions of Node, as well
    as for testing our module.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的技术，我们将专注于安装多个 Node 版本，因为这可以在测试 Node 即将发布的版本中的新功能以及测试我们的模块时派上用场。
- en: 'The tool we’ll use is nvm ([https://github.com/creationix/nvm](https://github.com/creationix/nvm);
    the Windows counterpart is nvmw: [https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw)).
    The following instructions will be for nvm, but the commands will be similar in
    nvmw once installed.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用的工具是 nvm ([https://github.com/creationix/nvm](https://github.com/creationix/nvm);
    Windows 的对应版本是 nvmw: [https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw)).
    以下说明将针对 nvm，但一旦安装，nvmw 的命令也将相似。'
- en: To install, run
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时，运行
- en: '![](384fig01_alt.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](384fig01_alt.jpg)'
- en: 'Now that we have it installed, let’s go ahead and test Node version 0.8 of
    our fastfib module. First let’s install Node 0.8:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了它，让我们继续测试我们的 fastfib 模块的 Node 0.8 版本。首先让我们安装 Node 0.8：
- en: '[PRE32]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: nvm went out and grabbed the latest version of the 0.8 branch to test against.
    We could have specified a patch if we wanted, but this will work for now. Note
    how we’re also using this version. We can validate that by running
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: nvm 去获取了 0.8 分支的最新版本以进行测试。如果我们想指定一个补丁，我们可以这样做，但现阶段这已经足够了。注意我们也在使用这个版本。我们可以通过运行以下命令来验证：
- en: '[PRE33]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, all Node and npm interaction happens within an isolated environment just
    for Node 0.8.26\. If we were to install more versions, they would be in their
    own isolated environments. We use nvm use to switch between them. For example,
    if you wanted to go back to your system install of Node, you could do the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有 Node 和 npm 交互都在为 Node 0.8.26 定制的隔离环境中进行。如果我们要安装更多版本，它们将各自在它们自己的隔离环境中。我们使用
    nvm use 在它们之间切换。例如，如果您想切换回系统安装的 Node 版本，您可以执行以下操作：
- en: '[PRE34]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And to go back to Node version 0.8.26:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要回到 Node 版本 0.8.26：
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s run our test suite in 0.8.26 and see how we do:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 0.8.26 上运行我们的测试套件，看看我们做得怎么样：
- en: '[PRE36]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Looks good! Let’s update our package.json to include 0.8 versions:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！让我们更新我们的 package.json 以包括 0.8 版本：
- en: '![](385fig01.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](385fig01.jpg)'
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What if my module loses support for a particular Node version?
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如果我的模块失去了对特定 Node 版本的支持怎么办？
- en: That’s totally fine. Users of an older version of Node will get the last-published
    package that’s supported for their version.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题。使用较旧版本 Node 的用户将获得适用于其版本的最新发布的支持包。
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve tested Node version 0.10 and 0.8; try testing a few other versions on
    your own. When you’re done, switch back to the system Node version.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经测试了 Node 版本 0.10 和 0.8；请尝试测试您自己的几个其他版本。完成后，请切换回系统 Node 版本。
- en: Now that we’ve looked through a variety of steps to get our module into a usable
    state for others, let’s publish it!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一系列步骤，使我们的模块处于可用的状态，以便其他人使用，让我们发布它！
- en: 13.4\. Publishing
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 发布
- en: As we wrap up this chapter, we’ll turn our focus on module distribution by looking
    at publishing modules publicly on npm or privately for internal use.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章时，我们将通过查看在 npm 上公开发布模块或私下内部使用模块来关注模块的发布。
- en: Technique 114 Publishing modules
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 114 发布模块
- en: Whew! We’ve gone through a lot of different techniques getting our module ready
    to publish. We know there will likely be changes, but we’re ready to release our
    first version out in the wild to be required in other projects. This technique
    explores the various aspects of publishing.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！我们已经通过许多不同的技术使我们的模块准备好发布。我们知道可能会有变化，但我们准备将我们的第一个版本发布到野外，以便在其他项目中作为依赖项使用。这项技术探讨了发布的各个方面。
- en: Problem
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to get your module published publicly.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将您的模块公开发布。
- en: Solution
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Register with npm if you haven’t and npm publish.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注册npm，请注册并发布。
- en: Discussion
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If it’s your first time publishing a module, you’ll need to register yourself
    with npm. Thankfully, it couldn’t be any easier. Run the following command and
    follow the prompts:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次发布模块，你需要自己在npm上注册。幸运的是，这非常简单。运行以下命令并按照提示操作：
- en: '[PRE37]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once finished, npm will save your credentials to the .npmrc file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，npm会将你的凭据保存到.npmrc文件中。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Changing existing account details
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更改现有账户详情
- en: The adduser command can also be used to change account details (except username)
    and register a fresh install with an existing account.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: adduser命令也可以用来更改账户详情（除了用户名）并使用现有账户注册新安装。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once registered, publishing a module is just as simple as adding a user. But
    before we get to that, let’s cover some good practices when publishing modules.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，发布模块就像添加用户一样简单。但在我们深入之前，让我们了解一下发布模块时的一些良好实践。
- en: Before you publish
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在发布之前
- en: 'One of the biggest things before publishing is to review [technique 110](#ch13lev2sec4)
    about semantic versioning:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布之前，最重要的是回顾关于语义版本化的[技巧110](#ch13lev2sec4)：
- en: Does your version number accurately reflect the changes since the last push?
    If this is your first push, this doesn’t matter as much.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的版本号是否准确地反映了自上次推送以来的更改？如果你是第一次推送，这并不那么重要。
- en: Do you do a changelog update with your release? Although not required, it can
    be extremely helpful to those who depend on your project to get a high-level view
    of what they can expect in this release.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在发布时更新了变更日志吗？虽然这不是必需的，但对于依赖你的项目的用户来说，这可以非常有帮助，让他们对这次发布可以期待什么有一个高层次的认识。
- en: Also, check whether your tests pass to avoid publishing broken code.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查你的测试是否通过，以避免发布有缺陷的代码。
- en: Publishing to npm
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布到npm
- en: 'Once you’re ready to publish, it’s as simple as running the following command
    from the project root directory:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好发布，只需从项目根目录运行以下命令即可：
- en: '[PRE38]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: npm will respond with the success or failure of the publish. If successful,
    it will indicate the version that was pushed to the public registry.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: npm会响应发布操作的成功或失败。如果成功，它将指示已推送到公共注册表的版本。
- en: '*Can you tell that npm wants you to get your modules out there as painlessly
    as possible?*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*你能感觉到npm希望你尽可能轻松地将模块发布出去吗？*'
- en: Undoing a publish
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 撤销发布
- en: Although we want a publish to go well, sometimes we miss things we wanted to
    release, or have some things we realize are broken after the fact. It’s recommended
    you don’t unpublish modules (although the ability exists). The reason is that
    people who are depending on that module and/or version can no longer get it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望发布顺利进行，但有时我们会错过想要发布的某些内容，或者在实际发布后发现有些内容是错误的。建议你不要撤销模块（尽管存在这种能力）。原因是依赖该模块和/或版本的用户的获取将不再可能。
- en: 'Typically, make the fix, increase the PATCH version, and npm publish again.
    A simple way to do that is by running the following commands:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，修复问题，增加补丁版本，然后再次运行npm publish。这样做的一个简单方法是运行以下命令：
- en: '![](386fig01.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](386fig01.jpg)'
- en: npm *does not* allow you to publish over an existing version, since that also
    would affect people who have already downloaded that particular version.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: npm *不允许*你覆盖现有版本，因为这也会影响到已经下载了该特定版本的用户。
- en: There are some cases where you really want to discourage users from using a
    particular version. For example, maybe a severe security flaw was fixed in versions
    0.2.5 and above, yet you have users depending on versions earlier than that. npm
    can help you get the word out by using npm deprecate.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，你真的希望阻止用户使用特定版本。例如，可能在0.2.5及更高版本中修复了严重的安全漏洞，但你还有用户依赖于比这更早的版本。npm可以通过使用npm
    deprecate来帮助你传达这一信息。
- en: 'Let’s say in the future, we find a critical bug in fastfib version 0.2.5 and
    below, and we wanted to warn users who are using those modules. We could run the
    following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在未来，我们发现fastfib版本0.2.5及以下存在一个关键漏洞，我们想要警告使用这些模块的用户。我们可以运行以下命令：
- en: '![](386fig02_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](386fig02_alt.jpg)'
- en: Now if any user installs fastfib 0.2.5 or less, they’ll receive the specified
    warning from npm.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果任何用户安装了fastfib 0.2.5或更低版本，他们将收到npm指定的警告。
- en: Technique 115 Keeping modules private
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧115 保持模块私有
- en: Although open source can be a fun and collaborative environment, there are times
    when you want your project to remain private. This is especially true for work
    done for clients. It can also be handy to bake a module first internally before
    deciding whether to publish. npm can safeguard your module and keep it private
    for you. In this technique we’ll talk about configuring your module to stay private
    and including private modules in your projects.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然开源可以是一个有趣且协作的环境，但有时你希望你的项目保持私有。这尤其适用于为客户完成的工作。在决定是否发布之前，先在内部构建一个模块也可能很有用。npm
    可以保护你的模块，并为你保持其私有性。在这个技术中，我们将讨论如何配置你的模块以保持私有，以及如何在项目中包含私有模块。
- en: Problem
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to keep your module private and use it internally.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望保持你的模块私有并内部使用。
- en: Solution
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Configure private in your package.json file and share it internally.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 package.json 文件中配置私有，并在内部共享。
- en: Discussion
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Let’s say we want to let fastfib to only be used internally. To ensure it doesn’t
    get accidentally published, we add the following to our package.json file:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让 fastfib 只在内部使用。为了确保它不会意外发布，我们在 package.json 文件中添加以下内容：
- en: '[PRE39]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This tells npm to refuse to publish your package with npm publish.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这会告诉 npm 不要使用 npm publish 发布你的包。
- en: This setting works well for client-specific projects. But what if you have a
    core set of internal modules you want to share across projects within your development
    team? For that there are a few different options.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置对于特定客户端的项目来说效果很好。但如果你想在开发团队内部跨项目共享一组核心模块，那该怎么办呢？为此，有几个不同的选项。
- en: Sharing private modules with Git
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Git 共享私有模块
- en: npm supports a couple of ways you can share your internal modules that are minimal
    to set up out of the box. If you’re using a Git repository, npm makes this incredibly
    simple to do.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: npm 支持几种你可以分享内部模块的方式，这些方式设置起来非常简单。如果你使用 Git 仓库，npm 使这变得非常简单。
- en: Let’s use GitHub as an example (although it can be *any* Git remote). Let’s
    say we had our private repo at
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以 GitHub 为例（尽管它可以是 *任何* Git 远程）。假设我们的私有仓库位于
- en: '[PRE40]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can then include it in our package.json dependencies with npm install (or
    modify the package.json directly):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 npm install 将其包含在我们的 package.json 依赖项中（或直接修改 package.json）：
- en: '[PRE41]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Pretty sweet! This by default will pull the contents of the master branch.
    If we wanted to specify a particular commit-ish (tag, branch, or SHA-1—[http://git-scm.com/book/en/Git-Internals-Git-Objects](http://git-scm.com/book/en/Git-Internals-Git-Objects)),
    we can do that too! Here are some examples within a package.json file:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 非常棒！默认情况下，这将拉取 master 分支的内容。如果我们想指定一个特定的 commit-ish（标签、分支或 SHA-1—[http://git-scm.com/book/en/Git-Internals-Git-Objects](http://git-scm.com/book/en/Git-Internals-Git-Objects)），我们也可以这样做！以下是一些在
    package.json 文件中的示例：
- en: '![](387fig01_alt.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](387fig01_alt.jpg)'
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Including public repositories
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包含公开仓库
- en: You may have guessed it, but you can also use public Git repositories as well.
    This can be helpful if you really need a feature or fix that hasn’t been published
    on npm yet. For more examples, see the package.json documentation ([https://www.npmjs.org/doc/json.html#Git-URLs-as-Dependencies](https://www.npmjs.org/doc/json.html#Git-URLs-as-Dependencies)).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，你还可以使用公开的 Git 仓库。如果你真的需要一些尚未发布到 npm 的功能或修复，这可能会很有帮助。更多示例，请参阅 package.json
    文档（[https://www.npmjs.org/doc/json.html#Git-URLs-as-Dependencies](https://www.npmjs.org/doc/json.html#Git-URLs-as-Dependencies)）。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Sharing private modules as a URL
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将私有模块作为 URL 共享
- en: 'If you aren’t using Git or prefer to have your build system spit out packages,
    you can specify a URL endpoint where npm can find a tarball. To package up your
    module, you can use the tar command like the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 Git 或者希望你的构建系统输出包，你可以指定一个 npm 可以找到 tarball 的 URL 端点。要打包你的模块，你可以使用以下
    tar 命令：
- en: '![](388fig01_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](388fig01_alt.jpg)'
- en: '[PRE42]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From here, we can throw that file on a web server and install it using the
    following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以将这个文件上传到 web 服务器，并使用以下命令安装：
- en: '[PRE43]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A note about public endpoints
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于公开端点的说明
- en: Although typically not used often, tarballs of packages can be used with public
    endpoints too; it’s usually better and easier to publish to npm instead.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常不常用，但包的 tarball 也可以与公开端点一起使用；通常来说，发布到 npm 更为方便和简单。
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Sharing modules with a private npm registry
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用私有 npm 仓库共享模块
- en: Another option for private repositories is hosting your own private npm registry
    and having npm publish push to that repository. For the complete functionality
    of npm, this will require an installation of a recent version of CouchDB, which,
    in turn, requires Erlang.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于私有仓库，另一个选项是托管你自己的私有 npm 注册表，并让 npm publish 将内容推送到该仓库。为了实现 npm 的完整功能，这需要安装
    CouchDB 的最新版本，而 CouchDB 又需要 Erlang。
- en: Since this involves a variety of tricks/headaches depending on your operating
    system, we won’t cover setting up an instance here. Hopefully, the process will
    get streamlined soon. If you want to experiment, check out the npm-registry-couchapp
    project ([https://github.com/npm/npm-registry-couchapp](https://github.com/npm/npm-registry-couchapp)).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这涉及到根据你的操作系统而定的各种技巧/头痛问题，我们在这里不会涵盖设置实例的过程。希望这个过程很快就会简化。如果你想进行实验，请查看 npm-registry-couchapp
    项目 ([https://github.com/npm/npm-registry-couchapp](https://github.com/npm/npm-registry-couchapp))。
- en: 13.5\. Summary
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5. 摘要
- en: Third-party modules are where innovation happens. npm makes this trivial and
    fun! With the rise of social coding sites like GitHub, collaboration on modules
    is also easy to do. In this chapter we looked at many different aspects of module
    development. Let’s summarize what we learned.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方模块是创新发生的地方。npm 使得这一切变得简单而有趣！随着像 GitHub 这样的社交编码网站的兴起，模块的协作也变得容易。在本章中，我们探讨了模块开发的许多不同方面。让我们总结一下我们学到了什么。
- en: 'When starting to work on a module, consider the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始工作于一个模块时，考虑以下事项：
- en: Define your module idea. Can you summarize it in one sentence?
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你的模块想法。你能用一句话总结它吗？
- en: Check your module idea. Is there another module out there doing what you want
    to do? Search it out with npm search or npmjs.org.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你的模块想法。是否已有其他模块在做你想要做的事情？使用 npm search 或 npmjs.org 进行搜索。
- en: Once you’ve landed on an idea, prove it out. Start with a simple API you’d like
    to work with. Write an implementation and tests installing any dependencies you
    need along the way.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了一个想法，就证明它。从一个你想要与之合作的简单 API 开始。编写实现和测试，并在过程中安装任何需要的依赖项。
- en: 'After you’ve proven your idea (or perhaps during), think about these things:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在你证明你的想法（或可能是在此期间）之后，考虑以下事项：
- en: Have you initialized your package.json file? Run npm init to get a skeleton
    representing the state of the current project.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经初始化了 package.json 文件吗？运行 npm init 以获取表示当前项目状态的骨架。
- en: Work with your dependencies. Are some optional, development-only? Make sure
    that’s indicated in your package.json file.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的依赖项一起工作。有些是可选的，仅用于开发吗？确保在 package.json 文件中指明这一点。
- en: Check your semver ranges in package.json. Do you trust the version ranges specified
    in your package.json file? Check for updates with npm outdated.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 package.json 中的 semver 范围。你信任 package.json 文件中指定的版本范围吗？使用 npm outdated 检查更新。
- en: What versions of Node will your code run on? Check it out by using nvm or a
    build system like Travis CI. Specify the version range in your package.json file.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码将在哪些版本的 Node 上运行？使用 nvm 或像 Travis CI 这样的构建系统来检查。在 package.json 文件中指定版本范围。
- en: Try out your module using npm link in another project.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个项目中使用 npm link 尝试你的模块。
- en: When you’re ready to publish, it’s as simple as npm publish. Consider keeping
    a changelog for your users and try to follow semantic versioning, so users have
    a reasonable idea of what to expect from version to version.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好发布时，只需使用 npm publish 即可。考虑为你的用户提供变更日志，并尝试遵循语义版本控制，这样用户对每个版本可以期待的内容有一个合理的了解。
- en: And that’s a wrap for this book! We hope at this point you were able to grasp
    the core foundations of Node, understand how to apply those foundations in real-world
    scenarios, and how to go beyond standard development by writing your own Node
    modules (which we hope to see on npm!).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书就到这里了！我们希望到这一点，你已经能够掌握 Node 的核心基础，了解如何在现实场景中应用这些基础，以及如何通过编写自己的 Node 模块（我们希望能在
    npm 上看到！）来超越标准开发。
- en: 'A growing Node community is available to help you continue to level up on your
    journey. Please check out the appendix to make the most of that community. If
    you have specific questions for us, please visit the #nodejsinpractice Google
    group ([https://groups.google.com/forum/#!forum/nodejsinpractice](https://groups.google.com/forum/#!forum/nodejsinpractice)),
    and thanks for reading!'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '一个不断增长的 Node 社区可以帮你继续提升你的旅程。请查看附录，以充分利用这个社区。如果你对我们有任何具体问题，请访问 #nodejsinpractice
    Google 群组 ([https://groups.google.com/forum/#!forum/nodejsinpractice](https://groups.google.com/forum/#!forum/nodejsinpractice))，感谢阅读！'
