- en: 5 Iterables and iterations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 可迭代对象和迭代
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding iterables and iterators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可迭代对象和迭代器
- en: Creating common data containers using iterables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可迭代对象创建常见数据容器
- en: Using list, dictionary, and set comprehensions for instantiation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表、字典和集合推导式进行实例化
- en: Improving for-loop iterations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高for循环迭代
- en: Using continue, break, and else in for and while loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在for和while循环中使用continue、break和else
- en: Previous chapters mentioned iterables several times, and we know that lists,
    tuples, and many other built-in data types are iterables. But we haven’t explicitly
    defined the concept of iterables. We say that these data types are iterables,
    but we haven’t discussed why. In this chapter, you’ll find out how they constitute
    iterables. More importantly, we’ll explore how we can create the most common data
    models, such as lists and dictionaries, from other iterables by using constructors
    and comprehensions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章多次提到了可迭代对象，我们知道列表、元组以及许多其他内置数据类型都是可迭代的。但我们还没有明确地定义可迭代对象的概念。我们说这些数据类型是可迭代的，但并没有讨论为什么。在本章中，你将了解到它们是如何构成可迭代的。更重要的是，我们将探讨如何通过使用构造器和推导式从其他可迭代对象中创建最常见的数据模型，例如列表和字典。
- en: One essential mechanism for Python or any other programming language to perform
    repetitive work is for-loop iterations (or while loop, with for loops being more
    prevalent). In each iteration, the same operations can be applied to each item
    of the iterables. We have a variety of ways to improve the performance of for
    loops by applying built-in functions, such as enumerate and zip, and by using
    optional state-ments, including break and continue. In this chapter, you’ll learn
    about these topics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python或其他任何编程语言来说，执行重复性工作的一个基本机制是for循环迭代（或while循环，其中for循环更为常见）。在每次迭代中，相同的操作可以应用于可迭代对象的每个项目。我们可以通过应用内置函数，如enumerate和zip，以及使用可选语句，包括break和continue，来有多种方法提高for循环的性能。在本章中，你将了解这些主题。
- en: 5.1 How do I create common data containers using iterables?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 我如何使用可迭代对象创建常见的数据容器？
- en: Iterables shouldn’t be strangers to you. Chapter 2 reviewed essential techniques
    of processing strings, and strings are iterables that consist of characters. Chapter
    3 discussed several built-in data containers, including lists, tuples, sets, and
    dictionaries, all of which are iterables that consist of individual items (or
    key-value pairs). Chapter 4 examined the shared methods among sequence data types,
    and all sequence data types are iterables. As you can see, iterables are prevalent
    in Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象不应该对你来说是陌生人。第二章回顾了处理字符串的基本技术，字符串是由字符组成的可迭代对象。第三章讨论了几个内置数据容器，包括列表、元组、集合和字典，所有这些都是由单个项目（或键值对）组成的可迭代对象。第四章考察了序列数据类型之间的共有方法，所有序列数据类型都是可迭代的。正如你所看到的，可迭代对象在Python中很普遍。
- en: 'Indeed, iterables are an important base type on which many built-in data structures
    are built. Consider the following scenario. In the task management app, you have
    two separate sources of data, with one being the task ID numbers and the other
    being the task titles. You need to create a dict object that consists of ID-title
    pairs:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，可迭代对象是许多内置数据结构构建的重要基础类型。考虑以下场景。在任务管理应用中，你有两个独立的数据来源，一个是任务ID号，另一个是任务标题。你需要创建一个包含ID-标题对的字典对象：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create the desired output, beginners might think of using a for loop:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建所需输出，初学者可能会想到使用for循环：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A seemingly more advanced solution involves dictionary comprehension (section
    5.2) and the use of the zip function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个看似更高级的解决方案涉及字典推导式（第5.2节）和zip函数的使用：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These solutions aren’t the best, however, because they don’t take advantage
    of the fact that dict, as well as many built-in data containers, takes iterables
    directly for instantiation. This section first reviews what iterables are and
    then moves on to discuss one key technique: instantiating common built-in data
    containers by using iterables.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些解决方案并不是最好的，因为它们没有利用到字典以及许多内置数据容器可以直接接受可迭代对象进行实例化的这一事实。本节首先回顾了什么是可迭代对象，然后继续讨论一个关键技术：通过使用可迭代对象来实例化常见内置数据容器。
- en: Instance, instantiation, constructor, and construction
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实例、实例化、构造函数和构建
- en: In object-oriented programming (OOP) languages, including Python, the essential
    data models are classes, including built-in classes such as list, dict, and tuple,
    and custom classes that we create in our own projects. When we create an object
    that belongs to the class, such as a dict object—num_dict = dict(one=1, two=2)—we
    say that we create an instance of the class; thus, num_dict is an instance of
    the dict class. Relatedly, the process of creating an instance is known as instantiation*.*
    The same instantiation concept applies to custom classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）语言中，包括Python，基本的数据模型是类，包括内置类如列表、字典和元组，以及我们在自己的项目中创建的自定义类。当我们创建属于类的对象，例如一个字典对象`num_dict
    = dict(one=1, two=2)`时，我们说我们创建了一个类的实例；因此，`num_dict`是`dict`类的一个实例。相关地，创建实例的过程被称为实例化*。*相同的实例化概念也适用于自定义类。
- en: During the instantiation process, we use the dict function to create the dict
    object, and this kind of function that creates instances of a class is known as
    the constructor*.* As you may have seen or known, for custom classes, the constructor
    is the __init__ function that you define. Because we use a constructor for instantiation,
    we can also call the instantiation as construction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化过程中，我们使用`dict`函数来创建字典对象，这种创建类实例的函数被称为构造函数*。*正如你可能看到或知道的，对于自定义类，构造函数是你定义的`__init__`函数。因为我们在实例化时使用构造函数，所以我们也可以将实例化称为构造。
- en: NOTE Chapter 8 covers instantiation in more detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第8章更详细地介绍了实例化。
- en: 5.1.1 Getting to know iterables and iterators
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 了解可迭代对象和迭代器
- en: The use of iterables is not an isolated topic; a key related concept is iterators.
    *Iterators* are a special data type from which we can retrieve each of their elements
    via a process known as *iteration.* The key connection between iterables and iterators
    is that all the iterables are converted to iterators before we can perform any
    iteration-related operations with them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象的使用不是一个孤立的主题；一个相关的关键概念是迭代器。*迭代器*是一种特殊的数据类型，我们可以通过称为*迭代*的过程从中检索其每个元素。可迭代对象和迭代器之间的关键联系是，在我们可以对它们执行任何迭代相关操作之前，所有可迭代对象都被转换为迭代器。
- en: 'Under the hood, two functions are doing the trick for us: iter and next. Figure
    5.1 shows how iterables and iterators work together for iteration in three steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，有两个函数在为我们做这件事：`iter`和`next`。图5.1显示了可迭代对象和迭代器如何通过三个步骤一起进行迭代：
- en: Create an iterator from an iterable by using iter. Iterators are designed to
    perform iteration of an iterable’s elements.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`iter`函数从一个可迭代对象中创建迭代器。迭代器被设计用来迭代可迭代对象的元素。
- en: Render elements by using next. Calling next on the iterator retrieves the next
    element if one is available.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`next`函数来渲染元素。在迭代器上调用`next`会检索下一个元素（如果有的话）。
- en: Stop the iteration with the StopIteration exception. When no more elements are
    available, calling next results in the StopIteration exception.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`StopIteration`异常来停止迭代。当没有更多元素可用时，调用`next`会导致`StopIteration`异常。
- en: '![CH05_F01_Cui](../Images/CH05_F01_Cui.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F01_Cui](../Images/CH05_F01_Cui.png)'
- en: Figure 5.1 The workflow of iteration with iterators. Iterators are created by
    using the iter function from iterables. The iterators use the next function to
    retrieve the next item, if available. When the iterator exhausts its items, the
    StopIteration exception is raised.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 使用迭代器的迭代工作流程。迭代器通过使用`iter`函数从可迭代对象中创建。迭代器使用`next`函数来检索下一个项目（如果有的话）。当迭代器耗尽其项目时，会引发`StopIteration`异常。
- en: 'To illustrate the iteration process, consider one common iterable, a list object,
    from which we create an iterator by using iter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明迭代过程，考虑一个常见的可迭代对象，即列表对象，我们通过使用`iter`函数创建迭代器：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The memory address will be different on your computer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在你的计算机上，内存地址将不同。
- en: 'We start with a list object, tasks, and create an iterator list_iterator by
    calling the iter function. We can use the next function to retrieve the iterator’s
    items one by one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个列表对象`tasks`开始，通过调用`iter`函数创建一个迭代器`list_iterator`。我们可以使用`next`函数逐个检索迭代器的项目：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, every time we call next on the iterator, we retrieve the next
    item until we exhaust the items of the iterator and encounter the StopIteration
    exception.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每次我们在迭代器上调用`next`时，我们都会检索下一个项目，直到我们耗尽迭代器的项目并遇到`StopIteration`异常。
- en: 'This discussion of using iter and next provides a mechanistic overview of how
    iteration works. In our code, we rarely need to create an iterator ourselves.
    Instead, Python does the heavy lifting for us behind the scenes. Take the for
    loop, the most common form of using iterables and iterators, as an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节关于使用iter和next的讨论提供了迭代工作原理的机制概述。在我们的代码中，我们很少需要自己创建迭代器。相反，Python在幕后为我们做了繁重的工作。以for循环为例，这是使用可迭代对象和迭代器最常见的形式：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use the list tasks directly in the for loop without worrying about creating
    an iterator, as it’s processed automatically by Python. More importantly, instead
    of raising the StopIteration exception when the list iterator is exhausted, the
    for loop is exited safely, as the exception is handled for us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在for循环中直接使用列表任务，无需担心创建迭代器，因为Python会自动处理。更重要的是，当列表迭代器耗尽时，for循环会安全退出，因为异常已经被我们处理了。
- en: 5.1.2 Inspecting iterability
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 检查可迭代性
- en: To better use iterables in our code, it’s essential for us to know what data
    types are iterables beyond the ones we’ve already covered, including str, list,
    tuple, dict, and set. In this section, you’ll find out how to determine whether
    a specific object is an iterable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地在我们的代码中使用可迭代对象，了解我们已覆盖的str、list、tuple、dict和set之外的数据类型是可迭代的至关重要。在本节中，你将了解如何确定特定对象是否是可迭代的。
- en: 'From a practical perspective, any data type that can be used in a for loop
    is an iterable. What’s the formal way to determine an object’s iterability? You
    might infer from the previous section that if the object can be converted to an
    iterator by means of the iter function, it is an iterable. The following code
    snippet shows you how objects (an int object versus a list object) behave differently
    in terms of their iterability:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，任何可以在for循环中使用的数据类型都是可迭代的。那么，确定一个对象的可迭代性的正式方法是什么呢？你可能从上一节推断出，如果一个对象可以通过iter函数转换为迭代器，那么它就是可迭代的。以下代码片段展示了对象（一个int对象与一个list对象）在可迭代性方面的不同行为：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Concept Iterability refers to the characteristic of an object being an iterable,
    such that it can be converted to an iterator for iteration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 可迭代性是指一个对象具有可迭代的特性，即它可以被转换为迭代器进行迭代。
- en: On top of how to inspect an object’s iterability, we should be aware of what
    common data types are iterables besides str, list, tuple, dict, and set. Using
    iter to determine iterability, we could come up with the solution shown in the
    next listing. Chapter 12 discusses how try...except... works in greater detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查对象的可迭代性之外，我们还应该了解除了str、list、tuple、dict和set之外，哪些常见数据类型是可迭代的。使用iter来确定可迭代性，我们可以得出下一列表中所示解决方案。第12章将更详细地讨论try...except...的工作方式。
- en: Listing 5.1 Checking whether an object is an iterable
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 检查对象是否是可迭代的
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Uses an underscore to denote that we don't use the return result
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用下划线表示我们不使用返回结果
- en: ❷ The else clause executes when there is no TypeError exception.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当没有TypeError异常时，else子句会执行。
- en: In listing 5.1, to test whether an object is iterable, we try to call the iter
    function directly with the object. When calling this function succeeds, the object
    is an iterable; when calling fails, the object isn’t an iterable. Using the is_iterable
    function, we can run the test for a series of built-in objects to determine what
    data types are iterables. Table 5.1 shows common built-in iterables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表5.1中，为了测试一个对象是否是可迭代的，我们尝试直接使用对象调用iter函数。当调用此函数成功时，对象是可迭代的；当调用失败时，对象不是可迭代的。使用is_iterable函数，我们可以对一系列内置对象进行测试，以确定哪些数据类型是可迭代的。表5.1显示了常见的内置可迭代对象。
- en: Table 5.1 Common built-in iterables with code examples
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 常见内置可迭代对象及代码示例
- en: '| Data type | Code example | Iterator type |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 代码示例 | 迭代器类型 |'
- en: '| str | "Hello" | str_iterator |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| str | "Hello" | str_iterator |'
- en: '| list | [1, 2, 3] | list_iterator |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| list | [1, 2, 3] | list_iterator |'
- en: '| tuple | (1, 2, 3) | tuple_iterator |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| tuple | (1, 2, 3) | tuple_iterator |'
- en: '| dict | {"one": 1, "two": 2} | dict_keyiterator¹ |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| dict | {"one": 1, "two": 2} | dict_keyiterator¹ |'
- en: '| set | {1, 2, 3} | set_iterator |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| set | {1, 2, 3} | set_iterator |'
- en: '| range | range(3) | range_iterator |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| range | range(3) | range_iterator |'
- en: '| map | map(int, ["1", "2"]) | map |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| map | map(int, ["1", "2"]) | map |'
- en: '| zip | zip([1, 2], [2, 3]) | zip |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| zip | zip([1, 2], [2, 3]) | zip |'
- en: '| filter | filter(bool, [1, None]) | filter |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| filter | filter(bool, [1, None]) | filter |'
- en: '| enumerate | enumerate([1, 2, 3]) | enumerator |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| enumerate | enumerate([1, 2, 3]) | enumerator |'
- en: '| reversed | reversed("Hello") | reversed |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| reversed | reversed("Hello") | reversed |'
- en: '(¹ When you iterate dict, the default is to iterate its keys. The following
    two operations are equivalent: for key in dict and for key in dict.keys(). You
    can iterate the values and the items of a dict object. For more information, see
    section 5.3.7.)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: （¹ 当迭代字典时，默认是迭代其键。以下两个操作是等效的：for key in dict 和 for key in dict.keys()。你可以迭代字典对象的值和项。有关更多信息，请参阅第
    5.3.7 节。）
- en: In table 5.1, you’ll notice some data types that I haven’t covered yet, such
    as map and zip. Section 5.1.3 discusses some of these iterable types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在表 5.1 中，你会注意到一些我还没有介绍的数据类型，例如 map 和 zip。第 5.1.3 节讨论了这些可迭代类型中的一些。
- en: 5.1.3 Using iterables to create built-in data containers
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 使用可迭代对象创建内置数据容器
- en: In chapter 2, we learned about collection data types, including lists, sets,
    tuples, and dictionaries, also known as data containers. In simple scenarios,
    we can use their respective literal forms to create the data when they involve
    a small number of elements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们学习了集合数据类型，包括列表、集合、元组和字典，也称为数据容器。在简单场景中，当涉及少量元素时，我们可以使用各自的字面量形式来创建数据。
- en: As shown in listing 5.2, we create a few data containers without using their
    constructors. Instead, we specify the data with its special syntactical requirements,
    such as square brackets for list objects and curly braces for set objects. This
    instantiation approach is known as *using literals to create instances.*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 5.2 所示，我们创建了一些数据容器，而没有使用它们的构造函数。相反，我们使用其特殊的语法要求来指定数据，例如列表对象使用方括号，集合对象使用花括号。这种实例化方法被称为*使用字面量创建实例*。
- en: Listing 5.2 Using literals for instantiation
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 使用字面量进行实例化
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we need to create container data that has many elements, however, it’s
    less convenient to use the literals. Notably, each of these collection data types
    has its own constructors, using the respective class names, and they can take
    iterables to create new collection objects. The following listing shows how.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们需要创建具有许多元素的容器数据时，使用字面量就不那么方便了。值得注意的是，这些集合数据类型都有自己的构造函数，使用相应的类名，并且它们可以接受可迭代对象来创建新的集合对象。以下列表显示了如何实现。
- en: Listing 5.3 Using iterables for instantiation
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 使用可迭代对象进行实例化
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Calls the list constructor
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用列表构造函数
- en: ❷ Calls the tuple constructor
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用元组构造函数
- en: ❸ Calls the dict constructor
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用字典构造函数
- en: ❹ Calls the set constructor
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用集合构造函数
- en: As shown in listing 5.3, the list, tuple, dict, and set constructors can take
    an iterable to create a corresponding object. The technique of creating objects
    from iterables is often used in real-life projects when we deal with many kinds
    of iterables and the involved data is related. Thus, we often take advantage of
    this feature to create new data from existing iterables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 5.3 所示，列表、元组、字典和集合构造函数可以接受一个可迭代对象来创建相应的对象。从可迭代对象创建对象的技术在现实生活中的项目中经常使用，当我们处理许多种类的可迭代对象且涉及的数据相关时。因此，我们经常利用这一特性从现有的可迭代对象中创建新的数据。
- en: 'question *Strings* are iterables of characters. Suppose that we have a str
    object: letters = "ABCDE". What’s the best way to create a list of characters,
    ["A", "B", "C", "D", "E"], from letters?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 *字符串* 是字符的可迭代对象。假设我们有一个 str 对象：letters = "ABCDE"。从 letters 中创建字符列表 ["A",
    "B", "C", "D", "E"] 的最佳方法是什么？
- en: 'Suppose that our project has a list object of strings, with each representing
    a floating-point number: numbers_str = ["1.23", "4.56", "7.89"]. To perform calculations
    next, we convert strings to floats. We can achieve this conversion by using map,
    which applies a function to each item of the iterable and creates the map iterator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的项目有一个字符串列表对象，每个字符串代表一个浮点数：numbers_str = ["1.23", "4.56", "7.89"]。为了进行下一步的计算，我们需要将字符串转换为浮点数。我们可以通过使用
    map 来实现这种转换，它将一个函数应用于可迭代对象的每个项目，并创建一个 map 迭代器：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code example, the map function applies the built-in float function
    (it’s the float constructor, to be precise) to each string, and the list constructor
    takes the created map iterator to create a list object of floating-point numbers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，map 函数将内置的 float 函数（确切地说，是 float 构造函数）应用于每个字符串，然后列表构造函数使用创建的 map 迭代器来创建一个浮点数列表对象。
- en: Peek The map function is a higher-order function that takes a function as an
    argument. Find more in section 7.2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 瞧，map 函数是一个高阶函数，它接受一个函数作为参数。更多内容请参阅第 7.2 节。
- en: 'Compared with that of other data containers, the dict type’s constructor is
    special, as it requires each item in the iterable to consist of two items, with
    the keys and values in a paired manner. Besides using a list of tuples that each
    have two elements, a common way to create a dict object from existing iterables
    is to use the zip function to join two iterables. This scenario is the same one
    that I posed earlier: how to create a dict object from two list objects. Here’s
    the solution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据容器相比，dict类型的构造器是特殊的，因为它要求可迭代对象中的每个元素都由两个元素组成，键和值以配对的方式存在。除了使用包含两个元素的元组列表外，从现有的可迭代对象创建dict对象的一种常见方法是通过使用zip函数将两个可迭代对象连接起来。这种情况与我之前提出的是一样的：如何从两个列表对象创建dict对象。以下是解决方案：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The magic of this operation is that the zip function joins the id_numbers and
    titles side by side, forming a zip iterator that renders elements consisting of
    one item from each iterable. Figure 5.2 shows how the zip function works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的魔力在于zip函数将id_numbers和titles并排连接，形成一个zip迭代器，该迭代器生成由每个可迭代对象中的一个项目组成的元素。图5.2显示了zip函数的工作方式。
- en: '![CH05_F02_Cui](../Images/CH05_F02_Cui.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F02_Cui](../Images/CH05_F02_Cui.png)'
- en: Figure 5.2 The zip function creates an iterator from multiple iterables. In
    the example, we use two iterables. The zip function joins the items at the corresponding
    position from each of the iterables. Please note that the order of the iterables
    used in the zip function matters because the created tuples store the items in
    the order that matches the iterables’ order.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 zip函数从多个可迭代对象创建迭代器。在示例中，我们使用了两个可迭代对象。zip函数将每个可迭代对象在相应位置的项连接起来。请注意，在zip函数中使用的可迭代对象的顺序很重要，因为创建的元组按照可迭代对象的顺序存储项。
- en: 'In figure 5.2, the example uses two iterables to create the iterator: a zip
    object that renders two-item tuple objects. The two-item tuples are what the dict
    constructor needs, the first item becoming a key and the second item becoming
    the corresponding value. In real projects, you’ll often use the zip function to
    create dict objects.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在图5.2中，示例使用两个可迭代对象来创建迭代器：一个生成两个元素元组的zip对象。这两个元素的元组是dict构造器所需要的，第一个元素成为键，第二个元素成为相应的值。在实际项目中，你通常会使用zip函数来创建dict对象。
- en: This zip and that zip
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个zip和那个zip
- en: 'The zip function joins two or more iterables, with each iterable contributing
    one item to the zip iterator’s elements. Most of the time, you use two iterables
    in a zip function, which mimics the action of your real-world jacket’s zipper.
    Thus, if you’re confused about what the zip function does, think about what your
    jacket’s zipper does: joins two rows of teeth, with the rows alternating to form
    a pair.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: zip函数将两个或多个可迭代对象连接起来，每个可迭代对象向zip迭代器的元素贡献一个项目。大多数时候，你在zip函数中使用两个可迭代对象，这模仿了你现实生活中的夹克拉链的动作。因此，如果你对zip函数的作用感到困惑，想想你的夹克拉链是如何工作的：将两排牙齿连接起来，这些牙齿交替排列以形成一对。
- en: You may know that zipping is a file-compression concept. In Python, the zipfile
    module provides the related functionalities of zipping and unzipping files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道zipping是一个文件压缩概念。在Python中，zipfile模块提供了与zip和unzip文件相关的功能。
- en: 5.1.4 Discussion
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 讨论
- en: Besides Python’s standard library, iterables are heavily used in third-party
    libraries. The ndarray in the NumPy and the Series in the pandas library, for
    example, can take an iterable for instantiation. If your work involves data science,
    you’ll find it handy to convert data between different types of iterables.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python的标准库之外，可迭代对象在第三方库中也被大量使用。例如，NumPy中的ndarray和pandas库中的Series可以接受可迭代对象进行实例化。如果你的工作涉及数据科学，你会发现将数据在不同类型的可迭代对象之间转换非常方便。
- en: 5.1.5 Challenge
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 挑战
- en: As an aspiring finance analyst, Ava is learning Python for her work. She’s fascinated
    by the zip function, which connects multiple iterables. She wonders how zip works
    with multiple iterables. Can you help her write some code to try to zip three
    iterables? Commonly, the number of items in the iterables differs. Can you find
    out what happens if you use zip to join iterables of different numbers of items?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名有抱负的金融分析师，Ava正在学习Python以用于她的工作。她对连接多个可迭代对象的zip函数很着迷，她想知道zip如何与多个可迭代对象一起工作。你能帮她编写一些代码来尝试zip三个可迭代对象吗？通常，可迭代对象中的项目数量是不同的。你能找出如果你使用zip来连接不同数量的可迭代对象会发生什么吗？
- en: Hint Two iterables form two-item tuples after zipping. When one iterable is
    shorter than others, the shorter iterable has nothing to contribute when its elements
    are used up first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：两个可迭代对象在zip之后形成两个元素的元组。当一个可迭代对象比其他可迭代对象短时，当它的元素首先被用完时，较短的可迭代对象就没有东西可以贡献了。
- en: 5.2 What are list, dictionary, and set comprehensions?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 列表、字典和集合推导式是什么？
- en: 'If you ask an intermediate-level Python programmer what feature is one of the
    most Pythonic, you may get the answer *list comprehension,* a concise way of creating
    list objects. The following code snippet shows what list comprehension looks like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问一个中级Python程序员哪个特性是最Pythonic的，你可能会得到答案*列表推导式*，这是一种创建列表对象的简洁方法。以下代码片段展示了列表推导式看起来是什么样子：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, list comprehension doesn’t look like literals, as it doesn’t
    list the items directly, but it doesn’t look like the constructor approach either,
    as it doesn’t call list. List comprehension is a Pythonic feature that you’ll
    use often. *Pythonic* means that it’s concise and readable (certainly given that
    you know the technique). Besides list comprehension, dictionary and set comprehensions
    are available for creating dict and set objects, respectively. In the next section,
    you’ll learn about these comprehension techniques and some pitfalls you should
    avoid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，列表推导式看起来不像字面量，因为它没有直接列出项，但它也不像构造函数方法，因为它没有调用list。列表推导式是Python的一个常用特性。*Pythonic*意味着它简洁且易于阅读（当然，前提是你了解这项技术）。除了列表推导式之外，还有字典和集合推导式可用于创建字典和集合对象。在下一节中，你将了解这些推导技术以及你应该避免的一些陷阱。
- en: 5.2.1 Creating lists from iterables using list comprehension
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 使用列表推导式从可迭代对象创建列表
- en: We use different kinds of iterables to store a variety of data. Often, we need
    to convert this data to a list object in our projects. In this section, you’ll
    learn to convert iterables to list objects by using list comprehension. Suppose
    that in our task management application, we have a list of instance objects of
    the Task class, as shown in the next listing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同类型的可迭代对象来存储各种数据。在项目中，我们通常需要将这些数据转换为列表对象。在本节中，你将学习如何使用列表推导式将可迭代对象转换为列表对象。假设在我们的任务管理应用程序中，我们有一个Task类实例对象的列表，如下所示。
- en: Listing 5.4 Creating a list of custom class instances
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 创建自定义类实例的列表
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Custom class using named tuples
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用命名元组的自定义类
- en: Reminder A *named tuple* is a lightweight data model used to hold data and support
    dot notations. See section 3.3 for more details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：*命名元组*是一种轻量级的数据模型，用于存储数据并支持点表示法。有关更多详细信息，请参阅第3.3节。
- en: 'In our app, we need a list object to get all the titles for these tasks. A
    beginner who doesn’t know list comprehension might come up with the following
    solution:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们需要一个列表对象来获取这些任务的全部标题。一个不了解列表推导式的初学者可能会提出以下解决方案：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use a for loop to iterate the items in tasks and retrieve their title attributes,
    and we append them to the list object task_titles. This solution works, but it’s
    not the most efficient or Pythonic. A better approach is to use list comprehension:
    [expression for item in iterable], in which the expression is a specific operation
    using each item of the iterable. Expressions are evaluated to become the items
    in the created list. The following code snippet shows how to use list comprehension
    to extract the tasks’ titles:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用for循环遍历tasks中的项并检索它们的title属性，然后将它们追加到task_titles列表对象中。这个解决方案是可行的，但不是最有效或最Pythonic的方法。更好的方法是使用列表推导式：[expression
    for item in iterable]，其中expression是对可迭代对象中每个项进行特定操作的表达式。表达式被评估后成为创建的列表中的项。以下代码片段展示了如何使用列表推导式提取任务的标题：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in this example, by using list comprehension, we create a list object
    of the desired data. The example highlights the most significant advantage of
    using list comprehension: *conciseness.* You don’t need to use a for loop, and
    the operation goes into one line of code. Although some beginners may find this
    technique to be puzzling, when you become more experienced with Python, you’ll
    find list comprehension to be not only concise, but also readable.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，通过使用列表推导式，我们创建了一个包含所需数据的列表对象。该示例突出了使用列表推导式最显著的优点：*简洁性*。你不需要使用for循环，操作可以放在一行代码中。尽管一些初学者可能会觉得这项技术令人困惑，但当你对Python更加熟练时，你会发现列表推导式不仅简洁，而且易于阅读。
- en: List comprehension or map
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式或map
- en: 'We use list comprehension to create a list object from an existing iterable.
    Notably, we can create the same list object by using a list constructor together
    with the map function. To derive the list of titles, for example, we can use the
    following alternative solution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导式从一个现有的可迭代对象创建一个列表对象。值得注意的是，我们可以通过使用列表构造函数和map函数一起使用来创建相同的列表对象。例如，要获取标题列表，我们可以使用以下替代方案：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As section 7.1 discusses, we can also use a lambda function to eliminate the
    need to create the get_title function: titles = list(map(lambda x: x.title, tasks)).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '如第7.1节所述，我们还可以使用lambda函数来消除创建get_title函数的需要：titles = list(map(lambda x: x.title,
    tasks))。'
- en: As you can see, using list and map to create a list object is usually more verbose
    than list comprehension; thus, it’s generally less readable. I recommend that
    you use list comprehension instead of the map approach. Nevertheless, some people
    prefer the map approach because it represents a coding style termed *functional
    programming*. The style focuses on writing and using functions instead of focusing
    on objects, as in OOP languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用列表和映射创建列表对象通常比列表推导式更冗长；因此，它通常可读性较差。我建议您使用列表推导式而不是映射方法。尽管如此，有些人更喜欢映射方法，因为它代表了一种称为
    *函数式编程* 的编码风格。这种风格侧重于编写和使用函数，而不是像面向对象语言那样关注对象。
- en: 5.2.2 Creating dictionaries from iterables using dictionary comprehension
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 使用字典推导式从可迭代对象创建字典
- en: 'dict is another key data container type in Python. As with list objects, we
    can create dict objects by using comprehension: dictionary comprehension. In this
    section, I quickly go over dictionary comprehension, as it has only a minor difference
    in syntax from list comprehension. The principle is the same, providing a concise
    way to create a dict object from an existing iterable.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: dict是Python中另一种关键的数据容器类型。与列表对象一样，我们可以通过使用推导式创建字典对象：字典推导式。在本节中，我将快速介绍字典推导式，因为它与列表推导式在语法上只有细微的差别。原理相同，提供了一种从现有可迭代对象创建字典对象的简洁方法。
- en: 'Because dictionaries consist of key-value pairs, dictionary comprehension includes
    two expressions separated by a colon, as in {expr_key: expr_value for item in
    iterable}, in which expr_key evaluates to the key and expr_value evaluates to
    the corresponding value. Another syntactical difference is the use of curly braces
    in dictionary comprehension, as opposed to square brackets in list comprehension.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '由于字典由键值对组成，字典推导式包括两个由冒号分隔的表达式，如 {expr_key: expr_value for item in iterable}，其中
    expr_key 计算为键，expr_value 计算为相应的值。另一个语法上的区别是，在字典推导式中使用花括号，而在列表推导式中使用方括号。'
- en: 'Using the same list object tasks as our starting point, suppose that our application
    needs a dict object in which the titles are the keys and the descriptions are
    the values. The following code shows how we can address this need by using a for
    loop and dictionary comprehension, providing a head-to-head comparison for readability:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们的起点相同的列表对象任务，假设我们的应用程序需要一个字典对象，其中标题是键，描述是值。以下代码展示了我们如何通过使用循环和字典推导式来满足这一需求，以提供易于阅读的逐项比较：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Compared with the non-Pythonic for approach, dictionary comprehension is much
    more concise. For experienced Python users, it’s also more readable, as by reading
    it, you can tell that the titles become the keys and the descriptions become the
    values. This clarity is another advantage of comprehension as a concise technique
    for creating data containers in Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与非Pythonic的for方法相比，字典推导式更加简洁。对于经验丰富的Python用户来说，它也更容易阅读，因为通过阅读它，您可以知道标题成为键，描述成为值。这种清晰度是推导式作为Python中创建数据容器简洁技术的另一个优点。
- en: 5.2.3 Creating sets from iterables using set comprehension
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 使用集合推导式从可迭代对象创建集合
- en: In section 3.5, we learned that set objects are the perfect data model when
    we’re concerned about membership testing. Thus, we often need set objects that
    are converted from other iterables. We can achieve such conversion with set comprehension,
    {expression for item in iterable}, in which expression evaluates to the set’s
    items. In this section, you’ll learn about set comprehension.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3.5节中，我们了解到当关注成员测试时，集合对象是完美的数据模型。因此，我们经常需要将其他可迭代对象转换为集合对象。我们可以通过集合推导式实现这种转换，{expression
    for item in iterable}，其中表达式计算为集合的项。在本节中，您将了解集合推导式。
- en: Reminder Because of the underlying implementation using hash tables, item lookup
    in a set object takes a constant amount of time, a phenomenon known as *O(1) time
    complexity**.*
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：由于底层实现使用哈希表，集合对象中的项查找需要恒定的时间，这种现象称为 *O(1) 时间复杂度*。
- en: 'Set comprehension uses curly braces instead of square brackets. Across all
    three comprehension techniques, you may notice that the symbols used are the same
    as their respective literal forms: [] for list, {:} for dict, and {} for set.
    Thus, if you’re confused about comprehensions’ symbols, think of their literal
    forms.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式使用花括号而不是方括号。在所有三种推导技术中，你可能注意到所使用的符号与它们的字面形式相同：[]用于列表，{:}用于字典，{}用于集合。因此，如果你对推导的符号感到困惑，想想它们的字面形式。
- en: 'The following code snippet shows the conciseness of set comprehension for creating
    a set object from an iterable compared with the for-loop approach. We use task.title
    to derive each task’s title, which goes to the created set object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了与for循环方法相比，集合推导式创建集合对象时的简洁性。我们使用task.title来获取每个任务的标题，这些标题将添加到创建的集合对象中：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Creating an empty set requires a set constructor, as there is no literal form
    for an empty set.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空集合需要一个集合构造函数，因为空集合没有字面形式。
- en: 'One thing to note is that like the set constructor (example: set([1, 1, 2,
    2, 3, 3]) = {1, 2, 3}), set comprehension removes duplicates for you automatically,
    because set objects only store unique items due to the underlying hash implementations.
    That is, objects that have the same value (and thus the same hash value; remember
    a hash function’s consistency) can have only one copy in the set object, as shown
    in this example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，类似于集合构造函数（例如：set([1, 1, 2, 2, 3, 3]) = {1, 2, 3}），集合推导式会自动为你删除重复项，因为集合对象只存储唯一项，这是由于底层哈希实现的结果。也就是说，具有相同值（因此具有相同的哈希值；记住哈希函数的一致性）的对象在集合对象中只能有一个副本，如下例所示：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Items in a set object are unordered.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 集合对象中的项是无序的。
- en: 5.2.4 Applying a filtering condition
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 应用过滤条件
- en: When we iterate through an iterable, sometimes we need to evaluate whether the
    item meets specific criteria before we perform the operations. In this section,
    you’ll see how to apply a filtering condition to the comprehension technique.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历可迭代对象时，有时在执行操作之前需要评估项是否满足特定标准。在本节中，你将看到如何将过滤条件应用于推导技术。
- en: 'Suppose that for the tasks list, we want to generate a list of the titles only
    for the tasks whose urgency level is greater than 3\. In this case, we should
    filter the iterable by using the if statement. A beginner who has no knowledge
    of list comprehension can use a regular for loop to come up with the following
    solution:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于tasks列表，我们只想生成紧急程度大于3的任务的标题列表。在这种情况下，我们应该通过使用if语句来过滤可迭代对象。一个对列表推导式一无所知的初学者可以使用常规的for循环来得出以下解决方案：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the for loop, we examine the task’s urgency level in each iteration and
    append the task only if it passes the test. But a Pythonic solution is to integrate
    the if statement into list comprehension: [expression for item in iterable if
    condition]. Specifically, we append the if statement following the iterable to
    filter the applicable elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在for循环中，我们检查每个迭代的任务紧急程度，并且只有当任务通过测试时才将其添加到列表中。但Python风格的解决方案是将if语句集成到列表推导式中：[expression
    for item in iterable if condition]。具体来说，我们将if语句添加到iterable之后以过滤适用元素：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the pertinent code isn’t shown here, the if statement can also be used
    in dictionary and set comprehensions to filter unwanted items while creating dict
    and set objects. If you’re interested, you can try that feature.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然相关的代码在这里没有展示，但if语句也可以在创建字典和集合对象时用于过滤不需要的项。如果你感兴趣，可以尝试这个功能。
- en: 5.2.5 Using embedded for loops
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 使用嵌套for循环
- en: When we have nested data, we may need to derive all the elements from each layer
    of the nested structures. The list object tasks represents a layer of data, for
    example, and each element is another layer of data, as each task has its own stored
    data. In this section, you’ll learn how to use embedded for loops to derive the
    innermost items for nested data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到嵌套数据时，我们可能需要从嵌套结构的每一层中提取所有元素。列表对象tasks代表一层数据，例如，每个元素是另一层数据，因为每个任务都有自己的存储数据。在本节中，你将学习如何使用嵌套for循环来提取嵌套数据的内部项。
- en: 'We’ll begin with a non-Pythonic approach as a direct comparison. When you use
    for loops for iteration, you may know that you can embed a for loop in another
    for loop, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从非Python风格的方法开始，作为直接比较。当你使用for循环进行迭代时，你可能知道你可以在另一个for循环中嵌入一个for循环，如下所示：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This operation of embedded for loops is valid is because tasks is a list of
    Task instances, and each Task instance is a named tuple—a kind of iterable too.
    The same operation is supported by list comprehension. That is, you can have embedded
    for loops in list comprehension. Observe this feature:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套for循环的操作是有效的，因为tasks是一个包含Task实例的列表，每个Task实例都是一个命名元组——也是一种可迭代对象。列表推导式也支持相同的操作。也就是说，你可以在列表推导式中使用嵌套for循环。观察这个特性：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this code, the first for loop extracts each task from the list object tasks,
    and the second for loop extracts each item of the task object. This syntax may
    confuse some beginners because of the two for loops. My tip is that they read
    the code as though they’re dealing with regular embedded for loops. The first
    for refers to the outer one, and the second for refers to the inner one: [expression
    for iterable in iterables for item in iterable].'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，第一个for循环从列表对象tasks中提取每个任务，第二个for循环提取任务对象的每个项。这种语法可能会让一些初学者感到困惑，因为有两个for循环。我的建议是，他们应该像处理常规嵌套for循环一样阅读代码。第一个for指的是外层循环，第二个for指的是内层循环：[expression
    for iterable in iterables for item in iterable]。
- en: Theoretically, you can have as many embedded for loops as you want. From a readability
    perspective, however, I don’t recommend using comprehensions with more than two
    layers of for loops, as I’ve discussed so far.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，你可以有任意多的嵌套for循环。然而，从可读性的角度来看，我不建议使用超过两层for循环的推导式，正如我之前讨论的那样。
- en: Readability Don’t use more than two layers of for loops. It’s hard to read a
    list comprehension that has three or more layers of for loops.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 不要使用超过两层for循环。具有三层或更多for循环的列表推导式很难阅读。
- en: 5.2.6 Discussion
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.6 讨论部分
- en: Section 5.2 discussed how to use list, dictionary, and set comprehensions as
    concise ways to create list, dict, and set objects, respectively. Figure 5.3 summarizes
    these techniques.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第5.2节讨论了如何使用列表、字典和集合推导式作为创建列表、字典和集合对象的简洁方法。图5.3总结了这些技术。
- en: You should be clear about when you should use comprehensions. That is, when
    you start with an iterable and want to create an instance of a list, dict, or
    set class, that scenario probably is the best time to use comprehensions. Do you
    know why I say *probably?* There are a few exceptions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该清楚何时应该使用推导式。也就是说，当你从一个可迭代对象开始，并希望创建列表、字典或集合类的实例时，这种情况可能是使用推导式的最佳时机。你知道我为什么说“可能”吗？有一些例外。
- en: '![CH05_F03_Cui](../Images/CH05_F03_Cui.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F03_Cui](../Images/CH05_F03_Cui.png)'
- en: Figure 5.3 The general forms for list, dictionary, and set comprehensions. Each
    comprehension involves iterating an iterable, uses distinct syntax for comprehension,
    and creates the respective instance objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 列表、字典和集合推导式的一般形式。每个推导式都涉及迭代一个可迭代对象，使用不同的语法进行推导，并创建相应的实例对象。
- en: 'First, if you don’t need to manipulate the items in the iterable, you should
    consider using their constructors directly. You start with a list object, numbers
    = [1, 1, 2, 3], and you want to create a set object, for example. Although it’s
    not wrong to do so, you shouldn’t use set comprehension: {x for x in numbers}.
    Instead, you should use a set constructor, as it takes an iterable directly and
    creates a set object: set(numbers).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你不需要操作可迭代对象中的项，你应该考虑直接使用它们的构造函数。你从一个列表对象开始，numbers = [1, 1, 2, 3]，并希望创建一个集合对象，例如。虽然这样做并没有错，但你不应该使用集合推导式：{x
    for x in numbers}。相反，你应该使用集合构造函数，因为它直接接受一个可迭代对象并创建一个集合对象：set(numbers)。
- en: 'Second, when the comprehension requires complicated expressions or deeply nested
    for loops, it’s better to use the conventional for-loop approach. Suppose that
    you have the following comprehension:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当推导式需要复杂的表达式或深层嵌套的循环时，使用传统的for循环方法会更好。假设你有以下推导式：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can’t say that this code isn’t readable, but you should try your best to
    make your code readable for most readers. Here’s an alternative:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能说这段代码不可读，但你应该尽力使你的代码对大多数读者来说都是可读的。这里有一个替代方案：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compared with the preceding solution, this one takes a few more lines of code,
    but it clearly presents the multiple layers of for loops, which are easier to
    read and understand.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的解决方案相比，这个解决方案需要更多的代码行，但它清楚地展示了多层for循环，这使得代码更容易阅读和理解。
- en: 5.2.7 Challenge
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.7 挑战
- en: Lucas is learning Python for his graduate research in the field of physics.
    He has realized that list, dictionary, and set comprehensions use square brackets
    and curly braces. He wonders what (expression for item in iterable) can do. Because
    this expression uses parentheses, which are used in creating tuples, is this approach
    tuple comprehension? Try running it, and tell Lucas what he’ll get.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 卢卡斯正在学习Python，以便在物理学领域进行研究生研究。他已经意识到列表、字典和集合使用方括号和花括号。他想知道表达式（表达式 for 项 in 可迭代对象）能做什么。因为这个表达式使用了括号，而括号用于创建元组，所以这种方法是元组推导吗？尝试运行它，并告诉卢卡斯他将得到什么。
- en: Hint If the process were tuple comprehension, I would have covered it already.
    You can check the nature of an object by using the type function. Section 7.4
    covers the created object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果这个过程是元组推导，我早就已经覆盖了。你可以使用type函数检查对象的性质。第7.4节涵盖了创建的对象。
- en: 5.3 How do I improve for-loop iterations with built-in functions?
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 我该如何使用内置函数改进for循环迭代？
- en: In our projects, most data is expected to be presented in an organized form.
    In a discussion forum, for example, we need to lay out the posts with titles on
    the left side and authors on the right side. To print a receipt in a clear format,
    we need to list the items one by one together with their respective prices. As
    you can imagine, you can say that every project uses structured information, and
    the universal need to store this information justifies the implementation of various
    kinds of iterables of distinct characteristics in Python.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，大多数数据都期望以有组织的形式呈现。例如，在一个讨论论坛中，我们需要将帖子以标题在左侧、作者在右侧的形式排列。为了以清晰格式打印收据，我们需要逐个列出项目及其相应的价格。正如你所想象的，可以说每个项目都使用结构化信息，存储这种信息的普遍需求证明了Python中实现具有不同特性的各种可迭代对象的必要性。
- en: 'For the structured information—posts, ordered items, or any applicable data
    in your projects—most of the time, the data is homogeneous, and we generally apply
    the same operation. When you try to apply the same operation to an iterable, it’s
    best to use a for loop, which has the following form (and you should be familiar
    with it):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构化信息——帖子、有序项或项目中任何适用的数据——大多数情况下，数据是同质的，我们通常应用相同的操作。当你尝试将相同的操作应用于可迭代对象时，最好使用for循环，其形式如下（你应该熟悉它）：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Knowing this basic form is a good start toward addressing iteration-related
    problems. But Python has more features that make for loops work better. In this
    section, you’ll study the Pythonic implementations for the applicable use cases.
    I’ll show you a non-Pythonic solution as a starting point, and then I’ll explore
    the Pythonic solution. Finally, I’ll briefly explain the functions and techniques.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这种基本形式是解决迭代相关问题的良好开端。但Python还有更多特性可以使for循环工作得更好。在本节中，你将学习Python对这些适用用例的实现。我会先展示一个非Python风格的解决方案作为起点，然后我会探索Python风格的解决方案。最后，我将简要解释这些函数和技术。
- en: 5.3.1 Enumerating items with enumerate
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 使用enumerate枚举项
- en: Many iterables are sequence data, such as lists and tuples. Each item has a
    corresponding index—its position in the sequence data. We often want to use an
    item’s position information together with the item’s data itself. In this section,
    I address this need, which is known as *enumeration**.*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可迭代对象是序列数据，例如列表和元组。每个项都有一个相应的索引——它在序列数据中的位置。我们经常想使用项的位置信息以及项本身的数据。在本节中，我解决这个需求，这被称为*枚举**。
- en: Suppose that our task management application has a list of instance objects
    of the Task class. For simplicity, the Task class is implemented by using named
    tuples, as shown in the following listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的任务管理应用程序有一个Task类的实例对象列表。为了简单起见，Task类是通过使用命名元组实现的，如下所示。
- en: Listing 5.5 Creating a list of custom class instances
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 创建自定义类实例的列表
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The use case is that we want to display these tasks in a numbered list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是我们想以编号列表的形式显示这些任务：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you think about a solution, you’ll probably notice that the only missing
    information is the counter of each task—that is, the index of the task in the
    tasks. Thus, you may come up with the following solution:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一个解决方案，你可能会注意到唯一缺失的信息是每个任务的计数器——即任务在任务列表中的索引。因此，你可能会有以下解决方案：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Readability In the f-string (covered in section 2.1.4), we apply format specifiers,
    such as text alignment used in the code, to format the interpolated strings. This
    structural alignment provides better readability for the string output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 在f-string（在第2.1.4节中介绍），我们应用格式说明符，例如代码中使用的文本对齐，来格式化插值字符串。这种结构对齐提供了更好的字符串输出可读性。
- en: The solution creates a range object using the length of tasks. Note that when
    you send only one argument (len(tasks), which is 3) to the range constructor,
    it’s parsed as the stop parameter; thus, the range object consists of the indexes
    of 0, 1, and 2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案使用任务的长度创建一个范围对象。请注意，当你只向范围构造函数发送一个参数（len(tasks)，即3）时，它被解析为停止参数；因此，范围对象包含索引0、1和2。
- en: 'Although this solution works for the use case, a more Pythonic solution takes
    advantage of the enumerate function, which retrieves the items and generates a
    counter for each one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案适用于该用例，但一个更Pythonic的解决方案利用enumerate函数，它检索项目并为每个项目生成一个计数器：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The enumerate function takes an iterable and creates an iterator of the enumerate
    type (table 5.1). This iterator renders a tuple object each time: (item_counter,
    item), the item’s counter, and the item from the original iterable. By default,
    the counter matches each item’s index, so the first item has a counter of 0\.
    Notably, the enumerate function takes an optional argument, start, which allows
    you to set the number for the first item. In our case, we want to start the counting
    from 1, so we set start=1 in the enumerate function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: enumerate函数接受一个可迭代对象并创建一个enumerate类型的迭代器（表5.1）。这个迭代器每次渲染一个元组对象：（item_counter，item），即项目的计数器和来自原始可迭代对象的项目。默认情况下，计数器与每个项目的索引匹配，因此第一个项目的计数器为0。值得注意的是，enumerate函数接受一个可选参数start，允许你设置第一个项目的数字。在我们的例子中，我们希望从1开始计数，因此在enumerate函数中设置start=1。
- en: Reminder We also use tuple unpacking (section 4.4). Each item from the enumerate
    iterator is a tuple object. One-to-one unpacking creates two variables, task_i
    and task, to access the counter and the item simultaneously.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒 我们还使用了元组解包（第4.4节）。enumerate迭代器中的每个项目都是一个元组对象。一对一解包创建了两个变量，task_i和task，以同时访问计数器和项目。
- en: 5.3.2 Reversing items with reversed
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用reversed反转项目
- en: 'In this section, we start with the same iterable: the list object tasks from
    section 5.3.1\. This time, we want to display the tasks in reverse order while
    keeping the original data for other purposes. When you see this need, you may
    think of getting the items from the last to the first one. This thought may lead
    you to the following solution:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们以相同的可迭代对象开始：5.3.1节中的列表对象tasks。这次，我们希望在保持原始数据用于其他目的的同时，以相反的顺序显示任务。当你看到这个需求时，你可能想到从最后一个到第一个获取项目。这种想法可能会让你想到以下解决方案：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This solution creates a range object by using the length of the tasks. One
    special thing about this solution involves using negative indexing (section 4.2)
    to retrieve the items in the reverse order of the original list object. Because
    negative indexing starts with -1 for the last item, we must add 1 to task_i before
    we negate the index. As you can tell, figuring out how to create the desired negative
    indexes from positive indexes isn’t straightforward. In this use case, a Pythonic
    solution takes advantage of the reversed function, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案通过使用任务的长度创建一个范围对象。这个解决方案的一个特别之处在于使用负索引（第4.2节）以原始列表对象的相反顺序检索项目。因为负索引从最后一个项目的-1开始，我们必须在取反索引之前将task_i加1。正如你可以告诉的，从正索引中找出所需的负索引并不简单。在这个用例中，一个Pythonic的解决方案利用reversed函数，如下所示：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The reversed function takes a sequence data object and returns a reversed object.
    Notably, the reversed object is an iterator that renders the items in the reverse
    order of the original list object. Compared with the non-Pythonic solution, the
    solution doesn’t need to deal with any indexes. Instead, we use task to directly
    access the items that are rendered by the reversed iterator. Such direct access
    without any index conversion is clean and readable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: reversed函数接受一个序列数据对象并返回一个反转对象。值得注意的是，反转对象是一个迭代器，它以原始列表对象的相反顺序渲染项目。与非Pythonic解决方案相比，该解决方案不需要处理任何索引。相反，我们使用task直接访问由reversed迭代器渲染的项目。这种无需任何索引转换的直接访问既干净又易于阅读。
- en: 5.3.3 Aligning iterables with zip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 使用zip对齐可迭代对象
- en: When we have multiple iterables to hold separate pieces of information for the
    same objects, we want to perform operations that require information from all
    the iterables. In this case, we need to join these iterables in some way. In this
    section, you’ll learn about joining iterables with the zip function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多组迭代器来保存相同对象的单独信息时，我们希望执行需要所有迭代器信息的操作。在这种情况下，我们需要以某种方式连接这些迭代器。在本节中，您将了解如何使用
    `zip` 函数连接迭代器。
- en: 'The description of this use case may be confusing. I’ll elaborate it by providing
    a concrete example. Besides the list object tasks, our application has two list
    objects—dates, when the tasks are due, and locations, where the tasks should be
    carried out:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例的描述可能有些令人困惑。我将通过提供一个具体的例子来详细说明。除了任务列表对象之外，我们的应用程序还有两个列表对象——日期（任务到期时），以及位置（任务应该执行的地方）：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We want to display the following information to the users: each task’s title,
    its due date, and the task’s location. When you see this need, you may think that
    these iterables contain different aspects of the same items. You may observe that
    the consistent element across these iterables is that the information at a given
    index pertains to the same task. Thus, you may come up with the following solution:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向用户展示以下信息：每个任务的标题、其到期日期以及任务的位置。当您看到这个需求时，您可能会认为这些迭代器包含相同项的不同方面。您可能会观察到，这些迭代器之间的一个一致元素是给定索引处的信息与同一任务相关。因此，您可能会想出以下解决方案：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because we know that the indexes are the consistent elements that allow us
    to refer to the same tasks across these iterables, we create a range object to
    obtain the indexes. If you recall, however, section 5.1.3 discusses how to use
    zip to join two iterables in creating a dict object. As mentioned there, a zip
    object is an iterator that renders tuple objects aggregated from aligned iterables.
    Here’s a solution that uses the zip function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道索引是一致的元素，允许我们在这些迭代器中引用相同的任务，所以我们创建一个范围对象来获取索引。然而，如果您还记得，第5.1.3节讨论了如何使用
    `zip` 来在创建字典对象时连接两个迭代器。正如那里提到的，`zip` 对象是一个迭代器，它渲染由对齐迭代器聚合的元组对象。以下是一个使用 `zip` 函数的解决方案：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The zip function takes multiple iterables (in our case, three) and aligns them
    side by side. As an iterator, the created zip object from this function call renders
    a tuple object consisting of three items that the iterables contribute. Notably,
    as with the enumerate object, you use one-to-one tuple unpacking to create the
    task, date, and location at the same time, which significantly improves your code’s
    conciseness and readability. (You’ll get used to this feature and find it to be
    rather readable.)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数接受多个迭代器（在我们的例子中，是三个），并将它们并排排列。作为一个迭代器，从这个函数调用创建的 `zip` 对象会渲染一个元组对象，该对象由迭代器提供的三个项组成。值得注意的是，与
    `enumerate` 对象一样，您可以使用一对一的元组解包来同时创建任务、日期和位置，这显著提高了您代码的简洁性和可读性。（您会习惯这个功能，并发现它相当易于阅读。）'
- en: It’s also possible that the related iterables will have different numbers of
    items. By default, the zip function stops zipping after the iterable with the
    fewest items is exhausted. But if you want zipping to match the iterable with
    the most items, you may want to use the zip_longest function, which is available
    in the itertools module (see the following sidebar).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能相关的迭代器会有不同数量的项。默认情况下，`zip` 函数在最少项的迭代器耗尽后停止压缩。但如果你想让压缩与最多项的迭代器匹配，你可能想使用 `zip_longest`
    函数，该函数在 `itertools` 模块中可用（见以下侧边栏）。
- en: Zipping iterables of different numbers of items
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩不同数量项的迭代器
- en: To show you how zip works, I’ve used only iterables of the same length. What
    would happen if the iterables had different numbers of items?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `zip` 的工作原理，我仅使用了相同长度的迭代器。如果迭代器有不同的数量项会发生什么？
- en: By default, the zip function stops zipping when the iterable with the fewest
    items is exhausted. If you run zip(range(3), range(4)), for example, you only
    get three tuple objects. Sometimes, we want to ensure that the iterables have
    the same numbers of items. To enforce such congruency, Python 3.10 introduced
    the optional parameter strict, which specifies that there are equal numbers of
    items when it’s set to True. Please note that strict is set to False by default,
    so previous uses of the zip function still work. Publishing a new software version
    without affecting the code created using the old version is called backward compatibility*.*
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`zip`函数在包含最少元素的迭代对象耗尽时停止打包。例如，如果你运行`zip(range(3), range(4))`，你只会得到三个元组对象。有时，我们希望确保迭代对象具有相同数量的元素。为了强制这种一致性，Python
    3.10引入了可选参数`strict`，当设置为`True`时，指定迭代对象具有相同数量的元素。请注意，`strict`默认设置为`False`，因此使用旧版本`zip`函数的先前用法仍然有效。在不影响使用旧版本创建的代码的情况下发布新的软件版本被称为*向后兼容性*。
- en: 'For some use cases, we want to zip until the iterable with the most items is
    exhausted. In these cases, we should consider using the zip_longest function,
    which exists in the itertools module in the standard Python library. The following
    code snippet shows its use. As you can see, when shorter iterables are exhausted,
    Python uses None as fillers to zip with the remaining items of longer iterables:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用例，我们希望将`zip`操作进行到包含最多元素的迭代对象耗尽为止。在这些情况下，我们应该考虑使用`zip_longest`函数，该函数存在于标准Python库中的`itertools`模块中。以下代码片段展示了它的用法。正如你所看到的，当较短的迭代对象耗尽时，Python使用`None`作为填充项与较长的迭代对象的剩余元素进行打包：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 5.3.4 Chaining multiple iterables with chain
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 使用链式连接多个可迭代对象
- en: 'In the zip function, iterables are aligned side by side before their respective
    items are zipped. But you may have multiple iterables that you want to join in
    such a way that you can retrieve their items sequentially. That is, you want to
    use the iterables consecutively instead of simultaneously. In this section, you’ll
    explore this feature, which is known as *chaining of the iterables**.* Suppose
    that in addition to the list object tasks, you have a list object that saves the
    tasks you just completed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zip`函数中，在将各自的元素进行打包之前，可迭代对象是并排对齐的。但可能存在多个你想要以这种方式连接的可迭代对象，以便你可以按顺序检索它们的元素。也就是说，你希望连续使用这些可迭代对象而不是同时使用。在本节中，你将探索这个特性，它被称为*可迭代对象的链式连接**。假设除了`tasks`列表对象外，你还有一个保存你刚刚完成的任务的列表对象：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The use case is that you want to show all the titles for the completed and
    pending tasks. When you see this use case, you might create a list object that
    joins tasks and completed_tasks, resulting in the following solution:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是你想显示所有已完成和待完成的任务标题。当你看到这个用例时，你可能会创建一个列表对象来连接`tasks`和`completed_tasks`，从而得到以下解决方案：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This solution works, but it involves creating an intermediate list object.
    Although the problem usually doesn’t arise when the list object isn’t big, memory
    use can be concerning if you must deal with multiple large list objects. Thus,
    a more Pythonic solution involves the use of the chain function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案是可行的，但它涉及到创建一个中间列表对象。尽管当列表对象不大时通常不会出现这个问题，但如果必须处理多个大型列表对象，内存使用可能会引起关注。因此，一个更Pythonic的解决方案涉及使用`chain`函数：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Like the zip_longest function, the chain function is available in the itertools
    module. chain takes multiple iterables to create an iterator that aggregates all
    the items from these iterables. Thus, both zip and chain can take multiple iterables
    and join them in different ways. Figure 5.4 shows the differences.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与`zip_longest`函数类似，`chain`函数也存在于`itertools`模块中。`chain`函数接受多个可迭代对象以创建一个迭代器，该迭代器聚合这些迭代对象的所有元素。因此，`zip`和`chain`函数都可以接受多个可迭代对象并以不同的方式将它们连接起来。图5.4显示了它们之间的差异。
- en: '![CH05_F04_Cui](../Images/CH05_F04_Cui.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F04_Cui](../Images/CH05_F04_Cui.png)'
- en: Figure 5.4 Both zip and chain take multiple iterables. The zip function joins
    the iterables side by side at each index, and the chain function joins the iterables
    sequentially. The zip iterator renders tuple objects with their elements coming
    from each of the iterables. The chain iterator renders the elements sequentially
    from each of the iterables. The figure uses two iterables as an example, and both
    functions can take more than two iterables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 `zip`和`chain`函数都接受多个可迭代对象。`zip`函数在每个索引处将迭代对象并排连接，而`chain`函数则按顺序连接迭代对象。`zip`迭代器生成包含来自每个迭代对象的元素的元组对象。`chain`迭代器按顺序生成来自每个迭代对象的元素。该图使用两个迭代对象作为示例，并且这两个函数可以接受超过两个迭代对象。
- en: In other words, the iteration of multiple iterables is processed through the
    chain iterator, which doesn’t add memory overhead imposed by creating an intermediate
    list object in the non-Pythonic solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，多个可迭代对象的迭代是通过链式迭代器处理的，这不会增加非 Pythonic 解决方案中创建中间列表对象所强加的内存开销。
- en: 5.3.5 Filtering the iterable with filter
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.5 使用 `filter` 过滤可迭代对象
- en: An iterable consists of multiple items. In some cases, however, we want to work
    with a subset of the items that satisfies our needs. In this section, you’ll learn
    about filtering an iterable with the filter function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象由多个项组成。然而，在某些情况下，我们只想处理满足我们需求的项的子集。在本节中，你将学习如何使用 `filter` 函数过滤可迭代对象。
- en: 'Suppose that we want to display the information of the tasks whose urgency
    level should be greater than 3\. As shown in the comprehension techniques (section
    5.2.4), we can apply a filtering condition in a for loop:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要显示紧急程度等级大于 3 的任务的详细信息。正如在第 5.2.4 节中的理解技术所示，我们可以在 for 循环中应用过滤条件：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I should say that this solution is perfectly fine, and I’m happy if you came
    up with it. But a slightly better way, Pythonic or not (you decide; see section
    5.3.6), is using the filter function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该说的是，这个解决方案是完美的，如果你想出了它，我会很高兴。但稍微好一点的方法（无论是否是 Pythonic，由你决定；参见第 5.3.6 节），是使用
    `filter` 函数：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The filter function takes a function that is applied to the items of the iterable.
    Each item is evaluated by the function: if True, the item is kept, and if False,
    the item is excluded. In our example, we use a lambda function, and x refers to
    an item from the iterable. Although we saw lambda functions when we discussed
    sorting lists in section 3.2, they are discussed in detail in section 7.1\. For
    now, you can think of lambda as a regular function that returns a value from the
    expression—in our case, whether the task’s urgency level is greater than 3.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数接受一个应用于可迭代对象项的函数。每个项都会被该函数评估：如果为 True，则保留该项，如果为 False，则排除该项。在我们的例子中，我们使用了一个
    lambda 函数，其中 x 指的是可迭代对象中的一个项。尽管我们在第 3.2 节讨论排序列表时看到了 lambda 函数，但它们在第 7.1 节中进行了详细讨论。现在，你可以将
    lambda 视为一个返回表达式的值的常规函数——在我们的例子中，就是任务的紧急程度是否大于 3。'
- en: 5.3.6 Discussion
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.6 讨论部分
- en: 'When you use reversed, you create an iterator that has the same items as the
    iterable but in reverse order. You shouldn’t confuse reversed with the reverse
    method, which reverses a list object in place. The in-place change implies that
    this method changes the original list object and returns None. Thus, the following
    code won’t run! The same distinction applies to sorted and sort. The former creates
    a sorted list object and is compatible with a for loop. The latter returns None
    and is incompatible with a for loop:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `reversed` 时，你会创建一个具有与可迭代对象相同项但顺序相反的迭代器。你不应该将 `reversed` 与原地反转列表对象的 `reverse`
    方法混淆。原地更改意味着此方法会更改原始列表对象并返回 None。因此，以下代码将无法运行！同样的区别也适用于 `sorted` 和 `sort`。前者创建一个排序后的列表对象，并且与
    for 循环兼容。后者返回 None，与 for 循环不兼容：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Starting in Python 3.10, zip has an optional strict parameter. Setting strict
    to True requires the length of the iterables to be the same; otherwise, zip stops
    when the iterable with the fewest items is exhausted. As you’ll see in section
    6.1, setting a default value to a parameter allows users to omit the argument
    during the function call. The most significant implication is that in an old codebase,
    any call of the zip function, such as zip(list0, list1), still works even if you
    update your Python to version 3.10\. The function will be interpreted as zip(list0,
    list1, strict=False), which doesn’t require the iterables to have the same number
    of elements, as the old zip function before Python 3.10 did. This brilliant design
    supports backward compatibility.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.10 开始，`zip` 函数有一个可选的严格参数。将严格设置为 True 要求可迭代对象的长度必须相同；否则，`zip` 函数会在最短的可迭代对象耗尽时停止。正如你在第
    6.1 节中看到的，将默认值设置给参数允许用户在函数调用时省略该参数。最显著的影响是，在旧代码库中，任何对 `zip` 函数的调用，例如 `zip(list0,
    list1)`，即使你更新了 Python 到版本 3.10 仍然有效。该函数将被解释为 `zip(list0, list1, strict=False)`，这不需要可迭代对象具有相同数量的元素，就像
    Python 3.10 之前的旧 `zip` 函数一样。这种出色的设计支持向后兼容性。
- en: Maintainability When you introduce new features to an existing codebase, it’s
    best to have backward compatibility so you don’t need to go back to fix code that
    uses the old features.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 当你向现有代码库引入新功能时，最好有向后兼容性，这样你就不需要回去修复使用旧功能的代码。
- en: For more advanced iteration tools, look at the itertools module, which provides
    a variety of iteration-related functionalities that you can explore—more than
    zip_ longest and chain. The range object, for example, is an iterable that renders
    integers but not decimals. Notably, itertools has a function count that creates
    an iterator to render evenly spaced values, including decimal values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的迭代工具，请查看itertools模块，它提供了各种迭代相关功能，你可以探索——不仅仅是zip_ longest和chain。例如，range对象是一个可迭代对象，它返回整数而不是小数。值得注意的是，itertools有一个count函数，它创建一个迭代器来生成均匀间隔的值，包括小数。
- en: For the filter function, some people prefer filter as a Pythonic implementation.
    But I don’t find using the filter function to be a significant improvement on
    using an if statement. To me, using an if statement is more explicit, as it makes
    the critical logical operation (the condition evaluation) stand out as a separate
    line of code. It’s up to you whether to use filter or an if statement.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于filter函数，有些人更喜欢将其视为Pythonic实现。但我觉得使用filter函数并没有比使用if语句有显著改进。对我来说，使用if语句更明确，因为它使关键逻辑操作（条件评估）作为一个单独的代码行突出显示。是否使用filter或if语句取决于你。
- en: 5.3.7 Challenge
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.7 挑战
- en: In section 3.4, you learned that you can use keys(), values(), and items() to
    access a dictionary’s keys, values, or key-value pairs. Do you know whether they’ll
    all be iterables? If you need to iterate the key-value pairs, what’s the best
    way?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.4节中，你学习了可以使用keys()、values()和items()来访问字典的键、值或键值对。你知道它们是否都是可迭代的吗？如果你需要迭代键值对，最好的方法是什么？
- en: Hint The items function returns key-value pairs as tuple objects, and you can
    use tuple unpacking to retrieve the key and value from each tuple object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：items函数返回键值对作为元组对象，你可以使用元组解包从每个元组对象中检索键和值。
- en: 5.4 Using optional statements within for and while loops
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 在for和while循环中使用可选语句
- en: 'So far, I’ve discussed how for loops help you do repeated work by going over
    iterables. Besides for loops, we often use another important control flow, while
    loops, to perform repetitive work. If you aren’t familiar with the while loop,
    see the following example. In essence, you specify a condition after the while
    keyword, and the code evaluates the condition in every iteration. When the condition
    is True, the code in the body executes; in the example, it runs when n is 1 and
    2. When the condition is False, the while loop is exited; in the example, n becomes
    3 after the while loop completes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经讨论了如何使用for循环通过遍历可迭代对象来完成重复工作。除了for循环之外，我们经常使用另一个重要的控制流——while循环，来执行重复工作。如果你不熟悉while循环，请看下面的示例。本质上，你在while关键字之后指定一个条件，并在每次迭代中评估该条件。当条件为True时，执行主体中的代码；在示例中，当n为1和2时执行。当条件为False时，退出while循环；在示例中，while循环完成后n变为3：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These control flows execute the code within the body during the iteration. But
    you don’t always want to complete the iterations for all the elements. Suppose
    that we have a list of tasks to complete for the week, as shown in the next listing,
    and we want to prioritize the urgent tasks, so we need to find the *first* task
    that has an urgency level of 5.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制流在迭代过程中执行主体中的代码。但你不总是希望对所有元素完成迭代。假设我们有一周要完成的任务列表，如下一列表所示，我们想要优先处理紧急任务，因此我们需要找到第一个紧急级别为5的任务。
- en: Listing 5.6 Finding the urgent task by creating a list
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 通过创建列表查找紧急任务
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Task is a class created by using named tuples.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Task是通过使用命名元组创建的类。
- en: 'If we try to address this need with a for loop, we might come up with the following
    solution:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用for循环来满足这个需求，我们可能会得到以下解决方案：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Sets the value when the task is urgent and the first_urgent_task0 is not set
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当任务紧急且first_urgent_task0未设置时设置值
- en: Reminder The enumerate function creates a counter for the iterable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：enumerate函数为可迭代对象创建一个计数器。
- en: 'As you can see, the for loop iterates over the entire list object before it
    completes the needed job. If you eyeball the list, you’ll notice that the task
    you’re looking for is at the beginning; it’s highly inefficient if you have to
    wait for the iteration to complete after the list object is exhausted in the for
    loop. Why not exit the for loop after the needed task is found? Fortunately, it’s
    possible to change the default iteration behaviors with two optional statements:
    break and continue. Besides these two statements, Python has a unique feature
    that allows you to use an else statement with the for and while loops.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，for循环在完成所需工作之前会遍历整个列表对象。如果您查看列表，您会注意到您正在寻找的任务位于开头；如果您在for循环中必须等待迭代完成，直到列表对象耗尽，那么这将非常低效。为什么不在找到所需任务后退出for循环呢？幸运的是，您可以使用两个可选语句：break和continue来更改默认的迭代行为。除了这两个语句之外，Python还有一个独特功能，允许您在for和while循环中使用else语句。
- en: In this section, I review how these statements work. More importantly, I use
    practical examples to show you how these statements improve the readability and
    efficiency of your for and while loops.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我回顾了这些语句的工作原理。更重要的是，我使用实际示例向您展示这些语句如何提高您for和while循环的可读性和效率。
- en: 5.4.1 Exiting the loops with the break statement
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 使用break语句退出循环
- en: 'The preceding use case requires a mechanism to exit the for loop before iterating
    over the entire iterable. We achieve this feature with a break statement, which
    stops the iteration and makes execution exit the loop immediately. In this section,
    you’ll learn how to use the break statement. To begin, quickly review a simple
    example to establish a basic understanding of how break works from a technical
    perspective:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的用例中，我们需要在遍历整个可迭代对象之前退出for循环。我们通过break语句实现这一功能，它停止迭代并立即使执行退出循环。在本节中，您将学习如何使用break语句。首先，快速回顾一个简单的示例，从技术角度建立对break如何工作的基本理解：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can see that the for loop stops running when number is 2, which reflects
    what break does, exiting the for loop immediately. In case you’re wondering, the
    break statement works the same way in a while loop:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当数字为2时，for循环停止运行，这反映了break的作用，立即退出for循环。如果您想知道，break语句在while循环中也是以相同的方式工作的：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Putting these two examples together, you should observe the general use pattern:
    we place the break statement within an if statement to check a specific condition.
    During the iteration, the condition’s evaluation may change, and when it evaluates
    to True, the break statement executes in such a way that the loop terminates instantly.
    I’ve used for loops on various occasions. To give you a different taste, figure
    5.5 depicts how break works in a while loop.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个示例结合起来，您应该观察到一般的用法模式：我们在if语句中放置break语句以检查特定条件。在迭代过程中，条件的评估可能会改变，当它评估为True时，break语句以这种方式执行，使得循环立即终止。我已经在各种场合使用过for循环。为了给您不同的体验，图5.5描述了break在while循环中的工作原理。
- en: '![CH05_F05_Cui](../Images/CH05_F05_Cui.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F05_Cui](../Images/CH05_F05_Cui.png)'
- en: Figure 5.5 How the break statement works in a while loop. The condition in the
    while loop’s head is evaluated in every iteration. When it’s True, the execution
    moves to the body of the while loop. At a certain point, we place an if statement,
    within which we use break. When this condition evaluates to True, the break statement
    executes and ends the while loop. If the condition is False, it goes back to the
    while loop’s head and evaluates the condition again to determine whether the while
    loop ends or continues.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 在while循环中break语句的工作原理。while循环头部的条件在每次迭代中都会被评估。当条件为True时，执行将移动到while循环的主体。在某个点上，我们放置一个if语句，在其中使用break。当这个条件评估为True时，break语句执行并结束while循环。如果条件为False，它将回到while循环的头部并再次评估条件，以确定while循环是结束还是继续。
- en: Now that you know how break works, the next step is solving the practical use
    case introduced earlier. Because you need to find only the first urgent task,
    retrieving all urgent tasks takes longer because the entire list is iterating.
    A better solution uses the break statement, as shown in the next listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了break的工作原理，下一步是解决之前介绍的实际用例。因为您只需要找到第一个紧急任务，检索所有紧急任务需要更长的时间，因为整个列表都在迭代。一个更好的解决方案是使用break语句，如下一个列表所示。
- en: Listing 5.7 Finding the urgent task by using break
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 通过使用break查找紧急任务
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Sets an initial value
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置初始值
- en: As shown in listing 5.7, the for loop iterates the tasks and checks the urgency
    level for each task. When it finds an urgent task, the iteration ends immediately
    because we’ve obtained the needed information; any additional operation wastes
    time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 5.7 所示，for 循环遍历任务并检查每个任务的紧急程度。当它找到一个紧急任务时，迭代立即结束，因为我们已经获得了所需的信息；任何额外的操作都是浪费时间。
- en: Maintainability You want to give first_urgent_task1 an initial value, which
    I set to None. If you don’t set an initial value, the only place where first_urgent_task1
    is set is within the body of the if statement. Chances are that there are no urgent
    tasks, in which case first_urgent_task1 is never set. Trying to access a variable
    that is never set crashes your application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 你想要给 first_urgent_task1 赋予一个初始值，我将它设置为 None。如果你不设置初始值，first_urgent_task1
    被设置的唯一地方是在 if 语句的体内。很可能没有紧急任务，在这种情况下，first_urgent_task1 从未设置。尝试访问从未设置的变量会导致你的应用程序崩溃。
- en: 5.4.2 Skipping an iteration with the continue statement
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 使用 continue 语句跳过迭代
- en: When we work with an iterable, we may need to apply operations only to some
    elements that meet specific criteria. You’ve learned that you can filter the iterable
    (section 5.3.5). But you can also skip the operations for the elements that don’t
    meet the criteria, which can be more readable. In this section, you’ll learn how
    to use continue to skip the iterations of specific elements.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与可迭代对象一起工作时，我们可能只需要对满足特定标准的某些元素应用操作。你已经了解到你可以过滤可迭代对象（第 5.3.5 节）。但你也可以跳过不符合标准的元素的操作，这可以使代码更易读。在本节中，你将学习如何使用
    continue 跳过特定元素的迭代。
- en: 'Like break, the continue statement changes the default iteration behavior by
    skipping the current iteration and moving to the next one. Here’s a simple for
    loop that shows the action of continue:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与 break 一样，continue 语句通过跳过当前迭代并移动到下一个迭代来改变默认的迭代行为。以下是一个简单的 for 循环，展示了 continue
    的作用：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For each of the first three iterations with 0, 1, and 2, the if condition evaluates
    to True; the continue statement gets executed, the code moves to the next iteration,
    and we don’t get any printout. Until the number becomes 3, the continue statement
    doesn’t run, so the iteration proceeds to the print function call. Figure 5.6
    shows how continue works in general.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前三次迭代，即 0、1 和 2，if 条件评估为 True；continue 语句执行，代码移动到下一个迭代，我们没有得到任何打印输出。直到数字变为
    3，continue 语句才不执行，迭代继续到 print 函数调用。图 5.6 展示了 continue 的一般工作方式。
- en: '![CH05_F06_Cui](../Images/CH05_F06_Cui.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F06_Cui](../Images/CH05_F06_Cui.png)'
- en: Figure 5.6 How the continue statement works in a for loop. When the iterator
    renders an item, the code in the body of the for loop executes. In the body, the
    condition in the if statement is evaluated. When the condition is True, the continue
    statement runs and skips to the next iteration. When it’s False, the execution
    in the body of the for loop moves to some other operations until execution moves
    to the next iteration. The iteration stops when the iterator exhausts its items
    and the for loop ends.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 如何在 for 循环中使用 continue 语句。当迭代器生成一个项目时，for 循环体内的代码执行。在循环体中，if 语句中的条件被评估。当条件为
    True 时，continue 语句执行并跳到下一个迭代。当条件为 False 时，for 循环体的执行移动到其他操作，直到执行移动到下一个迭代。当迭代器耗尽其项目并且
    for 循环结束时，迭代停止。
- en: Consider a more practical example. Suppose that we need to apply a series of
    functionalities to those urgent tasks. Without using the continue statement, we
    may have the following implementation for an illustration. Please note that the
    code in the next listing won’t run, as we don’t define the do_something methods.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个更实际的例子。假设我们需要对那些紧急任务应用一系列功能。如果不使用 continue 语句，我们可能会有以下实现来演示。请注意，下一列表中的代码无法运行，因为我们没有定义
    do_something 方法。
- en: Listing 5.8 Applying multiple operations for items when a condition is met
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 当满足条件时对项目应用多个操作
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the example, we apply the functions only to urgent tasks. In other words,
    we don’t need to apply any functions to the tasks that have an urgency level equal
    to or less than 4. Thus, in this kind of situation, you can consider using continue
    as an alternative implementation, as the following listing shows.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只对紧急任务应用函数。换句话说，我们不需要对紧急程度等于或低于 4 的任务应用任何函数。因此，在这种情况下，你可以考虑使用 continue
    作为替代实现，如下列表所示。
- en: Listing 5.9 Skipping an iteration when a condition is met
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 当满足条件时跳过迭代
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you compare the implementations in listings 5.8 and 5.9, you’ll find that
    the major difference is using the opposite evaluation conditions in two places.
    You may wonder what differences these two implementations make. From a performance
    perspective, they don’t make a difference, but their readability may be different.
    When you have a series of operations to apply to items that meet a criterion,
    it’s usually more readable to use the complementary evaluation criterion together
    with the continue statement (figure 5.7).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较列表5.8和5.9中的实现，你会发现主要区别在于两个地方使用了相反的评估条件。你可能想知道这两个实现有什么不同。从性能角度来看，它们没有区别，但可读性可能不同。当你需要对满足特定标准的项目执行一系列操作时，通常使用与continue语句（图5.7）一起使用的互补评估条件会更易于阅读。
- en: '![CH05_F07_Cui](../Images/CH05_F07_Cui.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F07_Cui](../Images/CH05_F07_Cui.png)'
- en: Figure 5.7 Reducing indentation layers with the continue statement. Without
    continue, the for loop needs two layers of indentation. By contrast, the same
    for loop needs one layer of indentation when an opposite evaluation condition
    is used.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 使用continue语句减少缩进层。如果没有continue，for循环需要两层缩进。相比之下，当使用相反的评估条件时，相同的for循环只需要一层缩进。
- en: As shown in figure 5.7, with continue, we reduce the needed level of indentations.
    Thus, our code has better readability because we removed the deeply nested code.
    Compare listings 5.7 and 5.8.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如图5.7所示，使用continue语句，我们可以减少所需的缩进级别。因此，我们的代码可读性更好，因为我们去除了深层嵌套的代码。比较列表5.7和5.8。
- en: 5.4.3 Using else statements in the for and while loops
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 在for和while循环中使用else语句
- en: We know that we can use an else statement together with an if statement. In
    essence, the if...else... statement creates a logical branch by examining a condition.
    When the condition is evaluated to be true, the operations within the if statement
    execute; otherwise, the operations within the else statement execute. Notably,
    the operations of these two statements are mutually exclusive, meaning that only
    one of them can run.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以将else语句与if语句一起使用。本质上，if...else...语句通过检查条件来创建一个逻辑分支。当条件评估为真时，if语句内的操作执行；否则，else语句内的操作执行。值得注意的是，这两个语句的操作是互斥的，意味着只能运行其中一个。
- en: In most programming languages, the else statement exists only in the if...else...
    statement. Python is unusual in this regard; it allows us to use the else statement
    in for and while loops. Note that adding an else statement to a for or while loop
    isn’t common practice, and it can confuse many Python programmers, particularly
    beginners. Although you want to use the else statement in a for or while loop
    with caution, it’s helpful to know and use these features in the desired use scenarios.
    In this section, you’ll explore these use scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，else语句仅存在于if...else...语句中。Python在这方面很特别；它允许我们在for和while循环中使用else语句。请注意，将else语句添加到for或while循环中并不是常见的做法，这可能会让许多Python程序员，尤其是初学者感到困惑。尽管你可能会谨慎地在for或while循环中使用else语句，但了解并使用这些特性在期望的使用场景中是有帮助的。在本节中，你将探索这些使用场景。
- en: Using else in a for loop
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在for循环中使用else
- en: 'When you append an else statement to a for loop, it forms the following structure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将else语句添加到for循环中时，它形成以下结构：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Unlike the mutual exclusiveness of execution between if and else in the if...else...
    statement, the else statement doesn’t form the opposite branch against the for-loop
    part (or the iteration part). The execution rule is that the else statement runs
    only one time after completing the iteration, but it’s skipped if the iteration
    is terminated because of the break statement. The code in the next listing shows
    the rule.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与if...else...语句中if和else执行之间的互斥性不同，else语句不会形成与for循环部分（或迭代部分）相反的分支。执行规则是else语句在迭代完成后只运行一次，但如果迭代因break语句而终止，则跳过else语句。下一列表中的代码显示了这一规则。
- en: Listing 5.10 How the for...else statement works
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.10 for...else语句的工作原理
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the factor that determines whether the else statement is skipped
    is whether the break statement executes. In short: run break -> skip else and
    no break -> run else. Thus, if the iteration involves no break statements, don’t
    append the else statement because it executes anyway. In other words, a valid
    use case of the for...else... statement is that you need to include a break statement
    in the iteration part.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，决定是否跳过else语句的因素是break语句是否执行。简而言之：执行break -> 跳过else，没有执行break -> 执行else。因此，如果迭代不涉及break语句，则不需要添加else语句，因为它无论如何都会执行。换句话说，for...else...语句的有效用例之一是你需要在迭代部分包含一个break语句。
- en: Consider a practical use case. Suppose that we have a list of tasks, and we
    want to locate the first task with the desired urgency level. We may have a solution
    that uses a for...else... statement, as shown in the following listing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实际用例。假设我们有一个任务列表，我们想要定位具有所需紧急水平的第一个任务。我们可能有一个使用for...else...语句的解决方案，如下面的列表所示。
- en: Listing 5.11 A practical example of the for...else statement
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 for...else语句的实际示例
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In listing 5.11, we see that when the iteration finds a task with the desired
    urgency level, it exits the loop in such a way that the else statement is skipped.
    When all the iterations complete without triggering the break statement, however,
    such as when the desired urgency level is 1, the else statement is executed, and
    we get the printout of None for the task.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表5.11中，我们看到当迭代找到一个具有所需紧急水平的任务时，它会以跳过else语句的方式退出循环。然而，当所有迭代完成而没有触发break语句时，例如当所需的紧急水平为1时，else语句被执行，并且我们得到任务为None的打印输出。
- en: Using else in a while loop
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环中使用else
- en: 'When you append an else statement to a while loop, it forms the following structure:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将else语句添加到while循环中时，它形成以下结构：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Like the for...else... statement, the while...else... statement has the same
    execution rule: run break -> skip else and no break -> run else. Figure 5.8 shows
    the rule for for and while loops.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与for...else...语句一样，while...else...语句具有相同的执行规则：执行break -> 跳过else，没有执行break ->
    执行else。图5.8显示了for和while循环的规则。
- en: '![CH05_F08_Cui](../Images/CH05_F08_Cui.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F08_Cui](../Images/CH05_F08_Cui.png)'
- en: Figure 5.8 How else works in for and while loops. In the iteration loop, if
    a break statement runs, the iteration ends immediately, and the else statement
    is skipped. If the loop ends normally without running the break statement, the
    else statement is executed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 for和while循环中else的工作方式。在迭代循环中，如果执行了break语句，则迭代立即结束，else语句被跳过。如果没有执行break语句而正常结束循环，则执行else语句。
- en: As a practical example, suppose that we want to rest while we complete a series
    of tasks in each session. To make our work effective in a session, we set a resting
    threshold as the sum of the total urgency level for the completed tasks. The next
    listing shows a possible implementation using the while...else... statement.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际示例，假设我们希望在每次会话中完成一系列任务的同时休息。为了使我们的工作在会话中有效，我们设置一个休息阈值，即已完成任务的总体紧急水平的总和。下面的列表显示了使用while...else...语句的可能实现。
- en: Listing 5.12 A practical example of the while...else statement
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 while...else语句的实际示例
- en: '[PRE56]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ A list evaluates to True if it is nonempty.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果一个列表非空，则其评估结果为True。
- en: ❷ pop removes and returns the last item from a list object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ pop从列表对象中移除并返回最后一个元素。
- en: Readability When you examine the emptiness of a data container or a sequence
    object, such as str, list, or dict, it’s preferred that you use the object itself,
    such as if tasks and while tasks. In these cases, if the tasks has any items,
    it’s evaluated to be True. By contrast, a non-Pythonic or less-readable approach
    involves examining the length of these objects, such as if len(tasks) > 0.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 当您检查数据容器或序列对象（如str、list或dict）的空状态时，您最好使用对象本身，例如if tasks和while tasks。在这些情况下，如果tasks有任何项，它将被评估为True。相比之下，一种非Pythonic或可读性较差的方法是检查这些对象的长度，例如if
    len(tasks) > 0。
- en: The first two calls on the complete_tasks_with_break function involve running
    the break statement so that the else statement is skipped. By contrast, the third
    call completes the iterations without running the break statement so that the
    else statement runs.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: complete_tasks_with_break函数的前两次调用涉及运行break语句，以便跳过else语句。相比之下，第三次调用在未运行break语句的情况下完成迭代，因此else语句被执行。
- en: 5.4.4 Discussion
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.4 讨论
- en: You should be clear about when to use for and when to use while for iterations.
    Use for loops when you have an iterable to begin with and the number of iterations
    depends on the number of items that the iterable can render. By contrast, use
    while loops when you’re not sure how many iterations you will run, as the while
    loop consistently checks against a specific criterion to determine when to end.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该清楚何时使用 for 循环和何时使用 while 循环进行迭代。当你一开始就有可迭代对象，且迭代次数取决于可迭代对象可以渲染的项目数量时，使用 for
    循环。相比之下，当你不确定将运行多少次迭代时，使用 while 循环，因为 while 循环会持续检查特定标准以确定何时结束。
- en: Avoid using else with for and while loops because this practice is unfamiliar
    to most people and thus confuses many programmers. I don’t recommend using this
    feature in your codebase. I showed you the technique only in case you see other
    programmers use it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在 for 循环和 while 循环中使用 else 语句，因为这种做法对大多数人来说都不熟悉，因此会令许多程序员感到困惑。我不建议在你的代码库中使用这个特性。我仅展示了这个技术，以防你看到其他程序员使用它。
- en: Maintainability Avoid using else with for and while loops, which can be confusing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 避免在 for 循环和 while 循环中使用 else 语句，这可能会造成混淆。
- en: 5.4.5 Challenge
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.5 挑战
- en: Listing 5.7 set an initial value of None to the first_urgent_task1 variable.
    As mentioned, setting this initial value is important because there’s no guarantee
    that an urgent task can be found if you deal with a different set of tasks. Suppose
    that you don’t set an initial value and use a list of tasks that doesn’t contain
    any urgent task. See what happens if you try to access the first_urgent_task1
    variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 将 first_urgent_task1 变量的初始值设置为 None。正如所述，设置此初始值很重要，因为如果你处理的是一组不同的任务，无法保证一定能找到紧急任务。假设你没有设置初始值，并使用一个不包含任何紧急任务的待办事项列表。看看当你尝试访问
    first_urgent_task1 变量时会发生什么。
- en: Hint If a variable hasn’t been assigned, Python has no way to figure out what
    you mean by that variable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 如果一个变量没有被赋值，Python 没有办法确定你所说的那个变量是什么意思。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Iterables can be converted to iterators by means of the iter function. The iterators
    are data objects that can render their elements one by one by using the next function.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象可以通过 iter 函数转换为迭代器。迭代器是数据对象，可以通过使用 next 函数逐个渲染它们的元素。
- en: Common data containers such as list, dict, set, and tuple can take iterables
    to create their respective instance objects using their respective constructors.
    Thus, whenever you have iterables of any type, if you need to create data containers
    from the existing iterables, think about using these constructors first.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的数据容器，如列表、字典、集合和元组，可以通过各自的构造函数接受可迭代对象来创建它们各自的实例对象。因此，每当你有任何类型的可迭代对象时，如果你需要从现有可迭代对象创建数据容器，首先考虑使用这些构造函数。
- en: List, dictionary, and set comprehensions are concise ways to create list, dict,
    and set objects, respectively. They eliminate the need to use a regular for loop
    for instantiation. If you don’t manipulate the items, however, it’s likely that
    you can use the constructor directly for instantiation.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、字典和集合推导式是创建列表、字典和集合对象的简洁方式，分别对应。它们消除了使用常规 for 循环进行实例化的需要。然而，如果你不操作这些项，你很可能可以直接使用构造函数进行实例化。
- en: We use for loops to perform iterations on iterables, and they constitute an
    essential way of applying the same operations to a group of items stored in an
    iterable. To make for loops more effective, you need to remember the advanced
    approaches to manipulating existing iterables, such as enumerate, reversed, zip,
    chain, and filter. Among these functions, chain is part of the itertools module,
    which has additional advanced operations with iterations.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 for 循环在可迭代对象上执行迭代，它们是应用相同操作到存储在可迭代对象中的项目组的基本方式。为了使 for 循环更有效，你需要记住操作现有可迭代对象的高级方法，例如
    enumerate、reversed、zip、chain 和 filter。在这些函数中，chain 是 itertools 模块的一部分，该模块具有额外的迭代高级操作。
- en: 'Both for and while loops can include three optional statements: break, continue,
    and else. break exits the loop instantly, continue skips the current iteration,
    and else runs when there is no break in the iteration loop. You need to know the
    proper use cases for these statements.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for 循环和 while 循环都可以包含三个可选语句：break、continue 和 else。break 立即退出循环，continue 跳过当前迭代，而
    else 在迭代循环中没有 break 语句时执行。你需要知道这些语句的正确用法。
