- en: 2  The Basics of Node.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2  Node.js 的基础知识
- en: 'In the first chapter, we talked about what Node.js is. We discussed that it''s
    JavaScript, it is asynchronous in nature, and that it has a rich set of third-party
    modules. If you''re like me, you didn''t totally understand these things when
    you first started with Node. This chapter aims to give the intro to Node that
    I wish I had: short and sweet.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了 Node.js 是什么。我们讨论了它是 JavaScript，它是异步的，并且它有一套丰富的第三方模块。如果你像我一样，当你刚开始使用
    Node 时，你并没有完全理解这些事情。本章旨在提供我希望拥有的 Node 入门介绍：简短而精炼。
- en: We'll talk about
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论
- en: ·  Installing Node
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ·  安装 Node
- en: ·  How to use its module system
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用其模块系统
- en: ·  How to install third-party packages
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何安装第三方包
- en: ·  Some examples of its fancy "evented I/O".
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  它花哨的“事件驱动 I/O”的一些示例。
- en: ·  Some tricks for running your Node code nicely.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  运行你的 Node 代码的一些技巧。
- en: NOTE I'm going to assume that you know a fair bit of JavaScript and that you
    don't want an extremely thorough knowledge of Node from this chapter. I'm also
    going to assume that you have a working understanding of how to use the command
    line. If this whirlwind introduction to Node is a little too whirlwind, check
    out Node.js in Action at [http://www.manning.com/cantelon/](http://www.manning.com/cantelon/) for
    more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我将假设你已经对 JavaScript 有相当的了解，并且你不想从这个章节中获得 Node 的极其详尽的知识。我还将假设你熟悉如何使用命令行。如果这个关于
    Node 的快速介绍有点太快了，你可以查看[http://www.manning.com/cantelon/](http://www.manning.com/cantelon/)上的
    Node.js in Action 以获取更多信息。
- en: Let's get started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 2.1     Installing Node
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1     安装 Node
- en: A theme of the JavaScript world is an overwhelming number of choices, and Node's
    installation is no exception; there are a lot of different ways to get Node running
    on your system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 世界的主题是选择过多，Node 的安装也不例外；有太多不同的方式可以在你的系统上运行 Node。
- en: The official downloads page at [http://nodejs.org/download/](http://nodejs.org/download/) has
    a number of download links for pretty much every platform—Windows, Mac, and Linux.
    The choice of platform should be obvious—choose the one for your operating system.
    If you're not sure if your system is 32-bit or 64-bit, search the web to try to
    answer it because you'll get a lot of performance benefits from choosing 64-bit
    if it's available. Mac and Windows users have the option to download a binary
    or an installer, and I'd recommend the latter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://nodejs.org/download/](http://nodejs.org/download/)的官方下载页面上有针对几乎所有平台的下载链接——Windows、Mac
    和 Linux。平台的选择应该是显而易见的——选择适合你操作系统的版本。如果你不确定你的系统是 32 位还是 64 位，请在网上搜索以尝试回答这个问题，因为如果你可以选择
    64 位，你将获得很多性能上的好处。Mac 和 Windows 用户可以选择下载二进制文件或安装程序，我建议选择后者。
- en: If you have a package manager on your system, you can use that instead. Node.js
    is available on various package mangers, including apt-get, Homebrew, and Chocolatey.
    You can check out the official "Installing Node.js via package manager" guide
    at [https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你系统中有包管理器，你可以使用它。Node.js 可在多个包管理器上使用，包括 apt-get、Homebrew 和 Chocolatey。你可以在[https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager](https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager)查看官方的“通过包管理器安装
    Node.js”指南。
- en: 'If you''re on Mac or Linux, I highly recommend the Node Version Manager, or
    NVM, found at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
    If you''re on Windows, NVMW at [https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw) is
    a port for Windows users. These programs allow you to easily switch between Node
    versions, which is great if you want to have the stable version of Node and the
    exciting experimental pre-release versions. It also allows you to easily upgrade
    Node when new versions are released. NVM has a couple of other benefits that I
    like, too: it''s trivial to uninstall, and it doesn''t need administrator (root)
    access to install it on your system.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac 或 Linux，我强烈推荐使用 Node 版本管理器，或简称 NVM，可以在[https://github.com/creationix/nvm](https://github.com/creationix/nvm)找到。如果你使用的是
    Windows，NVMW 在[https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw)为
    Windows 用户提供了一个端口。这些程序允许你轻松地在 Node 版本之间切换，如果你想要同时拥有 Node 的稳定版本和令人兴奋的实验性预发布版本，这将是极好的。它还允许你在新版本发布时轻松升级
    Node。NVM 还有一些我喜欢的其他好处：它非常容易卸载，并且安装时不需要管理员（root）权限。
- en: NVM is a one-line install that you can copy-paste and run from the instructions
    at [https://github.com/creationix/nvm](https://github.com/creationix/nvm) (or [https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw) for
    the Windows version).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NVM 是一个单行安装，你可以从 [https://github.com/creationix/nvm](https://github.com/creationix/nvm)（或
    [https://github.com/hakobera/nvmw](https://github.com/hakobera/nvmw) 用于 Windows
    版本）的说明中复制粘贴并运行。
- en: In any case, get Node installed!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，安装 Node 吧！
- en: 2.1.1  Running your first Node script
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1  运行你的第一个 Node 脚本
- en: 'How ever you chose to install Node, it''s time to run something! Let''s built
    the classic "hello world". Create a file called `helloworld.js` and put the following
    inside:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何安装 Node，现在是时候运行一些东西了！让我们构建经典的 "hello world"。创建一个名为 `helloworld.js` 的文件，并在其中放入以下内容：
- en: Listing 2.1 helloworld.js
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 helloworld.js
- en: '`console.log("Hello, world!");`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log("Hello, world!");`'
- en: 'We call the `console.log` function with the argument we want to print: the
    string "Hello, world!". If you''ve ever used the console when writing browser-based
    JavaScript, this should look familiar.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们想要打印的参数调用 `console.log` 函数：字符串 "Hello, world!"。如果你曾经在使用基于浏览器的 JavaScript
    编写时使用过控制台，这应该看起来很熟悉。
- en: To run this, type `node helloworld.js`. (You may have to `cd` into the directory
    where `helloworld.js` lives.) If everything works well, you should see the text
    appear on the screen! The output will look something like Figure 2.1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，请输入 `node helloworld.js`。（你可能需要 `cd` 到 `helloworld.js` 所在的目录。）如果一切顺利，你应该会在屏幕上看到文本！输出将类似于图
    2.1。
- en: '![](../Images/02_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/02_01.png)'
- en: Figure 2.1 The result of running our "hello world" code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 运行我们的 "hello world" 代码的结果。
- en: 2.2     Using modules
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2     使用模块
- en: Most programming languages have a way of including File A from File B so that
    you can split your code into multiple files. C and C++ have `#include`; Python
    has `import`; Ruby and PHP have `require`. Some languages like C# do this kind
    of cross-file communication implicitly at compile time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种方式来包含文件 A 以便从文件 B 中提取，这样你就可以将代码分成多个文件。C 和 C++ 有 `#include`；Python
    有 `import`；Ruby 和 PHP 有 `require`。一些语言如 C# 在编译时隐式地执行这种跨文件通信。
- en: For most of its life, the JavaScript language didn't have an official way to
    do this. To solve this problem, people built things that concatenated JavaScript
    files together into one file, or built dependency loaders like RequireJS. A lot
    of web developers simply fill their webpages with `<script>` tags.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 语言的多数历史中，它没有官方的方式来执行这项任务。为了解决这个问题，人们构建了将 JavaScript 文件连接成一个文件的工具，或者构建了像
    RequireJS 这样的依赖加载器。许多网络开发者只是简单地用 `<script>` 标签填充他们的网页。
- en: Node wanted to solve this problem elegantly and they implemented a standard
    module system called CommonJS. At its core, CommonJS lets you include code from
    one file in another.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Node 希望优雅地解决这个问题，并实现了一个名为 CommonJS 的标准模块系统。在其核心，CommonJS 允许你从一个文件中包含另一个文件的代码。
- en: 'There are three major components to this module system: requiring built-in
    modules, requiring third-party modules, and making your own modules. Let''s see
    how they work.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块系统有三个主要组成部分：引入内置模块、引入第三方模块以及创建自己的模块。让我们看看它们是如何工作的。
- en: 2.2.1  Requiring built-in modules
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1  引入内置模块
- en: Node has a number of built-in modules, ranging from file system access in a
    module called "fs" to utility functions in a built-in module called "util".
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Node 有许多内置模块，从名为 "fs" 的模块中的文件系统访问到名为 "util" 的内置模块中的实用函数。
- en: A common task when building web applications with Node is parsing of the URL.
    When a browser sends a request to your server, they'll ask for a specific URL.
    Perhaps they'll ask for the homepage; perhaps they'll ask for the about page;
    perhaps they'll ask for something else. These URLs come in as strings but we often
    want to parse them to get more information about them. Node has a built-in URL
    parser module; let's use it to see how to require packages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 构建网络应用时，一个常见的任务是解析 URL。当浏览器向你的服务器发送请求时，它们会请求一个特定的 URL。也许他们会请求主页；也许他们会请求关于页面；也许他们会请求其他内容。这些
    URL 以字符串的形式传入，但我们通常希望解析它们以获取更多信息。Node 有一个内置的 URL 解析模块；让我们使用它来看看如何引入包。
- en: Node's built-in `url` module exposes a few functions, but the "big kahuna" is
    a function called `parse`. It takes a URL string and extracts useful information,
    like the domain or the path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的内置 `url` 模块公开了一些函数，但 "大块头" 是一个名为 `parse` 的函数。它接受一个 URL 字符串并提取有用的信息，如域名或路径。
- en: 'We''ll use Node''s `require` function to use the `url` module. `require` is
    similar to keywords like `import` or `include` in other languages. `require` takes
    the name of a package as a string argument and returns a package. There''s nothing
    special about the object that''s returned—it''s often an object, but it could
    be a function or a string or a number. Here''s how we might use the URL module:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Node 的 `require` 函数来使用 `url` 模块。`require` 与其他语言中的 `import` 或 `include`
    关键字类似。`require` 接收一个包名称作为字符串参数，并返回一个包。返回的对象没有什么特别之处——它通常是一个对象，但它也可能是函数、字符串或数字。以下是使用
    URL 模块的方法：
- en: Listing 2.2 Requiring Node's URL module
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 导入 Node 的 URL 模块
- en: '`var url = require("url");   #A` `var parsedURL = url.parse("http://www.example.com/  
    #B` `                       [CA]profile?name=barry");  #B`   `console.log(parsedURL.protocol); 
    // "http:"` `console.log(parsedURL.host);      // "www.example.com"``console.log(parsedURL.query);    
    // "name=barry"`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`var url = require("url");   #A` `var parsedURL = url.parse("http://www.example.com/  
    #B` `                       [CA]profile?name=barry");  #B` `console.log(parsedURL.protocol); 
    // "http:"` `console.log(parsedURL.host);      // "www.example.com"` `console.log(parsedURL.query);    
    // "name=barry"`'
- en: '#A This requires a module called "url" and puts it in a variable called "url".
    It''s just a convention that these are the same.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这要求一个名为 "url" 的模块，并将其放入一个名为 "url" 的变量中。这是一个约定，它们是相同的。'
- en: '#B This uses url.parse. This would throw an undefined error if we didn''t have
    the first line requiring the module.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 这使用了 url.parse。如果没有第一行导入模块，这将抛出一个未定义的错误。'
- en: In the above example, `require("url")` returns an object that has the parse
    function attached. Then we use it as we would any object!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`require("url")` 返回一个具有附加 parse 函数的对象。然后我们就像使用任何对象一样使用它！
- en: If you save this as `url-test.js`, you can run it with `node url-test.js`. It
    will print the protocol, host, and query of our example URL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其保存为 `url-test.js`，你可以使用 `node url-test.js` 运行它。它将打印出我们示例 URL 的协议、主机和查询。
- en: 'Most of the time, when you are requiring a module, you''ll put in a variable
    that has the same name as the module itself. The above example puts the url module
    in a variable of the same name: url.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当你需要导入一个模块时，你会将一个与模块本身同名的变量放入其中。上面的例子将 url 模块放入了一个同名的变量中：url。
- en: 'But you don''t have to do that! We could have put it in a variable with a completely
    different name, if we wanted. The following example illustrates that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不必这样做！如果我们愿意，我们可以将其放入一个完全不同名称的变量中。以下示例说明了这一点：
- en: Listing 2.3 Requiring things into different variable names
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 将事物导入不同的变量名
- en: '`var theURLModule = require("url");`   `var parsedURL = theURLModule.parse("http://example.com");``//
    ...`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`var theURLModule = require("url");` `var parsedURL = theURLModule.parse("http://example.com");`
    `// ...`'
- en: It's a loose convention to give the variables the same name as what you're requiring
    to prevent confusion, but there's nothing enforcing that in code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给变量命名与你要导入的内容相同的名称是一种松散的约定，以防止混淆，但在代码中并没有强制执行这一点。
- en: 2.2.2  Requiring third-party modules with package.json and npm
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 使用 package.json 和 npm 导入第三方模块
- en: Node has several built-in modules, but they're rarely enough; third-party packages
    are indispensible when making applications. And this is a book about a third-party
    module, after all, so you should definitely know how to use them!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Node 有几个内置模块，但它们通常不足以满足需求；在制作应用程序时，第三方包是必不可少的。毕竟，这本书是关于第三方模块的，所以你绝对应该知道如何使用它们！
- en: The first thing we need to talk about is `package.json`. Every Node project
    sits in a folder, and at the root of every Node project, there's a file called `package.json`.
    (When I say "every Node project", I mean every single one, from third-party packages
    to applications. You'll likely never build a Node project without one.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先讨论的是 `package.json`。每个 Node 项目都位于一个文件夹中，每个 Node 项目的根目录下都有一个名为 `package.json`
    的文件。（当我提到“每个 Node 项目”，我的意思是每一个，从第三方包到应用程序。你很可能不会在没有 `package.json` 的情况下构建 Node
    项目。）
- en: '"package dot json" is a pretty simple JSON file that defines project metadata
    like the name of the project, its version, and its authors. It also defines the
    project''s dependencies.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '"package dot json" 是一个相当简单的 JSON 文件，它定义了项目元数据，如项目的名称、版本和作者。它还定义了项目的依赖项。'
- en: 'Let''s make a simple app. Make a new folder and save this to `package.json`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序。创建一个新的文件夹，并将以下内容保存到 `package.json`：
- en: Listing 2.4 A simple package.json file
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 一个简单的 package.json 文件
- en: '`{` `  "name": "my-fun-project",   #A` `  "author": "Evan Hahn",      #B` ` 
    "private": true,            #C` `  "version": "0.2.0",         #D` `  "dependencies":
    {}          #E``}`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "my-fun-project",   #A` `  "author": "Evan Hahn",      #B` ` 
    "private": true,            #C` `  "version": "0.2.0",         #D` `  "dependencies":
    {}          #E``}`'
- en: '#A Define the name of your project.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 定义你项目的名称。'
- en: '#B Define the author. This can be an array of authors if you have many, and
    it probably isn''t "Evan Hahn".'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 定义作者。如果你有多个作者，这可以是一个作者数组，而且很可能不是 "Evan Hahn"。'
- en: '#C This says "this is a private project; don''t let me be published to the
    package registry for anyone to use."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这表示 "这是一个私有项目；不要让我被发布到包注册库供任何人使用。"'
- en: '#D Define the version of the package.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 定义包的版本。'
- en: '#E Notice that this project has no dependencies yet. We''ll install some soon!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '#E 注意，这个项目目前还没有依赖项。我们很快就会安装一些。'
- en: Now that we've defined our package, we can install its dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的包，我们可以安装它的依赖项。
- en: 'When you install Node, you actually get two programs: Node (as you might expect)
    and something called npm (deliberately lowercase). npm is an official helper for
    Node that helps you with your Node projects.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Node 时，你实际上得到了两个程序：Node（正如你可能预期的）和称为 npm 的东西（故意小写）。npm 是 Node 的官方助手，它帮助你处理
    Node 项目。
- en: npm is often called the "Node Package Manager", but its unabbreviated name has
    never been explicitly stated—its website randomly shows names like "Never Poke
    Monkeys" or "Nine Putrid Mangos". It may evade the "package manager" moniker because
    it does much more than that, but package management is perhaps its biggest feature,
    which we'll use now.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: npm 通常被称为 "Node 包管理器"，但其全称从未被明确指出——其网站随机显示诸如 "Never Poke Monkeys" 或 "Nine Putrid
    Mangos" 这样的名字。它可能避免了 "包管理器" 这个名称，因为它做的不仅仅是包管理，但包管理可能是其最大的特性，我们现在就要使用它。
- en: 'Let''s say we want to use Mustache (see [https://mustache.github.io/](https://mustache.github.io/)),
    a standard little templating system. It lets you turn template strings into "real"
    strings. An example explains it best:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用 Mustache（见 [https://mustache.github.io/](https://mustache.github.io/)），一个标准的简单模板系统。它允许你将模板字符串转换为
    "真实" 字符串。一个例子最能说明问题：
- en: Listing 2.5 An example of the Mustache templating system
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 Mustache 模板系统的示例
- en: '`// Returns "Hello, Nicholas Cage!"` `Mustache.render("Hello, {{first}} {{last}}!",
    {` `  first: "Nicholas",` `  last: "Cage"` `});`   `// Returns "Hello, Sheryl
    Sandberg!"` `Mustache.render("Hello, {{first}} {{last}}!", {` `  first: "Sheryl",`
    `  last: "Sandberg"``});`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`// 返回 "Hello, Nicholas Cage!"` `Mustache.render("Hello, {{first}} {{last}}!",
    {` `  first: "Nicholas",` `  last: "Cage"` `});`   `// 返回 "Hello, Sheryl Sandberg!"`
    `Mustache.render("Hello, {{first}} {{last}}!", {` `  first: "Sheryl",` `  last:
    "Sandberg"` `});`'
- en: Let's say that we want to write a simple Node application that greets Nicholas
    Cage with the Mustache module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想写一个简单的 Node 应用程序，使用 Mustache 模块向 Nicholas Cage 打招呼。
- en: 'From the root of this directory, run `npm install mustache --save`. (You must
    run this command from the root of this directory so that `npm` knows where to
    put things.) This command will create a new folder in this directory called`node_modules`.
    Then it downloads the latest version of the Mustache package and puts it into
    this new `node_modules` folder (go look inside to check it out!). Finally, the `--save` flag
    will add it to your `package.json`. Your package.json file should look similar,
    but it will now have the latest version of the Mustache package:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个目录的根目录运行 `npm install mustache --save`。（你必须从这个目录的根目录运行这个命令，这样 `npm` 才知道在哪里放置东西。）这个命令将在该目录中创建一个新的文件夹，名为
    `node_modules`。然后它下载 Mustache 包的最新版本并将其放入这个新的 `node_modules` 文件夹中（进去看看吧！）最后，`--save`
    标志将其添加到你的 `package.json` 文件中。你的 package.json 文件应该看起来类似，但现在它将包含 Mustache 包的最新版本：
- en: Listing 2.6 A simple package.json file
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 一个简单的 package.json 文件
- en: '`{` `  "name": "my-fun-project",` `  "author": "Evan Hahn",` `  "private":
    true,` `  "version": "0.2.0",` `  "dependencies": {` `    "mustache": "^2.0.0" 
    #A` `  }``}`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "my-fun-project",` `  "author": "Evan Hahn",` `  "private":
    true,` `  "version": "0.2.0",` `  "dependencies": {` `    "mustache": "^2.0.0" 
    #A` `  }``}`'
- en: '#A Notice this new line. Your dependency version may be newer than the one
    here.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意这个新行。你的依赖项版本可能比这里的新。'
- en: If you left off the `--save` flag, you'd see the new `node_modules` folder and
    it'd have Mustache inside, but nothing would be present in your `package.json`.
    The reason you want dependencies listed in your `package.json` is so that someone
    else can install the dependencies later if you gave them the project—they just
    have to run `npm install` with no arguments. Node projects typically have dependencies
    listed in their `package.json` but they don't come with the actual dependency
    files (they don't include the `node_modules` folder).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用`--save`标志，你会看到新的`node_modules`文件夹，里面会有Mustache，但在你的`package.json`中没有任何内容。你想要在`package.json`中列出依赖项的原因是，如果有人得到了你的项目，他们稍后可以安装这些依赖项——他们只需要运行`npm
    install`而不带任何参数。Node项目通常在`package.json`中列出依赖项，但它们并不包含实际的依赖文件（它们不包含`node_modules`文件夹）。
- en: Now that we've installed it, we can use the Mustache module from our code!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了它，我们就可以在我们的代码中使用Mustache模块了！
- en: Listing 2.7 Using the Mustache module
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 使用Mustache模块
- en: '`var Mustache = require("mustache");  #A` `var result = Mustache.render("Hi,
    {{first}} {{last}}!", {` `  first: "Nicolas",` `  last: "Cage"` `});``console.log(result);`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`var Mustache = require("mustache");  #A` `var result = Mustache.render("Hi,
    {{first}} {{last}}!", {` `  first: "Nicolas",` `  last: "Cage"` `});``console.log(result);`'
- en: '#A Notice how we require Mustache—just like a built-in module.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意我们是如何require Mustache的——就像一个内置模块。'
- en: Save the code above to `mustache-test.js` and run it with `node mustache-test.js`. 
    You should see the text "Hi, Nicholas Cage!" appear.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码保存为`mustache-test.js`，并使用`node mustache-test.js`运行它。你应该会看到文本“Hi, Nicholas
    Cage!”出现。
- en: And that's it! Once it's installed into `node_modules`, you can use Mustache
    just like you would a built-in module. Node knows how to require modules inside
    the `node_modules` folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦安装到`node_modules`中，你就可以像使用内置模块一样使用Mustache。Node知道如何从`node_modules`文件夹中require模块。
- en: When you're adding dependencies, you can also manually edit `package.json` and
    then run `npm install`. You can also install specific versions of dependencies
    or install them from places other than the official npm registry; see more at
    the `npm install` documentation ([https://docs.npmjs.com/cli/install](https://docs.npmjs.com/cli/install)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加依赖项时，你也可以手动编辑`package.json`，然后运行`npm install`。你也可以安装特定版本的依赖项，或者从非官方npm注册处安装它们；更多内容请参阅`npm
    install`文档([https://docs.npmjs.com/cli/install](https://docs.npmjs.com/cli/install))。
- en: npm init
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: npm init
- en: npm does much more than just install dependencies. For example, it allows you
    to autogenerate your package.json file. You can create package.json by hand yourself,
    but npm can do it for you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: npm的功能远不止安装依赖项。例如，它允许你自动生成你的package.json文件。你可以手动创建package.json，但npm可以为你完成这项工作。
- en: In your new project directory, you can type npm init. It will ask you a bunch
    of questions about your project—project name, author, version—and when it's all
    done, it will save a new package.json. There's nothing sacred about this generated
    file; you can change it all you want. But it can save you a bit of time when creating
    these package.json files.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新项目目录中，你可以输入npm init。它会询问你关于项目的一些问题——项目名称、作者、版本等——完成后，它会保存一个新的package.json。这个生成的文件没有什么神圣的；你可以随意更改它。但它可以在创建这些package.json文件时节省你一些时间。
- en: 2.2.3  Defining your own modules
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 定义自己的模块
- en: We've been using other peoples' modules for this whole chapter—now let's learn
    how to define our own.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用他人的模块——现在让我们学习如何定义自己的模块。
- en: 'Let''s say we want a function that returns a random integer between 0 and 100. 
    Without any module magic, that function might look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个函数，该函数返回0到100之间的随机整数。在没有模块魔法的情况下，这个函数可能看起来像这样：
- en: Listing 2.8 A function that returns a random integer between 0 and 100
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 返回0到100之间随机整数的函数
- en: '`var MAX = 100;`   `function randomInteger() {` `   return Math.floor((Math.random()
    * MAX));``}`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`var MAX = 100;` `function randomInteger() {` `   return Math.floor((Math.random()
    * MAX));``}`'
- en: This shouldn't be too earth-shattering; this might be how you'd write that function
    in a browser context. But in Node, we can't just save this into a file and call
    it a day; we need to choose a variable to export, so that when other files`require` this
    one, they know what to grab. In this case, we'll be exporting `randomInteger`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会太震撼；这可能是你在浏览器环境中编写该函数的方式。但在Node中，我们不能只是将其保存到文件中，然后结束；我们需要选择一个变量来导出，这样当其他文件`require`这个文件时，它们就知道要抓取什么。在这种情况下，我们将导出`randomInteger`。
- en: 'Try saving this into a file called `random-integer.js`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将以下内容保存到名为`random-integer.js`的文件中：
- en: Listing 2.9 random-integer.js
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 random-integer.js
- en: '`var MAX = 100;`   `function randomInteger() {` `   return Math.floor((Math.random()
    * MAX));` `}`  `module.exports = randomInteger; #A`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`var MAX = 100;` `function randomInteger() {` `   return Math.floor((Math.random()
    * MAX));` `}` `module.exports = randomInteger; #A`'
- en: '#A This line does the actual "exporting" of the module for other files.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这一行实际上完成了模块对其他文件的“导出”。'
- en: The last line is the only thing that might be foreign to someone new to Node.
    You can only export one variable, and you'll choose that variable by setting `module.exports` to
    it. In this case, the variable we're exporting is a function. In this module, `MAX` is
    not exported, so that variable won't be available to anyone who requires this
    file. Nobody will be able to require it--it'll stay private to the module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行可能是新接触Node的人感到陌生的地方。你只能导出一个变量，并且你会通过将`module.exports`设置为它来选择那个变量。在这个例子中，我们导出的变量是一个函数。在这个模块中，`MAX`没有被导出，所以这个变量对任何需要这个文件的人来说都是不可用的。没有人能够导入它——它将保持模块的私有性。
- en: REMEMBER module.exports can be anything you want. Anything to which you can
    assign a variable can be assigned to `module.exports`. It's a function in this
    example, but is often an object. It could even be a string or a number or an array
    if you'd like!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: REMEMBER `module.exports` 可以是任何你想要的东西。任何你可以分配变量的东西都可以分配给`module.exports`。在这个例子中，它是一个函数，但通常是对象。如果你愿意，甚至可以是字符串、数字或数组！
- en: Now, let's say we wanted to use our new module. In the same directory as `random-integer.js`,
    save a new file. It doesn't matter what you call it (so long as it's not `random-integer.js`),
    but let's call it `print-three-random-integers.js`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要使用我们新的模块。在`random-integer.js`所在的同一目录下，保存一个新文件。你给它取什么名字都无关紧要（只要它不是`random-integer.js`），但让我们叫它`print-three-random-integers.js`。
- en: Listing 2.10 Using our module from another file
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 从另一个文件使用我们的模块
- en: '`var randomInt = require("./random-integer");  #A` `console.log(randomInt()); 
    // 12` `console.log(randomInt());  // 77``console.log(randomInt());  // 8`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`var randomInt = require("./random-integer"); #A` `console.log(randomInt());
    // 12` `console.log(randomInt()); // 77` `console.log(randomInt()); // 8`'
- en: '#A Note that this is a relative path.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意这是一个相对路径。'
- en: We can now require it just like any other module, but we have to specify the
    path using the dot syntax. Other than that, it's exactly the same! You can use
    it as you would another module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像使用其他模块一样使用它，但我们必须使用点语法指定路径。除此之外，它完全一样！你可以像使用其他模块一样使用它。
- en: You can run this code just like any other, by running `node print-three-random-integers.js`.
    If you did everything correctly, it'll print three random numbers between 0 and
    100!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像运行其他代码一样运行这段代码，通过运行`node print-three-random-integers.js`。如果你一切都做对了，它将打印出0到100之间的三个随机数！
- en: You might try running `node random-integer.js`, and you'll notice that it doesn't
    appear do anything. It exports a module, but defining a function doesn't mean
    the function will run and print anything to the screen!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会尝试运行`node random-integer.js`，你会注意到它似乎没有做什么。它导出了一个模块，但定义一个函数并不意味着函数会运行并打印任何东西到屏幕上！
- en: NOTE This book only covers making local modules within a project. If you're
    interested in publishing open source packages for everyone to use, check out the
    guide on my website at [http://evanhahn.com/make-an-npm-baby](http://evanhahn.com/make-an-npm-baby) .
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NOTE 这本书只涵盖在项目内部创建本地模块。如果你对为所有人使用发布开源包感兴趣，请查看我网站上关于如何创建npm包的指南[http://evanhahn.com/make-an-npm-baby](http://evanhahn.com/make-an-npm-baby)。
- en: That's a quick intro to Node's module system!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是对Node模块系统的快速介绍！
- en: '2.3     Node: an asynchronous world'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 Node：一个异步的世界
- en: In Chapter 1, we discussed the asynchronous nature of Node. I used a "let's
    bake muffins" analogy. While I'm preparing the batter for my muffins, I can't
    do other substantive things; I can't read a book; I can't prepare more batter,
    et cetera. But once I put the muffins in the oven, I can do other things. I don't
    just stand there staring at the oven until it beeps—I could go for a jog. When
    the oven beeps, I'm back on muffin duty and I'm occupied again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了Node的异步特性。我使用了“让我们烤松饼”的类比。当我正在为我的松饼准备面糊时，我无法做其他实质性的事情；我无法读书；我无法再准备更多的面糊，等等。但是一旦我把松饼放进烤箱，我就可以做其他事情了。我不会只是站在那里盯着烤箱，直到它发出哔哔声——我可以去慢跑。当烤箱哔哔声响起时，我又回到了烤松饼的责任上，我又开始忙碌了。
- en: A key point here is that I'm never doing two things at once. Even if multiple
    things are happening at once (I could be jogging while the muffins are baking), I'm only
    doing one thing at a time. This is because the oven isn't me—it's an external
    resource.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个关键点是，我永远不会同时做两件事。即使同时发生多件事（我可以在松饼烤制时慢跑），我也只会一次做一件事。这是因为烤箱不是“我”——它是一个外部资源。
- en: '![](../Images/02_02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_02.png)'
- en: Figure 2.2 Comparing an asynchronous world (like Node) to a synchronous one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 比较异步世界（如Node）和同步世界。
- en: Node's asynchronous model works similarly. A browser might request a 100 megabyte
    cat picture from your Node-powered web server. You begin to load this big photo
    off of the hard disk. As far as we're concerned, the hard disk is an external
    resource, so we ask it for the file and then we can move onto other things while
    we wait for it to load.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Node的异步模型工作方式类似。一个浏览器可能会从你的Node驱动的Web服务器请求一张100兆字节的猫图片。你开始从硬盘加载这张大图片。就我们而言，硬盘是一个外部资源，所以我们请求文件，然后我们可以在等待它加载的同时做其他事情。
- en: 'While you''re loading that file, a second request comes in. You don''t have
    to wait for the first request to finish completely—while you''re waiting for the
    hard disk to finish what it was working on, you can start parsing the second request.
    Once again: Node is never really doing two things at once, but when an external
    resource is working on something, you''re not held up waiting.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在加载该文件时，第二个请求进来了。你不必等待第一个请求完全完成——当你等待硬盘完成它正在处理的工作时，你可以开始解析第二个请求。再次强调：Node实际上并不是同时做两件事，但当外部资源正在处理某事时，你不会被卡住等待。
- en: 'The two most common external resources you''ll deal with in Express are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，你将遇到的两个最常见的外部资源是：
- en: 1.  Anything involving the file system—like reading and writing files from your
    hard drive
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 任何涉及文件系统的事情——比如从硬盘读取和写入文件
- en: 2.  Anything involving a network—like receiving requests, sending responses,
    or sending your own requests over the Internet
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 任何涉及网络的事情——比如接收请求、发送响应或通过互联网发送自己的请求
- en: Conceptually, that's about it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，就是这样了！
- en: In code, these asynchronous things are handled by callbacks. You’ve probably
    done something like this if you've ever done an AJAX request on a webpage; you
    send a request and pass a callback. When the browser has finished your request,
    it'll call your callback. Node works in exactly the same way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这些异步操作是通过回调来处理的。如果你在网页上做过AJAX请求，你可能做过类似的事情；你发送一个请求并传递一个回调。当浏览器完成你的请求后，它会调用你的回调。Node正是以这种方式工作的。
- en: 'For example, let''s say you''re reading a file called `myfile.txt` from disk.
    When you''ve finished reading the whole file, you want to print the number of
    times the letter X appears in the file. Here''s how that might work:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在从磁盘读取一个名为`myfile.txt`的文件。当你读取完整个文件后，你想要打印文件中字母X出现的次数。这可能的工作方式如下：
- en: Listing 2.11 Reading a file from disk
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 从磁盘读取文件
- en: '`var fs = require("fs");  #A`   `var options = { encoding: "utf-8" };                     
    #B` `fs.readFile("myfile.txt", options, function(err, data) {  #B` `  if (err)
    {                                #C` `    console.error("Error reading file!");  
    #C` `    return;                                 #C` `  }                                        
    #C`   `  console.log(data.match(/x/gi).length + " letter X''s");   #D` `});`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`var fs = require("fs");  #A` `var options = { encoding: "utf-8" };                     
    #B` `fs.readFile("myfile.txt", options, function(err, data) {  #B` `  if (err)
    {                                #C` `    console.error("Error reading file!");  
    #C` `    return;                                 #C` `  }                                        
    #C`   `  console.log(data.match(/x/gi).length + " letter X''s");   #D` `});`'
- en: '#A Require Node''s file system module like we''ve seen before.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如我们之前所见，需要Node的文件系统模块。'
- en: '#B Read myfile.txt (and interpret the bytes as UTF-8).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 读取myfile.txt（并将字节解释为UTF-8）。'
- en: '#C Handle any errors encountered when reading the file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 处理读取文件时遇到的任何错误。'
- en: '#D Print the number of X''s by using a regular expression.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 使用正则表达式打印X的数量。'
- en: Let's step through this code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这段代码。
- en: First, we require Node's built-in file system module. This has tons of functions
    for various tasks on the file system, most commonly reading and writing files.
    In this example, we'll use its `readFile` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入Node的内置文件系统模块。这个模块提供了大量的函数，用于文件系统上的各种任务，最常见的是读取和写入文件。在这个例子中，我们将使用它的`readFile`方法。
- en: Next, we set some options that we'll pass into `fs.readFile`. We call it with
    the filename (myfile.txt), the options we just created, and a callback. When the
    file has been read off of disk, Node will jump into your callback.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一些选项，这些选项将传递给`fs.readFile`。我们使用文件名（myfile.txt）、我们刚刚创建的选项和一个回调函数来调用它。当文件从磁盘读取完毕后，Node将跳转到你的回调函数。
- en: Most callbacks in Node are called with an error as their first argument. If
    all goes well, the `err` argument will be `null`. But if things don't go so well
    (maybe the file didn't exist or was corrupted), the `err` argument will have some
    value. It's a best practice to handle those errors. Sometimes the errors don't
    completely halt your program and you can continue on, but you often handle the
    error and then break out of the callback by throwing an error or returning.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Node中的大多数回调都是以错误作为它们的第一个参数。如果一切顺利，`err`参数将是`null`。但如果事情不顺利（比如文件不存在或已损坏），`err`参数将有一些值。处理这些错误是一种最佳实践。有时错误不会完全阻止你的程序，你可以继续执行，但通常你会处理错误，然后通过抛出错误或返回来跳出回调。
- en: This is a common Node practice and you'll see it almost everywhere you see a
    callback.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的Node实践，你几乎在任何看到回调的地方都能看到它。
- en: Finally, once we know we don't have any errors, we print out the number of X's
    in the file! We use a little regular expression trick to do this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们知道没有错误，我们就打印出文件中X的数量！我们使用一个小正则表达式技巧来完成这个任务。
- en: 'Okay, pop quiz: what happens if we added a `console.log` statement at the very
    end of this file, like this?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们来个小测验：如果我们在这个文件的最后添加一个`console.log`语句，会发生什么？
- en: Listing 2.12 Adding a console.log after the asynchronous operations
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 在异步操作后添加console.log
- en: '`var fs = require("fs");`   `vra options = { encoding: "utf-8" };` `fs.readFile("myfile.txt",
    options, function(err, data) {` `  // ...` `});`  `console.log("Hello world!"); 
    #A`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`var fs = require("fs");` `var options = { encoding: "utf-8" };` `fs.readFile("myfile.txt",
    options, function(err, data) {` `  // ...` `});` `console.log("Hello world!");`
    #A'
- en: '#A Note the added line here.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 注意：这里添加了一行。'
- en: Because this file reading operation is asynchronous, we'll see "Hello world"
    before we see any results from the file. This is because the external resource—the
    file system—hasn't gotten back to us yet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个文件读取操作是异步的，我们会在看到任何来自文件的结果之前看到“Hello world”。这是因为外部资源——文件系统——还没有给我们回复。
- en: This is how Node's asynchronous model can be super helpful. While an external
    resource is handling something, we can continue onto other code. In the context
    of web applications, that means that we can parse many more requests at once.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Node的异步模型如何变得非常有帮助。当外部资源正在处理某事时，我们可以继续执行其他代码。在Web应用程序的上下文中，这意味着我们可以同时解析更多的请求。
- en: NOTE There's a fantastic video on how callbacks and the event loop work in JavaScript
    (both in Node and in the browsers). If you're interested in understanding the
    nitty-gritty details, I cannot recommend Philip Roberts's "What the heck is the
    event loop anyway?" at [https://www.youtube.com/watch?v=8aGhZQkoFbQ](https://www.youtube.com/watch?v=8aGhZQkoFbQ) enough.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有一个关于JavaScript中回调和事件循环如何工作的精彩视频（在Node和浏览器中都是如此）。如果你对理解细节感兴趣，我非常推荐Philip
    Roberts的"What the heck is the event loop anyway?"，你可以在这里观看：[https://www.youtube.com/watch?v=8aGhZQkoFbQ](https://www.youtube.com/watch?v=8aGhZQkoFbQ)。
- en: '2.4     Building a web server with Node: the HTTP Module'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用Node构建Web服务器：HTTP模块
- en: 'Understanding the big concepts in Node will help you understand the built-in
    module that''s most important to Express: its HTTP module. It''s the module that
    makes it possible to develop web servers with Node, and it''s what Express is
    built on.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Node中的大概念将帮助你理解Express最重要的内置模块：它的HTTP模块。这个模块使得使用Node开发Web服务器成为可能，也是Express构建的基础。
- en: 'Node''s `http` module has various features (making requests to other servers,
    for instance) but we''ll use its HTTP server component: a function called `http.createServer`.
    This function takes a callback that''s called every time a request comes into
    your server, and it returns a server object. Here''s a very simple server that
    sends "hello world" with every request (which you can save into `myserver.js` if
    you''d like to run it):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Node的`http`模块有许多功能（例如向其他服务器发送请求），但我们将使用它的HTTP服务器组件：一个名为`http.createServer`的函数。这个函数接受一个回调，每当有请求进入你的服务器时都会被调用，并返回一个服务器对象。以下是一个非常简单的服务器，它会随每个请求发送“hello
    world”（如果你想要运行它，可以将其保存为`myserver.js`）：
- en: Listing 2.13 A simple "hello world" web server with Node
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 使用Node的简单“hello world”Web服务器
- en: '`var http = require("http");           #A`   `function requestHandler(request,
    response) {             #B` `  console.log("In comes a request to: " + request.url); 
    #B` `  response.end("Hello, world!");                         #B` `}                              
                             #B`   `var server = http.createServer(requestHandler); 
    #C`  `server.listen(3000);  #D`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`var http = require("http");           #A` `function requestHandler(request,
    response) {             #B` `  console.log("In comes a request to: " + request.url); 
    #B` `  response.end("Hello, world!");                         #B` `}                              
                             #B`   `var server = http.createServer(requestHandler); 
    #C`  `server.listen(3000);  #D`'
- en: '#A Require Node''s built-in HTTP module.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 引入 Node 的内置 HTTP 模块。'
- en: '#B Define a function that''ll handle incoming HTTP requests.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 定义一个处理传入 HTTP 请求的函数。'
- en: '#C Create a server that uses your function to handle requests.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 创建一个使用您的函数来处理请求的服务器。'
- en: '#D Start the server listening on port 3000.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 在端口 3000 上启动服务器监听。'
- en: This code is split up into four chunks above.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被分成四个部分。
- en: The first chunk simply requires the HTTP module and puts it into a variable
    called `http`. We saw this above with the URL module and the file system module—this
    is exactly the same.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分只是引入了 HTTP 模块并将其放入一个名为 `http` 的变量中。我们上面看到了 URL 模块和文件系统模块——这完全一样。
- en: 'Next, we define a request handler function. Nearly every bit of code in this
    book is either a request handler function or a way to call one, so listen up!
    These request handler functions take two arguments: an object that represents
    the request (often shortened to `req`) and an object that represents the response
    (often shortened to `res`). The request object has things like the URL that the
    browser requested (did they request the homepage or the about page?), or the type
    of browser visiting your page (called the user-agent), or things like that. You
    call methods on the response object and Node will package up the bytes and send
    them across the internet.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个请求处理函数。这本书中的大部分代码要么是请求处理函数，要么是调用一个函数的方式，所以请注意！这些请求处理函数接受两个参数：一个表示请求的对象（通常简称为
    `req`）和一个表示响应的对象（通常简称为 `res`）。请求对象包含诸如浏览器请求的 URL（他们请求的是主页还是关于页面？），或者访问你页面的浏览器类型（称为用户代理），或者类似的东西。你在响应对象上调用方法，Node
    将打包字节并发送它们穿过互联网。
- en: The rest of the code points Node's built-in HTTP server at the request handler
    function and starts it on port 3000.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码将 Node 的内置 HTTP 服务器指向请求处理函数，并在端口 3000 上启动。
- en: WHAT ABOUT HTTPS? Node also comes with a module called https. It's very similar
    to the http module, and creating a web server with it is almost identical. If
    you decide to swap things out later, it should take less than 2 minutes if you
    know how to do HTTPS. If you don't know much about HTTPS, don't worry about this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS 呢？Node 还附带了一个名为 https 的模块。它与 http 模块非常相似，使用它创建一个网络服务器几乎完全相同。如果你决定稍后更换，如果你知道如何做
    HTTPS，应该不到 2 分钟就能完成。如果你对 HTTPS 了解不多，不用担心这个问题。
- en: You can try saving the code above into a file called `myserver.js`. To run the
    server, type `node myserver.js` (or just `node myserver`). Now, if you visit [http://localhost:3000](http://localhost:3000) in
    your browser, you'll see something like Figure 2.3.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将上面的代码保存到一个名为 `myserver.js` 的文件中。要运行服务器，输入 `node myserver.js`（或者只是 `node
    myserver`）。现在，如果你在浏览器中访问 [http://localhost:3000](http://localhost:3000)，你将看到类似于图
    2.3 的内容。
- en: '![](../Images/02_03.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_03.png)'
- en: Figure 2.3 A simple "hello world" app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 一个简单的 "Hello World" 应用程序。
- en: 'You''ll also notice that something appears in your console every time you visit
    a page. Try visiting a few other URLs: [http://localhost:3000/](http://localhost:3000/) or [http://localhost:3000/hello/world](http://localhost:3000/hello/world) or [http://localhost:3000/what?is=anime](http://localhost:3000/what?is=anime).
    The output will change in the console, but your server won''t do anything different
    and will always just say "Hello, world!" Figure 2.4 shows what your console might
    look like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，每次你访问一个页面时，你的控制台都会出现一些内容。尝试访问几个其他的 URL：[http://localhost:3000/](http://localhost:3000/)
    或 [http://localhost:3000/hello/world](http://localhost:3000/hello/world) 或 [http://localhost:3000/what?is=anime](http://localhost:3000/what?is=anime)。控制台中的输出将会改变，但你的服务器不会做任何不同的事情，它总是会输出
    "Hello, world!" 图 2.4 展示了你的控制台可能的样子：
- en: '![](../Images/02_04.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/02_04.png)'
- en: Figure 2.4 The console from your "hello world" app might look something like
    this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 "Hello World" 应用的控制台可能看起来像这样。
- en: Notice that the request URL doesn't include "localhost:3000" anywhere. That
    might be a little unintuitive, but this is pretty helpful, as it turns out. This
    allows you to deploy your application anywhere, from your local server to your
    favorite .com address. It'll work without any changes!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到请求URL中任何地方都没有包含"localhost:3000"。这可能有点不太直观，但事实证明这非常有帮助。这允许你将你的应用程序部署在任何地方，从你的本地服务器到你最喜欢的.com地址。它将无需任何更改即可工作！
- en: 'One could imagine parsing the request URL. You could imagine doing something
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象解析请求URL。你可以想象做些类似这样的事情：
- en: Listing 2.14 Parsing the request URL with a request handler function
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 使用请求处理函数解析请求URL
- en: '`// …`   `function requestHandler(req, res) {` `  if (req.url === "/") {` `   
    res.end("Welcome to the homepage!");` `  }` `  else if (req.url === "/about")
    {` `    res.end("Welcome to the about page!");` `  }` `  else {` `    res.end("Error!
    File not found.");` `  }` `}`  `// …`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `function requestHandler(req, res) {` `  if (req.url === "/") {` `   
    res.end("欢迎来到主页！");` `  }` `  else if (req.url === "/about") {` `    res.end("欢迎来到关于页面！");`
    `  }` `  else {` `    res.end("错误！文件未找到。");` `  }` `}` `// …`'
- en: You could imagine building your entire site in this one request handler function.
    For very small sites, this might be easy, but you could imagine this function
    getting huge and unwieldy pretty quickly. You might want a framework to help you
    clean up this HTTP server…things could get messy!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象在这个请求处理函数中构建你的整个网站。对于非常小的网站，这可能很容易，但你可能会想象这个函数很快就会变得庞大且难以控制。你可能需要一个框架来帮助你清理这个HTTP服务器……事情可能会变得混乱！
- en: That's where Express will come in.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Express将发挥作用的地方。
- en: 2.5     Summary
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5     摘要
- en: 'In this chapter, we''ve learned:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了：
- en: ·  How to install Node.js
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何安装Node.js
- en: ·  How to use its module system by using `require` and `module.exports`
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何通过使用`require`和`module.exports`来使用其模块系统
- en: ·  `package.json` for describing our project's metadata with things like name,
    author, verison, and more
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用`package.json`描述我们项目的元数据，如名称、作者、版本等
- en: ·  Using npm to install packages with `npm install` (and a couple of other tricks
    like `init`)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ·  使用npm通过`npm install`安装包（以及一些其他技巧，如`init`）
- en: ·  The asynchronous, evented I/O concepts of Node—you can sort of do two things
    at once
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ·  Node的异步、事件驱动I/O概念——你可以同时做两件事
- en: ·  How to use Node's built-in HTTP module to build a simple web server
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用Node的内置HTTP模块构建一个简单的Web服务器
