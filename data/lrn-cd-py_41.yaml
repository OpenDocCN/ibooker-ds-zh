- en: 'Lesson 34\. Capstone project: card game'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第34课。综合项目：卡片游戏
- en: After reading [lesson 34](#ch34), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第34课](#ch34)之后，你将能够
- en: Use classes to build a more complex program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类构建更复杂的程序
- en: Use classes others have created to improve your program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用他人创建的类来改进你的程序
- en: Allow users to play a simple version of the card game War
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户玩战争牌局的简单版本
- en: When you make your own object types, you can organize larger programs so that
    they’re easier to write. The principles of modularity and abstraction introduced
    with functions also apply to classes. Classes are used to package a set of properties
    and behaviors common to a set of objects so that the objects can be used consistently
    in a program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建自己的对象类型时，你可以组织更大的程序，使其更容易编写。与函数一起引入的模块化和抽象原则也适用于类。类用于封装一组属性和行为，这些属性和行为对一组对象是通用的，以便对象可以在程序中一致地使用。
- en: A common first program with classes is to simulate playing some sort of game
    with the user.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的一个常见初始程序是模拟与用户玩某种游戏。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The problem
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: 'You want to simulate playing the card game War. Each round, players will take
    a card from one deck and compare the cards. The one with the higher card wins
    the round and gives their card to the other player. The winner is determined after
    numerous rounds, when the deck is empty. The winner is the person with fewer cards
    in their hand. You’ll create two types of objects: a `Player` and a `CardDeck`.
    After defining the classes, you’ll write code that simulates a game between two
    players. You’ll first ask users for their names then create two `Player` objects.
    Both players will use the same card deck. Then you’ll use methods defined in the
    `Player` and `CardDeck` classes to automatically simulate the rounds and determine
    the winner.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你想模拟玩战争牌局。每一轮，玩家将从一副牌中抽一张牌并比较牌面。牌面较高的玩家赢得该轮，并将他们的牌交给另一玩家。经过多轮比赛后，当牌堆为空时，确定赢家。赢家是手中牌较少的人。你将创建两种类型的对象：`Player`
    和 `CardDeck`。在定义了这些类之后，你将编写代码来模拟两个玩家之间的游戏。你将首先询问用户的姓名，然后创建两个 `Player` 对象。两位玩家将使用同一副牌。然后，你将使用
    `Player` 和 `CardDeck` 类中定义的方法来自动模拟轮次并确定赢家。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 34.1\. Using classes that already exist
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.1. 使用现有的类
- en: Objects built into the Python language are always there for you to use in your
    programs; these are objects such as `int`, `float`, `list`, and `dict`. But many
    other classes have already been written by other programmers and can be used to
    enhance the functionality of your program. Instead of typing their class definition
    in your code file, you can use an `import` statement to bring in the definition
    of another class into your file. This way, you can create objects of that type
    and use that class’s methods in your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预先构建到 Python 语言中的对象始终可供你在程序中使用；这些对象如 `int`、`float`、`list` 和 `dict`。但许多其他类已经被其他程序员编写，并且可以用来增强你程序的功能。你不需要在代码文件中键入它们的类定义，而是可以使用一个
    `import` 语句将另一个类的定义引入到你的文件中。这样，你可以创建该类型的对象，并在你的代码中使用该类的功能。
- en: 'A useful class you’ll want to use in your card game is the `random` class.
    You can bring in the random class definitions with this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你在卡片游戏中想要使用的一个有用的类是 `random` 类。你可以使用以下方式引入随机类定义：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you can create an object that can perform operations with random numbers.
    You use dot notation on the class name, as mentioned in [lesson 31](kindle_split_047.html#ch31),
    and call the method you want to use along with any parameters it expects. For
    example,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建一个可以执行随机数操作的对象。你可以在类名上使用点符号，如[第31课](kindle_split_047.html#ch31)中提到的，并调用你想要使用的方法以及它期望的任何参数。例如，
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This gives you a random number between 0 (including) and 1 (not including)
    and binds it to the variable `r`. Here’s another example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这会给你一个介于 0（包括）和 1（不包括）之间的随机数，并将其绑定到变量 `r`。这里还有一个例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This line gives you a random integer between `a` and `b` (including) and binds
    it to the variable `r`. Now consider this line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会给你一个介于 `a` 和 `b`（包括）之间的随机整数，并将其绑定到变量 `r`。现在考虑这一行：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It gives you a random element from a list `L` and binds it to the variable `r`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它会从列表 `L` 中随机选择一个元素并将其绑定到变量 `r`。
- en: 34.2\. Detailing the game rules
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.2. 详细说明游戏规则
- en: 'The first step before beginning to code is to understand how you want your
    program to run, and what the specific game rules are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前的第一步是理解你希望程序如何运行，以及具体的游戏规则是什么：
- en: For simplicity, assume a deck contains four suits, each with cards 2 to 9\.
    When denoting a card, use `"2H"` for the 2 of hearts, `"4D"` for the 4 of diamonds,
    `"7S"` for the 7 of spades, `"9C"` for the 9 of clubs, and so on.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简化，假设一副牌包含四种花色，每种花色都有2到9的牌。在表示牌时，使用 `"2H"` 表示红心2，`"4D"` 表示方片4，`"7S"` 表示黑桃7，`"9C"`
    表示梅花9，依此类推。
- en: A player has a name (string) and a hand of cards (list).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家有一个名字（字符串）和一副牌（列表）。
- en: When the game begins, ask two players for their names and set them.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时，询问两名玩家的名字并将它们设置好。
- en: Each round, add one card to each player’s hand.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每轮游戏，向每位玩家的手中各添加一张牌。
- en: 'Compare the cards just added to each player: first by the number, and then,
    if equal, by Spades > Hearts > Diamonds > Clubs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较刚刚添加到每位玩家手中的牌：首先按数字比较，如果相同，则按黑桃 > 红心 > 方片 > 梅花排序。
- en: The person with the larger card removes the card from their hand, and the person
    with the smaller card takes the card and adds it to their hand.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有较大牌的玩家从手中移除该牌，持有较小牌的玩家拿走该牌并将其添加到自己的手中。
- en: When the deck is empty, compare the number of cards the players have; the person
    with fewer cards wins.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当牌堆为空时，比较玩家手中的牌数；牌数较少的玩家获胜。
- en: 'You’ll define two classes: one for a `Player` and one for a `CardDeck`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您将定义两个类：一个用于 `Player`，另一个用于 `CardDeck`。
- en: 34.3\. Defining the Player class
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.3. 定义 `Player` 类
- en: A player is defined by a name and a hand. The name is a string, and the hand
    is a list of strings, representing the cards. When you create a `Player` object,
    you give them a name as an argument and assume that they have no cards in their
    hand.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家由名字和手牌定义。名字是一个字符串，手牌是一个字符串列表，代表牌。创建 `Player` 对象时，您需要提供一个名字作为参数，并假设他们手中没有牌。
- en: The first step is to define the `__init__` method to tell Python how to initialize
    a `Player` object. Knowing that you have two data attributes for a `Player` object,
    you can also write a method to return the name of the `Player`. This is shown
    in the following listing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义 `__init__` 方法，告诉Python如何初始化一个 `Player` 对象。知道您有一个 `Player` 对象的两个数据属性，您还可以编写一个方法来返回
    `Player` 的名字。这在上面的列表中显示。
- en: Listing 34.1\. Definition for the `Player` class
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表34.1. `Player` 类的定义
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Sets a hand to be an empty list**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将手设为一个空列表**'
- en: '***2* Sets the name to the string passed in when creating a Player object**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 在创建 `Player` 对象时将传入的字符串设置为名字**'
- en: '***3* A method to return the player’s name**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 一个返回玩家名字的方法**'
- en: Now, according to the game rules, a player can also add a card to their hand
    and remove a card from their hand. Notice that you check to make sure that the
    card added is a valid card by making sure its value is not `None`. To check the
    number of cards in players’ hands and determine a winner, you can also add a method
    that tells you the number of cards in a hand. The following listing shows these
    three methods.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据游戏规则，玩家还可以向手中添加一张牌并从手中移除一张牌。请注意，您需要检查添加的牌是否有效，确保其值不是 `None`。为了检查玩家手中的牌数并确定获胜者，您还可以添加一个方法来告诉您手中的牌数。以下列表显示了这三个方法。
- en: Listing 34.2\. Definition for the `Player` class
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表34.2. `Player` 类的定义
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Adding a card to the hand adds it to the list, and adds only a card with
    a valid number and suit.**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 向手中添加一张牌将其添加到列表中，并且只添加具有有效数字和花色的牌。**'
- en: '***2* Removing a card from the hand finds the card and removes it from the
    list.**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 从手中移除一张牌找到该牌并将其从列表中移除。**'
- en: '***3* The size of the hand returns the number of elements in the list.**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 手的大小返回列表中的元素数量。**'
- en: 34.4\. Defining the CardDeck class
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.4. 定义 `CardDeck` 类
- en: 'A `CardDeck` class will represent a deck of cards. The deck has 32 cards, with
    the numbers 2 to 9 for each of the four deck types: spades, hearts, diamonds,
    and clubs. The following listing shows how to initialize the object type. There’ll
    be only one data attribute, a list of all possible cards in the deck. Each card
    is denoted by a string; for example, of the form `"3H"` for the 3 of hearts.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardDeck` 类将代表一副牌。牌堆有32张牌，每种花色（黑桃、红心、方片、梅花）都有2到9的牌。以下列表显示了如何初始化对象类型。将只有一个数据属性，即牌堆中所有可能牌的列表。每张牌都用一个字符串表示；例如，红心3的形式为
    `"3H"`。'
- en: Listing 34.3\. Initialization for the `CardDeck` class
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表34.3. `CardDeck` 类的初始化
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Makes a string of all possible cards in the deck**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 创建一副牌中所有可能牌的字符串**'
- en: '***2* Splits the long string on the comma and adds all cards (strings) to a
    list for the deck**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 在逗号处分割长字符串，并将所有牌（字符串）添加到牌堆列表中。**'
- en: After you decide that you’ll represent a card deck with a list containing all
    cards in the deck, you can start to implement the methods for this class. This
    class will use the `random` class to pick a random card that a player will use.
    One method will return a random card from the deck; another method will compare
    two cards and tell you which one is higher.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你决定使用包含牌组中所有卡片的列表来表示牌组之后，你可以开始实现这个类的相关方法。这个类将使用 `random` 类来随机选择玩家将使用的卡片。一个方法将返回牌组中的一张随机卡片；另一个方法将比较两张卡片并告诉你哪一张更高。
- en: Listing 34.4\. Methods in the `CardDeck` class
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 34.4\. `CardDeck` 类中的方法
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* If there are no more cards in the deck, return None.**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果牌组中没有更多卡片，则返回 None。**'
- en: '***2* Picks a random card from the deck list**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从牌组列表中随机选择一张卡片**'
- en: '***3* Removes the card from the deck list**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从牌组列表中移除卡片**'
- en: '***4* Returns the value of the card (string)**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回卡片的值（字符串）**'
- en: '***5* Checks the card number value, returns the first card if it’s higher**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查卡片号码值，如果更高则返回第一张卡片**'
- en: '***6* Checks the card number value, returns the second card if it’s higher**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 检查卡片号码值，如果更高则返回第二张卡片**'
- en: '***7* When the card number value is equal, use the suit.**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 当卡片号码值相等时，使用花色。**'
- en: 34.5\. Simulate the card game
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.5\. 模拟牌局
- en: After you define object types to help you simulate a card game, you can write
    code that uses these types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你定义了帮助你模拟牌局的对象类型之后，你可以编写使用这些类型的代码。
- en: 34.5.1\. Setting up the objects
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 34.5.1\. 设置对象
- en: The first step is to set up the game by creating two `Player` objects and one
    `CardDeck` object. You ask for the names of two players, create a new `Player`
    object for each, and call the method to set the name. This is shown in the following
    listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置游戏，创建两个 `Player` 对象和一个 `CardDeck` 对象。你要求输入两位玩家的名字，为每位玩家创建一个新的 `Player`
    对象，并调用设置名字的方法。这将在下面的列表中展示。
- en: Listing 34.5\. Initializing game variables and objects
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 34.5\. 初始化游戏变量和对象
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Gets user input of the player 1 name**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取玩家 1 的用户输入名字**'
- en: '***2* Makes a new Player object**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个新的 `Player` 对象**'
- en: '***3* Makes a new CardDeck object**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个新的 `CardDeck` 对象**'
- en: After initializing the object you’ll use in the game, you can now simulate the
    game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化你将在游戏中使用的对象之后，你现在可以模拟游戏了。
- en: 34.5.2\. Simulating rounds in the game
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 34.5.2\. 模拟游戏中的回合
- en: A game consists of many rounds and continues until the deck is empty. It’s possible
    to calculate the number of rounds players will play; if each player takes a card
    every round and there are 32 cards in the deck, there’ll be 16 rounds. You could
    use a `for` loop to count the rounds, but a `while` loop is also an acceptable
    way of implementing the rounds.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一局游戏由许多回合组成，并持续到牌组为空。可以计算出玩家将玩多少轮；如果每位玩家在每一轮都抽一张牌，而牌组中有 32 张牌，那么将有 16 轮。你可以使用
    `for` 循环来计数回合，但 `while` 循环也是实现回合的可接受方式。
- en: In each round, each player gets a card, so call the `get_card` method on the
    deck twice, once for each player. Each player object then calls `add_card_to_hand`,
    which adds the random card returned from the deck to their own hand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一轮中，每位玩家都会得到一张牌，所以对牌组调用 `get_card` 方法两次，一次为每位玩家。然后，每个玩家对象调用 `add_card_to_hand`，将牌组返回的随机卡片添加到他们的手中。
- en: 'Then, both players will have at least a card, and there are two cases to consider:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，两位玩家至少都有一张牌，需要考虑两种情况：
- en: The game is over because the deck is empty.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束，因为牌组已空。
- en: The deck still contains cards, and players must compare and decide who gives
    the other a card.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 牌组中仍然有卡片，玩家必须比较并决定谁给对方一张牌。
- en: When the game is over, you check the sizes of the hands by calling `hand_size`
    on each player object. The player with the larger hand loses, and you exit from
    the loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏结束时，你通过在每个玩家对象上调用 `hand_size` 来检查手牌的大小。手牌更大的玩家输，然后你退出循环。
- en: If the game isn’t over, you need to decide which player has the higher card
    by calling the `compare_cards` method on the deck with the two players’ cards.
    The returned value is the higher card, and if the number values are equal, the
    suit decides which card weighs more. If the higher card is the same as `player1`’s
    card, `player1` needs to give the card to `player2`. In code, this translates
    to `player1` calling `remove_card_from_hand` and `player2` calling `add_card_to_hand`.
    A similar situation happens when the larger card is the same as `player2`’s card.
    See the following listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '如果游戏还没有结束，你需要通过在包含两名玩家牌的牌组上调用 `compare_cards` 方法来决定哪位玩家拥有较大的牌。返回值是较大的牌，如果数值相等，花色将决定哪张牌更重。如果较大的牌与
    `player1` 的牌相同，`player1` 需要将牌给 `player2`。在代码中，这对应于 `player1` 调用 `remove_card_from_hand`
    和 `player2` 调用 `add_card_to_hand`。当较大的牌与 `player2` 的牌相同时，也会发生类似的情况。请参阅以下列表。 '
- en: Listing 34.6\. Loop to simulate rounds in the game
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 34.6\. 模拟游戏回合的循环
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Game over because at least one player has no more cards**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 游戏结束，因为至少有一名玩家没有更多的牌**'
- en: '***2* Checks the sizes of the hands, and player2 wins because they have fewer
    cards**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查手牌的大小，player2 胜出，因为他们手中的牌更少**'
- en: '***3* Checks the sizes of the hands, and player1 wins because they have fewer
    cards**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查手牌的大小，player1 胜出，因为他们手中的牌更少**'
- en: '***4* Players have the same number of cards, so a tie**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 玩家拥有相同数量的牌，因此是平局**'
- en: '***5* The break exits the while loop when one player wins or there’s a tie.**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当一名玩家获胜或出现平局时，break 语句会退出 while 循环。**'
- en: '***6* Game can continue because there are still cards to compare between hands**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 游戏可以继续，因为手中仍有牌需要比较**'
- en: '***7* Compares cards between players, and the returned card is the higher card**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 比较玩家之间的牌，返回的是较大的牌**'
- en: '***8* Higher card belongs to player1, so add player1’s card to player2’s hand**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 较大的牌属于 player1，因此将 player1 的牌添加到 player2 的手中**'
- en: '***9* Higher card belongs to player1, so remove player1’s card from their hand.**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 较大的牌属于 player1，因此从 player1 的手中移除其牌。**'
- en: 34.6\. Modularity and abstraction with classes
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 34.6\. 使用类实现模块化和抽象
- en: Implementing this game is a large undertaking. Without breaking the problem
    into smaller subtasks, coding the game would quickly become messy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个游戏是一项庞大的任务。如果不将问题分解成更小的子任务，编写游戏代码会很快变得杂乱无章。
- en: Using objects and object-oriented programming, you’ve also managed to modularize
    your program even further. You separated your code into different objects and
    gave each object a set of data attributes and a set of methods.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象和面向对象编程，你还成功地进一步模块化了你的程序。你将代码分离成不同的对象，并为每个对象提供一组数据属性和一组方法。
- en: 'Using object-oriented programming also allowed you to separate two main ideas:
    creating classes that organize your code, and using the classes to implement code
    that plays the game. While simulating the gameplay, you were able to use the objects
    of the same type consistently, leading to neat and easy-to-read code. This abstracted
    the details of how the object types and their methods were implemented, and you
    were able to use the docstrings of methods to decide which methods were appropriate
    during the simulation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象编程还允许你分离两个主要思想：创建组织代码的类，以及使用这些类来实现玩游戏的代码。在模拟游戏玩法时，你能够一致地使用相同类型的对象，从而产生整洁且易于阅读的代码。这抽象了对象类型及其方法实现的具体细节，并且你能够使用方法的文档字符串来决定在模拟过程中哪些方法是合适的。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, my objective was to teach you how to write a larger program
    that uses classes others have created to improve your program, and how to create
    your own classes and use them to play a game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你如何编写一个更大的程序，该程序使用其他人创建的类来改进你的程序，以及如何创建自己的类并使用它们来玩游戏。
- en: The code for the class definitions needs to be written only once. It dictates
    the overall properties of your objects and operations you can do with these objects.
    This code doesn’t manipulate any specific objects. The code for the gameplay itself
    (the code not including the class definitions) is straightforward, because you’re
    creating objects and calling methods on the appropriate objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的代码只需要编写一次。它决定了你的对象的整体属性以及你可以对这些对象执行的操作。此代码不操作任何特定的对象。游戏玩法本身的代码（不包括类定义的代码）很简单，因为你正在创建对象并在适当的对象上调用方法。
- en: This structure separates code that tells others what an object is and what it
    can do, from code that uses these objects to achieve various tasks. In this way,
    you’re hiding some of the unnecessary coding details that you don’t need to know
    in order to implement the gameplay.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构将描述一个对象是什么以及它能做什么的代码与使用这些对象来完成各种任务的代码分开。这样，你就可以隐藏一些不必要的编码细节，这些细节对于实现游戏玩法并不需要知道。
