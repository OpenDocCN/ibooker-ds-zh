- en: '4 Jump the Five: Working with dictionaries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 跳过五：与字典一起工作
- en: “When I get up, nothing gets me down.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “当我起床时，没有什么能让我沮丧。”
- en: --D. L. Roth
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: --D. L. Roth
- en: '| In an episode of the television show *The Wire*, drug dealers assume the
    police are intercepting their text messages. Whenever a phone number needs to
    be texted in the course of a criminal conspiracy, the dealers will obfuscate the
    number. They use an algorithm we’ll call “Jump the Five” because each number is
    changed to its mate on the opposite of a US telephone pad if you jump over the
    5\. In this exercise, we’ll discuss how to encrypt messages using this algorithm,
    and then we’ll see how to use it to decrypt the encrypted messages, you feel me?
    | ![](../Images/4-unnumb-1.png)  |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 在电视剧《火线》的一集中，毒品贩子认为警察正在拦截他们的短信。在犯罪阴谋过程中需要发送电话号码时，贩子会混淆这个号码。他们使用一个我们称之为“跳过五”的算法，因为如果你跳过5，每个数字都会变成美国电话键盘另一侧的配对数字。在这个练习中，我们将讨论如何使用这个算法加密消息，然后我们将看到如何使用它来解密加密的消息，你明白吗？|
    ![图片](../Images/4-unnumb-1.png)  |'
- en: If we start with the 1 button and jump across the 5, we get to 9\. The 6 jumps
    the 5 to become 4, and so forth. The numbers 5 and 0 will swap with each other.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从1按钮开始跳过5，我们就会到达9。6跳过5变成4，以此类推。数字5和0会相互交换。
- en: 'In this exercise, we’re going to write a Python program called jump.py that
    will take in some text as a positional argument. Each number in the text will
    be encoded using this algorithm. All non-number text will pass through unchanged.
    Here are a couple of examples:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个名为 jump.py 的 Python 程序，它将接受一些文本作为位置参数。文本中的每个数字都将使用此算法进行编码。所有非数字文本将保持不变。这里有一些例子：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will need some way to inspect each character in the input text to identify
    the numbers--you will learn how to use a `for` loop for this. Then you’ll see
    how a `for` loop can be rewritten as a “list comprehension.” You’ll need some
    way to associate a number like 1 with the number 9, and so on for all the numbers--you’ll
    learn about a data structure in Python called a *dictionary* that will allow you
    to do exactly that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要某种方式来检查输入文本中的每个字符以识别数字--你将学习如何使用 `for` 循环来做这件事。然后你将看到如何将 `for` 循环重写为“列表推导式”。你需要某种方式将像1这样的数字与9这样的数字关联起来，等等--你将学习到Python中称为“字典”的数据结构，它将允许你做到这一点。
- en: In this chapter, you will learn to
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到
- en: Create a dictionary
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典
- en: Use a `for` loop and a list comprehension to process text, character by character
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `for` 循环和列表推导式处理文本，逐字符处理
- en: Check if items exist in a dictionary
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查字典中是否存在项
- en: Retrieve values from a dictionary
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典中检索值
- en: Print a new string with the numbers substituted with their encoded values
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个新的字符串，用编码后的值替换数字
- en: Before we start writing, you need to learn about Python’s dictionaries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，你需要了解Python的字典。
- en: 4.1 Dictionaries
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 字典
- en: '| A Python dictionary allows us to relate some *thing* (a “key”) to some other
    *thing* (a “value”). An actual dictionary does this. If we look up a word like
    “quirky” in a dictionary ([www.merriam-webster.com/dictionary/ quirky](http://www.merriam-webster.com/dictionary/quirky)),
    we can find a definition, as in figure 4.1\. We can think of the word itself as
    the “key” and the definition as the “value.” | ![](../Images/4-unnumb-2.png)  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Python 字典允许我们将一些“东西”（一个“键”）与另一些“东西”（一个“值”）相关联。实际的字典就是这样做的。如果我们查找像“quirky”这样的词在字典中（[www.merriam-webster.com/dictionary/
    quirky](http://www.merriam-webster.com/dictionary/quirky)），我们可以找到一个定义，如图4.1所示。我们可以将这个词本身视为“键”，将定义视为“值”。|
    ![图片](../Images/4-unnumb-2.png)  |'
- en: '![](../Images/4-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-1.png)'
- en: Figure 4.1 You can find the definition of a word by looking it up in a dictionary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 你可以通过在字典中查找来找到单词的定义。
- en: Dictionaries actually provide quite a bit more information about words, such
    as pronunciation, part of speech, derived words, history, synonyms, alternate
    spellings, etymology, first known use, and so on. (I really love dictionaries.)
    Each of those attributes has a value, so we could also think of the dictionary
    entry for a word as itself being another “dictionary” (see figure 4.2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 字典实际上提供了关于单词的很多信息，例如发音、词性、派生词、历史、同义词、变体拼写、词源、首次使用等。（我真的喜欢字典。）每个属性都有一个值，因此我们也可以将单词的字典条目视为另一个“字典”（见图4.2）。
- en: '![](../Images/4-2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-2.png)'
- en: Figure 4.2 The entry for “quirky” can contain much more than a single definition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 “quirky”的条目可以包含比单个定义更多的内容。
- en: Let’s see how we can use Python’s dictionaries to go beyond word definitions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Python的字典来超越单词定义。
- en: 4.1.1 Creating a dictionary
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 创建字典
- en: '| In the film *Monty Python and the Holy Grail*, King Arthur and his knights
    must cross The Bridge of Death. Anyone who wishes to cross must correctly answer
    three questions from the Keeper. Those who fail are cast into the Gorge of Eternal
    Peril. | ![](../Images/4-unnumb-3.png) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 在电影《蒙提·派森与圣杯》中，亚瑟王和他的骑士们必须穿越死亡之桥。任何想要过桥的人都必须正确回答守护者的三个问题。那些失败的人将被投入永恒的深渊。
    | ![](../Images/4-unnumb-3.png) |'
- en: Let us ride to CAMELOT.... No, sorry, let us create and use a dictionary to
    keep track of the questions and answers as key/value pairs. Once again, I want
    you to fire up your `python3` or IPython REPL or Jupyter Notebook and type these
    out for yourself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们骑马前往卡美洛……不，抱歉，让我们创建并使用一个字典来跟踪问题和答案作为键/值对。再次提醒，我希望你打开你的`python3`或IPython交互式解释器或Jupyter笔记本，并亲自输入以下内容。
- en: Lancelot goes first. We can use the `dict()` function to create an empty dictionary
    for his answers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 兰斯洛特先开始。我们可以使用`dict()`函数为他创建一个空的答案字典。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or we can use empty curly brackets (both methods are equivalent):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用空的花括号（两种方法等效）：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| The Keeper’s first question is, “What is your name?” Lancelot answers, “My
    name is Sir Lancelot of Camelot.” We can add the key “name” to the `answers` dictionary
    by using square brackets (`[]`--not curlies!) and the literal string `''name''`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '| 守护者的第一个问题是，“你叫什么名字？”兰斯洛特回答，“我叫卡美洛的兰斯洛特爵士。”我们可以通过使用方括号（`[]`--不是花括号！）和字面字符串`''name''`来将键“name”添加到`answers`字典中：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| ![](../Images/4-unnumb-4.png) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/4-unnumb-4.png) |'
- en: '![](../Images/4-3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-3.png)'
- en: Figure 4.3 A dictionary is printed inside curly braces. The keys are separated
    from the values by a colon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 字典被打印在花括号内。键与值之间用冒号分隔。
- en: 'If you type `answers` and press Enter in the REPL, Python will show you a structure
    in curlies (see figure 4.3) to indicate that this is a `dict`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入`answers`并在交互式解释器中按Enter键，Python将显示一个花括号结构（见图4.3），以指示这是一个`dict`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can verify this with the `type()` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`type()`函数来验证这一点：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next the Keeper asks, “What is your quest?” to which Lancelot answers “To seek
    the Holy Grail.” Let’s add “quest” to `answers`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，守护者问道，“你的任务是做什么？”兰斯洛特回答，“寻找圣杯。”让我们将“quest”添加到`answers`中：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| There’s no return value to let us know something happened, so type `answers`
    to inspect the variable again to ensure the new key/value was added:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| 没有返回值来告诉我们发生了什么，所以再次输入`answers`来检查变量，以确保新键/值已添加：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally the Keeper asks, “What is your favorite color?” and Lancelot answers,
    “Blue.” | ![](../Images/4-unnumb-5.png) |
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，守护者问道，“你最喜欢的颜色是什么？”兰斯洛特回答，“蓝色。” | ![](../Images/4-unnumb-5.png) |
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note I’m using “favorite_color” (with an underscore) as the key, but I could
    use “favorite color” (with a space) or “FavoriteColor” or “Favorite color,” but
    each one of those would be a separate and distinct string, or key. I prefer to
    use the PEP 8 naming conventions for dictionary keys and variable and functions
    names. PEP 8, the “Style Guide for Python Code” ([www.python.org/ dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)),
    suggests using lowercase names with words separated by underscores.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我使用的是“favorite_color”（带下划线）作为键，但我可以使用“favorite color”（带空格）或“FavoriteColor”或“Favorite
    color，”但每个都会是一个单独且不同的字符串，或键。我更喜欢使用PEP 8命名约定来为字典键、变量和函数命名。PEP 8，即“Python代码风格指南”（[www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/))，建议使用小写名称，单词之间用下划线分隔。
- en: 'If you knew all the answers beforehand, you could create `answers` using the
    `dict()` function with the following syntax, where you do *not* have to quote
    the keys, and the keys are separated from the values with equal signs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道所有答案，你可以使用`dict()`函数并按照以下语法创建`answers`，其中你不需要引用键，键与值之间用等号分隔：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or you could use the following syntax using curlies `{}`, where the keys must
    be quoted and they are followed by a colon (`:`):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用以下语法，使用花括号`{}`，其中键必须引用，并且它们后面跟着一个冒号（`:`）：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It might be helpful to think of the `answers` dictionary as a box holding key/value
    pairs that describe Lancelot’s answers (see figure 4.4), just the way the “quirky”
    dictionary holds all the information about that word.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将`answers`字典想象成一个盒子，里面装着键/值对，描述了兰斯洛特的答案（见图4.4），就像“古怪”字典一样，它包含了关于那个单词的所有信息。
- en: '![](../Images/4-4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-4.png)'
- en: Figure 4.4 Just like the “quirky” dictionary entry, a Python dictionary can
    contain many key/value pairs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 就像“古怪”的字典条目一样，Python字典可以包含许多键/值对。
- en: 4.1.2 Accessing dictionary values
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 访问字典值
- en: 'To retrieve the values, you use the key name inside square brackets (`[]`).
    For instance, you can get the `name` like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索值，您使用方括号内的键名。例如，您可以这样获取`name`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| Let’s request his “age”:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '| 让我们请求他的“年龄”：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, you will cause an exception if you ask for a dictionary key
    that doesn’t exist! | ![](../Images/4-unnumb-6.png) |
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您请求一个不存在的字典键，将会引发一个异常！| ![图片](../Images/4-unnumb-6.png) |
- en: 'Just as with strings and lists, you can use `x` `in` `y` to first see if a
    key exists in the `dict`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串和列表一样，您可以使用`x in y`来首先检查键是否存在于`dict`中：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| ![](../Images/4-unnumb-7.png) | The `dict.get()` method is a *safe* way to
    ask for a value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '| ![图片](../Images/4-unnumb-7.png) | `dict.get()`方法是一种*安全*的方式来请求一个值：'
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the requested key does not exist in the `dict`, it will return the special
    value `None`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求的键不在`dict`中时，它将返回特殊值`None`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'That doesn’t print anything because the REPL won’t print a `None`, but we can
    check the `type()`. Note that the type of `None` is the `NoneType`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会打印任何内容，因为REPL不会打印`None`，但我们可以检查`type()`。注意，`None`的类型是`NoneType`：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| There is an optional second argument you can pass to `dict.get()`, which
    is the value to return *if the key does not exist*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '| 您可以向`dict.get()`传递一个可选的第二个参数，该参数是如果键不存在时返回的值：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s going to be important for the solution because we will only need to represent
    the characters 0-9\. | ![](../Images/4-unnumb-8.png) |
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于解决方案来说很重要，因为我们只需要表示0-9这些字符。| ![图片](../Images/4-unnumb-8.png) |
- en: 4.1.3 Other dictionary methods
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 其他字典方法
- en: 'If you want to know how “big” a dictionary is, the `len()` (length) function
    on a `dict` will tell you how many key/value pairs are present:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道字典“有多大”，`dict`上的`len()`（长度）函数会告诉您有多少键/值对：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `dict.keys()` method will give you just the keys:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict.keys()`方法将只给出键：'
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And `dict.values()` will give you just the values:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 而`dict.values()`将只给出值：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Often we want both together, so you might see code like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经常我们希望两者都有，所以您可能会看到这样的代码：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An easier way to write this would be to use the `dict.items()` method, which
    will return the contents of the dictionary as a new `list` containing each key/value
    pair:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单的方法是使用`dict.items()`方法，它将返回一个包含每个键/值对的新`list`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding `for` loop could also be written using the `dict.items()` method:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`for`循环也可以使用`dict.items()`方法来编写：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① Unpack each key/value pair into the variables key and value (see figure 4.5).
    Note that you don’t have to call them key and value. You could use k and v or
    question and answer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将每个键/值对解包到变量key和value中（见图4.5）。注意，您不必称它们为key和value。您可以使用k和v或问题与答案。
- en: ② Print the key in a left-justified field 15 characters wide. The value is printed
    normally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在15个字符宽的左对齐字段中打印键。值按正常方式打印。
- en: '![](../Images/4-5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-5.png)'
- en: Figure 4.5 We can unpack the key/value pairs returned by `dict.items()` into
    variables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 我们可以将`dict.items()`返回的键/值对解包到变量中。
- en: In the REPL you can execute `help(dict)` to see all the methods available to
    you, like `dict.pop()`, which removes a key/value, or `dict.update()`, which merges
    one dictionary with another.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中，您可以执行`help(dict)`来查看所有可用的方法，如`dict.pop()`，它删除一个键/值，或`dict.update()`，它将一个字典与另一个合并。
- en: Tip Each key in the `dict` is unique.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：`dict`中的每个键都是唯一的。
- en: That means if you set a value for a given key twice,
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果您为给定的键设置两次值，
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'you will not have two entries but one entry with the *second* value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不会有两个条目，而是一个带有*第二个*值的条目：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keys don’t have to be strings--you can also use numbers like the `int` and `float`
    types. Whatever value you use must be immutable. For instance, lists could not
    be used because they are mutable, as you saw in the previous chapter. You’ll learn
    which types are immutable as we go further.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 键不必是字符串--您也可以使用像`int`和`float`这样的数字类型。您使用的任何值都必须是不可变的。例如，列表不能使用，因为它们是可变的，就像您在上一章中看到的。随着我们进一步学习，您将了解哪些类型是不可变的。
- en: 4.2 Writing jump.py
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 编写jump.py
- en: Now let’s get started with writing our program. You’ll need to create a program
    called jump.py in the 04_jump_the_five directory so you can use the test.py that
    is there. Figure 4.6 shows a diagram of the inputs and outputs. Note that your
    program will only affect the numbers in the text. Anything that is *not* a number
    will remain unchanged.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写我们的程序。你需要在04_jump_the_five目录下创建一个名为jump.py的程序，这样你就可以使用那里的test.py了。图4.6显示了输入和输出的示意图。请注意，你的程序只会影响文本中的数字。任何不是数字的内容都将保持不变。
- en: '![](../Images/4-6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![4-6](../Images/4-6.png)'
- en: Figure 4.6 A string diagram for the jump.py program. Any number in the input
    text will be changed to a corresponding number in the output text.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 jump.py程序的字符串图。输入文本中的任何数字都将更改为输出文本中的相应数字。
- en: 'When your program is run with no arguments, `-h`, or `--help`, it should print
    a usage message:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序没有参数、`-h`或`--help`时，它应该打印一个使用消息：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we will be processing *text* representations of the “numbers,” so
    the string `'1'` will be converted to the string `'9'`. We won’t be changing the
    actual integer value `1` to the integer value `9`. Keep that in mind as you figure
    out a way to represent the substitutions in table 4.1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将处理“数字”的文本表示，所以字符串`'1'`将被转换为字符串`'9'`。我们不会将实际的整数值`1`更改为整数值`9`。在确定如何在表4.1中表示替换时，请记住这一点。
- en: Table 4.1 The encoding table for the numeric characters in the text
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 文本中数字字符的编码表
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| ![](../Images/4-table.png) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| ![4-table](../Images/4-table.png) |'
- en: How would you represent this using a `dict`? Try creating a `dict` called `jumper`
    in the REPL with the preceding key/value pairs, and then see if the following
    `assert` statements will execute with exceptions. Remember that `assert` will
    return nothing if the statement is `True`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何使用`dict`来表示这个？尝试在REPL中创建一个名为`jumper`的`dict`，包含前面的键/值对，然后看看以下`assert`语句是否会抛出异常。记住，如果语句为`True`，`assert`将返回无内容。
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, you will need a way to visit each character. I suggest you use a `for`
    loop, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一种方法来遍历每个字符。我建议你使用一个`for`循环，如下所示：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rather than printing the `char`, print the value of `char` in the `jumper` table,
    or print the `char` itself. Look at the `dict.get()` method! Also, if you read
    `help(print)`, you’ll see there is an `end` option to replace the newline that
    gets stuck onto the end with something else.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是打印`char`，打印`jumper`表中`char`的值，或者打印`char`本身。查看`dict.get()`方法！另外，如果你阅读了`help(print)`，你会看到有一个`end`选项可以替换粘附在末尾的换行符。
- en: 'Here are some other hints:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他的提示：
- en: The numbers can occur anywhere in the text, so I recommend you process the input
    character by character with a `for` loop.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字可以出现在文本的任何位置，所以我建议你使用`for`循环逐个字符处理输入。
- en: Given any one character, how can you look it up in your table?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定任意一个字符，你如何在你的表中查找它？
- en: If the character is in your table, how can you get the value (the translation)?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符在你的表中，你如何获取其值（即翻译）？
- en: How can you `print()` the translation or the value without printing a newline?
    Look at `help(print)` in the REPL to read about the options for `print()`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不打印换行的情况下`print()`翻译或值？查看REPL中的`help(print)`来了解`print()`的选项。
- en: If you read `help(str)` on Python’s `str` class, you’ll see that there is a
    `str.replace()` method. Could you use that?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你阅读了Python的`str`类的`help(str)`，你会看到有一个`str.replace()`方法。你能使用它吗？
- en: Now spend the time to write the program on your own before you look at the solutions.
    Use the tests to guide you.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看解决方案之前，先花时间自己编写程序。使用测试来指导你。
- en: 4.3 Solution
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 解决方案
- en: Here is one solution that satisfies the tests. I will show some variations after
    we discuss this first version.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个满足测试的解决方案。在讨论这个第一个版本之后，我会展示一些变体。
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Define the get_args() function first, so it’s easy to find when I read the
    program.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ① 首先定义get_args()函数，这样我在阅读程序时容易找到。
- en: ② Define one positional argument called “text.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义一个名为“text”的位置参数。
- en: ③ Define a main() function where the program starts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义一个名为main()的主函数，程序从这里开始。
- en: ④ Get the command-line arguments from get_args ().
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 从get_args()获取命令行参数。
- en: ⑤ Create a dictionary for the lookup table.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建一个查找表字典。
- en: ⑥ Process each character in the input text.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 处理输入文本中的每个字符。
- en: ⑦ Print either the value of the character from the “jumper” table or the character
    itself. Change the “end” value to print() so as to avoid adding a newline.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 打印“jumper”表中的字符值或字符本身。将“end”值更改为print()以避免添加换行符。
- en: ⑧ Print a newline after I am done processing the characters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 在处理完字符后打印一个换行符。
- en: ⑨ Call the main() function if the program is in the “main” namespace.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 如果程序在“main”命名空间中，则调用`main()`函数。
- en: 4.4 Discussion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 讨论
- en: Let’s break this program down into the big ideas, like how we define the parameters,
    define and use a dictionary, process the input text, and print the output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个程序分解成大的概念，比如我们如何定义参数，定义和使用字典，处理输入文本，以及打印输出。
- en: 4.4.1 Defining the parameters
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 定义参数
- en: 'As usual, the `get_args()` function is defined first. The program needs to
    define one positional argument. Since I’m expecting some “text,” I call the argument
    `''text''` and then assign that to a variable called `text`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，首先定义`get_args()`函数。程序需要定义一个位置参数。由于我期望一些“文本”，我将参数命名为`'text'`，然后将其分配给一个名为`text`的变量：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While that seems rather obvious, I think it’s very important to name things
    for *what they are*. That is, please don’t leave the name of the argument as `'positional'`--that
    does not describe what it *is*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来相当明显，但我认为给事物命名以反映其本质非常重要。也就是说，请不要将参数的名称保留为`'positional'`--这并不能描述它*是什么*。
- en: It may seem like overkill to use `argparse` for such a simple program, but it
    handles the validation of the correct *number* and *type* of the arguments as
    well as generating help documentation, so it’s well worth the effort.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`argparse`处理这样一个简单的程序可能看起来有些过度，但它处理了正确*数量*和*类型*的参数验证以及生成帮助文档，所以这是值得努力的。
- en: 4.4.2 Using a dict for encoding
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 使用字典进行编码
- en: 'I suggested you could represent the substitution table as a `dict`, where each
    number `key` has its substitute as the `value` in the `dict`. For instance, I
    know that if I jump from 1 over the 5, I should land on 9:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你可以将替换表表示为一个`dict`，其中每个数字`key`在`dict`中都有其对应的`value`。例如，我知道如果我从1跳过5，我应该落在9上：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since there are only 10 numbers to encode, this is probably the easiest way
    to write this. Note that the numbers are written with quotes around them, so they
    are actually of the type `str` and not `int` (integers). I do this because I will
    be reading characters from a `str`. If I stored them as actual numbers, I would
    have to coerce the `str` types using the `int()` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有10个数字需要编码，这可能是编写它的最简单方法。注意，数字被引号包围，因此它们实际上是`str`类型，而不是`int`（整数）。我这样做是因为我将从`str`中读取字符。如果我将它们作为实际数字存储，我必须使用`int()`函数强制转换`str`类型：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 4.4.3 Various ways to process items in a series
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 以各种方式处理一系列项目
- en: As you’ve seen before, strings and lists in Python are similar in how you can
    index them. Both strings and lists are essentially sequences of elements--strings
    are sequences of characters, and lists can be sequences of anything at all.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，Python中的字符串和列表在索引方式上很相似。字符串和列表本质上都是元素的序列--字符串是字符的序列，而列表可以是任何东西的序列。
- en: There are several different ways to process any sequence of items, which here
    will be characters in a string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任何项目序列（在这里是字符串中的字符）有几种不同的方法。
- en: 'Method 1: Using a for loop to print() each character'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：使用for循环打印()每个字符
- en: 'As I suggested in the introduction, we can process each character of the `text`
    using a `for` loop. To start, I might first see if each character of the text
    is in the `jumper` table using the `x` `in` `y` construct:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在介绍中建议的，我们可以使用`for`循环处理`text`中的每个字符。首先，我可能首先检查文本中的每个字符是否在`jumper`表中，使用`x
    in y`结构：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note When `print()` is given more than one argument, it will put a space between
    each bit of text. You can change that with the `sep` argument. Read `help(print)`
    to learn more.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 当`print()`被赋予多个参数时，它将在每段文本之间放置一个空格。您可以使用`sep`参数来更改这一点。阅读`help(print)`以了解更多信息。
- en: 'Now let’s try to translate the numbers. I could use an `if` expression, where
    I print the value from the `jumper` table if `char` is present, and, otherwise,
    print the `char`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试翻译这些数字。我可以使用一个`if`表达式，如果`char`存在，则从`jumper`表中打印值，否则打印`char`：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It’s a bit laborious to check for every character, but it’s necessary because,
    for instance, the letter “A” is not in `jumper`. If I try to retrieve that value,
    I’ll get an exception:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个字符确实有些费劲，但这是必要的，因为例如，字母“A”不在`jumper`中。如果我尝试检索该值，我会得到一个异常：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `dict.get()` method allows me to safely ask for a value if it is present.
    Asking for “A” will not produce an exception, but it will also not show anything
    in the REPL because it returns the `None` value:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict.get()` 方法允许我在键存在时安全地请求一个值。请求 “A” 不会产生异常，但也不会在 REPL 中显示任何内容，因为它返回 `None`
    值：'
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It’s a bit easier to see if we try to `print()` the values:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试 `print()` 值，会更容易看到：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I can provide a second, optional argument to `dict.get()`, which is the default
    value to return when the key does not exist. In this program, I want to print
    the character itself when it does not exist in `jumper`. For instance, if I had
    “A,” I’d want to print “A”:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以向 `dict.get()` 提供第二个可选参数，即当键不存在时返回的默认值。在这个程序中，当字符不在 `jumper` 中时，我想打印该字符本身。例如，如果我有
    “A”，我想打印 “A”：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But if I have “5,” I want to print “0”:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我有 “5”，我想打印 “0”：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I can use that to process all the characters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用它来处理所有字符：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I don’t want that newline printing after every character, so I can use `end=''`
    to tell Python to put the empty string at the `end` instead of a newline.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我不希望在每个字符后打印换行符，所以我可以使用 `end=''` 来告诉 Python 在 `end` 处放置空字符串而不是换行符。
- en: 'When I run this in the REPL, the output is going to look funny because I have
    to press Enter after the `for` loop to run it. Then I’ll be left with `ABC987`
    with no newline, and then the `>>>` prompt:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 REPL 中运行这段代码时，输出看起来会有些奇怪，因为我必须按下 Enter 键来运行 `for` 循环。然后我会剩下 `ABC987`，没有换行符，然后是
    `>>>` 提示符：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In your code, you’ll have to add another `print()`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，你将不得不添加另一个 `print()`。
- en: It’s useful that you can change what is added at the `end`, and that you can
    `print()` with no arguments to print a newline. There are several other really
    cool things `print()` can do, so I encourage you to read `help(print)` and try
    them out.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变在 `end` 处添加的内容，并且你可以不带参数 `print()` 来打印换行符。`print()` 还可以做很多其他非常酷的事情，所以我鼓励你阅读
    `help(print)` 并尝试它们。
- en: 'Method 2: Using a for loop to build a new string'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 2：使用 for 循环构建新的字符串
- en: 'There are several other ways you could solve this. While it was fun to explore
    all the things we can do with `print()`, that code is a bit ugly. I think it’s
    cleaner to create a `new_text` variable and call `print()` once with that:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以几种其他方式解决这个问题。虽然探索我们可以用 `print()` 做的所有事情很有趣，但那段代码有点丑陋。我认为创建一个 `new_text`
    变量并使用它来调用一次 `print()` 会更干净：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Create an empty new_text variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个空的 new_text 变量。
- en: ② Use the same for loop.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用相同的 for 循环。
- en: ③ Append either the encoded number or the original char to the new_text.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将编码后的数字或原始字符追加到 new_text 中。
- en: ④ Print the new_text.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 打印新的文本。
- en: 'In this version, I start by setting `new_text` equal to the empty string:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我首先将 `new_text` 设置为空字符串：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'I use the same `for` loop to process each character in the `text`. Each time
    through the loop, I use `+=` to append the right side of the equation to the left
    side. The `+=` adds the value on the right to the variable on the left:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用相同的 `for` 循环来处理 `text` 中的每个字符。每次循环迭代，我使用 `+=` 将等式的右侧追加到左侧。`+=` 将右侧的值添加到左侧的变量中：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: On the right, I’m using the `jumper.get()` method. Each character will be appended
    to the `new_text`, as shown in figure 4.7.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我使用 `jumper.get()` 方法。每个字符将被追加到 `new_text` 中，如图 4.7 所示。
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](../Images/4-7.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-7.png)'
- en: Figure 4.7 The `+=` operator will append the string on the right to the variable
    on the left.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 `+=` 运算符将右侧的字符串追加到左侧的变量中。
- en: 'Now I can call `print()` once with the new value:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以使用新值调用一次 `print()`。
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Method 3: Using a for loop to build a new list'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 3：使用 for 循环构建新的列表
- en: 'This method is the same as the preceding one, but rather than `new_text` being
    a `str`, it’s a `list`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与前面的一种相同，但 `new_text` 不是 `str`，而是一个 `list`：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ① Initialize new_text as an empty list.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 new_text 初始化为一个空列表。
- en: ② Iterate through each character of the text.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文本中的每个字符。
- en: ③ Append the results of the jumper.get () call to the new_text variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将 jumper.get() 调用的结果追加到 new_text 变量中。
- en: ④ Join the new_text on the empty string to create a new string to print.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用空字符串连接 new_text 来创建一个新的字符串以打印。
- en: 'As we go through the book, I’ll keep reminding you how Python treats strings
    and lists similarly. Here I’m using `new_text` exactly the same as I did before,
    starting with an empty structure and then making it longer for each character.
    I could actually use the exact same `+=` syntax instead of the `list.append()`
    method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们阅读这本书的过程中，我会不断地提醒你Python如何相似地处理字符串和列表。在这里，我使用`new_text`与之前完全相同，从一个空的结构开始，然后为每个字符使其更长。实际上，我可以使用完全相同的`+=`语法而不是`list.append()`方法：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After the `for` loop is done, I have all the new characters that need to be
    put back together using `str.join()` into a new string that I can `print()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环完成后，我将所有需要重新组合的新字符使用`str.join()`放入一个新的字符串中，然后我可以`print()`它。
- en: 'Method 4: Turning a for loop into a list comprehension'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法4：将for循环转换为列表推导式
- en: A shorter solution uses a *list comprehension*, which is basically a one-line
    `for` loop inside square brackets (`[]`) that results in a new `list` (see figure
    4.8).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简短的解决方案使用列表推导式，它基本上是一个位于方括号`[]`中的一行`for`循环，它会产生一个新的`list`（见图4.8）。
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](../Images/4-8.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8](../Images/4-8.png)'
- en: Figure 4.8 A list comprehension will generate a new `list` with the results
    of iterating with a `for` statement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 列表推导式将生成一个新`list`，其中包含使用`for`语句迭代的结果。
- en: A list comprehension is read backwards from a `for` loop, but it’s all there.
    It’s one line of code instead four!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是从`for`循环反向读取的，但它包含了所有内容。它只有一行代码，而不是四行！
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can use `str.join()` on the empty string to turn that `list` into a new
    string you can `print()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`str.join()`在空字符串上，将那个`list`转换成一个新的字符串，然后你可以`print()`它：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The purpose of a list comprehension is to create a new list, which is what we
    were trying to do with the `for` loop code before. A list comprehension makes
    much more sense and uses far fewer lines of code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的目的是创建一个新的列表，这是我们之前使用`for`循环代码试图做到的。列表推导式更有意义，并且使用的代码行数更少。
- en: 'Method 5: Using the str.translate() function'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法5：使用str.translate()函数
- en: 'This last approach uses a really powerful method from the `str` class to change
    all the characters in one step:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法使用`str`类中的一个非常强大的方法来一步改变所有字符：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The argument to `str.translate()` is a translation table that describes how
    each character should be translated. That’s exactly what `jumper` does.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.translate()`的参数是一个转换表，它描述了每个字符应该如何被转换。这正是`jumper`所做的事情。'
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I’ll explain this in much greater detail in chapter 8\.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在第8章中更详细地解释这一点。
- en: 4.4.4 (Not) using str.replace()
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 （不）使用str.replace()
- en: I asked earlier whether you could use `str.replace()` to change all the numbers.
    It turns out you cannot, because you’ll end up changing some of the values twice
    so that they end up at their original values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前问过你是否可以使用`str.replace()`来改变所有的数字。结果发现你不能，因为你将改变一些值两次，最终它们会回到原始值。
- en: 'Watch how we start off with this string:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何从这个字符串开始的：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When you change “1” to “9,” now you have two 9’s:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将“1”改为“9”时，现在你有两个9：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means that when you try to change all the 9’s to 1’s, you end up with
    two 1’s. The `1` in the first position is changed to `9` and then back to `1`
    again:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你尝试将所有的9变成1时，你最终会得到两个1。第一个位置上的1变成了9，然后又变回1：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So if you go through each number in “1234567890” and try to change them using
    `str.replace()`, you’ll end up with the value “1234543215”:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你逐个数字地遍历“1234567890”并尝试使用`str.replace()`来改变它们，你最终会得到值“1234543215”：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: But the correctly encoded string is “9876043215.” The `str.translate()` function
    exists to change all the values in one move, all while leaving the unchanging
    characters alone.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但正确编码的字符串是“9876043215”。`str.translate()`函数存在就是为了一步改变所有值，同时不改变不变的字符。
- en: 4.5 Going further
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 进一步学习
- en: Try creating a similar program that encodes the numbers with strings (for example,
    “5” becomes “five,” “7” becomes “seven”). Be sure to write the necessary tests
    in `test.py` to check your work!
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建一个类似的程序，用字符串来编码数字（例如，“5”变成“five”，“7”变成“seven”）。务必在`test.py`中编写必要的测试来检查你的工作！
- en: What happens if you feed the output of the program back into itself? For example,
    if you run `./jump.py` `12345`, you should get `98760`. If you run `./jump.py`
    `98760`, do you recover the original numbers? This is called *round-tripping*,
    and it’s a common operation with algorithms that encode and decode text.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将程序的输出反馈到程序中会发生什么？例如，如果你运行`./jump.py` `12345`，你应该得到`98760`。如果你运行`./jump.py`
    `98760`，你能恢复原始数字吗？这被称为*round-tripping*，这是编码和解码文本的算法中常见的操作。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create a new dictionary using the `dict()` function or with empty curly
    brackets (`{}`).
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `dict()` 函数或使用空的花括号 (`{}`) 来创建一个新的字典。
- en: Dictionary values are retrieved using their keys inside square brackets or by
    using the `dict.get()` method.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过在方括号内使用键或使用 `dict.get()` 方法来检索字典的值。
- en: For a `dict` called `x`, you can use `'key'` `in` `x` to determine if a key
    exists.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于名为 `x` 的 `dict`，您可以使用 `'key'` `in` `x` 来判断一个键是否存在。
- en: You can use a `for` loop to iterate through the characters of a `str` just like
    you can iterate through the elements of a `list`. You can think of strings as
    lists of characters.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `for` 循环遍历 `str` 的字符，就像您遍历 `list` 的元素一样。您可以将字符串视为字符的列表。
- en: The `print()` function takes optional keyword arguments like `end=''`, which
    you can use to print a value to the screen without a newline.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()` 函数接受可选的关键字参数，如 `end=''''`，您可以使用它来在屏幕上打印一个值而不换行。'
