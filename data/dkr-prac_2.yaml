- en: Part 3\. Docker and DevOps
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分\. Docker 和 DevOps
- en: Now you’re ready to take Docker beyond your development environment and start
    using it in other phases of software delivery. Build and testing automation are
    cornerstones of the DevOps movement. We’ll demonstrate Docker’s power through
    automation of the software delivery lifecycle, deployments, and realistic environment
    testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好将 Docker 超越你的开发环境，并开始在软件交付的其他阶段使用它。构建和测试自动化是 DevOps 运动的基石。我们将通过自动化软件交付生命周期、部署和现实环境测试来展示
    Docker 的强大功能。
- en: '[Chapter 8](kindle_split_019.xhtml#ch08) will show various techniques for delivering
    and improving continuous integration, making your software deliveries both more
    reliable and scalable.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 8 章](kindle_split_019.xhtml#ch08) 将展示各种交付和改进持续集成的技术，使你的软件交付更加可靠和可扩展。'
- en: '[Chapter 9](kindle_split_020.xhtml#ch09) focuses on continuous delivery. We’ll
    explain what continuous delivery is, and look at ways in which Docker can be used
    to improve this aspect of your development pipeline.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 9 章](kindle_split_020.xhtml#ch09) 专注于持续交付。我们将解释什么是持续交付，并探讨 Docker 可以如何用来改进你开发管道的这一方面。'
- en: '[Chapter 10](kindle_split_021.xhtml#ch10) shows how you can harness Docker’s
    networking model to full effect, creating multicontainer services, simulating
    realistic networks, and creating networks on demand.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 10 章](kindle_split_021.xhtml#ch10) 展示了如何充分利用 Docker 的网络模型，创建多容器服务，模拟现实网络，以及按需创建网络。'
- en: This part takes you from development all the way to the point where you can
    think about running Docker in production.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将带你从开发一直走到你可以考虑在生产环境中运行 Docker 的阶段。
- en: 'Chapter 8\. Continuous integration: Speeding up your development pipeline'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 持续集成：加速你的开发管道
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using the Docker Hub workflow as a CI tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Hub 工作流程作为 CI 工具
- en: Speeding up your I/O-heavy builds
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速你的 I/O 重量级构建
- en: Using Selenium for automated testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Selenium 进行自动化测试
- en: Running Jenkins within Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 中运行 Jenkins
- en: Using Docker as a Jenkins slave
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 作为 Jenkins 从属节点
- en: Scaling your available compute with your dev team
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你的开发团队一起扩展可用计算资源
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this chapter we’re going to look at various techniques that will use Docker
    to enable and improve your continuous integration (CI) efforts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种技术，这些技术将使用 Docker 来使你的持续集成（CI）工作得以实现和改进。
- en: By now you should understand how Docker is well suited to being used for automation.
    Its lightweight nature, and the power it gives you to port environments from one
    place to another, can make it a key enabler of CI. We’ve found the techniques
    in this chapter to be invaluable in making a CI process feasible within a business.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经理解 Docker 非常适合用于自动化。它的轻量级特性，以及它赋予你将环境从一个地方迁移到另一个地方的能力，可以使它成为 CI 的关键推动者。我们发现本章中的技术对于在商业环境中使
    CI 过程可行非常有价值。
- en: By the end of this chapter you’ll understand how Docker can make the process
    of CI faster, more stable, and reproducible. By using test tools such as Selenium,
    and expanding your build capacity with the Jenkins Swarm plugin, you’ll see how
    Docker can help you get even more out of your CI process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解 Docker 如何使 CI（持续集成）过程更快、更稳定、可重复。通过使用测试工具如 Selenium，以及使用 Jenkins
    Swarm 插件扩展你的构建能力，你将看到 Docker 如何帮助你从 CI 过程中获得更多。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In case you don’t know, *continuous integration* is a software lifecycle strategy
    used to speed up the development pipeline. By automatically rerunning tests every
    time a significant change is made to the codebase, you get faster and more stable
    deliveries because there’s a base level of stability in the software being delivered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，*持续集成* 是一种软件生命周期策略，用于加速开发管道。通过在代码库中每次进行重大更改时自动重新运行测试，你可以获得更快、更稳定的交付，因为正在交付的软件有一个基本的稳定性水平。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1\. Docker Hub automated builds
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. Docker Hub 自动构建
- en: The Docker Hub automated build feature was mentioned in [technique 10](kindle_split_011.xhtml#ch02sb11),
    though we didn’t go into any detail on it. In short, if you point to a Git repository
    containing a Dockerfile, the Docker Hub will handle the process of building the
    image and making it available to download. An image rebuild will be triggered
    on any changes in the Git repository, making this quite useful as part of a CI
    process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 自动构建功能在[技术 10](kindle_split_011.xhtml#ch02sb11)中提到，尽管我们没有详细介绍它。简而言之，如果您指向包含
    Dockerfile 的 Git 仓库，Docker Hub 将处理构建镜像并使其可供下载的过程。任何 Git 仓库中的更改都会触发镜像重建，这使得它作为
    CI 流程的一部分非常有用。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using the Docker Hub workflow**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Docker Hub 工作流程**'
- en: This technique will introduce you to the Docker Hub workflow, which enables
    you to trigger rebuilds of your images
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将向您介绍 Docker Hub 工作流程，它使您能够触发镜像的重建。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: For this section, you’ll need an account on docker.com linked to either a GitHub
    or a Bitbucket account. If you don’t already have these set up and linked, instructions
    are available from the homepages of github.com and bitbucket.org.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，您需要在 docker.com 上创建一个账户，并将其与 GitHub 或 Bitbucket 账户关联。如果您还没有设置并关联这些账户，可以在
    github.com 和 bitbucket.org 的主页上找到说明。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**PROBLEM**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to automatically test and push changes to your image when the code
    changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在代码更改时自动测试并推送更改到您的镜像。
- en: '**SOLUTION**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Set up a Docker Hub repository and link it to your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Docker Hub 仓库并将其与您的代码链接。
- en: 'Although the Docker Hub build isn’t complicated, a number of steps are required:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker Hub构建并不复杂，但需要执行多个步骤：
- en: Create your repository on GitHub or BitBucket.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitHub 或 Bitbucket 上创建您的仓库。
- en: Clone the new Git repository.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆新的 Git 仓库。
- en: Add code to your Git repository.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的 Git 仓库添加代码。
- en: Commit the source.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交源代码。
- en: Push the Git repository.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送 Git 仓库。
- en: Create a new repository on the Docker Hub.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker Hub 上创建一个新的仓库。
- en: Link the Docker Hub repository to the Git repository.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Docker Hub 仓库链接到 Git 仓库。
- en: Wait for the Docker Hub build to complete.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 Docker Hub 构建完成。
- en: Commit and push a change to the source.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交并推送源代码的更改。
- en: Wait for the second Docker Hub build to complete.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待第二次 Docker Hub 构建完成。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Both Git and Docker use the term “repository” to refer to a project. This can
    confuse people. A Git repository and a Docker repository are not the same thing,
    even though here we’re linking the two types of repositories.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Git 和 Docker 都使用“仓库”一词来指代一个项目。这可能会让人困惑。Git 仓库和 Docker 仓库不是同一回事，尽管在这里我们将这两种类型的仓库关联起来。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Create your repository on GitHub or Bitbucket**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 GitHub 或 Bitbucket 上创建您的仓库**'
- en: Create a new repository on GitHub or Bitbucket. You can give it any name you
    want.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 或 Bitbucket 上创建一个新的仓库。您可以给它任何您想要的名称。
- en: '**Clone the new Git repository**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**克隆新的 Git 仓库**'
- en: Clone your new Git repository to your host machine. The command for this will
    be available from the Git project’s homepage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的新的 Git 仓库克隆到您的宿主机上。此命令将可在 Git 项目的主页上找到。
- en: Change directory into this repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到该仓库的目录。
- en: '**Add code to your Git repository**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**向您的 Git 仓库添加代码**'
- en: Now you need to add code to the project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要向项目中添加代码。
- en: You can add any Dockerfile you like, but the following listing shows an example
    known to work. It consists of two files representing a simple dev tools environment.
    It installs some preferred utilities and outputs the bash version you have.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任何喜欢的 Dockerfile，但以下列表显示了一个已知可以工作的示例。它由两个文件组成，代表一个简单的开发工具环境。它安装了一些首选的实用工具，并输出您拥有的
    bash 版本。
- en: Listing 8.1\. Dockerfile—simple dev tools container Dockerfile
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. Dockerfile—简单的开发工具容器 Dockerfile
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Installs useful packages**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装有用的软件包**'
- en: '***2*** **Adds a line to the root’s bashrc to source bash_extra**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在根的 bashrc 中添加一行以源 bash_extra**'
- en: '***3*** **Adds bash_extra from the source to the container**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将源代码中的 bash_extra 添加到容器中**'
- en: 'Now you’ll need to add the bash_extra file you referenced and give it the following
    content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要添加您所引用的 bash_extra 文件，并给它以下内容：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file is just for illustration. It shows that you can create a bash file
    that’s sourced on startup. In this case it displays the version of bash you’re
    using in your shell, but it could contain all manner of things that set up your
    shell to your preferred state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件仅用于说明。它表明您可以在启动时创建一个 bash 文件。在这种情况下，它显示您在 shell 中使用的 bash 版本，但它可以包含所有各种设置您
    shell 到您首选状态的东西。
- en: '**Commit the source**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交源代码**'
- en: 'To commit your source code source, use this command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要提交您的源代码，请使用以下命令：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Push the Git repository**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**推送Git仓库**'
- en: 'Now you can push the source to the Git server with this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用以下命令将源代码推送到Git服务器：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Create a new repository on the Docker Hub**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Docker Hub上创建一个新的仓库**'
- en: Next you need to create a repository for this project on the Docker Hub. Go
    to [https://hub.docker.com](https://hub.docker.com) and ensure you’re logged in.
    Then click on Create and choose Create Automated Build.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在Docker Hub上为该项目创建一个仓库。转到[https://hub.docker.com](https://hub.docker.com)，确保您已登录。然后点击创建并选择创建自动化构建。
- en: For the first time only, you’ll need to go through the account-linking process.
    You’ll see a prompt to link your account to a hosted Git service. Select your
    service and follow the instructions to link your account. You may be offered the
    choice to give full or more limited access to Docker Inc. for the integration.
    If you opt for the more limited access, you should read the official documentation
    for your specific service to identify what extra work you might need to do during
    the rest of the steps.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，您需要完成账户链接过程。您将看到一个提示，要求将您的账户链接到托管Git服务。选择您的服务并按照说明链接您的账户。您可能会被提供选择给予Docker
    Inc.完全访问权限或更有限访问权限以进行集成的选项。如果您选择更有限的访问权限，您应该阅读您特定服务的官方文档，以确定您在剩余步骤中可能需要做哪些额外工作。
- en: '**Link the Docker Hub repository to the Git repository**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**将Docker Hub仓库链接到Git仓库**'
- en: You’ll see a screen with a choice of Git services. Pick the source code service
    you use (GitHub or Bitbucket) and select your new repository from the provided
    list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个选择Git服务的屏幕。选择您使用的源代码服务（GitHub或Bitbucket），并从提供的列表中选择您的新仓库。
- en: You’ll see a page with options for the build configuration. You can leave the
    defaults and click Create Repository at the bottom.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个带有构建配置选项的页面。您可以保留默认设置，然后在底部点击创建仓库。
- en: '**Wait for the Docker Hub build to complete**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待Docker Hub构建完成**'
- en: You’ll see a page with a message explaining that the link worked. Click on the
    Build Details link.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个带有解释链接成功的消息的页面。点击构建详情链接。
- en: Next, you’ll see a page that shows the details of the builds. Under Builds History,
    there will be an entry for this first build. If you don’t see anything listed,
    you may need to click the button to trigger the build manually. The Status field
    next to the build ID will show Pending, Finished, Building, or Error. If all is
    well, you’ll see one of the first three. If you see Error, something has gone
    wrong and you’ll need to click on the build ID to see what the error was.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个显示构建详细信息的页面。在构建历史记录下，将有一个条目用于这个第一个构建。如果您没有看到任何列出内容，您可能需要点击按钮来手动触发构建。构建ID旁边的状态字段将显示为挂起、完成、构建中或错误。如果一切顺利，您将看到前三个状态之一。如果您看到错误，说明出了问题，您需要点击构建ID来查看错误详情。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It can take a while for the build to start, so seeing Pending for some time
    while waiting is perfectly normal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建开始可能需要一些时间，所以在等待时看到挂起状态一段时间是完全正常的。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Click Refresh periodically until you see that the build has completed. Once
    it’s complete, you can pull the image with the `docker pull` command listed on
    the top of the same page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定期刷新，直到您看到构建已完成。一旦完成，您可以使用同一页面上列出的`docker pull`命令拉取镜像。
- en: '**Commit and push a change to the source**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交并推送源代码的更改**'
- en: 'Now you decide that you want more information about your environment when you
    log in, so you want to output the details of the distribution you’re running in.
    To achieve this, add these lines to your bash_extra file so that it now looks
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您决定在登录时想要更多关于您环境的信息，因此您想要输出您正在运行的发行版的详细信息。为了实现这一点，将这些行添加到您的bash_extra文件中，使其现在看起来像这样：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then commit and push as in steps 4 and 5.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照步骤4和5进行提交和推送。
- en: '**Wait for the second Docker Hub build to complete**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待第二个Docker Hub构建完成**'
- en: If you return to the build page, a new line should show up under the Builds
    History section, and you can follow this build as in step 8.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您返回到构建页面，构建历史记录部分应该会显示一条新行，您可以像第8步一样跟踪此构建。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You’ll be emailed if there’s an error with your build (no email if all is OK),
    so once you’re used to this workflow, you’ll only need to check up on it if you
    receive an email.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的构建出现错误（如果没有问题则不会收到邮件），您将会收到邮件，所以一旦您习惯了这种工作流程，您只需要在收到邮件时检查一下。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can now use the Docker Hub workflow. You’ll quickly get used to this framework
    and find it invaluable for keeping your builds up to date and reducing the cognitive
    load of rebuilding Dockerfiles by hand.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 Docker Hub 工作流程。你会很快习惯这个框架，并发现它对于保持构建更新和减少手动重建 Dockerfile 的认知负担非常有价值。
- en: '**DISCUSSION**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Because the Docker Hub is the canonical source of images, pushing there during
    your CI process can make some things more straightforward (distributing images
    to third parties, for one). Not having to run the build process yourself is easier
    and gives you some additional benefits, like a checkmark against the listing on
    the Docker Hub indicating that the build was performed on a trusted server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker Hub 是镜像的规范来源，在你的 CI 流程中推送那里可以使一些事情变得更加简单（例如，向第三方分发镜像）。不需要自己运行构建过程更容易，并给你带来一些额外的优势，比如在
    Docker Hub 的列表上有一个勾选标记，表明构建是在受信任的服务器上执行的。
- en: Having this additional confidence in your builds helps you comply with the *Docker
    contract* in [technique 70](kindle_split_020.xhtml#ch09sb02)—in [technique 113](kindle_split_029.xhtml#ch16sb06)
    we’ll look at how specific machines can sometimes affect Docker builds, so using
    a completely independent system is good for increasing confidence in the final
    results.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的构建有额外的信心可以帮助你遵守 [技术 70](kindle_split_020.xhtml#ch09sb02) 中的 *Docker 协议*——在
    [技术 113](kindle_split_029.xhtml#ch16sb06) 中，我们将探讨特定机器有时如何影响 Docker 构建，因此使用一个完全独立的系统对于提高最终结果的可信度是有益的。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.2\. More efficient builds
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 更高效的构建
- en: CI implies a more frequent rebuilding of your software and tests. Although Docker
    makes delivering CI easier, the next problem you may bump into is the resulting
    increased load on your compute resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'CI 意味着更频繁地重建你的软件和测试。尽管 Docker 使交付 CI 更容易，但你可能遇到的下一个问题是计算资源上的负载增加。 '
- en: We’ll look at ways to alleviate this pressure in terms of disk I/O, network
    bandwidth, and automated testing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨在磁盘 I/O、网络带宽和自动化测试方面缓解这种压力的方法。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Speeding up I/O-intensive builds with eatmydata**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 eatmydata 加速 I/O 密集型构建**'
- en: Because Docker is a great fit for automated building, you’ll likely perform
    a lot of disk-I/O-intensive builds as time goes on. Jenkins jobs, database rebuild
    scripts, and large code checkouts will all hit your disks hard. In these cases,
    you’ll be grateful for any speed increases you can get, both to save time and
    to minimize the many overheads that result from resource contention.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 非常适合自动化构建，随着时间的推移，你可能会执行大量的磁盘 I/O 密集型构建。Jenkins 作业、数据库重建脚本和大型代码签出都会对你的磁盘造成严重打击。在这些情况下，你会感激任何可以获得的加速，无论是为了节省时间还是为了最小化由于资源竞争而产生的许多开销。
- en: This technique has been shown to give up to a 1:3 speed increase, and our experience
    backs this up. This is not to be sniffed at!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术已被证明可以提高高达 1:3 的速度，我们的经验也证实了这一点。这可不是小事情！
- en: '**PROBLEM**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to speed up your I/O-intensive builds.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望加速你的 I/O 密集型构建。
- en: '**SOLUTION**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: eatmydata is a program that takes your system calls to write data and makes
    them super-fast by bypassing work required to persist those changes. This entails
    some lack of safety, so it’s not recommended for normal use, but it’s quite useful
    for environments not designed to persist, such as in testing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: eatmydata 是一个程序，它将你的系统调用写入数据，并通过绕过持久化这些更改所需的工作来使它们变得超级快。这涉及一些安全性的缺乏，因此不建议在常规使用中，但它对于设计用于不持久化的环境非常有用，例如在测试中。
- en: '**Installing eatmydata**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 eatmydata**'
- en: 'To install eatmydata in your container, you have a number of options:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的容器中安装 eatmydata，你有多种选择：
- en: If you’re running a deb-based distribution, you can `apt-get install` it.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你运行的是基于 deb 的发行版，你可以使用 `apt-get install` 安装它。
- en: If you’re running an rpm-based distribution, you’ll be able to `rpm --install`
    it by searching for it on the web and downloading it. Websites such as rpmfind.net
    are a good place to start.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你运行的是基于 rpm 的发行版，你可以在网上搜索并下载它后使用 `rpm --install` 安装它。例如，rpmfind.net 是一个很好的起点。
- en: As a last resort, and if you have a compiler installed, you can download and
    compile it directly as shown in the next listing.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后的手段，如果你已经安装了编译器，你可以直接下载并按照下面的列表进行编译。
- en: Listing 8.2\. Compiling and installing eatmydata
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2. 编译和安装 eatmydata
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Flamingspork.com is the website of the maintainer.**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **Flamingspork.com 是维护者的网站。**'
- en: '***2*** **If this version doesn’t download, check on the website to see whether
    it’s been updated to a number later than 105.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果此版本未下载，请访问网站查看是否已更新到大于105的版本。**'
- en: '***3*** **Change the prefix directory if you want the eatmydata executable
    to be installed somewhere other than /usr/bin.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果您想将eatmydata可执行文件安装到除/usr/bin之外的其他位置，请更改前缀目录。**'
- en: '***4*** **Builds the eatmydata executable**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **构建eatmydata可执行文件**'
- en: '***5*** **Installs the software; this step requires root privileges**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **安装软件；此步骤需要root权限**'
- en: '**Using eatmydata**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 eatmydata**'
- en: 'Once libeatmydata is installed on your image (either from a package or from
    source), run the eatmydata wrapper script before any command, to take advantage
    of it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在您的镜像上安装了libeatmydata（无论是从软件包还是从源代码），在执行任何命令之前运行eatmydata包装脚本，以利用它：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 8.1](#ch08fig01) shows at a high level how eatmydata saves you processing
    time.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](#ch08fig01) 从高层次展示了eatmydata如何节省您处理时间。'
- en: Figure 8.1\. Application writes to disk without (top) and with (bottom) eatmydata
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 应用程序写入磁盘（顶部）和带有eatmydata（底部）的情况
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: eatmydata skips the steps to guarantee that data is safely written to disk,
    so there’s a risk that data will not yet be on disk when the program thinks it
    is. For test runs, this usually doesn’t matter, because the data is disposable,
    but don’t use eatmydata to speed up any kind of environment where the data matters!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: eatmydata跳过了确保数据安全写入磁盘的步骤，因此存在数据尚未写入磁盘而程序认为它已经写入磁盘的风险。对于测试运行，这通常无关紧要，因为数据是可丢弃的，但不要使用eatmydata来加速任何数据重要的环境！
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Be aware that running `eatmydata docker run ...` to start a Docker container,
    perhaps after installing eatmydata on your host or mounting the Docker socket,
    will not have the effect you may expect due to the Docker client/server architecture
    outlined in [chapter 2](kindle_split_011.xhtml#ch02). Instead, you need to install
    eatmydata inside each individual container you want to use it in.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行`eatmydata docker run ...`以启动Docker容器，可能是在您的宿主机上安装eatmydata或挂载Docker套接字之后，由于[第2章](kindle_split_011.xhtml#ch02)中概述的Docker客户端/服务器架构，这不会产生您可能期望的效果。相反，您需要在每个您想要使用eatmydata的容器内安装eatmydata。
- en: '**DISCUSSION**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although precise use cases will vary, one place you should immediately be able
    to apply this is in [technique 68](#ch08sb09). It’s very rare for the data integrity
    on a CI job to matter—you’re usually just interested in success or failure, and
    the logs in the case of failure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具体用例可能会有所不同，但您应该能够立即应用的一个地方是[技术68](#ch08sb09)。在CI作业的数据完整性通常并不重要——您通常只对成功或失败感兴趣，在失败的情况下，您通常只关心日志。
- en: One other relevant technique is [technique 77](kindle_split_021.xhtml#ch10sb03).
    A database is one place where data integrity really does matter a lot (any popular
    one will be designed to not lose data in the case of machine power loss), but
    if you’re just running some tests or experiments, it’s overhead that you don’t
    need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项相关的技术是[技术77](kindle_split_021.xhtml#ch10sb03)。数据库是数据完整性真正非常重要的一个地方（任何流行的数据库都将设计为在机器电源丢失的情况下不会丢失数据），但如果你只是运行一些测试或实验，这将是您不需要的开销。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up a package cache for faster builds**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**为快速构建设置包缓存**'
- en: As Docker lends itself to frequent rebuilding of services for development, testing,
    and production, you can quickly get to a point where you’re repeatedly hitting
    the network a lot. One major cause is downloading package files from the internet.
    This can be a slow (and costly) overhead, even on a single machine. This technique
    shows you how to set up a local cache for your package downloads, covering apt
    and yum.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker适合于开发、测试和生产中频繁重建服务，您可能会迅速达到一个需要反复大量访问网络的点。一个主要原因是下载来自互联网的包文件。这甚至可能在单台机器上也是一个缓慢（且昂贵）的开销。这项技术向您展示了如何设置本地缓存以用于您的包下载，包括apt和yum。
- en: '**PROBLEM**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to speed up your builds by reducing network I/O.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过减少网络I/O来加速您的构建。
- en: '**SOLUTION**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Install a Squid proxy for your package manager. [Figure 8.2](#ch08fig02) illustrates
    how this technique works.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的包管理器安装一个Squid代理。[图8.2](#ch08fig02)说明了这项技术的工作原理。
- en: Figure 8.2\. Using a Squid proxy to cache packages
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 使用Squid代理缓存包
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig02_alt.jpg)'
- en: Because the calls for packages go to the local Squid proxy first, and are only
    requested over the internet the first time, there should only be one request over
    the internet for each package. If you have hundreds of containers all pulling
    down the same large packages from the internet, this can save you a lot of time
    and money.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件包的调用首先发送到本地 Squid 代理，并且只有在第一次请求时才通过互联网请求，因此对于每个软件包，应该只有一个互联网请求。如果你有数百个容器都从互联网下载相同的大型软件包，这可以为你节省大量时间和金钱。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may have network configuration issues when setting this up on your host.
    Advice is given in the following sections to determine whether this is the case,
    but if you’re unsure how to proceed, you may need to seek help from a friendly
    network admin.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在主机上设置此配置时，可能会遇到网络配置问题。以下各节提供了建议，以确定是否出现这种情况，但如果你不确定如何进行，你可能需要寻求友好的网络管理员帮助。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Debian**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Debian**'
- en: For Debian (otherwise known as apt or .deb) packages, the setup is simpler because
    there is a prepackaged version.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Debian（也称为 apt 或 .deb）软件包，设置更简单，因为有预包装版本。
- en: 'On your Debian-based host run this command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Debian 的主机上运行以下命令：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure that the service is started by telneting to port 8000:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过telnet到端口8000确保服务已启动：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Press Ctrl-] followed by Ctrl-d to quit if you see the preceding output. If
    you don’t see this output, then Squid has either not installed properly or it
    has installed on a nonstandard port.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到前面的输出，请按 Ctrl-] 然后按 Ctrl-d 退出。如果没有看到此输出，则 Squid 要么未正确安装，要么安装在了非标准端口。
- en: To set up your container to use this proxy, we’ve provided the following example
    Dockerfile. Bear in mind that the IP address of the host, from the point of view
    of the container, may change from run to run. For this reason, you may want to
    convert this Dockerfile to a script to be run from within the container before
    installing new software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的容器使用此代理，我们提供了以下示例 Dockerfile。请注意，从容器的角度来看，主机的 IP 地址可能会在每次运行时发生变化。因此，你可能希望在安装新软件之前将此
    Dockerfile 转换为在容器内运行的脚本。
- en: Listing 8.3\. Configuring a Debian image to use an apt proxy
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 配置 Debian 镜像以使用 apt 代理
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Ensures the route tool is installed**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确保路由工具已安装**'
- en: '***2*** **To determine the host’s IP address from the point of view of the
    container, runs the route command and uses awk to extract the relevant IP address
    from the output (see [technique 67](#ch08sb08)).**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为了确定容器视角下的主机 IP 地址，运行路由命令并使用 awk 从输出中提取相关 IP 地址（见[技术67](#ch08sb08)）。**'
- en: '***3*** **Port 8000 is used to connect to the Squid proxy on the host machine.**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **端口8000用于连接到主机上的 Squid 代理。**'
- en: '***4*** **The echoed lines with the appropriate IP address and configuration
    are added to apt’s proxy configuration file.**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将带有适当 IP 地址和配置的回显行添加到 apt 的代理配置文件中。**'
- en: '**Yum**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Yum**'
- en: On the host, ensure Squid is installed by installing the squid package with
    your package manager.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，通过使用你的包管理器安装 squid 软件包来确保 Squid 已安装。
- en: 'Then you’ll need to change the Squid configuration to create a larger cache
    space. Open up the /etc/squid/squid.conf file and replace the commented line beginning
    with `#cache_dir ufs /var/spool/squid` with this: `cache_dir ufs /var/spool/squid
    10000 16 256`. This creates a space of 10,000 MB, which should be sufficient.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要更改 Squid 配置以创建更大的缓存空间。打开 /etc/squid/squid.conf 文件，将开始的注释行 `#cache_dir
    ufs /var/spool/squid` 替换为以下内容：`cache_dir ufs /var/spool/squid 10000 16 256`。这会创建一个10,000
    MB的空间，应该足够使用。
- en: 'Ensure the service is started by telneting to port 3128:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过telnet到端口3128确保服务已启动：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Press Ctrl-] followed by Ctrl-d to quit if you see the preceding output. If
    you don’t see this output, then Squid has either not installed properly or has
    installed on a nonstandard port.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到前面的输出，请按 Ctrl-] 然后按 Ctrl-d 退出。如果没有看到此输出，则 Squid 要么未正确安装，要么安装在了非标准端口。
- en: To set up your container to use this proxy, we’ve provided the following example
    Dockerfile. Bear in mind that the IP address of the host, from the point of view
    of the container, may change from run to run. You may want to convert this Dockerfile
    to a script to be run from within the container before installing new software.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置你的容器使用此代理，我们提供了以下示例 Dockerfile。请注意，从容器的角度来看，主机的 IP 地址可能会在每次运行时发生变化。你可能希望在安装新软件之前将此
    Dockerfile 转换为在容器内运行的脚本。
- en: Listing 8.4\. Configuring a CentOS image to use a yum proxy
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 配置 CentOS 镜像以使用 yum 代理
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Ensures the route tool is installed**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确保路由工具已安装**'
- en: '***2*** **To determine the host’s IP address from the point of view of the
    container, runs the route command and uses awk to extract the relevant IP address
    from the output**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为了从容器的角度确定主机的 IP 地址，运行 route 命令并使用 awk 从输出中提取相关 IP 地址**'
- en: '***3*** **Port 3128 is used to connect to the Squid proxy on the host machine.**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用端口 3128 连接到主机上的 Squid 代理。**'
- en: '***4*** **To avoid cache misses where possible, removes the mirror lists and
    uses the base URLs only. This ensures you only hit one set of URLs to fetch packages,
    and you’re therefore more likely to hit the cached file.**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **尽可能避免缓存未命中，移除镜像列表并仅使用基础 URL。这确保你只击中一组 URL 来获取软件包，因此你更有可能击中缓存文件。**'
- en: '***5*** **Removes the fastestmirror plugin, as it’s no longer required.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **移除 fastestmirror 插件，因为它不再需要。**'
- en: '***6*** **Ensures the mirrors are checked. When running yum update, the mirrors
    listed in the config files may have out-of-date information, so the first update
    will be slow.**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **确保镜像被检查。当运行 yum update 时，配置文件中列出的镜像可能包含过时的信息，因此第一次更新可能会很慢。**'
- en: If you set up two containers this way and install the same large package on
    both, one after the other, you should notice that the second installation downloads
    its prerequisites much quicker than the first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以这种方式设置两个容器并在两个容器中依次安装相同的大型软件包，你应该会注意到第二个安装比第一个下载其依赖项要快得多。
- en: '**DISCUSSION**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You may have observed that you can run the Squid proxy on a container rather
    than on the host. That option wasn’t shown here to keep the explanation simple
    (in some cases, more steps are required to make Squid work within a container).
    You can read more about this, along with how to make containers automatically
    use the proxy, at [https://github.com/jpetazzo/squid-in-a-can](https://github.com/jpetazzo/squid-in-a-can).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经观察到你可以在容器上而不是在主机上运行 Squid 代理。这里没有展示这个选项是为了保持解释简单（在某些情况下，需要更多步骤才能使 Squid
    在容器中工作）。你可以阅读更多关于此内容，以及如何使容器自动使用代理的信息，请参阅[https://github.com/jpetazzo/squid-in-a-can](https://github.com/jpetazzo/squid-in-a-can)。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Headless Chrome in a container**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器中的无头 Chrome**'
- en: Running tests is a crucial part of CI, and most unit test frameworks will run
    within Docker without any issues. But sometimes more involved testing is called
    for, from making sure multiple microservices cooperate correctly to ensuring that
    website frontend functionality still works. Visiting a website frontend requires
    a browser of some kind, so to solve this problem we need a way to start a browser
    inside a container, and then to control it programmatically.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试是 CI 的关键部分，大多数单元测试框架都可以在 Docker 中无问题运行。但有时需要更复杂的测试，从确保多个微服务正确协作到确保网站前端功能仍然正常。访问网站前端需要某种类型的浏览器，因此为了解决这个问题，我们需要一种方法在容器内启动浏览器，然后对其进行程序化控制。
- en: '**PROBLEM**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to test against the Chrome browser within a container, without needing
    a GUI.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在容器内测试 Chrome 浏览器，而不需要 GUI。
- en: '**SOLUTION**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the Puppeteer Node.js library in an image to automate Chrome actions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像中使用 Puppeteer Node.js 库来自动化 Chrome 操作。
- en: This library is maintained by the Google Chrome development team, and it allows
    you to write scripts against Chrome for testing purposes. It’s “headless,” which
    means you don’t need a GUI to work against it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库由 Google Chrome 开发团队维护，它允许你针对测试目的编写针对 Chrome 的脚本。它是“无头”的，这意味着你不需要 GUI 就可以与之工作。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This image is also maintained by us on GitHub at [https://github.com/docker-in-practice/docker-puppeteer](https://github.com/docker-in-practice/docker-puppeteer).
    It’s also accessible as a Docker image with `docker pull dockerinpractice/docker-puppeteer`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此镜像也由我们在 GitHub 上维护[https://github.com/docker-in-practice/docker-puppeteer](https://github.com/docker-in-practice/docker-puppeteer)。它也可以作为
    Docker 镜像通过 `docker pull dockerinpractice/docker-puppeteer` 获取。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows a Dockerfile that will create an image containing
    all you need to get started with Puppeteer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个 Dockerfile，它将创建一个包含所有启动 Puppeteer 所需内容的镜像。
- en: Listing 8.5\. Puppeteer Dockerfile
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. Puppeteer Dockerfile
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Starts with an Ubuntu base image**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以 Ubuntu 基础镜像开始**'
- en: '***2*** **Installs all the software required. This is most of the display libraries
    required to get Chrome to operate within a container.**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **安装所有必需的软件。这是大多数用于在容器中运行 Chrome 所需的显示库。**'
- en: '***3*** **Sets up the latest nodejs version**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **设置最新的 nodejs 版本**'
- en: '***4*** **Installs the Ubuntu nodejs package**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **安装 Ubuntu 的 nodejs 软件包**'
- en: '***5*** **Creates a non-root user, “puser” (which the library requires to run)**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 创建一个非root用户，“puser”（库运行所需的用户）'
- en: '***6*** **Creates a node modules folder**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 创建一个node modules文件夹'
- en: '***7*** **Sets the NODE_PATH environment variable to the node_module folder**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 将NODE_PATH环境变量设置为node模块文件夹'
- en: '***8*** **Sets the current working directory to the node module path**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 将当前工作目录设置为node模块路径'
- en: '***9*** **Installs webpack (a dependency of Puppeteer)**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 安装webpack（Puppeteer的依赖项）'
- en: '***10*** **Clones the Puppeteer module code**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** 克隆Puppeteer模块代码'
- en: '***11*** **Goes to the Puppeteer code folder**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** 进入Puppeteer代码文件夹'
- en: '***12*** **Installs the Puppeteer NodeJS library**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** 安装Puppeteer NodeJS库'
- en: '***13*** **Goes to the Puppeteer examples folder**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13*** 进入Puppeteer示例文件夹'
- en: '***14*** **Adds a no-sandbox argument to the Puppeteer launch arguments, to
    overcome a security setting when running within a container**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***14*** 将no-sandbox参数添加到Puppeteer启动参数中，以克服在容器内运行时的安全设置'
- en: '***15*** **Starts the container with bash, adding a helpful echo command**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***15*** 使用bash启动容器，并添加一个有用的echo命令'
- en: 'Build and run this Dockerfile with this command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建和运行此Dockerfile：
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then run it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行它：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll be presented with a terminal and the suggestion to run `node pdf.js`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个终端和运行`node pdf.js`的建议。
- en: The pdf.js file contains a simple script that serves as an example of what can
    be done with the Puppeteer library.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: pdf.js文件包含一个简单的脚本，作为使用Puppeteer库可以做什么的示例。
- en: Listing 8.6\. pdf.js
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. pdf.js
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Runs the Javascript interpreter in strict mode, which catches commonly
    seen unsafe actions that are technically allowed**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 以严格模式运行JavaScript解释器，这可以捕获技术上允许但常见的不安全操作'
- en: '***2*** **Imports the Puppeteer library**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 导入Puppeteer库'
- en: '***3*** **Creates an async block in which the code will run**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 创建一个异步块，代码将在其中运行'
- en: '***4*** **A browser is run up using the puppeteer.launch function. The code
    pauses while the launching completes, with the await keyword**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 使用`puppeteer.launch`函数启动浏览器。代码在启动完成前暂停，使用`await`关键字'
- en: '***5*** **Uses the newPage function to make the browser wait for a page (equivalent
    to a browser tab) to be available**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 使用`newPage`函数使浏览器等待页面（相当于浏览器标签页）可用'
- en: '***6*** **Opens the HackerNews website with the page.goto function, and waits
    until there is no network traffic before continuing**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 使用`page.goto`函数打开HackerNews网站，并在继续之前等待没有网络流量'
- en: '***7*** **Uses the page.pdf function to create a PDF of the current tab in
    the letter format, and calls the file hn.pdf**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 使用`page.pdf`函数以信函格式创建当前标签页的PDF，并调用文件`hn.pdf`'
- en: '***8*** **Closes the browser and waits until termination is complete**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 关闭浏览器并等待终止完成'
- en: '***9*** **Calls the function returned by the async block**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 调用异步块返回的函数'
- en: 'A host of options are available to the Puppeteer user beyond this simple example.
    It’s beyond the scope of this technique to explain the Puppeteer API in detail.
    If you want to look in more depth at the API and adapt this technique, take a
    look at the Puppeteer API documentation on GitHub: [https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Puppeteer用户除了这个简单的示例之外，还有许多选项可用。本技术的范围不包括详细解释Puppeteer API。如果您想更深入地了解API并调整此技术，请查看GitHub上的Puppeteer
    API文档：[https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md](https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md)。
- en: '**DISCUSSION**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique shows you how Docker can be used to test against a specific browser.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了如何使用Docker来针对特定浏览器进行测试。
- en: 'The next technique broadens this one in two ways: by using Selenium, a popular
    testing tool that can work against multiple browsers, and combining this with
    some exploration of X11 to allow you to see a browser running in an graphical
    window rather than in the headless fashion used in this technique.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术以两种方式扩展了这一点：通过使用Selenium，这是一个流行的测试工具，可以针对多个浏览器进行工作，并将其与一些X11的探索相结合，这样您就可以看到在图形窗口中运行的浏览器，而不是像本技术中使用的那种无头模式。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Running Selenium tests inside Docker**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Docker内运行Selenium测试**'
- en: One Docker use case we haven’t yet examined in much detail is running graphical
    applications. In [chapter 3](kindle_split_013.xhtml#ch03), VNC was used to connect
    to containers during the “save game” approach to development ([technique 19](kindle_split_013.xhtml#ch03sb10)),
    but this can be clunky—windows are contained inside the VNC viewer window, and
    desktop interaction can be a little limited. We’ll explore an alternative to this
    by demonstrating how you can write graphical tests using Selenium. We’ll also
    show you how this image can be used to run the tests as part of your CI workflow.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有详细研究的一个 Docker 用例是运行图形应用程序。在[第 3 章](kindle_split_013.xhtml#ch03)中，使用 VNC
    连接到容器以在“保存游戏”的开发方法（[技术 19](kindle_split_013.xhtml#ch03sb10)）中，但这可能有些笨拙——窗口被包含在
    VNC 观看器窗口内，桌面交互可能有点受限。我们将通过演示如何使用 Selenium 编写图形测试来探索这种方法的替代方案。我们还将向你展示如何使用此镜像作为
    CI 工作流程的一部分来运行测试。
- en: '**PROBLEM**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be able to run graphical programs in your CI process while having
    the option to display those same graphical programs on your own screen.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在 CI 流程中运行图形程序的同时，有选择地在自己的屏幕上显示这些相同的图形程序。
- en: '**SOLUTION**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Share your X11 server socket to view the programs on your own screen, and use
    xvfb in your CI process.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 X11 服务器套接字共享以在你的屏幕上查看程序，并在你的 CI 流程中使用 xvfb。
- en: 'No matter what other things you need to do to start your container, you must
    have the Unix socket that X11 uses to display your windows mounted as a volume
    inside the container, and you need to indicate which display your windows should
    be shown on. You can double-check whether these two things are set to their defaults
    by running the following commands on your host:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你需要做什么来启动你的容器，你都必须将 X11 用于显示窗口的 Unix 套接字作为卷挂载在容器内，并且你需要指出你的窗口应该显示在哪个显示上。你可以在你的主机上运行以下命令来双重检查这两件事是否设置为默认值：
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first command checks that the X11 server Unix socket is running in the location
    assumed for the rest of the technique. The second command checks the environment
    variable applications use to find the X11 socket. If your output for these commands
    doesn’t match the output here, you may need to alter some arguments to the commands
    in this technique.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首个命令检查 X11 服务器 Unix 套接字是否在技术其余部分假设的位置运行。第二个命令检查应用程序使用的环境变量以查找 X11 套接字。如果你的这些命令的输出与这里的输出不匹配，你可能需要修改此技术中命令的一些参数。
- en: Now that you’ve checked your machine setup, you need to get the applications
    running inside a container to be seamlessly displayed outside the container. The
    main problem you need to overcome is the security that your computer puts in place
    to prevent other people from connecting to your machine, taking over your display,
    and potentially recording your keystrokes. In [technique 29](kindle_split_015.xhtml#ch05sb02)
    you briefly saw how to do this, but we didn’t talk about how it worked or look
    at any alternatives.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经检查了你的机器设置，你需要确保容器内的应用程序能够无缝地显示在容器外部。你需要克服的主要问题是你的计算机为了防止其他人连接到你的机器、接管你的显示以及可能记录你的按键而设置的安全措施。在[技术
    29](kindle_split_015.xhtml#ch05sb02)中，你简要地看到了如何做到这一点，但我们没有讨论它是如何工作的或查看任何替代方案。
- en: X11 has multiple ways of authenticating a container to use your X socket. First
    we’ll look at the .Xauthority file—it should be present in your home directory.
    It contains hostnames along with the “secret cookie” each host must use to connect.
    By giving your Docker container the same hostname as your machine and using the
    same username as outside the container, you can use your existing .Xauthority
    file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: X11 有多种方式来验证容器以使用你的 X 套接字。首先，我们将查看 .Xauthority 文件——它应该存在于你的家目录中。它包含主机名以及每个主机必须使用的“秘密饼干”以连接。通过给你的
    Docker 容器分配与你的机器相同的主机名，并使用容器外相同的用户名，你可以使用现有的 .Xauthority 文件。
- en: Listing 8.7\. Starting a container with an Xauthority-enabled display
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 使用启用 Xauthority 的显示启动容器
- en: '[PRE17]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second method of allowing Docker to access the socket is a much blunter
    instrument and it has security issues, because it disables all the protection
    X gives you. If nobody has access to your computer, this may be an acceptable
    solution, but you should always try to use the .Xauthority file first. You can
    secure yourself again after you try the following steps by running `xhost -` (though
    this will lock out your Docker container):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Docker访问套接字的第二种方法是一个更直接的工具，但它存在安全问题，因为它禁用了X为您提供的所有保护。如果没有人能访问您的计算机，这可能是一个可接受的解决方案，但您应该始终首先尝试使用.Xauthority文件。您可以通过运行`xhost
    -`（尽管这将锁定您的Docker容器）来在尝试以下步骤后再次保护自己：
- en: Listing 8.8\. Starting a container with xhost-enabled display
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 使用xhost启用显示启动容器
- en: '[PRE18]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line in the preceding listing disables all access control to X, and
    the second runs the container. Note that you don’t have to set the hostname or
    mount anything apart from the X socket.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，第一行禁用了对X的所有访问控制，第二行运行了容器。请注意，您不需要设置主机名或挂载除了X套接字之外的内容。
- en: 'Once you’ve started up your container, it’s time to check that it works. You
    can do this by running the following commands if going the .Xauthority route:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启动了容器，就是时候检查它是否正常工作了。如果您选择.Xauthority路径，可以通过运行以下命令来完成：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively you can use these slightly different commands if you’re going
    the xhost route, because you don’t need to run the command as a specific user:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您选择xhost路径，可以使用以下略有不同的命令，因为您不需要以特定用户身份运行该命令：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will start up a classic application that tests whether X is working—xeyes.
    You should see the eyes follow your cursor as you move it around the screen. Note
    that (unlike VNC) the application is integrated into your desktop—if you were
    to start xeyes multiple times, you’d see multiple windows.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个经典的应用程序来测试X是否工作——xeyes。当您在屏幕上移动光标时，应该会看到眼睛跟随。请注意，（与VNC不同）应用程序集成到您的桌面中——如果您多次启动xeyes，您会看到多个窗口。
- en: It’s time to get started with Selenium. If you’ve never used it before, it’s
    a tool with the ability to automate browser actions, and it’s commonly used to
    test website code—it needs a graphical display for the browser to run in. Although
    it’s most commonly used with Java, we’re going to use Python to allow more interactivity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始使用Selenium了。如果您以前从未使用过它，它是一个具有自动化浏览器操作能力的工具，通常用于测试网站代码——它需要一个图形显示来运行浏览器。尽管它最常与Java一起使用，但我们将使用Python来允许更多的交互性。
- en: The following listing first installs Python, Firefox, and a Python package manager,
    and then it uses the Python package manager to install the Selenium Python package.
    It also downloads the “driver” binary that Selenium uses to control Firefox. A
    Python REPL is then started, and the Selenium library is used to create a Firefox
    instance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表首先安装Python、Firefox和一个Python包管理器，然后使用Python包管理器安装Selenium Python包。它还下载了Selenium用于控制Firefox的“驱动”二进制文件。然后启动Python
    REPL，并使用Selenium库创建Firefox实例。
- en: For simplicity, this will only cover the xhost route—to go the Xauthority route,
    you’ll need to create a home directory for the user so Firefox has somewhere to
    save its profile settings.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，这里只涵盖xhost路径——要选择Xauthority路径，您需要为用户创建一个家目录，以便Firefox有地方保存其配置文件设置。
- en: Listing 8.9\. Installing the Selenium requirements and starting a browser
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9\. 安装Selenium需求并启动浏览器
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you may have noticed, Firefox has launched and appeared on your screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，Firefox已经启动并出现在您的屏幕上。
- en: 'You can now experiment with Selenium. An example session running against GitHub
    follows—you’ll need a basic understanding of CSS selectors to understand what’s
    going on here. Note that websites frequently change, so this particular snippet
    may need modifying to work correctly:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以尝试使用Selenium。以下是一个针对GitHub的示例会话——您需要了解CSS选择器的基本知识才能理解这里发生的事情。请注意，网站经常更改，因此这个特定的片段可能需要修改才能正确工作：
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The details here aren’t important, though you can get an idea of what’s going
    on by switching to Firefox between commands—we’re navigating to the docker-in-practice
    organization on GitHub, and clicking the organization link. The main takeaway
    is that we’re writing commands in Python in our container and seeing them take
    effect in the Firefox window running inside the container, but visible on the
    desktop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里详细的内容并不重要，尽管您可以通过在命令之间切换到Firefox来了解正在发生的事情——我们正在导航到GitHub上的docker-in-practice组织，并点击组织链接。主要的收获是我们正在容器中用Python编写命令，并看到它们在容器内运行的Firefox窗口中生效，但它们在桌面上可见。
- en: This is great for debugging tests you write, but how would you integrate them
    into a CI pipeline with the same Docker image? A CI server typically doesn’t have
    a graphical display, so you need to make this work without mounting your own X
    server socket. But Firefox still needs an X server to run on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试你编写的测试非常棒，但你是如何将它们集成到具有相同Docker镜像的CI管道中的呢？CI服务器通常没有图形显示，所以你需要在不挂载自己的X服务器套接字的情况下使它工作。但Firefox仍然需要一个X服务器来运行。
- en: There’s a useful tool created for situations like this called xvfb, which pretends
    to have an X server running for applications to use, but it doesn’t require a
    monitor.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的工具叫做xvfb，它模拟了一个X服务器的运行，供应用程序使用，但不需要显示器。
- en: 'To see how this works, we’ll install xvfb, commit the container, tag it as
    `selenium`, and create a test script:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这是如何工作的，我们将安装xvfb，提交容器，将其标记为`selenium`，并创建一个测试脚本：
- en: Listing 8.10\. Creating a Selenium test script
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.10\. 创建Selenium测试脚本
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the subtle difference in the assignment of the `dlink` variable (indexing
    to position `99` rather than `0`). By attempting to get the hundredth result containing
    the text “Docker in Practice”, you’ll trigger an error, which will cause the Docker
    container to exit with a nonzero status and trigger failures in the CI pipeline.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`dlink`变量赋值的微妙差异（索引位置为`99`而不是`0`）。通过尝试获取包含文本“Docker in Practice”的第100个结果，你会触发一个错误，这将导致Docker容器以非零状态退出，并触发CI管道中的失败。
- en: 'Time to try it out:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试一下了：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You’ve run a self-removing container that executes the Python test script running
    under a virtual X server. As expected, it failed and returned a nonzero exit code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经运行了一个自我删除的容器，它在一个虚拟X服务器下执行Python测试脚本。不出所料，它失败了，并返回了一个非零退出代码。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `sh -c "command string here"` is an unfortunate result of how Docker treats
    `CMD` values by default. If you built this image with a Dockerfile, you’d be able
    to remove the `sh -c` and make `xvfb-run -s '-screen 0 1024x768x24 -extension
    RANDR'` the entrypoint, allowing you to pass the test command as image arguments.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`sh -c "command string here"`是Docker默认处理`CMD`值的不幸结果。如果你用Dockerfile构建了这个镜像，你就可以移除`sh
    -c`，并将`xvfb-run -s ''-screen 0 1024x768x24 -extension RANDR''`作为entrypoint，这样你就可以通过镜像参数传递测试命令。'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Docker is a flexible tool and can be put to some initially surprising uses (graphical
    apps in this case). Some people run *all* of their graphical apps inside Docker,
    including games!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个灵活的工具，可以用于一些最初令人惊讶的用途（在这种情况下是图形应用程序）。有些人甚至将所有图形应用程序都在Docker中运行，包括游戏！
- en: We wouldn’t go that far ([technique 40](kindle_split_015.xhtml#ch05sb13) does
    look at doing this for at least your developer tools) but we’ve found that re-examining
    assumptions about Docker can lead to some surprising use cases. For example, [appendix
    A](kindle_split_030.xhtml#app01) talks about running graphical Linux applications
    on Windows after installing Docker for Windows.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会走那么远（[技术40](kindle_split_015.xhtml#ch05sb13)确实考虑了至少为你的开发工具做这件事），但我们发现重新审视对Docker的假设可以导致一些令人惊讶的使用案例。例如，[附录A](kindle_split_030.xhtml#app01)讨论了在安装Docker
    for Windows后，在Windows上运行图形Linux应用程序。
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.3\. Containerizing your CI process
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 容器化你的CI流程
- en: Once you have a consistent development process across teams, it’s important
    to also have a consistent build process. Randomly failing builds defeat the point
    of Docker.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在团队间建立了一致的开发流程，也重要的是要有一个一致的建设流程。随机失败的构建会抵消Docker的作用。
- en: As a result, it makes sense to *containerize* your entire CI process. This not
    only makes sure your builds are repeatable, it allows you to move your CI process
    anywhere without fear of leaving some vital piece of configuration behind (likely
    discovered with much frustration later).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将整个CI流程容器化是有意义的。这不仅确保了你的构建是可重复的，还允许你将CI流程移动到任何地方，而不用担心会遗漏一些重要的配置（很可能会在后来的沮丧中找到）。
- en: In these techniques, we’ll use Jenkins (as this is the most widely used CI tool),
    but the same techniques should apply to other CI tools. We don’t assume a great
    deal of familiarity with Jenkins here, but we won’t cover setting up standard
    tests and builds. That information isn’t essential to the techniques here.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些技术中，我们将使用Jenkins（因为这是最广泛使用的CI工具），但同样的技术也适用于其他CI工具。我们这里不假设对Jenkins有很高的熟悉度，但也不会涵盖设置标准测试和构建的内容。这些信息对这里的技术不是必需的。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Running the Jenkins master within a Docker container**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Docker容器中运行Jenkins主节点**'
- en: Putting the Jenkins master inside a container doesn’t have as many benefits
    as doing the same for a slave (see the next technique), but it does give you the
    normal Docker win of immutable images. We’ve found that being able to commit known-good
    master configurations and plugins eases the burden of experimentation significantly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将Jenkins主节点放在容器内并不像为从节点做同样的事情那样有那么多好处（参见下一技术），但它确实提供了不可变镜像的正常Docker优势。我们发现，能够提交已知良好的主节点配置和插件，可以显著减轻实验的负担。
- en: '**PROBLEM**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a portable Jenkins server.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个可移植的Jenkins服务器。
- en: '**SOLUTION**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the official Jenkins Docker image to run your server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用官方Jenkins Docker镜像来运行你的服务器。
- en: Running Jenkins within a Docker container gives you some advantages over a straightforward
    host install. Cries of “Don’t touch my Jenkins server configuration!” or, even
    worse, “Who touched my Jenkins server?” aren’t unheard of in our office, and being
    able to clone the state of a Jenkins server with a `docker export` of the running
    container to experiment with upgrades and changes helps silence these complaints.
    Similarly, backups and porting become easier.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker容器中运行Jenkins为你提供了比直接主机安装更多的优势。在我们办公室，经常听到“别动我的Jenkins服务器配置！”或者更糟糕的是，“谁动了我的Jenkins服务器？”的抱怨，而能够通过`docker
    export`运行中的容器状态来克隆Jenkins服务器的状态，以便进行升级和更改的实验，有助于平息这些抱怨。同样，备份和迁移也变得更容易。
- en: In this technique, we’ll take the official Jenkins Docker image and make a few
    changes to facilitate some later techniques that require the ability to access
    the Docker socket, like doing a Docker build from Jenkins.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将使用官方的Jenkins Docker镜像并进行一些修改，以方便后续需要访问Docker套接字的技术，例如从Jenkins中执行Docker构建。
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Jenkins-related examples from this book are available on GitHub: `git clone
    https://github.com/docker-in-practice/jenkins.git`.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的Jenkins相关示例可在GitHub上找到：`git clone https://github.com/docker-in-practice/jenkins.git`。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This Jenkins image and its `run` command will be used as the server in Jenkins-related
    techniques in this book.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的Jenkins相关技术将使用此Jenkins镜像及其`run`命令作为服务器。
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Building the server**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建服务器**'
- en: 'We’ll first prepare a list of plugins we want for the server and place it in
    a file called jenkins_plugins.txt:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先准备一个我们想要的服务器插件列表，并将其放置在一个名为jenkins_plugins.txt的文件中：
- en: '[PRE25]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This very short list consists of the Jenkins’ Swarm plugin (no relation to Docker
    Swarm), which we’ll use in a later technique.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常短的列表包括Jenkins的Swarm插件（与Docker Swarm无关），我们将在后续技术中使用它。
- en: The following listing shows the Dockerfile for building the Jenkins server.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了构建Jenkins服务器的Dockerfile。
- en: Listing 8.11\. Jenkins server build
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.11\. Jenkins服务器构建
- en: '[PRE26]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Uses the official Jenkins image as a base**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用官方Jenkins镜像作为基础**'
- en: '***2*** **Copies a list of plugins to install**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **复制要安装的插件列表**'
- en: '***3*** **Runs the plugins into the server**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将插件运行到服务器中**'
- en: '***4*** **Switches to the root user and removes the plugins file**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **切换到root用户并删除插件文件**'
- en: '***5*** **Adds the Docker group to the container with the same group ID as
    your host machine (the number may differ for you)**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将具有与主机机器相同组ID的Docker组添加到容器中（你的数字可能不同）**'
- en: '***6*** **Switches back to the Jenkins user in the container**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **切换回容器中的Jenkins用户**'
- en: No `CMD` or `ENTRYPOINT` instruction is given because we want to inherit the
    startup command defined in the official Jenkins image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 没有给出`CMD`或`ENTRYPOINT`指令，因为我们希望继承官方Jenkins镜像中定义的启动命令。
- en: 'The group ID for Docker may be different on your host machine. To see what
    the ID is for you, run this command to see the local group ID:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在你的主机机器上的组ID可能不同。要查看你的ID，请运行以下命令以查看本地组ID：
- en: '[PRE27]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Replace the value if it differs from 999.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不同，请替换该值。
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: The group ID must match on the Jenkins server environment and your slave environment
    if you plan to run Docker from within the Jenkins Docker container. There will
    also be a potential portability issue if you choose to move the server (you’d
    encounter the same issue on a native server install). Environment variables won’t
    help here by themselves, as the group needs to be set up at build time rather
    than being dynamically configured.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在Jenkins Docker容器内运行Docker，Jenkins服务器环境和你的从节点环境中的组ID必须匹配。如果你选择移动服务器（在本地服务器安装中会遇到相同的问题），也可能存在潜在的便携性问题。环境变量本身无法帮助解决这个问题，因为组需要在构建时设置，而不是动态配置。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To build the image in this scenario, run this command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在此场景下构建镜像，请运行以下命令：
- en: '[PRE28]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Running the server**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行服务器**'
- en: 'Now you can run the server under Docker with this command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用此命令在Docker下运行服务器：
- en: '[PRE29]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Opens up the Jenkins server port to the host’s port 8080**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将Jenkins服务器端口8080打开到主机**'
- en: '***2*** **If you want to attach Jenkins “build slave” servers, port 50000 needs
    to be open on the container.**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果您想附加Jenkins“构建从属节点”服务器，容器上需要打开50000端口。**'
- en: '***3*** **Mounts the Docker socket so you can interact with the Docker daemon
    from within the container**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **挂载Docker套接字，以便您可以从容器内与Docker守护进程交互**'
- en: '***4*** **Mounts the Jenkins application data to the host machine /tmp so that
    you don’t get file permission errors. If you’re using this in production, look
    at running it mounting a folder that’s writeable by any user.**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将Jenkins应用程序数据挂载到主机机器/tmp，这样您就不会遇到文件权限错误。如果您在生产环境中使用此功能，请考虑运行它时挂载一个任何用户都可写入的文件夹。**'
- en: '***5*** **Runs the server as a daemon**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **以守护进程模式运行服务器**'
- en: If you access http://localhost:8080, you’ll see the Jenkins configuration interface—follow
    the process to your linking, probably using `docker exec` (described in [technique
    12](kindle_split_013.xhtml#ch03sb03)) to retrieve the password you’ll be prompted
    for at the first step.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问http://localhost:8080，您将看到Jenkins配置界面——按照流程进行，可能需要使用`docker exec`（在[技术12](kindle_split_013.xhtml#ch03sb03)中描述）来检索在第一步中提示的密码。
- en: Once complete, your Jenkins server will be ready to go, with your plugins already
    installed (along with some others, depending on the options you selected during
    the setup process). To check this, go to Manage Jenkins > Manage Plugins > Installed,
    and look for Swarm to verify that it’s installed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，您的Jenkins服务器将准备就绪，您的插件已经安装（以及一些其他插件，具体取决于您在设置过程中选择的选项）。要检查此，请转到“管理Jenkins”>“管理插件”>“已安装”，并查找Swarm以验证它是否已安装。
- en: '**DISCUSSION**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You’ll see that we’ve mounted the Docker socket with this Jenkins master as
    we did in [technique 45](kindle_split_016.xhtml#ch06sb06), providing access to
    the Docker daemon. This allows you to perform Docker builds with the built-in
    master slave by running the containers on the host.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们像在[技术45](kindle_split_016.xhtml#ch06sb06)中做的那样，将Docker套接字挂载到这个Jenkins主节点上，从而提供对Docker守护进程的访问。这允许您通过在主机上运行容器来使用内置的主从节点执行Docker构建。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The code for this technique and related ones is available on GitHub at [https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术及相关技术的代码可在GitHub上找到：[https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins)。
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Containing a complex development environment**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含复杂开发环境**'
- en: Docker’s portability and lightweight nature make it an obvious choice for a
    CI slave (a machine the CI master connects to in order to carry out builds). A
    Docker CI slave is a step change from a VM slave (and is even more of a leap from
    bare-metal build machines). It allows you to perform builds on a multitude of
    environments with a single host, to quickly tear down and bring up clean environments
    to ensure uncontaminated builds, and to use all your familiar Docker tooling to
    manage your build environments.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的可移植性和轻量级特性使其成为CI从属节点（CI主节点连接以执行构建的机器）的明显选择。Docker CI从属节点是VM从属节点（甚至是从裸机构建机器的更大飞跃）。它允许您在单个主机上执行多种环境下的构建，快速拆解和建立干净的环境以确保不受污染的构建，并使用所有熟悉的Docker工具来管理您的构建环境。
- en: Being able to treat the CI slave as just another Docker container is particularly
    interesting. Do you have mysterious build failures on one of your Docker CI slaves?
    Pull the image and try the build yourself.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将CI从属节点视为另一个Docker容器特别有趣。您在某个Docker CI从属节点上遇到神秘的构建失败吗？拉取镜像并尝试自行构建。
- en: '**PROBLEM**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to scale and modify your Jenkins slave.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您想缩放和修改您的Jenkins从属节点。
- en: '**SOLUTION**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker to encapsulate the configuration of your slave in a Docker image,
    and deploy.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker将您的从属节点配置封装在Docker镜像中，并部署。
- en: Many organizations set up a heavyweight Jenkins slave (often on the same host
    as the server), maintained by a central IT function, that serves a useful purpose
    for a time. As time goes on, and teams grow their codebases and diverge, requirements
    grow for more and more software to be installed, updated, or altered so that the
    jobs will run.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织设置了一个重型 Jenkins 从属节点（通常与服务器在同一主机上），由中央 IT 功能维护，在一段时间内发挥了有用的作用。随着时间的推移，团队扩大了代码库并发生了分歧，对安装、更新或更改更多软件的需求也随之增长，以便作业可以运行。
- en: '[Figure 8.3](#ch08fig03) shows a simplified version of this scenario. Imagine
    hundreds of software packages and multiple new requests all giving an overworked
    infrastructure team headaches.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.3](#ch08fig03) 展示了这个场景的简化版本。想象一下，数百个软件包和多个新的请求都给过载的基础设施团队带来了头疼。'
- en: Figure 8.3\. An overloaded Jenkins server
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 过载的 Jenkins 服务器
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique has been constructed to show you the essentials of running a
    Jenkins slave in a container. This makes the result less portable but the lesson
    easier to grasp. Once you understand all the techniques in this chapter, you’ll
    be able to make a more portable setup.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术已被构建来向您展示在容器中运行 Jenkins 从属节点的关键要素。这使得结果不太便携，但更容易掌握。一旦您理解了本章中所有技术，您将能够创建一个更便携的设置。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Stalemate has been known to ensue, because sysadmins may be reluctant to update
    their configuration management scripts for one group of people as they fear breaking
    another’s build, and teams get increasingly frustrated over the slowness of change.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 已知会出现僵局，因为系统管理员可能不愿意更新他们的配置管理脚本，因为他们担心会破坏另一组的构建，而且团队对变化的缓慢越来越感到沮丧。
- en: Docker (naturally) offers a solution by allowing multiple teams to use a base
    image for their own personal Jenkins slave, while using the same hardware as before.
    You can create an image with the required shared tooling on it, and allow teams
    to alter it to meet their own needs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（自然地）通过允许多个团队使用他们自己的 Jenkins 从属节点的基镜像，同时使用之前相同的硬件，提供了一个解决方案。您可以在上面创建包含所需共享工具的镜像，并允许团队根据他们的需求对其进行修改。
- en: Some contributors have uploaded their own reference slaves on the Docker Hub;
    you can find them by searching for “jenkins slave” on the Docker Hub. The following
    listing is a minimal Jenkins slave Dockerfile.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一些贡献者已在 Docker Hub 上上传了他们自己的参考从属节点；您可以通过在 Docker Hub 上搜索“jenkins slave”来找到它们。以下列表是一个最小的
    Jenkins 从属节点 Dockerfile。
- en: Listing 8.12\. Bare-bones Jenkins slave Dockerfile
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 纯粹的 Jenkins 从属节点 Dockerfile
- en: '[PRE30]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Creates the Jenkins slave user and group**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建 Jenkins 从属用户和组**'
- en: '***2*** **Sets the Jenkins user password to “jpass”. In a more sophisticated
    setup, you’d likely want to use other authentication methods.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将 Jenkins 用户密码设置为“jpass”。在更复杂的设置中，您可能希望使用其他认证方法。**'
- en: '***3*** **Installs the required software to function as a Jenkins slave.**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **安装所需的软件以作为 Jenkins 从属节点运行。**'
- en: '***4*** **On startup, outputs the IP address of the host machine from the point
    of view of the container, and starts the SSH server**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在启动时，从容器的角度输出主机的 IP 地址，并启动 SSH 服务器**'
- en: 'Build the slave image, tagging it as `jenkins_slave`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 构建从属节点镜像，标记为 `jenkins_slave`：
- en: '[PRE31]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run it with this command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行它：
- en: '[PRE32]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Jenkins server needs to be running
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Jenkins 服务器需要运行
- en: 'If you don’t have a Jenkins server already running on your host, set one up
    using the previous technique. If you’re in a hurry, run this command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的主机上还没有运行 Jenkins 服务器，请使用之前的技术设置一个。如果您急于完成，请运行以下命令：
- en: '[PRE33]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will make the Jenkins server available at http://localhost:8080 if you’ve
    run it on your local machine. You’ll need to go through the setup process before
    using it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地机器上运行它，这将使 Jenkins 服务器在 http://localhost:8080 上可用。您在使用它之前需要完成设置过程。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you navigate to the Jenkins server, you’ll be greeted with the page in [figure
    8.4](#ch08fig04).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到 Jenkins 服务器，您将看到图 8.4 所示的页面。
- en: Figure 8.4\. The Jenkins homepage
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. Jenkins 主页
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04_alt.jpg)'
- en: You can add a slave by clicking on Build Executor Status > New Node and adding
    the node name as a Permanent Agent, as shown in [figure 8.5](#ch08fig05). Call
    it `mydockerslave`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击“构建执行器状态”>“新建节点”并添加节点名称作为永久代理来添加从属节点，如图 8.5 所示。将其命名为 `mydockerslave`。
- en: Figure 8.5\. Naming a new node page
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 命名新节点页面
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig05_alt.jpg)'
- en: 'Click OK and configure it with these settings, as shown in [figure 8.6](#ch08fig06):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”，并使用这些设置进行配置，如图8.6所示：
- en: Set Remote Root Directory to /home/jenkins_slave.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“远程根目录”设置为/home/jenkins_slave。
- en: Give it a Label of “dockerslave”.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给它一个标签“dockerslave”。
- en: Make sure the Launch Slave Agents Via SSH option is selected.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保选中“通过SSH启动从节点代理”选项。
- en: Set the host to the route IP address seen from within the container (output
    with the `docker run` command earlier).
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机设置为容器内看到的路由IP地址（使用之前的`docker run`命令输出）。
- en: Click Add to add credentials, and set the username to “jenkins_slave” and the
    password to “jpass”. Now select those credentials from the drop-down list.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“添加”以添加凭据，并将用户名设置为“jenkins_slave”，密码设置为“jpass”。现在从下拉列表中选择这些凭据。
- en: Set Host Key Verification Strategy to either Manually Trusted Key Verification
    Strategy, which will accept the SSH key on first connect, or Non Verifying Verification
    Strategy, which will perform no SSH host key checking.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“主机密钥验证策略”设置为手动信任密钥验证策略，这将接受首次连接时的SSH密钥，或者设置为非验证验证策略，这将不执行SSH主机密钥检查。
- en: Click Advanced to expose the Port field, and set it to 2222.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“高级”以显示端口字段，并将其设置为2222。
- en: Click Save.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“保存”。
- en: Figure 8.6\. The Jenkins node settings page
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6. Jenkins节点设置页面
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig06_alt.jpg)'
- en: Now click through to the new slave, and click Launch Slave Agent (assuming this
    doesn’t happen automatically). After a minute you should see that the slave agent
    is marked as online.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击进入新的从节点，并点击“启动从节点代理”（假设这不会自动发生）。一分钟后你应该能看到从节点代理被标记为在线。
- en: Go back to the homepage by clicking on Jenkins at the top left, and click on
    New Item. Create a Freestyle Project called “test”, and under the Build section,
    click Add Build Step > Execute Shell, with the command `echo done`. Scroll up,
    and select Restrict Where Project Can Be Run and enter the Label Expression “dockerslave”.
    You should see that Slaves In Label is set as 1, meaning the job is now linked
    to the Docker slave. Click Save to create the job.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击左上角的Jenkins返回主页，然后点击“新建项目”。创建一个名为“test”的Freestyle项目，在“构建”部分，点击“添加构建步骤”>“执行Shell”，命令为`echo
    done`。向上滚动，并选择“限制项目运行位置”并输入标签表达式“dockerslave”。你应该能看到“标签下的从节点”设置为1，这意味着作业现在已链接到Docker从节点。点击“保存”以创建作业。
- en: 'Click Build Now, and then click the build “#1” link that appears below on the
    left. Then click Console Output, and you should see output like this in the main
    window:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“立即构建”，然后点击左侧出现的构建链接“#1”。然后点击“控制台输出”，你应该在主窗口中看到如下输出：
- en: '[PRE34]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Well done! You’ve successfully created your own Jenkins slave.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经成功创建了你的Jenkins从节点。
- en: Now if you want to create your own bespoke slave, all you need to do is alter
    the slave image’s Dockerfile to your taste, and run that instead of the example
    one.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你想创建自己的定制从节点，你只需要修改从节点镜像的Dockerfile以符合你的口味，然后运行它而不是示例中的那个。
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this technique and related ones is available on GitHub at [https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术及相关技术的代码可在GitHub上找到，链接为[https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins)。
- en: '|  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique walks you down the road of creating a container to act like a
    virtual machine, much like [technique 12](kindle_split_013.xhtml#ch03sb03) but
    with the added complexity of Jenkins integration. One particularly useful strategy
    is to also mount the Docker socket inside the container and install the Docker
    client binary so you can perform Docker builds. See [technique 45](kindle_split_016.xhtml#ch06sb06)
    for information on mounting the Docker socket (for a different purpose) and [appendix
    A](kindle_split_030.xhtml#app01) for installation details.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术引导你创建一个容器来充当虚拟机，类似于[技术12](kindle_split_013.xhtml#ch03sb03)，但增加了Jenkins集成的复杂性。一个特别有用的策略是在容器内挂载Docker套接字并安装Docker客户端二进制文件，以便你可以执行Docker构建。有关挂载Docker套接字（用于不同目的）的信息，请参阅[技术45](kindle_split_016.xhtml#ch06sb06)，有关安装详情，请参阅[附录A](kindle_split_030.xhtml#app01)。
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Scaling your CI with Jenkins’ Swarm plugin**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Jenkins的Swarm插件扩展CI**'
- en: Being able to reproduce environments is a big win, but your build capacity is
    still constrained by the number of dedicated build machines you have available.
    If you want to do experiments on different environments with the newfound flexibility
    of Docker slaves, this may become frustrating. Capacity can also become a problem
    for more mundane reasons—the growth of your team!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 能够重现环境是一个巨大的胜利，但你的构建能力仍然受限于你拥有的专用构建机器的数量。如果你想要利用Docker从节点的新发现灵活性在不同的环境中进行实验，这可能会变得令人沮丧。容量也可能因为更平凡的原因成为问题——你团队的成长！
- en: '**PROBLEM**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want your CI compute to scale up with your development work rate.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的CI计算能力与你的开发工作率同步扩展。
- en: '**SOLUTION**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Jenkins’ Swarm plugin and a Docker Swarm slave to dynamically provision
    Jenkins slaves.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jenkins的Swarm插件和Docker Swarm从节点动态提供Jenkins从节点。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'It’s been mentioned before, but it’s worth repeating here: the Jenkins’ Swarm
    plugin is not at all related to Docker’s Swarm technology. They are two entirely
    unrelated things that happen to use the same word. The fact that they can be used
    together here is pure coincidence.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这之前已经提到过，但在这里重复一遍：Jenkins的Swarm插件与Docker的Swarm技术根本无关。它们是完全无关的两件事，碰巧使用了同一个词。它们可以在这里一起使用纯粹是巧合。
- en: '|  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Many small- to medium-sized businesses have a model for CI where one or more
    Jenkins servers are devoted to supplying the resources required to run Jenkins
    jobs. This is illustrated in [figure 8.7](#ch08fig07).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 许多中小型企业都有一个CI模型，其中一个或多个Jenkins服务器被专门用于提供运行Jenkins作业所需的资源。这如图 8.7 所示。
- en: 'Figure 8.7\. Before: Jenkins server—OK with one dev, but doesn’t scale'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 之前：Jenkins服务器——对一个开发者来说可以，但无法扩展
- en: '![](Images/08fig07_alt.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig07_alt.jpg)'
- en: This works fine for a time, but as the CI processes become more embedded, capacity
    limits are often reached. Most Jenkins workloads are triggered by check-ins to
    source control, so as more developers check in, the workload increases. The number
    of complaints to the ops team then explodes as busy developers impatiently wait
    for their build results.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一段时间内工作得很好，但随着CI流程变得更加嵌入式，容量限制通常会被达到。大多数Jenkins工作负载都是由源控制的提交触发的，因此随着更多开发者的提交，工作负载会增加。当忙碌的开发者不耐烦地等待他们的构建结果时，运营团队收到的投诉数量就会激增。
- en: One neat solution is to have as many Jenkins slaves as there are people checking
    in code, as illustrated in [figure 8.8](#ch08fig08).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整洁的解决方案是拥有与提交代码的人数一样多的Jenkins从节点，如图 8.8 所示。
- en: 'Figure 8.8\. After: compute scales with team'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8\. 之后：计算能力随团队扩展
- en: '![](Images/08fig08_alt.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig08_alt.jpg)'
- en: The Dockerfile shown in [listing 8.13](#ch08ex013) creates an image with the
    Jenkins Swarm client plugin installed, allowing a Jenkins master with the appropriate
    Jenkins Swarm server plugin to connect and run jobs. It begins in the same way
    as the normal Jenkins slave Dockerfile in the last technique.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8.13](#ch08ex013)中显示的Dockerfile创建了一个安装了Jenkins Swarm客户端插件的镜像，允许具有适当Jenkins
    Swarm服务器插件的Jenkins主节点连接并运行作业。它以与上一技术中正常Jenkins从节点Dockerfile相同的方式开始。
- en: Listing 8.13\. Dockerfile
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. Dockerfile
- en: '[PRE35]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1*** **Retrieves the Jenkins Swarm plugin**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检索Jenkins Swarm插件**'
- en: '***2*** **Copies the startup script to the container**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将启动脚本复制到容器中**'
- en: '***3*** **Marks the startup script as executable**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将启动脚本标记为可执行**'
- en: '***4*** **Makes the startup script the default command run**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将启动脚本设置为默认运行的命令**'
- en: The following listing is the startup script copied into the preceding Dockerfile.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是复制到前面Dockerfile中的启动脚本。
- en: Listing 8.14\. startup.sh
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. startup.sh
- en: '[PRE36]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1*** **Determines the IP address of the host**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确定主机的IP地址**'
- en: '***2*** **Uses the host IP as the Jenkins server IP, unless JENKINS_IP was
    set in the environment of the call to this script**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用主机IP作为Jenkins服务器IP，除非在此脚本的调用环境中设置了JENKINS_IP**'
- en: '***3*** **Sets the Jenkins port to 8080 by default**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **默认将Jenkins端口设置为8080**'
- en: '***4*** **Sets the Jenkins label for this slave to “swarm”**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将此从节点的Jenkins标签设置为“swarm”**'
- en: '***5*** **Sets the Jenkins home directory to the jenkins_slave user’s home
    by default**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **默认将Jenkins主目录设置为jenkins_slave用户的家目录**'
- en: '***6*** **Logs the commands run from here as part of the output of the script**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将在此处运行的命令记录为脚本的输出部分**'
- en: '***7*** **Runs the Jenkins Swarm client**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **运行Jenkins Swarm客户端**'
- en: '***8*** **Sets the root directory to the Jenkins home directory**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **将根目录设置为Jenkins主目录**'
- en: '***9*** **Sets the label to identify the client for jobs**'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **设置标签以识别作业客户端**'
- en: '***10*** **Sets the Jenkins server to point the slave at**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **将Jenkins服务器设置为指向从属节点**'
- en: Most of the preceding script sets up and outputs the environment for the Java
    call at the end. The Java call runs the Swarm client, which turns the machine
    on which it’s run into a dynamic Jenkins slave rooted in the directory specified
    in the `-fsroot` flag, running jobs labeled with the `-labels` flag and pointed
    at the Jenkins server specified with the `-master` flag. The lines with `echo`
    just provide some debugging information about the arguments and environment setup.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分前面的脚本设置并输出了Java调用末尾的环境。Java调用运行Swarm客户端，将运行它的机器转换为一个动态的Jenkins从属节点，该节点以`-fsroot`标志指定的目录为根，运行带有`-labels`标志的作业，并指向带有`-master`标志指定的Jenkins服务器。带有`echo`的行仅提供了有关参数和环境设置的调试信息。
- en: 'Building and running the container is a simple matter of running what should
    be the now-familiar pattern:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行容器是一个简单的过程，只需运行现在应该熟悉的模式：
- en: '[PRE37]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `username` and `password` should be an account on your Jenkins instance
    with permission to create slaves—the `admin` account will work, but you can also
    create another account for this purpose.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`username`和`password`应该是具有创建从属节点权限的Jenkins实例上的账户——`admin`账户将工作，但您也可以为此目的创建另一个账户。'
- en: Now that you have a slave set up on this machine, you can run Jenkins jobs on
    it. Set up a Jenkins job as normal, but add `swarm` as a label expression in the
    Restrict Where This Project Can Be Run section (see [technique 67](#ch08sb08)).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在这台机器上设置了一个从属节点，您可以在其上运行Jenkins作业。按照常规设置Jenkins作业，但在“限制此项目可以运行的位置”部分添加`swarm`作为标签表达式（参见[技术67](#ch08sb08)）。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Jenkins jobs can be onerous processes, and it’s quite possible that their running
    will negatively affect the laptop. If the job is a heavy one, you can set the
    labels on jobs and Swarm clients appropriately. For example, you might set a label
    on a job as 4CPU8G and match it to Swarm containers run on 4CPU machines with
    8 GB of memory.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins作业可能是一个繁琐的过程，而且它们运行可能会对笔记本电脑产生负面影响。如果作业很重，您可以适当地设置作业和Swarm客户端的标签。例如，您可能将一个作业的标签设置为4CPU8G，并将其与在4CPU机器上运行且具有8GB内存的Swarm容器匹配。
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This technique gives some indication of the Docker concept. A predictable and
    portable environment can be placed on multiple hosts, reducing the load on an
    expensive server and reducing the configuration required to a minimum.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术给出了一些关于Docker概念的指示。可预测且可移植的环境可以放置在多个主机上，减少昂贵服务器的负载，并将所需的配置减少到最低。
- en: Although this isn’t a technique that can be rolled out without considering performance,
    we think there’s a lot of scope here to turn contributing developers’ computer
    resources into a form of game, increasing efficiency in a development organization
    without needing expensive new hardware.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个不考虑性能就无法推广的技术，但我们认为在这里有很大的空间将贡献开发者的计算机资源转化为一种游戏形式，在不需要昂贵的新硬件的情况下提高开发组织的效率。
- en: '**DISCUSSION**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can automate this process by setting it up as a supervised system service
    on all of your estate’s PCs (see [technique 82](kindle_split_023.xhtml#ch11sb02)).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其设置为所有您地产的PC上的监督系统服务来自动化此过程（参见[技术82](kindle_split_023.xhtml#ch11sb02)）。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this technique and related ones is available on GitHub at [https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术及相关技术的代码可在GitHub上找到，链接为[https://github.com/docker-in-practice/jenkins](https://github.com/docker-in-practice/jenkins)。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Upgrading your containerized Jenkins server safely**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全升级容器化的Jenkins服务器**'
- en: If you’ve used Jenkins for a while in production, you’ll be aware that Jenkins
    frequently publishes updates to its server for security and functionality changes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在生产环境中使用Jenkins有一段时间，您会知道Jenkins经常发布更新以进行安全和功能更改。
- en: On a dedicated, non-dockerized host, this is generally managed for you through
    package management. With Docker, it can get slightly more complicated to reason
    about upgrades, as you’ve likely separated out the context of the server from
    its data.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个专用、非Docker化的主机上，这通常通过软件包管理为您管理。使用Docker，升级的推理可能会稍微复杂一些，因为您可能已经将服务器与其数据分离。
- en: '**PROBLEM**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reliably upgrade your Jenkins server.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望可靠地升级您的Jenkins服务器。
- en: '**SOLUTION**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Run a Jenkins updater image that will handle the upgrade of a Jenkins server.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个Jenkins更新器镜像，该镜像将处理Jenkins服务器的升级。
- en: This technique is delivered as a Docker image composed of a number of parts.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术作为由多个部分组成的 Docker 镜像提供。
- en: First we’ll outline the Dockerfile that builds the image. This Dockerfile draws
    from the library Docker image (which contains a Docker client) and adds a script
    that manages the upgrade.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述构建镜像的 Dockerfile。此 Dockerfile 从库 Docker 镜像（其中包含 Docker 客户端）中提取，并添加一个管理升级的脚本。
- en: The image is run in a Docker command that mounts the Docker items on the host,
    giving it the ability to manage any required Jenkins upgrade.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像在 Docker 命令中运行，将主机上的 Docker 项目挂载，使其能够管理任何所需的 Jenkins 升级。
- en: '**Dockerfile**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**'
- en: We start with the Dockerfile.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Dockerfile 开始。
- en: Listing 8.15\. Dockerfile for Jenkins updater
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. Jenkins 升级器的 Dockerfile
- en: '[PRE38]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **Uses the docker standard library image**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 docker 标准库镜像**'
- en: '***2*** **Adds in the jenkins_updater.sh script (discussed next)**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加 jenkins_updater.sh 脚本（将在下文讨论）**'
- en: '***3*** **Ensures that the jenkins_updater.sh script is runnable**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **确保 jenkins_updater.sh 脚本可执行**'
- en: '***4*** **Sets the default entrypoint for the image to be the jenkins_updater.sh
    script**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将镜像的默认入口点设置为 jenkins_updater.sh 脚本**'
- en: The preceding Dockerfile encapsulates the requirements to back up Jenkins in
    a runnable Docker image. It uses the `docker` standard library image to get a
    Docker client to run within a container. This container will run the script in
    [listing 8.16](#ch08ex016) to manage any required upgrade of Jenkins on the host.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Dockerfile 将备份 Jenkins 的需求封装在一个可执行的 Docker 镜像中。它使用 `docker` 标准库镜像来获取一个 Docker
    客户端在容器中运行。该容器将运行 [列表 8.16](#ch08ex016) 中的脚本，以管理主机上 Jenkins 所需的任何升级。
- en: '|  |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If your docker daemon version differs from the version in the `docker` Docker
    image, you may run into problems. Try to use the same version.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 docker 守护进程版本与 `docker` Docker 镜像中的版本不同，你可能会遇到问题。请尝试使用相同的版本。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**jenkins_updater.sh**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**jenkins_updater.sh**'
- en: This is the shell script that manages the upgrade within the container.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理容器内升级的 shell 脚本。
- en: Listing 8.16\. Shell script to back up and restart Jenkins
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 用于备份和重启 Jenkins 的 Shell 脚本
- en: '[PRE39]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** **This script uses the sh shell (not the /bin/bash shell) because only
    sh is available on the Docker image**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **此脚本使用 sh shell（而不是 /bin/bash shell），因为 Docker 镜像上只有 sh 可用**'
- en: '***2*** **Ensures the script will fail if any of the commands within it fail**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **确保如果脚本中的任何命令失败，则脚本将失败**'
- en: '***3*** **Logs all the commands run in the script to standard output**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将脚本中运行的所有命令记录到标准输出**'
- en: '***4*** **Only fires if “docker pull jenkins” does not output “up to date”**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **仅在“docker pull jenkins”不输出“up to date”时触发**'
- en: '***5*** **When upgrading, begins by stopping the jenkins container**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **升级时，首先停止 Jenkins 容器**'
- en: '***6*** **Once stopped, renames the jenkins container to “jenkins.bak.” followed
    by the time to the minute**'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **停止后，将 Jenkins 容器重命名为“jenkins.bak.”，后面跟着分钟数**'
- en: '***7*** **Copies the Jenkins container image state folder to a backup**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将 Jenkins 容器镜像状态文件夹复制到备份**'
- en: '***8*** **Runs the Docker command to start up Jenkins, and runs it as a daemon**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **运行 Docker 命令启动 Jenkins，并以守护进程方式运行**'
- en: '***9*** **Sets the jenkins container to always restart**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **设置 Jenkins 容器始终重启**'
- en: '***10*** **Mounts the jenkins state volume to a host folder**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **将 Jenkins 状态卷挂载到主机文件夹**'
- en: '***11*** **Gives the container the name “jenkins” to prevent multiples of these
    containers running simultaneously by accident**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **给容器命名为“jenkins”，以防止意外同时运行多个此类容器**'
- en: '***12*** **Publishes the 8080 port in the container to the 8080 port on the
    host**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** **将容器中的 8080 端口映射到主机的 8080 端口**'
- en: '***13*** **Finally, gives the jenkins image name to be run to the docker command**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13*** **最后，将要运行的 Jenkins 镜像名称传递给 Docker 命令**'
- en: The preceding script tries to pull `jenkins` from the Docker Hub with the `docker
    pull` command. If the output contains the phrase “up to date”, the `docker pull
    | grep ...` command returns `true`. But you only want to upgrade when you don’t
    see “up to date” in the output. This is why the `if` statement is negated with
    a `!` sign after the `if`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本尝试使用 `docker pull` 命令从 Docker Hub 拉取 `jenkins`。如果输出包含“up to date”短语，则 `docker
    pull | grep ...` 命令返回 `true`。但只有当输出中没有“up to date”时，你才希望升级。这就是为什么在 `if` 语句后面用
    `!` 符号取反的原因。
- en: The result is that the code in the `if` block is only fired if you downloaded
    a new version of the “latest” Jenkins image. Within this block, the running Jenkins
    container is stopped and renamed. You rename it rather than delete it in case
    the upgrade doesn’t work and you need to reinstate the previous version. Further
    to this rollback strategy, the mount folder on the host containing Jenkins’ state
    is also backed up.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，只有当你下载了“最新”的 Jenkins 图像的新版本时，`if` 块中的代码才会被触发。在这个块中，运行的 Jenkins 容器会被停止并重命名。你选择重命名而不是删除它，以防升级失败，你需要恢复到之前的版本。此外，包含
    Jenkins 状态的主机挂载文件夹也会进行备份。
- en: Finally, the latest-downloaded Jenkins image is started up using the `docker
    run` command.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `docker run` 命令启动最新下载的 Jenkins 图像。
- en: '|  |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may want to change the host mount folder or the name of the running Jenkins
    container based on personal preference.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 根据个人喜好，你可能想要更改主机挂载文件夹或运行中的 Jenkins 容器的名称。
- en: '|  |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You might be wondering how this Jenkins image is connected to the host’s Docker
    daemon. To achieve this, the image is run using the method seen in [technique
    66](#ch08sb07).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这个 Jenkins 图像是如何连接到主机的 Docker 守护进程的。为了实现这一点，使用在 [技术 66](#ch08sb07) 中看到的方法运行图像。
- en: '**The jenkins-updater image invocation**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**jenkins-updater 图像调用**'
- en: 'The following command will perform a Jenkins upgrade, using the image (with
    shell script inside it) that was created earlier:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行 Jenkins 升级，使用之前创建的包含 shell 脚本的图像：
- en: Listing 8.17\. Docker command to run the Jenkins updater
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 运行 Jenkins 更新器的 Docker 命令
- en: '[PRE40]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** **The docker run command**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **docker run 命令**'
- en: '***2*** **Removes the container when it has completed its job**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **容器完成其工作后删除容器**'
- en: '***3*** **Runs the container in the background**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在后台运行容器**'
- en: '***4*** **Mounts the host’s docker daemon folder to the container**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将主机上的 docker 守护进程文件夹挂载到容器中**'
- en: '***5*** **Mounts the host’s docker socket to the container so the docker command
    will work within the container**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将主机上的 docker socket 挂载到容器中，以便在容器内运行 docker 命令**'
- en: '***6*** **Mounts the host’s docker mount folder where the Jenkins data is stored,
    so that the jenkins_updater.sh script can copy the files**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **挂载主机上的 docker 挂载文件夹，其中存储 Jenkins 数据，以便 jenkins_updater.sh 脚本可以复制文件**'
- en: '***7*** **Specifies that the dockerinpractice/jenkins-updater image is the
    image to be run**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **指定 dockerinpractice/jenkins-updater 图像是将要运行的图像**'
- en: '**Automating the upgrade**'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化升级**'
- en: The following one-liner makes it easy to run within a crontab. We run this on
    our home servers.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行命令使得在 crontab 中运行变得容易。我们在我们的家用服务器上运行这个命令。
- en: '[PRE41]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding command is all on one line because crontab does not ignore newlines
    if there is a backslash in front in the way that shell scripts do.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令都在一行中，因为 crontab 如果前面有反斜杠，不会忽略换行符，这与 shell 脚本的行为不同。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The end result is that a single crontab entry can safely manage the upgrade
    of your Jenkins instance without you having to worry about it.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，单个 crontab 条目可以安全地管理 Jenkins 实例的升级，而无需你担心。
- en: The task of automating the cleanup of old backed-up containers and volume mounts
    is left as an exercise for the reader.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 自动清理旧备份容器和卷挂载的任务留作读者的练习。
- en: '**DISCUSSION**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique exemplifies a few things we come across throughout the book,
    which can be applied in similar contexts to situations other than Jenkins.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了我们在整本书中遇到的一些事情，这些事情可以应用于除了 Jenkins 之外的类似情境。
- en: First, it uses the core `docker` image to communicate with the Docker daemon
    on the host. Other portable scripts might be written to manage Docker daemons
    in other ways. For example, you might want to write scripts to remove old volumes,
    or to report on the activity on your daemon.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它使用核心 `docker` 图像与主机上的 Docker 守护进程通信。其他可移植脚本可能被编写来以其他方式管理 Docker 守护进程。例如，你可能想要编写脚本来删除旧卷，或者报告守护进程的活动。
- en: More specifically, the `if` block pattern could be used to update and restart
    other images when a new one is available. It’s not uncommon for images to be updated
    for security reasons or to make minor upgrades.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`if` 块模式可以用来在可用新图像时更新和重启其他图像。出于安全原因或进行小幅度升级而更新图像并不罕见。
- en: If you’re concerned with difficulties in upgrading versions, it’s also worth
    pointing out that you need not take the “latest” image tag (which this technique
    does). Many images have different tags that track different version numbers. For
    example, your image `exampleimage` might have an `exampleimage:latest` tag, as
    well as `example-image:v1.1` and `exampleimage:v1` tags. Any of these might be
    updated at any time, but the `:v1.1` tag is less likely to move to a new version
    than the `:latest` tag. The `:latest` tag could move to the same version as a
    new `:v1.2` tag (which might require steps to upgrade) or even a `:v2.1` tag,
    where the new major version `2` indicates a change more likely to be disruptive
    to any upgrade process.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您担心升级版本时的困难，也值得指出的是，您不需要采取“最新”的镜像标签（这项技术就是这样做的）。许多镜像有不同的标签，跟踪不同的版本号。例如，您的镜像`exampleimage`可能有一个`exampleimage:latest`标签，以及`example-image:v1.1`和`exampleimage:v1`标签。这些标签中的任何一个都可能随时更新，但`:v1.1`标签不太可能移动到新的版本，而`:latest`标签则更有可能移动到新的版本，比如与新的`:v1.2`标签相同（可能需要升级步骤）或甚至`:v2.1`标签，其中新的主要版本`2`表明可能对任何升级过程造成更大的破坏。
- en: This technique also outlines a rollback strategy for Docker upgrades. The separation
    of container and data (using volume mounts) can create tension about the stability
    of any upgrade. By retaining the old container and a copy of the old data at the
    point where the service was working, it’s easier to recover from failure.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术还概述了Docker升级的回滚策略。通过使用卷挂载将容器和数据分离可能会对任何升级的稳定性造成紧张。通过保留在服务正常工作时的旧容器和旧数据的副本，更容易从故障中恢复。
- en: '**Database upgrades and Docker**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库升级和Docker**'
- en: Database upgrades are a particular context in which stability concerns are germane.
    If you want to upgrade your database to a new version, you have to consider whether
    the upgrade requires a change to the data structures and storage of the database’s
    data. It’s not enough to run the new version’s image as a container and expect
    it to work. It gets a bit more complicated if the database is smart enough to
    know which version of the data it’s seeing and can perform the upgrade itself
    accordingly. In these cases, you might be more comfortable upgrading.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库升级是一个特别的环境，其中稳定性问题至关重要。如果您想将数据库升级到新版本，您必须考虑升级是否需要更改数据库数据结构和存储。仅仅运行新版本的镜像作为容器并期望它工作是不够的。如果数据库足够智能，知道它看到的数据版本并可以相应地进行升级，那么情况会变得更加复杂。在这些情况下，您可能会更愿意进行升级。
- en: Many factors feed into your upgrade strategy. Your app might tolerate an optimistic
    approach (as you see here in the Jenkins example) that assumes everything will
    be OK, and prepares for failure when (not if) it occurs. On the other hand, you
    might demand 100% uptime and not tolerate failure of any kind. In such cases,
    a fully tested upgrade plan and a deeper knowledge of the platform than running
    `docker pull` is generally desired (with or without the involvement of Docker).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 许多因素会影响您的升级策略。您的应用程序可能可以容忍乐观的方法（正如您在这里看到的Jenkins示例），假设一切都会顺利，并在（不是如果）发生故障时做好准备。另一方面，您可能要求100%的可用性，并且不能容忍任何类型的故障。在这种情况下，通常需要一个经过充分测试的升级计划，并且比仅运行`docker
    pull`更深入地了解平台（无论是否涉及Docker）。
- en: 'Although Docker doesn’t eliminate the upgrade problem, the immutability of
    versioned images can make it simpler to reason about them. Docker can also help
    you prepare for failure in two ways: backing up state in host volumes, and making
    testing predictable state easier. The hit you take in managing and understanding
    what Docker is doing can give you more control over and certainty about the upgrade
    process.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker不能消除升级问题，但版本化镜像的不可变性可以使推理它们变得更加简单。Docker还可以通过两种方式帮助您为故障做准备：在主机卷中备份状态，并使测试可预测状态变得更容易。您在管理和理解Docker所做之事时付出的代价可以给您在升级过程中带来更多的控制和确定性。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use the Docker Hub workflow to automatically trigger builds on code
    changes.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Docker Hub工作流程在代码更改时自动触发构建。
- en: Builds can be sped up significantly by using eatmydata and package caches.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用eatmydata和包缓存可以显著加快构建速度。
- en: Builds can also be sped up by using proxy caches for external artifacts such
    as system packages.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用代理缓存外部工件（如系统包）可以加快构建速度。
- en: You can run GUI tests (like Selenium) inside Docker.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Docker内部运行GUI测试（如Selenium）。
- en: Your CI platform (such as Jenkins) can itself be run from a container.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的CI平台（如Jenkins）本身也可以从容器中运行。
- en: A Docker CI slave lets you keep complete control over your environment.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker CI从属节点让你可以完全控制你的环境。
- en: You can farm out build processes to your whole team using Docker and Jenkins’
    Swarm plugin.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Docker和Jenkins的Swarm插件将构建过程外包给整个团队。
- en: 'Chapter 9\. Continuous delivery: A perfect fit for Docker principles'
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 持续交付：与Docker原则完美契合
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The Docker contract between dev and ops
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者和运维之间的Docker合同
- en: Taking manual control over build availability across environments
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同环境之间手动控制构建可用性
- en: Moving builds between environments over low-bandwidth connections
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在低带宽连接之间移动构建
- en: Centrally configuring all containers in an environment
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境中集中配置所有容器
- en: Achieving zero-downtime deployment with Docker
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker实现零停机时间部署
- en: '|  |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once you’re confident that all of your builds are being quality-checked with
    a consistent CI process, the logical next step is to start looking at deploying
    every good build to your users. This goal is known as continuous delivery (CD).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确信所有的构建都在一致的CI过程中进行了质量检查，下一步合乎逻辑的做法就是开始考虑将每个好的构建部署给用户。这个目标被称为持续交付（CD）。
- en: In this chapter we’ll refer to your “CD pipeline”—the process your build goes
    through after it comes out of your “CI pipeline.” The dividing line can sometimes
    be blurred, but think of the CD pipeline as starting when you have a final image
    that has passed your initial tests during the build process. [Figure 9.1](#ch09fig01)
    demonstrates how the image might progress through a CD pipeline until it (hopefully)
    reaches production.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提到你的“CD管道”——你的构建在“CI管道”之后所经历的过程。有时这条分界线可能会变得模糊，但将CD管道视为当你有一个在构建过程中通过初始测试的最终镜像时开始。图9.1[图9.1](#ch09fig01)展示了镜像可能如何通过CD管道直到（希望）达到生产。
- en: Figure 9.1\. A typical CD pipeline
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 典型的CD管道
- en: '![](Images/09fig01.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig01.jpg)'
- en: It’s worth repeating that last point—the image that comes out of CI should be
    final and unmodified throughout your CD process! Docker makes this easy to enforce
    with immutable images and encapsulation of state, so using Docker takes you one
    step down the CD road already.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重复的是，最后一点——CI输出的镜像应该是最终的，并且在CD过程中不应被修改！Docker通过不可变镜像和状态封装使这一点变得容易执行，因此使用Docker已经让你在CD道路上前进了一步。
- en: When this chapter is done, you’ll fully understand why Docker’s immutability
    makes it a perfect partner for your CD strategy. In this way, Docker can be a
    key enabler for any DevOps strategy in any organization.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 当本章完成后，你将完全理解为什么Docker的不可变性使其成为你的CD策略的完美伙伴。通过这种方式，Docker可以成为任何组织中任何DevOps策略的关键推动者。
- en: 9.1\. Interacting with other teams in the CD pipeline
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 与CD管道中的其他团队互动
- en: First we’re going to take a little step back and look at how Docker changes
    the relationship between development and operations.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将稍微退后一步，看看Docker如何改变开发和运维之间的关系。
- en: Some of the biggest challenges in software development aren’t technical—splitting
    people up into teams based on their roles and expertise is a common practice,
    yet this can result in communication barriers and insularity. Having a successful
    CD pipeline requires involvement from the teams at all stages of the process,
    from development to testing to production. Having a single reference point for
    all teams can help ease this interaction by providing structure.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的一些最大挑战并非技术性的——根据角色和专长将人们分成团队是一种常见做法，但这也可能导致沟通障碍和孤立。拥有一个成功的CD管道需要所有团队在流程的所有阶段都参与进来，从开发到测试再到生产。为所有团队提供一个单一参考点可以通过提供结构来帮助缓解这种互动。
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The Docker contract: Reducing friction**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker合同：减少摩擦**'
- en: One of Docker’s aims is to allow easy expression of inputs and outputs as they
    relate to a container that contains a single application. This can provide clarity
    when working with other people—communication is a vital part of collaboration,
    and understanding how Docker can ease things by providing a single reference point
    can help you win over Docker unbelievers.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的一个目标是可以轻松地表达输入和输出，这些输入和输出与包含单个应用程序的容器相关。这可以在与其他人合作时提供清晰性——沟通是协作的重要组成部分，了解Docker如何通过提供一个单一参考点来简化事情，可以帮助你赢得Docker怀疑者。
- en: '**PROBLEM**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want cooperating teams’ deliverables to be clean and unambiguous, reducing
    friction in your delivery pipeline.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望合作团队的交付成果清晰且无歧义，以减少你的交付管道中的摩擦。
- en: '**SOLUTION**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the *Docker contract* to facilitate clean deliverables between teams.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Docker合约**来促进团队之间的清晰交付。
- en: As companies scale, they frequently find that the flat, lean organization they
    once had, in which key individuals “knew the whole system,” gives way to a more
    structured organization within which different teams have different responsibilities
    and competencies. We’ve seen this firsthand in the organizations we’ve worked
    at.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 随着公司的规模扩大，他们经常发现，他们曾经拥有的扁平、精简的组织结构，其中关键人物“了解整个系统”，转变为一个更加结构化的组织，其中不同的团队有不同的责任和能力。我们在我们工作的组织中亲眼目睹了这一点。
- en: If technical investment isn’t made, friction can arise as growing teams deliver
    to each other. Complaints of increasing complexity, “throwing the release over
    the wall,” and buggy upgrades all become familiar. Cries of “Well, it works on
    our machine!” will increasingly be heard, to the frustration of all concerned.
    [Figure 9.2](#ch09fig02) gives a simplified but representative view of this scenario.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行技术投资，随着团队之间的交付，摩擦可能会产生。关于日益复杂的系统、将发布版本“扔过墙”以及有缺陷的升级的抱怨变得司空见惯。越来越多的“嗯，在我们的机器上它运行得很好！”的叫声将引起所有相关人员的挫败感。[图9.2](#ch09fig02)提供了一个简化的但具有代表性的场景视图。
- en: 'Figure 9.2\. Before: a typical software workflow'
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 之前：典型的软件工作流程
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig02_alt.jpg)'
- en: The workflow in [figure 9.2](#ch09fig02) has a number of problems that may well
    look familiar to you. They all boil down to the difficulties of managing state.
    The test team might test something on a machine that differs from what the operations
    team has set up. In theory, changes to all environments should be carefully documented,
    rolled back when problems are seen, and kept consistent. Unfortunately, the realities
    of commercial pressure and human behavior routinely conspire against this goal,
    and environmental drift is seen.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.2](#ch09fig02)中的工作流程有许多问题，这些可能对你来说很熟悉。它们都归结为管理状态困难。测试团队可能在与运维团队设置不同的机器上测试某些内容。理论上，所有环境的更改都应该被仔细记录，当发现问题时应回滚，并保持一致性。不幸的是，商业压力和人类行为的现实通常与这一目标作对，导致环境漂移。'
- en: Existing solutions to this problem include VMs and RPMs. VMs can be used to
    reduce the surface area of environmental risk by delivering complete machine representations
    to other teams. The downside is that VMs are relatively monolithic entities that
    are difficult for teams to manipulate efficiently. At the other end, RPMs offer
    a standard way of packaging applications that helps define dependencies when rolling
    out software. This doesn’t eliminate configuration management issues, though,
    and rolling out RPMs created by fellow teams is far more error-prone than using
    RPMs that have been battle-tested across the internet.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的现有方案包括虚拟机和RPM。虚拟机可以通过向其他团队提供完整的机器表示来减少环境风险的范围。缺点是虚拟机是相对单一的整体，团队难以高效地操作。在另一端，RPM提供了一种打包应用程序的标准方式，有助于在部署软件时定义依赖关系。但这并没有消除配置管理问题，而且使用由其他团队创建的RPM进行部署比使用在互联网上经过实战检验的RPM更容易出错。
- en: '**The Docker contract**'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker合约**'
- en: What Docker can do is give you a clean line of separation between teams, where
    the Docker image is both the borderline and the unit of exchange. We call this
    the *Docker contract*, illustrated in [figure 9.3](#ch09fig03).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: Docker所能做到的是在团队之间提供一个清晰的分离线，其中Docker镜像既是边界也是交换的单位。我们称之为**Docker合约**，如图9.3所示。
- en: 'Figure 9.3\. After: the Docker contract'
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 之后：Docker合约
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig03_alt.jpg)'
- en: With Docker, the reference point for all teams becomes much cleaner. Rather
    than dealing with sprawling monolithic virtual (or real) machines in unreproducible
    states, all teams are talking about the same code, whether it’s on test, live,
    or development. In addition, there’s a clean separation of data from code, which
    makes it easier to reason about whether problems are caused by variations in data
    or code.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，所有团队参考点变得更加清晰。而不是处理在不可复制的状态下蔓延的单一虚拟（或真实）机器，所有团队都在讨论相同的代码，无论是测试、生产还是开发。此外，数据和代码之间有一个清晰的分离，这使得更容易推断问题是由数据或代码的变化引起的。
- en: Because Docker uses the remarkably stable Linux API as its environment, teams
    that deliver software have far more freedom to build software and services in
    whatever fashion they like, safe in the knowledge that it will run predictably
    in various environments. This doesn’t mean that you can ignore the context in
    which it runs, but it does reduce the risk of environmental differences causing
    issues.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker使用非常稳定的Linux API作为其环境，因此交付软件的团队在以他们喜欢的任何方式构建软件和服务方面拥有更多的自由，同时有信心它在各种环境中可以可预测地运行。这并不意味着你可以忽略它运行的环境，但它确实减少了环境差异导致问题的风险。
- en: Various operational efficiencies result from having this single reference touchpoint.
    Bug reproduction becomes much easier, as all teams are able to describe and reproduce
    issues from a known starting point. Upgrades become the responsibility of the
    team delivering the change. In short, state is managed by those making the change.
    All these benefits greatly reduce the communications overhead and allow teams
    to get on with their jobs. This reduced communications overhead can also help
    encourage moves toward a microservices architecture.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个参考接触点，因此产生了各种操作效率。由于所有团队都能从一个已知的起点描述和重现问题，因此错误重现变得容易得多。升级成为负责交付变更的团队的责任。简而言之，状态由进行变更的人管理。所有这些好处都大大减少了通信开销，并允许团队继续他们的工作。这种减少的通信开销还可以帮助鼓励向微服务架构的转变。
- en: 'This is no merely theoretical benefit: we’ve seen this improvement firsthand
    in a company of over 500 developers, and it’s a frequent topic of discussion at
    Docker technical meetups.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是纯粹的理论优势：我们在一个拥有500多名开发者的公司中亲身体验了这种改进，并且这是Docker技术聚会上的常见讨论话题。
- en: '**DISCUSSION**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique outlines a strategy, useful to keep in mind as you continue throughout
    the book, to identify how other techniques fit into this new world. For example,
    [technique 76](kindle_split_021.xhtml#ch10sb02) describes a way to run a microservices-based
    application in the same cross-container way it would be run on production systems,
    eliminating a source of configuration file tweaking. When you do find yourself
    with external URLs or other unchanging factors on different environments, [technique
    85](kindle_split_023.xhtml#ch11sb05) will step up with information about service
    discovery—a good way to turn a sprawl of configuration files into a single source
    of truth.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术概述了一种策略，在你继续阅读本书的过程中，有助于确定其他技术如何适应这个新世界。例如，[技术76](kindle_split_021.xhtml#ch10sb02)描述了一种以与在生产系统中运行相同的方式运行基于微服务的应用程序的方法，消除了配置文件调整的来源。当你发现自己在不同环境中遇到外部URL或其他不变因素时，[技术85](kindle_split_023.xhtml#ch11sb05)将提供关于服务发现的信息——将配置文件散布变成单一真相来源的好方法。
- en: '|  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.2\. Facilitating deployment of Docker images
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 促进Docker镜像的部署
- en: The first problem when trying to implement CD is moving the outputs of your
    build process to the appropriate location. If you’re able to use a single registry
    for all stages of your CD pipeline, it may seem like this problem has been solved.
    But it doesn’t cover a key aspect of CD.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试实施CD时遇到的第一问题是将构建过程的输出移动到适当的位置。如果你能够为CD管道的所有阶段使用单个注册库，这似乎解决了这个问题。但这也未涵盖CD的一个关键方面。
- en: 'One of the key ideas behind CD is *build promotion*: each stage of a pipeline
    (user acceptance tests, integration tests, and performance tests) can only trigger
    the next stage if the previous one has been successful. With multiple registries
    you can ensure that only *promoted* builds are used by only making them available
    in the next registry when a build stage passes.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: CD背后的一个关键思想是*构建提升*：管道的每个阶段（用户验收测试、集成测试和性能测试）只有在前一个阶段成功后才能触发下一个阶段。使用多个注册库，你只需通过仅在构建阶段通过时在下一个注册库中提供它们，就可以确保只使用*提升的*构建。
- en: We’ll look at a few ways of moving your images between registries, and even
    at a way of sharing Docker objects without a registry.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种在注册库之间移动镜像的方法，甚至探讨一种在没有注册库的情况下共享Docker对象的方法。
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Manually mirroring registry images**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动镜像注册库镜像**'
- en: The simplest image-mirroring scenario is when you have a machine with a high-bandwidth
    connection to both registries. This permits the use of normal Docker functionality
    to perform the image copy.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的镜像镜像场景是你有一个与两个注册库都有高速连接的机器。这允许使用正常的Docker功能来执行镜像复制。
- en: '**PROBLEM**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to copy an image between two registries.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在两个注册库之间复制一个镜像。
- en: '**SOLUTION**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Manually use the standard pulling and pushing commands in Docker to transfer
    the image.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 手动使用Docker的标准拉取和推送命令来传输图片。
- en: 'The solution for this involves:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法包括：
- en: Pulling the image from the registry
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从仓库拉取图片
- en: Retagging the image
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新标记图片
- en: Pushing the retagged image
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送重新标记的图片
- en: If you have an image at test-registry.company.com and you want to move it to
    stage-registry.company.com, the process is simple.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个在test-registry.company.com的镜像，并且你想将其移动到stage-registry.company.com，这个过程很简单。
- en: Listing 9.1\. Transferring an image from a test to a staging registry
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 从测试仓库到预发布仓库传输图片
- en: '[PRE42]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are three important points to note about this process:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中有三个重要点需要注意：
- en: The new image has been force tagged. This means that any older image with the
    same name on the machine (left there for layer-caching purposes) will lose the
    image name, so the new image can be tagged with the desired name.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新镜像已被强制标记。这意味着任何在机器上（为了层缓存目的而留下）的具有相同名称的旧镜像将丢失图片名称，因此新镜像可以用所需的名称进行标记。
- en: All dangling images have been removed. Although layer caching is extremely useful
    for speeding up deployment, leaving unused image layers around can quickly use
    up disk space. In general, old layers are less likely to be used as time passes
    and they become more out-of-date.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有悬挂的图片都已经删除。尽管层缓存对于加快部署速度非常有用，但留下未使用的图片层会迅速耗尽磁盘空间。一般来说，随着时间的推移，旧层被使用的可能性越小，它们就越过时。
- en: You may need to log into your new registry with `docker login`.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要使用`docker login`登录到你的新仓库。
- en: The image is now available in the new registry for use in subsequent stages
    of your CD pipeline.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图片现在可以在新的仓库中使用，用于CD管道的后续阶段。
- en: '**DISCUSSION**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'This technique illustrates a simple point about Docker tagging: the tag itself
    contains information about the registry it belongs to.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术说明了关于Docker标记的一个简单点：标记本身包含有关它所属仓库的信息。
- en: Most of the time this is hidden from users because they normally pull from the
    default registry (the Docker Hub at docker.io). When you’re starting to work with
    registries, this issue comes to the fore because you have to explicitly tag the
    registry with the registry location in order to push it to the correct endpoint.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，用户看不到这个问题，因为他们通常从默认仓库（docker.io上的Docker Hub）拉取。当你开始使用仓库时，这个问题就会显现出来，因为你必须明确地用仓库位置标记仓库，以便将其推送到正确的端点。
- en: '|  |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Delivering images over constrained connections**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过受限连接传输图片**'
- en: Even with layering, pushing and pulling Docker images can be a bandwidth-hungry
    process. In a world of free large-bandwidth connections, this wouldn’t be a problem,
    but sometimes reality forces us to deal with low-bandwidth connections or costly
    bandwidth metering between data centers. In this situation you need to find a
    more efficient way of transferring differences, or the CD ideal of being able
    to run your pipeline multiple times a day will remain out of reach.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有分层，推送和拉取Docker镜像也可能是一个带宽密集型的过程。在一个免费大带宽连接的世界里，这不会是问题，但有时现实迫使我们必须处理数据中心之间的低带宽连接或昂贵的带宽计费。在这种情况下，你需要找到一种更有效的方法来传输差异，否则你每天多次运行管道的理想CD将遥不可及。
- en: The ideal solution is a tool that will reduce the average size of an image so
    it’s even smaller than classic compression methods can manage.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 理想解决方案是一个工具，它将减少镜像的平均大小，使其甚至比经典的压缩方法还要小。
- en: '**PROBLEM**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to copy an image between two machines with a low-bandwidth connection
    between them.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在两个机器之间通过低带宽连接复制一张图片。
- en: '**SOLUTION**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Export the image, split it up, transfer the chunks, and import the recombined
    image on the other end.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 导出镜像，将其分割，传输块，然后在另一端导入重新组合的镜像。
- en: 'To do all this, we must first introduce a new tool: bup. It was created as
    a backup tool with extremely efficient deduplication—*deduplication* being the
    ability to recognize where data is used repeatedly and only store it once. It
    works particularly well on archives containing a number of similar files, which
    is conveniently a format Docker allows you to export images as.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成所有这些，我们首先需要介绍一个新工具：bup。它被创建为一个具有非常高效去重功能的备份工具——去重是指识别数据重复使用的地方，并且只存储一次。它在包含许多相似文件的存档上工作得特别出色，这恰好是Docker允许你导出镜像的格式。
- en: For this technique we’ve created an image called dbup (short for “Docker bup”),
    which makes it easier to use bup to deduplicate images. You can find the code
    behind it at [https://github.com/docker-in-practice/dbup](https://github.com/docker-in-practice/dbup).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项技术，我们创建了一个名为dbup（代表“Docker bup”）的镜像，这使得使用bup去重镜像变得更加容易。您可以在[https://github.com/docker-in-practice/dbup](https://github.com/docker-in-practice/dbup)找到其背后的代码。
- en: As a demonstration, let’s see how much bandwidth we could save when upgrading
    from the ubuntu:14.04.1 image to ubuntu:14.04.2. Bear in mind that in practice
    you’d have a number of layers on top of each of these, which Docker would want
    to completely retransfer after a lower layer change. By contrast, this technique
    would recognize the significant similarities and give you much greater savings
    than you’ll see in the following example.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，让我们看看从ubuntu:14.04.1镜像升级到ubuntu:14.04.2时，我们可以节省多少带宽。请注意，在实际操作中，您会在每个镜像的顶部有一系列层，Docker会在底层层发生变化后完全重新传输这些层。相比之下，这项技术会识别出显著的相似性，并为您节省比以下示例中看到的更多的带宽。
- en: The first step is to pull both of those images so we can see how much is transferred
    over the network.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是拉取这两个镜像，以便我们可以看到通过网络传输了多少内容。
- en: Listing 9.2\. Examining and saving two Ubuntu images
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 检查并保存两个Ubuntu镜像
- en: '[PRE43]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The bottom layer on each image (the `ADD`) is the majority of the size, and
    you can see that the file being added is different, so you can treat the whole
    image size as the amount that would be transferred when pushing the new image.
    Also note that the Docker registry uses gzip compression to transfer layers, so
    we’ve included that in our measurement (instead of taking the size from `docker
    history`). About 65 MB is being transferred in both the initial deployment and
    the subsequent deployment.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像的底层（`ADD`）是大小的主要部分，您可以看到被添加的文件是不同的，因此您可以将其整个镜像大小视为推送新镜像时将传输的量。此外，请注意，Docker注册表使用gzip压缩来传输层，因此我们在测量中包括了这一点（而不是从`docker
    history`获取大小）。在初始部署和后续部署中，都正在传输大约65 MB。
- en: In order to get started, you’ll need two things—a directory to store the pool
    of data bup uses as storage, and the dockerinpractice/dbup image. You can then
    go ahead and add your image to the bup data pool.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，您需要两样东西——一个目录来存储bup用作存储的数据池，以及dockerinpractice/dbup镜像。然后，您可以继续将您的镜像添加到bup数据池中。
- en: Listing 9.3\. Saving two Ubuntu images into the bup data pool
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 将两个Ubuntu镜像保存到bup数据池中
- en: '[PRE44]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Adding the second image to the bup data pool has only increased the size by
    about 20 MB. Assuming you synced the folder to another machine (possibly with
    rsync) after adding ubuntu:14.04.1, syncing the folder again will only transfer
    20 MB (as opposed to the 65 MB before).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 将第二张图片添加到bup数据池中，仅使大小增加了大约20 MB。假设您在添加ubuntu:14.04.1后同步了文件夹到另一台机器（可能使用rsync），再次同步文件夹时，只需传输20
    MB（而不是之前的65 MB）。
- en: You then need to load the image at the other end.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要加载另一端的镜像。
- en: Listing 9.4\. Loading an image from the bup data pool
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 从bup数据池中加载镜像
- en: '[PRE45]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The process for transferring between registries would look something like this:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表之间传输的过程可能看起来像这样：
- en: '`docker pull` on host1'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在host1上执行`docker pull`
- en: '`dbup save` on host1'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在host1上执行`dbup save`
- en: '`rsync` from host1 to host2'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从host1到host2的`rsync`
- en: '`dbup load` on host2'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在host2上执行`dbup load`
- en: '`docker push` on host2'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在host2上执行`docker push`
- en: This technique opens up a number of possibilities that may not have been possible
    previously. For example, you can now rearrange and consolidate layers without
    having to worry about how long it will take to transfer all of the new layers
    over the low-bandwidth connection.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术打开了许多以前可能无法实现的可能性。例如，现在您可以重新排列和合并层，而无需担心通过低带宽连接传输所有新层需要多长时间。
- en: '**DISCUSSION**'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Even when following best practices and adding your application code as the last
    stage, bup may be able to help—it will recognize that most of the code is unchanged
    and only add the difference to the data pool.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 即使遵循最佳实践并在最后阶段添加您的应用程序代码，bup也可能有所帮助——它会识别出大部分代码没有变化，并且只将差异添加到数据池中。
- en: The data pools can be very large, such as database files, and bup will likely
    perform very well (which is useful if you’ve decided to use [technique 77](kindle_split_021.xhtml#ch10sb03)
    with the database inside the container, meaning there’s no volume). This is actually
    somewhat unusual—database exports and backups are typically very efficient to
    incrementally transfer, but the actual on-disk storage of databases can vary significantly
    and occasionally defeat tools like rsync. On top of this, dbup puts a full history
    of your images at your fingertips—there’s no need to store three full copies of
    images to roll back to. You can pull them out of the pool at your leisure. Unfortunately
    there’s currently no way to clean the pool of images you don’t want any more,
    so you’ll probably need to clear the pool every now and again.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 数据池可以非常大，例如数据库文件，bup可能会表现得非常好（如果你已经决定在容器内部使用[技术77](kindle_split_021.xhtml#ch10sb03)，这意味着没有卷）。这实际上有些不寻常——数据库的导出和备份通常非常高效地进行增量传输，但实际的磁盘存储可以有很大差异，有时甚至会使像rsync这样的工具失效。除此之外，dbup将你的镜像的完整历史记录放在你的指尖——无需存储三个完整的镜像副本以进行回滚。你可以随意从池中提取它们。不幸的是，目前还没有方法清理你不再需要的镜像池，所以你可能需要时不时地清理池。
- en: Although you may not see an immediate need for dbup, keep it in mind, in case
    your bandwidth bills start growing.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能目前看不到dbup的即时需求，但请记住它，以防你的带宽账单开始增长。
- en: '|  |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Sharing Docker objects as TAR files**'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**将Docker对象作为TAR文件共享**'
- en: TAR files are a classic method of moving files around on Linux. Docker allows
    you to create TAR files and ship them around manually when there’s no registry
    available and no possibility of setting one up. Here we’re going to show you the
    ins and outs of these commands.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: TAR文件是Linux上移动文件的经典方法。Docker允许你在没有可用注册表且无法设置注册表的情况下创建TAR文件并手动传输。在这里，我们将向您展示这些命令的细节。
- en: '**PROBLEM**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to share images and containers with others, with no available registry.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要与他人共享镜像和容器，但没有可用的注册表。
- en: '**SOLUTION**'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use `docker export` or `docker save` to create TAR file artifacts, and then
    consume them with `docker import` or `docker load` over SSH.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker export` 或 `docker save` 创建TAR文件形式的工件，然后通过SSH使用 `docker import` 或
    `docker load` 消费它们。
- en: The distinctions between the commands can be difficult to grasp if you’re using
    them casually, so let’s take a moment to quickly go over what they do. [Table
    9.1](#ch09table01) outlines the inputs and outputs of the commands.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你随意使用这些命令，区分它们可能很难理解，所以让我们花点时间快速了解一下它们的功能。[表9.1](#ch09table01)概述了这些命令的输入和输出。
- en: Table 9.1\. Export and import vs. save and load
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. 导出和导入与保存和加载
- en: '| **Command** | **Creates?** | **Of what?** | **From what?** |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **创建？** | **什么？** | **从什么？** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| export | TAR file | Container filesystem | Container |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| export | TAR文件 | 容器文件系统 | 容器 |'
- en: '| import | Docker image | Flat filesystem | TAR file |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| import | Docker镜像 | 平坦文件系统 | TAR文件 |'
- en: '| save | TAR file | Docker image (with history) | Image |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| save | TAR文件 | Docker镜像（带有历史记录） | 镜像 |'
- en: '| load | Docker image | Docker image (with history) | TAR file |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| load | Docker镜像 | Docker镜像（带有历史记录） | TAR文件 |'
- en: The first two commands work with flat filesystems. The command `docker export`
    outputs a TAR file of the files that make up the state of the container. As always
    with Docker, the state of running processes isn’t stored—only the files. The command
    `docker import` creates a Docker image—with no history or metadata—from a TAR
    file.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个命令与平坦文件系统一起工作。`docker export` 命令输出构成容器状态的文件TAR文件。像Docker中的常规操作一样，运行中的进程的状态不会存储——只有文件。`docker
    import` 命令从一个TAR文件创建一个没有历史记录或元数据的Docker镜像。
- en: These commands aren’t symmetrical—you can’t create a container from an existing
    container using only `import` and `export`. This asymmetry can be useful because
    it allows you to `docker export` an image to a TAR file, and then `docker import`
    it to “lose” all the layer history and metadata. This is the image-flattening
    approach described in [technique 52](kindle_split_017.xhtml#ch07sb05).
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令不是对称的——你不能仅使用 `import` 和 `export` 从现有的容器创建一个容器。这种不对称性可能很有用，因为它允许你使用 `docker
    export` 将镜像导出到TAR文件，然后使用 `docker import` “丢失”所有层历史记录和元数据。这是[技术52](kindle_split_017.xhtml#ch07sb05)中描述的镜像扁平化方法。
- en: 'If you’re exporting or saving to a TAR file, the file is sent to `stdout` by
    default, so make sure you save it to a file like this:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导出或保存到TAR文件，文件默认发送到 `stdout`，所以请确保你将其保存到如下文件：
- en: '[PRE46]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A TAR file like the one just created can be flung around the network safely
    (though you may want to compress it with `gzip` first), and other people can use
    them to import images intact. They can be sent by email or `scp` if you have access:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 与刚刚创建的TAR文件类似，可以在网络上安全地传输（尽管你可能想先使用`gzip`进行压缩），其他人可以使用它们完整地导入镜像。如果你有权限，可以通过电子邮件或`scp`发送：
- en: '[PRE47]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can take this one step further and deliver images to other users’ Docker
    daemons directly—assuming you have the permission.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更进一步，直接将镜像发送到其他用户的Docker守护进程——前提是你有权限。
- en: Listing 9.5\. Sending an image directly over SSH
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. 通过SSH直接发送镜像
- en: '[PRE48]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1*** **Extracts the Debian version 7.3 image and pipes it to the ssh command**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **提取Debian版本7.3的镜像并将其通过ssh命令管道传输**'
- en: '***2*** **Runs a command on a remote machine, example.com**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在远程机器上运行命令，例如example.com**'
- en: '***3*** **Takes the TAR file it’s given and creates an image with all the history.
    The dash indicates that the TAR file is being delivered over standard input.**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **接受给定的TAR文件并创建包含所有历史的镜像。破折号表示TAR文件是通过标准输入传递的。**'
- en: If you want to discard the history of the image, you can use `import` instead
    of `load`.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想丢弃镜像的历史，可以使用`import`而不是`load`。
- en: Listing 9.6\. Transferring a Docker image directly over SSH, discarding layers
  id: totrans-689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 通过SSH直接传输Docker镜像，丢弃层
- en: '[PRE49]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|  |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike `docker import`, `docker load` doesn’t require a dash at the end to indicate
    that the TAR file is being delivered through standard input.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 与`docker import`不同，`docker load`不需要在末尾添加破折号来指示TAR文件是通过标准输入传递的。
- en: '|  |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You may remember the export and import process from [technique 52](kindle_split_017.xhtml#ch07sb05),
    where you saw how flattening images can be used to remove secrets that may be
    hidden in lower layers. The fact that secrets may be accessible in lower layers
    is worth bearing in mind if you’re transferring images to other people—realizing
    that you deleted your public key on the top image layer but that it’s available
    lower down can be a real hassle, because you should then treat it as compromised
    and change it everywhere.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[技术52](kindle_split_017.xhtml#ch07sb05)中的导出和导入过程，你看到了如何通过扁平化镜像来移除可能隐藏在下层的秘密。如果你将镜像传输给其他人，考虑到秘密可能在下层可访问的事实是值得注意的——意识到你在顶层镜像中删除了公钥，但在下层它仍然可用，可能会带来真正的麻烦，因为你应该将其视为已泄露并更改所有地方。
- en: If you find yourself doing the image transfer in this technique a lot, it may
    be worth putting a little time into [technique 9](kindle_split_011.xhtml#ch02sb10)
    to set up your own registry and make things less ad hoc.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己经常使用这种技术进行镜像传输，可能值得花点时间设置自己的注册表，使事情不那么随意。[技术9](kindle_split_011.xhtml#ch02sb10)。
- en: '|  |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3\. Configuring your images for environments
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 配置你的镜像以适应环境
- en: As mentioned in the introduction to this chapter, one of the keystones of CD
    is the concept of “doing the same thing everywhere.” Without Docker, this would
    mean building a deployment artifact once and using the same one everywhere. In
    a Dockerized world, this means using the same image everywhere.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，持续交付（CD）的一个基石是“在所有地方做同样的事情”的概念。在没有Docker的情况下，这意味着构建一次部署工件并在所有地方使用它。在Docker化的世界中，这意味着在所有地方使用相同的镜像。
- en: But environments aren’t all the same—there may be different URLs for external
    services, for example. For “normal” applications you’d be able to use environment
    variables to solve this problem (with the caveat that they’re not easy to apply
    to numerous machines). The same solution can work for Docker (explicitly passing
    the variables in), but there’s a better way of doing it with Docker that comes
    with some additional benefits.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 但环境并不完全相同——例如，外部服务可能有不同的URL。对于“正常”应用程序，你可以使用环境变量来解决这个问题（前提是它们不容易应用于多台机器）。相同的解决方案也可以用于Docker（明确传递变量），但Docker还有更好的方法来做这件事，并带来一些额外的优势。
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Informing your containers with etcd**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用etcd通知你的容器**'
- en: Docker images are designed so they can be deployed anywhere, but you’ll often
    want to add some extra information after deployment to affect the behavior of
    the application while it’s running. In addition, machines running Docker may need
    to remain unaltered, so you may need an external source of information (making
    environment variables less suitable).
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像被设计成可以在任何地方部署，但部署后你通常会想添加一些额外的信息来影响应用程序运行时的行为。此外，运行Docker的机器可能需要保持不变，因此你可能需要一个外部信息源（这使得环境变量不太适用）。
- en: '**PROBLEM**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You need an external source of configuration when running containers.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器时，您需要一个外部配置源。
- en: '**SOLUTION**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Set up etcd, a distributed key/value store, to hold your container configuration.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 设置etcd，一个分布式键/值存储，以存储您的容器配置。
- en: etcd holds pieces of information and can be part of a multinode cluster for
    resiliency. In this technique you’ll create an etcd cluster to hold your configuration
    and use an etcd proxy to access it.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: etcd存储信息片段，可以是多节点集群的一部分以实现容错。在这个技术中，您将创建一个etcd集群来存储您的配置，并使用etcd代理来访问它。
- en: '|  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Each value held by etcd should be kept small—under 512 KB is a good rule of
    thumb; past this point you should consider doing benchmarking to verify that etcd
    is still performing as you’d expect. This limit is not unique to etcd. You should
    bear it in mind for other key/value stores like Zookeeper and Consul.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: etcd存储的每个值都应该保持较小——小于512 KB是一个很好的经验法则；超过这个点，您应该考虑进行基准测试以验证etcd是否仍然按您期望的方式运行。这个限制不仅适用于etcd。您应该在其他键/值存储（如Zookeeper和Consul）中记住这一点。
- en: '|  |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because etcd cluster nodes need to talk to each other, the first step is to
    identify your external IP address. If you were going to run the nodes on different
    machines, you’d need the external IP for each of them.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 因为etcd集群节点需要相互通信，所以第一步是确定您的外部IP地址。如果您打算在不同的机器上运行节点，您需要每个节点的外部IP地址。
- en: Listing 9.7\. Identifying IP addresses of the local machine
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 确定本地机器的IP地址
- en: '[PRE50]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here we’ve looked for all IPv4 interfaces and excluded LoopBack and Docker.
    The top line (the first IP address on that line) is the one you need, and it represents
    the machine on the local network—try pinging it from another machine if you’re
    not sure.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们查找了所有IPv4接口，并排除了LoopBack和Docker。该列表的第一行（该行上的第一个IP地址）是您需要的，它代表本地网络上的机器——如果您不确定，请从另一台机器上尝试ping它。
- en: We can now get started with the three-node cluster, all running on the same
    machine. Be careful with the following arguments—the ports being exposed and advertised
    change on each line, as do the names of the cluster nodes and containers.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始使用三个节点集群，所有节点都在同一台机器上运行。请注意以下参数——每行中公开和宣传的端口都会改变，集群节点和容器的名称也是如此。
- en: Listing 9.8\. Setting up a three-node etcd cluster
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 设置三个节点的etcd集群
- en: '[PRE51]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1*** **The external IP address of your machine**'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **您的机器的外部IP地址**'
- en: '***2*** **Uses the external IP address of the machine in the cluster definition,
    giving the nodes a way to communicate with others. Because all nodes will be on
    the same host, the cluster ports (for connecting to other nodes) must be different.**'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在集群定义中使用机器的外部IP地址，为节点提供与其他节点通信的方式。因为所有节点都将位于同一主机上，所以集群端口（用于连接到其他节点）必须不同。**'
- en: '***3*** **The port for handling requests from clients**'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **处理客户端请求的端口**'
- en: '***4*** **The port to listen on for talking to other nodes in the cluster,
    corresponding to the ports specified in $CLUSTER**'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **用于与其他集群节点通信的监听端口，对应于$CLUSTER中指定的端口**'
- en: '***5*** **Currently connected nodes in the cluster**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **当前连接到集群的节点**'
- en: You’ve now started up the cluster and have a response from one node. In the
    preceding commands, anything referring to “peer” is controlling how the etcd nodes
    find and talk to each other, and anything referring to “client” defines how other
    applications can connect to etcd.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已启动了集群，并从其中一个节点收到了响应。在前面的命令中，任何提到“对等节点”的内容都是控制etcd节点如何找到并相互通信的方式，而任何提到“客户端”的内容则定义了其他应用程序如何连接到etcd。
- en: Let’s see the distributed nature of etcd in action.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看etcd的分布式特性是如何发挥作用的。
- en: Listing 9.9\. Testing the resilience of an etcd cluster
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.9\. 测试etcd集群的容错能力
- en: '[PRE52]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, you add a key to your etcd2 node and then kill it. But
    etcd has automatically replicated the information to the other nodes and is able
    to provide you with the information anyway. Although the preceding code paused
    for five seconds, etcd will typically replicate in under a second (even across
    different machines). Feel free to `docker start etcd2` now to make it available
    again—any changes you’ve made in the meantime will replicate back to it.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您向您的etcd2节点添加了一个键，然后将其杀死。但etcd已自动将信息复制到其他节点，并且仍然能够提供信息。尽管前面的代码暂停了五秒钟，但etcd通常在不到一秒钟内就会复制（即使是在不同的机器上）。现在您可以自由地`docker
    start etcd2`使其再次可用——在此期间您所做的任何更改都会复制回它。
- en: You can see that the data is still available, but it’s a little unfriendly to
    have to manually choose another node to connect to. Fortunately etcd has a solution
    for this—you can start a node in “proxy” mode, which means it doesn’t replicate
    any data; rather, it forwards the requests to the other nodes.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到数据仍然可用，但手动选择另一个节点来连接有点不方便。幸运的是，etcd有一个解决方案——你可以以“代理”模式启动一个节点，这意味着它不会复制任何数据；相反，它将请求转发到其他节点。
- en: Listing 9.10\. Using an etcd proxy
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.10\. 使用etcd代理
- en: '[PRE53]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This now gives you some freedom to experiment with how etcd behaves when over
    half the nodes are offline.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在让你有了一些自由去实验当超过一半的节点离线时etcd的行为。
- en: Listing 9.11\. Using etcd with more than half the nodes down
  id: totrans-735
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11\. 使用超过一半节点下线的etcd
- en: '[PRE54]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Etcd permits reading but prevents writing when half or more of the nodes are
    not available.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 当一半或更多的节点不可用时，etcd允许读取但阻止写入。
- en: You can now see that it would be possible to start an etcd proxy on each node
    in a cluster to act as an “ambassador container” for retrieving centralized configuration,
    as follows.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到，在集群中的每个节点上启动一个etcd代理作为检索集中配置的“大使容器”是可能的，如下所示。
- en: Listing 9.12\. Using an etcd proxy inside an ambassador container
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.12\. 在大使容器中使用etcd代理
- en: '[PRE55]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: An ambassador is a so-called “Docker pattern” that has some currency among Docker
    users. An ambassador container is placed between your application container and
    some external service and handles the request. It’s similar to a proxy, but it
    has some intelligence baked into it to handle the specific requirements of the
    situation—much like a real-life ambassador.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 大使（ambassador）是一种所谓的“Docker模式”，在Docker用户中有些流行。大使容器被放置在应用程序容器和某些外部服务之间，并处理请求。它类似于代理，但它内置了一些智能来处理特定情况的具体要求——就像现实生活中的大使一样。
- en: '|  |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you have an etcd running in all environments, creating a machine in an
    environment is just a matter of starting it up with a link to an etcd-proxy container—all
    CD builds to the machine will then use the correct configuration for the environment.
    The next technique shows how to use etcd-provided configuration to drive zero-downtime
    upgrades.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在所有环境中运行了etcd，在环境中创建一个机器只需启动它并链接到etcd-proxy容器——然后所有CD构建到该机器都将使用环境的正确配置。下一个技术将展示如何使用etcd提供的配置来驱动零停机时间升级。
- en: '**DISCUSSION**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The ambassador container shown in the previous section draws on the link flag
    introduced in [technique 8](kindle_split_011.xhtml#ch02sb09). As noted there,
    linking has fallen somewhat out of favor in the Docker world, and a more idiomatic
    way to achieve the same thing now is with named containers on a virtual network,
    covered in [technique 80](kindle_split_021.xhtml#ch10sb06).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中展示的大使容器利用了[技术8](kindle_split_011.xhtml#ch02sb09)中引入的链接标志。正如那里所指出的，链接在Docker世界中已经有些不受欢迎，现在实现相同功能的一种更符合习惯的方式是在虚拟网络上的命名容器，这在[技术80](kindle_split_021.xhtml#ch10sb06)中有介绍。
- en: Having a cluster of key/value servers providing a consistent view of the world
    is a big step forward from managing configuration files on many machines, and
    it helps you push toward fulfilling the Docker contract described in [technique
    70](#ch09sb02).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个提供世界一致视图的关键/值服务器集群，比在多台机器上管理配置文件前进了一大步，并帮助你朝着实现[技术70](#ch09sb02)中描述的Docker合同迈进。
- en: '|  |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.4\. Upgrading running containers
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 升级运行中的容器
- en: In order to achieve the ideal of multiple deployments to production every day,
    it’s important to reduce downtime during the final step of the deployment process—turning
    off the old applications and starting up the new ones. There’s no point deploying
    four times a day if the switchover is an hour-long process each time!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现每天多次部署到生产环境的理想，在部署过程的最后一步——关闭旧应用程序并启动新应用程序——减少停机时间非常重要。如果每次切换都是一个小时的流程，那么每天部署四次就没有意义了！
- en: Because containers provide an isolated environment, a number of problems are
    already mitigated. For example, you don’t need to worry about two versions of
    an application using the same working directory and conflicting with each other,
    or about rereading some configuration files and picking up new values without
    restarting using the new code.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器提供了一个隔离的环境，许多问题已经得到了缓解。例如，你不必担心两个版本的应用程序使用相同的工 作目录并相互冲突，或者重新读取某些配置文件并获取新值而不需要重新启动使用新代码。
- en: Unfortunately there are some downsides to this—it’s no longer simple to change
    files in-place, so soft-restarts (required to pick up configuration file changes)
    become harder to achieve. As a result, we’ve found it a best practice to always
    perform the same upgrade process regardless of whether you’re changing a few configuration
    files or thousands of lines of code.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这有一些缺点——不再简单地在原地更改文件，因此软重启（用于获取配置文件更改）变得更加困难。因此，我们发现，无论你是更改几个配置文件还是数千行代码，始终执行相同的升级过程是一种最佳实践。
- en: Let’s look at an upgrade process that will achieve the gold standard of zero-downtime
    deployment for web-facing applications.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个升级过程，它将实现面向 Web 应用程序的零停机时间部署的黄金标准。
- en: '|  |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using confd to enable zero-downtime switchovers**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 confd 实现零停机时间切换**'
- en: Because containers can exist side by side on a host, the simple switchover approach
    of removing a container and starting a new one can be performed in as little as
    a few seconds (and it permits a similarly fast rollback).
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器可以在主机上并排存在，所以移除一个容器并启动一个新的容器的简单切换方法可以在几秒钟内完成（并且它允许快速回滚）。
- en: For most applications, this may well be fast enough, but applications with a
    long startup time or high availability requirements need an alternative approach.
    Sometimes this is an unavoidably complex process requiring special handling with
    the application itself, but web-facing applications have an option you may wish
    to consider first.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序来说，这可能会足够快，但对于启动时间较长或高可用性要求的应用程序，需要另一种方法。有时这可能是一个不可避免地复杂的流程，需要与应用程序本身进行特殊处理，但面向
    Web 的应用程序有一个你可能首先考虑的选项。
- en: '**PROBLEM**'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You need to be able to upgrade web-facing applications with zero downtime.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要能够以零停机时间升级面向 Web 的应用程序。
- en: '**SOLUTION**'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use confd with nginx on your host to perform a two-stage switchover.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主机上使用 confd 与 nginx 结合进行两阶段切换。
- en: Nginx is an extremely popular web server with a crucial built-in ability—it
    can reload configuration files without dropping connections to the server. By
    combining this with confd, a tool that can retrieve information from a central
    datastore (like etcd) and alter configuration files accordingly, you can update
    etcd with the latest settings and watch everything else be handled for you.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 是一个非常受欢迎的 Web 服务器，它具有一个关键内置功能——它可以在不断开服务器连接的情况下重新加载配置文件。通过将其与 confd 结合，这是一个可以从中央数据存储（如
    etcd）检索信息并相应地更改配置文件的工具，你可以更新 etcd 上的最新设置，并观察其他一切为你处理。
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The Apache HTTP server and HAProxy both also offer zero-downtime reloading and
    can be used instead of nginx if you have existing configuration expertise.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: Apache HTTP 服务器和 HAProxy 也都提供零停机时间重新加载，如果你有现有的配置专业知识，可以使用它们代替 nginx。
- en: '|  |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first step is to start an application that will serve as an old application
    that you’ll eventually update. Python comes with Ubuntu and has a built-in web
    server, so we’ll use it as an example.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是启动一个将作为旧应用程序运行的应用程序，你最终会更新它。Python 随 Ubuntu 一起提供，并内置了 Web 服务器，所以我们将用它作为示例。
- en: Listing 9.13\. Starting a simple fileserver in a container
  id: totrans-769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.13\. 在容器中启动简单的文件服务器
- en: '[PRE56]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The HTTP server has started successfully, and we used the filter option of the
    `inspect` command to pull out information about what port on the host is mapped
    to point inside the container.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 服务器已成功启动，我们使用了 `inspect` 命令的过滤器选项来提取有关主机上哪个端口映射到容器内部点的信息。
- en: Now make sure you have etcd running—this technique assumes you’re still in the
    same working environment as the previous technique. This time you’re going to
    use etcdctl (short for “etcd controller”) to interact with etcd (rather than `curl`ing
    etcd directly) for simplicity.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请确保 etcd 正在运行——这个技术假设你仍然在之前技术相同的工作环境中。这次你将使用 etcdctl（简称“etcd 控制器”）与 etcd 交互（而不是直接
    `curl` etcd），以简化操作。
- en: Listing 9.14\. Download and use the etcdctl Docker image
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. 下载并使用 etcdctl Docker 镜像
- en: '[PRE57]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This has downloaded an etcdctl Docker image that we prepared, and it has set
    up an alias to always connect the etcd cluster set up previously. Now start up
    nginx.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这已下载了我们准备好的 etcdctl Docker 镜像，并设置了一个别名，始终连接之前设置的 etcd 集群。现在启动 nginx。
- en: Listing 9.15\. Start an nginx + confd container
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. 启动 nginx + confd 容器
- en: '[PRE58]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is an image we prepared earlier, which uses confd to retrieve information
    from etcd and automatically update configuration files. The parameter that we
    pass tells the container where it can connect to the etcd cluster. Unfortunately
    we haven’t told it where it can find our apps yet, so the logs are filled with
    errors.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前准备的一个镜像，它使用confd从etcd检索信息并自动更新配置文件。我们传递的参数告诉容器它可以连接到哪个etcd集群。不幸的是，我们还没有告诉它在哪里可以找到我们的应用程序，所以日志中充满了错误。
- en: Let’s add the appropriate information to etcd.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在etcd中添加适当的信息。
- en: Listing 9.16\. Demonstrating the auto-configuration of the nginx container
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.16\. 展示nginx容器的自动配置
- en: '[PRE59]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The update to etcd has been read by confd and applied to the nginx configuration
    file, allowing you to visit your simple file server. The `sleep` command is included
    because confd has been configured to check for updates every 10 seconds. Behind
    the scenes, a confd daemon running in the confd-nginx container polls for changes
    in the etcd cluster, using a template within the container to regenerate the nginx
    configuration only when changes are detected.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: etcd的更新已被confd读取并应用到nginx配置文件中，允许你访问你的简单文件服务器。包含`sleep`命令是因为confd已被配置为每10秒检查更新。在幕后，运行在confd-nginx容器中的confd守护进程会轮询etcd集群中的更改，使用容器内的模板仅在检测到更改时重新生成nginx配置。
- en: Let’s say we’ve decided we want to serve /etc rather than /. We’ll now start
    up our second application and add it to etcd. Because we’ll then have two backends,
    we’ll end up getting responses from each of them.\
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定我们想要服务/etc而不是/。现在我们将启动我们的第二个应用程序并将其添加到etcd。因为我们将有两个后端，我们最终会从它们各自得到响应。\
- en: Listing 9.17\. Using confd to set up two backend web services for nginx
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.17\. 使用confd为nginx设置两个后端Web服务
- en: '[PRE60]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding process, we checked that the new container came up correctly
    before adding it to etcd (see [figure 9.4](#ch09fig04)). We could have performed
    the process in one step by overwriting the `/app/upstream/py1` key in etcd—this
    is also useful if you need only one backend to be accessible at a time.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的过程中，我们在将其添加到etcd之前检查了新容器是否正确启动（见[图9.4](#ch09fig04)）。我们可以通过覆盖etcd中的`/app/upstream/py1`键来一步完成这个过程——这在你只需要一次只访问一个后端时也很有用。
- en: Figure 9.4\. Adding the py2 container to etcd
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 将py2容器添加到etcd
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: With the two-stage switchover, the second stage is to remove the old backend
    and container.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在两阶段切换中，第二阶段是移除旧的后端和容器。
- en: Listing 9.18\. Removing the old upstream address
  id: totrans-790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.18\. 移除旧的上游地址
- en: '[PRE61]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The new application is up and running by itself! At no point has the application
    been inaccessible to users, and there has been no need to manually connect to
    web server machines to reload nginx.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 新的应用程序自行启动并运行！应用程序在任何时候都没有对用户不可用，也没有必要手动连接到Web服务器机器来重新加载nginx。
- en: '**DISCUSSION**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'The uses of confd extend to more than configuring web servers: if you have
    any file containing text that needs updating based on external values, confd is
    there to step in—a useful connector between configuration files stored on disk
    and a single-point-of-truth etcd cluster.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: confd的使用不仅限于配置Web服务器：如果你有任何包含需要根据外部值更新的文本的文件，confd就会介入——它是存储在磁盘上的配置文件和单点真相etcd集群之间一个有用的连接器。
- en: As noted in the previous technique, etcd is not designed for storing large values.
    There’s also no reason you must use etcd with confd—there are a number of integrations
    available for the most popular key/value stores, so you might not need to add
    another moving part if you’ve already got something that works for you.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的技术中提到的，etcd不是为存储大值而设计的。也没有理由你必须与confd一起使用etcd——对于最流行的键值存储，有大量的集成可用，所以如果你已经有了对你有效的东西，你可能不需要添加另一个移动部件。
- en: Later on, in [technique 86](kindle_split_023.xhtml#ch11sb06), when we look at
    using Docker in production, you’ll see a method that avoids having to manually
    alter etcd at all if you want to update the backend servers for a service.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的[技术86](kindle_split_023.xhtml#ch11sb06)中，当我们查看在生产中使用Docker时，你会看到一个方法，如果你想要更新服务的后端服务器，可以避免手动更改etcd。
- en: '|  |'
  id: totrans-797
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Docker provides a great basis for a contract between development and operations
    teams.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker为开发和运维团队之间的合同提供了一个很好的基础。
- en: Moving images between registries can be a good way to control how far builds
    progress through your CD pipeline.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册表中移动镜像可以是控制构建在CD管道中进展的好方法。
- en: Bup is good at squeezing image transfers even more than layers can.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bup比层更能有效地压缩镜像传输。
- en: Docker images can be moved and shared as TAR files.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像可以作为TAR文件进行移动和共享。
- en: etcd can act as a central configuration store for an environment.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd可以作为环境的中央配置存储。
- en: Zero-downtime deployment can be achieved by combining etcd, confd, and nginx.
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合etcd、confd和nginx可以实现零停机时间部署。
- en: 'Chapter 10\. Network simulation: Realistic environment testing without the
    pain'
  id: totrans-805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 网络模拟：无需痛苦的现实环境测试
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Coming to grips with Docker Compose
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Docker Compose
- en: Testing your applications on troublesome networks
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在麻烦的网络上进行应用程序测试
- en: Taking a first look at Docker network drivers
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初探Docker网络驱动程序
- en: Creating a substrate network for seamless communications across Docker hosts
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Docker主机之间无缝通信创建基础网络
- en: '|  |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As part of your DevOps workflow, you’ll likely need to use the network in some
    way. Whether you’re trying to find out where the local memcache container is,
    connecting to the outside world, or plumbing together Docker containers running
    on different hosts, you’re likely to want to reach out to the wider network sooner
    or later.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 作为您的DevOps工作流程的一部分，您可能会以某种方式使用网络。无论您是试图找出本地memcache容器在哪里，连接到外部世界，还是将运行在不同主机上的Docker容器连接起来，您迟早都会想要连接到更广泛的网络。
- en: After reading this chapter you’ll know how to manage containers as a unit using
    Docker Compose, and simulate and manage networks by using Docker’s virtual network
    tooling. This chapter is a small first step toward orchestration and service discovery—subjects
    we’ll take a deeper dive into in [part 4](kindle_split_022.xhtml#part04) of this
    book.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您将了解如何使用Docker Compose将容器作为一个单元进行管理，并通过使用Docker的虚拟网络工具来模拟和管理网络。本章是向编排和服务发现迈出的小小第一步——我们将在本书的第4部分（[part
    4](kindle_split_022.xhtml#part04)）中更深入地探讨这些主题。
- en: '10.1\. Container communication: Beyond manual linking'
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 容器通信：超越手动链接
- en: In [technique 8](kindle_split_011.xhtml#ch02sb09) you saw how to connect containers
    with links, and we mentioned the advantages provided by a clear statement of container
    dependencies. Unfortunately, links have a number of disadvantages. Links have
    to be manually specified when starting each container, containers have to be started
    in the correct order, loops in links are forbidden, and there’s no way to replace
    a link (if a container dies, every dependent container must be restarted to recreate
    the links). On top of everything else, they’re deprecated!
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在[技术8](kindle_split_011.xhtml#ch02sb09)中，您看到了如何使用链接连接容器，我们提到了容器依赖关系明确声明提供的优势。不幸的是，链接有许多缺点。启动每个容器时必须手动指定链接，容器必须按正确顺序启动，链接中不允许有循环，而且无法替换链接（如果容器死亡，所有依赖的容器都必须重新启动以重新创建链接）。除此之外，它们已被弃用！
- en: Docker Compose is currently the most popular replacement for anything that previously
    involved a complex links setup, and we’ll take a look at it now.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是目前最受欢迎的替代方案，用于替代之前涉及复杂链接设置的所有内容，我们现在将探讨它。
- en: '|  |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**A simple Docker Compose cluster**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个简单的Docker Compose集群**'
- en: Docker Compose started life as *fig*, a now-deprecated independent effort to
    ease the pain of starting multiple containers with appropriate arguments for linking,
    volumes, and ports. Docker Inc. liked this so much that they acquired it, gave
    it a makeover, and released it with a new name.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose最初是*fig*，这是一个现在已弃用的独立项目，旨在简化使用适当的参数（链接、卷和端口）启动多个容器的痛苦。Docker Inc.非常喜欢这个项目，因此他们收购了它，进行了改造，并以新的名称发布。
- en: This technique introduces you to Docker Compose using a simple example of Docker
    container orchestration.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过一个简单的Docker容器编排示例向您介绍Docker Compose。
- en: '**PROBLEM**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to coordinate connected containers on your host machine.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要协调主机机器上连接的容器。
- en: '**SOLUTION**'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker Compose, a tool for defining and running multicontainer Docker applications.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose，这是一个用于定义和运行多容器Docker应用程序的工具。
- en: The central idea is that rather than wiring up container startup commands with
    complex shell scripts or Makefiles, you declare the application’s startup configuration,
    and then bring the application up with a single, simple command.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是，而不是用复杂的shell脚本或Makefile连接容器启动命令，您声明应用程序的启动配置，然后使用单个简单命令启动应用程序。
- en: '|  |'
  id: totrans-827
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We assume you have Docker Compose installed—refer to the official instructions
    ([http://docs.docker.com/compose/install](http://docs.docker.com/compose/install))
    for the latest advice.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已安装 Docker Compose——有关最新建议，请参阅官方说明 ([http://docs.docker.com/compose/install](http://docs.docker.com/compose/install))。
- en: '|  |'
  id: totrans-830
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this technique we’re going to keep things as simple as possible with an echo
    server and client. The client sends the familiar “Hello world!” message every
    five seconds to the echo server, and then receives the message back.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将使用 echo 服务器和客户端尽可能简单。客户端每五秒向 echo 服务器发送熟悉的“Hello world！”消息，然后接收回消息。
- en: '|  |'
  id: totrans-832
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The source code for this technique is available at [https://github.com/docker-in-practice/docker-compose-echo](https://github.com/docker-in-practice/docker-compose-echo).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的源代码可在 [https://github.com/docker-in-practice/docker-compose-echo](https://github.com/docker-in-practice/docker-compose-echo)
    找到。
- en: '|  |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following commands create a directory for you to work in while creating
    the server image:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令为您创建一个目录，以便在创建服务器镜像时工作：
- en: '[PRE62]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Create the server Dockerfile with the code shown in the following listing.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下列表中的代码创建服务器 Dockerfile。
- en: Listing 10.1\. Dockerfile—a simple echo server
  id: totrans-839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. Dockerfile——一个简单的 echo 服务器
- en: '[PRE63]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1*** **Installs the nmap package, which provides the ncat program used here**'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 安装 nmap 包，它提供了此处使用的 ncat 程序'
- en: '***2*** **Runs the ncat program by default when starting the image**'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 默认情况下，在启动镜像时运行 ncat 程序'
- en: The `-l 2000` arguments instruct `ncat` to listen on port 2000, and `-k` tells
    it to accept multiple client connections simultaneously and to continue running
    after clients close their connections so more clients can connect. The final arguments,
    `--exec /bin/cat`, will make `ncat` run `/bin/cat` for any incoming connections
    and forward any data coming over the connection to the running program.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l 2000` 参数指示 `ncat` 在端口 2000 上监听，`-k` 告诉它同时接受多个客户端连接，并在客户端关闭连接后继续运行，以便更多客户端可以连接。最后的参数
    `--exec /bin/cat` 将使 `ncat` 为任何传入的连接运行 `/bin/cat`，并将通过连接传输的任何数据转发到正在运行的程序。'
- en: 'Next, build the Dockerfile with this command:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用此命令构建 Dockerfile：
- en: '[PRE64]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now you can set up the client image that sends messages to the server. Create
    a new directory and place the client.py file and Dockerfile in there:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以设置发送消息到服务器的客户端镜像。创建一个新的目录，并将 client.py 文件和 Dockerfile 放在那里：
- en: '[PRE65]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We’ll use a simple Python program as the echo server client in the next listing.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一列表中使用一个简单的 Python 程序作为 echo 服务器客户端。
- en: Listing 10.2\. client.py—a simple echo client
  id: totrans-849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. client.py——一个简单的 echo 客户端
- en: '[PRE66]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1*** **Imports the Python packages needed**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 导入所需的 Python 包'
- en: '***2*** **Creates a socket object**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 创建一个套接字对象'
- en: '***3*** **Uses the socket to connect to the ‘talkto’ server on port 2000**'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用套接字连接到端口 2000 上的“talkto”服务器'
- en: '***4*** **Sends a string with a newline character to the socket**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 向套接字发送带有换行符的字符串'
- en: '***5*** **Creates a buffer of 1024 bytes to receive data, and places the data
    into the data variable when a message is received**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 创建一个 1024 字节的缓冲区以接收数据，并在收到消息时将数据放入 data 变量'
- en: '***6*** **Prints the received data to standard out**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 将接收到的数据打印到标准输出'
- en: '***7*** **Flushes the standard out buffer so you can see messages as they come
    in**'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 清空标准输出缓冲区，以便您可以查看传入的消息'
- en: '***8*** **Closes the socket object**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 关闭套接字对象'
- en: '***9*** **Waits 5 seconds and repeats**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** 等待 5 秒并重复'
- en: The Dockerfile for the client is straightforward. It installs Python, adds the
    client.py file, and then defaults it to run on startup, as shown in the following
    listing.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的 Dockerfile 很简单。它安装 Python，添加 client.py 文件，并在启动时默认运行，如下所示列表。
- en: Listing 10.3\. Dockerfile—a simple echo client
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. Dockerfile——一个简单的 echo 客户端
- en: '[PRE67]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Build the client with this command:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令构建客户端：
- en: '[PRE68]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To demonstrate the value of Docker Compose, we’ll first run these containers
    by hand:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Docker Compose 的价值，我们首先将手动运行这些容器：
- en: '[PRE69]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you’re finished, Ctrl-C out of the client, and remove the containers:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用 Ctrl-C 退出客户端，并删除容器：
- en: '[PRE70]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Many things can go wrong even in this trivial example: starting the client
    first will result in the failure of the application to start; forgetting to remove
    the containers will result in problems when you try to restart; and naming containers
    incorrectly will result in failure. These kinds of orchestration problems will
    only increase as your containers and their architecture get more sophisticated.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，也可能出现很多问题：首先启动客户端会导致应用程序启动失败；忘记删除容器会在你尝试重启时导致问题；以及错误地命名容器会导致失败。随着你的容器及其架构变得更加复杂，这类编排问题只会增加。
- en: Compose helps with this by encapsulating the orchestration of these containers’
    startup and configuration within a simple text file, managing the nuts and bolts
    of the startup and shutdown commands for you.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: Compose通过将这些容器的启动和配置的编排封装在一个简单的文本文件中，为你管理启动和关闭命令的细节。
- en: 'Compose takes a YAML file. You create this in a new directory:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: Compose需要一个YAML文件。你可以在新目录中创建它：
- en: '[PRE71]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The YAML file’s contents are shown in the following listing.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件的内容如下所示。
- en: Listing 10.4\. docker-compose.yml—Docker Compose echo server and client YAML
    file
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. docker-compose.yml—Docker Compose echo服务器和客户端YAML文件
- en: '[PRE72]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1*** **This Docker Compose file follows version 3 of the specification.**'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **此Docker Compose文件遵循规范的第3版。**'
- en: '***2*** **The reference names of the running services are their identifiers:
    echo-server and client, in this case.**'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行服务的引用名称是它们的标识符：在这个例子中是echo-server和client。**'
- en: '***3*** **Each section must define the image used: the client and server images,
    in this case.**'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **每个部分必须定义使用的镜像：在这个例子中是客户端和服务器镜像。**'
- en: '***4*** **Exposes the echo-server’s port 2000 to other services**'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将echo-server的端口2000暴露给其他服务**'
- en: '***5*** **Each section must define the image used: the client and server images,
    in this case.**'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **每个部分必须定义使用的镜像：在这个例子中是客户端和服务器镜像。**'
- en: '***6*** **Defines a link to the echo-server. References to “talkto” within
    the client will be sent to the echo server. The mapping is done by setting up
    the /etc/hosts file dynamically in the running container.**'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **定义了一个到echo-server的链接。客户端内的“talkto”引用将被发送到echo服务器。映射是通过在运行容器中动态设置/etc/hosts文件来完成的。**'
- en: 'The syntax of docker-compose.yml is fairly easy to grasp: each service is named
    under the `services` key, and configuration is stated in an indented section underneath.
    Each item of configuration has a colon after its name, and attributes of these
    items are stated either on the same line or on the following lines, beginning
    with dashes at the same level of indentation.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: docker-compose.yml的语法相当容易理解：每个服务都在`services`键下命名，配置在缩进的部分中声明。每个配置项的名称后面都有一个冒号，这些项的属性要么在同一行上声明，要么在下一行上声明，且与缩进级别相同。
- en: The key item of configuration to understand here is `links` within the client
    definition. This is created in the same way as the `docker run` command sets up
    links, except Compose handles startup order for you. In fact, most of the Docker
    command-line arguments have direct analogues in the docker-compose.yml syntax.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要理解的关键配置项是客户端定义中的`links`。这以与`docker run`命令设置链接相同的方式创建，但Compose会为你处理启动顺序。实际上，大多数Docker命令行参数在docker-compose.yml语法中都有直接的对应项。
- en: We used the `image:` statement in this example to define the image used for
    each service, but you can also get docker-compose to rebuild the required image
    dynamically by defining the path to the Dockerfile in a `build:` statement. Docker
    Compose will perform the build for you.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`image:`语句来定义每个服务使用的镜像，但你也可以通过在`build:`语句中定义Dockerfile的路径来让docker-compose动态地重建所需的镜像。Docker
    Compose会为你执行构建。
- en: '|  |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: A YAML file is a text configuration file with a straightforward syntax. You
    can read more about it at [http://yaml.org](http://yaml.org).
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件是一种具有简单语法的文本配置文件。你可以了解更多信息，请参阅[http://yaml.org](http://yaml.org)。
- en: '|  |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Now that all the infrastructure is set up, running the application is easy:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有基础设施都已设置，运行应用程序变得简单：
- en: '[PRE73]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|  |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you get an error when starting docker-compose that looks like “Couldn’t connect
    to Docker daemon at http+unix://var/run/docker.sock—is it running?” the issue
    may be that you need to run it with sudo.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动docker-compose时遇到类似“无法连接到Docker守护进程在http+unix://var/run/docker.sock—is
    it running？”的错误，问题可能是你需要用sudo运行它。
- en: '|  |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When you’ve seen enough, press Ctrl-C a few times to exit the application. You
    can bring it up again at will with the same command, without worrying about removing
    containers. Note that it will output “Recreating” rather than “Creating” if you
    rerun it.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看够了，多次按 Ctrl-C 退出应用程序。您可以使用相同的命令随意重新启动它，无需担心删除容器。请注意，如果您重新运行它，它将输出“Recreating”而不是“Creating”。
- en: '**DISCUSSION**'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: We mentioned a possible need for `sudo` in the previous section—you may want
    to revisit [technique 41](kindle_split_016.xhtml#ch06sb02) if this applies to
    you, as it makes using tools that interact with the Docker daemon significantly
    easier.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中提到了可能需要 `sudo` 的情况——如果您适用，您可能需要重新查看[技术 41](kindle_split_016.xhtml#ch06sb02)，因为它使得使用与
    Docker 守护进程交互的工具变得容易得多。
- en: Docker Inc. advertises Docker Compose as ready for use in production, either
    on a single machine as shown here, or deploying it across multiple machines with
    swarm mode—you’ll see how to do this in [technique 87](kindle_split_024.xhtml#ch12sb02).
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Inc. 宣称 Docker Compose 已准备好在生产环境中使用，无论是像这里所示的单台机器，还是通过集群模式在多台机器上部署——您将在[技术
    87](kindle_split_024.xhtml#ch12sb02)中看到如何做到这一点。
- en: 'Now that you’ve come to grips with Docker Compose, we’ll move on to a more
    complex and real-world scenario for docker-compose: using socat, volumes, and
    the replacement for links to add server-like functionality to a SQLite instance
    running on the host machine.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经掌握了 Docker Compose 的使用方法，我们将继续探讨 docker-compose 的更复杂和实际应用场景：使用 socat、卷和链接的替代品，为主机机器上运行的
    SQLite 实例添加类似服务器的功能。
- en: '|  |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A SQLite server using Docker Compose**'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Docker Compose 的 SQLite 服务器**'
- en: SQLite doesn’t come with any concept of a TCP server by default. By building
    on previous techniques, this technique provides you with a means of achieving
    TCP server functionality using Docker Compose.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 默认没有 TCP 服务器的概念。通过构建在之前的技术之上，此技术为您提供了一种使用 Docker Compose 实现TCP服务器功能的方法。
- en: 'Specifically, it builds on these previously covered tools and concepts:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，它基于以下之前介绍的工具和概念：
- en: Volumes
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷
- en: Proxying with socat
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 socat 进行代理
- en: Docker Compose
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: We’ll also introduce the replacement for links—networks.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍链接的替代品——网络。
- en: '|  |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique requires SQLite version 3 to be installed on your host. We also
    suggest that you install rlwrap to make line editing friendlier when interacting
    with your SQLite server (this is optional). These packages are freely available
    from standard package managers.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术要求在您的宿主机上安装 SQLite 版本 3。我们还建议您安装 rlwrap，以便在与 SQLite 服务器交互时进行行编辑更加友好（这是可选的）。这些软件包可以从标准的软件包管理器中免费获取。
- en: '|  |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The code for this technique is available for download here: [https://github.com/docker-in-practice/docker-compose-sqlite](https://github.com/docker-in-practice/docker-compose-sqlite).'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术的代码可在此处下载：[https://github.com/docker-in-practice/docker-compose-sqlite](https://github.com/docker-in-practice/docker-compose-sqlite)。
- en: '**PROBLEM**'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to efficiently develop a complex application referencing external data
    on your host using Docker.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Docker 在宿主机上高效地开发一个复杂的应用程序，该应用程序引用外部数据。
- en: '**SOLUTION**'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker Compose.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose。
- en: '[Figure 10.1](#ch10fig01) gives an overview of this technique’s architecture.
    At a high level there are two running Docker containers: one responsible for executing
    SQLite clients, and the other for proxying separate TCP connections to these clients.
    Note that the container executing SQLite isn’t exposed to the host; the proxy
    container achieves that. This kind of separation of responsibility into discrete
    units is a common feature of microservices architectures.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.1](#ch10fig01) 给出了此技术架构的概述。从高层次来看，有两个正在运行的 Docker 容器：一个负责执行 SQLite 客户端，另一个负责代理到这些客户端的单独
    TCP 连接。请注意，执行 SQLite 的容器没有暴露给宿主机；代理容器实现了这一点。这种将责任分离成离散单元的做法是微服务架构的常见特征。'
- en: Figure 10.1\. How the SQLite server works
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. SQLite 服务器的工作原理
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: We’re going to use the same image for all our nodes. Set up the Dockerfile in
    the next listing.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为所有节点使用相同的镜像。在下一个列表中设置 Dockerfile。
- en: Listing 10.5\. All-in-one SQLite server, client, and proxy Dockerfile
  id: totrans-922
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. SQLite 服务器、客户端和代理 Dockerfile 的集成
- en: '[PRE74]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1*** **Installs required applications**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装所需的应用程序**'
- en: '***2*** **Exposes port 12345 so that the nodes can communicate via the Docker
    daemon**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **暴露端口 12345，以便节点可以通过 Docker 守护进程进行通信**'
- en: The following listing shows docker-compose.yml, which defines how the containers
    should be started up.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了docker-compose.yml，它定义了容器应该如何启动。
- en: Listing 10.6\. SQLite server and proxy docker-compose.yml
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. SQLite服务器和代理docker-compose.yml
- en: '[PRE75]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** **The server and proxy containers are defined in this stanza.**'
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **服务器和代理容器定义在这个段落中。**'
- en: '***2*** **Creates a socat proxy to link the output of a SQLite call to a TCP
    port**'
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个socat代理，将SQLite调用的输出链接到TCP端口**'
- en: '***3*** **Builds the image on startup from the Dockerfile in the same directory**'
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在启动时从同一目录下的Dockerfile构建镜像**'
- en: '***4*** **Mounts the test SQLite db file to /opt/sqlite/db within the container**'
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将测试SQLite数据库文件挂载到容器内的/opt/sqlite/db**'
- en: '***5*** **Both services will become part of the sqlnet Docker network.**'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **这两个服务将成为sqlnet Docker网络的一部分。**'
- en: '***6*** **The server and proxy containers are defined in this stanza.**'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **服务器和代理容器定义在这个段落中。**'
- en: '***7*** **Creates a socat proxy to pass data from port 12346 to the server
    container’s 12345 port**'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **创建一个socat代理，将数据从12346端口传递到服务器容器的12345端口**'
- en: '***8*** **Builds the image on startup from the Dockerfile in the same directory**'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **在启动时从同一目录下的Dockerfile构建镜像**'
- en: '***9*** **Publishes port 12346 to the host**'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **将端口12346发布到主机**'
- en: '***10*** **Both services will become part of the sqlnet Docker network.**'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **这两个服务将成为sqlnet Docker网络的一部分。**'
- en: '***11*** **Defines a list of networks that containers in this Docker Compose
    file can join**'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **定义了容器可以加入的网络的列表**'
- en: The socat process in the server container will listen on port 12345 and permit
    multiple connections, as specified by the `TCP-L:12345,fork,reuseaddr` argument.
    The part following `EXEC:` tells `socat` to run SQLite on the /opt/sqlite/db file
    for every connection, assigning a pseudo-terminal to the process. The socat process
    in the client container has the same listening behavior as the server container
    (except on a different port), but instead of running something in response to
    an incoming connection, it will establish a TCP connection to the SQLite server.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器容器中的socat进程将在12345端口上监听，并允许多个连接，如`TCP-L:12345,fork,reuseaddr`参数所指定的。`EXEC:`后面的部分告诉`socat`为每个连接在/opt/sqlite/db文件上运行SQLite，并为进程分配一个伪终端。客户端容器中的socat进程具有与服务器容器相同的监听行为（除了在不同的端口上），但不会在响应传入连接时运行任何东西，而是将建立到SQLite服务器的TCP连接。
- en: One notable difference from the previous technique is the use of networks rather
    than links—networks present a way to create new virtual networks inside Docker.
    Docker Compose will always use a new “bridge” virtual network by default; it’s
    just been named explicitly in the preceding Compose configuration. Because any
    new bridge network allows access to containers using their service names, there’s
    no need to use links (though you still can if you want aliases for services).
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的技术相比，一个显著的不同点是使用网络而不是链接——网络提供了一种在Docker内部创建新虚拟网络的方法。Docker Compose默认情况下始终会使用一个新的“桥接”虚拟网络；它只是在先前的Compose配置中明确命名了。因为任何新的桥接网络都允许通过服务名称访问容器，所以不需要使用链接（尽管如果你想为服务设置别名，仍然可以使用链接）。
- en: Although this functionality could be achieved in one container, the server/proxy
    container setup allows the architecture of this system to grow more easily, as
    each container is responsible for one job. The server is responsible for opening
    SQLite connections, and the proxy is responsible for exposing the service to the
    host machine.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个功能可以在一个容器中实现，但服务器/代理容器设置使得这个系统的架构更容易扩展，因为每个容器负责一项工作。服务器负责打开SQLite连接，而代理负责将服务暴露给主机机器。
- en: The following listing (simplified from the original in the repository, [https://github.com/docker-in-practice/docker-compose-sqlite](https://github.com/docker-in-practice/docker-compose-sqlite))
    creates two minimal SQLite databases, test and live, on your host machine.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表（从存储库中的原始内容简化，[https://github.com/docker-in-practice/docker-compose-sqlite](https://github.com/docker-in-practice/docker-compose-sqlite)）在您的宿主机上创建了两个最小的SQLite数据库，test和live。
- en: Listing 10.7\. setup_dbs.sh
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. setup_dbs.sh
- en: '[PRE76]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1*** **Removes any directory from a previous run**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从之前的运行中删除任何目录**'
- en: '***2*** **Throws an error if the directory still exists**'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **如果目录仍然存在，则抛出错误**'
- en: '***3*** **Creates the test DB with one table**'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建包含一个表的测试数据库**'
- en: '***4*** **Creates the live DB with one table**'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **创建包含一个表的实时数据库**'
- en: '***5*** **Inserts one row with the string “test” into the table**'
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **向表中插入一行包含字符串“test”**'
- en: '***6*** **Inserts one row with the string “live” into the table**'
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **向表中插入一个包含字符串“live”的行**'
- en: '***7*** **Returns to the previous directory**'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **返回到上一个目录**'
- en: To run this example, set up the databases and call docker-compose up, as shown
    in the following listing.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请设置数据库并调用 docker-compose up，如下所示。
- en: Listing 10.8\. Run up the Docker Compose cluster
  id: totrans-954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 启动 Docker Compose 集群
- en: '[PRE77]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Then, in one or more other terminals, you can run Telnet to create multiple
    sessions against one SQLite database.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个或多个其他终端中，您可以通过运行 Telnet 来创建针对一个 SQLite 数据库的多个会话。
- en: Listing 10.9\. Connecting to the SQLite server
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 连接到 SQLite 服务器
- en: '[PRE78]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1*** **Makes a connection to the proxy using Telnet, wrapped in rlwrap to
    gain the editing and history functionality of a command line**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 rlwrap 包装的 Telnet 连接到代理，以获得命令行的编辑和历史功能**'
- en: '***2*** **Output of the Telnet connection**'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **Telnet 连接的输出**'
- en: '***3*** **Connects to SQLite here**'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **连接到 SQLite**'
- en: '***4*** **Runs a SQL command against the sqlite prompt**'
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在 sqlite 提示符下运行 SQL 命令**'
- en: If you want to switch the server to live, you can change the configuration by
    changing the `volumes` line in docker-compose.yml from this,
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将服务器切换到实时状态，您可以通过更改 docker-compose.yml 中的 `volumes` 行来更改配置，
- en: '[PRE79]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'to this:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止：
- en: '[PRE80]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then rerun this command:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新运行此命令：
- en: '[PRE81]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|  |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although we did some basic tests with this multiplexing of SQLite clients, we
    make no guarantees about the data integrity or performance of this server under
    any kind of load. The SQLite client wasn’t designed to work in this way. The purpose
    of this technique is to demonstrate the general approach of exposing a binary
    in this way.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对这种 SQLite 客户端的复用进行了一些基本测试，但我们不对该服务器在任何负载下的数据完整性和性能做出任何保证。SQLite 客户端并非设计成以这种方式工作。这项技术的目的是演示以这种方式公开二进制文件的一般方法。
- en: '|  |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This technique demonstrates how Docker Compose can take something relatively
    tricky and complicated, and make it robust and straightforward. Here we’ve taken
    SQLite and given it extra server-like functionality by wiring up containers to
    proxy SQLite invocations to the data on the host. Managing the container complexity
    is made significantly easier with Docker Compose’s YAML configuration, which turns
    the tricky matter of orchestrating containers correctly from a manual, error-prone
    process to a safer, automated one that can be put under source control. This is
    the beginning of our journey into orchestration, which you’ll be hearing much
    more about in [part 4](kindle_split_022.xhtml#part04) of the book.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了 Docker Compose 如何将相对复杂和棘手的事情变得健壮和简单。在这里，我们使用了 SQLite，并通过将容器连接到代理来将 SQLite
    调用代理到主机上的数据，从而赋予了它额外的服务器功能。使用 Docker Compose 的 YAML 配置可以显著简化容器复杂性的管理，它将正确编排容器的棘手问题从手动、易出错的流程转变为更安全、自动化的流程，并且可以置于源代码控制之下。这是我们进入编排之旅的开始，您将在本书的[第
    4 部分](kindle_split_022.xhtml#part04)中听到更多关于它的内容。
- en: '**DISCUSSION**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Using networks with the `depends_on` feature of Docker Compose allows you to
    effectively emulate the functionality of links by controlling startup order. For
    a full treatment of all possible options available to Docker Compose, we recommend
    you read the official documentation at [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 的 `depends_on` 功能，您可以通过控制启动顺序来有效地模拟链接的功能。要全面了解 Docker Compose
    所提供的所有可能选项，我们建议您阅读官方文档[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)。
- en: To find out more about Docker virtual networks, take a look at [technique 80](#ch10sb06)—it
    goes into the details of what Docker Compose is doing behind the scenes to set
    up your virtual networks.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Docker 虚拟网络的信息，请查看[技术 80](#ch10sb06)——它详细介绍了 Docker Compose 在幕后是如何设置您的虚拟网络的。
- en: '|  |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 10.2\. Using Docker to simulate real-world networking
  id: totrans-978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 使用 Docker 模拟现实世界的网络
- en: Most people who use the internet treat it as a black box that somehow retrieves
    information from other places around the world and puts it on their screens. Sometimes
    they experience slowness or connection drops, and it’s not uncommon to observe
    cursing of the ISP as a result.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用互联网的人将其视为一个黑盒，它以某种方式从世界各地的其他地方检索信息并将其显示在他们的屏幕上。有时他们会遇到速度慢或连接中断的情况，因此对 ISP
    的咒骂并不少见。
- en: 'When you build images containing applications that need to be connected, you
    likely have a much firmer grasp of which components need to connect to where,
    and how the overall setup looks. But one thing remains constant: you can still
    experience slowness and connection drops. Even large companies, with data centers
    they own and operate, have observed unreliable networking and the issues it causes
    with applications.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建包含需要连接的应用程序镜像时，您可能对哪些组件需要连接到何处以及整体设置看起来如何有了更深入的了解。但有一点是恒定的：您仍然可能会遇到网络缓慢和连接中断。即使是拥有并运营自己数据中心的大型公司，也观察到了不可靠的网络以及它给应用程序带来的问题。
- en: We’ll look at a couple of ways you can experiment with flaky networks to help
    determine what problems you may be facing in the real world.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种您可以通过实验不稳定的网络来确定您可能在实际世界中遇到的问题的方法。
- en: '|  |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Simulating troublesome networks with Comcast**'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Comcast 模拟麻烦的网络**'
- en: As much as we might wish for perfect network conditions when we distribute applications
    across many machines, the reality is much uglier—tales of packet loss, connection
    drops, and network partitions abound, particularly on commodity cloud providers.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能希望当我们在多台机器上分发应用程序时拥有完美的网络条件，但现实情况要糟糕得多——关于数据包丢失、连接中断和网络分区的故事比比皆是，尤其是在通用云服务提供商那里。
- en: It’s prudent to test your stack before it encounters these situations in the
    real world to see how it behaves—an application designed for high availability
    shouldn’t grind to a halt if an external service starts experiencing significant
    additional latency.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的堆栈在实际世界中遇到这些情况之前对其进行测试是明智的，以了解其行为——为高可用性设计的应用程序不应该因为外部服务开始经历显著的额外延迟而停止运行。
- en: '**PROBLEM**'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be able to apply varying network conditions to individual containers.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望能够将不同的网络条件应用到单个容器中。
- en: '**SOLUTION**'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Comcast (the networking tool, not the ISP).
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Comcast（网络工具，而不是 ISP）。
- en: Comcast ([https://github.com/tylertreat/Comcast](https://github.com/tylertreat/Comcast))
    is a humorously named tool for altering network interfaces on your Linux machine
    in order to apply unusual (or, if you’re unfortunate, typical!) conditions to
    them.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: Comcast ([https://github.com/tylertreat/Comcast](https://github.com/tylertreat/Comcast))
    是一个有趣命名的工具，用于在您的 Linux 机器上更改网络接口，以便将不寻常的（或者如果您不幸，是典型的！）条件应用于它们。
- en: Whenever Docker creates a container, it also creates virtual network interfaces—this
    is how all your containers have different IP addresses and can ping each other.
    Because these are standard network interfaces, you can use Comcast on them, as
    long as you can find the network interface name. This is easier said than done.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Docker 创建一个容器时，它也会创建虚拟网络接口——这就是所有容器都有不同的 IP 地址并且可以互相 ping 的原因。因为这些是标准网络接口，只要您能找到网络接口名称，您就可以在上面使用
    Comcast。这说起来容易做起来难。
- en: The following listing shows a Docker image containing Comcast, all its prerequisites,
    and some tweaks.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个包含 Comcast、所有先决条件和一些调整的 Docker 镜像。
- en: Listing 10.10\. Preparing to run the `comcast` image
  id: totrans-993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 准备运行 `comcast` 镜像
- en: '[PRE82]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The tweaks we added here provide the `-cont` option, which allows you to refer
    to a container rather than having to find the name of a virtual interface. Note
    that we’ve had to add some special flags to the `docker run` command in order
    to give the container more permissions—this is so Comcast is freely able to examine
    and apply changes to network interfaces.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的调整提供了 `-cont` 选项，允许您引用容器而不是必须找到虚拟接口的名称。请注意，我们不得不向 `docker run` 命令添加一些特殊标志，以便给容器更多的权限——这样
    Comcast 就可以自由地检查和修改网络接口。
- en: 'To see the difference Comcast can make, we’ll first find out what a normal
    network connection looks like. Open a new terminal and run the following commands
    to set your expectations for baseline network performance:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 Comcast 可以带来的差异，我们首先需要了解正常网络连接是什么样的。打开一个新的终端并运行以下命令，以设定对基准网络性能的预期：
- en: '[PRE83]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1*** **The connection between this machine and [www.example.com](http://www.example.com)
    seems to be reliable, with no packets lost.**'
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这台机器与 [www.example.com](http://www.example.com) 之间的连接似乎很可靠，没有数据包丢失。**'
- en: '***2*** **The average round trip time is about 100 ms for [www.example.com](http://www.example.com).**'
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **平均往返时间是大约 100 毫秒，对于 [www.example.com](http://www.example.com)。**'
- en: '***3*** **The total time taken to download the HTML homepage of [www.example.com](http://www.example.com)
    is about 0.7 s.**'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **下载 [www.example.com](http://www.example.com) 的 HTML 主页所需的总时间大约是 0.7
    秒。**'
- en: 'Once you’ve done this, leave the container running and you can apply some network
    conditions to it:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，让容器继续运行，你可以对其应用一些网络条件：
- en: '[PRE84]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding command applies three different conditions: 50 KBps bandwidth
    cap for all destinations (to bring back memories of dial-up), an added latency
    of 100 ms (on top of any inherent delay), and a packet loss percentage of 20%.'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应用了三种不同的条件：对所有目的地的50 KBps带宽限制（让人回忆起拨号上网），增加100毫秒的延迟（加上任何固有的延迟），以及20%的丢包率。
- en: 'Comcast first identifies the appropriate virtual network interface for the
    container and then invokes a number of standard Linux command-line networking
    utilities to apply the traffic rules, listing what it’s doing as it goes along.
    Let’s see how our container reacts to this:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: Comcast首先识别容器适当的虚拟网络接口，然后调用一系列标准的Linux命令行网络工具来应用流量规则，并在执行过程中列出其操作。让我们看看我们的容器对此的反应：
- en: '[PRE85]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Success! An additional 100 ms of latency is reported by ping, and the timing
    from `wget` shows a slightly greater than 5x slowdown, approximately as expected
    (the bandwidth cap, latency addition, and packet loss will all impact on this
    time). But there’s something odd about the packet loss—it seems to be three times
    greater than expected. It’s important to bear in mind that the ping is sending
    a few packets, and that packet loss isn’t a precise “one in five” counter—if you
    increase the ping count to 50, you’ll find that the resulting loss is much closer
    to what’s expected.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！ping报告了额外的100毫秒延迟，而`wget`的计时显示略大于5倍减速，大约符合预期（带宽限制、延迟增加和丢包都将影响这个时间）。但关于丢包有些奇怪——它似乎比预期大三倍。重要的是要记住，ping只发送了几包，丢包不是一个精确的“五分之一”计数器——如果你将ping计数增加到50，你会发现结果丢包更接近预期。
- en: Note that the rules we’ve applied apply to *all* network connections via this
    network interface. This includes connections to the host and other containers.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们应用的规定适用于通过此网络接口的所有网络连接。这包括与主机和其他容器的连接。
- en: Let’s now instruct Comcast to remove the rules. Comcast is sadly not yet able
    to add and remove individual conditions, so altering anything on a network interface
    means completely removing and re-adding rules on the interface. You also need
    to remove the rules if you want to get your normal container network operation
    back. Don’t worry about removing them if you exit the container, though—they’ll
    be automatically deleted when Docker deletes the virtual network interface.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们指导Comcast移除这些规则。遗憾的是，Comcast目前还不能添加和移除单个条件，因此更改网络接口上的任何内容意味着完全移除并重新添加接口上的规则。如果你想要恢复正常的容器网络操作，也需要移除这些规则。不过，如果你退出容器，无需担心移除它们——当Docker删除虚拟网络接口时，它们将被自动删除。
- en: '[PRE86]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If you want to get your hands dirty, you can dig into Linux traffic control
    tools, possibly using Comcast with `-dry-run` to generate example sets of commands
    to use. A full treatment of the possibilities is outside the scope of the technique,
    but remember, if you can put it in a container, and it hits the network, you can
    toy with it.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解，可以研究Linux流量控制工具，可能使用带有`-dry-run`的Comcast生成要使用的命令示例集。全面探讨所有可能性超出了本技术的范围，但请记住，如果你可以将它放入容器中，并且它触网，你就可以对其进行操作。
- en: '**DISCUSSION**'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: With some implementation effort, there’s no reason you can’t use Comcast for
    more than just manual control of container bandwidth. For example, imagine you
    were using a tool like btsync ([technique 35](kindle_split_015.xhtml#ch05sb08))
    but wanted to limit the available bandwidth so it doesn’t saturate your connection—download
    Comcast, put it in the container, and use `ENTRYPOINT` ([technique 49](kindle_split_017.xhtml#ch07sb02))
    to set up the bandwidth limits as part of container startup.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些实施努力，你完全有理由使用Comcast不仅仅是为了手动控制容器带宽。例如，假设你正在使用像btsync这样的工具([技术35](kindle_split_015.xhtml#ch05sb08))，但希望限制可用带宽以避免占用你的连接——下载Comcast，将其放入容器中，并使用`ENTRYPOINT`([技术49](kindle_split_017.xhtml#ch07sb02))在容器启动时设置带宽限制。
- en: To do this, you’ll need to install the dependencies of Comcast (listed for the
    `alpine` image in our Dockerfile at [https://github.com/docker-in-practice/docker-comcast/blob/master/Dockerfile](https://github.com/docker-in-practice/docker-comcast/blob/master/Dockerfile))
    and likely give at least network admin capabilities to the container—you can read
    more about capabilities in [technique 93](kindle_split_027.xhtml#ch14sb02).
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要安装Comcast的依赖项（在Dockerfile中的`alpine`镜像中列出，见[https://github.com/docker-in-practice/docker-comcast/blob/master/Dockerfile](https://github.com/docker-in-practice/docker-comcast/blob/master/Dockerfile)），并且可能需要给容器至少赋予网络管理员权限——你可以在[技术93](kindle_split_027.xhtml#ch14sb02)中了解更多关于权限的内容。
- en: '|  |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Simulating troublesome networks with Blockade**'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Blockade模拟麻烦的网络**'
- en: Comcast is an excellent tool with a number of applications, but there’s an important
    use case it doesn’t solve—how can you apply network conditions to containers en
    masse? Manually running Comcast against tens of containers would be painful, and
    hundreds would be unthinkable! This is a particularly relevant problem for containers,
    because they’re so cheap to spin up—if you’re trying to run a large network simulation
    on a single machine with hundreds of VMs rather than containers, you may find
    you have bigger problems, like a lack of memory!
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 康卡斯特（Comcast）是一个功能丰富的工具，有多个应用场景，但它无法解决一个重要的用例——如何批量将网络条件应用到容器中？手动对数十个容器运行Comcast将非常痛苦，而对数百个容器来说则几乎不可想象！这对于容器来说尤其是一个相关的问题，因为启动容器的成本非常低——如果你试图在单台机器上运行一个包含数百个虚拟机而不是容器的复杂网络模拟，你可能会发现你面临更大的问题，比如内存不足！
- en: On the subject of simulating a network with many machines, there’s a particular
    kind of network failure that becomes interesting at this scale—a network partition.
    This is when a group of networked machines splits into two or more parts, such
    that all machines in the same part can talk to each other, but different parts
    can’t communicate. Research indicates that this happens more than you might think,
    particularly on consumer-grade clouds!
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论模拟多机网络的背景下，有一种特定的网络故障在这个规模下变得有趣——网络分区。这是指一组网络机器分裂成两个或更多部分，使得同一部分中的所有机器可以相互通信，但不同部分之间无法通信。研究表明，这种情况的发生频率可能比你想象的要高，尤其是在消费级云上！
- en: Going down the classic Docker microservices route brings these problems into
    sharp relief, and having the tools to do experiments is crucial for understanding
    how your service will deal with it.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着经典的Docker微服务路线，这些问题变得尤为突出，拥有进行实验的工具对于理解你的服务如何处理这些问题至关重要。
- en: '**PROBLEM**'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to orchestrate setting network conditions for large numbers of containers,
    including creating network partitions.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望协调为大量容器设置网络条件，包括创建网络分区。
- en: '**SOLUTION**'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Blockade ([https://github.com/worstcase/blockade](https://github.com/worstcase/blockade))—an
    open source piece of software originally from a team at Dell, created for “testing
    network failures and partitions.”
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blockade（[https://github.com/worstcase/blockade](https://github.com/worstcase/blockade)）——一个开源软件，最初来自戴尔团队，用于“测试网络故障和分区”。
- en: Blockade works by reading a configuration file (blockade.yml) in your current
    directory that defines how to start containers and what conditions to apply to
    them. In order to apply conditions, it may download other images with required
    utilities installed. The full configuration details are available in the Blockade
    documentation, so we’ll only cover the essentials.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞（Blockade）通过读取当前目录下的配置文件（blockade.yml）来定义如何启动容器以及应用哪些条件到它们上。为了应用条件，它可能会下载包含所需实用工具的其他镜像。完整的配置细节可以在Blockade文档中找到，因此我们只介绍基本内容。
- en: First you need to create a blockade.yml file.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个blockade.yml文件。
- en: Listing 10.11\. The blockade.yml file
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11. blockade.yml文件
- en: '[PRE87]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The containers in the preceding configuration are set up to represent a server
    being connected to by two clients. In practice, this could be something like a
    database server with client applications, and there’s no inherent reason you have
    to limit the number of components you want to model. Chances are, if you can represent
    it in a compose .yml file (see [technique 76](#ch10sb02)), you can probably model
    it in Blockade.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，容器被设置为代表两个客户端连接的服务器。在实践中，这可能是数据库服务器及其客户端应用程序，你没有必要限制你想要模拟的组件数量。如果你能在compose
    .yml文件中（参见[技术76](#ch10sb02)）表示它，那么你很可能在Blockade中对其进行建模。
- en: We’ve specified the network driver as `udn` here—this makes Blockade mimic the
    behavior of Docker Compose in [technique 77](#ch10sb03), creating a new virtual
    network so containers can ping each other by container name. To this end, we’ve
    had to explicitly specify `container_name` for the server, as Blockade generates
    one itself by default. The `sleep 5` commands are to make sure the server is running
    before starting the clients—if you prefer to use links with Blockade, they will
    ensure the containers are started up in the correct order. Don’t worry about the
    `network` section for now; we’ll come back to it shortly.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里指定了网络驱动程序为`udn`——这使得Blockade模仿Docker Compose在[技术77](#ch10sb03)中的行为，创建一个新的虚拟网络，以便容器可以通过容器名称相互ping。为此，我们必须明确指定服务器的`container_name`，因为Blockade默认会生成一个。`sleep
    5`命令是为了确保在启动客户端之前服务器正在运行——如果你更喜欢使用Blockade的链接，它们将确保容器按正确的顺序启动。现在不用担心`network`部分；我们很快就会回到它。
- en: 'As usual, the first step in using Blockade is to pull the image:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Blockade的第一步通常是拉取镜像：
- en: '[PRE88]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You’ll notice that we’re missing a few arguments to `docker run`, compared to
    the previous technique (like `--privileged` and `--pid=host`). Blockade uses other
    containers to perform the network manipulation, so it doesn’t need permissions
    itself. Also note the argument to mount the current directory into the container,
    so that Blockade is able to access blockade.yml and store state in a hidden folder.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，与之前的技术（如`--privileged`和`--pid=host`）相比，我们缺少了一些`docker run`的参数。Blockade使用其他容器来执行网络操作，因此它本身不需要权限。另外，请注意挂载当前目录到容器中的参数，这样Blockade就能访问blockade.yml并在一个隐藏文件夹中存储状态。
- en: '|  |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re running on a networked filesystem, you may encounter strange permission
    issues when you start Blockade for the first time—this is likely because Docker
    is trying to create the hidden state folder as root, but the networked filesystem
    isn’t cooperating. The solution is to use a local disk.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个网络文件系统上运行，当你第一次启动Blockade时可能会遇到奇怪的权限问题——这很可能是由于Docker试图以root用户创建隐藏状态文件夹，但网络文件系统不配合。解决方案是使用本地磁盘。
- en: '|  |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Finally we come to the moment of truth—running Blockade. Make sure you’re in
    the directory you’ve saved blockade.yml into:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了关键时刻——运行Blockade。确保你位于保存blockade.yml的目录中：
- en: '[PRE89]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1040
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On startup, Blockade may sometimes give cryptic errors about files in /proc
    not existing. The first thing to check is whether a container has immediately
    exited on startup, preventing Blockade from checking its network status. Additionally,
    try to resist any temptation to use the Blockade `-c` option to specify a custom
    path to the config file—only subdirectories of the current directory are available
    inside the container.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Blockade有时可能会显示一些关于/proc中文件不存在的神秘错误。首先需要检查的是容器是否在启动时立即退出，这阻止了Blockade检查其网络状态。此外，请尽量抵制使用Blockade
    `-c`选项来指定自定义配置文件路径的诱惑——容器内部只能访问当前目录的子目录。
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'All of the containers defined in our config file have been started, and we’ve
    been given a bunch of helpful information about the started containers. Let’s
    now apply some basic network conditions. Tail the logs of client1 in a new terminal
    (with `docker logs -f 613b5b1cdb7d`) so you can see what happens as you change
    things:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置文件中定义的所有容器都已启动，并且我们得到了有关已启动容器的大量有用信息。现在让我们应用一些基本的网络条件。在新终端（使用`docker logs
    -f 613b5b1cdb7d`）中跟踪client1的日志，这样你就可以看到当你改变设置时发生了什么：
- en: '[PRE90]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1*** **Makes the network flaky (drops packets) for all containers**'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使所有容器的网络变得不可靠（丢弃数据包**）'
- en: '***2*** **Delays the next command to give the previous one time to take effect
    and log some output**'
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **延迟下一个命令以给前一个命令足够的时间生效并记录一些输出**'
- en: '***3*** **Makes the network slow (adds a delay to packets) for container client1**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使client1容器的网络变慢（向数据包添加延迟**）'
- en: '***4*** **Checks the status the containers are in**'
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **检查容器当前的状态**'
- en: '***5*** **Reverts all the containers to normal operation**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将所有容器恢复到正常操作**'
- en: The `flaky` and `slow` commands use the values defined in the `network` section
    of the preceding configuration file ([listing 10.11](#ch10ex011))—there’s no way
    to specify a limit on the command line. If you want, it’s possible to edit blockade.yml
    while containers are running and then selectively apply the new limits to containers.
    Be aware that a container can either be on a slow *or* flaky network, not both.
    These limitations aside, the convenience of running this against hundreds of containers
    is fairly significant.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`flaky`和`slow`命令使用前一个配置文件中`network`部分定义的值（[列表10.11](#ch10ex011)）——无法在命令行上指定限制。如果你愿意，可以在容器运行时编辑blockade.yml，然后选择性地将新限制应用于容器。请注意，容器可以处于**慢速**或**不可靠**的网络中，但不能同时处于两者。尽管有这些限制，但针对数百个容器运行此功能的便利性相当显著。'
- en: 'If you look back at your logs from `client1`, you should now be able to see
    when the different commands took effect:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下`client1`的日志，你现在应该能够看到不同命令何时生效：
- en: '[PRE91]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1*** **`icmp_seq` is sequential (no packets being dropped) and `time` is
    low (a small delay).**'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`icmp_seq`** 是连续的（没有数据包被丢弃）且**`time`** 低（延迟小）。'
- en: '***2*** **`icmp_seq` starts skipping numbers—the `flaky` command has taken
    effect.**'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **`icmp_seq`** 开始跳过数字——**`flaky`** 命令已经生效。'
- en: '***3*** **`time` has taken a big jump—the `slow` command has taken effect.**'
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **`time`** 的时间发生了大幅跳跃——**`slow`** 命令已经生效。'
- en: 'All this is useful, but it’s nothing we couldn’t have done already with some
    (likely painful) scripting on top of Comcast, so let’s take a look at the killer
    feature of Blockade—network partitions:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很实用，但我们已经可以通过在Comcast之上进行一些（可能很痛苦）的脚本编写来实现，所以让我们来看看Blockade的杀手级功能——网络分区：
- en: '[PRE92]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This has put our three nodes in two boxes—the server in one and clients in
    the other—with no way of communicating between them. You’ll see that the log for
    `client1` has stopped doing anything because all of the ping packets are being
    lost. The clients can still talk to each other, though, and you can verify this
    by sending a few ping packets between them:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的三个节点被分成了两个盒子——服务器在一个盒子中，客户端在另一个盒子中，它们之间无法通信。你会看到`client1`的日志已经停止了任何操作，因为所有的ping数据包都丢失了。尽管如此，客户端之间仍然可以互相通信，你可以通过在它们之间发送几个ping数据包来验证这一点：
- en: '[PRE93]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: No packet loss, low delay ... looks like a good connection. Partitions and other
    network conditions operate independently, so you can play with packet loss while
    your apps are partitioned. There’s no limit to the number of partitions you can
    define, so you can play with complex scenarios to your heart’s content.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据包丢失，延迟低……看起来连接良好。分区和其他网络条件独立运行，因此你可以在应用分区的同时玩转数据包丢失。你可以定义的分区数量没有限制，因此你可以随心所欲地玩转复杂的场景。
- en: '**DISCUSSION**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: If you need more power than Blockade and Comcast can individually provide, you
    can combine the two. Blockade is excellent at creating partitions and doing the
    heavy lifting of starting up containers; adding Comcast to the mix gives you fine-grained
    control over the network connections of each and every container.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要的功能比Blockade和Comcast各自能提供的还要强大，你可以将它们结合起来。Blockade在创建分区和执行启动容器的繁重工作方面非常出色；将Comcast加入其中，你可以对每个容器的网络连接进行精细控制。
- en: It’s also worth looking into the complete help for Blockade—it offers other
    things you may find useful, like “chaos” functionality to impact random containers
    with assorted conditions and a `--random` argument to commands so you could (for
    example) see how your application reacts when containers are killed at random.
    If you’ve heard of Netflix’s Chaos Monkey, this is a way to mimic it on a smaller
    scale.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，查看Blockade的完整帮助文档——它提供了其他你可能觉得有用的功能，例如“混乱”功能，可以随机影响具有各种条件的容器，以及命令的`--random`参数，这样你就可以（例如）看到当容器随机被杀死时你的应用程序如何反应。如果你听说过Netflix的Chaos
    Monkey，这是一种在更小规模上模仿它的方法。
- en: '|  |'
  id: totrans-1064
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.3\. Docker and virtual networks
  id: totrans-1065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3 Docker和虚拟网络
- en: Docker’s core functionality is all about isolation. Previous chapters have shown
    some of the benefits of process and filesystem isolation, and in this chapter
    you’ve seen network isolation.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的核心功能都是关于隔离。前面的章节展示了进程和文件系统隔离的一些好处，而本章你看到了网络隔离。
- en: 'You could think of there being two aspects to network isolation:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以认为网络隔离有两个方面：
- en: '*Individual sandbox*—Each container has its own IP address and set of ports
    to listen on without stepping on the toes of other containers (or the host).'
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*独立沙盒*——每个容器都有自己的IP地址和要监听的端口集合，不会与其他容器（或主机）冲突。'
- en: '*Group sandbox*—This is a logical extension of the individual sandbox—all of
    the isolated containers are grouped together in a private network, allowing you
    to play around without interfering with the network your machine lives on (and
    incurring the wrath of your company network administrator!).'
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*沙盒组*——这是单个沙盒的逻辑扩展——所有隔离的容器都在一个私有网络中分组在一起，允许您在不干扰您机器所在的网络（以及招致您公司网络管理员的愤怒！）的情况下进行实验。'
- en: The previous two techniques provide some practical examples of these two aspects
    of network isolation—Comcast manipulated individual sandboxes to apply rules to
    each container, whereas partitioning in Blockade relied on the ability to have
    complete oversight of the private container network to split it into pieces. Behind
    the scenes, it looks a bit like [figure 10.2](#ch10fig02).
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种技术提供了网络隔离这两个方面的实际示例——Comcast通过操纵单个沙盒来为每个容器应用规则，而Blockade中的分区则依赖于对私有容器网络的完全监督能力来将其分割成片段。幕后，它看起来有点像[图10.2](#ch10fig02)。
- en: Figure 10.2\. Internal Docker networking on a host machine
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 主机机器上的内部Docker网络
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig02_alt.jpg)'
- en: The exact details of how the bridge works aren’t important. Suffice it to say
    that the bridge creates a flat network between containers (it allows direct communication
    with no intermediate steps) and it forwards requests to the outside world to your
    external connection.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接如何工作的确切细节并不重要。只需说，桥接在容器之间创建了一个扁平网络（它允许直接通信，没有中间步骤）并将请求转发到外部连接。
- en: Docker Inc. then altered this model based on feedback from users to allow you
    to create your own virtual networks with *network drivers*, a plugin system to
    extend the networking capabilities of Docker. These plugins are either built-in
    or provided by third parties and should do all the necessary work to wire up the
    network, letting you get on with using it.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Inc.随后根据用户反馈调整了此模型，允许您使用*网络驱动程序*创建自己的虚拟网络，这是一个插件系统，用于扩展Docker的网络功能。这些插件要么是内置的，要么由第三方提供，应该完成所有必要的网络连接工作，让您可以继续使用它。
- en: New networks you create can be thought of as additional group sandboxes, typically
    providing access within the sandbox but not allowing cross-sandbox communication
    (though the precise details of the network behavior depend on the driver).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的新网络可以被视为额外的沙盒组，通常在沙盒内提供访问权限，但不允许跨沙盒通信（尽管网络行为的精确细节取决于驱动程序）。
- en: '|  |'
  id: totrans-1076
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Creating another Docker virtual network**'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建另一个Docker虚拟网络**'
- en: When people first learn about the ability to create their own virtual networks,
    one common response is to ask how they can create a copy of the default Docker
    bridge, to allow sets of containers to communicate but be isolated from other
    containers. Docker Inc. realized this would be a popular request, so it was implemented
    as one of the first features of virtual networks in the initial experimental release.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们第一次了解到他们可以创建自己的虚拟网络时，一个常见的反应是询问他们如何创建默认Docker桥接的副本，以便容器集之间可以通信但与其他容器隔离。Docker
    Inc.意识到这将是一个受欢迎的请求，因此它被实现为初始实验版中虚拟网络的第一批功能之一。
- en: '**PROBLEM**'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a solution supported by Docker Inc. for creating virtual networks.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个由Docker Inc.支持的创建虚拟网络解决方案。
- en: '**SOLUTION**'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the set of Docker subcommands nested under `docker network` to create your
    own virtual network.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套在`docker network`下的Docker子命令集创建您自己的虚拟网络。
- en: The built-in “bridge” driver is probably the most commonly used driver—it’s
    officially supported and allows you to create fresh copies of the default built-in
    bridge. There’s one important difference we’ll look at later in this technique,
    though—in non-default bridges, you can ping containers by name.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的“桥接”驱动程序可能是最常用的驱动程序——它是官方支持的，并允许您创建默认内置桥接的新副本。然而，在这个技术中，我们将稍后探讨一个重要的区别——在非默认桥接中，您可以通过名称ping容器。
- en: 'You can see the list of built-in networks with the `docker network ls` command:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker network ls`命令查看内置网络列表：
- en: '[PRE94]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here you can see the three networks that are always available for containers
    to join on my machine. The `bridge` network is where containers end up by default,
    with the ability to talk to other containers on the bridge. The `host` network
    specifies what happens when you use `--net=host` when starting a container (the
    container sees the network as any normal program running on your machine would),
    and `none` corresponds to `--net=none`, a container that only has the loopback
    interface.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在我的机器上始终可用的三个网络，容器可以加入这些网络。`bridge` 网络是容器默认到达的地方，能够与其他桥接上的容器通信。`host`
    网络指定了在启动容器时使用 `--net=host` 的情况（容器将网络视为机器上运行的任何正常程序），而 `none` 对应于 `--net=none`，这是一个只有回环接口的容器。
- en: 'Let’s add a new `bridge` network, providing a new flat network for containers
    to freely communicate in:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个新的 `bridge` 网络，为容器提供一个新的平坦网络以自由通信：
- en: '[PRE95]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This has created a new network interface that will use a different IP address
    range than the normal Docker bridge. For bridges, the new network interface name
    will currently begin with `br-`, but this may change in future.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个新的网络接口，它将使用与正常 Docker 桥接不同的 IP 地址范围。对于桥接，新的网络接口名称目前将以 `br-` 开头，但将来可能会改变。
- en: 'Let’s now start up two containers attached to the network:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在启动两个连接到网络的容器：
- en: '[PRE96]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1*** **Starts a container with name c1 (on the default bridge)**'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **启动名为 c1 的容器（在默认桥接上）**'
- en: '***2*** **Connects container c1 with the mynet network**'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将容器 c1 连接到 mynet 网络**'
- en: '***3*** **Creates a container named c2 inside the mynet network**'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在 mynet 网络中创建名为 c2 的容器**'
- en: '***4*** **Starts a container with name c3 (on the default bridge)**'
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **启动名为 c3 的容器（在默认桥接上）**'
- en: The preceding commands demonstrate two different ways of connecting a container
    to a network—starting the container and then attaching the service, and creating
    and attaching in one step.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令展示了将容器连接到网络的两种不同方式——先启动容器然后附加服务，以及一步创建和附加。
- en: There’s a difference between these two. The first will join the default network
    on startup (usually the Docker bridge, but this is customizable with an argument
    to the Docker daemon), and then will add a new interface so it can access mynet
    as well. The second will *just* join mynet—any containers on the normal Docker
    bridge will be unable to access it.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况有所不同。第一个会在启动时连接到默认网络（通常是 Docker 桥接网络，但可以通过 Docker 守护进程的参数进行自定义），然后添加一个新的接口，以便它也能访问
    mynet。第二个只会连接到 mynet——任何在正常 Docker 桥接上的容器都无法访问它。
- en: 'Let’s do some connectivity checks. First we should take a look at the IP addresses
    of our container:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些连通性检查。首先我们应该查看我们容器的 IP 地址：
- en: '[PRE97]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '***1*** **Lists the interfaces and IP addresses for c1—one on the default bridge,
    one in mynet**'
  id: totrans-1100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **列出 c1 的接口和 IP 地址——一个在默认桥接上，一个在 mynet 中**'
- en: '***2*** **Lists the interface and IP address for c2, inside mynet**'
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **列出 mynet 内 c2 的接口和 IP 地址**'
- en: '***3*** **Lists the interface and IP address for c3, on the default bridge**'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **列出默认桥接上 c3 的接口和 IP 地址**'
- en: 'Now we can do some connectivity tests:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行一些连通性测试：
- en: '[PRE98]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1*** **Attempts to ping the name for container 1 from container 2 (success)**'
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **尝试从容器 2 ping 容器 1 的名称（成功）**'
- en: '***2*** **Attempts to ping the name and IP address for container 3 from container
    2 (failure)**'
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **尝试从容器 2 ping 容器 3 的名称和 IP 地址（失败）**'
- en: '***3*** **Attempts to ping the name for container 2 from container 1 (success)**'
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **尝试从容器 1 ping 容器 2 的名称（成功）**'
- en: '***4*** **Attempts to ping the name and IP address for container 3 from container
    1 (failure, success)**'
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **尝试从容器 1 ping 容器 3 的名称和 IP 地址（失败，成功）**'
- en: 'There’s a lot going on here! These are the key takeaways:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情！以下是关键要点：
- en: On the new bridge, containers can ping each other with IP address and name.
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的桥接上，容器可以通过 IP 地址和名称相互 ping。
- en: On the default bridge, containers can only ping each other by IP address.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在默认桥接上，容器只能通过 IP 地址相互 ping。
- en: Containers straddling multiple bridges can access containers from any network
    they’re a member of.
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横跨多个桥接的容器可以访问它们所属的任何网络中的容器。
- en: Containers can’t access each other at all across bridges, even with an IP address.
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间无法通过桥接相互访问，即使使用 IP 地址。
- en: '**DISCUSSION**'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This new bridge creation functionality was used in [technique 77](#ch10sb03)
    with Docker Compose and [technique 79](#ch10sb05) with Blockade to provide the
    ability for containers to ping each other by name. But you’ve also seen that this
    is a highly flexible piece of functionality with the potential to model reasonably
    complex networks.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的桥接器创建功能在[技术77](#ch10sb03)中使用Docker Compose，在[技术79](#ch10sb05)中使用Blockade时被使用，以提供容器通过名称ping对方的能力。但你也已经看到，这是一个高度灵活的功能，具有建模合理复杂网络的可能性。
- en: For example, you might want to experiment with a *bastion host*, a single locked-down
    machine that provides access to another higher-value network. By putting your
    application services in a new bridge and then only exposing services via a container
    connected to both the default and new bridges, you can start running somewhat
    realistic penetration tests while staying isolated on your own machine.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想尝试使用一个*堡垒主机*，一个单独的锁定机器，它为访问另一个价值更高的网络提供访问权限。通过将你的应用程序服务放在一个新的桥接器中，然后仅通过连接到默认和新的桥接器的容器来公开服务，你可以在保持自己机器隔离的同时开始运行一些相对现实的渗透测试。
- en: '|  |'
  id: totrans-1117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Setting up a substrate network with Weave**'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Weave设置底物网络**'
- en: 'A substrate network is a software-level network layer built on top of another
    network. In effect, you end up with a network that appears to be local, but under
    the hood it’s communicating across other networks. This means that performance-wise,
    the network will behave less reliably than a local network, but from a usability
    point of view it can be a great convenience: you can communicate with nodes in
    completely different locations as though they were in the same room.'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 底物网络是在另一个网络之上构建的软件级网络层。实际上，你最终得到一个看起来像是本地的网络，但在底层它是在其他网络之间进行通信。这意味着从性能的角度来看，网络的行为将不如本地网络可靠，但从可用性的角度来看，它可以非常方便：你可以像它们在同一房间里一样与完全不同位置的节点通信。
- en: This is particularly interesting for Docker containers—containers can be seamlessly
    connected across hosts in the same way as connecting hosts across networks. Doing
    this removes any urgent need to plan how many containers you can fit on a single
    host.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于Docker容器来说尤其有趣——容器可以在主机之间无缝连接，就像在网络之间连接主机一样。这样做消除了对计划单个主机上可以容纳多少容器的迫切需求。
- en: '**PROBLEM**'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to seamlessly communicate between containers across hosts.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在主机之间无缝地通信容器。
- en: '**SOLUTION**'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Weave Net (referred to as just “Weave” for the rest of this technique) to
    set up a network that lets containers talk to each other as if they’re on a local
    network together.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Weave Net（在本技术中其余部分简称为“Weave”）来设置一个网络，允许容器像在本地网络中一样相互通信。
- en: We’re going to demonstrate the principle of a substrate network with Weave ([https://www.weave.works/oss/net/](https://www.weave.works/oss/net/)),
    a tool designed for this purpose. [Figure 10.3](#ch10fig03) shows an overview
    of a typical Weave network.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Weave ([https://www.weave.works/oss/net/](https://www.weave.works/oss/net/))来演示底物网络的原理，这是一个为此目的设计的工具。[图10.3](#ch10fig03)展示了典型Weave网络的概览。
- en: Figure 10.3\. A typical Weave network
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3.一个典型的Weave网络
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-1128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig03_alt.jpg)'
- en: In [figure 10.3](#ch10fig03), host 1 has no access to host 3, but they can talk
    to each other over the Weave network as though they were locally connected. The
    Weave network isn’t open to the public—only to those containers started up under
    Weave. This makes the development, testing, and deployment of code across different
    environments relatively straightforward, because the network topology can be made
    the same in each case.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10.3](#ch10fig03)中，主机1无法访问主机3，但它们可以通过Weave网络相互通信，就像它们是本地连接的一样。Weave网络不对公众开放——只对在Weave下启动的容器开放。这使得在不同环境中开发、测试和部署代码相对简单，因为网络拓扑可以在每种情况下都保持一致。
- en: '**Installing Weave**'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装Weave**'
- en: Weave is a single binary. You can find installation instructions at [https://www.weave.works/docs/net/latest/install/installing-weave/](https://www.weave.works/docs/net/latest/install/installing-weave/).
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: Weave是一个单一的二进制文件。你可以在[https://www.weave.works/docs/net/latest/install/installing-weave/](https://www.weave.works/docs/net/latest/install/installing-weave/)找到安装说明。
- en: 'The instructions in the preceding link (and listed below for convenience) worked
    for us. Weave needs to be installed on every host that you want to be part of
    your Weave network:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前链接（以及以下方便起见列出）中的说明对我们有效。Weave需要安装在你希望成为Weave网络一部分的每个主机上：
- en: '[PRE99]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '|  |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you experience problems with this technique, there may already be a Weave
    binary on your machine that’s part of another software package.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在此技术中遇到问题，你的机器上可能已经有一个Weave二进制文件，它是另一个软件包的一部分。
- en: '|  |'
  id: totrans-1137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up Weave**'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置Weave**'
- en: To follow this example, you’ll need two hosts. We’ll call them `host1` and `host2`.
    Make sure they can talk to each other by using ping. You’ll need the IP address
    of the first host you start Weave on.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循此示例，你需要两个主机。我们将它们称为`host1`和`host2`。确保它们可以通过ping相互通信。你需要第一个启动Weave的主机的IP地址。
- en: A quick way to get a host’s public IP address is by accessing [https://ifconfig.co/](https://ifconfig.co/)
    with a browser, or by running `curl https://ifconfig.co`, but be aware that you’ll
    probably need to open firewalls for the two hosts to connect across the open internet.
    You can also run Weave on a local network if you select the correct IP address.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 获取主机公共IP地址的一个快速方法是使用浏览器访问[https://ifconfig.co/](https://ifconfig.co/)，或者运行`curl
    https://ifconfig.co`，但请注意，你可能需要为两个主机打开防火墙，以便它们可以通过开放的互联网连接。如果你选择正确的IP地址，你还可以在本地网络中运行Weave。
- en: '|  |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you experience problems with this technique, it’s likely that the network
    is firewalled in some way. If you’re not sure, talk to your network administrator.
    Specifically, you’ll need to have port 6783 open for both TCP and UDP, and 6784
    for UDP.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用此技术时遇到问题，很可能是网络以某种方式被防火墙隔离。如果你不确定，请咨询你的网络管理员。具体来说，你需要确保端口6783对TCP和UDP都开放，端口6784仅对UDP开放。
- en: '|  |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'On the first host, you can run the first Weave router:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个主机上，你可以运行第一个Weave路由器：
- en: '[PRE100]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '***1*** **Determines host1’s IP address**'
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确定host1的IP地址**'
- en: '***2*** **Launches the Weave service on host1\. This needs to be done once
    on each host, and it will download and run some Docker containers to run in the
    background to manage the substrate network.**'
  id: totrans-1148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在host1上启动Weave服务。这需要在每个主机上执行一次，并且它将下载并运行一些Docker容器，在后台运行以管理底层数据网络。**'
- en: '***3*** **Sets up the docker command in this shell to use Weave. If you close
    your shell or open a new one, you’ll need to run this command again.**'
  id: totrans-1149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在此shell中设置docker命令以使用Weave。如果你关闭了shell或打开了一个新的shell，你需要再次运行此命令。**'
- en: '***4*** **Starts the container**'
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **启动容器**'
- en: '***5*** **Retrieves the IP address of the container on the Weave network**'
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **检索Weave网络上容器的IP地址**'
- en: Weave takes care of inserting an additional interface into the container, `ethwe`,
    which provides an IP address on the Weave network.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: Weave负责在容器中插入一个额外的接口`ethwe`，它为Weave网络提供一个IP地址。
- en: 'You can perform similar steps on `host2`, but telling Weave about the location
    of host1:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`host2`上执行类似的步骤，但需要告诉Weave关于host1位置的信息：
- en: '[PRE101]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1*** **Launches the Weave service on host2 as root. This time you add the
    first host’s public IP address so it can attach to the other host.**'
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以root用户在host2上启动Weave服务。这次你需要添加第一个主机的公共IP地址，以便它可以连接到另一台主机。**'
- en: '***2*** **Sets up your environment appropriately for Weave’s service**'
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为Weave的服务设置适当的环境**'
- en: '***3*** **Continues as with hostl**'
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **与host1的步骤相同**'
- en: The only difference on `host2` is that you tell Weave that it should peer with
    the Weave on `host1` (specified with the IP address or hostname, and optional
    `:port`, by which host2 can reach it).
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`host2`上唯一的区别是，你需要告诉Weave它与`host1`上的Weave进行对等连接（通过IP地址或主机名指定，可选的`:port`，这样host2就可以到达它）。
- en: '**Testing your connection**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的连接**'
- en: 'Now that you’ve got everything set up, you can test whether your containers
    can talk to each other. Let’s take the container on `host2`:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置好了一切，你可以测试你的容器是否可以相互通信。让我们以`host2`上的容器为例：
- en: '[PRE102]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1*** **Pings the other server’s assigned IP address**'
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **ping其他服务器分配的IP地址**'
- en: '***2*** **A successful ping response**'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **成功的ping响应**'
- en: If you get a successful ping, you’ve proven connectivity within your self-assigned
    private network spanning two hosts. You’re also able to ping by container name,
    as with a custom bridge.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到成功的ping响应，你已证明在跨越两个主机的自分配私有网络内存在连接性。你也能够通过容器名称ping，就像使用自定义网桥一样。
- en: '|  |'
  id: totrans-1165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It’s possible that this won’t work due to ICMP protocol (used by ping) messages
    being blocked by a firewall. If this doesn’t work, try telnetting to port 6783
    on the other host to test whether connections can be made.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ICMP协议（ping使用）消息可能被防火墙阻止，因此这可能不起作用。如果不起作用，尝试在另一台主机上telnet到端口6783以测试是否可以建立连接。
- en: '|  |'
  id: totrans-1168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: A substrate network is a powerful tool for imposing some order on the occasionally
    chaotic world of networks and firewalls. Weave even claims to intelligently route
    your traffic across partially partitioned networks, where some host B can see
    A and C, but A and C can’t talk—this may be familiar from [technique 80](#ch10sb06).
    That said, bear in mind that sometimes these complex network setups exist for
    a reason—the whole point of bastion hosts is isolation for the sake of security.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 子网是强有力地使网络和防火墙偶尔混乱的世界有秩序的工具。Weave 甚至声称可以智能地路由您的流量穿过部分分割的网络，其中某些主机 B 可以看到 A 和
    C，但 A 和 C 不能通信—这可能会在[技术 80](#ch10sb06)中熟悉。尽管如此，请记住，有时这些复杂的网络设置存在是有原因的——堡垒主机的全部目的就是为了安全而隔离。
- en: All of this power comes at a cost—there are reports of Weave networks sometimes
    being significantly slower than “raw” networks, and you have to run additional
    management machinery in the background (because the plugins model for networks
    doesn’t cover all use cases).
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些功能都付出了代价—有报道称 Weave 网络有时比“原始”网络慢得多，并且您必须在后台运行额外的管理工具（因为网络插件模型不涵盖所有用例）。
- en: The Weave network has many additional pieces of functionality, from visualization
    to integration with Kubernetes (we’ll introduce Kubernetes as an orchestrator
    in [technique 88](kindle_split_024.xhtml#ch12sb03)). We recommend you look at
    the Weave Net overview to find out more and get the most out of your network—[https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: Weave 网络具有许多额外的功能，从可视化到与 Kubernetes 的集成（我们将在[技术 88](kindle_split_024.xhtml#ch12sb03)中介绍
    Kubernetes 作为编排器）。我们建议您查看 Weave Net 概述以了解更多信息并充分利用您的网络—[https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/).
- en: One thing we haven’t covered here is the built-in overlay network plugin. Depending
    on your use case, this may be worth some research as a possible replacement for
    Weave, though it requires either use of Swarm mode ([technique 87](kindle_split_024.xhtml#ch12sb02))
    or setting up a globally accessible key/value store (perhaps etcd, from [technique
    74](kindle_split_020.xhtml#ch09sb06)).
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有涵盖的一件事是内置的覆盖网络插件。根据您的用例，这可能值得研究作为 Weave 的可能替代品，尽管它需要使用 Swarm 模式([技术 87](kindle_split_024.xhtml#ch12sb02))或设置一个全局可访问的键/值存储（可能是
    etcd，来自[技术 74](kindle_split_020.xhtml#ch09sb06))。
- en: '|  |'
  id: totrans-1174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-1175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Docker Compose can be used to set up clusters of containers.
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 可以用来设置容器集群。
- en: Comcast and Blockade are both useful tools for testing containers in bad networks.
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 康卡斯特和Blockade都是测试坏网络中容器的有用工具。
- en: Docker virtual networks are an alternative to linking.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 虚拟网络是链接的替代方案。
- en: You can manually model networks in Docker with virtual networks.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用虚拟网络在 Docker 中手动建模网络。
- en: Weave Net is useful for stringing containers together across hosts.
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weave Net 对于在主机之间连接容器很有用。
