- en: 12 Are we there yet?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 我们到了吗？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Debugging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具
- en: Networking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络通信
- en: Collaboration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作
- en: Are we there yet?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到了吗？
- en: So help me, I will turn this book around!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，请相信我，我会把这个书翻过来！
- en: Joking aside, reading this book provides a great leap forward for a Python developer.
    If you’ve worked through the examples and built the MyBlog code, you’ve created
    an interesting application and managed the complexity of doing so. You’ve pulled
    together tools and techniques from many software engineering domains to create
    a cohesive whole that delivers useful functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，阅读这本书为Python开发者提供了一个巨大的飞跃。如果您已经完成了示例并构建了MyBlog代码，您已经创建了一个有趣的应用程序并管理了实现它的复杂性。您已经从许多软件工程领域汇集了工具和技术，以创建一个统一的整体，提供有用的功能。
- en: What’s more, you’ve followed good practices to manage the complexity of the
    application. Having managed that complexity means the MyBlog application is maintainable
    over time and can be expanded on without making the structure brittle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，您已经遵循了良好的实践来管理应用程序的复杂性。管理这种复杂性意味着MyBlog应用程序随着时间的推移是可维护的，并且可以在不使结构脆弱的情况下进行扩展。
- en: To answer the question “Are we there yet?” elicits the age-old response, “Well,
    yes and no.” Let’s talk about why the answer isn’t definitive and how that’s an
    energizing and exciting invitation to an adventurous journey to expand your skills
    as a developer even further.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答“我们到了吗？”这个问题，会引发古老的回答，“嗯，是的，也不是。”让我们谈谈为什么这个答案不是确定的，以及这如何成为一次充满活力和令人兴奋的邀请，去进行一次冒险之旅，进一步扩展你作为开发者的技能。
- en: 12.1 Testing
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 测试
- en: An important aspect of creating software applications is testing them. I purposefully
    haven’t included any discussion, or examples, of testing the code presented in
    this book. I did this for a couple of reasons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建软件应用程序的一个重要方面是测试它们。我故意没有包括任何关于测试本书中展示的代码的讨论或示例。我这样做有几个原因。
- en: First, writing test code often creates as much, if not more, code than the application
    being tested. This isn’t a reason to avoid it, but in the context of this book,
    it would have added another technical domain of work over the examples. It would
    have also detracted from the educational intent of those examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写测试代码往往会产生与被测试的应用程序一样多，如果不是更多，的代码。这并不是避免它的理由，但在本书的上下文中，它会在示例之上增加另一个技术工作领域。这也会分散那些示例的教育意图。
- en: Second, software testing is a big subject and warrants its own book. Including
    a subset of what software testing means would have done the subject matter, and
    you, a disservice. A great book about testing in the Python world is Brian Okken’s
    Python Testing with pytest ([http://mng.bz/Zql9](http://mng.bz/Zql9)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，软件测试是一个很大的主题，值得有它自己的书。包括软件测试含义的一部分会对主题和您都造成不利。关于Python世界测试的伟大书籍是Brian Okken的《Python
    Testing with pytest》（[http://mng.bz/Zql9](http://mng.bz/Zql9)）。
- en: Testing software benefits from automation in every way. Using testing tools
    and frameworks (like pytest) to automate tests provides consistency and early
    warnings if conditions change during development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试从自动化中受益于各个方面。使用测试工具和框架（如pytest）来自动化测试提供了一致性，并在开发过程中条件发生变化时提供早期警告。
- en: Also, in most cases, it’s better if people other than the developer of the application
    perform the testing. It’s far too easy as a developer to unconsciously follow
    the “happy path” that produces the desired results. This is very different from
    what users of your software do. They will push your software to its limits with
    edge cases and unintended boundary conditions. That being said, there are many
    types of testing to consider that apply to the applications and code you develop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数情况下，如果测试不是由应用程序的开发者执行，那就更好了。作为开发者，无意识地遵循“快乐路径”以产生期望的结果是非常容易的。这与您的软件用户所做的事情非常不同。他们会通过边缘情况和未预见的边界条件来推动您的软件达到极限。话虽如此，有许多类型的测试需要考虑，这些测试适用于您开发和开发的应用程序。
- en: 12.1.1 Unit testing
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 单元测试
- en: Unit testing is one of the cases where the developer of an application creates
    the tests. A unit test isolates a function or component and validates that it
    handles the inputs passed to the function and produces the expected outputs. Besides
    testing that the expected inputs produce the expected outputs, the tests should
    exercise edge cases. The tests should determine if the function reasonably handles
    unexpected inputs and if the output is an expected error condition or exception.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是应用程序开发者创建测试的情况之一。单元测试隔离一个函数或组件，并验证它是否处理传递给函数的输入并产生预期的输出。除了测试预期的输入产生预期的输出外，测试还应练习边缘情况。测试应确定函数是否合理地处理意外的输入，以及输出是否是预期的错误条件或异常。
- en: Unit tests should only examine the function or component being tested and not
    dependencies on external resources outside the test framework’s ability to control
    or predict. Accessing a database, a network, or some unpredictable timing operation
    can cause a test to fail because the resource failed. In those cases, the external
    resource must be “mocked” to make the test repeatable. Mocking an external resource
    replaces the actual resource object with something that simulates its behavior
    but in a repeatable, dependable way.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应仅检查正在测试的函数或组件，而不是测试框架无法控制或预测的外部资源的依赖。访问数据库、网络或某些不可预测的时间操作可能导致测试失败，因为资源失败。在这些情况下，外部资源必须被“模拟”以使测试可重复。模拟外部资源是用模拟其行为但以可重复、可靠的方式替换实际资源对象。
- en: 12.1.2 Functional testing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 功能测试
- en: Functional testing builds on unit testing by examining the functionality of
    systems and subsystems, which are built on functions and components. The purpose
    of the tests is to compare the actual functionality of a system against the requirements
    of that system. This draws on the specification to guide the development of a
    system and its intended purpose.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试建立在单元测试的基础上，通过检查系统和子系统的功能，这些系统和子系统建立在函数和组件之上。测试的目的是将系统的实际功能与该系统的需求进行比较。这依赖于规格说明来指导系统的开发和其预期目的。
- en: 12.1.3 End-to-end testing
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 端到端测试
- en: End-to-end (e2e) testing determines if the workflows provided by an application
    behave as expected from beginning to end. Is a user able to start, continue, and
    complete the process that the application is intended to provide?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端（e2e）测试确定应用程序提供的流程是否从开始到结束都按预期行为。用户是否能够开始、继续并完成应用程序旨在提供的流程？
- en: 12.1.4 Integration testing
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 集成测试
- en: Integration testing is similar to end-to-end testing with the addition that
    a system is run on the target hardware and in the environment where the application
    will be deployed. This isn’t always possible, but steps should be taken to get
    as close to the target hardware and environment as reasonably practical.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试类似于端到端测试，但增加了系统在目标硬件和应用程序将部署的环境中运行。这并不总是可能的，但应采取步骤尽可能接近目标硬件和环境。
- en: 12.1.5 Load testing
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.5 压力测试
- en: Load testing determines if an application running on its target hardware in
    its expected environment can handle the workload for which it’s designed. Unit
    tests often use small subsets of controlled data to exercise functionality. Load
    testing data sets can be much larger to simulate actual use case data-handling
    expectations. For multi-user systems, like web applications, load testing also
    examines whether a system can handle the number of simultaneous users expected
    to access the system and remain responsive enough to meet their needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试确定在目标硬件上运行并处于预期环境中的应用程序是否能够处理其设计的负载。单元测试通常使用受控数据的小子集来测试功能。负载测试数据集可以大得多，以模拟实际用例的数据处理预期。对于多用户系统，如Web应用程序，负载测试还检查系统是否能够处理预期同时访问系统的用户数量，并且足够响应以满足他们的需求。
- en: 12.1.6 Performance testing
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.6 性能测试
- en: Performance testing determines if a system meets the performance requirements.
    The requirements can be expressed in terms of speed of processing, handling a
    specified number of multiple requests, the throughput of data, and other metrics.
    This kind of testing is dependent on a clear understanding of what the performance
    metrics are, how they will be measured, and that users and developers understand
    and agree on both.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试确定系统是否满足性能要求。这些要求可以用处理速度、处理指定数量的多个请求、数据处理吞吐量和其他指标来表示。这种测试依赖于对性能指标有清晰的理解，如何进行测量，以及用户和开发者都理解和同意这些指标。
- en: 12.1.7 Regression testing
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.7 回归测试
- en: Regression testing helps developers discover if code modifications in a system
    break functionality, adversely affect resource consumption, or change performance
    characteristics. Regression testing can automate examining and reporting on the
    results of end-to-end tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试帮助开发者发现系统中的代码修改是否破坏了功能、对资源消耗产生不利影响或改变了性能特征。回归测试可以自动化检查和报告端到端测试的结果。
- en: 12.1.8 Accessibility testing
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.8 可访问性测试
- en: Accessibility testing is very dependent on who the audience is for the software
    you develop. If you are creating library code for users who are other developers,
    accessibility problems might focus on the developer experience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性测试非常依赖于你开发的软件的受众是谁。如果你正在为其他开发者创建库代码，可访问性问题可能集中在开发者体验上。
- en: However, if you are creating mobile or web applications that will be generally
    available to anyone, you need to think about how users with disabilities will
    access your application. The relevant disabilities can include vision and hearing
    impairment and other physical and cognitive concerns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你正在创建将向任何人普遍提供的移动或Web应用程序，你需要考虑残疾用户如何访问你的应用程序。相关的残疾可能包括视力或听力障碍以及其他身体和认知问题。
- en: 12.1.9 Acceptance testing
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.9 接受测试
- en: Acceptance testing is focused on whether software, or an application, meets
    the requirements that initiated creating it. The requirements can be defined by
    yourself, your colleagues, your company, or your customers. These are the stakeholders
    who determine if an application meets the agreed-upon requirements and can be
    considered complete.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试关注的是软件或应用程序是否满足启动其创建的要求。这些要求可以由你自己、你的同事、你的公司或你的客户定义。这些是决定应用程序是否满足既定要求并可视为完整的项目利益相关者。
- en: It’s enticing to assume that a fully complete and clear specification document
    is a necessity for acceptance testing. In my experience, for the average software
    project, no such document exists. Requirements are often vague and open-ended,
    which can lead to wildly different assumptions and understandings between users
    and developers about an application’s functionality. Misunderstandings like this
    can cause the relationship between the end user and the developer to become adversarial,
    especially in situations where the developer accepts the requirements, and the
    user isn’t involved in acceptance testing until the end of the project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个完整且清晰的规范文档是接受测试的必要条件是很诱人的。根据我的经验，对于平均的软件项目，通常不存在这样的文档。需求往往是模糊和开放式的，这可能导致用户和开发者对应用程序功能的不同假设和理解。这种误解可能导致最终用户和开发者之间的关系变得对抗性，尤其是在开发者接受需求，而用户直到项目结束时才参与接受测试的情况下。
- en: A different approach can often create a better path toward acceptance, with
    agreement all around. Because requirements are often insufficiently defined, it’s
    better if the developer involves the user in an iterative process. As features
    are developed, they are demonstrated to the user, and course corrections are addressed
    as the product and its requirements are better understood by both parties.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 采取不同的方法通常可以创造一条更好的接受路径，并得到各方面的同意。因为需求往往定义不足，所以开发者最好在迭代过程中让用户参与。随着功能的开发，它们被展示给用户，并且当产品及其需求被双方更好地理解时，会针对课程修正进行解决。
- en: Iterative development and acceptance-testing practice can turn an adversarial
    relationship into a more collaborative one. The final acceptance testing is more
    likely to be successful because the project outcome has been participated in by
    both the user and developer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代开发和接受测试实践可以将对抗性关系转变为更协作的关系。最终的接受测试更有可能成功，因为项目成果是由用户和开发者共同参与的。
- en: 12.2 Debugging
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 调试
- en: If you attempted any of the examples, modified them, or wrote programs of your
    own, you’ve run into bugs in the code. There are no perfect programs, and bugs
    are part of a developer’s life. There are runtime errors such as trying to divide
    by zero, and there are logical errors where the results of a program are not what
    you want or expect. Growing as a developer includes being able to find and fix
    problems—our own or others’—in program code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过任何示例、修改过它们或编写了自己的程序，你已经在代码中遇到了错误。没有完美的程序，错误是开发者生活的一部分。存在运行时错误，如尝试除以零，以及逻辑错误，即程序的结果不是你想要的或预期的。作为开发者成长包括能够找到和修复程序代码中的问题——无论是自己的还是他人的。
- en: 12.2.1 Reproducing bugs
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 重现错误
- en: Before diving in and reading thousands, perhaps tens of thousands, of lines
    of code, it’s essential to determine if the bug can be reproduced. Is there a
    series of steps you can take to cause the bug to occur reliably? Is there a set
    of data you can feed to the program to cause the bug to appear?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入阅读数千行，甚至数万行代码之前，确定错误是否可以重现是至关重要的。是否存在一系列可以采取的步骤来可靠地引发错误？是否存在一组可以提供给程序的数据来引发错误？
- en: It’s far more difficult to find and fix a bug if you can’t exercise the bug
    consistently. This can mean taking the time to write harness code, or unit tests,
    to isolate the problem and inform you when the problem is resolved.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法一致地执行错误，找到和修复错误就变得非常困难。这可能意味着需要花费时间编写封装代码或单元测试来隔离问题并告知问题何时得到解决。
- en: 12.2.2 Breakpoints
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 断点
- en: Using a debugger to set breakpoints as part of your toolset is very effective
    for finding bugs in applications. A breakpoint is a location that you set in your
    application that triggers the application to stop running and transfer control
    to the debugger.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试器设置为断点作为你的工具集的一部分，对于在应用程序中查找错误非常有效。断点是在你的应用程序中设置的一个位置，当应用程序运行到该位置时，会停止运行并将控制权传递给调试器。
- en: When a debugger intercepts a breakpoint, you can examine the state of the running
    application at that time. You can view variables, evaluate statements, and single-step
    to the next line of code to see the results.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试器拦截断点时，你可以检查运行中的应用程序在该时刻的状态。你可以查看变量、评估语句，并单步执行到下一行代码以查看结果。
- en: Many debuggers can set conditional breakpoints, which are only triggered if
    certain conditions are true. For example, you can reproduce a bug, but only after
    thousands of iterations through a large data set. A conditional breakpoint can
    be set to trigger when a counter is equal to the number of iterations needed to
    trigger the bug. Examining code at a breakpoint is a valuable tool to ascertain
    what’s occurring in an application at that snapshot of time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多调试器可以设置条件断点，这些断点仅在特定条件为真时才会触发。例如，你可以重现一个错误，但只有在经过数千次通过大量数据集的迭代之后。可以设置一个条件断点，在计数器等于触发错误所需的迭代次数时触发。在断点处检查代码是确定在那个时间点应用程序中发生什么的有价值工具。
- en: 12.2.3 Logging
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 记录日志
- en: Being able to observe the state of an application at a breakpoint is valuable,
    but sometimes you’ll need to see the history of events as well. Logging events
    over the runtime of an application gives you a view of the path an application
    has taken through the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在断点处观察应用程序的状态是有价值的，但有时你还需要看到事件的历史。在应用程序运行期间记录事件，为你提供了应用程序通过代码所走过的路径的视图。
- en: Adding a timestamp to those logging events also gives you a chronology of those
    events, when they occurred, and how much time has transpired between them. You
    can add print statements for this, but Python provides a better tool—the logging
    system. The Python logger module adds a great deal of visibility to the inner
    workings of your applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间戳添加到这些日志事件中，也为你提供了这些事件的编年史，包括它们发生的时间以及它们之间经过的时间。你可以添加打印语句来做到这一点，但Python提供了一个更好的工具——日志系统。Python的日志模块为你的应用程序的内部工作提供了大量的可见性。
- en: If you add `logger.debug(...)` statements to your code, you can log as much
    information as you need to help debug an application. Then, when the application
    is deployed, the `logger.level` can be set to `INFO` and the debug statements
    are ignored. This means the `logger.debug(...)` statements can be left in the
    code, unlike print statements, which should usually be removed to declutter the
    application’s log output. If another bug manifests, the `logger.level` can be
    set to `DEBUG` and your `logger.debug(...)` statements become active again to
    assist with finding and resolving a new bug.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中添加了 `logger.debug(...)` 语句，你可以记录所需的所有信息来帮助调试应用程序。然后，当应用程序部署后，可以将 `logger.level`
    设置为 `INFO`，这样调试语句就会被忽略。这意味着 `logger.debug(...)` 语句可以保留在代码中，而与通常需要从应用程序的日志输出中移除的打印语句不同。如果出现另一个错误，可以将
    `logger.level` 设置为 `DEBUG`，这样你的 `logger.debug(...)` 语句就会再次激活，以帮助找到和解决新的错误。
- en: 12.2.4 Bad results
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 不良结果
- en: Is the bug an application crash or are bad results being produced? In this case,
    it’s very useful to use a debugger (standalone or built into an IDE) to understand
    the state of the application at the point the bug occurs or is about to occur.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是应用程序崩溃还是产生了不良结果？在这种情况下，使用调试器（独立或集成在IDE中）来了解错误发生或即将发生的应用程序状态非常有用。
- en: Looking for the computation that generated the bad results can mean moving back
    and forth in the call stack (order of operations and function calls) to observe
    the values that contribute to the results. A pad and pencil, or a text editor,
    are useful here to keep track of these intermediary values. If the computations
    look right, perhaps the data set being fed to the application contains bad data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找产生不良结果的计算可能意味着在调用栈（操作顺序和函数调用）中来回移动，以观察对结果有贡献的值。这里可以使用便签纸和铅笔，或者文本编辑器，来跟踪这些中间值。如果计算看起来是正确的，那么可能被应用程序提供的数据集包含不良数据。
- en: 12.2.5 Process of elimination
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 排除法
- en: Often, the search for a bug is a process of elimination, constantly narrowing
    down the domain where the bug lives until you find it. This process can be in
    the code or the data. Using debugger breakpoints or logging statements can help
    narrow the domain in the code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，寻找错误是一个排除过程，不断缩小错误存在的领域，直到找到它。这个过程可能发生在代码或数据中。使用调试器断点或日志语句可以帮助缩小代码中的领域。
- en: If you suspect the input data set is the source of the problem, use a divide-and-conquer
    approach to narrow in on the problem data. Cut the data in half and feed one half
    at a time to the application. Continue to repeat this process with the half that
    exhibited the problem until you find the value(s) that are triggering the bad
    results. Even with huge datasets, this process takes relatively few iterations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑输入数据集是问题的根源，使用分而治之的方法来缩小问题数据。将数据分成两半，一次只向应用程序提供一半。继续重复这个过程，直到找到触发不良结果的值。即使对于大型数据集，这个过程也需要相对较少的迭代。
- en: 12.2.6 Rubber-ducking the problem
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6 橡皮鸭问题
- en: Perhaps the simplest, and sometimes most effective, path to a solution is to
    talk about the problem with a friend or colleague. The act of putting your thoughts
    into words that clarify the problem for your audience often presents the solution
    or a path to the solution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单，有时也是最有成效的解决问题的途径是与朋友或同事讨论问题。将你的想法用语言表达出来，以澄清问题，这通常能提出解决方案或通往解决方案的途径。
- en: 12.3 Tools
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 工具
- en: Like any complex, interesting task, there are tools available to help you accomplish
    your goals. Learning about useful tools and becoming proficient with them makes
    you a much more powerful developer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何复杂而有趣的任务一样，都有可用的工具帮助你实现目标。了解有用的工具并熟练掌握它们可以使你成为一个更强大的开发者。
- en: 12.3.1 Source control
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 源代码控制
- en: The example code accompanying this book resides in a Git repository hosted on
    GitHub. Git is one tool used to create repositories for the source-code files
    necessary to create applications. Repository tools help manage the history of
    a project’s development and the documentation of that history.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随本书的示例代码存储在GitHub上托管的Git仓库中。Git是用于创建创建应用程序所需的源代码文件的仓库的工具之一。仓库工具有助于管理项目开发的历史和该历史的文档。
- en: If you’re working as the sole developer of an application, it’s still well worth
    learning how to use a source-code management tool. Being able to review and restore
    the history of your work can be invaluable while working on a complex application
    over time. If you’re part of a team working on an application, source control
    is a necessity to help manage and prevent collisions while more than one person
    works on the same section of code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个应用程序的唯一开发者，学习如何使用源代码管理工具仍然是非常有价值的。能够审查和恢复你工作的历史，在长时间开发复杂应用程序时可能非常有价值。如果你是团队中的一员，正在开发应用程序，源代码控制是必需的，以帮助管理和防止多人同时工作在相同代码部分时的冲突。
- en: Lastly, using a hosted solution like GitHub offers a stable and convenient backup
    solution, over and above any backup system you maintain locally. You do backup
    your hard disk, don’t you?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用像GitHub这样的托管解决方案提供了一种稳定且方便的备份解决方案，这超出了你本地维护的任何备份系统。你确实备份了你的硬盘，不是吗？
- en: 12.3.2 Optimization
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 优化
- en: When I was first writing software, I had daydreams about creating games with
    moving images that reacted to the player’s input. At that time, computers were
    8-bit systems with some 16-bit functionality, very limited memory, and CPUs that
    ran in the single-digit megahertz range.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编写软件时，我幻想着创建能够对玩家输入做出反应的游戏，其中包含动态图像。当时，计算机是8位系统，带有一些16位功能，内存非常有限，CPU运行在单数兆赫兹范围内。
- en: With those goals, under those conditions, optimizing code for performance was
    a necessity. It was also a lot of fun figuring out how to pull a little more speed
    out of a system by using code only.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些目标下，在那些条件下，为了性能而优化代码是必要的。通过仅使用代码来找出如何从系统中提取更多速度也是一件很有趣的事情。
- en: The lure of optimization is a siren song drawing in many a developer. Software
    runs exceptionally fast on modern computers, and thinking about how you can make
    an application run faster by different implementations, data structures, caching,
    and a host of other techniques is tempting.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的诱惑就像是一个迷人的海妖之歌，吸引了许多开发者。软件在现代计算机上运行得特别快，思考如何通过不同的实现、数据结构、缓存以及其他众多技术来使应用程序运行更快是非常诱人的。
- en: The first element to consider when optimizing an application is the performance
    target. A general statement such as “make it faster” is not a clear requirement.
    Any reasonably complex application provides many features; you must determine
    which of those features is important to make faster, and by how much.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化应用程序时，首先需要考虑的是性能目标。像“让它更快”这样的泛泛之谈并不是一个明确的要求。任何合理复杂的应用程序都提供了许多功能；你必须确定哪些功能是重要的，以及需要提高多少。
- en: The second element to consider is measuring the performance of an application.
    It’s important to measure the current baseline performance to establish if changes
    in the application improve the performance at all.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的第二个要素是衡量应用程序的性能。测量当前基线性能对于确定应用程序中的更改是否改善了性能非常重要。
- en: While thinking about optimizing an application, it’s useful to keep the 90/10
    rule in mind. As a rule of thumb, many applications spend 90 percent of their
    time in 10 percent of the code. If you embark on an optimization journey, this
    rule implies that you spend 90 percent of your development time working on the
    10 percent of code where the application spends the bulk of its time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑优化应用程序时，记住90/10规则是有用的。作为一个经验法则，许多应用程序90%的时间都花在10%的代码上。如果你开始优化之旅，这条规则意味着你将90%的开发时间用于工作在应用程序大部分时间所花费的10%的代码上。
- en: Keep in mind a relevant concept I discussed in Chapter 1—optimizing your time
    as a developer. Reaching a “fast enough” state of an application that delivers
    the intended features right away is often more desirable than a marginally faster
    application that you deliver later. Remember the adage, “Shipping is a feature.”
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住我在第一章中讨论的一个相关概念——作为开发者优化你的时间。达到一个“足够快”的应用程序状态，即立即提供预期功能，通常比稍后交付的略微更快的应用程序更受欢迎。记住这句谚语，“交付本身就是一项功能。”
- en: Lastly, an application’s performance can be enormously improved by running it
    on a faster computer, on a network with more bandwidth, using a database with
    more capacity, and other dependencies outside of the application. These kinds
    of changes are often much less expensive in terms of developer time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在更快的计算机上运行，在带宽更宽的网络中运行，使用容量更大的数据库，以及其他应用程序之外的其他依赖项，可以极大地提高应用程序的性能。这类变化在开发者时间方面通常成本较低。
- en: Becoming proficient with a tool also means knowing when not to use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 精通一个工具也意味着知道何时不要使用它。
- en: 12.3.3 Containers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 容器
- en: A container provides an environment configured by the developer for an application
    to run in. In this way, an application in a container can run on any computing
    resource that can host the container. No matter what host the container runs on,
    the application in the container always interacts with the same environment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为应用程序提供一个由开发者配置的环境，以便应用程序在其中运行。这样，容器中的应用程序可以运行在任何可以托管容器的计算资源上。无论容器运行在哪个主机上，容器中的应用程序始终与相同的环境进行交互。
- en: The application in the container runs on what is commonly called a “guest” operating
    system. The guest operating system is a subset of a full operating system and
    is much smaller than a traditional virtual machine (VM). The application in the
    container makes calls to the guest OS for services, and the guest OS, in turn,
    makes calls to the “host” OS for services of the computing resource on which it
    resides.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的应用程序运行在通常称为“客户”操作系统的环境中。客户操作系统是完整操作系统的一个子集，并且比传统虚拟机（VM）小得多。容器中的应用程序会调用客户操作系统以获取服务，而客户操作系统反过来又会调用“主机”操作系统以获取其所在计算资源的服务。
- en: Applications can also be developed directly in containers running on your development
    computer, which acts as the host for the container. This has the advantage of
    developing the application in the same environment (the container) with which
    it will be deployed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用也可以直接在运行在开发计算机上的容器中开发，该计算机作为容器的宿主。这种做法的优势在于，可以在与部署环境（容器）相同的环境中开发应用。
- en: 12.3.4 Databases
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 数据库
- en: The MyBlog application uses an SQLite database to persist the content and relationships
    created by users of the application. RDBMSs are often much larger and more complex
    than what we’ve created here, with many more tables containing millions of rows
    of data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用使用SQLite数据库来持久化应用用户创建的内容和关系。RDBMS通常比我们在这里创建的更大、更复杂，包含更多的表，表中包含数百万行数据。
- en: In the past, I have worked with existing databases far more than I’ve created
    them. As a developer, it’s useful to learn more about database structures, tools,
    and techniques to expand the features of a database and maintain its performance.
    The databases presented in this book have done this by eliminating redundant data
    and taking advantage of the relationships possible in an RDBMS. It’s also important
    to learn when redundant data is acceptable to improve query performance for an
    application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我参与的工作远远多于我创建的数据库。作为一名开发者，了解更多关于数据库结构、工具和技术对于扩展数据库功能和维护其性能是有用的。本书中介绍的数据库通过消除冗余数据并利用RDBMS中可能的关系来实现这一点。了解何时可以接受冗余数据以改善应用查询性能也同样重要。
- en: Some database systems are document based rather than table based. These are
    often called NoSQL databases, as they sometimes don’t provide SQL access to the
    data. Instead, the data is accessed by making function calls against the database
    API and passing parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库系统是基于文档而非基于表。这些通常被称为NoSQL数据库，因为它们有时不提供SQL访问数据。相反，通过调用数据库API并传递参数来访问数据。
- en: The NoSQL document-oriented databases often store information in JavaScript
    Object Notation (JSON) structures. Instead of table structures with strict data
    typing, the stored JSON data can be dynamically changed at will.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL文档型数据库通常以JavaScript对象表示法（JSON）结构存储信息。与具有严格数据类型的表结构不同，存储的JSON数据可以随意动态更改。
- en: Both database approaches have advantages and disadvantages, and it falls to
    the developer and application stakeholders to determine which would serve the
    needs of an application best. A NoSQL database can be faster to retrieve data
    for certain kinds of applications. An RDBMS database can offer more structure
    and consistency to the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种数据库方法都有优点和缺点，最终取决于开发者和应用利益相关者来确定哪种最适合应用的需求。NoSQL数据库在某些类型的应用中检索数据可能更快。关系型数据库管理系统（RDBMS）数据库可以提供更多结构和数据一致性。
- en: An additional wrinkle when considering either type of database is that both
    are acquiring more and more features of the other. Modern RDBMS databases offer
    the ability to store JSON data as a column within tables and functions to interact
    with the data contained by JSON documents. By the same token, NoSQL databases
    are offering SQL interfaces that allow more traditional queries to access the
    managed data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这两种数据库类型时，还有一个额外的复杂性，那就是两者都在越来越多地获得对方的功能。现代RDBMS数据库提供了将JSON数据作为表中的列存储的能力，以及与JSON文档中包含的数据交互的功能。同样，NoSQL数据库也提供了SQL接口，允许进行更传统的查询以访问管理的数据。
- en: 12.3.5 Languages
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.5 语言
- en: This is a Python book, and Python is a powerful general-purpose language that
    is the right choice for many technical domains that can benefit from computer
    applications. That doesn’t mean Python is the only, or even the best, choice in
    every situation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本Python书籍，Python是一种功能强大的通用语言，是许多可以从计算机应用中受益的技术领域的正确选择。但这并不意味着Python是唯一，甚至是在每种情况下都是最佳选择。
- en: One of the goals of this book is to give you a well-stocked toolbelt when constructing
    a Python application. Sometimes, however, the problem at hand would benefit from
    another toolbelt entirely. Learning and knowing other programming languages will
    benefit a well-grounded developer in many ways throughout their career.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是在构建Python应用时为你提供一套丰富的工具箱。然而，有时手头的难题可能需要完全不同的工具箱。学习和了解其他编程语言将使有扎实基础的开发者在其职业生涯的许多方面受益。
- en: For example, JavaScript is essentially the standard language when working in
    a web browser. Its superset, TypeScript, is also gaining traction, not only in
    the browser but as a server-side language.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，JavaScript 在网页浏览器中工作时基本上是标准语言。它的超集 TypeScript 也在浏览器和服务器端语言中获得了吸引力。
- en: Rust, C#, Go, Java, Kotlin, and many others all have wide application and acceptance
    as tools used in various programming domains. Those domains overlap, and the decision
    about which to use can be based on what language is most appealing and comfortable
    to a software developer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rust、C#、Go、Java、Kotlin 以及许多其他语言都广泛应用于各种编程领域，并且得到了广泛的接受。这些领域有所重叠，关于选择哪种语言的决定可以基于哪种语言对软件开发者来说最吸引人和舒适。
- en: Throughout my career, I’ve worked in Fortran, Pascal, C/C++, Visual Basic, PHP,
    JavaScript, TypeScript, and, of course, Python. Some of them I’d gladly work in
    again, some I’d rather not, but they all served me and my career well at the time.
    Staying current is an interesting and challenging part of being a developer. Spending
    time learning new technology tools should benefit you and your life, so spend
    it wisely.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的整个职业生涯中，我使用过 Fortran、Pascal、C/C++、Visual Basic、PHP、JavaScript、TypeScript，当然还有
    Python。其中一些我会乐意再次使用，一些则宁愿不使用，但它们在当时的时刻都为我及我的职业生涯提供了很好的服务。保持最新是作为开发者有趣且具有挑战性的一个方面。花时间学习新技术工具应该对你和你的生活有益，所以请明智地利用时间。
- en: 12.4 OS environments
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 操作系统环境
- en: Many of the applications running in the world are hosted on Windows, Linux,
    or Mac computers. As a developer, the computer you work on will also most likely
    be a Windows, Linux, or Mac system. You can spend a career working in a single
    environment to develop and deploy your applications, but doing so might shrink
    the domain of the kinds of applications you can write.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上运行的大多数应用程序都托管在 Windows、Linux 或 Mac 计算机上。作为一名开发者，你工作的计算机也最可能是 Windows、Linux
    或 Mac 系统。你可以花费整个职业生涯在一个环境中开发并部署你的应用程序，但这样做可能会缩小你可以编写的应用程序类型的领域。
- en: Programming in Python allows you to create applications that are unaware of
    what operating system the application runs on most of the time. It’s that last
    part, “most of the time,” that is worth keeping in mind.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 编程可以使你创建的应用程序在大多数情况下对运行在哪个操作系统上并不知情。正是那最后的部分，“大多数情况下”，值得我们牢记。
- en: Becoming familiar with developing for other operating systems is valuable because
    it puts another tool in your hands to reach a wider audience. With the growing
    adoption of cloud computing and the use of containers for applications, developing
    on one platform and targeting another for deployment is common.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉为其他操作系统开发是有价值的，因为它为你提供了另一个工具，以触及更广泛的受众。随着云计算的日益普及以及容器在应用程序中的应用，在一个平台上开发并在另一个平台上部署是常见的。
- en: 12.5 Cloud computing
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 云计算
- en: Cloud computing systems allow computing resources to be located elsewhere and
    accessed securely through the internet. Besides moving the responsibility of running
    and maintaining computing hardware for a service, it gives developers the ability
    to size the computing resources and capabilities appropriately for user requirements.
    The size and capabilities of the resource can also be changed dynamically up or
    down, depending on the workload on the system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算系统允许计算资源位于其他地方，并通过互联网安全访问。除了将运行和维护计算硬件的责任转移到服务之外，它还使开发者能够根据用户需求适当地调整计算资源和能力。资源的规模和能力也可以根据系统的工作负载动态地上下调整。
- en: Applications rarely execute in isolation and have dependencies on networks,
    file storage, load balancers, databases, and more. These dependencies are also
    available from cloud service providers and can be scaled to meet the needs of
    an entire integrated system. Applications can run independently in a cloud provider’s
    computing instance, but it’s becoming more common for an application to exist
    in a container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序很少独立执行，并且依赖于网络、文件存储、负载均衡器、数据库等。这些依赖关系也来自云服务提供商，并且可以扩展以满足整个集成系统的需求。应用程序可以在云提供商的计算实例中独立运行，但应用程序存在于容器中的情况越来越普遍。
- en: 12.6 Networking
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 网络
- en: The world is a very connected place and becoming more so all the time. Connections
    and what they bring to conversations and the choices we make have changed the
    fabric of society in extraordinary ways. A software application working in isolation
    would be a rare exception, as almost all significant applications run and depend
    on environments connected to a network and often beyond to the internet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 世界是一个非常紧密联系的地方，而且一直在变得更加紧密。联系以及它们为对话和我们的选择带来的东西以非凡的方式改变了社会的结构。一个独立工作的软件应用程序将是一个罕见的例外，因为几乎所有重要的应用程序都是在连接到网络的环境中运行并依赖的，而且经常延伸到互联网之外。
- en: While working on the MyBlog application—getting the server running and accessing
    it with a local browser—it can be easy to forget that it’s a networked application.
    There’s no reason the application couldn’t run on a server located in one part
    of the world and be accessed by a web browser somewhere else in the world. Writing
    applications for computer systems connected to networks means your application
    can provide information and resources to other systems, as well as consume information
    and resources provided by other systems on the network.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 MyBlog 应用程序——让服务器运行并使用本地浏览器访问它时——很容易忘记它是一个网络应用程序。没有理由应用程序不能在一个世界的一部分的服务器上运行，同时被世界另一部分的网络浏览器访问。为连接到网络的计算机系统编写应用程序意味着你的应用程序可以为其他系统提供信息和资源，同时也可以消耗网络上其他系统提供的信息和资源。
- en: All modern languages provide tools and libraries to interface with networks
    and communicate across them. The MyBlog application is an example that uses the
    HTTP protocol to connect the server to the browser. Learning how to use and develop
    networked applications can increase the power and feature sets of your applications
    by orders of magnitude.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代语言都提供了工具和库来与网络接口并跨网络进行通信。MyBlog 应用程序是一个使用 HTTP 协议将服务器连接到浏览器的例子。学习如何使用和开发网络应用程序可以通过数量级增加你的应用程序的强大功能和特性集。
- en: 12.7 Collaboration
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 协作
- en: Building relationships is an important aspect of being a well-grounded developer.
    Certainly, creating and maintaining relationships in a database is vital, but
    building and maintaining relationships with the people in your life is far more
    important.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 建立关系是成为一个扎实开发者的重要方面。当然，在数据库中创建和维护关系是至关重要的，但与你的生活中的人建立和维护关系要重要得多。
- en: Even as the sole developer on a personal project, you’ll be reaching out to
    ask questions on sites, blogs, and user groups, and of colleagues and friends,
    seeking help with challenges you’ll face. Remember the idiom “Good developers
    are lazy”? It doesn’t mean well-grounded developers are slow to complete their
    projects; it means we take advantage of already-existing solutions to problems
    to implement elements faster.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是一个个人项目的唯一开发者，你也会在网站、博客和用户组上提问，向同事和朋友寻求帮助，寻求解决你将面临的挑战。记住这个成语“好的开发者是懒惰的”？这并不意味着扎实的基础开发者完成项目慢；这意味着我们利用已有的解决方案来更快地实现元素。
- en: Being part of a community is a two-way street. We should listen more than talk,
    strive to offer more help than we ask for, and work hard to build and maintain
    relationships so others in the community seek us out.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成为社区的一员是双向的。我们应该多听少说，努力提供比我们要求的更多帮助，并努力建立和维护关系，以便社区中的其他人来寻求我们。
- en: Being part of a diverse community of developers means encountering various perspectives.
    In my experience, this exposure presents approaches, ideas, and solutions that
    I wouldn’t have established on my own.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成为多样化开发者社区的一员意味着会遇到各种观点。根据我的经验，这种接触提供了我独自无法建立的方法、思想和解决方案。
- en: Collaboration is a multiplier. Connecting and sharing with people multiplies
    your talents and abilities as a developer manyfold.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 协作是一个乘数。连接和与人分享可以多倍地增加你作为开发者的才能和能力。
- en: 12.8 Closing thoughts
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 结束语
- en: You’ve come a long way on your journey as a well-grounded Python developer—from
    the early chapters of observing through a telescope to the huge field of view
    of many possible destinations and the many small details of a fully realized and
    focused application. The characteristics of being a software developer are unique
    from any other engineering endeavor. The domains in which we work span the macroscopic
    view of the unfathomably huge to the microscopic details of the unimaginably small.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您作为一名扎实的Python开发者的旅程已经走了很长的路——从早期章节通过望远镜观察，到众多可能的终点和完全实现且专注的应用程序中的许多细节。作为软件开发者的特点与其他任何工程领域都不同。我们工作的领域从无法理解的巨大宏观视角到难以想象的微小细节。
- en: I’ve been developing software for nearly forty years and accept that there are
    so many things I still want to learn. The desire to learn and the fortunate ability
    to do so have been key for me.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经开发了将近四十年的软件，并接受我还有很多东西想要学习。学习的渴望和幸运的能力对我来说一直是关键。
- en: My goal for this book was to help guide you along a path that leads to being
    a well-grounded Python developer. Yet, the answer to the question “Are we there
    yet?” is happily “no.” You are at a way station that branches into many paths,
    and you can follow any of them. I hope that you find the journeys ahead as enlightening
    and enjoyable and just plain as much fun as possible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书的目标是帮助您沿着一条道路前进，这条道路通向成为一名扎实的Python开发者。然而，对于“我们到了吗？”这个问题，答案是高兴地“还没有。”您正处于一个分叉路口，通往许多路径，您可以跟随其中任何一条。我希望您发现前方的旅程同样富有启发性、愉快，并且尽可能有趣。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Application testing is an important aspect of developing useful and stable applications.
    Many facets exist to testing an application—some can be automated, and some can’t.
    It’s also a big topic worthy of its own book.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序测试是开发有用且稳定的应用程序的重要方面。测试应用程序有许多方面——一些可以自动化，而一些则不能。这同样是一个值得单独成书的大话题。
- en: Being able to reproduce, find, and fix bugs is an essential skill of the well-grounded
    developer. Good tools and the right mindset are the starting places to begin debugging
    an application.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够重现、查找和修复错误是扎实开发者的一项基本技能。良好的工具和正确的心态是开始调试应用程序的起点。
- en: Code optimization is a double-edged sword. It can offer great improvements to
    an application’s performance, and it can be a huge time sink. Having reasons to
    optimize an application, specific goals to achieve, and metrics to measure whether
    you’ve achieved those goals are essential first steps.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码优化是一把双刃剑。它可以为应用程序的性能带来巨大的改进，也可能是一个巨大的时间黑洞。有理由优化应用程序，有具体的目标要实现，以及有衡量你是否达到这些目标的指标，这些是至关重要的第一步。
- en: We’ve only touched on what databases can do for you as a developer and for your
    applications as a resource. Learning more about their capabilities and constraints
    is time well spent.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只是触及了数据库作为开发者的你以及作为资源的你的应用所能为你带来的功能。深入了解它们的性能和限制是值得花费时间的。
