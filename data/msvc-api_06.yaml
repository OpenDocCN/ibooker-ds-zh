- en: 4 Principles of REST API design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API设计的4个原则
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The design principles of REST APIs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API的设计原则
- en: How the Richardson maturity model helps us understand the advantages of REST
    best design principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Richardson成熟度模型如何帮助我们理解REST最佳设计原则的优势
- en: The concept of resource and the design of endpoints for REST APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的概念和REST API端点的设计
- en: Using HTTP verbs and HTTP status codes to create highly expressive REST APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP动词和HTTP状态码创建高度表达的REST API
- en: Designing high-quality payloads and URL query parameters for REST APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计高质量的负载和URL查询参数的REST API
- en: Representational state transfer (REST) describes an architectural style for
    applications that communicate over a network. Originally, the concept of REST
    included a list of constraints for the design of distributed and scalable web
    applications. Over time, detailed protocols and specifications have emerged that
    give us well-defined guidelines for designing REST APIs. Today, REST is by far
    the most popular choice for building web APIs.[¹](#pgfId-1248568) In this chapter,
    we study the design principles of REST and learn to apply them by designing the
    orders API of the CoffeeMesh platform, the on-demand coffee delivery application
    we introduced in chapter 1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表示性状态转移（REST）描述了一种用于通过网络通信的应用程序的架构风格。最初，REST的概念包括了一组用于设计分布式和可扩展Web应用程序的约束。随着时间的推移，详细协议和规范已经出现，为我们提供了设计REST
    API的明确指南。今天，REST是构建Web API中最受欢迎的选择。[¹](#pgfId-1248568) 在本章中，我们研究REST的设计原则，并通过设计CoffeeMesh平台上的订单API，即我们在第1章中介绍的需求咖啡配送应用程序，来学习如何应用这些原则。
- en: We explain the concept of a resource, and what it means for the design of REST
    APIs. You’ll also learn to leverage features of the HTTP protocol, such as HTTP
    verbs and status codes, to create highly expressive APIs. The final part of this
    chapter covers best practices for designing API payloads and URL query parameters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了资源的概念，以及它对REST API设计意味着什么。你还将学习如何利用HTTP协议的功能，如HTTP动词和状态码，来创建高度表达的API。本章的最后部分涵盖了设计API负载和URL查询参数的最佳实践。
- en: 4.1 What is REST?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 什么是REST？
- en: REST, a term coined by Roy Fielding in his doctoral dissertation “Architectural
    Styles and the Design of Network-based Software Architectures” (PhD diss., University
    of California, Irvine, 2000, p. 109), describes an architectural style for loosely
    coupled and highly scalable applications that communicate over a network. It refers
    to the ability to transfer the representation of a resource’s state. The concept
    of resource is fundamental in REST applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REST，由Roy Fielding在其博士论文“架构风格和网络软件架构设计”（PhD diss., University of California,
    Irvine, 2000, p. 109）中提出，描述了一种用于通过网络通信的松散耦合和高度可扩展应用程序的架构风格。它指的是传输资源状态表示的能力。资源概念在REST应用程序中是基本的。
- en: DEFINITION REST is an architectural style for building loosely coupled and highly
    scalable APIs. REST APIs are structured around resources, entities that can be
    manipulated through the API.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义REST是一种用于构建松散耦合和高度可扩展API的架构风格。REST API围绕资源构建，这些资源可以通过API进行操作。
- en: 'A *resource* is an entity that can be referenced by a unique hypertext reference
    (i.e., URL). There are two types of resources: collections and singletons. A *singleton*
    represents a single entity, while *collections* represent lists of entities.[²](#pgfId-1248579)
    What does this mean in practice? It means that we use different URL paths for
    each type of resource. For example, CoffeeMesh’s orders service manages orders,
    and through its API we can access a specific order through the `/orders/{order_id}`
    URL path, while a collection of orders is available under the `/orders` URL path.
    Therefore, `/orders/{order_id}` is a singleton endpoint, while `/orders` is a
    collections endpoint.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *资源* 是一个可以通过唯一的超文本引用（即URL）进行引用的实体。资源有两种类型：集合和单例。一个 *单例* 代表一个单一实体，而 *集合* 代表实体列表。[²](#pgfId-1248579)
    这在实践中意味着我们为每种类型的资源使用不同的URL路径。例如，CoffeeMesh的订单服务管理订单，通过其API，我们可以通过`/orders/{order_id}`
    URL路径访问特定的订单，而订单集合则位于`/orders` URL路径下。因此，`/orders/{order_id}`是一个单例端点，而`/orders`是一个集合端点。
- en: Some resources can be nested within another resource, such as a payload for
    an order with several items listed in a nested array.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些资源可以嵌套在其他资源内部，例如一个订单的负载，其中列出了嵌套数组中的多个项目。
- en: Listing 4.1 Example of payload with nested resources
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1具有嵌套资源的负载示例
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can create nested endpoints to represent nested resources. Nested endpoints
    allow us to access specific details of a resource. For example, we can expose
    a GET `/orders/{order_id}/status` endpoint that allows us to get an order’s status
    without all the other details about the order. Using nested endpoints is a common
    optimization strategy when resources are represented by large payloads since they
    help us avoid costly data transfers when we are only interested in one property.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建嵌套端点来表示嵌套资源。嵌套端点允许我们访问资源的特定细节。例如，我们可以公开一个GET `/orders/{order_id}/status`
    端点，允许我们获取订单的状态，而不需要订单的所有其他细节。当资源由大型有效负载表示时，使用嵌套端点是一种常见的优化策略，因为它们帮助我们避免在只对单个属性感兴趣时进行昂贵的传输。
- en: The resource-oriented nature of REST APIs may sometimes appear limiting. A common
    concern is how to model actions through endpoints while keeping our APIs RESTful.
    For example, how do we represent the action of cancelling an order? A common heuristic
    is to represent actions as nested resources. For example, we can have a POST `/orders/{order_id}/cancel`
    endpoint to cancel orders. In this case, we model the order’s cancellation as
    creating a cancellation event.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: REST API的资源导向性质有时可能显得有限。一个常见的担忧是如何通过端点建模操作同时保持我们的API是RESTful的。例如，我们如何表示取消订单的操作？一个常见的启发式方法是表示操作为嵌套资源。例如，我们可以有一个用于取消订单的POST
    `/orders/{order_id}/cancel` 端点。在这种情况下，我们将订单的取消建模为创建一个取消事件。
- en: Designing clean endpoints is the first step toward building REST APIs that are
    easy to maintain and to consume. The patterns you’ve learned in this section go
    a long way to achieving clean endpoints, and in the rest of this chapter, you’ll
    learn additional patterns and principles for clean API design. In the next section,
    you’ll learn about the six architectural constraints of REST API applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计干净的端点是构建易于维护和消费的REST API的第一步。在本节中学到的模式对于实现干净的端点大有裨益，在本章的其余部分，你将学习更多关于干净API设计的模式和原则。在下一节中，你将了解REST
    API应用的六个架构约束。
- en: 4.2 Architectural constraints of REST applications
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 REST应用的架构约束
- en: 'In this section, we study the architectural constraints of REST applications.
    These constraints were enumerated by Fielding, and they specify how a server should
    process and respond to a client request. Before we delve into the details, let’s
    first provide a brief overview of each constraint:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究REST应用的架构约束。这些约束由Fielding列举，并指定了服务器应该如何处理和响应用户请求。在我们深入细节之前，让我们首先简要概述每个约束：
- en: '*Client -server architecture*—The user interface (UI) must be decoupled from
    the backend.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端-服务器架构*——用户界面（UI）必须与后端解耦。'
- en: '*Statelessness*—The server must not manage states between requests.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无状态*——服务器必须在请求之间不管理状态。'
- en: '*Cacheability*—Requests that always return the same response must be cacheable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缓存性*——始终返回相同响应的请求必须是可缓存的。'
- en: '*Layered system*—The API may be architected in layers, but such complexity
    must be hidden from the user.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层系统*——API可以分层架构，但这种复杂性必须对用户隐藏。'
- en: '*Code on demand*—The server can inject code into the user interface on demand.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按需代码*——服务器可以在需要时将代码注入用户界面。'
- en: '*Uniform interface*—The API must provide a consistent interface for accessing
    and manipulating resources.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统一接口*——API必须提供一致的接口来访问和操作资源。'
- en: Let’s discuss each of these constraints in more detail.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这些约束。
- en: '4.2.1 Separation of concerns: The client-server architecture principle'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 关注点分离：客户端-服务器架构原则
- en: REST relies on the principle of separation of concerns, and consequently it
    requires that user interfaces are decoupled from data storage and server logic.
    This allows server-side components to evolve independently from UI elements. As
    you can see in figure 4.1, a common implementation of the client-server architectural
    pattern is building the UI as a standalone application, for example, as a single-page
    application (SPA).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: REST依赖于关注点分离的原则，因此它要求用户界面与数据存储和服务器逻辑解耦。这允许服务器端组件独立于UI元素进行演变。如图4.1所示，客户端-服务器架构模式的一个常见实现是将UI构建为一个独立的应用程序，例如，作为一个单页应用程序（SPA）。
- en: '![](../Images/04-01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](../Images/04-01.png)'
- en: Figure 4.1 REST’s client-server architecture principle states that the server
    implementation must be decoupled from the client.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 REST的客户端-服务器架构原则指出，服务器实现必须与客户端解耦。
- en: '4.2.2 Make it scalable: The statelessness principle'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 使其可扩展：无状态原则
- en: In REST, every request to the server must contain all the information necessary
    to process it. In particular, the server must not keep state from one request
    to the next. As you can see in figure 4.2, removing state management from server
    components makes it easier to scale the backend horizontally. This allows us to
    deploy multiple instances of the server, and because none of those instances manages
    the API client’s state, the client can communicate with any of them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，对服务器的每个请求都必须包含处理它所需的所有信息。特别是，服务器不得从一次请求保持到下一次请求的状态。正如您在图4.2中看到的，从服务器组件中移除状态管理使得水平扩展后端变得更加容易。这允许我们部署多个服务器实例，并且由于这些实例中没有任何一个管理API客户端的状态，客户端可以与任何一个实例通信。
- en: '![](../Images/04-02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-02.png)'
- en: Figure 4.2 REST’s statelessness principle states that the server must not manage
    the state of the client. This allows us to deploy multiple instances of the API
    server and respond to the API client with any of them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 REST的无状态原则指出，服务器不得管理客户端的状态。这允许我们部署多个API服务器实例，并使用任何一个实例来响应API客户端。
- en: '4.2.3 Optimize for performance: The cacheability principle'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 优化性能：缓存原则
- en: When applicable, server responses must be cached. Caching improves the performance
    of APIs because it means we don’t have to perform all the calculations required
    to serve a response again and again. GET requests are suitable for caching, since
    they return data already saved in the server. As you can see in figure 4.3, by
    caching a GET request, we avoid having to fetch data from the source every time
    a user requests the same information. The longer it takes to assemble the response
    for a GET request, the greater the benefits of caching it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当适用时，服务器响应必须被缓存。缓存提高了API的性能，因为它意味着我们不必再次执行为提供响应所需的全部计算。GET请求适合缓存，因为它们返回已经保存在服务器中的数据。正如您在图4.3中看到的，通过缓存GET请求，我们避免了每次用户请求相同信息时都要从源获取数据。组装GET请求响应所需的时间越长，缓存它的好处就越大。
- en: '![](../Images/04-03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-03.png)'
- en: Figure 4.3 REST’s cacheability principle states that cacheable responses must
    be cached, which helps to boost the API server performance. In this example, we
    cache the order’s status for a short period of time to avoid multiple requests
    to the kitchen service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 REST的缓存原则指出，可缓存的响应必须被缓存，这有助于提高API服务器的性能。在这个例子中，我们缓存订单状态一段时间，以避免对厨房服务进行多次请求。
- en: Figure 4.3 illustrates the benefits of caching. As we learned in chapter 3,
    customers can track the progress on their orders once they’ve been submitted to
    the kitchen. The orders service interfaces with the kitchen service to obtain
    information on the order’s progress. To save time the next time the customer checks
    the order’s status, we cache its value for a short period of time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3说明了缓存的优点。正如我们在第3章中学到的，一旦订单提交给厨房，客户就可以跟踪订单的进度。订单服务与厨房服务接口，以获取订单进度的信息。为了节省时间，当客户下次检查订单状态时，我们将其值缓存一段时间。
- en: '4.2.4 Make it simple for the client: The layered system principle'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 简化客户端操作：分层系统原则
- en: In a REST architecture, clients must have a unique point of entry to your API
    and must not be able to tell whether they are connected directly to the end server
    or to an intermediary layer such as a load balancer. You can deploy different
    components of a server-side application in different servers, or you can deploy
    the same component across different servers for redundancy and scalability. This
    complexity should be hidden from the user by exposing a single endpoint that encapsulates
    access to your services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST架构中，客户端必须有一个唯一的API入口点，并且不能判断他们是直接连接到端服务器还是连接到负载均衡器等中间层。您可以在不同的服务器上部署服务器端应用程序的不同组件，或者为了冗余和可扩展性，可以在不同的服务器上部署相同的组件。这种复杂性应该通过暴露一个封装了对您的服务访问的单个端点来隐藏给用户。
- en: As you can see in figure 4.4, a common solution to this problem is the API gateway
    pattern, which is a component that serves as an entry point for all microservices.
    The API gateway knows the server addresses of each service, and it knows how to
    map each request to the relevant service.[³](#pgfId-1248656)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图4.4中看到的，解决这个问题的常见方法是API网关模式，这是一个充当所有微服务入口点的组件。API网关知道每个服务的服务器地址，并且知道如何将每个请求映射到相应的服务。[³](#pgfId-1248656)
- en: '![](../Images/04-04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-04.png)'
- en: Figure 4.4 REST’s layered system principle states that the complexity of our
    backend must be hidden from the client. A common solution to this problem is the
    API gateway pattern, which serves as an entry point to all the services in the
    platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 REST分层系统原则指出，我们的后端复杂性必须对客户端隐藏。解决这个问题的常见方法是API网关模式，它作为平台中所有服务的入口点。
- en: '4.2.5 Extendable interfaces: The code-on-demand principle'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 可扩展接口：按需代码原则
- en: Servers can extend the functionality of a client application by sending executable
    code directly from the backend, such as JavaScript files needed to run a UI. This
    constraint is optional and only applies to applications in which the backend serves
    the client interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过直接从后端发送可执行代码来扩展客户端应用程序的功能，例如运行UI所需的JavaScript文件。这个限制是可选的，并且仅适用于后端提供客户端界面的应用程序。
- en: '4.2.6 Keep it consistent: The uniform interface principle'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 保持一致性：统一接口原则
- en: REST applications must expose a uniform and consistent interface to their consumers.
    The interface must be documented, and the API specification must be followed strictly
    by the server and the client. Individual resources are identified by a Uniform
    Resource Identifier (URI),[⁴](#pgfId-1248675) and each URI must be unique and
    always return the same resource. For example, the URI `/orders/8` represents an
    order with ID 8, and a GET request on this URI always returns the state of the
    order with ID 8\. If the order is deleted from the system, the ID must not be
    reused to represent a different order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: REST应用程序必须向其消费者提供一个统一和一致的接口。该接口必须得到文档化，服务器和客户端必须严格遵循API规范。单个资源通过统一资源标识符（URI）[⁴](#pgfId-1248675)进行标识，并且每个URI必须是唯一的，并且始终返回相同的资源。例如，URI
    `/orders/8` 代表ID为8的订单，对该URI的GET请求始终返回ID为8的订单的状态。如果订单从系统中删除，则不得重新使用该ID来表示不同的订单。
- en: Resources must be represented using a serialization method of choice, and that
    approach should be used consistently across the API. Nowadays, REST APIs typically
    use JSON as the serialization format, although other formats are also possible,
    such as XML.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 资源必须使用选择的序列化方法表示，并且在整个API中应始终使用这种方法。如今，REST API通常使用JSON作为序列化格式，尽管其他格式也是可能的，例如XML。
- en: The architectural constraints of REST give us solid ground for designing robust
    and scalable APIs. But as we’ll see in the following sections of this chapter,
    there are more factors we need to consider when designing an API. In the next
    section, you’ll learn to make your APIs discoverable by enriching a resource’s
    description with related hypermedia links.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: REST的架构约束为我们设计健壮和可扩展的API提供了坚实的基础。但正如我们在本章的后续部分将看到的，在设计API时，我们还需要考虑更多因素。在下一节中，你将学习如何通过丰富资源的描述来包含相关的超媒体链接，使你的API变得可发现。
- en: 4.3 Hypermedia as the engine of application state
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 超媒体作为应用状态引擎
- en: 'Now that we understand the most important design constraints of REST APIs,
    let’s look at another important concept in REST: hypermedia as the engine of application
    state (HATEOAS). HATEOAS is a paradigm in the design of REST APIs that emphasizes
    the concept of discoverability. HATEOAS makes APIs easier to use by enriching
    responses with all the information users need to interact with a resource. In
    this section, we explain how HATEOAS works, and we discuss the benefits and disadvantages
    of this approach`.`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了REST API最重要的设计约束，让我们来看看REST的另一个重要概念：超媒体作为应用状态引擎（HATEOAS）。HATEOAS是REST
    API设计中的一个范例，强调可发现性概念。HATEOAS通过丰富响应，包含用户与资源交互所需的所有信息，使得API更容易使用。在本节中，我们解释了HATEOAS是如何工作的，并讨论了这种方法的优点和缺点。
- en: What exactly is HATEOAS? In an article written in 2008 with the title “REST
    APIs Must Be Hypertext-Driven” ([http://mng.bz/p6y5](http://mng.bz/p6y5)), Fielding
    suggested that REST APIs must include related links in their responses to allow
    clients to navigate the API by following those links.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: HATEOAS究竟是什么？在2008年发表的一篇题为“REST APIs Must Be Hypertext-Driven”的文章（[http://mng.bz/p6y5](http://mng.bz/p6y5)）中，菲尔德宁建议REST
    API必须在它们的响应中包含相关链接，以便客户端可以通过跟随这些链接来导航API。
- en: DEFINITION *Hypermedia as the engine of application state* (HATEOAS) is a design
    paradigm of REST that emphasizes the idea of discoverability. Whenever a client
    requests a resource from the server, the response must contain a list of related
    links to the resource. For example, if a client requests the details of an order,
    the response must include the links to cancel and pay for the order.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *超媒体作为应用状态引擎*（HATEOAS）是REST的一种设计范式，强调可发现性的理念。每当客户端从服务器请求一个资源时，响应必须包含与该资源相关的链接列表。例如，如果客户端请求一个订单的详细信息，响应必须包括取消和付款的链接。
- en: For example, as you can see in figure 4.5, when a client requests the details
    of an order, the API includes a collection of links related to the order. With
    those links, we can cancel the order, or we can pay for it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如图4.5所示，当客户端请求一个订单的详细信息时，API会包含与该订单相关的链接集合。通过这些链接，我们可以取消订单，或者为其付款。
- en: '![](../Images/04-05.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-05.png)'
- en: Figure 4.5 In the HATEOAS paradigm, the API sends a representation of the requested
    resource with other links related to the resource.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 在HATEOAS范式中，API发送请求资源的表示，以及与资源相关的其他链接。
- en: Listing 4.2 Representation of an order including hypermedia links
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 包含超媒体链接的订单表示
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Providing relational links makes APIs navigational and easier to use, since
    every resource comes with all the URLs we need to work with it. However, in practice,
    many APIs are not implemented that way for several reasons:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 提供关系链接使API可导航且易于使用，因为每个资源都附带我们与之交互所需的所有URL。然而，在实践中，由于几个原因，许多API并没有这样实现：
- en: The information supplied by hyperlinks is already available in the API documentation.
    In fact, the information contained in an OpenAPI specification is far richer and
    more structured than what you can provide in a list of related links for specific
    resources.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超链接提供的信息已经在API文档中提供。事实上，OpenAPI规范中包含的信息比在特定资源的相关链接列表中提供的信息更为丰富和结构化。
- en: It’s not always clear exactly what links should be returned. Different users
    have different levels of permissions and roles, which allow them to perform different
    actions and access different resources. For example, external users can use the
    POST `/orders` endpoint in the CoffeeMesh API to place an order, and they are
    also able to use the GET `/orders/{order_id}` endpoint to retrieve the details
    of an order. However, they cannot use the DELETE `/orders/{order_id}` endpoint
    to delete an order, since this endpoint is restricted to internal users of the
    CoffeeMesh platform. If the point of HATEOAS is to make the API navigational from
    a single point of entry, it wouldn’t make sense to return the DELETE `/orders/{order_id}`
    endpoint to external users since they are not able to use it. Therefore, it’s
    necessary to return different lists of related links to different users according
    to their permissions. However, this level of flexibility introduces additional
    complexity in our API designs and implementations and couples the authorization
    layer with the API layer.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非总是清楚应该返回哪些链接。不同的用户有不同的权限和角色，这使他们能够执行不同的操作和访问不同的资源。例如，外部用户可以使用CoffeeMesh API中的`/orders`端点下单，并且他们也能够使用`/orders/{order_id}`端点检索订单的详细信息。然而，他们不能使用`/orders/{order_id}`端点的DELETE操作来删除订单，因为这个端点是限制给CoffeeMesh平台内部用户的。如果HATEOAS的目的是从单一入口点使API可导航，那么将DELETE
    `/orders/{order_id}`端点返回给外部用户就没有意义，因为他们无法使用它。因此，有必要根据用户的权限返回不同的相关链接列表。然而，这种灵活性在我们的API设计和实现中引入了额外的复杂性，并将授权层与API层耦合在一起。
- en: Depending on the state of the resource, certain actions and resources may not
    be available. For example, you can call the POST `/orders/1234/cancel` endpoint
    on an active order but not on a cancelled order. This level of ambiguity makes
    it hard to define and implement robust interfaces that follow the HATEOAS principles.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据资源的状态，某些操作和资源可能不可用。例如，你可以在一个活跃订单上调用`/orders/1234/cancel`端点，但不能在一个已取消的订单上调用。这种模糊性使得定义和实现遵循HATEOAS原则的健壮接口变得困难。
- en: Finally, in some APIs, the list of related links may be large and therefore
    make the response payload too big, hence compromising the performance of the API
    and the reliability of the connection for small devices with low network connectivity.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在某些API中，相关链接的列表可能很大，因此会使响应负载过大，从而影响API的性能和低网络连接设备连接的可靠性。
- en: When working on your own APIs, you can decide whether to follow the HATEOAS
    principles. There’s a certain level of benefit in providing lists of related resources
    in some cases. For example, in a wiki application, the linked resources section
    of a payload can be used to list content related to a specific article, links
    to the same article in other languages, and links to actions that can be performed
    on the article. Overall, you may want to strike a balance between what your API
    documentation already provides to the client in a more clear and detailed way,
    and what you can offer in your responses to facilitate the interaction between
    the client and the API. If you’re building a public-facing API, your clients will
    benefit from relational links. However, if it’s a small internal API, it’s probably
    unnecessary to include relational links.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在自己的API上工作时，你可以决定是否遵循HATEOAS原则。在某些情况下，提供相关资源的列表有一定的好处。例如，在一个维基应用程序中，有效载荷的链接资源部分可以用来列出与特定文章相关的文章内容、同一文章在其他语言的链接以及可以对该文章执行的操作的链接。总的来说，你可能希望在API文档已经以更清晰和详细的方式提供给客户端的内容，以及你可以在响应中提供的内容之间找到一个平衡，以促进客户端和API之间的交互。如果你正在构建面向公众的API，你的客户端将从关系链接中受益。然而，如果它是一个小型的内部API，可能没有必要包含关系链接。
- en: Now that we know how we make our APIs discoverable and when it’s worth doing
    so, let’s study the Richardson maturity model, which will help you understand
    to what extent your APIs comply with the design principles of REST.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使我们的API可发现以及何时这样做是值得的，让我们来研究理查森成熟度模型，这将帮助你了解你的API在多大程度上符合REST的设计原则。
- en: 4.4 Analyzing the maturity of an API with the Richardson maturity model
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用理查森成熟度模型分析API的成熟度
- en: This section discusses the Richardson maturity model, a mental model developed
    by Leonard Richardson to help us think about the degree to which an API complies
    with the principles of REST.[⁵](#pgfId-1248741) The Richardson maturity model
    distinguishes four levels (from level 0 to level 3) of “maturity” in an API. Each
    level introduces additional elements of good REST API design (figure 4.6). Let’s
    discuss each level in detail.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了理查森成熟度模型，这是一个由伦纳德·理查森开发的心理模型，帮助我们思考一个API符合REST原则的程度。[⁵](#pgfId-1248741)
    理查森成熟度模型区分了API中“成熟度”的四个级别（从0级到3级）。每个级别都引入了额外的良好REST API设计元素（见图4.6）。让我们详细讨论每个级别。
- en: '![](../Images/04-06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6](../Images/04-06.png)'
- en: Figure 4.6 The Richardson maturity model distinguishes four levels of API maturity,
    where the highest level represents an API design that abides by the best practices
    and standards of REST, while the lowest level represents a type of API that doesn’t
    apply any of the principles of REST.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 理查森成熟度模型区分了API成熟度的四个级别，其中最高级别代表一个遵守REST最佳实践和标准的API设计，而最低级别代表一种不应用任何REST原则的API类型。
- en: '4.4.1 Level 0: Web APIs à la RPC'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 第0级：Web API类似于RPC
- en: 'At level 0, HTTP is essentially used as a transport system to carry interactions
    with the server. The notion of API in this case is closer to the idea of a *remote
    procedure call* (RPC; see appendix A). All the requests to the server are made
    on the same endpoint and with the same HTTP method, usually GET or POST. The details
    of the client’s request are carried in an HTTP payload. For example, to place
    an order through the CoffeeMesh website, the client might send a POST request
    on a generic `/api` endpoint with the following payload:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第0级，HTTP基本上被用作一个传输系统来承载与服务器的交互。在这种情况下，API的概念更接近于*远程过程调用*（RPC；见附录A）。所有对服务器的请求都是在同一个端点上，使用相同的HTTP方法进行的，通常是GET或POST。客户端请求的详细信息包含在HTTP有效载荷中。例如，为了通过CoffeeMesh网站下订单，客户端可能会在通用的`/api`端点上发送以下有效载荷的POST请求：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The server invariably responds with 200 status codes and an accompanying payload
    letting us know the outcome of processing the request. Similarly, to get the details
    of an order, a client might make the following POST request on the generic `/api`
    endpoint (assuming the ID of the order is 8):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器总是以200状态码和伴随的有效载荷响应，让我们知道请求处理的结果。同样，为了获取订单的详细信息，客户端可能会在通用的`/api`端点上发出以下POST请求（假设订单ID为8）：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '4.4.2 Level 1: Introducing the concept of resource'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 第1级：引入资源概念
- en: 'Level 1 introduces the concept of resource URLs. Instead of a generic `/api`
    endpoint, the server exposes URLs that represent resources. For example, the `/orders`
    URL represents a collection of orders, while the `/orders/{order_id}` URL represents
    a single order. To place an order, the client sends a POST request on the `/orders`
    endpoint with a similar payload as in level 0:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第1级介绍了资源URL的概念。服务器不再暴露通用的`/api`端点，而是暴露代表资源的URL。例如，`/orders` URL代表订单集合，而`/orders/{order_id}`
    URL代表单个订单。为了下订单，客户端在`/orders`端点上发送一个与第0级类似的POST请求：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time when requesting the details of the last order, the client will make
    a POST request on the URI representing that order: `/orders/8`. At this level,
    the API doesn’t distinguish between HTTP methods to represent different actions.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当请求最后一个订单的详细信息时，客户端将在代表该订单的URI上发送一个POST请求：`/orders/8`。在这个级别，API不区分HTTP方法来表示不同的操作。
- en: '4.4.3 Level 2: Using HTTP methods and status codes'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 第2级：使用HTTP方法和状态码
- en: 'Level 2 introduces the concept of HTTP verbs and status codes. At this level,
    HTTP verbs are used to represent specific actions. For example, to place an order,
    a client sends a POST request on the `/orders` endpoint with the following payload:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第2级介绍了HTTP动词和状态码的概念。在这个级别，HTTP动词用于表示特定的操作。例如，为了下订单，客户端在`/orders`端点上发送一个POST请求，带有以下有效负载：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, the HTTP method POST indicates the operation we want to perform,
    and the payload only includes the details of the order we want to place. Similarly,
    to get the details of an order, we send a GET request on the order’s URI: `/orders/`
    `{order_id}`. In this case, we use the HTTP verb GET to tell the server that we
    want to retrieve details of the resource specified in the URI.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，HTTP方法POST表示我们想要执行的操作，有效负载仅包括我们想要下订单的订单详情。同样，为了获取订单的详细信息，我们向订单的URI发送一个GET请求：`/orders/`
    `{order_id}`。在这种情况下，我们使用HTTP动词GET来告诉服务器我们想要检索URI中指定的资源的详细信息。
- en: While previous levels include the same status code (usually 200) in all responses,
    level 2 introduces the semantic use of HTTP status codes to report the outcome
    of processing the client’s request. For example, when we create a resource using
    a POST request, we get a 201 response status code, and a request for a nonexistent
    resource gets a 404 response status code. For more information on HTTP status
    codes and best practices using them, see section 4.6.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前几个级别在所有响应中都包含相同的状态码（通常是200），但第2级引入了HTTP状态码的语义使用，以报告处理客户端请求的结果。例如，当我们使用POST请求创建资源时，我们得到一个201响应状态码，而对于一个不存在的资源的请求，我们得到一个404响应状态码。有关HTTP状态码和最佳实践的更多信息，请参阅第4.6节。
- en: '4.4.4 Level 3: API discoverability'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 第3级：API可发现性
- en: Level 3 introduces the concept of discoverability by applying the principles
    of HATEOAS and by enriching responses with links that represent the actions we
    can perform on a resource. For example, a GET request on the `/orders/{order_id}`
    endpoint returns a representation of an order, and it includes a list of related
    links.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第3级通过应用HATEOAS原则并丰富响应，通过包含表示我们可以对资源执行的操作的链接来引入可发现性的概念。例如，对`/orders/{order_id}`端点的GET请求返回一个订单表示，并包括相关链接列表。
- en: Listing 4.3 Representation of an order, including hypermedia links
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 订单表示，包括超媒体链接
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the Richardson maturity model, level 3 represents the last step toward what
    he calls the “Glory of REST.”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在里查德森成熟度模型中，第3级代表他所称的“REST的荣耀”的最后一步。
- en: What does the Richardson maturity model mean for the design of our APIs? The
    model gives us a framework to think about where our API designs stand within the
    overall principles of REST. This model isn’t meant to measure the degree to which
    an API “complies” with the principles of REST, or to otherwise assess the quality
    of an API design; instead, it gives us a framework to think about how well we
    leverage the HTTP protocol to create expressive APIs that are easy to understand
    and to consume.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 里查德森成熟度模型对我们API的设计意味着什么？该模型为我们提供了一个框架，以思考我们的API设计在REST整体原则中的位置。这个模型并不是用来衡量API“遵守”REST原则的程度，或者评估API设计质量；相反，它为我们提供了一个框架，以思考我们如何利用HTTP协议创建易于理解和消费的表达式丰富的API。
- en: Now that we understand the main design principles of REST APIs, it’s time to
    start designing the orders API! In the next section, we’ll begin by designing
    the API endpoints by learning to use HTTP methods.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了REST API的主要设计原则，是时候开始设计订单API了！在下一节中，我们将通过学习如何使用HTTP方法来设计API端点。
- en: 4.5 Structured resource URLs with HTTP methods
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用HTTP方法的具有结构性的资源URL
- en: As we learned in section 4.4, using HTTP methods and status codes is associated
    with a mature API design in the Richardson maturity model. In this section, we
    learn to use HTTP methods correctly by applying them to the design of the CoffeeMesh
    application’s orders API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在4.4节中学到的，使用HTTP方法和状态码与Richardson成熟度模型中的成熟API设计相关联。在本节中，我们通过将HTTP方法应用于CoffeeMesh应用程序订单API的设计来学习如何正确使用HTTP方法。
- en: HTTP methods are special keywords used in HTTP requests to indicate the type
    of action we want to perform in the server. Proper use of HTTP methods makes our
    APIs more structured and elegant, and since they’re part of the HTTP protocol,
    they also make the API more understandable and easier to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法是用于HTTP请求中的特殊关键字，用于指示我们希望在服务器上执行的操作类型。正确使用HTTP方法可以使我们的API更加结构化和优雅，并且由于它们是HTTP协议的一部分，它们也使得API更加易于理解和使用。
- en: DEFINITION *HTTP request methods* are keywords used in HTTP requests to indicate
    the type of action we wish to perform. For example, the GET method retrieves the
    details of a resource, while the POST method creates a new resource. The most
    important HTTP methods for REST APIs are GET, POST, PUT, PATCH, and DELETE. HTTP
    methods are also known as verbs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP请求方法**的定义是用于HTTP请求中的关键字，用于指示我们希望执行的操作类型。例如，GET方法用于检索资源的详细信息，而POST方法用于创建新的资源。对于REST
    API来说，最重要的HTTP方法是GET、POST、PUT、PATCH和DELETE。HTTP方法也被称为动词。'
- en: 'In my experience, there’s often confusion around the proper use of HTTP methods.
    Let’s clear up that confusion by learning the semantics of each method. The most
    relevant HTTP methods in REST APIs are GET, POST, PUT, PATCH, and DELETE:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，关于HTTP方法正确使用的问题常常存在混淆。让我们通过学习每个方法的语义来消除这种混淆。在REST API中最相关的HTTP方法是GET、POST、PUT、PATCH和DELETE：
- en: '*GET*—Returns information about the requested resource'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GET*—返回关于请求资源的详细信息'
- en: '*POST*—Creates a new resource'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*POST*—创建新的资源'
- en: '*PUT*—Performs a full update by replacing a resource'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PUT*—通过替换资源执行完全更新'
- en: '*PATCH*—Updates specific properties of a resource'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PATCH*—更新资源的特定属性'
- en: '*DELETE*—Deletes a resource'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DELETE*—删除资源'
- en: Semantics of the PUT method
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PUT方法的语义
- en: According to the HTTP specification, PUT can be idempotent, and therefore we
    can use it to create a resource if it doesn’t exist. However, the specification
    also highlights “[a] service that selects a proper URI on behalf of the client,
    after receiving a state-changing request, SHOULD be implemented using the POST
    method rather than PUT.” This means that, when the server is in charge of generating
    the URI of a new resource, we should create resources using the POST method, and
    PUT can only be used for updates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据HTTP规范，PUT可以是幂等的，因此如果资源不存在，我们可以使用它来创建资源。然而，规范也强调了“在收到状态改变请求后，代表客户端选择适当URI的服务应该使用POST方法而不是PUT方法。”这意味着，当服务器负责生成新资源的URI时，我们应该使用POST方法来创建资源，而PUT方法只能用于更新。
- en: 'See R. Fielding, “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”
    (RFC 7231, June 2014, [https://tools.ietf.org/html/rfc7231#section-4.3.4](https://tools.ietf.org/html/rfc7231#section-4.3.4)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 参见R. Fielding，“超文本传输协议（HTTP/1.1）：语义和内容”（RFC 7231，2014年6月，[https://tools.ietf.org/html/rfc7231#section-4.3.4](https://tools.ietf.org/html/rfc7231#section-4.3.4))。
- en: 'HTTP methods allow us to model the basic operations we can perform on a resource:
    create (POST), read (GET), update (PUT and PATCH), and delete (DELETE). We refer
    to these operations with the acronym CRUD, which comes from the field of databases,[⁶](#pgfId-1248895)
    but is very popular in the world of APIs. You’ll often hear about CRUD APIs, which
    are APIs designed to perform these operations on resources.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法允许我们模拟对资源可以执行的基本操作：创建（POST）、读取（GET）、更新（PUT和PATCH）和删除（DELETE）。我们用缩写CRUD来指代这些操作，它来自数据库领域，[⁶](#pgfId-1248895)，但在API的世界中非常流行。你经常会听到关于CRUD
    API的讨论，这些API被设计来对资源执行这些操作。
- en: 'PUT vs. PATCH: What’s the difference, and when do you use them?'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PUT与PATCH：它们有什么区别，何时使用它们？
- en: We can use both PUT and PATCH to perform updates. So, what’s the difference
    between the two? While PUT requires the API client to send a whole new representation
    of the resource (hence the replacement semantics), PATCH allows you to send only
    those properties that changed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 PUT 和 PATCH 来执行更新。那么，两者之间的区别是什么？PUT 要求 API 客户端发送资源的新完整表示（因此具有替换语义），而
    PATCH 允许您只发送已更改的属性。
- en: 'For example, imagine that an order has the following representation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个订单具有以下表示：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now suppose that the user wants to make a small amendment in this order and
    update the size of the croissants from `"medium"` to `"small"`. Although the user
    wants to change one specific field, with PUT they must send the whole payload
    back to the server. However, with PATCH they only need to send the fields that
    must be updated in the server. PATCH requests are more optimal, since the payloads
    sent to the server are smaller. However, as you can see in the following example,
    PATCH requests also have a more complex structure, and sometimes they’re more
    difficult to process in the backend:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设用户想要对这个订单进行小的修改，并将羊角面包的大小从 `"medium"` 更改为 `"small"`。尽管用户只想更改一个特定的字段，但使用
    PUT 他们必须将整个有效负载发送回服务器。然而，使用 PATCH 他们只需要发送服务器中必须更新的字段。PATCH 请求更优，因为发送到服务器的有效负载更小。然而，正如以下示例所示，PATCH
    请求也有更复杂的结构，有时在后端处理起来也更困难：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This follows the guidelines of the JSON Patch specification:^a a JSON Patch
    request must specify the type of operation we want to perform, plus the target
    attribute and its desired value. We use JSON Patch to declare the target attribute.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循 JSON Patch 规范的指南：^a JSON Patch 请求必须指定我们想要执行的操作类型，以及目标属性及其期望的值。我们使用 JSON
    Patch 来声明目标属性。
- en: While implementing PATCH endpoints is good practice for public-facing APIs,
    internal APIs often only implement PUT endpoints for updates since they’re easier
    to handle. In the orders API, we’ll implement updates as PUT requests.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现 PATCH 端点是面向公众的 API 的良好实践，但内部 API 通常只实现 PUT 端点用于更新，因为它们更容易处理。在订单 API 中，我们将实现更新为
    PUT 请求。
- en: ^a P. Bryan and M. Nottingham, “JavaScript Object Notation (JSON) Patch” ([https://www.rfc-editor.org/rfc/rfc6902](https://www.rfc-editor.org/rfc/rfc6902)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ^a P. Bryan 和 M. Nottingham，"JavaScript 对象表示法 (JSON) Patch" ([https://www.rfc-editor.org/rfc/rfc6902](https://www.rfc-editor.org/rfc/rfc6902))。
- en: 'How do we use HTTP methods to define the endpoints of CoffeeMesh’s orders API?
    We use HTTP methods in combination with URLs, so let’s first define the resource
    URLs. In section 4.1, we learned to distinguish between two types of resource
    URLs in REST: singletons, which represent a single resource, and collections,
    which represent a list of resources. In the orders API, we have these two resource
    URLs:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用 HTTP 方法来定义 CoffeeMesh 订单 API 的端点？我们结合使用 HTTP 方法和 URL，因此首先定义资源 URL。在第
    4.1 节中，我们学习了在 REST 中区分两种类型的资源 URL：单例，它表示单个资源，和集合，它表示资源列表。在订单 API 中，我们有这两个资源 URL：
- en: '`/orders`—Represents a list of orders.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders`—表示订单列表。'
- en: '`/orders/{orders_id}`—Represents a single order. The curly braces around `{order_id}`
    indicates that this is a URL path parameter and must be replaced by the ID of
    an order.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}`—表示单个订单。大括号 `{order_id}` 中的圆括号表示这是一个 URL 路径参数，必须用订单的 ID
    替换。'
- en: 'As you can see in figure 4.7, we use the singleton URL `/orders/{order_id}`
    to perform actions on an order, such as updating it, and the collections URL `/orders`
    to place and to list past orders. HTTP methods help us model these operations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.7 所示，我们使用单例 URL `/orders/{order_id}` 来执行对订单的操作，例如更新它，以及集合 URL `/orders`
    来放置和列出过去的订单。HTTP 方法帮助我们建模这些操作：
- en: POST `/orders` to place orders since we use POST to create new resources.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST `/orders` 来下订单，因为我们使用 POST 来创建新资源。
- en: GET `/orders` to retrieve a list of orders since we use GET to obtain information.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GET `/orders` 来检索订单列表，因为我们使用 GET 来获取信息。
- en: GET `/orders/{order_id}` to retrieve the details of a particular order.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GET `/orders/{order_id}` 来检索特定订单的详细信息。
- en: PUT `/orders/{order_id}` to update an order since we use PUT to update a resource.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PUT `/orders/{order_id}` 来更新订单，因为我们使用 PUT 来更新资源。
- en: DELETE `/orders/{order_id}` to delete an order since we use DELETE for deletes.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DELETE `/orders/{order_id}` 来删除订单，因为我们使用 DELETE 进行删除。
- en: POST `/orders/{order_id}/cancel` to cancel an order. We use POST to create a
    cancellation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST `/orders/{order_id}/cancel` 来取消订单。我们使用 POST 来创建取消操作。
- en: POST `/orders/{order_id}/pay` to pay for an order. We use POST to create a payment.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST `/orders/{order_id}/pay` 来支付订单。我们使用 POST 来创建支付。
- en: '![](../Images/04-07.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-07.png)'
- en: Figure 4.7 We combine HTTP methods with URL paths to design our API endpoints.
    We leverage the semantics of HTTP methods to convey the intention of each endpoint.
    For example, we use the POST method to create new resources, so we use it in the
    POST `/orders` endpoint to place orders.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 我们将 HTTP 方法与 URL 路径结合来设计我们的 API 端点。我们利用 HTTP 方法的语义来传达每个端点的意图。例如，我们使用 POST
    方法来创建新资源，因此我们在 POST `/orders` 端点中使用它来下订单。
- en: Now that we know how to design API endpoints by combining URL paths with HTTP
    methods, let’s see how to leverage the semantics of HTTP status codes to return
    expressive responses.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何通过结合 URL 路径和 HTTP 方法来设计 API 端点，让我们看看如何利用 HTTP 状态码的语义来返回表达性的响应。
- en: 4.6 Using HTTP status codes to create expressive HTTP responses
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 使用 HTTP 状态码创建表达性的 HTTP 响应
- en: This section explains how we use HTTP status codes in the responses of a REST
    API. We begin by clarifying what HTTP status codes are and how we classify them
    into groups, and then we explain how to use them to model our API responses.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们在 REST API 的响应中使用 HTTP 状态码的方式。我们首先明确 HTTP 状态码是什么，以及我们如何将它们分类到不同的组中，然后解释如何使用它们来模拟我们的
    API 响应。
- en: 4.6.1 What are HTTP status codes?
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 什么是 HTTP 状态码？
- en: 'We use status codes to signal the result of processing a request in the server.
    When properly used, HTTP status codes help us deliver expressive responses to
    our APIs’ consumers. Status codes fall into the following five groups:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用状态码来表示服务器处理请求的结果。当正确使用时，HTTP 状态码帮助我们向 API 的消费者提供表达性的响应。状态码分为以下五个组：
- en: '*1xx group*—Signals that an operation is in progress'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*1xx 组*—表示操作正在进行中'
- en: '*2xx group*—Signals that a request was successfully processed'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2xx 组*—表示请求被成功处理'
- en: '*3xx group*—Signals that a resource has been moved to a new location'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*3xx 组*—表示资源已移动到新位置'
- en: '*4xx group*—Signals that something was wrong with the request'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*4xx 组*—表示请求存在问题'
- en: '*5xx group*—Signals that there was an error while processing the request'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*5xx 组*—表示在处理请求时出现错误'
- en: NOTE HTTP response status codes are used to indicate the outcome of processing
    an HTTP request. For example, the 200 status code indicates that the request was
    successfully processed, while the 500 status code indicates that an internal server
    error was raised while processing the request. HTTP status codes are associated
    with a reasoned phrase that explains the intent of the code. For example, the
    reasoned phrase for the 404 status code is “Not Found.” You can check out the
    full list of status codes and learn more about them at [http://mng.bz/z5lw](http://mng.bz/z5lw).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：HTTP 响应状态码用于指示处理 HTTP 请求的结果。例如，200 状态码表示请求被成功处理，而 500 状态码表示在处理请求时引发了内部服务器错误。HTTP
    状态码与一个有理的短语相关联，该短语解释了代码的意图。例如，404 状态码的有理短语是“未找到”。您可以在 [http://mng.bz/z5lw](http://mng.bz/z5lw)
    查看状态码的完整列表并了解更多信息。
- en: The full list of HTTP status codes is long, and enumerating them one by one
    wouldn’t do much to help us understand how we use them. Instead, let’s look at
    the most commonly used codes and see how we apply them in our API designs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码的完整列表很长，逐一列举它们并不会对我们理解如何使用它们有很大帮助。相反，让我们看看最常用的代码，并看看我们如何在 API 设计中应用它们。
- en: 'When thinking about HTTP status codes, it’s useful to distinguish between successful
    and unsuccessful responses. A successful response means the request was successfully
    processed, while an unsuccessful response means that something went wrong while
    processing the request. For each of the endpoints that we defined in section 4.5,
    we use the following successful HTTP status codes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 HTTP 状态码时，区分成功和失败响应是有用的。成功响应意味着请求被成功处理，而失败响应意味着在处理请求时出现了问题。对于我们在 4.5 节中定义的每个端点，我们使用以下成功
    HTTP 状态码：
- en: 'POST `/orders`: 201 (Created)—Signals that a resource has been created.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST `/orders`: 201 (已创建)—表示已创建资源。'
- en: 'GET `/orders`: 200 (OK)—Signals that the request was successfully processed.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET `/orders`: 200 (OK)—表示请求被成功处理。'
- en: 'GET `/orders/{order_id}`: 200 (OK)—Signals that the request was successfully
    processed.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET `/orders/{order_id}`: 200 (OK)—表示请求被成功处理。'
- en: 'PUT `/orders/{order_id}`: 200 (OK)—Signals that the resource was successfully
    updated.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PUT `/orders/{order_id}`: 200 (OK)—表示资源已成功更新。'
- en: 'DELETE `/orders/{order_id}`: 204 (No Content)—Signals that the request was
    successfully processed but no content is delivered in the response. Contrary to
    all other methods, a DELETE request doesn’t require a response with payload, since,
    after all, we are instructing the server to delete the resource. Therefore, a
    204 (No Content) code is a good choice for this type of HTTP request.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'DELETE `/orders/{order_id}`: 204 (No Content)—表示请求已成功处理，但响应中没有内容。与所有其他方法不同，DELETE
    请求不需要带有有效载荷的响应，因为毕竟我们是在指示服务器删除资源。因此，204 (No Content) 状态码是这类 HTTP 请求的好选择。'
- en: 'POST `/orders/{order_id}/cancel`: 200 (OK)—Although this is a POST endpoint,
    we use the 200 (OK) status code since we’re not really creating a resource, and
    all the client wants to know is that the cancellation was successfully processed.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST `/orders/{order_id}/cancel`: 200 (OK)—尽管这是一个 POST 端点，我们使用 200 (OK) 状态码，因为我们实际上并没有创建资源，客户端只想知道取消操作已成功处理。'
- en: 'POST `/orders/{order_id}/pay`: 200 (OK)—Although this is a POST endpoint, we
    use the 200 (OK) status code since we’re not really creating a resource, and all
    the client wants to know is that the payment was successfully processed.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST `/orders/{order_id}/pay`: 200 (OK)—尽管这是一个 POST 端点，我们使用 200 (OK) 状态码，因为我们实际上并没有创建资源，客户端只想知道支付已成功处理。'
- en: 'That’s all good for successful responses, but what about error responses? What
    kinds of errors can we encounter in the server while processing requests, and
    what kinds of HTTP status codes are appropriate for them? We distinguish two groups
    of errors:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的响应来说，这些都很好，但错误响应呢？在服务器处理请求时，我们可能会遇到哪些类型的错误，以及哪些 HTTP 状态码是合适的？我们区分两组错误：
- en: Errors made by the user when sending the request, for example, due to a malformed
    payload, or due to the request being sent to a nonexistent endpoint. We address
    this type of error with an HTTP status code in the 4xx group.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在发送请求时犯的错误，例如，由于有效载荷格式不正确，或者由于请求发送到了一个不存在的端点。我们使用 4xx 组中的 HTTP 状态码来处理这类错误。
- en: Errors unexpectedly raised in the server while processing the request, typically
    due to a bug in our code. We address this type of error with an HTTP status code
    in the 5xx group.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器处理请求时意外抛出的错误，通常是由于我们代码中的错误。我们使用 5xx 组中的 HTTP 状态码来处理这类错误。
- en: Let’s talk about each of these error types in more detail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这些错误类型。
- en: 4.6.2 Using HTTP status codes to report client errors in the request
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 使用 HTTP 状态码来报告请求中的客户端错误
- en: 'An API client can make different types of errors when sending a request to
    an API. The most common type of error in this category is sending a malformed
    payload to the server. We distinguish two types of malformed payloads: payloads
    with invalid syntax and unprocessable entities.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: API 客户端在向 API 发送请求时可能会犯不同类型的错误。这类错误中最常见的一种是向服务器发送格式不正确的有效载荷。我们区分两种格式不正确的有效载荷：无效语法的有效载荷和不可处理的实体。
- en: Payloads with *invalid syntax* are payloads that the server can neither parse
    nor understand. A typical example of a payload with invalid syntax is malformed
    JSON. As you can see in figure 4.8, we address this type of error with a 400 (Bad
    Request) status code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*无效语法* 的有效载荷是服务器既无法解析也无法理解的有效载荷。无效语法有效载荷的一个典型例子是格式不正确的 JSON。如图 4.8 所示，我们使用
    400 (Bad Request) 状态码来处理这类错误。'
- en: '![](../Images/04-08.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-08.png)'
- en: Figure 4.8 When a client sends a malformed payload, we respond with a 400 (Bad
    Request) status code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 当客户端发送一个格式不正确的有效载荷时，我们以 400 (Bad Request) 状态码进行响应。
- en: '*Unprocessable entities* are syntactically valid payloads that miss a required
    parameter, contain invalid parameters, or assign the wrong value or type to a
    parameter. For example, let’s say that, to place an order, our API expects a POST
    request on the `/orders` URL path with a payload like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可处理的实体* 是语法上有效的有效载荷，但缺少所需的参数，包含无效的参数，或将错误的值或类型分配给参数。例如，假设为了下订单，我们的 API 期望在
    `/orders` URL 路径上发送一个类似以下的 POST 请求：'
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That is, we expect the user to send us a list of elements, where each element
    represents an item of the order. Each item is described by the following properties:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们期望用户发送给我们一个元素列表，其中每个元素代表订单中的一个项目。每个项目由以下属性描述：
- en: '`product`—Identifies the product the user is ordering'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`—标识用户正在订购的产品'
- en: '`size`—Identifies the size that applies to the ordered product'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`—标识适用于订购产品的尺寸'
- en: '`quantity`—Tells us how many items of the same product and size the user wishes
    to order'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`—告诉我们用户希望订购多少个相同产品和大小的项目'
- en: As you can see in figure 4.9, an API client can send a payload missing one of
    the required properties, such as `product`. We address this type of error with
    the 422 (Unprocessable Entity) status code, which signals that something was wrong
    with the request and it couldn’t be processed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.9所示，API客户端可以发送缺少所需属性之一的有效负载，例如`product`。我们使用422（不可处理实体）状态码来处理此类错误，该状态码表示请求存在问题，无法处理。
- en: '![](../Images/04-09.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-09.png)'
- en: Figure 4.9 When an API client sends a malformed payload, the server responds
    back with a 400 (Bad Request) status code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 当API客户端发送格式错误的负载时，服务器会以400（错误请求）状态码响应。
- en: Another common error happens when an API client requests a resource that doesn’t
    exist. For example, we know that the GET `/``orders/{order_id}` endpoint serves
    the details of an order. If a client uses that endpoint with a nonexistent order
    ID, we should respond with an HTTP status code signaling that the order doesn’t
    exist. As you can see in figure 4.10, we address this error with the 404 (Not
    Found) status code, which signals that the requested resource is not available
    or couldn’t be found.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误发生在API客户端请求一个不存在的资源时。例如，我们知道GET `/orders/{order_id}` 端点提供订单的详细信息。如果客户端使用该端点并带有不存在的订单ID，我们应该以一个表示订单不存在的HTTP状态码进行响应。如图4.10所示，我们使用404（未找到）状态码来处理这个错误，该状态码表示请求的资源不可用或找不到。
- en: '![](../Images/04-10.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-10.png)'
- en: Figure 4.10 When an API client requests a resource that doesn’t exist, the server
    responds with status code 404 (Not Found).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 当API客户端请求一个不存在的资源时，服务器会以状态码404（未找到）响应。
- en: Another common error happens when API clients send a request using an HTTP method
    that is not supported. For example, if a user sent a PUT request on the `/orders`
    endpoint, we must tell them that the PUT method is not supported on that URL path.
    There are two HTTP status codes we can use to address this situation. As you can
    see in figure 4.11, we can return a 501 (Not Implemented) if the method hasn’t
    been implemented but will be available in the future (i.e., we have a plan to
    implement it).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误发生在API客户端使用不支持的方法发送请求时。例如，如果用户在`/orders`端点上发送PUT请求，我们必须告诉他们该URL路径不支持PUT方法。我们可以使用两种HTTP状态码来处理这种情况。如图4.11所示，如果方法尚未实现但将来将可用（即我们有计划实现它），我们可以返回501（未实现）状态码。
- en: '![](../Images/04-11.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-11.png)'
- en: Figure 4.11 When an API client sends a request to a URL path with an HTTP method
    that will be exposed in the future but hasn’t been implemented, the server responds
    with a 501 (Not Implemented) status code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 当API客户端向一个未来将公开但尚未实现的URL路径发送请求时，服务器会以501（未实现）状态码响应。
- en: If the requested HTTP method is not available and we don’t have a plan to implement
    it, we respond with the 405 (Method Not Allowed) status code, as illustrated in
    figure 4.12.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的HTTP方法不可用且我们没有计划实现它，我们像图4.12所示的那样以405（方法不允许）状态码进行响应。
- en: '![](../Images/04-12.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-12.png)'
- en: Figure 4.12 When an API client makes a request on a URL path with an HTTP method
    that is not supported and will not be supported, the server responds with a 405
    (Method Not Allowed) status code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 当API客户端对一个不支持且未来也不会支持的HTTP方法进行URL路径请求时，服务器会以405（方法不允许）状态码响应。
- en: Two common errors in API requests have to do with authentication and authorization.
    The first happens when a client sends an unauthenticated request to a protected
    endpoint. In that case, we must tell them that they should first authenticate.
    As you can see in figure 4.13, we address this situation with the 401 (Unauthorized)
    status code, which signals that the user hasn’t been authenticated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: API请求中常见的两个错误与身份验证和授权有关。第一个错误发生在客户端向受保护的端点发送未经身份验证的请求时。在这种情况下，我们必须告诉他们他们应该首先进行身份验证。如图4.13所示，我们使用401（未授权）状态码来处理这种情况，该状态码表示用户尚未经过身份验证。
- en: '![](../Images/04-13.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-13.png)'
- en: Figure 4.13 When an API client sends an unauthenticated request to an endpoint
    that requires authentication, the server responds with a 401 (Unauthorized) status
    code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 当API客户端向需要身份验证的端点发送未经身份验证的请求时，服务器会以401（未授权）状态码响应。
- en: The second error happens when a user is correctly authenticated and tries to
    use an endpoint or a resource they are not authorized to access. An example is
    a user trying to access the details of an order that doesn’t belong to them. As
    you can see in figure 4.14, we address this scenario with the 403 (Forbidden)
    status code, which signals that the user doesn’t have permissions to access the
    requested resource or to perform the requested operation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种错误发生在用户正确认证后，试图访问他们无权访问的端点或资源。一个例子是用户试图访问不属于他们的订单详情。如图4.14所示，我们使用403（禁止）状态码来处理这种情况，这表示用户没有权限访问请求的资源或执行请求的操作。
- en: '![](../Images/04-14.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14](../Images/04-14.png)'
- en: Figure 4.14 When an authenticated user makes a request using an HTTP method
    they’re not allowed to use, the server responds with a 403 (Forbidden) status
    code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 当认证用户使用他们不被允许使用的HTTP方法发起请求时，服务器会以403（禁止）状态码进行响应。
- en: Now that we know how to use HTTP status codes to report user errors, let’s turn
    our attention to status codes for server errors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何使用HTTP状态码来报告用户错误，那么让我们将注意力转向服务器错误的状态码。
- en: 4.6.3 Using HTTP status codes to report errors in the server
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 使用HTTP状态码在服务器中报告错误
- en: The second group of errors are those raised in the server due to a bug in our
    code or to a limitation in our infrastructure. The most common type of error within
    this category is when our application crashes unexpectedly due to a bug. In those
    situations, we respond with a 500 (Internal Server Error) status code, as you
    can see in figure 4.15.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组错误是由于我们代码中的错误或我们基础设施的限制在服务器中引发的。这一类别中最常见的错误类型是当我们的应用程序因错误而意外崩溃时。在这些情况下，我们以500（内部服务器错误）状态码进行响应，如图4.15所示。
- en: '![](../Images/04-15.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15](../Images/04-15.png)'
- en: Figure 4.15 When the server raises an error due to a bug in our code, we respond
    with `a` 500 (Internal Server Error) status code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 当服务器因我们代码中的错误而引发错误时，我们以500（内部服务器错误）状态码进行响应。
- en: 'A related type of error happens when our application becomes unable to service
    requests. We usually handle this situation with the help of a proxy server or
    an API gateway (see section 4.2.4). Our API can become unresponsive when the server
    is overloaded or down for maintenance, and we must let the user know about this
    by sending an informative status code. We distinguish two scenarios:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序无法处理请求时，会发生一种相关的错误类型。我们通常借助代理服务器或API网关（见4.2.4节）来处理这种情况。当服务器过载或维护关闭时，我们的API可能变得无响应，我们必须通过发送信息状态码来让用户知道这一点。我们区分两种情况：
- en: As you can see in figure 4.16, when the server is unable to take on new connections,
    we must respond with a 503 (Service Unavailable) status code, which signals that
    the server is overloaded or down for maintenance and therefore cannot service
    additional requests.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如图4.16所示，当服务器无法接受新的连接时，我们必须响应503（服务不可用）状态码，这表示服务器过载或维护关闭，因此无法处理更多请求。
- en: '![](../Images/04-16.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16](../Images/04-16.png)'
- en: Figure 4.16 When the API server is overloaded and can’t serve additional requests,
    we respond to the client with a 503 (Service Unavailable) status code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 当API服务器过载且无法处理更多请求时，我们向客户端响应503（服务不可用）状态码。
- en: When the server takes too long to respond to the request, we respond with a
    504 (Gateway Timeout) status code, as shown in figure 4.17.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器响应请求过慢时，我们以504（网关超时）状态码进行响应，如图4.17所示。
- en: '![](../Images/04-17.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17](../Images/04-17.png)'
- en: Figure 4.17 When the API server is very slow responding to the request, a proxy
    server responds to the client with a 504 (Gateway Timeout) status code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 当API服务器响应请求非常慢时，代理服务器会以504（网关超时）状态码向客户端响应。
- en: 'This completes our overview of the HTTP status codes most commonly used in
    the design of web APIs. The correct use of status codes goes a long way toward
    delivering a good developer experience for your API clients, but there’s one more
    thing we need to design well: API payloads. In the next section, we turn our attention
    to this important topic.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对在Web API设计中最常用HTTP状态码的概述。正确使用状态码对于为您的API客户端提供良好的开发者体验大有裨益，但我们还需要设计好一件事：API有效载荷。在下一节中，我们将关注这个重要话题。
- en: 4.7 Designing API payloads
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 设计API有效载荷
- en: This section explains best practices for designing user-friendly HTTP request
    and response payloads. *Payloads* represent the data exchanged between a client
    and a server through an HTTP request. We send payloads to the server when we want
    to create or update a resource, and the server sends us payloads when we request
    data. The usability of an API is very much dependent on good payload design. Poorly
    designed payloads make APIs difficult to use and result in bad user experiences.
    It’s therefore important to spend some effort designing high-quality payloads,
    and in this section you’ll learn some patterns and best practices to help you
    in that task.[⁷](#pgfId-1249079)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了设计用户友好的 HTTP 请求和响应负载数据的最佳实践。*负载数据*代表客户端和服务器通过 HTTP 请求交换的数据。当我们想要创建或更新资源时，我们会向服务器发送负载数据，而当请求数据时，服务器会向我们发送负载数据。API
    的可用性很大程度上取决于良好的负载数据设计。设计不良的负载数据会使 API 难以使用，并导致糟糕的用户体验。因此，在设计高质量的负载数据时投入一些努力是很重要的。在本节中，你将学习一些模式和最佳实践，以帮助你完成这项任务。[⁷](#pgfId-1249079)
- en: 4.7.1 What are HTTP payloads, and when do we use them?
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.1 什么是 HTTP 负载数据，我们何时使用它们？
- en: An HTTP request is a message an application client sends to a web server, and
    an HTTP response is the server’s reply to the request. An HTTP *request* includes
    a URL, an HTTP method, a set of headers, and, optionally, a body or payload. HTTP
    headers include metadata about the request’s contents, such as the encoding format.
    Similarly, an HTTP *response* includes a status code, a set of headers, and, optionally,
    a payload. We can represent payloads with different data serialization methods,
    such as XML and JSON. In REST APIs, data is typically represented as a JSON document.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求是应用程序客户端发送给 Web 服务器的消息，HTTP 响应是服务器对请求的回复。HTTP *请求*包括一个 URL、一个 HTTP 方法、一组标头，以及可选的正文或负载数据。HTTP
    标头包含有关请求内容元数据的信息，例如编码格式。同样，HTTP *响应*包括状态码、一组标头，以及可选的负载数据。我们可以用不同的数据序列化方法表示负载数据，例如
    XML 和 JSON。在 REST API 中，数据通常表示为 JSON 文档。
- en: DEFINITION An *HTTP message body* or *payload* is a message that contains the
    data exchanged in an HTTP request. Both HTTP requests and responses can contain
    a message body. The message body is encoded in one of the media types supported
    by HTTP, such as XML or JSON. The Content-Type header of the HTTP request tells
    us the encoding type of the message. In REST APIs, the message body is typically
    encoded as JSON.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*HTTP 消息正文*或*负载数据*是包含 HTTP 请求中交换的数据的消息。HTTP 请求和响应都可以包含消息正文。消息正文以 HTTP 支持的媒体类型之一进行编码，例如
    XML 或 JSON。HTTP 请求的 Content-Type 标头告诉我们消息的编码类型。在 REST API 中，消息正文通常编码为 JSON。
- en: HTTP requests include a payload when we need to send data to the server. For
    example, a POST request typically sends data to create a resource. The HTTP specification
    allows us to include payloads in all HTTP methods, but it discourages their use
    in GET ([http://mng.bz/O69K](http://mng.bz/O69K)) and DELETE ([http://mng.bz/YKeo](http://mng.bz/YKeo))
    requests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要向服务器发送数据时，HTTP 请求会包含负载数据。例如，POST 请求通常用于发送数据以创建资源。HTTP 规范允许我们在所有 HTTP 方法中包含负载数据，但建议不要在
    GET ([http://mng.bz/O69K](http://mng.bz/O69K)) 和 DELETE ([http://mng.bz/YKeo](http://mng.bz/YKeo))
    请求中使用它们。
- en: The wording of the HTTP specification is intentionally vague on whether DELETE
    and GET requests can include a payload. It doesn’t forbid the use of payloads,
    but it states that they don’t have any defined semantics. This allows some APIs
    to include payloads in GET requests. A famous example is Elasticsearch, which
    allows clients to send query documents in the body of a GET request ([http://mng.bz/G14M](http://mng.bz/G14M)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 规范在是否允许 DELETE 和 GET 请求包含负载数据方面故意表述模糊。它没有禁止使用负载数据，但指出它们没有定义的语义。这允许一些 API
    在 GET 请求中包含负载数据。一个著名的例子是 Elasticsearch，它允许客户端在 GET 请求的正文发送查询文档 ([http://mng.bz/G14M](http://mng.bz/G14M))。
- en: What about HTTP responses? Responses may contain a payload depending on the
    status code. According to the HTTP specification, responses with a 1xx status
    code, as well as the 204 (No Content) and 304 (Not Modified) status codes, must
    not include a payload. All other responses do. In the context of REST APIs, the
    most important payloads are those in the 4xx and 5xx error responses, as well
    as 2xx success responses with the exception of the 204 status code. In the next
    section, you’ll learn to design high-quality payloads for all those responses.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么HTTP响应呢？响应可能包含有效载荷，这取决于状态码。根据HTTP规范，状态码为1xx的响应，以及204（无内容）和304（未修改）状态码的响应，不得包含有效载荷。所有其他响应都包含有效载荷。在REST
    API的上下文中，最重要的有效载荷是4xx和5xx错误响应中的有效载荷，以及2xx成功响应中的有效载荷，除了204状态码。在下一节中，你将学习如何为所有这些响应设计高质量的有效载荷。
- en: 4.7.2 HTTP payload design patterns
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.2 HTTP有效载荷设计模式
- en: 'Now that we know when we use payloads, let’s learn best practices for designing
    them. We’ll focus on the design of response payloads, since they present more
    variety. As we learned in section 4.6.1, we distinguish between error and success
    responses. Error responses’ payloads should include an `"error"` keyword detailing
    why the client is getting an error. For example, a 404 response, which is generated
    when the requested resource cannot be found in the server, can include the following
    error message:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了何时使用有效载荷，那么让我们学习设计它们的最佳实践。我们将重点关注响应有效载荷的设计，因为它们具有更多的多样性。正如我们在4.6.1节中学到的，我们区分错误响应和成功响应。错误响应的有效载荷应包括一个
    `"error"` 关键字，详细说明客户端为什么收到错误。例如，当请求的资源在服务器中找不到时生成的404响应，可以包含以下错误信息：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`"error"` is a commonly used keyword for error messages, but you can also use
    other keywords such as `"detail"` and `"message"`. Most web development frameworks
    handle HTTP errors and have default templates for error responses. For example,
    FastAPI uses `"detail`", so we’ll use that keyword in the orders API specification.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`"error"` 是错误消息中常用的关键字，但你也可以使用其他关键字，如 `"detail"` 和 `"message"`。大多数Web开发框架处理HTTP错误，并为错误响应提供默认模板。例如，FastAPI使用
    `"detail"`，因此我们将在订单API规范中使用该关键字。'
- en: 'Among success responses, we distinguish three scenarios: when we create a resource,
    when we update a resource, and when we get the details of a resource. Let’s see
    how we design responses for each of these scenarios.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功响应中，我们区分三种场景：当我们创建一个资源时，当我们更新一个资源时，以及当我们获取一个资源的详细信息时。让我们看看我们是如何为这些场景中的每一个设计响应的。
- en: Response payloads for POST requests
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: POST请求的响应有效载荷
- en: We use POST requests to create resources. In CoffeeMesh’s orders API, we place
    orders through the POST `/orders` endpoint. To place an order, we send the list
    of items we want to buy to the server, which takes responsibility for assigning
    a unique ID to the order, and therefore the order’s ID must be returned in the
    response payload. The server also sets the time when the order was taken and its
    initial status. We call the properties set by the server *server-side* or *read-only
    properties*, and we must include them in the response payload. As you can see
    in figure 4.18, it’s good practice to return a full representation of the resource
    in the response to a POST request. This payload serves to validate that the resource
    was correctly created.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用POST请求来创建资源。在CoffeeMesh的订单API中，我们通过POST `/orders` 端点下订单。为了下订单，我们将我们想要购买的商品列表发送到服务器，服务器负责分配一个唯一的ID给订单，因此订单的ID必须在响应有效载荷中返回。服务器还设置订单被接受的时间和其初始状态。我们将服务器设置的属性称为
    *服务器端* 或 *只读属性*，我们必须在响应有效载荷中包含它们。正如你在图4.18中看到的，对于POST请求的响应返回资源的完整表示是一个好习惯。这个有效载荷的作用是验证资源是否被正确创建。
- en: '![](../Images/04-18.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-18.png)'
- en: Figure 4.18 When an API client sends a POST request to create a new resource,
    the server responds with a full representation of the resource just created with
    its ID and any other properties set by the server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 当API客户端发送POST请求以创建新资源时，服务器会响应一个包含其ID和服务器设置的任何其他属性的资源的完整表示。
- en: Response payloads for PUT and PATCH requests
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PUT和PATCH请求的响应有效载荷
- en: To update a resource, we use a PUT or a PATCH request. As we saw in section
    4.5, we make PUT/PATCH requests on a singleton resource URI, such as the PUT `/orders/`
    `{order_id}` endpoint of CoffeeMesh’s orders API. As you can see in figure 4.19,
    in this case it’s also good practice to return a full representation of the resource,
    which the client can use to validate that the update was correctly processed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新资源，我们使用PUT或PATCH请求。正如我们在4.5节中看到的，我们在单例资源URI上执行PUT/PATCH请求，例如CoffeeMesh订单API的PUT
    `/orders/` `{order_id}`端点。如图4.19所示，在这种情况下，返回资源的完整表示也是良好的实践，客户端可以使用它来验证更新是否正确处理。
- en: '![](../Images/04-19.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-19.png)'
- en: Figure 4.19 When an API client sends a PUT request to update a resource, the
    server responds with a full representation of the resource.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 当API客户端向更新资源的PUT请求发送时，服务器响应资源的完整表示。
- en: Response payloads for GET requests
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GET请求的响应负载
- en: 'We retrieve resources from the server using GET requests. As we established
    in section 4.5, CoffeeMesh’s orders API exposes two GET endpoints: the GET `/orders`
    and the GET `/orders/{orders_id}` endpoints. Let’s see what options we have when
    designing the response payloads of these endpoints.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GET请求从服务器检索资源。正如我们在4.5节中确立的，CoffeeMesh的订单API公开了两个GET端点：GET `/orders`和GET
    `/orders/{orders_id}`端点。让我们看看在设计这些端点的响应负载时我们有哪些建议。
- en: 'The GET `/orders` returns a list of orders. To design the contents of the list,
    we have two strategies: include a full representation of each order or include
    a partial representation of each order. As you can see in figure 4.20, the first
    strategy gives the API client all the information they need in one request. However,
    this strategy may compromise the performance of the API when the items in the
    list are big, resulting in a large response payload.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: GET `/orders` 返回订单列表。为了设计列表的内容，我们有两种策略：包含每个订单的完整表示或包含每个订单的部分表示。如图4.20所示，第一种策略在一个请求中向API客户端提供所有所需信息。然而，当列表中的项目很大时，这种策略可能会影响API的性能，导致响应负载过大。
- en: '![](../Images/04-20.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-20.png)'
- en: Figure 4.20 When an API client sends a request to the GET `/orders` endpoint,
    the server responds with a list of orders, where each order object contains full
    details about the order.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 当API客户端向GET `/orders`端点发送请求时，服务器响应订单列表，其中每个订单对象包含关于订单的完整详细信息。
- en: The second strategy for the GET `/orders` endpoint’s payload is to include a
    partial representation of each order, as you can see in figure 4.21\. For example,
    it’s common practice to include only the ID of each item in the response of a
    GET request on a collection endpoint, such as GET `/orders`. In this situation,
    the client must call the GET `/orders/{order_id}` endpoint to get a full representation
    of each order.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: GET `/orders`端点负载的第二种策略是包含每个订单的部分表示，如图4.21所示。例如，在集合端点的GET请求响应中只包含每个项目的ID是一种常见的做法，如GET
    `/orders`。在这种情况下，客户端必须调用GET `/orders/{order_id}`端点来获取每个订单的完整表示。
- en: '![](../Images/04-21.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-21.png)'
- en: Figure 4.21 When the API client makes a GET request on the `/orders` URL path,
    the server responds with a list of order IDs. The client uses those IDs to request
    the details of each order on the GET `/orders/{order_id}` endpoint.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 当API客户端对`/orders` URL路径发出GET请求时，服务器响应订单ID列表。客户端使用这些ID在GET `/orders/{order_id}`端点上请求每个订单的详细信息。
- en: Which approach is better? It depends on the use case. It’s preferable to send
    a full representation of each resource, especially in public-facing APIs. However,
    if you’re working on an internal API and the full details of each item aren’t
    needed, you can shorten the payload by including only the properties the client
    needs. Smaller payloads are faster to process, which results in a better user
    experience. Finally, singleton endpoints, such as the GET `/orders/{order_id}`,
    must always return a full representation of the resource.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？这取决于用例。在公共API中，发送每个资源的完整表示更可取。然而，如果你正在开发内部API，并且不需要每个项目的全部详细信息，你可以通过只包含客户端需要的属性来缩短负载。较小的负载处理速度更快，这会导致更好的用户体验。最后，单例端点，如GET
    `/orders/{order_id}`，必须始终返回资源的完整表示。
- en: Now that we know how to design API payloads, let’s turn our attention to URL
    query parameters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何设计API负载，让我们将注意力转向URL查询参数。
- en: 4.8 Designing URL query parameters
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 设计URL查询参数
- en: Now let’s talk about URL query parameters and how, why, and when you should
    use them. Some endpoints, such as the GET `/orders` endpoint of the orders API,
    return a list of resources. When an endpoint returns a list of resources, it’s
    best practice to allow users to filter and paginate the results. For example,
    when using the GET `/orders` endpoint, we may want to limit the results to only
    the five most recent orders or to list only cancelled orders. URL query parameters
    allow us to accomplish those goals and should always be optional, and, when appropriate,
    the server may assign default values for them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈URL查询参数以及何时、为什么以及如何使用它们。某些端点，如订单API的GET `/orders`端点，返回资源列表。当一个端点返回资源列表时，最佳实践是允许用户过滤和分页结果。例如，当使用GET
    `/orders`端点时，我们可能只想限制结果为最近的五笔订单，或者只列出已取消的订单。URL查询参数允许我们实现这些目标，并且始终应该是可选的，并且，在适当的情况下，服务器可以为它们分配默认值。
- en: Definition *URL query parameters* are key-value parameters in the URL. Query
    parameters come after a question mark (?), and they’re typically used to filter
    the results of an endpoint, such as the GET `/orders` endpoint of the orders API.
    We can combine multiple query parameters by separating them with ampersands (&).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*URL查询参数*的定义是URL中的键值参数。查询参数位于问号（?）之后，通常用于过滤端点的结果，例如订单API的GET `/orders`端点。我们可以通过使用和号（&）来分隔它们，组合多个查询参数。'
- en: 'URL query parameters are key-value pairs that form part of a URL but are separated
    from the URL path by a question mark. For example, if we want to call the GET
    `/orders` endpoint and filter the results by cancelled orders, we may write something
    like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: URL查询参数是构成URL的一部分的键值对，但它们通过问号与URL路径分开。例如，如果我们想调用GET `/orders`端点并通过已取消的订单过滤结果，我们可能会写如下：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can chain multiple query parameters within the same URL by separating them
    with ampersands. Let’s add a query parameter named `limit` to the GET `/orders`
    endpoint to allow us to restrict the number of results. To filter the GET `/orders`
    endpoint by cancelled orders and restrict the number of results to 5, we make
    the following API request:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用和号（&）来分隔多个查询参数，在同一个URL中链式调用多个查询参数。让我们向GET `/orders`端点添加一个名为`limit`的查询参数，以便我们可以限制结果的数量。为了通过已取消的订单过滤GET
    `/orders`端点并限制结果数量为5，我们发出以下API请求：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s also common practice to allow API clients to paginate results. Pagination
    consists of slicing the results into different sets and serving one set at a time.
    We can use several strategies to paginate results, but the most common approach
    is using a `page` and a `per_page` combination of parameters. `page` represents
    a set of the data, while `per_page` tells us how many items we want to include
    in each set. The server uses `per_page`’s value to determine how many sets of
    the data we’ll get. We combine both parameters in an API request as in the following
    example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 允许API客户端分页结果也是常见的做法。分页包括将结果分割成不同的集合，并一次服务一个集合。我们可以使用几种策略来分页结果，但最常见的方法是使用`page`和`per_page`参数的组合。`page`代表数据集，而`per_page`告诉我们每个集合中要包含多少项。服务器使用`per_page`的值来确定我们将得到多少数据集。我们可以在以下示例中将这两个参数组合在API请求中：
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This concludes our journey through the best practices and design principles
    of REST APIs. You’re now equipped with the resources you need to design highly
    expressive and structured REST APIs that are easy to understand and consume. In
    the next chapter, you’ll learn to document your API designs using the OpenAPI
    standard.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过REST API的最佳实践和设计原则的旅程的结束。你现在拥有了设计高度表达性和结构化的REST API所需的资源，这些API易于理解和消费。在下一章中，你将学习如何使用OpenAPI标准来记录你的API设计。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Representational state transfer (REST) defines the design principles of well-architected
    REST APIs:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表现性状态转移（REST）定义了良好架构的REST API的设计原则：
- en: '*Client-server architecture*—Client and server code must be decoupled.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端-服务器架构*—客户端和服务器代码必须解耦。'
- en: '*Statelessness*—The server must not keep state between requests.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无状态*—服务器必须在请求之间不保持状态。'
- en: '*Cacheability*—Cacheable requests must be cached.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缓存性*—可缓存的请求必须被缓存。'
- en: '*Layered system*—The architectural complexity of the backend must not be exposed
    to end users.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层系统*—后端架构的复杂性不得暴露给最终用户。'
- en: '*Code on demand (optional)*—Client applications may be able to download executable
    code from the server.'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码按需（可选）*—客户端应用程序可能能够从服务器下载可执行代码。'
- en: '*Uniform interface*—The API must provide a uniform and consistent interface.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统一接口*——API必须提供统一且一致的接口。'
- en: Hypermedia as the engine of application state (HATEOAS) is a paradigm that states
    that REST APIs must include referential links in their responses. HATEOAS makes
    APIs navigational and easier to use.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为应用程序状态引擎的超媒体（HATEOAS）是一种范式，它指出REST API必须在它们的响应中包含引用链接。HATEOAS使API具有导航性并更容易使用。
- en: Good REST API design leverages features of the HTTP protocol, such as HTTP methods
    and status codes, to create well-structured and highly expressive APIs that are
    easy to consume.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的REST API设计利用了HTTP协议的特性，例如HTTP方法和状态码，以创建结构良好且高度表达的API，这些API易于消费。
- en: The most important HTTP methods for REST APIs are
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于REST API来说，最重要的HTTP方法是
- en: GET for retrieving resources from the server
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET用于从服务器检索资源
- en: POST for creating new resources
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST用于创建新资源
- en: PUT and PATCH for updating resources
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT和PATCH用于更新资源
- en: DELETE for deleting resources
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DELETE用于删除资源
- en: We exchange data with an API server using payloads. A payload goes in the body
    of an HTTP request or response. Clients send request payloads using the POST,
    PUT, and PATCH HTTP methods. Server responses always include a payload, except
    when the status code is 204, 304, or one from the 1xx group.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用有效载荷与API服务器交换数据。有效载荷位于HTTP请求或响应的主体中。客户端使用POST、PUT和PATCH HTTP方法发送请求有效载荷。服务器响应总是包含有效载荷，除非状态码是204、304或1xx组中的任何一个。
- en: URL query parameters are key-value pairs in the URL, and we use them for filtering,
    paginating, and sorting the results of a GET endpoint.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL查询参数是URL中的键值对，我们使用它们来过滤、分页和排序GET端点的结果。
- en: '* * *'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ The 2022 “State of the API Report” by Postman found that the majority of participants
    in the survey (89%) use REST ([https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ Postman的2022年“API状态报告”发现，调查的大多数参与者（89%）使用REST（[https://www.postman.com/state-of-api/api-technologies/#api-technologies](https://www.postman.com/state-of-api/api-technologies/#api-technologies)）。
- en: ² See Prakash Subramaniam’s excellent article “REST API Design—Resource Modeling”
    for an in-depth discussion of resources and resource modeling in REST APIs ([https://www.thoughtworks.com/en-gb/insights/blog/rest-api-design-resource-modeling](https://www.thoughtworks.com/en-gb/insights/blog/rest-api-design-resource-modeling)).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ² 关于REST API中资源和资源建模的深入讨论，请参阅Prakash Subramaniam的出色文章“REST API设计——资源建模”（[https://www.thoughtworks.com/en-gb/insights/blog/rest-api-design-resource-modeling](https://www.thoughtworks.com/en-gb/insights/blog/rest-api-design-resource-modeling)）。
- en: ³ For more information on this pattern, see Chris Richardson, *Microservices
    Patterns* (Manning, 2019, pp. 259–291; [https://livebook.manning.com/book/microservices-patterns/chapter-8/point-8620-53-297-0](https://livebook.manning.com/book/microservices-patterns/chapter-8/point-8620-53-297-0)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 关于此模式的更多信息，请参阅Chris Richardson的《微服务模式》（Manning，2019，第259-291页；[https://livebook.manning.com/book/microservices-patterns/chapter-8/point-8620-53-297-0](https://livebook.manning.com/book/microservices-patterns/chapter-8/point-8620-53-297-0)）。
- en: '⁴ For the latest specification on URIs, see “RFC 7320: URI Design and Ownership”
    by M. Nottingham (July 2004, [https://tools.ietf.org/html/rfc7320](https://tools.ietf.org/html/rfc7320)).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 关于URI的最新规范，请参阅M. Nottingham的“RFC 7320：URI设计和所有权”（2004年7月，[https://tools.ietf.org/html/rfc7320](https://tools.ietf.org/html/rfc7320)）。
- en: ⁵ Leonard Richardson presented his maturity model in his talk “Justice Will
    Take Us Millions of Intricate Moves” at QCon San Francisco in 2008 ([https://www.crummy.com/writing/speaking/2008-QCon/](https://www.crummy.com/writing/speaking/2008-QCon/)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ Leonard Richardson在2008年QCon旧金山会议上的演讲“正义将需要数百万个复杂的步骤”中提出了他的成熟度模型（[https://www.crummy.com/writing/speaking/2008-QCon/](https://www.crummy.com/writing/speaking/2008-QCon/)）。
- en: ⁶ The CRUD acronym was reportedly introduced by James Martin in his influential
    book *Managing the Data-Base Environment* (Prentice-Hall, 1983, p. 381).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ CRUD缩写据说是由James Martin在他的有影响力的书籍《管理数据库环境》中引入的（Prentice-Hall，1983，第381页）。
- en: ⁷ In addition to learning best practices, you’ll find it useful to read about
    anti-patterns. My article, “How Bad Models Ruin an API (or Why Design-First is
    the Way to Go),” contains an overview of common anti-patterns you should avoid
    ([https://www.microapis.io/blog/how-bad-models-ruin-an-api](https://www.microapis.io/blog/how-bad-models-ruin-an-api)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 除了学习最佳实践外，阅读有关反模式的内容也会很有用。我的文章“如何糟糕的模型破坏API（或为什么设计优先是正确的方法）”概述了你应该避免的常见反模式（[https://www.microapis.io/blog/how-bad-models-ruin-an-api](https://www.microapis.io/blog/how-bad-models-ruin-an-api)）。
