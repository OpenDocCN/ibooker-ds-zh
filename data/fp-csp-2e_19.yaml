- en: 15 Stateful programs and stateful computations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 有状态的程序和有状态的计算
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What makes a program stateful?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是使程序有状态的原因？
- en: Writing stateful programs without mutating state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不突变状态编写有状态的程序
- en: Generating random structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机结构
- en: Composing stateful computations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写有状态的计算
- en: Since chapter 1, I’ve been preaching against state mutation as a side effect
    that should be avoided at almost any cost, and you’ve seen several examples of
    refactoring programs to avoid state mutation. In this chapter, you’ll see how
    the functional approach works when keeping state is a requirement rather than
    an implementation detail of your program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1章开始，我就一直在反对将状态突变作为一种副作用，几乎在任何情况下都应该避免，你已经看到了几个重构程序以避免状态突变的例子。在本章中，你将看到当保持状态是需求而不是程序实现细节时，函数方法是如何工作的。
- en: 'But what’s a *stateful* program exactly? It’s a program whose behavior differs,
    depending on past inputs or events.[¹](#pgfId-1150440) By analogy, if somebody
    says, “Good morning,” you’ll probably mindlessly greet them in return. If that
    person immediately says, “Good morning” again, your reaction will certainly differ:
    Why in the world would somebody say “Good morning” twice in a row? A stateless
    program, on the other hand, would keep answering “Good morning” just as mindlessly
    as before because it has no notion of past inputs. Every time is like the first
    time.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但究竟什么是*有状态的*程序呢？它是一个其行为会根据过去的输入或事件而不同的程序。[¹](#pgfId-1150440) 通过类比，如果有人对你说，“早上好”，你可能会无意识地回应他们。如果那个人立刻又说，“早上好”，你的反应肯定会不同：为什么有人会连续两次说“早上好”？另一方面，无状态的程序会像之前一样无意识地继续回答“早上好”，因为它没有过去输入的概念。每次都像第一次一样。
- en: '![](Images/CH15_UN01_Buonanno2.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_UN01_Buonanno2.png)'
- en: In this chapter, you’ll see how two apparently contradictory ideas—keeping state
    in memory and avoiding state mutation—can be reconciled in a stateful functional
    program. You’ll then see how functions that handle state can be composed using
    the techniques you learned in chapter 14.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将看到如何在有状态的函数程序中调和两个看似矛盾的想法——在内存中保持状态和避免状态突变。然后，你将看到如何使用第14章中学到的技术来组合处理状态的函数。
- en: 15.1 Programs that manage state
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 管理状态的程序
- en: 'In this section, you’ll see a simple command-line program that enables the
    user to look up foreign exchange rates (FX rates). A sample interaction with the
    program would be as follows (bold letters indicate user input):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到一个简单的命令行程序，它允许用户查找外汇汇率（FX汇率）。与程序的一个示例交互如下（粗体字母表示用户输入）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you’ve downloaded the code samples, you can try it out for yourself:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经下载了代码示例，你可以亲自尝试：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following listing shows an initial stateless implementation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个初始的无状态实现。
- en: Listing 15.1 Stateless implementation of a simple program to look up FX rates
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.1 简单查找外汇汇率的程序的无状态实现
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Performs a web request to fetch the requested rate
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行网络请求以获取请求的汇率
- en: You can disregard the implementation details of `RatesApi.GetRate`; all we care
    about is that it takes a currency pair identifier such as EURUSD (for Euros/US
    Dollars) and returns the exchange rate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以忽略`RatesApi.GetRate`的实现细节；我们关心的是它接受一个货币对标识符，例如EURUSD（欧元/美元），并返回汇率。
- en: The program works, but if you repeatedly ask it for the same currency pair,
    it will perform an HTTP request every time. There are several reasons why you
    might want to avoid unnecessary remote requests, such as performance, network
    use, or cost incurred per request. Next, we’ll introduce an in-memory cache to
    avoid looking up rates we’ve already retrieved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以工作，但如果你反复请求相同的货币对，它每次都会执行HTTP请求。你可能有很多原因想要避免不必要的远程请求，比如性能、网络使用或每次请求产生的成本。接下来，我们将介绍一个内存缓存来避免查找我们之前已经检索到的汇率。
- en: 15.1.1 Caching data in memory
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 在内存中缓存数据
- en: We want to store rates in a cache when they’re retrieved and only make HTTP
    requests for rates we haven’t requested before, as figure 15.1 shows. (In practice,
    you’d want values stored in the cache to expire after some time, but I’ll disregard
    this requirement in order to concentrate on the essential aspects of keeping state.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索汇率时，我们想在缓存中存储它们，并且只为之前未请求的汇率进行HTTP请求，如图15.1所示。（在实践中，你希望存储在缓存中的值在一段时间后过期，但为了集中精力在保持状态的本质方面，我将忽略这一要求。）
- en: '![](Images/CH15_F01_Buonanno2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_F01_Buonanno2.png)'
- en: Figure 15.1 Keeping a cache of previously retrieved rates
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 保持之前检索到的汇率的缓存
- en: 'Of course, as functional programmers, we want to do this without state mutation.
    What will be the type of the program’s state? A dictionary would be a natural
    choice, mapping each pair identifier (such as EURUSD) to the corresponding exchange
    rate. Just to make sure we don’t mutate it, let’s make it an immutable dictionary:
    `ImmutableDictionary<string,` `decimal>`. And because that’s quite an ugly type,
    we’ll alias it as `Rates` to make the code less verbose.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为函数式程序员，我们希望在不进行状态变更的情况下完成这项工作。程序的状态类型将是什么？字典将是一个自然的选择，将每个对标识符（如 EURUSD）映射到相应的汇率。为了确保我们不修改它，让我们将其制作为一个不可变字典：`ImmutableDictionary<string,
    decimal>`。由于这是一个相当丑陋的类型，我们将它别名为 `Rates` 以使代码更简洁。
- en: The following listing provides an implementation that stores already retrieved
    rates in the cache and only calls the remote API if the rate wasn’t previously
    retrieved. It does this without state mutation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了一个实现，它将已检索的汇率存储在缓存中，并且仅在汇率之前未检索到时才调用远程 API。它这样做而不进行状态变更。
- en: Listing 15.2 Stateful implementation keeping a cache of rates
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.2 保持汇率缓存的带状态实现
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A readable name for the program state
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 程序状态的易读名称
- en: ❷ Sets up an initial state and passes control to `MainRec`
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置初始状态并将控制权传递给 `MainRec`
- en: ❸ Gets a result as well as the new state
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同时获取结果以及新状态
- en: ❹ Recursively calls itself with the new state
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 递归地以新状态调用自身
- en: ❺ Uses the cached rate if available
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果可用，则使用缓存的速率
- en: ❻ Performs a web request
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 执行网络请求
- en: ❼ Returns a tuple with the retrieved rate and the updated state of the program
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 返回一个包含检索到的汇率和程序更新状态的元组
- en: 'Look at the signatures of the two `GetRate` functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看看两个 `GetRate` 函数的签名：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first signature is the stateless version; the second is the stateful version.
    The latter also takes (along with the requested currency pair) the current state
    of the program, and it returns (along with the resulting rate) the new state of
    the program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个签名是无状态版本；第二个是有状态版本。后者还接受（连同请求的货币对）程序的当前状态，并返回（连同结果汇率）程序的新状态。
- en: Important If global variables can’t be mutated, you must pass state around via
    arguments and return values. This is the key to writing stateful applications
    without mutation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：如果全局变量不能被修改，你必须通过参数传递状态并通过返回值返回。这是编写无状态应用程序而不进行修改的关键。
- en: Let’s now move up to `MainRec` (for recursive), which contains the basic control
    flow of the program. The thing to note here is that it takes as an input parameter
    the current state of the program, which it passes on to `GetRate` to retrieve
    the new state (along with the rate, which is printed). It ends by calling itself
    with the new state.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转到 `MainRec`（用于递归），它包含程序的基本控制流程。这里要注意的是，它接受程序当前状态作为输入参数，并将其传递给 `GetRate`
    以检索新状态（连同打印的汇率）。它通过以新状态调用自身结束。
- en: Finally, `Main` simply calls `MainRec` with the initial state of the program,
    which is an empty cache. You can view the entire program execution as a loop with
    `MainRec` recursively calling itself, passing the current version of the state
    as a parameter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Main` 仅通过程序的初始状态调用 `MainRec`，该初始状态是一个空的缓存。你可以将整个程序执行视为一个循环，其中 `MainRec`
    递归地调用自身，并将当前状态版本作为参数传递。
- en: Note that although there are no global variables in the program, it’s still
    a stateful program. The program keeps some state in memory, which affects how
    the program operates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管程序中没有全局变量，但它仍然是一个有状态程序。程序在内存中保持一些状态，这会影响程序的操作方式。
- en: Generally speaking, recursion is a risky business in C#, as it can blow the
    stack if more than about 10,000 recursive calls are made. If you want to avoid
    the recursive definition, you can use a loop instead. The following listing shows
    the `Main` method rewritten to use a loop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，递归在 C# 中是一个风险业务，因为如果进行了超过约 10,000 次递归调用，它可能会崩溃堆栈。如果你想避免递归定义，可以使用循环代替。以下列表显示了重写的
    `Main` 方法，使用循环。
- en: Listing 15.3 Converting a recursive function to a loop
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.3 将递归函数转换为循环
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The initial state
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始状态
- en: ❷ Reassigns the state variable for the next iteration
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为下一次迭代重新分配状态变量
- en: Here, instead of the recursive call, we keep a local mutable variable, `state`,
    which is reassigned to the new state as needed. We’re not mutating any global
    state, so the fundamental idea still holds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是进行递归调用，而是保持一个局部可变变量 `state`，根据需要将其重新分配为新状态。我们没有修改任何全局状态，所以基本思想仍然成立。
- en: For the remaining examples in this chapter, I’ll stick to the recursive version,
    which I find cleaner. In a real-life application, you’ll want to use the iterative
    version to avoid stack overflow.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余示例中，我将坚持使用递归版本，我认为它更简洁。在实际应用中，你将想要使用迭代版本以避免栈溢出。
- en: 15.1.2 Refactoring for testability and error handling
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 测试性和错误处理的重构
- en: You’ve seen how you can create a stateful program that doesn’t require mutation.
    Before we move on, I’d like to make some improvements to the program in order
    to illustrate some of the ideas around testability and error handling, which you
    saw in previous chapters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何创建一个不需要突变的状态程序。在继续之前，我想对程序进行一些改进，以便说明一些关于测试性和错误处理的想法，这些想法你在前面的章节中已经看到了。
- en: 'You’ll notice that although there are no side effects in terms of state mutation,
    there are I/O side effects everywhere, so the program isn’t at all testable. We
    can refactor `GetRate` to take the function performing the HTTP request as an
    input argument, following the pattern explained in chapter 3:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，尽管在状态突变方面没有副作用，但到处都有 I/O 副作用，所以程序根本不可测试。我们可以重构 `GetRate`，使其接受执行 HTTP 请求的函数作为输入参数，遵循第
    3 章中解释的模式：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now `GetRate` has no side effects other than those that may occur by calling
    the given delegate `getRate`. As a result, it’s easy to unit test this function
    by providing a delegate with a predictable behavior. `MainRec` could likewise
    be brought under test by injecting functions to invoke for I/O.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `GetRate` 除了通过调用给定的委托 `getRate` 可能产生的副作用外，没有其他副作用。因此，通过提供一个具有可预测行为的委托，可以轻松地对这个函数进行单元测试。`MainRec`
    同样可以通过注入要调用的函数来进行测试。
- en: 'Next, there’s no error handling at all: if you enter the name of a currency
    pair that doesn’t exist, the program crashes. Let’s put `Try` to good use. First,
    we’ll wrap the stateless `GetRate` method in a `Try`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，没有任何错误处理：如果你输入一个不存在的货币对名称，程序会崩溃。让我们充分利用 `Try`。首先，我们将无状态的 `GetRate` 方法包装在
    `Try` 中：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The safe function returns a `Try`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安全函数返回一个 `Try`。
- en: ❷ The unsafe version works just like before.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 不安全版本的工作方式与之前相同。
- en: 'The stateful `Program.GetRate` method must now change its signature to not
    take a function returning a `decimal` but a `Try<decimal>`. Accordingly, its return
    type will also be wrapped in a `Try`. Here’s the signature before and after:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的计算 `Program.GetRate` 方法现在必须更改其签名，不再接受返回 `decimal` 的函数，而是接受 `Try<decimal>`。相应地，其返回类型也将被
    `Try` 包装。以下是修改前后的签名：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The following listing shows the refactored implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了重构后的实现。
- en: Listing 15.4 The program refactored to use `Try` for error handling
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.4 使用 `Try` 进行错误处理的程序重构
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could try it out for yourself with
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以亲自尝试它：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s a sample interaction with the program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与程序的一个示例交互：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Returns the cached rate
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回缓存的汇率
- en: ❷ Handles errors gracefully
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 优雅地处理错误
- en: Notice how we were able to add testability and error handling in a relatively
    painless way without puffing up the implementation with interfaces, `try`-`catch`
    statements, and so on. Instead, we have more powerful function signatures and
    more explicit relationships between functions via parameter passing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何能够相对轻松地添加测试性和错误处理，而没有通过接口、`try`-`catch` 语句等来膨胀实现。相反，我们有了更强大的函数签名，以及通过参数传递的函数之间更明确的关系。
- en: 15.1.3 Stateful computations
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3 有状态的计算
- en: As you’ve seen in this section, if you want to handle state functionally (without
    state mutation), state must be made available to functions as an input argument,
    and functions that affect the state must return the updated state as part of their
    result. The remaining part of this chapter focuses on *stateful computations*,
    which are functions that interact with some state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中看到的，如果你想以函数方式（不进行状态突变）处理状态，必须将状态作为输入参数提供给函数，并且影响状态的函数必须将其结果作为它们结果的一部分返回更新后的状态。本章的剩余部分将专注于
    *有状态的计算*，这些是与其他状态交互的函数。
- en: NOTE *Stateful computations* are functions that take a state (as well as, potentially,
    other arguments) and return a new state (along with, potentially, a return value).
    They’re also called *state transitions*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *有状态的计算* 是那些接受一个状态（以及可能的其他参数）并返回一个新的状态（以及可能的一个返回值）的函数。它们也被称为 *状态转换*。
- en: Stateful computations may appear both in stateful and stateless programs. You’ve
    already seen a few examples. In the previous scenario, `GetRate` is a stateful
    computation because it takes some state (the cache) along with a currency pair
    and returns the updated state along with the requested rate. In chapter 13, the
    static `Account` class contained only stateful computations, each taking an `AccountState`
    (along with a command) and returning a new `AccountState` (along with an event
    to store), although in this case, things were slightly complicated by the result
    being wrapped in a `Validation`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 状态计算可能出现在有状态和无状态的程序中。你已经看到了一些例子。在前一个场景中，`GetRate` 是一个状态计算，因为它接受一些状态（缓存）以及一个货币对，并返回更新后的状态以及请求的汇率。在第
    13 章中，静态的 `Account` 类只包含状态计算，每个计算都接受一个 `AccountState`（以及一个命令）并返回一个新的 `AccountState`（以及一个用于存储的事件），尽管在这种情况下，由于结果被包裹在一个
    `Validation` 中，事情变得稍微复杂了一些。
- en: If you want to combine several stateful computations (the process of always
    passing the state into a function), extracting it from the result and passing
    it to the next function can become quite tedious. Fortunately, stateful computations
    can be composed monadically in a way that hides the state-passing, as you’ll see
    next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想组合几个状态计算（总是将状态传递给函数的过程），从结果中提取它并将其传递给下一个函数可能会变得相当繁琐。幸运的是，状态计算可以通过单子方式组合，从而隐藏状态传递，正如你接下来将看到的。
- en: The rest of this chapter contains advanced material, which is not required to
    understand the following chapters, in case you decide to skip to the next chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分包含高级内容，这些内容对于理解以下章节不是必需的，以防你决定跳到下一章。
- en: 15.2 A language for generating random data
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 用于生成随机数据的语言
- en: 'Random data has many legitimate practical uses, including property-based testing
    (which I discussed in chapter 10), load testing (where you generate lots of random
    data and then bombard your system to see how it holds up), and simulation algorithms
    like Monte Carlo. In this context, I’m mainly interested in presenting random
    generation as a good introductory example of how stateful computations compose.
    To get started, type the following into the REPL:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数据有许多合法的实际用途，包括基于属性的测试（我在第 10 章中讨论过）、负载测试（你生成大量的随机数据，然后对你的系统进行轰炸，以查看其表现如何），以及蒙特卡洛等模拟算法。在这种情况下，我主要感兴趣的是将随机生成作为状态计算组合的一个很好的入门示例。要开始，请在
    REPL 中输入以下内容：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because you’re explicitly passing the value 100 as a seed for the random generator,
    you should get *exactly* the same results. As you can see, it’s not that random
    after all. It’s next to impossible to get real randomness with our current computers;
    instead, we use pseudo-random generators, which use a scrambling algorithm to
    deterministically produce an output that *looks* random. Typically, you don’t
    want to get the same sequence of values every time, so a `Random` instance is
    usually initialized without an explicit seed; in this case, the current time is
    used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你明确地将值 100 作为随机生成器的种子传递，你应该得到**完全相同**的结果。正如你所见，它并不像想象中那么随机。在目前的计算机中，要得到真正的随机性几乎是不可能的；相反，我们使用伪随机生成器，它使用一个打乱算法来决定性地产生一个**看起来**随机的输出。通常情况下，你不想每次都得到相同的值序列，因此
    `Random` 实例通常在没有显式种子的情况下初始化；在这种情况下，使用当前时间。
- en: 'If `Random` is deterministic, how does it produce a different output every
    time you call `Next`? The answer is that `Random` is stateful: every time you
    call `Next`, the state of the `Random` instance is updated. In other words, `Next`
    has side effects.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Random` 是确定性的，它是如何每次调用 `Next` 时产生不同的输出呢？答案是 `Random` 是有状态的：每次你调用 `Next`，`Random`
    实例的状态都会更新。换句话说，`Next` 有副作用。
- en: '`Next` is called with no input arguments and yields an `int` as its explicit
    output. But it has an implicit input (the current state of the `Random` instance)
    that determines the output, as well as another implicit output, that is, the new
    state of the `Random` instance. This will in turn determine the output of the
    following call to `Next`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Next` 在没有输入参数的情况下被调用，并返回一个 `int` 类型的显式输出。但是它有一个隐式输入（`Random` 实例的当前状态），这个输入决定了输出，以及另一个隐式输出，即
    `Random` 实例的新状态。这将反过来决定下一次调用 `Next` 的输出。'
- en: 'We’re going to create a side-effect-free random generator where all inputs
    and outputs are explicit. Generating a number is a stateful computation because
    it requires a seed, and it must also generate a new seed to be used in the following
    generation. We don’t want to only generate integers but values of any type, so
    the type of a generator function can be captured with the following delegate:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个无副作用的随机生成器，其中所有输入和输出都是明确的。生成一个数字是一个有状态的计算，因为它需要一个种子，并且还必须生成一个新的种子用于后续的生成。我们不想只生成整数，而是任何类型的值，因此生成器函数的类型可以用以下委托来捕获：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `Generator<T>` is a stateful computation that takes an `int` value as a seed
    (the state) and returns a tuple consisting of the generated `T` and a new seed,
    which can be used to generate a subsequent value. In arrow-notation, the signature
    for `Generator<T>` is
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator<T>` 是一个有状态的计算，它接受一个 `int` 值作为种子（状态）并返回一个由生成的 `T` 和一个新种子组成的元组，该种子可以用于生成后续的值。在箭头符号中，`Generator<T>`
    的签名如下'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To run a generator, we can define the following `Run` methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个生成器，我们可以定义以下 `Run` 方法：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first overload runs the generator with the given seed and returns the generated
    value, disregarding the state. The second overload uses the clock to get a different
    seed value each time it’s called (it’s therefore impure and not testable, unlike
    the first overload). Next, let’s create some generators.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载使用给定的种子运行生成器并返回生成的值，忽略状态。第二个重载使用时钟在每次调用时获取不同的种子值（因此它是非纯净的，不可测试，与第一个重载不同）。接下来，让我们创建一些生成器。
- en: 15.2.1 Generating random integers
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 生成随机整数
- en: The basic building block we need is a generator that scrambles the seed value
    into a new `int`. The following listing shows one possible implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的基本构建块是一个将种子值打乱成新的 `int` 的生成器。以下列表显示了一种可能的实现。
- en: Listing 15.5 A stateful computation returning a pseudorandom number
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.5 返回伪随机数的有状态计算
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a generator that, when given a seed, scrambles it to obtain another
    integer that *looks* unrelated.[²](#pgfId-1150693) It then returns that value
    both as a result value and as a seed to be used in the following computation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器，当给定一个种子时，将其打乱以获得另一个看似无关的整数。[²](#pgfId-1150693) 然后，它将此值作为结果值和用于后续计算的种子返回。
- en: 'Things start to get exciting when you want to generate more complex values.
    It turns out that if you can generate a random `int`, you can generate random
    values for arbitrarily complex types. But let’s start with baby steps: Knowing
    you can generate a random `int`, how could you write a generator for a simpler
    type such as a Boolean?'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想生成更复杂的值时，事情开始变得有趣。结果证明，如果你可以生成一个随机的 `int`，你可以为任意复杂的类型生成随机值。但让我们从小步开始：知道你可以生成一个随机的
    `int`，你将如何编写一个布尔类型等更简单类型的生成器？
- en: 15.2.2 Generating other primitives
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 生成其他原始类型
- en: 'Remember, a generator takes a seed and returns a new value (in this case, the
    generated Boolean) along with a new seed. The skeleton of a `Generator<bool>`
    would be as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，生成器接受一个种子并返回一个新值（在这种情况下，生成的布尔值）以及一个新种子。`Generator<bool>` 的骨架如下：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How can we go about implementing it? We already have a generator for an `int`,
    so we can generate an `int` and return true/false depending on whether it's even/odd.
    We also need to return a new seed, and for this, we can take advantage of the
    new seed computed when generating the `int`. Essentially, we’re using `NextInt`,
    transforming the resulting `int` into a `bool` and reusing the seed. Figure 15.2
    illustrates this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现它？我们已经有了一个 `int` 的生成器，因此我们可以生成一个 `int` 并根据它是偶数还是奇数返回 true/false。我们还需要返回一个新的种子，为此，我们可以利用生成
    `int` 时计算的新种子。本质上，我们正在使用 `NextInt`，将结果 `int` 转换为 `bool` 并重用种子。图 15.2 说明了这一点。
- en: '![](Images/CH15_F02_Buonanno2.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_F02_Buonanno2.png)'
- en: Figure 15.2 Using the `NextInt` generator to generate a Boolean
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 使用 `NextInt` 生成器生成布尔值
- en: 'The implementation is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方式如下：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s think of this differently. What we’re doing here is effectively
    mapping a function that turns an `int` into a `bool` while reusing the new seed
    returned by the existing `NextInt` generator. We can generalize this pattern to
    define `Map`: if you have a `Generator<T>` and a function `f` `: T` `→` `R`, you
    can obtain a `Generator<R>` as follows: run the generator to obtain a `T` and
    a new seed; apply `f` to obtain an `R`; return the resulting `R` along with the
    new seed. The following listing shows the implementation of `Map`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们换一种不同的方式来思考这个问题。我们在这里所做的是有效地映射一个函数，该函数将 `int` 转换为 `bool`，同时重用现有 `NextInt`
    生成器返回的新种子。我们可以将这个模式推广到定义 `Map`：如果你有一个 `Generator<T>` 和一个函数 `f` `: T` `→` `R`，你可以获得一个
    `Generator<R>`，如下所示：运行生成器以获得一个 `T` 和一个新种子；应用 `f` 以获得一个 `R`；返回结果 `R` 以及新种子。以下列表显示了
    `Map` 的实现。'
- en: Listing 15.6 Definition of `Map` for `Generator<T>`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.6 `Generator<T>` 的 `Map` 定义
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ `Map` returns a generator that, when given a seed...
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Map` 返回一个生成器，当给定一个种子...
- en: ❷ ... runs the given generator `gen` to obtain a `T` and a new seed...
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ... 运行给定的生成器 `gen` 以获得一个 `T` 和一个新种子...
- en: ❸ ... then uses `f` to turn the `T` into an `R`, which is returned along with
    the new seed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ... 然后使用 `f` 将 `T` 转换为 `R`，并将其与新种子一起返回。
- en: We can now define generators for types that carry less information than an `int`
    (such as `bool` or `char`) much more concisely, as in the following listing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更简洁地定义携带比 `int` 少的信息的类型生成器（例如 `bool` 或 `char`），如下所示。
- en: Listing 15.7 Building upon `NextInt` to generate other types
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.7 基于 `NextInt` 生成其他类型
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Generates an `int`...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成一个 `int`...
- en: ❷ ...returns whether it’s even
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ ... 返回它是否为偶数
- en: That’s much more readable because we don’t have to explicitly worry about the
    seed, and we can read the code in terms of “generate an int, and return whether
    it’s even.”
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易于阅读，因为我们不必显式地担心种子，我们可以用“生成一个 int，并返回它是否为偶数”来阅读代码。
- en: 15.2.3 Generating complex structures
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 生成复杂结构
- en: 'Now let’s move on and see how we can generate more complex values. Let’s try
    to generate a pair of integers. We’d have to write something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看我们如何生成更复杂的价值。让我们尝试生成一对整数。我们不得不写点像这样的事情：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here you see that for each stateful computation (or for each time we generate
    a random value), we need to extract the state (the newly created seed) and pass
    it on to the next computation. This is rather noisy. Fortunately, we can do away
    with the explicit state-passing by composing the generators with a LINQ expression
    as the following listing shows.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到对于每个有状态的计算（或者每次我们生成一个随机值），我们需要提取状态（新创建的种子）并将其传递给下一个计算。这相当嘈杂。幸运的是，我们可以通过将生成器与以下列表所示的
    LINQ 表达式组合来消除显式的状态传递。
- en: Listing 15.8 Defining a function that generates a pair of random integers
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.8 定义一个生成随机整数对的函数
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Generates an `int` and calls it `a`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成一个 `int` 并将其称为 `a`
- en: ❷ Generates another `int` and calls it `b`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成另一个 `int` 并将其称为 `b`
- en: ❸ Returns the pair of `a` and `b`
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回 `a` 和 `b` 的对
- en: This is much more readable, but under the covers, it’s the same as before. This
    works because I’ve defined an implementation of `Bind`/`SelectMany` that takes
    care of “threading the state,” passing it from one computation to the next. Graphically,
    figure 15.3 shows how `Bind` works. Listing 15.9 shows the corresponding code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易于阅读，但底层原理与之前相同。这是因为我已经定义了一个 `Bind`/`SelectMany` 的实现，它负责“传递状态”，将状态从一个计算传递到下一个计算。从图形上看，图
    15.3 显示了 `Bind` 的工作方式。列表 15.9 显示了相应的代码。
- en: '![](Images/CH15_F03_Buonanno2.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH15_F03_Buonanno2.png)'
- en: Figure 15.3 Definition of `Bind` for `Generator<T>`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 `Generator<T>` 的 `Bind` 定义
- en: Listing 15.9 Definition of `Bind` for `Generator<T>`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.9 `Generator<T>` 的 `Bind` 定义
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we have all the building blocks to generate arbitrarily complex types.
    Say we want to create an `Option<int>`. That’s easy—generate a Boolean for the
    state of the `Option` and an `int` for the value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有构建块来生成任意复杂的类型。比如说我们想要创建一个 `Option<int>`。这很简单——为 `Option` 的状态生成一个布尔值，并为值生成一个
    `int`：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should look familiar. You saw some similar code in section 10.1.3 when
    we were using FsCheck to define property tests and we needed to provide a method
    for generating random `Option`s. Indeed, FsCheck’s random generator is defined
    along the same lines as this one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很熟悉。当我们在 10.1.3 节中使用 FsCheck 定义属性测试并需要提供一个生成随机 `Option` 的方法时，你看到了一些类似的代码。实际上，FsCheck
    的随机生成器定义与这个类似。
- en: The following listing shows a slightly more complex example, that of generating
    a sequence of `int`s.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个稍微复杂一点的例子，即生成 `int` 序列。
- en: Listing 15.10 Generating a list of random numbers
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.10 生成随机数字列表
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s start with the top-level `IntList`. We generate a random Boolean to tell
    us if the sequence should be empty.[³](#pgfId-1150822) If so, we use `Empty`,
    which is a generator that always returns an empty sequence; otherwise, we return
    a non-empty sequence by calling `NonEmpty`. This generates an `int` as the first
    element and a random sequence to follow it. Note that `Empty` uses the `Return`
    function for `Generator`, which lifts a value into a generator that always returns
    that value and doesn’t affect the state it’s given.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶层 `IntList` 开始。我们生成一个随机的布尔值来告诉我们序列是否应该为空。[³](#pgfId-1150822) 如果是，我们使用 `Empty`，这是一个总是返回空序列的生成器；否则，我们通过调用
    `NonEmpty` 返回一个非空序列。这会生成一个 `int` 作为第一个元素，以及一个随后的随机序列。注意，`Empty` 使用 `Return` 函数为
    `Generator`，它将一个值提升为一个总是返回该值且不影响其状态的生成器。
- en: What about generating a string? A string is essentially a sequence of characters,
    so we can generate a list of `int`s, convert each `int` to a `char`, and build
    a string from the resulting sequence of characters. As you can see, we follow
    this approach to generate a language for combining generators of various types
    into generators for arbitrarily complex types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么生成一个字符串呢？字符串本质上是一系列字符，因此我们可以生成一个 `int` 列表，将每个 `int` 转换为 `char`，并从生成的字符序列中构建一个字符串。正如你所见，我们遵循这种方法来生成一个将各种类型的生成器组合成任意复杂类型生成器的语言。
- en: 15.3 A general pattern for stateful computations
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 状态计算的通用模式
- en: 'There are many other scenarios in which we may want to compose several stateful
    computations, other than generating random values. For this, we can use a more
    general delegate, `StatefulComputation`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他场景中，我们可能想要组合多个状态计算，而不仅仅是生成随机值。为此，我们可以使用一个更通用的委托，`StatefulComputation`：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A `StatefulComputation<T>` is a function in this form:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatefulComputation<T>` 是这种形式的函数：'
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`T` is the function’s result value, and `S` is the state.[⁴](#pgfId-1150835)
    You can compare this to the signature of `Generator<T>` to see how similar they
    are:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 是函数的结果值，`S` 是状态。[⁴](#pgfId-1150835) 你可以将它与 `Generator<T>` 的签名进行比较，看看它们有多么相似：'
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With `Generator`, the state that gets passed in and out is always an `int`.
    With the more general `StatefulComputation`, the state could be of an arbitrary
    type `S`. Thus, we can define `Map` and `Bind` in the same way (the only difference
    being an additional type parameter) and let them take care of threading the state
    between one computation and the next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Generator`，传入和传出的状态始终是一个 `int`。在更通用的 `StatefulComputation` 中，状态可以是任意类型 `S`。因此，我们可以以相同的方式定义
    `Map` 和 `Bind`（唯一的区别是额外的类型参数）并让它们负责在计算之间传递状态。
- en: In chapter 11, we discussed trees, and you saw how you could define a `Map`
    function that creates a new tree, where each element is the result of applying
    a function to each value in the original tree. Imagine that you now want to assign
    a number to each element, as figure 15.4 shows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 章中，我们讨论了树，你看到了如何定义一个 `Map` 函数，该函数创建一个新的树，其中每个元素都是将函数应用于原始树中的每个值的结果。想象一下，你现在想给每个元素分配一个数字，如图
    15.4 所示。
- en: '![](Images/CH15_F04_Buonanno2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH15_F04_Buonanno2.png)'
- en: Figure 15.4 Numbering each element in a tree
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 树中每个元素的编号
- en: This operation is similar to `Map` in the sense that you must traverse the tree
    and apply a function to each element. But, additionally, you must keep some state
    (a counter value) that needs to be incremented as you visit each element and used
    to label each leaf.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作与 `Map` 类似，因为你必须遍历树并对每个元素应用一个函数。但除此之外，你还必须保持一些状态（一个计数器值），这个值在访问每个元素时需要递增，并用于标记每个叶子节点。
- en: 'Let’s start by defining a `Numbered<T>` type that wraps a `T` and a number:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个 `Numbered<T>` 类型，它封装了一个 `T` 和一个数字：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means the operation we’re trying to model can be expressed as a function
    from `Tree<T>` to `Tree<Numbered<T>>`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们试图表示的操作可以表示为从 `Tree<T>` 到 `Tree<Numbered<T>>` 的函数。
- en: The following listing shows an initial implementation that traverses the tree,
    explicitly passing the state (a counter value) around.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个初始实现，它遍历树，显式地传递状态（计数器值）。
- en: Listing 15.11 Numbering the leaves of a tree by explicitly passing state
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.11 通过显式传递状态对树的叶子节点进行编号
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Calls the stateful overload, passing 0 as the initial state
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用状态重载，传入 0 作为初始状态
- en: ❷ Labels this leaf with the current count
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用当前计数标记这个叶子
- en: ❸ Returns the incremented count as the new state
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回增加后的计数作为新状态
- en: ❹ Recursively calls `Number` on the left and right subtrees
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 递归地在左右子树上调用`Number`
- en: ❺ Returns the new tree with the updated count
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回更新后的新树
- en: We start the computation with a count of 0\. The numbering function simply matches
    on the type of tree. If it’s a leaf, then it contains a `T`, so `Number` returns
    a pair, containing as the result a `Numbered<T>` (wrapping the `T` and the current
    count) and as the new state the incremented counter. If it’s a branch, then we
    recursively call `Number` on the left and right subtrees. Because each of these
    operations returns an updated state, we must thread the state along and return
    it in the result value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从计数为0的计算开始。编号函数简单地根据树类型进行匹配。如果是叶子，则包含一个`T`，因此`Number`返回一个对，其中结果是一个`Numbered<T>`（包装`T`和当前计数），新状态是增加后的计数器。如果是分支，则我们在左右子树上递归调用`Number`。因为这些操作中的每一个都返回一个更新后的状态，我们必须将状态传递下去，并在结果值中返回它。
- en: Although I find the preceding solution satisfactory, it’s true that manually
    passing state along introduces some noise. We can get rid of that by refactoring
    the code to use the `StatefulComputation` delegate instead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我发现前面的解决方案令人满意，但手动传递状态确实引入了一些噪声。我们可以通过重构代码以使用`StatefulComputation`委托来消除这一点。
- en: 'We’ll start by defining a simple stateful computation that takes an `int` (the
    state, which in this case is the counter) and returns the counter as the value
    and the incremented state as the new state:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个简单的有状态计算，它接受一个`int`（状态，在这种情况下是计数器）并返回计数器作为值和增加后的状态作为新状态：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remember, a stateful computation returns both a *value* and a *new state*. `GetAndIncrement`
    returns the current counter value as the returned value and the incremented counter
    as the new state.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，有状态计算返回一个*值*和一个*新状态*。`GetAndIncrement`返回当前计数器值作为返回值和增加后的计数器作为新状态。
- en: 'The interesting thing about `GetAndIncrement` is that it allows you to peek
    into the state: because the current counter value becomes the inner value of the
    computation, you can refer to it in a LINQ expression. You can see this in the
    following code, where we assign the current count value to the `count` variable.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAndIncrement`的有趣之处在于它允许你查看状态：因为当前的计数器值成为计算的内部值，你可以在LINQ表达式中引用它。你可以在以下代码中看到这一点，我们将当前计数值分配给`count`变量。'
- en: The following listing shows how we can rewrite our tree numbering function using
    LINQ to take care of passing the state.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用LINQ重写我们的树编号函数，以处理传递状态。
- en: Listing 15.12 Numbering the leaves of a tree using LINQ
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.12 使用LINQ对树叶子进行编号
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Assigns the current count to the `count` variable, while assigning the incremented
    count to the state
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将当前计数分配给`count`变量，同时将增加后的计数分配给状态
- en: ❷ The result is a new leaf containing the original leaf value, numbered with
    the current count.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 结果是一张包含原始叶子值的新叶子，编号为当前计数。
- en: 'As you can see, when you’re composing a sequence of several stateful computations
    as in the `Branch` case, LINQ can really improve readability. Otherwise, I find
    that passing the state around explicitly is clearer. Note that the preceding function
    returns a computation, which does nothing until it’s given an input state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你像`Branch`情况那样组合一系列有状态计算时，LINQ确实可以改善可读性。否则，我发现显式传递状态更清晰。请注意，前面的函数返回一个计算，它直到被赋予输入状态之前什么都不做：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Although stateful computations are ubiquitous, the need to chain several computations
    isn’t as frequent. It does crop up often in certain areas, though, such as simulations
    or parsers. A functional parser, for example, is usually modeled as a function
    that takes a string (the state), consumes part of the string, and produces a result
    consisting of a structured representation of what’s been parsed and the remainder
    of the string that’s left to parse (the new state).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有状态的计算无处不在，但需要链式调用多个计算的情况并不常见。然而，在特定领域，如模拟或解析器中，这种情况却经常出现。例如，一个功能解析器通常被建模为一个函数，该函数接受一个字符串（状态），消耗字符串的一部分，并产生一个结果，该结果由已解析的结构化表示和剩余待解析的字符串（新状态）组成。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When writing stateful programs, you can avoid changing state as a side effect
    by always passing the state explicitly as part of your functions' input and output.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编写有状态程序时，你可以通过始终显式地将状态作为函数的输入和输出的一部分来避免作为副作用改变状态。
- en: Stateful computations are functions in the form `S` `→` `(T,` `S)`. They take
    some state and return a value as well as an updated state.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态计算是形式为 `S` `→` `(T,` `S)` 的函数。它们接受一些状态，并返回一个值以及更新后的状态。
- en: Stateful computations can be composed monadically to reduce the syntactic burden
    of passing the state from one computation to the next.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态计算可以通过单调组合来减少从一次计算传递到下一次计算的状态的语法负担。
- en: '* * *'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ This means that a program may be considered stateful/stateless depending on
    where you draw the program boundary. You may have a stateless server that uses
    a DB to keep state. If you consider both as one program, it’s stateful; if you
    consider the server in isolation, it’s stateless.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 这意味着一个程序可能被认为是具有状态/无状态的，这取决于你如何划分程序边界。你可能有一个无状态的服务器，它使用数据库来保持状态。如果你将两者视为一个程序，那么它是具有状态的；如果你单独考虑服务器，那么它是无状态的。
- en: ² The specifics of the algorithm are irrelevant for the purposes of this discussion.
    There are many algorithms for generating pseudorandom numbers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ² 算法的具体细节对于本次讨论的目的来说并不重要。有许多生成伪随机数的算法。
- en: ³ This means that, statistically, half the generated lists will be empty, a
    quarter of the lists will have one element, and so on, so this generator is unlikely
    to produce a long list. You can follow a different approach and generate a random
    length first, presumably within a given range, and then populate the values. As
    this shows, once you start to generate random data, it’s important to define parameters
    that govern the random generation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这意味着，从统计学的角度来看，一半生成的列表将是空的，四分之一的列表将有一个元素，依此类推，因此这个生成器不太可能产生一个长的列表。你可以采取不同的方法，首先生成一个随机长度，假设在给定的范围内，然后填充值。正如这所显示的，一旦你开始生成随机数据，定义控制随机生成的参数就很重要。
- en: ⁴ In FP lingo, this is called *the state monad*. This is a truly terrible name
    to describe a function that takes some state as an argument. This unfortunate
    name is probably the greatest hurdle to understanding it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 在函数式编程（FP）的术语中，这被称为*状态单子*。这是一个真正糟糕的名称，用来描述一个接受某些状态作为参数的函数。这个不幸的名称可能是理解它的最大障碍。
