- en: 6 Identifying resource consumption problems using profiling techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用性能分析技术识别资源消耗问题
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Evaluating resource consumption
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估资源消耗
- en: Identifying issues with resource consumption
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别资源消耗问题
- en: “And for you, Frodo Baggins, I give you the light of Eärendil, our most beloved
    star. May it be a light to you in dark places when all other lights go out.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “至于你，弗罗多·巴金斯，我给你Eärendil的光，我们最喜爱的星星。愿它在所有其他灯光熄灭的黑暗地方成为你的光明。”
- en: —Galadriel (*Lord of the Rings*, by J.R.R. Tolkien)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ——加拉德丽尔（J.R.R. 托尔金的《魔戒》）
- en: 'In this chapter, we start with using a profiler. We’ll continue the discussion
    in chapter 7\. A profiler may not be as powerful as the light of Eärendil, but
    this tool is definitely a light in dark cases when all the other lights go out.
    A *profiler* is a powerful tool that has helped me to understand the root cause
    of an app’s strange behavior in many difficult situations. I consider learning
    to use a profiler a must for all developers, as it can be a compass to guide you
    to the cause of a seemingly hopeless problem. As you’ll learn in this chapter,
    the profiler intercepts the executing JVM processes and offers extremely useful
    details:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先从使用性能分析器开始。我们将在第7章继续讨论。性能分析器可能不如Eärendil的光那么强大，但这个工具在所有其他灯光熄灭的黑暗情况下绝对是一盏明灯。*性能分析器*是一个强大的工具，它帮助我在许多困难情况下理解应用程序奇怪行为的原因。我认为学习使用性能分析器对所有开发者来说都是必须的，因为它可以成为指引你找到看似无望的问题原因的指南。正如你将在本章中学到的，性能分析器拦截正在执行的JVM进程，并提供极其有用的详细信息：
- en: How the app consumes resources such as the CPU and memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序如何消耗资源，如CPU和内存
- en: The threads in execution and their current status
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在执行的线程及其当前状态
- en: The code in execution and the resources spent by a given piece of code (e.g.,
    the duration of each method’s execution)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在执行的代码及其消耗的资源（例如，每个方法执行的持续时间）
- en: In section 6.1, we will analyze some scenarios so you can see how the details
    provided by a profiler can be useful and why they are so important. In section
    6.2, we will discuss using a profiler to solve the scenarios in section 6.1\.
    We’ll start by installing and configuring a profiler in section 6.2.1\. Then,
    in section 6.2.2., we’ll analyze how an app consumes system resources, and in
    section 6.2.3, we’ll learn how to identify when an app is having issues with managing
    the used memory. We’ll continue our discussion about using a profiler in chapter
    7, where you’ll learn how to identify the code in execution and the performance
    problems related to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.1节中，我们将分析一些场景，以便你可以看到性能分析器提供的细节如何有用，以及为什么它们如此重要。在6.2节中，我们将讨论使用性能分析器解决6.1节中的场景。我们将在6.2.1节中开始安装和配置性能分析器。然后，在6.2.2节中，我们将分析应用程序如何消耗系统资源，而在6.2.3节中，我们将学习如何识别应用程序在管理使用内存方面出现问题时的情况。我们将在第7章继续讨论使用性能分析器，你将学习如何识别正在执行的代码及其相关的性能问题。
- en: 'I use the VisualVM profiler for the examples in this chapter. VisualVM is a
    free profiler and an excellent tool I’ve successfully used for many years. You
    can download VisualVM here: [https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml).
    VisualVM is not the only profiling tool for Java apps. Some other well-known profiling
    tools are Java Mission Control ([http://mng.bz/AVQE](http://mng.bz/AVQE)) and
    JProfiler ([http://mng.bz/Zplj](http://mng.bz/Zplj)).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章的示例中使用VisualVM性能分析器。VisualVM是一个免费的性能分析器，是我多年来成功使用的优秀工具。你可以从这里下载VisualVM：[https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)。VisualVM不是Java应用程序的唯一性能分析工具。一些其他知名的性能分析工具包括Java
    Mission Control ([http://mng.bz/AVQE](http://mng.bz/AVQE)) 和 JProfiler ([http://mng.bz/Zplj](http://mng.bz/Zplj))。
- en: 6.1 Where would a profiler be useful?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 性能分析器在哪里会有用？
- en: 'In this section, we analyze three scenarios in which a profiling tool can help
    you:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了三个场景，其中性能分析工具可以帮助你：
- en: Identifying abnormal usage of resources
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别资源使用异常
- en: Finding which part of code executes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到执行中的代码部分
- en: Identifying slowness in an app’s execution
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别应用程序执行中的缓慢
- en: 6.1.1 Identifying abnormal usage of resources
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 识别资源使用异常
- en: 'A profiler is commonly used to determine how an app consumes CPU and memory,
    which helps you to understand the app’s specific problems. Thus, it is the first
    step in investigating such issues. Observing how the app consumes resources will
    usually lead you to two categories of issues:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器通常用于确定应用程序如何消耗CPU和内存，这有助于你理解应用程序的具体问题。因此，它是调查此类问题的第一步。观察应用程序如何消耗资源通常会引导你到两类问题：
- en: '*Thread-related issues*—Usually concurrency issues caused by a lack of or improper
    synchronization'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*线程相关的问题*——通常是由缺乏或不适当的同步引起的并发问题'
- en: '*Memory leaks*—Situations in which the app fails to remove unneeded data from
    memory, causing slowness in execution and potentially a complete failure of the
    app'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存泄漏*——应用程序未能从内存中移除不必要数据的情况，导致执行缓慢，并可能导致应用程序完全失败'
- en: I‘ve encountered both types of issues in real-world apps more than I would have
    liked. The effects of resource usage issues are very diverse. In some cases, they
    just cause slowness in the app; in other cases, they may cause the app to fail
    entirely. My “favorite” thread-related issue I have had to solve using a profiler
    was causing battery problems on a mobile device. Slowness wasn’t the biggest problem.
    Users complained that their device’s battery was consumed unnaturally fast when
    they used this Android-based app. This behavior definitely required investigation.
    After spending some time observing the app’s behavior, I discovered that one of
    the libraries the app used sometimes created threads that remained in execution
    and did nothing but consume the system’s resources. In a mobile app, CPU resource
    use is often reflected in the battery’s consumption.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我在现实世界中的应用程序中遇到了这两种类型的问题，比我愿意遇到的要多。资源使用问题的影响非常多样。在某些情况下，它们只会导致应用程序变慢；在其他情况下，它们可能导致应用程序完全失败。我必须使用分析器解决的“最喜欢”的线程相关问题是在移动设备上导致电池问题。变慢并不是最大的问题。用户抱怨说，当他们使用这个基于Android的应用程序时，他们的设备电池消耗得非常快。这种行为肯定需要调查。在花了一些时间观察应用程序的行为后，我发现应用程序使用的某个库有时会创建一些保持执行状态但什么也不做的线程，只是消耗系统资源。在移动应用程序中，CPU资源的使用通常反映在电池的消耗上。
- en: Once you discover the potential problem, you can investigate it further with
    a thread dump, as you’ll learn in chapter 10\. Generally, the root cause of such
    problems is a faulty synchronization of the threads.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现了潜在的问题，你就可以通过线程转储进一步调查它，正如你将在第10章中学到的。通常，此类问题的根本原因是线程的同步错误。
- en: I also find memory leaks now and then in apps. In most cases, the final result
    of a memory leak is an `OutOfMemoryError` that leads to an app crash. So when
    I hear about an app crashing, I usually suspect a memory problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我也时不时地在应用程序中发现内存泄漏。在大多数情况下，内存泄漏的最终结果是一个`OutOfMemoryError`，这会导致应用程序崩溃。所以当我听说应用程序崩溃时，我通常会怀疑存在内存问题。
- en: TIP Whenever you encounter an app that is randomly crashing, you should consider
    a memory leak.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：每当遇到随机崩溃的应用程序时，你应该考虑内存泄漏。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/icon_guy.png)'
- en: The root cause of abnormal resource use is often an error in coding that allows
    object references to exist even after the objects are no longer needed. Remember
    that although the JVM has an automatic mechanism that releases unneeded data from
    memory (we call this mechanism the *garbage collector* [GC]), it’s still the developer’s
    responsibility to ensure that all references to unnecessary data are removed.
    If we implement code that retains references to objects, the GC doesn’t know they
    are no longer used and won’t remove them. We call this situation a *memory leak*.
    In section 6.2.3, you’ll learn to use the profiler to identify when such a problem
    exists; then, in chapter 11, you’ll learn to research its root cause using a heap
    dump.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 资源使用异常的根本原因通常是在编码中出现的错误，即使对象不再需要，也会允许对象引用存在。请记住，尽管JVM有一个自动机制可以从内存中释放不再需要的数据（我们称这个机制为*垃圾回收器*
    [GC]），但确保所有对不必要数据的引用都被移除仍然是开发者的责任。如果我们实现保留对象引用的代码，GC不知道它们不再被使用，因此不会移除它们。我们称这种情况为*内存泄漏*。在第6.2.3节中，你将学习如何使用分析器来识别此类问题；然后，在第11章中，你将学习如何使用堆转储来研究其根本原因。
- en: 6.1.2 Finding out what code executes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 查找执行代码
- en: 'As a developer and consultant, I sometimes worked with large, complex, and
    dirty codebases. Several times I have been in a situation in which I had to investigate
    a particular app capability; I could reproduce the problem but had no idea which
    part of the code was involved. Some years ago, I investigated a problem with a
    legacy app running some processes. The company’s management made the uninspired
    decision to let just one developer be responsible for the code. No one else had
    any idea what was there or how to work with it. When that developer departed,
    leaving behind no documentation or a friendly codebase, I was asked to help identify
    the cause of an issue. The first look at the code scared me a bit: the app lacked
    a class design, and there was a combination of Java and Scala mixed with some
    Java reflection-driven code.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发人员和顾问，我有时与大型、复杂且混乱的代码库合作。有好几次，我不得不调查一个特定应用程序的功能；我能够重现问题，但不知道代码的哪个部分参与了其中。几年前，我调查了一个运行某些进程的遗留应用程序的问题。公司的管理层做出了一个不太明智的决定，让只有一个开发者负责代码。没有人知道那里有什么或者如何与之合作。当那个开发者离开时，没有留下任何文档或友好的代码库，我被要求帮助确定问题的原因。第一次看到代码让我有点害怕：应用程序缺少类设计，Java和Scala混合了一些由Java反射驱动的代码。
- en: How do you figure out which code you need to investigate in such a case? Fortunately,
    a profiler has the capability of sampling the executing code. The tool intercepts
    the methods and visually displays what executes, giving you just enough to start
    an investigation. Once you find the code in execution, you can read it and, eventually,
    use a debugger, as discussed in chapters 2 to 4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你如何确定需要调查的代码？幸运的是，性能分析器具有采样执行代码的能力。该工具拦截方法，并以可视化的方式显示执行的内容，为你提供足够的信息开始调查。一旦你找到了正在执行的代码，你可以阅读它，并最终使用第2章到第4章中讨论的调试器。
- en: With a profiler, you can find what code executes behind the scenes without first
    looking into the code. This capability is called *sampling*, and it is particularly
    useful when the code is so muddy that you can’t even understand what is being
    called.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用性能分析器，你可以找到幕后执行的代码，而无需首先查看代码。这种能力被称为*采样*，当代码如此混乱以至于你甚至无法理解正在调用什么时，这种能力尤其有用。
- en: 6.1.3 Identifying slowness in an app’s execution
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 识别应用程序执行中的缓慢
- en: In some cases, you have to deal with performance problems. The general question
    you want to answer for such cases is, “What is taking so long to execute?” Empirically,
    developers always first suspect the parts of the code related to I/O communication.
    Calling a web service, connecting to a database, or storing data in a file are
    examples of I/O actions that often cause latencies in apps. Still, an I/O call
    isn’t always the cause of a slowness problem. And even then, unless you know the
    codebase by heart (which rarely happens), it is still difficult to spot where
    the problem comes from without some help.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你必须处理性能问题。对于这类情况，你想要回答的一般问题是：“为什么执行这么慢？”从经验上看，开发者总是首先怀疑与I/O通信相关的代码部分。调用网络服务、连接到数据库或存储数据到文件都是可能导致应用程序延迟的I/O操作。然而，I/O调用并不总是导致缓慢问题的原因。即使如此，除非你完全熟悉代码库（这种情况很少发生），否则没有一些帮助，仍然很难找到问题来源。
- en: Fortunately, the profiler is quite “magical” and has the ability to intercept
    code in execution and calculate the resources each piece of code consumes. We’ll
    discuss these abilities in chapter 7.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，性能分析器非常“神奇”，并且具有拦截执行代码和计算每段代码消耗的资源的能力。我们将在第7章中讨论这些能力。
- en: 6.2 Using a profiler
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使用性能分析器
- en: In this section, we examine how to use a profiler to solve problems such as
    those discussed in section 6.1\. We begin (in section 6.2.1) with installing and
    configuring VisualVM. We’ll then examine a profiler’s investigative capabilities.
    I use an app to demonstrate each topic; the app is small enough to allow you to
    focus on the presented subject but complex enough to be relevant to our discussion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨如何使用性能分析器来解决第6.1节中讨论的问题。我们从安装和配置VisualVM（在第6.2.1节中）开始。然后，我们将检查性能分析器的调查能力。我使用一个应用程序来演示每个主题；这个应用程序足够小，可以让你专注于展示的主题，但同时也足够复杂，与我们的讨论相关。
- en: In section 6.2.2, we will discuss system resource consumption and how to identify
    whether your app has any issues related to overconsumption. In section 6.2.3,
    you’ll learn what kind of memory issues an app may encounter and how to spot them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6.2.2节中，我们将讨论系统资源消耗以及如何确定你的应用程序是否存在与过度消耗相关的问题。在第6.2.3节中，你将了解应用程序可能遇到哪些内存问题以及如何发现它们。
- en: 6.2.1 Installing and configuring VisualVM
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 安装和配置 VisualVM
- en: In this section, you’ll learn how to install and configure VisualVM. Before
    you use a profiler, you need to make sure you correctly install and configure
    this, or a similar, tool. Then, you can use the examples provided with the book
    to try out each of the capabilities we discuss in this chapter. If you work on
    a real-world project, I recommend using the techniques with the app you are implementing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何安装和配置 VisualVM。在使用分析器之前，你需要确保正确安装和配置此工具或类似工具。然后，你可以使用本书提供的示例来尝试本章中讨论的每个功能。如果你在现实世界的项目中工作，我建议使用你正在实施的应用程序中的技术。
- en: 'Installing VisualVM is straightforward. Once you download the version according
    to your operating system from the official site ([https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)),
    the only thing you need to do is make sure you correctly configure the location
    of the JDK you want VisualVM to use. In the configuration file, which you can
    find at the etc/visualvm.config location in the VisualVM folder, define the location
    of the JDK in your system. You need to assign the JDK path to the `visualvm_jdkhome`
    variable and uncomment the line (remove the # in front of it), as presented in
    the next snippet. VisualVM works with Java 8 or above:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '安装 VisualVM 很简单。一旦你从官方网站（[https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)）下载了适用于你的操作系统的版本，你需要做的唯一一件事是确保你正确配置了
    VisualVM 要使用的 JDK 位置。在 VisualVM 文件夹中的 etc/visualvm.config 配置文件中，定义你的系统中的 JDK 位置。你需要将
    JDK 路径分配给 `visualvm_jdkhome` 变量，并取消注释该行（移除其前面的 #），如下面的代码片段所示。VisualVM 与 Java 8
    或更高版本兼容：'
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you configure the JDK location, you can run VisualVM using the executable
    code in the bin folder where you installed the app. If you correctly configured
    the JDK location, the app will start, and you’ll see an interface similar to the
    one presented in figure 6.1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 JDK 位置，你就可以使用安装应用程序的 bin 文件夹中的可执行代码来运行 VisualVM。如果你正确配置了 JDK 位置，应用程序将启动，你将看到一个类似于图6.1所示的界面。
- en: '![](../../OEBPS/Images/CH06_F01_Spilca3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Spilca3.png)'
- en: Figure 6.1 VisualVM welcome screen. Once you configure and start VisualVM, you
    find that the tool has a simple and easy-to-learn GUI. On the left of the welcome
    screen are the processes running locally that you can investigate with the tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 VisualVM 欢迎屏幕。一旦你配置并启动 VisualVM，你会发现这个工具具有简单且易于学习的图形用户界面。在欢迎屏幕的左侧是本地运行的可调查进程。
- en: Let’s start a Java app. You can use the project da-ch6-ex1 provided with this
    book. Either use the IDE to start the app or start the app from the console directly.
    Profiling a Java process is not affected by the way the app is started.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个 Java 应用程序。你可以使用本书提供的项目 da-ch6-ex1。你可以使用 IDE 启动应用程序，或者直接从控制台启动应用程序。分析
    Java 进程不受应用程序启动方式的影响。
- en: Once you start the app, VisualVM displays the process on the left side. Usually,
    if you didn’t explicitly give a particular name to the process, VisualVM uses
    the main class name, as presented in figure 6.2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动应用程序，VisualVM 在左侧显示进程。通常，如果你没有明确为进程指定特定名称，VisualVM 将使用主类名，如图6.2所示。
- en: '![](../../OEBPS/Images/CH06_F02_Spilca3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F02_Spilca3.png)'
- en: Figure 6.2 Double-click a process name to start using VisualVM to investigate
    that process, and a new tab will appear. In this tab are all the needed capabilities
    VisualVM provides for exploring that particular process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 双击进程名称以使用 VisualVM 调查该进程，并将出现一个新标签页。在这个标签页中，VisualVM 为探索该特定进程提供了所有需要的功能。
- en: 'Generally, starting the app should be enough. However, in some cases, VisualVM
    doesn’t know how to connect to a local process because of various issues, as presented
    in figure 6.3\. In such a case, the first thing to try is explicitly specifying
    the domain name using a VM argument when starting the application you want to
    profile:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，启动应用程序应该足够了。然而，在某些情况下，由于各种问题，VisualVM 无法连接到本地进程，如图6.3所示。在这种情况下，首先尝试的是在启动要分析的应用程序时，使用
    VM 参数显式指定域名：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../../OEBPS/Images/CH06_F03_Spilca3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F03_Spilca3.png)'
- en: Figure 6.3 If the tool doesn’t seem to be working properly, you need to check
    the way it is configured. Such problems can occur when the configured JVM distribution
    is not among those VisualVM supports. Sometimes the tool can’t connect to the
    local process you want to investigate for some reason. In such cases, use a different
    JVM distribution that complies with the tool’s requirements or review how the
    process you want to investigate was started.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 如果工具似乎工作不正常，您需要检查其配置方式。当配置的JVM发行版不在VisualVM支持的发行版中时，可能会出现此类问题。有时，由于某些原因，工具可能无法连接到您想要调查的本地进程。在这种情况下，使用符合工具要求的另一个JVM发行版，或审查您想要调查的进程是如何启动的。
- en: 'A similar problem can also be caused by using a JVM version that VisualVM doesn’t
    support. If adding the `-Djava.rmi.server.hostname=localhost` argument doesn’t
    solve your issue, check that the JVM distribution you configured is among those
    VisualVM supports (according to the download section on its website: [https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml)).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的问题也可能是由使用VisualVM不支持的热点版本引起的。如果添加`-Djava.rmi.server.hostname=localhost`参数不能解决您的问题，请检查您配置的JVM发行版是否在VisualVM支持的发行版中（根据其网站上的下载部分：[https://visualvm.github.io/download.xhtml](https://visualvm.github.io/download.xhtml))。
- en: 6.2.2 Observing the CPU and memory usage
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 观察CPU和内存使用情况
- en: One of the simplest things you can do with a profiler is observe how your app
    consumes the system’s resources. This way, you can spot problems such as memory
    leaks or zombie threads in your app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用分析器做的最简单的事情之一是观察您的应用如何消耗系统资源。这样，您可以发现应用中的问题，如内存泄漏或僵尸线程。
- en: DEFINITION A memory leak is when your app doesn’t deallocate unneeded data.
    Over time, there will be no more free memory. This is a problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：内存泄漏是指您的应用没有释放不再需要的数据。随着时间的推移，将没有更多的空闲内存。这是一个问题。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: As you’ll learn in this section, you can use a profiler to visually confirm
    that your app isn’t behaving correctly. For example, *zombie threads* are threads
    that remain in continuous execution, consuming the app’s resources. You can easily
    observe such problems using VisualVM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解到您可以使用分析器来直观地确认您的应用行为不正确。例如，*僵尸线程*是那些持续执行并消耗应用资源的线程。您可以使用VisualVM轻松观察到此类问题。
- en: I prepared some projects to show you how to use a profiler to identify app issues
    that cause abnormal resource consumption. We’ll run the apps provided with the
    book one by one, and we’ll use VisualVM to observe the behavior and identify abnormalities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一些项目来向您展示如何使用分析器来识别导致异常资源消耗的应用问题。我们将逐个运行书中提供的应用，并使用VisualVM来观察行为并识别异常。
- en: 'Let’s start with app da-ch6-ex1\. The idea of the app is simple: two threads
    continuously add values to a list, while two other threads continuously remove
    (consume) the values from this list. We often call this implementation a *producer-consumer
    approach*, a multithreaded design pattern commonly encountered in apps.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用da-ch6-ex1开始。该应用的想法很简单：两个线程持续向列表中添加值，而另外两个线程持续从该列表中移除（消费）值。我们通常称这种实现为*生产者-消费者方法*，这是一种在应用中常见的多线程设计模式。
- en: Listing 6.1 The producer thread adding values to a list
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 生产者线程向列表添加值
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Sets a maximum number of values for the list
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为列表设置最大值数量
- en: ❷ Adds a random value in the list
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在列表中添加一个随机值
- en: The following code shows the implementation of the consumer thread.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了消费者线程的实现。
- en: Listing 6.2 The consumer thread removing values from the list
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 消费者线程从列表中移除值
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Checks whether the list contains any value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查列表中是否包含任何值。
- en: ❷ If the list contains values, removes the first value from the list
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果列表包含值，则从列表中移除第一个值
- en: The `Main` class creates and starts two instances of the producer thread and
    two instances of the consumer thread.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类创建了两个生产者线程实例和两个消费者线程实例。'
- en: Listing 6.3 The `Main` class creating and starting the producer and consumer
    threads
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 `Main`类创建并启动生产者和消费者线程
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Creates a list to store the random values the producer generates
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个列表以存储生产者生成的随机值
- en: ❷ Starts the consumer and produces threads
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动消费者和生产者线程
- en: This application wrongly implements a multithreaded architecture. More precisely,
    multiple threads concurrently access and change a list of type `ArrayList`. Because
    `ArrayList` is not a concurrent collection implementation in Java, it doesn’t
    manage the threads’ access itself. Multiple threads accessing this collection
    potentially enter a *race condition*. A race condition happens when multiple threads
    compete to access the same resource. That is, they are in a race to access the
    same resource.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用错误地实现了一个多线程架构。更确切地说，多个线程并发访问和修改一个类型为`ArrayList`的列表。因为`ArrayList`不是Java中的并发集合实现，它不会自己管理线程的访问。多个线程访问这个集合可能会进入*竞争条件*。当多个线程竞争访问同一资源时，就会发生竞争条件。也就是说，它们在争夺访问同一资源。
- en: In project da-ch6-ex1, the implementation lacks thread synchronization. When
    you run the app, some of the threads stop after a short time because of exceptions
    caused by the race condition, while others remain forever alive, doing nothing
    (zombie threads). We’ll use VisualVM to identify all these problems. Then, we’ll
    run project da-ch6-ex2, which applies a correction to the app that synchronizes
    the threads that access the list. We’ll compare the results displayed by VisualVM
    for the first example to the second example to understand the difference between
    a normal app and a problematic app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目da-ch6-ex1中，实现缺少线程同步。当你运行应用时，由于竞争条件引起的异常，一些线程在短时间内停止，而其他线程则永远保持活跃，什么也不做（僵尸线程）。我们将使用VisualVM来识别所有这些问题。然后，我们将运行项目da-ch6-ex2，它对应用进行了修正，同步了访问列表的线程。我们将比较VisualVM显示的第一个示例和第二个示例的结果，以了解正常应用和有问题的应用之间的差异。
- en: 'The app will run quickly and then stop (potentially showing an exception stack
    trace in the console). The next code snippet shows what the log messages the app
    prints in the console look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将快速运行然后停止（可能在控制台显示异常堆栈跟踪）。下面的代码片段显示了应用在控制台打印的日志消息的样子：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may think that because this app only has three classes, you don’t need a
    profiler to spot the problem—reading the code is enough here. Indeed, with only
    three classes, you may be able to spot the problem without using a separate tool.
    That’s because the apps we use are simplified examples to allow you to focus on
    using the profiler. But in the real world, apps are more complex, and problems
    are much more challenging to spot without an appropriate tool (such as a profiler).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，因为这个应用只有三个类，你不需要使用分析器来找出问题——阅读代码在这里就足够了。确实，只有三个类，你可能不需要使用单独的工具就能找出问题。这是因为我们使用的应用是简化示例，以便你能够专注于使用分析器。但在现实世界中，应用更加复杂，没有适当的工具（如分析器）很难发现这些问题。
- en: 'Even if the app looks like it’s paused, you can see something interesting when
    you use VisualVM to investigate what is happening behind the scenes. To investigate
    this unexpected behavior, follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用看起来像是暂停的，当你使用VisualVM调查幕后发生的事情时，你也能看到一些有趣的东西。为了调查这种意外行为，请按照以下步骤操作：
- en: Check the process CPU usage.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程CPU使用情况。
- en: Check the process memory usage.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程内存使用情况。
- en: Visually investigate the executing threads.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化调查正在执行的线程。
- en: The process is consuming a lot of CPU resources, so, somehow, it seems to still
    be alive. To observe its resource consumption, use the Monitor tab in VisualVM
    after double-clicking the process name in the left panel. One of the widgets you
    find on this tab shows you the CPU usage (figure 6.4).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 进程消耗了大量的CPU资源，所以，某种程度上，它似乎仍然活跃。为了观察其资源消耗，在VisualVM中双击左侧面板中的进程名称后，使用监视器选项卡。在这个选项卡上，你找到的一个小部件显示了CPU使用情况（图6.4）。
- en: '![](../../OEBPS/Images/CH06_F04_Spilca3.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 使用VisualVM观察CPU资源的使用情况](../../OEBPS/Images/CH06_F04_Spilca3.png)'
- en: Figure 6.4 Using VisualVM to observe the use of CPU resources. The widget in
    the Monitor tab shows you how much CPU the process uses and how much of the usage
    is caused by the GC. This information helps you to understand whether the app
    has execution problems and is excellent guidance for the next steps in your investigation.
    In this particular example, the process spends about 50% CPU. The GC doesn’t influence
    this value. These signs are often indicators of zombie threads that are usually
    generated by concurrency problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 使用VisualVM观察CPU资源的使用情况。监视器选项卡上的小部件显示了进程使用了多少CPU以及多少使用是由GC引起的。这些信息有助于你了解应用是否有执行问题，并且是调查下一步的绝佳指导。在这个特定示例中，进程消耗了大约50%的CPU。GC不会影响这个值。这些迹象通常是僵尸线程的指标，这些僵尸线程通常由并发问题生成。
- en: The consumer and producer threads seem to have entered a continuous running
    state where they consume the system’s resources even if they don’t correctly fulfill
    their tasks. In this case, the state is a consequence of race conditions because
    the threads are trying to access and change a nonconcurrent collection. But we
    already know there’s something wrong with the app. We want to observe the symptoms
    such problems cause so that in other similar situations we will know our app encountered
    the same problem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者和生产者线程似乎已经进入了一个持续运行的状态，即使它们没有正确完成它们的工作，也会消耗系统的资源。在这种情况下，这种状态是竞态条件的结果，因为线程正在尝试访问和修改一个非并发集合。但我们已经知道应用程序有问题。我们想要观察这些问题引起的症状，这样在类似的其他情况下，我们就会知道我们的应用程序遇到了相同的问题。
- en: In this widget, you can also find the amount of CPU resources the GC uses. The
    GC is the JVM mechanism that deals with removing the data the app no longer needs
    from memory. The GC CPU usage is valuable information because it can indicate
    that the app has a problem with memory allocation. If the GC spends a lot of CPU
    resources, it can signify that the app has a memory leak issue.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小部件中，您还可以找到GC使用的CPU资源量。GC是JVM机制，用于从内存中删除应用程序不再需要的数据。GC CPU使用情况是宝贵的信息，因为它可以表明应用程序存在内存分配问题。如果GC消耗大量的CPU资源，这可能表明应用程序存在内存泄漏问题。
- en: In this case, the GC doesn’t spend any CPU resources. This is not a good sign
    either. In other words, the app is spending a lot of processing power but isn’t
    processing anything. These signs usually indicate zombie threads, which are generally
    a consequence of concurrency problems.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，GC没有消耗任何CPU资源。这也不是一个好迹象。换句话说，应用程序正在消耗大量的处理能力，但没有进行任何处理。这些迹象通常表明僵尸线程，这通常是并发问题的后果。
- en: The next step is to look at the widget showing memory consumption. This widget
    is strategically placed near the one showing you the CPU consumption, as presented
    in figure 6.5\. We’ll discuss this widget in more detail in section 6.2.3, but
    for the moment, notice that the app spends almost no memory at all. This behavior
    is, again, not a good sign as it is equivalent to saying, “The app does nothing.”
    Using just these two widgets, we can conclude that we are most likely facing a
    concurrency issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是查看显示内存消耗的小部件。这个小部件被巧妙地放置在显示CPU消耗的小部件附近，如图6.5所示。我们将在6.2.3节中更详细地讨论这个小部件，但此时请注意，应用程序几乎不消耗任何内存。这种行为，再次，不是一个好迹象，因为它相当于说，“应用程序什么也没做。”仅使用这两个小部件，我们就可以得出我们很可能面临一个并发问题的结论。
- en: '![](../../OEBPS/Images/CH06_F05_Spilca3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F05_Spilca3.png)'
- en: Figure 6.5 On the right side of the CPU usage widget, you find the memory usage
    widget. In this example, the app uses almost no memory. This is also why the GC
    activity is zero. An app not consuming any memory means the app isn’t doing anything.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPU使用率小部件的右侧，您会发现内存使用率小部件。在这个例子中，应用程序几乎不使用内存。这也是为什么GC活动为零的原因。不消耗任何内存的应用程序意味着应用程序什么也没做。
- en: We’ll discuss using thread dumps in chapter 10\. For now, we’ll focus only on
    the high-level widgets the profile offers, and we’ll compare the results these
    widgets provide for a healthy and an unhealthy app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第10章中讨论使用线程转储。现在，我们将只关注配置文件提供的高级小部件，并将比较这些小部件对健康和不健康应用程序提供的结果的比较。
- en: Before going into a detailed investigation of the threads in execution, I prefer
    to use VisualVM to visually observe how the threads execute. In most cases, doing
    so gives me some clues about which threads I need to pay attention to. Once I
    get this info, I use a thread dump to find the concurrency problem and learn how
    to fix it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入调查执行中的线程之前，我更喜欢使用VisualVM来直观地观察线程是如何执行的。在大多数情况下，这样做会给我一些线索，告诉我需要关注哪些线程。一旦我得到这些信息，我就使用线程转储来查找并发问题，并学习如何修复它。
- en: '![](../../OEBPS/Images/icon_guy3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy3.png)'
- en: Figure 6.6 shows the Threads tab, which you find near the Monitor tab. The Threads
    tab offers a visual representation of the threads in execution and their states.
    In this example, all four threads the app started are executing and in a running
    state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6显示了“线程”选项卡，您可以在“监视器”选项卡附近找到它。线程选项卡提供了执行线程及其状态的视觉表示。在这个例子中，应用程序启动的所有四个线程都在执行状态中。
- en: '![](../../OEBPS/Images/CH06_F06_Spilca3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F06_Spilca3.png)'
- en: Figure 6.6 The Threads tab offers a visual representation of the threads that
    are alive and their status. The widget shows all the process threads, including
    those started by the JVM, which helps you to easily identify which threads you
    should pay attention to and eventually investigate deeper using a thread dump.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 线程选项卡提供了对存活线程及其状态的视觉表示。小部件显示了所有进程线程，包括由JVM启动的线程，这有助于你轻松识别应该注意哪些线程，并最终使用线程转储进行更深入的调查。
- en: 'Concurrency problems can have different results. Not necessarily all the threads
    will remain alive, for example. Sometimes concurrent access can cause exceptions
    that interrupt some or all the threads entirely. The next snippet shows an example
    of such an exception that can occur during an app’s execution:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 并发问题可能产生不同的结果。不一定所有线程都将保持存活，例如。有时并发访问可能导致异常，这会中断某些或所有线程。以下代码片段显示了应用程序执行期间可能发生的此类异常的示例：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If such an exception happens, then some threads may be stopped, and the Threads
    tab won’t display them. Figure 6.7 shows a case in which the app threw an exception
    and only one of the threads stayed alive.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生此类异常，则某些线程可能会停止，并且线程选项卡不会显示它们。图6.7显示了一个应用程序抛出异常，只有一个线程保持存活。
- en: '![](../../OEBPS/Images/CH06_F07_Spilca3.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F07_Spilca3.png)'
- en: Figure 6.7 If exceptions occur during an app’s execution, some of the threads
    may be stopped. This figure shows a case in which the concurrent access caused
    exceptions in three of the threads and stopped them. Only one thread remained
    alive. Remember, concurrency problems in multithreaded apps can cause different
    unexpected results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 如果应用程序执行期间发生异常，一些线程可能会停止。此图显示了一个并发访问导致三个线程发生异常并停止的情况。只有一个线程仍然存活。记住，多线程应用程序中的并发问题可能导致不同的意外结果。
- en: In this example, we focus only on discovering a resource consumption problem.
    The next step is to use a thread dump to figure out the exact cause of the concurrency
    problem. We’ll discuss everything about thread dumps in chapter 7, but for now,
    let’s remain focused on identifying resource consumption issues. We will run the
    same verifications on a healthy app and compare it to our unhealthy one. This
    way, you’ll know how to immediately recognize correct and incorrect app behavior.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们只关注发现资源消耗问题。下一步是使用线程转储来确定并发问题的确切原因。我们将在第7章中讨论有关线程转储的所有内容，但就目前而言，让我们专注于识别资源消耗问题。我们将在一个健康的应用程序上运行相同的验证，并将其与我们的不健康应用程序进行比较。这样，你就会知道如何立即识别正确的和不正确的应用程序行为。
- en: The example in project da-ch6-ex2 is the corrected version of the same app we
    just looked at. I added some synchronized blocks to avoid concurrent access for
    the threads and eliminate the race condition problems. I used the `list` instance
    as the thread monitor for the synchronized code blocks for both consumers and
    producers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 项目da-ch6-ex2中的示例是刚刚查看的相同应用程序的修正版本。我添加了一些同步块以避免线程的并发访问并消除竞争条件问题。我为消费者和生产者同步代码块都使用了`list`实例作为线程监视器。
- en: Listing 6.4 Synchronizing access for the consumer
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 消费者访问同步
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Synchronizes the access on the list, using the list instance as a thread monitor
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用列表实例作为线程监视器来同步对列表的访问
- en: The following code shows the synchronization applied to the `Producer` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了应用于`Producer`类的同步。
- en: Listing 6.5 Synchronizing access for the producer
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 生产者访问同步
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Synchronizes the access on the list, using the list instance as a thread monitor
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用列表实例作为线程监视器来同步对列表的访问
- en: I also gave custom names to each thread. I always recommend this approach. Did
    you spot the default names the JVM gave our threads in the previous example? Generally,
    Thread-0, Thread-1, Thread-2, and so on are not names you can easily use to identify
    a given thread. I prefer giving threads custom names whenever I can so that I
    can identify them quickly. Moreover, I give them names starting with an underline
    so it is easier to sort them. First, I defined the constructor in the `Consumer`
    and `Producer` classes (listings 6.4 and 6.5, respectively) and used the `super()`
    constructor to name the threads. I then gave them names, as presented in listing
    6.6.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我还为每个线程设置了自定义名称。我总是推荐这种方法。你注意到在前一个示例中 JVM 为我们的线程提供的默认名称了吗？通常，Thread-0、Thread-1、Thread-2
    等等并不是你可以轻易用来识别特定线程的名称。我总是尽可能地给线程设置自定义名称，这样我就可以快速地识别它们。此外，我给它们起的名字以下划线开头，这样排序起来更容易。首先，我在
    `Consumer` 和 `Producer` 类（分别见列表 6.4 和 6.5）中定义了构造函数，并使用 `super()` 构造函数来命名线程。然后，我给它们命名，如列表
    6.6 所示。
- en: Listing 6.6 Setting custom names for the threads
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 为线程设置自定义名称
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that after starting this app, the console continuously shows logs. The
    app doesn’t stop like it did with example da-ch6-ex1\. Let’s use VisualVM to observe
    resource consumption. In the CPU utilization widget, you can see that the app
    spends less CPU, while the memory usage widget shows that the app uses some of
    the allocated memory while running. Also, we can observe the activity of the GC.
    As you will learn later in this chapter, on the right side of the memory graph
    are valleys that are a result of the GC’s activity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，启动此应用程序后，控制台会持续显示日志。应用程序不会像示例 da-ch6-ex1 那样停止。让我们使用 VisualVM 来观察资源消耗。在 CPU
    利用率小部件中，你可以看到应用程序消耗的 CPU 较少，而内存使用情况小部件显示应用程序在运行时使用了一些分配的内存。此外，我们还可以观察到 GC 的活动。正如你将在本章后面学到的那样，内存图右侧的谷底是
    GC 活动的结果。
- en: '![](../../OEBPS/Images/CH06_F08_Spilca3.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F08_Spilca3.png)'
- en: Figure 6.8 After correctly synchronizing the code, the resource consumption
    widgets look different. The CPU consumption is lower, and the app uses some memory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 在正确同步代码后，资源消耗小部件看起来不同。CPU 消耗较低，应用程序使用了一些内存。
- en: The Threads tab shows that the monitor sometimes blocks the threads, which only
    allows one thread at a time through a synchronized block. The threads don’t run
    continuously, which makes the app consume less CPU, as shown in figure 6.8\. Figure
    6.9 shows the threads’ visualization in the Threads tab.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 线程选项卡显示监视器有时会阻塞线程，这仅允许一次只有一个线程通过同步块。线程不会连续运行，这使得应用程序消耗的 CPU 较少，如图 6.8 所示。图 6.9
    显示了线程选项卡中的线程可视化。
- en: Note Even if we added synchronized blocks, some code still remains outside of
    these blocks. For this reason, the threads may still appear to run concurrently
    (as shown in figure 6.9).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：即使我们添加了同步块，一些代码仍然位于这些块之外。因此，线程可能仍然看起来是并发运行的（如图 6.9 所示）。
- en: '![](../../OEBPS/Images/CH06_F09_Spilca3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F09_Spilca3.png)'
- en: Figure 6.9 The Threads tab helps you to visualize the execution of the threads
    in your app. Since the threads’ names start with an underline, you can simply
    sort them by name to see them grouped. Notice that their execution is interrupted
    from time to time by the monitor, which allows just one thread at a time through
    the synchronized blocks of code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 线程选项卡帮助你可视化应用程序中线程的执行。由于线程的名称以下划线开头，你可以简单地按名称排序它们以查看它们分组。注意，它们的执行有时会被监视器中断，这允许一次只有一个线程通过同步代码块。
- en: 6.2.3 Identifying memory leaks
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 识别内存泄漏
- en: In this section, we discuss memory leaks and how to determine when your app
    is affected by them. A *memory leak* is when an app stores and keeps references
    to unused objects (figure 6.10). Because of these references, the GC (the mechanism
    responsible for removing unneeded data from the app’s memory) cannot remove these
    objects. As the app continues to add more data, the memory fills up. When the
    app doesn’t have enough space to add the new data, it throws an `OutOfMemoryError`
    and stops. We’ll use a simple app that causes an `OutOfMemoryError` to demonstrate
    how to identify a memory leak using VisualVM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论内存泄漏以及如何确定你的应用程序何时受到影响。*内存泄漏*是指应用程序存储并保留对未使用对象的引用（见图 6.10）。由于这些引用，GC（负责从应用程序内存中删除不需要数据的机制）无法删除这些对象。随着应用程序继续添加更多数据，内存会填满。当应用程序没有足够的空间添加新数据时，它会抛出
    `OutOfMemoryError` 并停止。我们将使用一个简单的应用程序，该应用程序会导致 `OutOfMemoryError`，以演示如何使用 VisualVM
    识别内存泄漏。
- en: '![](../../OEBPS/Images/CH06_F10_Spilca3.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F10_Spilca3.png)'
- en: Figure 6.10 An `OutOfMemoryError` is like a ticking bomb. An app fails to remove
    references to objects it no longer uses. The GC can’t remove these instances from
    the memory because the app keeps their references. While more objects are created,
    the memory gets full. At some point, there’s no more space in the heap to allocate
    other objects, and the app fails with an `OutOfMemoryError`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 `OutOfMemoryError` 像一个定时炸弹。应用程序未能移除它不再使用的对象的引用。由于应用程序保留这些实例的引用，垃圾回收器无法从内存中移除这些实例。随着更多对象的创建，内存会填满。在某个时刻，堆中不再有空间分配其他对象，应用程序会因
    `OutOfMemoryError` 而失败。
- en: In the example provided with project da-ch6-ex3, you can find a simple app that
    stores random instances in a list but never removes their references. The following
    code provides an example of a simple implementation that produces an `OutOfMemoryError`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目 da-ch6-ex3 提供的示例中，你可以找到一个简单的应用程序，它在列表中存储随机实例，但从不移除它们的引用。以下代码提供了一个简单实现的示例，该实现会产生一个
    `OutOfMemoryError`。
- en: Listing 6.7 Producing an `OutOfMemoryError`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 产生 `OutOfMemoryError`
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Continuously adds new instances to a list until the JVM runs out of memory
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 持续向列表中添加新实例，直到 JVM 内存耗尽
- en: 'The class `Cat` is a simple `java` object, as presented by the following code
    snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Cat` 是一个简单的 `java` 对象，如下代码片段所示：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s run this app and observe resource usage with VisualVM. We’re especially
    interested in the widget that shows memory usage. When a memory leak affects your
    app, this widget can confirm that the used memory grows continuously. The GC tries
    to deallocate unused data from memory, but it removes too few. In the end, the
    memory gets filled, the app cannot store the new data, and it throws an `OutOfMemoryError`
    (figure 6.11).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个应用程序，并使用 VisualVM 观察资源使用情况。我们特别感兴趣的是显示内存使用情况的控件。当内存泄漏影响你的应用程序时，这个控件可以确认使用的内存会持续增长。垃圾回收器试图从内存中释放未使用的数据，但它移除的数据太少。最终，内存被填满，应用程序无法存储新数据，并抛出
    `OutOfMemoryError`（图 6.11）。
- en: '![](../../OEBPS/Images/CH06_F11_Spilca3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F11_Spilca3.png)'
- en: Figure 6.11 When a memory leak affects your app, the used memory grows continuously.
    GC attempts to free the memory but cannot remove enough data. The used memory
    increases until the app can’t allocate any more new data. At this point, the app
    throws an `OutOfMemoryError` and stops. In many cases, a memory leak also causes
    intensified GC activity, which can be seen in the CPU resource usage widget.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 当内存泄漏影响你的应用程序时，使用的内存会持续增长。垃圾回收器尝试释放内存，但无法移除足够的数据。使用的内存增加，直到应用程序无法分配更多新数据。此时，应用程序抛出
    `OutOfMemoryError` 并停止。在许多情况下，内存泄漏还会导致垃圾回收活动加剧，这可以在 CPU 资源使用小部件中看到。
- en: 'If you let the app run long enough, you’ll eventually see the error stack trace
    in the app’s console:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让应用程序运行足够长的时间，你最终会在应用程序的控制台中看到错误堆栈跟踪：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s important to remember that an `OutOfMemoryError` stack trace doesn’t necessarily
    indicate the place that causes the problem. Since an app has just one heap memory
    location, a certain thread can cause the problem, whereas another thread may be
    unlucky enough to be the last one trying to use the memory location and thus gets
    the error. The only sure way to identify the root cause is using a heap dump,
    which you’ll learn in chapter 11.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`OutOfMemoryError` 的堆栈跟踪并不一定表明导致问题的位置。由于应用程序只有一个堆内存位置，某个线程可能引起问题，而另一个线程可能不幸成为最后一个尝试使用内存位置的线程，从而引发错误。唯一确定识别根本原因的方法是使用堆转储，你将在第
    11 章中学习。
- en: '![](../../OEBPS/Images/CH06_F12_Spilca3.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F12_Spilca3.png)'
- en: Figure 6.12 A comparison between the memory usage for a healthy app versus an
    app suffering from a memory leak. The GC manages to free unneeded data from memory
    for a healthy app, and the allocated space never fills up. An app suffering from
    a memory leak doesn’t allow the GC to remove enough data. At some point, the memory
    fills up completely, generating an `OutOfMemoryError`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 健康应用程序与受内存泄漏影响的应用程序的内存使用量比较。垃圾回收器能够为健康应用程序从内存中释放不需要的数据，分配的空间永远不会填满。受内存泄漏影响的应用程序不允许垃圾回收器移除足够的数据。在某个时刻，内存完全填满，生成
    `OutOfMemoryError`。
- en: Figure 6.12 compares normal behavior and the behavior of an app affected by
    a memory leak, as seen in VisualVM. For the app with a normal execution (not affected
    by a memory leak), notice that the graph has peaks and valleys. The app allocates
    memory that fills it up (the peaks), and from time to time, the GC removes the
    data that’s no longer needed (the valleys). This ebb and flow is usually a good
    sign that the capability you are investigating is not affected by a memory leak.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12比较了正常行为和受内存泄漏影响的应用程序的行为，如图6.12所示。对于正常执行（未受内存泄漏影响）的应用程序，请注意图表有峰值和谷值。应用程序分配内存使其填满（峰值），并且有时垃圾回收器会移除不再需要的数据（谷值）。这种起伏通常是调查的能力未受内存泄漏影响的良好迹象。
- en: However, if you see that the memory progressively fills and the GC doesn’t clean
    it, your app may have a memory leak. Once you suspect a memory leak, you need
    to investigate further using a heap dump.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你看到内存逐渐填满而垃圾回收器（GC）没有清理它，那么你的应用程序可能存在内存泄漏。一旦你怀疑有内存泄漏，你需要进一步使用堆转储来调查。
- en: You can control the allocated heap size in a Java app. This way, you can enlarge
    the maximum limit the JVM allocates to your app. However, giving the app more
    memory is not a solution for a memory leak. But this approach can be a temporary
    solution to give you more time to solve the root cause of the problem. To set
    a maximum heap size for an app, use the JVM property `-Xmx`, followed by the amount
    you want to allocate (e.g., `-Xmx1G` will allocate a maximum heap size of 1 GB).
    You can similarly set a minimum initial heap size using the `-Xms` property (e.g.,
    `-Xms500m` would allocate a minimum heap size of 500 MB).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制Java应用程序中分配的堆大小。这样，你可以增加JVM为你的应用程序分配的最大限制。然而，给应用程序更多的内存并不是解决内存泄漏的解决方案。但这种方法可以作为一个临时解决方案，给你更多时间来解决问题的根本原因。要为应用程序设置最大堆大小，请使用JVM属性`-Xmx`，后跟你想分配的量（例如，`-Xmx1G`将分配最大堆大小为1
    GB）。你可以使用类似的方法使用`-Xms`属性设置最小初始堆大小（例如，`-Xms500m`将分配最小堆大小为500 MB）。
- en: 'Aside from the normal heap space, any app also uses a *metaspace* : the memory
    location where the JVM stores the class metadata needed for the app’s execution.
    In VisualVM you can observe the allocation of the metaspace in the memory allocation
    widget as well. To evaluate the metadata allocation, use the Metaspace tab of
    the widget, as presented in figure 6.13.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的堆空间外，任何应用程序也会使用一个*元空间*：JVM存储应用程序执行所需类元数据的内存位置。在VisualVM中，你可以在内存分配小部件中观察到元空间的分配。要评估元数据分配，请使用小部件的元空间选项卡，如图6.13所示。
- en: '![](../../OEBPS/Images/CH06_F13_Spilca3.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F13_Spilca3.png)'
- en: Figure 6.13 The metaspace is a part of the memory used to store class metadata.
    In particular cases, the metaspace can be overflowed. A VisualVM memory allocation
    widget also shows the usage of the metaspace.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 元空间是用于存储类元数据的内存的一部分。在特定情况下，元空间可能会溢出。VisualVM内存分配小部件也显示了元空间的用法。
- en: An `OutOfMemoryError` on the metadata space happens less often, but it’s not
    impossible. I recently dealt with such a case in an app that was misusing a framework
    for data persistence. Generally, frameworks and libraries using Java reflection
    are the most likely to generate such problems if misused since they often rely
    on dynamic proxies and indirect calls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据空间中的`OutOfMemoryError`发生得较少，但并非不可能。我最近处理了一个应用程序的此类案例，该应用程序误用了数据持久性的框架。通常，如果误用，使用Java反射的框架和库最有可能生成此类问题，因为它们通常依赖于动态代理和间接调用。
- en: In my situation, the app was misusing a framework named Hibernate. I would not
    be surprised if you have already heard about Hibernate since it’s one of the most
    common solutions to manage persistent data in Java apps today. Hibernate is an
    excellent tool that helps to implement the most-used persistence capabilities
    of an app while eliminating the need to write unneeded code. Hibernate manages
    a context of instances and maps the changes to this context to the database. But
    it’s not recommended for a very large context. In other words, don’t work with
    too many records from the database at once!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，应用程序误用了名为Hibernate的框架。如果你已经听说过Hibernate，那也不会让我感到惊讶，因为它是目前管理Java应用程序中持久数据最常用的解决方案之一。Hibernate是一个优秀的工具，它有助于实现应用程序最常用的持久化功能，同时消除了编写不必要的代码的需要。Hibernate管理实例的上下文并将对上下文的更改映射到数据库。但是，它不推荐用于非常大的上下文。换句话说，不要一次性处理来自数据库的太多记录！
- en: The app I had trouble with defined a scheduled process, loading many records
    from a database and processing them in a defined way. It seems that, at some point,
    the number of records this process was fetching was so large that the load operation
    itself caused the metaspace to fill; the problem was a misuse of the framework,
    not a bug in the framework. The developers should not have used Hibernate and
    instead used an alternate, more low-level solution like JDBC.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到问题的应用程序定义了一个计划中的进程，从数据库中加载许多记录并以定义的方式处理它们。似乎在某个时刻，此进程获取的记录数量如此之大，以至于加载操作本身导致了元空间的填充；问题在于框架的误用，而不是框架的bug。开发者不应该使用Hibernate，而应该使用替代的、更底层的解决方案，如JDBC。
- en: The problem was critical, and I had to find a short-term solution since a complete
    refactoring would have taken a long time. Just as for the heap, you can customize
    the metaspace size. Using the `-XX:MaxMetaspaceSize` property, you can enlarge
    the metaspace (e.g., `-XX:MaxMetaspaceSize=100M`), but remember that this is not
    a real solution to the problem. The long-term solution for such a case is to refactor
    the functionality to avoid loading so many records at once in the memory and eventually
    use an alternate persistence technology if needed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 问题非常关键，我必须找到短期解决方案，因为完全重构将花费很长时间。就像堆一样，你可以自定义元空间的大小。使用`-XX:MaxMetaspaceSize`属性，你可以扩大元空间（例如，`-XX:MaxMetaspaceSize=100M`），但请记住，这并不是解决问题的真正方法。此类情况的长期解决方案是重构功能，以避免一次性在内存中加载大量记录，并在必要时最终使用替代的持久化技术。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A profiler is a tool that allows you to observe an app’s execution to identify
    the causes of certain problems that are more difficult to spot otherwise. A profiler
    shows you
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器是一个工具，它允许你观察应用程序的执行，以识别其他情况下更难发现的问题的原因。分析器会显示给你
- en: How an app spends system resources such as the CPU and memory
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序如何消耗系统资源，如CPU和内存
- en: What code executes and the duration of each method execution
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的代码以及每个方法执行的持续时间
- en: The execution stack of methods on different threads
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同线程上方法执行的调用栈
- en: The executing threads and their status
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程及其状态
- en: The profiler provides excellent visual widgets that help you to more quickly
    understand certain aspects.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器提供了优秀的可视化控件，帮助你更快地理解某些方面。
- en: You can observe the GC’s execution using the profiler, which helps you to identify
    issues such as the app not correctly deallocating unused data from memory (memory
    leaks).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用分析器观察GC的执行，这有助于你识别应用程序未正确从内存中释放未使用数据（内存泄漏）等问题。
