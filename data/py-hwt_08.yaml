- en: 6 Defining user-friendly functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 定义用户友好函数
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Setting proper default arguments for a function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数设置适当的默认参数
- en: Setting and using the return value for a function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用函数的返回值
- en: Applying type hints to the parameters and the return value
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型提示应用于参数和返回值
- en: Defining functions with a variable number of positional and keyword arguments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义具有可变数量位置参数和关键字参数的函数
- en: Creating proper docstrings for a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数创建适当的文档字符串
- en: In previous chapters, you’ve seen several examples of functions. Broadly speaking,
    no matter what our applications are about, we define a wide range of functions
    to perform various operations, such as making calculations and formatting strings.
    When you work in a team environment, you often need to define functions that allow
    your team members to reuse your code. When you publish a Python package, the package
    should include well-defined functions for users like the built-in functions provided
    by the standard Python library. Thus, it’s an essential skill to define user-friendly
    functions; even if you work on your own, you don’t want functions to be hard to
    use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经看到了几个函数的例子。总的来说，无论我们的应用是什么，我们都会定义一系列函数来执行各种操作，例如进行计算和格式化字符串。当你在一个团队环境中工作时，你经常需要定义允许团队成员重用你代码的函数。当你发布一个Python包时，该包应包括为用户定义的良好函数，就像标准Python库提供的内置函数一样。因此，定义用户友好函数是一项基本技能；即使你独自工作，你也不想函数难以使用。
- en: When I say *user-friendly functions,* I mean functions that are easy to understand,
    with proper type hints for the arguments, and that are convenient to call, possibly
    using default arguments. For functions that are self-explanatory, users can locate
    the needed help information, usually in the form of docstrings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说*用户友好函数*时，我指的是易于理解、具有适当的参数类型提示且便于调用的函数，可能使用默认参数。对于那些自解释的函数，用户可以找到所需的帮助信息，通常以文档字符串的形式提供。
- en: In this chapter, you’ll learn the key techniques underlying user-friendly functions.
    When we build our own task management app in chapter 14, you’ll see the usage
    of all these techniques, highlighting the importance of functions in any project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习构建用户友好函数背后的关键技术。当我们第14章构建自己的任务管理应用时，你会看到所有这些技术的应用，突出函数在任何一个项目中的重要性。
- en: 6.1 How do I set default arguments to make function calls easier?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 如何设置默认参数以简化函数调用？
- en: Depending on the specific requirements, functions may take zero to multiple
    arguments. For functions, it’s easier to call those with fewer arguments; ideally,
    a function is easiest to call if it doesn’t require any arguments. When a function
    has multiple arguments, we can reduce the number of arguments needed for function
    calls by setting default arguments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体要求，函数可以接受零个或多个参数。对于函数来说，调用参数较少的函数更容易；理想情况下，一个函数如果不需要任何参数，调用起来最简单。当一个函数有多个参数时，我们可以通过设置默认参数来减少函数调用所需的参数数量。
- en: The biggest advantage of setting default arguments in a function is *convenience.*
    We don’t need to set parameters when the default arguments are exactly what we
    need. Moreover, the function needs *flexibility* so we can still override the
    default values by setting the applicable arguments. In this section, you’ll learn
    about setting default arguments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中设置默认参数的最大优势是*便利性*。当默认参数正好是我们需要的时，我们不需要设置参数。此外，函数需要*灵活性*，这样我们仍然可以通过设置适用的参数来覆盖默认值。在本节中，你将学习如何设置默认参数。
- en: 6.1.1 Calling functions with default arguments
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 使用默认参数调用函数
- en: Setting default arguments in functions is a common technique for making function
    calls easier and is prevalent in the standard Python library. In this section,
    let’s take a quick look at some use cases to gain firsthand experience with the
    convenience of calling functions with default arguments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中设置默认参数是一种常见的简化函数调用的技术，在标准Python库中很普遍。在本节中，让我们快速看一下一些用例，以获得使用默认参数调用函数的便利性的第一手经验。
- en: 'Although we didn’t explicitly discuss default arguments in previous chapters,
    we have taken advantage of this feature several times. Section 3.2, for example,
    discusses how to use the sort method on list objects, as in the following code
    snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在前几章中我们没有明确讨论默认参数，但我们已经多次利用了这一特性。例如，在第3.2节中，我们讨论了如何在列表对象上使用排序方法，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we want to sort the numbers list in descending order, we call the sort
    method by setting the reverse parameter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要按降序对数字列表进行排序时，我们通过设置 reverse 参数来调用 sort 方法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s examine the head of the sort method: sort(*, key=None, reverse=False).
    You’ll notice that the parameters key and reverse have default values: None and
    False. The default values for these parameters are often known as *default arguments.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 sort 方法的头部：sort(*, key=None, reverse=False)。你会注意到参数 key 和 reverse 有默认值：None
    和 False。这些参数的默认值通常被称为 *默认参数*。
- en: Trivia The asterisk in the sort method dictates that all the arguments following
    the asterisk should be set with their parameter names, such as numbers .sort(reverse=True).
    By contrast, numbers.sort(True) is an invalid call. This technique is known as
    *setting keyword-only arguments**.* See section 6.4.1 for more about it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 事实趣闻：sort 方法中的星号指示所有跟在星号后面的参数都应该使用它们的参数名来设置，例如 numbers.sort(reverse=True)。相比之下，numbers.sort(True)
    是一个无效的调用。这种技术被称为 *设置关键字参数**。有关更多信息，请参阅第 6.4.1 节。
- en: When Python’s core developers defined the sort method, they knew that when we
    sort a list object, in most cases we use the lexicographic or numeric order, and
    we want the items in ascending order so that they supply None and False as the
    default arguments to the key and reverse parameters. When we use sort on a list
    object, we typically use the_list.sort(), which is interpreted as the_list.sort(key=None,
    reverse=False) because of the default arguments that are set in the function definition.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 的核心开发者定义 sort 方法时，他们知道当我们对一个列表对象进行排序时，在大多数情况下我们使用字典序或数值序，并且我们希望项目按升序排列，因此他们为
    key 和 reverse 参数提供了 None 和 False 作为默认参数。当我们对一个列表对象使用 sort 时，我们通常使用 the_list.sort()，这被解释为
    the_list.sort(key=None, reverse=False)，因为函数定义中设置了默认参数。
- en: 6.1.2 Defining functions with default arguments
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 定义具有默认参数的函数
- en: Functions with default arguments are not only easy to call, but also flexible,
    supporting multiple use scenarios. In this section, you’ll study the general process
    of defining functions with default arguments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 具有默认参数的函数不仅易于调用，而且灵活，支持多种使用场景。在本节中，你将学习定义具有默认参数的函数的一般过程。
- en: 'When we initially define a function, it usually serves one specific purpose
    by taking one or multiple arguments. Suppose that in our task management app,
    we update the task’s status when the user completes a task. We can have the following
    function: complete_task. Note that this function should have been defined as an
    instance method (section 8.2). Here, I’m defining it outside the Task class for
    the purpose of calling it conveniently:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初定义一个函数时，它通常通过接受一个或多个参数来执行一个特定的目的。假设在我们的任务管理应用程序中，当用户完成任务时，我们更新任务的状态。我们可以有一个以下函数：complete_task。请注意，这个函数应该被定义为实例方法（第
    8.2 节）。在这里，我将其定义在 Task 类外部，以便于方便地调用它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines a custom class
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个自定义类
- en: Peek We use a custom class instead of a named tuple-based data model here. A
    custom class gives us the flexibility of changing the instance object’s attributes,
    which we can’t do with a named tuple model (section 3.3). Defining custom classes
    is covered in chapter 8.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 窥视：在这里，我们使用自定义类而不是基于命名元组的模型。自定义类使我们能够改变实例对象的属性，这是我们不能使用命名元组模型（第 3.3 节）做到的。定义自定义类的内容在第
    8 章中介绍。
- en: 'When the user completes the task, we update its status to “completed,” which
    is one thing the function does. Later, we realize that we may want the user to
    add a completion note for the task—that is, we need to expand the function’s functionality.
    With this added functionality, our function has evolved to the following version:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成任务后，我们将其状态更新为“已完成”，这是该函数执行的一项操作。后来，我们意识到我们可能希望用户为任务添加一个完成备注——也就是说，我们需要扩展函数的功能。有了这个新增的功能，我们的函数已经演变为以下版本：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After updating this function, we’re happy about our decision, but we recognize
    two problems. First, we need to update our old code where we call complete_task(task),
    as it’s missing an argument. Second, in most other places, we need to update the
    status without worrying about setting any note, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更新此函数后，我们对我们的决定感到满意，但我们认识到两个问题。首先，我们需要更新我们调用 complete_task(task) 的旧代码，因为它缺少一个参数。其次，在大多数其他地方，我们需要更新状态，而不必担心设置任何备注，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we’re using the function in a pattern that sends an empty string
    as the note, which may remind you of the DRY (Don’t Repeat Yourself) principle:
    when you repeat something, chances are that you should refactor your code. In
    this case, we mostly set the note to be an empty string, which is a perfect usage
    for setting default arguments in function definitions, handling automatic argument
    setting for most use cases:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用一个模式来使用函数，将空字符串作为笔记，这可能会让你想起DRY（不要重复自己）原则：当你重复某事时，很可能你应该重构你的代码。在这种情况下，我们主要设置笔记为空字符串，这是在函数定义中设置默认参数的完美用法，处理大多数用例的自动参数设置：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the updated function, when we don’t need to set the note, we can simply
    run
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新后的功能，当我们不需要设置笔记时，我们可以简单地运行
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Besides the convenience of omitting an argument, the most important thing is
    that updating the function doesn’t break any old code that calls the same function
    with only the task argument. Because of the default argument in the updated function
    definition, this function call in your old code complete_task(task) is automatically
    interpreted as complete_task(task, "").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了省略参数的便利性之外，最重要的是更新函数不会破坏使用相同任务参数调用相同函数的旧代码。由于更新后的函数定义中的默认参数，你旧代码中的这个函数调用 complete_task(task)
    会自动解释为 complete_task(task, "")。
- en: Maintainability When you update your functions, it’s best to keep the same calling
    signature so that existing code will still work without any update.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 当你更新你的函数时，最好保持相同的调用签名，这样现有的代码仍然可以在没有任何更新的情况下工作。
- en: 'To provide a systematic overview, figure 6.1 shows the general process of evolving
    a function with a single functionality to one with multiple functionalities by
    using default arguments. In the figure, we define two roles: application programming
    interface (API) developer, who defines the function, and API consumer, who uses
    the function in building the application. Certainly, depending on the size of
    a team, these roles can be handled by different people. On smaller projects, however,
    it’s likely that the same person will play both roles.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个系统性的概述，图6.1展示了通过使用默认参数将具有单一功能的函数演变到具有多个功能的函数的一般过程。在图中，我们定义了两个角色：应用程序编程接口（API）开发者，定义函数的人，以及API消费者，使用该函数构建应用程序的人。当然，根据团队的大小，这些角色可以由不同的人处理。然而，在较小的项目中，同一个人很可能同时扮演这两个角色。
- en: '![CH06_F01_Cui](../Images/CH06_F01_Cui.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Cui](../Images/CH06_F01_Cui.png)'
- en: Figure 6.1 An example of the general process of creating a function with default
    arguments. When API developers receive feedback from the consumers, they add the
    needed parameter so that consumers can set the note. Later, consumers realize
    that it’s tedious to set an empty string to the note and ask the developer to
    change the API. The developer uses the default-arguments feature to update the
    API, eliminating the need to set the note parameter when the empty string is the
    desired argument.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 创建具有默认参数的函数的一般过程示例。当API开发者从消费者那里收到反馈时，他们会添加所需的参数，以便消费者可以设置笔记。后来，消费者意识到将空字符串设置为笔记很繁琐，并要求开发者更改API。开发者使用默认参数功能更新API，消除了在空字符串是期望的参数时设置笔记参数的需要。
- en: 'From the consumer’s perspective, calling a function with default arguments
    allows them to omit setting the arguments, which automatically default to the
    preset values. From the developer’s perspective, when you simplify the calling
    of the defined function, consumers are less likely to make mistakes because of
    the reduced number of parameters. Thus, you’re improving consumers’ experience
    in two aspects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从消费者的角度来看，使用默认参数调用函数允许他们省略设置参数，这些参数将自动默认为预设值。从开发者的角度来看，当你简化定义函数的调用时，由于参数数量的减少，消费者犯错的几率更小。因此，你在两个方面提高了消费者的体验：
- en: '*You’re providing an additional feature to the existing function.* The function
    is more flexible with multiple functionalities.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你正在为现有函数提供额外的功能。* 函数具有更多的灵活性，具有多个功能。'
- en: '*You''re making sure that the existing code that uses the old calling signature
    still works.* The missing argument will be interpreted with the default value.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你正在确保使用旧调用签名的现有代码仍然有效。* 缺少的参数将使用默认值进行解释。'
- en: 6.1.3 Avoiding the pitfall of setting default arguments for mutable parameters
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 避免为可变参数设置默认参数的陷阱
- en: In section 6.1.2, you learned the rationale for setting default arguments and
    the evolving process of a function that uses default arguments. Our examples involved
    setting a default argument of the str type. As discussed in chapter 3, strings
    are immutable. Another category of data models is the mutable ones, such as lists
    and dictionaries. In this section, you’ll learn about setting the correct default
    arguments for mutable parameters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.1.2节中，你学习了设置默认参数的理由以及使用默认参数的函数的演变过程。我们的例子涉及设置字符串类型的默认参数。如第3章所述，字符串是不可变的。另一类数据模型是可变的，如列表和字典。在本节中，你将学习为可变参数设置正确的默认参数。
- en: 'What''s the correct term: Arguments or parameters?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的术语是：参数还是参数？
- en: The terms *arguments* and *parameters* appear to be used interchangeably to
    refer to the variables used in a function. A minor nuance exists, however. When
    we define functions, we refer to the variables specified in the function head
    as *parameters*. When we call functions, we refer to the variables we use as *arguments*.
    In other words, parameters are the variables used in a function’s definition.
    By contrast, arguments are the variables used in a function’s invocation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*参数*和*参数*似乎可以互换使用，以指代函数中使用的变量。然而，这里存在一个细微的区别。当我们定义函数时，我们将函数头部中指定的变量称为*参数*。当我们调用函数时，我们将使用的变量称为*参数*。换句话说，参数是函数定义中使用的变量。相比之下，参数是函数调用中使用的变量。
- en: 'Suppose that when we complete a task, we can optionally add the task to a group
    of tasks that we track. We may have the following working version to start with:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当我们完成任务时，我们可以选择性地将任务添加到我们跟踪的任务组中。我们可能有一个以下的工作版本作为起点：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Use the titles only for simplicity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅使用标题以简化。
- en: We set an empty list object to the grouped_tasks parameter as the default argument.
    Our intention is that if we call this function by omitting the grouped_tasks argument,
    an empty list object will be created. You can observe the result in the next listing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个空列表对象设置为grouped_tasks参数的默认参数。我们的意图是，如果我们通过省略grouped_tasks参数来调用此函数，将创建一个空列表对象。你可以在下一个列表中观察到结果。
- en: Listing 6.1 Using functions with mutable default arguments
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 使用具有可变默认参数的函数
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As shown in listing 6.1, for each invocation of the complete_task function
    with the omission of grouped_tasks, we wanted to have a new list object that holds
    the completed task. Quite surprisingly, however, both list objects have the same
    items, although we were expecting work_tasks and play_tasks to be [''Homework'']
    and [''Fishing''], respectively. If you take a closer look at these two list objects,
    you’ll find that they’re the same object:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表6.1所示，对于每个调用complete_task函数且省略grouped_tasks的情况，我们希望有一个新的列表对象来保存完成的任务。然而，令人惊讶的是，这两个列表对象具有相同的项，尽管我们预计work_tasks和play_tasks分别应该是['Homework']和['Fishing']。如果你仔细观察这两个列表对象，你会发现它们是同一个对象：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ is compares whether two variables refer to the same object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ is比较两个变量是否引用同一个对象。
- en: 'The underlying reason for this phenomenon is that Python evaluates the function
    when it’s defined. The evaluation has a side effect: any mutable default arguments
    are created during evaluation and become part of the function. In our example,
    a list object is created when the function is evaluated. Now that specific list
    object is used as the grouped_tasks argument whenever the function is called without
    a grouped_ tasks argument being provided, as the code in the next listing shows.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象的潜在原因是Python在定义函数时对其进行评估。评估有一个副作用：任何可变默认参数都是在评估期间创建的，并成为函数的一部分。在我们的例子中，当函数被评估时创建了一个列表对象。现在，这个特定的列表对象在每次调用函数且未提供grouped_tasks参数时用作grouped_tasks参数，如下一个列表中的代码所示。
- en: Listing 6.2 Using the same mutable object defined in the function
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 使用函数中定义的相同可变对象
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ An id function returns the memory address, which uniquely identifies an object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个id函数返回内存地址，该地址唯一地标识一个对象。
- en: ❷ __defaults__ retrieves the default objects associated with the function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ __defaults__检索与函数关联的默认对象。
- en: In listing 6.2, we use the built-in id function to check an object’s memory
    address. When we work with the same object, the id function returns the same memory
    address. As you can see, when we call the function without specifying the tasks
    argument, we’re getting the same object that is created from the function definition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表6.2中，我们使用内置的id函数来检查对象的内存地址。当我们处理相同的对象时，id函数返回相同的内存地址。正如你所见，当我们调用函数而不指定tasks参数时，我们得到的是从函数定义中创建的相同对象。
- en: CPython and the id function
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CPython和id函数
- en: When you write Python code, the code gets executed on your computer (the machine).
    Notably, the Python code itself doesn’t talk to your machine directly. Instead,
    the code must be compiled into bytecode before it can be executed. There are different
    implementations for compiling Python code. Among them, the most prevalent is CPython,
    which is the original Python implementation and the one you can download from
    Python’s official website. Other implementations such as Jython compile Python
    code to Java bytecode.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写Python代码时，代码会在你的电脑（机器）上执行。值得注意的是，Python代码本身并不直接与你的机器通信。相反，代码必须在执行之前被编译成字节码。Python代码的编译有不同的实现方式。其中，最普遍的是CPython，它是Python的原始实现，也是你可以从Python官方网站下载的实现。其他实现，如Jython，将Python代码编译成Java字节码。
- en: In CPython, the id function returns the memory address of the object at that
    moment. Thus, if you run the id function in the same code at different times or
    on different machines, you should expect the memory addresses to be different.
    In a related note, other Python implementations may use different identities for
    the id function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPython中，id函数返回对象在该时刻的内存地址。因此，如果你在不同的代码中或在不同的机器上运行id函数，你应该预期内存地址会有所不同。相关地，其他Python实现可能为id函数使用不同的标识符。
- en: If we can’t use [] or list() as the default value for a list parameter, what
    can we use? Does this mean that we can’t set a default value for a mutable parameter?
    The answer is no. The common practice is to use None as the default argument for
    mutable parameters. The next listing shows the desired pattern.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能将[]或list()用作列表参数的默认值，我们可以使用什么？这难道意味着我们不能为可变参数设置默认值吗？答案是否定的。常见的做法是将None用作可变参数的默认参数。下一个列表显示了期望的模式。
- en: Listing 6.3 Using None as the default value for mutable parameters
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 使用None作为可变参数的默认值
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ When we compare an object with None, use is instead of ==.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当我们比较一个对象与None时，使用is而不是==。
- en: As you can see, the default argument for the function is None. In the function
    body, we check whether the grouped_tasks argument is None, and when it is true,
    we create a new list object. Every time we call this function with the omission
    of the grouped_ tasks arguments, the function creates a new list object for us,
    which is the desired behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该函数的默认参数是None。在函数体中，我们检查grouped_tasks参数是否为None，如果是，则创建一个新的列表对象。每次我们调用此函数而省略grouped_tasks参数时，该函数都会为我们创建一个新的列表对象，这正是我们期望的行为。
- en: Maintainability When you set a default argument for a mutable parameter in a
    function, set it to None.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 当你在函数中为可变参数设置默认值时，将其设置为None。
- en: 6.1.4 Discussion
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 讨论
- en: Setting default arguments in function definitions is a widely used pattern in
    Python’s standard library. Besides the sort method, many built-in functions, such
    as sorted and print, include default arguments. With default arguments, these
    functions are easy to call; they also maintain flexibility if we set different
    arguments. You should be mindful of the difference between mutable and immutable
    parameters. When you set a wrong default argument for a mutable parameter, you
    can introduce bugs into your codebase.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中设置默认参数是Python标准库中广泛使用的一种模式。除了sort方法外，许多内置函数，如sorted和print，也包括默认参数。有了默认参数，这些函数很容易调用；如果我们设置不同的参数，它们也保持了灵活性。你应该注意可变参数和不可变参数之间的区别。当你为可变参数设置错误的默认值时，你可能会在你的代码库中引入错误。
- en: 6.1.5 Challenge
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 挑战
- en: Cory teaches Python coding in college. He wants to show his students that the
    default arguments are evaluated when a function is defined, not when the function
    is called. Can you help him think of another approach to support this claim?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 科里在大学里教授Python编程。他希望向他的学生展示默认参数是在函数定义时而不是在函数调用时被评估的。你能帮他想到另一种支持这一论点的办法吗？
- en: 'Hint Create a timestamp to check what happens during function definition and
    calls. The following code allows you to retrieve a timestamp:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 创建一个时间戳来检查函数定义和调用期间发生了什么。以下代码允许你检索时间戳：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 6.2 How do I set and use the return value in function calls?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 如何在函数调用中设置和使用返回值？
- en: We define functions to perform specific operations. To use these functions,
    we call them by sending the applicable arguments, which are a function’s input.
    When the function completes its operation, it returns a value, which is a function’s
    output. By now, you should know the importance of functions in your applications;
    thus, it’s critical to have not only the skills to deal with the input (such as
    setting a default argument, covered in section 6.1), but also the skills to deal
    with the output. In this section, we’ll focus on studying how to set the return
    value and how to use it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义函数来执行特定的操作。要使用这些函数，我们需要通过传递适当的参数来调用它们，这些参数是函数的输入。当函数完成其操作后，它返回一个值，这是函数的输出。到目前为止，你应该知道函数在你应用程序中的重要性；因此，不仅需要处理输入的技能（如设置默认参数，在
    6.1 节中介绍），还需要处理输出的技能。在本节中，我们将专注于研究如何设置返回值以及如何使用它。
- en: 6.2.1 Returning a value implicitly or explicitly
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 隐式或显式地返回值
- en: We have used many built-in and custom functions in our examples. Some functions
    return a value; others don’t appear to return a value. In this section, I show
    that every Python function returns a value, although sometimes implicitly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了许多内置和自定义函数。有些函数返回一个值；而有些函数看起来没有返回值。在本节中，我将展示每个 Python 函数都返回一个值，尽管有时是隐式的。
- en: 'The built-in sum function calculates the summation value of an iterable. Not
    surprisingly, the returned value is the sum of the items of the iterable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 sum 函数计算可迭代对象的求和值。不出所料，返回值是可迭代对象中项的总和：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In section 3.2, we learned about using sort to order the items of a list object.
    Notably, the sort method sorts a list object in place, which means that sort changes
    the original list object. Relatedly, if you check sort’s return value, you’ll
    find that it is None:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 3.2 节中，我们学习了如何使用 sort 方法对列表对象中的项进行排序。值得注意的是，sort 方法是在原地排序列表对象，这意味着 sort 会改变原始列表对象。相关地，如果你检查
    sort 的返回值，你会发现它是 None：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Through these two examples, we should be aware that every function returns
    a value, and we should be clear about what a function returns: None or something
    else. Don’t assume what a function returns because you can make silly mistakes
    when you try to chain method calls. The following problematic code is trying to
    sort the primes list and append 13 to the end:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个例子，我们应该意识到每个函数都返回一个值，并且我们应该清楚函数返回了什么：None 还是其他值。不要假设函数返回了什么，因为当你尝试链式调用方法时，你可能会犯愚蠢的错误。以下有问题的代码试图对
    primes 列表进行排序，并将 13 添加到末尾：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Question Do you know why this code won’t run? Check what sort returns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 你知道为什么这段代码无法运行吗？检查 sort 返回什么。
- en: 6.2.2 Defining functions returning zero, one, or multiple values
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 定义返回零个、一个或多个值的函数
- en: 'The best way to understand how functions return values is to define functions
    so that you have granular control of their behavior. In general, there are three
    scenarios in terms of how many values a function returns: zero, one, and multiple.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解函数如何返回值，最好的方法是定义函数，以便你对它们的行为有细粒度的控制。一般来说，根据函数返回值的数量，有三种情况：零个、一个和多个。
- en: Returning zero values
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回零值
- en: 'Strictly speaking, we can’t define functions that return no values. As discussed
    in section 6.2.1, every function has a return value, implicitly or explicitly.
    When we define a function that doesn’t return anything, it is still evaluated
    to return None. Consider the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们不能定义不返回值的函数。正如 6.2.1 节中讨论的，每个函数都有一个返回值，无论是隐式还是显式。当我们定义一个不返回任何内容的函数时，它仍然会被评估为返回
    None。考虑以下示例：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, the function definition doesn’t have a return statement. But
    when we check the return value, the appended_no_return value is None. This result
    is consistent with the discussion in section 6.2.1\. Figure 6.2 shows a general
    pattern for defining a function without returning a variable explicitly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，函数定义中没有返回语句。但当我们检查返回值时，appended_no_return 的值是 None。这个结果与 6.2.1 节中的讨论一致。图
    6.2 展示了定义不显式返回变量的函数的一般模式。
- en: '![CH06_F02_Cui](../Images/CH06_F02_Cui.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Cui](../Images/CH06_F02_Cui.png)'
- en: Figure 6.2 The implicit return of a function. When a function doesn’t have a
    return statement, it’s equivalent to a function that returns None.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 函数隐式返回。当一个函数没有返回语句时，它等同于返回 None 的函数。
- en: Question What’s the return value of a function when it has a bare return statement?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 当函数有一个裸的返回语句时，它的返回值是什么？
- en: Returning one value
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个值
- en: Returning a value is the most common form for functions. As you should be aware,
    functions are defined to perform a specific operation. Typically, we expect to
    have one output value from an operation, as it eliminates ambiguity about the
    function’s purpose. Thus, in most cases, you should aim for your functions to
    return only one value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是函数最常见的形式。你应该知道，函数被定义为执行特定的操作。通常，我们期望从操作中有一个输出值，因为它消除了关于函数目的的歧义。因此，在大多数情况下，你应该让你的函数只返回一个值。
- en: 'It’s time for a quick review of the process of assigning a function’s return
    value to a variable—the most common form of calling a function. Consider the following
    scenario:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候快速回顾一下将函数的返回值分配给变量的过程了——这是调用函数最常见的形式。考虑以下场景：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code snippet shows a common use case: calling the function say_hello and
    assigning its return value to the variable greeting. Do you know exactly what’s
    happening behind the scenes? If so, you can skip to the next section; otherwise,
    see figure 6.3.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段展示了常见的用法：调用函数 say_hello 并将它的返回值分配给变量 greeting。你知道幕后发生了什么吗？如果你知道，你可以跳到下一节；否则，请参阅图
    6.3。
- en: '![CH06_F03_Cui](../Images/CH06_F03_Cui.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Cui](../Images/CH06_F03_Cui.png)'
- en: Figure 6.3 The process of creating a variable from a function call. When you
    define a function, the function is saved to the namespace. When you call the function,
    it looks up the namespace to locate the function and calls the function with the
    supplied arguments. When the function call is complete, the returned value is
    sent back and assigned to the variable. When the assignment is complete, the new
    variable is loaded into the same namespace so that it can be looked up for later
    use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 从函数调用创建变量的过程。当你定义一个函数时，该函数被保存到命名空间中。当你调用函数时，它会查找命名空间以定位函数，并使用提供的参数调用函数。当函数调用完成时，返回的值被发送回并分配给变量。当赋值完成时，新变量被加载到相同的命名空间中，以便以后可以查找使用。
- en: 'Concept A *namespace* is a collection of defined variables that you can look
    up and use. You can think of it as a dictionary object: the identifiers, such
    as a function’s name, are the keys, and their corresponding objects are the values.
    Section 10.2 discusses namespaces in detail.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *命名空间* 是一组定义的变量集合，你可以从中查找和使用。你可以将其视为一个字典对象：标识符，如函数的名称，是键，它们对应的对象是值。第 10.2
    节详细讨论了命名空间。
- en: When you create a variable from a function call, you’re using an assignment
    statement. An assignment statement evaluates the right side’s expression; in our
    case, it’s calling the function, which is looked up from the current namespace.
    After completing the operation defined in the function, execution returns the
    value and assigns it to the greeting variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从函数调用中创建一个变量时，你正在使用一个赋值语句。赋值语句评估右侧的表达式；在我们的例子中，它是调用函数，该函数从当前命名空间中查找。在完成函数中定义的操作后，执行返回值并将其分配给
    greeting 变量。
- en: Returning multiple values
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多个值
- en: When your function performs complicated operations, these operations may generate
    two or more objects, and you’ll need all objects for subsequent processing. In
    this case, you should consider returning all these objects as the function’s output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的函数执行复杂的操作时，这些操作可能会生成两个或更多的对象，并且你需要所有这些对象来进行后续处理。在这种情况下，你应该考虑将这些对象全部作为函数的输出返回。
- en: As you probably know, it’s standard for scientists to report the mean and the
    standard deviation of all the measures in an experiment. Suppose that you’re defining
    a function to help scientists complete this job. The next listing shows a possible
    solution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能所知，科学家报告实验中所有测量的平均值和标准差是标准的。假设你正在定义一个函数来帮助科学家完成这项工作。接下来的列表显示了可能的解决方案。
- en: Listing 6.4 Returning multiple values from a function
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 从函数中返回多个值
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The generate_stats function returns the mean and the standard deviation simultaneously,
    which simplifies your codebase. A non-Pythonic approach might use two separate
    functions if each function returns only one value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: generate_stats 函数同时返回平均值和标准差，这简化了你的代码库。一种非 Pythonic 的方法可能会使用两个单独的函数，如果每个函数只返回一个值：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notably, you don’t always want to return multiple values. In listing 6.4, the
    values measure_mean and measure_std are closely related, and they constitute the
    statistical reports of these experimental measures; thus, the listing is a valid
    example of returning two values from a function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你并不总是想返回多个值。在列表6.4中，measure_mean和measure_std值密切相关，它们构成了这些实验度量的统计报告；因此，这个列表是返回函数中两个值的有效例子。
- en: 'By contrast, when you’re trying to return two values that are unrelated, your
    function is likely to consist of mixed operations that serve separate purposes.
    The following code snippet is an example of a poorly defined function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，当你试图返回两个不相关的值时，你的函数可能由服务于不同目的的混合操作组成。以下代码片段是一个定义不良的函数的例子：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, in the process_data function, the returned values aren’t related.
    Thus, when some other people use this function, it’s hard for them to figure out
    what’s coming from this function call because the function serves two distinct
    purposes: formatting the measures and calculating the measures’ mean. A more readable
    approach would define separate functions for each purpose. More important, these
    functions should be named in a way that clearly reflects their purposes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在process_data函数中，返回的值不相关。因此，当其他人使用这个函数时，他们很难弄清楚这个函数调用会返回什么，因为这个函数服务于两个不同的目的：格式化度量值和计算度量值的平均值。一个更可读的方法是为每个目的定义单独的函数。更重要的是，这些函数应该以清楚地反映它们目的的方式命名：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Maintainability Functions should serve single purposes. When you think that
    you’re “refactoring” or “saving” lines of code by combining functions that serve
    different purposes, you’re making the code harder to use and read, which can cause
    confusion for yourself and your teammates.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性函数应服务于单一目的。当你认为通过合并服务于不同目的的函数来“重构”或“节省”代码行时，你正在使代码更难使用和阅读，这可能会让你和你的队友感到困惑。
- en: 6.2.3 Using multiple values returned from a function call
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 使用函数调用返回的多个值
- en: When a function returns None or any other single value, using the return value
    is straightforward. But a function can return multiple values in some cases. In
    this section, we’ll discuss how to use multiple values returned from a function
    call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数返回None或任何其他单一值时，使用返回值是直接的。但有些情况下，一个函数可以返回多个值。在本节中，我们将讨论如何使用函数调用返回的多个值。
- en: 'Although I’ve been saying that we can define a function that returns multiple
    values, in fact, we can return only one object in any function. Check the use
    of the generate_ stats function that we defined in listing 6.4:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我一直说我们可以定义一个返回多个值的函数，但实际上，在任何函数中我们只能返回一个对象。检查我们定义在列表6.4中的generate_stats函数的使用情况：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ The type function checks the data type of the object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类型函数检查对象的数据类型。
- en: The returned value from calling generate_stats is a tuple object, although it
    appears that we’re returning two values in the function definition. These two
    values are packed into a single tuple object. In other words, strictly speaking,
    when we appear to return multiple values in a function definition, we’re returning
    *a single variable* that is a tuple object consisting of these values. Please
    note that as discussed regarding tuple unpacking (section 4.4), parentheses are
    optional for creating a tuple object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用generate_stats返回的值是一个元组对象，尽管在函数定义中看起来我们返回了两个值。这两个值被打包到一个单一的元组对象中。换句话说，严格来说，当我们似乎在函数定义中返回多个值时，我们返回的是一个*单一变量*，它是一个包含这些值的元组对象。请注意，正如关于元组解包（第4.4节）所讨论的，创建元组对象时括号是可选的。
- en: You can apply the tuple unpacking technique to using the multiple values returned
    from a function, which is a concise, Pythonic way to access the individual items
    of the returned tuple object, as shown in the next listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将元组解包技术应用于使用函数返回的多个值，这是一种简洁、Pythonic的方式来访问返回的元组对象的各个单独项，如下一列表所示。
- en: Listing 6.5 Unpacking the return tuple object
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 解包返回的元组对象
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Question What should you do if you want to use only the mean from calling the
    generate_stats function?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 如果你想只使用从generate_stats函数调用中返回的均值，你应该怎么做？
- en: 6.2.4 Discussion
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 讨论
- en: Your functions should serve a single purpose, so returning only one value is
    the preferred form of output. Although you can return as many values as you want
    from a function, it’s not a good idea to return too many, because it is confusing
    for the function’s users to figure out what each of the values stands for. As
    a rule of thumb, it’s best to have your function return one value. In some cases,
    using two to four values is fine, but using five or more probably means that something
    is wrong with your function, such as serving multiple purposes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数应该只服务于单一目的，因此只返回一个值是首选的输出形式。虽然你可以从函数中返回尽可能多的值，但返回过多的值并不是一个好主意，因为这会让函数的用户难以弄清楚每个值代表什么。作为一个经验法则，最好让你的函数只返回一个值。在某些情况下，使用两个到四个值是可以的，但使用五个或更多可能意味着你的函数有问题，比如服务于多个目的。
- en: 6.2.5 Challenge
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.5 挑战
- en: 'Zoe continues to work on her location-centered application (section 3.1.4).
    She defines multiple functions that return a place’s latitude and longitude:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Zoe继续工作在她的以位置为中心的应用程序（第3.1.4节）。她定义了多个函数，这些函数返回一个地点的纬度和经度：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you see the pattern repetition of return values, you realize that she should
    refactor her code. What suggestion can you give her to make these functions return
    one value?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到返回值的模式重复时，你会意识到她应该重构她的代码。你能给她什么建议来使这些函数返回一个值？
- en: Hint Named tuples (section 3.3) are a lightweight data model that you can use
    to hold data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 命名元组（第3.3节）是一种轻量级的数据模型，你可以用它来存储数据。
- en: 6.3 How do I use type hints to write understandable functions?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 如何使用类型提示编写可理解的函数？
- en: 'When we define functions, Python doesn’t require that we specify the types
    of the arguments and the return value. In most cases, our functions accept only
    specific data types. Consider this function from listing 6.4:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，Python不需要我们指定参数和返回值的类型。在大多数情况下，我们的函数只接受特定的数据类型。考虑以下列表6.4中的函数：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If users don’t know what kind of data types they need to use, they might call
    the function as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不知道他们需要使用什么类型的数据，他们可能会这样调用函数：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function call doesn’t work because the function assumes that the argument
    measures is a list or tuple object. Thus, to reduce the possibility that others
    will use our functions incorrectly, we should consider using type hints in our
    function definitions. Proper *type hints* tell users what kinds of arguments our
    functions take and what value our functions return, making our functions more
    understandable. In the next section, you’ll learn how to write user-friendly functions
    with type hints.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用不起作用，因为该函数假设参数measures是一个列表或元组对象。因此，为了减少其他人使用我们的函数不正确的情况，我们应该考虑在我们的函数定义中使用类型提示。适当的*类型提示*告诉用户我们的函数需要哪些类型的参数以及我们的函数返回什么值，使我们的函数更易于理解。在下一节中，你将学习如何编写具有类型提示的用户友好函数。
- en: 6.3.1 Providing type hinting to variables
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 为变量提供类型提示
- en: 'In chapters 1-5, you learned about common data models such as str, list, tuple,
    and dict. When we define a variable of a particular type, we create it without
    worrying about specifying the data type. But we can indicate the data type of
    the variable, which is the basis of applying type hints to functions. In this
    section, we’ll review the essential skills for providing type hints to variables.
    Here’s a simple example of creating an int variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1-5章中，你学习了关于常见数据模型如str、list、tuple和dict的内容。当我们定义特定类型的变量时，我们创建它而不必担心指定数据类型。但我们可以指明变量的数据类型，这是为函数应用类型提示的基础。在本节中，我们将回顾为变量提供类型提示的基本技能。以下是一个创建int变量简单示例：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Trivia The built-in type function allows us to inspect an object’s type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 The built-in type function allows us to inspect an object’s type.
- en: 'As expected, the variable number has a data type of int. If we decide to assign
    this variable with a different value, such as a string, to number, we can do the
    following in Python:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，变量number的数据类型为int。如果我们决定将这个变量赋值为不同的值，例如一个字符串，我们可以这样做：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the code snippet, we assign a string literal to the variable number, which
    makes its data type str. In other words, we’re working with the same variable,
    number, but its data type has been converted from int to str with a simple reassignment.
    Using programming terminology, we say that Python is *dynamically typed*—the type
    of variables can change after their creation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们将一个字符串字面量赋值给变量number，使其数据类型变为str。换句话说，我们正在使用同一个变量number，但通过简单的重新赋值，其数据类型已从int转换为str。使用编程术语，我们说Python是*动态类型化的*——变量的类型可以在创建后改变。
- en: By contrast, some other programming languages won’t let you change the type
    of a variable after it’s defined; these languages are *statically typed.* Swift,
    the recommended language for developing iPhone apps and other Apple-related systems,
    is a statically typed language. In Swift, we can’t reassign a string value to
    a variable that is initially defined as an integer. When a variable has a specific
    type, you can’t use a value of a different type for reassignment, as shown in
    the next listing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一些其他编程语言不允许你在定义变量后更改其类型；这些语言是*静态类型的。* Swift，推荐用于开发iPhone应用和其他苹果相关系统的语言，是一种静态类型语言。在Swift中，我们不能将字符串值重新分配给最初定义为整数的变量。当一个变量具有特定类型时，你不能使用不同类型的值进行重新分配，如下一个列表所示。
- en: Listing 6.6 An example of static typing in Swift
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 Swift中静态类型的一个示例
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Even though Python is a dynamically typed language, we can provide type hints
    to the variables that we create in Python. This feature, known as *type hinting,*
    was added to Python 3.6\. To provide a type hint, you use a semicolon after the
    variable name, after which you specify the type of the variable. Following are
    some examples:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python是一种动态类型语言，但我们可以在Python中为创建的变量提供类型提示。这个功能被称为*类型提示*，它是在Python 3.6中添加的。要提供类型提示，你在变量名后使用分号，然后指定变量的类型。以下是一些示例：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It’s important to know that type hinting doesn’t make Python a statically typed
    language and that it doesn’t enforce the typing of the variable. (If you’re wondering
    about the point of using type hints, see the next section.) You can still assign
    a value of a different type to a variable that you create with type hinting and
    run the following two lines of code without problems:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道类型提示并不会使Python成为静态类型语言，并且它不会强制变量的类型。（如果你想知道使用类型提示的目的，请参阅下一节。）你仍然可以将不同类型的值分配给使用类型提示创建的变量，并且可以无问题地运行以下两行代码：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 6.3.2 Using type hinting in function definitions
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 在函数定义中使用类型提示
- en: In section 6.3.1, you learned to provide type hinting to individual variables.
    In this section, we’ll apply this technique to a function definition to see the
    benefits of defining functions with type hints.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.3.1节中，你学习了如何为单个变量提供类型提示。在本节中，我们将把这个技术应用到函数定义中，以了解使用类型提示定义函数的好处。
- en: 'Using type hinting in a function definition is no different from using it to
    create variables except for one thing: providing hints to the return value. We’ll
    use the example in the next listing (a modified version of the generate_stats
    function defined in listing 6.4) to see how type hinting with functions works.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中使用类型提示与用它来创建变量没有区别，除了一个方面：为返回值提供提示。我们将通过下一个列表中的示例（6.4列表中定义的generate_stats函数的修改版本）来了解函数类型提示是如何工作的。
- en: Listing 6.7 Using type hints in a function
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 在函数中使用类型提示
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Adding type hints to a function’s parameters is the same as creating variables,
    and both usages take the form param: data_type. Adding type hints to the return
    value is different because in the function head, we don’t have an explicit variable
    for the return value. Instead, we use -> data_type to indicate the type for the
    return value. There are two major reasons to use type hints in the function definitions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '向函数参数添加类型提示与创建变量相同，并且这两种用法都采用param: data_type的形式。向返回值添加类型提示不同，因为在函数头部，我们没有为返回值提供一个明确的变量。相反，我们使用->
    data_type来表示返回值的类型。在函数定义中使用类型提示有两个主要原因：'
- en: '*Type hints make it clear to users what parameters the function takes and what
    it returns.* If you call help(generate_stats), for example, you’ll be able to
    see the function’s signature and use it correctly:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型提示清楚地告诉用户函数需要哪些参数以及它返回什么。* 例如，如果你调用help(generate_stats)，你将能够看到函数的签名并正确使用它：'
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Type hints facilitate coding efficiency by allowing you to check the proper
    types while you’re coding.* This advantage is not obvious if you use the console
    or a plain-text editor because real-time code analysis is provided by the leading
    Python integrated development environments (IDEs), either natively or through
    the installation of plugins, also known as extensions.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型提示通过允许你在编码时检查正确的类型来提高编码效率。* 如果你使用控制台或纯文本编辑器，这个优势可能并不明显，因为主要的Python集成开发环境（IDEs）要么原生提供，要么通过安装插件（也称为扩展）提供实时代码分析。'
- en: Suppose that you define a function that accepts integers, and you specify this
    requirement by using type hints. Figure 6.4 shows how code analysis can result
    in meaningful pop-up menus that help you ensure code quality.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你定义了一个接受整数的函数，并且通过使用类型提示来指定这个要求。图6.4显示了代码分析如何产生有意义的弹出菜单，这有助于你确保代码质量。
- en: '![CH06_F04_Cui](../Images/CH06_F04_Cui.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Cui](../Images/CH06_F04_Cui.png)'
- en: Figure 6.4 Pop-up menus are shown for functions with type hints in the Python
    editor PyCharm. When you call the function, the pop-up menu shows the arguments
    and their respective types. When you call the function with the wrong types, the
    pop-up menu shows the incompatible types.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 在Python编辑器PyCharm中显示了具有类型提示的函数的弹出菜单。当你调用函数时，弹出菜单会显示参数及其相应的类型。当你用错误的类型调用函数时，弹出菜单会显示不兼容的类型。
- en: 6.3.3 Applying advanced type-hinting skills to function definitions
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 将高级类型提示技能应用于函数定义
- en: 'In section 6.3.2, you learned about the syntax of using type hints in a function
    definition. In several situations, however, you’ll find that the basic usage isn’t
    enough. In this section, you’ll learn about some advanced uses for type hinting:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.3.2节中，你学习了如何在函数定义中使用类型提示的语法。然而，在几种情况下，你会发现基本用法是不够的。在本节中，你将了解类型提示的一些高级用法：
- en: Arguments with default values
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认值的参数
- en: Custom classes
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类
- en: Container objects
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器对象
- en: Multiple data types
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种数据类型
- en: Using arguments with default values
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有默认值的参数
- en: 'I’ve covered how to set a default value for a parameter in a function definition.
    When this feature is combined with type hints, all we need to know is the order
    of the sequence: type hint first and then the default value. The following code
    snippet shows an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了如何在函数定义中为参数设置默认值。当这个特性与类型提示结合使用时，我们只需要知道序列的顺序：类型提示首先，然后是默认值。以下代码片段显示了一个示例：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The parameter multiplier has a default value of 1 with the int type. Please
    note that the spaces used in specifying the parameter’s default value and type
    are necessary because they help improve the readability of the code. Specifically,
    you should have spaces before and after the type and the = sign.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 参数乘数对于int类型具有默认值1。请注意，在指定参数的默认值和类型时使用的空格是必要的，因为它们有助于提高代码的可读性。具体来说，应该在类型和等号前后留有空格。
- en: Readability Spaces and empty lines are necessary in many places to improve code
    readability by creating visual separators for distinct components.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：在许多地方，空格和空行是必要的，通过为不同的组件创建视觉分隔符来提高代码的可读性。
- en: Working with custom classes
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义类一起工作
- en: When our project grows, we introduce new classes to manage the data. These classes
    are new types, and we can use them as we do built-in data types such as int, tuple,
    and dict. The following listing shows how to include custom classes in function
    definitions by using type hints.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目增长时，我们引入新的类来管理数据。这些类是新的类型，我们可以像使用内置数据类型int、tuple和dict一样使用它们。以下列表显示了如何通过使用类型提示将自定义类包含在函数定义中。
- en: Listing 6.8 Using type hints with custom classes
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 在自定义类中使用类型提示
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Uses the pass statement as a placeholder
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用pass语句作为占位符
- en: Trivia The pass statement is used where code is required to fulfill syntactical
    requirements. As a placeholder, the pass statement does nothing. In the body of
    a class definition, we’re required to write code to implement the class. In this
    case, however, we can use pass to validate the class definition.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事实：pass语句用于满足代码的语法要求。作为一个占位符，pass语句不执行任何操作。在类定义的主体中，我们需要编写代码来实现类。然而，在这种情况下，我们可以使用pass来验证类定义。
- en: 'As shown in listing 6.8, we define two classes: Task (using the named tuple
    technique) and User (using a typical class definition). When these classes are
    defined, we can use them immediately. Python knows these classes are types and
    that they can be used to indicate the types of the arguments in a function definition.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表6.8所示，我们定义了两个类：Task（使用命名元组技术）和User（使用典型的类定义）。当这些类被定义后，我们可以立即使用它们。Python知道这些类是类型，并且它们可以被用来指示函数定义中参数的类型。
- en: Working with container objects
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器对象一起工作
- en: We have learned that several built-in data types, such as list and tuple, are
    containers because they can hold other objects. When it comes to type hints for
    these containers, you may notice that providing a type for the container itself
    isn’t always meaningful enough. Suppose that we have a function for completing
    several tasks, as shown in the following listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，一些内置数据类型，如列表和元组，是容器，因为它们可以包含其他对象。当涉及到这些容器的类型提示时，您可能会注意到，为容器本身提供类型并不总是足够有意义的。假设我们有一个用于完成多个任务的函数，如下所示。
- en: Listing 6.9 Type hints using a container type
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 使用容器类型的类型提示
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function definition shows that the tasks argument is a list object, but
    it doesn’t specify what objects go into the list. Thus, people may use a list
    of str objects or a list of Task objects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义显示 tasks 参数是一个列表对象，但它没有指定列表中包含的对象类型。因此，人们可能会使用包含 str 对象的列表或包含 Task 对象的列表：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It’s true that when you add specific operations to the function, you make either
    str or Tasks objects compatible, but it’s more user-friendly to provide specificity
    to the tasks argument. Is it a list of str or Task objects? The next listing shows
    a modified version of the function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向函数添加特定操作时，您可以使 str 或 Tasks 对象兼容，但为 tasks 参数提供具体性更符合用户友好性。它是 str 对象的列表还是 Task
    对象的列表？下一列表显示了函数的修改版本。
- en: Listing 6.10 Type hints using a container of specific content types
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 使用特定内容类型的容器类型提示
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Trivia The type-hinting feature is evolving in recent Python versions. Some
    features may be not available if you don’t use the latest version of Python.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 事实：Python 近期版本中的类型提示功能正在演变。如果您不使用 Python 的最新版本，某些功能可能不可用。
- en: Instead of using only list, you can use a pair of brackets following list to
    include the expected data type of the contained objects. In our case, we expect
    the list object to contain Task objects but not str objects. With this change,
    you’ll notice that the IDE can give you a warning when you use a list object of
    an incompatible data type, such as strings, as shown in figure 6.5.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表之外，您还可以使用一对括号跟在列表后面来包含包含对象的预期数据类型。在我们的例子中，我们期望列表对象包含 Task 对象，而不是 str 对象。通过这种改变，您会注意到，当您使用不兼容的数据类型的列表对象时，IDE
    会给出警告，如图 6.5 所示。
- en: '![CH06_F05_Cui](../Images/CH06_F05_Cui.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Cui](../Images/CH06_F05_Cui.png)'
- en: Figure 6.5 Displaying a warning when the container holds objects of an incompatible
    data type. The screenshot was taken from the Python IDE PyCharm. Because of the
    IDE’s real-time code analysis, after you specify the argument that is incorrect
    according to the type hints, the IDE displays a warning pop-up menu.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 当容器包含不兼容数据类型的对象时显示警告。截图来自 Python IDE PyCharm。由于 IDE 的实时代码分析，在您指定与类型提示不符的参数后，IDE
    会显示警告弹出菜单。
- en: Besides list, the most common container data types are dict, tuple, and set.
    Table 6.1 summarizes the respective type hints for the contained objects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表之外，最常见的容器数据类型是 dict、tuple 和 set。表 6.1 总结了各自包含对象的类型提示。
- en: Table 6.1 Type hints for common built-in container objects
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 常见内置容器对象的类型提示
- en: '| Container type | Code examples | Explanation |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 容器类型 | 代码示例 | 说明 |'
- en: '| list | list[str] | A list of str objects |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| list | list[str] | 包含 str 对象的列表 |'
- en: '| list[int] | A list of int objects |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| list[int] | 包含 int 对象的列表 |'
- en: '| tuple | tuple[float, int] | A tuple of a float object and an int object |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| tuple | tuple[float, int] | 包含 float 对象和 int 对象的元组 |'
- en: '| tuple[float, ...] | A tuple of multiple float objects |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| tuple[float, ...] | 包含多个 float 对象的元组 |'
- en: '| dict | dict[int, str] | A dict of keys using int objects and values using
    str objects |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| dict | dict[int, str] | 使用 int 对象作为键和 str 对象作为值的字典 |'
- en: '| dict[int, list[int]] | A dict of keys using int objects and values using
    list objects of int objects |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| dict[int, list[int]] | 使用 int 对象作为键和 int 对象列表作为值的字典 |'
- en: '| set | set[int] | A set of int objects |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| set | set[int] | int 对象的集合 |'
- en: '| set[str] | A set of str objects |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| set[str] | 包含 str 对象的集合 |'
- en: Taking multiple data types
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接受多种数据类型
- en: It’s possible for a function to take different data types for a specific parameter.
    In listing 6.6, the generate_stats function’s measures parameter is a list of
    numbers. But this function would work the same way if we used a tuple of numbers.
    In this case, we should use type hinting to indicate that a parameter can be of
    multiple types, as show in the next listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受特定参数的不同数据类型。在列表 6.6 中，generate_stats 函数的 measures 参数是一个数字列表。但如果我们使用数字元组，这个函数的工作方式也将相同。在这种情况下，我们应该使用类型提示来指示参数可以是多种类型，如下一列表所示。
- en: Listing 6.11 Specifying multiple types
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 指定多个类型
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To specify multiple types for a parameter, we use the vertical bar | to separate
    types. Notably, if you have more than two types, you can use more than one bar:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要为参数指定多个类型，我们使用竖线 | 来分隔类型。值得注意的是，如果你有超过两种类型，你可以使用多个竖线：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 6.3.4 Discussion
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.4 讨论
- en: 'Python didn’t support type hints in its early days but gradually became equipped
    with type-hinting features. One major addition to Python’s standard library is
    the typing module for advanced type hinting. What you’ve learned in this chapter
    will make you ready to learn anything new in the typing module. To give you a
    head start, the following code shows how to make type hints clearer with the typing
    module, as it includes higher-level typing information (such as Sequence, which
    can capture any sequence data types):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在早期并不支持类型注解，但逐渐配备了类型注解功能。Python 标准库的一个主要补充是用于高级类型注解的 typing 模块。你在这章中学到的知识将使你准备好学习
    typing 模块中的任何新内容。为了给你一个先发优势，以下代码展示了如何使用 typing 模块使类型注解更清晰，因为它包括更高级别的类型信息（如 Sequence，它可以捕获任何序列数据类型）：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 6.3.5 Challenge
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.5 挑战
- en: Andrew is building a Python package to process finance data. He uses type hints
    in the package to make it easier for users. How can he write type hints when the
    parameter for a function is a list of int or a list of str?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 安德鲁正在构建一个用于处理财务数据的 Python 包。他在包中使用类型注解来简化用户的使用。当函数的参数是一个 int 列表或一个 str 列表时，他该如何编写类型注解？
- en: Hint The vertical bar indicates *or,* which doesn’t have to be between the type
    annotations. In other words, it can be used within a type annotation, such as
    set[int | str].
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：竖线表示 *或*，它不必位于类型注解之间。换句话说，它可以在类型注解中使用，例如 set[int | str]。
- en: 6.4 How do I increase function flexibility with *args and **kwargs?
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 如何使用 *args 和 **kwargs 增加函数的灵活性？
- en: 'When we define functions, we want them to solve specific problems. To call
    these functions, we send the applicable arguments so they can perform the desired
    operations. So far, all the functions that we have defined accept a preset number
    of arguments, but sometimes the desired use case requires more than a preset number
    of arguments. Consider the head for the built-in print function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，我们希望它们解决特定问题。为了调用这些函数，我们发送适用的参数，以便它们可以执行所需的操作。到目前为止，我们定义的所有函数都接受预设数量的参数，但有时所需的用例需要超过预设数量的参数。考虑内置的
    print 函数的头部：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: On the surface, it appears that the print function takes five arguments, with
    the last four having default values. As you may have noticed, however, we can
    print as many objects as we want by using print, as the next listing shows.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，print 函数似乎接受五个参数，其中最后四个有默认值。然而，你可能已经注意到，我们可以通过使用 print 来打印任意数量的对象，正如下一个列表所示。
- en: Listing 6.12 Using the built-in print function
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 使用内置的 print 函数
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The reason why print can accept multiple objects is that * is used before the
    objects parameter, which means a variable number (zero or more) of positional
    arguments. This parameter specification technique is commonly denoted as *args.
    Using *args makes the print function flexible enough to accept any number of objects.
    Notably, there is another closely related technique for specifying a variable
    number of *keyword* arguments, which is denoted as **kwargs. In the next section,
    you’ll learn how to use *args and **kwargs to define functions that have good
    flexibility. Moreover, we’ll introduce some key concepts in terms of arguments’
    categories.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print 可以接受多个对象的原因是在对象参数之前使用了 *，这意味着一个可变数量的（零个或更多）位置参数。这种参数指定技术通常表示为 *args。使用
    *args 使得 print 函数足够灵活，可以接受任意数量的对象。值得注意的是，还有另一种与指定可变数量的 *关键字* 参数密切相关的技术，表示为 **kwargs。在下一节中，你将学习如何使用
    *args 和 **kwargs 定义具有良好灵活性的函数。此外，我们还将介绍有关参数类别的关键概念。
- en: 6.4.1 Knowing positional and keyword arguments
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 了解位置参数和关键字参数
- en: You may have noticed that when we call functions, in the parentheses, we sometimes
    use the arguments directly, and at other times, we use identifiers preceding the
    specified arguments. We have different terms for these two types of arguments.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们调用函数时，在括号中，我们有时直接使用参数，有时使用在指定参数之前的前缀标识符。我们对这两种类型的参数有不同的术语。
- en: 'When the arguments have associated identifiers, they’re *keyword arguments,*
    and these identifiers are used in the function body to refer to these arguments.
    When the arguments don’t have associated identifiers, they’re *positional arguments.*
    In other words, Python processes these arguments based on the arguments’ positions
    according to the sequence in the function definition. To understand the distinction
    between keyword and positional arguments, consider a simple function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数有相关标识符时，它们是**关键字参数**，这些标识符在函数体中用于引用这些参数。当参数没有相关标识符时，它们是**位置参数**。换句话说，Python根据函数定义中的顺序，根据参数的位置处理这些参数。为了理解关键字参数和位置参数的区别，考虑一个简单的函数：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For a typical function like multiply_numbers, we can set the parameters as either
    positional or keyword arguments. Figure 6.6 shows a few ways to call this function
    with two parameters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个典型的函数，如multiply_numbers，我们可以将参数设置为位置参数或关键字参数。图6.6展示了调用此函数时使用两个参数的几种方法。
- en: '![CH06_F06_Cui](../Images/CH06_F06_Cui.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Cui](../Images/CH06_F06_Cui.png)'
- en: Figure 6.6 Using positional and keyword arguments in function calls. If the
    arguments have identifiers preceding the arguments, they’re keyword arguments.
    If the arguments have no identifiers, they’re positional arguments.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6展示了在函数调用中使用位置参数和关键字参数。如果参数前面有标识符，它们是关键字参数。如果参数没有标识符，它们是位置参数。
- en: 'From the various examples shown in figure 6.6, we can summarize the following
    key points regarding the use of positional and keyword arguments:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从图6.6中展示的各种示例中，我们可以总结出以下关于使用位置参数和关键字参数的关键点：
- en: '*When you use positional arguments, the order of these arguments matters.*
    The arguments will be matched with the original parameters in the function head.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当你使用位置参数时，这些参数的顺序很重要**。参数将与函数头部的原始参数匹配。'
- en: '*When you use keyword arguments, the order of these arguments doesn''t matter.*
    The arguments will be used according to the supplied keywords/identifiers.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当你使用关键字参数时，这些参数的顺序不重要**。参数将根据提供的关键字/标识符使用。'
- en: '*When you use both positional and keyword arguments, you have to place positional
    arguments before any keyword arguments.* Otherwise, you’ll raise a SyntaxError.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当你同时使用位置参数和关键字参数时，必须将位置参数放在任何关键字参数之前**。否则，你会引发语法错误。'
- en: Now that you know the distinction between positional and keyword arguments,
    we’re ready to discuss defining a variable number of positional and keyword arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了位置参数和关键字参数的区别，我们准备讨论定义可变数量的位置参数和关键字参数。
- en: Positional-only and keyword-only arguments
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位置参数和仅关键字参数
- en: Figure 6.6 shows that arguments can be set as either positional or keyword when
    you call the function. That is, when you call a function with arguments, Python
    follows a specific order to figure out what the arguments are against the function’s
    definition. If the arguments are keyword, Python matches them with the corresponding
    parameters in the definition. If the arguments are positional, Python processes
    them based on their positions. In general, we don’t restrict how the arguments,
    either positional or keyword, are set.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6显示，在调用函数时，参数可以设置为位置参数或关键字参数。也就是说，当你用参数调用函数时，Python会遵循特定的顺序来确定参数与函数定义中的对应关系。如果参数是关键字参数，Python将它们与定义中的相应参数匹配。如果参数是位置参数，Python将根据它们的位置处理它们。一般来说，我们不限制参数（无论是位置参数还是关键字参数）的设置方式。
- en: 'There are two more advanced ways to specify how the arguments should be set:
    *positional-only arguments* can be set only positionally, and *keyword-only arguments*
    can be set only with identifiers. If you recall, the sort method has the following
    head: sort(*, key=None, reverse=False). The * specifies that all the arguments
    behind it should be set only as keyword-only arguments.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种更高级的方式来指定参数的设置方式：**仅位置参数**只能按位置设置，而**仅关键字参数**只能用标识符设置。如果你还记得，sort方法有如下头部：sort(*,
    key=None, reverse=False)。星号*表示所有其后的参数都应该仅作为仅关键字参数设置。
- en: By reinforcing keyword-only arguments, you’re forcing readers to use keyword
    arguments, so they know exactly what parameters they’re setting. You can use this
    feature if you want some arguments to be set only as keyword arguments.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强化仅关键字参数，你迫使读者使用关键字参数，这样他们就能确切知道正在设置哪些参数。如果你想某些参数只能作为关键字参数设置，可以使用这个特性。
- en: 'For positional-only arguments, look at the sum function: sum(iterable, /, start=0).
    The / specifies that the arguments before it should be set only as positional
    arguments. This feature can be useful, but in your code, you rarely need to set
    arguments that can be used only as positional arguments.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅限位置参数，看看 sum 函数：sum(iterable, /, start=0)。/ 指定它之前的参数应仅作为位置参数设置。这个特性可能很有用，但在你的代码中，你很少需要设置只能作为位置参数使用的参数。
- en: 6.4.2 Accepting a variable number of positional arguments
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 接受可变数量的位置参数
- en: In the print function (listing 6.12), *objects allows us to print as many objects
    as we want, which improves its flexibility. In this section, you’ll learn how
    to define a function that accepts a variable number of positional arguments.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 print 函数（列表 6.12）中，*objects 允许我们打印任意数量的对象，这提高了其灵活性。在本节中，你将学习如何定义一个接受可变数量位置参数的函数。
- en: 'To facilitate the discussion, I’ll begin with a simple function, the purpose
    of which is to convert any number of objects to their corresponding string representations.
    Apparently, we don’t know how many objects will be sent to the function call.
    Thus, we want this function to be flexible, like the print function. The following
    code snippet shows the function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于讨论，我将从一个简单的函数开始，其目的是将任意数量的对象转换为它们对应的字符串表示。显然，我们不知道会有多少对象被发送到函数调用中。因此，我们希望这个函数具有灵活性，就像
    print 函数一样。下面的代码片段显示了该函数：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using *args as a tuple
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *args 作为元组
- en: In the function’s head, we use *items to indicate that the function can take
    a variable number of positional arguments. In essence, you use the asterisk (*)
    symbol to precede the argument name. Now that we know that with this function
    head, the user can call it with an arbitrary number of positional arguments, the
    next question is how we can use these positional arguments in the function body.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的头部，我们使用 *items 来表示该函数可以接受任意数量的位置参数。本质上，你使用星号 (*) 符号来在参数名前。既然我们知道这个函数头，用户可以用任意数量的位置参数调用它，那么下一个问题是如何在函数体中使用这些位置参数。
- en: 'Because we’ve included a line of code to print the arguments, print(f"got {items}
    in {type(items)}"), we can call stringify to inspect what items is:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在代码中包含了一行打印参数的代码，print(f"got {items} in {type(items)}"), 我们可以调用 stringify
    来检查 items 的内容：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The return value of the function is printed in the console.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数的返回值将在控制台打印。
- en: From the output, we know that all the positional arguments are packed into a
    tuple object named items. Thus, we can apply any tuple-related techniques to items.
    In the example, we use the list comprehension technique to iterate the items object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们知道所有位置参数都被打包到一个名为 items 的元组对象中。因此，我们可以对 items 应用任何元组相关技术。在示例中，我们使用列表推导技术迭代
    items 对象。
- en: Placing *args as the last positional argument
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *args 作为最后一个位置参数
- en: 'When you expect the user to call a function that accepts other specified positional
    arguments besides *args, you should place *args at the end. Consider a modified
    version of the stringify function:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你期望用户调用一个接受除了 *args 之外的其他指定位置参数的函数时，你应该将 *args 放在末尾。考虑对 stringify 函数的修改版本：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When we call stringify_a, Python knows to parse the positional arguments accordingly.
    The first argument goes to item0, and the remaining arguments go to items:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 stringify_a 时，Python 会知道相应地解析位置参数。第一个参数传递给 item0，其余参数传递给 items：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Apparently, the stringify_a function is valid. Now look at an invalid modification:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，stringify_a 函数是有效的。现在看看一个无效的修改：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When we call stringify_b with positional arguments, it is impossible for Python
    to figure out which argument goes to which parameter. items means any number of
    positional arguments, and Python doesn’t know where to stop, as in this example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用位置参数调用 stringify_b 时，Python 无法确定哪个参数对应哪个参数。items 表示任意数量的位置参数，Python 也不知道在哪里停止，就像这个例子一样：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we call stringify_b with only positional arguments, we encounter the TypeError,
    and the error message tells us that we’re missing the keyword-only argument item0.
    Thus, we could use stringify_b if we set items as a keyword argument:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只用位置参数调用 stringify_b 时，我们会遇到 TypeError，错误信息告诉我们我们缺少关键字参数 item0。因此，如果我们把 items
    设置为关键字参数，我们就可以使用 stringify_b：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Although the function call works, our original intention was to define a function
    that could be called only with positional arguments. With that assumption, we
    should remember to place *args at the end of the list of positional arguments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数调用是有效的，但我们的初衷是定义一个只能用位置参数调用的函数。基于这个假设，我们应该记住将*args放在位置参数列表的末尾。
- en: 6.4.3 Accepting a variable number of keyword arguments
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 接受任意数量的关键字参数
- en: In section 6.4.2, we learned to create a function that accepts any number of
    positional arguments. As a counterpart, we can define a function that accepts
    any number of keyword arguments. As a convention, we use **kwargs to denote the
    variable number of keyword arguments. In this section, you’ll learn about **kwargs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.4.2节中，我们学习了如何创建一个可以接受任意数量位置参数的函数。作为对比，我们可以定义一个可以接受任意数量关键字参数的函数。按照惯例，我们使用**kwargs**来表示关键字参数的可变性。在本节中，你将了解**kwargs**。
- en: 'To facilitate the discussion, I’ll start with a simple function that involves
    **kwargs. Using the function as an example, here are the key points of using **kwargs:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于讨论，我将从一个涉及**kwargs**的简单函数开始。以该函数为例，以下是使用**kwargs**的关键点：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using **kwargs as a dict
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将**kwargs**作为字典使用
- en: 'We know that the variable number of positional arguments is packed as a tuple
    object. In a similar fashion, the variable number of keyword arguments is packed
    into a single object: dict. Let’s see whether that’s the case by calling the create_report
    function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，可变数量的位置参数被打包成一个元组对象。以类似的方式，可变数量的关键字参数被打包成一个单一的对象：字典。让我们通过调用create_report函数来验证这一点：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: From the printout, you can easily see that these keyword arguments form a dict
    object. With this dict object, we can use applicable dict-related methods. In
    this example, we iterate all the key-value pairs by using items.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从打印输出中，你可以轻松地看到这些关键字参数形成了一个字典对象。使用这个字典对象，我们可以使用相关的字典方法。在这个例子中，我们通过使用items迭代所有键值对。
- en: Placing **kwargs as the last parameter
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将**kwargs**作为最后一个参数
- en: When you use **kwargs in a function, you should remember the syntax rule that
    **kwargs should be placed after all the other parameters. Related to this rule,
    positional arguments should be placed before all the keyword arguments. Figure
    6.7 shows the general order of these kinds of arguments.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数中使用**kwargs**时，你应该记住语法规则，即**kwargs**应该放在所有其他参数之后。与此规则相关，位置参数应该放在所有关键字参数之前。图6.7显示了这些参数的一般顺序。
- en: '![CH06_F07_Cui](../Images/CH06_F07_Cui.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F07_Cui](../Images/CH06_F07_Cui.png)'
- en: Figure 6.7 The order of placing positional and keyword arguments in a function
    definition. In general, positional arguments should always precede keyword arguments.
    *args should be the last positional argument, and **kwargs should be the last
    keyword argument.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 函数定义中位置参数和关键字参数的放置顺序。一般来说，位置参数应该始终在关键字参数之前。*args应该是最后一个位置参数，**kwargs应该是最后一个关键字参数。
- en: 6.4.4 Discussion
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 讨论
- en: Although using *args and **kwargs helps improve the flexibility of the defined
    functions, it’s less explicit to the function’s users regarding the applicable
    parameters. Thus, we shouldn’t abuse this feature. Only when you can’t know how
    many positional or keyword arguments you expect the function to accept should
    you consider using *args and **kwargs. In general, it’s preferred to use explicitly
    named positional and keyword arguments in a function definition, because these
    argument names clearly indicate what the parameters are presumed to be doing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用*args和**kwargs**有助于提高定义的函数的灵活性，但对于函数的用户来说，它对适用参数的说明不够明确。因此，我们不应该滥用这个特性。只有在你无法知道函数期望接受多少位置参数或关键字参数时，才应考虑使用*args和**kwargs**。一般来说，在函数定义中使用显式命名的位置参数和关键字参数是首选的，因为这些参数名称清楚地表明了参数的预期行为。
- en: 6.4.5 Challenge
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.5 挑战
- en: 'Let’s continue the story about Cory, who teaches Python coding in college.
    The students know that a function with **kwargs accepts a variable number of keyword
    arguments, as in the following example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讲述关于柯里（Cory）的故事，他在大学里教授Python编程。学生们知道，一个带有**kwargs**的函数可以接受任意数量的关键字参数，如下面的例子所示：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To test the students’ knowledge of calling functions, he creates a list of
    ways to call the preceding example function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试学生对调用函数的知识，他创建了一个调用前面示例函数的方法列表：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you were one of the students, would you know which techniques are valid and
    which are not? What makes some calls invalid?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名学生，你会知道哪些技术是有效的，哪些不是吗？是什么使得一些调用无效？
- en: Hint The keyword arguments use identifiers. Python has specific rules about
    identifiers. They can’t start with a number, for example.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 关键字参数使用标识符。Python对标识符有特定的规则。例如，它们不能以数字开头。
- en: 6.5 How do I write proper docstrings for a function?
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 如何为函数编写合适的文档字符串？
- en: When we come across a new function, it’s common to look up its documentation
    to figure out how to use it. You can use the built-in isinstance function to check
    whether an object belongs to a specific type, for example. But you don’t know
    how to call this function. Besides looking up the information online, is there
    any way to get the pertinent information? The answer is yes—with the help of the
    built-in help function, as the following listing shows.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个新函数时，通常会查阅其文档以了解如何使用它。例如，你可以使用内置的isinstance函数来检查一个对象是否属于特定类型。但你不知道如何调用这个函数。除了在网上查找信息外，还有没有其他方法来获取相关信息？答案是肯定的——借助内置的help函数，如下所示。
- en: Listing 6.13 Getting the docstring by using help
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 使用help获取文档字符串
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As shown in listing 6.13, we use the help function to retrieve the docstrings
    for the isinstance function. Although this technique is less commonly known, you
    can also retrieve a function’s docstring by accessing its special attribute __doc__:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表6.13所示，我们使用help函数检索isinstance函数的文档字符串。尽管这种技术不太为人所知，但你也可以通过访问其特殊属性__doc__来检索一个函数的文档字符串：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you didn’t know, Python uses *docstrings* to refer to the documentation of
    a function, a class, or a module to explain the functionalities of these things.
    In our case, we’re viewing the docstrings for the function isinstance, which provides
    specific instructions on how to use isinstance. More importantly, you can conveniently
    access the docstrings with a simple help call in a Python console without relying
    on any external resources. In this section, you’ll learn to write proper docstrings
    for a function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，Python使用*docstrings*来指代函数、类或模块的文档，以解释这些事物的功能。在我们的例子中，我们正在查看isinstance函数的文档字符串，它提供了如何使用isinstance的具体说明。更重要的是，你可以通过在Python控制台中简单地调用help来方便地访问文档字符串，而不依赖于任何外部资源。在本节中，你将学习如何为函数编写合适的文档字符串。
- en: Concept A *docstring* is a string that documents a module, class, function,
    or method in such a way that users know how to use them properly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *docstring* 是一个字符串，它以这种方式记录模块、类、函数或方法，使用户知道如何正确使用它们。
- en: 6.5.1 Examining the basic structure of a function's docstring
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 检查函数文档字符串的基本结构
- en: A function’s docstring is a multiline string below the function’s head. As a
    convention, we use triple quotes to enclose the string. You can use double or
    single quotation marks to form the triple quotes as long as they’re matched. In
    this section, we review the basic structure of a function’s docstring.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的文档字符串位于函数头部下方的一个多行字符串。按照惯例，我们使用三引号来包围字符串。只要它们匹配，你可以使用双引号或单引号来形成三引号。在本节中，我们将回顾函数文档字符串的基本结构。
- en: 'For this multiline string, as a best practice, three key elements are required:
    a summary of the function, parameters, and a return value. If your function can
    raise one or multiple exceptions, you want to specify them too, as a fourth element.
    Figure 6.8 shows the building elements of a function’s docstring.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个多行字符串，作为最佳实践，需要包含三个关键元素：函数的摘要、参数和返回值。如果你的函数可以抛出一个或多个异常，你希望指定它们，作为第四个元素。图6.8显示了函数文档字符串的构建元素。
- en: '![CH06_F08_Cui](../Images/CH06_F08_Cui.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F08_Cui](../Images/CH06_F08_Cui.png)'
- en: 'Figure 6.8 A function’s docstring in Google style. Three elements are required:
    summary, parameters, and return value. If the function raises any exception, it
    needs to be specified too.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 Google风格的函数文档字符串。需要包含三个元素：摘要、参数和返回值。如果函数抛出任何异常，也需要指定。
- en: Notably, Python programmers haven’t reached a consensus regarding docstring
    style. The docstring shown in figure 6.8 is called Google style because it’s officially
    recommended by Google. Multiple styles have been adopted by different Python users
    and IDEs. As one of the most common Python IDEs, PyCharm uses the so-called *reStructuredText
    (reST**)* style as the default option for docstrings; figure 6.9 shows an example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Python程序员在文档字符串风格上还没有达成共识。图6.8中显示的文档字符串被称为Google风格，因为它是由Google官方推荐的。不同的Python用户和IDE已经采用了多种风格。作为最常用的Python
    IDE之一，PyCharm将所谓的*reStructuredText (reST)*风格作为文档字符串的默认选项；图6.9显示了示例。
- en: '![CH06_F09_Cui](../Images/CH06_F09_Cui.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F09_Cui](../Images/CH06_F09_Cui.png)'
- en: 'Figure 6.9 A function’s docstring in the reST style used by PyCharm. The key
    elements are the same as docstrings in other styles: summary, parameters, return
    value, and exceptions (where applicable).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 PyCharm使用的reST风格的函数文档字符串。关键元素与其他风格的文档字符串相同：摘要、参数、返回值和异常（如有）。
- en: Although Python programmers generally agree on what elements should be included
    in a function’s docstring, it’s up to each individual programmer to choose a preferred
    style or follow the company’s convention. In this section, we’ll stick to the
    reST style. In the next sections, we’ll discuss the proper ways to define each
    element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python程序员通常在函数文档字符串应包含哪些元素上达成一致，但每个程序员都有权选择一个首选风格或遵循公司的约定。在本节中，我们将坚持使用reST风格。在下一节中，我们将讨论定义每个元素的适当方法。
- en: Maintainability It’s important to stick to a specific docstring style in the
    project. Consistency in documentation is essential for both readability and maintainability.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 在项目中坚持特定的文档字符串风格很重要。文档的一致性对于可读性和可维护性都是必不可少的。
- en: 6.5.2 Specifying the function's action as the summary
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 将函数的动作指定为摘要
- en: The first element in a function’s docstring is the summary of the function.
    The summary should be concise, occupying only one line if at all possible. It
    provides a high-level description of the action that the function performs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 函数文档字符串的第一个元素是函数的摘要。摘要应该是简洁的，如果可能的话，只占用一行。它提供了函数执行动作的高级描述。
- en: 'In listing 6.13, for example, we saw the docstring for the built-in isinstance
    function. Its summary clearly indicates the function’s action: Return whether
    an object is an instance of a class or of a subclass thereof. We should use the
    same philosophy in creating our own summary. Notably, for some simple functions,
    it’s possible to need only one line as the docstring. In this case, the summary
    constitutes the entire docstring. The following simple function represents such
    a scenario:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在列表6.13中，我们看到了内置的isinstance函数的文档字符串。其摘要清楚地指出了函数的动作：返回一个对象是否是某个类或其子类的实例。我们在创建自己的摘要时应该使用相同的理念。值得注意的是，对于一些简单的函数，可能只需要一行作为文档字符串。在这种情况下，摘要构成了整个文档字符串。以下简单的函数代表了这种情况：
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 6.5.3 Documenting the parameters and the return value
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.3 记录参数和返回值
- en: 'After providing the summary for the function, the next step in creating a function’s
    docstring is documenting each of the parameters used by the function. In reST
    style, each parameter starts with :param, and different parameters are listed
    as separate lines. For each parameter, we need to provide the following information:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在为函数提供摘要之后，创建函数文档字符串的下一步是记录函数使用的每个参数。在reST风格中，每个参数以`:param`开头，不同的参数作为单独的行列出。对于每个参数，我们需要提供以下信息：
- en: '*Parameter name*—It should match exactly what is used in the function’s head.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数名称*—它应该与函数头中使用的完全一致。'
- en: '*Parameter type*—What type of data are you expecting for the parameter? Specify
    it.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数类型*—你期望参数是什么类型的数据？请指定它。'
- en: '*Description*—Depending on how intuitive the parameter is, provide a useful
    description to help users understand what this parameter is or why it’s needed
    if its purpose isn’t clear.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*描述*—根据参数的直观性，提供有用的描述以帮助用户理解该参数是什么，或者如果其目的不明确，为什么需要它。'
- en: '*Default value* (optional)—If the parameter has a default value, specify it.
    Notably, if it’s ambiguous why you choose a specific value as the default value,
    you need to provide a brief justification.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认值*（可选）—如果参数有一个默认值，请指定它。值得注意的是，如果你选择特定值作为默认值的原因不明确，你需要提供简要的说明。'
- en: You can see these guidelines in action in the following listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下列表中看到这些指南的实际应用。
- en: Listing 6.14 Docstring example of a simple function
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 简单函数的文档字符串示例
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The example in listing 6.14 provides the needed docstring for the three parameters,
    including parameter name, type, and explanation. In addition, because taking_int
    has a default value, it’s mentioned in the docstring. When one parameter’s docstring
    expands more than one line, remember to insert some indentation for the second
    line and later lines so that the delineation between different parameters is clear.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14中的示例提供了三个参数所需的文档字符串，包括参数名称、类型和说明。此外，由于taking_int有一个默认值，它也在文档字符串中提到。当一个参数的文档字符串超过一行时，请记住在第二行和后续行中插入一些缩进，以便清楚地划分不同的参数。
- en: From a readability perspective, we use sensible names for the function itself
    (quotient) and all the parameters (dividend, divisor, and taking_int). Using sensible
    names is key in a function definition because these names can provide intuitive
    information about the function. If they’re named well, users probably don’t even
    need to check the docstring to understand the function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从可读性的角度来看，我们为函数本身（quotient）和所有参数（被除数、除数和 taking_int）使用有意义的名称。在使用函数定义时，使用有意义的名称是关键，因为这些名称可以提供关于函数的直观信息。如果它们命名得当，用户可能甚至不需要检查文档字符串就能理解函数。
- en: Readability Everything should be named sensibly for best readability. It’s OK
    to use long names because autocompletion is a feature in common IDEs. After you
    write the first couple of letters, you can select the needed name.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 为了最佳的可读性，一切都应该有意义的命名。使用长名称是可以的，因为自动补全是常见 IDE 的一个功能。在你写下前几个字母之后，你可以选择所需的名字。
- en: In other words, your goal in defining a function is to make it easy for users
    to understand and use, minimizing the possibility that they must refer to the
    function’s docstrings. Keep in mind that the docstring should be a backup source
    of information for your functions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你在定义函数时的目标是使其易于用户理解和使用，最大限度地减少他们必须参考函数的文档字符串的可能性。请记住，文档字符串应该是你函数的备用信息源。
- en: For a function’s return value, the docstring uses :return to indicate the return
    value’s type and explanation. The explanation should be concise and easy to understand.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数的返回值，文档字符串使用 :return 来指示返回值的类型和说明。说明应该是简洁且易于理解的。
- en: 6.5.4 Specifying any exceptions possibly raised
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.4 指定可能抛出的任何异常
- en: When your function could raise any exceptions, you should specify them in the
    docstring so that when users read the docstrings, they know the possible exceptions
    to expect and can avoid or handle them.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的函数可能抛出任何异常时，你应该在文档字符串中指定它们，这样当用户阅读文档字符串时，他们就会知道可能遇到的异常，并可以避免或处理它们。
- en: 'Let’s consider the quotient function, which includes the division operation
    dividend / divisor. We know that a division is undefined if the divisor is 0,
    and we can see what will happen if we’re trying to divide a number by 0:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 quotient 函数，它包括除法操作被除数 / 除数。我们知道如果除数为 0，除法是未定义的，我们可以看到如果我们尝试将一个数字除以 0
    会发生什么：
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Thus, we should specify such an exception in the docstring, as shown in the
    next listing.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该在文档字符串中指定这样的异常，如以下列表所示。
- en: Listing 6.15 Specifying the possible exception in the docstring
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 在文档字符串中指定可能的异常
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Raises ZeroDivisionError explicitly
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 明确抛出 ZeroDivisionError 异常
- en: In listing 6.15, we explicitly examine whether divisor is 0 and raise the ZeroDivisionError
    when it’s 0. Please note that even if we don’t raise this exception explicitly,
    such an exception can still be raised when we call something like quotient(1,
    0) because Python raises ZeroDivisionError whenever applicable. Here, I explicitly
    raise this exception because I want to show you how an exception raised by a function
    should be documented in the docstring.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 6.15 中，我们明确检查除数是否为 0，并在其为 0 时抛出 ZeroDivisionError 异常。请注意，即使我们没有明确抛出这个异常，当我们调用类似
    quotient(1, 0) 这样的操作时，Python 也会在适用的情况下抛出 ZeroDivisionError 异常。在这里，我明确抛出这个异常，因为我想要展示一个由函数抛出的异常应该如何在文档字符串中进行记录。
- en: On a related note, when we create our own Python modules, we often need to define
    custom exceptions ourselves to explicitly raise these custom exceptions in the
    functions we create. I cover custom exceptions in section 12.5.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 相关地，当我们创建自己的 Python 模块时，我们经常需要自己定义自定义异常，以便在创建的函数中明确抛出这些自定义异常。我在第 12.5 节中介绍了自定义异常。
- en: 6.5.5 Discussion
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.5 讨论
- en: There are different styles in which to create a function’s docstrings. The key
    is sticking to a specific style consistently. If you work on a team, use the style
    that your team has agreed on. If you write functions/modules only for yourself,
    adopt the style you’re most used to. Please remember that consistency in coding
    is key to sustained maintainability of any project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数的文档字符串有不同的风格。关键是始终如一地坚持特定的风格。如果你在一个团队中工作，使用团队商定的风格。如果你只为自己的函数/模块编写代码，采用你最习惯的风格。请记住，代码的一致性是任何项目持续可维护性的关键。
- en: 6.5.6 Challenge
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.6 挑战
- en: Jerry used to adopt the reST style for his docstrings, as shown in listing 6.15\.
    He’s joining a company that uses Google style for all the documentation. As a
    best practice, what would the docstring look like if he rewrote the docstrings
    in listing 6.15 by using Google style?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 杰瑞过去通常使用 reST 风格为其文档字符串，如列表 6.15 所示。他现在加入了一家使用 Google 风格对所有文档进行编写的公司。作为一个最佳实践，如果他使用
    Google 风格重写列表 6.15 中的文档字符串，那么文档字符串会是什么样子？
- en: Hint Figure 6.8 shows a docstring that uses Google style.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 提示图 6.8 展示了一个使用 Google 风格的文档字符串。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You should consider setting default values for the arguments whose values are
    the same for most calls. The users don’t need to set them anymore when the default
    values are used, making it easier to read these function calls with fewer arguments.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该考虑为大多数调用中值相同的参数设置默认值。当使用默认值时，用户不再需要设置它们，这使得使用较少参数的函数调用更容易阅读。
- en: When you set default values for mutable arguments, such as list, don’t use the
    constructor list(), because a function is evaluated when it’s defined, including
    the default arguments. Using the constructor will result in different function
    calls manipulating the same mutable object and producing undesired side effects.
    To avoid this pitfall, you should use None as the default value of mutable arguments.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你为可变参数设置默认值时，例如列表，不要使用构造函数 list()，因为函数是在定义时进行评估的，包括默认参数。使用构造函数会导致不同的函数调用操作相同的可变对象，并产生不期望的副作用。为了避免这种陷阱，你应该使用
    None 作为可变参数的默认值。
- en: Every Python function has a return value—either the explicitly returned value
    or the implicitly returned None.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 Python 函数都有一个返回值——要么是显式返回的值，要么是隐式返回的 None。
- en: A function can return multiple values that form a single tuple object. You can
    use the tuple unpacking technique to retrieve individual items after the function
    call. That way, it’s clearer to the readers how you’re going to use the return
    value.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数可以返回多个值，这些值形成一个单一的元组对象。你可以在函数调用之后使用元组解包技术来检索单个项。这样，读者可以更清楚地了解你将如何使用返回值。
- en: Although Python is a dynamically typed language, we can use type hints to provide
    useful typing information on the arguments and return value for a function. When
    you incorporate type hinting into a function definition, you make your functions
    more readable, making it easier for users to understand your function. More important,
    modern IDEs can take advantage of a function’s type hints and provide real-time
    warnings if an incompatible type of object is used for an argument.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 Python 是一种动态类型语言，但我们可以使用类型提示来为函数的参数和返回值提供有用的类型信息。当你将类型提示纳入函数定义中时，你会使你的函数更易于阅读，使用户更容易理解你的函数。更重要的是，现代
    IDE 可以利用函数的类型提示，并在使用不兼容类型的对象作为参数时提供实时警告。
- en: When we call a function, we often pass the needed arguments. When the arguments
    use identifiers, they’re called keyword arguments. By contrast, arguments that
    have no identifiers and are parsed based on their positions are positional arguments.
    Positional arguments should always be placed before keyword arguments.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用函数时，我们通常会传递所需的参数。当参数使用标识符时，它们被称为关键字参数。相比之下，没有标识符且基于其位置解析的参数是位置参数。位置参数应始终放在关键字参数之前。
- en: Most of the time, it’s best to define a fixed number of positional and keyword
    arguments. In certain situations, however, it’s necessary to define functions
    that accept a variable number of positional and/or keyword arguments, which are
    denoted as *args and **kwargs, respectively.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数情况下，最好定义一个固定数量的位置参数和关键字参数。然而，在某些情况下，有必要定义接受可变数量位置参数和/或关键字参数的函数，这些参数分别表示为
    *args 和 **kwargs。
- en: You need to provide documentation, called docstrings, if your functions are
    to be used publicly. A function’s docstring should include the function’s summary,
    all the parameters, the return value, and the possible exceptions (if any).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的函数要公开使用，你需要提供文档，称为文档字符串。函数的文档字符串应包括函数的摘要、所有参数、返回值以及可能的异常（如果有）。
- en: Developers use different styles for docstrings. When you write docstrings for
    your functions, be sure to adopt a specific docstring style and use it consistently.
    When you apply a docstring consistently, it’s easy for you to develop and maintain
    your code (you need to be savvy about only one style), and you also make things
    easy for readers.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者会使用不同的风格来编写文档字符串。当你为你的函数编写文档字符串时，务必采用一种特定的文档字符串风格，并保持一致地使用。当你一致地应用文档字符串，这将使你更容易开发和维护你的代码（你只需要熟悉一种风格），同时也会让读者更容易理解。
