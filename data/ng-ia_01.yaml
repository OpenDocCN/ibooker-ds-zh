- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building your first Angular app
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你的第一个 Angular 应用程序
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Angular components and how they form a basis for your app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 组件及其如何构成你的应用程序的基础
- en: Defining a number of types of components, using decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器定义多种类型的组件
- en: Learning how services can be used to share data across your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用服务在应用程序中共享数据
- en: Setting up routing to display different pages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置路由以显示不同的页面
- en: You’re going to build an entire Angular app in this chapter, starting from scratch,
    while learning about the primary concepts of Angular. You’ll see some TypeScript
    features in action, as well as new and upcoming features of JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从零开始构建一个完整的 Angular 应用程序，同时学习 Angular 的主要概念。你将看到 TypeScript 的某些功能在实际应用中的表现，以及
    JavaScript 的新功能和即将推出的功能。
- en: This project will remain focused and simple, yet still be representative of
    many of the features you’ll use in a typical app. The app you’ll create is a stock
    tracking app, with data coming from Yahoo! Finance. It will be able to fetch current
    stock prices, add or remove stocks from a list, and adapt a visual display based
    on the current day’s gains or losses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将保持专注和简单，同时仍然代表了你将在典型应用程序中使用的许多功能。你将创建的应用程序是一个股票跟踪应用程序，数据来自 Yahoo! Finance。它将能够获取当前的股票价格，从列表中添加或删除股票，并根据当天的盈亏调整视觉显示。
- en: 'In this chapter, we’ll build this app piece by piece. We’ll focus on getting
    through the example application with enough detail to understand the various pieces
    and complexity in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步构建这个应用程序。我们将专注于通过示例应用程序，以足够的细节来理解本章中的各个部分和复杂性：
- en: '*Bootstrapping* *the app —*To start the app, we’ll use the *bootstrap* feature
    to kick things off once they’re loaded. This happens once during the app lifecycle,
    and we’ll bootstrap the App component.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引导* *应用程序 —* 要启动应用程序，我们将使用 *引导* 功能在加载完成后启动一切。这发生在应用程序生命周期中一次，我们将引导 App 组件。'
- en: '*Creating components —*Angular is all about *components*, and we’ll create
    several components for different purposes. We’ll learn about how they’re built
    and how they nest to create complex applications.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建组件 —* Angular 全是关于 *组件*，我们将为不同的目的创建几个组件。我们将了解它们是如何构建的，以及它们如何嵌套以创建复杂的应用程序。'
- en: '*Creating services and using HttpClient* —For code reuse, we’ll encapsulate
    some logic that helps manage the list of stocks into a *service* and also uses
    the HttpClient service from Angular to load stock quote data.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建服务和使用 HttpClient* — 为了代码重用，我们将把一些帮助管理股票列表的逻辑封装到一个 *服务* 中，并使用 Angular 的 HttpClient
    服务来加载股票报价数据。'
- en: '*Using pipes and directives in templates* —Using *pipes*, we can transform
    data from one format into another during display, such as formatting a timestamp
    into a local date format. *Directives* are useful tools to modify the behavior
    of DOM elements inside a template, such as the ability to repeat pieces or conditionally
    show elements.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在模板中使用管道和指令* — 使用 *管道*，我们可以在显示过程中将数据从一种格式转换为另一种格式，例如将时间戳格式化为本地日期格式。*指令* 是修改模板中
    DOM 元素行为的实用工具，例如重复部分或条件性地显示元素。'
- en: '*Setting up routing* —Most applications need the ability to allow users to
    navigate around the application, and by using the *router* we can see how to route
    between different components.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置路由* — 大多数应用程序都需要允许用户在应用程序中导航的能力，通过使用 *路由器*，我们可以了解如何在不同的组件之间进行路由。'
- en: Using a limited amount of code, you’ll be able to create a robust application
    that does a number of complex tasks. Subsequent chapters focus on each of the
    individual features in detail for a more complete picture of everything Angular
    has to offer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有限的代码，你可以创建一个健壮的应用程序，执行多个复杂任务。后续章节将详细介绍每个单独的功能，以更全面地了解 Angular 提供的一切。
- en: You should be familiar with ES2015 and the newer capabilities of the JavaScript
    language. I won’t be going into detail about the newer language constructs, such
    as imports or classes. I recommend spending some time reading at the Mozilla Developer
    Network ([https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript))
    for more details, or pick up a book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉 ES2015 以及 JavaScript 语言的最新功能。我不会详细介绍新的语言结构，例如导入或类。我建议花些时间阅读 Mozilla 开发者网络
    ([https://developer.mozilla.org/en-US/docs/Web/JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript))
    以获取更多详细信息，或者选择一本书来阅读。
- en: 2.1 Previewing the chapter project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 预览章节项目
- en: When we are done, the app should appear as you see in figures [2.1](#figure2.1)
    and [2.2](#figure2.2). We’ll walk through the various pieces briefly before we
    build them so you’ll see how they all come together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，应用应该看起来像你在图 [2.1](#figure2.1) 和 [2.2](#figure2.2) 中看到的那样。在我们构建它们之前，我们会简要地介绍各个部分，这样你就能看到它们是如何组合在一起的。
- en: First, there’s an API that loads current stock price data from Yahoo! Finance;
    it’s deployed on Heroku and isn’t covered in this chapter, but you can view the
    code for the API at [https://github.com/angular-in-action/api](https://github.com/angular-in-action/api).
    It’s a standard REST API and doesn’t require authentication. We’ll create a service
    to help us access and load data from the API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个 API 从 Yahoo! Finance 加载当前的股票价格数据；它在 Heroku 上部署，但本章没有涵盖，但你可以在 [https://github.com/angular-in-action/api](https://github.com/angular-in-action/api)
    上查看 API 的代码。它是一个标准的 REST API，不需要身份验证。我们将创建一个服务来帮助我们访问和从 API 加载数据。
- en: When the app loads, it shows the dashboard page ([figure 2.1](#figure2.1)) with
    a list of cards. Each card contains a single stock, the current price, and the
    day’s change in price (as a currency value and as a percentage). The background
    of the cards will be red for negative change, green for a positive change, or
    gray for no change. Each of these cards is an instance of a component that takes
    the stock data and determines how to render the card.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用加载时，它会显示仪表板页面 ([figure 2.1](#figure2.1))，其中包含一系列卡片。每个卡片包含一个股票、当前价格和当天的价格变动（以货币值和百分比表示）。卡片的背景将为红色表示负变动，绿色表示正变动，或灰色表示无变动。这些卡片是组件的实例，它们接收股票数据并确定如何渲染卡片。
- en: '![c02-1.png](image_fi/293313c02/c02-1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![c02-1.png](image_fi/293313c02/c02-1.png)'
- en: '[**Figure 2.1**](#figureanchor2.1) The dashboard page for the stock tracking
    app with links and summary cards'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 2.1**](#figureanchor2.1) — 股票跟踪应用的仪表板页面，包含链接和摘要卡片'
- en: Lastly, the top navbar has two links, to the dashboard and manage views, which
    allow for general navigation between the views. We’ll use the Angular Router to
    set up these routes and manage how the browser determines which to display.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，顶部的导航栏有两个链接，一个是仪表板，另一个是管理视图，这允许在视图之间进行一般导航。我们将使用 Angular Router 来设置这些路由并管理浏览器如何确定显示哪个视图。
- en: When you click the Manage link in the navbar, you’ll see the manage page ([figure
    2.2](#figure2.2)) with a list of the stocks. Here you can remove any of the stocks
    by clicking the Remove button. You can also add new stocks by typing the stock
    symbol into the text area and pressing the Enter key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在导航栏中点击管理链接时，你会看到管理页面 ([figure 2.2](#figure2.2))，其中列出了股票。在这里，你可以通过点击删除按钮来删除任何股票。你也可以通过在文本区域中输入股票代码并按
    Enter 键来添加新的股票。
- en: '![c02-2.png](image_fi/293313c02/c02-2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![c02-2.png](image_fi/293313c02/c02-2.png)'
- en: '[**Figure 2.2**](#figureanchor2.2) The manage page for the stock tracking app
    with the form to change the list of symbols to display'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 2.2**](#figureanchor2.2) — 股票跟踪应用的管理页面，包含更改要显示的符号列表的表单'
- en: This page is a single component, but contains a form that’s updated immediately
    upon changes input by the user. The list can be extended by putting a new stock
    symbol in the input field and hitting Enter, or the list can be reduced by clicking
    the Remove button. In both cases, the list of symbols is immediately changed,
    and if you go back to the dashboard you’ll see the updated list appear.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面是一个单独的组件，但它包含一个表单，用户输入更改后立即更新。可以通过在输入字段中输入新的股票代码并按 Enter 键来扩展列表，或者通过点击删除按钮来减少列表。在两种情况下，符号列表都会立即更改，如果你回到仪表板，你会看到更新的列表出现。
- en: 'This project has a few limitations you should be aware of. To keep the example
    focused and simple, there are a few details that aren’t included in the app:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有一些限制，你应该知道。为了保持示例的专注和简单，有一些细节没有包含在应用中：
- en: '*No persistence* —Anytime you refresh the app in the browser, the list of stocks
    resets to the default list.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有坚持* — 每次你在浏览器中刷新应用时，股票列表都会重置为默认列表。'
- en: '*Lack of* *error checking* —Some situations can throw an error or cause strange
    behavior, such as trying to add a stock that doesn’t exist.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺乏* *错误检查* — 一些情况可能会引发错误或导致异常行为，例如尝试添加一个不存在的股票。'
- en: '*No unit tests* —For this example, I kept the focus on the code and intentionally
    left out unit tests, which are covered later.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*没有单元测试* — 对于这个示例，我专注于代码，并故意省略了单元测试，这些将在后面介绍。'
- en: This example is intended to provide you with an overview of how Angular apps
    can be built—not to provide a bulletproof app. I provide you a number of interesting
    challenges you can attempt near the end of the chapter, and there are many possible
    features that can be imagined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例旨在为您提供Angular应用构建的概述——而不是提供一个坚不可摧的应用。我在本章末尾提供了一些有趣的挑战，以及许多可以想象的可能功能。
- en: 2.2 Setting up the project
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 设置项目
- en: We’ll build this example from scratch using the Angular CLI. If you ever need
    to look at the code for this project, it can be found on GitHub at [https://github.com/angular-in-action/stocks](https://github.com/angular-in-action/stocks),
    and each step is tagged so you can follow along using Git, or you can copy the
    contents from the chapter as it appears.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Angular CLI从头开始构建这个示例。如果您需要查看这个项目的代码，可以在GitHub上找到[https://github.com/angular-in-action/stocks](https://github.com/angular-in-action/stocks)，每个步骤都有标签，这样您可以使用Git跟踪，或者您可以复制章节中的内容。
- en: If you haven’t set up the Angular CLI, please go back to chapter 1 and set it
    up. We’re using the CLI version 1.5 in this book, so if you’re using an older
    version you’ll want to upgrade.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有设置Angular CLI，请回到第1章并设置它。本书中使用的是CLI版本1.5，所以如果您使用的是旧版本，您可能需要升级。
- en: 'In the terminal, start from a directory that you want to generate a new project
    folder inside. Then you can run the following command to generate a new project,
    and then start the development server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，从一个您想要在其中生成新项目文件夹的目录开始。然后您可以使用以下命令生成新项目，并启动开发服务器：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will take a few moments as the CLI installs a number of packages from npm,
    and this depends greatly on the speed of your network and how busy the registry
    is. Once it has completed, you can use your browser to view the app at http://localhost:4200\.
    You should see a simple page that says something about being a new Angular app,
    as shown in [figure 2.3](#figure2.3). The default content of a new project changes
    over time, so don’t worry if it looks a little different.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将花费一些时间，因为CLI从npm安装了多个包，这取决于您网络的速率以及注册表的繁忙程度。一旦完成，您可以使用浏览器在http://localhost:4200查看应用。您应该看到一个简单的页面，上面写着有关这是一个新的Angular应用的内容，如图2.3所示。新项目的默认内容会随着时间的推移而变化，所以如果看起来有点不同，请不要担心。
- en: '![c02-3.png](image_fi/293313c02/c02-3.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![c02-3.png](image_fi/293313c02/c02-3.png)'
- en: '[**Figure 2.3**](#figureanchor2.3) The CLI generates a blank app with some
    default content.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图2.3**](#figureanchor2.3)  CLI生成了一个包含一些默认内容的空白应用。'
- en: If you see a similar screen, then everything should be set up and ready to go.
    It’s not the most exciting-looking example, but it sets up a few things for you
    automatically. We’re now going to take a tour of what has been generated and how
    it works to display this simple message.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似的屏幕，那么一切应该都设置好了，准备就绪。这不是最令人兴奋的示例，但它为您自动设置了一些东西。我们现在将浏览已经生成的内容以及它是如何显示这个简单信息的。
- en: 2.3 The basic app scaffolding
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 基本应用骨架
- en: The CLI generated a new project that contains a lot of files. We’ll look at
    the most important ones for the moment and learn more about the rest over time.
    It’s important to note that the CLI generates files in a specific way, and making
    changes to file locations or names may cause the CLI to fail. For now, I recommend
    leaving files where they are until you’re more comfortable or unless you plan
    to build your own tooling later. Over time, the exact files and filenames that
    are generated by the CLI may change, so if you have any issues, look at the CLI
    changelog and documentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CLI生成了一个包含许多文件的新项目。我们暂时将关注最重要的文件，并随着时间的推移了解更多关于其他文件的信息。需要注意的是，CLI以特定的方式生成文件，更改文件位置或名称可能会导致CLI失败。目前，我建议您在更熟悉之前不要移动文件，除非您计划稍后构建自己的工具。随着时间的推移，CLI生成的确切文件和文件名可能会发生变化，所以如果您遇到任何问题，请查看CLI的变更日志和文档。
- en: The project contains several directories and files. The primary files are listed
    in table 2.1, along with their general roles in the application. Most of these
    are configuration for various aspects of the development, such as linting rules,
    unit test configuration, and CLI configuration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含几个目录和文件。主要文件列在表2.1中，以及它们在应用程序中的通用角色。这些大多数是针对开发各个方面的配置，例如代码风格检查规则、单元测试配置和CLI配置。
- en: '**Table 2.1** Top-level contents of the project generated by the CLI and their
    roles'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2.1**  CLI生成的项目顶级内容及其角色'
- en: '| **Asset** | **Role** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **资产** | **角色** |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| e2e | End-to-end testing folder, contains a basic stub test |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| e2e | 端到端测试文件夹，包含一个基本的存根测试 |'
- en: '| node_modules | Standard NPM modules directory, no code should be placed here
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| node_modules | 标准的NPM模块目录，不应在此处放置代码 |'
- en: '| src | Source directory for the application |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| src | 应用程序的源目录 |'
- en: '| .editorconfig | Editor configuration defaults |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| .editorconfig | 编辑器配置默认值 |'
- en: '| .angular-cli.json | Configuration file for the CLI about this project |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| .angular-cli.json | 关于此项目的CLI配置文件 |'
- en: '| karma.conf.js | Karma configuration file for unit test runner |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| karma.conf.js | Karma单元测试运行器的配置文件 |'
- en: '| package.json | Standard NPM package manifest file |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| package.json | 标准的NPM包清单文件 |'
- en: '| protractor.conf.js | Protractor configuration file for e2e test runner |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| protractor.conf.js | Protractor端到端测试运行器的配置文件 |'
- en: '| README.md | Standard readme file, contains starter information |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| README.md | 标准的README文件，包含启动信息 |'
- en: '| tsconfig.json | Default configuration file for TypeScript compiler |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| tsconfig.json | TypeScript编译器的默认配置文件 |'
- en: '| tslint.json | TSLint configuration file for TypeScript linting rules |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| tslint.json | TypeScript代码风格检查的配置文件 |'
- en: In this chapter, you’ll only modify files that exist inside the src directory,
    which contains all the application code. Table 2.2 contains a listing of all the
    assets generated inside src. This may seem like a lot of files, but they each
    play a role, and if you aren’t sure what one does, leave it alone for now.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将只修改位于src目录内的文件，该目录包含所有应用程序代码。表2.2列出了src目录内生成的所有资产。这看起来可能有很多文件，但它们各自都扮演着角色，如果你不确定某个文件的作用，现在就先不要动它。
- en: '**Table 2.2** Contents of the src directory and their roles'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2.2** src目录的内容及其角色'
- en: '| **Asset** | **Role** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **资产** | **角色** |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| app | Contains the primary App component and module |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| app | 包含主要应用程序组件和模块 |'
- en: '| assets | Empty directory to store static assets like images |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| assets | 用于存储静态资源（如图片）的空目录 |'
- en: '| environments | Environment configurations to allow you to build for different
    targets, like dev or production |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| environments | 环境配置，允许你为不同的目标（如开发或生产）构建 |'
- en: '| favicon.ico | Image displayed as browser favorite icon |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| favicon.ico | 作为浏览器收藏夹图标显示的图片 |'
- en: '| index.html | Root HTML file for the application |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| index.html | 应用程序的根HTML文件 |'
- en: '| main.ts | Entry point for the web application code |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| main.ts | 网络应用程序代码的入口点 |'
- en: '| polyfills.ts | Imports some common polyfills required to run Angular properly
    on some browsers |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| polyfills.ts | 导入一些在特定浏览器上正确运行Angular所需的常见polyfills |'
- en: '| styles.css | Global stylesheet |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| styles.css | 全局样式表 |'
- en: '| test.ts | Unit test entry point, not part of application |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| test.ts | 单元测试的入口点，不属于应用程序部分 |'
- en: '| tsconfig.app.json | TypeScript compiler configuration for apps |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| tsconfig.app.json | 应用的TypeScript编译器配置 |'
- en: '| tsconfig.spec.json | TypeScript compiler configuration for unit tests |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| tsconfig.spec.json | 单元测试的TypeScript编译器配置 |'
- en: '| typings.d.ts | Typings configuration |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| typings.d.ts | 类型定义配置 |'
- en: Now that you have a general idea of what was generated, we’re going to inspect
    a few of the key files that comprise the application logic. The next section takes
    a closer look at how Angular renders the contents of the app directory into the
    output that you view on the screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对生成的内容有了大致的了解，我们将检查构成应用程序逻辑的一些关键文件。下一节将更详细地探讨Angular如何将应用程序目录的内容渲染到你在屏幕上看到的结果。
- en: 2.4 How Angular renders the base application
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 Angular渲染基本应用程序
- en: Before we start to build our application, you need to understand how this base
    scaffolding works and what we’ll need to add. This is a whirlwind tour to get
    you up and running as fast as possible, so expect more depth and nuance later
    in the book. In chapter 3, we’ll spend more time on these topics to get a deeper
    understanding of how everything is constructed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用程序之前，你需要了解这个基本脚手架是如何工作的，以及我们需要添加什么。这是一个快速浏览，以便你尽可能快地开始，所以请期待在本书后面的内容中会有更深入和细致的探讨。在第3章中，我们将花更多的时间来探讨这些主题，以获得对如何构建一切的更深入理解。
- en: Angular requires at least one component and one module. A *component* is the
    basic building block of Angular applications and acts much like any other HTML
    element. A *module* is a way for Angular to organize different parts of the application
    into a single unit that Angular can understand. You might think of components
    as LEGO® bricks, which can be many different shapes, sizes, and colors, and modules
    would be the packaging the LEGOs come in. Components are for functionality and
    structure, whereas modules are for packaging and distribution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 至少需要一个组件和一个模块。一个 *组件* 是 Angular 应用程序的基本构建块，它类似于任何其他 HTML 元素。一个 *模块*
    是 Angular 将应用程序的不同部分组织成一个 Angular 可以理解的单一单元的方式。你可能将组件想象成 LEGO® 砖块，它们可以有多种不同的形状、大小和颜色，而模块则是
    LEGO® 砖块包装的方式。组件用于功能性和结构，而模块用于包装和分发。
- en: 2.4.1 App component
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 App 组件
- en: We’re going to start by looking at the src/app/app.component.ts file. This contains
    what’s called the *App component*, which is the root of the application. In LEGO®
    terms, you could picture this component as the big green platform you use to start
    building from. The following listing shows the code for the component. Again,
    the exact code may change over time, so don’t worry if it’s slightly different—it
    will have the same basic requirements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看 src/app/app.component.ts 文件开始。这个文件包含了一个被称为 *App 组件* 的内容，它是应用程序的根组件。在
    LEGO® 的术语中，你可以将这个组件想象成你用来开始构建的大绿色平台。下面的列表显示了组件的代码。再次强调，具体的代码可能会随时间而变化，所以如果它略有不同，请不要担心——它将具有相同的基本要求。
- en: '**Listing 2.1** Generated App component (src/app/app.component.ts)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.1** 生成 App 组件（src/app/app.component.ts）'
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That listing might contain some unfamiliar syntax if you’re new to TypeScript,
    so let’s take a closer look at each section of the code. First, you import the
    `Component` annotation. It’s used to decorate the App component by adding details
    that are related to the component but aren’t part of its controller logic, which
    is the `AppComponent` class. Angular looks at these annotations and uses them
    with the `AppComponent` controller class to create the component at runtime.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 TypeScript 新手，那么列表中可能包含一些不熟悉的语法，所以让我们仔细看看代码的每个部分。首先，你导入 `Component` 注解。它用于通过添加与组件相关的详细信息来装饰
    App 组件，但这些信息不是其控制器逻辑的一部分，即 `AppComponent` 类。Angular 会查看这些注解，并使用它们与 `AppComponent`
    控制器类一起在运行时创建组件。
- en: The `@Component` annotation declares that this class is a component by accepting
    an object. It has a selector property that declares the HTML selector of the component.
    That means the component is used in the template by adding an HTML tag `<app-root></app-root>`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component` 注解通过接受一个对象来声明这个类是一个组件。它有一个选择器属性，用于声明组件的 HTML 选择器。这意味着组件在模板中使用时，会通过添加一个
    HTML 标签 `<app-root></app-root>` 来实现。'
- en: The `templateUrl` property declares a link to a template containing an HTML
    template. Likewise, the `styleUrls` property contains an array of links to any
    CSS files that should be loaded for this component. The `@Component` annotation
    can have more properties, and you’ll see a few more in action in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateUrl` 属性声明了一个指向包含 HTML 模板的模板的链接。同样，`styleUrls` 属性包含了一个指向任何应为此组件加载的
    CSS 文件的链接数组。`@Component` 注解可以有更多属性，你将在本章中看到更多关于这些属性的使用。'
- en: Finally, you see that the `AppComponent` class has a single property called
    `title`. The value is what you should see rendered in the browser, so this is
    the source of the value that ultimately appears. Angular relies greatly on ES2015
    classes to create objects, and almost all entities in Angular are created with
    classes and annotations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以看到 `AppComponent` 类有一个名为 `title` 的单个属性。其值是你应该在浏览器中看到的值，因此这是最终出现在浏览器中的值的来源。Angular
    极大地依赖于 ES2015 类来创建对象，并且 Angular 中的几乎所有实体都是通过类和注解创建的。
- en: 'Now let’s look at the markup associated with the App component by opening src/app/app.component.html,
    shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过打开 src/app/app.component.html 来查看与 App 组件相关的标记，如下所示：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, this is just a simple header tag, but there’s the `title` property
    defined between double curly braces. This is a common convention for how to bind
    a value into a template (perhaps you’re familiar with *Mustache templates*), and
    it means Angular will replace `{{title}}` with the value of the `title` property
    from the component. This is called *interpolation* and is frequently used to display
    data in a template.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是一个简单的标题标签，但其中定义了双大括号之间的 `title` 属性。这是一种常见的绑定值到模板的方式（也许您熟悉 *Mustache
    模板*），这意味着 Angular 将用组件中 `title` 属性的值替换 `{{title}}`。这被称为 *插值*，常用于在模板中显示数据。
- en: We’ve looked at the App component, but now we need to look at the App module
    to see how things get wired up and rendered with Angular.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看过 App 组件，但现在我们需要查看 App 模块，以了解如何使用 Angular 进行连接和渲染。
- en: 2.4.2 App module
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 应用模块
- en: The App module is the packaging that helps tell Angular what’s available to
    render. Just as most food items have packaging that describes the various ingredients
    inside and other important values, a module describes the various dependencies
    that are needed to render the module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: App 模块是一种打包方式，有助于告诉 Angular 可用哪些内容进行渲染。就像大多数食品项目都有包装来描述内部的各种成分和其他重要值一样，模块描述了渲染模块所需的各种依赖项。
- en: There’s at least one module in an application, but it’s possible to create multiple
    modules for different reasons (covered later). In this case, it’s the App component
    from earlier plus additional capabilities that are needed in most applications
    (such as routing, forms, and HttpClient).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中至少有一个模块，但出于不同的原因（稍后介绍），可以创建多个模块。在这种情况下，这是之前提到的 App 组件以及大多数应用程序所需的其他功能（如路由、表单和
    HttpClient）。
- en: The CLI generated the module for us, so we can look at it in src/app/app.module.ts,
    as shown in the following listing. Once again, this may change over time, but
    the structure and purpose remain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 为我们生成了模块，因此我们可以在 src/app/app.module.ts 中查看它，如下所示。再次强调，这些内容可能会随时间变化，但结构和目的保持不变。
- en: '**Listing 2.2** App module (src/app/app.module.ts)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.2**  App 模块（src/app/app.module.ts）'
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like a component, a module is an object with an decorator. The object here
    is called `AppModule`, and `NgModule` is the decorator. The first block is to
    import any Angular dependencies that are common to most apps and the App component.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像组件一样，模块也是一个具有装饰器的对象。这里的对象称为 `AppModule`，而 `NgModule` 是装饰器。第一个块是导入大多数应用程序通用的任何
    Angular 依赖项以及 App 组件。
- en: The `NgModule` decorator takes an object with a few different properties. The
    `declarations` property is to provide a list of any components and directives
    to make available to the entire application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModule` 装饰器接受一个具有几个不同属性的对象。`declarations` 属性用于提供一个组件和指令列表，以便在整个应用程序中可用。'
- en: The `imports` property is an array of other modules upon which this module depends—in
    this case, the Browser module (a collection of required capabilities). If you
    ever include other modules, such as third-party modules or ones you’ve created,
    they also need to be listed here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`imports` 属性是一个数组，包含此模块所依赖的其他模块——在本例中是浏览器模块（一组必需的功能）。如果您包含其他模块，例如第三方模块或您自己创建的模块，它们也需要在此列出。'
- en: The next property is the `providers` property, which is empty by default. Any
    services that are created are to be listed here, and we’ll see how to do this
    shortly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个属性是 `providers` 属性，默认为空。任何创建的服务都需要在此列出，我们将在稍后看到如何进行此操作。
- en: Lastly, the `bootstrap` property defines which components to bootstrap at runtime.
    Typically, this will be the same App component, and the CLI already set it up
    for us. The `bootstrap` property should match the component that you bootstrap
    in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bootstrap` 属性定义了在运行时启动哪些组件。通常，这将是相同的 App 组件，CLI 已经为我们设置好了。`bootstrap` 属性应与下一节中启动的组件相匹配。
- en: We’ve written code that creates a configuration for Angular to look at and understand
    how to render. The last step to look at is the code that gets executed at launch,
    which is called *bootstrapping*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码为 Angular 创建了一个配置，以便它查看和理解如何渲染。接下来要查看的是启动时执行的代码，这被称为 *启动*。
- en: 2.4.3 Bootstrapping the app
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 启动应用程序
- en: The application must be bootstrapped at runtime to start the process of rendering.
    So far, we’ve only declared code, but now we’ll see how it gets executed. The
    CLI takes care of wiring up the build tooling, which is based on webpack.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须在运行时引导以启动渲染过程。到目前为止，我们只声明了代码，但现在我们将看到它是如何执行的。CLI 负责连接基于 webpack 的构建工具。
- en: Start by taking a look at the .angular-cli.json file. You’ll see an array of
    apps, and one of the properties is the `main` property. By default, it points
    to the src/app/main.ts file. This means that when the application gets built,
    it will automatically call the contents of the main.ts file as the first set of
    instructions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看 .angular-cli.json 文件。你会看到一个应用程序数组，其中一个属性是 `main` 属性。默认情况下，它指向 src/app/main.ts
    文件。这意味着当应用程序构建时，它将自动调用 main.ts 文件的内容作为第一组指令。
- en: The role of main.ts is to bootstrap the Angular application. The contents of
    the main.ts file are included in the following listing, and contain only a few
    basic instructions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: main.ts 文件的作用是引导 Angular 应用程序。main.ts 文件的内容包含在以下列表中，并且只包含几个基本指令。
- en: '[**Listing 2.3**](#listinganchor2.3) The main file that is called on launch
    (src/app/main.ts)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表 2.3**](#listinganchor2.3) 启动时调用的主文件（src/app/main.ts）'
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first section imports some dependencies, particularly `platformBrowserDynamic`
    and `AppModule`. The name is a bit long, but the `platformBrowserDynamic` object
    is used to tell Angular which module is being loading, and in this case that’s
    the `AppModule` from earlier. I cover the rendering of modules later in the book,
    but for now it’s important to understand that this is the point where the code
    begins to execute.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分导入了一些依赖项，特别是 `platformBrowserDynamic` 和 `AppModule`。名称有点长，但 `platformBrowserDynamic`
    对象用于告诉 Angular 正在加载哪个模块，在这种情况下是之前提到的 `AppModule`。我在书中稍后介绍了模块的渲染，但到目前为止，重要的是要理解这是代码开始执行的地方。
- en: 'There’s one last piece to review by looking at the index.html file. If you
    remember from the App component code, there was a selector of `app-root` used
    to identify the component in markup. You should see the following in the src/index.html
    file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 index.html 文件，我们可以审查最后一件事情。如果你记得 App 组件代码，有一个 `app-root` 选择器用于在标记中识别组件。你应该在
    src/index.html 文件中看到以下内容：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the app is bootstrapped (by the code from [listing 2.3](#listing2.3)),
    Angular will look for the `app-root` element and replace it with the rendered
    component. That’s what you end up seeing in the screen from [figure 2.1](#figure2.1),
    but while it’s loading everything, you’ll see a “Loading ...” message. It can
    take a moment for all the assets to load and initialize before the component renders.
    This is known as *Just in Time* compilation (JiT), meaning that everything is
    loaded and rendered on demand in the browser. JiT is only meant for development,
    and may be removed in future releases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序通过 [列表 2.3](#listing2.3) 中的代码引导，Angular 将寻找 `app-root` 元素并将其替换为渲染的组件。这就是你在
    [图 2.1](#figure2.1) 中看到的内容，但在加载一切的同时，你会看到一个“正在加载...”的消息。在组件渲染之前，所有资产都需要加载和初始化，这可能需要一点时间。这被称为
    *即时编译*（JiT），意味着所有内容都是按需在浏览器中加载和渲染的。JiT 仅适用于开发，可能在未来的版本中被移除。
- en: 'I’d like to add a couple of small touches that will help us style the rest
    of the application, by adding some basic CSS and markup. First we need to add
    two link tags to our src/index.html:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我想添加一些小的细节，帮助我们通过添加一些基本的 CSS 和标记来设计应用程序的其余部分。首先，我们需要向我们的 src/index.html 添加两个链接标签：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will load some font icons and the global styles for the application, which
    are based on the Material Design Lite project. This is one way you can load external
    references to style libraries or other assets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载一些字体图标和应用程序的全局样式，这些样式基于 Material Design Lite 项目。这是你可以加载外部样式库或其他资产引用的一种方式。
- en: 'We’d like to give our application some global styles. Add the following to
    the src/styles.css file—it will give the application a light gray background:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望给我们的应用程序添加一些全局样式。将以下内容添加到 src/styles.css 文件中——它将为应用程序提供一个浅灰色背景：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lastly we want to set up some base markup to structure our application. Let’s
    replace the content of the src/app/app.component.html file with the markup in
    the following listing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要设置一些基本标记来构建我们的应用程序。让我们用以下列表中的标记替换 src/app/app.component.html 文件的内容。
- en: '**Listing 2.4** Base markup scaffolding (src/app/app.component.html)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表 2.4**](#listinganchor2.4) 基本标记脚手架（src/app/app.component.html）'
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This markup is based around the Material Design Lite design style for how to
    create a basic toolbar and main body. The toolbar has the title and two links
    (which are currently inactive), and should appear like [figure 2.4](#figure2.4).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标记基于 Material Design Lite 设计风格，用于创建基本的工具栏和主体。工具栏包含标题和两个链接（目前处于非活动状态），应该看起来像[图
    2.4](#figure2.4)。
- en: '![c02-4.png](image_fi/293313c02/c02-4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![c02-4.png](image_fi/293313c02/c02-4.png)'
- en: '[**Figure 2.4**](#figureanchor2.4) Modified base scaffolding to have Material
    Design Lite markup'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 2.4**](#figureanchor2.4) 修改后的基本脚手架以使用 Material Design Lite 标记'
- en: All right, we’ve created the base app scaffolding using the CLI, seen the App
    component, App module, and bootstrap logic, and found the markup that renders
    out the component. Congratulations, you’ve made your first Angular app! Okay,
    I know it isn’t that impressive—yet—but this is the fundamental part of every
    Angular app. For the rest of the chapter, we’ll take this basic application and
    build it up to the full stock tracking example. To get started, you’ll learn about
    creating an Angular service that loads data from an API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经使用 CLI 创建了基本的应用程序脚手架，看到了 App 组件、App 模块和引导逻辑，并找到了渲染组件的标记。恭喜你，你已经制作了你的第一个
    Angular 应用程序！好吧，我知道这还不是那么令人印象深刻——但这是每个 Angular 应用程序的基本部分。在接下来的章节中，我们将从这个基本应用程序开始，逐步构建到完整的股票跟踪示例。要开始，你将学习如何创建一个从
    API 加载数据的 Angular 服务。
- en: 2.5 Building services
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 构建服务
- en: '*Services* are objects that abstract some common logic that you plan to reuse
    in multiple places. They can do about anything you need them to do, because they’re
    objects. Using ES2015 modules, these classes are exported, and so any component
    can import them as necessary. They could also have functions or even static values,
    like a string or number, as a way to share data between various parts of your
    application.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务* 是对象，它们抽象了一些你计划在多个地方重用的常用逻辑。由于它们是对象，它们可以执行你需要它们做的任何事情。使用 ES2015 模块，这些类被导出，因此任何组件都可以按需导入它们。它们也可以有函数，甚至静态值，如字符串或数字，作为在应用程序的各个部分之间共享数据的方式。'
- en: Another way to think of services is as sharable objects that any part of your
    app can import as needed. They’re able to abstract some logic or data (such as
    the logic necessary to load some data from a source), so it’s easy to use inside
    of any component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考服务的方式是将它们视为可共享的对象，你的应用程序的任何部分都可以按需导入。它们能够抽象一些逻辑或数据（例如从源加载某些数据所需的逻辑），因此很容易在任何组件中使用。
- en: Although services will often help manage data, they’re not restricted to any
    particular job. The intention of a service is to enable reuse of code. A service
    might be a set of common methods that need to be shared. You could have various
    “helper methods” that you don’t want to write over and over, such as utilities
    to parse data formats or authentication logic that needs to be run in multiple
    places.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务通常有助于管理数据，但它们并不局限于任何特定的工作。服务的目的是使代码可重用。一个服务可能是一组需要共享的常用方法。你可以有各种“辅助方法”，例如解析数据格式或需要在多个地方运行的认证逻辑，你不想反复编写。
- en: In the app, you’ll want to have a list of the stocks for both the dashboard
    and manage pages to use. This is a perfect scenario of when to use a service to
    help manage the data and share it across different components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，你将需要有一个股票列表，用于仪表板和管理页面。这是一个使用服务来帮助管理和在不同组件间共享数据的完美场景。
- en: 'The CLI gives us a nice way to create a service that has the scaffolding we
    need to get started. It will generate a simple service and a test stub for that
    service, as well. To generate a service, you run the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 为我们提供了一种创建具有所需脚手架的服务的好方法。它还将为该服务生成一个简单的服务和一个测试存根。要生成一个服务，你运行以下命令：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The CLI will generate the files in the src/app/services directory. It contains
    the most basic service, which does nothing. Let’s go ahead and fill in the code
    for the entire service and go over how it works. You’ll end up supplementing what
    was generated with the code from the following listing. The Stocks service will
    have an array that contains a list of the stock symbols and expose a set of methods
    to retrieve or modify the list of stocks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 会生成 src/app/services 目录下的文件。它包含最基本的服务，该服务不执行任何操作。让我们继续填写整个服务的代码，并了解它是如何工作的。你最终将补充以下列表中的代码。股票服务将有一个包含股票代码列表的数组，并公开一组方法来检索或修改股票列表。
- en: '**Listing 2.5** Stocks service (src/app/services/stocks.service.ts)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.5** 股票服务（src/app/services/stocks.service.ts）'
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The service first needs to import its dependencies; one is the decorator for
    a service, and the other is the HttpClient service. Then it declares two variables;
    one is to track the list of stock symbols, and the other is the API endpoint URL.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务首先需要导入其依赖项；一个是服务的装饰器，另一个是 HttpClient 服务。然后它声明两个变量；一个是跟踪股票符号列表，另一个是 API 端点
    URL。
- en: Then the `StockInterface` interface is defined and exported for other components
    to use. This provides a TypeScript definition of what a stock object should contain,
    which is used by TypeScript to ensure the use of the data remains consistent.
    We’ll use this later to ensure that we’re typing our stock objects correctly when
    they’re used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义并导出 `StockInterface` 接口供其他组件使用。这提供了 TypeScript 对股票对象应包含内容的定义，TypeScript
    使用它来确保数据的使用保持一致。我们将在以后使用它来确保在它们被使用时正确地为我们股票对象进行类型化。
- en: The `StocksService` class is exported and is decorated by the `Injectable` decorator.
    The decorator is used to set up the proper wiring for Angular to know how to use
    it elsewhere, so if you forget to include the decorator, the class might not be
    injectable into your application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`StocksService` 类被导出并由 `Injectable` 装饰器装饰。装饰器用于设置适当的连接，以便 Angular 知道如何在其他地方使用它，所以如果你忘记包含装饰器，类可能无法注入到你的应用程序中。'
- en: In the constructor method, the HttpClient service is injected using the TypeScript
    technique of declaring a private variable called `http` and then giving it a type
    of HttpClient. Angular can inspect the type definition and determine how to inject
    the requested object into the class. If you’re new to TypeScript, keep in mind
    that anytime you see a colon after a variable declaration, you’re defining the
    object type that should be assigned to that variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数方法中，使用 TypeScript 技术声明一个名为 `http` 的私有变量，并给它一个 HttpClient 类型。Angular 可以检查类型定义并确定如何将请求的对象注入到类中。如果你是
    TypeScript 新手，请记住，每次你在变量声明后看到冒号，你都是在定义应该分配给该变量的对象类型。
- en: The service contains four methods. The `get()`method is a simple method that
    returns the current value of the `stocks` array, but it always returns a copy
    instead of the direct value. This is done to encapsulate the stock values and
    prevent them from being directly modified. The `add()`method adds a new item to
    the `stocks` array and returns the newly modified value. The `remove()` method
    will drop an item from the `stocks` array.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务包含四个方法。`get()` 方法是一个简单的返回 `stocks` 数组当前值的函数，但它总是返回一个副本而不是直接值。这样做是为了封装股票值并防止它们被直接修改。`add()`
    方法向 `stocks` 数组添加一个新项目并返回新修改后的值。`remove()` 方法将从 `stocks` 数组中删除一个项目。
- en: Finally, the `load()` method makes a call to the HttpClient service to load
    the data for current stock price values. The HttpClient service is called and
    returns an observable, which is a construct for handling asynchronous events,
    such as data from an API call. We’ve covered observables briefly in chapter 1
    and will see them more in other chapters, but this is your first glimpse of them
    in action.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`load()` 方法调用 HttpClient 服务来加载当前股票价格数据。HttpClient 服务被调用并返回一个可观察对象（observable），这是一个用于处理异步事件（如
    API 调用中的数据）的构造。我们在第 1 章中简要介绍了可观察对象，将在其他章节中看到更多，但这是你第一次看到它们在实际操作中的样子。
- en: 'There is a little feature of the HttpClient that appears as part of the `get()`
    method and is put between two angle brackets:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: HttpClient 有一个小功能，作为 `get()` 方法的一部分出现，并被放置在两个尖括号之间：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is known as a *type variable*, which is a feature of TypeScript that allows
    you to tell the `http.get()` method what type of object it should expect, and
    in this case it will expect to get an array of objects that conform to the `StockInterface`
    (our stock objects). This is optional, but it’s very helpful to alert the compiler
    if you try to access properties that don’t exist.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *类型变量*，是 TypeScript 的一个特性，允许你告诉 `http.get()` 方法它应该期望什么类型的对象，在这种情况下，它将期望得到一个符合
    `StockInterface`（我们的股票对象）的对象数组。这是可选的，但如果尝试访问不存在的属性，它对编译器非常有帮助。
- en: 'There’s one more step we have to do, because the CLI doesn’t automatically
    register the service with the App module, and we need to register HttpClient with
    the application as well. Open the src/app/app.module.ts file and near the top
    add these two imports:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要进行一个额外的步骤，因为命令行界面（CLI）不会自动将服务注册到 App 模块中，我们还需要将 HttpClient 注册到应用程序中。打开
    src/app/app.module.ts 文件，并在顶部附近添加这两个导入：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will import the Stocks service and `HttpClientModule` into the file, but
    we need to register the `HttpClientModule` with the application. Find the imports
    section as defined in the NgModule, and update it like you see here to include
    the `HttpClientModule`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入Stocks服务和`HttpClientModule`到文件中，但我们需要将`HttpClientModule`注册到应用程序中。找到在NgModule中定义的导入部分，并像下面这样更新它以包括`HttpClientModule`：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we need to register the new `StocksService` with the `providers` property
    to inform Angular that it should be made available for the module to use:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新的`StocksService`注册到`providers`属性中，以通知Angular它应该对模块可用：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Your service is wired up and ready to consume, but we haven’t used it yet anywhere
    in our application. The next section looks at how to consume it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你的服务已经配置好并准备好使用，但我们还没有在我们的应用程序中使用它。下一节将探讨如何使用它。
- en: This service is not too complex. It’s mostly designed to abstract the modification
    of the array so it’s not directly modified and load the data from the API. While
    the application runs, the `stocks` array can be modified, and changes are reflected
    in both the dashboard and manage components, as you’ll see shortly. Because it’s
    exported, it’s easily imported when needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务并不复杂。它主要设计用于抽象数组的修改，以便它不会被直接修改，并从API加载数据。当应用程序运行时，`stocks`数组可以被修改，并且更改将反映在仪表板和管理组件中，正如你很快就会看到的。因为它被导出，所以当需要时很容易导入。
- en: Now you’ll create a component that uses some default directives and allow configurable
    properties to modify the component’s display.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建一个使用一些默认指令并允许可配置属性修改组件显示的组件。
- en: 2.6 Creating your first component
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 创建你的第一个组件
- en: You’ve already seen a basic component (the App component). Now you’ll build
    a more complex component that uses some directives and pipes and has a property.
    We’re going to create a component that displays a basic summary card of the stock
    price information.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一个基本组件（App组件）。现在，你将构建一个更复杂的组件，该组件使用一些指令和管道，并有一个属性。我们将创建一个显示股票价格信息基本摘要卡的组件。
- en: This component will only receive data to display from its parent component and
    modify its own display based on that input value. For example, a parent component
    will pass along the current data for a particular stock, and the Summary component
    will use the daily change to determine whether the background should be green
    or red based on whether the stock went up or down.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将只从其父组件接收要显示的数据，并根据输入值修改自己的显示。例如，父组件将传递特定股票的当前数据，而摘要组件将使用每日变化来确定背景应该是绿色还是红色，这取决于股票是上涨还是下跌。
- en: 'The key goals of this component are to do the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本组件的关键目标如下：
- en: Accept stock data and display it
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收股票数据并显示
- en: Change background color depending on the day’s activity (green for increase,
    red for decrease)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据当天的活动更改背景颜色（增长时为绿色，减少时为红色）
- en: Format values for proper display, such as currency or percentage values
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化值以正确显示，例如货币或百分比值
- en: Figure 2.5 shows the component in place, and we’ll even wire it up to load the
    data from the API. Eventually, we’ll instantiate multiple copies of this component
    to display a card for each of the stocks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5显示了组件的位置，我们甚至将其连接到从API加载数据。最终，我们将实例化多个此组件的副本，以显示每个股票的卡片。
- en: '![c02-5.png](image_fi/293313c02/c02-5.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![c02-5.png](image_fi/293313c02/c02-5.png)'
- en: '**Figure 2.5** Single Summary component displaying stock data'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.5** 单个显示股票数据的摘要组件'
- en: Obviously, when you run this the stock values will change based on the latest
    data, but you can see the card displaying the current data. Let’s dig into building
    this card and then we’ll walk through the individual parts of how it results in
    this output.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当你运行此操作时，股票价值将根据最新数据而变化，但你可以看到显示当前数据的卡片。让我们深入了解构建这张卡片，然后我们将逐步讲解它是如何产生这个输出的各个部分。
- en: 'Go back to the terminal and run the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回终端并运行以下命令：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The CLI will generate a new component inside the src/app/components/summary
    directory. We had to create the src/app/components directory first, because the
    CLI doesn’t make new folders for you automatically if they’re missing. This helps
    organize the components into a single directory, though you could choose to generate
    them elsewhere.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将在src/app/components/summary目录内生成一个新的组件。我们首先必须创建src/app/components目录，因为CLI不会自动为你创建缺失的文件夹。这有助于将组件组织到单个目录中，尽管你也可以选择在其他地方生成它们。
- en: Now the contents of the component are pretty similar to how the App component
    appeared originally. It contains an empty CSS file, basic HTML template, test
    stub, and empty class already initialized with the component annotation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件的内容与App组件最初出现时的内容非常相似。它包含一个空的CSS文件、基本的HTML模板、测试占位符以及已经初始化并带有组件注解的空类。
- en: We’ll start by setting up the template for our component and then we’ll create
    the controller to manage it. Open the src/app/components/summary/summary.component.html
    file and replace the contents with what you see in the following listing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置组件的模板，然后我们将创建控制器来管理它。打开`src/app/components/summary/summary.component.html`文件，将其内容替换为以下列表中的内容。
- en: '**Listing 2.6** Summary component template'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2.6** 摘要组件模板'
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The template contains some markup to structure the card like a material design
    card. If we look at the first line, we see this snippet as an attribute on the
    `div` element:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包含一些标记来结构化卡片，使其看起来像一张材料设计卡片。如果我们查看第一行，我们会看到这个片段作为`div`元素上的一个属性：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is a special kind of attribute called a directive. *Directives* allow you
    to modify the behavior and display of DOM elements in a template. Think of them
    as attributes on HTML elements that cause the element to change its behavior,
    such as the `disabled` attribute that disables an HTML input element. Directives
    make it possible to add some conditional logic or otherwise modify the way the
    template behaves or is rendered.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊类型的属性，称为指令。*指令*允许您修改模板中DOM元素的行为和显示。把它们想象成HTML元素上的属性，可以导致元素改变其行为，例如禁用HTML输入元素的`disabled`属性。指令使得添加一些条件逻辑或以其他方式修改模板的行为或渲染方式成为可能。
- en: The NgClass directive is able to add or remove CSS classes to and from the element.
    It’s assigned a value, which is an object that contains properties that are the
    CSS class names, and those properties map to a method on the controller (to be
    written). If the method returns true, it will add the class; if false, it will
    be removed. In this snippet, the card will get the `increase` CSS class when it’s
    positive, or the `decrease` CSS class when it’s negative, for the day’s trading.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: NgClass指令能够向元素添加或移除CSS类。它被分配了一个值，这个值是一个包含CSS类名的属性对象，这些属性映射到控制器上的一个方法（待编写）。如果方法返回true，它将添加该类；如果为false，它将被移除。在这个片段中，卡片在当天交易为正时将获得`increase`
    CSS类，在为负时将获得`decrease` CSS类。
- en: Angular has a few directives built in, and you’ll see a couple more in this
    chapter. Directives usually take an expression (like our object in this example),
    which is evaluated by Angular and passed to the directive. The expression might
    evaluate to a Boolean or other primitive value or resolve to a function call that
    would be run to return a value before the directive runs. Based on the value of
    the expression, the directive might do different things, such as show or hide
    whether the expression is true or false.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Angular内置了一些指令，您将在本章中看到更多。指令通常接受一个表达式（如本例中的我们的对象），该表达式由Angular评估并传递给指令。表达式可能评估为布尔值或其他原始值，或者解析为一个函数调用，该函数调用将在指令运行之前执行以返回一个值。根据表达式的值，指令可能会做不同的事情，例如根据表达式是true还是false来显示或隐藏。
- en: 'We saw an example of interpolation earlier, but we now have a more complex
    example that displays the symbol of the stock. The controller is expected to have
    a property called `stock`, which is an object with various values:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了一个插值的例子，但现在有一个更复杂的例子，用于显示股票的符号。控制器预期有一个名为`stock`的属性，它是一个包含各种值的对象：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The double curly braces syntax is the way to display some value in the page.
    This is called *interpolation*, if you’ll recall from earlier, though this is
    a bit more complex. The content between the braces is called an *Angular expression*
    and is evaluated against the controller (like the directive), meaning that it
    will try to find a property on the controller to display. If it fails, normally
    it will throw an error, but the safe navigation operator `?.` will silently fail
    and not display anything if the property is missing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号语法是显示页面中某些值的方式。这被称为*插值*，如果您还记得之前的内容，这要复杂一些。大括号之间的内容被称为*Angular表达式*，它将与控制器（如指令）进行评估，这意味着它将尝试在控制器上找到一个属性来显示。如果失败，通常它会抛出一个错误，但安全导航运算符`?.`将在属性缺失时静默失败，并且不会显示任何内容。
- en: This block will display the stock symbol, but as uppercase. Most JavaScript
    expressions are valid Angular expressions, though some things are different, such
    as the safe navigation operator. The ability to call prototype methods like `toUpperCase()`
    remains, and that’s how it’s able to render the text as uppercase.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块将显示股票符号，但为大写形式。大多数 JavaScript 表达式都是有效的 Angular 表达式，尽管有些事情是不同的，例如安全导航运算符。调用原型方法（如
    `toUpperCase()`）的能力仍然存在，这就是它能够将文本渲染为大写的原因。
- en: 'The next interpolation shows the last trade price and adds another feature
    called *pipes*, which are added directly into the expression to format the output.
    The interpolation expression is extended with a pipe symbol, `|`, and then a pipe
    is named and optionally configured with values separated with the colon `:` symbol.
    The price value comes back as a normal float (like 111.8), which is not the same
    format as currency, which should appear like $111.80:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个插值显示了最后交易价格，并添加了一个名为 *管道* 的另一个功能，这些管道直接添加到表达式中以格式化输出。插值表达式通过管道符号 `|` 扩展，然后通过冒号
    `:` 分隔的命名管道进行配置（可选）。价格值返回为普通浮点数（如 111.8），这与货币格式不同，货币应显示为 $111.80：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Pipes only modify the data before it is displayed, and do not change the value
    in the controller. In this code, the double curly braces indicate that you want
    to bind the data stored in the `stock.lastTradePriceOnly` property to display
    it. The data is piped through the Currency pipe, which converts the value into
    a financial figure based on a USD figure, and rounds to two decimal points. Now
    let’s look at the next line:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 管道只修改显示之前的数据，并不改变控制器中的值。在这段代码中，双大括号表示您希望将存储在 `stock.lastTradePriceOnly` 属性中的数据绑定以显示。数据通过货币管道传输，该管道根据美元数值将值转换为金融数字，并四舍五入到两位小数。现在让我们看看下一行：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The next line also has two different interpolation bindings with a Currency
    or Percentage pipe. The first will convert to the same currency format, but the
    second will take a percentage as a decimal, such as 0.06, and turn it into 6%.
    The Angular documentation can detail all the options available and how to use
    them for each pipe.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行也有两个不同的插值绑定，使用货币或百分比管道。第一个将转换为相同的货币格式，但第二个将百分比作为小数（如 0.06）转换成 6%。Angular
    文档可以详细说明所有可用的选项以及如何为每个管道使用它们。
- en: This template doesn’t work in isolation; it requires a controller to wire up
    the data and the methods. Let’s open the src/app/components/summary/summary.component.ts
    file and replace the code, as you see in the following listing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板单独不起作用；它需要一个控制器来连接数据和方法。让我们打开 `src/app/components/summary/summary.component.ts`
    文件，并替换您在以下列表中看到的代码。
- en: '**Listing 2.7** Summary component controller'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.7** 摘要组件控制器'
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This controller imports dependencies, which is almost always the first block
    of any file written in TypeScript. The component metadata describes the selector,
    linked styles, and linked template files that comprise the component. We’ll add
    some CSS to the styles in a moment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器导入依赖项，这几乎是任何用 TypeScript 编写的文件的第一个代码块。组件元数据描述了选择器、链接样式和链接模板文件，这些构成了组件。我们稍后将向样式添加一些
    CSS。
- en: 'The summary controller class starts with a property called `stock`, which is
    preceded with the `Input` annotation. This indicates that this property is to
    be provided to the component by a parent component passing it to the summary.
    Properties are bound to an element using an attribute, as you can see here—this
    example will set the value of `stockData` of the parent component in the `stock`
    property of the Summary component:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要控制器类以一个名为 `stock` 的属性开始，该属性前带有 `Input` 注解。这表示此属性将由父组件提供，并将其传递给摘要。属性通过属性绑定到元素，如您在此处所见——此示例将设置父组件的
    `stockData` 的值在摘要组件的 `stock` 属性中：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because input is passed through a binding attribute, it will evaluate the expression
    and pass it into that property for the Summary component to consume. Angular expressions
    behave the same anytime there’s a binding. They try to find a corresponding value
    in the controller to bind to the property.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输入是通过绑定属性传递的，所以它将评估表达式并将其传递到该属性中，以便摘要组件可以消费。Angular 表达式在存在绑定时表现相同。它们试图在控制器中找到对应值以绑定到属性。
- en: Lastly, there are the two methods for checking whether the stock value is positive
    or negative. The stock could also be neutral, so that’s the default state, and
    only if the stock changes will one of the methods return `true`. These methods
    are used by the NgClass directive to determine whether it should add a particular
    CSS class, as described earlier in the template.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个方法用于检查股票值是正数还是负数。股票也可能是中性的，所以这是默认状态，只有当股票发生变化时，其中一个方法才会返回 `true`。这些方法由
    NgClass 指令使用，如模板中之前所述，以确定是否添加特定的 CSS 类。
- en: The final piece we want to add are the CSS classes themselves. Angular has some
    interesting ways to encapsulate CSS styles so they only apply to a single component.
    We’ll dig into the specifics later, but open the src/app/components/summary/summary.component.css
    file and add the styles, as shown in the following listing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的最后部分是 CSS 类本身。Angular 有一些有趣的方式来封装 CSS 样式，以确保它们只应用于单个组件。我们稍后会深入探讨具体细节，但请打开
    src/app/components/summary/summary.component.css 文件，并添加样式，如下面的列表所示。
- en: '**Listing 2.8** Summary component CSS styles'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.8** 摘要组件 CSS 样式'
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is typical CSS, though you may not have seen or used the `:host` selector
    in the past. Because components need to be as self-contained as possible, they
    rely on the Shadow DOM concepts discussed in chapter 1\. When Angular renders
    this component, it will modify the output to ensure that the CSS selector is unique
    and doesn’t accidentally interfere with other elements on the page. This behavior
    is configurable, but that will be covered later.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的 CSS，尽管你可能以前没有见过或使用过 `:host` 选择器。因为组件需要尽可能自包含，它们依赖于第 1 章中讨论的 Shadow DOM
    概念。当 Angular 渲染此组件时，它会修改输出以确保 CSS 选择器是唯一的，并且不会意外地干扰页面上的其他元素。这种行为是可以配置的，但稍后我们会介绍。
- en: The host selector is a way to specify that you want the styles to apply to the
    element that hosts the element, so in this case it will look at the Summary component
    element itself rather than the contents inside it. The primary purpose of the
    CSS here is to establish the Summary component background color.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 主选择器是一种指定您希望样式应用于宿主元素的途径，因此在这种情况下，它将查看摘要组件元素本身，而不是其内容。这里 CSS 的主要目的是确定摘要组件的背景颜色。
- en: We’ve walked through the Summary component generation and built out a functional
    component. Let’s quickly use it to get a glimpse of how it behaves.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走过了摘要组件的生成过程，并构建了一个功能组件。让我们快速使用它来了解一下它的行为。
- en: Look at the src/app/app.module.ts file and you’ll see that the CLI already modified
    the module to include the Summary component in the App module. There’s nothing
    to do here, but I wanted to point it out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 查看src/app/app.module.ts 文件，你会看到 CLI 已经修改了模块，使其包含在 App 模块中的摘要组件。这里没有需要做的事情，但我想要指出这一点。
- en: Now look at src/app/app.component.ts and update it to the contents of the following
    listing. This will include the Stocks service and use it to store the stock data
    onto a property. We’ll then use this to display the summary card.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看 src/app/app.component.ts 并更新为以下列表的内容。这将包括股票服务，并使用它将股票数据存储到属性中。然后我们将使用它来显示摘要卡片。
- en: '**Listing 2.9** App component controller'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.9** 应用组件控制器'
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here we store the loaded stock data onto a property called `stocks`. We also
    provide some typing information, which is imported from our Stocks service, so
    that TypeScript knows what kind of value to expect. Finally, instead of logging
    the data to the console, we store it on the `stocks` property.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将加载的股票数据存储在一个名为 `stocks` 的属性中。我们还提供了一些类型信息，这些信息是从我们的股票服务中导入的，这样 TypeScript
    就知道期望什么类型的值。最后，我们不是将数据记录到控制台，而是将其存储在 `stocks` 属性中。
- en: 'Now we’ll need to update the src/app/app.component.html file to use the Summary
    component. Here is the snippet you need to update from the template:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 src/app/app.component.html 文件以使用摘要组件。以下是您需要从模板中更新的片段：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first line added `*ngIf="stocks"`, which is a directive that will only render
    the contents inside the element when the expression is true. In this case, it
    won’t render the Summary component until the stock data has been loaded.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的第一行是 `*ngIf="stocks"`，这是一个指令，只有当表达式为真时才会渲染元素内的内容。在这种情况下，它不会渲染摘要组件，直到股票数据被加载。
- en: The middle line shows the instantiation of a single Summary component, and the
    first value of the `stocks` array is bound into the `stock` property. The data
    returns as an array, so we’re directly accessing the first value. Recall the input
    value we declared in the Summary component, which is also named `stock`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 中间行显示了单个摘要组件的实例化，`stocks`数组的第一个值绑定到`stock`属性上。数据以数组形式返回，因此我们直接访问第一个值。回想一下在摘要组件中声明的输入值，它也命名为`stock`。
- en: Once you save this and run the app, it should finally display a single summary
    card with the current stock data for Apple’s stock. We’ve made our first component
    and displayed it inside our application!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并运行应用后，它应该最终显示一张包含苹果股票当前数据的单个摘要卡片。我们已经创建了第一个组件，并在应用内部显示了它！
- en: Next you’ll create another component and use it together with the Summary component
    to create the dashboard that displays the list of stocks and their current statuses.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建另一个组件，并将其与摘要组件一起使用，以创建显示股票列表及其当前状态的仪表板。
- en: 2.7 Components that use components and services
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 使用组件和服务的组件
- en: We’re ready to combine the previously created Summary component and Stocks service
    into a working Dashboard component. This component will comprise one entire page
    of the application, as you see in [figure 2.6](#figure2.6). This component will
    manage the loading of the data using the Stocks service and then display each
    stock using a copy of the Summary component.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好将之前创建的摘要组件和股票服务合并成一个可工作的仪表板组件。这个组件将包含应用的一个完整页面，正如你在[图2.6](#figure2.6)中看到的那样。这个组件将使用股票服务来管理数据的加载，然后使用摘要组件的副本显示每一支股票。
- en: '![c02-6.png](image_fi/293313c02/c02-6.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![c02-6.png](image_fi/293313c02/c02-6.png)'
- en: '[**Figure 2.6**](#figureanchor2.6) Dashboard component wired up with loading
    data and showing five Summary component instances'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图2.6**](#figureanchor2.6) 仪表板组件连接了加载数据并显示五个摘要组件实例'
- en: 'We’ll see how to properly orchestrate a complete view, rather than our isolated
    examples so far. To get started, we can use the CLI again to generate another
    component:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何正确地编排一个完整的视图，而不是我们迄今为止的孤立示例。要开始，我们可以再次使用CLI来生成另一个组件：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This will output new files into the src/app/components/dashboard directory
    for the HTML, CSS, controller, and unit test. It also adds the component to the
    App module to be immediately consumable. Let’s reset our working project to display
    this new component by modifying the src/app/app.component.html file with the content
    here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`src/app/components/dashboard`目录中输出新的HTML、CSS、控制器和单元测试文件。它还将组件添加到App模块中，使其立即可使用。让我们通过修改`src/app/app.component.html`文件中的内容来重置我们的工作项目，以显示这个新组件：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should display the default component message in the application, since
    that’s the default code generated by the CLI. We also need to remove some logic
    from the App component controller; it should now appear as you see here. This
    removes the imports and loading of stock data in the App component itself, and
    we’ll put it instead into the dashboard in a moment. Replace the contents of src/app/app.component.ts
    with the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示应用中的默认组件消息，因为这是CLI生成的默认代码。我们还需要从应用组件控制器中移除一些逻辑；它现在应该看起来像这里所示。这移除了应用组件本身中的导入和股票数据的加载，我们将在稍后将其放入仪表板中。将`src/app/app.component.ts`的内容替换为以下内容：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Great! We’ve now cleaned up the App component and are ready to start building
    out the dashboard. Our first order of business is to set up the dashboard controller.
    Its job is to use the Stocks service to load data and make it available for the
    component to consume.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经清理了应用组件，准备开始构建仪表板。我们的首要任务是设置仪表板控制器。它的任务是使用股票服务来加载数据，并使其可供组件使用。
- en: Open the controller at src/app/components/dashboard/dashboard.component.ts and
    replace it with the code in the following listing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`src/app/components/dashboard/dashboard.component.ts`控制器，并用以下列表中的代码替换它。
- en: '**Listing 2.10** Dashboard controller'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2.10** 仪表板控制器'
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The controller starts by importing the `Component` annotation and the `OnInit`
    interface. If you haven’t implemented an interface before, an interface is a means
    to enforce that a class contains a required method—in this case, the method named
    `ngOnInit`. Leveraging TypeScript’s capabilities for enforcing code typings and
    interfaces is helpful as projects get larger.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器首先导入 `Component` 注解和 `OnInit` 接口。如果你之前没有实现接口，接口是一种强制类包含所需方法的手段——在这种情况下，名为
    `ngOnInit` 的方法。随着项目规模的增大，利用 TypeScript 强制代码类型和接口的能力是有帮助的。
- en: 'The `DashboardComponent` class is the component controller, and it declares
    that it must implement the requirements of `OnInit`. If it doesn’t, TypeScript
    will fail to compile the code and throw an error. It then has two properties:
    an array of stocks and an array of strings that represent the stock symbols to
    display. Initially they’re empty arrays, so we’ll need to get them loaded for
    the component to render.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`DashboardComponent` 类是组件控制器，它声明必须实现 `OnInit` 的要求。如果不实现，TypeScript 将无法编译代码并抛出错误。它有两个属性：一个股票数组和一个表示要显示的股票符号的字符串数组。最初它们是空数组，因此我们需要将它们加载以使组件能够渲染。'
- en: The `constructor` method runs as soon as the component is created. It will import
    the Stocks service onto the `service` property and then request the current list
    of stock symbols from it. This works because this is a synchronous action that
    loads a value directly from memory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor` 方法在组件创建时立即运行。它将 Stocks 服务导入到 `service` 属性，然后从它请求当前的股票符号列表。这是因为这是一个同步操作，直接从内存中加载一个值。'
- en: But we don’t load data from the service in the constructor for a number of reasons.
    We’ll dig into the complexities later in the book, but the primary reason is due
    to the way that components are rendered. The constructor fires early in the rendering
    of a component, which means that often, values are not yet ready to be consumed.
    Components expose a number of lifecycle hooks that allow you to execute commands
    at various stages of rendering, giving you greater control over when things occur.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不会在构造函数中从服务加载数据，原因有很多。我们将在本书的后面深入探讨这些复杂性，但主要原因是由于组件的渲染方式。构造函数在组件渲染的早期阶段触发，这意味着通常，值还没有准备好被消费。组件暴露了多个生命周期钩子，允许你在渲染的各个阶段执行命令，从而让你对何时发生事件有更大的控制权。
- en: In our code, we use the `ngOnInit` lifecycle hook to call the service to load
    the stock data. It uses the list of stock symbols that was loaded in the constructor.
    We then subscribe to wait for the results to return and store them in the `stocks`
    property. This uses the observable approach to handling asynchronous requests.
    We’ll look at observables in depth later as well. Here we are using them because
    the HttpClient returns an observable for us to receive the response. This is exposed
    as a stream of data, even though it is a single event.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用 `ngOnInit` 生命周期钩子调用服务来加载股票数据。它使用在构造函数中加载的股票符号列表。然后我们订阅等待结果返回并将它们存储在
    `stocks` 属性中。这使用了处理异步请求的可观察方法。我们将在稍后深入探讨可观察对象。这里我们使用它们是因为 HttpClient 为我们返回了一个可观察对象，以便接收响应。尽管它是一个单一的事件，但它被暴露为一个数据流。
- en: Now we need to complete the component by adding the template. Open the src/app/components/dashboard/dashboard.component.html
    file and replace it with the contents of the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过添加模板来完成组件。打开 src/app/components/dashboard/dashboard.component.html 文件，并用以下列表的内容替换它。
- en: '**Listing 2.11** Dashboard component template'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.11** Dashboard 组件模板'
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The template has some classes to use the Material Design Lite UI framework for
    a grid structure. The template contains another NgIf attribute to show a loading
    message while the data is loaded, like we used earlier. Once the stock data has
    returned from the API, the loading message will be hidden.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包含一些类，用于使用 Material Design Lite UI 框架的网格结构。模板还包含另一个 NgIf 属性，在加载数据时显示加载消息，就像我们之前使用的那样。一旦股票数据从
    API 返回，加载消息将被隐藏。
- en: Then we see another element that has a new directive, NgFor. Like NgIf, it starts
    with an `*`, and the expression is similar to what you would use in a traditional
    JavaScript `for` loop. The expression contains `let stock of stocks`, which means
    that it will loop over each of the items in the `stocks` array and expose a local
    variable by the name of `stock`. Again, this is the same kind of behavior that
    you would see in a JavaScript `for` loop, but applied in the context of HTML elements.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到另一个具有新指令NgFor的元素。像NgIf一样，它以`*`开头，表达式类似于你会在传统的JavaScript `for`循环中使用的表达式。表达式包含`let
    stock of stocks`，这意味着它将遍历`stocks`数组中的每个项目，并通过名为`stock`的局部变量暴露它。再次强调，这是你在JavaScript
    `for`循环中会看到的行为，但应用于HTML元素上下文中。
- en: NgFor will then create an instance of the Summary component for each of the
    stock items. It binds the stock data into the component. Each copy of the Summary
    component is distinct from the others, and they don’t directly share data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: NgFor将为每个股票项目创建Summary组件的一个实例。它将股票数据绑定到组件中。每个Summary组件的副本与其他组件不同，并且它们不会直接共享数据。
- en: You’ve now completed the dashboard view, which uses a service and another component
    to render the experience. When you run the application now, you should see the
    five default stocks appearing as separate cards in the page. The grid layout should
    lay them out in four columns.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了仪表板视图，它使用服务和另一个组件来渲染体验。当你现在运行应用程序时，你应该看到五个默认股票作为页面上的单独卡片出现。网格布局应该将它们排列成四列。
- en: Next you’ll build a new component that has a form that manages the list of stock
    symbols to use when displaying the stocks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将构建一个新的组件，该组件具有一个表单，用于管理在显示股票时使用的股票符号列表。
- en: 2.8 Components with forms and events
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 带有表单和事件的组件
- en: We want to manage the stocks that are displayed, so we’ll need to add another
    component that has a form to edit the list of stocks ([figure 2.7](#figure2.7)).
    This form will allow users to input new stock symbols to add to the list and will
    have a list of the current stocks with a button that will remove a stock from
    the list. This list of stocks is shared throughout the entire application, so
    any changes will replicate elsewhere.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要管理显示的股票，因此我们需要添加另一个具有用于编辑股票列表的表单的组件（[图2.7](#figure2.7)）。此表单将允许用户输入要添加到列表中的新股票符号，并将有一个当前股票列表，其中包含一个按钮，可以从中删除股票。这个股票列表在整个应用程序中共享，因此任何更改都会在其他地方复制。
- en: '![c02-7.png](image_fi/293313c02/c02-7.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![c02-7.png](image_fi/293313c02/c02-7.png)'
- en: '[**Figure 2.7**](#figureanchor2.7) Manage component with a form to add an item
    and buttons to remove existing stocks'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图2.7**](#figureanchor2.7) 具有用于添加项目并删除现有股票按钮的Manage组件'
- en: Forms are essential in applications, and Angular comes with built-in support
    for building complex forms with many features. Forms in Angular are comprised
    of any number of *controls*, which are the various types of inputs and fields
    the form may contain (such as a text input, a checkbox, or some custom element).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表单在应用程序中至关重要，Angular自带内置支持用于构建具有许多功能的复杂表单。Angular中的表单由任意数量的*控件*组成，这些控件是表单可能包含的各种输入和字段（如文本输入、复选框或某些自定义元素）。
- en: 'Let’s start by generating a new component for the manage view. Using the CLI,
    run the following command, and remember, this will also automatically register
    the component with the App module so it’s ready to consume:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从生成用于管理视图的新组件开始。使用CLI运行以下命令，并记住，这将自动将组件注册到App模块中，使其准备好使用：
- en: '[PRE78]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now update the src/app/app.component.html file and change the content of the
    main element, as you see in the following code, so the Manage component will display
    in the application. Then when you run the application, it will display the default
    message you see with any new component:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新src/app/app.component.html文件，并更改主元素的内容，如以下代码所示，以便Manage组件在应用程序中显示。然后当你运行应用程序时，它将显示任何新组件的默认消息：
- en: '[PRE79]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We also need to add the `FormsModule` to our application, because we are going
    to use the form features that aren’t automatically included by Angular. Open up
    the src/app/app.module.ts file and add a new import:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`FormsModule`添加到我们的应用程序中，因为我们将要使用Angular自动包含的表单功能。打开src/app/app.module.ts文件并添加一个新的导入：
- en: '[PRE80]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then update the imports definition of the module to declare the `FormsModule`
    like you see here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更新模块的导入定义，声明`FormsModule`，如下所示：
- en: '[PRE81]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let’s start making our Manage component by updating the controller with some
    logic. In [figure 2.7](#figure2.7), you’ll see we need to load the list of symbols
    stored in memory. There will also need to be two methods: one to handle the removal
    of a stock and another to add a new stock symbol to the list.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始制作我们的 Manage 组件，通过更新控制器添加一些逻辑。在 [图 2.7](#figure2.7) 中，你会看到我们需要加载存储在内存中的符号列表。还需要有两个方法：一个用于处理股票的删除，另一个用于将新的股票符号添加到列表中。
- en: Open src/app/components/manage/manage.component.ts and update it to match the
    following listing. This will comprise the additional methods and setup required
    for this view.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/app/components/manage/manage.component.ts 并更新它以匹配以下列表。这将包括为该视图所需的额外方法和设置。
- en: '**Listing 2.12** Manage component controller'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.12** Manage 组件控制器'
- en: '[PRE82]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As usual, we start by importing dependencies for the component. Then the component
    metadata is declared using the `@Component` annotation. The `class` object is
    then declared, which contains two properties: the first is the array of symbols
    that’s retrieved from the Stocks service, and the second is a property to hold
    the value of the input. We’ll see how the `stock` property is linked to the input
    field in the template, but this is where it’s first defined.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们首先导入组件的依赖项。然后使用 `@Component` 注解声明组件元数据。接着声明 `class` 对象，其中包含两个属性：第一个是从股票服务检索到的符号数组，第二个是用于存储输入值的属性。我们将在模板中看到
    `stock` 属性是如何与输入字段关联的，但这是它首次定义的地方。
- en: The constructor uses the service to get the array of stock symbols and store
    it on the `symbols` property. This doesn’t require the `OnInit` lifecycle hook,
    because it’s a synchronous request to get data that exists in memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用服务获取股票符号数组并将其存储在 `symbols` 属性上。这不需要 `OnInit` 生命周期钩子，因为它是对内存中存在的数据进行同步请求。
- en: Then we have the two methods to add or remove the symbols from the list. The
    service always returns a copy of the `stocks` symbol array, so we have to use
    the service methods to manage the list (which is encapsulated inside the service
    and isn’t directly modifiable). The `add` method will add a new item to the list
    of symbols, and then store the modified list onto the symbols list. Conversely,
    the `remove` method will remove the item from the array and refresh the symbols
    list in the controller.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有两个方法用于向列表中添加或删除符号。服务始终返回 `stocks` 符号数组的副本，因此我们必须使用服务方法来管理列表（该列表封装在服务中，不能直接修改）。`add`
    方法将向符号列表添加新项，然后将修改后的列表存储到符号列表中。相反，`remove` 方法将从数组中删除项并刷新控制器中的符号列表。
- en: This controller satisfies our needs for handling the actions of the form, but
    now we need to create the template to display the form and its contents. Open
    src/app/components/manage/manage.component.html and add the contents from the
    following listing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器满足了处理表单操作的需求，但现在我们需要创建模板来显示表单及其内容。打开 src/app/components/manage/manage.component.html
    并添加以下列表中的内容。
- en: '**Listing 2.13** Manage component template'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 2.13** Manage 组件模板'
- en: '[PRE89]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this template there’s a decent amount of markup only for the grid layout.
    Any class that starts with `mdl-` is part of the styles provided by Material Design
    Lite’s grid and UI library.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，只有相当数量的标记用于网格布局。任何以 `mdl-` 开头的类都是 Material Design Lite 的网格和 UI 库提供的样式的一部分。
- en: The first interesting section is the form, which has a new type of attribute
    we haven’t seen before. The `(submit)="add()"` attribute is a way to add an event
    listener, known as an *event binding*. When the form is submitted (which is done
    by pressing Enter), it will call the `add` method. Any attribute that’s surrounded
    by parentheses is an event binding, and the name of the event should match the
    event without the *on* (`onsubmit` is `submit`).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有趣的章节是表单，它有一个我们之前没有见过的属性类型。`(submit)="add()"` 属性是添加事件监听器的方式，称为 *事件绑定*。当表单提交时（通过按
    Enter 键完成），它将调用 `add` 方法。任何被括号包围的属性都是事件绑定，事件名称应与不带 *on* 的事件名称匹配（`onsubmit` 是 `submit`）。
- en: The form contains a single input element, which has another new type of attribute.
    The `[(ngModel)]="stock"` attribute is a two-way binding that will sync the value
    of the input and the value of the property in the controller anytime it changes
    from either location. This way, as the user types into the text field, the value
    will be immediately available for the controller to consume. When the user hits
    Enter, the `submit` event fires and will use the value of the `stock` property
    when adding the new symbol. I cover form concepts in greater detail later, but
    this is your first preview of how a simple form is constructed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 表单包含一个单独的输入元素，它还有一个新的属性类型。`[(ngModel)]="stock"`属性是一个双向绑定，它将在输入值或控制器中的属性值发生变化时同步两者的值。这样，当用户在文本字段中键入时，值将立即对控制器可用。当用户按下Enter键时，`submit`事件触发，并使用`stock`属性的值添加新的符号。我将在稍后更详细地介绍表单概念，但这是您对简单表单构建的第一次预览。
- en: The next section loops over the list of symbols using NgFor. I covered how this
    works earlier, so I won’t go into detail. For each symbol, it will create a local
    variable called `symbol`, create a new table row that binds the value, and a button
    that’s for removing the item.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分使用NgFor遍历符号列表。我之前已经介绍了它是如何工作的，所以这里不再详细说明。对于每个符号，它将创建一个名为`symbol`的局部变量，创建一个新的表格行以绑定值，以及一个用于删除项目的按钮。
- en: The `remove` button contains another event binding, this one to handle the click
    event. The `(click)="remove(symbol)"` attribute adds an event listener to the
    click event and will call the `remove` method in the controller, passing along
    the symbol. Because there are multiple instances of the button, each one passes
    along the local variable to know which symbol to remove.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`按钮包含另一个事件绑定，这次是处理点击事件。`(click)="remove(symbol)"`属性向点击事件添加了一个事件监听器，并将调用控制器中的`remove`方法，传递符号。因为按钮有多个实例，每个实例都会传递局部变量，以便知道要删除哪个符号。'
- en: The last task is to add routing to the application to activate routes for the
    two views to act like two different pages.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务是为应用程序添加路由，以激活两个视图的路由，使其像两个不同的页面一样操作。
- en: 2.9 Application routing
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 应用程序路由
- en: The final piece of the application is the *routing*, which configures the different
    pages that the application can render. Most applications need some form of routing
    so it can display the correct part of the application at the expected time. Angular
    has a router that works well with the Angular architecture by mapping components
    to routes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最后一部分是*路由*，它配置了应用程序可以渲染的不同页面。大多数应用程序都需要某种形式的路由，以便在预期的时间显示应用程序的正确部分。Angular有一个与Angular架构配合良好的路由器，通过将组件映射到路由。
- en: The router works by declaring an outlet in the template, which is the place
    in the template that the final rendered component will be displayed. Think of
    the outlet as the default placeholder for the content, and until the content is
    ready to be displayed, it will be empty.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器通过在模板中声明一个出口来工作，这是最终渲染的组件将被显示的地方。将出口视为内容的默认占位符，直到内容准备好显示，它将是空的。
- en: To set up our routes, we’ll link the Manage and Dashboard components to two
    routes. We’ll handle the configuration ourselves, because the CLI doesn’t support
    setting up routes in this particular release. To begin, create a new file at src/app/app.routes.ts
    and fill it with the code from the following listing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的路由，我们将管理组件和仪表板组件链接到两个路由。我们将自己处理配置，因为CLI不支持在此特定版本中设置路由。首先，在`src/app/app.routes.ts`创建一个新文件，并用以下列表中的代码填充它。
- en: '**Listing 2.14** App routing configuration'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表2.14** 应用程序路由配置'
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This file’s main purpose is to configure the routes for the application, and
    we start by importing the `RouterModule` and the Route type definition. The `RouterModule`
    is used to activate the router and accepts the routes configuration when it’s
    initialized. We also import the two routable components, the Dashboard and Manage
    components, so we can reference them properly in our routes configuration.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的主要目的是配置应用程序的路由，我们首先导入`RouterModule`和路由类型定义。`RouterModule`用于激活路由器，并在初始化时接受路由配置。我们还导入了两个可路由组件，即仪表板和管理组件，这样我们就可以在路由配置中正确地引用它们。
- en: The routes are defined as an array of objects that have at least one property—in
    this case two, for a URL path and a component. For the first route, there’s no
    path, so it acts as the application index (which will be http://localhost:4200)
    and links to the Dashboard component. The second route provides a URL path of
    manage (which will be http://localhost:4200/manage) and links to the Manage component.
    This is the most likely type of routing that you’ll do with Angular, though there
    are many ways to configure and nest routes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 路由被定义为对象数组，这些对象至少有一个属性——在本例中是两个，一个是URL路径，一个是组件。对于第一个路由，没有路径，因此它充当应用程序索引（将是http://localhost:4200），并链接到仪表板组件。第二个路由提供了一个URL路径为manage（将是http://localhost:4200/manage），并链接到管理组件。这可能是你用Angular做的最常见类型的路由，尽管有许多配置和嵌套路由的方法。
- en: Finally, we create a new value `AppRoutes`, which is assigned to the result
    of `RouterModule.forRoot(routes)`. We’ll dig further into how the `forRoot` method
    behaves later, but it’s a way to pass configuration to the module. In this case,
    we’re passing the array of routes. We export this so we can import it into our
    App module and register it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个新的值`AppRoutes`，它被分配给`RouterModule.forRoot(routes)`的结果。我们将在稍后进一步探讨`forRoot`方法的行为，但这是一个向模块传递配置的方法。在这种情况下，我们传递了路由数组。我们导出这个值，以便我们可以将其导入到我们的App模块中并注册它。
- en: 'Open the src/app/app.module.ts file and add a new line at the end of the imports
    that imports the `AppRoutes` object you created in the previous file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 打开src/app/app.module.ts文件，并在导入的末尾添加一行新行，导入你在上一个文件中创建的`AppRoutes`对象：
- en: '[PRE99]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now update the `imports` property of your module to include the `AppRoutes`
    object. This will register the Router module and our configuration with our application:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新模块的`imports`属性，以包含`AppRoutes`对象。这将注册路由器模块和我们的配置到应用程序中：
- en: '[PRE100]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The final step is to declare a place for the router to render, and update the
    links to use the router to navigate. Open the src/app/app.component.html file
    one last time and make a few modifications. First you’ll change the contents of
    the main element to have a different element, the router outlet:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是声明一个路由器渲染的位置，并更新链接以使用路由器进行导航。最后一次打开src/app/app.component.html文件，进行一些修改。首先，你将更改主元素的内容，使其包含一个不同的元素，即路由器出口：
- en: '[PRE101]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This declares the specific location in the application that the router should
    render the component. It’s the same place that we’ve put our components while
    building them, so it should make sense that this is the best place.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了路由器应在应用程序中渲染组件的具体位置。这正是我们在构建组件时放置组件的地方，因此应该很清楚这是最佳位置。
- en: 'Then we need to update the links to use a new directive that will set up the
    navigation between routes. The RouterLink directive binds to an array of paths
    that are used to build a URL:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要更新链接以使用一个新的指令来设置路由之间的导航。RouterLink指令绑定到一个路径数组，用于构建URL：
- en: '[PRE102]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The directive parses the array and tries to match to a known route. Once it
    matches a route, it will add an `href` to the anchor tag that correctly links
    to that route.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 指令解析数组并尝试匹配已知路由。一旦匹配到路由，它将向锚标签添加一个`href`属性，以正确链接到该路由。
- en: The router is capable of more advanced configuration, such as nested routes,
    accepting parameters, and having multiple outlets. I cover the router in more
    detail in chapter 7\.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器能够进行更高级的配置，例如嵌套路由、接受参数和拥有多个出口。我将在第7章中更详细地介绍路由器。
- en: Now your project is complete, and you can reload the application in the browser
    to see it running, as previewed earlier. Congratulations! You’ve got a working
    Angular app running, and now you can try to make it do some more things.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已完成，你可以在浏览器中重新加载应用程序以查看其运行，如之前预览的那样。恭喜！你已经运行了一个有效的Angular应用程序，现在你可以尝试让它做更多的事情。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Congratulations on making it through a functional Angular app! We went through
    a lot of Angular features quickly, but you should now have an understanding of
    how various parts are assembled into an app. Here is a quick recap of the primary
    takeaways:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了一个功能性的Angular应用程序！我们快速地介绍了许多Angular功能，但你现在应该了解如何将各个部分组装成一个应用程序。以下是一些主要收获的快速回顾：
- en: Angular apps are components that contain a tree of components. The root app
    is bootstrapped on page load to initialize the application.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular应用程序是包含组件树的组件。根应用程序在页面加载时启动以初始化应用程序。
- en: A component is an ES6 class with an `@Component` annotation that adds metadata
    to the class for Angular to properly render it.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是一个带有 `@Component` 注解的 ES6 类，它为 Angular 添加了元数据以便正确渲染该类。
- en: Services are also ES6 modules and should be designed for portability. Any ES6
    class could be used, even if it isn’t specifically meant for Angular.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务也是 ES6 模块，并且应该设计为可移植性。任何 ES6 类都可以使用，即使它不是专门为 Angular 设计的。
- en: Directives are attributes that modify the template in some way, such as NgIf,
    which conditionally shows or hides the DOM element based on the value of an expression.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令是修改模板的属性，例如 NgIf，它根据表达式的值有条件地显示或隐藏 DOM 元素。
- en: Angular has built-in form support that includes the ability to automatically
    validate, group, and bind data with any form control, as well as use events.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 内置了表单支持，包括自动验证、分组以及将数据绑定到任何表单控件的能力，以及使用事件。
- en: Routing in Angular is based around paths mapping to a component. Routes will
    render a single component, and that component will also be able to render any
    additional components it needs.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 中的路由是基于路径映射到组件的。路由将渲染单个组件，并且该组件也将能够渲染它需要的任何附加组件。
