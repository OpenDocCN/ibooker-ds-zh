- en: 2 Getting started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 开始
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Assembling and configuring the core hardware and software of the robot
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装和配置机器人的核心硬件和软件
- en: Controlling the Neopixel color and brightness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制 Neopixel 的颜色和亮度
- en: Reading sensor data from the four onboard touch sensors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从四个板载触摸传感器读取传感器数据
- en: Controlling DC motors with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 控制 DC 电机
- en: Creating your first Python robotics program that interacts with sensors and
    motors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个与传感器和电机交互的 Python 机器人程序
- en: In this chapter, you will learn how to connect and configure the main hardware
    and software components used for the robots in this book. Once the hardware and
    software are set up, we’ll get straight into interacting with the hardware using
    Python by reading sensor data from the onboard touch sensors. Then, you will learn
    how to control the Neopixel lights and a DC motor. Finally, all these different
    hardware components and Python scripts will come together to create a robotics
    program that controls the Neopixel and DC motors based on touch sensor input.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何连接和配置本书中机器人使用的主要硬件和软件组件。一旦硬件和软件设置完成，我们将通过从板载触摸传感器读取传感器数据，直接使用 Python
    与硬件交互。然后，你将学习如何控制 Neopixel 灯和 DC 电机。最后，所有这些不同的硬件组件和 Python 脚本将结合在一起，创建一个基于触摸传感器输入控制
    Neopixel 和 DC 电机的人工智能程序。
- en: 2.1 Introducing our robotic hardware
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍我们的机器人硬件
- en: Figure 2.1 shows the hardware stack discussed in the previous chapter, with
    the specific components used in this chapter highlighted in the boxes with darker
    text. The components with grayed-out text will be used in later chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 展示了前一章讨论的硬件堆栈，本章中使用的特定组件以较暗的文本框突出显示。带有灰色文本的组件将在后续章节中使用。
- en: '![](../Images/CH02_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_Alsabbagh.png)'
- en: 'Figure 2.1 Hardware stack: the Raspberry Pi will handle network communication
    using Ethernet and Wi-Fi.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 硬件堆栈：Raspberry Pi 将使用以太网和 Wi-Fi 处理网络通信。
- en: The Linux operating system will be installed on the Raspberry Pi. The Ethernet
    and Wi-Fi hardware components will be used to connect the machine to the network
    and allow other computers on the network to connect to it. The CRICKIT HAT will
    then be connected to the Raspberry Pi and used to control the Neopixel and attached
    motor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统将安装在 Raspberry Pi 上。以太网和 Wi-Fi 硬件组件将被用于将机器连接到网络，并允许网络上的其他计算机连接到它。然后，CRICKIT
    HAT 将连接到 Raspberry Pi 并用于控制 Neopixel 和连接的电机。
- en: Make sure to check the hardware purchasing guide found in appendix A before
    buying the hardware needed in this chapter. The appendix shows which hardware
    is needed for the different chapters and also has some recommendations for optional
    purchases that can improve robot projects. Appendix B provides detailed instructions
    for the installation and configuration of the Raspberry Pi and Adafruit CRICKIT
    HAT. It is also worth noting that appendix D provides a mechanism to mock the
    robotic hardware and run any code in the book on any laptop or desktop computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在购买本章所需的硬件之前，请务必检查附录 A 中的硬件购买指南。附录显示了不同章节所需的硬件，还有一些可选购买的推荐，这些推荐可以改善机器人项目。附录
    B 提供了安装和配置 Raspberry Pi 和 Adafruit CRICKIT HAT 的详细说明。还值得注意的是，附录 D 提供了一种模拟机器人硬件的机制，可以在任何笔记本电脑或台式计算机上运行本书中的任何代码。
- en: 2.1.1 Raspberry Pi
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 Raspberry Pi
- en: 'The Raspberry Pi is a small single-board computer created by the Raspberry
    Pi Foundation ([https://raspberrypi.org](https://raspberrypi.org)). The Raspberry
    Pi 4 with 2 GB or more of RAM is the recommended model to use for the projects.
    Figure 2.2 shows a photo of the Raspberry Pi 4 for reference. The attributes of
    these computers that make them an ideal choice for robotics projects are the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 是由 Raspberry Pi 基金会创建的小型单板计算机 ([https://raspberrypi.org](https://raspberrypi.org))。建议使用具有
    2 GB 或更多 RAM 的 Raspberry Pi 4 模型。图 2.2 展示了 Raspberry Pi 4 的照片以供参考。这些计算机的以下属性使它们成为机器人项目的理想选择：
- en: Their small size and lightweight structure are important for mobile robots.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的小尺寸和轻质结构对移动机器人很重要。
- en: Running Linux and Python opens the door to a wide array of powerful software
    to build robot projects on.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Linux 和 Python 为在机器人项目上构建强大的软件打开了大门。
- en: Versatile robot chassis kits compatible with the Raspberry Pi allow different
    configurations of board, motor, and battery.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Raspberry Pi 兼容的多功能机器人底盘套件允许不同的板、电机和电池配置。
- en: Powerful CPU and memory make intensive applications such as real-time computer
    vision and machine learning possible.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的CPU和内存使得实时计算机视觉和机器学习等密集型应用成为可能。
- en: Good camera support allows the robots to see their environment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的相机支架使机器人能够看到其环境。
- en: They have built-in and flexible connectivity options such as Ethernet, Wi-Fi,
    Bluetooth, and USB.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有内置和灵活的连接选项，如以太网、Wi-Fi、蓝牙和USB。
- en: A general-purpose input/output (GPIO) connector provides a powerful mechanism
    to add hardware features to the board utilized by the Adafruit CRICKIT.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用输入/输出（GPIO）连接器为Adafruit CRICKIT所使用的电路板提供了强大的机制，以添加硬件功能。
- en: '![](../Images/CH02_F02_Alsabbagh.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F02_Alsabbagh.png)'
- en: 'Figure 2.2 Raspberry Pi: the main hardware interfaces on the board are labeled.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 树莓派：电路板上的主要硬件接口已标注。
- en: 2.1.2 Adafruit CRICKIT HAT
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 Adafruit CRICKIT HAT
- en: 'The Adafruit CRICKIT HAT is a hardware add-on for the Raspberry Pi created
    by Adafruit Industries ([https://adafruit.com](https://adafruit.com); figure 2.3).
    The CRICKIT HAT connects to the GPIO connector on the Raspberry Pi and provides
    the following features used by the projects in the book:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit CRICKIT HAT是Adafruit Industries为树莓派创建的硬件扩展板（[https://adafruit.com](https://adafruit.com)；图2.3）。CRICKIT
    HAT连接到树莓Pi的GPIO连接器，并为本书中的项目提供以下功能：
- en: Up to two bi-directional DC motors can be connected, powered, and controlled.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可连接多达两个双向直流电机，供电并控制。
- en: Up to four servo motors can be connected, powered, and controlled.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可连接多达四个伺服电机，供电并控制。
- en: Four capacitive touch input sensors are built into the board.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 芯片板上集成了四个电容式触摸输入传感器。
- en: A Neopixel RGB LED is built into the board.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 芯片板上集成了Neopixel RGB LED。
- en: Python support is provided by the Adafruit Python library to control and interact
    with the motors, capacitive touch, and Neopixels.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit Python库提供Python支持，用于控制与电机、电容式触摸和Neopixel的交互。
- en: '![](../Images/CH02_F03_Alsabbagh.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F03_Alsabbagh.png)'
- en: 'Figure 2.3 Adafruit CRICKIT HAT: the DC motors and servo motors are connected
    to this board.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 Adafruit CRICKIT HAT：直流电机和伺服电机连接到该电路板。
- en: 2.2 Configuring the software for our robots
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 为我们的机器人配置软件
- en: Figure 2.4 shows the software stack presented in the previous chapter. Details
    of the specific software used in this chapter are described in the following text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4展示了前一章中提到的软件堆栈。本章中使用的特定软件的详细信息将在下文中描述。
- en: '![](../Images/CH02_F04_Alsabbagh.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F04_Alsabbagh.png)'
- en: 'Figure 2.4 Software stack: this chapter will cover the installation and configuration
    of Linux and Python.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 软件堆栈：本章将涵盖Linux和Python的安装和配置。
- en: Once Linux is installed, Python will be configured to have a dedicated virtual
    environment where Python libraries can be installed. The Adafruit CRICKIT library
    will be installed, which will then be used to run the Python code to interact
    with the CRICKIT hardware components such as the Neopixel LED and the touch input
    sensors. The `blink` and `touch` applications will then be created using Python
    and the Adafruit libraries to communicate with the CRICKIT board using the I2C
    device interface in Linux. The Python `time` module will be used to control the
    time duration of different actions. Before continuing with the chapter, make sure
    to follow the installation and configuration instructions in appendix B for the
    Raspberry Pi and the Adafruit CRICKIT HAT.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Linux后，Python将被配置为拥有一个专用的虚拟环境，其中可以安装Python库。将安装Adafruit CRICKIT库，然后使用它来运行Python代码，以与CRICKIT硬件组件（如Neopixel
    LED和触摸输入传感器）交互。将使用Python的`time`模块来控制不同动作的时间持续时间。在继续本章之前，请确保遵循附录B中关于树莓派和Adafruit
    CRICKIT HAT的安装和配置说明。
- en: 2.3 Changing Neopixel colors
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 更改Neopixel颜色
- en: 'The CRICKIT library offers several different ways to interact with the Neopixel
    LED. We can explore these options in a REPL (read–evaluate–print loop) session.
    Check appendix B for help activating the Python virtual environment and opening
    a REPL session. The Neopixel can be quite bright, so we will lower the brightness
    to 1% and then set the color to blue:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CRICKIT库提供了几种与Neopixel LED交互的不同方式。我们可以在REPL（读取-评估-打印循环）会话中探索这些选项。有关激活Python虚拟环境和打开REPL会话的帮助，请参阅附录B。Neopixel可能非常明亮，因此我们将亮度降低到1%，然后将颜色设置为蓝色：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So far, we have set the color using the RGB hexadecimal color code. It would
    be nice if we could set colors using human-readable color names. This functionality
    isn’t directly available through the CRICKIT library, but we can create a simple
    dictionary to store and look up common color names:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用RGB十六进制颜色代码设置颜色。如果能使用人类可读的颜色名称来设置颜色那就更好了。这种功能在CRICKIT库中不是直接可用的，但我们可以创建一个简单的字典来存储和查找常见的颜色名称：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can now create a simple script to continually loop through each color name
    and set the color. This code will create a multicolor blinking effect with the
    LED. During each loop, the script will print out the color name, set the color,
    and pause for 0.1 seconds before setting the next color. Save the following script
    in a file called `blink.py` on the Pi.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个简单的脚本，不断循环遍历每个颜色名称并设置颜色。此代码将创建一个多色闪烁效果，使用LED。在每次循环中，脚本将打印出颜色名称，设置颜色，然后在设置下一个颜色之前暂停0.1秒。将以下脚本保存到名为`blink.py`的文件中，存放在Pi上。
- en: 'Listing 2.1 `blink.py`: Creating a multicolor blinking effect with the LED'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 `blink.py`：使用LED创建多色闪烁效果
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The file can be given execute permission by running
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行命令来赋予文件执行权限
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then run the Python script:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行Python脚本：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason the script can be executed directly is that the first line is using
    a Unix feature called shebang, which tells Linux that the script should be executed
    through the Python interpreter `python3`. Make sure to activate the Python virtual
    environment before running the script, as shown in appendix B. We can exit the
    script by pressing Ctrl+C, which will force the script to exit. When saving the
    script on the Pi, place it in the `/home/robo/bin/` directory, which can also
    be accessed as `~/bin`. This is a standard location on Linux systems to place
    user scripts such as these, and it will be the convention followed in the book.
    The `blink.py` file and all the code for the projects in this book can be found
    on GitHub ([https://github.com/marwano/robo](https://github.com/marwano/robo)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以直接执行的原因是第一行使用了Unix的一个特性，称为shebang，它告诉Linux该脚本应该通过Python解释器`python3`来执行。确保在运行脚本之前激活Python虚拟环境，如附录B所示。我们可以通过按Ctrl+C退出脚本，这将强制脚本退出。在Pi上保存脚本时，将其放置在`/home/robo/bin/`目录中，也可以作为`~/bin`访问。这是Linux系统上放置用户脚本等的标准位置，本书将遵循这一惯例。《blink.py》文件以及本书中所有项目的代码都可以在GitHub上找到（[https://github.com/marwano/robo](https://github.com/marwano/robo)）。
- en: 'Going deeper: The I2C communication protocol'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：I2C通信协议
- en: The CRICKIT HAT has its own microcontroller on the board and uses the I2C communication
    protocol to enable communication between the Raspberry Pi and its microcontroller.
    This is all taken care of by the Python Adafruit CRICKIT library. Being very powerful
    and flexible, I2C protocol is a popular choice for communication between integrated
    chips. The SparkFun website has a great guide ([https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c))
    on I2C. It can be interesting and useful to learn what is going on under the hood
    with these low-level hardware protocols.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CRICKIT HAT在板上有自己的微控制器，并使用I2C通信协议来启用Raspberry Pi与其微控制器之间的通信。所有这些都由Python Adafruit
    CRICKIT库处理。I2C协议非常强大且灵活，是集成电路之间通信的流行选择。SparkFun网站有一个关于I2C的出色指南（[https://learn.sparkfun.com/tutorials/i2c](https://learn.sparkfun.com/tutorials/i2c)）。了解这些底层硬件协议的内部工作原理既有趣又实用。
- en: 'The Adafruit site has a good hands-on guide ([http://mng.bz/g7mV](http://mng.bz/g7mV))
    to communicating with I2C devices in Python. We can use this guide to do some
    basic interaction with I2C on the Pi with the CRICKIT HAT. Let’s first open a
    REPL and import the `board` module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit网站有一个关于在Python中使用I2C设备进行交互的良好实践指南（[http://mng.bz/g7mV](http://mng.bz/g7mV)）。我们可以使用这个指南在Pi上使用CRICKIT
    HAT进行一些基本的I2C交互。让我们首先打开一个REPL并导入`board`模块：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now create an `I2C` object to scan for the CRICKIT HAT:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个`I2C`对象来扫描CRICKIT HAT：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now scan for I2C devices and save the result in `devices`. We can see
    from the results that one device was found:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扫描I2C设备并将结果保存在`devices`中。我们可以从结果中看到找到了一个设备：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From appendix B, we know that the I2C address for the CRICKIT HAT is expected
    to be `0x49`. We can confirm the device we found is the CRICKIT HAT by calculating
    its hexadecimal with the following line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从附录B中，我们知道CRICKIT HAT的I2C地址预期为`0x49`。我们可以通过以下行计算其十六进制值来确认我们找到的设备是CRICKIT HAT：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The I2C protocol is a powerful protocol that can support up to 1,008 peripheral
    devices connected on just two wires.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议是一种强大的协议，可以在仅两条线上支持多达1,008个外围设备。
- en: 2.4 Checking the touch sensor state
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 检查触摸传感器状态
- en: 'There are four capacitive touch input sensors on the CRICKIT. Figure 2.5 shows
    their close-up view. From Python, each sensor can be checked individually to see
    whether it is currently detecting a touch event. Without touching the touch sensor,
    run the following code in a REPL session:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CRICKIT上有四个电容式触摸输入传感器。图2.5显示了它们的特写视图。从Python中，每个传感器都可以单独检查，以查看它是否正在检测触摸事件。在不触摸触摸传感器的情况下，在REPL会话中运行以下代码：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/CH02_F05_Alsabbagh.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_Alsabbagh.png)'
- en: 'Figure 2.5 Capacitive touch sensors: these sensors can detect touch events.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 电容式触摸传感器：这些传感器可以检测触摸事件。
- en: 'Now run the last line again while touching the first touch sensor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在触摸第一个触摸传感器的同时再次运行最后一行：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the `value` attribute is accessed, the CRICKIT library checks the touch
    sensor state and returns a Boolean value of either `True` or `False` depending
    on the sensor data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`value`属性时，CRICKIT库会检查触摸传感器状态，并返回一个布尔值`True`或`False`，这取决于传感器数据。
- en: 2.5 Controlling DC motors
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 控制直流电机
- en: 'Connect the two wires of a DC motor into the DC motor connector port 1\. Figure
    2.6 shows the location of these motor connections on the CRICKIT. The two wires
    can be connected either way into the CRICKIT motor port; it won’t cause any problems.
    Make sure to use the M/M extension jumper wires mentioned in appendix A, as this
    will ensure the male and female ends match. Once connected, run the following
    lines in a REPL session:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将直流电机的两根线连接到直流电机连接器端口1。图2.6显示了这些电机连接在CRICKIT上的位置。这两根线可以任意方式连接到CRICKIT电机端口；这不会引起任何问题。请确保使用附录A中提到的M/M扩展跳线，因为这将确保公母端匹配。一旦连接，请在REPL会话中运行以下行：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/CH02_F06_Alsabbagh.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F06_Alsabbagh.png)'
- en: 'Figure 2.6 DC motor connections: the connection points for DC motors are screwed
    in place.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 直流电机连接：直流电机的连接点被拧紧固定。
- en: The DC motor will now run at full speed. To stop the motor running, use
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 直流电机现在将以全速运行。要停止电机运行，请使用
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 2.6 Controlling motors with the touch sensor
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 使用触摸传感器控制电机
- en: We can take what we have learned so far and combine these different parts of
    the CRICKIT library to make an application that continually checks the touch sensor
    and starts or stops the motor based on whether the sensor is being touched. We
    will also change the LED color whenever the motor is started or stopped. Let’s
    start constructing this application piece by piece.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将到目前为止学到的知识结合起来，将这些CRICKIT库的不同部分组合起来，制作一个不断检查触摸传感器并根据传感器是否被触摸来启动或停止电机的应用程序。我们还将根据电机是否启动或停止改变LED颜色。让我们一步步构建这个应用程序。
- en: 'First, we’ll import the CRICKIT library to control the motors and the `time`
    library to pause between checking for touch events:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入CRICKIT库来控制电机和`time`库来在检查触摸事件之间暂停：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we’ll define `RGB` so that we can set colors by name and save how long
    we wait between checking touch events in a setting called `POLL_DELAY`. The poll
    delay value is set at 0.1 seconds, which is fast enough to make the experience
    of touching the sensor and starting the motor responsive:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`RGB`，这样我们就可以通过名称设置颜色，并在名为`POLL_DELAY`的设置中保存检查触摸事件之间的等待时间。轮询延迟值设置为0.1秒，这足以使触摸传感器和启动电机的体验响应迅速：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before starting the main loop of the program, we set the brightness of the
    LED:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始程序的主循环之前，我们设置LED的亮度：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The remainder of the program runs in this infinite loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分在这个无限循环中运行：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the first line of the loop, we check whether the sensor is being touched
    and set the `throttle` variable accordingly. In Python, this syntax is called
    a *conditional expression*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第一行，我们检查传感器是否被触摸，并相应地设置`throttle`变量。在Python中，这种语法称为*条件表达式*：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We take the same approach to set the LED to red when the motor is on and blue
    when it is off using the `color` variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用相同的方法，使用`color`变量在电机开启时将LED设置为红色，关闭时设置为蓝色：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After calculating the `throttle` and `color` values, we apply them to the motor
    and LED:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了`throttle`和`color`值之后，我们将它们应用到电机和LED上：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we sleep for `POLL_DELAY` seconds before starting the next loop iteration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在开始下一个循环迭代之前，睡眠`POLL_DELAY`秒：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The full application can be saved as `touch.py` on the Pi and then executed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序可以保存为Pi上的`touch.py`，然后执行。
- en: 'Listing 2.2 `touch.py`: Starting the motor when the touch sensor is pressed'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 `touch.py`：当触摸传感器被按下时启动电机
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you run the script, you will see that the motor is initially not moving,
    and the LED color will be blue. If you press the touch sensor, the LED color will
    change to red, and the motor will start moving at full speed. If you stop touching
    the sensor, the LED will return to the initial blue color, and the motor will
    come to a full stop. Figure 2.7 maps the touch sensor state to the color of the
    LED and the motor running state.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行脚本时，你会看到电机最初是不动的，LED的颜色将是蓝色。如果你按下触摸传感器，LED的颜色将变为红色，电机将以全速开始移动。如果你停止触摸传感器，LED将恢复到最初的蓝色，电机将完全停止。图2.7将触摸传感器的状态映射到LED的颜色和电机的运行状态。
- en: '![](../Images/CH02_F07_Alsabbagh.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F07_Alsabbagh.png)'
- en: 'Figure 2.7 Touch state diagram: the LED and motor state changes in reaction
    to touch events.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 触摸状态图：LED和电机状态根据触摸事件发生变化。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Raspberry Pi is a single-board computer created by the Raspberry Pi Foundation.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派是由树莓派基金会创建的单板计算机。
- en: The Adafruit CRICKIT HAT is a hardware add-on for the Raspberry Pi created by
    Adafruit Industries.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit CRICKIT HAT是Adafruit Industries为树莓派创建的硬件附加组件。
- en: The CRICKIT HAT, once connected to the Raspberry Pi, can be used to control
    the Neopixel and attached motors.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦连接到树莓派，CRICKIT HAT就可以用来控制Neopixel和连接的电机。
- en: The Adafruit Python CRICKIT library can be used to run Python code that interacts
    with the CRICKIT hardware components.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit Python CRICKIT库可以用来运行与CRICKIT硬件组件交互的Python代码。
- en: The Raspberry Pi Imager is software that can be used to prepare the installation
    media (microSD card/USB flash drive) with the Raspberry Pi OS image.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派Imager是一种软件，可以用来准备带有树莓派OS镜像的安装介质（microSD卡/USB闪存驱动器）。
- en: The CRICKIT HAT is connected to the Raspberry Pi using the GPIO connector.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRICKIT HAT通过GPIO连接器连接到树莓派。
- en: Neopixel colors can be changed in Python using the RGB hexadecimal color codes.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中可以使用RGB十六进制颜色代码更改Neopixel颜色。
- en: When checking the touch sensor state, the CRICKIT library returns a Boolean
    value of either `True` or `False`, depending on the touch sensor state.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检查触摸传感器状态时，CRICKIT库返回一个布尔值，要么是`True`，要么是`False`，这取决于触摸传感器的状态。
- en: DC motors can be turned on and off by setting the throttle attribute to `1`
    or `0`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置节流属性为`1`或`0`，可以开启和关闭直流电机。
- en: A connected motor can be turned on and off based on touch events using a loop
    that continually polls for touch events and sets the throttle for the motor accordingly.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用不断轮询触摸事件并相应地设置电机节流的循环，根据触摸事件开启和关闭连接的电机。
