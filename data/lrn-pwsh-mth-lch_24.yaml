- en: 24 Handling errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 24 处理错误
- en: In this chapter, we’ll focus on how to capture, deal with, log, and otherwise
    handle errors the tool may encounter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍如何捕获、处理、记录以及以其他方式处理工具可能遇到的错误。
- en: Note [PowerShell.org](http://PowerShell.org) offers a free e-book called *The
    Big Book of PowerShell Error Handling*, which dives into this topic from a more
    technical reference perspective, at [https://devopscollective.org/ebooks/](https://devopscollective.org/ebooks/).
    We recommend checking it out once you’ve completed this tutorial-focused chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[PowerShell.org](http://PowerShell.org)提供了一个名为《PowerShell错误处理大全书》的免费电子书，它从更技术性的参考角度深入探讨了这一主题，请访问[https://devopscollective.org/ebooks/](https://devopscollective.org/ebooks/)。我们建议在完成这个以教程为重点的章节后查看它。
- en: Before we get started, there are two variables that we need to get comfortable
    with. The first is the `$Error` automation variable. This contains an array of
    error objects that have occurred in your current session, with the most recent
    error object showing up at `$Error[0]`. By default, all errors will be put into
    this variable. You can change this behavior by setting your `ErrorAction` common
    parameter to `Ignore`. You can get more information about automatic variables
    by running `get-help about_automatic_variables`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有两个变量我们需要熟悉。第一个是`$Error`自动化变量。它包含了一个数组，其中包含了当前会话中发生的错误对象，最新的错误对象显示在`$Error[0]`。默认情况下，所有错误都会放入这个变量中。你可以通过设置`ErrorAction`常见参数为`Ignore`来改变这种行为。你可以通过运行`get-help
    about_automatic_variables`来获取有关自动变量的更多信息。
- en: 'The second built-in variable that you can use is the common parameter variable
    `ErrorVariable`. This is an object that you can send errors to, so you can use
    them at a later time if needed (e.g., for writing to a log file):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的第二个内置变量是常见的参数变量`ErrorVariable`。这是一个你可以发送错误的对象，因此如果需要的话，你可以在稍后使用它们（例如，写入日志文件）：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ErrorVariable` will only hold the most recent error unless you add a `+` (plus)
    sign in front of it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorVariable`将只保留最近的错误，除非你在它前面添加一个`+`（加号）：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: NOTE We did not use the `$` in front of the error variable because it is not
    needed here.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们没有在错误变量前使用`$`符号，因为在这里不需要。
- en: 24.1 Understanding errors and exceptions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.1 理解错误和异常
- en: 'PowerShell defines two broad types of bad situations: an *error* and an *exception*.
    Because most PowerShell commands are designed to deal with multiple things at
    once, and because in many cases a problem with one thing doesn’t mean you want
    to stop dealing with all the other things, PowerShell tries to err on the side
    of “just keep going.” So, often, when something goes wrong in a command, PowerShell
    will emit an *error* and keep going (figure 24.1). For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell定义了两种广泛的错误情况：一个*错误*和一个*异常*。因为大多数PowerShell命令都是设计来同时处理多个事物的，而且在很多情况下，一个事物的问题并不意味着你想停止处理其他所有事物，所以PowerShell试图在“继续进行”这一边犯错。因此，当命令中发生错误时，PowerShell通常会发出一个*错误*并继续运行（图24.1）。例如：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](Images/CH24_UN01_Plunk.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH24_UN01_Plunk.png)'
- en: Figure 24.1 `Get-Service` with a service that doesn’t exist
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图24.1 `Get-Service`与一个不存在的服务
- en: The service `Nobody` doesn’t exist, so PowerShell will emit an *error* on that
    second item. But by default, PowerShell will *keep going* and process the third
    item in the list. When PowerShell is in this keep-going mode*, you can’t have
    your code respond to the problem condition*. If you want to do something about
    the problem, you have to change PowerShell’s default response to this kind of
    *nonterminating error*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 服务`Nobody`不存在，所以PowerShell会在第二个项目上发出一个*错误*。但默认情况下，PowerShell会*继续运行*并处理列表中的第三个项目。当PowerShell处于这种继续运行的模式时，你无法让代码响应问题条件。如果你想对问题采取行动，你必须改变PowerShell对这种*非终止错误*的默认响应。
- en: 'At a global level, PowerShell defines an `$ErrorActionPreference` variable,
    which tells PowerShell what to do in the event of a nonterminating error—that
    is, this variable tells PowerShell what to do when a problem comes up, but PowerShell
    is able to keep going. The default value for this variable is `Continue`. Here
    are the options:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在全球范围内，PowerShell定义了一个`$ErrorActionPreference`变量，它告诉PowerShell在发生非终止错误时应该做什么——也就是说，这个变量告诉PowerShell在出现问题时应该做什么，但PowerShell仍然能够继续运行。这个变量的默认值是`Continue`。以下是可用的选项：
- en: '`Break`—Enter the debugger when an error occurs or when an exception is raised.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Break`——当发生错误或抛出异常时进入调试器。'
- en: '`Continue` *(default)*—Displays the error message and continues executing.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Continue`（默认）——显示错误消息并继续执行。'
- en: '`Ignore`—Suppresses the error message and continues to execute the command.
    The `Ignore` value is intended for per-command use, not for use as a saved preference.
    `Ignore` isn’t a valid value for the `$ErrorActionPreference` variable.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ignore`—抑制错误信息并继续执行命令。`Ignore`值旨在用于每个命令，而不是用作保存的偏好。`Ignore`不是`$ErrorActionPreference`变量的有效值。'
- en: '`Inquire`—Displays the error message and asks you whether you want to continue.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inquire`—显示错误信息并询问你是否想继续。'
- en: '`SilentlyContinue`—No effect. The error message isn’t displayed, and execution
    continues without interruption.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SilentlyContinue`—无效果。错误信息不会显示，执行将继续而不会中断。'
- en: '`Stop`—Displays the error message and stops executing. In addition to the error
    generated, the `Stop` value generates an `ActionPreferenceStopException` object
    to the error stream.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stop`—显示错误信息并停止执行。除了生成的错误外，`Stop`值还会向错误流生成一个`ActionPreferenceStopException`对象。'
- en: '`Suspend`—Automatically suspends a workflow job to allow for further investigation.
    After investigation, the workflow can be resumed. The `Suspend` value is intended
    for per-command use, not for use as a saved preference. `Suspend` isn’t a valid
    value for the `$ErrorActionPreference` variable.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspend`—自动挂起工作流作业以允许进一步调查。调查后，工作流可以继续。`Suspend`值旨在用于每个命令，而不是用作保存的偏好。`Suspend`不是`$ErrorActionPreference`变量的有效值。'
- en: 'Rather than changing `$ErrorActionPreference` globally, you’ll typically want
    to specify a behavior on a per-command basis. You can do this using the `-ErrorAction`
    common parameter, which exists on every PowerShell command—even the ones you write
    yourself that include `[CmdletBinding()]`. For example, try running these commands,
    and note the different behaviors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是全局更改`$ErrorActionPreference`，你通常会想为每个命令指定一个行为。你可以使用存在于每个PowerShell命令中的`-ErrorAction`通用参数来完成此操作——即使是你自己编写的包含`[CmdletBinding()]`的命令。例如，尝试运行这些命令，并注意它们的不同行为：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The thing to remember is that *you can’t handle exceptions in your code* *unless
    PowerShell actually generates an exception*. Most commands *won’t* generate an
    exception unless you run them with the `Stop` error action. One of the biggest
    mistakes people make is forgetting to add `-EA` `Stop` to a command where they
    want to handle the problem (`-EA` is short for `-ErrorAction`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的是，*除非PowerShell实际生成异常，否则你无法在代码中处理异常*。大多数命令*不会*生成异常，除非你使用`Stop`错误操作运行它们。人们犯的最大错误之一就是忘记在想要处理问题的命令中添加`-EA
    Stop`（`-EA`是`-ErrorAction`的缩写）。
- en: 24.2 Bad handling
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.2 不良处理
- en: We see people engage in two fundamentally bad practices. These aren’t *always*
    bad, but they’re *usually* bad, so we want to bring them to your attention.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到人们参与两种根本性的不良做法。这些做法*并不总是*是错误的，但它们*通常*是错误的，所以我们想引起你的注意。
- en: 'First up is globally setting the preference variable right at the top of a
    script or function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是在脚本或函数的最顶部全局设置偏好变量：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the olden days of VBScript, people used `On` `Error` `Resume` `Next`. This
    is essentially saying, “I don’t want to know if anything is wrong with my code.”
    People do this in a misguided attempt to suppress possible errors that they know
    won’t matter. For example, attempting to delete a file that doesn’t exist will
    cause an error—but you probably don’t care, because mission accomplished either
    way, right? But to suppress that unwanted error, you should be using `-EA` `SilentlyContinue`
    on the `Remove-Item` command, not globally suppressing *all* errors in your script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在VBScript的古老时代，人们使用`On Error Resume Next`。这本质上是在说，“我不想知道我的代码是否有任何问题。”人们这样做是为了错误地抑制他们知道不会造成影响的可能错误。例如，尝试删除一个不存在的文件将导致错误——但你可能并不在乎，因为任务无论如何都完成了，对吧？但为了抑制这个不想要的错误，你应该在`Remove-Item`命令中使用`-EA
    SilentlyContinue`，而不是全局抑制脚本中的所有错误。
- en: The other bad practice is a bit more subtle and can come up in the same situation.
    Suppose you *do* run `Remove-Item` with `-EA` `SilentlyContinue`, and then suppose
    you try to delete a file that does exist but that you don’t have permission to
    delete. You’ll suppress the error and wonder why the file still exists.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不良做法更为微妙，可能会出现在相同的情况下。假设你确实使用了`-EA SilentlyContinue`来运行`Remove-Item`，然后假设你尝试删除一个确实存在但你没有权限删除的文件。你会抑制错误并想知道为什么文件仍然存在。
- en: Before you start suppressing errors, make sure you’ve thought it through. Nothing
    is more vexing than spending hours debugging a script because you suppressed an
    error message that would have told you where the problem was. We can’t tell you
    how often this comes up in forum questions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始抑制错误之前，请确保你已经仔细考虑过。没有什么比花费数小时调试脚本更令人沮丧了，因为你抑制了一个本可以告诉你问题所在位置的错误消息。我们无法告诉你这在论坛问题中出现的频率有多高。
- en: 24.3 Two reasons for exception handling
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.3 异常处理的两个原因
- en: There are two broad reasons to handle exceptions in your code. (Notice that
    we’re using their official name, *exceptions*, to differentiate them from the
    nonhandleable *errors* that we wrote about previously.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中处理异常有两个主要原因。（注意，我们使用它们的官方名称*异常*来区分我们之前提到的不可处理的*错误*。）
- en: Reason one is that you plan to run your tool out of your view. Perhaps it’s
    a scheduled task, or maybe you’re writing tools that will be used by remote customers.
    In either case, you want to make sure you have evidence for any problems that
    occur, to help you with debugging. In this scenario, you might globally set `$ErrorActionPreference`
    to `Stop` at the top of your script, and wrap the entire script in an error-handling
    construct. That way, any errors, even unanticipated ones, can be trapped and logged
    for diagnostic purposes. Although this is a valid scenario, it isn’t the one we’re
    going to focus on in this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是，你计划在你的视线之外运行你的工具。这可能是一个计划任务，或者你可能正在编写将被远程客户使用的工具。在两种情况下，你都想确保你有任何发生问题的证据，以帮助你进行调试。在这种情况下，你可以在脚本顶部全局设置`$ErrorActionPreference`为`Stop`，并将整个脚本包裹在错误处理结构中。这样，任何错误，即使是未预见的错误，都可以被捕获并记录以供诊断。尽管这是一个有效的情况，但我们将不会在本书中重点关注这种情况。
- en: We’ll focus on reason two—you’re running a command *where you can anticipate
    a certain kind of problem occurring*, and you want to actively deal with that
    problem. This might be a failure to connect to a computer, a failure to log on
    to something, or another scenario along those lines. Let’s dig into that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注第二个原因——你正在运行一个你可以预见到可能会出现某种问题的命令，并且你想要积极处理这个问题。这可能是无法连接到计算机，无法登录到某个系统，或者类似的情况。让我们深入探讨一下。
- en: 24.4 Handling exceptions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.4 处理异常
- en: 'Suppose you are building a script that connects to remote machines. You can
    anticipate the `New-PSSession` command running into problems: a computer might
    be offline or nonexistent, or the computer might not work with the protocol you’ve
    selected. You want to catch those conditions and, depending on the parameters
    you ran with, log the failed computer name to a text file and/or try again using
    the other protocol. You’ll start by focusing on the command that could cause the
    problem and make sure it’ll generate a *terminating exception* if it runs into
    trouble. Change this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个连接到远程机器的脚本。你可以预见到`New-PSSession`命令可能会遇到问题：计算机可能离线或不存在，或者计算机可能不支持你选择的协议。你想要捕获这些条件，并根据你运行的参数，将失败的计算机名称记录到文本文件中，并尝试使用其他协议再次运行。你将从关注可能引发问题的命令开始，并确保它在遇到麻烦时能够生成一个*终止异常*。更改如下：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what if we want to run this command on multiple computers? We have two options.
    The first option is to put multiple computer names into the `$computer` variable.
    After all, it does accept an array of strings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想在多台计算机上运行这个命令怎么办？我们有两种选择。第一种选择是将多个计算机名称放入`$computer`变量中。毕竟，它接受字符串数组。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here is where you will need to make some personal decisions. Do you want to
    let your script continue to run if an error occurs and capture the error for later
    use, or do you want your script to stop running immediately? A lot of this will
    depend on what you are trying to accomplish. If you are attempting to connect
    to five remote computers to run a command, is it okay if it runs on only four
    of them, and you log the error that the fifth computer could not be contacted,
    or do you need the command to run on either all five or none of them?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你需要做出一些个人决定的地方。当发生错误时，你是想让你的脚本继续运行并捕获错误以供后续使用，还是想让脚本立即停止运行？这很大程度上取决于你想要达成的目标。如果你试图连接到五台远程计算机来运行一个命令，如果只有四台运行成功，而你记录了第五台计算机无法连接的错误，这是否可以接受，或者你需要命令在所有五台或没有任何一台计算机上运行？
- en: 'You have two options here. The first option is to wrap your command in a `foreach`
    loop. That way `ErrorAction` is set each time the command is executed. If you
    have one failure, the rest of the sessions will still be created. This, however,
    negates the fact that `New-PSSession` `computername` parameter can take an array
    of objects as its input:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你有两种选择。第一种选择是将你的命令包裹在一个 `foreach` 循环中。这样每次执行命令时都会设置 `ErrorAction`。如果你有一个失败，其余的会话仍然会被创建。然而，这却否定了
    `New-PSSession` `computername` 参数可以接受对象数组作为其输入的事实：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second option is to tell PowerShell to continue and put the error in the
    `ErrorVariable` common parameter (don’t forget to append the `+` symbol to the
    existing variable data):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是告诉 PowerShell 继续执行并将错误放入 `ErrorVariable` 公共参数中（别忘了将 `+` 符号附加到现有变量数据上）：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Make sure you understand why this design principle is so important! As we mentioned
    before, we do not want to suppress useful errors if we can help it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你理解为什么这个设计原则如此重要！正如我们之前提到的，如果我们能帮助的话，我们不想抑制有用的错误。
- en: Try it now Using what you have learned so far in this chapter and in previous
    chapters, get the state of the `spooler` service and the `print` service. Make
    sure to log your errors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 使用你在本章和前几章中学到的知识，获取 `spooler` 服务和 `print` 服务的状态。确保记录你的错误。
- en: 'Just changing the error action to `Stop` isn’t enough, though. You also need
    to wrap your code in a `Try/Catch` construct. If an exception occurs in the `Try`
    block, then all the subsequent code in the `Try` block will be skipped, and the
    `Catch` block will execute instead:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只是将错误操作更改为 `Stop` 是不够的。你还需要将你的代码包裹在 `Try/Catch` 构造中。如果在 `Try` 块中发生异常，那么 `Try`
    块中随后的所有代码都将被跳过，然后执行 `Catch` 块：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s what’s happening: within the `Catch` block, you take the opportunity
    to write out a warning message for the benefit of the user. They can suppress
    warnings by adding `-Warning-Action` `SilentlyContinue` when running the command.
    This is some complex logic—go through it a few times, and make sure you understand
    it!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是：在 `Catch` 块中，你有机会为用户的利益编写一条警告信息。他们可以通过在运行命令时添加 `-Warning-Action` `SilentlyContinue`
    来抑制警告。这是一些复杂的逻辑——多看几遍，确保你理解它！
- en: 24.5 Handling exceptions for noncommands
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.5 处理非命令的异常
- en: What if you’re running something—like a .NET Framework method—that doesn’t have
    an `-ErrorAction` parameter? In *most* cases, you can run it in a `Try` block
    as is, because *most* of these methods will throw trappable, terminating exceptions
    if something goes wrong. The nonterminating exception thing is unique to PowerShell
    commands like functions and cmdlets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行某些东西——比如一个没有 `-ErrorAction` 参数的 .NET Framework 方法——会发生什么？在 *大多数* 情况下，你可以直接在
    `Try` 块中运行它，因为 *大多数* 这些方法在出错时都会抛出可捕获的、终止的异常。非终止异常的情况是 PowerShell 命令（如函数和 cmdlets）特有的。
- en: 'But you *still* may have instances when you need to do this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但你仍然可能遇到需要这样做的情况：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is your error handling of last resort. Basically, you’re temporarily modifying
    `$ErrorActionPreference` for the duration of the one command (or whatever) for
    which you want to catch an exception. This isn’t a common situation in our experience,
    but we figured we’d point it out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的最后一种错误处理方法。基本上，你只是暂时修改 `$ErrorActionPreference`，以便在你想捕获异常的单个命令（或任何其他操作）期间使用。在我们经验中，这种情况并不常见，但我们认为我们应该指出这一点。
- en: 24.6 Going further with exception handling
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.6 进一步学习异常处理
- en: 'It’s possible to have multiple `Catch` blocks after a given `Try` block, with
    each `Catch` dealing with a specific type of exception. For example, if a file
    deletion failed, you could react differently for a File Not Found or an Access
    Denied situation. To do this, you’ll need to know the .NET Framework type name
    of each exception you want to call out separately. *The Big Book of PowerShell
    Error Handling* has a list of common ones and advice for figuring these out (e.g.,
    generating the error on your own in an experiment, and then figuring out what
    the exception type name was). Broadly, the syntax looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的 `Try` 块之后，可以有多重 `Catch` 块，每个 `Catch` 块处理特定类型的异常。例如，如果文件删除失败，你可以针对“文件未找到”或“访问被拒绝”的情况采取不同的反应。为此，你需要知道你想要单独调用的每个异常的
    .NET Framework 类型名称。*《PowerShell 错误处理大全书》* 列出了常见的一些类型，并提供了如何确定这些类型的建议（例如，在自己的实验中生成错误，然后确定异常类型名称）。总的来说，语法看起来像这样：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also shown in that example is the optional `Finally` block, which will always
    run after the `Try` or the `Catch`, whether or not an exception occurs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个示例中还展示了可选的 `Finally` 块，它将在 `Try` 或 `Catch` 之后始终运行，无论是否发生异常。
- en: Deprecated exception handling
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 已废弃的异常处理
- en: You may, in your internet travels, run across a `Trap` construct in PowerShell.
    This dates back to v1, when the PowerShell team frankly didn’t have time to get
    `Try/Catch` working, and `Trap` was the best short-term fix they could come up
    with. `Trap` is *deprecated*, meaning it’s left in the product for backward compatibility,
    but you’re not intended to use it in newly written code. For that reason, we’re
    not covering it here. It *does* have some uses in global, “I want to catch and
    log any possible error” situations, but `Try/Catch` is considered a more structured,
    professional approach to exception handling, and we recommend that you stick with
    it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络旅行中，你可能会在 PowerShell 中遇到一个 `Trap` 构造。这可以追溯到 v1，当时 PowerShell 团队坦白地说没有时间让
    `Try/Catch` 工作起来，而 `Trap` 是他们能想出的最好的短期解决方案。`Trap` 已被**弃用**，这意味着它被保留在产品中以保持向后兼容性，但你不应该在新编写的代码中使用它。因此，我们在这里不讨论它。在全局的，“我想捕获并记录任何可能的错误”的情况下，它确实有一些用途，但
    `Try/Catch` 被认为是一种更结构化、更专业的异常处理方法，我们建议你坚持使用它。
- en: 24.7 Lab
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.7 实验室
- en: 'Using what you have learned so far, do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你迄今为止学到的知识，做以下事情：
- en: Create a function that will get the uptime on remote machines. Make sure you
    are using the built-in commands in PowerShell 7 and not .NET methods.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于获取远程机器的运行时间。确保你使用的是 PowerShell 7 的内置命令，而不是 .NET 方法。
- en: Make sure the function can accept input for multiple machines.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保函数可以接受多个机器的输入。
- en: Include error-handling methods that we discussed in this chapter such as `Try/
    Catch` and error actions.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含本章中讨论的错误处理方法，如 `Try/Catch` 和错误操作。
- en: Above and beyond
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 超越和超越
- en: 'Take what you have learned so far about remoting and make your function work
    regardless of the operating system. Here is a hint: There are three built-in variables
    that may prove useful:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将你迄今为止关于远程操作学到的知识应用到你的函数中，使其能够在任何操作系统上工作。这里有一个提示：有三个内置变量可能很有用：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are some key things to remember:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关键事项需要记住：
- en: '`$Error` contains all the error messages in your session.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$Error` 包含你会话中的所有错误消息。'
- en: '`ErrorVariable` can be used to store errors as well (append the `+` sign to
    it).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorVariable` 也可以用来存储错误（向其添加 `+` 符号）。'
- en: '`Try/Catch` is your friend, but only with nonterminating errors.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Try/Catch` 是你的朋友，但仅限于非终止错误。'
- en: 24.8 Lab answer
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 24.8 实验室答案
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
