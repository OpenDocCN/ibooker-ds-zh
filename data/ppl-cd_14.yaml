- en: 11 Dockerized microservices on K8s
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 在 K8s 上 Docker 化微服务
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Setting up a Kubernetes cluster on AWS with Terraform
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 在 AWS 上设置 Kubernetes 集群
- en: Automating application deployment on Kubernetes with Jenkins pipelines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jenkins 管道自动化 Kubernetes 上的应用程序部署
- en: Packaging and versioning Kubernetes Helm charts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和版本化 Kubernetes Helm 图表
- en: Converting Compose files to Kubernetes manifests with Kompose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kompose 将 Compose 文件转换为 Kubernetes 清单
- en: Running post-deployment tests and health checks within CI/CD pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 CI/CD 管道中运行部署后测试和健康检查
- en: Discovering Jenkins X and setting up serverless CI/CD pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 Jenkins X 并设置无服务器 CI/CD 管道
- en: The preceding chapter covered how to set up a CI/CD pipeline from scratch for
    containerized applications running in Docker Swarm (figure 11.1). This chapter
    covers how to deploy the same application in Kubernetes (K8s) and automate the
    deployment. In addition, you’ll learn how to use Jenkins X to simplify the workflow
    of cloud-native applications running in Kubernetes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章介绍了如何从头开始为在 Docker Swarm 中运行的容器化应用程序设置 CI/CD 管道（图 11.1）。本章介绍了如何在 Kubernetes（K8s）中部署相同的应用程序并自动化部署。此外，您还将学习如何使用
    Jenkins X 来简化在 Kubernetes 中运行的本地区域应用程序的工作流程。
- en: '![](Images/CH11_F01_Labouardy.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F01_Labouardy.png)'
- en: Figure 11.1 Current CI/CD pipeline workflow
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 当前 CI/CD 管道工作流程
- en: Docker Swarm might be a good solution for beginners and smaller workloads. However,
    for large deployment and at a certain scale, you might want to consider shifting
    to Kubernetes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 可能是初学者和较小工作负载的好解决方案。然而，对于大型部署和一定规模的工作负载，您可能需要考虑转向 Kubernetes。
- en: For those of you who are AWS power users, Amazon Elastic Kubernetes Service
    (EKS) is a natural fit. Other cloud providers offer managed Kubernetes solutions,
    including Azure Kubernetes Service (AKS) and Google Kubernetes Engine (GKE).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些 AWS 高级用户来说，Amazon Elastic Kubernetes Service (EKS) 是一个自然的选择。其他云服务提供商也提供托管
    Kubernetes 解决方案，包括 Azure Kubernetes Service (AKS) 和 Google Kubernetes Engine (GKE)。
- en: 11.1 Setting up a Kubernetes cluster
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 设置 Kubernetes 集群
- en: As I’ve said, AWS offers the Amazon Elastic Kubernetes Service ([https://aws.amazon.com/eks](https://aws.amazon.com/eks)).
    The EKS cluster will be deployed in a custom VPC within multiple private subnets.
    EKS runs the Kubernetes control plane for you across multiple AWS availability
    zones to eliminate a single point of failure, as shown in figure 11.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，AWS 提供了 Amazon Elastic Kubernetes Service ([https://aws.amazon.com/eks](https://aws.amazon.com/eks))。EKS
    集群将在多个私有子网中的自定义 VPC 内部署。EKS 在多个 AWS 可用区运行 Kubernetes 控制平面，以消除单点故障，如图 11.2 所示。
- en: '![](Images/CH11_F02_Labouardy.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F02_Labouardy.png)'
- en: Figure 11.2 The AWS EKS architecture consists of node groups deployed in private
    subnets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 AWS EKS 架构由部署在私有子网中的节点组组成。
- en: A few tools (including AWS CloudFormation, eksctl, and kOps) allow you to get
    up and running quickly on EKS. In this chapter, we picked Terraform because we
    were already using it to manage our Jenkins cluster on AWS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具（包括 AWS CloudFormation、eksctl 和 kOps）允许您快速在 EKS 上启动和运行。在本章中，我们选择了 Terraform，因为我们已经在
    AWS 上使用它来管理我们的 Jenkins 集群。
- en: To get started, provision a new VPC to host the sandbox environment and divide
    it into two private subnets. Amazon EKS requires subnets in at least two availability
    zones. The VPC is created to isolate the Kubernetes workload. For EKS to discover
    the VPC subnets and manage network resources, we tag them with `kubernetes.io/cluster/<cluster-name>`.
    The `<cluster-name>` value matches the EKS cluster’s name, which is `sandbox`.
    Create a file called vpc.tf with the content in the following listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请为沙箱环境配置一个新的 VPC 并将其划分为两个私有子网。Amazon EKS 至少需要两个可用区的子网。VPC 是为了隔离 Kubernetes
    工作负载而创建的。为了使 EKS 能够发现 VPC 子网并管理网络资源，我们使用 `kubernetes.io/cluster/<cluster-name>`
    标记它们。《cluster-name》的值与 EKS 集群的名称匹配，即 `sandbox`。创建一个名为 vpc.tf 的文件，其内容如下所示。
- en: Listing 11.1 Kubernetes custom VPC
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 Kubernetes 自定义 VPC
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, define the subnets and set up the appropriate route tables. Refer to chapter11/eks/vpc.tf
    for the full source code, or head back to chapter 10 for a step-by-step guide
    on how to deploy a custom VPC on AWS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，定义子网并设置适当的路由表。有关完整源代码，请参阅 chapter11/eks/vpc.tf，或返回 chapter 10 以获取在 AWS 上部署自定义
    VPC 的分步指南。
- en: Next, we create a new eks_masters.tf file and define the `sandbox` EKS cluster,
    which is a managed K8s control plane, as shown in the following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的 eks_masters.tf 文件，并定义 `sandbox` EKS 集群，这是一个托管的 K8s 控制平面，如下所示。
- en: Listing 11.2 EKS sandbox cluster
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 EKS 沙箱集群
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The managed control plane uses an IAM role with the AmazonEKSClusterPolicy and
    AmazonEKServicePolicy policies. These attachments grant the cluster the permissions
    it needs to take care of itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制平面使用具有AmazonEKSClusterPolicy和AmazonEKServicePolicy策略的IAM角色。这些附加项授予集群它需要自行管理的权限。
- en: Now it’s time to spin up some worker nodes. A node is a simple EC2 instance
    that runs the Kubernetes objects (pods, deployments, services, and so forth).
    The master’s automatic scheduling takes into account the available resources on
    each node. Define an EKS node group resource within eks_workers.tf as shown in
    the following listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启动一些工作节点了。节点是一个简单的EC2实例，它运行Kubernetes对象（pods、deployments、services等）。主机的自动调度会考虑每个节点上的可用资源。在eks_workers.tf中定义EKS节点组资源，如下所示。
- en: Listing 11.3 Kubernetes node group resource
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 Kubernetes节点组资源
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also create an IAM role that the worker nodes are going to assume. We grant
    the AmazonEKSWorkerNodePolicy, AmazonEKS_CNI_Policy, and AmazonEC2ContainerRegistryReadOnly
    policies. Refer to chapter11/eks/eks_workers.tf for the full source code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个IAM角色，工作节点将假定该角色。我们授予AmazonEKSWorkerNodePolicy、AmazonEKS_CNI_Policy和AmazonEC2ContainerRegistryReadOnly策略。有关完整源代码，请参阅chapter11/eks/eks_workers.tf。
- en: Note This section assumes that you are familiar with the usual Terraform plan/apply
    workflow; if you’re new to Terraform, refer first to chapter 5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节假设你熟悉通常的Terraform计划/应用工作流程；如果你是Terraform的新手，请首先参考第5章。
- en: Lastly, define the variables listed in table 11.1 in the variables.tf file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`variables.tf`文件中定义表11.1中列出的变量。
- en: Table 11.1 EKS Terraform variables
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 EKS Terraform变量
- en: '| Variable | Type | Value | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 类型 | 值 | 描述 |'
- en: '| `region` | String | None | The name of the region, such as `eu-central-1`,
    in which to deploy the EKS cluster |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `region` | 字符串 | None | 部署EKS集群的区域名称，例如`eu-central-1` |'
- en: '| `shared_credentials_file` | String | `~/.aws/credentials` | The path to the
    shared credentials file. If this is not set and a profile is specified, `~/.aws/credentials`
    will be used. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `shared_credentials_file` | 字符串 | `~/.aws/credentials` | 共享凭据文件的路径。如果未设置且指定了配置文件，则将使用`~/.aws/credentials`。
    |'
- en: '| `aws_profile` | String | `profile` | The AWS profile name as set in the shared
    credentials file |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `aws_profile` | 字符串 | `profile` | 在共享凭据文件中设置的AWS配置文件名称 |'
- en: '| `author` | String | None | Name of the owner of the EKS cluster. It’s optional,
    but recommended, to tag your AWS resources to track the monthly costs by owner
    or environment. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `author` | 字符串 | None | EKS集群的所有者名称。标记你的AWS资源以跟踪按所有者或环境划分的月度成本是可选的，但建议这么做。
    |'
- en: '| `availability_zones` | List | None | Availability zone for spinning up the
    VPC subnets |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `availability_zones` | 列表 | None | 启动VPC子网的可用区 |'
- en: '| `vpc_name` | String | `sandbox` | The name of the VPC |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `vpc_name` | 字符串 | `sandbox` | VPC的名称 |'
- en: '| `cidr_block` | String | `10.1.0.0/16` | The VPC CIDR block |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `cidr_block` | 字符串 | `10.1.0.0/16` | VPC CIDR块 |'
- en: '| cluster_name | String | `sandbox` | The EKS cluster’s name |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| cluster_name | 字符串 | `sandbox` | EKS集群的名称 |'
- en: '| public_subnets_count | Number | 2 | The number of public subnets to create
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| public_subnets_count | 数字 | 2 | 要创建的公共子网数量 |'
- en: '| `private_subnets_count` | Number | 2 | The number of private subnets to create
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `private_subnets_count` | 数字 | 2 | 要创建的私有子网数量 |'
- en: Then, issue the `terraform` `init` command to initialize a working directory
    and download the AWS provider plugin. In your initialized directory, run `terraform
    plan` to review the planned actions. Your terminal output should indicate that
    the plan is running and the resources that will be created. This should include
    the EKS cluster, VPC, and IAM roles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行`terraform init`命令以初始化工作目录并下载AWS提供者插件。在你的初始化目录中，运行`terraform plan`以审查计划中的操作。你的终端输出应指示计划正在运行以及将要创建的资源。这应包括EKS集群、VPC和IAM角色。
- en: If you’re comfortable with the execution plan, confirm the run with `terraform
    apply`. This provisioning process should take a few minutes. Upon successful deployment,
    a new EKS cluster for the sandbox environment will be deployed and available in
    the AWS EKS console, as shown in figure 11.3.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对执行计划感到满意，请使用`terraform apply`确认运行。此配置过程可能需要几分钟。部署成功后，将为沙箱环境部署一个新的EKS集群，并在AWS
    EKS控制台中可用，如图11.3所示。
- en: '![](Images/CH11_F03_Labouardy.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F03_Labouardy.png)'
- en: Figure 11.3 EKS sandbox cluster
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 EKS沙箱集群
- en: Now that you’ve provisioned your EKS cluster, you need to configure kubectl.
    This is a command-line utility for communicating with the cluster API server.
    At the time of writing this book, I’m using version v1.18.3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经配置了EKS集群，您需要配置kubectl。这是一个用于与集群API服务器通信的命令行实用程序。在撰写本书时，我使用的是版本v1.18.3。
- en: Note The kubectl tool is available in many operating system package managers;
    refer to the official documentation ([https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/))
    for installation instructions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：kubectl工具在许多操作系统包管理器中可用；有关安装说明，请参阅官方文档（[https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)）。
- en: 'To grant kubectl access to the K8s API, we need to generate a kubeconfig file
    (located under .kube/config in your home directory). You can create or update
    a kubeconfig file with the AWS CLI `update-kubeconfig` command. Issue this command
    to get the access credentials for your cluster:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要授予kubectl对K8s API的访问权限，我们需要生成一个kubeconfig文件（位于您家目录下的.kube/config）。您可以使用AWS
    CLI的`update-kubeconfig`命令创建或更新kubeconfig文件。运行以下命令以获取您集群的访问凭证：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To verify that your cluster is configured correctly and running, execute the
    following command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的集群配置正确且正在运行，请执行以下命令。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will list all of the nodes in a cluster and the status of each node:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将列出集群中的所有节点以及每个节点的状态：
- en: '![](Images/CH11_F03_UN01_Labouardy.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F03_UN01_Labouardy.png)'
- en: Note To optimize K8s costs, you can use EC2 Spot instances, as they cost about
    30–70% less than their on-demand counterparts. However, this requires some special
    considerations, as they could be terminated with only a 2-minute warning.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了优化K8s成本，您可以使用EC2 Spot实例，因为它们比按需实例便宜约30-70%。然而，这需要一些特殊考虑，因为它们可能只有2分钟的警告就被终止。
- en: At this point, you should be able to use Kubernetes. In the next section, we
    will automate the deployment of the Watchlist application described in chapter
    7 into the K8s cluster with Jenkins following the PaC approach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够使用Kubernetes。在下一节中，我们将按照PaC方法使用Jenkins自动化第7章中描述的Watchlist应用程序的部署到K8s集群。
- en: 11.2 Automating continuous deployment flow with Jenkins
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用Jenkins自动化持续部署流程
- en: To complete a Kubernetes deployment from Jenkins, all we need are K8s deployment
    files, which will contain references to the Docker images, along with the configuration
    settings (for example, port, network name, labels, and constraints). To run this
    file, we will need to execute the `kubectl apply` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Jenkins完成Kubernetes部署，我们只需要K8s部署文件，这些文件将包含对Docker镜像的引用，以及配置设置（例如端口、网络名称、标签和约束）。要运行此文件，我们需要执行`kubectl
    apply`命令。
- en: On the develop branch of the watchlist-deployment GitHub repository, create
    a deployments folder. Inside it, create a movies-loader-deploy.yaml file by using
    your favorite text editor or IDE, with the content in the following listing. The
    deployment instructs Kubernetes on how to create and update the movies-loader
    service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在watchlist-deployment GitHub仓库的develop分支上，创建一个deployments文件夹。在其内部，使用您喜欢的文本编辑器或IDE创建一个movies-loader-deploy.yaml文件，内容如下所示。该部署指令指导Kubernetes如何创建和更新movies-loader服务。
- en: Listing 11.4 Movie loader deployment resource
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 Movie loader部署资源
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note As a reminder, the movies-loader and movies-store services are using Amazon
    SQS to load and consume movie items, respectively. To grant those services permission
    to interact with SQS, you need to assign the AmazonSQSFullAccess policy to the
    EKS node group.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：作为提醒，movies-loader和movies-store服务分别使用Amazon SQS加载和消费电影条目。为了授予这些服务与SQS交互的权限，您需要将AmazonSQSFullAccess策略分配给EKS节点组。
- en: The movies-loader service can be deployed to Kubernetes through a deployment
    resource. The deployment definition uses the `develop` tag of the movies-loader
    Docker image and defines a set of environment variables, such as the SQS URL and
    AWS region. The MongoDB resource can also be deployed with the mongodb-deploy.yaml
    file in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: movies-loader服务可以通过部署资源部署到Kubernetes。部署定义使用movies-loader Docker镜像的`develop`标签，并定义了一组环境变量，例如SQS
    URL和AWS区域。MongoDB资源也可以使用以下列表中的mongodb-deploy.yaml文件进行部署。
- en: Listing 11.5 MongoDB deployment resource
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 MongoDB部署资源
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most interesting thing about this deployment definition is the environment
    variables part. Instead of hardcoding the MongoDB credentials, we are using K8s
    secrets. We’re creating secret store authentication credentials so only Kubernetes
    can access them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署定义中最有趣的部分是环境变量部分。我们不是使用硬编码的 MongoDB 凭据，而是使用 K8s 机密。我们正在创建秘密存储认证凭据，以便只有 Kubernetes
    可以访问它们。
- en: 'Before we create a Kubernetes secret, we need to maintain a space in the Kubernetes
    cluster where we can get a view on the list of pods, services, and deployments
    we use to build and run the application. We will create a dedicated namespace
    to associate all of our Kubernetes objects with the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建 Kubernetes 机密之前，我们需要在 Kubernetes 集群中维护一个空间，以便我们可以查看我们用于构建和运行应用程序的 pods、服务和部署的列表。我们将使用以下命令创建一个专用命名空间来关联所有我们的
    Kubernetes 对象：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, invoke the following Kubernetes command on your local machine to create
    MongoDB credentials secrets:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的本地机器上执行以下 Kubernetes 命令以创建 MongoDB 凭据机密：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](Images/CH11_F03_UN02_Labouardy.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F03_UN02_Labouardy.png)'
- en: 'Create deployment files for the rest of the services: movies-store, movies-parser,
    and movies-marketplace. The deployments folder structure should look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为其余服务创建部署文件：movies-store、movies-parser 和 movies-marketplace。部署文件夹结构应如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All the source code can be downloaded from the GitHub repository, under the
    chapter11/deployment/kubectl/deployments folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有源代码都可以从 GitHub 仓库下载，位于 chapter11/deployment/kubectl/deployments 文件夹下。
- en: To deploy the application with Jenkins, create a Jenkinsfile.eks file at the
    top-level directory of the watchlist-deployment project, as shown in the following
    listing. The Jenkinsfile will configure kubectl with the `aws` `eks` `update-kubeconfig`
    command. Then it issues a `kubectl` `apply` command to deploy the deployment resources.
    The `kubectl` `apply` command takes as an argument the deployments folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Jenkins 部署应用程序，请在 watchlist-deployment 项目的顶级目录中创建一个 Jenkinsfile.eks 文件，如下所示。Jenkinsfile
    将使用 `aws eks update-kubeconfig` 命令配置 kubectl。然后它发出一个 `kubectl apply` 命令来部署部署资源。`kubectl
    apply` 命令将部署文件夹作为参数。
- en: Listing 11.6 Jenkinsfile deployment stages
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 Jenkinsfile 部署阶段
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ AWS region where the EKS cluster is deployed
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 部署 EKS 集群的 AWS 区域
- en: ❷ Configures kubectl so that you can connect to an Amazon EKS cluster
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置 kubectl 以连接到 Amazon EKS 集群
- en: ❸ Deploys the new changes to EKS
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将新更改部署到 EKS
- en: 'Before pushing the Jenkinsfile and deployment files to the Git remote repository,
    we need to install the kubectl command line on the Jenkins master. Also, we need
    to provide access to EKS with IAM roles. To grant Jenkins master permissions to
    interact with the K8s cluster, we must edit the `aws-auth` ConfigMap within Kubernetes.
    On your local machine, run the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Jenkinsfile 和部署文件推送到 Git 远程仓库之前，我们需要在 Jenkins 主机上安装 kubectl 命令行。此外，我们需要通过
    IAM 角色提供对 EKS 的访问权限。为了授予 Jenkins 主机与 K8s 集群交互的权限，我们必须编辑 Kubernetes 中的 `aws-auth`
    ConfigMap。在您的本地机器上，运行以下命令：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A text editor will open; add the Jenkins instance’s IAM role to the `mapRoles`
    section. Then, save the file and exit the text editor. Check whether the ConfigMap
    is properly configured with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个文本编辑器；将 Jenkins 实例的 IAM 角色添加到 `mapRoles` 部分。然后保存文件并退出文本编辑器。使用以下命令检查 ConfigMap
    是否配置正确：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](Images/CH11_F03_UN03_Labouardy.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F03_UN03_Labouardy.png)'
- en: 'Once the ConfigMap is configured, install aws-iam-authenticator, which is a
    tool to manage AWS IAM credentials for Kubernetes access. Refer to the AWS documentation
    at [http://mng.bz/AOWW](http://mng.bz/AOWW) for the installation guide. Then,
    generate a kubeconfig with the AWS CLI `update-kubeconfig` command. The command
    should create a /home/ec2-user/.kube/config file with no warning. Now we can issue
    the `kubectl get` `nodes` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 ConfigMap，安装 aws-iam-authenticator，这是一个用于管理 Kubernetes 访问的 AWS IAM 凭据的工具。有关安装指南，请参阅
    AWS 文档[http://mng.bz/AOWW](http://mng.bz/AOWW)。然后，使用 AWS CLI 的 `update-kubeconfig`
    命令生成 kubeconfig。命令应创建一个没有警告的 /home/ec2-user/.kube/config 文件。现在我们可以发出 `kubectl
    get nodes` 命令：
- en: '![](Images/CH11_F03_UN04_Labouardy.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F03_UN04_Labouardy.png)'
- en: 'Now, we’re ready to push the Jenkinsfile and Kubernetes deployment files to
    the Git repository under the develop branch:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将 Jenkinsfile 和 Kubernetes 部署文件推送到 develop 分支下的 Git 仓库：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The GitHub repository content should look similar to figure 11.4 after pushing
    K8s deployment files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送 K8s 部署文件后，GitHub 仓库内容应类似于图 11.4。
- en: '![](Images/CH11_F04_Labouardy.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F04_Labouardy.png)'
- en: Figure 11.4 Kubernetes deployment files in the Git repository
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 Git仓库中的Kubernetes部署文件
- en: Once the changes are committed, the GitHub webhook we created in section 7.6
    will trigger a build on the watchlist-deployment multibranch job on the develop
    branch’s nested job; see figure 11.5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交更改，我们在第7.6节中创建的GitHub webhook将在develop分支的嵌套作业上触发watchlist-deployment多分支作业的构建；见图11.5。
- en: '![](Images/CH11_F05_Labouardy.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F05_Labouardy.png)'
- en: Figure 11.5 The `kubectl` `apply` command’s outpu.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 `kubectl apply`命令的输出。
- en: 'At the `Deploy` stage, the `kubectl apply` command will be executed to deploy
    the application deployment resources. On your local machine, run this command
    to list deployments running in the sandbox K8s cluster:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Deploy`阶段，将执行`kubectl apply`命令以部署应用程序部署资源。在您的本地机器上，运行此命令以列出在沙盒K8s集群中运行的部署：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The four components (loader, parser, store, and marketplace) of our application
    will be deployed alongside a MongoDB server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的四个组件（加载器、解析器、存储器和市场）将与MongoDB服务器一起部署：
- en: '![](Images/CH11_F05_UN05_Labouardy.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F05_UN05_Labouardy.png)'
- en: 'These deployment resources are referencing Docker images stored in Amazon ECR.
    At the time of deploying the EKS cluster, we have granted permissions to the K8s
    cluster to interact with ECR. However, if your Docker images are hosted on a remote
    repository that requires username/password authentication, you need to create
    a Docker Registry secret with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部署资源正在引用存储在Amazon ECR中的Docker镜像。在部署EKS集群时，我们已经授予K8s集群与ECR交互的权限。然而，如果您的Docker镜像托管在需要用户名/密码身份验证的远程仓库中，您需要使用以下命令创建一个Docker
    Registry秘密：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you need to reference this secret in your deployment file under the `spec`
    section as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在部署文件中的`spec`部分引用此秘密，如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our application is deployed. To access it, we need to create a K8s service for
    both the marketplace and store, as shown in the following listing. Create a services
    directory in the root repository, and then create a service for movies-store called
    movies-store.svc.yaml. The service creates a cloud network load balancer (for
    instance, AWS Elastic Load Balancer). This provides an externally accessible IP
    address for accessing the Movies Store API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已部署。要访问它，我们需要为市场和服务创建K8s服务，如下所示列表。在根仓库中创建一个服务目录，然后创建一个名为movies-store的服务，称为movies-store.svc.yaml。该服务创建一个云网络负载均衡器（例如，AWS
    Elastic Load Balancer）。这提供了一个外部可访问的IP地址，用于访问电影存储API。
- en: Listing 11.7 Movie store service resource
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.7电影存储服务资源
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Additionally, we create another service to expose the Movies Marketplace (UI).
    Add the content in the following listing to movies-marketplace.svc.yaml.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们创建另一个服务以公开电影市场（UI）。将以下列表中的内容添加到movies-marketplace.svc.yaml中。
- en: Listing 11.8 Movies Marketplace service resource
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8电影市场服务资源
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The movies-store and movies-parser services store the movie metadata in a MongoDB
    service. Therefore, we need to expose the MongoDB deployment through a Kubernetes
    service to allow MongoDB to receive incoming operations. The service is exposed
    to an internal IP in the cluster. The `ClusterIP` keyword makes the service reachable
    from only within the cluster. The MongoDB pod targeted by the service is determined
    by `LabelSelector`. Add the following YAML block to mongodb-svc.yaml.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: movies-store和movies-parser服务将电影元数据存储在MongoDB服务中。因此，我们需要通过Kubernetes服务公开MongoDB部署，以允许MongoDB接收传入的操作。该服务暴露在集群的内部IP上。`ClusterIP`关键字使服务仅可在集群内部访问。由服务针对的MongoDB
    pod由`LabelSelector`确定。将以下YAML块添加到mongodb-svc.yaml。
- en: Listing 11.9 Movies Marketplace service resource
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9电影市场服务资源
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we update the Jenkinsfile in listing 11.6 to deploy the Kubernetes
    services by providing the services folder as a parameter to the `kubectl` `apply`
    command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将列表11.6中的Jenkinsfile更新为通过将服务文件夹作为参数提供给`kubectl apply`命令来部署Kubernetes服务：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Push the changes to the develop branch. A new build will be triggered, and the
    services will be deployed, as shown in figure 11.6.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到develop分支。将触发新的构建，并将服务部署，如图11.6所示。
- en: '![](Images/CH11_F06_Labouardy.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F06_Labouardy.png)'
- en: Figure 11.6 The `kubectl` `apply` output
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 `kubectl apply`命令的输出
- en: 'Type the following command on your local machine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地机器上输入以下命令：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It should show the load balancers for the three K8s services:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该显示三个K8s服务的负载均衡器：
- en: '![](Images/CH11_F06_UN06_Labouardy.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F06_UN06_Labouardy.png)'
- en: On AWS Management Console, two public-facing load balancers should be created
    in the EC2 dashboard ([http://mng.bz/Zx7Z](http://mng.bz/Zx7Z)), as shown in figure
    11.7.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS管理控制台中，应在EC2仪表板中创建两个面向公众的负载均衡器（[http://mng.bz/Zx7Z](http://mng.bz/Zx7Z)），如图
    11.7 所示。
- en: '![](Images/CH11_F07_Labouardy.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F07_Labouardy.png)'
- en: Figure 11.7 Movies Store and Marketplace ELBs
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 电影商店和市场 ELB
- en: Note Make sure to set the load balancer FQDN in the environment.sandbox.tf file
    of the movies-marketplace project. The API URL will be injected while building
    the marketplace Docker image. Refer to section 9.1.2 for more details.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保在电影市场项目的 environment.sandbox.tf 文件中设置负载均衡器的FQDN。API URL将在构建市场Docker镜像时注入。有关更多详细信息，请参阅第
    9.1.2 节。
- en: To secure access to the Store API, we can enable an HTTPS listener on the public
    load balancer by updating the movies-store service with the changes detailed in
    the following listing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护对商店API的访问，我们可以通过更新电影商店服务并应用以下列表中详细说明的更改来在公共负载均衡器上启用HTTPS监听器。
- en: Listing 11.10 HTTPS listener configuration
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 HTTPS监听器配置
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Used on the service to specify the protocol spoken by the backend (pod) behind
    a listener
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于在监听器后面指定后端（pod）所使用的协议
- en: ❷ Exposes port 443 (HTTPS) and forwards requests internally to port 3000 of
    the movies-store pod
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 公开端口 443（HTTPS）并将请求内部转发到电影商店pod的端口 3000
- en: Push the changes to the remote repository. Jenkins will deploy the changes and
    update the load balancer listener configuration to accept incoming traffic on
    port 443 (HTTPS), as shown in figure 11.8.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到远程仓库。Jenkins将部署更改并更新负载均衡器监听器配置，以在端口 443（HTTPS）上接受传入流量，如图 11.8 所示。
- en: '![](Images/CH11_F08_Labouardy.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F08_Labouardy.png)'
- en: Figure 11.8 Load balancer HTTP/HTTPS listeners
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 负载均衡器HTTP/HTTPS监听器
- en: It’s optional, but you can create an A record in Amazon Route 53 pointing to
    the load balancer FQDN and update environment.sandbox.ts to use the friendly domain
    name instead of the load balancer FQDN; see the following listing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是必需的，但你可以在Amazon Route 53中创建一个指向负载均衡器FQDN的A记录，并将 environment.sandbox.ts 更新为使用友好域名而不是负载均衡器FQDN；请参阅以下列表。
- en: Listing 11.11 Marketplace Angular environment variables
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 市场Angular环境变量
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you point your browser to the marketplace URL, it should call the Movies
    Store API and list the movies crawled from IMDb pages, as shown in figure 11.9\.
    It might take several minutes for DNS to propagate and for the marketplace to
    show up.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将浏览器指向市场URL，它应该调用电影商店API并列出从IMDb页面爬取的电影，如图 11.9 所示。DNS传播和市场出现可能需要几分钟。
- en: '![](Images/CH11_F09_Labouardy.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F09_Labouardy.png)'
- en: Figure 11.9 Watchlist Marketplace application
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 观看列表市场应用程序
- en: Now, every time you change the source code of any of the four microservices,
    the pipeline will be triggered, and the changes will be deployed to the sandbox
    Kubernetes cluster, as shown in figure 11.10.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你更改四个微服务中的任何一个的源代码时，管道都会被触发，更改将被部署到沙盒Kubernetes集群中，如图 11.10 所示。
- en: '![](Images/CH11_F10_Labouardy.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F10_Labouardy.png)'
- en: Figure 11.10 Movies Marketplace CI/CD workflo.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 电影市场 CI/CD 工作流程。
- en: 'Finally, to visualize our application, we can deploy the Kubernetes dashboard
    by issuing the following commands in a terminal session:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了可视化我们的应用程序，我们可以在终端会话中运行以下命令来部署Kubernetes仪表板：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These commands will deploy the metrics-server and K8s dashboard v2.0.5 under
    the kube-system namespace. The metrics-server, which collects resource metrics
    from Kubelet, has to be running in the cluster for the metrics and graphs to be
    available in the Kubernetes dashboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在 kube-system 命名空间下部署 metrics-server 和 K8s仪表板 v2.0.5。收集来自Kubelet的资源指标的
    metrics-server 必须在集群中运行，以便在Kubernetes仪表板中可用指标和图形。
- en: To grant access to cluster resources from the K8s dashboard, we need to create
    an eks-admin service account and cluster role binding to securely connect to the
    dashboard with admin-level permissions. Create an eks-admin.yaml file with the
    content in the following listing (`apiVersion` of the `ClusterRoleBinding` resource
    may differ between Kubernetes versions).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要从K8s仪表板授予对集群资源的访问权限，我们需要创建一个eks-admin服务账户和集群角色绑定，以具有管理员权限安全地连接到仪表板。创建一个 eks-admin.yaml
    文件，其中包含以下列表中的内容（`ClusterRoleBinding` 资源的 `apiVersion` 可能在不同版本的Kubernetes中有所不同）。
- en: Listing 11.12 Kubernetes dashboard service account
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 Kubernetes仪表板服务账户
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, create a service account with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令创建一个服务账户：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, create a proxy server that will allow you to navigate to the dashboard
    from the browser on your local machine. This will continue running until you stop
    the process by pressing Ctrl-C. Issue the `kubectl` `proxy` command, and the dashboard
    should be accessible from [http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个代理服务器，它将允许你从本地机器上的浏览器导航到仪表板。这将一直运行，直到你通过按Ctrl-C停止进程。发出`kubectl` `proxy`命令，仪表板应该可以通过[http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login)访问。
- en: 'Opening this URL will take us to the account authentication page for the Kubernetes
    dashboard. To get access to the dashboard, we need to authenticate our account.
    Retrieve an authentication token for the eks-admin service account with the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此URL将带我们到Kubernetes仪表板的账户认证页面。为了访问仪表板，我们需要认证我们的账户。使用以下命令检索eks-admin服务账户的认证令牌：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now copy the token and paste it into the Enter Token field on the login screen.
    Click the Sign In button, and that’s it. You are now logged in as an admin.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在复制令牌并将其粘贴到登录屏幕上的“输入令牌”字段。点击“登录”按钮，就这样。你现在已作为管理员登录。
- en: The Kubernetes dashboard, shown in figure 11.11, provides user-friendly features
    to manage and troubleshoot the deployed application. Awesome! You have successfully
    built a CI/CD pipeline for a cloud-native application in K8s.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板，如图11.11所示，提供了用户友好的功能来管理和调试已部署的应用程序。太棒了！你已经在K8s中成功构建了一个云原生应用的CI/CD管道。
- en: '![](Images/CH11_F11_Labouardy.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F11_Labouardy.png)'
- en: Figure 11.11 Kubernetes dashboard
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 Kubernetes仪表板
- en: 11.2.1 Migrating Docker Compose to K8s manifests with Kompose
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 使用Kompose将Docker Compose迁移到K8s清单
- en: Another way of creating deployment files is by converting the docker-compose.yml
    file defined in chapter 10’s listing 10.12 with an open source tool called Kompose.
    Refer to the project’s official GitHub repository ([https://github.com/kubernetes/kompose](https://github.com/kubernetes/kompose))
    for an installation guide.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建部署文件的另一种方式是将第10章列表10.12中定义的docker-compose.yml文件转换为开源工具Kompose。有关安装指南，请参阅项目的官方GitHub仓库（[https://github.com/kubernetes/kompose](https://github.com/kubernetes/kompose)）。
- en: 'Once Kompose is installed, run the following command against the docker-compose.yml
    file provided in chapter 10 (chapter10/deployment/sandbox/docker-compose.yml):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了Kompose，请对第10章提供的docker-compose.yml文件（chapter10/deployment/sandbox/docker-compose.yml）运行以下命令：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should create the Kubernetes deployments and services based on the settings
    and network topology specified in docker-compose.yml:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会根据docker-compose.yml中指定的设置和网络拓扑创建Kubernetes部署和服务：
- en: '![](Images/CH11_F11_UN07_Labouardy.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F11_UN07_Labouardy.png)'
- en: You can push those files to the remote Git repository, and Jenkins will issue
    the `kubectl` `apply` `-f` command to deploy the services and deployments.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些文件推送到远程Git仓库，Jenkins将发出`kubectl` `apply` `-f`命令来部署服务和部署。
- en: However, writing and maintaining Kubernetes YAML manifests for all the required
    Kubernetes objects can be a time-consuming and tedious task. For the simplest
    of deployments, you would need at least three YAML manifests with duplicated and
    hardcoded values. That’s where a tool like Helm ([https://helm.sh/](https://helm.sh/))
    comes into play to simplify this process and create a single package that can
    be advertised to your cluster.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为所有必需的Kubernetes对象编写和维护Kubernetes YAML清单可能是一项耗时且繁琐的任务。对于最简单的部署，你需要至少三个包含重复和硬编码值的YAML清单。这就是像Helm
    ([https://helm.sh/](https://helm.sh/))这样的工具发挥作用来简化此过程并创建一个可以推广到你的集群的单个包的地方。
- en: 11.3 Walking through continuous delivery steps
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 漫步通过持续交付步骤
- en: 'Helm is a useful package manager for Kubernetes. It has two parts: the client
    (CLI) and the server (which is called Tiller and was removed in Helm 3). The client
    lives on your local machine, and the server lives on the Kubernetes cluster to
    execute what is needed.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的有用包管理器。它有两个部分：客户端（CLI）和服务器（在Helm 3中被移除，称为Tiller）。客户端位于你的本地机器上，服务器位于Kubernetes集群中以执行所需操作。
- en: To fully grasp Helm, you need to become familiar with these three concepts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全掌握Helm，你需要熟悉这三个概念。
- en: '*Chart*—A package of preconfigured Kubernetes resources'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*图表*——一组预配置的Kubernetes资源'
- en: '*Release*—A specific instance of a chart that has been deployed to the cluster
    by using Helm'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发布*—使用 Helm 部署到集群的图表的特定实例'
- en: '*Repository*—A group of published charts that can be made available to others
    through a remote registry'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Repository*—一组已发布的图表，可以通过远程仓库提供给其他人'
- en: 'Check out the getting started page for instructions on downloading and installing
    Helm: [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看入门页面以获取有关下载和安装 Helm 的说明：[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
- en: Note Helm is assumed to be compatible with *n*-3 versions of Kubernetes. Refer
    to the Helm Version Support Policy documentation to determine which version of
    Helm is compatible with your K8s cluster.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Helm 假设与 *n*-3 版本的 Kubernetes 兼容。请参阅 Helm 版本支持策略文档，以确定与您的 K8s 集群兼容的 Helm
    版本。
- en: 'At the time of writing this book, Helm v3.6.1 is being used. After installing
    Helm, create a new chart for the application called `watchlist` in the top-level
    directory of the watchlist-deployment project:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，正在使用 Helm v3.6.1。安装 Helm 后，在 watchlist-deployment 项目的顶级目录中创建一个名为 `watchlist`
    的新图表：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should create a directory called watchlist with the following files and
    folders:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 watchlist 的目录，包含以下文件和文件夹：
- en: '*Values.yaml*—Defines all values we want to inject into Kubernetes templates'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Values.yaml*—定义了我们想要注入到 Kubernetes 模板中的所有值'
- en: '*Chart.yaml*—Can be used to describe the version of the chart we’re packaging'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Chart.yaml*—可以用来描述我们正在打包的图表版本'
- en: '*.helmignore*—Similar to .gitignore and .dockerignore, contains a list of files
    and folders to exclude while packaging the Helm chart'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.helmignore*—类似于 .gitignore 和 .dockerignore，包含在打包 Helm 图表时排除的文件和文件夹列表'
- en: '*templates**/*—Contains the actual manifest such as Deployments, Services,
    ConfigMaps, and Secrets'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*templates**/*—包含实际的清单，如 Deployments、Services、ConfigMaps 和 Secrets'
- en: 'Next, define template files inside the templates folder for each microservice.
    The template file describes how to deploy each service on Kubernetes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在模板文件夹内为每个微服务定义模板文件。模板文件描述了如何在 Kubernetes 上部署每个服务：
- en: '![](Images/CH11_F11_UN08_Labouardy.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F11_UN08_Labouardy.png)'
- en: For instance, the movies-loader template folder uses the same deployment files
    we defined in listing 11.4, except it references variables defined in values.yaml.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，movies-loader 模板文件夹使用我们在列表 11.4 中定义的相同部署文件，但它引用了在 values.yaml 中定义的变量。
- en: The deployment.yaml file is responsible for deploying a deployment object based
    on the movies-loader Docker image. This definition pulls the built Docker image
    from the Docker Registry and creates a new deployment with it in Kubernetes; see
    the following listing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.yaml 文件负责根据 movies-loader Docker 镜像部署部署对象。此定义从 Docker 仓库拉取构建的 Docker
    镜像，并在 Kubernetes 中创建一个新的部署；请参见以下列表。
- en: Listing 11.13 Movie loader deployment
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 电影加载器部署
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Helm charts use `{{}}` for templating, which means that whatever is inside will
    be interpreted to provide an output value. We can also use a piping mechanism
    to combine two or more commands for scripting and filtering.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表使用 `{{}}` 进行模板化，这意味着其中的内容将被解释以提供输出值。我们还可以使用管道机制将两个或多个命令组合起来进行脚本编写和过滤。
- en: The movies-loader container reference environment variables like `AWS_REGION`
    and `SQS_URL` are defined in configmap.yaml, as shown in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: movies-loader 容器引用的环境变量，如 `AWS_REGION` 和 `SQS_URL`，在 configmap.yaml 中定义，如下列表所示。
- en: Listing 11.14 Movie loader ConfigMap
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 电影加载器 ConfigMap
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The deployment file also references sensitive information such as MongoDB credentials.
    These credentials are stored securely in Kubernetes secrets, which are provided
    in the following listing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 部署文件还引用了敏感信息，例如 MongoDB 凭据。这些凭据存储在 Kubernetes 机密中，如下列表所示。
- en: Listing 11.15 Application secrets
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.15 应用程序密钥
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Helm charts make it easy to set overridable defaults in the values.yaml file,
    allowing us to define a base setting. We can move as many variables as we want
    out of the template and into the values.yaml file. This way, we can easily update
    and inject new values at installation time:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表使得在 values.yaml 文件中设置可覆盖的默认值变得容易，允许我们定义基本设置。我们可以将尽可能多的变量从模板移动到 values.yaml
    文件中。这样，我们可以在安装时轻松更新和注入新值：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This allows us to create a portable package that can be customized during runtime
    by overriding the values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们创建一个可移植的包，在运行时可以通过覆盖值进行自定义：
- en: 'Also, note the use of custom annotations or metadata in the deployment file.
    We will inject the Jenkins build ID and Git commit ID during the build of the
    Helm chart. This can be useful for debugging and troubleshooting running Kubernetes
    deployments:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意在部署文件中使用自定义注释或元数据。我们将在 Helm 图表的构建过程中注入 Jenkins 构建ID和 Git 提交ID。这可以用于调试和解决正在运行的
    Kubernetes 部署的问题：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'MongoDB offers a stable and official Helm chart that can be used for straightforward
    installation and configuration on Kubernetes. We define the MongoDB chart as a
    dependency in Chart.yaml under the `dependencies` section:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 提供了一个稳定且官方的 Helm 图表，可用于在 Kubernetes 上直接安装和配置。我们在 `Chart.yaml` 下的 `dependencies`
    部分将 MongoDB 图表定义为依赖项：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that our chart is defined, on your terminal session, issue the following
    command to install the watchlist application via the Helm chart we just created:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了图表，在你的终端会话中，输入以下命令通过我们刚刚创建的 Helm 图表安装监视列表应用程序：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The command takes the values.override.yaml file, which contains the values
    to override at runtime, such as the environment name and MongoDB username and
    password:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 命令接受 `values.override.yaml` 文件，其中包含在运行时覆盖的值，例如环境名称和 MongoDB 用户名和密码：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Check installation progress by checking the status of deployments and pods.
    Type `kubectl` `get` `pods` `-n` `watchlist` to show the running pods:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查部署和 Pod 的状态来检查安装进度。输入 `kubectl get pods -n watchlist` 以显示正在运行的 Pod：
- en: '![](Images/CH11_F11_UN09_Labouardy.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F11_UN09_Labouardy.png)'
- en: Note To check the generated manifests of a release without installing the chart,
    use the `--dry-run` flag to return rendered templates.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要检查发布生成的清单而不安装图表，请使用 `--dry-run` 标志以返回渲染的模板。
- en: We can now update the Jenkinsfile (chapter11/Jenkinsfile.eks) to use the Helm
    command line instead of kubectl. Since our application chart is already installed,
    we will use the `helm` `upgrade` command to upgrade the chart. This command takes
    as a parameter values to override, and sets the annotation values from the Jenkins
    environment variable `BUILD_TAG` and the `commitID()` method, as shown next.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新 Jenkinsfile（chapter11/Jenkinsfile.eks），使用 Helm 命令行而不是 kubectl。由于我们的应用程序图表已经安装，我们将使用
    `helm upgrade` 命令来升级图表。此命令接受覆盖的参数值，并设置来自 Jenkins 环境变量 `BUILD_TAG` 和 `commitID()`
    方法的注释值，如下所示。
- en: Listing 11.16 Helm upgrade within the Jenkins pipeline
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 在 Jenkins 管道中升级 Helm
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Helm tries to perform the least invasive upgrade. It will update only things
    that have changed since the last release.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 尝试执行最不侵入性的升级。它将只更新自上次发布以来已更改的内容。
- en: Push the changes to the develop branch. The GitHub repository should look similar
    to figure 11.12.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到开发分支。GitHub 仓库应类似于图 11.12。
- en: '![](Images/CH11_F12_Labouardy.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F12_Labouardy.png)'
- en: Figure 11.12 Watchlist Helm chart
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 监视列表 Helm 图表
- en: On Jenkins, a new build will be triggered. At the end of the `Deploy` stage,
    the `helm` `upgrade` command will be executed; the output is shown in figure 11.13.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 上，将触发一个新的构建。在 `Deploy` 阶段结束时，将执行 `helm upgrade` 命令；输出如图 11.13 所示。
- en: '![](Images/CH11_F13_Labouardy.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F13_Labouardy.png)'
- en: Figure 11.13 Helm upgrade output
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 Helm 升级输出
- en: Now every change on the develop branch will build a new Helm chart and create
    a new release on the sandbox cluster. If the Docker image has been changed, Kubernetes
    rolling updates provide the functionality to deploy changes with 0% downtime.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，开发分支上的每次更改都将构建一个新的 Helm 图表并在沙盒集群上创建一个新的发布。如果 Docker 镜像已更改，Kubernetes 滚动更新提供了在
    0% 停机时间内部署更改的功能。
- en: Note If something does not go as planned during a release, rolling back to a
    previous release is easy by using the `helm` `rollback` command.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果在发布过程中出现计划外的情况，可以使用 `helm rollback` 命令轻松回滚到之前的发布。
- en: For code promotion to the staging environment, we just need to update the values
    .override.yaml file to set the environment value to `staging` and use the `preprod`
    image tag, as shown in the following listing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将代码提升到预发布环境，我们只需更新 `.override.yaml` 文件，将环境值设置为 `staging` 并使用 `preprod` 镜像标签，如下所示。
- en: Listing 11.17 Staging variable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.17 预发布变量。
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you push the changes to the preprod branch, the application will be deployed
    to the Kubernetes staging cluster, as shown in figure 11.14.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将更改推送到预生产分支，应用程序将被部署到 Kubernetes 预发布集群，如图 11.14 所示。
- en: '![](Images/CH11_F14_Labouardy.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F14_Labouardy.png)'
- en: Figure 11.14 CI/CD workflow on preprod branch
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 预生产分支上的 CI/CD 工作流程
- en: 'We can verify that the preprod version has been deployed by typing the following
    command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来验证预生产版本已被部署：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The movies-marketplace deployment has annotations with git/commitId equal to
    the GitHub commit ID responsible for triggering the Jenkins job, and the jenkins/build
    annotation’s value is the name of the Jenkins job that triggered the deployment
    (figure 11.15).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: movies-marketplace部署具有git/commitId等于触发Jenkins作业的GitHub提交ID的注解，jenkins/build注解的值是触发部署的Jenkins作业的名称（图11.15）。
- en: '![](Images/CH11_F15_Labouardy.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F15_Labouardy.png)'
- en: Figure 11.15 Movies Marketplace deployment description
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 Movies Marketplace部署描述
- en: For production deployment, update values.override.yaml with proper values, as
    shown in the following listing. In this example, we set the image tag to `latest`,
    the environment to `production`, and we configure five replicas of the movies-parser
    service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产部署，使用以下列表更新values.override.yaml中的适当值。在此示例中，我们将镜像标签设置为`latest`，环境设置为`production`，并配置了五个movies-parser服务的副本。
- en: Listing 11.18 Production variables
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.18生产变量
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Push the new files to the master branch. At the end of the pipeline, the stack
    will be deployed to the K8s production cluster.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将新文件推送到master分支。在流水线结束时，堆栈将被部署到K8s生产集群。
- en: Now if a push event occurs on the master branch on any of the four microservices,
    the CI/CD pipeline will be triggered, and user approval will be requested, as
    shown in figure 11.16.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果在任何一个四个微服务的master分支上发生推送事件，CI/CD流水线将被触发，并请求用户批准，如图11.16所示。
- en: '![](Images/CH11_F16_Labouardy.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F16_Labouardy.png)'
- en: Figure 11.16 User approval for production deployment
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 生产部署的用户批准
- en: If the deployment is approved, the watchlist-deployment job will be triggered,
    and the master nested job will be executed. As a result, a new Helm release of
    the watchlist application will be created in production, as shown in figure 11.17.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果部署得到批准，watchlist-deployment作业将被触发，并执行master嵌套作业。因此，将在生产环境中创建watchlist应用程序的新Helm发布，如图11.17所示。
- en: '![](Images/CH11_F17_Labouardy.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F17_Labouardy.png)'
- en: Figure 11.17 Application deployment in production
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17生产中的应用程序部署
- en: Upon the completion of the deployment process, a Slack notification will be
    sent to a preconfigured Slack channel, as shown in figure 11.18.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程完成后，将向预先配置的Slack频道发送Slack通知，如图11.18所示。
- en: '![](Images/CH11_F18_Labouardy.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F18_Labouardy.png)'
- en: Figure 11.18 Production deployment Slack notification
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18生产部署Slack通知
- en: 'Run the `kubectl get pods` command. This should display five pods based on
    the movies-parser Docker image:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`kubectl get pods`命令。这应该会基于movies-parser Docker镜像显示五个Pod：
- en: '![](Images/CH11_F18_UN10_Labouardy.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F18_UN10_Labouardy.png)'
- en: 'To view the marketplace dashboard, locate the external IP of the load balancer
    in the EXTERNAL-IP column of the `kubectl get services -n watchlist` output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看市场仪表板，在`kubectl get services -n watchlist`输出的`EXTERNAL-IP`列中找到负载均衡器的外部IP：
- en: '![](Images/CH11_F18_UN11_Labouardy.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F18_UN11_Labouardy.png)'
- en: Navigate to that address in your browser, and the Movies Marketplace UI should
    be displayed, as you can see in figure 11.19.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中导航到该地址，应该会显示Movies Marketplace UI，如图11.19所示。
- en: '![](Images/CH11_F19_Labouardy.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F19_Labouardy.png)'
- en: Figure 11.19 Marketplace production environment
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19市场生产环境
- en: 'Under a production environment, you would replace the load balancer FQDN with
    an alias in Route 53\. Refer to the official AWS documentation for instructions:
    [http://mng.bz/Rq8P](http://mng.bz/Rq8P).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您应将负载均衡器的FQDN替换为Route 53中的别名。有关说明，请参阅官方AWS文档：[http://mng.bz/Rq8P](http://mng.bz/Rq8P)。
- en: 11.4 Packaging Kubernetes applications with Helm
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用Helm打包Kubernetes应用程序
- en: So far, you have seen how to create one single chart for the microservices-based
    application and how to create a new release with Jenkins upon new Git commits.
    Another way of packaging the application is to create separate charts for each
    microservice, and then reference those charts as dependencies in the main chart
    (similar to a MongoDB chart). Figure 11.20 illustrates how Helm charts are packaged
    within a CI/CD pipeline.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何为基于微服务应用程序创建单个图表，以及如何在新的Git提交后使用Jenkins创建新发布。另一种打包应用程序的方法是为每个微服务创建单独的图表，然后在主图表中引用这些图表作为依赖项（类似于MongoDB图表）。图11.20说明了Helm图表如何在CI/CD流水线中打包。
- en: '![](Images/CH11_F20_Labouardy.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F20_Labouardy.png)'
- en: Figure 11.20 CI/CD of containerized application with Helm
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20 使用 Helm 的容器化应用程序的 CI/CD
- en: On a push event, a Jenkins build will be triggered to build the Docker image
    and package the new release in a Helm chart. From there, the new chart is deployed
    to the corresponding Kubernetes environment. Along the way, a Slack notification
    is sent to notify the developers about the pipeline status.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送事件上，将触发 Jenkins 构建，以构建 Docker 图像并将新版本打包到 Helm 图表中。从那里，新的图表被部署到相应的 Kubernetes
    环境。在此过程中，将发送 Slack 通知以通知开发者有关管道状态。
- en: 'On the movies-marketplace project, create a new Helm chart in the top-level
    directory by typing the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影市场项目上，通过输入以下命令在顶级目录中创建一个新的 Helm 图表：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It should create a new folder called chart with the following structure:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该创建一个名为 chart 的新文件夹，具有以下结构：
- en: '![](Images/CH11_F20_UN12_Labouardy.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F20_UN12_Labouardy.png)'
- en: As mentioned earlier, a Helm chart consists of metadata used to help describe
    the application, define constraints on the minimum required Kubernetes and/or
    Helm version, and manage the version of the chart. All of this metadata lives
    in the Chart.yaml file (chapter11/microservices/movies-marketplace), shown in
    the following listing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Helm 图表由用于帮助描述应用程序、定义对所需的最小 Kubernetes 和/或 Helm 版本的约束以及管理图表版本元数据组成。所有这些元数据都位于
    Chart.yaml 文件中（chapter11/microservices/movies-marketplace），如下所示。
- en: Listing 11.19 Movie loader chart
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.19 电影加载器图表
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To be able to reference this chart from the main watchlist chart, we need to
    store it somewhere. Many open source solutions are available for storing Helm
    charts. GitHub can be used as a remote registry for Helm charts. Create a new
    GitHub repository called watchlist-charts and create an empty index.yaml file.
    This file will contain the metadata about available charts in the repository.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从主 watchlist 图表中引用此图表，我们需要将其存储在某个地方。有许多开源解决方案可用于存储 Helm 图表。GitHub 可以用作 Helm
    图表的远程注册库。创建一个名为 watchlist-charts 的新 GitHub 仓库，并创建一个空的 index.yaml 文件。此文件将包含有关存储库中可用图表的元数据。
- en: Note Nexus Repository OSS supports Helm charts as well. You can publish charts
    to a Helm-hosted repository on Nexus.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Nexus Repository OSS 也支持 Helm 图表。您可以将图表发布到 Nexus 托管的 Helm 仓库。
- en: Then, push this file to the master branch by issuing these commands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过执行以下命令将此文件推送到主分支。
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The GitHub repository will look like figure 11.21.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库将看起来像图 11.21。
- en: '![](Images/CH11_F21_Labouardy.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F21_Labouardy.png)'
- en: Figure 11.21 Helm charts GitHub repository
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.21 Helm 图表 GitHub 仓库
- en: The Helm repository is an HTTP server that has a file index.yaml and all your
    chart files. To turn the GitHub repository into an HTTP server, we will enable
    GitHub pages.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 仓库是一个具有文件 index.yaml 和所有您的图表文件的 HTTP 服务器。为了将 GitHub 仓库变成 HTTP 服务器，我们将启用
    GitHub Pages。
- en: Click the Settings tab. Scroll down to the GitHub Pages section and select the
    master branch as a source, as shown in figure 11.22.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 点击设置选项卡。向下滚动到 GitHub Pages 部分，并选择 master 分支作为源，如图 11.22 所示。
- en: '![](Images/CH11_F22_Labouardy.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F22_Labouardy.png)'
- en: Figure 11.22 Enabling GitHub pages
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.22 启用 GitHub 页面
- en: With the private Helm repository ready to be used, let’s package and publish
    our first Helm chart. On the movies-marketplace project, update the `Build` stage
    to use a parallel build to build the Docker image and the Helm chart. The `Build`
    stage should look like the following listing. (The complete Jenkinsfile is available
    at chapter11/pipeline/movies-marketplace/Jenkinsfile.)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 Helm 仓库准备就绪并可供使用后，让我们打包并发布我们的第一个 Helm 图表。在 movies-marketplace 项目中，更新 `Build`
    阶段以使用并行构建来构建 Docker 图像和 Helm 图表。`Build` 阶段应如下所示。（完整的 Jenkinsfile 可在 chapter11/pipeline/movies-marketplace/Jenkinsfile
    中找到。）
- en: Listing 11.20 Building the Docker image and Helm chart
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.20 构建 Docker 图像和 Helm 图表
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Builds the appropriate Docker image by injecting the target environment settings
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过注入目标环境设置构建适当的 Docker 图像
- en: ❷ Packages the application in a Helm chart
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将应用程序打包到 Helm 图表中
- en: The `helm package` command, as its name indicates, packages the chart directory
    into a chart archive (movies-marketplace-1.0.0.tgz). Finally, update the `Push`
    stage to use a parallel step as well, as shown in the following listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm package` 命令，如其名称所示，将图表目录打包到图表存档（movies-marketplace-1.0.0.tgz）。最后，更新 `Push`
    阶段以使用并行步骤，如下所示。'
- en: Listing 11.21 Storing the Docker image in a private registry
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.21 在私有注册表中存储 Docker 图像
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Authenticates with ECR in order to push the Docker images afterward
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过 ECR 进行身份验证，以便之后推送 Docker 图像
- en: ❷ Tags and stores the image in ECR
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标记并存储图像到 ECR
- en: ❸ Publishes the Helm chart to GitHub—see listing 11.22 for complete instructions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将Helm图表发布到GitHub——有关完整说明，请参阅列表11.22。
- en: The `Helm` `Chart` stage will clone the watchlist-charts GitHub repository with
    the `git clone` command, and add the metadata of the new packaged Helm chart to
    index.yaml with the `helm` `repo` `index` command. Then it pushes index.yaml and
    the archive chart to the Git repository; see the following listing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Helm` `Chart`阶段将使用`git clone`命令克隆watchlist-charts GitHub仓库，并使用`helm` `repo`
    `index`命令将新打包的Helm图表的元数据添加到index.yaml中。然后它将index.yaml和存档图表推送到Git仓库；请参阅以下列表。'
- en: Listing 11.22 Publishing the Helm chart to GitHub
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.22 将Helm图表发布到GitHub
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Generates an index file, given a directory containing packaged charts
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据包含打包图表的目录生成索引文件
- en: ❷ Provides SSH credentials to builds via an ssh-agent
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过ssh-agent为构建提供SSH凭据
- en: ❸ Changes current directory to watchlist-charts folder
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将当前目录更改为watchlist-charts文件夹
- en: ❹ Commits and pushes the archive and index file to GitHub
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将存档和索引文件提交并推送到GitHub
- en: If you push the new Jenkinsfile to the Git remote repository, a new pipeline
    will be triggered, as shown in figure 11.23\. At the `Build` stage, the movies-marketplace
    Docker image and Helm chart will be packaged. Next, the `Push` stage will be executed
    to push the Docker image to the Docker private registry and the Helm chart to
    the GitHub repository.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将新的Jenkinsfile推送到Git远程仓库，将触发一个新的流水线，如图11.23所示。在`构建`阶段，将打包movies-marketplace
    Docker镜像和Helm图表。接下来，将执行`推送`阶段，将Docker镜像推送到Docker私有仓库，将Helm图表推送到GitHub仓库。
- en: '![](Images/CH11_F23_Labouardy.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F23_Labouardy.png)'
- en: Figure 11.23 CI/CD workflow with Helm and Docker
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 使用Helm和Docker的CI/CD工作流程
- en: Upon the completion of the CI/CD pipeline, a new archived chart will be available
    in the GitHub repository, as shown in figure 11.24.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD管道完成后，GitHub仓库中将出现一个新的存档图表，如图11.24所示。
- en: '![](Images/CH11_F24_Labouardy.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F24_Labouardy.png)'
- en: Figure 11.24 Packaging the Movies Marketplace chart
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 打包Movies Marketplace图表
- en: The index.yaml file will reference the newly built Helm chart under the `entries`
    section, as you can see in figure 11.25.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: index.yaml文件将在`entries`部分引用新构建的Helm图表，如图11.25所示。
- en: '![](Images/CH11_F25_Labouardy.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F25_Labouardy.png)'
- en: Figure 11.25 Helm repository metadata
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 Helm仓库元数据
- en: 'You can override the chart version set in Chart.yaml by providing the new version
    with the `--version` flag at the time of packaging a Helm chart:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在打包Helm图表时使用`--version`标志提供新版本来覆盖Chart.yaml中设置的图表版本：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Repeat the same steps for other repositories to create a Helm chart per service.
    Once done, the Helm charts repository should contain four archived files (figure
    11.26).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他仓库重复相同的步骤以为每个服务创建一个Helm图表。完成后，Helm图表仓库应包含四个存档文件（图11.26）。
- en: '![](Images/CH11_F26_Labouardy.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F26_Labouardy.png)'
- en: Figure 11.26 Application charts stored in the GitHub repository
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 存储在GitHub仓库中的应用图表
- en: 'Next, we configure the GitHub repository as a Helm repository:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置GitHub仓库作为Helm仓库：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Finally, we can reference these charts in the watchlist Chart.yaml file under
    the `dependencies` section, as shown in the following listing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在以下列表中`dependencies`部分下的watchlist Chart.yaml文件中引用这些图表，如下所示。
- en: Listing 11.23 Watchlist application charts
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.23 观察列表应用图表
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that all pieces are running together and we checked the core functionality,
    let’s validate that the solution is up for a typical GitFlow development process.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有组件都在一起运行，我们已经检查了核心功能，让我们验证该解决方案是否适用于典型的GitFlow开发流程。
- en: 11.5 Running post-deployment smoke tests
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 运行部署后烟雾测试
- en: The microservices are deployed. However, that doesn’t mean these services are
    properly configured and correctly performing all the jobs that they’re supposed
    to be doing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务已部署。但这并不意味着这些服务已正确配置并且正确执行了它们应该执行的所有任务。
- en: You want to have a health check that indicates the current health operation
    of your services. You can set up a simple one by implementing an HTTP request
    to a service URL and check whether the response code is 200.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望有一个健康检查，指示你的服务的当前健康操作。你可以通过实现一个对服务URL的HTTP请求并检查响应代码是否为200来设置一个简单的检查。
- en: For instance, let’s implement a health check for the movies-store service. Update
    the Jenkinsfile of the movies-store project (chapter11/pipeline/movies-store/Jenkinsfile)
    to add the function shown in the following listing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们为 movies-store 服务实现一个健康检查。更新 movies-store 项目的 Jenkinsfile（chapter11/pipeline/movies-store/Jenkinsfile），添加以下列表中显示的功能。
- en: Listing 11.24 Groovy function to return API URL
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.24 返回 API URL 的 Groovy 函数
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The function returns the service URL based on the current Git branch name.
    Finally, we add a `Healthcheck` stage at the end of the pipeline to issue a cURL
    command on the service URL:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数根据当前的 Git 分支名称返回服务 URL。最后，我们在管道的末尾添加一个 `Healthcheck` 阶段，对服务 URL 执行 cURL 命令：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `-m` flag is used to set a time-out of 10 seconds, to give Kubernetes enough
    time to pull the latest built image and deploy the changes into the cluster before
    checking the service health status.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 标志用于设置10秒的超时时间，以便在检查服务健康状态之前，给 Kubernetes 足够的时间拉取最新构建的镜像并将更改部署到集群中。'
- en: Once you push the changes to the Git remote repository, a new build will be
    triggered. Upon the completion of the CI/CD pipeline, a cURL command will be executed
    with a GET request on the service URL, as shown in figure 11.27.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将更改推送到 Git 远程仓库，就会触发一个新的构建。CI/CD 管道完成后，将执行一个 cURL 命令，对服务 URL 进行 GET 请求，如图
    11.27 所示。
- en: '![](Images/CH11_F27_Labouardy.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F27_Labouardy.png)'
- en: Figure 11.27 cURL command output
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/CH11_F27_Labouardy.png)'
- en: If the service responds before the expiration time-out, the cURL command will
    return a successful exit code. Otherwise, an error will be thrown to make the
    pipeline fail.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务在超时时间之前响应，cURL 命令将返回成功的退出代码。否则，将抛出错误，使管道失败。
- en: However, if the service is responding, that doesn’t mean it’s working correctly
    or a new version of the service has been successfully deployed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果服务正在响应，这并不意味着它运行正确，或者服务的新版本已经成功部署。
- en: To be able to issue advanced HTTP requests against the service URL, we will
    install the Jenkins HTTP Request plugin ([www.jenkins.io/doc/pipeline/steps/http_request/](https://www.jenkins.io/doc/pipeline/steps/http_request/))
    from the Jenkins Plugins page, as shown in figure 11.28.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够对服务 URL 发出高级 HTTP 请求，我们将从 Jenkins 插件页面安装 Jenkins HTTP 请求插件（[www.jenkins.io/doc/pipeline/steps/http_request/](https://www.jenkins.io/doc/pipeline/steps/http_request/))，如图
    11.28 所示。
- en: '![](Images/CH11_F28_Labouardy.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F28_Labouardy.png)'
- en: Figure 11.28 Jenkins HTTP Request plugin
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/CH11_F28_Labouardy.png) Jenkins HTTP 请求插件'
- en: We can now update the movies-store’s Jenkinsfile. The plugin offers an `httpRequest`
    DSL object that can be used to call a remote URL. In the following listing, `httpRequest`
    returns a response object that exposes the response body through a `content` attribute.
    Then, we use the `JsonSlurper` class to parse the response to a JSON object. The
    updated `Healthcheck` stage is shown in the following listing.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新 movies-store 的 Jenkinsfile。该插件提供了一个 `httpRequest` DSL 对象，可以用来调用远程 URL。在下面的列表中，`httpRequest`
    返回一个响应对象，通过 `content` 属性公开响应体。然后，我们使用 `JsonSlurper` 类将响应解析为 JSON 对象。更新的 `Healthcheck`
    阶段在下面的列表中显示。
- en: Listing 11.25 Movie store Healthcheck stage
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.25 电影商店健康检查阶段
- en: '[PRE53]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The service returns the version number deployed in Kubernetes. This value is
    fixed in the service source code, but you can inject the Jenkins build ID as a
    version number while building the Docker image of the service and check whether
    the returned version is equal to the Jenkins build ID at the `Healthcheck` stage.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 服务返回在 Kubernetes 中部署的版本号。这个值在服务源代码中是固定的，但在构建服务的 Docker 镜像时，你可以将 Jenkins 构建ID注入为版本号，并在
    `Healthcheck` 阶段检查返回的版本是否等于 Jenkins 构建ID。
- en: Figure 11.29 shows the end result of the CI/CD pipeline of each microservice
    running in Kubernetes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/CH11_F29_Labouardy.png) 显示了在 Kubernetes 中运行的每个微服务的 CI/CD 管道的最终结果。'
- en: '![](Images/CH11_F29_Labouardy.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F29_Labouardy.png)'
- en: Figure 11.29 Complete CI/CD workflow for containerized microservices
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](Images/CH11_F29_Labouardy.png)'
- en: When you opt for Jenkins to build cloud-native applications running in Kubernetes,
    you’re required to create extensive configurations, as well as spending considerable
    time learning and using all of the necessary plugins to make it happen. Fortunately,
    Jenkins X comes into play to offer simplicity and ready-to-go templates.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择使用 Jenkins 来构建运行在 Kubernetes 中的云原生应用时，你需要创建大量的配置，并且需要花费相当多的时间去学习和使用所有必要的插件来实现这一目标。幸运的是，Jenkins
    X 出现了，它提供了简单易用的模板。
- en: 11.6 Discovering Jenkins X
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 发现 Jenkins X
- en: '*Jenkins X* ([https://jenkins-x.io/](https://jenkins-x.io/)) is a CI/CD solution
    for modern cloud applications on Kubernetes. It’s used to simplify the configurations
    and lets you harness the power of Jenkins 2.0\. It also lets you use open source
    tools like Helm, Artifact Hub, ChartMuseum, Nexus, and Docker Registry to easily
    build cloud-native applications.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jenkins X* ([https://jenkins-x.io/](https://jenkins-x.io/))是Kubernetes上现代云应用的CI/CD解决方案。它用于简化配置，并让你利用Jenkins
    2.0的力量。它还让你能够使用像Helm、Artifact Hub、ChartMuseum、Nexus和Docker Registry这样的开源工具，轻松构建云原生应用。'
- en: 'Jenkins X adds what’s missing from Jenkins: comprehensive support for continuous
    delivery and managing the promotion of projects to preview, staging, and production
    environments running in Kubernetes. It uses GitOps to manage the configuration
    and version of the Kubernetes resources that are deployed to each environment.
    So each environment has its own Git repository that contains all the Helm charts,
    their versions, and the configuration for the applications to be run in the environment.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X为Jenkins添加了缺失的功能：对持续交付的全面支持，以及管理将项目提升到运行在Kubernetes中的预览、测试和生产环境的推广。它使用GitOps来管理部署到每个环境的Kubernetes资源的配置和版本。因此，每个环境都有自己的Git仓库，其中包含所有Helm图表、它们的版本以及在该环境中运行的应用程序的配置。
- en: When following this methodology, Git is the single source of truth for both
    the infrastructure as code and the application code. All changes to the desired
    state are Git commits. So it’s easy to see who made changes when, and more importantly,
    it’s then easy to revert changes that cause bad things to happen.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循此方法时，Git是基础设施代码和应用代码的唯一真相来源。所有对期望状态的变化都是Git提交。因此，很容易看到谁在何时进行了更改，更重要的是，如果更改导致不良后果，那么很容易回滚这些更改。
- en: 'With that being said, let’s get our hands dirty and cover how Jenkins X works.
    To get started, install the Jenkins X CLI, and pick the most suitable instructions
    for your operating system: [http://mng.bz/20ZX](http://mng.bz/20ZX). Run `jx`
    `version` `--short` to make sure you’re on the latest stable version. I’m using
    version 2.1.71 at the time of writing this book.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们动手实践，了解Jenkins X是如何工作的。要开始，请安装Jenkins X CLI，并选择适合你操作系统的最合适说明：[http://mng.bz/20ZX](http://mng.bz/20ZX)。运行`jx`
    `version` `--short`以确保你使用的是最新稳定版本。我在撰写本书时使用的是版本2.1.71。
- en: 'Jenkins X runs on a Kubernetes cluster. If you’re running on one of the major
    cloud providers (Amazon EKS, GKE, or AKS), Jenkins X provides multiple approaches
    for creating this cluster:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X运行在Kubernetes集群上。如果你在主要的云服务提供商（Amazon EKS、GKE或AKS）上运行，Jenkins X提供了多种创建此集群的方法：
- en: '[PRE54]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note You can run Jenkins X on the existing EKS cluster by referring to the official
    guide at [https://jenkins-x.io/v3/admin/setup/operator/](https://jenkins-x.io/v3/admin/setup/operator/).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以通过参考官方指南在现有的EKS集群上运行Jenkins X，官方指南请见[https://jenkins-x.io/v3/admin/setup/operator/](https://jenkins-x.io/v3/admin/setup/operator/)。
- en: 'Install Jenkins X on a K8s cluster by issuing the following command from your
    terminal session:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端会话中运行以下命令，在K8s集群上安装Jenkins X：
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You will be asked a series of questions that will configure the installation,
    as shown in figure 11.30.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要回答一系列问题来配置安装，如图11.30所示。
- en: When the installation is done, you will be presented with useful links and the
    password for your Jenkins X–related services. Don’t forget to save it somewhere
    for future use.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将看到有用的链接和Jenkins X相关服务的密码。不要忘记将其保存在某处以备将来使用。
- en: Jenkins X also deploys a set of supporting services, including the Jenkins dashboard,
    Docker Registry, ChartMuseum, and Artifact Hub to manage Helm charts, and Nexus,
    which serves as a Maven and npm repository.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X还部署了一系列支持服务，包括Jenkins仪表板、Docker Registry、ChartMuseum和Artifact Hub来管理Helm图表，以及Nexus，它作为Maven和npm仓库。
- en: '![](Images/CH11_F30_Labouardy.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F30_Labouardy.png)'
- en: Figure 11.30 Jenkins X installation output
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 Jenkins X安装输出
- en: 'The following is the output of the `kubectl` `get` `svc` command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`kubectl` `get` `svc`命令的输出：
- en: '![](Images/CH11_F30_UN13_Labouardy.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F30_UN13_Labouardy.png)'
- en: Point your browser to the Jenkins URL printed during the installation process
    and sign in with the admin username and password displayed previously in figure
    11.30\. The dashboard in figure 11.31 should be served.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的浏览器指向安装过程中打印的Jenkins URL，并使用图11.30中显示的管理员用户名和密码登录。图11.31中的仪表板应该被提供。
- en: '![](Images/CH11_F31_Labouardy.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH11_F31_Labouardy.png)'
- en: Figure 11.31 Jenkins web dashboard
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 Jenkins网页仪表板
- en: It is possible to run Jenkins in serverless mode while installing Jenkins X.
    Then, instead of running the Jenkins web dashboard, which continuously consumes
    CPU and memory resources, you can run Jenkins only when you need it.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Jenkins X 的同时，你可以以无服务器模式运行 Jenkins。然后，你不需要运行持续消耗 CPU 和内存资源的 Jenkins 网页仪表板，而只需在你需要时运行
    Jenkins。
- en: 'The Jenkins X installation also creates two Git repositories by default: one
    for your staging environment and one for production, as shown in figure 11.32:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 安装还默认创建了两个 Git 仓库：一个用于你的暂存环境，一个用于生产环境，如图 11.32 所示：
- en: '*Staging*—Any merge performed on the project master branch will automatically
    be deployed as a new version to staging (auto promote).'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暂存*—在项目主分支上执行的任何合并都将自动作为新版本部署到暂存环境（自动提升）。'
- en: '*Production*—You will have to manually promote your staging application version
    into production by using a `jx` `promote` command.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生产*—你必须手动使用 `jx` `promote` 命令将你的暂存应用程序版本提升到生产环境。'
- en: '![](Images/CH11_F32_Labouardy.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F32_Labouardy.png)'
- en: Figure 11.32 Application deployment environments
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.32 应用部署环境
- en: Jenkins X uses these repositories to manage deployments to each environment,
    and promotions are done via Git pull requests. Each repository contains a Helm
    chart that specifies the applications to be deployed to the corresponding environment.
    Each repository also has a Jenkinsfile to handle promotions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 使用这些仓库来管理每个环境的部署，并且通过 Git pull 请求进行提升。每个仓库都包含一个 Helm 图表，指定要部署到相应环境的应用程序。每个仓库还有一个
    Jenkinsfile 来处理提升。
- en: 'Now that you have a working cluster with Jenkins X installed, we are going
    to create an application that can be built and deployed with Jenkins X. For clarity,
    I have created a RESTful API in Go that serves an HTTP endpoint with a list of
    the top 100 IMDb movies. We will import this project inside Jenkins with this
    command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 Jenkins X 的运行集群，我们将创建一个可以使用 Jenkins X 构建和部署的应用程序。为了清晰起见，我使用 Go 创建了一个
    RESTful API，它提供了一个包含前 100 部 IMDb 电影的 HTTP 端点列表。我们将使用以下命令将此项目导入 Jenkins：
- en: '[PRE56]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you wish to import a project that is already in a remote Git repository,
    you can use the `--url` argument:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望导入一个已经存在于远程 Git 仓库中的项目，你可以使用 `--url` 参数：
- en: '[PRE57]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following is the output of the import command:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为导入命令的输出：
- en: '![](Images/CH11_F32_UN14_Labouardy.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F32_UN14_Labouardy.png)'
- en: Jenkins X will go over the code and choose the right default build pack for
    the project based on the programming language. Our project was developed in Go,
    so it will be a Go build pack. Jenkins X will generate a Jenkinsfile, Dockerfile,
    and Helm chart based on the project runtime environment. The import command will
    create a remote repository on GitHub, register a webhook, and push the code to
    the remote repository, shown in figure 11.33.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 将检查代码并根据项目使用的编程语言选择正确的默认构建包。我们的项目是用 Go 开发的，所以它将是一个 Go 构建包。Jenkins
    X 将根据项目的运行环境生成 Jenkinsfile、Dockerfile 和 Helm 图表。导入命令将在 GitHub 上创建一个远程仓库，注册一个 webhook，并将代码推送到远程仓库，如图
    11.33 所示。
- en: '![](Images/CH11_F33_Labouardy.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F33_Labouardy.png)'
- en: Figure 11.33 Application GitHub repository
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.33 应用 GitHub 仓库
- en: 'Jenkins X will also automatically create a Jenkins multibranch pipeline job
    for the project, and the pipeline will be triggered. You can check the progress
    of the pipeline with this command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 还会自动为项目创建一个 Jenkins 多分支管道作业，并且管道将被触发。你可以使用以下命令检查管道的进度：
- en: '[PRE58]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![](Images/CH11_F33_UN15_Labouardy.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F33_UN15_Labouardy.png)'
- en: You can also track the progress of the pipeline from the Jenkins dashboard by
    clicking the project job; figure 11.34 shows the result.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过点击项目作业从 Jenkins 仪表板跟踪管道的进度；图 11.34 显示了结果。
- en: '![](Images/CH11_F34_Labouardy.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F34_Labouardy.png)'
- en: Figure 11.34 Application build pipeline
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.34 应用构建管道
- en: The pipeline stages are executed on a Kubernetes pod running in the Kubernetes
    cluster we provisioned earlier, as you can see in figure 11.35.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 管道阶段在我们在前面配置的 Kubernetes 集群中运行的 Kubernetes pod 上执行，如图 11.35 所示。
- en: '![](Images/CH11_F35_Labouardy.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F35_Labouardy.png)'
- en: Figure 11.35 Jenkins workers based on Kubernetes pods
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.35 基于 Kubernetes pod 的 Jenkins 工作节点
- en: The executed pipeline will clone the repository, build the Docker image, and
    push it to a Docker registry, as shown in the following listing.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的管道将克隆仓库，构建 Docker 镜像，并将其推送到 Docker 仓库，如下面的列表所示。
- en: Listing 11.26 Build stage when an event occurs on master branch
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.26 主分支上发生事件时的构建阶段
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A Helm chart will be packaged and pushed to the ChartMuseum repository, and
    a new release will be published on the project GitHub repository, as shown in
    figure 11.36\. Jenkins X uses semantic versioning for tagging.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表将被打包并推送到 ChartMuseum 仓库，同时在项目的 GitHub 仓库中发布一个新版本，如图 11.36 所示。Jenkins
    X 使用语义版本控制进行标记。
- en: '![](Images/CH11_F36_Labouardy.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F36_Labouardy.png)'
- en: Figure 11.36 Publishing the application release
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.36 发布应用程序版本
- en: The release will be promoted automatically to the staging environment, as shown
    in figure 11.37.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 版本将自动推广到预发布环境，如图 11.37 所示。
- en: '![](Images/CH11_F37_Labouardy.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F37_Labouardy.png)'
- en: Figure 11.37 Jenkins pipeline on the master branch
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.37 主分支上的 Jenkins 管道
- en: During the promotion stage, a new PR will be created by Jenkins X to deploy
    the new release to staging. This PR will add our application and its version in
    the env/requirements.yaml file inside the Git repository, as shown in figure 11.38.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在推广阶段，Jenkins X 将创建一个新的 PR 来将新版本部署到预发布环境。这个 PR 将在我们的 Git 仓库中的 env/requirements.yaml
    文件中添加我们的应用程序及其版本，如图 11.38 所示。
- en: '![](Images/CH11_F38_Labouardy.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F38_Labouardy.png)'
- en: Figure 11.38 Promoting the application to staging
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.38 将应用程序推广到预发布环境
- en: Now you can see that the multibranch jx-movies-store pipeline is triggered for
    the pull request. It will check out the PR, perform a `helm build`, and execute
    tests on the environment along with code review and approval. When it’s successful,
    it will merge the PR with the master, see figure 11.39.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到，多分支 jx-movies-store 管道被触发以处理拉取请求。它将检出 PR，执行 `helm build`，并在环境中执行测试，包括代码审查和批准。成功后，它将合并
    PR 到主分支，见图 11.39。
- en: '![](Images/CH11_F39_Labouardy.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F39_Labouardy.png)'
- en: Figure 11.39 Deploying an application to staging
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.39 将应用程序部署到预发布环境
- en: Once the application is deployed, we can type `jx` `get` `applications` to get
    the access URL for the application, as shown in figure 11.40.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序部署完成，我们可以输入 `jx get applications` 来获取应用程序的访问 URL，如图 11.40 所示。
- en: '![](Images/CH11_F40_Labouardy.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F40_Labouardy.png)'
- en: Figure 11.40 Application overall health status
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.40 应用程序整体健康状况
- en: 'Now we will update our application and see what will happen! Let’s create a
    new feature branch:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新我们的应用程序并看看会发生什么！让我们创建一个新的功能分支：
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Jenkins X creates a GitHub webhook during the import of our application. This
    means we can just commit a change, and our application will be updated automatically,
    as shown in figure 11.41.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 在导入我们的应用程序期间创建了一个 GitHub webhook。这意味着我们只需提交一个更改，我们的应用程序就会自动更新，如图 11.41
    所示。
- en: '![](Images/CH11_F41_Labouardy.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F41_Labouardy.png)'
- en: Figure 11.41 Building GitHub pull request
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.41 构建 GitHub 拉取请求
- en: 'Jenkins X automatically spins up preview environments for our pull request,
    so we can get fast feedback before changes are merged to the master:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 在导入我们的应用程序期间创建了一个 GitHub webhook。这意味着我们只需提交一个更改，我们的应用程序就会自动更新，如图 11.41
    所示。
- en: '![](Images/CH11_F41_UN16_Labouardy.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F41_UN16_Labouardy.png)'
- en: Jenkins X creates a preview environment in the PR for the application changes
    and displays a link to evaluate the new feature, as shown in figure 11.42.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 为应用程序的更改创建了一个预览环境，并显示了评估新功能的链接，如图 11.42 所示。
- en: '![](Images/CH11_F42_Labouardy.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F42_Labouardy.png)'
- en: Figure 11.42 Pull request preview environment
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.42 拉取请求预览环境
- en: The preview environment is created whenever a change is made to the repository,
    allowing any relevant user to validate or evaluate features, bug fixes, or security
    hotfixes. If we click the preview environment URL, we should have access to the
    service REST API, as shown in figure 11.43.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对仓库进行更改时，都会创建一个预览环境，允许任何相关用户验证或评估功能、错误修复或安全热修复。如果我们点击预览环境的 URL，我们应该可以访问服务
    REST API，如图 11.43 所示。
- en: '![](Images/CH11_F43_Labouardy.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F43_Labouardy.png)'
- en: Figure 11.43 Movies Store API
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.43 电影商店 API
- en: Once the new changes are validated, we can confirm the code and functionality
    changes with an `/approve` comment, as shown in figure 11.44\. This simple comment
    will merge the code changes back to the master branch and initiate a build on
    the master branch.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新更改得到验证，我们可以通过一个 `/approve` 注释来确认代码和功能更改，如图 11.44 所示。这个简单的注释会将代码更改合并回主分支，并在主分支上启动构建。
- en: '![](Images/CH11_F44_Labouardy.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F44_Labouardy.png)'
- en: Figure 11.44 ChatOps commands within Git PR
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.44 Git PR 中的 ChatOps 命令
- en: Jenkins X offers multiple commands that can be used while managing pull requests.
    Each command triggers a specific action. Table 11.2 summarizes the most used commands.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 提供了多个在管理拉取请求时可以使用的命令。每个命令都会触发特定的操作。表 11.2 总结了最常用的命令。
- en: Upon the completion of the build on the master branch, a new release will be
    published, as shown in figure 11.45.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在主分支构建完成后，将发布一个新的版本，如图 11.45 所示。
- en: Table 11.2 ChatOps commands
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.2 ChatOps 命令
- en: '| Command | Description |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| /`approve` | This PR can be merged. This command must be from someone in
    the repo OWNERS file. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| /`approve` | 此 PR 可以合并。此命令必须来自仓库 OWNERS 文件中的人。|'
- en: '| /`retest` | Rerun any failed test pipeline contexts for this PR. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| /`retest` | 重新运行此 PR 的任何失败的测试管道上下文。|'
- en: '| `/assign USER` | Assign the PR to the given user. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `/assign USER` | 将 PR 分配给指定的用户。|'
- en: '| /`lgtm` | This PR looks good to me. This command can be from anyone with
    access to the repo. |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| /`lgtm` | 这个 PR 看起来不错。此命令可以来自任何有权访问仓库的人。|'
- en: '![](Images/CH11_F45_Labouardy.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F45_Labouardy.png)'
- en: Figure 11.45 New application release
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.45 新应用程序发布
- en: 'When you’re satisfied with your application, you can use the `jx` CLI to promote
    the application to a different environment using a GitOps approach. For example,
    we can promote our application to production with the following command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对应用程序满意时，您可以使用 `jx` CLI 通过 GitOps 方法将应用程序提升到不同的环境。例如，我们可以使用以下命令将我们的应用程序提升到生产环境：
- en: '[PRE61]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A new PR will be created, but this time on our production repository, and the
    environment-watchlist-production job is triggered, as shown in figure 11.46.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个新的 PR，但这次是在我们的生产仓库中，并且触发了环境监视列表生产作业，如图 11.46 所示。
- en: '![](Images/CH11_F46_Labouardy.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH11_F46_Labouardy.png)'
- en: Figure 11.46 Promoting the application to production
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.46 将应用程序提升到生产环境
- en: Once the pull request is validated, the production pipeline runs Helm, which
    deploys the environment, pulling Helm charts from ChartMuseum, and Docker images
    from the Docker Registry. Kubernetes creates the project’s resources, typically
    a pod, service, and ingress.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拉取请求得到验证，生产管道运行 Helm，部署环境，从 ChartMuseum 拉取 Helm 图表和从 Docker 仓库拉取 Docker 镜像。Kubernetes
    创建项目的资源，通常是 pod、服务和 ingress。
- en: 'Jenkins X uses Git branch patterns to determine which branch names are automatically
    set up for CI/CD. By default, the master branch, and any branch starting with
    *PR-* or *feature* will be scanned. You can set up your own branch discovery mechanism
    with the following command:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 使用 Git 分支模式来确定哪些分支名称会自动设置为 CI/CD。默认情况下，主分支以及任何以 *PR-* 或 *feature*
    开头的分支将被扫描。您可以使用以下命令设置自己的分支发现机制：
- en: '[PRE62]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note If you are done with your Amazon EKS cluster, you should delete it and
    its resources so that you do not incur additional charges. Issue a `terraform
    destroy` command to delete the AWS resources.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您完成了您的 Amazon EKS 集群，您应该删除它及其资源，以免产生额外费用。发出 `terraform destroy` 命令以删除 AWS
    资源。
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kubernetes manages containerized applications on clusters of nodes by helping
    operators deploy, scale, update, and maintain their services, and providing mechanisms
    for service discovery.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 通过帮助操作员部署、扩展、更新和维护他们的服务，并提供服务发现机制，在节点集群上管理容器化应用程序。
- en: The `kubectl apply` command can be used from Jenkins pipelines to perform deployments
    on K8s clusters.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl apply` 命令可以从 Jenkins 管道中使用，以在 K8s 集群上执行部署。'
- en: A Helm chart encapsulates Kubernetes object definitions and provides a mechanism
    for configuration at deployment time.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 图表封装了 Kubernetes 对象定义，并提供了一种在部署时进行配置的机制。
- en: GitHub pages have built-in support for installing Helm charts from an HTTP server.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 页面内置了对从 HTTP 服务器安装 Helm 图表的支持。
- en: Jenkins X creates a Kubernetes pod for each agent started, defined by the Docker
    image to run, and stops it after each build.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X 为每个启动的代理创建一个 Kubernetes 容器，由运行 Docker 镜像定义，并在每次构建后停止它。
- en: Jenkins X preview environments are used to get early feedback on changes to
    applications before the changes are merged into the master branch.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X 预览环境用于在更改合并到主分支之前对应用程序的更改获取早期反馈。
- en: Jenkins X does not aim to replace Jenkins but builds on it with best-of-breed
    open source tools. It’s a great way to achieve CI/CD with batteries included,
    without having to assemble things together.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X 并不旨在取代 Jenkins，而是通过最佳开源工具构建在它之上。这是一个包含电池的 CI/CD 的绝佳方式，无需组装任何东西。
