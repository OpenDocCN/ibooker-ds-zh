- en: 4 Functional Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 功能组件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing functional components
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍功能组件
- en: Comparing functional components to class-based components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较功能组件和基于类的组件
- en: Choosing between the two types of component definitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两种组件定义类型之间进行选择
- en: Converting a class-based component to a functional component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基于类的组件转换为功能组件
- en: React was based on class-based components for a long time in the early years,
    but an alternative came along for the simplest of components at some point. Functional
    components are a more succinct and, in some regards, simpler way of writing React
    components, and they now have the same feature set as their class-based cousins.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，React长时间基于基于类的组件，但某个时候出现了替代方案，用于最简单的组件。功能组件是编写React组件的一种更简洁、在某些方面更简单的方式，并且它们现在具有与基于类的同族组件相同的特性集。
- en: The term *functional component* isn’t meant as a contrast to a nonfunctional
    component—no one has any use for those. Rather, the functional part refers to
    the component definition itself being a JavaScript function rather than a JavaScript
    class.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “功能组件”这个术语并不是指与非功能组件相对——没有人需要那些。相反，功能部分指的是组件定义本身是一个JavaScript函数，而不是JavaScript类。
- en: In the beginning, functional components were less powerful than class-based
    components, but when React hooks came about in React 16.8, functional components
    were suddenly as powerful, if not more, than their class-based siblings. Today,
    many React developers exclusively use functional components, as they are the primary
    method recommended by the React team.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，功能组件不如基于类的组件强大，但自从React 16.8中引入了React hooks，功能组件突然变得与基于类的兄弟组件一样强大，甚至更强大。如今，许多React开发者仅使用功能组件，因为这是React团队推荐的主要方法。
- en: 'Class-based components are still fully supported in React and probably not
    going anywhere anytime soon. You’ll also find them very common “in the wild,”
    for several reasons:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的组件在React中仍然完全受支持，并且可能不会在不久的将来消失。你也会发现它们在“野外”非常常见，原因有几个：
- en: Not all older codebases have been refactored away from class-based components
    and must still be maintained.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有旧的代码库都已重构为基于类的组件，并且仍需维护。
- en: Some older libraries still only document how they interface with class-based
    components and thus require your code to use them to interface with the library
    correctly.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些较老的库仍然只记录了它们如何与基于类的组件接口，因此需要你的代码使用它们来正确地与库接口。
- en: Some long-time React developers started using class-based components and feel
    more comfortable with them, so they prefer to stick to them when possible.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些长期使用React的开发者开始使用基于类的组件，并且对他们来说感觉更舒适，因此他们更喜欢在可能的情况下坚持使用它们。
- en: The mental model of a component life cycle changed quite a bit when going from
    class-based to functional components, and, in some instances, the re-render life
    cycle can be easier to maintain when using the old class-based approach.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从基于类的组件转换为功能组件时，组件的生命周期模型发生了相当大的变化，在某些情况下，使用旧有的基于类的方案来维护重新渲染的生命周期可能更容易。
- en: A tiny subset of the core functionality in React is only possible using class-based
    components (error boundary, in particular).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中，只有使用基于类的组件才能实现核心功能的一小部分（特别是错误边界）。
- en: Not only are functional components here to stay, but they’re also going to take
    over the world—at least the React world. All indicators point to functional components
    being the main way to write React going forward. Writing functional components
    makes your life as a developer significantly easier with (almost) no downsides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅功能组件会一直存在，而且它们还将接管世界——至少是React的世界。所有迹象都表明，功能组件将是编写React的主要方式。编写功能组件使开发者的生活（几乎）没有任何缺点地变得更加容易。
- en: In this chapter, we’ll go over what functional components are, how they differ
    (and how they don’t) from class-based components, how to choose which component
    type to use in your projects, and how you can convert a class-based component
    to a functional one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍功能组件是什么，它们如何与基于类的组件不同（以及它们如何相同），如何在项目中选择使用哪种组件类型，以及如何将基于类的组件转换为功能组件。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch04](https://rq2e.com/ch04).
    But, as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中示例的源代码可在[https://rq2e.com/ch04](https://rq2e.com/ch04)找到。但正如你在第二章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 4.1 The shorter way to write React components
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 编写React组件的简短方式
- en: 'In this section, we’ll introduce functional components and slowly add some
    extra utilities on top of them. These utilities are merely syntactic sugar, often
    enabled by modern JavaScript features rather than React-specific functionality.
    However, we’ll introduce these techniques in this chapter because we’ll be using
    all of them in later chapters. They are all standard in the industry, so you’ll
    see them in React codebases all the time. These utilities are all about simplifying
    how you write and interact with components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍函数组件，并逐渐在它们之上添加一些额外的实用工具。这些实用工具仅仅是语法糖，通常由现代JavaScript功能而不是React特定功能启用。然而，我们将在本章中介绍这些技术，因为我们在后面的章节中都会使用它们。它们都是行业标准，所以您将在React代码库中经常看到它们。这些实用工具都是关于简化您编写和交互组件的方式：
- en: Simplifying access to properties using destructuring
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解构简化对属性的访问
- en: Simplifying the component interface with default values
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认值简化组件接口
- en: Simplifying the component interface using pass-through properties
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用透传属性简化组件接口
- en: Together, these utilities will give you a good foundation to write simple, presentational
    React components using concise component definitions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用工具共同为您提供了编写简单、表现性React组件的良好基础，使用简洁的组件定义。
- en: 4.1.1 An example application
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 一个示例应用
- en: 'Let’s create a simple React application: a menu with a list of links all built
    with plain HTML. This is a very simple HTML fragment with a website menu, but
    it’s one of the building blocks of every web application.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的React应用程序：一个带有链接列表的菜单，所有这些链接都是用纯HTML构建的。这是一个非常简单的HTML片段，包含网站菜单，但它是每个Web应用程序的构建块之一。
- en: We’ll use this example to illustrate that when components get even a tiny bit
    complex, the three utilities mentioned previously will help us keep our components
    simple both on the outside and the inside. See the component tree in figure 4.1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个示例来说明，当组件变得稍微复杂一些时，前面提到的三个实用工具将帮助我们保持组件在外部和内部都保持简单。参见图4.1中的组件树。
- en: '![04-01](../Images/04-01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](../Images/04-01.png)'
- en: Figure 4.1 A tree diagram of our menu application showing the overall structure
    of components from the <App> at the top to the text nodes at the bottom
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 我们菜单应用程序的树形图，显示了从顶部的`<App>`到底部的文本节点组件的整体结构
- en: The output of this application will look like figure 4.2 in the browser.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的输出在浏览器中看起来将类似于图4.2。
- en: '![04-02](../Images/04-02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](../Images/04-02.png)'
- en: Figure 4.2 Our menu application as seen in the browser. It’s simple HTML with
    a tiny bit of styling.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 浏览器中看到的我们的菜单应用程序。这是一个简单的HTML，带有一点点样式。
- en: First, we’ll create it as we’ve seen previously using class-based components,
    and then secondly, we’ll create those same components using functions. When we
    get there, we’ll have a short discussion about which way is better. Note that
    this is a subjective discussion—there is no right answer—and you should feel free
    to use whatever method you feel works best for you.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将像之前看到的那样使用基于类的组件来创建它，然后其次，我们将使用函数创建相同的组件。当我们到达那里时，我们将简要讨论哪种方式更好。请注意，这是一个主观的讨论——没有正确答案——您应该自由地使用您认为最适合您的方法。
- en: Implementation using classes
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类实现
- en: 'This application includes three components: <App/>, <Menu /> inside <App/>,
    and <MenuItem />s in <Menu />. For now, let’s just put everything in the same
    file, that is, the App.js file, as shown in listing 4.1.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序包括三个组件：`<App/>`、`<App/>`内部的`<Menu/>`和`<Menu/>`中的`<MenuItem/>`。目前，让我们把所有东西都放在同一个文件中，即App.js文件，如列表4.1所示。
- en: Listing 4.1 Menu application using classes
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 使用类的菜单应用程序
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports a CSS file to style the application
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入CSS文件以设置应用程序样式
- en: ❷ Defines a new component
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个新组件
- en: ❸ Uses a standard HTML tag
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用标准HTML标签
- en: ❹ Makes an instance of another custom component without passing properties
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 不传递属性就创建另一个自定义组件的实例
- en: ❺ Passes properties to a custom component
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将属性传递给自定义组件
- en: ❻ Uses properties passed to a custom component
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用传递给自定义组件的属性
- en: 'Repository: rq04-menu-class'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq04-menu-class
- en: 'This example can be seen in repository rq04-menu-class. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在rq04-menu-class存储库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-menu-class](https://rq2e.com/rq04-menu-class)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-menu-class](https://rq2e.com/rq04-menu-class)'
- en: This application only uses things we already know. For example, we can nest
    components, use both built-in HTML components and our own custom components, pass
    properties to child components, and access properties passed to our custom components.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序只使用了我们已知的内容。例如，我们可以嵌套组件，使用内置的HTML组件和我们的自定义组件，向子组件传递属性，以及访问传递给我们的自定义组件的属性。
- en: Yes, we do also import a CSS file in this application. This is supported by
    CRA out of the box, and you can also see this in the default template when you
    create a new create-react-app (CRA) app as we showed previously in chapter 2.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们也在这个应用程序中导入了一个CSS文件。CRA（Create React App）默认支持这一点，您也可以在创建新的create-react-app（CRA）应用程序时在默认模板中看到这一点，正如我们在第2章中展示的那样。
- en: Implementation using functions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的实现
- en: For this example, we’re just going to throw ourselves in at the deep end. Let’s
    see what this same application looks like using functional components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将直接深入实践。让我们看看使用功能组件的相同应用程序看起来是什么样子。
- en: Listing 4.2 Menu application using functions
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 使用函数的菜单应用程序
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ These two functional components do not take any arguments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这两个功能组件不接受任何参数。
- en: ❷ This functional component does take a (single) argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个功能组件接受一个（单个）参数。
- en: 'Repository: rq04-menu-function'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-menu-function
- en: 'This example can be seen in repository rq04-menu-function. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-menu-function仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-menu-function](https://rq2e.com/rq04-menu-function)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-menu-function](https://rq2e.com/rq04-menu-function)'
- en: This almost looks too good to be true. To create a functional component, we
    simply create a function and return JavaScript XML (JSX)—that’s it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎太完美了，以至于不像是真的。要创建一个功能组件，我们只需创建一个函数并返回JavaScript XML（JSX）——就是这样。
- en: If we need to access properties passed to the component, we can do that through
    the single argument passed to the function, which is a frozen object of properties.
    This works similarly to this.props in a class-based component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要访问传递给组件的属性，我们可以通过传递给函数的单个参数（即属性的一个冻结对象）来实现。这与基于类的组件中的this.props的工作方式类似。
- en: Any function will do
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何函数都可以
- en: As you saw in listing 4.2 in the annotations, some functional components accept
    a props argument, but some do not. In addition, we used the statement version
    (i.e., function name() {}) of the function definition, but we didn’t have to.
    Any value that can be executed as a function, that returns JSX, can be used as
    a component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在注释中的列表4.2中看到的，一些功能组件接受一个props参数，但有些则不接受。此外，我们使用了函数定义的语句版本（即function name()
    {}），但实际上我们并不需要这样做。任何可以作为函数执行并返回JSX的值都可以用作组件。
- en: You can even define them inline in another component. This isn’t generally considered
    a good practice, but sometimes it might be useful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在另一个组件中内联定义它们。这通常被认为不是一种好的做法，但有时可能会有用。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Functional expression using the “function” keyword
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用“function”关键字的功能表达式
- en: ❷ Functional expression using arrow notation
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用箭头符号的功能表达式
- en: Here, we define one component, App, using a function expression, and another
    component, EmptyMenu, right in the function body using arrow notation. This is
    an empty list for now (so it doesn’t display any menu items), but it shows just
    how easy creating a component is.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用函数表达式定义了一个组件App，并在函数体内部使用箭头符号定义了另一个组件EmptyMenu。目前这是一个空列表（因此不会显示任何菜单项），但它展示了创建组件是多么简单。
- en: 'The latter function can even be shortened further using implicit return:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个函数甚至可以使用隐式返回进一步缩短：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yes, this is a fully valid React component. It’s a very simple component, for
    sure, and it doesn’t do much (yet), but this *is* a React component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个完全有效的React组件。当然，这是一个非常简单的组件，它目前并没有做很多事情（但会逐渐增加），但**这确实**是一个React组件。
- en: We’ll get back to how this feature of “any function can be a component” can
    be useful in later chapters. For now, just remember that we write our components
    in a certain way out of convention rather than framework constraints.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中回到“任何函数都可以是组件”这一特性如何有用的讨论。现在，只需记住，我们出于惯例而不是框架约束以某种方式编写我们的组件。
- en: 4.1.2 Destructuring properties
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 属性解构
- en: 'In the previous MenuItem example, we received our properties in the functional
    component as a props object and accessed the properties on the object later using,
    for example, props.label. A more common approach used by many React developers
    is to *destructure* the properties directly in the function signature. Destructuring
    is the process of extracting parts of a complex value in a compact way. In JavaScript,
    destructuring an object generally takes this form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个MenuItem示例中，我们以props对象的形式接收了函数组件的属性，并在之后使用，例如，props.label来访问对象的属性。许多React开发者使用的一种更常见的方法是在函数签名中直接解构属性。解构是以紧凑的方式提取复杂值部分的过程。在JavaScript中，解构对象通常具有以下形式：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Destructures “someObject” into parts “a” and “b”
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将“someObject”解构为“a”和“b”部分
- en: This expression assigns the value of someObject.a to the variable a. Similarly,
    the value of someObject.b is assigned to the variable b. The value of someObject.c
    is ignored, as we don’t destructure that in our expression.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将someObject.a的值赋给变量a。同样，someObject.b的值赋给变量b。someObject.c的值被忽略，因为我们没有在我们的表达式中解构它。
- en: 'We can also use destructuring when accepting object arguments to a function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在将对象参数传递给函数时使用解构：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This would result in the following console output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下控制台输出：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For such a simple example, you might question why we don’t make it two different
    arguments instead, such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的例子，您可能会质疑为什么我们不将其改为两个不同的参数，如下所示：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But as functions get more complex and more arguments are added, using just a
    single object makes it a lot easier to call the function with a variable number
    of arguments instead of having to remember that level is the fifth argument, and
    so on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着函数变得更加复杂并且添加了更多的参数，仅使用单个对象就可以更容易地以可变数量的参数调用函数，而不是必须记住级别是第五个参数，依此类推。
- en: In a functional React component, properties are always given as the first (and
    only) argument to our defining functions. We can use the method of destructuring
    the argument object to make the component definition even cleaner in the next
    listing. Note that this is only an excerpt of the file App.js in this example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数式React组件中，属性总是作为定义函数的第一个（也是唯一）参数给出。我们可以使用解构参数对象的方法，使组件定义在下一个列表中更加简洁。请注意，这仅是此示例中文件App.js的摘录。
- en: Listing 4.3 MenuItem with argument destructuring
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3具有参数解构的MenuItem
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Destructs the argument in the function definition
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在函数定义中解构参数
- en: ❷ Allows us to use the properties without going through the props object
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许我们无需通过props对象即可使用属性
- en: 'Repository: rq04-menu-destruct'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq04-menu-destruct
- en: 'This example can be seen in repository rq04-menu-destruct. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq04-menu-destruct存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的实际应用，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-menu-destruct](https://rq2e.com/rq04-menu-destruct)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-menu-destruct](https://rq2e.com/rq04-menu-destruct)'
- en: This is, of course, completely identical to doing destructuring in a line of
    its own inside the function definition in the next listing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然与在下一个列表中函数定义内部单独一行进行解构完全相同。
- en: Listing 4.4 MenuItem with explicit destructuring
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4具有显式解构的MenuItem
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Here, we still accept a props argument without destructuring it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这里，我们仍然接受一个props参数，但没有对其进行解构。
- en: ❷ However, we destruct it as a separate statement in the very first line in
    the component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 然而，我们在组件的第一行将其作为单独的语句进行了解构。
- en: ❸ We can then proceed to use the properties as separate variables as before.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 然后，我们可以像以前一样继续使用作为单独变量的属性。
- en: In this book, we’ll use the approach shown in listing 4.3 with argument destructuring
    directly in the component definition. You’ll also often see this in the wild,
    as many React developers use this convention. As mentioned earlier, however, it’s
    merely a convention; other variants are also possible.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 4.3 列表中展示的方法，在组件定义中直接进行参数解构。您也经常在现实中看到这种情况，因为许多 React 开发者使用这种约定。然而，如前所述，这只是一种约定；其他变体也是可能的。
- en: 4.1.3 Default values
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 默认值
- en: An added benefit of using destructured properties is that we can also introduce
    default values. Let’s say that our menu link to the blog should be opened in a
    new browser window (or tab), but the other links should just open regularly in
    the same session. We can do that by adding a new property, target, that the menu
    has to specify. Note again that this is only an excerpt of App.js.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解构属性的一个额外好处是，我们还可以引入默认值。假设我们的菜单链接到博客应该在新的浏览器窗口（或标签页）中打开，而其他链接应该只在同一个会话中常规打开。我们可以通过添加一个新属性
    target，该属性菜单必须指定来实现这一点。再次注意，这只是一个 App.js 的摘录。
- en: Listing 4.5 Menu items with targets
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 带有目标的菜单项
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Adds a new property to every instance of the menu item component
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为菜单项组件的每个实例添加一个新属性
- en: ❷ Accepts the new property in the destructuring inside the component
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在组件内部的解构中接受新属性
- en: ❸ Assigns the property to the relevant JSX element as an attribute
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将属性作为属性分配给相关的 JSX 元素
- en: However, one could argue that it makes sense that opening a link in the same
    session is the default behavior, and the menu shouldn’t have to specify that.
    We can implement this using default values in the function definition. Note that
    this isn’t React-specific functionality, but just normal JavaScript functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有人可能会认为，在同一个会话中打开链接是默认行为，菜单不需要指定这一点是有意义的。我们可以通过在函数定义中使用默认值来实现这一点。请注意，这不是
    React 特定的功能，而只是正常的 JavaScript 功能。
- en: Listing 4.6 Menu items with a default target
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 带有默认目标的菜单项
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ We don’t have to specify the target property if we don’t need to override
    the default.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果我们不需要覆盖默认值，我们不必指定目标属性。
- en: ❷ But when we do need to override the default, we can do so easily.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 但当我们需要覆盖默认值时，我们可以轻松地做到这一点。
- en: ❸ Defines the default using built-in JavaScript notation for defaults while
    destructuring
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用内置 JavaScript 语法在解构时定义默认值
- en: 'Repository: rq04-menu-default'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-menu-default
- en: 'This example can be seen in repository rq04-menu-default. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在仓库 rq04-menu-default 中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问此网站浏览代码，在您的浏览器中直接查看应用程序的运行情况，或下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq04-menu-default](https://rq2e.com/rq04-menu-default)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-menu-default](https://rq2e.com/rq04-menu-default)'
- en: Ordering properties
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 排序属性
- en: You can specify your component properties in any order you like. Although common
    JavaScript practice is to specify properties with defaults at the end of the definition,
    nothing prevents you from doing it differently.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按任何顺序指定组件属性。尽管常见的 JavaScript 实践是在定义的末尾指定具有默认值的属性，但没有任何东西阻止您以不同的方式做。
- en: 'This means that the following line is generally not recommended, but still
    completely valid:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下行通常不推荐，但仍然完全有效：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And, this is the recommended order:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是推荐的顺序：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This only refers to the order of nondefault properties versus default properties—the
    internal order of either list of properties has no general ordering, so it’s up
    to you or your team to set any such recommendations if desired.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅指非默认属性与默认属性之间的顺序——属性列表的内部顺序没有一般性排序，因此如果您希望，您或您的团队可以设置此类建议。
- en: 4.1.4 Pass-through properties
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 透传属性
- en: 'Let’s make our example even more hypothetical and say that we need various
    extra properties on the different elements:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的例子更加假设化，假设我们需要不同元素上的各种额外属性：
- en: The home link doesn’t need any extra properties.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页链接不需要任何额外属性。
- en: The about link needs an ID of "about-link".
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于链接需要一个 ID 为 "about-link"。
- en: The blog link needs an ID of "blog-link".
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客链接需要一个 ID 为 "blog-link"。
- en: Let’s implement this using what we know so far using default values for unspecified
    values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们目前所知道的知识，使用默认值来实现这一点。
- en: Listing 4.7 Menu items with multiple default values
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 带有多个默认值的菜单项
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is beginning to look a bit repetitive. We’re accepting a bunch of arguments
    only to pass them straight through to a single element—even with the same name
    and everything else intact.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始看起来有点重复。我们接受了一堆参数，只是为了将它们直接传递给单个元素——即使名称和所有其他内容都保持不变。
- en: The rest syntax
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余语法
- en: 'You can indicate that you want some arguments to be handled in a special way
    and all other arguments to be passed straight through to the target element by
    using another modern JavaScript concept known as the *rest syntax*. When destructuring
    an object, you can use the rest syntax, denoted by three periods, to specify an
    object that will be assigned all the leftover properties not already assigned:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用另一种现代 JavaScript 概念，称为 *剩余语法*，来指示您希望某些参数以特殊方式处理，而所有其他参数则直接传递到目标元素。在解构对象时，您可以使用表示剩余语法的三个点来指定一个对象，该对象将分配所有未分配的剩余属性：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The two properties, c and d, which we didn’t already reference in the destructuring
    statement, are transferred as properties to a new object named otherAttrs. Therefore,
    the preceding code snippet is equivalent to the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解构语句中未引用的两个属性 c 和 d，被作为属性传递到一个名为 otherAttrs 的新对象中。因此，前面的代码片段等价于以下代码片段：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use this in a component function definition like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件函数定义中使用它，如下所示：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can capture all the remaining properties in an object, often called rest.
    Now we just need to use this object and apply all the properties inside it to
    an element in the output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有剩余的属性捕获到一个对象中，通常称为剩余。现在我们只需要使用这个对象，并将它内部的全部属性应用到输出元素上。
- en: 'You’ve already seen how to assign properties to a JSX element from an object,
    but to reiterate, we do this using the spread operator:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何从一个对象中将属性分配给 JSX 元素，但为了重申，我们使用扩展操作符来完成这个操作：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember to wrap the spread inside brackets, or it won’t work.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要使用括号包裹扩展，否则它将不起作用。
- en: Rest in practice
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的实际应用
- en: Let’s go back to our example. We want to capture the label and href properties
    passed to our <MenuItem /> component, but we don’t care about the rest. If any
    other properties are passed to the component, we want to pass them straight through
    to our target element. Putting this all together, our component becomes the next
    listing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。我们想要捕获传递给我们的 <MenuItem /> 组件的 label 和 href 属性，但我们不关心剩余的属性。如果向组件传递其他任何属性，我们希望直接将它们传递到我们的目标元素。将这些全部组合起来，我们的组件变成了下一个列表。
- en: Listing 4.8 Menu items with rest and spread
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 带有剩余和扩展的菜单项
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ In this line, "..." is the rest syntax.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这一行中，"..." 是剩余语法。
- en: ❷ In this line, "..." is the spread operator.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这一行中，"..." 是扩展操作符。
- en: 'Repository: rq04-menu-rest'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-menu-rest
- en: 'This example can be seen in repository rq04-menu-rest. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-menu-rest仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在您的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq04-menu-rest](https://rq2e.com/rq04-menu-rest)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-menu-rest](https://rq2e.com/rq04-menu-rest)'
- en: This looks a lot nicer now. We don’t have to specify all those extra properties
    that we don’t really care about. Any other component can pass whatever it wants
    except for a few properties—here, label and href—that will receive special treatment.
    Note that we could even skip listing href as a property now, as it would be included
    in the rest variable, but we still list it because it’s a mandatory property that
    consumers of this component should always specify. Note that this is purely convention,
    not something enforced by React.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了。我们不必指定那些我们实际上并不关心的额外属性。任何其他组件都可以传递它想要的任何东西，除了几个属性——在这里是 label 和 href——它们将接受特殊处理。请注意，我们现在甚至可以省略将
    href 列为属性，因为它将包含在剩余变量中，但我们仍然列出它，因为它是一个强制属性，该组件的消费者应该始终指定。请注意，这纯粹是约定，不是由 React
    强制执行的。
- en: 'A few things to note here: As you can see, the rest syntax and the spread operator
    are identical. Both are three periods before a variable name. However, they are
    used very differently, as one is used for destructuring and the other for assigning.
    They have a similar nature, which is why they look the same, but they are different
    operators altogether.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事项：正如你所见，剩余语法和扩展操作符是相同的。两者都是在变量名前有三个点。然而，它们的使用方式非常不同，一个用于解构，另一个用于赋值。它们有相似的性质，这就是为什么它们看起来相同，但它们是完全不同的操作符。
- en: Using the variable name rest for the extra parameters is a common convention,
    but is by no means a requirement anywhere. You’ll see many developers use it,
    but feel free to change it to something that makes sense to you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量名rest作为额外参数是一种常见约定，但绝不是任何地方的要求。你会看到许多开发者使用它，但请随意将其更改为对你有意义的任何内容。
- en: In addition, this isn’t React-specific functionality, but merely a useful artifact
    of the JavaScript language that you’ll see many React developers use. We’ll be
    using it in future chapters as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这并不是React特有的功能，而仅仅是JavaScript语言的一个有用特性，你会在许多React开发者中使用它。我们将在未来的章节中也会使用它。
- en: Rest and property ordering
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余和属性排序
- en: 'The rest syntax has to be the very last element of the object destructuring,
    so you have to specify it at the end of the property list. When combined with
    default properties, which, of course, is still possible, the common ordering is
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余语法必须是对象解构中的最后一个元素，因此你必须指定在属性列表的末尾。当与默认属性结合使用时（当然，这仍然是可能的），常见的排序顺序如下：
- en: Properties without defaults
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无默认属性
- en: Properties with defaults
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认属性
- en: Rest
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 休息
- en: An example of all three types of properties is
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种属性类型的示例
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 4.2 A comparison of component types
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 组件类型比较
- en: 'At this stage in your React edification, the differences between functional
    components and class-based components might seem small or even insignificant.
    Boiled down to its bare minimum, it’s the difference between writing the following
    as a class-based component:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的React学习过程中，功能组件和基于类的组件之间的差异可能看起来很小，甚至微不足道。简化到最基本的形式，就是以下作为基于类的组件编写的差异：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'versus writing the following as a functional component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下作为功能组件编写的方式相比：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we get to more complex components in later chapters, especially when using
    callbacks and state, things get more complicated, and the differences between
    functional components and their class-based siblings become larger and larger.
    When we get to the composition of components and reuse of generalized functionality,
    very different patterns emerge in the two worlds—almost completely different.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在后面的章节中遇到更复杂的组件时，尤其是在使用回调和状态时，事情会变得更加复杂，功能组件与其基于类的兄弟之间的差异会越来越大。当我们到达组件组合和通用功能重用时，两个世界中的模式几乎完全不同。
- en: The choice between component types is fundamental in your React journey, but
    quite frankly, it’s not really a choice anymore. You’ll probably be using functional
    components unless there’s a strong reason not to for your particular project or
    development team. Nevertheless, in this section, we’ll go over the benefits and
    disadvantages of functional components, as well as some factors that are actually
    *not* factors in this choice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的React之旅中，组件类型的选择是基本的，但坦白说，这已经不再是选择。除非有强烈的理由不适用于你的特定项目或开发团队，否则你可能会使用功能组件。尽管如此，在本节中，我们将讨论功能组件的优势和劣势，以及一些实际上*不是*选择因素的因素。
- en: 4.2.1 Benefits of functional components
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 功能组件的优势
- en: 'The following is a non-exhaustive list of some subjective benefits of using
    functional components:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用功能组件的主观优势的非详尽列表：
- en: '*Compactness*—Functional components are most often more compact in terms of
    lines of code and pure template code overhead than class-based components. You
    simply have to type fewer characters when implementing functional components.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*紧凑性*—在代码行数和纯模板代码开销方面，功能组件通常比基于类的组件更紧凑。实现功能组件时，你只需输入更少的字符。'
- en: '*Readability*—It can be much harder to track down the origin of some property
    in a class-based component going through layers of composed higher-order components
    than to do the same thing in a functional component using hooks (new in React
    16.8, which we’ll cover in the next couple of chapters). Generally, functional
    components are much easier to read and understand even at a glance.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读性*—在基于类的组件中追踪某些属性来源可能比在功能组件中使用钩子（新在React 16.8中，我们将在下一章中介绍）进行同样操作要困难得多。一般来说，功能组件更容易阅读和理解，即使是一瞥。'
- en: '*Purity*—The *purity* of a function (a pure function has no side effects and
    doesn’t depend on any other information than its arguments) is easier to determine,
    and the side effects of impure functions are easier to deduce due to the existence
    of hooks. The purity or lack thereof of a class-based component is generally harder
    to deduce, which can make debugging and understanding a lot harder.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纯净度*—函数的*纯净度*（一个纯净函数没有副作用且不依赖于任何其他信息，除了其参数）更容易确定，由于存在钩子，不纯净函数的副作用也更容易推断。基于类的组件的纯净度或缺乏纯净度通常更难以推断，这可能会使得调试和理解变得更加困难。'
- en: '*Simplicity*—Functions are a fundamental part of any programming language and
    even mathematics. The theoretical tools used to describe, work with, compose,
    and explain functions are far greater than those for doing the same for classes.
    Classes are also fundamental in many programming languages, but they are still
    a significantly higher-level abstraction than simple functions.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单性*—函数是任何编程语言和数学的基本组成部分。用于描述、处理、组合和解释函数的理论工具远远多于用于处理类的工具。类在许多编程语言中也是基本的，但它们仍然是一个比简单函数高得多的抽象层次。'
- en: '*Testability*—Due to the ability to break off bits of functionality into independent
    hooks, functional components are often much easier to unit test, as you can break
    them down into smaller composable units and easily test each independently.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可测试性*—由于可以将功能的一部分拆分为独立的钩子，功能组件通常更容易进行单元测试，因为你可以将它们分解成更小的可组合单元，并轻松独立测试每个单元。'
- en: '*Popularity*—The preference for functional components is a benefit in and of
    itself. Most other React developers will by now be more at home using functional
    components; most new development happens in the ecosystem of functional components;
    and the vast majority of new content about React (videos, tutorials, books, etc.)
    refers exclusively to functional components.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流行度*—对功能组件的偏好本身就是一种好处。到目前为止，大多数其他React开发者可能更习惯于使用功能组件；大多数新开发都发生在功能组件的生态系统内；而且关于React（视频、教程、书籍等）的新内容绝大多数都是专门针对功能组件的。'
- en: Note that all of these benefits are about developer experience. The actual end
    product—the final web application available to end users—isn’t improved or degraded
    by the choice of component type. It’s almost exclusively about making it easier
    for developers to write, maintain, and debug components, where the syntax of functional
    components really shines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些好处都是关于开发者体验的。实际的产品——最终用户可用的最终Web应用程序——并不会因为组件类型的选择而得到改善或降低。这几乎完全是关于让开发者更容易编写、维护和调试组件，而功能组件的语法在这方面确实非常出色。
- en: In general, using functional components is more elegant, more succinct, and—most
    importantly—far easier to understand. Of course, this is partially a subjective
    opinion on behalf of the authors, but it’s a common opinion found among React
    developers as can be seen in public codebases on GitHub and similar repositories.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用功能组件更加优雅、更加简洁，最重要的是——更容易理解。当然，这部分是作者的主观意见，但这是在GitHub和类似仓库的公共代码库中可以看到的React开发者中的普遍观点。
- en: 4.2.2 Disadvantages of functional components
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 功能组件的缺点
- en: There are no direct disadvantages to using functional components. For any feature
    that you can create in both a functional component and a class-based component,
    there are never any disadvantages to creating said feature in a functional one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能组件没有直接的不利之处。对于你可以在功能组件和基于类的组件中创建的任何功能，在功能组件中创建该功能永远不会带来任何不利之处。
- en: 4.2.3 Nonfactors between component types
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 组件类型之间的非因素
- en: 'Some factors that are important to developers, development teams, and business
    units alike are not actually factors at all in the choice of component types.
    These nonfactors include the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员、开发团队和业务单元来说，一些重要的因素实际上在选择组件类型时并不是因素。这些非因素包括以下内容：
- en: '*Speed*—There is no inherent speed difference in running a simple component
    as a functional one versus a class-based one. The tools to make every component,
    and thus your entire application, speedy and responsive are slightly different
    in the two types of components. Most would probably argue that the tools are a
    bit more transparent and easier to understand in functional components, but similar
    tools exist for class-based components, so any component can be made fast if optimized
    properly or can behave sluggishly if not optimized properly.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*速度*—将一个简单的组件作为函数式组件运行与作为基于类的组件运行之间没有固有的速度差异。使每个组件以及你的整个应用快速和响应的工具在这两种类型的组件中略有不同。大多数人可能会认为，在函数式组件中，这些工具更透明且更容易理解，但基于类的组件也存在类似工具，因此任何组件都可以通过适当的优化变得快速，如果不优化则可能表现迟缓。'
- en: '*Composability*—Albeit the design patterns used are very different, code reuse
    and composability of functionality are just as good and well supported in both
    types of components.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可组合性*—尽管使用的模式设计非常不同，但在两种类型的组件中，代码重用和功能组合性都同样良好且得到很好的支持。'
- en: '*Usability*—For the end user visiting your web application, the experience
    is no different whether you’re using one type or the other. User experience does
    not affect this decision.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可用性*—对于访问你的Web应用的最终用户来说，使用哪种类型没有区别。用户体验不会影响这个决定。'
- en: '*Accessibility*—Making React components accessible is a skill of its own, but
    that applies regardless of whether you’re writing them one way or the other.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可访问性*—使React组件可访问是一项独特的技能，但这适用于你以任何一种方式编写组件的情况。'
- en: '*Reliability*—Components are just as easy or difficult to make reliable or
    correct regardless of the choice of component type. Reliability is a property
    of good software development, not the choice of tooling.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可靠性*—无论选择哪种组件类型，组件都同样容易或困难地变得可靠或正确。可靠性是良好软件开发的一个属性，而不是工具选择的问题。'
- en: '*Maintainability*—At least for now, there are no indications that class-based
    components are being deprecated, so both component types are expected to be fully
    supported by React in all future versions.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*—至少到目前为止，没有迹象表明基于类的组件正在被弃用，因此预计React在所有未来版本中都将完全支持这两种组件类型。'
- en: While all of these are important aspects of software development, they’re not
    directly influenced by the choice of component types; rather, they are influenced
    by the competence and vision of the developer or development team wielding the
    keyboard.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些都是软件开发的重要方面，但它们并不是直接受组件类型选择的影响；相反，它们受开发者或掌握键盘的开发团队的技能和视野的影响。
- en: 4.2.4 Choosing the component type
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 选择组件类型
- en: 'The short answer to “What component type should I choose for my project?” is
    simple: *use functional components*. The slightly longer answer adds the following
    postfix: *unless there’s a very strong reason not to*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“我应该为我的项目选择哪种组件类型？”的简短回答是简单的：*使用函数式组件*。稍微长一点的回答会加上以下后缀：*除非有非常强烈的理由不这样做*。
- en: In our most informed opinion, you should always use the latest stable version
    of any technology, and for React, that is most definitely functional components
    over class-based components. Functional components have been around for quite
    a while by now, most new development happens in functional components and their
    environment (hooks in particular), and most other developers will be using functional
    components as well. However, there might be scenarios where we would consider
    using class-based components, and we’ll cover those in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们最了解的意见，你应该始终使用任何技术的最新稳定版本，对于React来说，这无疑是函数式组件优于基于类的组件。函数式组件已经存在了一段时间，大部分新开发都发生在函数式组件及其环境中（特别是hooks），而且大多数其他开发者也会使用函数式组件。然而，可能存在一些情况，我们会考虑使用基于类的组件，我们将在下一节中介绍这些情况。
- en: 4.3 When not to use a functional component
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 不使用函数式组件的情况
- en: As mentioned previously, almost anything you can do with a class-based component,
    you can do with a functional component, except for error boundaries. There are
    a few other instances where you might want to choose to use a class-based component
    anyway, even if you don’t have to for technical reasons.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，几乎你可以用基于类的组件做到的任何事情，你都可以用函数式组件做到，除了错误边界。还有一些其他情况下，你可能仍然会选择使用基于类的组件，即使你不需要从技术角度考虑。
- en: 'In this section, we’ll discuss the following cases where you might want to
    avoid using functional components:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下你可能想要避免使用函数式组件的情况：
- en: You want to set up an error boundary to handle errors occurring further down
    the render tree.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要设置一个错误边界来处理渲染树中更下方的错误。
- en: You’re working in a codebase primarily composed of class-based components and
    want to make something that fits in.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在一个主要由类组件组成的代码库中工作，并想要创建一些与之兼容的东西。
- en: You’re using a library that is tailored to class-based components only.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用一个仅针对类组件定制的库。
- en: You’re specifically tasked to use the built-in React functionality of getSnapshotBeforeUpdate.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你被特别指派使用内置的React功能getSnapshotBeforeUpdate。
- en: The preceding items are written in prioritized order of their likeliness to
    occur in your everyday work. Given that the first item in the list is a rather
    specialized case necessary in only the largest and most complex codebases, you’re
    not likely to come across any of these exceptions at all. We’ll cover each of
    the exceptions in the following subsections.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的项目按照它们在日常工作中可能发生的优先级顺序编写。鉴于列表中的第一个项目是一个仅在最大和最复杂的代码库中必要的特殊案例，你不太可能遇到这些异常。我们将在以下小节中逐一介绍这些异常。
- en: 4.3.1 Error boundary
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 错误边界
- en: Establishing an error boundary is a valid concern for a mature React codebase
    once it gets to a certain complexity level, so this is something you’re likely
    to come across if you’re working on a large codebase. Currently, at the time of
    writing, there is still no way to solve this without using a class-based component.
    There aren’t even any plans to convert the error boundary functionality to a hook
    or similar, which would allow it to be possible in a functional component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个成熟的React代码库达到一定的复杂度时，建立错误边界是一个合理的问题，所以如果你在一个大型代码库中工作，你很可能会遇到这种情况。目前，在撰写本文时，还没有不使用类组件就能解决这个问题的方法。甚至没有计划将错误边界功能转换为钩子或类似功能，这样它就可以在函数组件中使用。
- en: An error boundary is a way of establishing a fallback in case a child component
    throws a JavaScript error. You should always strive to never have unhandled errors,
    of course, but as things get complex, input changes, APIs evolve, and your codebase
    gets more complex and harder to properly cover by tests, errors will occur. An
    error boundary is your way of making sure that when such an error does occur,
    at least the end user is presented with a nicely formatted error message along
    with your sincere apologies. You should probably also log the error to your analytics
    tool of choice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界是在子组件抛出JavaScript错误时提供一个回退机制的方式。当然，你应该始终努力避免未处理的错误，但随着事情变得复杂，输入变化，API演变，你的代码库变得更加复杂且难以通过测试正确覆盖，错误仍然会发生。错误边界是你的方式，确保当这样的错误发生时，至少最终用户会看到一个格式良好的错误消息以及你真诚的道歉。你可能还应该将错误记录到你选择的分析工具中。
- en: Two methods in the React API deal with errors occurring in child components.
    One is getDerivedStateFromError, where you can set an internal flag that this
    component should render differently because an error occurred somewhere. The other
    is componentDidCatch, where you get the actual error that occurred along with
    its stack trace and other information. This latter part allows you to log it for
    debugging purposes. We won’t go into detail about how these work, as it’s outside
    the scope of this book, but if you need them, the React documentation on both
    methods is pretty substantial.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: React API中有两种方法处理子组件中发生的错误。一个是getDerivedStateFromError，在这里你可以设置一个内部标志，表示这个组件应该以不同的方式渲染，因为某个地方发生了错误。另一个是componentDidCatch，在这里你可以获取实际发生的错误及其堆栈跟踪和其他信息。这部分允许你将其记录下来用于调试目的。我们不会深入探讨这些方法的工作原理，因为这不属于本书的范围，但如果你需要它们，React文档中关于这两种方法的说明相当详尽。
- en: If you find yourself needing to catch errors in a component tree, you have to
    use a class-based component for at least this one component. You can still keep
    99% of your components functional, despite having a single class-based error boundary
    or two.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要在组件树中捕获错误，你必须至少使用一个类组件。尽管只有一个类组件的错误边界或两个，但你仍然可以保持99%的组件是函数式的。
- en: 4.3.2 Codebase is class-based
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 代码库是类基础的
- en: Imagine that you’re hired to a development position in a company that has an
    old React codebase that they’re still actively working on. It’s a huge application,
    maybe with hundreds or even thousands of components, and an extensive set of complex
    functionalities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被雇佣到一个公司担任开发职位，该公司有一个旧的React代码库，他们仍在积极地进行开发。这是一个庞大的应用程序，可能有数百甚至数千个组件，以及一套复杂的功能。
- en: You’re asked to add some new functionality to just a tiny part of this application.
    While there is no problem mixing class-based and functional components, it might
    seem very odd to other developers that some components are written in one style
    while others are written in a different style.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求只向这个应用程序的一小部分添加一些新功能。虽然混合使用基于类的和函数组件没有问题，但其他开发者可能会觉得某些组件是用一种风格编写的，而其他组件是用另一种风格编写的，这看起来非常奇怪。
- en: Refactoring the entire codebase to functional components would be a huge undertaking,
    but it’s hopefully the goal for the engineering team in the long term. However,
    there will likely be a transition period where only certain parts of the codebase
    have been converted and you’ll be asked to keep using classes in some parts while
    using functional components in others.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个代码库重构为函数组件将是一项巨大的任务，但希望这是工程团队长期的目标。然而，很可能会有一个过渡期，其中代码库的某些部分已经被转换，你将被要求在某些部分继续使用类，在其他部分使用函数组件。
- en: As React ages and the ghost of class-based components is a relic of a further
    and further past, this scenario becomes less and less likely. If you find yourself
    in such a scenario, we recommend using the wisdom of the team and going with the
    flow. Don’t force a conversion before the team is ready as a whole, and don’t
    go against the agreed-upon coding conventions of your team.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 随着React的成熟和基于类的组件的幽灵越来越成为遥远的过去，这种情况变得越来越不可能。如果你发现自己处于这种情况，我们建议使用团队的智慧，顺应潮流。在团队全体准备好之前不要强迫转换，也不要违反团队约定的编码规范。
- en: 4.3.3 Library requires class-based components
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 库需要基于类的组件
- en: This scenario is somewhat hypothetical, as we can’t find a library requiring
    a class-based component, but that’s not to say that it doesn’t exist. There might
    be a circumstance where you’re interacting with third-party functionality that
    requires you to use class-based components.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况有些假设性，因为我们找不到需要基于类的组件的库，但这并不意味着它不存在。可能存在一种情况，你正在与第三方功能交互，这要求你使用基于类的组件。
- en: The most likely case is that you want to use an old library that hasn’t been
    updated since before React hooks came out, and their examples and guides still
    use class-based components. That doesn’t mean that you can’t use the library with
    hooks; it just means that you’re on your own and can’t use the library documentation
    to help you out if things don’t work. While outdated documentation is the most
    likely culprit of the library instructing you to use class-based components, we
    can’t rule out that there might be a library that doesn’t work with hooks at all.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最可能的情况是，你想使用一个在React hooks推出之前就不再更新的旧库，并且它们的示例和指南仍然使用基于类的组件。这并不意味着你不能使用带有hooks的库；只是意味着你必须自己解决，如果事情不顺利，就不能使用库文档来帮助你。虽然过时的文档可能是库指示你使用基于类的组件的最可能原因，但我们不能排除可能存在完全不兼容hooks的库。
- en: If either of the preceding scenarios occurs, your best bet is to look around
    for a more modern library. Many things have changed in the four years since hooks
    came out—not just notation—and you’ll probably find that the library in question
    is behind the curve on many things if it’s been unmaintained for that long.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述任何一种情况发生，你的最佳选择是寻找一个更现代的库。自从hooks推出以来，四年的时间里，许多事情都发生了变化——不仅仅是符号——如果你长时间没有维护，你可能会发现这个库在很多方面都落后于时代。
- en: 4.3.4 Snapshot before updating
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 更新前的快照
- en: 'There is another built-in function in the React API that doesn’t exist in a
    hooks-only React world: getSnapshotBeforeUpdate. This is an extremely specific
    piece of functionality that has the narrowest use case, the details of which we
    won’t go over here. You’ll be able to work around it easily with hooks if you
    just structure your components slightly differently.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: React API中还有一个内置函数，在仅使用hooks的React世界中不存在：getSnapshotBeforeUpdate。这是一个非常具体的特性，用途非常狭窄，细节我们在这里不会过多讨论。如果你只是稍微调整一下组件的结构，你就能轻松地用hooks绕过它。
- en: However, if you’re specifically tasked to use this functionality, there’s no
    way around it (also, who gave you this weird task?). If you’re just tasked with
    solving a problem, where getSnapshotBeforeUpdate will be a solution in a class-based
    component, you can find a similar solution using functional components.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你被具体指派去使用这个功能，就没有其他办法了（顺便问一下，是谁给你这个奇怪的任务的？）。如果你只是被指派去解决问题，其中getSnapshotBeforeUpdate将在基于类的组件中是一个解决方案，你可以使用函数组件找到一个类似的解决方案。
- en: This method is only mentioned here for completion, not because it’s a method
    frequently used at all. A quick search of GitHub reveals only seven repositories
    mentioning the method. Two are lists of React functions, two are examples of how
    to use this specific method, and three are old unmaintained demos. So, this whole
    method is a candidate for functionality that will likely disappear from the React
    API completely rather than be upgraded to a functional equivalent.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在这里仅提及以完善内容，并不是因为它是一个经常使用的方法。在GitHub上快速搜索只发现七个仓库提到了该方法。其中两个是React函数的列表，两个是使用此特定方法的示例，另外三个是旧的未维护的演示。因此，整个方法可能是React
    API中可能完全消失的功能，而不是升级到功能等效版本。
- en: 4.4 Conversion from a class-based to a functional component
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 从类组件到函数组件的转换
- en: You’ve already seen a simple class-based component converted to a functional
    one between code listings 4.1 and 4.2\. In this section, we’ll dig more into this
    conversion, iron out some gotchas, and prepare you for the journey ahead, as we’ll
    keep coming back to this conversion as we add more and more complicated functionality
    to our components in the next chapters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在代码列表4.1和4.2之间看到了一个简单的类组件被转换为功能组件。在本节中，我们将更深入地探讨这个转换，解决一些问题，并为接下来的旅程做好准备，因为随着我们在下一章中向组件添加越来越多的复杂功能，我们还将不断回到这个转换。
- en: 'For this conversion exercise, we’ll create another simple web application:
    a gallery with images and titles for each. This is a simple visual application
    that has no interaction (as we’ve not yet learned how to add that) but highlights
    different features of component internals, so we have to use some different tricks
    to convert the components. The output of this application will look like figure
    4.3 in the browser.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个转换练习中，我们将创建另一个简单的Web应用程序：一个带有图像和每个图像标题的画廊。这是一个简单的视觉应用程序，没有交互（因为我们还没有学习如何添加交互），但它突出了组件内部的不同功能，因此我们必须使用一些不同的技巧来转换组件。该应用程序的输出在浏览器中看起来像图4.3。
- en: '![04-03](../Images/04-03.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![04-03](../Images/04-03.png)'
- en: Figure 4.3 The gallery application as seen in the browser with simple figures
    and captions
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 浏览器中看到的画廊应用程序，带有简单的图形和标题
- en: 'We’ll create four versions of this component, which iterate as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建这个组件的四个版本，如下迭代：
- en: Version 1, using only the render method
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1版，仅使用render方法
- en: Version 2, using a secondary method as utility only
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2版，仅作为工具使用辅助方法
- en: Version 3, using a secondary method with class access
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3版，使用类访问的辅助方法
- en: Version 4, using the constructor to initialize a calculation
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4版，使用构造函数初始化计算
- en: The reason we go through these iterations is to see how to convert class-based
    components to functional components when the classes use more and more advanced
    patterns that require slightly different solutions in a functional equivalent.
    Finally, we’ll discuss how one-to-one conversion gets more complex—bordering on
    impossible—as components get more complicated.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这些迭代的原因是了解如何在类使用越来越多的高级模式且在功能等效中需要略微不同的解决方案时，将类组件转换为功能组件。最后，我们将讨论一对一转换如何随着组件变得更加复杂而变得更加复杂——几乎不可能。
- en: '4.4.1 Version 1: Render only'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 第1版：仅渲染
- en: We’ll implement our first iteration with classes completely similar to our menu
    earlier in this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与本章早期菜单完全相同的类来实现我们的第一个迭代。
- en: Original
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 原始
- en: We use three components, and each uses its render method to return JavaScript.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个组件，每个组件都使用其render方法返回JavaScript。
- en: Listing 4.9 Gallery v1 using classes
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 使用类的画廊v1
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Our three class components only have a render function and no other methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们这三个类组件只有一个render函数，没有其他方法。
- en: ❷ Our three class components only have a render function and no other methods.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们这三个类组件只有一个render函数，没有其他方法。
- en: 'Repository: rq04-gallery-class-v1'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-class-v1
- en: 'This example can be seen in repository rq04-gallery-class-v1. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-gallery-class-v1仓库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-class-v1](https://rq2e.com/rq04-gallery-class-v1)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-class-v1](https://rq2e.com/rq04-gallery-class-v1)'
- en: Conversion
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 转换
- en: When converting such a simple component to a functional component, we directly
    convert the render method of the class to a function with the same name as the
    class. Thus, it follows this simple template. If you have the class as
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这样一个简单的组件转换为函数组件时，我们直接将类的`render`方法转换为具有与类相同名称的函数。因此，它遵循这个简单的模板。如果你有这个类：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'you end up with this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到这个：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only other thing we also have to do is ensure that we directly destructure
    the props in the component definition rather than access them through this.props
    as we’ve seen before. This leads us to the result shown in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须做的唯一其他事情是确保我们在组件定义中直接解构props，而不是像之前看到的那样通过this.props访问它们。这导致以下列表中显示的结果。
- en: Listing 4.10 Gallery v1 using functions
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 图库v1使用函数
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Component definition changed to a function
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组件定义改为函数
- en: ❷ This component definition also takes destructured properties.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此组件定义还接受解构属性。
- en: ❸ Property reference changed to a direct variable rather than an object property
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 属性引用改为直接变量而不是对象属性
- en: 'Repository: rq04-gallery-function-v1'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-function-v1
- en: 'This example can be seen in repository rq04-gallery-function-v1. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库rq04-gallery-function-v1中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在你的浏览器中查看应用程序，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-function-v1](https://rq2e.com/rq04-gallery-function-v1)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-function-v1](https://rq2e.com/rq04-gallery-function-v1)'
- en: 'There’s nothing surprising here. We used all the tricks we’ve learned so far
    in this chapter:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么令人惊讶的。我们使用了本章迄今为止学到的所有技巧：
- en: A functional component is simply a function returning JSX.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件简单来说就是一个返回JSX的函数。
- en: If we need to accept properties, we destructure them in the function definition.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要接受属性，我们在函数定义中解构它们。
- en: When we need to access properties, we can do so directly using the destructured
    variables.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要访问属性时，我们可以直接使用解构变量。
- en: In the next couple of subsections, we’ll iterate the definition of the image
    component, so you’ll see different versions of only that component. For brevity,
    only the image component will be shown in the sample code listings.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个小节中，我们将迭代图像组件的定义，所以你将只看到该组件的不同版本。为了简洁起见，样本代码列表中只显示图像组件。
- en: '4.4.2 Version 2: Class method as utility'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 版本2：类方法作为实用工具
- en: In this version of the implementation, we examine what we would do if the image
    class had another method that served as a utility function aiding the rendering.
    The argument is that the src property of the <img /> element is a bit long and
    windy, and the JSX would look a lot simpler if we had a utility method to render
    this URL.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现的版本中，我们考察了如果图像类有另一个作为渲染辅助功能的方法，我们会怎么做。论点是`<img />`元素的`src`属性有点长且复杂，如果我们有一个渲染这个URL的实用方法，JSX看起来会简单得多。
- en: Original
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 原始
- en: Let’s expand the class-based implementation of the image gallery with some code
    improvements. In this iteration, we’ll imagine that the developer of the gallery
    wants to reduce the visual clutter of these lines in the original component from
    listing 4.9
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码改进来扩展图像库的基于类的实现。在这个迭代中，我们将假设画廊的开发者想要减少原始组件中列表4.9中这些行的视觉杂乱。
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'to something that looks simpler, like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将其简化为如下所示：
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This requires us to define a class method, getImageSource, which takes an argument,
    index, and returns a string with the URL:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要我们定义一个类方法`getImageSource`，它接受一个参数`index`，并返回一个包含URL的字符串：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Putting all this together, the resulting image component looks like the next
    listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，最终的图像组件看起来像下一个列表。
- en: Listing 4.11 Gallery v2 using classes (excerpt)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 图库v2使用类（摘录）
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Defines a new method in the class
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在类中定义一个新方法
- en: ❷ Invokes the new method with a property as the argument
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用属性作为参数调用新方法
- en: 'Repository: rq04-gallery-class-v2'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-class-v2
- en: 'This example can be seen in repository rq04-gallery-class-v2. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库rq04-gallery-class-v2中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-class-v2](https://rq2e.com/rq04-gallery-class-v2)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-class-v2](https://rq2e.com/rq04-gallery-class-v2)'
- en: Note that this listing only shows the image component. The app and gallery components
    are the same as before. We won’t bother repeating these in listing 4.11 nor in
    the conversion that follows. The task now becomes to convert this new class-based
    component, using multiple methods, to a functional component.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个列表只显示了图像组件。应用程序和画廊组件与之前相同。我们不会在列表 4.11 或随后的转换中重复这些内容。现在的任务是将这个新的基于类的组件，使用多种方法，转换为功能组件。
- en: Conversion
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 转换
- en: The key to converting this function is to recognize that the class method isn’t,
    in the object-oriented sense of the word, a method of the class, but merely a
    utility function. In fact, you could move the function completely outside the
    class and get the same result.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将此函数转换为关键是要认识到，在面向对象的意义上，类方法并不是类的方法，而仅仅是一个实用函数。实际上，您可以将该函数完全移出类外，并得到相同的结果。
- en: Imagine that listing 4.11, shown earlier, instead looked like listing 4.12.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，之前展示的列表 4.11，现在看起来像列表 4.12。
- en: Listing 4.12 Gallery v2 using classes and a function (excerpt)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 使用类和函数的画廊 v2（摘录）
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ We’ve moved the method out as a separate and independent function outside
    the class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们已将方法移出，作为类外部的独立函数。
- en: ❷ Invokes the function as any other function, and not as a method of the class
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将函数作为任何其他函数调用，而不是作为类的方法
- en: This works in the same way because the getImageSource method didn’t use any
    knowledge that was only available inside the class. In other words, the function
    was pure and only relied on its input and no other outside information, nor did
    it have any outside consequences.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是以同样的方式工作的，因为getImageSource方法没有使用任何仅在类内部可用的知识。换句话说，该函数是纯函数，仅依赖于其输入，没有依赖任何外部信息，也没有任何外部影响。
- en: Converting this new class-based component using a utility function now becomes
    just as simple as before. We leave the utility function as is and just convert
    the component itself.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实用函数将这个新的基于类的组件转换为现在与之前一样简单。我们保持实用函数不变，只需转换组件本身。
- en: Listing 4.13 Gallery v2 using functions (excerpt)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 使用函数的画廊 v2（摘录）
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Maintains the utility function outside the component definition
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将实用函数保持在组件定义之外
- en: ❷ Invokes this function as any other function
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将此函数作为任何其他函数调用
- en: 'Repository: rq04-gallery-function-v2'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq04-gallery-function-v2
- en: 'This example can be seen in repository rq04-gallery-function-v2. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-gallery-function-v2存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用程序的实际应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-function-v2](https://rq2e.com/rq04-gallery-function-v2)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-function-v2](https://rq2e.com/rq04-gallery-function-v2)'
- en: This does seem a lot simpler and more compact than the previous iteration in
    listing 4.10\. The <img /> tag is much simpler to read, and the details of the
    actual URL generation have been moved to a function dedicated to that task only.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实比列表 4.10 中的前一个迭代要简单得多，紧凑得多。`<img />` 标签更容易阅读，实际URL生成的细节已被移动到仅为此任务而创建的函数中。
- en: Here, we used the knowledge that the method was pure; that is, the method didn’t
    use any outside information but relied on its arguments only. What if this wasn’t
    the case? We’ll get to that in the next subsection.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了这个方法是无状态的知识；也就是说，该方法没有使用任何外部信息，只依赖于其参数。如果情况不是这样呢？我们将在下一小节中讨论。
- en: '4.4.3 Version 3: Real class method'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 版本 3：真正的类方法
- en: Now let’s take a new look at the class method we had in the previous example.
    Let’s instead imagine that the developer implementing this component wanted to
    use the fact that the method is part of the class and thus has direct access to
    the properties of the component.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新审视之前示例中的类方法。让我们想象一下，实现此组件的开发者想利用这个事实，即该方法属于类的一部分，因此可以直接访问组件的属性。
- en: Original
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 原始
- en: 'Using this information, the method doesn’t need to rely on an argument delivering
    the index but can retrieve the index directly from the component properties using
    this.props:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，方法不需要依赖于传递索引的参数，而是可以直接从组件属性中使用this.props检索索引：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, when we use this method, we don’t have to provide an argument; we can just
    call the method. This results in the component definition in the following listing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用这种方法时，我们不需要提供任何参数；我们只需调用该方法。这导致了以下列表中的组件定义。
- en: Listing 4.14 Gallery v3 using classes (excerpt)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14：使用类的Gallery v3（摘录）
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ This time, the class method uses the props object directly.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这次，类方法直接使用了props对象。
- en: ❷ We can now call the method without passing an argument to it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们现在可以调用该方法，而不需要向它传递任何参数。
- en: 'Repository: rq04-gallery-class-v3'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq04-gallery-class-v3
- en: 'This example can be seen in repository rq04-gallery-class-v3. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-gallery-class-v3存储库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-class-v3](https://rq2e.com/rq04-gallery-class-v3)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-class-v3](https://rq2e.com/rq04-gallery-class-v3)'
- en: Now the class method is indeed a method of the class and relies on outside information.
    What do we do now? The short answer is that there is no direct equivalent of this
    in a functional component; however, there are similar ways to achieve the same
    result.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个类方法确实是类的一个方法，并且依赖于外部信息。我们接下来该怎么办？简短的回答是，在功能组件中并没有这个的直接等价物；然而，有类似的方法可以达到相同的结果。
- en: 'There are two primary approaches to converting this class-based component to
    a functional component, each with its advantages and drawbacks:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个基于类的组件转换为功能组件有两种主要方法，每种方法都有其优点和缺点：
- en: Convert the method to a pure function and move it outside the component.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法转换为纯函数并将其移出组件。
- en: Create a local function inside the component.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件内部创建一个局部函数。
- en: We’ll cover both of those approaches and compare them in the following subsections.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中介绍这两种方法，并进行比较。
- en: Conversion using a pure function
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数进行转换
- en: 'Option 1 is to remember the previous version of the gallery image and try to
    reverse this advancement of complexity and interconnectedness. For this method,
    it’s quite simple: the goal is to remove any direct access to component properties
    or other component-local information and instead pass it as arguments to the function.
    This would lead us to the same version of getImageSource that we saw in version
    2, where it took an argument and returned a string.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1是记住画廊图像的先前版本，并试图逆转这种复杂性和相互关联性的进步。对于这种方法，相当简单：目标是移除对组件属性或其他组件本地信息的任何直接访问，并将其作为参数传递给函数。这将使我们回到版本2中看到的相同的getImageSource版本，它接受一个参数并返回一个字符串。
- en: 'Implementing this would look exactly like listing 4.13 earlier. However, imagine
    that the method was more complex and used a lot of properties:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点将完全类似于前面4.13列表所示。然而，想象一下，这个方法更加复杂并且使用了大量的属性：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we use this method in our class-based component render, it looks quite
    nice:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在基于类的组件的渲染中使用这种方法时，看起来相当不错：
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The usage of this function is quite compact, and all the complexity of accessing
    the different properties is moved to the method only.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用相当紧凑，并且将访问不同属性的所有复杂性都移动到了方法中。
- en: 'If we convert it to a pure function, we suddenly have to pass a ton of arguments
    to it, increasing the complexity. In our functional component with a pure function,
    we would have to pass all the properties to the function, and it would suddenly
    look like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其转换为纯函数，我们突然需要向它传递大量的参数，增加了复杂性。在我们的纯函数功能组件中，我们必须将所有属性传递给函数，它看起来会突然变成这样：
- en: '[PRE47]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This isn’t as nice and isolated as before, but it would work and would be a
    valid conversion.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这不如之前那么优雅和隔离，但它会起作用，并且是一个有效的转换。
- en: Conversion using a local function
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部函数进行转换
- en: Option 2 is to convert the class method to a local function inside our functional
    component, which would look like the next listing.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2是将类方法转换为功能组件内部的局部函数，这将在下一个列表中展示。
- en: Listing 4.15 Gallery v3 using functions (excerpt)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15：使用函数的Gallery v3（摘录）
- en: '[PRE48]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Defines a local function inside the component that has access to properties
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在组件内部定义一个可以访问属性的本地函数
- en: ❷ Invokes this function as any other function
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 以任何其他函数的方式调用此函数
- en: 'Repository: rq04-gallery-function-v3'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-function-v3
- en: 'This example can be seen in repository rq04-gallery-function-v3. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-gallery-function-v3仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-function-v3](https://rq2e.com/rq04-gallery-function-v3)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-function-v3](https://rq2e.com/rq04-gallery-function-v3)'
- en: Now because this definition of getImageSource is a local function inside our
    component, it has access to the properties passed to the component, and we don’t
    have to pass all the properties to the helper function. The downside to this approach
    is that every time we create a new component, we create a new local function.
    This doesn’t matter much in this example with only four components, but imagine
    a huge, complex application with thousands or even millions of instances of some
    components. If we had millions of instances of our original class-based component
    as defined in listing 4.14, we would still only have a single definition of the
    getImageSource method, which wouldn’t occupy a lot of memory.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在因为getImageSource的定义是组件内部的本地函数，它可以访问传递给组件的属性，我们不需要将所有属性传递给辅助函数。这种方法的缺点是每次我们创建一个新的组件时，都会创建一个新的本地函数。在这个只有四个组件的例子中，这并不重要，但想象一下拥有成千上万个甚至数百万个某些组件实例的庞大、复杂应用程序。如果我们有数百万个如列表4.14中定义的原始类组件的实例，我们仍然只有一个getImageSource方法的定义，这不会占用太多内存。
- en: However, with our functional component as defined in listing 4.15, every instance
    of our component would have a locally defined function, and each would occupy
    a slot in the program memory. This isn’t normally a worry, but it’s a slight difference
    between the two implementations.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据我们在列表4.15中定义的功能组件，每个组件实例都将有一个本地定义的函数，并且每个实例都会占用程序内存中的一个槽位。这通常不是问题，但这是两种实现之间的细微差别。
- en: When you’re converting a class-based component with extra class methods, you
    can use either option as outlined previously. Just be aware of the advantages
    and disadvantages of both. In the concrete example, both options are fully valid
    solutions, but sometimes one option will be more appropriate than the other, depending
    on the exact circumstances.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将具有额外类方法的基于类的组件进行转换时，您可以使用之前概述的任一选项。只需注意两种选项的优点和缺点。在具体示例中，两种选项都是完全有效的解决方案，但有时一个选项可能比另一个选项更合适，具体取决于具体情况。
- en: '4.4.4 Version 4: Constructor'
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 版本 4：构造函数
- en: As we’ve mentioned previously, you can also add a constructor method to your
    class-based component. Generally, the constructor is used for initializing attributes
    that will remain the same in the component’s entire lifetime, regardless of the
    properties passed. This is because the constructor is only executed once, the
    first time the component is created, and not every time the component properties
    update or the component re-renders for other reasons.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您还可以向基于类的组件添加构造函数。通常，构造函数用于初始化在组件整个生命周期中保持不变的属性，无论传递了哪些属性。这是因为构造函数只执行一次，即组件首次创建时，而不是每次组件属性更新或因其他原因重新渲染时。
- en: We’ll get into a lot more details about component re-rendering in future chapters.
    For now, just know that the constructor is only called once in the component’s
    lifetime, so you shouldn’t put any functionality there that depends on properties
    that might change in the future.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中详细介绍组件的重新渲染。现在，只需知道构造函数在组件的生命周期中只调用一次，因此您不应该在其中放置依赖于可能在未来改变的属性的任何功能。
- en: In this example, we’ll add a constructor to our image component that generates
    a random ID to be applied to our element. Reasons for doing this might include
    to attach it to some external library or to reference the element using Accessible
    Rich Internet Applications (ARIA) properties for accessibility.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将向我们的图像组件添加一个构造函数，该函数生成一个随机ID以应用于我们的元素。这样做的原因可能包括将其附加到某些外部库或使用可访问的富互联网应用程序（ARIA）属性来引用元素以提高可访问性。
- en: If we created an ID in the render method, the ID would regenerate every time
    the component renders. Instead, we create the ID in the constructor to make sure
    that it stays the same in the component’s lifetime.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在渲染方法中创建了一个ID，那么每次组件渲染时ID都会重新生成。相反，我们在构造函数中创建ID，以确保它在组件的生命周期中保持不变。
- en: Listing 4.16 Gallery v4 using classes (excerpt)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 使用类的 Gallery v4（摘录）
- en: '[PRE50]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Calling super(props) is required in the constructor of a class-based component;
    otherwise, your component won’t work.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在基于类的组件的构造函数中调用 super(props) 是必需的；否则，你的组件将无法工作。
- en: ❷ We create a class variable with the generated unique ID.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们使用生成的唯一ID创建一个类变量。
- en: ❸ We then use this ID in the render method by retrieving it from the class.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们随后在渲染方法中使用这个ID，通过从类中检索它。
- en: 'Repository: rq04-gallery-class-v4'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-class-v4
- en: 'This example can be seen in repository rq04-gallery-class-v4. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq04-gallery-class-v4 中看到。你可以通过创建一个基于相关模板的新应用程序来使用那个仓库：
- en: '[PRE51]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq04-gallery-class-v4](https://rq2e.com/rq04-gallery-class-v4)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-class-v4](https://rq2e.com/rq04-gallery-class-v4)'
- en: 'Note that we simply store the ID as a property directly on the class instance
    itself using this.id. We don’t put it in this.props for two reasons: (1) because
    we can’t (it’s a frozen object), and (2) because it’s not a property passed to
    our component—it’s something we calculated ourselves. So, how do we convert this
    to a functional component with the knowledge we have so far? We can’t! You’ll
    learn the tools to do this later in chapter 7, using hooks (useMemo in particular);
    for now, however, we don’t have the features to do this.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是直接将ID作为属性存储在类实例本身上，使用 this.id。我们不会将其放入 this.props 中，有两个原因：(1) 因为我们不能（它是一个冻结对象），(2)
    因为它不是传递给我们的组件的属性——这是我们自行计算的结果。所以，我们如何利用我们目前的知识将这个组件转换为函数组件呢？我们不能！你将在第7章学习到完成这个任务的工具，特别是使用
    hooks（特别是 useMemo）；然而，目前我们还没有这样的功能。
- en: The problem is that unlike class-based components, which have a constructor
    that runs only once when the component is created the first time, and a separate
    render method, which runs every time the component renders (and re-renders), a
    functional component only has a single method that runs every time the component
    renders, including the first time. In a functional component, there is no real
    difference between the first render and subsequent renders.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，与在组件首次创建时只运行一次构造函数并且有一个独立的渲染方法（每次组件渲染和重新渲染时都会运行）的基于类的组件不同，函数组件只有一个在每次组件渲染时（包括第一次渲染）都会运行的方法。在函数组件中，第一次渲染和后续渲染之间没有真正的区别。
- en: We haven’t seen a component yet that re-renders, but, for now, just trust us
    that almost all components you’ll be writing in React will need to render more
    than once. If a component only ever renders once, it’s most likely a very simple
    component with no internal logic or state. For example, your web application logo
    might be defined in a simple component that never changes. We’ll talk a lot more
    about component life cycles and rendering in chapter 6.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到需要重新渲染的组件，但，现在请相信我们，你将在 React 中编写的几乎所有组件都需要多次渲染。如果一个组件只渲染一次，它很可能是一个非常简单的组件，没有内部逻辑或状态。例如，你的网络应用程序的标志可能定义在一个简单的组件中，该组件永远不会改变。我们将在第6章中详细讨论组件的生命周期和渲染。
- en: To give you a sneak peek of what this ID generation would look like using functional
    components, check out listing 4.17\. Here, we use the hook, useMemo, to generate
    a unique ID the first time the component renders, and then reuse this same calculated
    result on every subsequent render.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你提前了解使用函数组件进行ID生成的样子，请查看列表 4.17。在这里，我们使用钩子 useMemo 在组件第一次渲染时生成一个唯一的ID，然后在每次后续渲染中重用这个相同的计算结果。
- en: Listing 4.17 Gallery v4 using functions (excerpt)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 使用函数的 Gallery v4（摘录）
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Imports the hook from the React package
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 React 包导入钩子
- en: ❷ Applies the hook and adds the magic—an empty array—that makes the hook run
    only once. This is called a dependency array, which is discussed in chapter 6.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用钩子并添加魔法——一个空数组——使钩子只运行一次。这被称为依赖数组，将在第6章中讨论。
- en: 'Repository: rq04-gallery-function-v4'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq04-gallery-function-v4
- en: 'This example can be seen in repository rq04-gallery-function-v4. You can use
    that repository by creating a new app based on the associated template:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq04-gallery-function-v4存储库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE53]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在您的浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq04-gallery-function-v4](https://rq2e.com/rq04-gallery-function-v4)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq04-gallery-function-v4](https://rq2e.com/rq04-gallery-function-v4)'
- en: We won’t go into more detail on how this works right now, but this is the logical
    equivalent of initializing a variable in the constructor. You’ll learn more about
    hooks, rendering, and memoization in chapter 7\. This technique does require some
    rewriting of the component, and you have to think a bit differently, but all the
    examples seen so far can be converted to functional components without too much
    work.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨其工作原理，但这与在构造函数中初始化变量的逻辑等价。您将在第7章中了解更多关于hooks、渲染和记忆化的内容。这项技术确实需要对组件进行一些重写，并且您需要稍微改变一下思维方式，但到目前为止看到的所有示例都可以通过不太多的工作转换为函数组件。
- en: 4.4.5 More complexity equals harder conversion
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 更多的复杂性意味着更困难的转换
- en: All the examples shown so far are very simple. We don’t have any interaction
    or any state. Features such as filtering which animals you want to see and clicking
    to expand the information about each animal require more complex React components,
    which in turn require more complex logic to convert to a functional component,
    if that’s the task you have.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的所有示例都非常简单。我们没有任何交互或任何状态。例如，过滤您想看到的动物和点击展开每个动物的详细信息等功能需要更复杂的React组件，这反过来又需要更复杂的逻辑来转换为函数组件，如果这是您的任务的话。
- en: When we introduce more complex features of functional React components in future
    chapters, we’ll also briefly discuss what this would look like in a class-based
    component. In addition, we’ll cover how you would handle the conversion of a component
    using these features to the equivalent features in a functional component.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在未来章节中介绍函数式React组件的更复杂特性时，我们也会简要讨论这在一个基于类的组件中会是什么样子。此外，我们还将介绍如何处理使用这些特性将组件转换为函数组件等价特性的过程。
- en: For now, just know that while all functionality (barring the very few exceptions
    we saw earlier in section 4.3) can be converted from a class-based component to
    a functional one, it might not always be simple. Just as we had to make judgment
    calls when converting components using class methods, other degrees of complexity
    will introduce several different approaches, some of which are more applicable
    to a given situation than others. On top of that, as the original developer starts
    to combine all these features, you might end up with a very complex component
    that needs to be completely reworked to make sense in a functional world.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需知道虽然所有功能（除了我们在4.3节中较早看到的少数例外）都可以从类组件转换为函数组件，但这可能并不总是简单的。正如我们在使用类方法转换组件时必须做出判断一样，其他不同程度的复杂性将引入几种不同的方法，其中一些可能比其他方法更适合特定情况。除此之外，随着原始开发者开始组合所有这些特性，您可能会得到一个非常复杂的组件，需要完全重写才能在函数式世界中有意义。
- en: 4.5 Quiz
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 小测验
- en: Are functional components *less powerful*, *as powerful*, or *more powerful*
    than class-based components in terms of React functionality and which applications
    you can build?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在React功能以及您能构建的应用程序方面，函数组件与类组件相比是*更弱*、*同样强大*还是*更强大*？
- en: How many arguments are passed to a functional component?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向函数组件传递了多少个参数？
- en: Which one of these statements is *not* a benefit of using functional components?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个陈述不是使用函数组件的好处？
- en: '*Functional components are more compact than class-based components.*'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*函数组件比类组件更紧凑*。'
- en: '*Functional components are faster than class-based components.*'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*函数组件比类组件更快*。'
- en: '*Functional components are easier to understand than class-based components.*'
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*函数组件比类组件更容易理解*。'
- en: If you’re starting a brand-new React application, should you use *functional
    components* or *class-based components*, all else being equal?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在启动一个新的React应用程序，您应该使用*函数组件*还是*类组件*，其他条件都相同？
- en: Converting a class-based component to a functional component is always trivial;
    *true* or *false*?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类组件转换为函数组件总是微不足道的；*正确*还是*错误*？
- en: Quiz answers
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验答案
- en: Functional components are exactly *as powerful* as class-based components. Any
    application you can build using one type can also be built using the other.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数组件与基于类的组件一样 *强大*。你可以使用一种类型构建的应用程序也可以使用另一种类型构建。
- en: 'Functional components receive *one* argument: a frozen object of properties.'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数组件接收 *一个* 参数：一个包含属性的冻结对象。
- en: '*Functional components are not faster than class-based components*. While there
    might be a slight difference in speed for any naive implementation, both types
    of components can be lightning-fast when optimized properly, or, when ill-composed,
    can drag your whole application down. The choice of component type isn’t in itself
    an indicator of application speed.'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*函数组件并不比基于类的组件更快*。虽然任何简单的实现可能会有轻微的速度差异，但两种类型的组件在适当优化后都可以非常快，或者在不恰当的组合下，可能会拖垮整个应用程序。组件类型的选择本身并不是应用速度的指标。'
- en: All else being equal, you should start any new project using *functional components*.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他条件相同的情况下，你应该使用 *函数组件* 开始任何新的项目。
- en: '*False*. Converting a simple class-based component to a functional one can
    often be trivial initially, but as component complexity grows, the conversion
    gets more and more complex.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。将简单的基于类的组件转换为函数组件最初可能很简单，但随着组件复杂性的增加，转换会变得越来越复杂。'
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Functional components are another way to write React components as an alternative
    to class-based components.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件是编写 React 组件的另一种方式，作为基于类的组件的替代方案。
- en: Any JavaScript function returning JSX is a functional component, but for the
    sake of convention, we tend to write functional components in a certain style.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何返回 JSX 的 JavaScript 函数都是一个函数组件，但为了遵循惯例，我们倾向于以特定的风格编写函数组件。
- en: Certain JavaScript tricks are often used to aid the definition of functional
    components, including destructuring, default values, the rest syntax, and the
    object spread operator.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些 JavaScript 技巧经常被用来帮助定义函数组件，包括解构、默认值、剩余语法和对象展开运算符。
- en: Functional components are at least as capable as class-based components in every
    respect.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件在各个方面至少与基于类的组件一样强大。
- en: In certain aspects, functional components are more beneficial to the developer
    experience, but these benefits do not extend to the final product, which is independent
    of the choice of component type.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些方面，函数组件对开发者体验更有益，但这些好处并不延伸到最终产品，最终产品独立于组件类型的选择。
- en: If given the choice, using functional components is the recommended way to write
    React components.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有机会选择，使用函数组件是编写 React 组件的推荐方式。
- en: Class-based components can generally be converted to functional components,
    but it might require a lot of work and refactoring of existing functionality.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于类的组件通常可以转换为函数组件，但这可能需要大量的工作和对现有功能的重构。
