- en: Chapter 3\. Methods and encapsulation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章。方法和封装
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [[1.1](kindle_split_011.html#ch01lev1sec1)] Define the scope of variables.
    | Variables can have multiple scopes: class, instance, method, and local. Accessibility
    of a variable in a given scope. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [[1.1](kindle_split_011.html#ch01lev1sec1)] 定义变量的作用域。 | 变量可以有多个作用域：类、实例、方法和局部。在给定作用域中变量的可访问性。
    |'
- en: '| [[2.3](kindle_split_013.html#ch02lev1sec3)] Know how to read or write to
    object fields. | Object fields can be read from and written to by directly accessing
    instance variables and calling methods. The correct notation to call methods on
    an object. Methods may or may not change the value of instance variables. Access
    modifiers affect access to instance variables and methods that can be called using
    a reference variable. Nonstatic methods can’t be called on uninitialized objects.
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [[2.3](kindle_split_013.html#ch02lev1sec3)] 了解如何读取或写入对象字段。 | 可以通过直接访问实例变量和调用方法来读取和写入对象字段。调用对象上方法的正确符号。方法可能或可能不会改变实例变量的值。访问修饰符影响通过引用变量可以调用的实例变量和方法的可访问性。非静态方法不能在未初始化的对象上调用。
    |'
- en: '| [[2.4](kindle_split_013.html#ch02lev1sec4)] Explain an Object''s Lifecycle
    (creation, “dereference by reassignment” and garbage collection). | Differences
    between when an object is declared, initialized, accessible, and eligible to be
    collected by Java’s garbage collection. Garbage collection in Java. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [[2.4](kindle_split_013.html#ch02lev1sec4)] 解释对象的生命周期（创建、通过重新赋值进行“解引用”和垃圾回收）。
    | 对象声明、初始化、可访问性和Java垃圾回收器可以收集对象的条件之间的差异。Java中的垃圾回收。 |'
- en: '| [[6.1](kindle_split_019.html#ch06lev1sec1)] Create methods with arguments
    and return values; including overloaded methods. | Creation of methods with correct
    return types and method argument lists. Creation of methods with the same names,
    but a different set of argument lists. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [[6.1](kindle_split_019.html#ch06lev1sec1)] 创建具有参数和返回值的函数；包括重载函数。 | 创建具有正确返回类型和方法参数列表的函数。创建具有相同名称但参数列表不同的函数。
    |'
- en: '| [[6.3](kindle_split_020.html#ch06lev1sec3)] Create and overload constructors;
    including impact on default constructors. | Like regular methods, constructors
    can be overloaded. A default constructor isn’t the same as a no-argument constructor.
    Java defines a no-argument constructor when no user-defined constructors are created.
    User-defined constructors can be overloaded. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [[6.3](kindle_split_020.html#ch06lev1sec3)] 创建和重载构造函数；包括对默认构造函数的影响。 | 正如常规方法一样，构造函数可以重载。默认构造函数与无参数构造函数不同。当没有创建用户定义的构造函数时，Java定义了一个无参数构造函数。用户定义的构造函数可以重载。
    |'
- en: '| [[6.5](kindle_split_020.html#ch06lev1sec5)] Apply encapsulation principles
    to a class. | Need for and benefits of encapsulation. Definition of classes that
    correctly implement the encapsulation principle. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [[6.5](kindle_split_020.html#ch06lev1sec5)] 将封装原则应用于类。 | 封装的需求和好处。正确实现封装原则的类的定义。
    |'
- en: '| [[6.6](kindle_split_020.html#ch06lev1sec6)] Determine the effect upon object
    references and primitive values when they are passed into methods that change
    the values. | Object references and primitives are treated in a different manner
    when passed to methods. Unlike reference variables, the values of primitives are
    never changed in the calling method when they’re passed to methods. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [[6.6](kindle_split_020.html#ch06lev1sec6)] 确定当将它们传递给会更改值的函数时，对象引用和原始值的影响。
    | 当传递给方法时，对象引用和原始值被以不同的方式处理。与引用变量不同，当传递给方法时，原始值的值在调用方法中永远不会改变。 |'
- en: Look around, and you’ll find multiple examples of *well-encapsulated objects*.
    For instance, most of us use the services of a bank, which applies a set of well-defined
    processes that enable us to secure our money and valuables (a bank vault). The
    bank may require input from us to execute some of its processes, such as depositing
    money into our accounts. But the bank may or may not inform us about the results
    of other processes; for example, it may inform us about an account balance after
    a transaction, but it likely won’t inform us about its recruitment plans for new
    employees.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 四处看看，你会发现许多*良好封装的对象*的例子。例如，我们中的大多数人使用银行的 服务，它应用一系列定义良好的流程，使我们能够保护我们的金钱和贵重物品（银行保险库）。银行可能需要我们从我们那里获取输入以执行其某些流程，例如将钱存入我们的账户。但是，银行可能或可能不会告诉我们其他流程的结果；例如，它可能在交易后告诉我们账户余额，但很可能不会告诉我们其为新员工招聘的计划。
- en: In Java, you can compare a bank to a well-encapsulated class and the bank processes
    to Java methods. In this analogy, your money and valuables are like object fields
    in Java. You can also compare inputs that a bank process requires to Java’s method
    parameters and compare the bank process result to a Java method’s return value.
    Finally, you can compare the set of steps that a bank executes when it opens a
    bank account to constructors in Java.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以将银行比作一个封装良好的类，而银行流程则对应Java方法。在这个类比中，你的钱和贵重物品就像Java中的对象字段。你还可以将银行流程所需的输入与Java的方法参数进行比较，并将银行流程的结果与Java方法的返回值进行比较。最后，你可以将银行在开设账户时执行的步骤集合与Java中的构造函数进行比较。
- en: 'In the exam, you must answer questions about methods and encapsulation. This
    chapter will help you get the correct answers by covering the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，你必须回答有关方法和封装的问题。本章将帮助你通过涵盖以下内容来获得正确答案：
- en: Defining the scope of variables
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量的作用域
- en: Explaining an object’s life cycle
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释对象的生命周期
- en: Creating methods with primitive and object arguments and return values
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有原始类型和对象参数以及返回值的方法
- en: Creating overloaded methods and constructors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建重载方法和构造函数
- en: Reading and writing to object fields
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入对象字段
- en: Calling methods on objects
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象上调用方法
- en: Applying encapsulation principles to a class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将封装原则应用于类
- en: Let’s get started with the scope of variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始讨论变量的作用域。
- en: 3.1\. Scope of variables
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 变量的作用域
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[1.1] Define the scope of variables'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.1] 定义变量的作用域'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The scope of a variable specifies its life span and its visibility. In this
    section, we’ll cover the scopes of variables, including the domains in which they’re
    accessible. Here are the available scopes of variables:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域指定了其生命周期及其可见性。在本节中，我们将介绍变量的作用域，包括它们可访问的域。以下是可用的变量作用域：
- en: Local variables (also known as method-local variables)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量（也称为方法局部变量）
- en: Method parameters (also known as method arguments)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数（也称为方法参数）
- en: Instance variables (also known as attributes, fields, and nonstatic variables)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量（也称为属性、字段和非静态变量）
- en: Class variables (also known as static variables)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量（也称为静态变量）
- en: As a rule of a thumb, the scope of a variable ends when the brackets of the
    block of code it’s defined in get closed. This might be hard to understand now,
    but it will become clearer when you go through the examples. Let’s get started
    by defining local variables.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，变量的作用域在定义它的代码块括号关闭时结束。现在这可能难以理解，但当你通过示例学习后，它将变得更加清晰。让我们从定义局部变量开始。
- en: 3.1.1\. Local variables
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 局部变量
- en: '*Local variables* are defined within a method. They may or may not be defined
    within code constructs such as `if`-`else` constructs, looping constructs, or
    `switch` statements. Typically, you’d use local variables to store the intermediate
    results of a calculation. Compared to the other three variable scopes listed previously,
    they have the shortest scope (life span).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部变量*是在方法内部定义的。它们可能或可能不在诸如`if-else`结构、循环结构或`switch`语句等代码结构内部定义。通常，你会使用局部变量来存储计算的中间结果。与之前列出的其他三个变量作用域相比，它们的作用域（生命周期）最短。'
- en: 'In the following code, a local variable `avg` is defined within the method
    `get-Average()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，局部变量`avg`是在`get-Average()`方法内部定义的：
- en: '![](149fig01_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](149fig01_alt.jpg)'
- en: As you can see, the variable `avg`, defined locally in the method `getAverage`,
    can’t be accessed outside it, in the method `setAverage`. The scope of this local
    variable, `avg`, is depicted in [figure 3.1](#ch03fig01). The unshaded area marks
    where `avg` is accessible, and the shaded area is where it won’t be available.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在`getAverage`方法中局部定义的变量`avg`不能在它外部，即`setAverage`方法中访问。这个局部变量`avg`的作用域在[图3.1](#ch03fig01)中有所描述。未阴影区域表示`avg`可访问的区域，而阴影区域表示它不可用的区域。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The life span of a variable is determined by its scope. If the scope of a variable
    is limited to a method, its life span is also limited to that method. You may
    notice that these terms are used interchangeably.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的生命周期由其作用域决定。如果变量的作用域仅限于一个方法，那么其生命周期也仅限于该方法。你可能注意到这些术语可以互换使用。
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 3.1\. You can access the local variable avg only within the method `getAverage`.
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 你只能在`getAverage`方法中访问局部变量avg。
- en: '![](03fig01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig01.jpg)'
- en: 'Let’s define another variable, `avg`, local to the `if` block of an `if` statement
    (code that executes when the `if` condition evaluates to `true`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义另一个变量，`avg`，它是`if`语句块（当`if`条件评估为`true`时执行的代码）的局部变量：
- en: '![](150fig01_alt.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](150fig01_alt.jpg)'
- en: In this case, the scope of the local variable `avg` is reduced to the `if` block
    of the `if`-`else` statement defined within the `getAverage` method. The scope
    of this local variable `avg` is depicted in [figure 3.2](#ch03fig02), where the
    unshaded area marks where `avg` is accessible, and the shaded part marks the area
    where it won’t be available.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，局部变量`avg`的作用域缩小到`getAverage`方法内定义的`if`-`else`语句的`if`块。这个局部变量`avg`的作用域在[图3.2](#ch03fig02)中展示，其中无阴影区域表示`avg`可访问的地方，阴影部分表示不可用的地方。
- en: Figure 3.2\. The scope of local variable `avg` is part of the `if` statement.
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 局部变量`avg`的作用域是`if`语句的一部分。
- en: '![](03fig02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig02.jpg)'
- en: 'Similarly, loop variables aren’t accessible outside the loop body:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，循环变量在循环体外部是不可访问的：
- en: '![](150fig02_alt.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](150fig02_alt.jpg)'
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The local variables topic is a favorite of OCA Java SE 8 Programmer I exam authors.
    You’re likely to be asked a question that seems to be about a rather complex topic,
    such as inheritance or exception handling, but instead it’ll be testing your knowledge
    on the scope of a local variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量是OCA Java SE 8程序员I考试作者们偏爱的主题。你可能会被问到关于继承或异常处理等相对复杂主题的问题，但实际测试的将是你对局部变量作用域的知识。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Can a local variable be accessed in a method, before its declaration? No. A
    *forward reference* to local variables isn’t allowed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明之前能否访问局部变量？不可以。不允许对局部变量的**前向引用**：
- en: '![](151fig01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig01.jpg)'
- en: 'If you reverse the declaration of the variables in the preceding example, the
    code will compile:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前例中变量的声明顺序颠倒，代码将可以编译：
- en: '![](151fig02_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig02_alt.jpg)'
- en: The scope of a local variable depends on the location of its declaration within
    a method. The scope of local variables defined within a loop, `if`-`else`, or
    `switch` construct or within a code block (marked with `{}`) is limited to these
    constructs. Local variables defined outside any of these constructs are accessible
    across the complete method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量的作用域取决于其在方法中声明的位置。在循环、`if`-`else`、`switch`构造或代码块（用`{}`标记）内定义的局部变量的作用域仅限于这些构造。在上述构造之外定义的局部变量在整个方法中都是可访问的。
- en: The next section discusses the scope of method parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论方法参数的作用域。
- en: 3.1.2\. Method parameters
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 方法参数
- en: 'The variables that accept values in a method signature are called *method parameters*.
    They’re accessible only in the method that defines them. In the following example,
    a method parameter `val` is defined for the method `setTested`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法签名中接受值的变量被称为**方法参数**。它们只能在定义它们的方法中访问。在以下示例中，为`setTested`方法定义了一个方法参数`val`：
- en: '![](151fig03_alt.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig03_alt.jpg)'
- en: In the preceding code, you can access the method parameter `val` only within
    the method `setTested`. It can’t be accessed in any other method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你只能在`setTested`方法内访问方法参数`val`。在其他任何方法中都无法访问。
- en: The scope of the method parameter `val` is depicted in [figure 3.3](#ch03fig03).
    The unshaded area marks where the variable is accessible, and the shaded part
    marks where it won’t be available.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数`val`的作用域在[图3.3](#ch03fig03)中展示。无阴影区域表示变量可访问的地方，阴影部分表示变量不可用的地方。
- en: Figure 3.3\. The scope of the method parameter `val`, which is defined in the
    method `setTested`
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 在方法`setTested`中定义的方法参数`val`的作用域
- en: '![](03fig03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig03.jpg)'
- en: 'The scope of a method parameter may be as long as that of a local variable
    or longer, but it can never be shorter. The following method, `isPrime`, defines
    a method parameter, `num`, and two local variables, `result` and `ctr`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数的作用域可能和局部变量一样长，甚至更长，但它永远不会更短。以下`isPrime`方法定义了一个方法参数`num`和两个局部变量`result`和`ctr`：
- en: '![](152fig01_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](152fig01_alt.jpg)'
- en: The scope of the method parameter `num` is as long as the scope of the local
    variable `result`. Because the scope of the local variable `ctr` is limited to
    the `for` block, it’s shorter than the method parameter `num`. The comparison
    of the scope of all of these three variables is shown in [figure 3.4](#ch03fig04),
    where the scope of each variable (defined in an oval) is shown by the rectangle
    enclosing it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数 `num` 的范围与局部变量 `result` 的范围相同。因为局部变量 `ctr` 的范围仅限于 `for` 块，所以它比方法参数 `num`
    短。这三个变量范围的比较在 [图 3.4](#ch03fig04) 中显示，其中每个变量的范围（在一个椭圆中定义）由包围它的矩形表示。
- en: Figure 3.4\. Comparison of the scope of method parameters and local variables
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图 3.4](03fig04.jpg)'
- en: '![](03fig04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4](03fig04.jpg)'
- en: Let’s move on to instance variables, which have a larger scope than method parameters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论实例变量，它们的范围比方法参数更大。
- en: 3.1.3\. Instance variables
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3. 实例变量
- en: '*Instance* is another name for an object. Hence, an *instance variable* is
    available for the life of an object. An instance variable is declared within a
    class, outside all the methods. It’s accessible to all the instance (or nonstatic)
    methods defined in a class.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例* 是对象的另一个名称。因此，*实例变量* 在对象的生命周期内可用。实例变量在类中声明，位于所有方法之外。它可被类中定义的所有实例（或非静态）方法访问。'
- en: 'In the following example, the variable `tested` is an instance variable—it’s
    defined within the class `Phone`, outside all the methods. It can be accessed
    by all the methods of class `Phone`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，变量 `tested` 是一个实例变量——它在类 `Phone` 中定义，位于所有方法之外。它可以被类 `Phone` 的所有方法访问：
- en: '![](153fig01_alt.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1](153fig01_alt.jpg)'
- en: The scope of the instance variable `tested` is depicted in [figure 3.5](#ch03fig05).
    As you can see, the variable `tested` is accessible across the object of class
    `Phone`, represented by the unshaded area. It’s accessible in the methods `setTested`
    and `isTested`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 `tested` 的范围在 [图 3.5](#ch03fig05) 中表示。如图所示，变量 `tested` 可以跨 `Phone` 类的对象访问，由无阴影区域表示。它在
    `setTested` 和 `isTested` 方法中可访问。
- en: Figure 3.5\. The instance variable `tested` is accessible across the object
    of class `Phone`.
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5. 实例变量 `tested` 可以跨 `Phone` 类的对象访问。
- en: '![](03fig05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5](03fig05.jpg)'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The scope of an instance variable is longer than that of a local variable or
    a method parameter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量的范围比局部变量或方法参数的范围更长。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Class variables, covered in the next section, have the largest scope of all
    types of variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中介绍的类变量是所有变量类型中范围最大的。
- en: 3.1.4\. Class variables
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.4. 类变量
- en: A *class variable* is defined by using the keyword `static`. A class variable
    belongs to a class, not to individual objects of the class. A class variable is
    shared across all objects—objects don’t have a separate copy of the class variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类变量* 是通过使用关键字 `static` 定义的。类变量属于一个类，而不是属于类的单个对象。类变量在所有对象之间共享——对象没有类变量的单独副本。
- en: 'You don’t even need an object to access a class variable. It can be accessed
    by using the name of the class in which it’s defined:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至不需要一个对象来访问类变量。您可以使用定义它的类的名称来访问它：
- en: '![](153fig02_alt.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2](153fig02_alt.jpg)'
- en: 'Let’s try to access this variable in another class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在另一个类中访问这个变量：
- en: '![](154fig01_alt.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1](154fig01_alt.jpg)'
- en: 'As you can see in the preceding code, the class variable `softKeyboard` is
    accessible using all the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，类变量 `softKeyboard` 可以通过以下所有方式访问：
- en: '`Phone.softKeyboard`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phone.softKeyboard`'
- en: '`p1.softKeyboard`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p1.softKeyboard`'
- en: '`p2.softKeyboard`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p2.softKeyboard`'
- en: 'It doesn’t matter whether you use the name of the class (`Phone`) or reference
    to an object (`p1`) to access a class variable. You can change the value of a
    class variable using either of them because they all refer to a single shared
    copy. When you access static variable `softKeyboard`, Java refers to the *type*
    of reference variables `p1` and `p2` (which is `Phone`) and not to the objects
    referred to by them. So accessing a static variable using a `null` reference won’t
    throw an exception:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用类的名称（`Phone`）还是对象的引用（`p1`）来访问类变量，都没有关系。您可以使用它们中的任何一个来更改类变量的值，因为它们都指向单个共享副本。当您使用
    `null` 引用来访问静态变量 `softKeyboard` 时，Java 会引用引用变量 `p1` 和 `p2` 的 *类型*（即 `Phone`），而不是它们所引用的对象。因此，使用
    `null` 引用访问静态变量不会抛出异常：
- en: '![](154fig02_alt.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2](154fig02_alt.jpg)'
- en: The scope of the class variable `softKeyboard` is depicted in [figure 3.6](#ch03fig06).
    As you can see, a single copy of this variable is accessible to all the objects
    of the class `Phone`. The variable `softKeyboard` is accessible even without the
    existence of any `Phone` instance. The class variable `softKeyboard` is made accessible
    by the JVM when it loads the `Phone` class into memory. The scope of the class
    variable `softKeyboard` depends on its access modifier and that of the `Phone`
    class. Because the class `Phone` and the class variable `softKeyboard` are defined
    using default access, they’re accessible only within the package `com.mobile`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量`softKeyboard`的作用域在[图3.6](#ch03fig06)中展示。如图所示，这个变量的单个副本对所有`Phone`类的对象都是可访问的。即使没有`Phone`实例的存在，`softKeyboard`变量也是可访问的。类变量`softKeyboard`在JVM将`Phone`类加载到内存时由JVM使其可访问。类变量`softKeyboard`的作用域取决于其访问修饰符和`Phone`类的访问修饰符。因为`Phone`类和类变量`softKeyboard`都是使用默认访问定义的，所以它们只能在包`com.mobile`内访问。
- en: Figure 3.6\. The scope of the class variable `softKeyboard` is limited to the
    package `com.mobile` because it’s defined in the class Phone, which is defined
    with default access. The class variable `softKeyboard` is shared and accessible
    across all objects of the class Phone.
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6。类变量`softKeyboard`的作用域限制在包`com.mobile`内，因为它是在使用默认访问定义的`Phone`类中定义的。类变量`softKeyboard`在`Phone`类的所有对象之间共享并可访问。
- en: '![](03fig06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig06.jpg)'
- en: Comparing the use of variables in different scopes
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较不同作用域中变量的使用
- en: 'Here’s a quick comparison of the use of the local variables, method parameters,
    instance variables, and class variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对局部变量、方法参数、实例变量和类变量使用的快速比较：
- en: Local variables are defined within a method and are normally used to store the
    intermediate results of a calculation.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量是在方法内定义的，通常用于存储计算的中间结果。
- en: Method parameters are used to pass values to a method. These values can be manipulated
    and may also be assigned to instance variables.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数用于将值传递给方法。这些值可以被操作，也可以分配给实例变量。
- en: Instance variables are used to store the state of an object. These are the values
    that need to be accessed by multiple methods.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量用于存储对象的状态。这些是需要被多个方法访问的值。
- en: Class variables are used to store values that should be shared by all the objects
    of a class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量用于存储应该由类中所有对象共享的值。
- en: 3.1.5\. Overlapping variable scopes
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.5。重叠变量作用域
- en: In the previous sections on local variables, method parameters, instance variables,
    and class variables, did you notice that some of the variables are accessible
    in multiple places within an object? For example, all four variables will be accessible
    in a loop within a method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的关于局部变量、方法参数、实例变量和类变量的章节中，你是否注意到一些变量在对象内的多个地方都是可访问的？例如，所有四个变量在方法内的循环中都是可访问的。
- en: This overlapping scope is shown in [figure 3.7](#ch03fig07). The variables are
    defined in ovals and are accessible within all methods and blocks, as illustrated
    by their enclosing rectangles.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重叠的作用域在[图3.7](#ch03fig07)中展示。变量定义在椭圆形中，并且可以在所有方法和块内访问，如它们包围的矩形所示。
- en: Figure 3.7\. The scopes of variables can overlap.
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7。变量的作用域可以重叠。
- en: '![](03fig07_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig07_alt.jpg)'
- en: As shown in [figure 3.7](#ch03fig07), an individual copy of `classVariable`
    can be accessed and shared by multiple objects (`object1` and `object2`) of a
    class. Both `object1` and `object2` have their own copy of the instance variable
    `instanceVariable`, so `instance-Variable` is accessible across all the methods
    of `object1`. The methods `method1` and `method2` have their own copies of `localVariable`
    and `methodParameter` when used with `object1` and `object2`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.7](#ch03fig07)所示，一个类的`classVariable`实例可以被该类的多个对象（`object1`和`object2`）访问和共享。`object1`和`object2`各自都有自己的实例变量`instanceVariable`的副本，因此`instanceVariable`可以在`object1`的所有方法中访问。当与`object1`和`object2`一起使用时，`method1`和`method2`各自有自己的`localVariable`和`methodParameter`副本。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The scope of `instanceVariable` overlaps with the scope of `local-Variable`
    and `methodParameter`, defined in `method1`. Hence, all three of these variables
    (`instanceVariable`, `localVariable`, and `methodParameter`) can access each other
    in this overlapped area. But `instanceVariable` can’t access `localVariable` and
    `methodParameter` outside `method1`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceVariable`的作用域与在`method1`中定义的`local-Variable`和`methodParameter`的作用域重叠。因此，这三个变量（`instanceVariable`、`localVariable`和`methodParameter`）可以在重叠区域相互访问。但是`instanceVariable`不能在`method1`外部访问`localVariable`和`methodParameter`。'
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Comparing the scope of variables
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较变量的作用域
- en: '[Figure 3.8](#ch03fig08) compares the life spans of local variables, method
    parameters, instance variables, and class variables.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.8](#ch03fig08)比较了局部变量、方法参数、实例变量和类变量的生命周期。'
- en: Figure 3.8\. Comparing the scope, or life span, of all four variables
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8\. 比较所有四个变量的作用域或生命周期
- en: '![](03fig08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08.jpg)'
- en: As you can see in [figure 3.8](#ch03fig08), local variables have the shortest
    scope or life span, and class variables have the longest scope or life span.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.8](#ch03fig08)所示，局部变量的作用域或生命周期最短，类变量的作用域或生命周期最长。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Different local variables can have different scopes. The scope of local variables
    may be shorter than or as long as the scope of method parameters. The scope of
    local variables is less than the scope of a method if they’re declared in a sub-block
    (within braces `{}`) in a method. This sub-block can be an `if` statement, a `switch`
    construct, a loop, or a `try`-`catch` block (discussed in [chapter 7](kindle_split_021.html#ch07)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的局部变量可以有不同的作用域。局部变量的作用域可能短于或等于方法参数的作用域。如果局部变量在方法中的子块（在大括号`{}`内）中声明，则局部变量的作用域小于方法的作用域。这个子块可以是一个`if`语句、一个`switch`构造、一个循环或一个`try`-`catch`块（在第7章中讨论）。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Variables with the same name in different scopes
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不同作用域中具有相同名称的变量
- en: 'The fact that the scopes of variables overlap results in interesting combinations
    of variables within different scopes but with the same names. Some rules are necessary
    to prevent conflicts. In particular, you can’t define a `static` variable and
    an instance variable with the same name in a class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变量作用域的重叠导致在不同作用域内具有相同名称的变量组合变得有趣。一些规则是必要的，以防止冲突。特别是，你无法在类中定义具有相同名称的`static`变量和实例变量：
- en: '![](157fig01_alt.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](157fig01_alt.jpg)'
- en: 'Similarly, local variables and method parameters can’t be defined with the
    same name. The following code defines a method parameter and a local variable
    with the same name, so it won’t compile:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，局部变量和方法参数不能具有相同的名称。以下代码定义了一个方法参数和一个局部变量，它们具有相同的名称，因此无法编译：
- en: '![](157fig02_alt.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](157fig02_alt.jpg)'
- en: 'A class can define local variables with the same name as the instance or class
    variables, also referred to as *shadowing*. The following code defines a class
    variable and a local variable, `softKeyboard,` with the same name, and an instance
    variable and a local variable, `phoneNumber`, with the same name, which is acceptable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义与实例或类变量具有相同名称的局部变量，也称为*阴影*。以下代码定义了一个类变量和一个局部变量`softKeyboard`，它们具有相同的名称，以及一个实例变量和一个局部变量`phoneNumber`，它们也具有相同的名称，这是可接受的：
- en: '![](157fig03_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](157fig03_alt.jpg)'
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Defining variables with the same name in overlapping scopes can be a dangerous
    coding practice. It’s usually accepted only in very specific situations, like
    constructors and setters. Please write code that’s easy to read, comprehend, and
    maintain.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在重叠的作用域中定义具有相同名称的变量可能是一种危险的编码实践。这通常只在非常特定的情况下被接受，例如构造函数和设置器。请编写易于阅读、理解和维护的代码。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What happens when you assign a value to a local variable that has the same name
    as an instance variable? Does the instance variable reflect this modified value?
    This question provides the food for thought in this chapter’s first Twist in the
    Tale exercise. It should help you remember what happens when you assign a value
    to a local variable when an instance variable already exists with the same name
    in the class (answer in the appendix).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给一个与实例变量具有相同名称的局部变量赋值时会发生什么？实例变量会反映这个修改后的值吗？这个问题为本章“故事中的第一个转折”练习提供了思考的食物。它应该有助于你记住当你给类中已经存在具有相同名称的实例变量赋值时，给局部变量赋值会发生什么（答案见附录）。
- en: Twist in the Tale 3.1
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事中的转折3.1
- en: 'The class `Phone` defines a local variable and an instance variable, `phoneNumber`,
    with the same name. Examine the definition of the method `setNumber`. Execute
    the class on your system and select the correct output of the class `TestPhone`
    from the given options:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Phone` 定义了一个局部变量和一个实例变量，`phoneNumber`，具有相同的名称。检查方法 `setNumber` 的定义。在您的系统上执行该类，并从给定选项中选择类
    `TestPhone` 的正确输出：
- en: '[PRE0]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '123456789'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '123456789'
- en: '987654321'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '987654321'
- en: No output
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无输出
- en: The class `Phone` will not compile.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `Phone` 将无法编译。
- en: In this section, you worked with variables in different scopes. When variables
    go out of scope, they’re no longer accessible by the remaining code. In the next
    section, you’ll see how an object is created and made accessible and then inaccessible.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你使用了不同作用域中的变量。当变量超出作用域时，它们就不再被剩余的代码访问。在下一节中，你将看到对象是如何创建和变得可访问，然后又变得不可访问的。
- en: 3.2\. Object’s life cycle
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 对象的生命周期
- en: '|  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[2.4](kindle_split_013.html#ch02lev1sec4)] Explain an Object’s Lifecycle (creation,
    “dereference by reassignment” and garbage collection)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.4](kindle_split_013.html#ch02lev1sec4)] 解释对象的生命周期（创建、“通过重新赋值取消引用”和垃圾回收）'
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The OCA Java SE 8 Programmer I exam will test your understanding of when an
    object is created, when it can be accessed, and when it can be dereferenced. The
    exam also tests your ability to determine the total number of objects that are
    accessible at a particular line of code. Primitives aren’t objects, so they’re
    not relevant in this section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8 程序员 I 考试将测试你对对象何时创建、何时可访问以及何时可取消引用的理解。考试还将测试你确定特定代码行处可访问对象总数的能力。原始数据类型不是对象，因此在本节中不相关。
- en: Unlike some other programming languages, such as C, Java doesn’t allow you to
    allocate or deallocate memory yourself when you create or destroy objects. Java
    manages the memory for allocating objects and reclaiming the memory occupied by
    unused objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他编程语言，如 C 语言不同，Java 不允许你在创建或销毁对象时自行分配或释放内存。Java 管理分配对象和回收未使用对象占用的内存。
- en: The task of reclaiming unused memory is taken care of by Java’s garbage collector,
    which is a low-priority thread. It runs periodically and frees up space occupied
    by unused objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回收未使用内存的任务由 Java 的垃圾回收器处理，它是一个低优先级的线程。它定期运行并释放未使用对象占用的空间。
- en: Java also provides a method called `finalize`, which is accessible to all the
    classes. The method `finalize` is defined in the class `java.lang.Object`, which
    is the base class of all Java classes. All Java classes can override the method
    `finalize`, which executes just before an object is garbage collected. In theory,
    you can use this method to free up resources being used by an object, although
    doing so isn’t recommended because its execution isn’t guaranteed to happen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Java 还提供了一个名为 `finalize` 的方法，该方法对所有类都是可访问的。`finalize` 方法在类 `java.lang.Object`
    中定义，这是所有 Java 类的基类。所有 Java 类都可以重写 `finalize` 方法，该方法在对象被垃圾回收之前执行。理论上，你可以使用此方法释放对象使用的资源，尽管这样做并不推荐，因为其执行并不保证会发生。
- en: An object’s life cycle starts when it’s created and lasts until it goes out
    of scope or is no longer referenced by a variable. When an object is accessible,
    it can be referenced by a variable and other classes can use it by calling its
    methods and accessing its variables. I’ll discuss these stages in detail in the
    following subsections.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生命周期从其创建开始，一直持续到它超出作用域或不再被变量引用。当对象可访问时，它可以被变量引用，其他类可以通过调用其方法和访问其变量来使用它。我将在以下子节中详细讨论这些阶段。
- en: 3.2.1\. An object is born
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 一个对象诞生
- en: 'An object comes into the picture when you use the keyword operator `new`. You
    can initialize a reference variable with this object. Note the difference between
    declaring a variable and initializing it. The following is an example of a class
    `Person` and a class `ObjectLifeCycle`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用关键字操作符 `new` 时，对象就会出现。你可以使用此对象初始化一个引用变量。注意声明变量和初始化它的区别。以下是一个 `Person` 类和一个
    `ObjectLifeCycle` 类的示例：
- en: '![](159fig01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](159fig01.jpg)'
- en: 'In the preceding code, no objects of class `Person` are created in the class
    `ObjectLifeCycle`; it declares only a variable of type `Person`. An object is
    created when a reference variable is initialized:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类 `ObjectLifeCycle` 中没有创建 `Person` 类的对象；它只声明了一个 `Person` 类型的变量。当引用变量被初始化时，才会创建对象：
- en: '![](159fig02_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](159fig02_alt.jpg)'
- en: The difference in variable declaration and object creation is illustrated in
    [figure 3.9](#ch03fig09), where you can compare a baby name to a reference variable
    and a real baby to an object. The left box in [figure 3.9](#ch03fig09) represents
    variable declaration, because the baby hasn’t been born yet. The right box in
    [figure 3.9](#ch03fig09) represents object creation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明和对象创建的区别在[图3.9](#ch03fig09)中得到了说明，你可以将婴儿的名字与引用变量相比，将真正的婴儿与对象相比。图3.9中的左框代表变量声明，因为婴儿还没有出生。图3.9中的右框代表对象创建。
- en: Figure 3.9\. The difference between declaring a reference variable and initializing
    a reference variable
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9\. 声明引用变量和初始化引用变量的区别
- en: '![](03fig09_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig09_alt.jpg)'
- en: 'Syntactically, an object comes into being by using the `new` operator. But
    the `String` class is an exceptional case here. `String` reference variables can
    also be initialized by using string literal values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，对象是通过使用`new`运算符创建的。但`String`类在这里是一个特例。`String`引用变量也可以通过使用字符串字面值来初始化：
- en: '![](159fig03_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](159fig03_alt.jpg)'
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Initializing a reference variable and an instance is not same. Initializing
    a reference variable might not always result in the creation of a new instance.
    In [chapter 4](kindle_split_015.html#ch04), we’ll cover in detail how `String`
    *literal values* are pooled in a *String pool* by JVM. Although using the `new`
    operator always creates a new `String` object, using a `String` literal value
    to initialize a `String` reference variable might not always create a new `String`
    object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化引用变量和实例化不是一回事。初始化引用变量不一定总是导致创建新的实例。在[第4章](kindle_split_015.html#ch04)中，我们将详细讲解JVM如何将`String`
    *字面值*池化到*字符串池*中。尽管使用`new`运算符总是创建一个新的`String`对象，但使用`String`字面值来初始化`String`引用变量不一定总是创建一个新的`String`对象。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'What happens when you create a new object without assigning it to any reference
    variable? Let’s create a new object of class `Person` in class `ObjectLifeCycle2`
    without assigning it to any reference variable (modifications in bold):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新对象而没有将其分配给任何引用变量时会发生什么？让我们在类`ObjectLifeCycle2`中创建一个新对象`Person`，但不将其分配给任何引用变量（粗体部分为修改）：
- en: '![](160fig01_alt.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](160fig01_alt.jpg)'
- en: In the preceding example, an object of the class `Person` is created, but it
    can’t be accessed using any reference variable. Creating an object in this manner
    will execute the relevant constructors of the class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，创建了一个`Person`类的对象，但无法使用任何引用变量来访问它。以这种方式创建对象将执行类的相关构造函数。
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for a count of instances created in a given code—the ones that are
    eligible for garbage collection and the ones that aren’t.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在给定代码中创建的实例的数量——那些可以和不可以进行垃圾回收的实例。
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, you’ll learn what happens after an object is created.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解对象创建后会发生什么。
- en: 3.2.2\. Object is accessible
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 对象是可访问的
- en: Once an object is created, it can be accessed using its reference variable.
    It remains accessible until it goes out of scope or its reference variable is
    explicitly set to `null`. Also, if you reassign another object to an initialized
    reference variable, the previous object becomes inaccessible *from that variable*.
    You can access and use an object within other classes and methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了对象，就可以使用其引用变量来访问它。它将保持可访问状态，直到它超出作用域或其引用变量被显式设置为`null`。此外，如果你将另一个对象重新分配给已初始化的引用变量，则之前的对象将从这个变量中变得不可访问。你可以在其他类和方法中访问和使用对象。
- en: 'Look at the following definition of the class `Exam`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下`Exam`类的定义：
- en: '[PRE1]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The class `ObjectLife1` declares a variable of type `Exam`, creates its object,
    calls its method, sets it to `null`, and then reinitializes it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectLife1`类声明了一个`Exam`类型的变量，创建了它的对象，调用了它的方法，将其设置为`null`，然后重新初始化它：'
- en: '![](161fig01_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](161fig01_alt.jpg)'
- en: 'The preceding example creates two objects of the class `Exam` using the same
    reference variable `myExam`. Let’s walk through what’s happening in the example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用相同的引用变量`myExam`创建了两个`Exam`类的对象。让我们分析一下例子中发生的情况：
- en: '![](num-1.jpg) creates a reference variable `myExam` and initializes it with
    an object of class `Exam`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-1.jpg) 创建了一个引用变量`myExam`，并用`Exam`类的对象初始化它。'
- en: '![](num-2.jpg) calls method `setName` on the object referenced by the variable
    `myExam`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-2.jpg) 在变量`myExam`引用的对象上调用`setName`方法。'
- en: '![](num-3.jpg) assigns a value `null` to the reference variable `myExam` such
    that the object referenced by this variable is no longer accessible through `myExam`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-3.jpg] 将值`null`分配给引用变量`myExam`，这样通过`myExam`就无法访问该变量所引用的对象。'
- en: '![](num-4.jpg) creates a new object of class `Exam` and assigns it to the reference
    variable `myExam`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-4.jpg] 创建了一个新的`Exam`类的对象并将其分配给引用变量`myExam`。'
- en: '![](num-5.jpg) calls method `setName` on the second `Exam` object, created
    in method `main`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![num-5.jpg] 在方法`main`中创建的第二个`Exam`对象上调用`setName`方法。'
- en: When ![](num-4.jpg) creates another object of class `Exam` and assigns it to
    the variable `myExam`, what happens to the first object created by ![](num-1.jpg)?
    Because the first object can no longer be accessed using any variable, it’s considered
    garbage by Java and deemed eligible to be sent to the garbage bin by Java’s garbage
    collector. As mentioned earlier, the garbage collector is a low-priority thread
    that reclaims the space used by unused or unreferenced objects in Java.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当![num-4.jpg] 创建另一个`Exam`类的对象并将其分配给变量`myExam`时，第一个由![num-1.jpg] 创建的对象会发生什么？因为第一个对象无法通过任何变量访问，所以Java认为它是垃圾，并认为它应该由Java的垃圾回收器送入垃圾箱。如前所述，垃圾回收器是一个低优先级的线程，它回收Java中未使用或未引用的对象所占用的空间。
- en: What happens when an object become inaccessible? You’ll find out in the next
    section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象变得不可访问时会发生什么？你将在下一节中找到答案。
- en: 3.2.3\. Object is inaccessible
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.3. 对象不可访问
- en: An object can become inaccessible if it goes out of scope or is dereferenced
    by reassignment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象超出作用域或通过重新分配被取消引用，它可能变得不可访问。
- en: Variable goes out of scope
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量超出作用域
- en: 'An object can become inaccessible if it goes out of scope:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象超出作用域，它可能变得不可访问：
- en: '![](162fig01_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![162fig01_alt.jpg]'
- en: In the preceding code, the variable `myExam1` is a local variable defined within
    the `if` block. Its scope starts from the line where it’s declared until the end
    of the `if` block, marked with a closing brace ![](num-1.jpg). After this closing
    brace, the object referred by the variable `myExam1` is no longer accessible.
    It goes out of scope and is marked as eligible for garbage collection by Java’s
    garbage collector. Similarly, the object referred to by the variable `myExam2`
    becomes inaccessible at the end of the `else` block, marked with a closing brace
    ![](num-3.jpg).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量`myExam1`是在`if`块内定义的局部变量。它的作用域从声明它的行开始，直到以闭合花括号![num-1.jpg] 标记的`if`块的末尾。在这个闭合花括号之后，变量`myExam1`所引用的对象不再可访问。它超出作用域，并被Java的垃圾回收器标记为符合垃圾回收的条件。同样，变量`myExam2`所引用的对象在以闭合花括号![num-3.jpg]
    标记的`else`块末尾变得不可访问。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When an object goes out of scope, it can no longer be referenced and is marked
    for garbage collection.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象超出作用域时，它将无法被引用，并被标记为垃圾回收。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Dereferencing by reassignment
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过重新分配取消引用
- en: 'A variable that already refers to an instance can be assigned another instance.
    In this case, the earlier instance is dereferenced and becomes eligible for garbage
    collection. Let’s work with a modified version of a previous code example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 已经引用实例的变量可以被分配另一个实例。在这种情况下，较早的实例被取消引用，并符合垃圾回收的条件。让我们用一个修改过的先前代码示例来工作：
- en: '![](162fig02_alt.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![162fig02_alt.jpg]'
- en: In the preceding code, an `Exam` instance is created and assigned to the variable
    `myExam` ![](num-1.jpg). At ![](num-2.jpg) `myExam` is set to `null` before being
    assigned another `Exam` instance ![](num-3.jpg). The code at ![](num-4.jpg) reassigns
    yet another `Exam` instance to `myExam`, without explicitly setting it to `null`.
    Again, the instance created at ![](num-3.jpg) is dereferenced. After the execution
    of ![](num-4.jpg), two `MyExam` instances are dereferenced by reassignment and
    are eligible for garbage collection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，创建了一个`Exam`实例并将其分配给变量`myExam` ![num-1.jpg]。在![num-2.jpg] `myExam`被分配另一个`Exam`实例之前被设置为`null`
    ![num-3.jpg]。![num-4.jpg] 中的代码重新分配了另一个`Exam`实例给`myExam`，而没有明确将其设置为`null`。同样，在![num-3.jpg]
    创建的实例再次被取消引用。在![num-4.jpg] 执行后，两个`MyExam`实例通过重新分配被取消引用，并符合垃圾回收的条件。
- en: At ![](num-5.jpg), another variable, `yourExam`, is initialized using an `Exam`
    instance. At ![](num-6.jpg), the variable `myExam` is assigned to the variable
    `yourExam`. This dereferences the `Exam` instance, which was assigned to `yourExam`
    earlier.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在![num-5.jpg]，另一个变量`yourExam`使用`Exam`实例初始化。在![num-6.jpg]，变量`myExam`被分配给变量`yourExam`。这取消了之前分配给`yourExam`的`Exam`实例的引用。
- en: '[Figure 3.10](#ch03fig10) shows how `Exam` instances are referred to by the
    variables `myExam` and `yourExam`. The `Exam` instances highlighted using gray
    boxes represent unreferenced objects.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.10](#ch03fig10) 展示了`Exam`实例如何通过变量`myExam`和`yourExam`被引用。使用灰色框突出显示的`Exam`实例代表未引用的对象。'
- en: Figure 3.10\. Objects can be dereferenced by reassignment of variables.
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10\. 对象可以通过变量的重新赋值来解除引用。
- en: '![](03fig10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig10.jpg)'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: An instance is dereferenced by reassignment when a variable is either explicitly
    set to `null` or is assigned another instance or reference variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被显式设置为`null`或分配给另一个实例或引用变量时，实例通过重新赋值来解除引用。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2.4\. Garbage collection
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.4\. 垃圾回收
- en: In the OCA Java SE 8 Programmer I exam, you’re likely to answer questions on
    garbage collection for code that has multiple variable declarations and initializations.
    The exam may query you on the total number of objects that are eligible for garbage
    collection after a particular line of code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA Java SE 8程序员I级考试中，你可能会回答有关具有多个变量声明和初始化的代码的垃圾回收问题。考试可能会询问在特定代码行之后有多少对象有资格进行垃圾回收。
- en: Automatic memory management
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动内存管理
- en: The garbage collector is a low-priority thread that marks the objects eligible
    for garbage collection in the JVM and then clears the memory of these objects.
    It enables automatic memory management because programmers aren’t required to
    mark these instances themselves.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器是一个低优先级的线程，它在JVM中标记有资格进行垃圾回收的对象，然后清除这些对象的内存。它通过程序员不需要自己标记这些实例来实现自动内存管理。
- en: When is an object garbage collected?
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时进行垃圾回收？
- en: You can determine only which objects are *eligible* to be garbage collected.
    You can *never* determine when a particular object *will* be garbage collected.
    A user can’t control or determine the execution of a garbage collector. It’s controlled
    by the JVM.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能确定哪些对象有资格进行垃圾回收。你永远无法确定特定对象何时会被垃圾回收。用户无法控制或确定垃圾回收器的执行。它由JVM控制。
- en: '|  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for questions with wordings such as “which objects are sure to be
    collected during the next GC cycle,” for which the real answer can never be known.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些措辞如“在下一个GC周期中哪些对象一定会被收集”的问题，对于这类问题的真正答案永远无法得知。
- en: '|  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s revisit the dog and leash analogy I used in [chapter 2](kindle_split_013.html#ch02)
    to define object reference variables. In [figure 3.11](#ch03fig11), you can compare
    an object reference variable with a leash and an object with a dog. Review the
    following comparisons, which will help you to understand the life cycle of an
    object and garbage collection:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我在[第2章](kindle_split_013.html#ch02)中使用的狗和狗绳的类比来定义对象引用变量。在[图3.11](#ch03fig11)中，你可以将对象引用变量与狗绳以及对象与狗进行比较。回顾以下比较，这将帮助你理解对象的生命周期和垃圾回收：
- en: An uninitialized reference variable can be compared to a dog leash without a
    dog.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个未初始化的引用变量可以比作没有狗的狗绳。
- en: An initialized reference variable can be compared to a leashed dog.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已初始化的引用变量可以比作拴着的狗。
- en: An unreferenced object can be compared to an unleashed dog.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个未引用的对象可以比作未拴的狗。
- en: Figure 3.11\. Comparing object reference variables and objects to dog leashes
    and leashed and unleashed dogs
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11\. 比较对象引用变量和对象与狗绳和拴着的狗以及未拴的狗
- en: '![](03fig11_alt.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig11_alt.jpg)'
- en: You can compare Java’s garbage collector to animal control. The way animal control
    picks up untethered dogs is like the way Java’s garbage collector reclaims the
    memory used by unreferenced objects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Java的垃圾回收器比作动物控制。动物控制收集未拴狗的方式就像Java的垃圾回收器回收未引用对象使用的内存一样。
- en: Using System.gc() or Runtime.getRuntime().gc()
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`System.gc()`或`Runtime.getRuntime().gc()`
- en: As a programmer, you can’t start execution of Java’s garbage collector. You
    can only *request* it to be started by calling `System.gc()` or `Runtime.getRuntime().gc()`.
    But calling this method doesn’t guarantee when the garbage collector would start
    (the call can even be ignored by the JVM). Watch out for exam questions that query
    you on the number of instances that have been garbage collected after calling
    `System.gc()`. It won’t *guarantee* any count, at any line of code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你不能启动Java垃圾回收器的执行。你只能通过调用`System.gc()`或`Runtime.getRuntime().gc()`来请求它启动。但调用此方法并不保证垃圾回收器何时会启动（JVM甚至可以忽略这个调用）。注意那些询问你在调用`System.gc()`之后有多少实例已被垃圾回收的考试问题。它不会在任何代码行保证任何计数。
- en: Garbage collecting referenced objects
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 垃圾回收引用对象
- en: The garbage collector can also reclaim memory from a group of referenced objects.
    This group of variables is referred to as an *island of isolation*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器还可以从一组引用对象中回收内存。这组变量被称为 *隔离岛*。
- en: 'An instance can be referred to by multiple variables. So when you assign `null`
    to one of these variables, the instances can still be referenced using other variable(s).
    But a group of instances with no *external reference* becomes eligible for garbage
    collection. Let’s work with an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实例可以被多个变量引用。因此，当你将这些变量之一设置为 `null` 时，实例仍然可以通过其他变量（s）进行引用。但是，没有 *外部引用* 的一组实例符合垃圾回收的条件。让我们通过一个例子来操作：
- en: '![](165fig01_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](165fig01_alt.jpg)'
- en: In the preceding example, an `Exam` instance can refer to an object of its own
    type, using its field `other`. At ![](num-1.jpg) and ![](num-2.jpg), two variables,
    `php` and `java`, are created and initialized using `Exam` instances. At ![](num-3.jpg),
    `java` is assigned to `php.other`. At ![](num-4.jpg), `php` is assigned to `java.other`.
    At ![](num-5.jpg), when `php` is set to `null`, the instance referred to by it
    *isn’t* eligible for garbage collection because it can still be referenced using
    `java.other`. At ![](num-6.jpg), when `java` is also set to `null`, both the objects
    referred to by `java` and `php` become eligible for garbage collection. As shown
    in [figure 3.12](#ch03fig12), even though both these objects can be referred to
    by each other, they can no longer be referenced in the method `main`. They form
    an *island of isolation*. Java’s garbage collector can determine such groups of
    instances.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，一个 `Exam` 实例可以使用其字段 `other` 指向其自身类型的对象。在 ![](num-1.jpg) 和 ![](num-2.jpg)
    处，创建了两个变量 `php` 和 `java`，并使用 `Exam` 实例进行初始化。在 ![](num-3.jpg) 处，`java` 被赋值给 `php.other`。在
    ![](num-4.jpg) 处，`php` 被赋值给 `java.other`。在 ![](num-5.jpg) 处，当 `php` 被设置为 `null`
    时，它所引用的实例 *不* 符合垃圾回收的条件，因为它仍然可以通过 `java.other` 进行引用。在 ![](num-6.jpg) 处，当 `java`
    也被设置为 `null` 时，`java` 和 `php` 所引用的对象都符合垃圾回收的条件。如图 [图 3.12](#ch03fig12) 所示，尽管这两个对象可以相互引用，但它们在
    `main` 方法中不能再被引用。它们形成了一个 *隔离岛*。Java 的垃圾回收器可以确定这样的实例组。
- en: Figure 3.12\. A group of instances with no external references forms an island
    of isolation, which is eligible for garbage collection.
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.12\. 没有外部引用的一组实例形成一个隔离岛，符合垃圾回收的条件。
- en: '![](03fig12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig12.jpg)'
- en: Now that you’re familiar with an object’s life cycle, you can create methods
    that accept primitive data types and objects as method arguments; these methods
    return a value, which can be either a primitive data type or an object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了对象的生命周期，你可以创建接受原始数据类型和对象作为方法参数的方法；这些方法返回一个值，这个值可以是原始数据类型或对象。
- en: 3.3\. Create methods with arguments and return values
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 创建具有参数和返回值的方法
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[6.1](kindle_split_019.html#ch06lev1sec1)] Create methods with arguments and
    return values; including overloaded methods'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.1](kindle_split_019.html#ch06lev1sec1)] 创建具有参数和返回值的方法；包括重载方法'
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you’ll work with the definitions of methods, which may or may
    not accept input parameters and may or may not return any values.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将处理方法的定义，这些方法可能接受输入参数，也可能不返回任何值。
- en: A method is a group of statements identified with a name. Methods are used to
    define the behavior of an object. A method can perform different operations, as
    shown in [figure 3.13](#ch03fig13).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是一组与名称相关的语句。方法用于定义对象的行为。方法可以执行不同的操作，如图 [图 3.13](#ch03fig13) 所示。
- en: Figure 3.13\. Different types of methods
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. 不同类型的方法
- en: '![](03fig13_alt.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig13_alt.jpg)'
- en: The method `setModel` can access and modify the state of a `Phone` instance.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setModel` 方法可以访问并修改 `Phone` 实例的状态。'
- en: The method `printVal` uses only the method parameter passed to it.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printVal` 方法仅使用传递给它的方法参数。'
- en: The method `todaysDate` initializes a `java.util.Date` instance and returns
    its `String` presentation.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`todaysDate` 方法初始化一个 `java.util.Date` 实例，并返回其 `String` 表示形式。'
- en: 'In the following subsections, you’ll learn about the components of a method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，你将了解方法组件：
- en: Return type
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型
- en: Method parameters
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数
- en: '`return` statement'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 语句'
- en: Access modifiers (covered in [chapter 1](kindle_split_011.html#ch01))
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符（在第 1 章中介绍）
- en: Nonaccess modifiers (covered in [chapter 1](kindle_split_011.html#ch01))
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非访问修饰符（在第 1 章中介绍）
- en: '[Figure 3.14](#ch03fig14) shows the code of a method accepting method parameters
    and defining a return type and a `return` statement.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.14](#ch03fig14) 展示了一个接受方法参数并定义返回类型和 `return` 语句的方法的代码。'
- en: Let’s get started with a discussion of the return type of a method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论方法的返回类型开始。
- en: Figure 3.14\. An example of a method that accepts method parameters and defines
    a return type and a `return` statement
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.14\. 接受方法参数并定义返回类型和 `return` 语句的方法示例
- en: '![](03fig14_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig14_alt.jpg)'
- en: 3.3.1\. Return type of a method
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 方法的返回类型
- en: The return type of a method states the type of value that a method will return.
    A method may or may not return a value. One that doesn’t return a value has a
    return type of `void`. A method can return a primitive value or an object of any
    class. The name of the return type can be any of the eight primitive types defined
    in Java, a class, or an interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的返回类型声明了方法将返回的值的类型。一个方法可能返回值，也可能不返回值。不返回值的方法具有 `void` 返回类型。方法可以返回一个原始值或任何类的对象。返回类型的名称可以是
    Java 中定义的八个原始类型之一、一个类或一个接口。
- en: 'In the following code, the method `setWeight` doesn’t return any value, and
    the method `getWeight` returns a value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，方法 `setWeight` 不返回任何值，而方法 `getWeight` 返回一个值：
- en: '![](168fig01_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](168fig01_alt.jpg)'
- en: If a method doesn’t return a value, you can’t assign the result of that method
    to a variable. What do you think is the output of the following class `TestMethods`,
    which uses the preceding class `Phone`?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法不返回值，你不能将该方法的结果赋给变量。你认为以下使用前面类 `Phone` 的 `TestMethods` 类的输出是什么？
- en: '![](168fig02_alt.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](168fig02_alt.jpg)'
- en: The preceding code won’t compile because the method `setWeight` doesn’t return
    a value. Its return type is `void`. Because the method `setWeight` doesn’t return
    a value, there’s nothing to be assigned to the variable `newWeight`, so the code
    fails to compile.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码无法编译，因为方法 `setWeight` 不返回任何值。它的返回类型是 `void`。因为方法 `setWeight` 不返回任何值，所以没有可以赋给变量
    `newWeight` 的内容，因此代码无法编译。
- en: 'If a method returns a value, the calling method may or may not bother to store
    the returned value from a method in a variable. Look at the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法返回一个值，调用该方法可能或可能不会费心将方法返回的值存储在变量中。看看以下代码：
- en: '![](168fig03_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](168fig03_alt.jpg)'
- en: In the preceding example, the value returned by the method `getWeight` isn’t
    assigned to any variable, which isn’t an issue for the Java compiler. The compiler
    will happily compile the code for you.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，方法 `getWeight` 返回的值没有被赋给任何变量，这对 Java 编译器来说不是问题。编译器会愉快地为你编译代码。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You can optionally assign the value returned by a method to a variable. If you
    don’t assign the returned value from a method, it’s neither a compilation error
    nor a runtime exception.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择将方法返回的值赋给变量。如果你没有将方法返回的值赋给变量，这既不是编译错误，也不是运行时异常。
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The value that you return from a method must be assignable to the variable
    to which it’s being assigned. For instance, the return value of `getWeight()`
    in `Phone` is `double`. You can assign the return value of `getWeight()` to a
    variable of type `double` but not to a variable of type `int` (without an explicit
    cast). Here’s the code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你从方法返回的值必须可以赋值给它被赋值的变量。例如，`Phone` 中的 `getWeight()` 的返回值是 `double`。你可以将 `getWeight()`
    的返回值赋给 `double` 类型的变量，但不能赋给 `int` 类型的变量（没有显式转换）。以下是代码：
- en: '![](169fig01_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](169fig01_alt.jpg)'
- en: 'In the preceding code, ![](num-1.jpg) will compile successfully because the
    return type of the method `getWeight` is `double` and the type of the variable
    `newWeight` is also `double`. But ![](num-2.jpg) won’t compile because the `double`
    value returned from method `getWeight` can’t be assigned to variable `newWeight2`,
    which is of type `int`. You can make it happen by an explicit cast:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![](num-1.jpg) 将成功编译，因为方法 `getWeight` 的返回类型是 `double`，而变量 `newWeight`
    的类型也是 `double`。但 ![](num-2.jpg) 无法编译，因为从方法 `getWeight` 返回的 `double` 值不能赋给类型为 `int`
    的变量 `newWeight2`。你可以通过显式转换使其发生：
- en: '![](169fig02_alt.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](169fig02_alt.jpg)'
- en: 'But an explicit cast won’t work with data types that aren’t compatible:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但显式转换不适用于不兼容的数据类型：
- en: '![](169fig03_alt.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](169fig03_alt.jpg)'
- en: We’ve discussed how to transfer a value out from a method. To transfer a value
    into a method, you can use method arguments.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何从方法中传递一个值。要将值传递到方法中，你可以使用方法参数。
- en: 3.3.2\. Method parameters
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 方法参数
- en: '*Method parameters* are the variables that appear in the definition of a method
    and specify the type and number of values that a method can accept. In [figure
    3.15](#ch03fig15), the variables `phNum` and `msg` are the method parameters.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法参数*是出现在方法定义中的变量，并指定方法可以接受的数据类型和值的数量。在[图3.15](#ch03fig15)中，变量`phNum`和`msg`是方法参数。'
- en: Figure 3.15\. An example of a method that accepts method parameters and defines
    a return type and a `return` statement
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.15\. 一个接受方法参数并定义返回类型和`return`语句的方法示例
- en: '![](03fig15_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig15_alt.jpg)'
- en: You can pass multiple values to a method as input. Theoretically, no limit exists
    on the number of method parameters that can be defined by a method, but practically
    it’s not a good idea to define more than three method parameters. It’s cumbersome
    to use a method with too many method parameters because you have to cross-check
    their types and purposes multiple times to ensure that you’re passing the right
    values at the right positions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将多个值传递给一个方法作为输入。理论上，没有限制可以定义的方法参数数量，但实际上定义超过三个方法参数并不是一个好主意。使用具有太多方法参数的方法很繁琐，因为您必须多次交叉检查它们的类型和目的，以确保您在正确的位置传递了正确的值。
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although the terms *method parameters* and *method arguments* are not the same,
    you may have noticed that many programmers use them interchangeably. *Method parameters*
    are the variables that appear in the definition of a method. *Method arguments*
    are the actual values that are passed to a method while executing it. In [figure
    3.15](#ch03fig15), the variables `phNum` and `msg` are method parameters. If you
    execute this method as `sendMsg("123456", "Hello")`, then the `String` values
    `"123456"` and `"Hello"` are method arguments. As you know, you can pass literal
    values or variables to a method. Thus, method arguments can be literal values
    or variables.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语*方法参数*和*方法参数*并不相同，您可能已经注意到许多程序员将它们互换使用。*方法参数*是出现在方法定义中的变量。*方法参数*是在执行方法时传递给方法的实际值。在[图3.15](#ch03fig15)中，变量`phNum`和`msg`是方法参数。如果您以`sendMsg("123456",
    "Hello")`的方式执行此方法，那么`String`值`"123456"`和`"Hello"`是方法参数。如您所知，您可以将字面值或变量传递给方法。因此，方法参数可以是字面值或变量。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A method may accept zero or multiple method arguments. The following example
    accepts two `int` values and returns their average as a `double` value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以接受零个或多个方法参数。以下示例接受两个`int`值，并返回它们的平均值作为`double`值：
- en: '![](170fig01_alt.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](170fig01_alt.jpg)'
- en: 'The following example shows a method that doesn’t accept any method parameters:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个不接受任何方法参数的方法：
- en: '[PRE2]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If a method doesn’t accept any parameters, the parentheses that follow the
    name of the method are empty. Because the keyword `void` is used to specify that
    a method doesn’t return a value, you may think it’s correct to use the keyword
    `void` to specify that a method doesn’t accept any method parameters, but this
    is incorrect. The following is an invalid definition of a method that accepts
    no parameters:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法不接受任何参数，则方法名称后面的括号是空的。因为关键字`void`用于指定方法不返回值，您可能会认为使用关键字`void`来指定方法不接受任何方法参数是正确的，但实际上这是不正确的。以下是不接受参数的方法定义无效的示例：
- en: '![](171fig01.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](171fig01.jpg)'
- en: 'You can define a parameter that can accept variable arguments (varargs) in
    your methods. Following is an example of the class `Employee`, which defines a
    method `days-OffWork` that accepts variable arguments:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在方法中定义一个可以接受可变参数（varargs）的参数。以下是一个名为`Employee`的类的示例，它定义了一个名为`days-OffWork`的方法，该方法接受可变参数：
- en: '[PRE3]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The ellipsis (`...`) that follows the data type indicates that the method parameter
    `days` may be passed an array or multiple comma-separated values. Reexamine the
    preceding code example and note the usage of the variable `days` in the method
    `daysOffWork`—it works like an array. When you define a variable-length argument
    for a method, Java creates an array behind the scenes to implement it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 跟在数据类型后面的省略号（`...`）表示方法参数`days`可以传递一个数组或多个以逗号分隔的值。重新审查前面的代码示例，并注意在`daysOffWork`方法中变量`days`的使用——它就像一个数组。当您为方法定义可变长度参数时，Java会在幕后创建一个数组来实现它。
- en: 'You can define only one variable argument in a parameter list, and it must
    be the last variable in the parameter list. If you don’t comply with these two
    rules, your code won’t compile:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数列表中，您只能定义一个可变参数，并且它必须是参数列表中的最后一个变量。如果您不遵守这两条规则，您的代码将无法编译：
- en: '![](171fig02_alt.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](171fig02_alt.jpg)'
- en: 'If your method defines multiple method parameters, the variable that accepts
    variable arguments must be the last one in the parameter list:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法定义了多个方法参数，接受可变参数的变量必须是参数列表中的最后一个：
- en: '![](171fig03_alt.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](171fig03_alt.jpg)'
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: In the OCA exam, you may be questioned on the valid return types for a method
    that doesn’t accept any method parameters. Note that there are no valid or invalid
    combinations of the number and type of method parameters that can be passed to
    a method and the value that it can return. They’re independent of each other.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA考试中，你可能会被问及不接受任何方法参数的方法的有效返回类型。请注意，没有有效或无效的组合可以传递给方法的方法参数的数量和类型以及它可以返回的值。它们是相互独立的。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can pass any type and number of parameters to a method, including primitives,
    objects of a class, or objects referenced by an interface.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向方法传递任何类型和数量的参数，包括基本类型、类的对象或接口引用的对象。
- en: Rules to remember
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要记住的规则
- en: 'Here are some points to note with respect to defining method parameters:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义方法参数时需要注意以下事项：
- en: You can define multiple parameters for a method.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为方法定义多个参数。
- en: The method parameter can be a primitive type or object.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数可以是基本类型或对象。
- en: The method’s parameters are separated by commas.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数之间用逗号分隔。
- en: Each method parameter is preceded by the name of its type. Each method parameter
    must have an explicit type declared with its name. You can’t declare the type
    once and then list the parameters separated by commas, as you can for variables.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法参数前面都跟着其类型的名称。每个方法参数必须使用其名称显式声明类型。你不能像变量那样先声明类型，然后用逗号分隔参数列表。
- en: 3.3.3\. Return statement
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 返回语句
- en: A `return` statement is used to exit from a method, with or without a value.
    For methods that define a return type, the `return` statement must be immediately
    followed by a return value. For methods that don’t return a value, the `return`
    statement can be used without a return value to exit a method. [Figure 3.16](#ch03fig16)
    illustrates the use of a `return` statement.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句用于从方法中退出，无论是否有值。对于定义了返回类型的方法，`return`语句必须立即后跟返回值。对于不返回值的方法，可以使用不带返回值的`return`语句来退出方法。[图3.16](#ch03fig16)说明了`return`语句的使用。'
- en: Figure 3.16\. An example of a method that accepts method parameters and defines
    a return type and a `return` statement
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.16\. 接受方法参数并定义返回类型和`return`语句的方法示例
- en: '![](03fig16_alt.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig16_alt.jpg)'
- en: 'In this example, we’ll revisit the previous example of method `calcAverage`,
    which returns a value of type `double`, using a `return` statement:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将回顾之前关于方法`calcAverage`的例子，该方法使用`return`语句返回`double`类型的数据：
- en: '![](173fig01.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](173fig01.jpg)'
- en: 'The methods that don’t return a value (the return type is `void`) aren’t required
    to define a `return` statement:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回值的方法（返回类型为`void`）不需要定义`return`语句：
- en: '![](173fig02_alt.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](173fig02_alt.jpg)'
- en: 'But you can use the `return` statement in a method even if it doesn’t return
    a value. Usually this statement is used to define an early exit from a method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 即使方法不返回值，你仍然可以在方法中使用`return`语句。通常这个语句用于定义方法的早期退出：
- en: '![](173fig03_alt.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](173fig03_alt.jpg)'
- en: 'Also, the `return` statement must be the last statement to *execute* in a method,
    if present. The `return` statement transfers control out of the method, which
    means that there’s no point in defining any code after it. The compiler will fail
    to compile such code:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果存在，`return`语句必须是方法中最后执行的最后一条语句。`return`语句将控制权从方法中移出，这意味着在它之后定义任何代码都没有意义。编译器将无法编译此类代码：
- en: '![](173fig04_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](173fig04_alt.jpg)'
- en: 'Note that there’s a difference in the `return` statement being the last statement
    in a method and being the last statement to execute in a method. The `return`
    statement need not be the *last statement* in a method, but it must be the *last
    statement to execute* in a method:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，方法中的`return`语句作为最后一条语句和方法中最后执行的最后一条语句之间存在差异。`return`语句不必是方法中的最后一条语句，但它必须是方法中最后执行的最后一条语句：
- en: '[PRE4]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the `return` statement isn’t the last statement in
    this method. But it’s the last statement to execute for method parameter values
    of less than zero.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`return`语句不是这个方法中的最后一条语句。但它对于小于零的方法参数值是最后执行的最后一条语句。
- en: Rules to remember when defining a return statement
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义返回语句时要记住的规则
- en: 'Here are some items to note when defining a `return` statement:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`return`语句时需要注意以下事项：
- en: For a method that returns a value, the `return` statement must be followed immediately
    by a value.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于返回值的方法，`return`语句必须立即跟随着一个值。
- en: For a method that doesn’t return a value (return type is `void`), the `return`
    statement must *not* be followed by a return value.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不返回值的方法（返回类型为`void`），`return`语句后面不得跟有返回值。
- en: If the compiler determines that a `return` statement isn’t the last statement
    to *execute* in a method, the method will fail to compile.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器确定`return`语句不是方法中最后一个执行的语句，则方法将无法编译。
- en: Do you think we’ve covered all the rules for defining a method? Not yet! Do
    you think you can define multiple methods in a class with the same name? You can,
    but you need to be aware of some additional rules, which are discussed in the
    next section.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为我们已经涵盖了定义方法的所有规则了吗？还没有！你认为你可以在一个类中定义具有相同名称的多个方法吗？你可以，但你需要注意一些额外的规则，这些规则将在下一节中讨论。
- en: 3.4\. Create an overloaded method
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 创建重载方法
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[6.1](kindle_split_019.html#ch06lev1sec1)] Create methods with arguments and
    return values; including overloaded methods'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.1](kindle_split_019.html#ch06lev1sec1)] 创建具有参数和返回值的方法；包括重载方法'
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '*Overloaded methods* are methods with the same name but different method parameter
    lists. In this section, you’ll learn how to create and use overloaded methods.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*重载方法*是具有相同名称但不同方法参数列表的方法。在本节中，你将学习如何创建和使用重载方法。'
- en: 'Imagine that you’re delivering a lecture and need to instruct the audience
    to take notes using paper, a smartphone, or a laptop—whichever is available to
    them for the day. One way to do this is give the audience a list of instructions
    as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在做讲座，需要指导听众使用纸张、智能手机或笔记本电脑（当天他们可用的任何设备）做笔记。一种方法是为听众提供一个如下指令的列表：
- en: Take notes using paper.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纸张做笔记。
- en: Take notes using a smartphone.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能手机做笔记。
- en: Take notes using a laptop.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用笔记本电脑做笔记。
- en: Another method is to instruct them to “take notes” and then provide them with
    the paper, a smartphone, or a laptop they’re supposed to use. Apart from the simplicity
    of the latter method, it also gives you the flexibility to add other media on
    which to take notes (such as one’s hand, some cloth, or the wall) without needing
    to remember the list of all the instructions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是指导他们“做笔记”，然后提供他们应该使用的纸张、智能手机或笔记本电脑。除了后者方法的简单性之外，它还允许你在不需要记住所有指令列表的情况下，添加其他用于做笔记的媒体（如手、布或墙）。
- en: This second approach, providing one set of instructions (with the same name)
    but a different set of input values can be compared to using overloaded methods
    in Java, as shown in [figure 3.17](#ch03fig17).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第二种方法，提供一组指令（具有相同的名称）但不同的输入值集，可以与Java中的重载方法进行比较，如图3.17所示。
- en: Again, overloaded methods are methods that are defined in the same class with
    the same name, but with different method argument lists. As shown in [figure 3.17](#ch03fig17),
    overloaded methods make it easier to add methods with similar functionality that
    work with different sets of input values.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，重载方法是定义在同一个类中，名称相同但方法参数列表不同的方法。如图3.17所示，重载方法使得添加具有相似功能但与不同输入值集一起工作的方法变得更加容易。
- en: Figure 3.17\. Real-life examples of overloaded methods
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.17\. 重载方法的真实示例
- en: '![](03fig17_alt.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig17_alt.jpg)'
- en: 'Let’s work with an example from the Java API classes that we all use frequently:
    `System.out.println()`. The `println` method accepts multiple types of method
    parameters:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Java API类中的一个常用示例为例：`System.out.println()`。`println`方法接受多种类型的方法参数：
- en: '![](175fig01.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](175fig01.jpg)'
- en: When you use the method `println`, you know that whatever you pass to it as
    a method argument will be printed to the console. Wouldn’t it be crazy to use
    methods like `printlnInt`, `printlnBool`, and `printlnString` for the same functionality?
    I think so, too. But opinions change across different conditions. At times, you
    might use specific methods instead of overloading because it reads well and avoids
    confusion. As you work with more code, you’ll be able to judge these situations
    for yourself.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`println`方法时，你知道你传递给它作为方法参数的任何内容都将打印到控制台。使用像`printlnInt`、`printlnBool`和`printlnString`这样的方法来执行相同的功能不是疯狂的吗？我也这么认为。但观点在不同条件下会改变。有时，你可能会使用特定方法而不是重载，因为这样读起来更清晰，避免了混淆。随着你编写更多代码，你将能够自己判断这些情况。
- en: Rules to remember for defining overloaded methods
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义重载方法时需要记住的规则
- en: 'Here are a few rules for defining overloaded methods:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些定义超载方法的规则：
- en: Overloaded methods must have method parameters different from one another.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超载方法必须具有彼此不同的方法参数。
- en: Overloaded methods may or may not define a different return type.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超载方法可能或可能不定义不同的返回类型。
- en: Overloaded methods may or may not define different access levels.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超载方法可能或可能不定义不同的访问级别。
- en: Overloaded methods can’t be defined by only changing their return type or access
    modifiers or both.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能仅通过更改返回类型或访问修饰符或两者来定义超载方法。
- en: Next, I’ll describe in detail the preceding rules—valid argument list, return
    types, and access level to define overloaded methods.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将详细描述前面的规则——有效参数列表、返回类型和访问级别以定义超载方法。
- en: 3.4.1\. Argument list
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 3.4.1\. 参数列表
- en: 'Overloaded methods accept different lists of arguments. The argument lists
    can differ in terms of any of the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 超载方法接受不同的参数列表。参数列表可以在以下任何方面有所不同：
- en: Change in the number of parameters that are accepted
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的参数数量变化
- en: Change in the types of parameters that are accepted
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的参数类型变化
- en: Change in the positions of the parameters that are accepted (based on parameter
    type, not variable names)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的参数位置变化（基于参数类型，而不是变量名）
- en: 'Following is an example of the overloaded method `calcAverage`, which accepts
    different numbers of method parameters:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是超载方法 `calcAverage` 的一个示例，它接受不同数量的方法参数：
- en: '![](176fig01_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](176fig01_alt.jpg)'
- en: 'The preceding code is an example of the simplest flavor of overloaded methods.
    You can also define overloaded methods in which the difference in the argument
    list is in the types of the parameters that are accepted:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是超载方法最简单形式的示例。你还可以定义参数列表差异在于接受的参数类型的超载方法：
- en: '![](176fig02_alt.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](176fig02_alt.jpg)'
- en: 'But you can’t define overloaded methods by just switching an array parameter
    into a vararg or vice versa (unless the vararg or array item type doesn’t remain
    the same). Behind the scenes, varargs are implemented as arrays. So the following
    overloaded methods won’t compile:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能仅仅通过将数组参数转换为可变参数或反之亦然来定义超载方法（除非可变参数或数组项类型保持不变）。在幕后，可变参数被实现为数组。因此，以下超载方法无法编译：
- en: '![](176fig03_alt.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](176fig03_alt.jpg)'
- en: 'The methods are also correctly overloaded if they change only the positions
    of the parameters that are passed to them:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们仅更改传递给它们的参数的位置，则这些方法也是正确超载的：
- en: '![](176fig04_alt.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![图片](176fig04_alt.jpg)'
- en: Although you might argue that the arguments being accepted are one and the same,
    with only their positions differing, the Java compiler treats them as different
    argument lists. The compiler can understand which method implementation you want
    to call by looking at the *sequence* of arguments you specified in your code.
    Hence, the preceding code is a valid example of overloaded methods.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能认为接受的参数完全相同，只是位置不同，但Java编译器将它们视为不同的参数列表。编译器可以通过查看你在代码中指定的参数的 *序列* 来理解你想要调用哪个方法实现。因此，前面的代码是超载方法的有效示例。
- en: 'But an issue arises when you try to execute this method using values that can
    be passed to both versions of the overloaded methods. In this case, the code will
    fail to compile:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你尝试使用可以传递给超载方法两个版本的值来执行此方法时，会出现问题。在这种情况下，代码将无法编译：
- en: '![](177fig01_alt.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](177fig01_alt.jpg)'
- en: 'In the preceding code, ![](num-1.jpg) defines the method `calcAverage`, which
    accepts two method parameters: a `double` and an `int`. ![](num-2.jpg) defines
    the overloaded method `calcAverage`, which accepts two method parameters: an `int`
    and a `double`. Because an `int` literal value can be passed to a variable of
    type `double`, literal values `2` and `3` can be passed to both of the overloaded
    methods declared at ![](num-1.jpg) and ![](num-2.jpg). Because this method call
    is dubious, ![](num-3.jpg) fails to compile.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![图片](num-1.jpg) 定义了接受两个方法参数的方法 `calcAverage`：一个 `double` 和一个 `int`。![图片](num-2.jpg)
    定义了超载方法 `calcAverage`，它接受两个方法参数：一个 `int` 和一个 `double`。因为整型字面量可以传递给 `double` 类型的变量，所以字面值
    `2` 和 `3` 可以传递给在 ![图片](num-1.jpg) 和 ![图片](num-2.jpg) 声明的超载方法中。因为这个方法调用是可疑的，所以
    ![图片](num-3.jpg) 无法编译。
- en: 3.4.2\. Return type
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 返回类型
- en: 'Methods can’t be defined as overloaded methods if they differ only in their
    return types, because return type is not part of a method signature:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法仅在返回类型上有所不同，则不能将方法定义为超载方法，因为返回类型不是方法签名的一部分：
- en: '![](177fig02_alt.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](177fig02_alt.jpg)'
- en: Methods in the preceding code can’t be termed overloaded methods.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的方法不能被称为重载方法。
- en: 3.4.3\. Access level
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3. 访问级别
- en: 'Methods can’t be defined as overloaded methods if they differ only in their
    access levels:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法仅在访问级别上不同，则不能将它们定义为重载方法：
- en: '![](177fig03_alt.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](177fig03_alt.jpg)'
- en: If you define overloaded `calcAverage` methods as shown in the preceding code,
    the code won’t compile.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了如前所示的重载 `calcAverage` 方法，代码将无法编译。
- en: In the next section, you’ll create special methods called constructors, which
    are used to create objects of a class.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建称为构造函数的特殊方法，用于创建类的对象。
- en: 3.5\. Constructors of a class
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 构造函数
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[6.3](kindle_split_020.html#ch06lev1sec3)] Create and overload constructors;
    including impact on default constructors'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.3](kindle_split_020.html#ch06lev1sec3)] 创建和重载构造函数；包括对默认构造函数的影响'
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you’ll create constructors, learn the differences between default
    and user-defined constructors, and create overloaded constructors.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建构造函数，了解默认构造函数和用户定义构造函数之间的区别，并创建重载的构造函数。
- en: What happens when you open a new bank account? Depending on the services your
    bank provides, you may be assigned a new bank account number, provided with a
    checkbook, and given access to a new online account the bank has created for you.
    These details are created and returned to you as part of setting up your new bank
    account.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开设一个新的银行账户时会发生什么？根据你银行提供的服务，你可能会被分配一个新的银行账户号码，提供支票簿，并允许访问银行为你创建的新在线账户。这些详细信息是在设置你的新银行账户时创建并返回给你的。
- en: Compare these steps with what a constructor does in Java, as illustrated in
    [figure 3.18](#ch03fig18).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些步骤与Java中构造函数的行为进行比较，如图3.18所示。
- en: Figure 3.18\. The series of steps that may be executed when you create a new
    bank account. These steps can be compared with what a constructor does in Java.
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.18. 创建新银行账户时可能执行的一系列步骤。这些步骤可以与Java中构造函数的行为进行比较。
- en: '![](03fig18.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig18.jpg)'
- en: '*Constructors* are special methods that create and return an object of the
    class in which they’re defined. Constructors have the same name as the class in
    which they’re defined, and they don’t specify a return type—not even `void`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数* 是特殊的方法，用于创建并返回它们定义的类中的对象。构造函数与它们定义的类的名称相同，并且它们不指定返回类型——甚至不是 `void`。'
- en: 'A constructor can accomplish the following tasks:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以完成以下任务：
- en: Call the superclass’s constructor; this can be an implicit or explicit call.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用超类的构造函数；这可以是一个隐式或显式调用。
- en: Initialize all the instance variables of a class with their default values.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认值初始化类的所有实例变量。
- en: 'Constructors come in two flavors: user-defined constructors and default constructors,
    which we’ll cover in detail in the next sections.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有两种类型：用户定义的构造函数和默认构造函数，我们将在下一节中详细讨论。
- en: 3.5.1\. User-defined constructors
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 用户定义的构造函数
- en: The author of a class has full control over the definition of the class. An
    author may or may not define a constructor in a class. If the author defines a
    constructor in a class, it’s known as a *user-defined constructor*. Here the word
    *user* doesn’t refer to another person or class that uses this class but instead
    refers to the person who created the class. It’s called “user-defined” because
    it’s not created by the Java compiler.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 类的作者对类的定义有完全的控制权。作者可以在类中定义构造函数，也可以不定义。如果作者在类中定义了构造函数，它被称为 *用户定义的构造函数*。这里的词 *用户*
    并不指另一个使用这个类的人或类，而是指创建这个类的人。它被称为“用户定义的”，因为它不是由Java编译器创建的。
- en: '[Figure 3.19](#ch03fig19) shows a class `Employee` that defines a constructor.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.19](#ch03fig19) 展示了一个名为 `Employee` 的类，它定义了一个构造函数。'
- en: Figure 3.19\. A class, `Employee`, with a constructor defined by the user Paul
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.19. 用户Paul定义的具有构造函数的类 `Employee`
- en: '![](03fig19_alt.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig19_alt.jpg)'
- en: 'Here’s a class, `Office`, that creates an object of class `Employee`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建 `Employee` 类对象的 `Office` 类：
- en: '![](179fig01_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](179fig01_alt.jpg)'
- en: 'In the preceding example, ![](num-1.jpg) creates an object of class `Employee`
    using the keyword `new`, which triggers the execution of the `Employee` class
    constructor. The output of the class `Office` is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，![](num-1.jpg) 使用关键字 `new` 创建了 `Employee` 类的对象，这触发了 `Employee` 类构造函数的执行。`Office`
    类的输出如下：
- en: '[PRE5]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because a constructor is called as soon as an object is created, you can use
    it to assign default values to the instance variable of your class, as follows
    (modified and additional code is highlighted in bold):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构造函数在创建对象时立即被调用，你可以用它来为类的实例变量分配默认值，如下所示（修改和额外的代码用粗体标出）：
- en: '![](179fig02_alt.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](179fig02_alt.jpg)'
- en: 'Let’s create an object of the class `Employee` in the class `Office` and see
    if there’s any difference:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Office`类中创建一个`Employee`类的对象，看看是否有任何区别：
- en: '![](179fig03_alt.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](179fig03_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE6]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because a constructor is a method, you can also pass method parameters to it,
    as follows (changes are highlighted in bold):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构造函数是一个方法，你也可以向它传递方法参数，如下所示（更改的地方用粗体标出）：
- en: '[PRE7]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can use this constructor in the class `Office` by passing to it the required
    method arguments, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递所需的方法参数来在`Office`类中使用这个构造函数，如下所示：
- en: '[PRE8]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Revisit the use and declaration of the previously mentioned constructors. Note
    that a constructor is called when you create an object of a class. A constructor
    does have an implicit return type, which is the class in which it’s defined. It
    creates and returns an object of its class, which is why you can’t define a return
    type for a constructor. Also note that you can define constructors using any of
    the four access levels.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前提到的构造函数的使用和声明。请注意，当你创建一个类的对象时，会调用构造函数。构造函数确实有一个隐式的返回类型，即它所定义的类。它创建并返回其类的对象，这就是为什么你不能为构造函数定义返回类型。此外，请注意，你可以使用四个访问级别中的任何一个来定义构造函数。
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'You can define a constructor using all four access levels: `public`, `protected`,
    default, and `private`.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有四个访问级别来定义构造函数：`public`、`protected`、默认和`private`。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'What happens if you define a return type for a constructor? Java will treat
    it as another method, not a constructor, which also implies that it won’t be called
    implicitly when you create an object of its class:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为构造函数定义一个返回类型会发生什么？Java会将其视为另一个方法，而不是构造函数，这也意味着当你创建其类的对象时，它不会隐式调用：
- en: '![](180fig01_alt.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](180fig01_alt.jpg)'
- en: In the preceding example, ![](num-1.jpg) won’t call the method `Employee` with
    the return type `void` defined in the class `Employee`. Because the method `Employee`
    defines its return type as `void`, it’s no longer treated as a constructor.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，![](num-1.jpg)不会调用在`Employee`类中定义的返回类型为`void`的方法`Employee`。因为方法`Employee`将其返回类型定义为`void`，它不再被视为构造函数。
- en: 'If the class `Employee` defines the return type of the method `Employee` as
    `void`, how can Java use it to create an object? The method (with the return type
    `void`) is treated as any other method in the class `Employee`. This logic applies
    to all the other data types: if you define the return type of a constructor to
    be any data type—such as `char`, `int`, `String`, `long`, `double`, or any other
    class—it’ll no longer be treated as a constructor.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Employee`类将`Employee`方法的返回类型定义为`void`，Java如何使用它来创建对象？具有返回类型`void`的方法在`Employee`类中被视为任何其他方法。这个逻辑适用于所有其他数据类型：如果你将构造函数的返回类型定义为任何数据类型——例如`char`、`int`、`String`、`long`、`double`或任何其他类——它将不再被视为构造函数。
- en: 'How do you execute such a method? By calling it explicitly, as in the following
    code (modified code is in bold):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如何执行这样的方法？通过显式调用它，如下面的代码所示（修改的代码用粗体标出）：
- en: '![](181fig01_alt.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](181fig01_alt.jpg)'
- en: Note that the `Employee` method in the preceding code is called like any other
    method defined in the class `Employee`. It doesn’t get called automatically when
    you create an object of the class `Employee`. As you can see in the preceding
    code, it’s allowed to define a method that’s not a constructor in a class with
    the same name. Interesting.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面代码中的`Employee`方法就像在`Employee`类中定义的任何其他方法一样被调用。当你创建`Employee`类的对象时，它不会自动被调用。正如前面代码所示，在具有相同名称的类中，允许定义不是构造函数的方法。很有趣。
- en: 'But note that the authors of the OCA exam also found this interesting, and
    you’re likely to get a few tricky questions regarding this concept. Don’t worry:
    with the right information under your belt, you’re sure to answer them correctly.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，OCA考试的作者也发现了这一点很有趣，你可能会遇到一些关于这个概念棘手的问题。别担心：有了正确的信息，你肯定能正确回答它们。
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A constructor must not define any return type. Instead, it creates and returns
    an object of the class in which it’s defined. If you define a return type for
    a constructor, it’ll no longer be treated as a constructor. Instead, it’ll be
    treated as a regular method, even though it shares the same name as its class.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数不得定义任何返回类型。相反，它创建并返回其定义的类的对象。如果您为构造函数定义了返回类型，它将不再被视为构造函数。相反，它将被视为一个普通方法，即使它与它的类具有相同的名称。
- en: '|  |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Initializer blocks versus constructors
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化器块与构造函数
- en: An *initializer block* is defined within a class, not as a part of a method.
    It executes for every object that’s created for a class. In the following example,
    the class `Employee` defines an initializer block`:`
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*初始化器块*是在类中定义的，而不是作为方法的一部分。它为每个创建的类的对象执行。在以下示例中，类`Employee`定义了一个初始化器块：'
- en: '![](181fig02_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![181fig02_alt.jpg]'
- en: 'In the following code, the class `TestEmp` creates an object of the class `Employee`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，类`TestEmp`创建了一个`Employee`类的对象：
- en: '![](182fig01_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![182fig01_alt.jpg]'
- en: 'If you define both an initializer and a constructor for a class, both of these
    will execute. The initializer block will execute prior to the constructor:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为类定义了初始化器和构造函数，这两个都会执行。初始化器块将在构造函数之前执行：
- en: '![](182fig02_alt.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![182fig02_alt.jpg]'
- en: 'The output of the class `TestEmp` is as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 类`TestEmp`的输出如下：
- en: '[PRE9]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a class defines multiple initializer blocks, their order of execution depends
    on their placement in a class. But all of them execute before the class’s constructor:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了多个初始化器块，它们的执行顺序取决于它们在类中的位置。但它们都在类的构造函数之前执行：
- en: '![](182fig03_alt.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![182fig03_alt.jpg]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE10]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Does the preceding code example leave you wondering why you need both an initializer
    block and a constructor, if both of these execute upon the creation of an object?
    Initializer blocks are used to initialize the variables of anonymous classes.
    An *anonymous class* is a type of inner class. In the absence of a name, anonymous
    classes can’t define a constructor and rely on an initializer block to initialize
    their variables upon the creation of an object of their class. Because inner classes
    aren’t on this exam, I won’t discuss how to use an initializer block with an anonymous
    inner class.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例让您疑惑为什么需要同时有一个初始化器块和一个构造函数，如果它们都在对象的创建时执行？初始化器块用于初始化匿名类的变量。*匿名类*是一种内部类。在没有名称的情况下，匿名类无法定义构造函数，并依赖于初始化器块在创建其类的对象时初始化其变量。由于内部类不在此考试范围内，我将不讨论如何使用初始化器块与匿名内部类一起使用。
- en: 'A lot of action can happen within an initializer block: It can create local
    variables. It can access and assign values to instance and static variables. It
    can call methods and define loops, conditional statements, and `try`-`catch`-`finally`
    blocks. Unlike constructors, an initializer block can’t accept method parameters.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器块内可以发生很多操作：它可以创建局部变量。它可以访问并分配实例和静态变量的值。它可以调用方法并定义循环、条件语句和`try`-`catch`-`finally`块。与构造函数不同，初始化器块不能接受方法参数。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Loops and conditional statements are covered in [chapter 5](kindle_split_018.html#ch05),
    and `try`-`catch`-`finally` blocks are covered in [chapter 7](kindle_split_021.html#ch07).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和条件语句在[第5章](kindle_split_018.html#ch05)中介绍，而`try`-`catch`-`finally`块在[第7章](kindle_split_021.html#ch07)中介绍。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.5.2\. Default constructor
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 默认构造函数
- en: In the previous section on user-defined constructors, I discussed how a constructor
    is used to create an object. What happens if you don’t define any constructor
    in a class?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面关于用户定义构造函数的章节中，我讨论了构造函数用于创建对象的方式。如果您在类中没有定义任何构造函数会发生什么？
- en: 'The following code is an example of the class `Employee` that doesn’t define
    a constructor:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是未定义构造函数的`Employee`类的示例：
- en: '![](183fig01.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![183fig01.jpg]'
- en: 'You can create objects of this class in another class (`Office`), as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在另一个类（`Office`）中创建此类的对象，如下所示：
- en: '![](183fig02_alt.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![183fig02_alt.jpg]'
- en: In this case, which method creates the object of the class `Employee`? [Figure
    3.20](#ch03fig20) shows what happens when a class (`Employee`) is compiled that
    doesn’t define any constructor. In the absence of a user-defined constructor,
    Java inserts a *default constructor*. This constructor doesn’t accept any method
    arguments. It calls the constructor of the super (parent) class and assigns default
    values to all the instance variables.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，哪个方法创建了`Employee`类的对象？[图3.20](#ch03fig20)显示了当编译一个没有定义任何构造函数的类（`Employee`）时会发生什么。在没有用户定义的构造函数的情况下，Java插入一个*默认构造函数*。这个构造函数不接受任何方法参数。它调用超类（父类）的构造函数并将所有实例变量赋值为默认值。
- en: Figure 3.20\. When the Java compiler compiles a class that doesn’t define a
    constructor, the compiler creates one for it.
  id: totrans-460
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.20。当Java编译器编译一个没有定义构造函数的类时，编译器会为其创建一个。
- en: '![](03fig20_alt.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig20_alt.jpg)'
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The accessibility of a default constructor matches the accessibility of its
    class. Java creates a public default constructor for a public class. It creates
    a default constructor with package access for a class with package-level access.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数的可访问性与其类的可访问性相匹配。Java为公共类创建一个公共默认构造函数。它为具有包级访问权限的类创建一个具有包访问权限的默认构造函数。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What happens if you add another constructor to the class `Employee`, as in the
    following example?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向`Employee`类添加另一个构造函数，如下例所示，会发生什么？
- en: '![](184fig01_alt.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图片](184fig01_alt.jpg)'
- en: In this case, upon recompilation, the Java compiler will notice that you’ve
    defined a constructor in the class `Employee`. It won’t add a default constructor
    to it, as shown in [figure 3.21](#ch03fig21).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在重新编译时，Java编译器会注意到你在`Employee`类中定义了一个构造函数。它不会为其添加默认构造函数，如图3.21所示。
- en: Figure 3.21\. When a class with a constructor is compiled, the Java compiler
    doesn’t add a default constructor to it.
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.21。当一个带有构造函数的类被编译时，Java编译器不会为其添加默认构造函数。
- en: '![](03fig21_alt.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig21_alt.jpg)'
- en: 'In the absence of a no-argument constructor, the following code will fail to
    compile:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有无参构造函数，以下代码将无法编译：
- en: '![](184fig02_alt.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](184fig02_alt.jpg)'
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Java defines a default constructor if and only if you don’t define a constructor.
    If a class doesn’t define a constructor, the compiler will add a default, no-argument
    constructor to the class. But if you modify the class later by adding a constructor
    to it, the Java compiler will remove the default, no-argument constructor that
    it initially added to the class.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: Java只在没有定义构造函数的情况下定义默认构造函数。如果一个类没有定义构造函数，编译器会为该类添加一个默认的无参构造函数。但是，如果你后来通过向类中添加构造函数来修改类，Java编译器将移除它最初添加到类中的默认无参构造函数。
- en: '|  |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.5.3\. Overloaded constructors
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3. 重载构造函数
- en: 'In the same way in which you can overload methods in a class, you can also
    overload the constructors in a class. *Overloaded constructors* follow the same
    rules as discussed in the previous section for overloaded methods. Here’s a quick
    recap:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以在类中重载方法一样，你也可以在类中重载构造函数。*重载构造函数*遵循与上一节中讨论的重载方法相同的规则。以下是一个快速回顾：
- en: Overloaded constructors must be defined using different argument lists.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数必须使用不同的参数列表来定义。
- en: Overloaded constructors can’t be defined by just a change in the access levels.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数不能仅通过改变访问级别来定义。
- en: Because constructors don’t define a return type, there’s no point in defining
    invalid overloaded constructors with different return types.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构造函数没有定义返回类型，所以定义具有不同返回类型的不合法重载构造函数是没有意义的。
- en: 'The following is an example of an `Employee` class that defines four overloaded
    constructors:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个定义了四个重载构造函数的`Employee`类的示例：
- en: '![](185fig01_alt.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图片](185fig01_alt.jpg)'
- en: In the preceding code, ![](num-1.jpg) defines a constructor that doesn’t accept
    any method arguments. ![](num-2.jpg) defines another constructor that accepts
    a single method argument. Note the constructors defined at ![](num-3.jpg) and
    ![](num-4.jpg). Both of these accept two method arguments, `String` and `int`.
    But the placement of these two method arguments is different in ![](num-3.jpg)
    and ![](num-4.jpg), which is acceptable and valid for overloaded constructors
    and methods.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![图片](num-1.jpg)定义了一个不接受任何方法参数的构造函数。![图片](num-2.jpg)定义了另一个接受单个方法参数的构造函数。注意![图片](num-3.jpg)和![图片](num-4.jpg)中定义的构造函数。这两个都接受两个方法参数，`String`和`int`。但是，这两个方法参数在![图片](num-3.jpg)和![图片](num-4.jpg)中的位置不同，这在重载构造函数和方法中是可接受且有效的。
- en: Invoking an overloaded constructor from another constructor
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从另一个构造函数调用重载的构造函数
- en: 'It’s common to define multiple constructors in a class and reuse their functionality
    across constructors. Unlike overloaded methods, which can be invoked using the
    name of a method, overloaded constructors are invoked by using the keyword `this`—an
    implicit reference that’s accessible to all objects that refer to an object itself:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类中定义多个构造函数并跨构造函数重用其功能是很常见的。与可以通过方法名调用的重载方法不同，重载构造函数是通过使用关键字 `this` 调用的——这是一个对所有引用对象本身的隐式引用，对所有对象都是可访问的：
- en: '![](186fig01_alt.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](186fig01_alt.jpg)'
- en: The code at ![](num-1.jpg) creates a no-argument constructor. At ![](num-2.jpg),
    this constructor calls the overloaded constructor by passing to it values `null`
    and `0`. ![](num-3.jpg) defines an overloaded constructor that accepts two method
    arguments.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](num-1.jpg) 的代码创建了一个无参数的构造函数。在 ![](num-2.jpg)，这个构造函数通过传递 `null` 和 `0` 的值来调用重载的构造函数。![](num-3.jpg)
    定义了一个接受两个方法参数的重载构造函数。
- en: 'Because a constructor is defined using the name of its class, it’s a common
    mistake to try to invoke a constructor from another constructor using the class’s
    name:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 因为构造函数是使用其类的名称定义的，所以尝试使用类的名称从另一个构造函数调用构造函数是一个常见的错误：
- en: '![](186fig02_alt.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](186fig02_alt.jpg)'
- en: 'Also, when you invoke an overloaded constructor using the keyword `this`, it
    must be the first statement in your constructor:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你使用关键字 `this` 调用一个重载构造函数时，它必须是你的构造函数中的第一个语句：
- en: '![](186fig03_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](186fig03_alt.jpg)'
- en: 'You can’t call two (or more) constructors within a constructor because the
    call to a constructor must be the first statement in a constructor:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在构造函数内部调用两个（或更多）构造函数，因为构造函数的调用必须是构造函数中的第一个语句：
- en: '![](187fig01_alt.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](187fig01_alt.jpg)'
- en: 'That’s not all: you can’t call a constructor from any other method in your
    class. None of the other methods of the class `Employee` can invoke its constructor.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此：你也不能从你的类中的任何其他方法调用构造函数。类 `Employee` 的其他方法都不能调用其构造函数。
- en: Rules to remember
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 需要记住的规则
- en: 'Here’s a quick list of rules to remember for the exam for defining and using
    overloaded constructors:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速列表，用于记住考试中定义和使用重载构造函数的规则：
- en: Overloaded constructors must be defined using different argument lists.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数必须使用不同的参数列表定义。
- en: Overloaded constructors can’t be defined by just a change in the access levels.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数不能仅通过改变访问级别来定义。
- en: Overloaded constructors may be defined using different access levels.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数可以使用不同的访问级别定义。
- en: A constructor can call another overloaded constructor by using the keyword `this`.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数可以通过使用关键字 `this` 来调用另一个重载的构造函数。
- en: A constructor can’t invoke a constructor by using its class’s name.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不能使用其类的名称来调用构造函数。
- en: If present, the call to another constructor must be the first statement in a
    constructor.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，对另一个构造函数的调用必须是构造函数中的第一个语句。
- en: You can’t call multiple constructors from a constructor.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能从构造函数中调用多个构造函数。
- en: A constructor can’t be invoked from a method (except by instantiating a class
    using the `new` keyword).
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不能从方法中调用（除了使用 `new` 关键字实例化类）。
- en: The next Twist in the Tale exercise hides an important concept within its code,
    which you can get to know only if you execute the modified code (answer in the
    appendix).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中的下一个转折点练习在其代码中隐藏了一个重要的概念，只有当你执行修改后的代码时才能了解（答案见附录）。
- en: Twist in the Tale 3.2
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折点 3.2
- en: 'Let’s modify the definition of the class `Employee` that I used in the section
    on overloaded constructors, as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我在重载构造函数部分使用的类 `Employee` 的定义，如下所示：
- en: '[PRE11]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Question: What is the output of this modified code, and why?'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：这段修改后的代码的输出是什么，为什么？
- en: Now that you’ve seen how to create methods and constructors, and their overloaded
    variants, we’ll turn to how all of these can be used to access and modify object
    fields in the next section.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何创建方法和构造函数，以及它们的重载变体，我们将在下一节中转向如何使用所有这些来访问和修改对象字段。
- en: 3.6\. Accessing object fields
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 访问对象字段
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[2.3](kindle_split_013.html#ch02lev1sec3)] Know how to read or write to object
    fields'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2.3](kindle_split_013.html#ch02lev1sec3)] 了解如何读取或写入对象字段'
- en: '|  |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you’ll learn what object fields are and how to read, initialize,
    and modify them. You’ll also learn the correct notation used to call methods on
    objects. Access modifiers also determine whether you can call a method on an object.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习什么是对象字段以及如何读取、初始化和修改它们。你还将学习用于在对象上调用方法的正确符号。访问修饰符还决定了你是否可以在对象上调用方法。
- en: 3.6.1\. What is an object field?
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 什么是对象字段？
- en: An *object field* is another name for an instance variable defined in a class.
    I’ve often seen certification aspirants who are confused over whether the object
    fields are the same as instance variables of a class.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象字段*是类中定义的实例变量的另一个名称。我经常看到一些认证考生对对象字段是否与类的实例变量相同感到困惑。'
- en: 'Here’s an example of the class `Star`:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`Star`类的示例：
- en: '![](188fig01_alt.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](188fig01_alt.jpg)'
- en: In the preceding example, ![](num-1.jpg) defines an instance variable, `starAge`.
    ![](num-2.jpg) defines a *setter* method, `setAge`. A *setter* (or *mutator*)
    method is used to set the value of a variable. ![](num-3.jpg) defines a *getter*
    (or *accessor*) method, `getAge`. A *getter* method is used to retrieve the value
    of a variable. In this example, the object field is `starAge`, not `age` or `newAge`.
    The name of an object field is not determined by the name of its *getter* or *setter*
    methods.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，![](num-1.jpg)定义了一个实例变量，`starAge`。![](num-2.jpg)定义了一个*setter*方法，`setAge`。*setter*（或*mutator*）方法用于设置变量的值。![](num-3.jpg)定义了一个*getter*（或*accessor*）方法，`getAge`。*getter*方法用于检索变量的值。在这个例子中，对象字段是`starAge`，而不是`age`或`newAge`。对象字段的名字不由其*getter*或*setter*方法的名字决定。
- en: '|  |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**JavaBeans properties and object fields**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaBeans属性和对象字段**'
- en: The reason for the confusion over the name of the object field is that Java
    classes can also be used to define visual or nonvisual components called *JavaBeans*,
    which are used in visual and nonvisual environments like Spring, Hibernate, and
    others. These classes are supposed to define getter and setter methods to retrieve
    and set the properties of the visual components. If a visual JavaBean component
    defines a property such as `age`, then the name of its getter and setter methods
    will be `getAge` and `setAge`. For a JavaBean, you don’t have to worry about the
    name of the variable that’s used to store the value of this property. In a JavaBean,
    an object field `thisIsMyAge-` can be used to store the value of its *property*
    `age`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字段名称的混淆原因在于Java类也可以用来定义称为*JavaBeans*的视觉或非视觉组件，这些组件用于Spring、Hibernate和其他视觉和非视觉环境中。这些类应该定义用于检索和设置视觉组件属性的getter和setter方法。如果一个视觉JavaBean组件定义了一个名为`age`的属性，那么它的getter和setter方法的名字将是`getAge`和`setAge`。对于JavaBean，你不必担心用于存储此属性值的变量的名称。在JavaBean中，一个对象字段`thisIsMyAge-`可以用来存储其*属性*`age`的值。
- en: Note that the JavaBeans I mentioned aren’t Enterprise JavaBeans. Enterprise
    JavaBeans are used in enterprise applications written in Java, which run on servers.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我提到的JavaBeans不是企业JavaBeans。企业JavaBeans用于用Java编写的企业应用程序，这些应用程序在服务器上运行。
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.6.2\. Read and write object fields
  id: totrans-527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2\. 读取和写入对象字段
- en: 'The OCA Java SE 8 Programmer I exam will test you on how to read values from
    and write them to fields of an object, which can be accomplished by any of following:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8程序员I级考试将测试你如何从对象字段中读取值并将它们写入，这可以通过以下任何一种方式完成：
- en: Using methods to read and write object fields
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法来读取和写入对象字段
- en: Using constructors to write values to object fields
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数将值写入对象字段
- en: Directly accessing instance variables to read and write object fields
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接访问实例变量以读取和写入对象字段
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Although object fields can be manipulated by direct access, it isn’t a recommended
    practice. It makes an object vulnerable to invalid data. Such a class isn’t well
    encapsulated.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过直接访问来操作对象字段，但这并不是推荐的做法。这样做会使对象容易受到无效数据的影响。这样的类并没有很好地封装。
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This exam objective (2.3) will also test your understanding of how to assign
    different values to the same object fields for multiple objects. Let’s start with
    an example:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此考试目标（2.3）还将测试你对如何为多个对象分配相同对象字段的不同值的理解。让我们从一个例子开始：
- en: '![](189fig01_alt.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](189fig01_alt.jpg)'
- en: 'In the class `Employee`, ![](num-1.jpg) defines two object fields: `name` and
    `age`. It defines a (no-argument) constructor. And ![](num-2.jpg) assigns a value
    of `22` to its field `age`. This class also defines a method `setName`, where
    ![](num-3.jpg) assigns the value passed to it to the object field `name`. The
    method `printEmp` is used to print the values of object fields `name` and `age`.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在类`Employee`中，![](num-1.jpg) 定义了两个对象字段：`name`和`age`。它定义了一个（无参数）构造函数。![](num-2.jpg)
    将值`22`分配给其字段`age`。此类还定义了一个`setName`方法，其中![](num-3.jpg) 将传递给它的值分配给对象字段`name`。`printEmp`方法用于打印对象字段`name`和`age`的值。
- en: 'The following is the definition of a class, `Office`, which creates two instances,
    `e1` and `e2`, of the class `Employee` and assigns values to its fields. Let’s
    look at the definition of the class `Office`:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类的定义，`Office`，它创建了两个`Employee`类的实例，`e1`和`e2`，并为其字段分配值。让我们看看类`Office`的定义：
- en: '[PRE12]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the output of the preceding code:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码的输出：
- en: '[PRE13]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Figure 3.22](#ch03fig22) defines object diagrams (a diagram with the name
    and type of an object, the name of the object’s fields, and their corresponding
    values), which will help you to better understand the preceding output.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.22](#ch03fig22) 定义了对象图（包含对象的名字和类型、对象字段的名称及其对应值），这将有助于您更好地理解前面的输出。'
- en: Figure 3.22\. Two objects of the class `Employee`
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.22\. 类`Employee`的两个对象
- en: '![](03fig22.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig22.jpg)'
- en: 'You can access the object field name of the object of the class `Employee`
    either by using its variable `name` or by using the method `setName`. The following
    line of code assigns a value `Selvan` to the field `name` of object `e1`:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用其变量`name`或使用`setName`方法来访问类`Employee`的对象字段名称。以下行代码将值`Selvan`分配给对象`e1`的字段`name`：
- en: '[PRE14]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following line of code uses the method `setName` to assign a value of `Harry`
    to the field `name` of object `e2`:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码使用`setName`方法将值`Harry`分配给对象`e2`的字段`name`：
- en: '[PRE15]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because the constructor of the class `Employee` assigns a value of `22` to the
    variable `age`, objects `e1` and `e2` both contain the same value, `22`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类`Employee`的构造函数将值`22`分配给变量`age`，所以对象`e1`和`e2`都包含相同的值，`22`。
- en: 'What happens if you don’t assign any value to an object field and try to print
    out its value? All the instance variables (object fields) are assigned their default
    values if you try to access or read their values before writing any values to
    them:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为对象字段分配任何值并尝试打印其值会发生什么？如果在写入任何值之前尝试访问或读取它们的值，所有实例变量（对象字段）都将分配它们的默认值：
- en: '![](191fig01_alt.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](191fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows (the default value of an object
    is `null` and `int` is `0`):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下（对象的默认值为`null`，`int`的默认值为`0`）：
- en: '[PRE16]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What happens if you change the access modifier of the variable `name` to `private`,
    as shown here (modified code in bold)?
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将变量`name`的访问修饰符更改为`private`，如下所示（加粗的修改后的代码），会发生什么？
- en: '![](191fig02_alt.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](191fig02_alt.jpg)'
- en: 'You won’t be able to set the value of the object field name as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法将对象字段名称的值设置为以下形式：
- en: '[PRE17]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This line of code won’t compile. Instead, it complains that the variable `name`
    has private access in the class `Employee` and can’t be accessed from any other
    class:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码无法编译。相反，它抱怨变量`name`在类`Employee`中具有私有访问权限，并且不能从任何其他类中访问：
- en: '[PRE18]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you answer questions on reading values from and writing them to an object
    field, watch out for the following points in the exam:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在考试中回答从对象字段读取值和写入值的问题时，请注意以下要点：
- en: Access modifier of the object field
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字段的访问修饰符
- en: Access modifiers of methods used to read and write the value of the object field
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读取和写入对象字段值的方法的访问修饰符
- en: Constructors that assign values to object fields
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值分配给对象字段的构造函数
- en: 3.6.3\. Calling methods on objects
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.3\. 在对象上调用方法
- en: 'You can call methods defined in a class using an object reference variable.
    In this exam objective, this exam will specifically test you on the following:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用对象引用变量调用类中定义的方法。在本考试目标中，此考试将特别测试以下内容：
- en: The correct notation used to call a method on an object reference variable
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个对象引用变量上的方法的正确表示法
- en: The right number of method parameters that must be passed to a method
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须传递给方法的方法参数的正确数量
- en: The return value of a method that’s assigned to a variable
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被分配给变量的方法的返回值
- en: 'Java uses the dot notation (`.`) to execute a method on a reference variable.
    Suppose the class `Employee` is defined as follows:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用点符号（`.`）在引用变量上执行方法。假设`Employee`类定义如下：
- en: '![](192fig01_alt.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](192fig01_alt.jpg)'
- en: 'You can create an object of class `Employee` and call the method `setName`
    on it like this:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个`Employee`类的对象，并像这样调用其上的`setName`方法：
- en: '[PRE19]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following method invocations aren’t valid in Java:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法调用在Java中是无效的：
- en: '![](192fig02.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![](192fig02.jpg)'
- en: 'When you call a method, you must pass to it the exact number of method parameters
    that are defined by it. In the previous definition of the `Employee` class, the
    method `setName` defines a method parameter of type `String`. You can pass a literal
    value or a variable to a method, as a method parameter. The following code invocations
    are correct:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个方法时，你必须传递给它由它定义的确切数量的方法参数。在`Employee`类的先前定义中，`setName`方法定义了一个类型为`String`的方法参数。你可以将字面值或变量传递给方法，作为方法参数。以下代码调用是正确的：
- en: '![](192fig03_alt.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](192fig03_alt.jpg)'
- en: '|  |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: A call to a method must be followed by passing values to all its method parameters.
    For a method that defines one or more method parameters, you can’t call the method
    followed by `()` to indicate it doesn’t need to be passed values.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个方法后必须传递值给所有它的方法参数。对于一个定义了一个或多个方法参数的方法，你不能在调用方法后跟`()`来表示它不需要传递值。
- en: '|  |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If the parameter list of the called method defines a variable argument at the
    rightmost position, you can call the method with a variable number of arguments.
    Let’s add a method `daysOffWork` in the class `Employee` that accepts a variable
    list of arguments (modifications in bold):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被调用方法的参数列表在最右侧定义了一个可变参数，你可以使用可变数量的参数来调用该方法。让我们在`Employee`类中添加一个名为`daysOffWork`的方法，它接受一个可变数量的参数（以下为粗体修改）：
- en: '[PRE20]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can call this method using a variable list of arguments:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个可变数量的参数来调用此方法：
- en: '![](193fig01_alt.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![](193fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE21]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Methods that accept varargs parameters can be called with a different count
    of actual arguments. Also, a method that accepts a vararg can be invoked with
    an array in place of the vararg.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 接受可变参数的方法可以用不同数量的实际参数来调用。此外，接受可变参数的方法可以用数组代替可变参数来调用。
- en: '|  |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s add the method `getName` to the class `Employee` that returns a `String`
    value (changes in bold):'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Employee`类中添加一个名为`getName`的方法，它返回一个`String`值（以下为粗体修改）：
- en: '[PRE22]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can assign the `String` value returned from the method `getName` to a `String`
    variable or pass it on to another method, as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`getName`方法返回的`String`值赋给一个`String`变量或传递给另一个方法，如下所示：
- en: '![](194fig01_alt.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](194fig01_alt.jpg)'
- en: 'In the preceding code, the return type of the method `setName` is `void`; therefore,
    you can’t use it to assign a value to a variable:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`setName`方法的返回类型是`void`；因此，你不能用它来给变量赋值：
- en: '![](194fig02_alt.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](194fig02_alt.jpg)'
- en: 'Also, you can’t assign a return value of a method to an incompatible variable,
    as follows:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不能将一个方法返回的不兼容值赋给一个变量，如下所示：
- en: '![](194fig03_alt.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![](194fig03_alt.jpg)'
- en: You can read and write object fields either by using methods or by directly
    accessing the instance variables of a class. But it’s not a good idea to enable
    access to the instance variables outside a class.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方法或直接访问类的实例变量来读取和写入对象字段。但是，允许类外部访问实例变量不是一个好主意。
- en: In the next section, you’ll see the risks of exposing instance variables outside
    a class and the benefits of a well-encapsulated class.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到将实例变量暴露在类外部的风险以及一个封装良好的类的益处。
- en: 3.7\. Apply encapsulation principles to a class
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. 将封装原则应用于一个类
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[6.5](kindle_split_020.html#ch06lev1sec5)] Apply encapsulation principles
    to a class'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.5](kindle_split_020.html#ch06lev1sec5)] 将封装原则应用于一个类'
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As the heading of this section suggests, we’ll apply the encapsulation principle
    to a class. A well-encapsulated object doesn’t expose its internal parts to the
    outside world. It defines a set of methods that enables the users of the class
    to interact with it.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节标题所示，我们将把封装原则应用于一个类。一个封装良好的对象不会将其内部部分暴露给外部世界。它定义了一组方法，使用户能够与之交互。
- en: As an example from the real world, you can compare a bank to a well-encapsulated
    class. A bank doesn’t expose its internal parts—for example, its vaults and bank
    accounts—to the outside world, just as a well-encapsulated class in Java shouldn’t
    expose the variables that it uses to store the state of an object outside that
    object. The way a bank defines a set of procedures (such as key access to vaults
    and verification before money withdrawals) to protect its internal parts is much
    like the way a well-encapsulated class defines methods to access its variables.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 作为现实世界的一个例子，你可以将一家银行比作一个封装良好的类。银行不会将其内部部分——例如，其保险库和银行账户——暴露给外界，就像Java中封装良好的类不应该将其用于存储对象状态的变量暴露给该对象之外。银行定义一系列程序（如对保险库的密钥访问和提款前的验证）来保护其内部部分的方式，与封装良好的类定义方法来访问其变量的方式非常相似。
- en: 3.7.1\. Need for encapsulation
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1\. 封装的需求
- en: 'The private members of a class—its variables and methods—are used to hide information
    about a class. Why would you need to hide class information? Compare a class with
    yourself. Do you want everyone else to know about all of your weaknesses? Do you
    want everyone else to be able to control your mind? The same applies to a class
    that you define in Java. A class may need a number of variables and methods to
    store an object’s state and define its behavior. But it wouldn’t like all the
    other classes to know about it. Here’s a quick list of reasons to encapsulate
    the state of a Java object:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 类的私有成员——其变量和方法——用于隐藏有关类的信息。你为什么需要隐藏类信息呢？将一个类与你自己比较。你希望其他人知道你所有的弱点吗？你希望其他人能够控制你的思想吗？这同样适用于你用Java定义的类。一个类可能需要一些变量和方法来存储对象的状态并定义其行为。但它不希望其他所有类都知道这一点。以下是一个快速列表，说明了为什么要封装Java对象的状态：
- en: To prevent an external object from performing dangerous operations
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止外部对象执行危险操作
- en: To hide implementation details, so that the implementation can change a second
    time without impacting other objects
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了隐藏实现细节，以便实现可以在不影响其他对象的情况下进行第二次更改
- en: To minimize the chance of *coupling*
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了最小化耦合的可能性
- en: 'Let’s work with an example. Here’s the definition of the class `Phone`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来工作。以下是`Phone`类的定义：
- en: '![](195fig01_alt.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![图片](195fig01_alt.jpg)'
- en: 'Because the variable `weight` isn’t defined as a `private` member, any other
    class (in the same package) can access it and write any value to it, as follows:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量`weight`没有被定义为`private`成员，任何其他类（在同一包中）都可以访问它并向其写入任何值，如下所示：
- en: '![](195fig02_alt.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![图片](195fig02_alt.jpg)'
- en: 3.7.2\. Apply encapsulation
  id: totrans-617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2\. 应用封装
- en: In the previous section, you might have noticed that the object fields of a
    class that isn’t well encapsulated are exposed outside the class. This approach
    enables the users of the class to assign arbitrary values to the object fields.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你可能已经注意到，封装不良的类的对象字段被暴露在类之外。这种方法使用户能够为对象字段分配任意值。
- en: Should this be allowed? For example, going back to the example of the `Phone`
    class discussed in [section 3.7.1](#ch03lev2sec22), how can the weight of a phone
    be a negative value?
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否应该被允许？例如，回到[3.7.1节](#ch03lev2sec22)中讨论的`Phone`类示例，一部电话的重量如何是负值？
- en: 'Let’s resolve this issue by defining the variable `weight` as a `private` variable
    in the class `Phone`, as follows (irrelevant changes have been omitted):'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Phone`类中将变量`weight`定义为`private`变量来解决这个问题，如下所示（省略了无关更改）：
- en: '[PRE23]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But now this variable won’t be accessible in the class `Home`. Let’s define
    methods using this variable, which can be accessible outside the class `Phone`
    (changes in bold):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在这个变量在`Home`类中将不可访问。让我们定义使用这个变量的方法，这些方法可以在`Phone`类之外访问（加粗处有变化）：
- en: '![](196fig01_alt.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![图片](196fig01_alt.jpg)'
- en: The method `setWeight` doesn’t assign the value passed to it as a method parameter
    to the instance variable `weight` if it’s a negative value or a value greater
    than 1,000\. This behavior is known as *exposing object functionality using public
    methods*.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法`setWeight`传递的参数是一个负值或大于1,000的值，则它不会将这个值分配给实例变量`weight`。这种行为被称为*使用公共方法公开对象功能*。
- en: 'Let’s see how this method is used to assign a value to the variable `weight`
    in the class `Home`:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法是如何在`Home`类中用于将值分配给变量`weight`的：
- en: '![](196fig02_alt.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![图片](196fig02_alt.jpg)'
- en: Note that when the class `Home` tries to set the value of the variable to `-12.23`
    or `77712.23` (out-of-range values), those values aren’t assigned to the `Phone`’s
    private variable `weight`. It accepts the value `12.23`, which is within the defined
    range.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当类`Home`尝试将变量的值设置为`-12.23`或`77712.23`（超出范围的值）时，这些值不会被分配给`Phone`的私有变量`weight`。它接受`12.23`这个值，它位于定义的范围内。
- en: On the OCA Java SE 8 Programmer I exam, you may also find the term *information
    hiding*. *Encapsulation* is the concept of defining variables and the methods
    together in a class. *Information hiding* originated from the application and
    purpose of the concept of encapsulation. These terms are also used interchangeably.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA Java SE 8程序员I级考试中，你也可能找到术语“信息隐藏”。*封装*是在类中定义变量和方法的概念。*信息隐藏*起源于封装概念的应用和目的。这些术语也可以互换使用。
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The terms *encapsulation* and *information hiding* are used interchangeably.
    By exposing object functionality only through methods, you can prevent your private
    variables from being assigned any values that don’t fit your requirements. One
    of the best ways to create a well-encapsulated class is to define its instance
    variables as private variables and allow access to these variables using public
    methods.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“封装”和“信息隐藏”可以互换使用。通过仅通过方法公开对象功能，您可以防止您的私有变量被分配任何不符合您要求的价值。创建一个良好封装的类的最佳方法之一是将其实例变量定义为私有变量，并允许通过公共方法访问这些变量。
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next Twist in the Tale exercise has a little hidden trick about determining
    a correctly encapsulated class. Let’s see if you can find it (answer in the appendix).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个“故事转折”练习中，有一个关于确定正确封装的类的隐藏技巧。让我们看看你是否能找到它（答案见附录）。
- en: Twist in the Tale 3.3
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折3.3
- en: Let’s modify the definition of the class `Phone` that I previously used to demonstrate
    the encapsulation principle in this section. Given the following definition of
    class `Phone`, which of the options, when replacing the code on lines 1–3, makes
    it a well-encapsulated class?
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我在本节中用来演示封装原则的类`Phone`的定义。给定以下`Phone`类的定义，以下哪个选项，当替换第1-3行的代码时，使其成为一个良好封装的类？
- en: '[PRE24]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Options:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 选项：
- en: '[PRE25]'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: b
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: '[PRE26]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: c
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: '[PRE27]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: d
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: '[PRE28]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: None of the above
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: Well-encapsulated classes don’t expose their instance variables outside their
    class. What happens when the methods of these classes modify the state of the
    method arguments that are passed to them? Is this acceptable behavior? I’ll discuss
    what happens in the next section.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 良好封装的类不会在其类外部公开其实例变量。当这些类的这些方法修改传递给它们的参数的状态时，会发生什么？这是否是可接受的行为？我将在下一节中讨论会发生什么。
- en: 3.8\. Passing objects and primitives to methods
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8\. 将对象和原始数据类型传递给方法
- en: '|  |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[6.6](kindle_split_020.html#ch06lev1sec6)] Determine the effect upon object
    references and primitive values when they are passed into methods that change
    the values.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6.6](kindle_split_020.html#ch06lev1sec6)] 确定当对象引用和原始数据类型被传递到会改变其值的方法时，它们的影响。'
- en: '|  |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you’ll learn the difference between passing object references
    and primitives to a method. You’ll determine the effect on object references and
    primitive values when they’re passed into methods that change the values.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习将对象引用和原始数据类型传递给方法的区别。你将确定当它们被传递到会改变其值的方法中时，对对象引用和原始数据值的影响。
- en: Object references and primitives behave in a different manner when they’re passed
    to a method because of the differences in how these two data types are internally
    stored by Java. Let’s start with passing primitives to methods.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象引用和原始数据类型被传递到方法中时，由于Java内部存储这两种数据类型的方式不同，它们的行为方式也不同。让我们从将原始数据类型传递给方法开始。
- en: 3.8.1\. Passing primitives to methods
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8.1\. 将原始数据类型传递给方法
- en: 'The value of a primitive data type is copied and passed to a method. Hence,
    the variable whose value was copied doesn’t change:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据类型的值被复制并传递给方法。因此，被复制的值的变量不会改变：
- en: '![](198fig01_alt.jpg)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![](198fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE29]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|  |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, method `modifyVal` *seems* to accept and modify the argument
    passed to it. This book includes such code because you might see similar code
    on the exam, which doesn’t follow coding or naming conventions. But please follow
    the coding conventions when you write code on real projects.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，方法 `modifyVal` *看似* 接受并修改了传递给它的参数。本书包含此类代码，因为你在考试中可能会看到类似的代码，这些代码不遵循编码或命名约定。但请在实际项目中编写代码时遵循编码约定。
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The method `modifyVal` ![](num-1.jpg) accepts a method argument `a` of type
    `int`. In this method, the variable `a` is a method parameter and holds a copy
    of the value that’s passed to it. The method increments the value of the method
    parameter `a` and prints its value.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `modifyVal` ![](num-1.jpg) 接受一个类型为 `int` 的方法参数 `a`。在这个方法中，变量 `a` 是方法参数，它持有传递给它的值的副本。方法增加方法参数
    `a` 的值并打印其值。
- en: When the class `Office` calls the method `modifyVal` ![](num-2.jpg), it passes
    a copy of the value of the object field `age` to it. The method `modifyVal` never
    accesses the object field `age`. Hence, after the execution of this method, the
    value of the method field `age` prints as `0` again.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 当类 `Office` 调用方法 `modifyVal` ![](num-2.jpg) 时，它传递了对象字段 `age` 的值的一个副本给它。方法 `modifyVal`
    从不访问对象字段 `age`。因此，在执行此方法之后，方法字段 `age` 的值再次打印为 `0`。
- en: 'What happens if the definition of the class `Employee` is modified as follows
    (modifications in bold):'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将类 `Employee` 的定义修改如下（加粗部分为修改）会发生什么：
- en: '[PRE30]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The class `Office` will still print the same answer because the method `modifyVal`
    defines a method parameter with the name `age` (do you remember the topic on variable
    scopes covered earlier in this chapter?). Note the following important points
    related to passing a method parameter to a method:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Office` 仍然会打印相同的答案，因为方法 `modifyVal` 定义了一个名为 `age` 的方法参数（你还记得本章前面讨论的变量作用域的话题吗？）。请注意以下与将方法参数传递给方法相关的重要点：
- en: It’s OK to define a method parameter with the same name as an instance variable
    (or object field). But this is not a recommended practice.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个与方法参数同名的方法参数（或对象字段）是可以的。但这不是推荐的做法。
- en: Within a method, a method parameter takes precedence over an object field. When
    the method `modifyVal` refers to the variable `age`, it refers to the method parameter
    `age`, not the instance variable `age`. To access the instance variable `age`
    within the method `modifyVal`, the variable name `age` needs to be prefixed with
    the keyword `this` (`this` is a keyword that refers to the object itself).
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个方法中，方法参数优先于对象字段。当方法 `modifyVal` 指向变量 `age` 时，它指的是方法参数 `age`，而不是实例变量 `age`。要在方法
    `modifyVal` 中访问实例变量 `age`，变量名 `age` 需要加上关键字 `this`（`this` 是一个指向对象本身的关键字）。
- en: The keyword `this` is discussed in detail in [chapter 6](kindle_split_019.html#ch06).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `this` 在 [第6章](kindle_split_019.html#ch06) 中有详细讨论。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When you pass a primitive variable to a method, its value remains the same after
    the execution of the method. The value doesn’t change, regardless of whether the
    method reassigns the primitive to another variable or modifies it.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将原始变量传递给一个方法时，该变量在方法执行后其值保持不变。无论方法是否将原始值重新分配给另一个变量或修改它，值都不会改变。
- en: '|  |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 3.8.2\. Passing object references to methods
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8.2\. 将对象引用传递给方法
- en: 'There are two main cases:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要情况：
- en: When a method reassigns the object reference passed to it to another variable
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当方法重新分配传递给它的对象引用到另一个变量时
- en: When a method modifies the state of the object reference passed to it
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当方法修改传递给它的对象引用的状态时
- en: When methods reassign the object references passed to them
  id: totrans-678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 当方法重新分配传递给它们的对象引用时
- en: When you pass an object reference to a method, the method can assign it to another
    variable. In this case, the state of the object, which was passed on to the method,
    remains intact. When a method is passed a reference value, a copy of the reference
    (that is, the memory address) is passed to the invoked method. The callee can
    do whatever it wants with its copy without ever altering the original reference
    held by the caller.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将对象引用传递给一个方法时，该方法可以将其分配给另一个变量。在这种情况下，传递给方法的对象的状态保持不变。当一个方法传递一个引用值时，传递给被调用方法的引用（即内存地址）的一个副本。被调用者可以对其副本做任何操作，而不会改变调用者持有的原始引用。
- en: 'The following code example explains this concept. Suppose you have the following
    definition of the class `Person`:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例解释了这一概念。假设你有以下 `Person` 类的定义：
- en: '[PRE31]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What do you think is the output of the following code?
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为以下代码的输出是什么？
- en: '![](200fig01_alt.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![](200fig01_alt.jpg)'
- en: In the preceding code, ![](num-1.jpg) creates two object references, `person1`
    and `person2`, illustrated in step 1 of [figure 3.23](#ch03fig23). The boxed values
    represent objects of the class `Person`. ![](num-2.jpg) prints `John:Paul`—the
    value of `person1.name` and `person2.name`.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，![](num-1.jpg) 创建了两个对象引用，`person1` 和 `person2`，这在[图3.23](#ch03fig23)的第1步中得到了说明。方框中的值代表
    `Person` 类的对象。![](num-2.jpg) 打印出 `John:Paul`——`person1.name` 和 `person2.name`
    的值。
- en: Figure 3.23\. Objects of class `Person`, referred to by variables `person1`,
    `person2`, `p1`, and `p2`
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.23. `Person` 类的对象，由变量 `person1`、`person2`、`p1` 和 `p2` 引用
- en: '![](03fig23.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig23.jpg)'
- en: The code then calls the method `swap` and passes to it the objects referred
    to by `person1` and `person2`. When these objects are passed as arguments to the
    method `swap`, the method arguments `p1` and `p2` also refer to these objects.
    This behavior is illustrated in step 2 in [figure 3.23](#ch03fig23).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码调用 `swap` 方法，并将 `person1` 和 `person2` 所引用的对象传递给它。当这些对象作为参数传递给 `swap` 方法时，方法参数
    `p1` 和 `p2` 也引用了这些对象。这种行为在[图3.23](#ch03fig23)的第2步中得到了说明。
- en: 'The method `swap` defines three lines of code:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 方法定义了三行代码：'
- en: '`Person temp = p1:` makes `temp` refer to the object referred to by `p1`'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person temp = p1:` 使得 `temp` 指向 `p1` 所引用的对象'
- en: '`p1 = p:` makes `p1` refer to the object referred to by `p2`'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p1 = p:` 使得 `p1` 指向 `p2` 所引用的对象'
- en: '`p2 = temp:` makes `p2` refer to the object referred to by `temp`'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p2 = temp:` 使得 `p2` 指向 `temp` 所引用的对象'
- en: These three steps are represented in [figure 3.24](#ch03fig24).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤在[图3.24](#ch03fig24)中有所展示。
- en: Figure 3.24\. The change in the objects referred to by variables during the
    execution of the method `swap`
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.24. 在 `swap` 方法执行过程中变量所引用的对象的变化
- en: '![](03fig24_alt.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig24_alt.jpg)'
- en: As you can see in [figure 3.24](#ch03fig24), the reference variables `person1`
    and `person2` are still referring to the objects that they passed to the method
    `swap`. Because no change was made to the values of the objects referred to by
    variables `person1` and `person2`, line ![](num-3.jpg) from the previous page
    prints `John:Paul` again.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.24](#ch03fig24)所示，引用变量 `person1` 和 `person2` 仍然引用它们传递给 `swap` 方法的对象。因为
    `person1` 和 `person2` 所引用的对象的值没有发生变化，所以上一页的行号 ![](num-3.jpg) 再次打印出 `John:Paul`。
- en: 'The output of the preceding code is as follows:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码的输出如下：
- en: '[PRE32]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When methods modify the state of the object references passed to them
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 当方法修改传递给它们的对象引用的状态时
- en: 'Let’s see how a method can change the state of an object so that the modified
    state is accessible in the calling method. Assume the same definition of the class
    `Person`, listed again for your convenience:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个方法如何改变对象的内部状态，使得修改后的状态可以在调用方法中访问。假设 `Person` 类的定义与之前相同，这里再次列出以方便您阅读：
- en: '[PRE33]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What’s the output of the following code?
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '![](201fig01_alt.jpg)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
  zh: '![](201fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码的输出如下：
- en: '[PRE34]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The method `resetValueOfMemberVariable` accepts the object referred to by `person1`
    and assigns it to the method parameter `p1`. Now both variables, `person1` and
    `p1`, refer to the same object. `p1.setName("Rodrigue")` modifies the value of
    the object referred to by the variable `p1`. Because the variable `person1` also
    refers to the same object, `person1.getName()` returns the new name, `Rodrigue`,
    in the method `main`. This sequence of actions is represented in [figure 3.25](#ch03fig25).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetValueOfMemberVariable` 方法接受 `person1` 所引用的对象，并将其赋值给方法参数 `p1`。现在这两个变量，`person1`
    和 `p1`，都引用了同一个对象。`p1.setName("Rodrigue")` 修改了 `p1` 所引用的对象的值。因为 `person1` 也引用了同一个对象，所以
    `person1.getName()` 在 `main` 方法中返回新的名字，`Rodrigue`。这一系列操作在[图3.25](#ch03fig25)中得到了展示。'
- en: Figure 3.25\. Modification of the state of an object passed to the method `resetValueOfMember-Variable`
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.25. 将对象状态传递给方法 `resetValueOfMember-Variable` 的修改
- en: '![](03fig25_alt.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig25_alt.jpg)'
- en: 3.9\. Summary
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9. 概述
- en: 'I started this chapter by discussing the scope of these variables: local, method
    parameter, instance, and class. Often these variables’ scopes overlap each other.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头讨论了这些变量的作用域：局部变量、方法参数、实例变量和类变量。通常这些变量的作用域会相互重叠。
- en: 'I also covered the constructors of a class: the user-defined and default constructors.
    Java inserts a default constructor in a class that doesn’t define any constructor.
    You can modify the source code of such a class, add a constructor, and recompile
    the class. Upon recompilation, the Java compiler removes the automatically generated
    constructor.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 我还介绍了类的构造函数：用户定义的构造函数和默认构造函数。Java 在没有定义任何构造函数的类中插入一个默认构造函数。你可以修改此类源代码，添加一个构造函数，并重新编译该类。重新编译后，Java
    编译器会移除自动生成的构造函数。
- en: I then covered the subobjective of reading from and writing to object fields.
    The terms *object fields* and *instance variables* have the same meaning and are
    used interchangeably. You can read from and write to object fields by directly
    accessing them or by using accessor methods. I also showed you how to apply encapsulation
    principles to a class and explained why doing so is useful.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我接着介绍了从对象字段读取和写入的子目标。术语 *对象字段* 和 *实例变量* 意义相同，可以互换使用。你可以通过直接访问或使用访问器方法来读取和写入对象字段。我还展示了如何将封装原则应用于类，并解释了这样做为什么有用。
- en: Finally, I explained the effect on references and primitives when they’re passed
    into methods that change their values. When you pass a primitive value to a method,
    its value never changes for the calling method. When you pass an object reference
    variable to a method, a change in its value may be reflected in the calling method—if
    the called method modifies an object field of the object passed to it. If the
    called method assigns a new object reference to the method argument before modifying
    the value of its fields, these changes aren’t visible in the calling method.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我解释了当它们传递给会改变其值的方法时，引用和原始数据类型的影响。当你将原始值传递给方法时，其值永远不会在调用方法中改变。当你将对象引用变量传递给方法时，其值的变化可能会在调用方法中反映出来——如果被调用方法修改了传递给它的对象字段。如果被调用方法在修改其字段值之前将其方法参数赋值为新的对象引用，则这些更改在调用方法中是不可见的。
- en: 3.10\. Review notes
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.10. 复习笔记
- en: This section lists the main points covered in this chapter.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了本章涵盖的主要要点。
- en: 'Scope of variables:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域：
- en: 'Variables can have multiple scopes: class, instance, local, and method parameters.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量可以有多个作用域：类、实例、局部和方法参数。
- en: Local variables are defined within a method. Loop variables are local to the
    loop within which they’re defined.
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量是在方法内部定义的。循环变量是在定义它们的循环内部局部有效的。
- en: The scope of local variables is less than the scope of a method if they’re declared
    in a sub-block (within braces, `{}`) in a method. This sub-block can be an `if`
    statement, a `switch` construct, a loop, or a `try`-`catch` block (discussed in
    [chapter 7](kindle_split_021.html#ch07)).
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果局部变量在方法中的子块（在大括号 `{}` 内）中声明，则其作用域小于方法的作用域。这个子块可以是 `if` 语句、`switch` 构造、循环或
    `try`-`catch` 块（在第 7 章中讨论）。
- en: Local variables can’t be accessed outside the method in which they’re defined.
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量不能在定义它们的函数外部访问。
- en: In a method, a local variable can’t be accessed before its declaration.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中，局部变量在其声明之前不能被访问。
- en: Instance variables are defined and accessible within an object. They’re accessible
    to all the instance methods of a class.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量是在对象内部定义和可访问的。它们对类的所有实例方法都是可访问的。
- en: Class variables are shared by all the objects of a class—they can be accessed
    even if there are no objects of the class.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量被类中的所有对象共享——即使没有该类的对象，也可以访问它们。
- en: Method parameters are used to accept arguments in a method. Their scope is limited
    to the method where they’re defined.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数用于在方法中接受参数。它们的范围仅限于定义它们的那个方法。
- en: A method parameter and a local variable can’t be defined using the same name.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能使用相同的名称定义方法参数和局部变量。
- en: Class and instance variables can’t be defined using the same name.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和实例变量不能使用相同的名称定义。
- en: Local and instance variables can be defined using the same name. In a method,
    if a local variable exists with the same name as an instance variable, the local
    variable takes precedence.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部和实例变量可以使用相同的名称定义。在方法中，如果存在与实例变量同名的一个局部变量，则局部变量具有优先权。
- en: 'Object’s life cycle:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生命周期：
- en: An object’s life cycle starts when it’s initialized and lasts until it goes
    out of scope or is no longer referenced by a variable.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的生命周期从初始化开始，一直持续到它超出作用域或不再被变量引用为止。
- en: When an object is alive, it can be referenced by a variable, and other classes
    can use it by calling its methods and accessing its variables.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象存活时，它可以被变量引用，其他类可以通过调用其方法和访问其变量来使用它。
- en: Declaring a reference object variable isn’t the same as creating an object.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个引用对象变量并不等同于创建一个对象。
- en: An object is created using the operator `new`. Strings have special shorthand
    built into the compiler. Strings can be created by using double quotes, as in
    `"Hello"`.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象使用`new`运算符创建。字符串在编译器中内置了特殊简写。字符串可以使用双引号创建，如`"Hello"`。
- en: An object is marked as eligible for garbage collection when it can no longer
    be accessed.
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象无法再被访问时，它会被标记为可回收垃圾。
- en: An object can become inaccessible if it can no longer be referenced by any variable,
    which happens when a reference variable is explicitly set to `null` or when it
    goes out of scope.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象无法再被任何变量引用，它就会变得不可访问，这通常发生在引用变量被显式设置为`null`或超出作用域时。
- en: The garbage collector can also reclaim memory from a group of referenced objects.
    This group of variables is referred to as island of isolation.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器也可以从一组引用对象中回收内存。这组变量被称为孤立岛。
- en: You can be sure only about whether objects are marked for garbage collection.
    You can never be sure about whether an object has been garbage collected.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能确定对象是否被标记为垃圾回收。你永远不能确定对象是否已被垃圾回收。
- en: 'Creating methods with arguments and return values:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 创建带有参数和返回值的方法：
- en: The return type of a method states the type of value that a method will return.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的返回类型说明了方法将返回的值的类型。
- en: You can define multiple method parameters for a method.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为方法定义多个方法参数。
- en: The method parameter can be of a primitive type or an object of a class or interface.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数可以是原始类型或类的对象或接口的对象。
- en: The method parameters are separated by commas.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数由逗号分隔。
- en: 'Unlike the declaration of a local variable, or instance and class fields, *each*
    method parameter must be preceded by its type. This isn’t allowed: `void description(String
    name, age) {}`.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与局部变量的声明或实例和类字段不同，*每个*方法参数都必须在其类型之前。不允许这样做：`void description(String name, age)
    {}`。
- en: You can define only one variable argument in a parameter list, and it must be
    the final variable in the parameter list. If these two rules aren’t followed,
    your code won’t compile.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在参数列表中定义一个唯一的可变参数，并且它必须是参数列表中的最后一个变量。如果不遵循这两个规则，你的代码将无法编译。
- en: For a method that returns a value, the `return` statement must be followed immediately
    by a compatible value.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于返回值的方法，`return`语句必须立即跟一个兼容的值。
- en: For a method that doesn’t return a value (return type is `void`), the `return`
    statement must not be followed by a return value.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不返回值的方法（返回类型为`void`），`return`语句后面不能跟返回值。
- en: If there’s code that can be executed only after a `return` statement, the class
    will fail to compile.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有代码只能在`return`语句之后执行，类将无法编译。
- en: A method can optionally accept method arguments.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以可选地接受方法参数。
- en: A method may optionally return a value.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以可选地返回一个值。
- en: A method returns a value by using the keyword `return` followed by the name
    of a variable, whose value is passed back to the calling method.
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法通过使用关键字`return`后跟变量名来返回值，其值被传递回调用方法。
- en: The returned value from a method may or may not be assigned to a variable. If
    the value is assigned to a variable, the variable type should be compatible with
    the type of the return value.
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法返回的值可能或可能不被分配给变量。如果值被分配给变量，变量类型应与返回值的类型兼容。
- en: A `return` statement should be the last statement in a method. Statements placed
    after the `return` statement aren’t accessible and fail to compile.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句应该是方法中的最后一个语句。在`return`语句之后放置的语句是不可访问的，并且无法编译。'
- en: A method can take zero or more parameters but can return only zero or one value.
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法可以接受零个或多个参数，但只能返回零个或一个值。
- en: 'Creating an overloaded method:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个覆载方法：
- en: Overloaded methods accept different lists of arguments. The argument lists can
    differ by
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆载的方法接受不同的参数列表。参数列表可以不同
- en: Changes in the number of parameters that are accepted
  id: totrans-754
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受参数数量的变化
- en: Changes in the types of parameters that are accepted
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受参数类型的变化
- en: Changes in the positions of parameters that are accepted
  id: totrans-756
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受参数位置的变化
- en: Methods can’t be defined as overloaded methods if they differ only in their
    return types or access levels.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法仅在返回类型或访问级别上有所不同，则不能将方法定义为重载方法。
- en: 'Constructors of a class:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 类的构造函数：
- en: Constructors are special methods defined in a class that create and return an
    object of the class in which they’re defined.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数是在类中定义的特殊方法，用于创建并返回它们所定义的类的对象。
- en: Constructors have the same name as the class, and they don’t specify a return
    type—not even `void`.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数与类的名称相同，它们不指定返回类型——甚至不是`void`。
- en: User-defined constructors are defined by the developer.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的构造函数由开发者定义。
- en: If a class defines multiple initializer blocks, their order of execution depends
    on their placement in a class. But all of them execute before a class’s constructor.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类定义了多个初始化块，它们的执行顺序取决于它们在类中的位置。但它们都在类的构造函数之前执行。
- en: Default constructors are defined by Java, but only if the developer doesn’t
    define any constructor in a class.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数由Java定义，但前提是开发者没有在类中定义任何构造函数。
- en: 'You can define a constructor using the four access levels: `public`, `protected`,
    default, and `private`.'
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用四种访问级别定义构造函数：`public`、`protected`、默认和`private`。
- en: Accessibility of a default constructor matches the accessibility of its class.
    Java creates a public default constructor for a public class. It creates a default
    constructor with package access for a class with package-level access.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数的访问性与其类的访问性相匹配。Java为公共类创建一个公共默认构造函数。它为具有包级访问权限的类创建一个具有包访问权限的默认构造函数。
- en: If you define a return type for a constructor, it’ll no longer be treated like
    a constructor. It’ll be treated like a regular method, even though it shares the
    same name as its class.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您为构造函数定义了返回类型，它将不再被视为构造函数。它将被视为普通方法，即使它与它的类具有相同的名称。
- en: An *initializer block* is defined within a class, not as a part of a method.
    It executes for every object that’s created for a class.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化块是在类中定义的，而不是作为方法的一部分。它为类创建的每个对象执行。
- en: If you define both an initializer and a constructor for a class, both of these
    will execute. The initializer block will execute prior to the constructor.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您为类定义了初始化块和构造函数，这两个都将执行。初始化块将在构造函数之前执行。
- en: Unlike constructors, an initializer block can’t accept method parameters.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构造函数不同，初始化块不能接受方法参数。
- en: An initializer block can create local variables. It can access and assign values
    to instance and static variables. It can call methods and define loops, conditional
    statements, and `try`-`catch`-`finally` blocks.
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化块可以创建局部变量。它可以访问和分配实例和静态变量的值。它可以调用方法并定义循环、条件语句和`try`-`catch`-`finally`块。
- en: 'Overloaded constructors:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 重载构造函数：
- en: A class can also define overloaded constructors.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类也可以定义重载构造函数。
- en: Overloaded constructors must be defined using different argument lists.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数必须使用不同的参数列表来定义。
- en: Overloaded constructors can’t be defined by just a change in the access levels.
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数不能仅通过改变访问级别来定义。
- en: Overloaded constructors may be defined using different access levels.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数可以使用不同的访问级别来定义。
- en: A constructor can call another overloaded constructor by using the keyword `this`.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数可以通过使用关键字`this`来调用另一个重载构造函数。
- en: A constructor can’t invoke a constructor by using its class’s name.
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不能通过使用其类名来调用另一个构造函数。
- en: If present, a call to another constructor must be the first statement in a constructor.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在，对另一个构造函数的调用必须是构造函数中的第一条语句。
- en: 'Accessing object fields:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象字段：
- en: An object field is another name for an instance variable defined in a class.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字段是类中定义的实例变量的另一个名称。
- en: An object field can be read either by directly accessing the variable (if its
    access level permits) or by using a method that returns its value.
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字段可以通过直接访问变量（如果其访问级别允许）或通过使用返回其值的方法来读取。
- en: Although object fields can be manipulated by direct access, it isn’t a recommended
    practice. It makes the object vulnerable to invalid data. Such a class isn’t well
    encapsulated.
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可以通过直接访问来操作对象字段，但这并不是推荐的做法。这会使对象容易受到无效数据的影响。这样的类没有很好地封装。
- en: An object field can be written either by directly accessing the variable (if
    its access level permits) or by using constructors and methods that accept a value
    and assign it to the instance variable.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字段可以通过直接访问变量（如果其访问级别允许）或通过使用接受值并将其分配给实例变量的构造函数和方法来写入。
- en: You can call methods defined in a class using an object reference variable.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用对象引用变量调用类中定义的方法。
- en: You can’t call two (or more) constructors within a constructor because the call
    to a constructor must be the first statement in a constructor.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在构造函数内部调用两个（或更多）构造函数，因为构造函数的调用必须是构造函数中的第一条语句。
- en: When calling a method, it must be passed the correct number and type of method
    arguments.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个方法时，必须传递正确数量和类型的方法参数。
- en: A call to a method must be followed by passing values to all its method parameters.
    For a method that defines one or more method parameters, you can’t call the method
    followed by `()` to indicate it doesn’t need to be passed values.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个方法后必须传递所有方法参数的值。对于一个定义了一个或多个方法参数的方法，你不能调用方法后跟 `()` 来表示它不需要传递值。
- en: Methods that accept varargs can be called with different counts of actual arguments.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受可变参数的方法可以用不同数量的实际参数来调用。
- en: 'Applying encapsulation principles to a class:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 将封装原则应用于类：
- en: A well-encapsulated object doesn’t expose the internal parts of an object outside
    it. It defines a set of well-defined interfaces (methods), which enables the users
    of the class to interact with it.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装良好的对象不会将其内部部分暴露在对象外部。它定义了一组定义良好的接口（方法），使用户能够与之交互。
- en: A class that isn’t well encapsulated is at risk of being assigned undesired
    values for its variables by the callers of the class, which can make the state
    of an object unstable.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个没有良好封装的类有风险，其变量可能被类的调用者赋予不希望的价值，这可能导致对象的状态不稳定。
- en: The terms *encapsulation* and *information hiding* are used interchangeably.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语“封装”和“信息隐藏”可以互换使用。
- en: To define a well-encapsulated class, define its instance variables as private
    variables. Allow access or manipulation to these variables using methods.
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义一个封装良好的类，将其实例变量定义为私有变量。允许通过方法访问或操作这些变量。
- en: 'Passing objects and primitives to methods:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象和原始数据类型传递给方法：
- en: Objects and primitives behave in different manners when they’re passed to a
    method, because of differences in the way these two data types are internally
    stored by Java.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象和原始数据类型被传递给方法时，由于这两种数据类型在Java内部存储方式的不同，它们的行为会有所不同。
- en: When you pass a primitive variable to a method, its value remains the same after
    the execution of the method. This doesn’t change, regardless of whether the method
    reassigns the primitive to another variable or modifies it.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将原始变量传递给一个方法时，该变量在方法执行后其值保持不变。这不会改变，无论方法是否将原始值重新分配给另一个变量或修改它。
- en: When you pass an object to a method, the method can modify the object’s state
    by executing its methods. In this case, the modified state of the object is reflected
    in the calling method.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将一个对象传递给一个方法时，方法可以通过执行其方法来修改对象的状态。在这种情况下，对象修改后的状态会在调用方法中反映出来。
- en: 3.11\. Sample exam questions
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.11. 样本考试问题
- en: '**[Q3-1.](#ch03qa2q0a1)**'
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-1.](#ch03qa2q0a1)**'
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which option defines a well-encapsulated class?
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个选项定义了一个封装良好的类？
- en: ''
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-806
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ''
  id: totrans-810
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-811
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-812
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: '**[Q3-2.](#ch03qa2q0a2)**'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-2.](#ch03qa2q0a2)**'
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct option(s):'
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项（s）：
- en: ''
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ''
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `height` of a `Person` can never be set to more than 300.
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Person` 的 `height` 永远不能设置为超过300。'
- en: The preceding code is an example of a well-encapsulated class.
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码是一个封装良好的类的示例。
- en: The class would be better encapsulated if the height validation weren’t set
    to 300.
  id: totrans-821
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果高度验证没有被设置为300，这个类将会有更好的封装性。
- en: '**Even though the class isn’t well encapsulated, it can be inherited by other
    classes.**'
  id: totrans-822
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**即使类没有良好的封装性，它也可以被其他类继承。**'
- en: '**[Q3-3.](#ch03qa2q0a3)**'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-3.](#ch03qa2q0a3)**'
- en: ''
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following methods correctly accepts three integers as method arguments
    and returns their sum as a floating-point number?
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个方法正确地接受三个整数作为方法参数，并以浮点数的形式返回它们的和？
- en: ''
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  id: totrans-828
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**[Q3-4.](#ch03qa2q0a4)**'
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-4.](#ch03qa2q0a4)**'
- en: ''
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the return type of a method is `int`, the method can return a value of type
    `byte`.
  id: totrans-841
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果方法的返回类型是 `int`，则方法可以返回 `byte` 类型的值。
- en: A method may or may not return a value.
  id: totrans-842
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法可能返回也可能不返回值。
- en: 'If the return type of a method is `void`, it can define a `return` statement
    without a value, as follows:'
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果方法的返回类型是 `void`，它可以定义一个不带值的 `return` 语句，如下所示：
- en: ''
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-845
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A method may or may not accept any method arguments.
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法可能接受也可能不接受任何方法参数。
- en: A method must accept at least one method argument or define its return type.
  id: totrans-849
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个方法必须接受至少一个方法参数或定义其返回类型。
- en: A method whose return type is `String` can’t return `null`.
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回类型为`String`的方法不能返回`null`。
- en: '**[Q3-5.](#ch03qa2q0a5)**'
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-5.](#ch03qa2q0a5)**'
- en: ''
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of class `Person`,
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下`Person`类的定义，
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of the following code?
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ''
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ''
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-869
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-870
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q3-6.](#ch03qa2q0a6)**'
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-6.](#ch03qa2q0a6)**'
- en: ''
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ''
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-877
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-882
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-883
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-884
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q3-7.](#ch03qa2q0a7)**'
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-7.](#ch03qa2q0a7)**'
- en: ''
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following signature of method `eJava`, choose the options that correctly
    overload this method:'
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下`eJava`方法的签名，选择正确重载此方法的选项：
- en: ''
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`private String eJava(int val, String firstName, double dur)`'
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`private String eJava(int val, String firstName, double dur)`'
- en: '`public void eJava(int val1, String val2, double val3)`'
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void eJava(int val1, String val2, double val3)`'
- en: '`String eJava(String name, int age, double duration)`'
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String eJava(String name, int age, double duration)`'
- en: '`float eJava(double name, String age, byte duration)`'
  id: totrans-896
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`float eJava(double name, String age, byte duration)`'
- en: '`ArrayList<String> eJava()`'
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList<String> eJava()`'
- en: '`char[] eJava(double numbers)`'
  id: totrans-898
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`char[] eJava(double numbers)`'
- en: '`String eJava()`'
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String eJava()`'
- en: '**[Q3-8.](#ch03qa2q0a8)**'
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-8.](#ch03qa2q0a8)**'
- en: ''
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code,
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，
- en: ''
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of the following code?
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '[PRE56]'
  id: totrans-912
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-914
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-915
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**[Q3-9.](#ch03qa2q0a9)**'
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-9.](#ch03qa2q0a9)**'
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct options:'
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The class `EJava` defines three overloaded constructors.
  id: totrans-922
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EJava`类定义了三个重载的构造函数。'
- en: The class `EJava` defines two overloaded constructors. The private constructor
    isn’t counted as an overloaded constructor.
  id: totrans-923
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EJava`类定义了两个重载的构造函数。私有构造函数不计入重载构造函数。'
- en: Constructors with different access modifiers can’t call each other.
  id: totrans-924
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同访问修饰符的构造函数不能相互调用。
- en: 'The code prints the following:'
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印以下内容：
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-928
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code prints the following:'
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印以下内容：
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**[Q3-10.](#ch03qa2q0a10)**'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-10.](#ch03qa2q0a10)**'
- en: ''
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the incorrect options:'
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择错误的选项：
- en: ''
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a user defines a `private` constructor for a `public` class, Java creates
    a `public` default constructor for the class.
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户为`public`类定义了一个`private`构造函数，Java将为该类创建一个`public`的默认构造函数。
- en: A class that gets a default constructor doesn’t have overloaded constructors.
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取默认构造函数的类没有重载构造函数。
- en: A user can overload the default constructor of a class.
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以重载类的默认构造函数。
- en: 'The following class is eligible for a default constructor:'
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类有资格获得默认构造函数：
- en: ''
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ''
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-944
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following class is also eligible for a default constructor:'
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类也有资格获得默认构造函数：
- en: ''
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 3.12\. Answers to sample exam questions
  id: totrans-948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.12\. 样本考试题目的答案
- en: '**[Q3-1.](#ch03qa1q1)**'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-1.](#ch03qa1q1)**'
- en: ''
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which option defines a well-encapsulated class?
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个选项定义了一个封装良好的类？
- en: ''
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-953
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ''
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-959
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**None of the above**'
  id: totrans-962
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以上皆非**'
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Options (a), (b), and (c) are incorrect because they all define
    a public instance variable. A well-encapsulated class should be like a capsule,
    hiding its instance variables from the outside world. The only way you should
    access and modify instance variables is through the public methods of a class
    to ensure that the outside world can access only the variables the class allows
    it to. By defining methods to assign values to its instance variables, a class
    can control the range of values that can be assigned to them.'
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项(a)、(b)和(c)都是错误的，因为它们都定义了一个公共实例变量。一个封装良好的类应该像一个胶囊，将其实例变量隐藏在外部世界之外。您应该通过类的公共方法访问和修改实例变量，以确保外部世界只能访问类允许它访问的变量。通过定义方法为其实例变量赋值，一个类可以控制可以分配给它们的值的范围。
- en: '**[Q3-2.](#ch03qa1q2)**'
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-2.](#ch03qa1q2)**'
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct option(s):'
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ''
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `height` of a `Person` can never be set to more than 300.
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Person`的`height`永远不会被设置为超过300。'
- en: The preceding code is an example of a well-encapsulated class.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码是一个封装良好的类的示例。
- en: The class would be better encapsulated if the height validation weren’t set
    to 300.
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果高度验证不是设置为300，类将具有更好的封装性。
- en: Even though the class isn’t well encapsulated, it can be inherited by other
    classes.
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使类没有良好的封装性，它也可以被其他类继承。
- en: ''
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: This class isn’t well encapsulated because its instance variable
    `height` is defined as a `public` member. Because the instance variable can be
    directly accessed by other classes, the variable doesn’t always use the method
    `setHeight` to set its `height`. The class `Person` can’t control the values that
    can be assigned to its public variable `height`.'
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：这个类没有很好地封装，因为它的实例变量 `height` 被定义为 `public` 成员。由于实例变量可以直接被其他类访问，变量并不总是使用 `setHeight`
    方法来设置其 `height`。类 `Person` 无法控制可以分配给其公共变量 `height` 的值。
- en: '**[Q3-3.](#ch03qa1q3)**'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-3.](#ch03qa1q3)**'
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following methods correctly accepts three integers as method arguments
    and returns their sum as a floating-point number?
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个方法正确地接受三个整数作为方法参数，并返回它们的和作为浮点数？
- en: ''
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ''
  id: totrans-986
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ''
  id: totrans-989
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-991
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ''
  id: totrans-992
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-994
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ''
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Answer: b, d Explanation: Option (a) is incorrect. The question specifies the
    method should return a decimal number (type `double` or `float`), but this method
    doesn’t return any value. Option (b) is correct. This method accepts three integer
    values that can be automatically converted to an integer: `byte`, `int`, and `int`.
    It computes the sum of these integer values and returns it as a decimal number
    (data type `double`). Note that the name of the method is `subtractNumbers`, which
    doesn’t make it an invalid option. Practically, you wouldn’t name a method `subtractNumbers`
    if it’s adding them. But syntactically and technically, this option meets the
    question’s requirements and is a correct option. Option (c) is incorrect. This
    method doesn’t accept integers as the method arguments. The type of the method
    argument `arg3` is `double`, which isn’t an integer. Option (d) is correct. Even
    though the name of the method seems weird, it accepts the correct argument list
    (all integers) and returns the result in the correct data type (`float`).'
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：b, d 解释：选项 (a) 是错误的。问题指定该方法应返回一个十进制数（类型 `double` 或 `float`），但此方法没有返回任何值。选项
    (b) 是正确的。此方法接受三个整数值，这些值可以自动转换为整数：`byte`、`int` 和 `int`。它计算这些整数值的总和，并将其作为十进制数（数据类型
    `double`）返回。请注意，方法的名称是 `subtractNumbers`，这并不使它成为一个无效选项。实际上，如果你在添加它们，你不会将方法命名为
    `subtractNumbers`。但从语法和技术上讲，此选项符合问题的要求，是一个正确的选项。选项 (c) 是错误的。此方法不接受整数作为方法参数。方法参数
    `arg3` 的类型是 `double`，这不是整数。选项 (d) 是正确的。尽管方法的名称看起来很奇怪，但它接受正确的参数列表（所有整数）并以正确的数据类型（`float`）返回结果。
- en: '**[Q3-4.](#ch03qa1q4)**'
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-4.](#ch03qa1q4)**'
- en: ''
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**If the return type of a method is `int`, the method can return a value of
    type `byte`.**'
  id: totrans-1001
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果方法的返回类型是 `int`，则方法可以返回 `byte` 类型的值。**'
- en: '**A method may or may not return a value.**'
  id: totrans-1002
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**方法可能返回也可能不返回值。**'
- en: '**If the return type of a method is `void`, it can define a `return` statement
    without a value, as follows:**'
  id: totrans-1003
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果方法的返回类型是 `void`，则可以定义一个没有值的 `return` 语句，如下所示：**'
- en: ''
  id: totrans-1004
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1005
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ''
  id: totrans-1006
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A method may or may not accept any method arguments.**'
  id: totrans-1008
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**方法可能接受也可能不接受任何方法参数。**'
- en: A method should accept at least one method argument or define its return type.
  id: totrans-1009
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法应至少接受一个方法参数或定义其返回类型。
- en: A method whose return type is `String` can’t return `null`.
  id: totrans-1010
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回类型为 `String` 的方法不能返回 `null`。
- en: ''
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, b, c, d'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, b, c, d
- en: ''
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (e) is incorrect. There’s no constraint on the number of
    arguments that can be passed to a method, regardless of whether the method returns
    a value.'
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项 (e) 是错误的。无论方法是否返回值，对传递给方法参数的数量没有限制。
- en: ''
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (f) is incorrect. You can’t return the value `null` for methods that
    return primitive data types. You can return `null` for methods that return objects
    (`String` is a class and not a primitive data type).
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (f) 是错误的。对于返回原始数据类型的方法，你不能返回 `null` 值。对于返回对象的方法（`String` 是一个类，而不是原始数据类型），你可以返回
    `null`。
- en: '**[Q3-5.](#ch03qa1q5)**'
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-5.](#ch03qa1q5)**'
- en: ''
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following definition of class `Person`,
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下 `Person` 类的定义，
- en: ''
  id: totrans-1020
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of the following code?
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ''
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1033
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ''
  id: totrans-1034
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: ''
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The class `EJavaGuruPassObject1` defines two methods, `someMethod`
    and `anotherMethod`. The method `someMethod` modifies the value of the object
    parameter passed to it. Hence, the changes are visible within this method and
    in the calling method (method `main`). But the method `anotherMethod` reassigns
    the reference variable passed to it. Changes to any of the values of this object
    are limited to this method. They aren’t reflected in the calling method (the `main`
    method).'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：类 `EJavaGuruPassObject1` 定义了两个方法，`someMethod` 和 `anotherMethod`。方法 `someMethod`
    修改了传递给它的对象参数的值。因此，这些更改在方法内部和调用方法（`main` 方法）中都是可见的。但方法 `anotherMethod` 重新分配了传递给它的引用变量。对此对象任何值的更改仅限于此方法。它们不会反映在调用方法（`main`
    方法）中。
- en: '**[Q3-6.](#ch03qa1q6)**'
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-6.](#ch03qa1q6)**'
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ''
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ''
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ''
  id: totrans-1051
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1052
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ''
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: When primitive data types are passed to a method, the values of
    the variables in the calling method remain the same. This behavior doesn’t depend
    on whether the primitive values are reassigned other values or modified by addition,
    subtraction, or multiplication—or any other operation.'
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：当原始数据类型传递给方法时，调用方法中变量的值保持不变。这种行为不依赖于原始值是否被重新分配其他值或通过加法、减法、乘法或其他操作进行修改。
- en: '**[Q3-7.](#ch03qa1q7)**'
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-7.](#ch03qa1q7)**'
- en: ''
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following signature of method `eJava`, choose the options that correctly
    overload this method:'
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定方法 `eJava` 的以下签名，选择正确重载此方法的选项：
- en: ''
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`private String eJava(int val, String firstName, double dur)`'
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`private String eJava(int val, String firstName, double dur)`'
- en: '`public void eJava(int val1, String val2, double val3)`'
  id: totrans-1068
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public void eJava(int val1, String val2, double val3)`'
- en: '**`String eJava(String name, int age, double duration)`**'
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`String eJava(String name, int age, double duration)`**'
- en: '**`float eJava(double name, String age, byte duration)`**'
  id: totrans-1070
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`float eJava(double name, String age, byte duration)`**'
- en: '**`ArrayList<String> eJava()`**'
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ArrayList<String> eJava()`**'
- en: '**`char[] eJava(double numbers)`**'
  id: totrans-1072
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`char[] eJava(double numbers)`**'
- en: '**`String eJava()`**'
  id: totrans-1073
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`String eJava()`**'
- en: ''
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c, d, e, f, g'
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c, d, e, f, g
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect. Overloaded methods can change the access
    modifiers, but changing the access modifier alone won’t make it an overloaded
    method. This option also changes the names of the method parameters, but that
    doesn’t make any difference to a method signature.'
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 (a) 是错误的。重载方法可以更改访问修饰符，但仅更改访问修饰符本身不会使其成为重载方法。此选项还更改了方法参数的名称，但这不会对方法签名造成任何影响。
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is incorrect. Overloaded methods can change the return type of the
    method, but changing the return type won’t make it an overloaded method.
  id: totrans-1079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是错误的。重载方法可以更改方法的返回类型，但更改返回类型不会使其成为重载方法。
- en: ''
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. Changing the placement of the types of the method parameters
    overloads it.
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是正确的。更改方法参数的类型位置会重载它。
- en: ''
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. Changing the return type of a method and the placement
    of the types of the method parameters overloads it.
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。更改方法的返回类型和更改方法参数的类型位置会重载它。
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is correct. Changing the return type of a method and making a change
    in the parameter list overloads it.
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (e) 是正确的。更改方法的返回类型并在参数列表中进行更改会重载它。
- en: ''
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (f) is correct. Changing the return type of a method and making a change
    in the parameter list overloads it.
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (f) 是正确的。更改方法的返回类型并在参数列表中进行更改会重载它。
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (g) is correct. Changing the parameter list also overloads a method.
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (g) 是正确的。更改参数列表也会重载方法。
- en: '**[Q3-8.](#ch03qa1q8)**'
  id: totrans-1090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-8.](#ch03qa1q8)**'
- en: ''
  id: totrans-1091
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code,
  id: totrans-1092
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，
- en: ''
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: what is the output of the following code?
  id: totrans-1096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1097
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ''
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '[PRE84]'
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ''
  id: totrans-1103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1104
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1105
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: No compilation issues exist with the code. You can overload methods
    by changing the type of the method arguments in the list. Using method arguments
    with data types having a base-derived class relationship (`Object` and `String`
    classes) is acceptable. Using method arguments with data types for which one can
    be automatically converted to the other (`int` and `long`) is also acceptable.'
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：代码中没有编译问题。您可以通过更改方法参数列表中的方法参数类型来重载方法。使用具有基类-派生类关系的数据类型的方法参数（`Object` 和 `String`
    类）是可以接受的。使用可以自动转换为对方的数据类型的方法参数（`int` 和 `long`）也是可以接受的。
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When the code executes `course.enroll(c)`, `char` can be passed to two overloaded
    `enroll` methods that accept `int` and `long`. The `char` gets expanded to its
    nearest type—`int`—so `course.enroll(c)` calls the overloaded method that accepts
    `int`, printing `int`. The code `course.enroll("Object")` is passed a `String`
    value. Although `String` is also an `Object`, this method calls the specific (not
    general) type of the argument passed to it. So `course.enroll("Object")` calls
    the overloaded method that accepts `String`, printing `String`.
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当代码执行 `course.enroll(c)` 时，`char` 可以传递给接受 `int` 和 `long` 参数的两个重载 `enroll` 方法。`char`
    被扩展为其最接近的类型——`int`——因此 `course.enroll(c)` 调用接受 `int` 的重载方法，打印 `int`。代码 `course.enroll("Object")`
    传递了一个 `String` 值。尽管 `String` 也是 `Object`，但此方法调用传递给它的特定（非通用）类型。因此 `course.enroll("Object")`
    调用接受 `String` 的重载方法，打印 `String`。
- en: '**[Q3-9.](#ch03qa1q9)**'
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-9.](#ch03qa1q9)**'
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct options:'
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ''
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The class `EJava` defines three overloaded constructors.**'
  id: totrans-1120
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**类 `EJava` 定义了三个重载构造函数。**'
- en: The class `EJava` defines two overloaded constructors. The private constructor
    isn’t counted as an overloaded constructor.
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `EJava` 定义了两个重载构造函数。私有构造函数不计入重载构造函数。
- en: Constructors with different access modifiers can’t call each other.
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同访问修饰符的构造函数不能相互调用。
- en: '**The code prints the following:**'
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码打印以下内容：**'
- en: ''
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ''
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code prints the following:'
  id: totrans-1128
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印以下内容：
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Answer: a, d Explanation: You can define overloaded constructors with different
    access modifiers in the same way that you define overloaded methods with different
    access modifiers. But a change in only the access modifier can’t be used to define
    overloaded methods or constructors. `private` methods and constructors are also
    counted as overloaded methods. The following line of code calls `EJava`’s constructor,
    which doesn’t accept any method argument:'
  id: totrans-1132
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：a, d 说明：你可以像定义具有不同访问修饰符的重载方法一样定义具有不同访问修饰符的重载构造函数。但仅访问修饰符的变化不能用来定义重载方法或构造函数。`private`
    方法或构造函数也被视为重载方法。以下代码行调用 `EJava` 的构造函数，该构造函数不接受任何方法参数：
- en: ''
  id: totrans-1133
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1134
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ''
  id: totrans-1135
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The no-argument constructor of this class calls the constructor that accepts
    an `int` argument, which in turn calls the constructor with the `String` argument.
    Because the constructor with the `String` constructor doesn’t call any other methods,
    it prints `protected` and returns control to the constructor that accepts an `int`
    argument. This constructor prints `private` and returns control to the constructor
    that doesn’t accept any method argument. This constructor prints `public` and
    returns control to the `main` method.
  id: totrans-1136
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类的无参数构造函数调用接受 `int` 参数的构造函数，后者又调用接受 `String` 参数的构造函数。因为具有 `String` 构造函数的构造函数没有调用任何其他方法，它打印
    `protected` 并将控制权返回给接受 `int` 参数的构造函数。此构造函数打印 `private` 并将控制权返回给不接受任何方法参数的构造函数。此构造函数打印
    `public` 并将控制权返回给 `main` 方法。
- en: '**[Q3-10.](#ch03qa1q10)**'
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q3-10.](#ch03qa1q10)**'
- en: ''
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the incorrect options:'
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择错误的选项：
- en: ''
  id: totrans-1140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**If a user defines a private constructor for a public class, Java creates
    a public default constructor for the class.**'
  id: totrans-1141
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果用户为公共类定义了私有构造函数，Java 会为该类创建一个公共默认构造函数。**'
- en: A class that gets a default constructor doesn’t have overloaded constructors.
  id: totrans-1142
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得默认构造函数的类没有重载构造函数。
- en: '**A user can overload the default constructor of a class.**'
  id: totrans-1143
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户可以重载类的默认构造函数。**'
- en: 'The following class is eligible for default constructor:'
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类符合默认构造函数的条件：
- en: ''
  id: totrans-1145
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ''
  id: totrans-1147
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1148
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following class is also eligible for a default constructor:'
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类也符合默认构造函数的条件：
- en: ''
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ''
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, c'
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, c
- en: ''
  id: totrans-1156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect. If a user defines a constructor for a
    class with any access modifier, it’s no longer an eligible candidate to be provided
    with a default constructor.'
  id: totrans-1157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：选项 (a) 是错误的。如果用户为具有任何访问修饰符的类定义了构造函数，它就不再是有资格获得默认构造函数的候选者。
- en: ''
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is correct. A class gets a default constructor only when it doesn’t
    have any constructor. A default or an automatic constructor can’t exist with other
    constructors.
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是正确的。一个类只有在没有其他构造函数时才会获得默认构造函数。默认或自动构造函数不能与其他构造函数共存。
- en: ''
  id: totrans-1160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is incorrect. A default constructor can’t coexist with other constructors.
    A default constructor is automatically created by the Java compiler if the user
    doesn’t define any constructor in a class. If the user reopens the source code
    file and adds a constructor to the class, upon recompilation no default constructor
    will be created for the class.
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是错误的。默认构造函数不能与其他构造函数共存。如果用户在类中没有定义任何构造函数，Java 编译器会自动创建一个默认构造函数。如果用户重新打开源代码文件并向类中添加一个构造函数，在重新编译后，将不会为该类创建默认构造函数。
- en: ''
  id: totrans-1162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. Because this class doesn’t have a constructor, Java will
    create a default constructor for it.
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。因为这个类没有构造函数，Java 会为它创建一个默认构造函数。
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Option (e) is also correct. This class also doesn’t have a constructor, so
    it’s eligible for the creation of a default constructor. The following isn’t a
    constructor because the return type of a constructor isn’t void:'
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (e) 同样正确。这个类也没有构造函数，因此它有资格创建一个默认构造函数。以下不是构造函数，因为构造函数的返回类型不是 void：
- en: ''
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE92]'
- en: ''
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s a regular and valid method, with the same name as its class.
  id: totrans-1169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它是一个常规且有效的函数，其名称与类名相同。
