- en: Unit 7\. Adding chat functionality
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7单元：添加聊天功能
- en: By this point, the main structure of your application is complete. It’s time
    to think about new features that could improve the overall interaction on your
    application but aren’t necessary for the fundamental functionalities. In earlier
    lessons, I discussed how particularly useful Node.js is for handling streams of
    data. If you want to send a big batch of data across the internet, Node.js makes
    the process simpler by supporting data chunking. Chunks of data are connected
    as they arrive at the server and processed when there’s enough data to do something
    meaningful with them. This approach is useful in various types of data streams,
    and it’s made possible through the event-emitting and event-handling features
    of Node.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应用的主要结构已经完成。现在是时候考虑可以改善应用整体交互的新功能，但这些功能对于基本功能并不是必需的。在之前的课程中，我讨论了Node.js在处理数据流方面的特别有用。如果你想通过互联网发送大量数据，Node.js通过支持数据分块使这个过程变得更简单。数据块在到达服务器时连接起来，并在有足够数据可以进行有意义操作时进行处理。这种方法适用于各种类型的数据流，并且是通过Node.js的事件发射和事件处理功能实现的。
- en: In this unit, you explore how to use Node.js to facilitate a real-time chat
    application through event-driven communication over web sockets. I discuss how
    chat applications can be built with the simplest of HTML tools and how web sockets
    and `socket.io` are more-efficient, sophisticated options than historic client-server
    communication. You apply the chat functionality to your existing application to
    allow existing users to communicate in a group setting. Then you take things a
    step further by creating a data model for your chat messages and loading messages
    from the database when you open the application’s chat page. Last, you implement
    an icon in the navigation bar that acts as an indicator when the chat page is
    active, even when the user is on a different page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本单元中，你将探索如何使用Node.js通过WebSocket的事件驱动通信来促进实时聊天应用。我讨论了如何使用最简单的HTML工具构建聊天应用，以及WebSocket和`socket.io`相比传统的客户端-服务器通信更加高效和复杂。你将把聊天功能应用到现有的应用中，以便现有用户可以在群组环境中进行交流。然后，你将进一步通过创建聊天消息的数据模型，并在打开应用聊天页面时从数据库中加载消息来实现。最后，你将在导航栏中实现一个图标，作为聊天页面活跃时的指示器，即使用户在另一个页面上也是如此。
- en: 'This unit covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本单元涵盖了以下主题：
- en: '[Lesson 30](../Text/kindle_split_048.html#ch30) introduces web sockets and
    shows how the `socket.io` package can help you connect users of your application
    through a real-time chat application. In this lesson, you learn how to create
    a simple chat page on your existing recipe application.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第30课](../Text/kindle_split_048.html#ch30)介绍了WebSocket，并展示了`socket.io`包如何帮助你通过实时聊天应用连接应用的用户。在本课中，你将学习如何在现有的食谱应用上创建一个简单的聊天页面。'
- en: '[Lesson 31](../Text/kindle_split_049.html#ch31) shows you how to take your
    chat application to the next level by saving the messages to your MongoDB database.
    In this lesson, you create a message model and connect the message to the sender.
    This way, you’ll be able to identify which messages belong to the user who’s logged
    in.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第31课](../Text/kindle_split_049.html#ch31)展示了如何通过将消息保存到MongoDB数据库中，将你的聊天应用提升到下一个层次。在本课中，你将创建一个消息模型，并将消息与发送者连接起来。这样，你就能识别出哪些消息属于已登录的用户。'
- en: '[Lesson 32](../Text/kindle_split_050.html#ch32) guides you through the implementation
    of an active chat indicator in the navigation bar. This icon animates as messages
    are shared on the chat page.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第32课](../Text/kindle_split_050.html#ch32)指导你如何在导航栏中实现一个活跃的聊天指示器。当聊天页面上的消息被分享时，这个图标会进行动画。'
- en: In [lesson 33](../Text/kindle_split_051.html#ch33) (the capstone lesson), you
    use the concepts learned in this unit to build a chat feature for the Confetti
    Cuisine application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第33课](../Text/kindle_split_051.html#ch33)（总结课程）中，你将使用在本单元中学到的概念为Confetti Cuisine应用构建聊天功能。
- en: Lesson 30\. Working with Socket.Io
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第30课：使用Socket.Io
- en: Building a web application in Node.js can be exciting. Often, you’ll find that
    the most challenging aspects stem primarily from architecting the application
    from a web-development perspective. It’s easy to forget what Node.js is capable
    of outside the normal request-response cycle. In this lesson, you explore communication
    between the client and server via an open TCP connection. This connection is made
    available by means of the `socket.io` package, which runs on web sockets and long
    polling, using normal HTTP requests held for longer periods on the server before
    responses are returned to facilitate a live-stream of data between client and
    server. You start by learning how to implement `socket.io` with Express.js. Then
    you create a chat box in a new application view. Last, you connect the client-side
    JavaScript and server code through custom events triggered and handled by `socket.io`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中构建一个网络应用可以非常有趣。通常，你会发现最具挑战性的方面主要来自于从网络开发的角度来架构应用。很容易忘记Node.js在正常请求-响应周期之外的能力。在本课中，你将探索客户端和服务器之间通过开放的TCP连接进行通信。这种连接是通过`socket.io`包实现的，该包在Web套接字和长轮询上运行，通过在服务器上保持更长时间的HTTP请求，在返回响应之前，以促进客户端和服务器之间实时数据流的实现。你首先学习如何使用Express.js实现`socket.io`。然后，你在一个新的应用视图中创建一个聊天框。最后，你通过`socket.io`触发和处理的自定义事件，将客户端JavaScript和服务器代码连接起来。
- en: This lesson covers
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Implementing `socket.io` in a Node.js application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js应用中实现`socket.io`
- en: Structuring your `socket.io` listeners within a controller
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器中组织你的`socket.io`监听器
- en: Creating a simple chat feature
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的聊天功能
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You built a perfectly functional application with tons of users flocking to
    sign up. Unfortunately, these users have no way of communicating with one another.
    Given that you’re building an application that’s community-driven, communication
    among members is important. The user data is already in the database. All you
    need to do is associate that data through a tool that supports real-time communication.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建了一个功能齐全的应用程序，众多用户纷纷前来注册。不幸的是，这些用户之间没有沟通的方式。鉴于你正在构建一个社区驱动的应用，成员之间的沟通非常重要。用户数据已经在数据库中。你所需要做的就是通过支持实时通信的工具将数据关联起来。
- en: With a little help from `socket.io`, you’ll soon be able to connect users so
    that they can chat with one another.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`socket.io`的一点点帮助下，你很快就能连接用户，使他们能够互相聊天。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)30.1\. Using socket.io'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)30.1\. 使用socket.io'
- en: You’ve built Node.js web applications that feature client-to-server communication.
    When the client wants to view a web page or post data, your application generates
    an HTTP request to the server. This method of communication over the internet
    has been around for a long time, celebrating its 20th birthday in 2017\. In technology
    years, that’s old. Although developers still heavily rely on the request-response
    cycle, it isn’t the most effective method of communication for every use case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了具有客户端到服务器通信功能的Node.js网络应用。当客户端想要查看网页或提交数据时，你的应用程序会向服务器生成一个HTTP请求。这种在互联网上的通信方式已经存在很长时间了，在2017年庆祝了它的20岁生日。在技术年数中，这已经很老了。尽管开发者仍然严重依赖请求-响应周期，但这并不是每个用例中最有效的通信方法。
- en: What if you want to view the scores of an NBA basketball game in real time,
    for example? You can load the page containing scores and statistics, but you’d
    need to reload the page every time you wanted to see an update in information.
    For a basketball game, these changes can come as rapidly as every second. Repeatedly
    creating `GET` requests to the server is a lot of work to expect from the client.
    *Polling* is used to generate repeated requests from the client to the server
    in anticipation of updated server data. Polling uses the standard techniques you’ve
    used so far to transfer data between the client and server, but it sends requests
    so frequently that it creates an illusion of an open channel of communication
    between both participants ([figure 30.1](#ch30fig01)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想实时查看NBA篮球比赛的得分，会怎样？你可以加载包含得分和统计信息的页面，但每次你想查看信息更新时，都需要重新加载页面。对于篮球比赛，这些变化可能每秒就会发生。反复向服务器创建`GET`请求对客户端来说是一项繁重的工作。"轮询"用于从客户端向服务器生成重复请求，以期待服务器数据的更新。轮询使用你迄今为止使用的标准技术来在客户端和服务器之间传输数据，但它发送请求的频率如此之高，以至于在双方参与者之间产生了一个开放通信通道的错觉（[图30.1](#ch30fig01)）。
- en: Figure 30.1\. Polling between a client and server
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图30.1\. 客户端和服务器之间的轮询
- en: '![](../Images/30fig01_alt.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/30fig01_alt.jpg)'
- en: To further improve on this technique, long polling was developed to reduce the
    number of requests needed to get updated data. *Long polling* behaves similarly
    to polling, in that the client makes repeated requests to the server for updated
    data, but fewer requests are made. Instead of making hundreds of requests when
    only dozens of them receive updated data, long polling allows requests to stay
    open as long as HTTP allows before the requests time out. Within that time—say,
    10 seconds—the server can hold on to the request and either respond with updated
    data when the server receives it or respond with no changes before the request
    times out. This more-efficient approach has allowed web browsers and devices to
    experience a sense of real-time informational exchange over a protocol that hasn’t
    changed much for decades.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高这项技术，开发了长轮询来减少获取更新数据所需的请求数量。*长轮询*的行为与轮询类似，即客户端重复向服务器请求更新数据，但请求数量更少。不是在只有几十个请求接收到了更新数据时才发送数百个请求，长轮询允许请求在HTTP允许的情况下保持打开状态，直到请求超时。在这段时间内——比如说，10秒——服务器可以保持对请求的控制，并在服务器收到更新数据时响应更新数据，或者在请求超时前响应无变化。这种更有效的方法使得网络浏览器和设备能够在几十年来变化不大的协议上体验到实时信息交换的感觉。
- en: Although these two methods are widely used, a recent new addition has allowed
    platforms like Node.js to thrive. *Web sockets* were introduced in 2011 to allow
    an open stream of communication between clients and server, creating a true open
    channel that allows information to flow in either direction as long as the server
    or clients are available. Web sockets use a different internet protocol from HTTP
    but are supported in use with a normal HTTP server. In most cases, a server running
    with web sockets enabled allows its open channels to be reached over the same
    application ports you’d use for a typical request-response exchange ([figure 30.2](#ch30fig02)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两种方法被广泛使用，但最近的一个新加入的方法使得像Node.js这样的平台得以繁荣发展。*WebSocket*于2011年推出，允许客户端和服务器之间建立开放的通信流，创建了一个真正的开放通道，使得信息可以在服务器或客户端可用的情况下双向流动。WebSocket使用与HTTP不同的互联网协议，但可以在普通的HTTP服务器上使用。在大多数情况下，启用WebSocket的服务器允许其开放通道通过与典型请求-响应交换相同的应用程序端口访问（[图30.2](#ch30fig02)）。
- en: Figure 30.2\. Opening a web socket connection between a client and server
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图30.2\. 客户端和服务器之间打开WebSocket连接
- en: '![](../Images/30fig02_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/30fig02_alt.jpg)'
- en: 'Although web sockets are a preferred method for live communication, they’re
    not supported by many older browsers and clients. This relatively new technology
    allows developers to build applications that stream data in real time, and you
    can incorporate it into your existing Node.js application: `socket.io`, a JavaScript
    library that uses web sockets when it can and polling where web sockets are unsupported.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebSocket是实时通信的首选方法，但许多较老的浏览器和客户端不支持它。这项相对较新的技术允许开发者构建能够实时传输数据的应用程序，并且你可以将其集成到现有的Node.js应用程序中：`socket.io`，这是一个当WebSocket可用时使用WebSocket，而在WebSocket不可用时使用轮询的JavaScript库。
- en: '`socket.io` is also a package that can be installed within a Node.js application,
    providing library support for web sockets. It uses the event-driven communication
    in Node.js and web sockets to allow the client and server to send data by triggering
    events. As a client looking for updated basketball-game statistics, for example,
    you might have client-side JavaScript listening for an `updated data` event triggered
    by the server. Then your browser would handle the `updated data` event along with
    any data passed with it to modify the contents of your web page. These events
    can come in a continuous stream or hours apart, if needed. If you wanted to signal
    to the server to send a message to all other listening clients, you could trigger
    an event that the server knows how to handle. Luckily, you have control of both
    the client-side and server-side code, so you can implement the firing and handling
    of any events you want.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.io`也是一个可以在Node.js应用程序中安装的包，为WebSocket提供库支持。它使用Node.js和WebSocket的事件驱动通信，允许客户端和服务器通过触发事件来发送数据。例如，作为一个寻找更新篮球比赛统计数据的客户端，你可能会有客户端JavaScript监听由服务器触发的`updated
    data`事件。然后你的浏览器会处理`updated data`事件以及与之一起传递的任何数据，以修改你网页的内容。这些事件可以连续不断地到来，或者根据需要隔几个小时才来一次。如果你想向服务器发送消息给所有其他监听客户端，你可以触发一个服务器知道如何处理的事件。幸运的是，你可以控制客户端和服务器端的代码，因此你可以实现任何你想要的触发和处理事件。'
- en: To start, install `socket.io` in your recipe application by running `npm i socket.io
    -S` in your project’s terminal window. You’ll use this library in the following
    sections to build a live-chat feature for users to communicate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的项目终端窗口中运行 `npm i socket.io -S` 以在您的食谱应用程序中安装 `socket.io`。在接下来的章节中，您将使用这个库为用户提供实时聊天功能。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.1**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.1**'
- en: '**[Q1:](#ch30qa2q0a1)**'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch30qa2q0a1)**'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How is long polling different from polling?
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 长轮询与轮询有何不同？
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.1 answer**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.1 答案**'
- en: '**[1:](#ch30qa1q1)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch30qa1q1)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Long polling works by sending the server requests that are sustained longer
    than typical requests. Polling depends on many individual `GET` requests. Long
    polling is more efficient because it keeps a single `GET` request alive for a
    longer period, allowing the server to receive updates and respond before the client
    makes another request.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 长轮询通过发送持续时间比典型请求更长的服务器请求来实现。轮询依赖于许多单独的 `GET` 请求。长轮询更高效，因为它保持单个 `GET` 请求活跃更长时间，允许服务器在客户端发出另一个请求之前接收更新并做出响应。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)30.2\. Creating a chat box'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![sectionFig](../Images/sectionFig.png)30.2. 创建聊天框'
- en: To get started with a chat feature, you need to build a basic view with a chat
    box and submit button. As you build the code to allow the client to handle server
    events, this chat box will populate with data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用聊天功能，您需要构建一个包含聊天框和提交按钮的基本视图。当您构建代码以允许客户端处理服务器事件时，此聊天框将填充数据。
- en: Create a new view called chat.ejs in your views folder. Within this view, add
    the code in [listing 30.1](#ch30ex01). In this code, you have a form that takes
    an input and a submit button. Below the form code is the tag created for the chat
    box. With some simple CSS styling, you can add a border and size dimensions to
    the chat box, prompting users to type the form input and submit it to add the
    content to the chat window below.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图文件夹中创建一个名为 chat.ejs 的新视图。在这个视图中，添加 [代码清单 30.1](#ch30ex01) 中的代码。在这个代码中，您有一个接受输入和提交按钮的表单。在表单代码下方是创建的聊天框标签。通过一些简单的
    CSS 样式，您可以添加边框和尺寸到聊天框，提示用户输入表单输入并将其提交以将内容添加到下面的聊天窗口中。
- en: Listing 30.1\. Creating a chat box in chat.ejs
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.1. 在 chat.ejs 中创建聊天框
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Add an HTML form for chat input.**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个用于聊天输入的 HTML 表单。**'
- en: '***2*** **Add a custom input element for chat content.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个用于聊天内容的自定义输入元素。**'
- en: '***3*** **Create a tag for the chat box.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建聊天框的标签。**'
- en: To load this view, add a new route and action. Add `router.get("/chat", homeController
    .chat)` to homeRoutes.js in your routes folder. This new route will be absorbed
    by the index.js route file and used by main.js. Now you need to create the chat
    action in homeController.js, as shown in the next listing. In this action, you
    simply render the chat.ejs view.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载此视图，请向您的路由文件夹中的 homeRoutes.js 添加一个新路由和操作。将 `router.get("/chat", homeController
    .chat)` 添加到您的路由文件夹中的 homeRoutes.js。此新路由将被 index.js 路由文件吸收并由 main.js 使用。现在您需要在
    homeController.js 中创建聊天操作，如下一列表所示。在这个操作中，您只需渲染 chat.ejs 视图。
- en: Listing 30.2\. Adding a chat action in homeController.js
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.2. 在 homeController.js 中添加聊天操作
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **Render a chat view.**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **渲染聊天视图。**'
- en: Relaunch your application, and visit http://localhost:3000/chat to see the chat
    box shown in [figure 30.3](#ch30fig03).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并访问 http://localhost:3000/chat 以查看 [图 30.3](#ch30fig03) 中显示的聊天框。
- en: Figure 30.3\. Displaying chat view
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 30.3. 显示聊天视图
- en: '![](../Images/30fig03_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![30fig03_alt](../Images/30fig03_alt.jpg)'
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Your chat page will not look exactly like [figure 30.3](#ch30fig03) unless you
    add custom styling to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您的聊天页面不会与 [图 30.3](#ch30fig03) 完全相同，除非您为其添加自定义样式。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this chat page set up, you need to remember the tag IDs that you used in
    the HTML. In the next section, you target the `#chat` box with chat messages and
    send new messages found in `#chat-input` to the server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好此聊天页面后，您需要记住在 HTML 中使用的标签 ID。在下一节中，您将针对 `#chat` 框发送聊天消息，并将新消息发送到 `#chat-input`
    中的服务器。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.2**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.2**'
- en: '**[Q1:](#ch30qa4q0a1)**'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch30qa4q0a1)**'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does the HTML element with ID `chat` not have any content?
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么具有 ID `chat` 的 HTML 元素没有任何内容？
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.2 answer**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.2 答案**'
- en: '**[1:](#ch30qa3q1)**'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch30qa3q1)**'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `#chat` element starts empty on each page load. You’ll use client-side Java-Script
    to populate the element with content as it’s received by the server.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在每次页面加载时，`#chat` 元素都是空的。您将使用客户端 JavaScript 来填充元素，以便在从服务器接收内容时显示内容。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)30.3\. Connecting the server and client'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![sectionFig](../Images/sectionFig.png)30.3. 连接服务器和客户端'
- en: Now that you have a chat page, you need the guts to get it working. With `socket.io`
    installed, you need to require it into your project. Because you want your socket
    server to run on your existing Express.js HTTP server, require `socket.io`, and
    pass it to your Express.js server. Add the require line to main.js below the line
    where you tell your app to listen on a specified port, as shown in [listing 30.3](#ch30ex03).
    In this code, you save the running server instance into a constant `server` so
    that you can pass the same Express.js HTTP server to `socket.io`. This process
    allows `socket.io` (which I’ll refer to as `io`) to attach to your application
    server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了聊天页面，你需要勇气让它工作。安装了`socket.io`后，你需要将其引入到你的项目中。因为你希望你的socket服务器运行在现有的Express.js
    HTTP服务器上，所以需要引入`socket.io`，并将其传递给Express.js服务器。将引入行添加到main.js中，在告诉你的应用程序监听指定端口的行下面，如[代码清单30.3](#ch30ex03)所示。在这段代码中，你将正在运行的服务器实例保存到一个常量`server`中，这样你就可以将相同的Express.js
    HTTP服务器传递给`socket.io`。这个过程允许`socket.io`（我将称之为`io`）附加到你的应用程序服务器。
- en: Listing 30.3\. Adding the server `io` object in main.js
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单30.3\. 在main.js中添加服务器`io`对象
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Save the server instance to server.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将服务器实例保存到server。'
- en: '***2*** **Pass the server instance to socket.io.**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 将服务器实例传递给socket.io。'
- en: Now you can start using `io` to build out your socket logic. As with your other
    code, though, compartmentalize this code into its own controller. Create a new
    chatController .js in your controllers folder, and require it below where you
    required `socket.io`. To require the controller, add `require("./controllers/chatController")(io)`
    to main.js. In this line, you’re passing the `io` object to your chat controller
    so that you can manage your socket connections from there. You don’t need to store
    this module in a constant because you won’t be using it further in main.js, so
    you can require it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始使用`io`来构建你的socket逻辑。尽管如此，像你的其他代码一样，将这段代码封装到它自己的控制器中。在你的controllers文件夹中创建一个新的chatController.js，并在引入`socket.io`之后引入它。为了引入控制器，将`require("./controllers/chatController")(io)`添加到main.js中。在这行代码中，你将`io`对象传递给你的聊天控制器，以便你可以从那里管理你的socket连接。你不需要将这个模块存储在常量中，因为你不会在main.js中进一步使用它，所以你可以直接引入。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important that you require chatController.js after defining the `io` object.
    Otherwise, you won’t have `socket.io` configured for use in your controller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`io`对象之后引入chatController.js是很重要的。否则，你将无法在控制器中使用配置好的`socket.io`。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Within chatController.js, add the code in [listing 30.4](#ch30ex04). In this
    code block, you’re exporting all the controller’s contents and taking a single
    parameter: the `io` object from main.js. In this file, you use `io` to listen
    for certain events. To start, `io` listens for the `conne``c``tion` event, indicating
    that a client has connected to the socket channel. In handling this event, you
    can use the specific client socket to listen for when the user disconnects or
    for custom events, such as the `message` event you created. If the server receives
    a `message` event, it uses `io` to send a string of data to all connected clients,
    using its `emit` method.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在chatController.js中，添加[代码清单30.4](#ch30ex04)中的代码。在这段代码块中，你导出控制器的内容并接受一个参数：来自main.js的`io`对象。在这个文件中，你使用`io`来监听某些事件。首先，`io`监听`connection`事件，表示客户端已连接到socket通道。在处理这个事件时，你可以使用特定的客户端socket来监听用户断开连接或自定义事件，例如你创建的`message`事件。如果服务器接收到`message`事件，它将使用`io`的`emit`方法向所有连接的客户端发送数据字符串。
- en: Listing 30.4\. Handling chat socket connections in chatController.js
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单30.4\. 在chatController.js中处理聊天socket连接
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Export the chat controller contents.**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 导出聊天控制器内容。'
- en: '***2*** **Listen for new user connections.**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 监听新用户连接。'
- en: '***3*** **Listen for when the user disconnects.**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 监听用户断开连接时的情况。'
- en: '***4*** **Listen for a custom message event.**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 监听自定义消息事件。'
- en: '***5*** **Broadcast a message to all connected users.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 向所有连接的用户广播消息。'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that you’re using the argument name `client` because this code will run
    with each new client connect. `client` represents the connected entity on the
    other side of the socket with the server. Client listeners run only if an initial
    `io` connection is made.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你使用的是参数名`client`，因为这段代码将在每个新的客户端连接时运行。`client`代表服务器另一侧连接的实体。客户端监听器仅在建立初始`io`连接时运行。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this code in place, you need to set up the client-side code to handle data
    from and send events to the server. To accomplish this task, add some code to
    your recipeApp.js JavaScript code in your public folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码的基础上，你需要设置客户端代码来处理来自服务器的数据并发送事件到服务器。为了完成这个任务，在你的公共文件夹中的recipeApp.js JavaScript代码中添加一些代码。
- en: In this code, initialize `socket.io` on the client side, allowing your server
    to detect that a new user has connected. Then, using jQuery, handle the form submission
    by emitting a `message` event to the server, and prevent the form from submitting
    naturally with `return false`. `socket.emit` takes a string argument as the event
    name and emits the event back to the server. Using `soc``k``et.on`, you listen
    for the `message` from the server, along with a string message. You display that
    message by appending it as a list item in your `#chat` element. On the server,
    you’ve already set up a handler in chatController.js for the `message` event to
    send back the message content `"Hello"` to the client.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，在客户端初始化 `socket.io`，使你的服务器能够检测到新用户的连接。然后，使用 jQuery，通过向服务器发送一个 `message`
    事件来处理表单提交，并使用 `return false` 阻止表单自然提交。`socket.emit` 接收一个字符串参数作为事件名称，并将事件发送回服务器。使用
    `socket.on`，你监听来自服务器的 `message`，以及一个字符串消息。你通过将消息作为列表项添加到你的 `#chat` 元素中来显示该消息。在服务器端，你已经在
    chatController.js 中为 `message` 事件设置了一个处理程序，向客户端发送消息内容 `"Hello"`。
- en: Listing 30.5\. Adding client-side JavaScript for `socket.io` in recipeApp.js
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.5\. 在recipeApp.js中添加 `socket.io` 的客户端 JavaScript 代码
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Initialize socket.io on the client.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在客户端初始化 socket.io。**'
- en: '***2*** **Emit an event when the form is submitted.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **当表单提交时触发事件。**'
- en: '***3*** **Listen for an event, and populate the chat box.**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **监听事件，并填充聊天框。**'
- en: '***4*** **Display messages from the server in the chat box.**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在聊天框中显示来自服务器的消息。**'
- en: The last step is loading the `socket.io` library on the client by adding a script
    tag to the view on which the chat is generated. To simplify this task, add the
    tag to your layout file. In layout.ejs, add `<script src="/socket.io/socket.io.js"></script>`
    below your other script and link tags. This tag tells your Node.js application
    to find the `socket.io` library in your node_modules folder.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在客户端加载 `socket.io` 库，通过在生成聊天的视图中添加一个脚本标签来实现。为了简化这个任务，将标签添加到你的布局文件中。在layout.ejs中，在你的其他脚本和链接标签下方添加
    `<script src="/socket.io/socket.io.js"></script>`。这个标签告诉你的 Node.js 应用程序在 node_modules
    文件夹中查找 `socket.io` 库。
- en: Relaunch your application, visit http://localhost:3000/chat, enter some text
    in the input box, and click Send. You should see `"Hello"` in your chat box ([figure
    30.4](#ch30fig04)). A new line should appear with each new text submission.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的应用程序，访问 http://localhost:3000/chat，在输入框中输入一些文本，然后点击发送。你应该在你的聊天框中看到 `"Hello"`（[图30.4](#ch30fig04)）。每次新的文本提交都会出现一个新的行。
- en: Figure 30.4\. Displaying text in the chat box
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图30.4\. 在聊天框中显示文本
- en: '![](../Images/30fig04_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/30fig04_alt.jpg)'
- en: In [lesson 31](../Text/kindle_split_049.html#ch31), you improve this chat to
    allow the application to save these messages to your database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第31课](../Text/kindle_split_049.html#ch31) 中，你改进了这个聊天应用，使其能够将消息保存到你的数据库中。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.3**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.3**'
- en: '**[Q1:](#ch30qa6q0a1)**'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch30qa6q0a1)**'
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does `io.emit` do?
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`io.emit` 是做什么的？'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.3 answer**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.3 答案**'
- en: '**[1:](#ch30qa5q1)**'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch30qa5q1)**'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `io` object controls much of the communication between the server and the
    client. `emit` allows `io` to send some specific data by triggering an event and
    notifying all connected client sockets.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`io` 对象控制着服务器和客户端之间的大部分通信。`emit` 允许 `io` 通过触发事件并通知所有已连接的客户端套接字来发送一些特定的数据。'
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned about `socket.io` and saw how to install it in a
    Node.js application. Then you created your first chat application by using web
    sockets over your Express.js server to facilitate event and data exchange between
    client and server. When this chat feature is installed, users can communicate
    with one another in real time. When a client refreshes the web page, however,
    the chat history is erased. What’s more, you have no indication of which user
    sent which message. In [lesson 31](../Text/kindle_split_049.html#ch31), you create
    a new data model and associate user accounts so that message authors can be identified
    and chats can persist across user sessions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了 `socket.io` 并了解了如何在 Node.js 应用程序中安装它。然后，你通过使用 Express.js 服务器上的 WebSocket
    来创建你的第一个聊天应用程序，从而实现客户端和服务器之间的事件和数据交换。当这个聊天功能安装后，用户可以实时相互沟通。然而，当客户端刷新网页时，聊天历史会被清除。更重要的是，你没有指示哪个用户发送了哪条消息。在[第31课](../Text/kindle_split_049.html#ch31)中，你创建了一个新的数据模型，并将用户账户关联起来，以便可以识别消息作者，并使聊天可以在用户会话之间持续。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: With a chat feature implemented, try sending more meaningful data between the
    client and server. The message content allows all clients to see the same messages
    at the same time, but maybe you want to see more than the message itself. Try
    sending the date stamp showing when the message was sent to the server. Then,
    with client-side Java-Script, collect that date stamp and display it next to the
    message in the chat box.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了聊天功能后，尝试在客户端和服务器之间发送更有意义的数据。消息内容允许所有客户端同时看到相同的消息，但也许你想要看到比消息本身更多的信息。尝试发送显示消息发送到服务器的日期戳。然后，使用客户端
    JavaScript 收集那个日期戳，并在聊天框中显示在消息旁边。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 31\. Saving Chat Messages
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第31课\. 保存聊天消息
- en: Your chat feature is coming together, and you can take it in many directions
    to improve it. Though the chat feature allows for real-time communication, when
    you refresh your page, all messages disappear. The next step is persisting these
    messages in your database. In this lesson, you implement a simple model to represent
    each chat message. Then you connect that model to the user model, allowing senders
    to associate with their own messages. Last, you query the database for the most
    recent messages whenever a page is reloaded. When you complete these steps, the
    chat will start to resemble ones that you’ve used on familiar websites and in
    familiar applications.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你的聊天功能正在逐步完善，你可以从多个方向来改进它。尽管聊天功能允许实时通信，但当你刷新页面时，所有消息都会消失。下一步是将这些消息持久化到你的数据库中。在本课中，你实现了一个简单的模型来表示每个聊天消息。然后，你将这个模型连接到用户模型，允许发送者将消息与自己的消息关联起来。最后，每次页面重新加载时，你都会查询数据库以获取最新的消息。当你完成这些步骤后，聊天将开始类似于你在熟悉的网站和应用中使用的聊天。
- en: This lesson covers
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Creating a message model
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建消息模型
- en: Saving messages in a `socket.io` event handler
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `socket.io` 事件处理器中保存消息
- en: Querying messages upon new socket connections
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的 socket 连接上查询消息
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: You have a chat page working, finally allowing users to talk to one another.
    As soon as a user refreshes their page, their chat history is gone. Although this
    feature could be marketed as a security implementation, it’s impractical. You
    want to save the message and do so without interrupting the fast-paced, event-driven
    system on which your chat application functions. In this lesson, you use Mongoose
    and your existing application structure to support saving and loading chat messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有一个可以工作的聊天页面，最终允许用户相互交谈。一旦用户刷新他们的页面，他们的聊天历史就会消失。尽管这个功能可以作为一个安全实现来推广，但它并不实用。你想要保存消息，并且希望在不会打断你的聊天应用程序上运行的快速、事件驱动系统的情况下完成。在本课中，你使用
    Mongoose 和现有的应用程序结构来支持保存和加载聊天消息。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)31.1\. Connecting messages to users'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)31.1\. 将消息连接到用户'
- en: In [lesson 30](../Text/kindle_split_048.html#ch30), you created a chat feature
    for your application, allowing users to trigger a `message` event, prompting the
    server to respond with the same `"Hello"` text-message content. You can improve
    this feature by sending the actual content you type in the chat input box to the
    server. To do so, modify your client-side code so that your event handler on form
    submission looks like [listing 31.1](#ch31ex01).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 30 课](../Text/kindle_split_048.html#ch30) 中，你为你的应用程序创建了一个聊天功能，允许用户触发一个
    `message` 事件，提示服务器以相同的 `"Hello"` 文本消息内容进行响应。你可以通过将实际在聊天输入框中输入的内容发送到服务器来改进这个功能。为此，修改你的客户端代码，使得你的表单提交事件处理器看起来像
    [列表 31.1](#ch31ex01) 中的那样。
- en: This small change allows you to grab the text the user typed right after he
    clicks the submit button. Then you send the text within an object as you emit
    the `message` event to the server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的改动允许你在用户点击提交按钮后立即获取他输入的文本。然后你将文本作为一个对象发送，当向服务器发出 `message` 事件时。
- en: Listing 31.1\. Emitting an event from the client in recipeApp.js
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.1\. 在 recipeApp.js 中从客户端发出事件
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Grab text from the view input field.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从视图输入字段中获取文本。**'
- en: '***2*** **Emit form data to the server.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将表单数据发送到服务器。**'
- en: In response, have the server emit this form data to all listening clients. You
    can do so by modifying the `message` event handler in the chat controller to emit
    the data back to all clients. Change the code around the `io.emit` line in chatController.js
    to the code in [listing 31.2](#ch31ex02). Here, you grab the data from the client
    and emit it back. If you relaunch your application and try to type a new chat
    message, that specific message appears in the chat box. You can also open a second
    browser window to mimic two users, and these two browsers allow for multiple socket
    connections to submit data and display new messages in the other browser’s chat
    box in real time ([figure 31.1](#ch31fig01)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为响应，让服务器向所有监听客户端发出这个表单数据。你可以通过修改聊天控制器的 `message` 事件处理器来向所有客户端发出数据。在 chatController.js
    中的 `io.emit` 行周围更改代码到 [列表 31.2](#ch31ex02) 中的代码。在这里，你从客户端获取数据并将其发送回去。如果你重新启动你的应用程序并尝试输入一个新的聊天消息，该特定消息会出现在聊天框中。你还可以打开第二个浏览器窗口来模拟两个用户，这两个浏览器允许进行多个套接字连接以提交数据，并在另一个浏览器的聊天框中实时显示新消息（[图
    31.1](#ch31fig01)）。
- en: Figure 31.1\. Displaying chats with two sockets
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 31.1\. 使用两个套接字显示聊天
- en: '![](../Images/31fig01_alt.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31fig01_alt.jpg)'
- en: Listing 31.2\. Change emit message to data in chatController.js
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.2\. 在 chatController.js 中将发出消息改为数据
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Collect data as a parameter.**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **收集数据作为参数。**'
- en: '***2*** **Return data in the message event as content.**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将消息事件中的数据作为内容返回。**'
- en: The next thing you want to do is add some information about the user who posted
    the chat message. Currently, you’re sending only the message content to the server,
    but you can send the user’s name and ID as well. Modify your chat form to include
    two pieces of hidden data, as shown in [listing 31.3](#ch31ex03). In this example,
    you check whether a `currentUser` is logged in, using data on the response provided
    by `passport`. If there’s a user, use that user’s `_id` attribute in the form
    as a hidden field. Then this value can be passed to the server when you submit
    your message.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来想要做的是添加一些关于发布聊天消息的用户的信息。目前，你只向服务器发送了消息内容，但你也可以发送用户的姓名和 ID。修改你的聊天表单以包含两个隐藏数据项，如
    [列表 31.3](#ch31ex03) 中所示。在这个例子中，你使用 `passport` 提供的响应中的数据检查是否有 `currentUser` 登录。如果有用户，使用该用户在表单中的
    `_id` 属性作为隐藏字段。然后这个值可以在你提交消息时传递给服务器。
- en: Listing 31.3\. Adding hidden fields in chat form in chat.ejs
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.3\. 在 chat.ejs 中添加聊天表单的隐藏字段
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Check for a logged-in user.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查是否有登录用户。**'
- en: '***2*** **Add a hidden field contain user data.**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加包含用户数据的隐藏字段。**'
- en: Now that you’ve included a user field in your chat form, you’ll display the
    chat box only if a user is signed in. Try loading `/chat` before logging in. Then
    try again after logging in with one of your local user accounts. The second try
    yields the chat-page contents.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在你的聊天表单中包含了用户字段，只有当用户登录时才会显示聊天框。在登录之前尝试加载 `/chat`。然后使用你的本地用户账户之一登录后再次尝试。第二次尝试会显示聊天页面的内容。
- en: Next, modify your custom client-side JavaScript to pull these values when the
    form is submitted. Replace your form-submission event listener with the code in
    the next listing. In this modified code, you grab the user’s ID and pass the value
    to the server, using the same local variable name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改你的自定义客户端 JavaScript 代码，在表单提交时提取这些值。用下一列表中的代码替换你的表单提交事件监听器。在这个修改后的代码中，你获取用户的
    ID 并将值传递给服务器，使用相同的局部变量名。
- en: Listing 31.4\. Pulling hidden field values from chat form in recipeApp.js
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.4\. 在 recipeApp.js 中从聊天表单中提取隐藏字段值
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Pull hidden field data from the form.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从表单中提取隐藏字段数据。**'
- en: '***2*** **Emit an event with message content and user data.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用消息内容和用户数据触发一个事件。**'
- en: Now you can handle this data on the server side by changing your code in the
    `message` event handler in chatController.js to collect all the individual attributes
    passed to the server ([listing 31.5](#ch31ex05)). By saving these values to a
    new object, you can filter out any unwanted values outside what you specify in
    the `messageAttributes` object. Then emit those values containing the message
    contents and user information to the other clients.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过更改 `chatController.js` 中的 `message` 事件处理器的代码来在服务器端处理这些数据，将传递给服务器的所有单个属性收集到一起（[列表
    31.5](#ch31ex05)）。通过将这些值保存到一个新对象中，你可以过滤掉任何你未在 `messageAttributes` 对象中指定的不想要的值。然后向其他客户端发送包含消息内容和用户信息的值。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This code must exist within the `io.on("connection"...` block. You can listen
    for specific events only from client sockets that are connected.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码必须存在于 `io.on("connection"...` 块中。你只能监听已连接的客户端套接字上的特定事件。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 31.5\. Receiving socket data in chatController.js
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.5\. 在 chatController.js 中接收套接字数据
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Collect all incoming data.**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **收集所有传入的数据。**'
- en: '***2*** **Emit the message with user data.**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **带有用户数据的消息触发。**'
- en: Last, you need to arrange this data and display it appropriately in the view.
    Back in recipeApp.js, change the code in `di``s``playMessage` to match the code
    in [listing 31.6](#ch31ex06). This function adds an HTML class attribute to the
    messages associated with the logged-in user. By comparing the ID of the user in
    the form with the ID associated with the chat message, you can filter out the
    logged-in user’s messages.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要安排这些数据并在视图中适当地显示它们。回到 `recipeApp.js`，将 `displayMessage` 中的代码更改为与 [列表 31.6](#ch31ex06)
    中的代码匹配。此函数向与登录用户关联的消息添加一个 HTML 类属性。通过比较表单中用户的 ID 与与聊天消息关联的 ID，你可以过滤掉登录用户的消息。
- en: To accomplish this task, add `getCurrentUserClass` to determine whether the
    message in the chat belongs to the user who’s currently logged in. If so, add
    a `current-user` class, which you can use to distinguish the messages for that
    user visually. After this change, each message identified as belonging to the
    current signed-in user will have this style class associated. Because you’re using
    the user’s ID and message content in this function, you need to pass the entire
    `message` object, not only the message content as you did before, to `displayMessage`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，添加 `getCurrentUserClass` 来确定聊天中的消息是否属于当前登录的用户。如果是，添加一个 `current-user`
    类，你可以用它来在视觉上区分该用户的消息。在此更改之后，每个被识别为属于当前登录用户的消息都将关联此样式类。因为你在这个函数中使用用户的 ID 和消息内容，所以你需要传递整个
    `message` 对象，而不仅仅是之前的消息内容，到 `displayMessage`。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Change your call `displayMessage(message.content)` to `displayMessage (message)`
    so that you can use all properties of the message object.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的调用 `displayMessage(message.content)` 改为 `displayMessage (message)`，这样你就可以使用消息对象的所有属性。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 31.6\. Pulling hidden field values from chat form in recipeApp.js
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.6\. 在 recipeApp.js 中从聊天表单中提取隐藏字段值
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Display the message contents along with the user name in chat box.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在聊天框中显示消息内容以及用户名。**'
- en: '***2*** **Check whether the message’s user ID matches the form’s user ID.**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查消息的用户 ID 是否与表单的用户 ID 匹配。**'
- en: Now add some styling to the `current-user` class elements and distinguish chat
    messages from one another. With two browser windows side by side, and two users
    logged in, the chat can look like [figure 31.2](#ch31fig02).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给 `current-user` 类元素添加一些样式，区分不同的聊天消息。在两个并排的浏览器窗口中，有两个用户登录，聊天可以看起来像 [图 31.2](#ch31fig02)。
- en: Figure 31.2\. Styling user messages with two sockets
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 31.2\. 使用两个套接字对用户消息进行样式化
- en: '![](../Images/31fig02_alt.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/31fig02_alt.jpg)'
- en: You’ve implemented the logic to associate messages with users and distinguish
    those messages on the view. This chat still seems to lack a few points, however.
    Although the logged-in user can identify their own messages, they don’t know the
    identity of the other users. In the next section, you add user names to the chat
    messages.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经实现了将消息与用户关联的逻辑，并在视图中区分这些消息。然而，这个聊天似乎仍然缺少一些要点。尽管登录用户可以识别自己的消息，但他们不知道其他用户的身份。在下一节中，您将向聊天消息添加用户名。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 31.1**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.1**'
- en: '**[Q1:](#ch31qa2q0a1)**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch31qa2q0a1)**'
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you need to compare the chat message’s user ID with the user ID on the
    chat form in the client-side JavaScript?
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么您需要在客户端 JavaScript 中将聊天消息的用户 ID 与聊天表单上的用户 ID 进行比较？
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 31.1 answer**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.1 答案**'
- en: '**[1:](#ch31qa1q1)**'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch31qa1q1)**'
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The form’s user ID reflects that of the logged-in user. If the user ID in the
    chat’s message matches the one in the form, you can safely mark that message as
    belonging to the logged-in user and apply styling to indicate that fact.
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表单的用户 ID 反映了登录用户的 ID。如果聊天消息中的用户 ID 与表单中的 ID 匹配，您可以安全地将该消息标记为属于登录用户，并应用样式来表示这一点。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)31.2\. Displaying user names in chat'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)31.2\. 在聊天中显示用户名'
- en: The closer you get to coupling messages with the user accounts that created
    them, the easier it will be for users to communicate with one another. To eliminate
    confusion, you want to use the user’s name as an identifier on the chat message.
    To do so, implement a few small changes in your code from section 1.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您越接近将消息与创建它们的用户账户耦合，用户之间的沟通就会越容易。为了消除混淆，您希望将用户的名字用作聊天消息的标识符。为此，您需要在第 1 节的代码中实施一些小的更改。
- en: You’ve already added a hidden input field on the chat form to submit the user’s
    `fullName`. When the logged-in user submits their chat message, their name is
    sent along too.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在聊天表单中添加了一个隐藏的输入字段来提交用户的 `fullName`。当登录用户提交他们的聊天消息时，他们的名字也会被发送。
- en: Next, grab this field value in recipeApp.js by pulling the value from the `#chat_user_name`
    input on form submission, and save it to a variable. The new `submit` event handler
    looks like the code in the next listing. Then emit that value within the same
    object paired with the `userName` key. You’ll use this key in the server later.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 recipeApp.js 中通过从表单提交时提取 `#chat_user_name` 输入的值来获取此字段值，并将其保存到变量中。新的 `submit`
    事件处理程序看起来像下一个列表中的代码。然后，在同一个对象中与 `userName` 键配对发送该值。您将在服务器上稍后使用此键。
- en: Listing 31.7\. Pulling an additional hidden field value from chat form in recipeApp.js
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.7\. 从 recipeApp.js 中的聊天表单中提取额外的隐藏字段值
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Pull the user’s name.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **提取用户的名字。**'
- en: '***2*** **Emit a custom event with message contents to the server.**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **向服务器发送包含消息内容的自定义事件。**'
- en: 'On the server, you need to include this user name in the message attributes
    you collect so that they can be emitted to other client sockets. You could use
    the user’s ID to retrieve their name, but this approach saves you from communicating
    with the database. In the `message` event handler in chatController.js, your message
    attributes variable assignment should read `let me``s``sageAttributes = {content:
    data.content, userName: data.userName, user: data.userId}`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '在服务器上，您需要将此用户名包含在您收集的消息属性中，以便它们可以发送到其他客户端套接字。您可以使用用户的 ID 来检索他们的名字，但这种方法可以节省您与数据库通信。在
    chatController.js 中的 `message` 事件处理程序中，您的消息属性变量赋值应读取 `let messageAttributes =
    {content: data.content, userName: data.userName, user: data.userId}`。'
- en: Last, arrange this data, and display it appropriately in the view. Back in recipeApp.js,
    change the code in the `displayMessage` function to the code in [listing 31.8](#ch31ex08).
    This change displays the name of the user associated with the posted message.
    You can still use the `getCurrentUserClass` function to determine whether the
    message in the chat belongs to the currently logged-in user.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安排这些数据，并在视图中适当地显示。回到 recipeApp.js，将 `displayMessage` 函数中的代码更改为 [列表 31.8](#ch31ex08)
    中的代码。此更改显示了与发布的消息关联的用户的名字。您仍然可以使用 `getCurrentUserClass` 函数来确定聊天中的消息是否属于当前登录的用户。
- en: Listing 31.8\. Displaying the user name in the chat in recipeApp.js
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.8\. 在 recipeApp.js 中显示用户名
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Display the user name in bold and stylize if currentUser.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以粗体显示用户名，并如果 currentUser 则进行样式化。**'
- en: After implementing these changes, you can see the names of the users posting
    in the chat ([figure 31.3](#ch31fig03)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这些更改后，您可以看到在聊天中发布消息的用户的名字（[图 31.3](#ch31fig03)）。
- en: Figure 31.3\. Showing user names with two sockets
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 31.3\. 显示带有两个套接字的用户名
- en: '![](../Images/31fig03_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31fig03_alt.jpg)'
- en: With this improvement, users can identify the author of specific chat messages
    by that sender’s name. This feature is great, as it reduces the anonymity of chat
    and allows registered users to connect with one another. You still have the problem
    of chat messages disappearing with each page load, however. You need to connect
    these chat messages to your database, and the best way to do so is through a Mongoose
    data model. In the next section, you explore the model schema needed for a chat
    message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改进，用户可以通过发送者的名字来识别特定聊天消息的作者。这个功能很棒，因为它减少了聊天的匿名性，并允许注册用户相互联系。然而，您仍然面临聊天消息随着页面加载而消失的问题。您需要将这些聊天消息连接到您的数据库，而最好的方法是通过
    Mongoose 数据模型。在下一节中，您将探索聊天消息所需的模型模式。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.2**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.2**'
- en: '**[Q1:](#ch31qa4q0a1)**'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch31qa4q0a1)**'
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do you pass the user’s name to the server instead of using the user’s ID
    to find the name in your database?
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么您将用户的姓名传递到服务器而不是使用用户的ID在您的数据库中查找姓名？
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.2 answer**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.2 答案**'
- en: '**[1:](#ch31qa3q1)**'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch31qa3q1)**'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the user’s ID to look up their name can work, but it adds another layer
    of work involving the database. With no immediate need to use your database for
    this chat, you can pass the extra string values.
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用用户的ID查找他们的姓名可以工作，但这会增加涉及数据库的另一层工作量。由于没有立即需要使用您的数据库进行此聊天，您可以传递额外的字符串值。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)31.3\. Creating a message model'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)31.3\. 创建消息模型'
- en: 'To make this chat page worth revisiting, you need to save the messages being
    shared. To do so, you need to save the messages to your database, and you have
    a few ways to save them:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个聊天页面值得再次访问，您需要保存共享的消息。为此，您需要将消息保存到您的数据库中，您有几种保存消息的方法：
- en: You can modify your user schema to save an array of messages. With each new
    message that any user submits, that message is added to the user’s `messages`
    array. This approach can work, but you’ll quickly end up with long lists that
    aren’t efficient or necessary to store in the user model.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以修改您的用户模式以保存消息数组。每当任何用户提交新消息时，该消息就会被添加到用户的 `messages` 数组中。这种方法可以工作，但您很快就会得到长长的列表，这些列表既不高效也不必要存储在用户模型中。
- en: You could also create a new model to represent the chat and its messages. This
    approach requires a new model module but ultimately saves you some work and makes
    it easier to understand exactly what data you’re working with and saving.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以创建一个新的模型来表示聊天及其消息。这种方法需要一个新的模型模块，但最终可以节省您的工作量，并使您更容易理解您正在处理和保存的数据。
- en: In this section, you build a Message model to contain the values you’ve been
    working with in this lesson. Create a new message.js file in your project’s models
    folder, and add the code in [listing 31.9](#ch31ex09) to that file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将构建一个 Message 模型来包含您在本课中一直在使用的值。在您的项目模型文件夹中创建一个新的 message.js 文件，并将 [列表
    31.9](#ch31ex09) 中的代码添加到该文件中。
- en: In this code, you’re defining a message schema that contains `content`, `userName`,
    and `user` properties. The content of the chat message is required, as are the
    user’s name and ID. In essence, every message needs some text and an author. If
    someone tries to save a message somehow without logging in and authenticating,
    your database won’t allow the data to save. You also set `timestamps` to `true`
    so that you can keep track of when the chat message was added to your database.
    This feature allows you to show the timestamp in the chat box, if you want.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您正在定义一个包含 `content`、`userName` 和 `user` 属性的消息模式。聊天消息的内容是必需的，用户的姓名和ID也是如此。本质上，每条消息都需要一些文本和一个作者。如果有人试图以某种方式保存消息而没有登录和验证，您的数据库将不允许保存这些数据。您还设置了
    `timestamps` 为 `true`，这样您就可以跟踪聊天消息何时添加到您的数据库中。如果您想显示聊天框中的时间戳，这个功能非常有用。
- en: Listing 31.9\. Creating the message schema in message.js
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.9\. 在 message.js 中创建消息模式
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Require content in each message.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **每条消息都需要内容。**'
- en: '***2*** **Require the user’s name with each message.**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **每条消息都需要用户的姓名。**'
- en: '***3*** **Require a user ID with each message.**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **每条消息都需要一个用户ID。**'
- en: '***4*** **Save the timestamp with each message.**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **保存每条消息的时间戳。**'
- en: Next, require this new model in chatController.js by adding `const Message =
    require ("../models/message")` to the top of the file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在文件顶部添加 `const Message = require ("../models/message")` 来在 chatController.js
    中引入这个新模型。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`../models/message` means you’re stepping out of the controllers folder and
    into the models folder to find message.js.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`../models/message`意味着你正在离开controllers文件夹进入models文件夹以找到message.js。'
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To start saving incoming data to message models, you need to use your `messageAttributes`
    as the properties of a new message object. Then try to save that message to your
    MongoDB database, and emit the message if you’re successful. Modify your code
    with the code in the next listing to change the `client.on(``"``message``"``)`
    block in chatController.js.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始将传入的数据保存到消息模型中，你需要使用你的`messageAttributes`作为新消息对象的属性。然后尝试将此消息保存到你的MongoDB数据库中，如果你成功，则发射该消息。使用下一个列表中的代码修改你的代码，以更改chatController.js中的`client.on("message")`块。
- en: Listing 31.10\. Saving a message in chatController.js
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.10\. 在chatController.js中保存消息
- en: '[PRE14]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Create a new message object with messageAttributes.**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用messageAttributes创建一个新的消息对象。**'
- en: '***2*** **Save the message.**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **保存消息。**'
- en: '***3*** **Emit the message values if the save is successful, or log any errors.**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果保存成功，则发射消息值，或记录任何错误。**'
- en: 'That’s all it takes to start saving your messages. You can relaunch your application,
    log in, and send messages to have them save behind the scenes. You won’t notice
    any changes, because as soon as you refresh the chat page, you still wipe the
    chat history, even though messages are saved in your database. To correct this
    problem, you need to load some recent chat messages whenever a user reconnects
    to the chat socket. Within chatController.js, add the code in [listing 31.11](#ch31ex11)
    to find the ten most recent chat messages and emit them with a new custom event.
    Use `sort({createdAt: -1})` to sort your database results in descending order.
    Then chain `limit(10)` to limit those results to the ten most recent. When you
    emit your custom `"load all messages"` events on the client socket, only newly
    connected users’ chat boxes will refresh with the latest chat messages. Reverse
    the list of messages with `messages.reverse()` so that you can prepend them in
    the view.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '只需这样做就可以开始保存你的消息。你可以重新启动你的应用程序，登录，并发送消息，它们将在幕后保存。你不会注意到任何变化，因为当你刷新聊天页面时，你仍然会清除聊天历史，即使消息已经保存在你的数据库中。为了纠正这个问题，你需要在用户重新连接到聊天套接字时加载一些最近的聊天消息。在chatController.js中，添加[列表31.11](#ch31ex11)中的代码来找到最近的十条聊天消息，并使用一个新的自定义事件将它们发射出来。使用`sort({createdAt:
    -1})`按降序排列你的数据库结果。然后使用`limit(10)`来限制这些结果只包含最近的十条。当你向客户端套接字发射自定义的`"load all messages"`事件时，只有新连接的用户聊天框会刷新显示最新的聊天消息。使用`messages.reverse()`反转消息列表，以便你可以在视图中将它们前置。'
- en: Listing 31.11\. Loading most recent messages in chatController.js
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.11\. 在chatController.js中加载最近的聊天消息
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Query the ten most recent messages.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查询最近的十条消息。**'
- en: '***2*** **Emit a custom event with ten messages to the new socket only.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **只向新套接字发射包含十条消息的自定义事件。**'
- en: The last step is handling this new custom event in your client-side JavaScript.
    In recipeApp.js, add the event handler in [listing 31.12](#ch31ex12). This code
    listens for the `"load all messages"` event emitted to this specific socket. Any
    data received here is handled by sending each message in the `data` array to your
    `displayMessage` function to prepend the message contents to your chat box.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在你的客户端JavaScript中处理这个新的自定义事件。在recipeApp.js中，添加[列表31.12](#ch31ex12)中的事件处理程序。此代码监听发射到该特定套接字的自定义`"load
    all messages"`事件。在这里接收到的任何数据都通过将`data`数组中的每条消息发送到你的`displayMessage`函数来处理，以便将消息内容前置到你的聊天框中。
- en: Listing 31.12\. Displaying most recent messages in recipeApp.js
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.12\. 在recipeApp.js中显示最近的聊天消息
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Handle ‘load all messages’ by parsing incoming data.**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过解析传入的数据来处理“load all messages”。**'
- en: '***2*** **Send each message to displayMessage to display in the chat box.**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将每条消息发送到displayMessage以在聊天框中显示。**'
- en: Try comparing views of two adjacent sockets before and after one of the sockets
    refreshes its connection. A user’s new connection refreshes the chat box with
    messages from the database. Now it’s much easier for users to participate in the
    chat with a preserved history of messages shared.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试比较在套接字刷新其连接之前和之后两个相邻套接字的视图。用户的新的连接会使用数据库中的消息刷新聊天框。现在，用户可以更容易地参与聊天，并保留共享的消息历史。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.3**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查31.3**'
- en: '**[Q1:](#ch31qa6q0a1)**'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch31qa6q0a1)**'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the purpose of the “`load all messages`” event?
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “`load all messages`”事件的目的是什么？
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.3 answer**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.3 答案**'
- en: '**[1:](#ch31qa5q1)**'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch31qa5q1)**'
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “`load all messages`” is a custom event you created to communicate with your
    client socket to load database messages to the chat box as soon as they connect.
    You can use any custom event name. This unique name is descriptive and can be
    handled however you like in the client-side JavaScript.
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “`load all messages`”是你创建的一个自定义事件，用于与客户端socket通信，以便在它们连接时立即将数据库消息加载到聊天框中。你可以使用任何自定义事件名称。这个独特的名称是描述性的，你可以在客户端JavaScript中以任何你喜欢的样子处理它。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to curate messages in your chat box to display
    information about the message’s author. You also displayed the names of users
    alongside their messages to increase transparency in the chat page. At the end
    of the lesson, you created a Message model and started saving messages to your
    application’s database. This implementation allows messages to persist across
    multiple socket connections. By loading the most recent messages on every new
    socket connection, you immediately involve users in the conversation. In [lesson
    32](../Text/kindle_split_050.html#ch32), you look at one way to use `socket.io`
    events to notify users of new messages even when they aren’t actively on the chat
    page.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你学习了如何在聊天框中整理消息，以显示关于消息作者的详细信息。你还显示了用户的姓名，以便在聊天页面上增加透明度。在本节课结束时，你创建了一个消息模型，并开始将消息保存到应用程序的数据库中。这种实现允许消息在多个socket连接之间持久化。通过在每次新的socket连接时加载最新的消息，你立即让用户参与到对话中。在[第32课](../Text/kindle_split_050.html#ch32)中，你将查看一种使用`socket.io`事件通知用户新消息的方法，即使他们没有在聊天页面上活跃。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试以下操作**'
- en: Now that you have messages saving to your database and associated with user
    accounts, add another layer of security at the controller layer. Although you’re
    saving user IDs to the message, you aren’t making sure that the user ID is valid
    in your database. Add some code within the promise chain where the message is
    saved in chat-Controller.js to check the database for a user by the same ID and
    verify it before you officially save the message. For this task, you need to require
    the user model in this controller.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将消息保存到数据库中，并且与用户账户相关联，现在在控制器层添加另一层安全措施。虽然你在消息中保存了用户ID，但你并没有确保该用户ID在数据库中是有效的。在chat-Controller.js中保存消息的promise链中添加一些代码，通过相同的ID在数据库中查找用户并验证它，然后再正式保存消息。为此任务，你需要在这个控制器中引入用户模型。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Lesson 32\. Adding a Chat Notification Indicator
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第32课：添加聊天通知指示器
- en: Your chat page is coming together. Now users can log in and view the most recent
    chat messages, whether they were sent moments or weeks ago. The chat page currently
    facilitates all the visual aspects of your application’s chat functionality. The
    nice thing about `socket.io` is that it doesn’t need to exist on one page. Because
    your chat works by emitting and handling events, you can use those events in other
    ways. In this lesson, you build a custom event emitter to notify all active users
    when chat messages are being submitted. Then you build a small visual indicator
    in the navigation bar that animates when new messages are being shared. Through
    this small feat, users get a visual indication of an active chat room even when
    they’re browsing a different page.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你的聊天页面正在成形。现在用户可以登录并查看最新的聊天消息，无论它们是几分钟前还是几周前发送的。聊天页面目前促进了应用程序聊天功能的所有视觉方面。`socket.io`的好处是它不需要存在于一个页面上。因为你的聊天是通过发射和处理事件来工作的，所以你可以用其他方式使用这些事件。在本节课中，你构建了一个自定义事件发射器，以通知所有活跃用户当聊天消息正在提交时。然后你在导航栏中构建了一个小的视觉指示器，当有新消息分享时它会动画化。通过这个小技巧，用户即使在浏览不同页面时也能得到一个活跃聊天室的视觉指示。
- en: This lesson covers
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本节课涵盖
- en: Broadcasting a custom event
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播自定义事件
- en: Animating an icon in response to an event
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应事件动画图标
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下**'
- en: Users are enjoying the chat page in your application, but they’d like to browse
    other pages in your application instead of waiting for new messages to arrive
    on the chat page. They don’t want to miss out when the chat is active again, however.
    In this lesson, you rely on a custom event emitted by the server to animate a
    navigation-bar icon. When this icon is animated, users on any page of the application
    know that a chat is active.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 用户正在享受你的应用程序中的聊天页面，但他们希望浏览应用程序中的其他页面，而不是等待聊天页面上的新消息到来。然而，他们不希望错过聊天再次活跃的时候。在本节课中，你依赖于服务器发出的自定义事件来动画化导航栏图标。当这个图标动画化时，应用程序任何页面的用户都知道聊天正在进行。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)32.1\. Broadcasting to all other sockets'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)32.1\. 向所有其他套接字广播'
- en: One thing to know about `socket.io` is that it can be configured to work over
    multiple specific chat rooms and different namespaces. It can even allow users
    to be added and removed from specific groups. In addition to these features, messages
    don’t always need to be emitted to every client. In fact, it doesn’t always make
    sense to emit a message to everyone if, for example, the client emitting the message
    is disconnecting.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `socket.io` 有一件事要知道，它可以配置为在多个特定的聊天室和不同的命名空间中工作。它甚至允许用户被添加到或从特定的组中移除。除了这些功能之外，消息不总是需要发送给每个客户端。实际上，如果发出消息的客户端正在断开连接，那么向每个人发出消息通常是没有意义的。
- en: In this section, you implement a new feature to notify all other users in the
    chat when a user’s socket disconnects. To do so, add the code in [listing 32.1](#ch32ex01)
    to chatController.js within the `io.on("connect")` block.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您实现了一个新功能，当用户的套接字断开连接时，通知聊天中的所有其他用户。为此，在 `io.on("connect")` 块内将 [列表 32.1](#ch32ex01)
    中的代码添加到 chatController.js 中。
- en: In this code, you’re listening for when a certain client disconnects. You used
    this code block before to log a message to your console. In addition to logging
    this information, use `client.broadcast.emit("user disconnected")` to send a message
    to every socket aside from the one emitting the message. `client.broadcast` sends
    a custom event called `'user disconnected'` to the connected chat users.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，您正在监听某个客户端断开连接的情况。您之前使用此代码块在控制台记录消息。除了记录此信息外，使用 `client.broadcast.emit("user
    disconnected")` 向除了发出消息的套接字之外的所有套接字发送消息。`client.broadcast` 向连接的聊天用户发送一个名为 `'user
    disconnected'` 的自定义事件。
- en: The reason you’re broadcasting the message instead of emitting it is because
    the client that’s emitting the message is disconnected and can no longer handle
    that custom event. You can use `broadcast` to emit to all other sockets even when
    the emitting socket isn’t disconnected, though.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您之所以广播消息而不是发出消息，是因为发出消息的客户端已经断开连接，无法再处理该自定义事件。即使发出消息的套接字没有断开连接，您也可以使用 `broadcast`
    向所有其他套接字发出消息。
- en: Listing 32.1\. Broadcasting event to all other users in chatController.js
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 32.1\. 在 chatController.js 中向所有其他用户广播事件
- en: '[PRE17]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Broadcast a message to all otherconnected sockets.**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **向所有其他连接的套接字广播消息。**'
- en: With this new event being emitted, you need to handle it on the client side.
    As with your other events, listen for the `"user di``s``connected"` event, and
    print some indication in the chat box. Add the event handler in [listing 32.2](#ch32ex02)
    to recipeApp.js. In this code, you reuse your `displayMessage` to post a hardcoded
    message to let other users know that someone disconnected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个新事件的触发，您需要在客户端处理它。就像您处理其他事件一样，监听 `"user disconnected"` 事件，并在聊天框中打印一些指示。在
    [列表 32.2](#ch32ex02) 中添加事件处理程序到 recipeApp.js。在这段代码中，您重用了 `displayMessage` 函数来发布一条硬编码的消息，以便让其他用户知道有人断开连接。
- en: Listing 32.2\. Displaying a message when a user disconnects in recipeApp.js
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 32.2\. 在 recipeApp.js 中显示用户断开连接时的消息
- en: '[PRE18]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Listen for the ‘user disconnected’ event, and display a custom message.**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **监听“user disconnected”事件，并显示自定义消息。**'
- en: Now relaunch your application, and log into multiple accounts by logging in
    on two different browsers or by using your browser’s incognito mode to log in
    with a new session. With two chat windows open side by side, you should see when
    one of the users is connected in the other chat box. In [figure 32.1](#ch32fig01),
    the left chat window shows that a user disconnected when the right window is refreshed.
    In this case, a page refresh results in an immediate connection thereafter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新启动您的应用程序，并通过在两个不同的浏览器上登录或使用浏览器的高级隐私模式以新会话登录来登录多个账户。当两个聊天窗口并排打开时，您应该能看到当另一个聊天窗口中的用户连接时的情况。在
    [图 32.1](#ch32fig01) 中，左侧的聊天窗口显示当右侧窗口刷新时用户断开连接。在这种情况下，页面刷新会导致立即重新连接。
- en: Figure 32.1\. Displaying user disconnects in chat
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 32.1\. 在聊天中显示用户断开连接
- en: '![](../Images/32fig01_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32fig01_alt.jpg)'
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 32.1**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.1**'
- en: '**[Q1:](#ch32qa1q0a1)**'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch32qa1q0a1)**'
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between `client.broadcast.emit` and `client.emit`?
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`client.broadcast.emit` 和 `client.emit` 之间的区别是什么？'
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 32.1 answer**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 32.1 答案**'
- en: '**[1:](#ch32qa1q1)**'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch32qa1q1)**'
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`client.broadcast.emit` emits an event to all sockets except for itself, and
    `client.emit` emits an event to all sockets including itself.'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`client.broadcast.emit` 向所有除了它自身的套接字发出事件，而 `client.emit` 向包括它自身的所有套接字发出事件。'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)32.2\. Creating a chat indicator in navigation'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)32.2\. 在导航中创建聊天指示器'
- en: The last addition you’ll make to your chat application is a feature to let users
    on other pages in the application know when there’s activity on the chat page.
    This feature could be helpful to users who are viewing their profiles or recipes,
    or hanging out on the home page; they might like to know that other users are
    awake and talking to one another in the chat room. To add this feature, add an
    icon to the navigation bar. When a message is submitted in the chat room, you
    animate the chat icon in the navigation bar to let users elsewhere know of chat
    activity.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您将对聊天应用程序进行的最后一个添加是一个功能，让应用程序中其他页面的用户知道聊天页面上有活动。这个功能可能对查看个人资料或菜谱的用户或在家页面上闲逛的用户有帮助；他们可能想知道其他用户是否在聊天室中醒来并互相交谈。为了添加这个功能，在导航栏中添加一个图标。当聊天室中提交消息时，您将导航栏中的聊天图标动画化，让其他用户知道聊天活动。
- en: First, add the icon to your navigation bar by adding `<a href="/chat" class="chat-icon">`
    `@</a>` in layout.ejs. With this icon in place, you should see `@` in your navigation
    bar the next time you relaunch your application. If you click this icon, it takes
    you to the `/chat` route.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在 layout.ejs 中添加 `<a href="/chat" class="chat-icon">` `@</a>` 将图标添加到导航栏中。有了这个图标，您下次重新启动应用程序时应该会在导航栏中看到
    `@`。如果您点击此图标，它将带您到 `/chat` 路由。
- en: Next, animate the icon by having it flash twice when any user sends a message.
    To accomplish this task, use jQuery’s `fadeOut` and `fadeIn` methods on the chat
    icon whenever a `"message"` event is received. Modify your `soc``k``et.on("message")`
    handler in recipe-App.js to look like the code in the next listing. In this example,
    you still use the `displayMessage` function to post the message to your chat view;
    then, with a simple `for` loop, you animate the chat icon to flash twice.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当任何用户发送消息时，使图标闪烁两次以进行动画处理。为了完成这个任务，在接收到 `"message"` 事件时，使用 jQuery 的 `fadeOut`
    和 `fadeIn` 方法对聊天图标进行操作。修改 recipe-App.js 中的 `socket.on("message")` 处理器，使其看起来像下一个列表中的代码。在这个例子中，您仍然使用
    `displayMessage` 函数将消息发布到您的聊天视图；然后，通过一个简单的 `for` 循环，您将聊天图标动画化使其闪烁两次。
- en: Listing 32.3\. Animating chat icon when messages are sent in recipeApp.js
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 32.3\. 在 recipeApp.js 中发送消息时动画化聊天图标
- en: '[PRE19]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Animate the chat icon to flash when a message is sent.**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **当发送消息时使聊天图标闪烁。**'
- en: Relaunch your application, and log in to two browsers under two different accounts.
    Notice that now when one user sends a message, the other user sees the chat icon
    flash twice in the navigation bar, no matter where in the application they are
    ([figure 32.2](#ch32fig02)).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的应用程序，并在两个不同的浏览器账户下登录。注意，现在当一位用户发送消息时，无论另一位用户在应用程序的哪个位置，他们都会看到导航栏中的聊天图标闪烁两次（[图
    32.2](#ch32fig02)）。
- en: Figure 32.2\. Animating the chat icon in the navigation bar
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 32.2\. 在导航栏中动画化聊天图标
- en: '![](../Images/32fig02_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32fig02_alt.jpg)'
- en: In [lesson 33](../Text/kindle_split_051.html#ch33), you apply these steps and
    fully implement a chat feature in your capstone project.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 33 课](../Text/kindle_split_051.html#ch33) 中，您将应用这些步骤并在您的毕业设计中完全实现聊天功能。
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 32.2**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 32.2**'
- en: '**[Q1:](#ch32qa2q0a1)**'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch32qa2q0a1)**'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: You can handle `socket.io` events on any page in your application.'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对错：您可以在应用程序的任何页面上处理 `socket.io` 事件。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 32.2 answer**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 32.2 答案**'
- en: '**[1:](#ch32qa2q1)**'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch32qa2q1)**'
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: True. For the example in this lesson, you imported the `socket.io` library in
    the layout.ejs file, which is used in every view. Similarly, your client-side
    JavaScript lives in files also imported to your layout file. If you were to import
    `socket.io` client only on a specific view, you’d be able to handle events only
    on that specific page.
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对。对于本课的例子，您在 layout.ejs 文件中导入了 `socket.io` 库，该文件用于每个视图。同样，您的客户端 JavaScript 也位于导入到布局文件中的文件中。如果您只在特定视图中导入
    `socket.io` 客户端，您就只能在该特定页面上处理事件。
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to customize your `socket.io` events for use
    outside the normal chat feature. Because events can be used in any part of the
    application that has a `socket.io` client, you can create events for many types
    of data transfer over an open connection. First, you created a new event to notify
    other users when a user disconnects. Then you used an existing event to trigger
    a nonchat feature in your layout’s navigation. With this chat feature functioning,
    it’s time to apply the same tools to your capstone project ([lesson 33](../Text/kindle_split_051.html#ch33)).
    Then it’s time to deploy!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何自定义 `socket.io` 事件以用于正常聊天功能之外。因为事件可以在具有 `socket.io` 客户端的任何应用程序部分中使用，所以你可以为许多类型的开放连接数据传输创建事件。首先，你创建了一个新事件，用于在用户断开连接时通知其他用户。然后你使用现有事件在布局导航中触发非聊天功能。随着聊天功能的运行，是时候将相同的工具应用到你的毕业设计项目（[课程
    33](../Text/kindle_split_051.html#ch33)）上了。然后就是部署的时候了！
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Now that your chat application has a feature that lets users know when a user
    has disconnected, it would be useful to know when a user connects. Use `io.on("connection")`
    to trigger a new event to your client to let them know that a new user has joined
    the chat.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的聊天应用已经有一个功能，可以让用户知道当其他用户断开连接时，那么知道用户连接的时间也会很有用。使用 `io.on("connection")`
    触发一个新事件到您的客户端，让他们知道有新用户加入了聊天。
- en: 'When you’re done, see whether you can add the user’s name in the connection
    message, as in `Notice: Jon Wexler has joined the chat`.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，看看你是否可以在连接消息中添加用户的姓名，例如 `通知：Jon Wexler 已加入聊天`。
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 33\. Capstone: Adding a Chat Feature to Confetti Cuisinex'
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程 33. 毕业设计：为 Confetti Cuisinex 添加聊天功能
- en: At this stage, my application’s foundation is complete. I can continue to improve
    existing functionality or build new features. Before the application is released
    to production and made available for everyone to use, Confetti Cuisine asked me
    to add an interesting feature to engage users. Without hesitation, I tell them
    that this is a perfect opportunity to build a chat feature within their Node.js
    application. Because I don’t want to complicate the application too much before
    deployment, I’ll keep the chat simple.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我的应用程序的基础已经完成。我可以继续改进现有功能或构建新功能。在应用程序发布到生产环境并供所有人使用之前，Confetti Cuisine
    要求我添加一个有趣的功能来吸引用户。毫不犹豫地，我告诉他们这正好是在他们的 Node.js 应用程序中构建聊天功能的绝佳机会。因为我不想在部署前让应用程序过于复杂，所以我将保持聊天简单。
- en: The chat will allow only users with accounts to communicate with one another.
    Every time a message is sent, I’ll save the message and associate it with the
    sender behind the scenes. Also, I’ll take advantage of `socket.io` to maintain
    an open connection between connected clients and the server for real-time communication.
    Through this library’s event-driven tools, I can emit events from the server to
    individual clients or all clients and from the client to the server. I could also
    emit events to a select group of clients, but I won’t need to implement that feature
    for this application.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天将只允许有账户的用户相互通信。每次发送消息时，我都会在幕后保存消息并将其与发送者关联起来。此外，我将利用 `socket.io` 维护连接客户端和服务器之间的开放连接，以实现实时通信。通过这个库的事件驱动工具，我可以从服务器向单个客户端或所有客户端发出事件，也可以从客户端向服务器发出事件。我还可以向选定的一组客户端发出事件，但在这个应用程序中我不需要实现该功能。
- en: Later, I’ll connect a chat icon in the navigation bar to animate whenever a
    chat message is sent. All users see this icon animate whenever a message is emitted.
    This icon doubles as a link to the chat page. It’s time to put the finishing touches
    on the Confetti Cuisine application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我将连接导航栏中的聊天图标，以便在发送聊天消息时进行动画。所有用户都会看到这个图标在消息发出时进行动画。这个图标还充当了聊天页面的链接。是时候为
    Confetti Cuisine 应用程序添加最后的修饰了。
- en: '![](../Images/sectionFig.png)33.1\. Installing socket.io'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)33.1\. 安装 socket.io'
- en: First, I need to install the `socket.io` package. `socket.io` offers a JavaScript
    library that helps me build a real-time communication portal through its use of
    web sockets and long polling to maintain open connections between the client and
    the server. To install this package as a dependency, I run `npm i socket.io -S`
    in my project’s terminal window.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要安装 `socket.io` 包。`socket.io` 提供了一个 JavaScript 库，通过使用 WebSockets 和长轮询来维护客户端和服务器之间的开放连接，帮助我构建实时通信门户。为了将此包作为依赖项安装，我在项目的终端窗口中运行
    `npm i socket.io -S`。
- en: With this package installed, I need to require it in my main application file
    and on the client side.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个包后，我需要在主应用程序文件和客户端中引入它。
- en: '![](../Images/sectionFig.png)33.2\. Setting up socket.io on the server'
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)33.2\. 在服务器上设置socket.io'
- en: Before I require `socket.io`, I need to save the server instance I’m creating
    with Express.js by assigning my `app.listen` line in main.js to a constant called
    `server`. Below this line, I’ll require `socket.io` in my project by adding `const
    io = require("socket.io")(server)`. In this line, I’m simultaneously requiring
    the `socket.io` module and passing it the instance of my HTTP server used by Express.js.
    This way, the connection used by `socket.io` will share the same HTTP server as
    my main application. With my `socket.io` instance stored in the `io` constant,
    I can start using `io` to build out my chat functionality.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我需要`socket.io`之前，我需要将使用Express.js创建的服务器实例保存下来，通过将main.js中的`app.listen`行赋值给一个名为`server`的常量。在这行代码下面，我在项目中通过添加`const
    io = require("socket.io")(server)`来引入`socket.io`。在这行代码中，我同时引入了`socket.io`模块，并传递了Express.js使用的HTTP服务器实例。这样，`socket.io`使用的连接将与我主应用程序使用的HTTP服务器共享。将我的`socket.io`实例存储在`io`常量中后，我就可以开始使用`io`来构建我的聊天功能了。
- en: First, I set up a new controller for chat functionality. Though all the `socket.io`
    code can exist in main.js, it’s easier to read and maintain in its own controller.
    I start by requiring a new controller in main.js and passing it the `io` object
    by adding `const chatController = require("./controllers/chatController")( io
    )` to the bottom of main.js. Next, I create chatController.js in my controllers
    folder. In this file, I add the code from [listing 33.1](#ch33ex01).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我为聊天功能设置了一个新的控制器。尽管所有的`socket.io`代码都可以存在于main.js中，但将其放在自己的控制器中更容易阅读和维护。我开始在main.js中引入一个新的控制器，并通过添加`const
    chatController = require("./controllers/chatController")( io )`到main.js的底部来传递`io`对象。接下来，我在controllers文件夹中创建了一个名为chatController.js的新文件。在这个文件中，我添加了[列表33.1](#ch33ex01)中的代码。
- en: I use the same `io` object created in main.js to listen for specific socket
    events. `io.on ("connection")` reacts when a new client connects to my socket
    server. `client.on ("disconnect")` reacts when a connected client disconnects.
    `cl``i``ent.on("message")` reacts when a client socket sends a custom `message`
    event to the server. I can name this event whatever I want. Because I’m working
    with chat messages, this event name seems to be appropriate. Within that last
    block, I use `io.emit` to send a `message` event back to all connected clients
    with the same data I received from an individual client. This way, everyone gets
    the same message that a single user submits.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用在main.js中创建的相同的`io`对象来监听特定的socket事件。`io.on ("connection")`在新的客户端连接到我的socket服务器时做出反应。`client.on
    ("disconnect")`在已连接的客户端断开连接时做出反应。`client.on("message")`在客户端socket向服务器发送自定义的`message`事件时做出反应。我可以命名这个事件，因为我正在处理聊天消息，这个事件名看起来似乎是合适的。在最后一个块中，我使用`io.emit`将来自单个客户端的数据发送回所有已连接的客户端，这样每个人都能收到单个用户提交的相同消息。
- en: Listing 33.1\. Adding a chat action in chatController.js
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.1\. 在chatController.js中添加聊天操作
- en: '[PRE20]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Export the chat controller contents.**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导出聊天控制器的内容。**'
- en: '***2*** **Listen for new user connections.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **监听新用户连接。**'
- en: '***3*** **Listen for when the user disconnects.**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **监听用户断开连接时的情况。**'
- en: '***4*** **Listen for a custom message event.**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **监听自定义消息事件。**'
- en: '***5*** **Broadcast a message to all connected users.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **向所有已连接用户广播消息。**'
- en: The last line of code sends a specific set of message attributes that I expect
    to receive from the client. That is, I expect the client to emit a `message` event
    along with content, user name, and user ID. I need to send those three attributes
    from the view.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码发送了我期望从客户端接收的特定消息属性集。也就是说，我期望客户端在发送内容、用户名和用户ID的同时触发一个`message`事件。我需要在视图中发送这三个属性。
- en: '![](../Images/sectionFig.png)33.3\. Setting up socket.io on the client'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)33.3\. 在客户端设置socket.io'
- en: To build a successful chat connection, I need a view that facilitates the socket
    connection from the client side. I want to build my chat box in a view called
    chat.ejs that’s reachable at the `/chat` URL path. I create a new route for this
    path in my homeRoutes.js by adding `router.get("/chat", homeController.chat)`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立一个成功的聊天连接，我需要一个视图来促进客户端的socket连接。我想在名为chat.ejs的视图中构建我的聊天框，该视图可通过`/chat`
    URL路径访问。我在homeRoutes.js中为这个路径添加了一个新的路由，通过添加`router.get("/chat", homeController.chat)`。
- en: Then I add the controller action to match this route by adding the code in the
    next listing to homeController.js. This code renders my chat.ejs view.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我通过添加下一个列表中的代码到homeController.js中来匹配这个路由。这段代码渲染了我的chat.ejs视图。
- en: Listing 33.2\. Adding a chat action in homeController.js
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.2\. 在homeController.js中添加聊天操作
- en: '[PRE21]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Render a chat view.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **渲染聊天视图。**'
- en: To render my chat view, I need to build the view. I create a new file in my
    views folder called chat.ejs and add the code in [listing 33.3](#ch33ex03). In
    this Embedded JavaScript (EJS) code, I first check for a `currentUser` in the
    view. Earlier, I set up the `currentUser` as a local variable to reflect an active
    user session through Passport.js. If a user is logged in, I display the chat form.
    The form contains three inputs. Two of the inputs are hidden but carry the user’s
    name and ID. I’ll use these inputs later to send the identity of the message author
    to the server. The first input is for the actual message content. Later, I’ll
    grab the value of this input as the content that I submit to the server.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染我的聊天视图，我需要构建视图。我在我的视图文件夹中创建了一个名为chat.ejs的新文件，并添加了[列表33.3](#ch33ex03)中的代码。在这段嵌入式JavaScript
    (EJS) 代码中，我首先检查视图中是否存在`currentUser`。之前，我通过Passport.js设置了`currentUser`作为局部变量，以反映一个活跃的用户会话。如果用户已登录，我显示聊天表单。表单包含三个输入。其中两个输入是隐藏的，但携带用户的名称和ID。我将在以后使用这些输入将消息作者的标识发送到服务器。第一个输入是实际的消息内容。以后，我将从这个输入中获取值作为提交给服务器的消息内容。
- en: Listing 33.3\. Adding hidden fields in chat form in `chat.ejs`
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.3\. 在`chat.ejs`中的聊天表单中添加隐藏字段
- en: '[PRE22]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Check for a logged-in user.**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **检查是否有已登录的用户。**'
- en: '***2*** **Add hidden fields containing user data.**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加包含用户数据的隐藏字段。**'
- en: The last pieces of this puzzle are adding some client-side JavaScript to monitor
    user interaction on this chat page and submitting the `socket.io` events needed
    to notify the server of new messages. In my public folder, I locate confettiCuisine.js
    and add to it the code in [listing 33.4](#ch33ex04). In this code, I import `socket.io`
    for the client and add logic to interact over web sockets with my server. In the
    first code block, I use jQuery to handle my form’s submission and grab all the
    values from my form’s three inputs. I expect to receive these same three attributes
    in my server’s `client.on("message")` event handler.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后几块是添加一些客户端JavaScript来监控这个聊天页面的用户交互，并提交`socket.io`事件以通知服务器有新消息。在我的公共文件夹中，我找到了confettiCuisine.js并将其中的代码添加到[列表33.4](#ch33ex04)。在这段代码中，我为客户端导入`socket.io`并添加了通过WebSockets与服务器交互的逻辑。在第一个代码块中，我使用jQuery来处理我的表单提交并从我的表单的三个输入中获取所有值。我期望在服务器的`client.on("message")`事件处理器中接收到这三个相同的属性。
- en: The second block of code uses the `socket` object to represent the specific
    client on which this code will run. `socket.on("message")` sets up the client
    to listen for the `message` event, which emits from the server. When that event
    is emitted, each client takes the message delivered with that event and passes
    it to a custom `displayMessage` function that I created. This function locates
    my chat box in the view and prepends the message to the screen.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段代码使用`socket`对象来表示将运行此代码的特定客户端。`socket.on("message")`设置客户端监听从服务器发出的`message`事件。当该事件被触发时，每个客户端都会将随事件传递的消息传递给一个我创建的自定义`displayMessage`函数。这个函数定位视图中的聊天框，并将消息添加到屏幕上。
- en: Listing 33.4\. Adding socket.io on the client in confettiCuisine.js
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.4\. 在confettiCuisine.js中为客户端添加socket.io
- en: '[PRE23]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Initialize socket.io on the client.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在客户端初始化socket.io。**'
- en: '***2*** **Listen for a submit event in the chat form.**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在聊天表单中监听提交事件。**'
- en: '***3*** **Emit an event when the form is submitted.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在表单提交时触发事件。**'
- en: '***4*** **Listen for an event, and populate the chat box.**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **监听事件，并填充聊天框。**'
- en: '***5*** **Display messages in the chat box.**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在聊天框中显示消息。**'
- en: 'Before my application can use the `io` object in this file, I need to require
    it within my layout.ejs by adding the following script tag above my confettiCuisine.js
    import line: `<script src="/socket.io/socket.io.js"></script>`. This line loads
    `socket.io` for the client from my node_modules folder.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的应用程序可以使用此文件中的`io`对象之前，我需要在layout.ejs中通过添加以下脚本标签在我的confettiCuisine.js导入行上方来`require`它：`<script
    src="/socket.io/socket.io.js"></script>`。这一行从我的node_modules文件夹中为客户端加载`socket.io`。
- en: I’m ready to launch my application and see chat messages stream from one user
    to the next. With some styling, I can make it easier for users to distinguish
    their messages from others. I can also use the user’s name in the chat box so
    the sender’s name and message appear side by side. To do so, I modify my `displayMessage`
    function to print the user’s name, as shown in the next listing. I check whether
    the message being displayed belongs to that user by comparing the current user’s
    ID with the ID in the message object.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备好启动我的应用程序，并看到聊天消息从一个用户流到下一个用户。通过一些样式，我可以让用户更容易地区分他们的消息。我还可以在聊天框中使用用户的名称，这样发送者的名称和消息就会并排显示。为此，我修改了我的
    `displayMessage` 函数，如下一列表所示。我检查正在显示的消息是否属于该用户，通过比较当前用户的 ID 和消息对象中的 ID。
- en: Listing 33.5\. Pulling hidden field values from chat form in confettiCuisine.js
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 33.5\. 从 confettiCuisine.js 中的聊天表单中提取隐藏字段值
- en: '[PRE24]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Display the user’s name along with the message.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **与消息一起显示用户的名称。**'
- en: '***2*** **Check whether the message belongs to the current user.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查消息是否属于当前用户。**'
- en: Next, I need to preserve these messages in my database by creating a Message
    model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要通过创建消息模型来保留这些消息在我的数据库中。
- en: '![](../Images/sectionFig.png)33.4\. Creating a Message model'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)33.4\. 创建消息模型'
- en: To ensure that my chat feature is worth using and a practical tool for users
    on the Confetti Cuisine application, the messages can’t disappear every time a
    user refreshes the page. To fix this problem, I’ll build a Message model to contain
    the message attributes in the chat form. I create a new message.js file in my
    project’s models folder and add the code in [listing 33.6](#ch33ex06) to that
    file.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我的聊天功能值得使用，并且是 Confetti Cuisine 应用程序上用户的实用工具，消息不能在每次用户刷新页面时消失。为了解决这个问题，我将构建一个消息模型来包含聊天表单中的消息属性。我在项目的模型文件夹中创建了一个新的
    message.js 文件，并将 [列表 33.6](#ch33ex06) 中的代码添加到该文件中。
- en: In this code, I’m defining a message schema that contains `content`, `userName`,
    and `user` properties. The content of the chat message is required, as are the
    user’s name and ID. In essence, every message needs some text and an author. If
    someone tries to save a message somehow without logging in and authenticating,
    the database won’t allow the data to save. I also set `timestamps` to `true` so
    that I can keep track of when the chat message was added to the database. This
    feature allows me to show the timestamp in the chat box, if I want.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我定义了一个包含 `content`、`userName` 和 `user` 属性的消息模式。聊天消息的内容是必需的，用户的名称和 ID
    也是必需的。本质上，每条消息都需要一些文本和一个作者。如果有人试图在不登录和验证的情况下以某种方式保存消息，数据库将不允许保存这些数据。我还将 `timestamps`
    设置为 `true`，这样我就可以跟踪聊天消息何时被添加到数据库中。这个功能允许我在想要的情况下在聊天框中显示时间戳。
- en: Listing 33.6\. Creating the message schema in message.js
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 33.6\. 在 message.js 中创建消息模式
- en: '[PRE25]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Require content in each message.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在每条消息中要求内容。**'
- en: '***2*** **Require the user’s name with each message.**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在每条消息中要求用户的名称。**'
- en: '***3*** **Require a user ID with each message.**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在每条消息中要求用户 ID。**'
- en: '***4*** **Save the timestamp with each message.**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将时间戳与每条消息一起保存。**'
- en: This Mongoose model is ready for use in my chat controller. Effectively, when
    a new message arrives in my chat controller, I attempt to save it and then emit
    it to other users’ chats. I require this new model in chatController.js by adding
    `const Message = require ("../models/message")` to the top of the file. The code
    in my chatController.js block for `client.on("message")` is shown in [listing
    33.7](#ch33ex07). I start by using the same `message-Attributes` from earlier
    in the controller to create a new `Message` instance. Then I try to save that
    message. If the message saves successfully, I emit it to all connected sockets;
    otherwise, I log the error, and the message never gets sent out from the server.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Mongoose 模型已经准备好在我的聊天控制器中使用。实际上，当我的聊天控制器收到一条新消息时，我会尝试保存它，然后将其发送给其他用户的聊天。我在
    chatController.js 文件的顶部通过添加 `const Message = require ("../models/message")` 来引入这个新模型。我的
    chatController.js 文件中 `client.on("message")` 的代码在 [列表 33.7](#ch33ex07) 中展示。我首先使用控制器中早先的相同
    `message-Attributes` 来创建一个新的 `Message` 实例。然后我尝试保存这条消息。如果消息保存成功，我会将其发送给所有已连接的套接字；否则，我会记录错误，并且消息永远不会从服务器发送出去。
- en: Listing 33.7\. Saving a message in chatController.js
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 33.7\. 在 chatController.js 中保存消息
- en: '[PRE26]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Create a new message object with messageAttributes.**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用消息属性创建一个新的消息对象。**'
- en: '***2*** **Save the message.**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **保存消息。**'
- en: '***3*** **Emit the message values if save is successful, and log any errors.**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果保存成功，则发射消息值，并记录任何错误。**'
- en: This code allows messages to save to my database, but chat message history still
    doesn’t appear for users who are connecting for the first time. I’ll correct that
    problem by loading older messages into my database.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许消息保存到我的数据库中，但对于第一次连接的用户，聊天消息历史仍然没有显示。我将通过将旧消息加载到我的数据库中来纠正这个问题。
- en: '![](../Images/sectionFig.png)33.5\. Loading messages on connection'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![33.5. 连接时加载消息](../Images/sectionFig.png)'
- en: The second task in preserving messages in the chat box is maintaining a consistent
    number of messages from the chat’s history in the chat box. I decide to allow
    the chat box to contain the ten most recent chats at any given moment. To do so,
    I need to load those ten most recent chats from my database and emit them to every
    client as soon as they connect to the chat.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在保持聊天框中消息的第二个任务是保持聊天历史中聊天框中消息的一致数量。我决定允许聊天框在任何给定时刻包含最近的十条聊天记录。为了做到这一点，我需要从我的数据库中加载这十条最近的聊天记录，并在它们连接到聊天时立即将它们发射给每个客户端。
- en: 'Within chatController.js, I add the code in [listing 33.8](#ch33ex08) to find
    the ten most recent chat messages and emit them with a new custom event. I use
    `sort({createdAt: -1})` to sort my database results in descending order. Then
    I append `limit(10)` to limit those results to the ten most recent. By emitting
    the custom `"load all messages"` event on the client socket, only newly connected
    users will have their chat boxes refresh with the latest chat messages. Then,
    I reverse the list of messages with `messages.reverse()` so that I can prepend
    them in the view.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '在chatController.js中，我添加了[列表33.8](#ch33ex08)中的代码来查找最近的十条聊天消息，并通过一个新的自定义事件将它们发射出来。我使用`sort({createdAt:
    -1})`来按降序排列我的数据库结果。然后，我添加`limit(10)`来限制这些结果只包含最近的十条。通过在客户端socket上发射自定义的`"load
    all messages"`事件，只有新连接的用户将刷新他们的聊天框以显示最新的聊天消息。然后，我使用`messages.reverse()`反转消息列表，以便在视图中将它们前置。'
- en: Listing 33.8\. Loading most recent messages in chatController.js
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.8. 在chatController.js中加载最近的聊天消息
- en: '[PRE27]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Query the ten most recent messages.**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查询最近的十条消息。**'
- en: '***2*** **Emit a custom event with ten messages to the new socket only.**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **只向新socket发射包含十条消息的自定义事件。**'
- en: To handle the `"load all messages"` event on the client side, I add the event
    handler in the next listing to confettiCuisine.js. In this block of code, I listen
    for the `"load all messages"` event to occur. When it does emit, I cycle through
    the messages received on the client and individually display them in the chat
    box through the `displayMessage` function.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理客户端的`"load all messages"`事件，我在下一个列表中添加了事件处理程序到confettiCuisine.js。在这段代码块中，我监听`"load
    all messages"`事件的发生。当它发生时，我遍历客户端接收到的消息，并通过`displayMessage`函数在聊天框中逐个显示它们。
- en: Listing 33.9\. Displaying most recent messages in confettiCuisine.js
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.9. 在confettiCuisine.js中显示最近的聊天消息
- en: '[PRE28]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Handle ‘load all messages’ by parsing incoming data.**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **通过解析传入的数据来处理‘load all messages’。**'
- en: '***2*** **Send each message to displayMessage to display in the chat box.**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将每条消息发送到displayMessage以在聊天框中显示。**'
- en: The chat is finally complete and ready to test locally. To mimic two separate
    users communicating, I relaunch my application and log in on two separate web
    browsers. I navigate to the chat page and see that my chats are being sent in
    real time over my Node.js application with `socket.io`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天功能最终完成并准备好本地测试。为了模拟两个独立用户之间的通信，我重新启动了我的应用程序并在两个不同的网络浏览器上登录。我导航到聊天页面，看到我的聊天消息正在通过Node.js应用程序的`socket.io`实时发送。
- en: '![](../Images/sectionFig.png)33.6\. Setting up the chat icon'
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![33.6. 设置聊天图标](../Images/sectionFig.png)'
- en: 'I want to make one final addition to this application: an icon that lets users
    elsewhere in the application know when the chat is active. I can easily add this
    feature with the existing `socket.io` event set up. All I need to do is add an
    icon to the navigation bar in my application by adding `<a href="/chat" class="chat-icon">@</a>`
    to layout.ejs. With this line alone, I have an icon in my navigation bar that
    links to the `/chat` route.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向这个应用程序添加一个最后的特性：一个图标，让应用程序其他部分的用户知道聊天是否活跃。我可以很容易地通过现有的`socket.io`事件设置来实现这个功能。我需要做的只是在我的应用程序导航栏中添加一个图标，通过在layout.ejs中添加`<a
    href="/chat" class="chat-icon">@</a>`来实现。仅此一行，我就在我的导航栏中添加了一个链接到`/chat`路由的图标。
- en: Next, I animate the icon by having it flash twice whenever a chat message is
    sent. Because I’m already emitting the `message` event from the server every time
    a new message is submitted, I can add the icon animation to the client’s handler
    for that event.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每当发送一条聊天消息时，我会让图标闪烁两次来动画化它。因为每次提交新消息时，我已经从服务器端发射了`message`事件，所以我可以在客户端为该事件的处理程序中添加图标动画。
- en: In confettiCuisine.js, I modify the `socket.on("message")` code block to look
    like the code in the following listing. In this code, I display the message in
    the chat box as usual and additionally target an element with the `chat-icon`
    class. This element represents my chat icon in the navigation bar. Then I rapidly
    fade the icon out and back in, twice.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在confettiCuisine.js中，我修改了`socket.on("message")`代码块，使其看起来像以下列表中的代码。在这个代码中，我像往常一样在聊天框中显示消息，并额外定位一个具有`chat-icon`类的元素。这个元素代表我在导航栏中的聊天图标。然后我快速淡出并淡入图标，共两次。
- en: Listing 33.10\. Animating chat icon when messages are sent in confettiCuisine.js
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表33.10\. 在confettiCuisine.js中发送消息时动画化聊天图标
- en: '[PRE29]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Animate the chat icon to flash when a message is sent.**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **当发送消息时动画化聊天图标。**'
- en: With this extra feature, users have some indication that conversations are taking
    place on the chat page.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个额外功能，用户可以有一些迹象表明聊天页面上正在进行对话。
- en: I could add to this chat feature in plenty of ways. I could create separate
    chats for each Confetti Cuisine class, for example, or use `socket.io` events
    to notify users when they’ve been tagged in a chat. I’ll consider implementing
    these features in the future.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以通过很多方式来增强这个聊天功能。例如，我可以为每个Confetti Cuisine班级创建单独的聊天室，或者使用`socket.io`事件在用户被标记在聊天中时通知他们。我将在未来考虑实现这些功能。
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)摘要'
- en: In this capstone exercise, I added a real-time chat feature to my Confetti Cuisine
    application. I used `socket.io` to simplify connections between the server and
    multiple clients. I used some built-in and custom events to transfer data between
    open sockets. At the end, I added a feature to notify users who aren’t in the
    chat room that others are actively communicating. With this feature added, I’m
    ready to deploy the application.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合练习中，我为我的Confetti Cuisine应用程序添加了实时聊天功能。我使用了`socket.io`来简化服务器和多个客户端之间的连接。我使用了一些内置和自定义事件在打开的套接字之间传输数据。最后，我添加了一个功能，通知不在聊天室中的用户其他人正在积极交流。添加了这个功能后，我就可以部署应用程序了。
