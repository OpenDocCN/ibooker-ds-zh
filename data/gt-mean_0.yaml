- en: Part 1\. Setting the baseline
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分. 建立基础
- en: Full-stack development is rewarding when you get it right. An application has
    many moving parts, and it’s your job to get them working in harmony. The best
    first steps you can take are understanding the building blocks you have to work
    with and looking at the ways you can put them together to achieve different results.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你做得正确时，全栈开发是非常有回报的。一个应用程序有很多组成部分，而你的任务是让它们协同工作。你可以采取的最佳第一步是理解你将要工作的构建块，并查看你可以如何将它们组合起来以实现不同的结果。
- en: These steps are what [part 1](#part01) is all about. In [chapter 1](kindle_split_011.xhtml#ch01),
    you’ll take a look at the benefits of learning full-stack development in some
    detail and explore the components of the MEAN stack. [Chapter 2](kindle_split_012.xhtml#ch02)
    builds on this knowledge of the components and discusses how you can use them
    together to build things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤就是[第一部分](#part01)的全部内容。在[第一章](kindle_split_011.xhtml#ch01)中，你们将详细探讨学习全栈开发的益处，并探索MEAN栈的组成部分。[第二章](kindle_split_012.xhtml#ch02)将在此基础上，讨论你们如何将这些组件组合起来构建东西。
- en: By the end of [part 1](#part01), you’ll have a good understanding of possible
    software and hardware architectures for a MEAN stack application, as well as the
    plan for the application you’ll build throughout the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到[第一部分](#part01)结束时，你们将很好地理解MEAN栈应用程序可能的软件和硬件架构，以及你们在整个书中将要构建的应用程序的规划。
- en: Chapter 1\. Introducing full-stack development
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章. 全栈开发简介
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Evaluating full-stack development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估全栈开发
- en: Getting to know the MEAN stack components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解MEAN栈组件
- en: Examining what makes the MEAN stack so compelling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探讨使MEAN栈如此吸引人的因素
- en: Previewing the application you’ll build throughout this book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预览本书中将要构建的应用程序
- en: If you’re like us, you’re probably impatient to dive into some code and get
    on with building something. But let’s take a moment first to clarify what we mean
    by *full-stack development* and look at the component parts of the stack to make
    sure that you understand each one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你们和我们一样，可能都迫不及待地想要开始编写代码，着手构建一些东西。但让我们先花一点时间来明确一下我们所说的*全栈开发*是什么意思，并查看栈的各个组成部分，以确保你们理解每一个部分。
- en: When we talk about full-stack development, we’re really talking about developing
    all parts of a website or application. The full stack starts with the database
    and web server in the back end, contains application logic and control in the
    middle, and goes all the way through to the user interface at the front end.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论全栈开发时，我们实际上是在谈论开发网站或应用程序的所有部分。全栈从后端的数据库和网络服务器开始，包含中间的应用逻辑和控制，一直延伸到前端的用户界面。
- en: 'The MEAN stack is a pure JavaScript stack comprised of four main technologies,
    with a cast of supporting technologies:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN栈是一个纯JavaScript栈，由四种主要技术组成，辅以一系列支持技术：
- en: '**M**ongoDB—the database'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**M**ongoDB——数据库'
- en: '**E**xpress—the web framework'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E**xpress——网络框架'
- en: '**A**ngular—the front-end framework'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A**ngular——前端框架'
- en: '**N**ode.js—the web server'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**N**ode.js——网络服务器'
- en: MongoDB has been around since 2007 and is actively maintained by MongoDB, Inc.,
    previously known as 10gen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB自2007年以来一直存在，并由MongoDB, Inc.（之前称为10gen）积极维护。
- en: Express was first released in 2009 by T. J. Holowaychuk and has become the most
    popular framework for Node.js. It’s open source, with more than 100 contributors,
    and is actively developed and supported.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Express首次由T. J. Holowaychuk于2009年发布，并已成为Node.js最受欢迎的框架。它是开源的，拥有超过100位贡献者，并且正在积极开发和维护。
- en: Angular is open source and backed by Google. The first version of Angular, known
    as AngularJS or Angular 1, has been around since 2010\. Angular 2, now known simply
    as Angular, was officially released in 2016 and is continually being developed
    and extended. The current version is Angular 7.1; Angular 2+ isn’t backward-compatible
    with AngularJS. See the sidebar “[Angular versions and release cycles](#ch01sb02)”
    for a bit more information about the number and release cycles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是开源的，由Google支持。Angular的第一个版本，被称为AngularJS或Angular 1，自2010年以来一直存在。Angular
    2，现在简单地称为Angular，于2016年正式发布，并且正在持续开发和扩展。当前版本是Angular 7.1；Angular 2+与AngularJS不向后兼容。有关版本和发布周期的更多信息，请参阅侧边栏“[Angular版本和发布周期](#ch01sb02)”。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Angular versions and release cycles**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular版本和发布周期**'
- en: The change from Angular 1.x to Angular 2 was a big deal in the developer community.
    It was a long time coming, different, and not backward-compatible. But now Angular
    is releasing versions much more frequently, aiming for every six months. The current
    version is Angular 7.1, with further iterations already being heavily worked on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular 1.x到Angular 2的变化在开发者社区中是一件大事。它来得晚，不同，而且不向后兼容。但现在Angular正在以每六个月一次的频率发布新版本。当前版本是Angular
    7.1，进一步的迭代已经正在被大量工作。
- en: The frequency of change is nothing to worry about, though; the changes are nowhere
    near as big as the complete rewrite that happened between 1.x and 2.0\. The changes
    are generally small, incremental changes. There may be some breaking changes between
    4 and 5, or 5 and 6, and so on, but these changes are normally small, specific
    items that are easy to pick up—unlike the change from Angular 1.x to 2.0.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 变化的频率无需担忧，尽管如此；这些变化远不如1.x到2.0之间的完全重写那么大。变化通常是小的、渐进式的。在4到5，或5到6等版本之间可能会有一些破坏性变化，但这些变化通常是小的、具体的项，易于掌握——与从Angular
    1.x到2.0的变化不同。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Node.js was created in 2009, and its development and maintenance are currently
    under the purview of the Node Foundation, of which Joyent (the organization that
    created Node) is a major member. Node.js uses Google’s open source V8 JavaScript
    engine at its core.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js于2009年创建，其开发和维护目前由Node Foundation负责，其中Joyent（创建Node的组织）是主要成员。Node.js的核心使用的是谷歌的开源V8
    JavaScript引擎。
- en: 1.1\. Why learn the full stack?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 为什么学习全栈开发？
- en: Indeed, why learn the full stack? It sounds like an awful lot of work! Well,
    yes, it *is* quite a lot of work, but it’s also rewarding, as you get to create
    fully functioning data-driven websites and applications all by yourself. And with
    the MEAN stack, the work isn’t as hard as you might think.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，为什么要学习全栈开发？这听起来像是一项非常繁重的工作！嗯，是的，这确实是一项相当繁重的工作，但同时也很有回报，因为你能够独自创建完全功能的数据驱动网站和应用。而且使用MEAN栈，工作并不会像你想象中那么困难。
- en: 1.1.1\. A brief history of web development
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 网络开发简史
- en: Back in the early days of the web, people didn’t have high expectations of websites.
    Not much emphasis was given to presentation; building websites was much more about
    what was going on behind the scenes. Typically, if you knew something like Perl
    and could string together a bit of HTML, you were a web developer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络开发的早期，人们对网站并没有很高的期望。对展示的重视不多；建网站更多的是关于幕后发生的事情。通常，如果你知道像Perl这样的东西并且能够将一点HTML串联起来，你就是一名网络开发者。
- en: As use of the internet spread, businesses started to take more of an interest
    in how their online presence portrayed them. In combination with increased browser
    support for Cascading Style Sheets (CSS) and JavaScript, this interest led to
    more-complicated front-end implementations. It was no longer a case of being able
    to string together HTML; you needed to spend time on CSS and JavaScript, making
    sure that it looked right and worked as expected. And all this needed to work
    in different browsers, which were much less compliant than they are today.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的普及，企业开始更加关注他们的在线形象。结合浏览器对层叠样式表（CSS）和JavaScript的支持增加，这种兴趣导致了更复杂的前端实现。不再是仅仅能够将HTML串联起来；你需要花时间在CSS和JavaScript上，确保它们看起来正确并且按预期工作。而且所有这些都需要在不同的浏览器上工作，而这些浏览器远不如今天那么兼容。
- en: This is where the distinction between front-end developer and back-end developer
    came in. [Figure 1.1](#ch01fig01) illustrates this separation over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前端开发者和后端开发者之间的区别所在。[图1.1](#ch01fig01)展示了这种随着时间的推移而出现的分离。
- en: Figure 1.1\. Divergence of front-end and back-end developers over time
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. 前端和后端开发者随时间的变化
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig01_alt.jpg)'
- en: While back-end developers focused on the mechanics behind the scenes, front-end
    developers focused on building a good user experience. As time went on, higher
    expectations were made of both camps, encouraging this trend to continue. Developers
    often had to choose an area of expertise and focus on it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当后端开发者专注于幕后机制时，前端开发者专注于构建良好的用户体验。随着时间的推移，对这两方面的期望越来越高，促使这一趋势持续发展。开发者经常不得不选择一个专业领域并专注于它。
- en: Helping developers with libraries and frameworks
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 帮助开发者使用库和框架
- en: During the 2000s, libraries and frameworks started to become popular and prevalent
    for the most common languages on both the front and back ends. Think Dojo and
    jQuery for front-end JavaScript; think Symfony for PHP and Ruby on Rails. These
    frameworks were designed to make life easier for developers, lowering the barriers
    to entry. A good library or framework abstracts away some of the complexities
    of development, allowing you to code faster and requiring less in-depth expertise.
    This trend toward simplification has resulted in a resurgence of full-stack developers
    who build both the front end and the application logic behind it, as [figure 1.2](#ch01fig02)
    shows.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代，库和框架开始在前端和后端最常见的语言中变得流行和普遍。想想前端JavaScript的Dojo和jQuery；想想PHP和Ruby on
    Rails的Symfony。这些框架被设计用来让开发者生活更轻松，降低入门门槛。一个好的库或框架可以抽象掉一些开发复杂性，让你更快地编码，并减少对深入专业知识的需求。这种简化趋势导致了全栈开发者的回归，他们既构建前端也构建其后的应用程序逻辑，如图1.2所示。
- en: Figure 1.2\. Impact of frameworks on the separated web development factions
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 框架对分离的Web开发派系的影响
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/01fig02_alt.jpg)'
- en: '[Figure 1.2](#ch01fig02) illustrates a trend rather than proclaims a definitive
    “all web developers should be full-stack developers” maxim. There have been full-stack
    developers throughout the entire history of the web, and moving forward, it’s
    most likely that some developers will choose to specialize in either front-end
    or back-end development. The intention is to show that through the use of frameworks
    and modern tools, you no longer have to choose one end or the other to be a good
    web developer.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)展示的是一个趋势，而不是宣称一个“所有Web开发者都应该成为全栈开发者”的绝对法则。在整个Web历史上一直都有全栈开发者，向前看，很可能会有些开发者会选择专注于前端或后端开发。目的是通过使用框架和现代工具，你不再需要选择一个端或另一个端来成为一名优秀的Web开发者。'
- en: A huge advantage in embracing the framework approach is that you can be incredibly
    productive, because you’ll have an all-encompassing vision of the application
    and how it ties together.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 采用框架方法的一个巨大优势是你可以非常高效地工作，因为你将拥有对应用程序及其如何结合在一起的全局视角。
- en: Moving the application code forward in the stack
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将应用程序代码向前移动到堆栈中
- en: Continuing with the trend toward frameworks, the past few years have seen an
    increasing effort to move the application logic away from the server and into
    the front end. Think of this as coding the back end in the front end. Some of
    the most popular JavaScript frameworks doing this are Angular, React, and Vue.js.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续遵循框架趋势，过去几年中，人们越来越努力地将应用程序逻辑从服务器移到前端。把这看作是在前端编码后端。在这方面做得最流行的JavaScript框架有Angular、React和Vue.js。
- en: Tightly coupling the application code to the front end this way tends to blur
    the lines between traditional front-end and back-end developers. One of the reasons
    why people like to use this approach is that it reduces the load on the servers,
    thus reducing cost. What you’re doing in effect is crowdsourcing the computational
    power required for the application by pushing that load into users’ browsers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式将应用程序代码紧密耦合到前端，往往会模糊传统前端和后端开发者之间的界限。人们喜欢使用这种方法的一个原因是因为它减少了服务器的负载，从而降低了成本。实际上你所做的是通过将负载推入用户的浏览器，将应用程序所需的计算能力众包。
- en: We’ll discuss the pros and cons of this approach in section [1.5](#ch01lev1sec5)
    and explain when it may (or may not) be appropriate to use one of these technologies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第[1.5](#ch01lev1sec5)节讨论这种方法的优缺点，并解释何时（或可能不）适合使用这些技术之一。
- en: 1.1.2\. The trend toward full-stack developing
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 全栈开发的趋势
- en: As discussed, the paths of front-end and back-end developers are merging; it’s
    entirely possible to be fully proficient in both disciplines. If you’re a freelancer,
    consultant, or part of a small team, being multiskilled is extremely useful, increasing
    the value that you can provide for your clients. Being able to develop the full
    scope of a website or application gives you better overall control and can help
    the parts work seamlessly together, because they haven’t been built in isolation
    by separate teams.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所讨论的，前端和后端开发者的道路正在融合；在两个学科中完全精通是完全可能的。如果你是一名自由职业者、顾问或小型团队的一员，多技能是非常有用的，可以增加你为客户提供的价值。能够开发整个网站或应用程序的范围，可以让你更好地控制整体，并有助于各部分无缝协作，因为它们不是由不同的团队独立构建的。
- en: If you work as part of a large team, chances are that you’ll need to specialize
    in (or at least focus on) one area. But it’s generally advisable to understand
    how your component fits with other components, giving you a greater appreciation
    of the requirements and goals of other teams and the overall project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你作为大型团队的一部分工作，你很可能会需要专门化（或者至少专注于）一个领域。但通常建议你了解你的组件如何与其他组件配合，这将使你更加欣赏其他团队和整个项目的要求和目标。
- en: In the end, building on the full stack yourself is rewarding. Each part comes
    with its own challenges and problems to solve, keeping things interesting. The
    technology and tools available today enhance this experience and empower you to
    build great web applications relatively quickly and easily.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，独立构建全栈是很有回报的。每个部分都伴随着自己的挑战和需要解决的问题，使事情保持有趣。今天可用的技术和工具增强了这种体验，并赋予你相对快速和容易地构建优秀网络应用程序的能力。
- en: 1.1.3\. Benefits of full-stack development
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 全栈开发的益处
- en: There are many benefits to learning full-stack development. For starters, there’s
    the enjoyment of learning new things and playing with new technologies, of course.
    Then you have the satisfaction of mastering something different and the thrill
    of being able to build and launch a full database-driven application all by yourself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 学习全栈开发有许多好处。首先，当然是有学习新事物和玩新技术的乐趣。然后，你会有掌握不同技能的满足感，以及能够独立构建和发布一个全数据库驱动的应用程序的激动。
- en: 'The benefits of working in a team include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中工作的好处包括以下内容：
- en: You’re more likely to have a better view of the bigger picture by understanding
    the different areas and how they fit together.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过理解不同的领域以及它们如何配合，你更有可能对大局有更好的看法。
- en: You’ll form an appreciation of what other parts of the team are doing and what
    they need to be successful.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将形成对团队其他部分正在做什么以及他们需要成功所需的了解。
- en: Like other team members, you can move around more freely.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像其他团队成员一样，你可以更加自由地移动。
- en: The additional benefits of working by yourself include
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 独自工作的额外好处包括
- en: You can build applications end-to-end by yourself without depending on other
    people.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以独立构建端到端的应用程序，而不依赖于其他人。
- en: You develop more skills, services, and capabilities to offer customers.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以开发更多技能、服务和能力，以提供给客户。
- en: All in all, there’s a lot to be said for full-stack development. Most of the
    accomplished developers we’ve met have been full-stack developers. Their overall
    understanding and ability to see the bigger picture is a tremendous bonus.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，全栈开发有很多可说的。我们遇到的大部分成功开发者都是全栈开发者。他们对整体的理解和看到大局的能力是一个巨大的优势。
- en: 1.1.4\. Why the MEAN stack specifically?
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 为什么是MEAN栈？
- en: The MEAN stack pulls together some of the “best-of-breed” modern web technologies
    into a powerful, flexible stack. One great thing about the MEAN stack is that
    it not only uses JavaScript in the browser, but also uses JavaScript throughout.
    Using the MEAN stack, you can code the front end and back end in the same language.
    That being said, it’s more common to build the Angular part of the stack in TypeScript.
    We’ll discuss this reasoning in [chapter 8](kindle_split_020.xhtml#ch08).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN栈将一些“最佳”的现代网络技术汇集到一个强大、灵活的栈中。MEAN栈的一个优点是它不仅在使用浏览器的JavaScript中，而且在整个应用中都用JavaScript。使用MEAN栈，你可以用同一种语言编写前端和后端代码。尽管如此，构建栈的Angular部分通常使用TypeScript。我们将在[第8章](kindle_split_020.xhtml#ch08)中讨论这个理由。
- en: '[Figure 1.3](#ch01fig03) demonstrates the principal technologies of the MEAN
    stack and shows where each one is commonly used.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.3](#ch01fig03) 展示了MEAN栈的主要技术，并显示了每个技术通常被用于何处。'
- en: Figure 1.3\. The principal technologies of the MEAN stack
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. MEAN栈的主要技术
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig03_alt.jpg)'
- en: The principal technology allowing full-stack JavaScript to happen is Node.js,
    bringing JavaScript to the back end.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 允许全栈JavaScript实现的主要技术是Node.js，它将JavaScript引入了后端。
- en: '1.2\. Introducing Node.js: The web server/platform'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 介绍Node.js：网络服务器/平台
- en: 'Node.js is the *N* in *MEAN*. Being last doesn’t mean that it’s the least important:
    it’s the foundation of the stack!'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是*MEAN*中的*N*。排在最后并不意味着它是最不重要的：它是栈的基础！
- en: In a nutshell, Node.js is a software platform that allows you to create your
    own web server and build web applications on top of it. Node.js isn’t itself a
    web server; neither is it a language. It contains a built-in HTTP server library,
    meaning that you don’t need to run a separate web server program such as NGINX,
    Apache, or Internet Information Services (IIS). This gives you greater control
    of how your web server works but also increases the complexity of getting it up
    and running, particularly in a live environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Node.js 是一个软件平台，它允许你创建自己的 Web 服务器并在其上构建 Web 应用程序。Node.js 本身不是一个 Web 服务器；它也不是一种语言。它包含一个内置的
    HTTP 服务器库，这意味着你不需要运行像 NGINX、Apache 或 Internet Information Services (IIS) 这样的独立
    Web 服务器程序。这让你能够更好地控制 Web 服务器的工作方式，但也增加了将其启动和运行，尤其是在实时环境中的复杂性。
- en: With PHP, for example, you can easily find a shared-server web host running
    Apache and send some files over FTP, and—all being well—your site is running.
    This works because the web host has already configured Apache for you and others
    to use. With Node.js, this isn’t the case, because you configure the Node.js server
    when you create your application. Many of the traditional web hosts are behind
    the curve on Node.js support, but several new Platform as a Service (PaaS) hosts
    are springing up to address this need, including Heroku, Nodejitsu, and DigitalOcean.
    The approach to deploying live sites on these PaaS hosts is different from the
    old FTP model but easy when you get the hang of it. You’ll be deploying a site
    live to Heroku as you go through the book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 PHP，你可以轻松找到一个运行 Apache 的共享服务器 Web 主机，并通过 FTP 发送一些文件，如果一切顺利，你的网站就可以运行了。这是因为
    Web 主机已经为你和其他人配置了 Apache。但在 Node.js 中，情况并非如此，因为你在创建应用程序时配置 Node.js 服务器。许多传统的 Web
    主机在 Node.js 支持方面落后于时代，但有几家新的平台即服务（PaaS）主机正在涌现以满足这一需求，包括 Heroku、Nodejitsu 和 DigitalOcean。在这些
    PaaS 主机上部署实时网站的方法与旧的 FTP 模型不同，但一旦掌握了技巧，就会变得简单。当你阅读本书时，你将部署一个网站到 Heroku。
- en: An alternative approach to hosting a Node.js application is doing it yourself
    on a dedicated server or virtual server from a cloud provider like AWS or Azure,
    on which you can install anything you need. But production server administration
    is a topic for another book! And although you could independently swap out any
    of the other components with an alternative technology, if you take Node.js out,
    everything that sits on top of it changes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 托管 Node.js 应用程序的另一种方法是自己在专用服务器或云服务提供商（如 AWS 或 Azure）的虚拟服务器上自行操作，你可以在上面安装你需要的任何东西。但生产服务器管理是另一本书的主题！尽管你可以独立用替代技术替换任何其他组件，但如果移除
    Node.js，其上的一切都会改变。
- en: '1.2.1\. JavaScript: The single language through the stack'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. JavaScript：通过堆栈的单一种语言
- en: 'One of the main reasons why Node.js is gaining broad popularity is that you
    code it in a language that most web developers are already familiar with: JavaScript.
    Until Node was released, if you wanted to be a full-stack developer, you had to
    be proficient in at least two languages: JavaScript on the front end and something
    like PHP or Ruby on the back end.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 获得广泛流行的主要原因之一是你可以用大多数 Web 开发者已经熟悉的语言来编写它：JavaScript。在 Node 发布之前，如果你想成为一名全栈开发者，你必须至少精通两种语言：前端使用
    JavaScript，后端使用类似 PHP 或 Ruby 的语言。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Microsoft’s foray into server-side JavaScript**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**微软对服务器端 JavaScript 的探索**'
- en: In the late 1990s, Microsoft released Active Server Pages (now known as Classic
    ASP). ASP could be written in VBScript or JavaScript, but the JavaScript version
    didn’t take off, largely because at the time, a lot of people were familiar with
    Visual Basic, which VBScript looks like. Many books and online resources were
    for VBScript, so it snowballed into becoming the standard language for Classic
    ASP.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代后期，微软发布了 Active Server Pages（现在称为 Classic ASP）。ASP 可以用 VBScript 或 JavaScript
    编写，但 JavaScript 版本并没有流行起来，很大程度上是因为当时很多人熟悉 Visual Basic，而 VBScript 的外观与 Visual
    Basic 类似。许多书籍和在线资源都是针对 VBScript 的，因此它滚雪球般地成为了 Classic ASP 的标准语言。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With the release of Node.js, you can use what you already know and put it to
    use on the server. One of the hardest parts of learning a new technology like
    this is learning the language, but if you already know some JavaScript, you’re
    one step ahead!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Node.js 的发布，你可以使用你已知的技能并将其用于服务器。学习这种新技术中最困难的部分之一是学习语言，但如果你已经了解一些 JavaScript，你就已经领先一步了！
- en: There’s a learning curve when you’re taking on Node.js, even if you’re an experienced
    front-end JavaScript developer. The challenges and obstacles in server-side programming
    are different from those on the front end, but you’ll face those challenges no
    matter what technology you use. On the front end, you may be concerned about making
    sure that everything works in a variety of browsers on different devices. On the
    server, you’re more likely to be aware of the flow of the code to ensure that
    nothing gets held up and that you don’t waste system resources.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始学习 Node.js 时，即使你是一个经验丰富的前端 JavaScript 开发者，也会有一个学习曲线。服务器端编程的挑战和障碍与前端不同，但无论你使用什么技术，你都会面临这些挑战。在前端，你可能担心确保各种浏览器在不同设备上都能正常工作。在服务器端，你更可能会关注代码的流程，以确保没有任何东西被阻塞，并且你不会浪费系统资源。
- en: 1.2.2\. Fast, efficient, and scalable
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2. 快速、高效和可扩展
- en: Another reason for the popularity of Node.js is that, when coded correctly,
    it’s extremely fast and makes efficient use of system resources. These features
    enable a Node.js application to serve more users on fewer server resources than
    most of the other mainstream server technologies. Business owners also like the
    idea of Node.js because it can reduce their running costs, even at large scale.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 受欢迎的另一个原因是，当代码编写正确时，它非常快，并且能够高效地利用系统资源。这些特性使得 Node.js 应用程序能够在比其他主流服务器技术更少的资源上服务更多的用户。企业主也喜欢
    Node.js 的想法，因为它可以降低他们的运营成本，即使在大型规模下也是如此。
- en: How does Node.js do this? Node.js is light on system resources because it’s
    single-threaded, whereas traditional web servers are multithreaded. In the following
    sections, we’ll look at what those terms mean, starting with the traditional multithreaded
    approach.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是如何做到这一点的？Node.js 资源消耗轻，因为它采用单线程模式，而传统的网络服务器是多线程的。在接下来的章节中，我们将探讨这些术语的含义，从传统的多线程方法开始。
- en: Traditional multithreaded web server
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传统的多线程网络服务器
- en: Most of the current mainstream web servers are multithreaded, including Apache
    and IIS. What this means is that every new visitor (or session) is given a separate
    thread and associated amount of RAM, often around 8 MB.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的大多数主流网络服务器都是多线程的，包括 Apache 和 IIS。这意味着每个新的访客（或会话）都会被分配一个单独的线程和相应数量的 RAM，通常约为
    8 MB。
- en: Thinking of a real-world analogy, imagine two people going into a bank wanting
    to do separate things. In a multithreaded model, they’d each go to a separate
    bank teller who would deal with their requests, as shown in [figure 1.4](#ch01fig04).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个现实世界的类比，想象两个人进入银行想要做不同的事情。在多线程模型中，他们会各自去不同的柜员，柜员会处理他们的请求，如[图 1.4](#ch01fig04)所示。
- en: 'Figure 1.4\. Example of a multithreaded approach: Visitors use separate resources.
    Visitors and their dedicated resources have no awareness of or contact with other
    visitors and their resources.'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4. 多线程方法的示例：访客使用单独的资源。访客及其专用资源对其他访客及其资源没有意识或联系。
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: You can see in [figure 1.4](#ch01fig04) that Simon goes to bank teller 1, and
    Sally goes to bank teller 2\. Neither side is aware of or affected by the other.
    Bank teller 1 deals with Simon, and nobody else, throughout the entirety of the
    transaction; the same goes for bank teller 2 and Sally.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[图 1.4](#ch01fig04)中看到，西蒙去柜员 1，萨莉去柜员 2。双方都没有意识到或受到对方的影响。柜员 1 整个交易过程中只处理西蒙的事务；柜员
    2 和萨莉的情况也是如此。
- en: This approach works perfectly well as long as you have enough tellers to service
    the customers. When the bank gets busy and the customers outnumber the tellers,
    the service starts to slow and the customers have to wait to be seen. Although
    banks don’t always worry about this situation too much and seem happy to make
    you stand in line, the same isn’t true of websites. If a website is slow to respond,
    users are likely to leave and never come back.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有足够的柜员来服务客户，这种方法就非常有效。当银行变得繁忙，客户数量超过柜员时，服务开始变慢，客户必须等待才能得到服务。尽管银行并不总是过分担心这种情况，看起来也乐于让你排队，但网站的情况并非如此。如果一个网站响应缓慢，用户可能会离开并且再也不回来。
- en: This is one of the reasons why web servers are often overpowered and have so
    much RAM, even though they don’t need it 90% of the time. The hardware is set
    up in such a way as to be prepared for a huge spike in traffic. This setup is
    like the bank hiring an additional 50 full-time tellers and moving to a bigger
    building because it gets busy at lunchtime.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么即使90%的时间不需要，网络服务器通常也会过载并且拥有大量的RAM的原因之一。硬件的设置方式是为了应对流量激增。这种设置就像银行在午餐时间繁忙时雇佣额外的50名全职出纳员并搬到一个更大的建筑一样。
- en: Surely there’s a better way—a way that’s a bit more scalable. Here’s where the
    single-threaded approach comes in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一定有更好的方法——一种稍微更可扩展的方法。这就是单线程方法发挥作用的地方。
- en: Single-threaded web server
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单线程网络服务器
- en: A Node.js server is single-threaded and works differently from a multithreaded
    server. Rather than giving each visitor a unique thread and a separate silo of
    resources, the server has every visitor join the same thread. A visitor and thread
    interact only when necessary—when the visitor is requesting something or the thread
    is responding to a request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js服务器是单线程的，并且与多线程服务器的工作方式不同。服务器不是为每个访客提供一个唯一的线程和单独的资源隔离区，而是让每个访客加入同一个线程。访客和线程只在必要时交互——当访客请求某物或线程响应请求时。
- en: Returning to the bank-teller analogy, there’d be only one teller who deals with
    all the customers. But rather than taking on and managing all requests end to
    end, the teller delegates any time-consuming tasks to back-office staff and deals
    with the next request. [Figure 1.5](#ch01fig05) illustrates how this process might
    work, using the two requests from the multithreaded example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到银行出纳员的类比，只有一个出纳员处理所有客户。但出纳员不是从头到尾管理所有请求，而是将任何耗时任务委托给后台工作人员，并处理下一个请求。[图1.5](#ch01fig05)展示了这个流程可能如何工作，使用了多线程示例中的两个请求。
- en: 'Figure 1.5\. Example of a single-threaded approach: Visitors use the same central
    resource. The central resource must be well disciplined to prevent one visitor
    from affecting others.'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5。单线程方法示例：访客使用相同的中央资源。中央资源必须非常规范，以防止一个访客影响其他访客。
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05_alt.jpg)'
- en: In the single-threaded approach shown in [figure 1.5](#ch01fig05), Sally and
    Simon give their requests to the same bank teller. But instead of dealing with
    one of them exclusively before the next, the teller takes the first request and
    passes it to the best person to deal with it before taking the next request and
    doing the same thing. When the teller is told that a requested task is complete,
    the teller passes the result back to the visitor who made the request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在图1.5中展示的单线程方法中，萨利和西蒙将他们的请求提交给同一个银行出纳员。但出纳员不是在处理完一个请求后再处理下一个，而是先处理第一个请求，将其转交给最适合处理的人，然后再处理下一个请求并做同样的事情。当出纳员被告知请求的任务已完成时，出纳员将结果转回提出请求的访客。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Blocking vs. nonblocking code**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻塞与非阻塞代码**'
- en: With the single-threaded model, it’s important to remember that all of your
    users use the same central process. To keep the flow smooth, you need to make
    sure that nothing in your code causes a delay, blocking another operation. An
    example would be if the bank teller has to go to the safe to deposit the money
    for Simon, in which case Sally would have to wait to make her request.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程模型中，重要的是要记住，所有用户都使用相同的中央进程。为了保持流程顺畅，你需要确保代码中没有任何东西会导致延迟，从而阻塞其他操作。一个例子是，如果银行出纳员必须去保险柜存钱给西蒙，那么萨利就必须等待她的请求。
- en: Similarly, if your central process is responsible for reading each static file
    (such as CSS, JavaScript, or images), it won’t be able to process any other request,
    thus blocking the flow. Another common task that’s potentially blocking is interacting
    with a database. If your process is going to the database each time it’s asked,
    be it searching for data or saving data, it won’t be able to do anything else.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你的中央进程负责读取每个静态文件（如CSS、JavaScript或图像），它将无法处理任何其他请求，从而阻塞流程。另一个可能阻塞的常见任务是与数据库交互。如果你的进程每次被要求访问数据库时，无论是搜索数据还是保存数据，它将无法做其他任何事情。
- en: For the single-threaded approach to work, you must make sure that your code
    is nonblocking. The way to achieve this is to make any blocking operations run
    asynchronously, preventing them from blocking the flow of your main process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使单线程方法有效，你必须确保你的代码是非阻塞的。实现这一目标的方法是将任何阻塞操作异步执行，防止它们阻塞主进程的流程。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Despite there being a single teller, neither of the visitors is aware of the
    other, and neither is affected by the requests of the other. This approach means
    that the bank doesn’t need several tellers always on hand. This model isn’t infinitely
    scalable, of course, but it’s more efficient. You can do more with fewer resources.
    It doesn’t mean, however, that you’ll never need to add more resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只有一个出纳员，但两位访客都没有意识到对方的存在，也没有受到对方请求的影响。这种方法意味着银行不需要总是有多个出纳员在岗。当然，这种模式并不是无限可扩展的，但效率更高。您可以用更少的资源做更多的事情。但这并不意味着您永远不会需要添加更多资源。
- en: This particular approach is possible in Node.js due to the asynchronous capabilities
    of JavaScript, as you’ll see in action throughout the book. But if you’re not
    sure about the theory, check out [appendix D](kindle_split_041.xhtml#app04) (available
    online or in the e-book), particularly the section on callbacks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 的异步能力，这种特定方法在 Node.js 中是可行的，您将在本书的整个内容中看到其实际应用。但如果您对理论不太确定，请查看[附录
    D](kindle_split_041.xhtml#app04)（可在网上或电子书中找到），特别是关于回调的部分。
- en: 1.2.3\. Using prebuilt packages via npm
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 通过 npm 使用预构建的包
- en: A package manager, npm, gets installed when you install Node.js. npm gives you
    the ability to download Node.js modules or *packages* to extend the functionality
    of your application. Currently, more than 350,000 packages are available through
    npm, an indication of how much depth of knowledge and experience you can bring
    to an application. This figure is up from 46,000, when the first edition of *Getting
    MEAN* was written four years ago!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装 Node.js 时，会安装包管理器 npm。npm 使您能够下载 Node.js 模块或 *包* 来扩展您应用程序的功能。目前，通过 npm
    可用超过 350,000 个包，这表明您可以为应用程序带来多少知识和经验。这个数字比四年前 *Getting MEAN* 第一版编写时的 46,000 个有所增加！
- en: Packages in npm vary widely in what they give you. You’ll use some npm packages
    throughout this book to bring in an application framework and a database driver
    with schema support. Other examples include helper libraries such as Underscore,
    testing frameworks like Mocha, and utilities like Colors, which adds color support
    to Node.js console logs. You’ll look more closely at npm and how it works when
    you start building an application in [chapter 3](kindle_split_014.xhtml#ch03).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: npm 中的包在提供的内容上差异很大。您将在本书中使用一些 npm 包来引入具有模式支持的框架和数据库驱动程序。其他例子包括像 Underscore 这样的辅助库、像
    Mocha 这样的测试框架以及像 Colors 这样的实用工具，它为 Node.js 控制台日志添加了颜色支持。您将在第 3 章开始构建应用程序时更详细地了解
    npm 和它的工作方式。
- en: As you’ve seen, Node.js is extremely powerful and flexible, but it doesn’t give
    you much help when you’re trying to create a website or application. Express can
    give you a hand here. You install Express by using npm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Node.js 非常强大和灵活，但在您尝试创建网站或应用程序时，它并不提供太多帮助。Express 可以在这里为您提供帮助。您可以通过
    npm 安装 Express。
- en: '1.3\. Introducing Express: The framework'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 介绍 Express：框架
- en: Express is the *E* in *MEAN*. Because Node.js is a platform, it doesn’t prescribe
    how it should be set up or used, which is one of its great strengths. But every
    time you create websites and web applications, quite a few common tasks need doing.
    Express is a web application framework for Node.js that’s designed to perform
    these tasks in a well-tested, repeatable way.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是 *MEAN* 中的 *E*。因为 Node.js 是一个平台，它不规定应该如何设置或使用，这是它的一个巨大优势。但每次您创建网站和
    Web 应用程序时，都需要完成许多常见任务。Express 是一个为 Node.js 设计的 Web 应用程序框架，旨在以经过测试、可重复的方式执行这些任务。
- en: 1.3.1\. Easing your server setup
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 简化您的服务器设置
- en: As already noted, Node.js is a platform, not a server, which allows you to get
    creative with your server setup and do things that you can’t do with other web
    servers. It also makes getting a basic website up and running harder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Node.js 是一个平台，而不是服务器，这允许您在服务器设置方面发挥创意，做一些其他 Web 服务器无法做到的事情。这也使得建立一个基本的网站变得更加困难。
- en: Express abstracts away this difficulty by setting up a web server to listen
    to incoming requests and return relevant responses. In addition, it defines a
    directory structure. One folder is set up to serve static files in a nonblocking
    way; the last thing you want is for your application to have to wait when someone
    requests a CSS file! You could configure this yourself directly in Node.js, but
    Express does it for you.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Express 通过设置一个网络服务器来监听传入的请求并返回相关响应，从而抽象出这种困难。此外，它还定义了目录结构。一个文件夹被设置为以非阻塞方式提供静态文件；您最不希望的是当有人请求
    CSS 文件时，您的应用程序需要等待！您可以直接在 Node.js 中配置此设置，但 Express 会为您完成。
- en: 1.3.2\. Routing URLs to responses
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 将 URL 路由到响应
- en: One of the great features of Express is that it provides a simple interface
    for directing an incoming URL to a certain piece of code. Whether this interface
    will serve a static HTML page, read from a database, or write to a database doesn’t
    matter. The interface is simple and consistent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的一个伟大功能是它提供了一个简单的接口，可以将传入的 URL 指向特定的代码片段。无论这个接口是提供静态 HTML 页面、从数据库读取还是写入数据库，这都不重要。该接口简单且一致。
- en: Express abstracts away some of the complexity of creating a web server in native
    Node.js to make code quicker to write and easier to maintain.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Express 抽象了在原生 Node.js 中创建 Web 服务器的某些复杂性，以使代码更快编写且更容易维护。
- en: '1.3.3\. Views: HTML responses'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 视图：HTML 响应
- en: It’s likely that you’ll want to respond to many of the requests to your application
    by sending some HTML to the browser. By now, it will come as no surprise to you
    that Express makes this task easier than it is in native Node.js.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你将希望通过向浏览器发送一些 HTML 来响应你应用程序的许多请求。到目前为止，Express 使这项任务比在原生 Node.js 中更容易，这对你来说可能不会感到惊讶。
- en: Express provides support for many templating engines that make it easier to
    build HTML pages in an intelligent way, using reusable components as well as data
    from your application. Express compiles these together and serves them to the
    browser as HTML.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Express 提供了对许多模板引擎的支持，这使得使用可重用组件以及应用程序中的数据以智能方式构建 HTML 页面变得更加容易。Express 将这些组件编译在一起，并以
    HTML 的形式提供给浏览器。
- en: 1.3.4\. Remembering visitors with session support
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4\. 使用会话支持记住访客
- en: Being single-threaded, Node.js doesn’t remember a visitor from one request to
    the next. It doesn’t have a silo of RAM set aside for you; it sees only a series
    of HTTP requests. HTTP is a stateless protocol, so there’s no concept of storing
    a session state. As it stands, it’s difficult to create a personalized experience
    in Node.js or have a secure area where a user has to log in; it’s not much use
    if the site forgets who you are on every page. You can do it, of course, but you
    have to code it yourself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 是单线程的，它不会记住一个请求到下一个请求的访问者。它没有为用户预留的 RAM 隔离区；它只看到一系列 HTTP 请求。HTTP
    是一种无状态协议，因此没有存储会话状态的概念。目前，在 Node.js 中创建个性化的体验或拥有一个用户必须登录的安全区域都很难；如果网站在每一页都忘记你是谁，那就没什么用了。当然，你可以做到这一点，但你必须自己编写代码。
- en: 'You’ll never guess what: Express has an answer to this problem too! Express
    can use *sessions* so that you can identify individual visitors through multiple
    requests and pages. Thank you, Express!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远猜不到：Express 对这个问题也有解决方案！Express 可以使用 *会话* 来识别通过多个请求和页面访问的个别访客。感谢 Express！
- en: Sitting on top of Node.js, Express gives you a great helping hand and a sound
    starting point for building web applications. It abstracts away many complexities
    and repeatable tasks that most of us don’t need—or want—to worry about. We only
    want to build web applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在 Node.js 之上，Express 为构建 Web 应用程序提供了极大的帮助和稳固的起点。它抽象了许多我们大多数人不需要或不想担心的复杂性和重复性任务。我们只想构建
    Web 应用程序。
- en: '1.4\. Introducing MongoDB: The database'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 介绍 MongoDB：数据库
- en: The ability to store and use data is vital for most applications. In the MEAN
    stack, the database of choice is MongoDB, the *M* in *MEAN*. MongoDB fits into
    the stack incredibly well. Like Node.js, it’s renowned for being fast and scalable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和使用数据的能力对于大多数应用程序至关重要。在 MEAN 堆栈中，首选的数据库是 MongoDB，即 *MEAN* 中的 *M*。MongoDB 与堆栈结合得非常好。像
    Node.js 一样，它以其快速和可扩展性而闻名。
- en: 1.4.1\. Relational databases vs. document stores
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 关系型数据库与文档存储
- en: If you’ve used a relational database before, or even a spreadsheet, you’ll be
    used to the concepts of columns and rows. Typically, a column defines the name
    and data type, and each row is a different entry. See [table 1.1](#ch01table01)
    for an example.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过关系型数据库，或者甚至使用过电子表格，你将熟悉列和行的概念。通常，列定义了名称和数据类型，而每一行是不同的条目。参见 [表 1.1](#ch01table01)
    以获取示例。
- en: Table 1.1\. An example of rows and columns in a relational database table
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1\. 关系型数据库表中的行和列示例
- en: '| firstName | middleName | lastName | maidenName | nickname |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| firstName | middleName | lastName | maidenName | nickname |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Simon | David | Holmes |   | Si |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Simon | David | Holmes |   | Si |'
- en: '| Sally | June | Panayiotou |   |   |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Sally | June | Panayiotou |   |   |'
- en: '| Rebecca |   | Norman | Holmes | Bec |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Rebecca |   | Norman | Holmes | Bec |'
- en: MongoDB is *not* like that! MongoDB is a document store. The concept of rows
    still exists, but columns are removed from the picture. Rather than a column defining
    what should be in the row, each row is a document, and this document both defines
    and holds the data itself. [Table 1.2](#ch01table02) shows how a collection of
    documents might be listed. (The indented layout is for readability, not a visualization
    of columns.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 并非如此！MongoDB 是一个文档存储。行的概念仍然存在，但列从图中移除。不是列定义了行中应该有什么，而是每一行都是一个文档，这个文档既定义又持有数据本身。[表
    1.2](#ch01table02) 展示了文档集合可能如何列出。（缩进布局是为了可读性，而不是列的可视化。）
- en: Table 1.2\. Each document in a document database defines and holds the data,
    in no particular order.
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.2\. 文档数据库中的每个文档都定义并持有数据，没有特定的顺序。
- en: '| firstName: "Simon" | middleName: "David" | lastName: "Holmes" | nickname:
    "Si" |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 名字: "Simon" | 中间名: "David" | 姓氏: "Holmes" | 昵称: "Si" |'
- en: '| lastName: "Panayiotou" | middleName: "June" | firstName: "Sally" |   |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 姓氏: "Panayiotou" | 中间名: "June" | 名字: "Sally" |   |'
- en: '| maidenName: "Holmes" | firstName: "Rebecca" | lastName: "Norman" | nickname:
    "Bec" |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 姓氏: "Holmes" | 名字: "Rebecca" | 姓氏: "Norman" | 昵称: "Bec" |'
- en: This less-structured approach means that a collection of documents could have
    a wide variety of data inside. In the next section, you’ll look at a sample document
    to get a better idea of what we’re talking about.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不太结构化的方法意味着文档集合内部可能包含各种类型的数据。在下一节中，你将查看一个示例文档，以更好地了解我们所说的内容。
- en: '1.4.2\. MongoDB documents: JavaScript data store'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. MongoDB 文档：JavaScript 数据存储
- en: MongoDB stores documents as BSON, which is binary JSON (JavaScript Serialized
    Object Notation). Don’t worry for now if you’re not fully familiar with JSON;
    check out the relevant section in [appendix D](kindle_split_041.xhtml#app04).
    In short, JSON is a JavaScript way of holding data, which is why MongoDB fits
    so well into the JavaScript-centric MEAN stack!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 以 BSON 格式存储文档，即二进制 JSON（JavaScript 序列化对象表示法）。现在如果你对 JSON 不太熟悉，不用担心；请查看附录
    D 中相关的部分。[附录 D](kindle_split_041.xhtml#app04)。简而言之，JSON 是一种 JavaScript 存储数据的方式，这也是为什么
    MongoDB 与以 JavaScript 为中心的 MEAN 栈如此契合！
- en: 'The following code snippet shows a simple example MongoDB document:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 MongoDB 文档的一个简单示例：
- en: '[PRE0]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even if you don’t know JSON well, you can probably see that this document stores
    the first and last names of Simon Holmes. Rather than a document holding a data
    set that corresponds to a set of columns, a document holds name/value pairs, which
    makes a document useful in its own right because it both describes and defines
    the data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对 JSON 不太了解，你可能也能看出这个文档存储了西蒙·霍姆斯的姓名。与一个文档持有与一组列相对应的数据集不同，一个文档持有名称/值对，这使得文档本身非常有用，因为它既描述又定义了数据。
- en: 'A quick word about _`id`: You most likely noticed the _`id` entry alongside
    the names in the preceding example MongoDB document. The _`id` entity is a unique
    identifier that MongoDB assigns to any new document when it’s created.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 _`id`_ 的一句快速说明：你很可能注意到了前面示例 MongoDB 文档中与名称并列的 _`id`_ 条目。_`id`_ 实体是 MongoDB
    在创建新文档时分配给任何新文档的唯一标识符。
- en: You’ll look at MongoDB documents in more detail in [chapter 5](kindle_split_016.xhtml#ch05),
    when you start to add data to your application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在应用程序中添加数据时，你将在[第 5 章](kindle_split_016.xhtml#ch05)中更详细地了解 MongoDB 文档。
- en: 1.4.3\. More than just a document database
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 不仅仅是文档数据库
- en: MongoDB sets itself apart from many other document databases with its support
    for secondary indexing and rich queries. You can create indexes on more than the
    unique identifier field, and querying indexed fields is much faster. You can also
    create some fairly complex queries against a MongoDB database—not to the level
    of huge SQL commands with joins all over the place, but powerful enough for most
    use cases.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 通过其对二级索引和丰富查询的支持，将自己与其他许多文档数据库区分开来。你可以在除了唯一标识符字段之外的地方创建索引，并且查询索引字段要快得多。你还可以对
    MongoDB 数据库创建一些相当复杂的查询——虽然不是像到处都有连接的巨大 SQL 命令那样，但对于大多数用例来说已经足够强大。
- en: As you build an application through the course of this book, you’ll get to have
    some fun with MongoDB and start to appreciate exactly what it can do.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你阅读本书的过程中构建应用程序时，你将有机会与 MongoDB 一起享受乐趣，并开始真正欣赏它所能做到的事情。
- en: 1.4.4\. What is MongoDB not good for?
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. MongoDB 不擅长什么？
- en: As of version 4, there’s little that a traditional RDBMS can do that MongoDB
    can’t, beyond the obvious differences we’ve already discussed. One of the biggest
    issues in earlier versions of MongoDB was lack of transaction support. MongoDB
    4, the version used in this book, has the capability to perform multidocument
    transactions with ACID (atomicity, consistency, isolation, durability) guarantees.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 4.0 版本，传统的 RDBMS 几乎无法做到 MongoDB 能做到的事情，除了我们已经讨论过的明显差异之外。MongoDB 早期版本中最大的问题之一是缺乏事务支持。本书使用的
    MongoDB 4 版本具有执行具有 ACID（原子性、一致性、隔离性、持久性）保证的多文档事务的能力。
- en: 1.4.5\. Mongoose for data modeling and more
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5. Mongoose 用于数据建模及其他
- en: MongoDB’s flexibility in what it stores in documents is a great thing for the
    database. But most applications need some structure to their data. Note that the
    *application* needs structure, not the database. So where does it make most sense
    to define the structure of your application data? In the application itself!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在文档中存储数据的灵活性对数据库来说是一件好事。但大多数应用程序需要其数据有一定的结构。请注意，*应用程序* 需要结构，而不是数据库。那么在哪里定义应用程序数据结构最有意义呢？在应用程序本身中！
- en: To this end, the company behind MongoDB created Mongoose. In the company’s words,
    Mongoose provides “elegant MongoDB object modeling for Node.js” ([https://mongoosejs.com](https://mongoosejs.com)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MongoDB 背后的公司创建了 Mongoose。用公司的话说，Mongoose 提供“优雅的 MongoDB 对象建模，适用于 Node.js”([https://mongoosejs.com](https://mongoosejs.com))。
- en: What is data modeling?
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是数据建模？
- en: Data modeling, in the context of Mongoose and MongoDB, defines what data *can*
    be in a document and what data *must* be in a document. When storing user information,
    you may want to be able to save the first name, last name, email address, and
    phone number. But you *need* only the first name and email address, and the email
    address must be unique. This information is defined in a *schema*, which is used
    as the basis for the data model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mongoose 和 MongoDB 的背景下，数据建模定义了文档中可以存储的数据以及必须存储的数据。当存储用户信息时，你可能希望能够保存姓氏、名字、电子邮件地址和电话号码。但你只需要姓氏和电子邮件地址，并且电子邮件地址必须是唯一的。这些信息在
    *模式* 中定义，该模式用作数据模型的基础。
- en: What else does Mongoose offer?
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mongoose 还提供了什么？
- en: As well as modeling data, Mongoose adds an entire layer of features on top of
    MongoDB that are useful for building web applications. Mongoose makes it easier
    to manage the connections to your MongoDB database and to save and read data.
    You’ll use all of these features later. Also later in the book, we’ll discuss
    how Mongoose enables you to add data validation at the schema level, making sure
    that you allow only valid data to be saved in the database.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了建模数据之外，Mongoose 在 MongoDB 上添加了一层完整的特性，这些特性对于构建 Web 应用程序非常有用。Mongoose 使得管理对
    MongoDB 数据库的连接以及保存和读取数据变得更加容易。你将在后面的内容中使用所有这些特性。本书后面还将讨论 Mongoose 如何使你能够在模式级别添加数据验证，确保只允许有效数据被保存到数据库中。
- en: MongoDB is a great choice of database for most web applications, because it
    provides a balance between the speed of pure document databases and the power
    of relational databases. The data is effectively stored in JSON, which makes it
    the perfect data store for the MEAN stack.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是大多数 Web 应用程序的理想数据库选择，因为它在纯文档数据库的速度和关系数据库的强大功能之间提供了平衡。数据以 JSON 格式有效存储，这使得它成为
    MEAN 栈的完美数据存储。
- en: '[Figure 1.6](#ch01fig06) shows some of the highlights of Mongoose and how it
    fits between the database and the application.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.6](#ch01fig06) 展示了 Mongoose 的亮点以及它是如何位于数据库和应用之间的。'
- en: Figure 1.6\. Mongoose fits between the database and the application, providing
    an easy-to-use interface (object models) and access to other functionality, such
    as validation.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6. Mongoose 位于数据库和应用之间，提供了一个易于使用的接口（对象模型）以及访问其他功能，如验证。
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.6](Images/01fig06_alt.jpg)'
- en: '1.5\. Introducing Angular: The front-end framework'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 介绍 Angular：前端框架
- en: Angular is the *A* in *MEAN*. In simple terms, Angular is a JavaScript framework
    for creating the interface for your website or application. In this book, you’ll
    be working with Angular 7, which is the most recently available version. All previous
    versions have been deprecated, and the online documentation no longer applies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是 *MEAN* 中的 *A*。简单来说，Angular 是一个用于创建网站或应用程序界面的 JavaScript 框架。在本书中，你将使用
    Angular 7，这是最近可用的版本。所有之前的版本都已弃用，在线文档不再适用。
- en: You could use Node.js, Express, and MongoDB to build a fully functioning, data-driven
    web application, and you’ll do that in this book. But you can put some icing on
    the cake by adding Angular to the stack.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Node.js、Express 和 MongoDB 来构建一个完全功能的数据驱动型网络应用程序，你将在本书中这样做。但你可以通过添加 Angular
    到这个堆栈来锦上添花。
- en: The traditional way of doing things is to have all data processing and application
    logic on the server, which then passes HTML to the browser. Angular enables you
    to move some or all of this processing and logic to the browser, often leaving
    the server passing data from the database. We’ll take a look at this process in
    a moment when we discuss data binding, but first, we need to address the question
    of whether Angular is like jQuery, the leading front-end JavaScript library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方法是将所有数据处理和应用程序逻辑放在服务器上，然后服务器将 HTML 传递给浏览器。Angular 允许你将一些或所有这些处理和逻辑移动到浏览器，通常让服务器从数据库传递数据。我们将在讨论数据绑定时讨论这个过程，但首先，我们需要解决
    Angular 是否像 jQuery（领先的客户端 JavaScript 库）这样的问题。
- en: 1.5.1\. jQuery vs. Angular
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1. jQuery 与 Angular 的比较
- en: If you’re familiar with jQuery, you may be wondering whether Angular works the
    same way. The short answer is no, not really. jQuery is generally added to a page
    to provide interactivity after the HTML has been sent to the browser and the Document
    Object Model (DOM) has completely loaded. Angular comes in a step earlier, building
    the HTML from templates, based on the data provided.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 jQuery，可能会想知道 Angular 是否以相同的方式工作。简短的答案是：不，实际上不是。jQuery 通常是在 HTML 发送到浏览器并且文档对象模型（DOM）完全加载后添加到页面上的，以提供交互性。Angular
    在这一步之前介入，根据提供的数据从模板构建 HTML。
- en: Also, jQuery is a library and as such has a collection of features that you
    can use as you wish. Angular is known as an *opinionated framework*, which means
    that it forces its opinion on you as to how it needs to be used. It also abstracts
    away some of the underlying complexity, simplifying the development experience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，jQuery 是一个库，因此它有一系列你可以按需使用的功能。Angular 被称为一个*有偏见的框架*，这意味着它强迫你按照它认为的方式使用。它还抽象了一些底层复杂性，简化了开发体验。
- en: 'As mentioned earlier, Angular helps put the HTML together based on the data
    provided, but it does more: it also immediately updates the HTML if the data changes
    and can update the data if the HTML changes. This feature is known as *two-way
    data binding*, which we’ll take a quick look at in the next section.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Angular 帮助根据提供的数据组合 HTML，但它还做了更多：如果数据发生变化，它会立即更新 HTML；如果 HTML 发生变化，它还可以更新数据。这个特性被称为*双向数据绑定*，我们将在下一节中简要介绍。
- en: '1.5.2\. Two-way data binding: Working with data in a page'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2. 双向数据绑定：在页面中处理数据
- en: 'To understand two-way data binding, consider a simple example. Compare this
    approach with traditional one-way data binding. Imagine that you have a web page
    and some data, and you want to do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解双向数据绑定，可以考虑一个简单的例子。将这种方法与传统单向数据绑定进行比较。想象你有一个网页和一些数据，你想要做以下事情：
- en: Display that data as a list to the user
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该数据以列表形式显示给用户
- en: Allow the user to filter that list by inputting text into a form field
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户通过在表单字段中输入文本来过滤该列表
- en: In both approaches—one-way and two-way binding—step 1 is similar. You use the
    data to generate some HTML markup for the end user to see. Step 2 is where things
    get a bit different.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种方法——单向和双向绑定——中，第一步是相似的。你使用数据为最终用户生成一些 HTML 标记。第二步是事情变得有点不同的地方。
- en: In step 2, you want to let the user enter some text in a form field to filter
    the list of data being displayed. With one-way data binding, you have to add event
    listeners to the form input field manually to capture the data and update the
    data model (to ultimately change what’s displayed to the user).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，你希望让用户在表单字段中输入一些文本以过滤显示的数据列表。使用单向数据绑定，你必须手动添加事件监听器到表单输入字段以捕获数据并更新数据模型（最终改变显示给用户的内容）。
- en: With two-way data binding, any updates to the form can be captured automatically,
    updating the model and changing what’s displayed to the user. This capability
    may not sound like a big deal, but to understand its power, it’s good to know
    that with Angular, you can achieve everything in steps 1 and 2 without writing
    a single line of JavaScript code! That’s right—it’s all done with Angular’s two-way
    data binding ... and a bit of help from some other Angular features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双向数据绑定，可以自动捕获表单的任何更新，更新模型并更改向用户显示的内容。这种功能可能听起来并不重要，但要理解其强大之处，了解使用Angular，你可以在步骤1和2中实现所有功能，而无需编写任何JavaScript代码！没错——这一切都是通过Angular的双向数据绑定...以及一些其他Angular功能的帮助来完成的。
- en: As you go through [part 3](kindle_split_019.xhtml#part03) of the book, you’ll
    get to see—and use—this in action. Seeing is believing with this feature, and
    you won’t be disappointed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这本书的[第3部分](kindle_split_019.xhtml#part03)时，你将看到——并使用——这一功能在实际中的应用。这个特性是“眼见为实”，你不会失望的。
- en: 1.5.3\. Using Angular to load new pages
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.3\. 使用Angular加载新页面
- en: One thing that Angular was specifically designed for is *single-page application*
    (SPA) functionality. In real terms, an SPA runs everything inside the browser
    and never does a full page reload. All application logic, data processing, user
    flow, and template delivery can be managed in the browser.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Angular特别设计用于的功能之一是*单页应用程序*（SPA）功能。实际上，SPA在浏览器内部运行所有内容，并且永远不会进行完整的页面刷新。所有应用程序逻辑、数据处理、用户流程和模板交付都可以在浏览器中管理。
- en: Think Gmail. That’s an SPA. Different views get shown in the page, along with
    a variety of data sets, but the page itself never fully reloads.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以Gmail为例。那是一个SPA。页面会显示不同的视图，以及各种数据集，但页面本身永远不会完全刷新。
- en: This approach can reduce the amount of resources you need on your server, because
    you’re essentially crowdsourcing the computational power. Each person’s browser
    is doing the hard work; your server is serving up static files and data on request.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以减少你在服务器上需要的资源量，因为你实际上是在众包计算能力。每个人的浏览器都在做艰苦的工作；你的服务器在请求时提供静态文件和数据。
- en: The user experience can also be better under this approach. After the application
    is loaded, fewer calls are made to the server, reducing the potential of latency.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法下，用户体验也可以得到改善。在应用程序加载后，对服务器的调用次数减少，减少了延迟的可能性。
- en: All this sounds great, but surely there’s a price to pay. Why isn’t everything
    built into Angular?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些听起来都很棒，但肯定要付出代价。为什么不是所有东西都集成到Angular中？
- en: 1.5.4\. Are there any downsides?
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.4\. 有任何缺点吗？
- en: Despite its many benefits, Angular isn’t appropriate for every website. Front-end
    libraries like jQuery are best used for progressive enhancement. The idea is that
    your site will function perfectly well without JavaScript, and the JavaScript
    you use makes the experience better. That isn’t the case with Angular or indeed
    with any other SPA framework. Angular uses JavaScript to build the rendered HTML
    from templates and data, so if your browser doesn’t support JavaScript or there’s
    a bug in the code, the site won’t run.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular有许多优点，但它并不适合每个网站。像jQuery这样的前端库最适合用于渐进增强。想法是，你的网站在没有JavaScript的情况下也能完美运行，你使用的JavaScript可以让体验变得更好。Angular或任何其他SPA框架都不是这样。Angular使用JavaScript从模板和数据构建渲染的HTML，所以如果你的浏览器不支持JavaScript或代码中存在错误，网站将无法运行。
- en: This reliance on JavaScript to build the page also causes problems with search
    engines. When a search engine crawls your site, it won’t run all JavaScript; with
    Angular, the only thing you get before JavaScript takes over is the base template
    from the server. If you want to be 100% certain that your content and data are
    indexed by search engines rather than only your templates, you need to think about
    whether Angular is right for that project.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖于JavaScript来构建页面的做法也导致搜索引擎出现问题。当搜索引擎爬取你的网站时，它不会运行所有JavaScript；在Angular中，在JavaScript接管之前，你只能得到服务器上的基本模板。如果你想确保你的内容和数据被搜索引擎索引，而不是只有你的模板，你需要考虑Angular是否适合那个项目。
- en: 'You have ways to combat this issue: in short, you need your server to output
    compiled content as well as Angular. But, if you don’t *need* to fight this battle,
    we recommend against doing so.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你有方法来应对这个问题：简而言之，你需要你的服务器输出编译后的内容以及Angular。但是，如果你*不需要*战斗这场战斗，我们建议不要这样做。
- en: One thing you can do is use Angular for some things and not others. There’s
    nothing wrong with using Angular selectively in your project. You might have a
    data-rich interactive application or section of your site that’s ideal for building
    in Angular, for example. Or you might have a blog or some marketing pages around
    your application. These elements don’t need to be built in Angular and arguably
    would be better served from the server in the traditional way. So part of your
    site is served by Node.js, Express, and MongoDB, and another part also has Angular
    doing its thing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的事情之一是，对于某些事情使用 Angular，而对于其他事情则不使用。在你的项目中选择性使用 Angular 没有什么问题。例如，你可能有一个数据丰富的交互式应用或网站的部分，非常适合在
    Angular 中构建。或者你可能有一个围绕你的应用的博客或一些营销页面。这些元素不需要在 Angular 中构建，并且从服务器以传统方式提供可能更好。因此，你的网站的一部分由
    Node.js、Express 和 MongoDB 提供，而另一部分也由 Angular 执行其功能。
- en: This flexible approach is one of the most powerful aspects of the MEAN stack.
    With one stack, you can achieve a great many things so long as you remember to
    be flexible in your thinking and don’t think of the MEAN stack as being a single
    architecture stack.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活的方法是 MEAN 栈最强大的特性之一。只要你在思考时保持灵活性，不要将 MEAN 栈视为单一的架构栈，你就可以通过一个栈实现许多事情。
- en: Things are improving, though. Web-crawling technologies, particularly those
    employed by Google, are becoming ever more capable, and this issue is quickly
    becoming part of the past.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，情况正在改善。网络爬虫技术，尤其是谷歌使用的那些，变得越来越强大，这个问题很快就会成为过去式。
- en: 1.5.5\. Developing in TypeScript
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.5\. 使用 TypeScript 进行开发
- en: Angular applications can be written in many flavors of JavaScript, including
    ES5, ES2015+, and Dart. But the most popular by far is TypeScript.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用可以编写多种 JavaScript 风格，包括 ES5、ES2015+ 和 Dart。但最受欢迎的无疑是 TypeScript。
- en: 'TypeScript is a superset of JavaScript, meaning that it *is* JavaScript, but
    with added features. In this book, you’ll use TypeScript to build the Angular
    part of your application. But don’t worry: we’ll start from the ground up in [part
    3](kindle_split_019.xhtml#part03) and cover the parts of TypeScript you need to
    know.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是 JavaScript 的超集，这意味着它*就是*JavaScript，但增加了额外的功能。在这本书中，你将使用 TypeScript
    来构建应用的 Angular 部分。但别担心：我们将从头开始，在[第 3 部分](kindle_split_019.xhtml#part03)中介绍你需要了解的
    TypeScript 部分。
- en: 1.6\. Supporting cast
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 支持角色
- en: The MEAN stack gives you everything you need to create data-rich interactive
    web applications, but you may want to use a few extra technologies to help you
    along the way. You can use Twitter Bootstrap to create a good user interface,
    Git to help manage your code, and Heroku to help by hosting the application on
    a live URL, for example. In later chapters, we’ll look at incorporating these
    technologies into the MEAN stack. In this section, we’ll cover briefly what each
    one can do for you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: MEAN 栈为你提供了创建数据丰富的交互式网络应用所需的一切，但你可能还想使用一些额外的技术来帮助你。例如，你可以使用 Twitter Bootstrap
    来创建良好的用户界面，使用 Git 来帮助管理你的代码，以及使用 Heroku 来通过托管应用在实时 URL 上提供帮助。在后面的章节中，我们将探讨将这些技术整合到
    MEAN 栈中。在本节中，我们将简要介绍每个技术能为你做什么。
- en: 1.6.1\. Twitter Bootstrap for user interface
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1\. Twitter Bootstrap 用于用户界面
- en: In this book, you’re going to use Twitter Bootstrap to create a responsive design
    with minimal effort. It’s not essential for the stack, and if you’re building
    an application from existing HTML or a specific design, you probably won’t want
    to add it. But in this book, you’ll build an application in a *rapid prototype*
    style, going from idea to application with no external influences.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将使用 Twitter Bootstrap 以最小的努力创建响应式设计。它对于栈来说不是必需的，如果你正在构建一个基于现有 HTML 或特定设计的应用，你可能不想添加它。但在这本书中，你将以*快速原型*风格构建一个应用，从想法到应用，没有任何外部影响。
- en: Bootstrap is a front-end framework that provides a wealth of help for creating
    a great user interface. Among its features, Bootstrap provides a responsive grid
    system, default styles for many interface components, and the ability to change
    the visual appearance with themes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个前端框架，它为创建出色的用户界面提供了丰富的帮助。在其特性中，Bootstrap 提供了一个响应式网格系统、许多界面组件的默认样式，以及通过主题改变视觉外观的能力。
- en: Responsive grid layout
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 响应式网格布局
- en: In a responsive layout, you serve up a single HTML page that arranges itself
    differently on different devices by detecting the screen resolution rather than
    trying to sniff out the actual device. Bootstrap targets four different pixel-width
    breakpoints for their layouts, loosely aimed at phones, tablets, laptops, and
    external monitors. If you give a bit of thought to how you set up your HTML and
    CSS classes, you can use one HTML file to offer the same content in different
    layouts suited to screen size.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式布局中，你提供一个HTML页面，通过检测屏幕分辨率而不是尝试检测实际设备来在不同设备上以不同的方式排列自己。Bootstrap针对四种不同的像素宽度断点进行布局，大致针对手机、平板电脑、笔记本电脑和外接显示器。如果你稍微考虑一下如何设置你的HTML和CSS类，你可以使用一个HTML文件在不同的布局中提供相同的内容，以适应屏幕大小。
- en: CSS classes and HTML components
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CSS类和HTML组件
- en: Bootstrap comes with a set of predefined CSS classes that can create useful
    visual components, such as page headers, alert-message containers, labels and
    badges, and stylized lists. The creators of Bootstrap put a lot of thought into
    the framework. Bootstrap helps you build an application quickly without having
    to spend too much time on the HTML layout and CSS styling.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap附带一系列预定义的CSS类，可以创建有用的视觉组件，例如页面标题、警告信息容器、标签和徽章，以及风格化的列表。Bootstrap的制作者在框架上投入了大量的思考。Bootstrap可以帮助你快速构建应用程序，无需花费太多时间在HTML布局和CSS样式上。
- en: Teaching Bootstrap isn’t an aim of this book, but we’ll point out various features
    as you use them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 教学Bootstrap不是本书的目标，但我们会在你使用时指出各种功能。
- en: Adding themes for a different feel
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加不同的主题以改变感觉
- en: Bootstrap has a default look and feel that provides a neat baseline, and it’s
    so commonly used that your site could end up looking like anybody else’s. Fortunately,
    you can download themes for Bootstrap to give your application a different twist.
    Downloading a theme is often as simple as replacing the Bootstrap CSS file with
    a new one. You’ll use a free theme in this book to build your application, but
    it’s also possible to buy premium themes from several websites to give an application
    a unique feel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap有一个默认的外观和感觉，提供了一个整洁的基线，并且由于其广泛的使用，你的网站可能会看起来像任何其他人的。幸运的是，你可以下载Bootstrap的主题来给你的应用程序带来不同的风格。下载主题通常只是用新的CSS文件替换Bootstrap
    CSS文件。你将在本书中使用免费的主题来构建你的应用程序，但也可以从多个网站购买高级主题，以给应用程序带来独特的风格。
- en: 1.6.2\. Git for source control
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2\. Git用于源代码控制
- en: Saving code on your computer or a network drive is all very well and good, but
    a computer or network drive holds only the current version and lets only you (or
    other users on your network) access it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机或网络驱动器上保存代码是非常好和有用的，但计算机或网络驱动器只保存当前版本，并且只允许你（或你网络上的其他用户）访问它。
- en: Git is a distributed revision control and source code management system that
    allows several people to work on the same codebase at the same time on different
    computers and networks. These can be pushed together, with all changes stored
    and recorded. It’s also possible to roll back to an earlier state if necessary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个分布式版本控制和源代码管理系统，允许多个人在不同的计算机和网络上的同一代码库上同时工作。这些可以一起推送，所有更改都存储并记录。如果需要，还可以回滚到早期状态。
- en: How to use Git
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何使用Git
- en: Git is typically used from the command line, although GUIs are available for
    Windows, Linux, and Mac. Throughout this book, you’ll use command-line statements
    to issue the commands that you need. Git is powerful, and we’ll scratch the surface
    of it in this book, but everything we do will be provided as part of the examples.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Git通常从命令行使用，尽管Windows、Linux和Mac都有GUI。在这本书的整个过程中，你将使用命令行语句来发出所需的命令。Git功能强大，我们将在本书中触及它的表面，但我们所做的一切都将作为示例的一部分提供。
- en: In a typical Git setup, you have a local repository on your machine and a remote
    centralized master repository hosted somewhere like GitHub or Bitbucket. You can
    pull from the remote repository into your local one or push from local to remote.
    All these tasks are easy to perform from the command line, and GitHub and Bitbucket
    have web interfaces so that you can visually keep track of everything you’ve committed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的Git设置中，你在你的机器上有一个本地仓库，并在GitHub或Bitbucket等地方托管一个远程集中式主仓库。你可以从远程仓库拉取到本地仓库，或者从本地推送到远程。所有这些任务都可以从命令行轻松执行，GitHub和Bitbucket都有网络界面，这样你可以直观地跟踪你所提交的一切。
- en: What is Git used for here?
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 这里Git的用途是什么？
- en: 'In this book, you’ll use Git for two reasons:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将使用Git的两个原因：
- en: The source code of the sample application in this book will be stored on GitHub,
    with different branches for various milestones. You’ll be able to clone the master
    or the separate branches to use the code.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中的示例应用程序的源代码将存储在 GitHub 上，不同分支对应不同的里程碑。你将能够克隆主分支或单独的分支来使用代码。
- en: You’ll use Git as the method of deploying your application to a live web server
    for the world to see. For hosting, you’ll use Heroku.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将使用 Git 作为将你的应用程序部署到全球可见的实时服务器的方法。对于托管，你将使用 Heroku。
- en: 1.6.3\. Hosting with Heroku
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.3. 使用 Heroku 托管
- en: Hosting Node.js applications can be complicated, but it doesn’t have to be.
    Many traditional shared hosting providers haven’t kept up with the interest in
    Node.js. Some providers install it for you so that you can run applications, but
    the servers generally aren’t set up to meet the unique needs of Node.js. To run
    a Node.js application successfully, you need a server that has been configured
    with it in mind, or you can use a PaaS provider that’s specifically designed for
    hosting Node.js.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 托管 Node.js 应用程序可能很复杂，但并不一定如此。许多传统的共享托管提供商没有跟上 Node.js 的兴趣。一些提供商为你安装它，这样你就可以运行应用程序，但服务器通常没有针对
    Node.js 的独特需求进行设置。要成功运行 Node.js 应用程序，你需要一个针对 Node.js 进行配置的服务器，或者你可以使用专门为托管 Node.js
    设计的 PaaS 提供商。
- en: In this book, you’ll take the latter approach. You’ll use Heroku ([https://www.heroku.com](https://www.heroku.com))
    as your hosting provider. Heroku is one of the leading hosts of Node.js applications
    and it has an excellent free tier that you’ll make use of.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将采取后一种方法。你将使用 Heroku ([https://www.heroku.com](https://www.heroku.com))
    作为你的托管提供商。Heroku 是 Node.js 应用程序的主要托管商之一，它提供了一个出色的免费层，你将利用这个免费层。
- en: 'Applications on Heroku are essentially Git repositories, making the publishing
    process incredibly simple. After everything is set up, you can publish your application
    to a live environment by using a single command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Heroku 上的应用程序本质上都是 Git 仓库，这使得发布过程变得极其简单。在一切设置完成后，你可以使用单个命令将你的应用程序发布到实时环境：
- en: '[PRE1]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 1.7\. Putting it together with a practical example
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7. 将其实践示例整合起来
- en: As we’ve already mentioned a few times, throughout the course of this book,
    you’ll build a working application on the MEAN stack. This process will give you
    a good grounding in each of the technologies and show you how they fit together.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经多次提到的，在这本书的过程中，你将在 MEAN 栈上构建一个工作应用程序。这个过程将使你对每种技术都有很好的了解，并展示它们是如何结合在一起的。
- en: 1.7.1\. Introducing the example application
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.1. 介绍示例应用程序
- en: So what are you going to be building as you go through the book? You’ll be building
    an application called Loc8r. Loc8r lists nearby places with Wi-Fi where people
    can go to get some work done. It also displays facilities, opening times, a rating,
    and a location map for each place. Users will be able to log in and submit ratings
    and reviews.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在你阅读本书的过程中，你将构建什么？你将构建一个名为 Loc8r 的应用程序。Loc8r 列出附近的带有 Wi-Fi 的地点，人们可以去那里完成工作。它还显示每个地点的设施、营业时间、评分和位置地图。用户将能够登录并提交评分和评论。
- en: This application has some grounding in the real world. Location-based applications
    themselves aren’t particularly new and come in a few guises. Swarm and Facebook
    Check In list everything nearby that they can and crowdsource data for new places
    and information updates. Urbanspoon helps people find nearby places to eat, allowing
    a user to search on price bracket and type of cuisine. Even companies like Starbucks
    and McDonald’s have sections of their applications that help users find the nearest
    one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序在现实世界中有些基础。基于位置的应用程序本身并不特别新颖，它们以几种形式出现。Swarm 和 Facebook Check In 列出他们能找到的所有附近事物，并为新地点和信息更新众包数据。Urbanspoon
    帮助人们找到附近的餐馆，允许用户根据价格区间和菜系类型进行搜索。甚至像星巴克和麦当劳这样的公司，它们的应用程序中也有帮助用户找到最近店铺的部分。
- en: Real or fake data?
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 真实数据还是假数据？
- en: Okay, we’re going to fake the data for Loc8r in this book, but you could collate
    the data, crowdsource it, or use an external source if you wanted to. For a rapid
    prototype approach, you’ll often find that faking data for the first private version
    of your application speeds the process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这本书中，我们将为 Loc8r 假设数据，但如果你愿意，你也可以收集数据、众包数据或使用外部来源。对于快速原型方法，你通常会发现在你的应用程序的第一个私有版本中伪造数据可以加快这个过程。
- en: End product
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最终产品
- en: You’ll use all layers of the MEAN stack to create Loc8r, including Twitter Bootstrap
    to help you create a responsive layout. [Figure 1.7](#ch01fig07) shows some screenshots
    of what you’ll build throughout the book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用MEAN栈的所有层来创建Loc8r，包括Twitter Bootstrap帮助你创建响应式布局。[图1.7](#ch01fig07)展示了你在本书中将要构建的一些截图。
- en: Figure 1.7\. Loc8r is the application you’ll build throughout this book. It
    displays differently on different devices, showing a list of places and details
    about each place, and allows visitors to log in and leave reviews.
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7\. Loc8r是你在本书中将构建的应用程序。它在不同的设备上显示不同，显示地点列表和每个地点的详细信息，并允许访客登录并留下评论。
- en: '![](Images/01fig07_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig07_alt.jpg)'
- en: 1.7.2\. How the MEAN stack components work together
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.2\. MEAN栈组件是如何协同工作的
- en: By the time you’ve been through this book, you’ll have an application running
    on the MEAN stack, using JavaScript all the way through. MongoDB stores data in
    binary JSON, which, through Mongoose, is exposed as JSON. The Express framework
    sits on top of Node.js, where the code is written in JavaScript. In the front
    end is Angular, which is TypeScript. [Figure 1.8](#ch01fig08) illustrates this
    flow and connection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在你阅读完这本书后，你将有一个运行在MEAN栈上的应用程序，全程使用JavaScript。MongoDB以二进制JSON格式存储数据，通过Mongoose暴露为JSON。Express框架建立在Node.js之上，代码以JavaScript编写。前端是Angular，它是TypeScript。[图1.8](#ch01fig08)展示了这个流程和连接。
- en: Figure 1.8\. JavaScript (partly as TypeScript) is the common language throughout
    the MEAN stack, and JSON is the common data format.
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. JavaScript（部分为TypeScript）是MEAN栈中的通用语言，JSON是通用数据格式。
- en: '![](Images/01fig08_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig08_alt.jpg)'
- en: We’ll explore various ways that you can architect the MEAN stack and how you’ll
    build Loc8r in [chapter 2](kindle_split_012.xhtml#ch02).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](kindle_split_012.xhtml#ch02)中探讨各种构建MEAN栈的方法以及如何构建Loc8r。
- en: Because JavaScript plays such a pivotal role in the stack, please take a look
    at [appendix D](kindle_split_041.xhtml#app04) (available online and in the e-book),
    which has a refresher on JavaScript pitfalls and best practices.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript在栈中扮演着如此关键的角色，请参阅[附录D](kindle_split_041.xhtml#app04)（可在网上和电子书中找到），其中包含JavaScript陷阱和最佳实践的复习。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: Which technologies make up the MEAN stack and how they work together
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成MEAN栈的技术有哪些以及它们是如何协同工作的
- en: Where MongoDB fits as the data layer
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB作为数据层的位置
- en: How Node.js and Express work together to provide an application server layer
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和Express如何协同工作以提供应用服务器层
- en: How Angular provides an amazing front-end, data-binding layer
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular如何提供出色的前端和数据绑定层
- en: A few ways to extend the MEAN stack with additional technologies
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种扩展MEAN栈的额外技术的方法
- en: Chapter 2\. Designing a MEAN stack architecture
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章\. 设计MEAN栈架构
- en: '*This chapter covers*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing a common MEAN stack architecture
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍常见的MEAN栈架构
- en: Single-page applications
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: Discovering alternative MEAN stack architectures
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索替代的MEAN栈架构
- en: Designing an architecture for a real application
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为真实应用程序设计架构
- en: Planning a build based on architecture design
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据架构设计进行构建规划
- en: In [chapter 1](kindle_split_011.xhtml#ch01), we took a look at the component
    parts of the MEAN stack and how they fit together. In this chapter, we’re going
    to look in more detail at how they fit together.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011.xhtml#ch01)中，我们探讨了MEAN栈的组成部分以及它们是如何相互配合的。在本章中，我们将更详细地探讨它们是如何相互配合的。
- en: We’ll start off by looking at what some people think of as *the* MEAN stack
    architecture, especially when they first encounter the stack. Using some examples,
    we’ll explore why you might use a different architecture and then switch things
    up a bit and move things around. MEAN is a powerful stack that can be used to
    solve a diverse range of problems ... if you get creative with how you design
    your solutions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些人认为的“**MEAN栈架构**”开始，特别是当他们第一次遇到这个栈时。通过一些示例，我们将探讨为什么你可能使用不同的架构，然后稍作调整，移动一些东西。MEAN是一个强大的栈，可以用来解决各种问题……如果你在解决方案的设计上富有创意。
- en: 2.1\. A common MEAN stack architecture
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 常见的MEAN栈架构
- en: A common way to architect a MEAN stack application is to have a representational
    state transfer (REST) API feeding a single-page application (SPA). The API is
    typically built with MongoDB, Express, and Node.js, with the SPA being built in
    Angular. This approach is particularly popular with those who come to the MEAN
    stack from an Angular background and are looking for a stack that provides a fast,
    responsive API. [Figure 2.1](#ch02fig01) illustrates the basic setup and data
    flow.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 架构 MEAN 栈应用程序的一种常见方式是使用表示状态转移（REST）API 为单页应用程序（SPA）提供数据。API 通常使用 MongoDB、Express
    和 Node.js 构建，SPA 则使用 Angular 构建。这种方法对于那些从 Angular 背景转向 MEAN 栈并且寻找提供快速、响应式 API
    的堆栈的人来说尤其受欢迎。[图 2.1](#ch02fig01) 展示了基本设置和数据流。
- en: Figure 2.1\. A common approach to MEAN stack architecture, using MongoDB, Express,
    and Node.js to build a REST API that feeds JSON data to an Angular SPA run in
    the browser
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. MEAN 栈架构的一种常见方法，使用 MongoDB、Express 和 Node.js 构建 REST API，将 JSON 数据传输到在浏览器中运行的
    Angular SPA
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig01_alt.jpg)'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What is a REST API?**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 REST API？**'
- en: '*REST* stands for *REpresentational State Transfer*, which is an architectural
    style rather than a strict protocol. REST is stateless; it has no idea of any
    current user state or history.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*REST* 代表 *表征状态转移*，这是一种架构风格，而不是严格的协议。REST 是无状态的；它对任何当前用户状态或历史没有任何概念。'
- en: '*API* is an abbreviation for *application program interface*, which enables
    applications to talk to one another. In the case of the web, an API is normally
    a set of URLs that respond with data when called in the correct manner with the
    correct information.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*API* 是 *应用程序编程接口* 的缩写，它使得应用程序之间能够相互通信。在网页的情况下，API 通常是一组在正确的方式和正确的信息下调用时返回数据的
    URL。'
- en: A *REST API* is a stateless interface to your application. In the case of the
    MEAN stack, the REST API is used to create a stateless interface to your database,
    enabling a way for other applications, such as an Angular SPA, to work with the
    data. In other words, you create a collection of structured URLs that return specific
    data when called.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*REST API* 是对应用程序的无状态接口。在 MEAN 栈的情况下，REST API 用于创建对数据库的无状态接口，从而为其他应用程序，如 Angular
    SPA，提供了一种与数据交互的方式。换句话说，你创建了一个结构化的 URL 集合，当调用时返回特定的数据。'
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 2.1](#ch02fig01) is a great setup, ideal if you have or intend to build
    an SPA as your user-facing side. Angular is designed with a focus on building
    SPAs, pulling in data from a REST API as well as pushing it back. MongoDB, Express,
    and Node.js are also extremely capable when it comes to building an API, using
    JSON all the way through the stack, including the database itself.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.1](#ch02fig01) 是一个很好的设置，如果你有或打算构建一个 SPA 作为你的用户界面，那么它是非常理想的。Angular 是专门设计用来构建
    SPAs 的，它从 REST API 中拉取数据，并将其推回。MongoDB、Express 和 Node.js 在构建 API 方面也非常强大，整个堆栈（包括数据库本身）都使用
    JSON。'
- en: This is where many people start with the MEAN stack, looking for an answer to
    the question, “I’ve built an application in Angular; now where do I get the data?”
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是许多人开始使用 MEAN 栈的地方，寻找问题的答案：“我已经用 Angular 开发了一个应用程序；现在我该从哪里获取数据？”
- en: Having an architecture like this is great if you have an SPA, but what if you
    have differing requirements? The MEAN stack is far more flexible than the current
    design suggests. All four components are individually powerful and have a lot
    to offer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有 SPA，这样的架构很棒，但如果你有不同的需求呢？MEAN 栈比当前的设计要灵活得多。所有四个组件都各自强大，有很多东西可以提供。
- en: 2.2\. Looking beyond SPAs
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 超越 SPAs 的视角
- en: Coding an SPA in Angular is like driving a Porsche along a coastal road with
    the roof down. Both are amazing. They’re fun, fast, sexy, agile, and exceedingly
    capable. If, historically, you’ve not done either thing before, it’s most likely
    that both are a vast improvement.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中编码 SPA 就像在沿海道路上开着敞篷的保时捷一样。两者都非常棒。它们有趣、快速、性感、敏捷，并且功能强大。如果你在历史上没有做过这两件事，那么很可能两者都是巨大的改进。
- en: But sometimes, they’re not appropriate. If you want to pack up the surfboards
    and take your family away for the week, you’re going to struggle with the sports
    car. As amazing as your car may be, in this case you’re going to want to use something
    different. It’s the same story with SPAs. Yes, building them in Angular is amazing,
    but sometimes an SPA isn’t the best solution to your problem. Let’s take a brief
    look at some things to bear in mind about SPAs when designing a solution and deciding
    whether a full SPA is right for your project.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，它们并不合适。如果你想收拾冲浪板，带着家人离开一周，你将难以驾驭跑车。尽管你的车可能很棒，但在这种情况下，你可能会想要使用不同的东西。对于SPA来说，情况也是如此。是的，在Angular中构建它们很棒，但有时SPA并不是解决你问题的最佳方案。让我们简要地看看在设计解决方案和决定是否全SPA适合你的项目时，关于SPA需要注意的一些事项。
- en: SPAs generally offer a fantastic user experience while reducing the load on
    your servers and therefore also your hosting costs. In sections [2.3.1](#ch02lev2sec5)
    and [2.3.2](#ch02lev2sec6), you’ll look at a good use case for an SPA and a bad
    one, and you’ll have built a full SPA by the end of this book.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: SPA通常提供极好的用户体验，同时减少服务器负载，因此也降低了你的托管成本。在[2.3.1](#ch02lev2sec5)和[2.3.2](#ch02lev2sec6)节中，你将看到SPA的良好和不良用例，并在本书结束时构建一个完整的SPA。
- en: 2.2.1\. Hard to crawl
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 难以爬取
- en: JavaScript applications are hard for search engines to crawl and index. Most
    search engines look at the HTML content on a page but don’t execute or even download
    much JavaScript. For those that do, the actual crawling of JavaScript-created
    content is nowhere near as good as content delivered by the server. If all your
    content is served via a JavaScript application, you can’t be sure how much of
    it will be indexed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript应用程序对搜索引擎的爬取和索引很困难。大多数搜索引擎查看页面上的HTML内容，但不会执行或下载很多JavaScript。对于那些确实会执行或下载的，对JavaScript创建的内容的实际爬取远不如由服务器提供的内容。如果你的所有内容都是通过JavaScript应用程序提供的，你无法确定其中有多少会被索引。
- en: A related downside is that automatic previews from social-sharing sites like
    Facebook, LinkedIn, and Pinterest don’t work well, also because they look at the
    HTML of the page you’re linking to and try to extract some relevant text and images.
    Like search engines, they don’t run JavaScript on the page, so content served
    by JavaScript won’t be seen.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的缺点是，来自Facebook、LinkedIn和Pinterest等社交分享网站的自动预览效果不佳，这也是因为他们查看你链接到的页面的HTML，并尝试提取一些相关的文本和图像。像搜索引擎一样，它们不会在页面上运行JavaScript，所以通过JavaScript提供的内容将不会被看到。
- en: All this is slowly improving. We hope that future editions of this book won’t
    need to have this section!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在慢慢改进。我们希望这本书的未来版本不需要有这个章节！
- en: Making an SPA crawlable
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使SPA可爬取
- en: You can use a couple of workarounds to make your site look crawlable. Both involve
    creating separate HTML pages that mirror the content of your SPA. You can have
    your server create an HTML-based version of your site and deliver that to crawlers,
    or you can use a headless browser such as PhantomJS to run your JavaScript application
    and output the resulting HTML.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些解决方案来使你的网站看起来可爬取。这两种方法都涉及创建单独的HTML页面，以反映你的SPA的内容。你可以让服务器创建你网站的HTML版本并将其提供给爬虫，或者你可以使用无头浏览器，如PhantomJS，来运行你的JavaScript应用程序并输出生成的HTML。
- en: Each method requires quite a bit of effort and can end up being a maintenance
    headache if you have a large, complex site. You also have potential search engine
    optimization (SEO) pitfalls. If your server-generated HTML is deemed to be too
    different from the SPA content, your site will be penalized. Running PhantomJS
    to output the HTML can slow the response speed of your pages, which is something
    for which search engines—Google in particular—downgrade you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都需要相当多的努力，如果你有一个大型、复杂的网站，最终可能会变成一个维护难题。你还有潜在的搜索引擎优化（SEO）陷阱。如果你的服务器生成的HTML被认为与SPA内容差异太大，你的网站将会受到惩罚。运行PhantomJS输出HTML可能会减慢你页面的响应速度，这是搜索引擎——特别是Google——会降低你排名的原因。
- en: Does it matter?
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 这重要吗？
- en: Whether this matters depends on what you want to build. If the main growth plan
    for whatever you’re building is through search engine traffic or social sharing,
    you want to give these concerns a great deal of thought. If you’re creating something
    small that will stay small, managing the workarounds is achievable, whereas at
    a larger scale, you’ll struggle.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否重要取决于你想要构建什么。如果你所构建的任何东西的主要增长计划是通过搜索引擎流量或社交分享，你想要对这些担忧给予极大的思考。如果你正在创建一些将保持小规模的东西，管理这些解决方案是可行的，而在更大规模上，你将面临挑战。
- en: On the other hand, if you’re building an application that doesn’t need much
    SEO—or indeed, if you *want* your site to be harder to scrape—you don’t need to
    be concerned about this issue. It could even be an advantage.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在构建一个不需要太多SEO的应用程序——或者实际上，如果你*希望*你的网站更难被抓取——你不需要担心这个问题。这甚至可能是一个优势。
- en: 2.2.2\. Analytics and browser history
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 分析和浏览器历史
- en: Analytics tools like Google Analytics rely heavily on entire new pages loading
    in the browser, initiated by a URL change. SPAs don’t work this way. There’s a
    reason why they’re called *single-page* applications!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 像Google Analytics这样的分析工具严重依赖于整个新页面在浏览器中的加载，由URL变化启动。SPA不这样做。这就是为什么它们被称为*单页*应用程序的原因！
- en: After the first page load, all subsequent page and content changes are handled
    internally by the application. The browser never triggers a new page load; nothing
    gets added to the browser history; and your analytics package has no idea who’s
    doing what on your site.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次页面加载之后，所有后续的页面和内容更改都由应用程序内部处理。浏览器永远不会触发新的页面加载；不会添加任何内容到浏览器历史记录；你的分析包也不知道谁在网站上做了什么。
- en: Adding page loads to an SPA
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在SPA中添加页面加载
- en: You can add page load events to an SPA by using the HTML5 history API, which
    will help you integrate analytics. The difficulty comes in managing this and ensuring
    that everything is being tracked accurately, which involves checking for missing
    reports and double entries.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用HTML5历史API将页面加载事件添加到SPA中，这将帮助你集成分析。困难在于管理和确保一切都被准确跟踪，这涉及到检查缺失的报告和重复记录。
- en: The good news is that you don’t have to build everything from the ground up.
    Several open source analytics integrations for Angular are available online, addressing
    most of the major analytics providers. You still have to integrate them into your
    application and make sure that everything is working correctly, but you don’t
    have to do everything from scratch.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你不必从头开始构建一切。网上有几种针对Angular的开源分析集成，解决了大多数主要分析提供商的问题。你仍然需要将它们集成到你的应用程序中并确保一切正常工作，但你不必从头开始做所有事情。
- en: Is it a major problem?
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 这是一个重大问题吗？
- en: The extent to which this is a problem depends on your need for undeniably accurate
    analytics. If you want to monitor trends in visitor flows and actions, you’re
    probably going to find analytics easy to integrate. The more detail and definite
    accuracy you need, the more work it is to develop and test. Although it’s arguably
    much easier to include your analytics code on every page of a server-generated
    site, analytics integration isn’t likely to be the sole reason to choose a non-SPA
    route.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否是一个问题取决于你对不可否认的准确分析的需求。如果你想监控访客流量和行为的趋势，你可能会发现集成分析很容易。你需要越多的细节和确切的准确性，开发和测试的工作量就越大。尽管在服务器生成的网站上在每个页面上包含你的分析代码可能更容易，但分析集成不太可能是选择非SPA路线的唯一原因。
- en: 2.2.3\. Speed of initial load
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 初始加载速度
- en: SPAs have a slower first page load than server-based applications, because the
    first load has to bring down the framework and the application code before rendering
    the required view as HTML in the browser. A server-based application only has
    to push out the required HTML to the browser, reducing latency and download time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于服务器的应用程序相比，SPA的首次页面加载速度较慢，因为第一次加载需要在浏览器中将框架和应用程序代码下载下来，然后再将所需的视图作为HTML渲染。基于服务器的应用程序只需要将所需的HTML推送到浏览器，从而减少延迟和下载时间。
- en: Speeding the page load
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加快页面加载
- en: You have some ways of speeding up the initial load of an SPA, such as a heavy
    approach to caching and lazy-loading modules when you need them. But you’ll never
    get away from the fact that the SPA needs to download the framework (at least,
    some of the application code) and will most likely hit an API for data before
    displaying something in the browser.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些方法可以加快SPA的初始加载速度，例如在需要时采用缓存和懒加载模块的重量级方法。但你永远无法摆脱SPA需要下载框架（至少，一些应用程序代码）并在显示浏览器中的内容之前很可能击中API获取数据的事实。
- en: Should you care about speed?
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你应该关心速度吗？
- en: The answer to whether you should care about the speed of the initial page load
    is, once again, “It depends.” It depends on what you’re building and how people
    are going to interact with it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否应该关心初始页面加载的速度，答案再次是“这取决于。”这取决于你正在构建的内容以及人们将如何与之互动。
- en: Think about Gmail. Gmail is an SPA and takes quite a while to load. Granted,
    this load time is normally only a couple of seconds, but everyone online is impatient
    these days and expects immediacy. But people don’t mind waiting for Gmail to load
    because it’s snappy and responsive once you’re in. And when you’re in, you often
    stay in for a while.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以Gmail为例。Gmail是一个SPA，加载需要相当长的时间。诚然，这个加载时间通常只有几秒钟，但如今网上的人都缺乏耐心，期望即时的响应。但人们不介意等待Gmail加载，因为一旦进入，它就非常迅速和响应灵敏。而且当你进入后，你通常会停留一段时间。
- en: But if you have a blog pulling in traffic from search engines and other external
    links, you don’t want the first page load to take a few seconds. People will assume
    that your site is down or running slowly and will click the Back button before
    you’ve had the chance to show them content.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有一个博客，从搜索引擎和其他外部链接中吸引流量，你不想首页加载需要几秒钟。人们会认为你的网站出了问题或运行缓慢，在你有机会向他们展示内容之前，他们就会点击后退按钮。
- en: 2.2.4\. To SPA or not to SPA?
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4. 是SPA还是非SPA？
- en: Just a reminder that the preceding sections aren’t an exercise in SPA-bashing;
    we’re just taking a moment to think about some things that often get pushed to
    the side until it’s too late. The three points about crawlability, analytics integration,
    and page load speed aren’t designed to give clear-cut definitions about when to
    create an SPA and when to do something else. They’re there to give a framework
    for consideration.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 只提醒一下，前面的章节并不是SPA的批评练习；我们只是花点时间思考一下那些经常被推到一边直到为时已晚的事情。关于可爬行性、分析集成和页面加载速度的三个点并不是为了给出何时创建SPA和何时做其他事情的明确定义。它们的存在是为了提供一个考虑框架。
- en: It may be the case that none of those things is an issue for your project and
    that an SPA is definitely the right way to go. If you find that each point makes
    you pause and think, and it looks as though you need to add workarounds for all
    three, an SPA probably isn’t the way to go.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可能这些事情对你的项目来说都不是问题，而且SPA绝对是正确的选择。如果你发现每个点都让你停下来思考，并且看起来你需要为这三个点添加折衷方案，那么SPA可能不是正确的选择。
- en: If you’re somewhere in between, it’s a judgment call about what’s most important
    and, crucially, what’s the best solution for the project. As a rule of thumb,
    if your solution includes a load of workarounds at the outset, you probably need
    to rethink it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于中间位置，那么这是一个关于什么最重要以及，关键的是，什么是对项目来说最好的解决方案的判断。一般来说，如果你的解决方案一开始就包含大量折衷方案，你可能需要重新考虑。
- en: Even if you decide that an SPA isn’t right for you, that doesn’t mean that you
    can’t use the MEAN stack. In the next section, we’ll take a look at how you can
    design a different architecture.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你决定SPA不适合你，这并不意味着你不能使用MEAN栈。在下一节中，我们将探讨如何设计不同的架构。
- en: 2.3\. Designing a flexible MEAN architecture
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 设计灵活的MEAN架构
- en: If Angular is like having a Porsche, the rest of the stack is like also having
    an Audi RS6 in the garage. A lot of people may be focusing on your sports car
    out front and not give a second glance to the estate car in your garage. But if
    you do go into the garage and have a poke around, you’ll find that there’s a Lamborghini
    V10 engine under the hood. There’s a lot more to that estate car than some people
    think!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Angular就像拥有一辆保时捷，那么其余的栈就像也在车库里有一辆奥迪RS6。很多人可能只关注你前面的跑车，而不会多看一眼车库里那辆旅行车。但如果你真的走进车库四处看看，你会发现引擎盖下有一台兰博基尼V10引擎。这辆旅行车比一些人想象的要复杂得多！
- en: Only ever using MongoDB, Express, and Node.js together to build a REST API is
    like only ever using the Audi RS6 to do the school drop-off runs. They’re all
    extremely capable and will do the job very well, but they have a lot more to offer.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用MongoDB、Express和Node.js一起构建REST API，就像只使用奥迪RS6进行学校接送一样。它们都非常能干，并且会非常出色地完成工作，但它们还有更多可以提供的东西。
- en: 'We talked a little about what the technologies can do in [chapter 1](kindle_split_011.xhtml#ch01),
    but here are a few starting points:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](kindle_split_011.xhtml#ch01)中简要讨论了这些技术能做什么，但这里有一些起点：
- en: MongoDB can store and stream binary information.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB可以存储和流式传输二进制信息。
- en: Node.js is particularly good for real-time connections using web sockets.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js特别适合使用Web sockets进行实时连接。
- en: Express is a web application framework with templating, routing, and session
    management built in.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express是一个内置模板、路由和会话管理的Web应用程序框架。
- en: There’s also a lot more, and we’re certainly not going to be able to address
    the full capabilities of all the technologies in this book. We’d need several
    books to do that! What we can do here is give you a simple example and show you
    how you can fit together the pieces of the MEAN stack to design the best solution.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容，我们当然无法在本书中涵盖所有技术的全部功能。为此，我们需要几本书！我们在这里能做的是提供一个简单的例子，并展示你如何将MEAN堆栈的各个部分组合起来，以设计最佳解决方案。
- en: 2.3.1\. Requirements for a blog engine
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 博客引擎的需求
- en: In this section, you’ll take a look at the familiar idea of a blog engine and
    see how you can best architect the MEAN stack to build one.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解熟悉的博客引擎概念，并了解如何最佳地架构MEAN堆栈来构建一个博客引擎。
- en: 'A blog engine typically has two sides: a public-facing side serving up articles
    to readers and (we hope) being syndicated and shared across the internet, and
    an administrator interface where blog owners log in to write new articles and
    manage their blogs. [Figure 2.2](#ch02fig02) shows some of the key characteristics
    of these two sides.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客引擎通常有两个方面：一个面向公众的方面，为读者提供文章，并（我们希望）在互联网上被聚合和共享，以及一个管理员界面，博客所有者可以登录以撰写新文章和管理他们的博客。[图2.2](#ch02fig02)展示了这两个方面的关键特性。
- en: 'Figure 2.2\. Conflicting characteristics of the two sides of a blog engine:
    the public-facing blog entries and the private admin interface'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 博客引擎两方面的冲突特性：面向公众的博客条目和私有管理员界面
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02_alt.jpg)'
- en: Looking at the lists in [figure 2.2](#ch02fig02), you can easily see a high
    level of conflict between the characteristics of the two sides. You’ve got content-rich,
    low interaction for the blog articles but a feature-rich, highly interactive environment
    for the admin interface. The blog articles should be quick to load to reduce bounce
    rates, whereas the admin area should be quick to respond to user input and actions.
    Finally, users typically stay on a blog entry for a short time but may share it
    with others, whereas the admin interface is private, and an individual user could
    be logged in for a long time.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看[图2.2](#ch02fig02)中的列表，你可以很容易地看到这两个方面的特性之间存在高度冲突。对于博客文章，你拥有丰富的内容和低交互性，而对于管理员界面，则是一个功能丰富、高度交互的环境。博客文章应该快速加载以减少跳出率，而管理员区域应该快速响应用户输入和操作。最后，用户通常在博客条目上停留的时间较短，但可能会与他人分享，而管理员界面是私人的，单个用户可能会长时间登录。
- en: Taking what we’ve discussed about potential issues with SPAs and looking at
    the characteristics of blog entries, you’ll see quite a lot of overlap. Bearing
    this in mind, it’s likely that you wouldn’t choose to use an SPA to deliver your
    blog articles to readers. On the other hand, the admin interface is a perfect
    fit for an SPA.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们关于SPA潜在问题的讨论，以及查看博客条目的特性，你会发现有很多重叠之处。考虑到这一点，你很可能不会选择使用SPA来向读者提供博客文章。另一方面，管理员界面非常适合SPA。
- en: So what do you do? Arguably the most important thing is to keep the blog readers
    coming. If they get a bad experience, they won’t come back; neither will they
    share. If a blog doesn’t get readers, the writer will stop writing or move to
    another platform. Then again, a slow and unresponsive admin interface will also
    see your blog owners jumping ship. So what *do* you do? How do you keep everybody
    happy and keep the blog engine in business?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你该怎么做呢？可以说，最重要的事情是保持博客读者的持续关注。如果他们获得糟糕的体验，他们就不会回来；他们也不会分享。如果一个博客没有读者，作者就会停止写作或转移到另一个平台。同样，一个缓慢且无响应的管理员界面也会导致博客所有者跳船。那么，你到底该怎么做？如何让每个人都满意，并保持博客引擎的运营？
- en: 2.3.2\. A blog engine architecture
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 博客引擎架构
- en: 'The answer lies in not looking for a one-size-fits-all solution. You effectively
    have two applications: public-facing content that should be delivered direct from
    the server and an interactive private admin interface that you want to build as
    an SPA. To start, look at the two applications separately, starting with the admin
    interface.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于不要寻找一个适合所有情况的解决方案。实际上，你拥有两个应用程序：面向公众的内容应该直接从服务器发送，以及一个你希望构建为SPA的交互式私有管理员界面。首先，分别查看这两个应用程序，从管理员界面开始。
- en: 'Admin interface: An Angular SPA'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 管理员界面：Angular SPA
- en: 'We’ve already stated that this interface would be an ideal fit for an SPA built
    in Angular. The architecture for this part of the engine should look familiar:
    a REST API built with MongoDB, Express, and Node.js, with an Angular SPA up front.
    [Figure 2.3](#ch02fig03) shows how this looks.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，这个接口非常适合用Angular构建的SPA。这个引擎部分的架构应该看起来很熟悉：一个用MongoDB、Express和Node.js构建的REST
    API，前端是一个Angular SPA。[图2.3](#ch02fig03)展示了它的样子。
- en: 'Figure 2.3\. A familiar sight: the admin interface is an Angular SPA making
    use of a REST API built with MongoDB, Express, and Node.js.'
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 熟悉的景象：管理界面是一个Angular SPA，利用了用MongoDB、Express和Node.js构建的REST API。
- en: '![](Images/02fig03.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig03.jpg)'
- en: There’s nothing particularly new shown in [figure 2.3](#ch02fig03). The entire
    application is built in Angular and runs in the browser, with JSON data being
    passed back and forth between the Angular application and the REST API.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.3](#ch02fig03)中展示的并没有什么特别新的内容。整个应用都是用Angular构建的，并在浏览器中运行，Angular应用和REST
    API之间通过JSON数据进行交互。'
- en: 'Blog entries: What to do?'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 博客条目：该做什么？
- en: Looking at the blog entries, you can see that things get a little more difficult.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 看看博客条目，你会发现事情变得有些复杂。
- en: If you think of the MEAN stack only as an Angular SPA calling a REST API, you’re
    going to get a bit stuck. You could build the public-facing site as an SPA anyway,
    because you want to use JavaScript and the MEAN stack. But it’s not the best solution.
    You could decide that the MEAN stack isn’t appropriate in this case and choose
    a different technology stack. But you don’t want to do that! You want end-to-end
    JavaScript.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只把MEAN栈看作是一个调用REST API的Angular单页应用（SPA），你可能会有些困惑。尽管如此，你仍然可以构建一个面向公众的SPA，因为你想要使用JavaScript和MEAN栈。但这并不是最佳解决方案。你可以决定在这种情况下MEAN栈并不合适，并选择不同的技术栈。但你不想这么做！你想要端到端的JavaScript。
- en: Take another look at the MEAN stack, and think about all the components. You
    know that Express is a web application framework. You know that Express can use
    template engines to build HTML on the server. You know that Express can use URL
    routing and MVC patterns. You should start to think that perhaps Express has the
    answer!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看MEAN栈，并思考所有组件。你知道Express是一个Web应用框架。你知道Express可以使用模板引擎在服务器上构建HTML。你知道Express可以使用URL路由和MVC模式。你应该开始思考，也许Express有答案！
- en: 'Blog entries: Making good use of Express'
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 博客条目：充分利用Express
- en: In this blog scenario, delivering the HTML and content directly from the server
    is exactly what you want to do. Express does this particularly well, even offering
    a choice of template engines right from the get-go. The HTML content will require
    data from the database, so you’ll use a REST API again. (For more on why it’s
    best to take this approach, see section [2.3.3](#ch02lev2sec7).) [Figure 2.4](#ch02fig04)
    lays out the basis for this architecture.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个博客场景中，直接从服务器发送HTML和内容正是你想要做的。Express在这方面做得尤其出色，甚至从一开始就提供了模板引擎的选择。HTML内容需要从数据库中获取数据，所以你将再次使用REST
    API。（关于为什么采取这种方法的更多内容，请参阅第2.3.3节[2.3.3](#ch02lev2sec7)。）[图2.4](#ch02fig04)展示了这种架构的基础。
- en: 'Figure 2.4\. An architecture for delivering HTML directly from the server:
    an Express and Node.js application at the front, interacting with a REST API built
    in MongoDB, Express, and Node.js'
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 直接从服务器发送HTML的架构：前端是一个Express和Node.js应用，与在MongoDB、Express和Node.js中构建的REST
    API交互
- en: '![](Images/02fig04.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04.jpg)'
- en: This approach enables you to use the MEAN stack (or part of it, at least) to
    deliver database-driven content directly from the server to the browser. But it
    doesn’t have to stop there. The MEAN stack is even more flexible.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使你能够使用MEAN栈（至少是它的一部分）直接从服务器将数据库驱动的内容发送到浏览器。但这并不一定要停止在这里。MEAN栈甚至更加灵活。
- en: 'Blog entries: Using more of the stack'
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 博客条目：使用更多的栈
- en: You’re looking at an Express application delivering blog content to visitors.
    If you want visitors to be able to log in, perhaps to add comments to articles,
    you need to track user sessions. You could use MongoDB with your Express application
    to do just this.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在查看一个Express应用，向访客提供博客内容。如果你想让访客能够登录，可能是为了添加文章评论，你需要跟踪用户会话。你可以使用MongoDB与你的Express应用一起做到这一点。
- en: You might also have some dynamic data in the sidebar of your posts, such as
    related posts or a search box with type-ahead autocompletion. You could implement
    these in Angular. Remember, Angular isn’t only for SPAs; it can also be used to
    create individual components that add some rich data interactivity to an otherwise
    static page. [Figure 2.5](#ch02fig05) shows these optional parts of MEAN added
    to the blog entry architecture.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能在您的帖子侧边栏中有些动态数据，例如相关帖子或带有自动补全功能的搜索框。您可以使用Angular来实现这些功能。记住，Angular不仅仅用于SPA；它还可以用来创建添加一些丰富数据交互性的独立组件，使原本静态的页面更加生动。[图2.5](#ch02fig05)显示了这些可选的MEAN部分添加到博客条目架构中。
- en: Figure 2.5\. Adding the options of using Angular and MongoDB as part of the
    public-facing aspect of the blog engine, serving the blog entries to visitors
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 在博客引擎的公共面向部分添加使用Angular和MongoDB作为选项，为访客提供博客条目
- en: '![](Images/02fig05.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig05.jpg)'
- en: Now you have the possibility of a full MEAN application delivering content to
    visitors who interact with your REST API.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有了构建一个完整的MEAN应用程序的可能性，该应用程序可以向与您的REST API交互的访客提供内容。
- en: 'Blog engine: A hybrid architecture'
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 博客引擎：混合架构
- en: At this point, you have two separate applications, each using a REST API. With
    a little bit of planning, you can have a common REST API used by both sides of
    the application. [Figure 2.6](#ch02fig06) shows what this looks like as a single
    architecture, with the single REST API interacting with the two front-end applications.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您有两个独立的应用程序，每个应用程序都使用REST API。通过一点规划，您可以让两个应用程序的两侧都使用一个共同的REST API。[图2.6](#ch02fig06)显示了这种作为单一架构的视图，其中单一的REST
    API与两个前端应用程序交互。
- en: 'Figure 2.6\. A hybrid MEAN stack architecture: a single REST API feeding two
    separate user-facing applications, built using different parts of the MEAN stack
    to provide the most appropriate solution'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 混合MEAN堆栈架构：一个单一的REST API为两个不同的用户界面应用程序提供数据，这些应用程序使用MEAN堆栈的不同部分来提供最合适的解决方案
- en: '![](Images/02fig06.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06.jpg)'
- en: This figure is a simple example to show how you can piece together the various
    parts of the MEAN stack into different architectures to answer the questions that
    your projects ask of you. Your options are limited only by your understanding
    of the components and your creativity in putting them together. There’s no one
    correct architecture for the MEAN stack.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图是一个简单的例子，说明您如何将MEAN堆栈的各个部分组合成不同的架构，以回答您的项目向您提出的问题。您的选择仅限于您对组件的理解以及您在组合它们时的创造力。对于MEAN堆栈来说，没有一种正确的架构。
- en: '2.3.3\. Best practice: Building an internal API for a data layer'
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 最佳实践：为数据层构建内部API
- en: You’ve probably noticed that every version of the architecture includes an API
    to surface the data and allow interaction between the main application and the
    database. There’s a good reason for this.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，架构的每个版本都包括一个API来展示数据并允许主应用程序与数据库之间的交互。这样做有很好的理由。
- en: If you were to start by building your application in Node.js and Express, serving
    HTML directly from the server, it would be easy to talk to the database directly
    from the Node.js application code. With a short-term view, this way is the easy
    way. But with a long-term view, it becomes the difficult way, because it tightly
    couples your data to your application code in such a way that nothing else can
    use it.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从使用Node.js和Express构建应用程序开始，直接从服务器提供HTML，那么从Node.js应用程序代码中直接与数据库通信将很容易。从短期来看，这是一种简单的方法。但从长期来看，这会变得困难，因为它将您的数据与应用程序代码紧密耦合，以至于其他任何东西都无法使用它。
- en: The other option is to build your own API that can talk to the database directly
    and output the data you need. Then your Node.js application can talk with this
    API instead of directly with the database. [Figure 2.7](#ch02fig07) shows a comparison
    of the two setups.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是构建自己的API，该API可以直接与数据库通信并输出所需的数据。然后您的Node.js应用程序可以与这个API通信，而不是直接与数据库通信。[图2.7](#ch02fig07)显示了两种设置的对比。
- en: Figure 2.7\. The short-term view of integrating data into your Node.js application.
    You can set up your Node.js application to talk directly to your database, or
    you can create an API that interacts with the database, and have your Node.js
    application talk only with the API.
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 将数据集成到您的Node.js应用程序中的短期视图。您可以设置您的Node.js应用程序直接与数据库通信，或者您可以创建一个与数据库交互的API，并让您的Node.js应用程序只与API通信。
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: Looking at [figure 2.7](#ch02fig07), you could well be wondering why you’d want
    to go to the effort of creating an API just to sit between your application and
    your database. Isn’t it creating more work? At this stage, yes, it’s creating
    more work, but you want to look farther down the road. What if you want to use
    your data in a native mobile application or in an Angular front end later?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 看到图2.7，你可能会想知道为什么你要费劲去创建一个API，只是为了在应用程序和数据库之间放置一个中间件。这难道不是增加了更多的工作量吗？在这个阶段，是的，它确实增加了工作量，但你应该看得更远一些。如果你以后想在原生移动应用程序或Angular前端中使用你的数据呢？
- en: You certainly don’t want to find yourself having to write separate but similar
    interfaces for each. If you’ve built your own API up front that outputs the data
    you need, you can avoid this work. If you have an API in place, when you want
    to integrate the data layer into your application, you can simply make it reference
    your API. It doesn’t matter whether your application is Node.js, Angular, iOS,
    or Android. It doesn’t have to be a public API that anyone can use so long as
    you can access it. [Figure 2.8](#ch02fig08) shows a comparison of the two approaches
    when you have Node.js, Angular, and iOS/Android applications all using the same
    data source.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然不希望发现自己不得不为每个应用程序编写单独但相似的接口。如果你在前面已经构建了一个API，它输出你需要的数据，你可以避免这项工作。如果你有一个现成的API，当你想要将数据层集成到应用程序中时，你只需让它引用你的API即可。无论你的应用程序是Node.js、Angular、iOS还是Android，只要你能访问它，就不必是一个任何人都可以使用的公共API。图2.8显示了当你有Node.js、Angular和iOS/Android应用程序都使用相同的数据源时，两种方法的比较。
- en: Figure 2.8\. The long-term view of integrating data into your Node.js application
    and additional Angular and iOS applications. The integrated approach has become
    fragmented, whereas the API approach is simple and maintainable.
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8. 将数据集成到你的Node.js应用程序以及额外的Angular和iOS应用程序的长期视图。集成方法已经变得碎片化，而API方法简单且易于维护。
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig08_alt.jpg)'
- en: As [figure 2.8](#ch02fig08) shows, the previously simple integrated approach
    is becoming fragmented and complex. You’ll have three data integrations to manage
    and maintain, so any changes will have to be made in multiple places to maintain
    consistency. If you have a single API, you don’t have any of these worries. With
    a little bit of extra work at the beginning, you can make life much easier for
    your future self. We’ll look at creating internal APIs in [chapter 6](kindle_split_017.xhtml#ch06).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如图2.8所示，之前简单的集成方法正在变得碎片化和复杂。你将需要管理和维护三个数据集成，因此任何更改都必须在多个地方进行，以保持一致性。如果你有一个单一的API，你就不会有这些烦恼。通过在开始时做一点额外的工作，你可以让你的未来生活变得更加轻松。我们将在第6章中探讨创建内部API。
- en: 2.4\. Planning a real application
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 规划真实的应用程序
- en: As we talked about in [chapter 1](kindle_split_011.xhtml#ch01), throughout the
    course of this book you’ll build a working application on the MEAN stack, called
    Loc8r. Loc8r lists nearby places with Wi-Fi where people can go to get some work
    done. It also displays facilities, opening times, a rating, and a location map
    for each place. Visitors will be able to submit ratings and reviews.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第1章中讨论的，在整个本书的过程中，你将构建一个基于MEAN栈的工作应用程序，名为Loc8r。Loc8r列出了附近有Wi-Fi的地方，人们可以去那里完成工作。它还显示了每个地点的设施、营业时间、评分和位置地图。访客将能够提交评分和评论。
- en: For the sake of the demo application, you’ll create fake data so that you can
    test it quickly and easily. In the next section, we’ll walk you through the application
    planning.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示应用程序，你需要创建一些假数据，这样你可以快速轻松地进行测试。在下一节中，我们将带你了解应用程序规划。
- en: 2.4.1\. Planning the application at a high level
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1. 在高层次上规划应用程序
- en: The first step is thinking about what screens you’ll need in your application.
    Focus on the separate page views and the user journeys. You can do this at a high
    level, not really concerning yourself with the details of what’s on each page.
    It’s a good idea to sketch out this stage on a piece of paper or a whiteboard,
    which helps you visualize the application as a whole. It also helps with organizing
    the screens into collections and flows while serving as a good reference point
    when you’re ready to build. As no data is attached to the pages or application
    logic behind them, it’s easy to add and remove parts, change what’s displayed
    where, and even change how many pages you want. Chances are that you won’t get
    it right the first time; the key is to start, and then iterate and improve until
    you’re happy with the separate pages and overall user flow.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是思考在你的应用程序中需要哪些屏幕。关注单独的页面视图和用户旅程。你可以从高层次开始，不必真正关心每个页面上具体的内容。在纸上或白板上勾勒出这个阶段是个好主意，这有助于你整体可视化应用程序。这也有助于在准备构建时将屏幕组织成集合和流程，同时作为一个良好的参考点。由于没有数据附加到页面或其背后的应用程序逻辑上，因此很容易添加和删除部分，更改显示的内容，甚至更改你想要的页面数量。很可能会第一次就做不对；关键是开始，然后迭代和改进，直到你对单独的页面和整体用户流程感到满意。
- en: Planning the screens
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规划屏幕
- en: 'Think about Loc8r. As stated earlier, your aim is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Loc8r。如前所述，你的目标是以下内容：
- en: '*Loc8r lists nearby places with Wi-Fi where people can go to get some work
    done. It also displays facilities, opening times, a rating, and a location map
    for each place. Visitors will be able to submit ratings and reviews.*'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Loc8r列出附近有Wi-Fi的地点，人们可以去那里完成一些工作。它还显示设施、营业时间、评分和每个地点的位置地图。访客将能够提交评分和评论。*'
- en: 'From this description, you can get an idea about some of the screens you’re
    going to need:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个描述中，你可以对将要需要的屏幕有一个大致的了解：
- en: A screen that lists nearby places
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出附近地点的屏幕
- en: A screen that shows details about an individual place
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示单个地点详细信息的屏幕
- en: A screen for adding a review about a place
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加关于地点评论的屏幕
- en: 'You’ll probably also want to tell visitors what Loc8r is for and why it exists,
    so you should add another screen to the list:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望告诉访客Loc8r是做什么的以及为什么存在，因此你应该将另一个屏幕添加到列表中：
- en: A screen for “about us” information
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “关于我们”信息的屏幕
- en: Dividing the screens into collections
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将屏幕划分为集合
- en: Next, take the list of screens and collate them where they logically belong
    together. The first three screens in the list, for example, deal with locations.
    The About page doesn’t belong anywhere, so it can go in a miscellaneous Others
    collection. A sketch of this arrangement looks something like [figure 2.9](#ch02fig09).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将屏幕列表整理到它们逻辑上属于一起的地方。例如，列表中的前三个屏幕处理位置。关于页面不属于任何地方，所以它可以放在杂项的其他集合中。这种安排的草图看起来像[图2.9](#ch02fig09)。
- en: Figure 2.9\. Collate the separate screens for your application into logical
    collections.
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9. 将你的应用程序的单独屏幕整理成逻辑集合。
- en: '![](Images/02fig09.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9](Images/02fig09.jpg)'
- en: Making a quick sketch like [figure 2.9](#ch02fig09) is the first stage in planning,
    and you need to go through this stage before you can start thinking about architecture.
    This stage gives you a chance to look at the basic pages and think about the flow.
    [Figure 2.9](#ch02fig09), for example, also shows a basic user journey in the
    Locations collection, going from the List page to a Details page and then to the
    form to add a review.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个快速草图，如[图2.9](#ch02fig09)，是规划的第一阶段，在你开始考虑架构之前，你需要完成这个阶段。这个阶段给你一个机会查看基本页面并思考流程。[图2.9](#ch02fig09)例如，还显示了在位置集合中的基本用户旅程，从列表页面到详情页面，然后到添加评论的表单。
- en: 2.4.2\. Architecting the application
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2. 架构应用程序
- en: On the face of it, Loc8r is a fairly simple application, with a few screens.
    But you still need to think about how to architect it, because you’re going to
    be transferring data from a database to a browser, letting users interact with
    the data, and allowing data to be sent back to the database.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，Loc8r是一个相当简单的应用程序，只有几个屏幕。但你仍然需要考虑如何构建它，因为你将要从数据库传输数据到浏览器，让用户与数据交互，并允许数据发送回数据库。
- en: Starting with the API
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从API开始
- en: 'Because the application will use a database and pass data around, start building
    the architecture with the piece you’re definitely going to need. [Figure 2.10](#ch02fig10)
    shows the starting point: a REST API built with Express and Node.js to enable
    interactions with the MongoDB database.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 因为应用程序将使用数据库并传递数据，所以从你肯定需要的部分开始构建架构。[图 2.10](#ch02fig10) 显示了起点：使用 Express 和
    Node.js 构建的 REST API，以实现与 MongoDB 数据库的交互。
- en: Figure 2.10\. Start with the standard MEAN REST API, using MongoDB, Express,
    and Node.js.
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10\. 从标准的 MEAN REST API 开始，使用 MongoDB、Express 和 Node.js。
- en: '![](Images/02fig10.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.10](Images/02fig10.jpg)'
- en: Building an API to interface with your data is a bit of a given and the base
    point of the architecture. The more interesting question is how you architect
    the application itself.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个 API 来与你的数据交互是基本的要求，也是架构的基础点。更有趣的问题是你是如何架构应用程序本身的。
- en: Application architecture options
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用架构选项
- en: At this point, you need to take a look at the specific requirements of your
    application and how to put together the pieces of the MEAN stack to build the
    best solution. Do you need something special from MongoDB, Express, Angular, or
    Node.js that will swing the decision a certain way? Do you want HTML to be served
    directly from the server, or is an SPA a better option?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要考虑你应用程序的具体要求以及如何将 MEAN 栈的各个部分组合起来以构建最佳解决方案。你是否需要 MongoDB、Express、Angular
    或 Node.js 的特殊功能，这将影响决策的方向？你是否希望直接从服务器提供 HTML，或者一个 SPA 是更好的选择？
- en: For Loc8r, you have no unusual or specific requirements, and whether it should
    be easily crawlable by search engines depends on the business growth plan. If
    the aim is to bring in organic traffic from search engines, yes, it needs to be
    crawlable. If the aim is to promote the application as an application and drive
    use that way, search engine visibility is a lesser concern.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Loc8r，你没有不寻常或特定的要求，并且它是否应该容易被搜索引擎抓取取决于业务增长计划。如果目标是吸引来自搜索引擎的有机流量，那么它需要是可抓取的。如果目标是作为应用程序推广应用程序并以此方式推动使用，那么搜索引擎的可视性就不再是主要关注点。
- en: 'Thinking back to the blog example, you can immediately envisage three possible
    application architectures, as shown in [figure 2.11](#ch02fig11):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下博客示例，你可以立即想象出三种可能的应用程序架构，如图 2.11 所示：
- en: A Node.js and Express application
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Node.js 和 Express 应用程序
- en: A Node.js and Express application with Angular additions for interactivity
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 Angular 增加的 Node.js 和 Express 应用程序，用于交互性
- en: An Angular SPA
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Angular 单页应用 (SPA)
- en: Figure 2.11\. Three options for building the Loc8r application, ranging from
    a server-side Express and Node.js application to a full client-side Angular SPA
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11\. 构建 Loc8r 应用程序的三个选项，从服务器端的 Express 和 Node.js 应用程序到完整的客户端 Angular SPA
- en: '![](Images/02fig11_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.11](Images/02fig11_alt.jpg)'
- en: With these three options in mind, which is the best for Loc8r?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这三个选项，Loc8r 最好的选择是哪一个？
- en: Choosing an application architecture
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择应用程序架构
- en: No specific business requirements are pushing you to favor one particular architecture
    over another. It doesn’t matter, because you’re going to do all three in this
    book. Building all three of the architectures allows you to explore how each approach
    works and enables you to take a look at each of the technologies in turn, building
    up the application layer by layer.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特定的业务需求推动你偏向于选择某种架构而不是另一种。没关系，因为在这本书中你将构建所有三种架构。构建所有三种架构让你能够探索每种方法是如何工作的，并使你能够依次查看每种技术，通过层层构建应用程序层。
- en: You’ll be building the architectures in the order in which they’re shown in
    [figure 2.11](#ch02fig11), starting with a Node.js and Express application, and
    then adding some Angular before refactoring to an Angular SPA. Although this isn’t
    necessarily how you might build a site normally, it gives you a great opportunity
    to learn all aspects of the MEAN stack. In section [2.5](#ch02lev1sec5), we’ll
    talk about this approach and walk through the plan in a bit more detail.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你将按照 [图 2.11](#ch02fig11) 中所示的顺序构建架构，首先是 Node.js 和 Express 应用程序，然后添加一些 Angular，最后重构为
    Angular SPA。虽然这不一定是你通常构建网站的方式，但它为你提供了一个很好的机会来学习 MEAN 栈的所有方面。在 [2.5](#ch02lev1sec5)
    节中，我们将讨论这种方法，并更详细地介绍计划。
- en: 2.4.3\. Wrapping everything in an Express project
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 将一切封装在 Express 项目中
- en: The architecture diagrams that you’ve been looking at so far imply that you’ll
    have separate Express applications for the API and the application logic. This
    is perfectly possible and a good way to go for a large project. If you’re expecting
    large amounts of traffic, you may even want your main application and your API
    on different servers. An additional benefit of this approach is that you can have
    more specific settings for each of the servers and applications that are best
    suited to particular needs.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的架构图暗示，你将会有单独的Express应用用于API和应用逻辑。这在大型项目中是完全可能的，也是一条很好的路线。如果你预计会有大量的流量，你可能甚至希望你的主要应用和API在不同的服务器上。这种方法的另一个好处是，你可以为每个服务器和应用设置更具体的设置，以最适合特定需求。
- en: 'Another way is to keep things simple and contained by having everything inside
    a single Express project. With this approach, you have only one application to
    worry about hosting and deploying and one set of source code to manage. This is
    what do with Loc8r: creating one Express project that contains a few subapplications.
    [Figure 2.12](#ch02fig12) illustrates this approach.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是保持简单和紧凑，将所有内容都放在一个Express项目中。采用这种方法，你只需关注一个应用的主机部署，并管理一套源代码。这就是Loc8r的做法：创建一个包含几个子应用的Express项目。[图2.12](#ch02fig12)展示了这种方法。
- en: Figure 2.12\. The architecture of the application with the API and application
    logic wrapped inside the same Express project
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12. API和应用逻辑包裹在同一Express项目中的应用架构
- en: '![](Images/02fig12_alt.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig12_alt.jpg)'
- en: When you’re putting together an application in this way, it’s important to organize
    your code well so that the distinct parts of the application are kept separate.
    As well as making code easier to maintain, this makes it easier to split the code
    into separate projects if a future you decides that doing so is the right route.
    We’ll keep coming back to this key theme throughout the book.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式组合应用时，组织好代码非常重要，以便将应用的不同部分保持分离。这不仅使代码更容易维护，还便于在将来决定这样做是正确路线时，将代码拆分为单独的项目。我们将在整本书中不断回到这个关键主题。
- en: 2.4.4\. The end product
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4. 最终产品
- en: As you can see, you use all layers of the MEAN stack to create Loc8r. You also
    include Twitter Bootstrap to create a responsive layout. [Figure 2.13](#ch02fig13)
    shows some screenshots of what you’ll build throughout the book.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你使用MEAN栈的所有层来创建Loc8r。你还包括Twitter Bootstrap来创建响应式布局。[图2.13](#ch02fig13)展示了你在整本书中将要构建的内容的截图。
- en: Figure 2.13\. Loc8r is the application you’ll build throughout this book. It
    displays differently on different devices, showing a list of places and details
    about each place, and enables visitors to log in and leave reviews.
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13. Loc8r是你在整本书中将要构建的应用。它在不同的设备上显示不同，显示地点列表和每个地点的详细信息，并允许访客登录并留下评论。
- en: '![](Images/02fig13_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig13_alt.jpg)'
- en: 2.5\. Breaking the development into stages
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. 将开发分解为阶段
- en: 'In this book, you have two aims:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你有两个目标：
- en: Build an application on the MEAN stack.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MEAN栈上构建一个应用。
- en: Learn about the different layers of the stack as you go.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行的过程中了解栈的不同层。
- en: You’ll approach the project in the way that you’d go about building a rapid
    prototype, but with a few tweaks to give you the best coverage of the whole stack.
    Start by looking at the five stages of rapid prototype development, and then see
    how to use this approach to build up Loc8r layer by layer, focusing on the different
    technologies as you go.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以构建快速原型的方式处理项目，但会进行一些调整，以覆盖整个栈的最佳效果。首先，看看快速原型开发的五个阶段，然后看看如何使用这种方法一层层地构建Loc8r，同时关注你正在使用的技术。
- en: 2.5.1\. Rapid prototype development stages
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.1. 快速原型开发阶段
- en: The following sections break the process into stages, which lets you concentrate
    on one thing at a time, increasing your chances of success. We find that this
    approach works well for making an idea a reality.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节将过程分解为阶段，这样你可以一次专注于一件事情，增加成功的机会。我们发现这种方法对于将想法变为现实非常有效。
- en: 'Stage 1: Build a static site'
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 阶段1：构建静态网站
- en: The first stage is building a static version of the application, which is essentially
    several HTML screens. The aims of this stage are
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段是构建应用的静态版本，这本质上是由几个HTML屏幕组成的。这一阶段的目标是
- en: To quickly figure out the layout
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了快速确定布局
- en: To ensure that the user flow makes sense
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保用户流程合理
- en: At this point, you’re not concerned with a database or flashy effects on the
    user interface; all you want to do is create a working mockup of the main screens
    and journeys that a user will take through the application.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你不需要关心数据库或用户界面的华丽效果；你只想创建一个用户将通过应用程序进行的主要屏幕和旅程的工作原型。
- en: 'Stage 2: Design the data model and create the database'
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第2阶段：设计数据模型并创建数据库
- en: When you have a working static prototype that you’re happy with, the next thing
    to do is look at any hardcoded data in the static application, and put it in a
    database. The aims of this stage are
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一个满意的静态原型感到满意时，下一步要做的是查看静态应用程序中的任何硬编码数据，并将其放入数据库中。这个阶段的目标是
- en: To define a data model that reflects the requirements of the application
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个反映应用程序需求的数据模型
- en: To create a database to work with the model
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个数据库以与模型一起工作
- en: The first part is defining the data model. Stepping back to a bird’s-eye view,
    what are the objects you need data about, how are the objects connected, and what
    data is held in them?
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是定义数据模型。退回到宏观视角，你需要关于哪些对象的数据，这些对象是如何相互连接的，以及它们包含哪些数据？
- en: When you try to do this stage before building the static prototype, you’re dealing
    with abstract concepts and ideas. When you have a prototype, you can see what’s
    happening on different pages and what data is needed where. Suddenly, this stage
    becomes much easier. Almost unknown to you, you’ve done the hard thinking while
    building the static prototype.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建静态原型之前尝试进行这个阶段，你是在处理抽象的概念和想法。当你有一个原型时，你可以看到不同页面上发生的事情以及需要哪些数据。突然之间，这个阶段变得容易多了。几乎在你没有意识到的情况下，你在构建静态原型时已经完成了艰难的思考。
- en: 'Stage 3: Build your data API'
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第3阶段：构建你的数据API
- en: After stages 1 and 2, you have a static site on one hand and a database on the
    other. This stage and the next take the natural steps of linking them. The aim
    of stage 3 is
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1和第2阶段之后，你有一边是静态网站，另一边是数据库。这个阶段和下一个阶段是自然地将它们连接起来的步骤。第3阶段的目标是
- en: To create a RESTful API that allows your application to interact with the database
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个RESTful API，允许你的应用程序与数据库交互
- en: 'Stage 4: Hook the database into the application'
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4阶段：将数据库连接到应用程序
- en: When you get to this stage, you have a static application and an API exposing
    an interface to your database. The aim of this stage is
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达这个阶段时，你有一个静态应用程序和一个API，该API公开了数据库的接口。这个阶段的目标是
- en: To get your application to talk to your API
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的应用程序能够与你的API通信
- en: When this stage is complete, the application will look pretty much the same
    as it did before, but the data will be coming from the database. When it’s done,
    you’ll have a data-driven application!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个阶段完成时，应用程序看起来几乎和之前一样，但数据将来自数据库。完成之后，你将拥有一个数据驱动的应用程序！
- en: 'Stage 5: Augment the application'
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第5阶段：增强应用程序
- en: This stage is all about embellishing the application with additional functionality.
    You might add authentication systems, data validation, or methods for displaying
    error messages to users. This stage could include adding more interactivity to
    the front end or tightening the business logic in the application.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段完全是关于用额外的功能装饰应用程序。你可能添加身份验证系统、数据验证或向用户显示错误消息的方法。这个阶段可能包括向前端添加更多交互性或加强应用程序中的业务逻辑。
- en: The aims of this stage are
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的目标是
- en: To add finishing touches to your application
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用程序添加最后的修饰
- en: To get the application ready for people to use
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使应用程序准备好供人们使用
- en: These five stages of development provide a great methodology for approaching
    a new build project. In the next section, you’ll take a look at how you’ll follow
    these steps to build Loc8r.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个开发阶段为处理新的建设项目提供了一个很好的方法论。在下一节中，你将了解如何遵循这些步骤来构建Loc8r。
- en: 2.5.2\. The steps to build Loc8r
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.5.2.构建Loc8r的步骤
- en: In building Loc8r throughout this book, you have two aims. First, of course,
    you want to build a working application on the MEAN stack. Second, you want to
    learn about the different technologies, how to use them, and how to put them together
    in different ways.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中构建Loc8r的过程中，你有两个目标。首先，当然，你想要在MEAN堆栈上构建一个可工作的应用程序。其次，你想要了解不同的技术，如何使用它们，以及如何以不同的方式将它们组合在一起。
- en: Throughout the book, you’ll follow the five stages of development, but with
    a couple of twists so that you get to see the whole stack in action. Before looking
    at the steps in detail, quickly remind yourself of the proposed architecture shown
    in [figure 2.14](#ch02fig14).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将遵循五个开发阶段，但会有一些变化，这样你就可以看到整个堆栈的实际运行情况。在详细查看步骤之前，快速回顾一下在 [图 2.14](#ch02fig14)
    中展示的提议架构。
- en: Figure 2.14\. Proposed architecture for Loc8r as you’ll build it throughout
    this book
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.14\. 你将在本书中构建的 Loc8r 的提议架构
- en: '![](Images/02fig14_alt.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig14_alt.jpg)'
- en: 'Step 1: Build a static site'
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 1 步：构建静态网站
- en: You’ll start by following stage 1 and building a static site. We recommend doing
    this for any application or site, because you can learn a lot with relatively
    little effort. When building the static site, it’s good to keep one eye on the
    future, keeping in mind what the final architecture will be. The architecture
    for Loc8r is already defined, as shown in [figure 2.14](#ch02fig14).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从遵循第 1 阶段并构建一个静态网站开始。我们建议为任何应用程序或网站都这样做，因为你可以用相对较少的努力学到很多东西。在构建静态网站时，最好关注未来，同时考虑最终架构将是什么样子。Loc8r
    的架构已经定义，如 [图 2.14](#ch02fig14) 所示。
- en: Based on this architecture, you’ll build the static application in Node and
    Express, using that as your starting point into the MEAN stack. [Figure 2.15](#ch02fig15)
    highlights this step in the process as the first part of developing the proposed
    architecture. This step is covered in [chapters 3](kindle_split_014.xhtml#ch03)
    and [4](kindle_split_015.xhtml#ch04).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个架构，你将在 Node 和 Express 中构建静态应用程序，将其作为进入 MEAN 堆栈的起点。[图 2.15](#ch02fig15) 强调了这个过程中的这一步骤，作为开发提议架构的第一部分。这一步骤在
    [第 3 章](kindle_split_014.xhtml#ch03) 和 [第 4 章](kindle_split_015.xhtml#ch04) 中有详细说明。
- en: Figure 2.15\. The starting point for your application is building the user interface
    in Express and Node.js.
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.15\. 你的应用程序的起点是使用 Express 和 Node.js 构建用户界面。
- en: '![](Images/02fig15_alt.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig15_alt.jpg)'
- en: 'Step 2: Design the data model and create the database'
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 2 步：设计数据模型并创建数据库
- en: Still following the stages of development, you’ll continue to stage 2 by creating
    the database and designing the data model. Again, any application is likely to
    need this step, and you’ll get much more out of it if you’ve been through step
    1 first.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然遵循开发阶段，通过创建数据库和设计数据模型，你将继续进入第 2 阶段。再次强调，任何应用程序都可能需要这一步骤，如果你首先完成了第 1 步，你会从中获得更多。
- en: '[Figure 2.16](#ch02fig16) illustrates how this step adds to the overall picture
    of building up the application architecture.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.16](#ch02fig16) 展示了这一步骤是如何为构建应用程序架构的整体图景增添内容的。'
- en: Figure 2.16\. After the static site is built, you’ll use the information gleaned
    to design the data model and create the MongoDB database.
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.16\. 静态网站构建完成后，你将利用获取的信息来设计数据模型并创建 MongoDB 数据库。
- en: '![](Images/02fig16_alt.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig16_alt.jpg)'
- en: In the MEAN stack, you’ll use MongoDB for this step, relying heavily on Mongoose
    for the data modeling. The data models are actually defined inside the Express
    application. This step is covered in [chapter 5](kindle_split_016.xhtml#ch05).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MEAN 堆栈中，你将使用 MongoDB 进行这一步骤，在数据建模方面高度依赖 Mongoose。数据模型实际上是在 Express 应用程序内部定义的。这一步骤在
    [第 5 章](kindle_split_016.xhtml#ch05) 中有详细说明。
- en: 'Step 3: Build your REST API'
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第 3 步：构建你的 REST API
- en: When you’ve built the database and defined the data models, you’ll want to create
    a REST API so that you can interact with the data through making web calls. Pretty
    much any data-driven application will benefit from having an API interface, so
    this step is another one you’ll want to have in most build projects.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建了数据库并定义了数据模型后，你将想要创建一个 REST API，这样你就可以通过进行网络调用来与数据交互。几乎任何数据驱动型应用程序都将从拥有
    API 接口中受益，因此这一步骤是大多数构建项目中你希望拥有的另一个步骤。
- en: You can see where this step fits into building the overall project in [figure
    2.17](#ch02fig17).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 2.17](#ch02fig17) 中看到这一步骤在构建整体项目中的位置。
- en: Figure 2.17\. Use Express and Node.js to build an API, exposing methods of interacting
    with the database.
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.17\. 使用 Express 和 Node.js 构建一个 API，暴露与数据库交互的方法。
- en: '![](Images/02fig17_alt.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig17_alt.jpg)'
- en: In the MEAN stack, this step is done mainly in Node.js and Express, with quite
    a bit of help from Mongoose. You’ll use Mongoose to interface with MongoDB rather
    than deal with MongoDB directly. This step is covered in [chapter 6](kindle_split_017.xhtml#ch06).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MEAN 堆栈中，这一步骤主要在 Node.js 和 Express 中完成，大量依赖 Mongoose。你将使用 Mongoose 与 MongoDB
    进行接口，而不是直接处理 MongoDB。这一步骤在 [第 6 章](kindle_split_017.xhtml#ch06) 中有详细说明。
- en: 'Step 4: Use the API from your application'
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第4步：使用应用程序中的API
- en: This step matches stage 4 of the development process and is where Loc8r starts
    to come to life. The static application from step 1 will be updated to use the
    REST API from step 3 to interact with the database created in step 2.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤与开发过程中的第4阶段相匹配，Loc8r开始变得有生命力。第1步中的静态应用程序将更新为使用第3步中的REST API与第2步中创建的数据库进行交互。
- en: To learn about all parts of the stack and the different ways in which you can
    use them, you’ll use Express and Node.js to make calls to the API. If, in a real-world
    scenario, you planned to build the bulk of an application in Angular, you’d hook
    your API into Angular instead. That approach is covered in [chapters 8](kindle_split_020.xhtml#ch08),
    [9](kindle_split_021.xhtml#ch09), and [10](kindle_split_022.xhtml#ch10).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解堆栈的所有部分以及你可以使用它们的不同方式，你将使用Express和Node.js来调用API。如果在现实世界的场景中，你计划在Angular中构建应用程序的大部分内容，你将把你的API连接到Angular。这种方法在第[8章](kindle_split_020.xhtml#ch08)、第[9章](kindle_split_021.xhtml#ch09)和第[10章](kindle_split_022.xhtml#ch10)中有详细说明。
- en: 'At the end of this step, you’ll have an application running on the first of
    the three architectures: an Express and Node.js application. [Figure 2.18](#ch02fig18)
    shows how this step glues together the two sides of the architecture.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，你将有一个运行在三种架构中的第一个架构上的应用程序：一个Express和Node.js应用程序。[图2.18](#ch02fig18)展示了这一步如何将架构的两部分粘合在一起。
- en: Figure 2.18\. Update the static Express application by hooking it into the data
    API, allowing the application to be database-driven.
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过将其连接到数据API来更新静态Express应用程序，允许应用程序数据库驱动。
- en: '![](Images/02fig18_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.18](Images/02fig18_alt.jpg)'
- en: In this build, you’ll do the majority of this step in Node.js and Express. This
    step is covered in [chapter 7](kindle_split_018.xhtml#ch07).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个构建过程中，你将主要使用Node.js和Express来完成这一步。这一步在第[7章](kindle_split_018.xhtml#ch07)中有详细说明。
- en: 'Step 5: Embellish the application'
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第5步：美化应用程序
- en: Step 5 relates to stage 5 in the development process, where you get to add extra
    touches to the application. You’ll use this step to take a look at Angular and
    see how you can integrate Angular components into an Express application. This
    addition to the project architecture is highlighted in [figure 2.19](#ch02fig19).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步与开发过程中的第5阶段相关，在这一阶段，你可以为应用程序添加额外的细节。你将使用这一步来查看Angular，并了解如何将Angular组件集成到Express应用程序中。这一项目架构的添加在第[图2.19](#ch02fig19)中得到了突出。
- en: Figure 2.19\. One way to use Angular in a MEAN application is to add components
    to the front end in an Express application.
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.19。在MEAN应用程序中使用Angular的一种方法是在Express应用程序的前端添加组件。
- en: '![](Images/02fig19_alt.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.19](Images/02fig19_alt.jpg)'
- en: This step is all about introducing and using Angular. To support this step,
    you’ll most likely also change some of your Node.js and Express setup. This step
    is covered in [chapter 8](kindle_split_020.xhtml#ch08).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步骤完全是关于引入和使用Angular。为了支持这一步骤，你很可能会也改变一些你的Node.js和Express设置。这一步骤在第[8章](kindle_split_020.xhtml#ch08)中有详细说明。
- en: 'Step 6: Refactor the code into an Angular SPA'
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第6步：将代码重构为Angular SPA
- en: In step 6, you’ll radically change the architecture by replacing the Express
    application and moving all the logic into an SPA, using Angular. Unlike the previous
    steps, this step replaces some of what came before it rather than building on
    it.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，你将通过替换Express应用程序并将所有逻辑移动到SPA中（使用Angular）来彻底改变架构。与之前的步骤不同，这一步不是在之前的基础上构建，而是替换了之前的一些内容。
- en: This step would be an unusual one in a normal build process—to develop an application
    in Express and redo it in Angular—but it suits the learning approach in this book
    particularly well. You’ll be able to focus on Angular, as you already know what
    the application should do, and a data API is ready for you to use.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的构建过程中，这一步可能是不寻常的——在Express中开发应用程序，然后在Angular中重新做——但这种方式非常适合本书的学习方法。你将能够专注于Angular，因为你已经知道应用程序应该做什么，而且数据API已经准备好供你使用。
- en: '[Figure 2.20](#ch02fig20) shows how this change affects the overall architecture.
    This step once again focuses on Angular and is covered in [chapters 9](kindle_split_021.xhtml#ch09)
    and [10](kindle_split_022.xhtml#ch10).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.20](#ch02fig20) 展示了这种变化如何影响整体架构。这一步再次聚焦于Angular，并在第[9章](kindle_split_021.xhtml#ch09)和第[10章](kindle_split_022.xhtml#ch10)中进行了介绍。'
- en: Figure 2.20\. Effectively rewriting the application as an Angular SPA
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图2.20](Images/02fig20_alt.jpg)'
- en: '![](Images/02fig20_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18](Images/02fig18_alt.jpg)'
- en: 'Step 7: Add authentication'
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第7步：添加身份验证
- en: In step 7, you’ll add functionality to the application by enabling users to
    register and log in. You’ll also see how to make use of users’ data while they’re
    using the application. You’ll build on everything you’ve done so far and add authentication
    to the Angular SPA. As part of this step, you’ll save user information in the
    database and secure certain API endpoints so that they can be used only by authenticated
    users.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，你将通过允许用户注册和登录来为应用程序添加功能。你还将看到如何在使用应用程序时利用用户数据。你将在之前所做的一切基础上添加认证到Angular
    SPA。作为这一步骤的一部分，你将在数据库中保存用户信息并确保某些API端点只能由认证用户使用。
- en: '[Figure 2.21](#ch02fig21) shows what you’ll be working with in the architecture.
    In this step, you’ll work with all the MEAN technologies. This step is covered
    in [chapters 11](kindle_split_024.xhtml#ch11) and [12](kindle_split_025.xhtml#ch12).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.21](#ch02fig21) 展示了你在架构中将要处理的内容。在这个步骤中，你将使用所有的MEAN技术。这一步骤在[第11章](kindle_split_024.xhtml#ch11)和[第12章](kindle_split_025.xhtml#ch12)中有详细说明。'
- en: Figure 2.21\. Using all the MEAN stack to add authentication to the Angular
    SPA
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.21\. 使用所有MEAN堆栈为Angular SPA添加认证
- en: '![](Images/02fig21_alt.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig21_alt.jpg)'
- en: That’s the planned software architecture. In the next section, we’ll have a
    quick chat about hardware.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 那是计划的软件架构。在下一节中，我们将简要讨论硬件。
- en: 2.6\. Hardware architecture
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 硬件架构
- en: No discussion of architecture would be complete without a section on hardware.
    You’ve seen how the software and code components can be put together, but what
    type of hardware do you need to run it all?
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于架构的讨论会不包含一个关于硬件的部分。你已经看到了软件和代码组件是如何组合在一起的，但你需要什么样的硬件来运行它们呢？
- en: 2.6.1\. Development hardware
  id: totrans-484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.1\. 开发硬件
- en: The good news is that you don’t need anything particularly special to run a
    development stack. A single laptop or even a virtual machine (VM) is enough to
    develop a MEAN application. All components of the stack can be installed on Windows,
    macOS, and most Linux distributions.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你不需要任何特别的东西来运行开发堆栈。一台笔记本电脑甚至一个虚拟机（VM）就足够开发一个MEAN应用程序。堆栈的所有组件都可以安装在Windows、macOS和大多数Linux发行版上。
- en: We’ve successfully developed applications on Windows and macOS laptops, as well
    as on Ubuntu VMs. Our preference is native development on macOS, but we know others
    who swear by Linux VMs.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Windows和macOS笔记本电脑以及Ubuntu虚拟机上成功开发了应用程序。我们更喜欢在macOS上本地开发，但我们知道有些人对Linux虚拟机情有独钟。
- en: If you have a local network and several servers, you can run different parts
    of your application across them. It’s possible to have one machine as a database
    server, another for the REST API, and a third for the main application code itself,
    for example. So long as the servers can talk to one another, this setup isn’t
    a problem.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个本地网络和多个服务器，你可以在它们之间运行应用程序的不同部分。例如，你可以有一个机器作为数据库服务器，另一个用于REST API，第三个用于主应用程序代码本身。只要服务器之间可以互相通信，这种设置就不会有问题。
- en: 2.6.2\. Production hardware
  id: totrans-488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.6.2\. 生产硬件
- en: The approach to production hardware architecture isn’t all that different from
    development hardware. The main difference is that production hardware is normally
    higher-spec and open to the internet to receive public requests.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 生产硬件架构的方法与开发硬件并没有太大的不同。主要区别是生产硬件通常规格更高，并且可以公开接入互联网以接收公共请求。
- en: Starter size
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初学者尺寸
- en: It’s possible to have all parts of your application hosted and running on the
    same server. You can see a basic diagram in [figure 2.22](#ch02fig22).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序的部分都可以托管并运行在同一个服务器上。你可以在[图2.22](#ch02fig22)中看到一个基本的示意图。
- en: Figure 2.22\. The simplest of hardware architectures, with everything on a single
    server
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.22\. 最简单的硬件架构，所有内容都在单个服务器上
- en: '![](Images/02fig22_alt.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig22_alt.jpg)'
- en: This architecture is okay for applications with low traffic but isn’t generally
    advised as your application grows, because you don’t want your application and
    database fighting over the same resources.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构适用于流量较低的应用程序，但随着应用程序的增长，通常不建议使用，因为你不希望应用程序和数据库争夺相同的资源。
- en: 'Growing up: A separate database server'
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成长：独立的数据库服务器
- en: 'One of the first things moved to a separate server is often the database. Now
    you have two servers: one for the application code and one for the database. [Figure
    2.23](#ch02fig23) illustrates this approach.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通常首先迁移到独立服务器的是数据库。现在你有两个服务器：一个用于应用程序代码，一个用于数据库。[图2.23](#ch02fig23)展示了这种方法。
- en: 'Figure 2.23\. A common hardware architecture approach: one server to run the
    application code and API and a second, separate database server'
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.23\. 常见的硬件架构方法：一个服务器运行应用程序代码和API，另一个独立的数据库服务器
- en: '![](Images/02fig23_alt.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig23_alt.jpg)'
- en: This model is common, particularly if you choose to use a Platform as a Service
    (PaaS) provider for your hosting. You’ll use that approach in this book.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型很常见，尤其是如果你选择使用平台即服务（PaaS）提供商来托管你的应用时。你将在本书中使用这种方法。
- en: Going for scale
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 追求规模
- en: 'Much as we talked about in the section on development hardware, you can have
    a different server for the different parts of your application: a database server,
    an API server, and an application server. This setup allows you to deal with more
    traffic as the load is spread across three servers, as illustrated in [figure
    2.24](#ch02fig24).'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在开发硬件部分所讨论的那样，你可以为应用程序的不同部分使用不同的服务器：数据库服务器、API服务器和应用程序服务器。这种设置允许你在三个服务器之间分散负载，如图2.24所示。
- en: 'Figure 2.24\. A decoupled architecture using three servers: one for the database,
    one for the API, and one for the application code'
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.24\. 使用三个服务器的解耦架构：一个用于数据库，一个用于API，一个用于应用程序代码
- en: '![](Images/02fig24_alt.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig24_alt.jpg)'
- en: But it doesn’t stop there. If your traffic starts to overload your three servers,
    you can have multiple instances (or clusters) of these servers, as shown in [figure
    2.25](#ch02fig25).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不止于此。如果你的流量开始超过你的三个服务器，你可以拥有这些服务器的多个实例（或集群），如图2.25所示。
- en: Figure 2.25\. You can scale MEAN applications by having clusters of servers
    for each part of your entire application.
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.25\. 你可以通过为应用程序的每个部分拥有服务器集群来扩展MEAN应用程序。
- en: '![](Images/02fig25_alt.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig25_alt.jpg)'
- en: Setting up this approach is a little more involved than the previous methods,
    because you need to ensure that your database remains accurate and that the load
    is balanced across servers. Once again, PaaS providers offer a convenient route
    into this type of architecture.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这种方法比之前的方法稍微复杂一些，因为你需要确保数据库保持准确，并且负载在服务器之间均衡。再次强调，PaaS提供商为这种类型的架构提供了一个方便的途径。
- en: You’ll get started on the journey in [chapter 3](kindle_split_014.xhtml#ch03)
    by creating the Express project that will hold everything together.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过创建一个将包含所有内容的Express项目来开始[第3章](kindle_split_014.xhtml#ch03)的旅程。
- en: Summary
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to design a common MEAN stack architecture with an Angular SPA, using a
    REST API built in Node.js, Express, and MongoDB
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用在Node.js、Express和MongoDB中构建的REST API设计一个常见的MEAN堆栈架构，使用Angular SPA
- en: How to assess the factors in your project to determine whether an SPA fits well
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何评估项目中的因素以确定单页面应用（SPA）是否适合
- en: How to design a flexible architecture in the MEAN stack
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在MEAN堆栈中设计一个灵活的架构
- en: The best practice of building an API to expose a data layer
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建API以暴露数据层的最佳实践
- en: Development and production hardware architectures
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和生产硬件架构
