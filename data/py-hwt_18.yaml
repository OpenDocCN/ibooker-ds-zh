- en: 13 Debugging and testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 调试与测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reading tracebacks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读跟踪信息
- en: Debugging your application interactively
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式调试你的应用程序
- en: Testing functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数
- en: Testing a class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试一个类
- en: Completing a programming project from scratch to production is like building
    a house. After you lay out the foundation, set up the frames and walls, complete
    the roof, and install the doors and windows, you feel that most of the house is
    done. But when you proceed to interior decoration, such as flooring, lights, furniture,
    and closets, you’ll realize that it’s still far from completion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始完成一个编程项目到生产就像建造一所房子。在你铺设地基、搭建框架和墙壁、完成屋顶并安装门窗之后，你会觉得房子的大部分已经完成。但是当你进行内部装修，如地板、灯光、家具和壁橱时，你会意识到它还远未完成。
- en: 'You’ve worked hard on your application for three months, feeling that you’ve
    completed 90% of the project. Before you push it into production, however, you
    must ensure its performance by debugging and testing it rigorously. It wouldn’t
    surprise me if the last estimated 10% costs you another three months—the same
    amount of time you needed for the first 90%. The debugging and testing phase is
    analogous to the interior decoration of a house—it’s so essential that your application
    can’t live without it—and you don’t want to hear your client’s complaints after
    launch day. Thus, let’s tackle the debugging and testing jobs while the application
    is still in our possession. In this chapter, you’ll learn the essential techniques
    that you can apply to conduct a rigorous final touch-up of your application: debugging
    and testing.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经努力工作了三个月，感觉你已经完成了项目的90%。然而，在你将其推入生产之前，你必须通过严格的调试和测试来确保其性能。如果最后估计的10%再花费你三个月的时间——这与你最初90%所需的时间相同——这并不会让我感到惊讶。调试和测试阶段类似于房屋的内部装修——它是如此重要，以至于你的应用程序没有它是无法运行的——而且你也不想听到客户在发布日后的抱怨。因此，让我们在应用程序仍然在我们手中的时候解决调试和测试任务。在本章中，你将学习可以应用于对应用程序进行严格最终润色的基本技术：调试和测试。
- en: 13.1 How do I spot problems with tracebacks?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 我如何通过跟踪信息发现问题？
- en: When our code fails to run due to exceptions, Python not only tells us about
    the exception, but also provides other information about where the exception is
    raised. Suppose that when we defined the Task class, we misspelled a method call.
    When we create an instance object of the Task class and call the instance method
    update_ urgency, we’ll encounter an AttributeError exception. Try running the
    code in the next listing in a console.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码由于异常而无法运行时，Python不仅告诉我们关于异常的信息，还提供了有关异常发生位置的其他信息。假设我们在定义Task类时拼写了一个方法调用。当我们创建Task类的实例对象并调用实例方法update_urgency时，我们会遇到AttributeError异常。尝试在控制台中运行下一列表中的代码。
- en: Listing 13.1 Showing a traceback when running some code
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 运行某些代码时显示跟踪信息
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The line number is 10 without counting empty lines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不计算空行，行号为10。
- en: ❷ The line of code that raises the exception
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 引发异常的代码行
- en: Note When you submit your code to a console, empty lines are removed, so you
    see a mismatch between the line number in the traceback and the one in the file.
    Because we often run code in the console and in a file, I’ll show you the tracebacks
    in both modes in this section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你将代码提交到控制台时，空行会被删除，所以你会看到跟踪信息中的行号与文件中的行号不匹配。因为我们经常在控制台和文件中运行代码，所以在本节中，我将向你展示两种模式下的跟踪信息。
- en: In most previous code snippets involving exceptions, I showed only the last
    line of the exception. Here, I’m showing the entire output message of the exception.
    Besides the exception line, the output has information such as the involved method
    name and line number, all of which can help us locate the buggy problem. These
    pieces of information in the output are known as *tracebacks.* Using tracebacks
    to locate a problem is the first step in debugging our code. In this section,
    you’ll learn how to read tracebacks and how to use them to locate problems in
    our code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数涉及异常的前置代码片段中，我只展示了异常的最后一行。在这里，我将展示异常的整个输出信息。除了异常行之外，输出还包括涉及的方法名称和行号等信息，所有这些都可以帮助我们定位错误问题。输出中的这些信息被称为*跟踪信息*。使用跟踪信息来定位问题是调试我们代码的第一步。在本节中，你将学习如何阅读跟踪信息以及如何使用它们来定位我们代码中的问题。
- en: 13.1.1 Understanding how a traceback is generated
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 理解如何生成跟踪信息
- en: Tracebacks are detailed descriptions of how an exception is raised. In chapter
    12, we learned about reading a traceback’s last line, which consists of an exception’s
    type and description. Here, let’s step back to understand how a traceback is generated,
    as it’s the basis for us to read tracebacks correctly and collect the information
    about the exception.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯是对异常抛出过程的详细描述。在第 12 章中，我们学习了如何读取回溯的最后一行，它包含异常的类型和描述。在这里，让我们回顾一下回溯是如何生成的，因为它是我们正确读取回溯并收集异常信息的基础。
- en: During the running of our application, events happen continuously, such as creating
    instances, accessing their attributes, and calling their methods. When something
    doesn’t work as expected, our application may encounter an exception and stop
    execution. Although running a specific line of code, such as task.update_urgency(4)
    in listing 13.1, appears to be the direct cause of our application’s termination,
    the line may not be the one to blame; the exception may be due to an underlying
    operation somewhere else. Thus, without resorting to tracebacks, we must understand
    the general execution process to know how an exception is raised.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序运行期间，事件会持续发生，例如创建实例、访问它们的属性和调用它们的方法。当某些事情没有按预期工作的时候，我们的应用程序可能会遇到异常并停止执行。尽管在列表
    13.1 中，如 task.update_urgency(4) 这样的特定代码行似乎是我们应用程序终止的直接原因，但这行代码可能并不是要责备的对象；异常可能是由其他地方的底层操作引起的。因此，在没有回溯的情况下，我们必须了解一般的执行过程，以便知道异常是如何被抛出的。
- en: Let’s use the code in listing 13.1 as an example. Figure 13.1 is a simple diagram
    of the essential execution steps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以列表 13.1 中的代码为例。图 13.1 是执行步骤的简单示意图。
- en: '![CH13_F01_Cui](../Images/CH13_F01_Cui.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F01_Cui](../Images/CH13_F01_Cui.png)'
- en: Figure 13.1 The execution process of the code in listing 13.1\. The first step
    is defining the Task class. The second step is creating an instance of the class.
    The third step is calling the update_urgency method. The fourth step is using
    the method’s definition in the class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 列表 13.1 中代码的执行过程。第一步是定义 Task 类。第二步是创建类的实例。第三步是调用 update_urgency 方法。第四步是使用类中的方法定义。
- en: 'The code in listing 13.1 consists of four major steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1 中的代码包含四个主要步骤：
- en: Defining the Task class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 Task 类
- en: Creating an instance of Task
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Task 的实例
- en: Calling the update_urgency method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 update_urgency 方法
- en: Using the update_urgency method’s definition in the class
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类中 update_urgency 方法的定义
- en: As annotated in listing 13.1, task.update_urgency(4) leads to the exception,
    and not because calling the method itself is wrong. Under the hood, something
    is wrong with the method definition. As you may notice in listing 13.1, update_urgency
    incorrectly calls update_db instead of _update_db, as it’s supposed to do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 13.1 中注释所示，task.update_urgency(4) 导致异常，并不是因为调用该方法本身是错误的。在底层，方法定义中存在错误。正如你在列表
    13.1 中可能注意到的，update_urgency 错误地调用了 update_db 而不是 _update_db，正如它应该做的。
- en: 'These four steps represent a snapshot of execution sequences when running a
    program, which involves thousands of continuous operations. From a general perspective,
    we can build an operation tree (figure 13.2). Each box represents a distinct operation.
    Such an operation can be referred to as a *call,* which corresponds to the term
    in a traceback’s title: Traceback (most recent call last). These operations form
    the *call stack,* which tracks the progression of the application’s execution.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个步骤代表了一个程序运行时执行序列的快照，这涉及到数千个连续的操作。从一般的角度来看，我们可以构建一个操作树（图 13.2）。每个框代表一个不同的操作。这样的操作可以被称为“调用”，这与回溯标题中的术语相对应：Traceback
    (most recent call last)。这些操作形成了“调用栈”，它跟踪应用程序执行的进展。
- en: Concept A *call stack* tracks the sequence of execution from the current call
    to the underlying operations that are required to complete the execution. These
    sequential operations form the call stack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 一个 *调用栈* 跟踪从当前调用到完成执行所需的底层操作的执行顺序。这些连续的操作形成了调用栈。
- en: '![CH13_F02_Cui](../Images/CH13_F02_Cui.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F02_Cui](../Images/CH13_F02_Cui.png)'
- en: Figure 13.2 A schematic representation of building a traceback. A traceback
    starts with the line of code that ultimately leads to the exception and follows
    the operations involved until arriving at the line of code that raises the exception
    directly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 构建回溯的示意图。回溯从最终导致异常的代码行开始，并跟随涉及的操作，直到到达直接抛出异常的代码行。
- en: Tracebacks are built on the call stack. They start with the call to the line
    of code that ultimately leads to the exception and record the operation (or the
    call) that the line of code invokes. If that operation doesn’t raise the exception,
    tracebacks continue to record the next operation until they locate the code that
    raises the exception. Figure 13.2 shows a schematic representation of a traceback.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯建立在调用栈之上。它们从最终导致异常的代码行的调用开始，并记录该代码行调用的操作（或调用）。如果该操作没有引发异常，回溯将继续记录下一个操作，直到它们定位到引发异常的代码。图
    13.2 显示了回溯的示意图。
- en: 13.1.2 Analyzing a traceback when running code in a console
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 在控制台中运行代码时的回溯分析
- en: In section 13.1.1, we examined how a traceback is generated under the hood.
    Now we’re ready to find out what elements constitute the traceback generated by
    running code in a console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.1.1 节中，我们检查了回溯是如何在幕后生成的。现在我们准备找出构成在控制台中运行代码生成的回溯的元素。
- en: Let’s continue with the traceback shown in listing 13.1\. Figure 13.3 shows
    the essential elements of a traceback that is generated by running code in a console.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看列表 13.1 中显示的回溯信息。图 13.3 展示了在控制台中运行代码生成的回溯的基本元素。
- en: '![CH13_F03_Cui](../Images/CH13_F03_Cui.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F03_Cui](../Images/CH13_F03_Cui.png)'
- en: Figure 13.3 Highlighting the key elements of a traceback generated in a console.
    Each line represents a distinct operation, as depicted in figure 13.2\. For each
    line, the key elements include the source file of the operation, the line number,
    and the buggy code. The last line shows the exception.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 突出了在控制台中生成的回溯的关键元素。每一行代表一个不同的操作，如图 13.2 所示。对于每一行，关键元素包括操作的源文件、行号和有问题的代码。最后一行显示了异常。
- en: 'Each line in the traceback represents an operation or a call. The first line
    is the line of code that ultimately leads to the exception: task.update_urgency(4).
    Let’s take a closer look at the second line to examine the key elements. Because
    we run the code in listing 13.1 in a console, the source of the involved operation
    is <stdin>, which represents the standard input: the console. Line 10 (annotated
    in listing 13.1; the line-number counts don’t include the empty lines when the
    code is submitted in the console) is the line where the exception is raised during
    execution of the update_urgency method. Specifically, this line is self.update_db(),
    which can’t work because the class doesn’t have the update_db instance method;
    therefore, the AttributeError exception is raised, as shown in the last line.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯中的每一行代表一个操作或调用。第一行是导致异常的代码行：task.update_urgency(4)。让我们仔细看看第二行，以检查关键元素。因为我们是在控制台中运行列表
    13.1 中的代码，所以涉及操作的来源是 <stdin>，它代表标准输入：控制台。列表 13.1 中的第 10 行（在列表 13.1 中有注释；控制台提交代码时，行号计数不包括空行）是执行
    update_urgency 方法时引发异常的行。具体来说，这一行是 self.update_db()，因为它无法工作，因为该类没有 update_db 实例方法；因此，引发了
    AttributeError 异常，如最后一行所示。
- en: 13.1.3 Analyzing a traceback when running a script
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 在运行脚本时的回溯分析
- en: In section 13.1.2, we focused on analyzing a traceback created by running code
    in a console. From a more general perspective, we often run our code as a script
    by using a command-line tool. In this section, we’ll see more interesting stuff
    in tracebacks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.1.2 节中，我们专注于分析在控制台中运行代码创建的回溯。从更一般的角度来看，我们通常通过使用命令行工具将代码作为脚本运行。在本节中，我们将看到回溯中更有趣的内容。
- en: 'To maintain some consistency, save the code in listing 13.1 to a script file
    named task_test.py. Watch for one change toward the end of the code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，将列表 13.1 中的代码保存到一个名为 task_test.py 的脚本文件中。注意代码片段末尾的一个变化：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, instead of creating an instance and calling the method directly,
    as in listing 13.1, we now include the pertinent code in a conditional statement,
    which runs only if the special attribute __name__ is equal to "__main__". It’s
    a best practice to include this statement, which allows you to run the file as
    a script and as a module. When you run the file as a script, the special attribute
    __name__ has a value of "__main__", so the statement evaluates as True and runs
    the included operations. In the meantime, when you import the file as a module,
    the module’s name is the file’s name, which isn’t "__main__", so you can’t run
    the included code unexpectedly. In the remaining sections, we’ll include the if
    statement in our script files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再像在13.1列表中那样直接创建实例并调用方法，而是现在将相关的代码包含在一个条件语句中，该语句仅在特殊属性 `__name__` 等于
    `"__main__"` 时运行。包含此语句是一种最佳实践，它允许您将文件作为脚本和模块运行。当您将文件作为脚本运行时，特殊属性 `__name__` 的值为
    `"__main__"`，因此该语句评估为 True 并运行包含的操作。与此同时，当您将文件作为模块导入时，模块的名称是文件名，它不是 `"__main__"`，因此您无法意外地运行包含的代码。在接下来的部分中，我们将在脚本文件中包含if语句。
- en: 'Maintainability In most cases, when your Python file is intended to be executed
    both as a script and a module, you should include the operations in an if statement
    (if __name__ == "__main__": # operations) if you want these operations to run
    only as a script. If you don’t, when the file is imported as a module, these operations
    will be executed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '可维护性 在大多数情况下，当您的Python文件旨在同时作为脚本和模块执行时，如果您只想让这些操作作为脚本运行，则应将这些操作包含在if语句中（if
    `__name__` == `"__main__"`: # operations）。如果不这样做，当文件作为模块导入时，这些操作将被执行。'
- en: You can run the following command in your command-line tool (listing 13.2),
    such as the Terminal app if you use a Mac computer or the cmd tool if you use
    a Windows computer. Please note that you need to navigate to the current directory
    if you don’t use the full path of the script file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的命令行工具中运行以下命令（列表13.2），例如，如果您使用的是Mac电脑，则使用Terminal应用；如果您使用的是Windows电脑，则使用cmd工具。请注意，如果您不使用脚本的完整路径，则需要导航到当前目录。
- en: Listing 13.2 Running a Python script that generates a traceback
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 运行生成跟踪回溯的Python脚本
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ $ means the command line’s prompt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `$` 表示命令行提示符。
- en: ❷ I use python3, as macOS defaults to Python version 2.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我使用python3，因为macOS默认使用Python 2版本。
- en: Compared with the traceback generated by executing code in a console, the traceback
    generated by running the script has additional information. As highlighted in
    listing 13.2, the traceback also shows the exact operation for that call. In the
    update_urgency method, for example, the code self.update_db() raises the AttributeError
    exception. The differences between the tracebacks from running the code in the
    console and running it as a script file arise because Python creates the call
    stack differently in these two running modes. When the code is running in the
    console, the call stack tracks only the lines, and while a script is executing,
    it tracks the specific operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与在控制台中执行代码生成的跟踪回溯相比，运行脚本生成的跟踪回溯包含更多信息。如列表13.2中所示，跟踪回溯还显示了该调用的确切操作。例如，在 `update_urgency`
    方法中，代码 `self.update_db()` 引发了 `AttributeError` 异常。在控制台中运行代码和作为脚本文件运行时的跟踪回溯之间的差异，是因为Python在这两种运行模式下创建的调用堆栈不同。当代码在控制台中运行时，调用堆栈仅跟踪行，而当脚本执行时，它跟踪具体的操作。
- en: 13.1.4 Focusing on the last call in a traceback
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.4 聚焦于跟踪回溯中的最后一个调用
- en: We’ve seen a couple of tracebacks that are generated by running code in a Python
    console or executing a script from a command line. You may have noticed where
    to spot the problem in a traceback, and this section addresses this topic formally.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些由在Python控制台运行代码或从命令行执行脚本生成的跟踪回溯。您可能已经注意到了在跟踪回溯中查找问题的位置，本节将正式讨论这个话题。
- en: 'By design, the traceback shows the call stack in a linear fashion from top
    to bottom. That is, the last call is shown at the bottom, which directly contributes
    to the exception that is raised. Thus, to solve the problem, we should focus on
    the last call. In the examples that we’ve used, the AttributeError exception informs
    us of the problem: AttributeError: ''Task'' object has no attribute ''update_db''.
    For the traceback that is generated when we run the file as a script (listing
    13.2), the error message even suggests Did you mean: ''_update_db''? Please note
    that this additional information may be not available in earlier Python versions.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '按照设计，跟踪回溯以从上到下的线性方式显示调用堆栈。也就是说，最后的调用显示在底部，这直接导致了抛出的异常。因此，为了解决问题，我们应该关注最后的调用。在我们使用的例子中，AttributeError
    异常告诉我们问题：AttributeError: ''Task'' 对象没有属性 ''update_db''。当我们以脚本的形式运行文件时生成的跟踪回溯（列表
    13.2），错误信息甚至建议：“你是指：''_update_db''？”请注意，这些附加信息可能在早期的 Python 版本中不可用。'
- en: Trivia Showing the Did you mean exception message is a recent addition to Python.
    Depending on your Python version and the Python editor you use, you may not see
    it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 逸事：显示“你是指”异常消息是 Python 中的一个新功能。根据你的 Python 版本和使用的 Python 编辑器，你可能看不到它。
- en: 'This suggestion is exactly what we should be taking. We go to the definition
    of the update_urgency method, shown in the last call of the traceback (use the
    line number to locate the code quickly), and replace update_db with _update_db.
    Note the difference in using an underscore prefix. After making this change, we
    can run the script again:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个建议正是我们应该采取的。我们前往更新紧急性方法的定义，如跟踪回溯的最后调用所示（使用行号快速定位代码），并将 update_db 替换为 _update_db。注意使用下划线前缀的差异。在做出这个更改后，我们可以再次运行脚本：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As expected, we don’t see the AttributeError exception. Now the script is working
    properly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们没有看到 AttributeError 异常。现在脚本运行正常。
- en: 13.1.5 Discussion
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.5 讨论
- en: In this section, I use a simple example to show the structure of a traceback
    and how to read it to fix a trivial problem in our code. In general, the last
    call pertains to the problem that we might fix. When your project uses multiple
    dependencies, however, it’s very likely that you’ll see more complicated tracebacks.
    I bet you’ll find that the last call in the traceback isn’t your code! When this
    happens, you must read the traceback upward by tracing to earlier calls, where
    you’ll find the code you wrote. This call is more likely to be the cause of the
    problem that you want to tackle.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我通过一个简单的例子来展示跟踪回溯的结构以及如何阅读它来修复我们代码中的简单问题。一般来说，最后的调用与可能需要我们修复的问题相关。然而，当你的项目使用多个依赖项时，你很可能会看到更复杂的跟踪回溯。我敢打赌，你会发现跟踪回溯中的最后调用不是你的代码！当这种情况发生时，你必须通过追踪到更早的调用来向上阅读跟踪回溯，在那里你会找到你编写的代码。这个调用更有可能是你想要解决的问题的根源。
- en: 13.1.6 Challenge
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.6 挑战
- en: Joe is a junior software developer. As part of his job, he’s been assigned to
    debug problems for the work-productivity software that the company develops. As
    part of his learning experience, he’s playing with tracebacks. In listing 13.1,
    the traceback includes two calls. To have some fun, how can he update the Task
    class by adding and using a few more methods to produce a traceback with more
    than two calls?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 乔是一个初级软件开发人员。作为他工作的一部分，他被分配去调试公司开发的提高工作效率软件的问题。作为他学习经验的一部分，他正在玩跟踪回溯。在列表 13.1
    中，跟踪回溯包括两个调用。为了找点乐子，他如何通过添加和使用一些更多的方法来更新 Task 类，从而生成包含两个以上调用的跟踪回溯？
- en: Hint You can add one or two methods, one of which contains buggy code that raises
    an exception. Use these methods in other methods to create multiple sequential
    calls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以添加一个或两个方法，其中一个包含会引发异常的代码错误。将这些方法用于其他方法中，以创建多个顺序调用。
- en: 13.2 How do I debug my program interactively?
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 如何交互式地调试我的程序？
- en: It’s always a good idea to identify bugs during the development phase so that
    you don’t have to deal with your clients’ complaints after product delivery. You
    may like to debug the program after every part is (almost) done. But I recommend
    that you debug your application bit by bit along the road, which minimizes the
    chances of bugs. Although you can check a traceback from an exception to solve
    a bug, it’s not always enough to let you check each involved operation closely,
    because an exception crashes your application instantly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段识别错误总是一个好主意，这样你就不必在产品交付后处理客户的投诉。你可能喜欢在每一部分（几乎）完成后都调试程序。但我建议你逐步调试你的应用程序，这样可以最大限度地减少错误的可能性。虽然你可以通过异常检查回溯来解决问题，但这并不总是足够让你仔细检查每个涉及的运算，因为异常会立即崩溃你的应用程序。
- en: Another essential debugging technique is the *interactive debugger,* which allows
    you to inspect your application in real time while it’s running. In this section,
    you’ll learn about the key features of the built-in debugger. Figure 13.4 shows
    the general aspects of debugging a program interactively. I cover those aspects
    in this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种重要的调试技术是 *交互式调试器*，它允许你在应用程序运行时实时检查它。在本节中，你将了解内置调试器的关键特性。图 13.4 展示了交互式调试程序的一般方面。我将在本节中介绍这些方面。
- en: '![CH13_F04_Cui](../Images/CH13_F04_Cui.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F04_Cui](../Images/CH13_F04_Cui.png)'
- en: Figure 13.4 The general aspects of debugging programs in Python. For a program,
    we add breakpoints to the places where we debug. When the execution encounters
    the breakpoint, it activates the interactive debugger. Then we can perform a variety
    of debugging tasks, such as running code line by line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 Python 中程序调试的一般方面。对于一个程序，我们在调试的地方添加断点。当执行遇到断点时，它会激活交互式调试器。然后我们可以执行各种调试任务，例如逐行运行代码。
- en: As covered in chapters 6 and 7, we know that functions are integral to applications.
    They also constitute most of the body of a custom class (chapter 8). Writing bug-free
    functions is the major objective for any programmer, so this section uses functions
    as examples to show the interactive debugging process.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 6 章和第 7 章所述，我们知道函数对于应用程序至关重要。它们也构成了自定义类（第 8 章）的大部分内容。编写无错误的函数是任何程序员的重大目标，因此本节使用函数作为示例来展示交互式调试过程。
- en: 13.2.1 Activating the debugger with a breakpoint
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 使用断点激活调试器
- en: In most cases, it doesn’t take us long to locate a buggy spot, because when
    our application crashes due to an exception, the generated traceback can inform
    us about the location of the exception. When we know the problem’s location, we
    can start our intervention by adding a *breakpoint* to activate the debugger.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们不需要花费太多时间就能找到有问题的位置，因为当我们的应用程序由于异常而崩溃时，生成的回溯信息可以告诉我们异常的位置。当我们知道问题位置后，我们可以通过添加
    *断点* 来激活调试器，开始我们的干预。
- en: Concept A *breakpoint* is a point where you request that your application stop
    executing for debugging purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *断点* 是你请求应用程序停止执行以进行调试的点。
- en: 'As part of the standard Python library, the module pdb provides the essential
    functionalities for debugging through an interactive debugger. To activate this
    debugger, you can call its set_trace function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准 Python 库的一部分，pdb 模块提供了通过交互式调试器进行调试的基本功能。要激活此调试器，你可以调用其 set_trace 函数：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Adding a breakpoint
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加断点
- en: In the create_task function, you import the pdb module and call set_trace to
    insert a breakpoint. (Please note that you could’ve moved the import statement
    outside the function; it’s only a convention to place it before set_trace.) When
    you call this function, you’ll notice that the debugger is activated; your Python
    console has changed its prompt from the default >>> to (Pdb), suggesting that
    Python has entered debug mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 create_task 函数中，你导入 pdb 模块并调用 set_trace 来插入断点。（请注意，你本可以将导入语句移到函数外部；将导入语句放在
    set_trace 之前只是一个惯例。）当你调用此函数时，你会注意到调试器被激活；你的 Python 控制台提示符从默认的 >>> 变成了 (Pdb)，这表明
    Python 已进入调试模式。
- en: 'Although you can activate the debugger by calling import pdb; pdb.set_trace(),
    I’m showing it here so that you’ll understand what this line of code means. You
    may have seen this usage in some legacy projects. A cleaner way, however, is to
    use a feature that was added in Python 3.7\. You call the built-in breakpoint
    function directly, as follows (if you have your debugger on, you can terminate
    it by pressing q):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以通过调用 import pdb; pdb.set_trace() 来激活调试器，但我在这里展示它是为了让你理解这一行代码的含义。你可能已经在一些旧项目中见过这种用法。然而，一种更干净的方法是使用
    Python 3.7 中添加的功能。你可以直接调用内置的 breakpoint 函数，如下所示（如果你打开了调试器，你可以通过按 q 来终止它）：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the output, you should see that the breakpoint function achieves the same
    effect by activating the debugger; it’s a convenience function that calls set_trace
    under the hood. Notably, debug mode is interactive, and many options are available
    to help you debug your function, as discussed in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你应该能看到断点函数通过激活调试器实现了相同的效果；它是一个底层调用 set_trace 的便利函数。值得注意的是，调试模式是交互式的，并且提供了许多选项来帮助你调试函数，正如下一节所讨论的。
- en: 13.2.2 Running code line by line
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 逐行运行代码
- en: When we carry out an operation, such as a function call, the operations happen
    instantaneously by executing its entire body. If it succeeds, we get the return
    value (or None implicitly). If it fails, we may get an exception or a value that
    we don’t expect. In either case, the operation is too fast for us to know exactly
    what’s going on with the function. If we can run code line by line, we can gain
    a better understanding of each step in the operation, giving us a higher chance
    of solving a possible bug. In this section, I’ll show you how to run code line
    by line. Equally important, you’ll see some key options of the debugger.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行一个操作，比如函数调用时，操作通过执行其整个主体瞬间发生。如果成功，我们得到返回值（或隐式地得到 None）。如果失败，我们可能会得到一个异常或我们预料之外的价值。在两种情况下，操作的速度太快，我们无法确切知道函数中发生了什么。如果我们能够逐行运行代码，我们就可以更好地理解操作中的每一步，从而提高我们解决可能出现的错误的机会。在本节中，我将向你展示如何逐行运行代码。同样重要的是，你将看到一些调试器的关键选项。
- en: Suppose that in our task management application, we obtain text data that contains
    a task’s information, and we want to convert this data to an instance object of
    the Task class. For tutorial purposes, let’s add a breakpoint in one of the functions
    and save the code in a script file named task_debug.py, as shown in the next listing.
    Although debugging works when you submit your code in a console, a real project
    is more like running a script, so we’ll use debugging with a script here.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的任务管理应用程序中，我们获得了包含任务信息的文本数据，并且我们想要将此数据转换为 Task 类的实例对象。为了教程的目的，让我们在其中一个函数中添加一个断点，并将代码保存在一个名为
    task_debug.py 的脚本文件中，如下所示。虽然你在控制台中提交代码时可以进行调试，但实际项目更像是运行脚本，所以我们将在这里使用脚本进行调试。
- en: Listing 13.3 Creating a function containing a breakpoint (task_bebug.py)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 创建包含断点的函数（task_debug.py）
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creating a named tuple class
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个命名元组类
- en: ❷ Adding a breakpoint
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加断点
- en: ❸ This is line number 10.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这是第 10 行。
- en: 'The create_task function creates the task by processing text data from calling
    obtain_text_data. To allow us to mimic situations when the function call fails,
    we have a Boolean argument to introduce a bug when needed. With this setup, we
    can move on to debugging the script without expecting a bug (inject_bug=False).
    Launch a command-line tool and navigate to the current directory, and then run
    the following command to execute the script:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: create_task 函数通过调用 obtain_text_data 并处理文本数据来创建任务。为了让我们能够模拟函数调用失败的情况，我们有一个布尔参数，在需要时引入错误。有了这个设置，我们可以继续调试脚本，而不期望出现错误（inject_bug=False）。启动命令行工具并导航到当前目录，然后运行以下命令来执行脚本：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should see that we’re in debug mode with (Pdb) as the prompt. The number
    (10) informs us of the line number, and current execution stops in the create_task
    function. It also shows the next line that is going to be executed, which is the
    calling of the obtain_text_data function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到我们处于调试模式，提示符为 (Pdb)。数字（10）告诉我们行号，并且当前执行在 create_task 函数中停止。它还显示了将要执行的下一行，即调用
    obtain_text_data 函数。
- en: 'To execute this line, we can press n, which stands for *next.* You’ll see that
    we complete running the present line, showing the next line of code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此行，我们可以按 n，代表 *下一个*。你会看到我们完成了当前行的运行，显示了下一行代码：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to execute the next line, we can press Return (on a Mac) or Enter
    (on a Windows computer), which should repeat the previous command: n. Execution
    moves to the next line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要执行下一行，可以按Return键（在Mac上）或Enter键（在Windows计算机上），这将重复上一个命令：n。执行移动到下一行：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can expect, if we keep pressing Enter or Return, the entire script will
    complete without any problems. But that’s not fun, right? Let’s see some other
    options for debugging.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，如果我们继续按Enter或Return键，整个脚本将无任何问题地完成。但这并不有趣，对吧？让我们看看一些其他调试选项。
- en: 'Sometimes, you may want to see other lines to get a bigger picture of the function.
    To do that, you can press the l key (lowercase L), because l stands for the list
    command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能想查看其他行以获得函数的更大视图。为此，您可以按l键（小写L），因为l代表列表命令：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This information is helpful in two ways: it shows all the lines that surround
    the current line, with the line numbers clearly labeled; and it uses an arrow
    to indicate the current line.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息以两种方式有帮助：它显示了围绕当前行的所有行，行号清晰标注；并且使用箭头指示当前行。
- en: 13.2.3 Stepping into another function
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 步进到另一个函数
- en: 'In the debugging in section 13.2.2, the first line of code calls another function:
    task_text = obtain_text_data(inject_bug). You may notice that we get the return
    value instantaneously. Although it’s not the case here, the called function can
    go wrong, and we may want to zoom into the called function to see its operation.
    We can quit the current debug session by pressing q and then run the script again
    in the command-line tool:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在13.2.2节中的调试中，第一行代码调用另一个函数：task_text = obtain_text_data(inject_bug)。您可能会注意到我们立即获得了返回值。尽管这里不是这种情况，被调用的函数可能会出错，我们可能想放大被调用的函数以查看其操作。我们可以通过按q键退出当前的调试会话，然后在命令行工具中再次运行脚本：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Instead of pressing n, which executes the next line, we want to press s, which
    stands for *step;* we’re asking to execute the next step. In this case, the next
    step is the calling of the obtain_text_data function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是按n键执行下一行，我们想按s键，它代表*步进；*我们要求执行下一个步骤。在这种情况下，下一个步骤是调用obtain_text_data函数：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we’ve zoomed into the function call instead of obtaining its
    return value directly. If we continue to press s or Return, we’ll view the entire
    function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们放大了函数调用，而不是直接获取其返回值。如果我们继续按s或Return键，我们将查看整个函数：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last operation shows the return value for calling the function: ''Laundry,3''.
    If we continue to press s, we’ll go back to our original function, create_task:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个操作显示了调用函数的返回值：'Laundry,3'。如果我们继续按s键，我们将回到原始函数，create_task：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You may notice that the commands n (next) and s (step) are similar, as both
    commands can execute the next line in most cases. The difference is that step
    allows you to step into another function call, as you’ve seen. Figure 13.5 shows
    the difference between n and s.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到命令n（下一个）和s（步进）很相似，因为这两个命令在大多数情况下都可以执行下一行。区别在于步进允许您进入另一个函数调用，正如您所看到的。图13.5显示了n和s之间的区别。
- en: '![CH13_F05_Cui](../Images/CH13_F05_Cui.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F05_Cui](../Images/CH13_F05_Cui.png)'
- en: Figure 13.5 The difference between the next and step commands in debugging.
    The next command executes the entire line; the step command attempts to execute
    the next line but stops at the next possible occasion. In the example, step is
    calling another function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 调试中next和step命令的区别。next命令执行整个行；step命令试图执行下一行，但在下一个可能的机会停止。在示例中，step调用另一个函数。
- en: In figure 13.5, although the step command attempts to execute the next line,
    it stops at the next possible occasion. In this case, that occasion is the calling
    of the obtain_ text_data function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.5中，尽管步进命令试图执行下一行，但它会在下一个可能的机会停止。在这种情况下，这个机会是调用obtain_text_data函数。
- en: 13.2.4 Inspecting pertinent variables
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 检查相关变量
- en: 'We can see what’s being executed, but we haven’t done anything proactively.
    Sometimes, a function call can’t work because it doesn’t have correct arguments.
    Even though the arguments may be the correct type, chances are that the values
    are incompatible, so we want to check the variables’ values inside the function.
    In this section, we’ll learn about inspecting variables in a function. We can
    change the last line of the script (task_debug.py) to create_task(inject_bug=True),
    and we can run the script from the command line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到正在执行的内容，但我们还没有采取任何主动措施。有时，函数调用可能无法正常工作，因为它没有正确的参数。即使参数可能是正确的类型，但很可能值是不兼容的，因此我们想要检查函数内部的变量值。在本节中，我们将学习如何在函数中检查变量。我们可以将脚本（task_debug.py）的最后一行更改为create_task(inject_bug=True)，然后可以从命令行运行脚本：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Suppose we know that the next line will raise the AttributeError exception.
    We can inspect the pertinent variables to see the potential cause of this exception:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道下一行将引发AttributeError异常。我们可以检查相关的变量以查看此异常的潜在原因：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding code snippet, we can use the command p to retrieve
    the variable’s value. If we want to display multiple variables, we can list them
    sequentially, with commas as separators:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们可以使用命令p检索变量的值。如果我们想显示多个变量，我们可以按顺序列出它们，用逗号作为分隔符：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It can be tedious to list all the variables that we want to check. We can take
    advantage of the feature that allows us to call a function directly in the debugger.
    Here, we can call the locals function, which shows the local namespace (section
    10.4):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列出我们想要检查的所有变量可能会很繁琐。我们可以利用允许我们在调试器中直接调用函数的功能。在这里，我们可以调用locals函数，它显示局部命名空间（第10.4节）：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can observe all the variables in the function’s local scope, giving us the
    full picture of the function’s status.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察函数局部作用域中的所有变量，从而全面了解函数的状态。
- en: 13.2.5 Discussion
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 讨论
- en: The tracebacks (section 13.1) provide a snapshot after your application has
    stopped executing, and everything that leads to the exception happens instantaneously.
    This static information doesn’t give you an opportunity to check each operation
    in a slow-motion manner; everything happens way too fast. By contrast, the debugger
    covered in this section is on-demand. You decide when the application can proceed
    to the next line, which gives you time to study each line closely to identify
    the possible cause of a bug. More importantly, the debugger is interactive, and
    you can explore options other than n, l, s, and p. You can find out more about
    the interactive debugger on the official Python website at [https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪回溯（第13.1节）在您的应用程序停止执行后提供了一个快照，并且导致异常的所有事情都是瞬间发生的。这种静态信息不会给您提供逐个检查每个操作的机会；一切发生得太快了。相比之下，本节中涵盖的调试器是按需的。您决定应用程序何时可以继续执行下一行，这给您时间仔细研究每一行以识别错误的可能原因。更重要的是，调试器是交互式的，您可以选择除了n、l、s和p之外的其他选项。您可以在官方Python网站上了解更多关于交互式调试器的信息：[https://docs.python.org/3/library/pdb.html](https://docs.python.org/3/library/pdb.html)。
- en: 13.2.6 Challenge
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.6 挑战
- en: Dylan is an eager learner of Python who wants to know the details of almost
    every technique. When he learns about debugging, he wants to know what’s happening
    during a function call in terms of the local namespace. For the example discussed
    in 13.2.4, instead of calling locals to retrieve the variables in a local scope
    after running a few lines, he wants to call locals after he starts the debugger.
    How do you expect the variable lists to change over the course of the function
    call?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 戴伦是Python的积极学习者，他想知道几乎所有技术的细节。当他学习调试时，他想知道在函数调用期间局部命名空间中发生了什么。对于13.2.4中讨论的示例，他不想在运行几行代码后调用locals来检索局部作用域中的变量，而是希望在启动调试器后调用locals。您预计变量列表在函数调用过程中会如何变化？
- en: Hint A namespace is dynamic. After the execution creates a new variable, it’s
    registered in the namespace.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：命名空间是动态的。在执行创建新变量后，它会在命名空间中注册。
- en: 13.3 How do I test my functions automatically?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 我如何自动测试我的函数？
- en: 'After completing your program’s functionalities and removing the obvious bugs
    through either the tracebacks or interactive debugging, you feel that your application
    is almost ready for delivery. But you want to do one more thing: test your program
    thoroughly. Testing is a broad concept that can be manifested in a variety of
    ways. When you’re removing any bugs from your application, you’re testing. When
    you’re calling some functions to ensure that they work as expected in your application,
    you’re testing. These examples are manual testing, however.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成你程序的函数性和通过回溯或交互式调试移除明显的错误之后，你感觉你的应用程序几乎可以交付了。但你还想做一件事：彻底测试你的程序。测试是一个广泛的概念，可以以多种方式体现。当你从你的应用程序中移除任何错误时，你就是在进行测试。当你调用一些函数以确保它们在你的应用程序中按预期工作，你也是在测试。然而，这些例子是手动测试。
- en: Although manual testing is acceptable when you work on smaller projects, it
    can be exhausting if your project’s scope is significant; every time you make
    changes to your code, you may have to go through each involved feature to ensure
    that it doesn’t break due to the changes. As you can imagine, manual testing can
    be a time-consuming factor that delays your progress. Fortunately, you can develop
    automatic testing for your application. Specifically, you can write code that
    tests the codebase of the application. Whenever you make changes to your codebase,
    you can run the test code, which can save considerable time. In this section,
    I’ll show you some important techniques for implementing automatic testing, with
    a special focus on functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在处理较小项目时手动测试是可以接受的，但如果你的项目范围很大，可能会非常累；每次你修改代码，你可能都必须遍历每个相关的功能，以确保它不会因为更改而损坏。正如你可以想象的那样，手动测试可能是一个耗时的因素，会延迟你的进度。幸运的是，你可以为你的应用程序开发自动测试。具体来说，你可以编写测试代码来测试应用程序的代码库。每次你修改代码库时，你都可以运行测试代码，这样可以节省大量时间。在本节中，我将向你展示一些实现自动测试的重要技术，特别关注函数。
- en: 'Maintainability Testing is an important tool for ensuring the maintainability
    of your codebase. Sections 13.3 and 13.4 provide only introductory information.
    If your job assignment is mainly about testing, you should look at educational
    materials on testing, such as *The Art of Unit Testing: With Examples in C#,*
    by Roy Osherove (Manning, 2019).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性测试是确保你的代码库可维护性的重要工具。第13.3节和第13.4节仅提供了介绍性信息。如果你的工作分配主要是关于测试，你应该查看有关测试的教育材料，例如Roy
    Osherove的《单元测试的艺术：C#示例》（Manning，2019年）。
- en: 13.3.1 Understanding the basis for testing functions
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 理解测试函数的基础
- en: We know that functions are integral to our application. If we can ensure that
    every function works as expected, our application will stand strong. This section
    shows the key elements of testing a function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道函数对我们应用程序至关重要。如果我们能确保每个函数都按预期工作，我们的应用程序就会很强大。本节展示了测试函数的关键要素。
- en: Let’s start with a simple function, which we can build on when we have more
    complicated functions to test. Suppose that our task management app has the following
    function to create a task, as an instance object of the Task class, from a string.
    We’re saving the function in the task_func.py file so that we can use it in our
    test, as the next listing shows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的函数开始，当我们有更复杂的函数要测试时，我们可以在其基础上构建。假设我们的任务管理应用程序有一个以下函数，用于从字符串创建一个任务，作为Task类的实例对象。我们将该函数保存在task_func.py文件中，以便我们可以在测试中使用它，如下所示。
- en: Listing 13.4 Defining a function to be tested (task_func.py)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4 定义要测试的函数（task_func.py）
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creates a custom class
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个自定义类
- en: 'For a specific functionality in our project (although we can use different
    implementation details), we generally expect that for given input, a function
    should return definite output. No matter how we’re going to change the implementation
    details of create_task, for example, we should expect the following to be true:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们项目中的特定功能（尽管我们可以使用不同的实现细节），我们通常期望对于给定的输入，函数应该返回确定的输出。无论我们如何更改create_task的实现细节，例如，我们应该期望以下内容为真：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we’re using an assert statement to verify the certainty of our function.
    In this case, we expect the dictionary representation of these two instances to
    be the same. Please note that instances of a custom class aren’t equal out of
    the box, but their dictionary representations can be compared for equality as
    a proxy. From a general perspective, this *certainty* of specific input producing
    specific output is the basis of testing functions. Figure 13.6 illustrates how
    testing functions works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 assert 语句来验证我们函数的确定性。在这种情况下，我们期望这两个实例的字典表示相同。请注意，自定义类的实例默认情况下并不相等，但它们的字典表示可以作为相等性的代理进行比较。从一般的角度来看，这种特定输入产生特定输出的*确定性*是测试函数的基础。图
    13.6 阐述了测试函数是如何工作的。
- en: '![CH13_F06_Cui](../Images/CH13_F06_Cui.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F06_Cui](../Images/CH13_F06_Cui.png)'
- en: Figure 13.6 The general process of testing functions. In the test function,
    we use specific input to call the function, and the produced output is compared
    with the expected output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 测试函数的一般过程。在测试函数中，我们使用特定的输入来调用函数，并将产生的输出与预期输出进行比较。
- en: 13.3.2 Creating a TestCase subclass for testing functions
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 为测试函数创建 TestCase 子类
- en: Now that we know the basis of testing functions, we’re ready to implement automatic
    testing by taking advantage of the unittest module (part of the standard Python
    library). This module provides important functionalities for testing our program
    automatically. Specifically, the module’s TestCase class allows us to test our
    function, as shown in the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了测试函数的基础，我们就可以利用 unittest 模块（Python 标准库的一部分）来实现自动测试。此模块为我们提供了自动测试程序的重要功能。具体来说，模块的
    TestCase 类允许我们测试我们的函数，如下面的列表所示。
- en: Listing 13.5 Testing a function using TestCase (test_task_func.py)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.5 使用 TestCase 测试函数（test_task_func.py）
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Imports the class and function from the script file
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从脚本文件中导入类和函数
- en: ❷ Imports the module
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入模块
- en: ❸ Inherits the TestCase class
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 继承 TestCase 类
- en: ❹ Calls the function to be tested
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用要测试的函数
- en: Note If you have problems importing the class and the function, you may want
    to open the chapter’s folder in your Python integrated development environment
    (IDE).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 如果你在导入类和函数时遇到问题，你可能需要在你的 Python 集成开发环境（IDE）中打开该章节的文件夹。
- en: In listing 13.5, we create the TestTaskCreation class by inheriting the TestCase
    class. It’s a convention to name our own test classes starting with Test. In the
    body of the class, we define an instance method that is designated to test the
    create_task function. It’s important to name this method with the test_ prefix
    so that when we run a test, Python knows that this method should be called. Figure
    13.7 shows the composition of the test class in relation to the functions we’re
    testing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 13.5 中，我们通过继承 TestCase 类创建了 TestTaskCreation 类。以 Test 开头命名我们的测试类是一种约定。在类的主体中，我们定义了一个实例方法，该方法被指定用于测试
    create_task 函数。使用 test_ 前缀命名这个方法很重要，这样当我们运行测试时，Python 就知道应该调用这个方法。图 13.7 展示了测试类与我们要测试的函数之间的关系。
- en: Readability Name your test class starting with Test, and follow it with the
    specific functionality your class is testing. Its methods should be named with
    the test_ prefix so that Python will run these methods during testing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 命名测试类时，以 Test 开头，并跟随着你的类要测试的具体功能。它的方法应该以 test_ 前缀命名，这样 Python 才会在测试期间运行这些方法。
- en: '![CH13_F07_Cui](../Images/CH13_F07_Cui.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![CH13_F07_Cui](../Images/CH13_F07_Cui.png)'
- en: Figure 13.7 Creating a test class that tests a set of functions. A test function
    should use test_ as its prefix, followed by the name of the function that it tests.
    The class should be named with a prefix of Test and is a subclass of the TestCase.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 创建一个测试类来测试一组函数。测试函数应该以 test_ 作为前缀，后跟它要测试的函数名称。类应该以 Test 作为前缀，并且是 TestCase
    的子类。
- en: 'The test_create_task method calls the to-be-tested function (create_task) with
    the specific input and compares the return value with the expected output. The
    comparison is done by calling assertEqual, which asserts that the two instances
    of the Task class are equal in their values. If that assertion is true, we’re
    confident that our function works as expected. In the last line, we call unittest.main(),
    which will run all the defined tests in the TestTaskCreation class. With this
    setup, we’re ready to test our function in a command-line tool:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: test_create_task方法使用特定的输入调用待测试的函数(create_task)，并将返回值与预期输出进行比较。比较是通过调用assertEqual完成的，该函数断言两个Task类的实例在值上相等。如果这个断言为真，我们就有信心我们的函数按预期工作。在最后一行，我们调用unittest.main()，这将运行TestTaskCreation类中定义的所有测试。有了这个设置，我们就准备好在命令行工具中测试我们的函数了：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For now, we have one unit of a test case: test_create_task. But we can define
    multiple test cases.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个测试用例的单元：test_create_task。但我们可以定义多个测试用例。
- en: Concept A *test case* is an individual unit of testing that checks for a specific
    response when a particular set of input is provided.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 概念一个*测试用例*是测试的一个单独单元，它检查在提供特定输入集时产生的特定响应。
- en: 'Suppose that we have another function that creates an instance of the Task
    class from a dict object. We add this function to the task_func.py file as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们还有一个从字典对象创建Task类实例的函数。我们将此函数添加到task_func.py文件中，如下所示：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function should be straightforward: it retrieves the needed values from
    the dict object and creates the instance object. We can update our test class
    to test this function too, as shown in the following listing.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数应该是直接的：它从字典对象中检索所需值并创建实例对象。我们可以更新我们的测试类来测试这个函数，如以下列表所示。
- en: Listing 13.6 Testing multiple functions (test_task_func.py)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.6 测试多个函数（test_task_func.py）
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As with test_create_task, we define a method that starts with test_. In this
    added method, we’re ensuring that the function works with the special case we’ve
    been using. We can run the test again:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与test_create_task类似，我们定义了一个以test_开头的方法。在这个新增的方法中，我们确保函数能够与我们所使用的特殊情况兼容。我们可以再次运行测试：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we defined two methods in the test class, so Python ran two
    tests for us, and both were OK. By the way, you may notice the two dots in the
    first line; the number of dots represents the number of tests that were run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在测试类中定义了两个方法，因此Python为我们运行了两个测试，并且两个都通过了。顺便说一下，您可能注意到第一行中的两个点；点的数量表示运行了测试的数量。
- en: 13.3.3 Setting up the test
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 设置测试
- en: 'We’ve seen how our test class can test two functions together. Notably, these
    two functions have something in common: both create an instance of the Task class.
    When we test them, we also create an instance of the Task class so that we can
    do the comparison. If you recall (section 2.1.4), repetition is a signal that
    there may be a need for refactoring. In this section, we set up the test, which
    can extract things in common in testing functions.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们的测试类可以一起测试两个函数。值得注意的是，这两个函数有共同点：它们都创建Task类的实例。当我们测试它们时，我们也创建一个Task类的实例，以便我们可以进行比较。如果您还记得（第2.1.4节），重复是可能需要重构的信号。在本节中，我们设置了测试，这可以提取测试函数中的共同点。
- en: Maintainability Always pay attention to possible opportunities for refactoring,
    such as code repetition. Refactoring improves your codebase’s maintainability.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性始终关注可能的重构机会，例如代码重复。重构可以提高代码库的可维护性。
- en: The TestClass has a setUp method that we can override. This method is called
    before running any test, so we can take advantage of this opportunity to carry
    out the operations that our test method shares. (Please note that these operations
    depend on what data we set up for our testing.) See the next listing for an example.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: TestClass有一个setUp方法，我们可以重写它。这个方法在运行任何测试之前被调用，因此我们可以利用这个机会执行测试方法共享的操作。（请注意，这些操作取决于我们为测试设置的数据。）请参见下一列表中的示例。
- en: Listing 13.7 Overriding the setUp method (test_task_func.py)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.7 重写setUp方法（test_task_func.py）
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As highlighted in listing 13.7, we update the class by adding an attribute.
    Specifically, we’re defining the task_dict, which holds the dict object that our
    test methods will use for equality comparisons. In the test methods, we can refer
    to the instance attribute task_dict directly; we don’t need to create duplicate
    instance objects for comparison. If we run the test script file again, we’ll see
    the same result.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 13.7 所示，我们通过添加一个属性来更新类。具体来说，我们正在定义 task_dict，它包含我们的测试方法将用于相等性比较的字典对象。在测试方法中，我们可以直接引用实例属性
    task_dict；我们不需要为比较创建重复的实例对象。如果我们再次运行测试脚本文件，我们将看到相同的结果。
- en: Trivia As you may have noticed, the methods in the unittest module use the lowercase
    camel naming convention (such as setUp and assertEqual) instead of snake case
    (such as set_up and assert_equal). The methods are named as they are for legacy
    reasons; they were adapted from Java-based tools, which use camel case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点：你可能已经注意到，unittest 模块中的方法使用小驼峰命名约定（例如 setUp 和 assertEqual），而不是蛇形命名法（例如 set_up
    和 assert_equal）。这些方法的命名是为了保留历史原因；它们是从基于 Java 的工具中改编而来的，这些工具使用驼峰命名法。
- en: 13.3.4 Discussion
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.4 讨论
- en: In the test class’s methods, we only use assertEqual to test equality between
    the desired output and the generated output. But there are other convenient methods
    to assert that the generated output meets the requirement of the desired output.
    assertIn(a, b), for example, checks whether a is in b, and assertTrue(a) checks
    whether a is True. These methods are straightforward to use, and you should get
    familiar with them. You can find these methods in the official documentation of
    the unittest module ([https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类的方 法中，我们只使用 assertEqual 来测试期望输出和生成输出之间的相等性。但还有其他方便的方法来断言生成的输出满足期望输出的要求。例如，assertIn(a,
    b) 检查 a 是否在 b 中，而 assertTrue(a) 检查 a 是否为 True。这些方法使用起来很简单，你应该熟悉它们。你可以在 unittest
    模块的官方文档中找到这些方法（[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)）。
- en: 13.3.5 Challenge
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.5 挑战
- en: Aaron is building software for weather forecasting, and he’s learning to run
    some unit tests in his project. While he’s following along with this section,
    in which we defined two functions and tested them with the TestTaskCreation class,
    he’s tasked with writing another function and its corresponding test method. Suppose
    that the function creates an instance of the Task class from a tuple object ("Laundry",
    3). Can you provide a solution?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 亚伦正在为天气预报构建软件，并且他正在学习在他的项目中运行一些单元测试。当他跟随本节内容，其中我们定义了两个函数并使用 TestTaskCreation
    类测试它们时，他被要求编写另一个函数及其相应的测试方法。假设该函数从一个元组对象 ("Laundry", 3) 创建 Task 类的实例。你能提供一个解决方案吗？
- en: Hint You can probably name this function create_task_from_tuple, in which you
    can use tuple unpacking (section 4.4) to get the title and urgency level for instantiation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可能把这个函数命名为 create_task_from_tuple，在其中你可以使用元组解包（第4.4节）来获取标题和紧急程度以进行实例化。
- en: 13.4 How do I test a class automatically?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 如何自动测试一个类？
- en: Although functions are integral to our application, the custom classes are the
    cornerstone of our application, as they’re the data models that bundle the necessary
    data and functionalities as a coherent entity. Typically, we don’t need to worry
    about testing the attributes of a custom class, as those attributes should be
    defined in a straightforward fashion. Thus, testing a class is mainly about testing
    its methods, as discussed in this section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数对我们应用程序至关重要，但自定义类是我们应用程序的基石，因为它们是将必要的数据和功能捆绑成一个连贯实体的数据模型。通常，我们不需要担心测试自定义类的属性，因为这些属性应该以简单的方式定义。因此，测试一个类主要关于测试其方法，正如本节所讨论的。
- en: 13.4.1 Creating a TestCase subclass for testing a class
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 为测试一个类创建 TestCase 子类
- en: Methods are functions, and they’re called *methods* because they’re defined
    within a class. Thus, testing a class’s methods boils down to testing these functions,
    which is covered extensively in section 13.3\. As you’ll see in this section,
    we’ll still create a TestCase subclass for testing a class. The examples use class
    methods, but the same testing principle applies to instance and static methods
    too.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是函数，它们被称为 *方法* 是因为它们是在类内部定义的。因此，测试一个类的方 法归结为测试这些函数，这在第13.3节中得到了广泛的讨论。正如你将在本节中看到的那样，我们仍然会为测试一个类创建一个
    TestCase 子类。示例使用类方法，但相同的测试原则也适用于实例和静态方法。
- en: 'In section 13.3, we worked on two functions: create_task and create_task_ from_dict.
    As you may have realized, we can convert them to custom methods. Because these
    two methods use the constructor to create an instance of the Task class, they’re
    perfect use cases for class methods, as the next listing shows.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.3 节中，我们处理了两个函数：create_task 和 create_task_from_dict。正如你可能意识到的，我们可以将它们转换为自定义方法。因为这两个方法使用构造函数来创建
    Task 类的实例，所以它们是类方法的完美用例，如下一个列表所示。
- en: Listing 13.8 Creating a class for testing (task_class.py)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.8 创建用于测试的类（task_class.py）
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In listing 13.8, the Task class has the task_from_text and task_from_dict class
    methods, which are converted from the create_task and create_task_from_dict functions,
    respectively.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 13.8 中，Task 类有 task_from_text 和 task_from_dict 类方法，它们分别从 create_task 和 create_task_from_dict
    函数转换而来。
- en: Reminder The class method uses cls as its first argument, which refers to the
    class. See section 8.2.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：类方法使用 cls 作为其第一个参数，它指的是类。参见 8.2 节。
- en: To test this class, we’ll create the TestTask class as a subclass of the TestCase
    class, in which we define two methods that correspond to the two class methods.
    Save the code in the next listing in a file called test_task_class.py.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，我们将创建一个名为 TestTask 的类，它是 TestCase 类的子类，在其中我们定义了两个方法，分别对应两个类方法。将代码保存在下一个列表中，文件名为
    test_task_class.py。
- en: Listing 13.9 Creating a class for testing a class (test_task_class.py)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9 创建用于测试类的类（test_task_class.py）
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Sets up the test
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置测试
- en: 'As we did with the TestCreationTask class, we define the test methods with
    names starting with test_ in the TestTask class so that when we run the script,
    all these test methods will run automatically. Observe the effect in the following
    code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 TestCreationTask 类中所做的那样，我们在 TestTask 类中定义了以 test_ 开头名称的测试方法，这样当我们运行脚本时，所有这些测试方法都会自动运行。观察以下代码片段的效果：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As expected, two tests were run, and neither had problems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，运行了两个测试，并且它们都没有问题。
- en: 13.4.2 Responding to test failures
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 对测试失败的反应
- en: 'The purpose of testing is to ensure that the units we’re testing work as expected.
    As you can imagine, the success of all tests is never guaranteed. When some tests
    fail, we need to know how to respond to those failures. Consider adding the following
    function to the Task class from listing 13.8:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目的是确保我们正在测试的单元按预期工作。正如你可以想象的那样，所有测试的成功从未得到保证。当某些测试失败时，我们需要知道如何对这些失败做出反应。考虑向列表
    13.8 中的 Task 类添加以下函数：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This instance method creates a formatted display for the task. To test this
    instance method, we can add the following test method to the TestTask class (listing
    13.9):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例方法为任务创建一个格式化的显示。为了测试这个实例方法，我们可以在 TestTask 类中添加以下测试方法（列表 13.9）：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you may have noticed, to simulate a test failure, I intentionally omitted
    the space between the task’s title and its urgency level in the assertEqual call.
    If we’re running the test, we should expect a failure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，为了模拟测试失败，我在 assertEqual 调用中故意省略了任务标题和紧急程度之间的空格。如果我们运行测试，我们应该期望失败：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Instead of seeing three dots, which correspond to three successful tests, we’re
    seeing ..F. The F indicates a test failure, and the detailed description of the
    failure informs us why the test fails: because of the AssertionError between these
    two strings. This error message should give us enough information to solve the
    problem. We can add a space in the string ''Laundry(3)'' to make the comparison
    equal.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到代表三个成功测试的三个点，而是看到了 ..F。F 表示测试失败，失败的详细描述告诉我们测试失败的原因：由于这两个字符串之间的 AssertionError。这个错误消息应该给我们足够的信息来解决该问题。我们可以在字符串
    'Laundry(3)' 中添加一个空格，使比较相等。
- en: 13.4.3 Discussion
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 讨论
- en: Testing should be an integral step in software development to ensure the quality
    of the product. During development, you should focus on removing bugs at the smallest
    possible scale. That is, you should do some manual testing whenever you complete
    a feature, even it’s a tiny one. You shouldn’t think “I’ll do the development
    now without doing any manual testing.” It’s much easier to solve any problem while
    you’re working on it. Although automatic testing can be powerful, you may have
    to refresh your memory before you can solve any problems that arise.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该是软件开发中的一个基本步骤，以确保产品的质量。在开发过程中，你应该专注于在尽可能小的范围内消除错误。也就是说，每当完成一个功能（即使是微小的功能）时，你应该进行一些手动测试。你不应该想“我现在先进行开发，不做任何手动测试。”在处理问题时，这样做更容易。尽管自动测试可能很强大，但在解决任何出现的问题之前，你可能需要刷新你的记忆。
- en: 13.4.4 Challenge
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.4 挑战
- en: A test that fails doesn’t have to be an AssertionError in our test class. It’s
    also possible that something is wrong with our code itself. Can you update the
    formatted_ display method to make it raise an exception and see what happens during
    the test?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试类中，一个失败的测试不一定是一个AssertionError。也可能我们的代码本身存在问题。你能更新formatted\_display方法，使其抛出异常，并在测试期间查看发生了什么吗？
- en: Hint The simplest way to raise an exception is to do so manually, such as raise
    TypeError.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：引发异常的最简单方法是手动进行，例如使用raise TypeError。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Tracebacks are detailed information that shows you how an exception is raised.
    The detailed information represents a series of operations or calls.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪信息提供了显示异常如何被抛出的详细信息。这些详细信息代表了一系列操作或调用。
- en: When you try to solve the problem from a traceback, you should focus on the
    last call in a traceback where the exception is raised.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您尝试从跟踪信息中解决问题时，应该关注跟踪信息中异常被抛出的最后一个调用。
- en: To examine some code’s execution closely, you can set a breakpoint, which activates
    the debugger. The pdb module is specifically designed for interactive debugging.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了仔细检查某些代码的执行情况，您可以设置断点，这会激活调试器。pdb模块专门设计用于交互式调试。
- en: With the interactive debugger, you can move execution line by line (the n command)
    so that we can know which line is the source of a problem.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式调试器，您可以逐行移动执行线（使用n命令），这样我们就可以知道哪个行是问题的来源。
- en: When you want to step into another operation, such as calling a function, you
    should use the s command instead of the n command, which executes the entire line
    instantly.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想要进入另一个操作，例如调用一个函数时，应该使用s命令而不是n命令，s命令会立即执行整行。
- en: The unittest module provides functionalities for automatic testing. It has the
    TestCase class, from which you can define your own test cases by creating a subclass.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: unittest模块提供了自动测试的功能。它包含TestCase类，您可以通过创建子类来定义自己的测试用例。
- en: You should respect the naming rules in terms of creating a testing method. It
    should start with test_, and the class should start with Test.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建测试方法时，您应该遵守命名规则。它应该以test_开头，类应该以Test开头。
- en: The basis of testing a function is the certainty of a function’s intended operation.
    When you provide some defined input, the function should generate the output without
    any ambiguity.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数的基础是函数预期操作的确定性。当您提供一些定义好的输入时，函数应该生成输出，没有任何歧义。
- en: In most cases, you can use assertEqual to evaluate the test results. You can
    use other methods in the TestCase class.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，您可以使用assertEqual来评估测试结果。您还可以在TestCase类中使用其他方法。
- en: Testing a class is effectively testing its methods, and you can apply the same
    techniques that you use to test functions to test methods.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试一个类实际上是在测试其方法，您可以将用于测试函数的相同技术应用到测试方法上。
