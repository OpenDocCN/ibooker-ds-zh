- en: 5 Working with providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 使用提供程序
- en: One of the more potentially confusing aspects of PowerShell is its use of a
    *provider. A* provider gives access to specialized data stores for easier viewing
    and management. The data appears in a drive in PowerShell.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中更可能让人感到困惑的方面之一是其对提供程序的使用。一个提供程序提供了访问专用数据存储的权限，以便更容易地查看和管理。这些数据在
    PowerShell 中显示为驱动器。
- en: 'We warn you that some of this chapter might seem a bit remedial for you. We
    expect that you’re familiar with the filesystem, for example, and you probably
    know all the commands you need to manage the filesystem from a shell. But bear
    with us: we’re going to point things out in a specific way so that we can use
    your existing familiarity with the filesystem to help make the concept of providers
    easier to understand. Also, keep in mind that PowerShell isn’t Bash. You may see
    some things in this chapter that look familiar, but we assure you that they’re
    doing something quite different from what you’re used to.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们警告您，本章中的一些内容可能对您来说有点基础。我们假设您熟悉文件系统，例如，您可能知道从 shell 管理文件系统所需的所有命令。但请耐心等待：我们将以特定的方式指出这些内容，以便我们可以利用您对文件系统的现有熟悉程度来帮助使提供程序的概念更容易理解。此外，请记住
    PowerShell 不是 Bash。您可能会在本章中看到一些看起来熟悉的内容，但我们向您保证，它们正在做与您习惯的完全不同的事情。
- en: 5.1 What are providers?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 提供程序是什么？
- en: 'A PowerShell provider, or *PSProvider*, is an adapter. It’s designed to take
    some kind of data storage, such as Windows Registry, Active Directory, or even
    the local filesystem, and make it look like a disk drive. You can see a list of
    installed PowerShell providers right within the shell:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 提供程序，或称为 *PSProvider*，是一个适配器。它旨在将某种数据存储（如 Windows 注册表、Active Directory
    或甚至本地文件系统）转换为看起来像磁盘驱动器的东西。您可以直接在 shell 中查看已安装的 PowerShell 提供程序列表：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Providers can also be added into the shell, typically along with a module,
    which are the two ways that PowerShell can be extended. (We’ll cover those extensions
    later in the book.) Sometimes, enabling certain PowerShell features may create
    a new PSProvider. For example, you can manipulate environment variables with the
    `Environment` provider, which we will cover in section 5.5 and you can see here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序也可以添加到 shell 中，通常与模块一起，这是 PowerShell 可以扩展的两种方式。（我们将在本书的后面部分介绍这些扩展。）有时，启用某些
    PowerShell 功能可能会创建一个新的 PSProvider。例如，您可以使用 `Environment` 提供程序来操作环境变量，我们将在第 5.5
    节中介绍，您也可以在这里看到：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that each provider has different capabilities. This is important, because
    it affects the ways in which you can use each provider. These are some of the
    common capabilities you’ll see:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个提供程序都有不同的功能。这很重要，因为它会影响您可以使用每个提供程序的方式。以下是一些您会看到的常见功能：
- en: '`ShouldProcess`—The provider supports the use of the `-WhatIf` and `-Confirm`
    parameters, enabling you to “test” certain actions before committing to them.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldProcess`—提供程序支持使用 `-WhatIf` 和 `-Confirm` 参数，使您能够在做出承诺之前“测试”某些操作。'
- en: '`Filter`—The provider supports the `-Filter` parameter on the cmdlets that
    manipulate providers’ content.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Filter`—提供程序支持在操作提供程序内容的 cmdlet 上使用 `-Filter` 参数。'
- en: '`Credentials`—The provider permits you to specify alternate credentials when
    connecting to data stores. There’s a `-Credential` parameter for this.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Credentials`—提供程序允许您在连接到数据存储时指定备用凭据。为此有一个 `-Credential` 参数。'
- en: 'You use a provider to create a *PSDrive*. A PSDrive uses a single provider
    to connect to data storage. You’re creating a drive mapping, and thanks to the
    providers, a PSDrive is able to connect to much more than disks. Run the following
    command to see a list of currently connected drives:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用提供程序来创建 *PSDrive*。PSDrive 使用单个提供程序来连接到数据存储。您正在创建驱动器映射，多亏了提供程序，PSDrive 能够连接到比磁盘多得多的东西。运行以下命令以查看当前连接的驱动器列表：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding list, you can see that we have one drive using the `FileSystem`
    provider, one using the `Env` provider, and so forth. The PSProvider adapts the
    data store, and the PSDrive makes it accessible. You use a set of cmdlets to see
    and manipulate the data exposed by each PSDrive. For the most part, the cmdlets
    you use with a PSDrive have the word `Item` somewhere in their noun:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，您可以看到我们有一个使用 `FileSystem` 提供程序的驱动器，一个使用 `Env` 提供程序的驱动器，等等。PSProvider
    适配数据存储，PSDrive 使其可访问。您使用一组 cmdlet 来查看和操作每个 PSDrive 暴露的数据。就大多数情况而言，您与 PSDrive 一起使用的
    cmdlet 的名词中都有 `Item` 这个词：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll use these cmdlets, and their aliases, to begin working with the providers
    on our system. Because it’s probably the one you’re most familiar with, we’ll
    start with the filesystem—the `FileSystem` PSProvider.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些 cmdlet 及其别名来开始处理我们系统上的提供器。因为它可能是你最熟悉的一个，所以我们将从文件系统——`FileSystem` PSProvider
    开始。
- en: 5.2 Understanding how the filesystem is organized
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 理解文件系统的组织结构
- en: The filesystem is organized around two main types of objects—folders and files.
    *Folders* are also a kind of container, capable of containing both files and other
    folders. *Files* aren’t a type of container; they’re more of an endpoint object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是围绕两种主要类型的对象组织起来的——文件夹和文件。*文件夹*也是一种容器，能够包含文件和其他文件夹。*文件*不是一种容器类型；它们更像是端点对象。
- en: You’re probably most familiar with viewing the filesystem through Finder on
    macOS, the file browser on Linux, or Explorer on your Windows device (figure 5.1),
    where the hierarchy of drives, folders, and files is visually obvious.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能最熟悉在 macOS 上的 Finder、Linux 上的文件浏览器或 Windows 设备上的资源管理器（图 5.1）中查看文件系统，在这些工具中，驱动器、文件夹和文件的层次结构在视觉上非常明显。
- en: '![](Images/CH05_F01_Plunk.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH05_F01_Plunk.png)'
- en: Figure 5.1 Viewing files, folders, and drives in Finder and Windows Explorer
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 在 Finder 和 Windows 资源管理器中查看文件、文件夹和驱动器
- en: PowerShell’s terminology differs somewhat from that of the filesystem. Because
    a PSDrive might not point to a filesystem—for example, a PSDrive can be mapped
    to the Environment, Registry, or even an SCCM endpoint, which is obviously not
    a filesystem—PowerShell doesn’t use the terms *file* and *folder*. Instead, it
    refers to these objects by the more generic term *item*. Both a file and a folder
    are considered items, although they’re obviously different types of items. That’s
    why the cmdlet names we showed you previously all use `Item` in their noun.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的术语与文件系统的术语略有不同。因为 PSDrive 可能不指向文件系统——例如，PSDrive 可以映射到环境、注册表，甚至 SCCM
    端点，这显然不是文件系统——PowerShell 不使用 *文件* 和 *文件夹* 这些术语。相反，它使用更通用的术语 *物品* 来指代这些对象。文件和文件夹都被视为物品，尽管它们显然是不同类型的物品。这就是为什么我们之前展示的
    cmdlet 名称都使用 `Item` 作为名词的原因。
- en: 'Items can, and often do, have properties. For example, a file item might have
    properties including its last write time, whether or not it’s read-only, and so
    on. Some items, such as folders, can have *child items*, which are the items contained
    within that item. Knowing those facts should help you make sense of the verbs
    and nouns in the command list we showed you earlier:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 物品可以，并且通常确实具有属性。例如，一个文件项可能具有包括最后写入时间、是否为只读等属性。一些物品，如文件夹，可以具有*子项*，这些是包含在该物品内的物品。了解这些事实应该有助于你理解我们之前展示的命令列表中的动词和名词：
- en: Verbs such as `Clear`, `Copy`, `Get`, `Move`, `New`, `Remove`, `Rename`, and
    `Set` can all apply to items (e.g., files and folders) and to item properties
    (e.g., the date the item was last written or whether it’s read-only).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`、`Copy`、`Get`、`Move`、`New`、`Remove`、`Rename` 和 `Set` 等动词都可以应用于物品（例如文件和文件夹）和物品属性（例如物品最后写入的日期或它是否为只读）。'
- en: The `Item` noun refers to individual objects, such as files and folders.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Item` 这个名词指的是单个对象，例如文件和文件夹。'
- en: The `ItemProperty` noun refers to attributes of an item, such as read-only,
    creation time, length, and so on.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemProperty` 这个名词指的是物品的属性，例如只读、创建时间、长度等。'
- en: The `ChildItem` noun refers to the items (e.g., files and subfolders) contained
    within an item (e.g., a folder).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildItem` 这个名词指的是包含在某个物品（例如文件夹）内的物品（例如文件和子文件夹）。'
- en: Keep in mind that these cmdlets are intentionally generic, because they’re meant
    to work with a variety of data stores. Some of the cmdlets’ capabilities don’t
    make sense in certain situations. As an example, because the `FileSystem` provider
    doesn’t support the `Transactions` capability, none of the cmdlets’ `-UseTransaction`
    parameters will work with items in the filesystem drives.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些 cmdlet 是故意设计成通用的，因为它们旨在与各种数据存储一起工作。一些 cmdlet 的功能在某些情况下可能没有意义。例如，由于 `FileSystem`
    提供器不支持 `Transactions` 功能，因此没有任何 `-UseTransaction` 参数可以与文件系统驱动器中的项目一起使用。
- en: 'Some PSProviders don’t support item properties. For example, the `Environment`
    PSProvider is what’s used to make the `ENV`: drive available in PowerShell. This
    drive provides access to the environment variables, but as the following example
    shows, they don’t have item properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 PSProviders 不支持物品属性。例如，`Environment` PSProvider 是用于在 PowerShell 中使 `ENV`
    驱动器可用的工具。此驱动器提供对环境变量的访问，但如下例所示，它们没有物品属性：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fact that not every PSProvider is the same is perhaps what makes providers
    so confusing for PowerShell newcomers. You have to think about what each provider
    is giving you access to, and understand that even when the cmdlet knows how to
    do something, that doesn’t mean the particular provider you’re working with will
    support that operation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，并非每个PSProvider都是相同的，这可能是使提供者对PowerShell新手来说如此令人困惑的原因。你必须考虑每个提供者为你提供了什么访问权限，并理解即使命令知道如何执行某项操作，这并不意味着你正在与之工作的特定提供者支持该操作。
- en: 5.3 Navigating the filesystem
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 导航文件系统
- en: 'Another cmdlet you need to know when working with providers is `Set-Location`.
    This is what you use to change the shell’s current location to a different container-type
    item, such as a folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当与提供者一起工作时，你需要了解的另一个命令是`Set-Location`。这是你用来将shell的当前位置更改为不同容器类型项目（如文件夹）的命令：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You’re probably more familiar with this command’s alias, `cd`, which corresponds
    to the `Change Directory` command from Bash. Here we use the alias and pass the
    desired path as a positional parameter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更熟悉这个命令的别名`cd`，它对应于Bash中的`Change Directory`命令。在这里，我们使用别名并将所需的路径作为位置参数传递：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Drives on non-Windows operating systems
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 非Windows操作系统的驱动器
- en: macOS and Linux don’t use drives to refer to discrete attached storage devices.
    Instead, the entire operating system has a single root, represented by a slash
    (in PowerShell, a backslash is also accepted). But PowerShell still provides PSDrives
    in non-Windows operating systems for other providers. Try running `Get-PSDrive`
    to see what’s available.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: macOS和Linux不使用驱动器来引用离散的附加存储设备。相反，整个操作系统有一个单一的根目录，用斜杠（在PowerShell中，反斜杠也被接受）表示。但PowerShell仍然在非Windows操作系统中为其他提供者提供PSDrives。尝试运行`Get-PSDrive`以查看可用内容。
- en: 'One of the trickier tasks in PowerShell is creating new items. For example,
    how do you create a new directory? Try running `New-Item` and you’ll get an unexpected
    prompt:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，创建新项目是较为棘手的一项任务。例如，如何创建一个新的目录？尝试运行`New-Item`，你会得到一个意外的提示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember, the `New-Item` cmdlet is generic—it doesn’t know you want to create
    a folder. It can create folders, files, and much more, but you have to tell it
    the type of item you want to create:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`New-Item`命令是通用的——它不知道你想要创建文件夹。它可以创建文件夹、文件以及更多内容，但你必须告诉它你想要创建的项目类型：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Windows PowerShell did include a `mkdir` command, which most people think is
    an alias for `New-Item`. But using `mkdir` doesn’t require you to specify the
    directory `-ItemType`. Because of the conflict with the built-in `mkdir` command,
    the `mkdir` function was removed in PowerShell Core for non-Windows platforms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Windows PowerShell确实包含了一个`mkdir`命令，大多数人认为它是`New-Item`的别名。但使用`mkdir`不需要你指定目录`-ItemType`。由于与内置的`mkdir`命令冲突，`mkdir`函数在PowerShell
    Core的非Windows平台上被移除。
- en: 5.4 Using wildcards and literal paths
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 使用通配符和字面路径
- en: 'Most providers allow you to specify paths in two ways using the `Item` cmdlets.
    This section will discuss these two ways of specifying paths. The `Item` cmdlets
    include the `-Path` parameter, and by default that parameter accepts wildcards.
    Looking at the full help for `Get-ChildItem`, for example, reveals the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供者允许你使用`Item`命令以两种方式指定路径。本节将讨论这两种指定路径的方式。`Item`命令包括`-Path`参数，默认情况下该参数接受通配符。例如，查看`Get-ChildItem`的完整帮助，可以发现以下内容：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `*` wildcard stands in for zero or more characters, whereas the `?` wildcard
    stands in for any single character. You’ve doubtless used this time and time again,
    probably with the `Dir` alias for `Get-ChildItem`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`通配符代表零个或多个字符，而`?`通配符代表任何单个字符。你无疑已经多次使用过这个，可能使用的是`Dir`别名来代替`Get-ChildItem`：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Linux and macOS, most of these wildcards are allowed as part of the names
    of items in the filesystem as well as in most other stores. In the Environment,
    for example, you’ll find a few values with names that include `?`. This presents
    a problem: When you use `*` or `?` in a path, is PowerShell supposed to treat
    it as a wildcard character or as a literal character? If you look for items named
    `variable?`, do you want the item with `variable?` as its name, or do you want
    `?` treated as a wildcard, giving you items such as `variable7` and `variable8`
    instead?'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS中，大多数这些通配符都可以作为文件系统中的项目名称以及大多数其他存储中的部分。例如，在环境变量中，你会找到一些包含`?`的名称的值。这提出了一个问题：当你使用`*`或`?`作为路径的一部分时，PowerShell应该将其视为通配符字符还是作为字面字符？如果你寻找名为`variable?`的项目，你是想要名为`variable?`的项目，还是想要将`?`视为通配符，从而得到如`variable7`和`variable8`之类的项目？
- en: 'PowerShell’s solution is to provide an alternate `-LiteralPath` parameter.
    This parameter doesn’t accept wildcards:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 的解决方案是提供一个替代的 `-LiteralPath` 参数。此参数不接受通配符：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you want `*` and `?` taken literally, you use `-LiteralPath` instead of
    the `-Path` parameter. Note that `-LiteralPath` isn’t positional; if you plan
    to use it, you have to type `-LiteralPath`. If you provide a path in the first
    position (such as `y*` in our first example), it’ll be interpreted as being for
    the `-Path` parameter. Wildcards are also treated as such.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将 `*` 和 `?` 字面理解时，使用 `-LiteralPath` 而不是 `-Path` 参数。请注意，`-LiteralPath` 不是位置参数；如果您打算使用它，您必须键入
    `-LiteralPath`。如果您在第一个位置提供了一个路径（例如，我们第一个例子中的 `y*`），它将被解释为 `-Path` 参数。通配符也被这样处理。
- en: 5.5 Working with other providers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 与其他提供者一起工作
- en: One of the best ways to get a feel for these other providers, and how the various
    `item` cmdlets work, is to play with a PSDrive that isn’t the filesystem. Of the
    providers built into PowerShell, the Environment is probably the best example
    to work with (in part because it’s available on every system).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些其他提供者以及各种 `item` cmdlet 的工作方式的一个最好的方法是通过玩一个不是文件系统的 PSDrive。在 PowerShell
    内置的提供者中，环境可能是最好的例子（部分原因是因为它在每个系统上都是可用的）。
- en: 'We will create an environment variable. Note that we are using an Ubuntu terminal
    for this exercise, but you can follow along just the same regardlessly if you
    are on a Windows or macOS machine (the wonders of cross-platform). Start by listing
    all environment variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个环境变量。请注意，我们在这个练习中使用的是 Ubuntu 终端，但无论您是在 Windows 还是 macOS 机器上，都可以同样跟随（跨平台的奇妙之处）。首先列出所有环境变量：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, set the environment variable `A` to the value `1`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将环境变量 `A` 设置为值 `1`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 5.5.1 Windows Registry
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 Windows 注册表
- en: 'Another provider we can look at on a Windows machine is the Registry. Let’s
    start by changing to the `HKEY_CURRENT_USER` portion of the Registry, exposed
    by the `HKCU:` drive:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，我们还可以查看的另一个提供者是注册表。让我们首先切换到注册表的 `HKEY_CURRENT_USER` 部分，由 `HKCU:`
    驱动器暴露：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: note You may have to launch PowerShell as administrator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能需要以管理员身份启动 PowerShell。
- en: 'Next, navigate to the right portion of the Registry:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导航到注册表的正确部分：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’re almost finished. You’ll notice that we’re sticking with full cmdlet
    names rather than using aliases to emphasize the cmdlets themselves:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了。你会注意到我们坚持使用完整的 cmdlet 名称，而不是使用别名来强调 cmdlet 本身：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note the `EnableAeroPeek` Registry value. Let’s change it to `0`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `EnableAeroPeek` 注册表值。让我们将其更改为 `0`：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You also could have used the `–Name` parameter instead of `–PSProperty`. Let’s
    check it again to make sure the change “took”:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `–Name` 参数而不是 `–PSProperty`。让我们再次检查以确保更改“生效”：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Mission accomplished! Using these same techniques, you should be able to work
    with any provider that comes your way.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！使用这些相同的技巧，你应该能够处理任何你遇到的提供者。
- en: 5.6 Lab
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 实验室
- en: Note For this lab, you need any computer running PowerShell v7.1 or later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验，您需要任何运行 PowerShell v7.1 或更高版本的计算机。
- en: 'Complete the following tasks from a PowerShell prompt:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PowerShell 提示符中完成以下任务：
- en: Create a new directory called Labs.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 Labs 的新目录。
- en: Create a zero-length file named /Labs/Test.txt (use `New-Item`).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 /Labs/Test.txt 的零长度文件（使用 `New-Item`）。
- en: Is it possible to use `Set-Item` to change the contents of /Labs/Test.txt to
    -`TESTING`? Or do you get an error? If you get an error, why?
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Set-Item` 将 /Labs/Test.txt 的内容更改为 `-TESTING` 是否可能？或者你会得到一个错误？如果你得到一个错误，为什么？
- en: Using the Environment provider, display the value of the system environment
    variable `PATH`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环境提供者，显示系统环境变量 `PATH` 的值。
- en: Use help to determine what the differences are between the `-Filter`, `-Include`,
    and `-Exclude` parameters of `Get-ChildItem`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用帮助来确定 `Get-ChildItem` 的 `-Filter`、`-Include` 和 `-Exclude` 参数之间的区别。
- en: 5.7 Lab answers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 实验答案
- en: '`New-Item -Path ~/Labs -ItemType Directory`'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-Item -Path ~/Labs -ItemType Directory`'
- en: '`New-Item –Path ~/labs -Name test.txt -ItemType file`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New-Item –Path ~/labs -Name test.txt -ItemType file`'
- en: The `FileSystem` provider doesn’t support this action.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileSystem` 提供者不支持此操作。'
- en: 'Either of these commands works:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下任一命令都有效：
- en: '`Get-Item env:PATH`'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-Item env:PATH`'
- en: '`Dir env:PATH`'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Dir env:PATH`'
- en: '`-Include` and `-Exclude` must be used with `–Recurse` or if you’re querying
    a container. `Filter` uses the PSProvider’s filter capability, which not all providers
    support. For example, you could use `DIR –filter` in the filesystem.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Include` 和 `-Exclude` 必须与 `–Recurse` 或如果您正在查询一个容器一起使用。`Filter` 使用 PSProvider
    的过滤功能，并非所有提供者都支持。例如，您可以在文件系统中使用 `DIR –filter`。'
- en: Above and beyond
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Did you run into any issues with task 4? PowerShell on a Windows machine is
    case insensitive, meaning uppercase and lowercase letters don’t matter. `PATH`
    is the same as `path`. However, in a Linux or macOS machine, capitalization matters:
    `PATH` is not the same as `path`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你在任务4中遇到任何问题了吗？在Windows机器上，PowerShell是不区分大小写的，这意味着大写和小写字母并不重要。`PATH`和`path`是相同的。然而，在Linux或macOS机器上，大小写很重要：`PATH`和`path`是不同的。
