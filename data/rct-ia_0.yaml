- en: Part 1\. Meet React
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1部分. 认识React
- en: 'If you’ve worked on frontend JavaScript applications in the past two years,
    you’ve probably heard of React. You might have heard of it even if you’re just
    starting out building user interfaces. Even if you’re hearing about React for
    the first time in this book, I’ve still got you covered: there are many hugely
    popular applications that use React. If you use Facebook, watch Netflix, or learn
    about computer science through Khan Academy, you’ve used an application built
    with React.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你过去两年在开发前端JavaScript应用程序，你很可能听说过React。即使你刚开始构建用户界面，你也可能听说过它。即使你在这本书中第一次听到React，我仍然会照顾你：有许多非常流行的应用程序使用React。如果你使用Facebook，观看Netflix，或者通过Khan
    Academy学习计算机科学，你已经使用了一个用React构建的应用程序。
- en: React is a library for building user interfaces. It was created by engineers
    at Facebook and since its release has made waves in the JavaScript communities.
    It’s gained in popularity over the past few years and is the tool of choice for
    many teams and engineers building dynamic user interfaces. In fact, the combination
    of React’s API, mental model, and robust community have led to the development
    of React for other platforms, including mobile and even virtual reality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个用于构建用户界面的库。它是由Facebook的工程师创建的，自发布以来在JavaScript社区中引起了轰动。在过去几年中，它的受欢迎程度有所上升，并且是许多团队和工程师构建动态用户界面的首选工具。事实上，React的API、思维模型和强大的社区的结合导致了React在其他平台上的开发，包括移动和甚至虚拟现实。
- en: In this book, you’ll explore React and see why it’s been such a successful and
    useful open source project. In [part 1](#part01), you’ll start with the basics
    of React and learn them from the ground up. Because the tooling involved in building
    robust JavaScript UI applications can be incredibly complex, we’ll avoid getting
    bogged down in tools and focus on learning the ins and outs of the React API.
    We’ll also avoid “magic” and work toward a concrete understanding of React and
    how it works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将探索React，了解为什么它是一个如此成功和有用的开源项目。在[第1部分](#part01)中，你将从React的基础开始学习。由于构建健壮的JavaScript
    UI应用程序所涉及的工具可能非常复杂，我们将避免陷入工具的泥潭，专注于学习React API的细节。我们还将避免“魔法”，并努力对React及其工作原理有一个具体和深入的理解。
- en: In [chapter 1](kindle_split_011_split_000.xhtml#ch01), you’ll learn about React
    at a high level. We’ll cover some important ideas like components, the virtual
    DOM, and some of the tradeoffs of React. In [chapter 2](kindle_split_012_split_000.xhtml#ch02),
    you’ll take a whirlwind tour through React’s APIs and build a simple comment-box
    component to get your hands dirty with React.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](kindle_split_011_split_000.xhtml#ch01)中，你将从高层次了解React。我们将涵盖一些重要思想，如组件、虚拟DOM以及React的一些权衡。在第2章[第2章](kindle_split_012_split_000.xhtml#ch02)中，你将快速浏览React的API，并构建一个简单的评论框组件，以便亲身体验React。
- en: Chapter 1\. Meet React
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章. 认识React
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing React
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍React
- en: Some of React’s high-level concepts and paradigms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React的一些高级概念和范式
- en: The virtual DOM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: Components in React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的组件
- en: React for teams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React团队
- en: Tradeoffs of using React
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React的权衡
- en: 'If you work as a web engineer in the tech industry, chances are you’ve heard
    of React. Maybe it was somewhere online like Twitter or Reddit. Maybe a friend
    or colleague mentioned it to you or you heard a talk about it at a meetup. Wherever
    it was, I bet that what you heard was probably either glowing or a bit skeptical.
    Most people tend to have a strong opinion about technologies like React. Influential
    and impactful technologies tend to generate that kind of response. For these technologies,
    often a smaller number of people initially “get it” before the technology catches
    on and moves to a broader audience. React started this way, but now enjoys immense
    popularity and use in the web engineering world. And it’s popular for good reason:
    it has a lot to offer and can reinvigorate, renew, or even transform how you think
    about and build user interfaces.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你作为科技行业的Web工程师工作，你很可能听说过React。也许是在Twitter或Reddit等在线平台。也许是一个朋友或同事向你提起，或者你在一次Meetup上听到了关于它的演讲。无论在哪里，我敢打赌你听到的可能是赞扬或有点怀疑。大多数人对于像React这样的技术都有强烈的看法。有影响力和影响力的技术往往会引起这种反应。对于这些技术，通常在技术流行并扩展到更广泛的受众之前，只有少数人最初“理解”它。React就是这样开始的，但现在在Web工程领域享有巨大的流行度和使用率。而且它之所以受欢迎，有很好的理由：它有很多东西可以提供，并且可以重新激发、更新甚至改变你对用户界面思考和构建的看法。
- en: 1.1\. Meet React
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 认识React
- en: React is a JavaScript library for building user interfaces across a variety
    of platforms. React gives you a powerful mental model to work with and helps you
    build user interfaces in a declarative and component-driven way. We’ll unpack
    these ideas and much more over the course of the book, but that’s what React is
    in the broadest, briefest sense.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个用于在各种平台上构建用户界面的JavaScript库。React为你提供了一个强大的心智模型来工作，并帮助你以声明性和组件驱动的方式构建用户界面。我们将在本书的其余部分详细探讨这些想法以及更多内容，这就是React在广义上最简短的解释。
- en: Where does React fit into the broader world of web engineering? You’ll often
    hear React talked about in the same space as projects like Vue, Preact, Angular,
    Ember, Webpack, Redux and other well-known JavaScript libraries and frameworks.
    React is often a major part of front-end applications and shares similar features
    with the other libraries and frameworks just mentioned. In fact, many popular
    front-end technologies are more like React in subtle ways now than in the past.
    There was a time when React’s approach was novel, but other technologies have
    since been influenced by React’s component-driven, declarative approach. React
    continues to maintain a spirit of rethinking established best practices, with
    the main goal being providing developers with an expressive mental model and a
    performant technology to build UI applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: React在更广泛的网络工程世界中处于什么位置？你经常会听到React与Vue、Preact、Angular、Ember、Webpack、Redux和其他知名JavaScript库和框架一起被提及。React通常是前端应用程序的主要部分，并且与上述其他库和框架具有相似的功能。事实上，许多流行的前端技术现在在微妙的方式上更像是React，而不是过去。曾经有一段时间，React的方法是新颖的，但其他技术后来受到了React的组件驱动、声明式方法的影响。React继续保持着重新思考既定最佳实践的精神，主要目标是向开发者提供一个表达性的心智模型和性能良好的技术来构建UI应用程序。
- en: What makes React’s mental model powerful? It draws on deep areas of computer
    science and software engineering techniques. React’s mental model draws broadly
    on functional and object-oriented programming concepts and focuses on components
    as primary units for building with. In React applications, you create interfaces
    from components. React’s rendering system manages these components and keeps the
    application view in sync for you. Components often correspond to aspects of the
    user interface, like datepickers, headers, navbars, and others, but they can also
    take responsibility for things like client-side routing, data formatting, styling,
    and other responsibilities of a client-side application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使React的心智模型强大？它借鉴了计算机科学和软件工程技术的深层次领域。React的心智模型广泛借鉴了函数式和面向对象编程的概念，并专注于组件作为构建的主要单元。在React应用程序中，你从组件创建接口。React的渲染系统管理这些组件，并为你保持应用程序视图的一致性。组件通常对应于用户界面的某些方面，如日期选择器、标题、导航栏等，但它们也可以负责客户端路由、数据格式化、样式和其他客户端应用程序的责任。
- en: 'Components in React should be easy to think about and integrate with other
    React components; they follow a predictable lifecycle, can maintain their own
    internal state, and work with “regular old JavaScript.” We’ll dive into these
    ideas over the course of the rest of the book, but we can look at them at a high
    level right now. [Figure 1.1](kindle_split_011_split_001.xhtml#ch01fig01) gives
    you an overview of the major ingredients that go into a React application. Let’s
    look at each part briefly:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: React中的组件应该易于思考和与其他React组件集成；它们遵循可预测的生命周期，可以维护自己的内部状态，并且与“常规的JavaScript”协同工作。我们将在本书的其余部分深入探讨这些想法，但我们可以现在从高层次上看看它们。[图1.1](kindle_split_011_split_001.xhtml#ch01fig01)为你概述了构建React应用程序的主要成分。让我们简要地看看每个部分：
- en: '***Components*—** Encapsulated units of functionality that are the primary
    unit in React. They utilize data (*properties* and *state*) to render your UI
    as output; we’ll explore how React components work with data later in [chapter
    2](kindle_split_012_split_000.xhtml#ch02) onward. Certain types of React components
    also provide a set of lifecycle methods that you can hook into. The *rendering
    process* (outputting and updating a UI based on your data) is predictable in React,
    and your components can hook into it using React’s APIs.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件*—**封装的功能单元，是React中的基本单元。它们利用数据（*属性*和*状态*）来渲染UI作为输出；我们将在第2章及以后章节中探讨React组件如何与数据协同工作。某些类型的React组件还提供了一组生命周期方法，你可以将其钩入。在React中，*渲染过程*（基于你的数据输出和更新UI）是可预测的，并且你的组件可以使用React的API将其钩入。'
- en: '***React libraries*—** React uses a set of core libraries. The core React library
    works with the `react-dom` and `react-native` libraries and is focused on component
    specification and definition. It allows you to build a tree of components that
    a renderer for the browser or another platform can use. `react-dom` is one such
    renderer and is aimed at browser environments and server-side rendering. The React
    Native libraries focus on native platforms and let you create React applications
    for iOS, Android, and other platforms.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 库**—React 使用一组核心库。核心 React 库与 `react-dom` 和 `react-native` 库协同工作，专注于组件规范和定义。它允许你构建一个组件树，浏览器或其他平台的渲染器可以使用。`react-dom`
    是这样一个渲染器，旨在浏览器环境和服务器端渲染。React Native 库专注于原生平台，并允许你为 iOS、Android 和其他平台创建 React
    应用。'
- en: Figure 1.1\. React allows you to create user interfaces from components. Components
    maintain their own state, are written in and work with “vanilla” JavaScript, and
    inherit a number of helpful APIs from React. Most React apps are written for browser-based
    environments, but can also be used in native environments like iOS and Android.
    For more about React Native, see Nader Dabit’s *React Native in Action*, also
    available from Manning.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1. React 允许你从组件创建用户界面。组件维护自己的状态，使用并配合“纯”JavaScript 编写，并从 React 继承了许多有用的
    API。大多数 React 应用是为基于浏览器的环境编写的，但也可以在 iOS 和 Android 等原生环境中使用。有关 React Native 的更多信息，请参阅
    Nader Dabit 的《React Native in Action》，该书也由 Manning 出版。
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片 1.1](Images/01fig01_alt.jpg)'
- en: '***Third-party libraries*—** React doesn’t come with tools for data modeling,
    HTTP calls, styling libraries, or other common aspects of a front-end application.
    This leaves you free to use additional code, modules, or other tools you prefer
    in your application. And even though these common technologies don’t come bundled
    with React, the broader ecosystem around React is full of incredibly useful libraries.
    In this book, we’ll use a few of these libraries and devote [chapters 10](kindle_split_022_split_000.xhtml#ch10)
    and [11](kindle_split_023_split_000.xhtml#ch11) to looking at Redux, a library
    for state management.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方库**—React 并不自带数据建模、HTTP 请求、样式库或其他前端应用常见方面的工具。这让你可以自由地在应用中使用额外的代码、模块或其他你偏好的工具。尽管这些常见技术并未与
    React 一同打包，但围绕 React 的更广泛生态系统充满了极其有用的库。在这本书中，我们将使用其中的一些库，并在第 [10](kindle_split_022_split_000.xhtml#ch10)
    章和第 [11](kindle_split_023_split_000.xhtml#ch11) 章中探讨 Redux，这是一个用于状态管理的库。'
- en: '***Running a React application*—** Your React application runs on the platform
    you’re building for. This book focuses on the web platform and builds a browser
    and server-based application, but other projects like React Native and React VR
    open the possibility of your app running on other platforms.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行 React 应用**—你的 React 应用运行在你构建的平台之上。这本书专注于 Web 平台，并构建基于浏览器和服务器端的应用，但其他项目如
    React Native 和 React VR 也为你的应用在其它平台上运行打开了可能性。'
- en: We’ll spend lots of time exploring the ins and outs of React in this book, but
    you may have a few questions before getting started. Is React something for you?
    Who else is using React? What are some of the tradeoffs of using React or not?
    These are important questions about a new technology that you’ll want answered
    before adopting it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将花费大量时间探索 React 的方方面面，但在开始之前，你可能会有一些疑问。React 是否适合你？还有谁在使用 React？使用 React
    或不使用 React 的一些权衡是什么？在采用这项新技术之前，这些问题对于新技术的了解非常重要。
- en: 1.1.1\. Who this book is for
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 这本书面向的对象
- en: This book is for anyone who’s working on or interested in building user interfaces.
    Really, it’s is for anyone who’s curious about React, even if you don’t work in
    UI engineering. You’ll get the most out of this book if you have some experience
    with using JavaScript to build front-end applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书适合任何正在构建用户界面或对此感兴趣的人。实际上，它适合任何对 React 感兴趣的人，即使你不从事 UI 工程工作。如果你有一些使用 JavaScript
    构建前端应用的经验，你将能从这本书中获得最大收益。
- en: You can learn how to build applications with React as long as you know the basics
    of JavaScript and have some experience building web applications. I don’t cover
    the fundamentals of JavaScript in this book. Topics like prototypal inheritance,
    ES2015+ code, type coercion, syntax, keywords, asynchronous coding patterns like
    async/await, and other fundamental topics are beyond the scope of this book. I
    do lightly cover anything that’s especially pertinent to React but don’t dive
    deep into JavaScript as a language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你掌握了JavaScript的基础知识并有一些构建Web应用程序的经验，你就可以学习如何使用React来构建应用程序。在这本书中，我不会涵盖JavaScript的基础知识。像原型继承、ES2015+代码、类型强制转换、语法、关键字、异步编码模式如async/await以及其他基本主题都不在本书的范围之内。我会简要地介绍与React特别相关的任何内容，但不会深入探讨JavaScript作为一门语言。
- en: 'This doesn’t mean you can’t learn React or won’t get anything from this book
    if you don’t know JavaScript. But you’ll get much more if you take the time to
    learn JavaScript first. Charging ahead without a working knowledge of JavaScript
    will make things more difficult. You might run into situations where things might
    seem like “magic” to you—things will work, but you won’t understand why. This
    usually hurts rather than helps you as a developer, so ... last warning: get comfortable
    with the basics of JavaScript before learning React. It’s a wonderfully expressive
    and flexible language. You’ll love it!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着如果你不知道JavaScript，就不能学习React或从这本书中学不到任何东西。但如果你花时间先学习JavaScript，你会得到更多。在没有掌握JavaScript的实际知识的情况下盲目前进会使事情变得更难。你可能会遇到一些对你来说像是“魔法”的情况——事情会工作，但你不会明白为什么。这通常对作为开发者的你来说弊大于利，所以...最后警告：在学习React之前，先熟悉JavaScript的基础知识。它是一门非常表达性和灵活的语言。你会喜欢的！
- en: You may already know JavaScript well and may have even dabbled in React before.
    This wouldn’t be too surprising given how popular React has become. If this is
    you, you’ll be able to gain a deeper understanding of some of the core concepts
    of React. But I don’t cover highly specific topics you may be looking for if you’ve
    been working with React for a while. For those, see other React-related Manning
    titles like *React Native in Action*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经很好地了解了JavaScript，甚至可能之前已经尝试过React。鉴于React的流行程度，这并不令人惊讶。如果你是这样的人，你将能够更深入地理解React的一些核心概念。但如果你已经使用React一段时间，我不会涵盖你可能正在寻找的非常具体的话题。对于这些，请参阅其他与React相关的Manning书籍，如*React
    Native in Action*。
- en: You may not fit into either group and may want a high-level overview of React.
    This book is for you, too. You’ll learn the fundamental concepts of React and
    you’ll have access to a sample application written in React—check out the running
    app at [https://social.react.sh](https://social.react.sh). You’ll be able to see
    the basics of building a React application in practice and how it might be suited
    to your team or next project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不属于上述任何一组，可能想要对React有一个高级概述。这本书也适合你。你将学习React的基本概念，并且可以访问一个用React编写的示例应用程序——查看运行中的应用程序[https://social.react.sh](https://social.react.sh)。你将能够看到在实践中构建React应用程序的基本方法以及它可能适合你的团队或下一个项目。
- en: 1.1.2\. A note on tooling
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 关于工具的说明
- en: If you’ve worked extensively on front-end applications in the past few years,
    you won’t be surprised by the fact that the tooling around applications has become
    as much a part of the development process as frameworks and libraries themselves.
    You’re likely using something like Webpack, Babel, or other tools in your applications
    today. Where do these and other tools fit into this book, and what you need to
    know?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你过去几年在前端应用程序方面的工作很多，你不会对应用程序周围的工具已经变得与框架和库本身一样成为开发过程的一部分而感到惊讶。你今天可能正在使用Webpack、Babel或其他工具。这些和其他工具在这个书中如何定位，你需要了解什么？
- en: You don’t need to be a master of Webpack, Babel, or other tools to enjoy and
    read this book. The sample application I’ve created utilizes a handful of important
    tools, and you can feel free to read through the configuration code for these
    in the sample application, but I don’t cover these tools in depth in this book.
    Tooling changes quickly, and more importantly, it would be well outside the scope
    of this book to cover these topics in depth. I’ll be sure to note anywhere tooling
    is relevant to our discussion, but besides that I’ll avoid covering it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要成为Webpack、Babel或其他工具的大师就能享受和阅读这本书。我创建的示例应用程序使用了几个重要的工具，你可以自由地阅读示例应用程序中的配置代码，但我不会在这本书中深入探讨这些工具。工具的变化很快，更重要的是，深入探讨这些主题会远远超出本书的范围。我会在工具与我们的讨论相关的地方确保注明，但除此之外，我会避免涉及。
- en: I also feel that tooling can be a distraction when learning a new technology
    like React. You’re already trying to get your head around a new set of concepts
    and paradigms—why clutter that with learning complex tooling too? That’s why [chapter
    2](kindle_split_012_split_000.xhtml#ch02) focuses on learning “vanilla” React
    first before moving on to features like JSX and JavaScript language features that
    require build tools. The one area of tooling that you’ll need to be familiar with
    is npm. npm is the package management tool for JavaScript, and you’ll use it to
    install dependencies for your project and run project commands from the command
    line. It’s likely you’re already familiar with npm, but if not, don’t let that
    dissuade you from reading the book. You only need the most basic terminal and
    npm skills to go forward. You can learn about npm at [https://docs.npmjs.com/getting-started/what-is-npm](https://docs.npmjs.com/getting-started/what-is-npm).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我还觉得在学习像 React 这样的新技术时，工具可能会分散注意力。你已经在尝试理解一套全新的概念和范式了——为什么还要在学习复杂的工具上增加负担呢？这就是为什么第
    2 章专注于首先学习“纯”React，然后再学习需要构建工具的 JSX 和 JavaScript 语言特性。你需要熟悉的一个工具领域是 npm。npm 是
    JavaScript 的包管理工具，你将用它来安装项目的依赖项，并从命令行运行项目命令。你可能已经熟悉 npm 了，但如果不是，不要让这阻止你阅读这本书。你只需要最基础的终端和
    npm 技能就可以继续前进。你可以在 [https://docs.npmjs.com/getting-started/what-is-npm](https://docs.npmjs.com/getting-started/what-is-npm)
    上了解 npm。
- en: 1.1.3\. Who uses React?
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 谁使用 React？
- en: When it comes to open source software, who is (and who isn’t) using it is more
    than just a matter of popularity. It affects the experience you’ll have working
    with the technology (including availability of support, documentation, and security
    fixes), the level of innovation in the community, and the potential lifetime of
    a certain tool. It’s generally more fun, easier, and overall a smoother experience
    to work with tools that have a vibrant community, a robust ecosystem, and a diversity
    of contributor experience and background.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开源软件时，谁在使用（以及谁没有使用）不仅仅是一个流行度的问题。它会影响你使用该技术的体验（包括支持、文档和安全修复的可用性），社区的创新水平，以及某个工具的潜在使用寿命。与拥有活跃社区、强大生态系统和多样化的贡献者经验和背景的工具一起工作通常更有趣、更容易，并且整体上更顺畅的体验。
- en: React started as a small project but now has broad popularity and a vibrant
    community. No community is perfect, and React’s isn’t either, but as far as open
    source communities go, it has many important ingredients for success. What’s more,
    the React community also includes smaller subsets of other open source communities.
    This can be daunting because the ecosystem can seem vast, but it also makes the
    community robust and diverse. [Figure 1.2](kindle_split_011_split_001.xhtml#ch01fig02)
    shows a map of the React ecosystem. I mention various libraries and projects throughout
    the course of the book, but if you’re curious to learn more about the React ecosystem,
    I’ve put together a guide at [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem).
    I’ll keep this updated over time and ensure it evolves as the ecosystem does.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: React 最初是一个小项目，但现在拥有广泛的流行度和一个充满活力的社区。没有社区是完美的，React 的社区也不例外，但就开源社区而言，它拥有许多成功的重要元素。更重要的是，React
    社区还包括其他开源社区的小子集。这可能令人望而生畏，因为生态系统可能看起来很庞大，但它也使社区变得强大和多样化。[图 1.2](kindle_split_011_split_001.xhtml#ch01fig02)
    展示了 React 生态系统的地图。我在本书的整个过程中提到了各种库和项目，但如果你对了解 React 生态系统感兴趣，我已准备了一份指南 [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem)。我会随着时间的推移保持更新，并确保它与生态系统的演变保持一致。
- en: Figure 1.2\. A map of the React ecosystem is diverse—even more so than I can
    represent here. If you’d like to learn more, check out my guide at [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem),
    which will help you find your way in the React ecosystem when starting out.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. React 生态系统图丰富多彩——甚至比我这里能展示的还要丰富。如果你想了解更多，请查看我的指南 [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem)，它将帮助你入门
    React 生态系统。
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.2](Images/01fig02_alt.jpg)'
- en: 'The primary way you might interact with React is probably in open source, but
    you likely use apps built with it every day. Many companies use React in different
    and exciting ways. Here are a few of the companies using React to power their
    products:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能与 React 的主要互动方式可能是开源，但你可能每天都在使用用其构建的应用程序。许多公司以不同的方式使用 React。以下是一些使用 React
    为其产品提供动力的公司：
- en: Facebook
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facebook
- en: Netflix
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix
- en: New Relic
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: New Relic
- en: Uber
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Uber
- en: Wealthfront
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wealthfront
- en: Heroku
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku
- en: PayPal
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PayPal
- en: BBC
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BBC
- en: Microsoft
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft
- en: NFL
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFL
- en: And more!
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多！
- en: Asana
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Asana
- en: ESPN
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESPN
- en: Walmart
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Walmart
- en: Venmo
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Venmo
- en: Codecademy
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codecademy
- en: Atlassian
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atlassian
- en: Asana
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Asana
- en: Airbnb
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Airbnb
- en: Khan Academy
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Khan Academy
- en: FloQast
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FloQast
- en: These companies aren’t blindly following the trends of the JavaScript community.
    They have exceptional engineering demands that impact a huge number of users and
    must deliver products on hard deadlines. Someone saying, “I heard React was good;
    we should React-ify everything!” won’t fly with managers or other engineers. Companies
    and developers want good tools that help them think better and move quickly so
    they can build high-impact, scalable, and reliable applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公司并不是盲目跟随JavaScript社区的潮流。它们有非凡的工程需求，这些需求影响了大量用户，并且必须在严格的截止日期内交付产品。有人会说，“我听说React很好；我们应该将一切React化！”这样的说法在经理或其他工程师那里是不会被接受的。公司和开发者想要好的工具，这些工具可以帮助他们更好地思考，快速行动，以便他们能够构建具有高影响力、可扩展和可靠的软件。
- en: 1.2\. What does React not do?
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. React不做什么？
- en: 'So far, I’ve been talking about React at a high-level: who uses it, who this
    book is for, and so on. My primary goals in writing this book are to teach you
    how to build applications with React and empower you as an engineer. React isn’t
    perfect, but it’s genuinely been a pleasure to work with, and I’ve seen teams
    do great things with it. I love writing about it, building with it, hearing talks
    about it at conferences, and engaging in the occasional spirited debate about
    this or that pattern.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直在从高层次上谈论React：谁在使用它，这本书是为谁写的，等等。我写这本书的主要目标是教你如何使用React构建应用程序，并赋予你作为工程师的权力。React并不完美，但与它一起工作确实是一种乐趣，我看到了团队用它做了很多伟大的事情。我喜欢写关于它，用它构建，在会议上听关于它的演讲，偶尔就这个或那个模式进行热烈的辩论。
- en: 'But I would be doing you a disservice if I didn’t talk about some of the downsides
    of React and describe what it *doesn’t* do. Understanding what something can’t
    do is as important as understanding what it can do. Why? The best engineering
    decisions and thinking usually happen in terms of tradeoffs instead of opinions
    or absolutes (“React is fundamentally better than tool *X* because I like it more”).
    On the former point: you’re probably not dealing with two totally different technologies
    (COBOL versus JavaScript); hopefully you’re not even considering technologies
    that are fundamentally unsuited to the task at hand. And to the latter point:
    building great projects and solving engineering challenges should never be about
    opinions. It’s not that people’s opinions don’t matter—that’s certainly not true—it’s
    that opinions don’t make things work well or at all.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我不谈论一些React的缺点并描述它*不*做什么，那我就对你不公平了。理解某物不能做什么和了解它能做什么一样重要。为什么？最好的工程决策和思考通常是基于权衡，而不是意见或绝对论（“React在本质上比工具*X*更好，因为我更喜欢它”）。关于前者：你可能不是在处理两种完全不同的技术（COBOL与JavaScript）；希望你甚至没有考虑那些与当前任务基本不匹配的技术。至于后者：构建伟大的项目和解决工程挑战永远不应该是关于意见的。并不是说人们的意见不重要——这当然是不正确的——而是意见并不能让事情变得更好或根本无法工作。
- en: 1.2.1\. Tradeoffs of React
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. React的权衡
- en: 'If tradeoffs are the bread and butter of good software evaluation and discussion,
    what tradeoffs are there with React? First, React is sometimes called *just the
    view*. This can be misconstrued or misunderstood because it can lead you to think
    React is just a templating system like Handlebars or Pug (née Jade) or that it
    has to be part of an MVC (model-view-controller) architecture. Neither is true.
    React can be both of those things, but it can be much more. To make things easier,
    I’ll describe React more in terms of what it *is* than what it’s not (“just the
    view,” for example). React is a *declarative*, *component-based* library for building
    user interfaces that works on a variety of platforms: web, native, mobile, server,
    desktop, and even on virtual reality platforms going forward (React VR).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果权衡是良好软件评估和讨论的精髓，那么React有哪些权衡呢？首先，React有时被称为*仅仅是视图*。这可能会被误解或理解错误，因为它可能会让你认为React只是一个像Handlebars或Pug（原名Jade）这样的模板系统，或者它必须作为MVC（模型-视图-控制器）架构的一部分。这两者都不正确。React可以是这两者，但还可以更多。为了使事情更简单，我将更多地从它*是什么*的角度来描述React，而不是它*不是什么*（例如，“仅仅是视图”）。React是一个*声明式*、*组件化*的库，用于构建用户界面，它可以在各种平台上工作：网页、原生、移动、服务器、桌面，甚至在未来还可以在虚拟现实平台上（React
    VR）。
- en: 'This leads to our first tradeoff: React is primarily concerned with the *view*
    aspects of UI. This means it’s not built to do many of the jobs of a more comprehensive
    framework or library. A quick comparison to something like Angular might help
    drive this point home. In its most recent major release, Angular has much more
    in common with React than it previously did in terms of concepts and design, but
    in other ways it covers much more territory than React. Angular includes opinionated
    solutions for the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了我们的第一个权衡：React主要关注UI的*视图*方面。这意味着它不是用来做更多全面框架或库的工作。与Angular等类似的东西的快速比较可能有助于阐明这一点。在其最近的主要版本中，Angular在概念和设计方面与React的相似之处比以前更多，但在其他方面它覆盖的领域比React更广。Angular包括以下方面的有偏见的解决方案：
- en: HTTP calls
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP调用
- en: Form building and validation
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单构建和验证
- en: Routing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: String and number formatting
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和数字格式化
- en: Internationalization
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化
- en: Dependency injection
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Basic data modeling primitives
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据建模原语
- en: Custom testing framework (although this isn’t as important a distinction as
    the other areas)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义测试框架（尽管这与其他领域的区分并不那么重要）
- en: Service workers included by default (a worker-style approach to executing JavaScript)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认包含服务工作者（一种执行JavaScript的工作者式方法）
- en: That’s a lot, and in my experience there are generally two ways people tend
    to react^([[1](kindle_split_011_split_002.xhtml#ch01fn1)]) to all these features
    coming with a framework. Either it’s along the lines of “Wow, I don’t have to
    deal with all those myself” or it’s “Wow, I don’t get to choose how I do anything.”
    The upside of frameworks like Angular, Ember, and the like is that there’s usually
    a well-defined way to do things. For example, routing in Angular is done with
    the built-in Angular Router, HTTP tasks are all done with the built-in HTTP routines,
    and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多，根据我的经验，人们通常有两种反应^([[1](kindle_split_011_split_002.xhtml#ch01fn1)])于框架带来的所有这些功能。要么是“哇，我不用自己处理所有这些”要么是“哇，我无法选择如何去做任何事情”。Angular、Ember等框架的优点通常是做事有明确的方式。例如，Angular中的路由是通过内置的Angular
    Router完成的，HTTP任务都是通过内置的HTTP例程完成的，等等。
- en: ¹
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pun not intended but, hey, it’s a book about React, so there it is.
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 并非有意为之的玩笑，但嘿，这是一本关于React的书，所以就这样吧。
- en: There’s nothing fundamentally wrong with this approach. I’ve worked on teams
    where we used technologies like this and I’ve worked on teams where we went the
    more flexible direction and chose technologies that “did one thing well.” We did
    great work with both kinds of technologies, and they served their purposes well.
    My personal preference is toward the choose-your-own, does-one-thing-well approach,
    but that’s really neither here nor there; it’s all about tradeoffs. React doesn’t
    come with opinionated solutions for HTTP, routing, data modeling (although it
    certainly has opinions about data flow in your views, which we’ll get to), or
    other things you might see in something like Angular. If your team sees this as
    something you absolutely can’t do without in a singular framework, React might
    not be your best choice. But in my experience, most teams want the flexibility
    of React coupled with the mental model and intuitive APIs that it brings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并没有根本性的错误。我曾与使用这类技术的团队共事，也曾在更灵活的方向上工作的团队中工作，我们选择了“做好一件事”的技术。我们用这两种技术都取得了很好的成果，并且它们都很好地完成了它们的目的。我个人的偏好是选择自己的、做好一件事的方法，但这真的无关紧要；这完全是关于权衡。React没有为HTTP、路由、数据建模（尽管它确实对视图中的数据流有意见，我们将在后面讨论）或其他你可能看到在Angular中的事物提供有偏见的解决方案。如果你的团队认为这是在单一框架中绝对不能没有的东西，React可能不是你的最佳选择。但根据我的经验，大多数团队希望React的灵活性加上它带来的心理模型和直观的API。
- en: One upside to the flexible approach of React is that you’re free to pick the
    best tools for the job. Don’t like the way *X* HTTP library works? No problem—swap
    it out for something else. Prefer to do forms in a different way? Implement it,
    no problem. React provides you with a set of powerful primitives to work with.
    To be fair, other frameworks like Angular will usually allow you to swap things
    out too, but the de facto and community-backed way of doing things will usually
    be whatever is built-in and included.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: React灵活方法的优点之一是你可以自由地选择最适合工作的工具。不喜欢*X* HTTP库的工作方式？没问题——用其他东西替换它。更喜欢用不同的方式做表单？实现它，没问题。React为你提供了一套强大的原语来工作。公平地说，其他框架如Angular通常也会允许你替换东西，但事实上的和社区支持的做法通常是内置和包含的。
- en: The obvious downside to having more freedom is that if you’re used to a more
    comprehensive framework like Angular or Ember, you’ll need to either come up with
    or find your own solution for different areas of your application. This can be
    a good thing or a bad thing, depending on factors like developer experience on
    your team, engineering management preferences, and other factors specific to your
    situation. There are plenty of good arguments for the one-size-fits-all as well
    as the does-one-thing-well approaches. I tend to be more convinced by the approach
    that lets you adapt and make flexible, case-by-case decisions about tooling over
    time in a way that entrusts engineering teams with the responsibility to determine
    or create the right tools. There’s also the incredibly broader JavaScript ecosystem
    to consider—you’ll be hard-pressed to find *nothing* aimed at a problem you’re
    solving. But at the end of the day, the fact remains that excellent, high-impact
    teams use both sorts of approaches (sometimes at the same time!) to build out
    their products.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有更多自由显然的缺点是，如果你习惯于像 Angular 或 Ember 这样更全面的框架，你将需要为应用程序的不同领域提出或找到自己的解决方案。这可能是好事也可能是坏事，这取决于团队的开发者经验、工程管理偏好以及你具体情况的其他因素。对于“一刀切”以及“只做一件事做好”的方法有很多好的论据。我更倾向于那种让你随着时间的推移适应并灵活地做出工具决策的方法，这种方法将责任委托给工程团队来确定或创建正确的工具。还有那极其广泛的
    JavaScript 生态系统需要考虑——你几乎找不到任何针对你正在解决的问题。但最终，事实仍然是，优秀的、有影响力的团队会使用这两种方法（有时同时使用！）来构建他们的产品。
- en: I’d be remiss if I didn’t mention lock-in before moving on. It’s an unavoidable
    fact that JavaScript frameworks are rarely truly interoperable; you can’t usually
    have an app that’s part Angular, part Ember, part Backbone, and part React, at
    least not without segmenting off each part or tightly controlling how they interact.
    It doesn’t usually make sense to put yourself in that sort of situation when you
    can avoid it. You usually go with one and maybe temporarily, at most, two primary
    frameworks for a particular application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，如果不提一下锁定问题，那我就疏忽了。一个不可避免的事实是，JavaScript 框架很少真正是可互操作的；你通常不能有一个部分是 Angular，部分是
    Ember，部分是 Backbone，部分是 React 的应用程序，至少在没有将每个部分分割开来或紧密控制它们交互的情况下是不可能的。当你能够避免这种情况时，将自己置于这种境地通常是没有意义的。你通常会为特定应用程序选择一个，最多再加上两个主要框架。
- en: But what happens when you need to change? If you use a tool with wide-ranging
    responsibilities like Angular, migrating your app is likely going to be a complete
    rewrite due to the deep idiomatic integration of your framework. You can rewrite
    smaller parts of the application, but you can’t just swap out a few functions
    and expect everything to work. This is an area where React can shine. It employs
    relatively few “magic” idioms. That doesn’t mean it makes migration painless,
    but it does help you to potentially forgo incurring the cost of a tightly integrated
    framework like Angular if you migrate to or from it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当你需要改变时会发生什么呢？如果你使用像 Angular 这样具有广泛职责的工具，迁移你的应用程序很可能会因为框架的深度惯用性而需要进行完全重写。你可以重写应用程序的较小部分，但你不能只是替换几个函数并期望一切都能正常工作。这正是
    React 可以发光的地方。它采用了相对较少的“魔法”惯用性。这并不意味着迁移变得毫无痛苦，但它确实可以帮助你在迁移到或从 Angular 迁移时，避免承担紧密集成框架的成本。
- en: Another tradeoff you make when choosing React is that it’s primarily developed
    and built by Facebook and is meant to serve the UI needs of Facebook. You might
    have a hard time working with React if your application is fundamentally different
    than the UI needs of Facebook’s apps. Fortunately, most modern web apps are in
    React’s technological wheelhouse, but there are certainly apps that aren’t. These
    might also include apps that don’t work within the conventional UI paradigms of
    modern web apps or apps that have very specific performance needs (such as a high-speed
    stock ticker). Yet even these can often be addressed with React, though some situations
    require more-specific technologies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择 React 时，你做出的另一个权衡是，它主要是由 Facebook 开发和构建的，旨在满足 Facebook 的 UI 需求。如果你的应用程序与
    Facebook 应用程序的 UI 需求在本质上不同，你可能会发现与 React 一起工作很困难。幸运的是，大多数现代 Web 应用程序都在 React 的技术领域内，但当然也有一些不在。这些可能还包括那些不适用于现代
    Web 应用程序传统 UI 体系结构的程序，或者那些具有非常特定性能需求的程序（例如高速股票行情）。尽管如此，这些情况通常也可以通过 React 解决，尽管某些情况需要更具体的技术。
- en: One last tradeoff we should discuss is React’s implementation and design. Baked
    into the core of React are systems that handle updating the UI for you when the
    data in your components change. They execute changes that you can hook into using
    certain methods called *lifecycle methods*. I cover these extensively in later
    chapters. React’s systems that handle updating your UI make it much easier to
    focus on building modular, robust components that your application can use. The
    way React abstracts away most of the work of keeping a UI up-to-date with data
    is a big part of why developers enjoy working with it so much and why it’s a powerful
    primitive in your hands. But it shouldn’t be assumed that there are no downsides
    or tradeoffs made with respect to the “engines” that power the technology.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该讨论的一个权衡是React的实现和设计。React的核心中包含了处理组件数据变化时更新UI的系统。它们执行你可以通过某些称为*生命周期方法*的方法钩入的变化。我在后面的章节中详细介绍了这些内容。React处理更新UI的系统使得构建模块化、健壮的组件变得容易，这些组件可以被你的应用使用。React抽象出大部分保持UI与数据同步的工作，这是开发者喜欢与之合作以及为什么它是你手中的强大原语的一个重要原因。但不应假设与推动这项技术的“引擎”相关的没有缺点或权衡。
- en: 'React is an abstraction, so the costs of it being an abstraction still remain.
    You don’t get as much visibility into the system you’re using because it’s built
    in a particular way and exposed through an API. This also means you’ll need to
    build your UI in an idiomatically React way. Fortunately, React’s APIs provide
    “escape hatches” that let you drop down into lower levels of abstraction. You
    can still use other tools like jQuery, but you’ll need to use them in a React-compatible
    way. This again is a tradeoff: a simpler mental model at the cost of not being
    able to do absolutely everything how you’d like.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个抽象层，因此作为抽象层所带来的成本仍然存在。由于它是按照特定方式构建并通过API暴露的，因此你无法像使用其他系统那样深入了解你所使用的系统。这也意味着你需要以React的方式构建你的UI。幸运的是，React的API提供了“逃生门”，让你可以降级到更低的抽象级别。你仍然可以使用像jQuery这样的其他工具，但你需要以React兼容的方式使用它们。这又是一个权衡：以更简单的思维模型为代价，无法做到绝对地按照你的意愿做任何事情。
- en: Not only do you lose some visibility to the underlying system, you also buy
    into the way that React does things. This tends to impact a narrower slice of
    your application stack (only views instead of data, special form-building systems,
    data modeling, and so on), but it affects it nonetheless. My hope is that you’ll
    see that the benefits of React far outweigh the cost of learning it and that the
    tradeoffs you make when using it generally leave you in a much better place as
    a developer. But it would be disingenuous for me to pretend that React will magically
    solve all your engineering challenges.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅你对底层系统的可见性有所降低，你还会接受React处理事情的方式。这通常会影响应用堆栈的一个较窄部分（只有视图而不是数据，特殊表单构建系统，数据建模等），但它确实会产生影响。我希望你能看到React的好处远远超过了学习的成本，而且在使用它时所做的权衡通常会使你作为一个开发者处于更好的位置。但假装React能神奇地解决你所有的工程挑战是不诚实的。
- en: 1.3\. The virtual DOM
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 虚拟DOM
- en: We’ve talked a little bit about some of the high-level features of React. I’ve
    posited that it can help you and your team become better at creating user interfaces
    and that part of this is due to the mental model and APIs that React provides.
    What’s behind all that? A major theme in React is a drive to simplify otherwise
    complex tasks and abstract unnecessary complexity away from the developer. React
    tries to do just enough to be performant while freeing you up to think about other
    aspects of your application. One of the main ways it does that is by encouraging
    you to be *declarative* instead of *imperative*. You get to declare how your components
    should behave and look under different states, and React’s internal machinery
    handles the complexity of managing updates, updating the UI to reflect changes,
    and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要讨论了React的一些高级特性。我提出，React可以帮助你和你的团队在创建用户界面方面变得更好，而这部分原因要归功于React提供的思维模型和API。这一切背后的动力是什么？React的一个主要主题是简化复杂的任务，并从开发者那里抽象出不必要的复杂性。React试图做到足够多，以保持性能，同时让你有更多时间去思考应用的其他方面。它实现这一目标的主要方式之一就是鼓励你采用*声明式*而非*命令式*的方式。你可以声明你的组件在不同状态下应该如何表现和外观，而React的内部机制则处理管理更新、更新UI以反映变化等复杂性。
- en: One of the major pieces of technology driving this is the virtual DOM. A *virtual
    DOM* is a data structure or collection of data structures that mimics or mirrors
    the Document Object Model that exists in browsers. I say *a* virtual DOM because
    other frameworks such as Ember employ their own implementation of a similar technology.
    In general, a virtual DOM will serve as an intermediate layer between the application
    code and the browser DOM. The virtual DOM allows the complexity of change detection
    and management to be hidden from the developer and moved to a specialized layer
    of abstraction. In the next sections, we’ll look from a high level at how this
    works in React. [Figure 1.3](kindle_split_011_split_003.xhtml#ch01fig03) shows
    a simplified overview of the DOM and virtual DOM relationship that we’ll explore
    shortly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动这一技术的关键部分之一是虚拟DOM。*虚拟DOM*是一个数据结构或数据结构的集合，它模拟或反映了浏览器中存在的文档对象模型。我说*a*虚拟DOM，因为其他框架如Ember使用它们自己类似技术的实现。一般来说，虚拟DOM将作为应用程序代码和浏览器DOM之间的中间层。虚拟DOM允许将变化检测和管理复杂性隐藏起来，并移动到专门的抽象层。在接下来的几节中，我们将从高层次的角度看看React中是如何实现这一点的。[图1.3](kindle_split_011_split_003.xhtml#ch01fig03)展示了我们将很快探讨的DOM和虚拟DOM关系的简化概述。
- en: Figure 1.3\. The DOM and virtual DOM. React’s virtual DOM handles change detection
    in data as well as translating browser events into events that React components
    can understand and react to. React’s virtual DOM also aims to optimize changes
    made to the DOM for the sake of performance.
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. DOM和虚拟DOM。React的虚拟DOM处理数据的变化检测，以及将浏览器事件转换为React组件可以理解和响应的事件。React的虚拟DOM还旨在优化对DOM的更改，以提高性能。
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig03_alt.jpg)'
- en: 1.3.1\. The DOM
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. DOM
- en: 'The best way to ensure that we understand React’s virtual DOM is to start by
    checking our understanding of the DOM. If you already feel you have a deep understanding
    of the DOM, feel free to move ahead. But if not, let’s start with an important
    question: what is the DOM? The DOM, or *Document Object Model*, is a programming
    interface that allows your JavaScript programs to interact with different types
    of documents (HTML, XML, and SVG). There are standards-driven specifications for
    it, which means that a public working group has created a standard set of features
    it should have and ways it should behave. Although other implementations exist,
    the DOM is mostly synonymous with web browsers like Chrome, Firefox, and Edge.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们理解React的虚拟DOM的最好方法是从检查我们对DOM的理解开始。如果你已经觉得自己对DOM有深刻的理解，那么请随意继续前进。但如果你还没有，让我们从一个重要的问题开始：什么是DOM？DOM，或称*文档对象模型*，是一个编程接口，允许你的JavaScript程序与不同类型的文档（HTML、XML和SVG）进行交互。它有一套由标准驱动的规范，这意味着一个公开的工作组已经创建了一套标准的功能集和它应该如何表现的行为。尽管存在其他实现，但DOM在大多数情况下与像Chrome、Firefox和Edge这样的网络浏览器是同义的。
- en: The DOM provides a structured way of accessing, storing, and manipulating different
    parts of a document. At a high level, the DOM is a tree structure that reflects
    the hierarchy of an XML document. This tree structure is comprised of sub-trees
    that are in turn made of nodes. You’ll probably know these as the `div`s and other
    elements that make up your web pages and applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: DOM提供了一种结构化的方式来访问、存储和操作文档的不同部分。从高层次来看，DOM是一个树结构，反映了XML文档的层次结构。这个树结构由子树组成，而这些子树又由节点组成。你可能知道这些是`div`和其他构成你的网页和应用程序的元素。
- en: You’ve probably used the DOM API before—but you may not have known you were
    using it. Whenever you use a method in JavaScript that accesses, modifies, or
    stores information related to something in an HTML document, you’re almost certainly
    using the DOM or its related APIs (see [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)
    for more on web APIs). This means that not all the methods you’ve used in JavaScript
    are necessarily part of the JavaScript language itself (`document.findElemenyById`,
    `querySelectorAll`, `alert`, and so on). They’re part of the bigger collection
    of *web APIs*—the DOM and other APIs that go into a browser—that allow you to
    interact with documents. [Figure 1.4](kindle_split_011_split_003.xhtml#ch01fig04)
    shows a simplified version of the DOM tree structure you’ve probably seen in your
    web pages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经使用过DOM API，但你可能不知道你正在使用它。每次你使用JavaScript中的方法来访问、修改或存储与HTML文档中的某些内容相关的信息时，你几乎肯定正在使用DOM或其相关API（有关更多关于Web
    API的信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)）。这意味着你使用的并非JavaScript语言本身的全部方法（`document.getElementById`、`querySelectorAll`、`alert`等）。它们是更大的集合——*Web
    API*的一部分——包括DOM和其他浏览器中的API，允许你与文档交互。[图1.4](kindle_split_011_split_003.xhtml#ch01fig04)展示了你可能在网页中见过的简化版DOM树结构。
- en: Figure 1.4\. Here’s a simple version of the DOM tree structure, using elements
    you’re probably familiar with. The DOM API that’s exposed to JavaScript lets you
    performs operations on these elements in the tree.
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4。这是一个使用你可能熟悉的元素的简单DOM树结构版本。暴露给JavaScript的DOM API允许你在树中对这些元素执行操作。
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: Common methods or properties you may have used to update or query a web page
    might include `getElementById`, `parent.appendChild`, `querySelectorAll`, `innerHTML`,
    and others. These are all provided by the host environment (in this case, the
    browser) and allow JavaScript to interact with the DOM. Without this ability,
    we’d have far less interesting web apps to use and perhaps no books about React
    to write!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用过的一些常见方法或属性，用于更新或查询网页可能包括`getElementById`、`parent.appendChild`、`querySelectorAll`、`innerHTML`等。这些都是由宿主环境（在这种情况下，是浏览器）提供的，允许JavaScript与DOM交互。没有这种能力，我们将有远少于现在有趣的Web应用程序可以使用，也许就没有关于React的书可以写了！
- en: Interacting with the DOM is usually straightforward but can get complicated
    in the context of a large web application. Fortunately, we don’t often need to
    directly interact with the DOM when building applications with React—we mostly
    leave that to React. There are cases when we want to reach out past the virtual
    DOM and interact with the DOM directly, and we’ll cover those in future chapters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与DOM交互通常很简单，但在大型Web应用程序的上下文中可能会变得复杂。幸运的是，当我们使用React构建应用程序时，我们通常不需要直接与DOM交互——我们主要让React来处理。有些情况下，我们想要超越虚拟DOM并直接与DOM交互，我们将在未来的章节中介绍这些情况。
- en: 1.3.2\. The virtual DOM
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2. 虚拟DOM
- en: The web APIs in browsers let us interact with web documents with JavaScript
    via the DOM. But if we can already do this, why do we need something else in between?
    I want to first state that React’s implementation of a virtual DOM doesn’t mean
    that the regular web APIs are bad or inferior to React. Without them, React can’t
    work. There are, however, certain pain points of working directly with the DOM
    in larger web applications. Generally, these pain points arise in the area of
    change detection. When data changes, we want to update the UI to reflect that.
    Doing that in a way that’s efficient and easy to think about can be difficult,
    so React aims to solve that problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的Web API允许我们通过DOM使用JavaScript与Web文档交互。但如果我们已经可以这样做，为什么我们还需要在中间添加其他东西呢？首先我要声明，React对虚拟DOM的实现并不意味着常规的Web
    API是不好或不如React。没有它们，React无法工作。然而，在大型Web应用程序中直接与DOM交互确实存在一些痛点。通常，这些痛点出现在变更检测的领域。当数据发生变化时，我们希望更新UI以反映这一点。以高效且易于思考的方式进行这一操作可能会很困难，因此React旨在解决这个问题。
- en: Part of the reason for that problem is the way browsers handle interactions
    with the DOM. When a DOM element is accessed, modified, or created, the browser
    is often performing a query across a structured tree to find a given element.
    That’s just to access an element, which is usually only the first part of an update.
    More often than not, it may have to reperform layout, sizing, and other actions
    as part of a *mutation*—all of which can tend to be computationally expensive.
    A virtual DOM won’t get you around this, but it can help updates to the DOM be
    optimized to account for these constraints.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 导致该问题的部分原因是浏览器处理与DOM交互的方式。当一个DOM元素被访问、修改或创建时，浏览器通常会在一个结构化树中进行查询以找到指定的元素。这只是为了访问一个元素，这通常只是更新的一部分。更常见的情况是，它可能需要重新执行布局、尺寸和其他操作，作为*突变*的一部分——所有这些都可能具有计算成本。虚拟DOM不能解决这个问题，但它可以帮助优化DOM的更新，以考虑到这些限制。
- en: When creating and managing a sizeable application that deals with data that
    changes over time, many changes to the DOM may be required, and often these changes
    can conflict or are done in a less-than-optimal way. That can result in an overly
    complicated system that’s difficult for engineers to work on and likely a subpar
    experience for users—lose-lose. Thus performance is another key consideration
    in React’s design and implementation. Implementing a virtual DOM helps address
    this, but it should be noted that it’s designed to be just “fast enough.” A robust
    API, simple mental model, and other things like cross-browser compatibility end
    up being more important outcomes of React’s virtual DOM than an extreme focus
    on performance. The reason I make this point is that you may hear the virtual
    DOM talked about as a sort of silver bullet for performance. It is performant,
    but it’s no magic performance bullet, and at the end of the day, many of its other
    benefits are more important for working with React.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建和管理一个处理随时间变化的数据的大规模应用程序时，可能需要对DOM进行许多更改，而且这些更改往往可能发生冲突或以非最佳方式完成。这可能导致一个过于复杂的系统，工程师难以工作，并且可能为用户提供的是次优体验——双方都输。因此，性能是React设计和实现中的另一个关键考虑因素。实现虚拟DOM有助于解决这个问题，但需要注意的是，它被设计成“足够快”。一个健壮的API、简单的心理模型以及其他诸如跨浏览器兼容性等因素，最终成为React虚拟DOM比极端关注性能更为重要的成果。我提出这个观点的原因是，你可能会听到虚拟DOM被描述为一种性能的银弹。它是高效的，但它并不是魔法般的性能子弹，最终，许多其他的好处对于使用React来说更为重要。
- en: 1.3.3\. Updates and diffing
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3 更新和diffing
- en: 'How does the virtual DOM work? React’s virtual DOM has a few similarities to
    another software world: 3D gaming. 3D games sometimes employ a rendering process
    that works very roughly as follows: get information from the game server, send
    it to the game world (the visual representation that the user sees), determine
    what changes need to be made to the visual world, and then let the graphics card
    determine the minimum changes necessary. One advantage of this approach is that
    you only need the resources for dealing with incremental changes and can generally
    do things much quicker than if you had to update everything.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是如何工作的？React的虚拟DOM在另一个软件世界中有一些建议相似之处：3D游戏。3D游戏有时采用一种渲染过程，大致如下：从游戏服务器获取信息，发送到游戏世界（用户看到的视觉表示），确定需要对视觉世界进行哪些更改，然后让显卡确定必要的最小更改。这种方法的一个优点是，你只需要处理增量更改的资源，通常可以比必须更新所有内容时更快地完成任务。
- en: That’s a gross oversimplification of the way 3D games are rendered and updated,
    but the general ideas give us a good example to think of when looking at how React
    performs updates. DOM mutation done poorly can be expensive, so React tries to
    be efficient in its updates to your UI and employs methods similar to 3D games.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对3D游戏渲染和更新的方式的一种过于简化的描述，但总体思路为我们提供了一个很好的例子，当我们考虑React如何执行更新时。糟糕的DOM突变可能代价高昂，因此React试图在更新UI时保持高效，并采用类似于3D游戏的方法。
- en: As [figure 1.5](kindle_split_011_split_003.xhtml#ch01fig05) shows, React creates
    and maintains a virtual DOM in memory, and a renderer like React-DOM handles updating
    the browser DOM based on changes. React can perform intelligent updates and only
    do work on parts that have changed because it can use *heuristic diffing* to calculate
    which parts of the in-memory DOM require changes to the DOM. Theoretically, this
    is much more streamlined and elegant than “dirty checking” or other more brute-force
    approaches, but a major practical implication is that developers have less complicated
    state tracking to reason about.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 1.5](kindle_split_011_split_003.xhtml#ch01fig05)所示，React 在内存中创建并维护一个虚拟 DOM，而像
    React-DOM 这样的渲染器则负责根据变化更新浏览器 DOM。React 可以执行智能更新，并且只对已更改的部分进行工作，因为它可以使用 *启发式差异比较*
    来计算内存中 DOM 的哪些部分需要更新到 DOM。理论上，这比“脏检查”或其他更粗暴的方法要流畅得多，但一个重要的实际影响是开发者有更简单的状态跟踪来推理。
- en: Figure 1.5\. React’s diffing and update procedure. When a change happens, React
    determines differences between the actual and in-memory DOMs. Then it performs
    an efficient update to the browser’s DOM. This process is often referred to as
    a *diff* (“what changed?”) *and patch* (“update only what changed”) process.
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. React 的差异和更新过程。当发生更改时，React 确定实际 DOM 和内存中 DOM 之间的差异。然后它对浏览器 DOM 执行高效的更新。这个过程通常被称为
    *差异*（“有什么变化？”）*和补丁*（“只更新变化的部分”）过程。
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.5](Images/01fig05_alt.jpg)'
- en: '1.3.4\. Virtual DOM: Need for speed?'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.4\. 虚拟 DOM：需要速度吗？
- en: As I’ve noted, there’s more to the virtual DOM than speed. It’s performant by
    design and generally results in snappy, speedy applications that are fast enough
    for modern web application needs. Performance and a better mental model have been
    so appreciated by engineers that many popular JavaScript libraries are creating
    their own versions or variations of a virtual DOM. Even in these cases, people
    tend to think that the virtual DOM is primarily focused on performance. Performance
    is a key feature of React, but it’s secondary to simplicity. The virtual DOM is
    part of what enables you to defer thinking about complicated state logic and focus
    on other, more important parts of your application. Together, speed and simplicity
    mean happier users and happier developers—a win-win!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，虚拟 DOM 不仅仅是速度快。它通过设计就具有高性能，通常会产生快速、响应灵敏的应用程序，足以满足现代网络应用的需求。性能和更好的心理模型受到了工程师们的极大赞赏，以至于许多流行的
    JavaScript 库都在创建它们自己的虚拟 DOM 版本或变体。即使在这些情况下，人们也倾向于认为虚拟 DOM 主要关注性能。性能是 React 的一个关键特性，但它是简单性的次级特性。虚拟
    DOM 是使您能够推迟考虑复杂状态逻辑并专注于应用程序其他更重要部分的一部分。速度和简单性共同意味着用户和开发者都更快乐——双赢！
- en: 'I’ve spent some time talking about the virtual DOM, but I don’t want to give
    you the idea that it will be an important part of working with React. In practice,
    you won’t need to be thinking extensively about how the virtual DOM is accomplishing
    your data updates or making your changes to your application. That’s part of the
    simplicity of React: you’re freed up to focus on the parts of your application
    that need the most focus.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经花了一些时间讨论虚拟 DOM，但我不想给你一个印象，即它将是使用 React 的重要部分。实际上，你不需要深入思考虚拟 DOM 如何完成你的数据更新或如何改变你的应用程序。这是
    React 简单性的一个部分：你被解放出来，可以专注于应用程序中最需要关注的部分。
- en: '1.4\. Components: The fundamental unit of React'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 组件：React 的基本单元
- en: React doesn’t just use a novel approach to dealing with changing data over time;
    it also focuses on components as a paradigm for organizing your application. Components
    are the most fundamental unit of React. There are several different ways you can
    create components with React, which future chapters will cover. Thinking in terms
    of components is essential for grasping not only how React was meant to work but
    also how you can best use it in your projects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: React 不仅使用了一种新颖的方法来处理随时间变化的数据；它还关注组件作为组织应用程序的范例。组件是 React 最基本的单元。你可以用几种不同的方式使用
    React 创建组件，未来的章节将介绍这些方法。从组件的角度思考对于理解 React 的预期工作方式以及如何在项目中最佳地使用它至关重要。
- en: 1.4.1\. Components in general
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. 组件概述
- en: What is a component? It’s a part of a larger whole. The idea of components is
    likely familiar to you, and you probably see them often even though you might
    not realize it. Using components as mental and visual tools when designing and
    building user interfaces can lead to better, more intuitive application design
    and use. A component can be whatever you determine it to be, although not everything
    makes sense as a component. For example, if you decide that the entirety of an
    interface is a component, with no child components or further subdivisions, you’re
    probably not helping yourself. Instead, it’s helpful to break different parts
    of an interface into parts that can be composed, reused, and easily reorganized.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是什么？它是更大整体的一部分。组件的概念可能对你来说很熟悉，即使你可能没有意识到，你也很可能经常看到它们。在设计构建用户界面时使用组件作为思维和视觉工具可以导致更好的、更直观的应用程序设计和使用。组件可以是任何你决定的东西，尽管不是所有东西都适合作为组件。例如，如果你决定整个界面是一个组件，没有子组件或进一步的细分，你可能并没有帮到自己。相反，将界面的不同部分分解成可以组合、重用和轻松重组的部分是有帮助的。
- en: To start thinking in terms of components, we’ll look at an example interface
    and break it down into its constituent parts. [Figure 1.6](kindle_split_011_split_004.xhtml#ch01fig06)
    shows an example of an interface you’ll be working on later in the book. User
    interfaces often contain elements that are reused or repurposed in other parts
    of the interface. And even if they’re not reused, they’re at least distinct. These
    different elements, the distinct elements of an interface, can be thought of as
    components. The interface on the left in [figure 1.6](kindle_split_011_split_004.xhtml#ch01fig06)
    is broken down into components on the right.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始从组件的角度思考，我们将查看一个示例界面并将其分解为其组成部分。[图1.6](kindle_split_011_split_004.xhtml#ch01fig06)展示了本书后面将要工作的界面示例。用户界面通常包含在其他界面部分中重复使用或重新定制的元素。即使它们没有被重复使用，它们至少是独特的。这些不同的元素，即界面的独特元素，可以被视为组件。图1.6中左侧的界面在右侧被分解为组件。
- en: Figure 1.6\. An example of an interface broken into components. Each distinct
    section can be thought of as a component. Items that repeat in a uniform nature
    can be thought of as one component that gets reused over different data.
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6. 将界面分解为组件的示例。每个独特的部分可以被视为一个组件。以统一的方式重复出现的项目可以被视为一个组件，该组件可以在不同的数据中重复使用。
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig06_alt.jpg)'
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Component thinking**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件思维**'
- en: Visit a popular site that you enjoy and use often (like GitHub, for example)
    and break down the interface into components. As you go, you’ll probably find
    yourself dividing things into separate parts. When does it make sense to stop
    breaking things down? Should an individual letter be a component? When might it
    make sense for a component to be something small? When would it make sense to
    consider a grouping of things as one component?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个你经常使用且喜欢的网站（例如GitHub）并将界面分解成组件。在这个过程中，你可能会发现自己将事物分成不同的部分。何时停止分解事物是有意义的？一个单独的字母是否应该是一个组件？何时一个小的组件是有意义的？何时将一组事物视为一个组件是有意义的？
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '1.4.2\. Components in React: Encapsulated and reusable'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2. React中的组件：封装和可重用
- en: React components are well encapsulated, reusable, and composable. These characteristics
    help enable a simpler and more elegant way of thinking about and building user
    interfaces. Your application can be comprised of clear, concise groups instead
    of being a spaghetti-code mess. Using React to build your application is almost
    like building your project with LEGOs, except that you can’t run out of pieces.
    You’ll encounter bugs, but thankfully there are no pieces to step on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: React组件具有良好的封装性、可重用性和可组合性。这些特性帮助实现了一种更简单、更优雅的方式来思考和构建用户界面。你的应用程序可以由清晰、简洁的组组成，而不是一团糟的意大利面代码。使用React构建你的应用程序几乎就像用乐高积木构建你的项目一样，只不过你不会用完积木。你可能会遇到错误，但幸运的是，没有积木可以踩到。
- en: In [exercise 1.1](kindle_split_011_split_004.xhtml#ch01sb01), you practiced
    thinking with components and broke an interface into some constituent components.
    You could have done it any number of ways, and it’s possible you might not have
    been especially organized or consistent. That’s fine. But when you work with components
    in React, it will be important to consider organization and consistency in component
    design. You’ll want to design components that are self-contained and focus on
    a particular concern or a handful of related concerns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[练习1.1](kindle_split_011_split_004.xhtml#ch01sb01)中，你练习了使用组件进行思考，并将接口分解为一些组成部分。你可以以任何数量种方式来做这件事，也许你可能并没有特别有组织或一致。这没关系。但是当你使用React中的组件时，考虑组件设计的组织和一致性将变得非常重要。你将希望设计出自我包含的组件，专注于特定的关注点或一系列相关关注点。
- en: This lends itself towards components that are portable, logically grouped, and
    easy to move around and reuse throughout your application. Even if it takes advantage
    of other libraries, a well-designed React component should be fairly self-contained.
    Breaking your UI into components allows you to work more easily on different parts
    of the application. Boundaries between components mean that functionality and
    organization can be well-defined, whereas self-contained components mean they
    can be reused and moved around more easily.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得组件具有可移植性、逻辑分组，并且易于在应用程序中移动和重用。即使它利用了其他库，一个设计良好的React组件应该相当自我包含。将你的UI分解为组件可以让你更轻松地在应用程序的不同部分工作。组件之间的边界意味着功能和组织可以很好地定义，而自我包含的组件意味着它们可以更容易地重用和移动。
- en: Components in React are meant to work together. This means you can *compose*
    together components to form new *composite* components. Component composition
    is one of the most powerful aspects of React. You can create a component once
    and make it available to the rest of your application for reuse. This is often
    especially helpful in larger applications. If you’re on a medium-to-large team,
    you could publish components to a private registry (npm or otherwise) that other
    teams could easily pull down and use in new or existing projects. This might not
    be a realistic scenario for all sizes of teams, but even smaller teams will benefit
    from the code reuse that React components promote.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: React中的组件旨在协同工作。这意味着你可以*组合*组件以形成新的*复合*组件。组件组合是React最强大的特性之一。你可以创建一个组件，并将其提供给应用程序的其他部分以供重用。这在大型应用程序中尤其有帮助。如果你在一个中到大型团队中，你可以将组件发布到私有注册表（npm或其他），其他团队可以轻松拉取并用于新项目或现有项目。这可能不是所有规模团队的实际情况，但即使是小型团队也会从React组件促进的代码重用中受益。
- en: A final aspect of React components is *lifecycle methods*. These are predictable,
    well-defined methods you can use as your component moves through different parts
    of its lifecycle (mounting, updating, unmounting, and so on). We’ll spend a lot
    of time on these methods in future chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的最后一个方面是*生命周期方法*。这些是在组件在其生命周期（挂载、更新、卸载等）的不同部分移动时可以使用的可预测、定义良好的方法。我们将在未来的章节中花费大量时间讨论这些方法。
- en: 1.5\. React for teams
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. React团队
- en: You now know a little bit more about components in React. React can make your
    life easier as an individual developer. But what about on a team? Overall, what
    makes React so appealing to individual developers is also what can make it a great
    fit for teams. Like any technology, React isn’t a perfect solution for every use
    case or project, no matter the hype or what fanatical developers may try to convince
    you of. As you’ve already seen, there are many things that React doesn’t do. But
    the things it does do, it does extremely well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你对React中的组件有了更多了解。React可以使个人开发者的生活变得更轻松。但在团队中呢？总的来说，使React对个人开发者有吸引力的因素，也可能使其成为团队的绝佳选择。像任何技术一样，React并不是每个用例或项目的完美解决方案，无论炒作如何，或者狂热的开发者可能试图让你相信什么。正如你之前看到的，React有很多事情不做。但它所做的事情，它做得非常出色。
- en: What makes React a great tool for larger teams and larger applications? First,
    there’s the simplicity of using it. *Simplicity* is not the same thing as *ease*.
    Easy solutions are often dirty and quick, and worst of all, they can incur technical
    debt. Truly simple technology is flexible and robust. React provides powerful
    abstractions that can still be worked with along with ways to drop down into the
    lower-level details when necessary. Simple technology is easier to understand
    and work with because the difficult work of streamlining and removing what’s not
    necessary has been done. In many ways React has made simple easy, providing an
    effective solution without introducing harmful “black magic” or an opaque API.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 什么让React成为大型团队和大型应用的优秀工具？首先，使用它的简单性。*简单性*与*易用性*不同。易用的解决方案通常很脏、很快，最糟糕的是，它们可能会产生技术债务。真正简单的技术是灵活且健壮的。React提供了强大的抽象，仍然可以在必要时深入到底层细节。简单技术更容易理解和操作，因为简化流程和去除不必要的部分的工作已经完成。在许多方面，React让简单变得容易，提供了一个有效的解决方案，而没有引入有害的“黑魔法”或模糊不清的API。
- en: All this is great for the individual developer, but the effect is amplified
    across larger teams and organizations. Although there’s certainly room for React
    to improve and keep growing, the hard work of making it a simple and flexible
    technology pays off for engineering teams. Simpler technologies with good mental
    models tend to create less of a mental burden for engineers and let them move
    faster and have a higher impact. As a bonus, a simpler set of tools is easier
    to learn for new employees. Trying to ramp up a new team member to an overly complex
    stack will not only cost time for the training engineers, it will also probably
    mean that the new developer will be unable to make meaningful contributions for
    some time. Because React seeks to carefully rethink established best practices,
    there’s the initial cost in paradigm switch, but after that it’s often a big,
    long-term win.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对个人开发者来说都是非常好的，但在更大的团队和组织中效果更明显。尽管React当然还有改进和继续发展的空间，但使其成为一个简单且灵活技术的辛勤工作对工程团队来说是值得的。具有良好心智模型的技术越简单，对工程师的心理负担就越小，让他们可以更快地工作并产生更大的影响。作为额外的好处，一套更简单的工具对新员工来说更容易学习。试图让新团队成员快速适应过于复杂的堆栈不仅会花费培训工程师的时间，而且新开发者可能需要一段时间才能做出有意义的贡献。因为React寻求仔细重新思考既定的最佳实践，所以在范式转换的初期会有成本，但之后通常是一个大型的、长期的胜利。
- en: Although it’s certainly a different tool than others in the same space, React
    is a fairly lightweight library in terms of responsibility and functionality.
    Where something like Angular may require you to “buy in” to a more comprehensive
    API, React is only concerned with the view of your application. This means it’s
    much more trivial to integrate it with your current technologies, and it will
    leave you room to make choices about other aspects. Some opinionated frameworks
    and libraries require an all-or-nothing adoption stance, but React’s “just the
    view” scope and general interoperability with JavaScript mean this isn’t always
    the case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管React与其他同一领域中的工具相比确实不同，但在责任和功能方面，React是一个相当轻量级的库。例如，Angular可能要求你“接受”一个更全面的API，而React只关注你的应用程序视图。这意味着它更容易与你的现有技术集成，并为你留下选择其他方面的空间。一些有偏见的框架和库要求全有或全无的采用立场，但React的“仅视图”范围和与JavaScript的通用互操作性意味着这并不总是如此。
- en: Instead of going all-in, you can incrementally transition different projects
    or tools over to React without having to make a drastic change to your structure,
    build stack, or other related areas. That’s a desirable trait for almost any technology,
    and it’s how React was first tried out at Facebook—in one small project area.
    From there it grew and took hold as more and more teams saw and experienced its
    benefits. What does all this mean for your team? It means you can evaluate React
    without having to take the risk of completely rewriting the product using React.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必全盘接受，可以逐步将不同的项目或工具过渡到React，而不必对结构、构建堆栈或其他相关领域进行剧烈的改变。这对几乎任何技术来说都是一个理想的特性，这也是React最初在Facebook上尝试的方式——在一个小的项目区域内。从那里，它逐渐成长并站稳脚跟，因为越来越多的团队看到了它的好处并亲身体验了它。这对你的团队意味着什么？这意味着你可以评估React，而无需承担完全使用React重写产品的风险。
- en: The simplicity, un-opinionated nature, and performance of React make it a great
    fit for projects small and large alike. As you keep exploring React, you’ll see
    how it can be a good fit for your team and projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: React 的简洁性、无偏见特性和性能使其非常适合大小项目。随着你对 React 的不断探索，你会看到它如何适合你的团队和项目。
- en: 1.6\. Summary
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 摘要
- en: 'React is a library for creating user interfaces that was initially built and
    open sourced by Facebook. It’s a JavaScript library built with simplicity, performance,
    and components in mind. Rather than provide a comprehensive set of tools for creating
    applications, it allows you to choose how to implement your data models, server
    calls, and other application concerns, and what to implement them with. These
    key reasons and others are why React can be a great tool for small and large applications
    and teams alike. Here are some of the benefits of React briefly summarized for
    a few typical roles:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于创建用户界面的库，最初由 Facebook 构建并开源。它是一个以简洁、性能和组件为设计理念的 JavaScript 库。它不提供创建应用程序的完整工具集，而是允许你选择如何实现你的数据模型、服务器调用和其他应用程序关注点，以及使用什么来实现它们。这些关键原因以及其他原因使得
    React 可以成为小型和大型应用程序和团队的优秀工具。以下是 React 对一些典型角色的简要总结：
- en: '***Individual developer*—** Once you learn React, your applications can be
    easier to rapidly build out. They will tend to be easier to work on for larger
    teams, and sophisticated features can be easier to implement and maintain.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***个人开发者*—** 一旦你学会了 React，你的应用程序可以更容易地快速构建。它们将更容易为大型团队工作，并且复杂功能可以更容易地实现和维护。'
- en: '***Engineering manager*—** There’s an initial cost for developers as they learn
    React, but eventually they’ll be able to more easily and quickly develop complex
    applications.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工程经理*—** 开发者学习 React 时会有一个初始成本，但最终他们能够更容易、更快地开发复杂的应用程序。'
- en: '***CTO or upper management*—** React, like any technology, is an investment
    with risks. But the eventual gains in productivity and reduced mental burdens
    often outweigh time sunk into ramping up. That’s not the case for every team,
    but it’s true for many.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***CTO 或高级管理层*—** React，就像任何技术一样，是一个有风险的投入。但最终的生产力提升和减轻心理负担往往超过了投入的时间。并非每个团队都是这样，但对于许多团队来说，这是真的。'
- en: 'All in all, React can be relatively easy for onboarding engineers to learn,
    can reduce the total amount of unnecessary complexity in an application, and can
    reduce technical debt by promoting code reuse. Take a second to review some of
    what you’ve learned about React so far:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，React 对于工程师的入门相对容易，可以减少应用程序中不必要的复杂性的总量，并通过促进代码重用减少技术债务。花点时间回顾一下你到目前为止学到的关于
    React 的内容：
- en: React is a library for building user interfaces, originally created by engineers
    at Facebook.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是一个用于构建用户界面的库，最初由 Facebook 的工程师创建。
- en: React provides a simple, flexible API that’s based around components.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 提供了一个简单、灵活的 API，它围绕组件构建。
- en: Components are the fundamental unit of React, and they’re used extensively in
    React applications.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是 React 的基本单元，并且在 React 应用程序中被广泛使用。
- en: React implements a virtual DOM that sits between your program and the browser
    DOM.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 实现了一个虚拟 DOM，它位于你的程序和浏览器 DOM 之间。
- en: The virtual DOM allows for efficient updates to the DOM using a fast diffing
    algorithm.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟 DOM 允许使用快速的 diffing 算法高效地更新 DOM。
- en: The virtual DOM allows for excellent performance, but the biggest win is the
    mental model that it affords.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟 DOM 允许出色的性能，但最大的优势是它提供的心理模型。
- en: Now that you know a little more about the background and design of React, we
    can really dive in. In the next chapter, you’ll create your first component and
    take a closer look at how React works. You’ll be learning more about the virtual
    DOM, components in React, and how you can create components of your own.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 React 的背景和设计有了更多了解，我们可以真正深入研究了。在下一章中，你将创建你的第一个组件，并更深入地了解 React 的工作原理。你将了解更多关于虚拟
    DOM、React 中的组件以及如何创建自己的组件。
- en: 'Chapter 2\. <Hello World />: our first component'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. <Hello World />：我们的第一个组件
- en: '*This chapter covers*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Thinking about user interfaces with components
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件思考用户界面
- en: Components in React
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 中的组件
- en: How React renders components
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 如何渲染组件
- en: Different ways of creating components in React
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中创建组件的不同方法
- en: Using JSX in React
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中使用 JSX
- en: '[Chapter 1](kindle_split_011_split_000.xhtml#ch01) talked about React in mostly
    theoretical terms. If you’re a “show me the code!” kind of person, this chapter
    is for you. We’ll start looking at React up close in this chapter. As we get into
    some of React’s API, you’ll build a simple comment box that will help you see
    the mechanics of React in action and start to solidify a mental model of how React
    works. We’ll start by building React components without any “syntactic sugar”
    or conveniences that might obscure the underlying technology. We’ll explore JSX
    (a lightweight markup language that helps us build React components more easily)
    at the end of the chapter. In later chapters, we’ll get more complex and see how
    to create a full app out of React components (Letters Social—check it out at [https://social.react.sh](https://social.react.sh)),
    but in this chapter, we’ll keep our scope limited to just a few related components.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](kindle_split_011_split_000.xhtml#ch01)主要从理论角度介绍了React。如果您是“给我看代码！”这类人，那么这一章就是为您准备的。我们将从本章开始近距离观察React。随着我们深入了解React的一些API，您将构建一个简单的评论框，这将帮助您看到React的实际运作机制，并开始巩固React工作原理的内心模型。我们将从构建没有任何“语法糖”或可能掩盖底层技术的便利性的React组件开始。我们将在本章末尾探讨JSX（一种轻量级标记语言，有助于我们更轻松地构建React组件）。在后面的章节中，我们将更加复杂，并了解如何从React组件中创建完整的应用程序（Letters
    Social—请查看[https://social.react.sh](https://social.react.sh))，但在这章中，我们将保持范围仅限于几个相关组件。'
- en: 'Before diving in, let’s take a brief, high-level look at React again to orient
    ourselves. [Figure 2.1](kindle_split_012_split_000.xhtml#ch02fig01) gives you
    an overview of the core aspects of most React applications. Let’s look at each
    part:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们再次简要地回顾一下React，以便定位自己。[图2.1](kindle_split_012_split_000.xhtml#ch02fig01)为您概述了大多数React应用程序的核心方面。让我们看看每个部分：
- en: '***Components*—** Encapsulated units of functionality that are the fundamental
    unit of React. These are what your views are made from. They’re JavaScript functions
    or classes that receive properties as inputs and maintain their own internal state.
    React provides a set of lifecycle methods for certain types of components so you
    can hook into the different component-management steps.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件***—**封装的功能单元是React的基本单元。这些是构成您视图的元素。它们是接收属性作为输入的JavaScript函数或类，并维护自己的内部状态。React为某些类型的组件提供了一套生命周期方法，以便您可以在不同的组件管理步骤中挂钩。**'
- en: '***React libraries*—** React applications run using the React libraries. The
    core React library (`react`) is supported by the `react-dom` and `react-native`
    libraries. React DOM handles rendering in browser or server-side environments,
    whereas React Native provides native bindings that mean you can create React applications
    for iOS or Android.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***React库***—**React应用程序使用React库运行。核心React库（`react`）由`react-dom`和`react-native`库支持。React
    DOM处理浏览器或服务器端环境中的渲染，而React Native提供原生绑定，这意味着您可以为iOS或Android创建React应用程序。'
- en: '***Third-party libraries*—** React doesn’t enforce opinions on you with regard
    to data modeling, HTTP calls, specific areas of styling such as look and feel,
    or other aspects of your application. For these, you’ll integrate other technologies
    to build out your application as you see fit. Not all libraries are compatible
    with React, but there are ways you can integrate most of them with React. We’ll
    explore using non-React code in React apps in [chapters 4](kindle_split_015_split_000.xhtml#ch04),
    [10](kindle_split_022_split_000.xhtml#ch10), and [11](kindle_split_023_split_000.xhtml#ch11).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***第三方库***—**React在数据建模、HTTP调用、特定区域的样式（如外观和感觉）或其他应用程序方面不强制您有任何观点。对于这些，您将集成其他技术来构建您认为合适的应用程序。并非所有库都与React兼容，但您可以通过一些方法将大多数库与React集成。我们将在第4章、第10章和第11章中探讨在React应用程序中使用非React代码。**'
- en: '***Running a React application*—** Your React application, created from components,
    runs on a platform of your choice: web, mobile, or native.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行React应用程序***—**您从组件创建的React应用程序可以在您选择的平台上运行：Web、移动或原生。'
- en: Figure 2.1\. This is React at a very high level, which you may recognize from
    [chapter 1](kindle_split_011_split_000.xhtml#ch01). With React you can use components
    to build user interfaces that can run on browsers and native platforms like iOS
    and Android. It isn’t a comprehensive framework—it leaves you the freedom to choose
    what libraries you use for data modeling, styling, HTTP calls, and more. You can
    run React apps in browsers and, with the help of React Native, on mobile devices.
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 这是在非常高的层次上对 React 的描述，你可能从[第 1 章](kindle_split_011_split_000.xhtml#ch01)中已经认识到了。使用
    React，你可以使用组件来构建可以在浏览器和原生平台（如 iOS 和 Android）上运行的用户界面。它不是一个全面的框架——它给你自由选择用于数据建模、样式、HTTP
    调用等方面的库。你可以在浏览器中运行 React 应用程序，并在 React Native 的帮助下在移动设备上运行。
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: 2.1\. Introducing React components
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 介绍 React 组件
- en: Components are the fundamental unit of a client-side application written in
    React. You’ll definitely be creating lots of components! In this chapter, you’ll
    build a simple comment box from components to get your hands dirty and take a
    whirlwind tour of React. But first let’s take a little time to explore “thinking
    in components” and see how that might shake out with regard to your comment box.
    For most of the book, we’ll usually dive into the code without spending too much
    time planning things out, but for this first foray into React we’ll do a little
    bit of planning to get our mindset right. Have a look at [figure 2.2](kindle_split_012_split_001.xhtml#ch02fig02).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是使用 React 编写的客户端应用程序的基本单元。你肯定会创建很多组件！在本章中，你将从组件构建一个简单的评论框，以便亲身体验并快速了解 React。但首先，让我们花一点时间来探索“以组件思考”的方式，看看这对你的评论框会有什么影响。在本书的大部分内容中，我们通常会直接进入代码编写，而不花太多时间去规划，但在这个
    React 的首次尝试中，我们将进行一些规划，以调整我们的心态。请参阅[图 2.2](kindle_split_012_split_001.xhtml#ch02fig02)。
- en: Figure 2.2\. Overview of a React component. We’ll be exploring each of these
    key parts for the rest of the book.
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. React 组件概述。在本书的剩余部分，我们将探索这些关键部分的每个部分。
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02_alt.jpg)'
- en: In this book, we’ll pretend that we’re employees of a fictional startup called
    Letters. You’ll build a next-generation social network (where you can post, comment,
    and like—truly ground-breaking). In this chapter, we’re exploring React as a potential
    technology choice for your company. You’ve been tasked with creating a simple
    set of components to get a feel for the technology. You have some really rough
    mockups that the design team gave you, but that’s about it. [Figure 2.3](kindle_split_012_split_001.xhtml#ch02fig03)
    shows a pretty version of what you’ll be building.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将假装自己是虚构初创公司 Letters 的员工。你将构建一个下一代社交网络（你可以发布、评论和点赞——真正具有革命性的）。在本章中，我们正在探索
    React 作为你公司潜在的技术选择。你被分配了一个创建一组简单组件的任务，以了解这项技术。你有一些设计团队给你的非常粗糙的原型，但仅此而已。[图 2.3](kindle_split_012_split_001.xhtml#ch02fig03)
    展示了你将构建的版本。
- en: Figure 2.3\. Rough comment box mockup. You’ll create a UI where users can add
    comments to a post and view previous comments.
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 粗略的评论框原型。你将创建一个用户可以添加评论并查看先前评论的用户界面。
- en: '![](Images/02fig03.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03.jpg)'
- en: How should you get started building this? Let’s begin with understanding the
    data your application needs and then seeing how you can turn that into components.
    How should you translate the mockup into components? You could just dive in and
    start trying to create components without knowing anything about React, but without
    understanding how they work or what purpose they’d serve, you could end up creating
    something messy or not idiomatic to React. We’ll do some planning in the next
    few sections so you have a better idea about how to structure and design your
    comment box.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该如何开始构建这个？让我们先了解你的应用程序需要的数据，然后看看你如何将其转换为组件。你应该如何将原型转换为组件？你可以直接跳入并尝试创建组件，而不了解
    React 的任何知识，但如果不了解它们的工作原理或它们将服务的目的，你可能会创建出混乱或不符合 React 习惯的东西。在接下来的几节中，我们将进行一些规划，以便你更好地了解如何构建和设计你的评论框。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Revisit your interface breakdown**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**回顾你的界面分解**'
- en: 'Before moving on, take some time to revisit an exercise from the last chapter.
    You looked at a web interface and took some time to break it down on your own.
    Take a minute to revisit the same interface and see if you’d do anything differently
    now that you know more about components in React. Would you group things together
    differently? Here’s the same marked-up GitHub profile interface from [chapter
    1](kindle_split_011_split_000.xhtml#ch01) to jog your memory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花点时间回顾一下上一章的一个练习。您查看了一个Web界面，并花了一些时间自己将其分解。花一分钟时间回顾一下相同的界面，看看现在您是否会对组件有更多的了解而做出不同的处理。您会以不同的方式将事物分组吗？以下是来自[第1章](kindle_split_011_split_000.xhtml#ch01)的相同标记的GitHub个人资料界面，以帮助您回忆：
- en: '![](Images/026fig01_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/026fig01_alt.jpg)'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.1.1\. Understanding the application data
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 理解应用程序数据
- en: Besides the mockup, we need something else before we can plan how your components
    will be organized. We need to know what information the API will provide to your
    application. Based on the mockup, you can probably already guess some of the data
    that you might be getting back. Getting a sense of the shape of your application
    data will be an important part of the planning we’re doing before starting to
    create your UI.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原型之外，在我们规划如何组织您的组件之前，我们还需要其他一些东西。我们需要知道API将向您的应用程序提供哪些信息。根据原型，您可能已经可以猜测一些可能返回的数据。对您的应用程序数据形状的感知将是我们在开始创建UI之前规划的重要部分。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Web APIs**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web APIs**'
- en: You may have heard the term *API* used frequently in your job or in your learning.
    If you’re already familiar with this concept, feel free to move on. If not, this
    section might help you. What is an API? An API, or, *application programming interface*,
    is a set of routines and protocols for building software. That might sound vague,
    and it is a pretty general definition. API is a broad term, applying to everything
    from company platforms to open source libraries.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在工作中或学习中经常听到*API*这个词。如果您已经熟悉这个概念，请随意继续。如果不熟悉，本节可能对您有所帮助。什么是API？API，或*应用程序编程接口*，是一组用于构建软件的例程和协议。这可能听起来有些模糊，这是一个相当通用的定义。API是一个广泛的概念，适用于从公司平台到开源库的各个方面。
- en: In web development and engineering, API has become almost synonymous with a
    remote, web-based *public* API. This means that an API is usually a way of exposing
    defined ways to interact with a program or platform, usually over the internet,
    and for people to use and consume. There are many examples, but two of the more
    familiar ones are the Facebook and Stripe APIs. They provide a set of methods
    to interact with their programs and data over the web.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发和工程中，API几乎成了远程、基于Web的*公共*API的同义词。这意味着API通常是一种暴露定义好的与程序或平台交互方式的方法，通常通过互联网，供人们使用和消费。有许多例子，但其中两个更熟悉的是Facebook和Stripe
    API。它们提供了一套通过Web与它们的程序和数据交互的方法。
- en: The back-end infrastructure team at Letters, our fictional company, has created
    such an API for you to use. There are many different forms and types of web-based
    APIs, but the one that you’ll work with in this book is that of a *RESTful JSON
    API*. This means that a server will give you data in the JSON format and the available
    data organized around resources like users, posts, comments, and so on. RESTful
    JSON APIs are a common style of remote API, so this likely won’t be the only time
    you work with one if you haven’t already.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚构的公司Letters的后端基础设施团队为您创建了一个这样的API。基于Web的API有许多不同的形式和类型，但您在本书中将使用的是*RESTful
    JSON API*。这意味着服务器将以JSON格式为您提供数据，并将可用的数据组织在用户、帖子、评论等资源周围。RESTful JSON API是远程API的一种常见样式，所以如果您之前没有这样做过，这很可能不是您唯一一次与之合作。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following listing shows an example of data you’ll receive from the API for
    your comment box and how it might match up to your mockup.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了您将从API收到的数据示例，以及它如何与您的原型相匹配。
- en: Listing 2.1\. Sample JSON API
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. 示例JSON API
- en: '[PRE0]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* This didn’t appear in the visual mockup, but that doesn’t mean you don’t
    need this piece of data.**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这在视觉原型中并未出现，但这并不意味着您不需要这块数据。**'
- en: '***2* You’ve received a collection of comment objects.**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您已收到一组评论对象。**'
- en: '***3* Comments have IDs too.**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 评论也有ID。**'
- en: The API returns a JSON response containing a single post. It has some important
    properties, including `id`, `content`, `author`, and `comments`. `id` is a number,
    `content` and `author` are strings, and `comments` is an array of objects. Each
    comment has its own ID, a user who made the comment, and the content of the comment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: API 返回一个包含单个帖子的 JSON 响应。它包含一些重要的属性，包括 `id`、`content`、`author` 和 `comments`。`id`
    是一个数字，`content` 和 `author` 是字符串，而 `comments` 是一个对象数组。每个评论都有自己的 ID、发表评论的用户和评论内容。
- en: '2.1.2\. Multiple components: Composition and parent-child relationships'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 多个组件：组合和父子关系
- en: You have the data we need and a mockup, but how do you go about forming components
    to use that data? For one, you need to know how components can be organized with
    other components. React components are organized into tree structures. Like DOM
    elements, React components can be nested and can contain other components. They
    can also appear “next to” other components, which means that they occur at the
    same level as other components (see [figure 2.4](kindle_split_012_split_001.xhtml#ch02fig04)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您拥有我们所需的数据和原型，但您如何着手构建组件以使用这些数据呢？首先，您需要了解组件如何与其他组件组织在一起。React 组件被组织成树状结构。就像
    DOM 元素一样，React 组件可以嵌套，并包含其他组件。它们也可以“并列”于其他组件旁边，这意味着它们与其他组件处于同一级别（见[图 2.4](kindle_split_012_split_001.xhtml#ch02fig04)）。
- en: Figure 2.4\. Components can have different types of relationships (parent and
    child), can be used to create other components, or can even stand alone. They
    can often be easily moved around because they’re self-contained and don’t carry
    any baggage when moved. As such, they’re said to be composable.
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4\. 组件可以有不同的关系类型（父和子），可以用来创建其他组件，甚至可以独立存在。由于它们是自包含的，并且在移动时不会携带任何“负担”，因此它们被称为可组合的。
- en: '![](Images/02fig04.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04.jpg)'
- en: 'That brings up an important question: what sort of relationships can components
    have? You might think there would be quite a few different types of relationships
    that can be created using components, and in one sense, you’re right. Components
    can be used in flexible ways. Because they’re self-contained and tend not to carry
    around any “baggage,” they’re said to be *composable*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个重要的问题：组件可以有什么样的关系？您可能会认为使用组件可以创建相当多的不同类型的关系，从某种意义上说，您是对的。组件可以以灵活的方式使用。因为它们是自包含的，并且通常不会携带任何“负担”，所以它们被称为*可组合的*。
- en: Composable components are often easily moved around and can be reused to create
    other components. You can think of them almost like LEGO bricks. Each LEGO brick
    is self-contained, so it can be easily moved around—you don’t have to bring a
    whole set with the one brick—and it easily fits in with other components. Portability
    isn’t the be-all, end-all, but it’s often a feature of well-designed React components.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合的组件通常很容易移动，并且可以重用来创建其他组件。您可以将它们想象成几乎像乐高积木。每个乐高积木都是自包含的，因此可以轻松移动——您不需要携带整个套装就可以移动一个积木，并且它们很容易与其他组件配合。便携性不是万能的，但它通常是设计良好的
    React 组件的一个特性。
- en: 'Because components are composable, they can be used in many places throughout
    your application. Wherever a component is used, it probably helps form a certain
    type of relationship: *parent* and *child*. If a component contains another component,
    it’s said to be the parent. A component within another component is said to be
    a child. Components that exist at the same level don’t share any sort of direct
    relationship, even though they might be right next to each other. They only “care”
    about their parents and children.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件是可组合的，它们可以在应用程序的许多地方使用。无论组件在哪里使用，它都可能有助于形成某种类型的关系：*父*和*子*。如果一个组件包含另一个组件，那么它被称为父组件。另一个组件内部的组件被称为子组件。处于同一级别的组件之间没有直接的直接关系，尽管它们可能紧挨着。它们只“关心”它们的父亲和子代。
- en: '[Figure 2.4](kindle_split_012_split_001.xhtml#ch02fig04) shows how components
    can relate to each other in a parent-child way and be composed together to create
    new components. Note the lack of direct relationship between the two sibling components
    despite a direct parent-child relationship. I’ll cover more on this when we explore
    data flow in React.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.4](kindle_split_012_split_001.xhtml#ch02fig04) 展示了组件如何以父子方式相互关联，并组合在一起以创建新的组件。请注意，尽管存在直接的父子关系，但两个兄弟组件之间没有直接的关系。当我们在
    React 中探索数据流时，我会对此进行更多介绍。'
- en: 2.1.3\. Establishing component relationships
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 建立组件关系
- en: We have a sense of the data and visual appearance of your interface as well
    as the parent-child relationship components can form. Now you can get started
    on defining your component hierarchy, which is the process of applying what you’ve
    learned so far. You’ll establish what will be a component and where it will go.
    This process of establishing component relationships won’t look the same for every
    team or every project. Component relationships are also likely to change over
    time, so don’t expect perfection your first time around. Easier iteration in a
    UI is part of what makes React pleasant to work with.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对您界面的数据和视觉外观有了感知，以及父组件和子组件可以形成的关系组件。现在您可以开始定义您的组件层次结构了，这是应用您所学知识的过程。您将确定哪些将成为组件以及它们将位于何处。这个建立组件关系的过程对于每个团队或每个项目来说可能看起来都不一样。组件关系也可能会随时间而变化，所以不要期望第一次就能完美无缺。在UI中更容易进行迭代是React易于使用的一部分原因。
- en: 'Take a minute or two to try breaking down the mockup into components before
    we move on. You’ve done this a couple times now, but practicing thinking with
    components will only make working with React easier. As you practice, remember
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，花一两分钟尝试将原型分解成组件。您已经这样做过几次了，但通过组件思考的练习将使使用React变得更加容易。在练习时，请记住以下几点：
- en: Ensure that components are grouped together in a way that makes sense; components
    should be organized around related functionality. If it’s untenable to move components
    around in your application, you might be creating too rigid a hierarchy. This
    isn’t always the case, but it’s good to watch out for.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保组件以有意义的分组方式组织在一起；组件应该围绕相关的功能进行组织。如果无法在您的应用程序中移动组件，您可能创建了一个过于僵化的层次结构。这并不总是这种情况，但这是一个值得注意的地方。
- en: If you see an interface element repeated multiple times, that’s usually a good
    candidate for becoming a component.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您看到界面元素被多次重复，那么通常将其变成组件是一个很好的候选。
- en: You won’t get everything perfect the first time, and that’s okay. It’s normal
    to iteratively improve your code. The initial planning isn’t meant to eliminate
    future change, but to set the proper starting direction.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您第一次可能无法做到完美，这是完全可以接受的。迭代地改进您的代码是正常的。最初的规划并不是为了消除未来的变化，而是为了设定正确的起始方向。
- en: With these guidelines in mind, you can look at the available data and mockup
    and start by breaking things up into a few components. [Figure 2.5](kindle_split_012_split_001.xhtml#ch02fig05)
    shows one way of breaking up the interface into components.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些指南的同时，您可以查看可用的数据和原型，并开始将它们分解成几个组件。[图2.5](kindle_split_012_split_001.xhtml#ch02fig05)展示了将界面分解成组件的一种方法。
- en: Figure 2.5\. You can break your interface up into just a few components. Note
    that you don’t necessarily need to create components for every single element
    of the interface, although it might make sense to decompose more parts into components
    as an application grows. Also, you’ll notice that the same comment component will
    be used for each of the comments attached to a post. And note that I’ve diagrammed
    things here on the side for readability; you might have instead drawn lines right
    on top of everything.
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5。您可以将界面分解成仅仅几个组件。请注意，您不一定需要为界面的每个元素都创建组件，尽管随着应用程序的增长，将更多部分分解成组件可能是有意义的。您还会注意到，相同的评论组件将被用于每个附加到帖子上的评论。此外，请注意，我为了可读性在这里的旁边绘制了图表；您可能直接在所有内容上方绘制线条。
- en: '![](Images/02fig05_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig05_alt.jpg)'
- en: With React you can be flexible in designing your application. We’ve come up
    with four components, but there are many ways that you might have gone about dividing
    things up. React enforces a parent-child relationship between components, but
    beyond that you’re free to define your hierarchy in whatever way makes the most
    sense to you and your team. There might be, for example, cases where you break
    a small section of the UI into many different parts. The size of the UI isn’t
    directly related to how many or how few components it should be comprised from.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React，您可以在设计应用程序时保持灵活性。我们提出了四个组件，但您可能有多种方式来划分这些内容。React强制组件之间建立父子关系，但除此之外，您可以根据您和您的团队认为最有意义的方式来定义您的层次结构。例如，可能会有这样的情况，您将UI的一个小部分分解成许多不同的部分。UI的大小并不直接关系到它应该由多少或多少个组件组成。
- en: Now that we’ve gone through some initial planning, you’re ready to dive in and
    start creating your comment box UI. In the next section, you’ll start creating
    React components. You won’t use any syntactic helpers like JSX. Instead, we’ll
    focus on “raw” React and you’ll get a feel for the core mechanics of the technology
    before moving on to use such helpers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一些初步规划，你就可以开始深入创建你的评论框 UI 了。在下一节中，你将开始创建 React 组件。你将不会使用任何像 JSX 这样的语法辅助工具。相反，我们将专注于“原始”React，你将在使用这些辅助工具之前先了解该技术的核心机制。
- en: You might get frustrated by having to forgo some of the helpers that you’d use
    during normal React development. I’m glad about that, because it will probably
    mean that you’ll more genuinely appreciate and understand the abstractions you’ll
    be working with. It’s not always the case, but in my experience starting with
    the lower-level elements of a new technology will generally better equip you to
    work with it for the long term. We don’t need to write our JavaScript programs
    in assembly code, certainly, but we also don’t want to use a technology with an
    incomplete understanding of the core mechanics.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会因为不得不放弃在正常 React 开发中使用的某些辅助工具而感到沮丧。我很高兴这样，因为这可能意味着你将更加真诚地欣赏和理解你将与之工作的抽象。虽然并不总是如此，但根据我的经验，从新技术的基础元素开始通常能更好地为你长期使用该技术做好准备。我们当然不需要用汇编代码编写我们的
    JavaScript 程序，但我们也不要使用一个对核心机制理解不完整的技术。
- en: 2.2\. Creating components in React
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 在 React 中创建组件
- en: In this section, you’ll create some React components and run them in a browser.
    For now, you won’t need to use node.js or any anything else to get everything
    set up and running. You’ll run code in the browser via CodeSandbox ([https://codesandbox.io](https://codesandbox.io)).
    If you’d prefer to edit the files locally, you can click Download in the CodeSandbox
    code editor and get the code for that example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一些 React 组件并在浏览器中运行它们。目前，你不需要使用 node.js 或其他任何东西来设置和运行一切。你将通过 CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)) 在浏览器中运行代码。如果你更喜欢在本地编辑文件，你可以在
    CodeSandbox 代码编辑器中点击下载，以获取该示例的代码。
- en: 'You’ll use three libraries for your first components: `React`, `React DOM`,
    and `prop-types`. `React DOM` is a renderer for React that was split off from
    the main `React` library to better separate concerns; it handles rendering components
    to the DOM or to a string for server-side rendering. The `prop-types` library
    is a development library that will help you do some typechecking on data passed
    to your components.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用三个库来创建你的第一个组件：`React`、`React DOM` 和 `prop-types`。`React DOM` 是从主 `React`
    库中分离出来的一个渲染器，以更好地分离关注点；它负责将组件渲染到 DOM 或字符串（用于服务器端渲染）。`prop-types` 库是一个开发库，它将帮助你对你组件传递的数据进行类型检查。
- en: You’ll start creating the comment box component by creating some of the constituent
    parts first. This will help you get a better sense of what’s going to happen overall
    when React creates and renders your components. You need to add a new DOM element
    with an ID of `root` as well as some basic code that uses `React DOM`. The following
    listing shows the bare-bones starting place for your component. For each listing,
    I’ll include a link to an online running version of the code you can easily edit
    and play around with.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过首先创建一些组成部分来开始创建评论框组件。这将帮助你更好地理解 React 创建和渲染组件时整体会发生什么。你需要添加一个新的 DOM 元素，其
    ID 为 `root`，以及一些使用 `React DOM` 的基本代码。以下列表显示了组件的裸骨起始点。对于每个列表，我都会包含一个链接，指向你可以轻松编辑和尝试的在线运行代码版本。
- en: Listing 2.2\. Starting out
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 开始
- en: '[PRE1]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Store a reference to the root element—you’ll render your React app into
    this DOM element.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 保存对根元素的引用——你将在此 DOM 元素中渲染你的 React 应用程序。**'
- en: '***2* In the index.html file you’ve created a div with the id ‘root’.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在你创建的 index.html 文件中，你已经创建了一个具有 id ‘root’ 的 div 元素。**'
- en: Code for [listing 2.2](kindle_split_012_split_002.xhtml#ch02ex02) is available
    online at [https://codesandbox.io/s/vj9xkqzkvy](https://codesandbox.io/s/vj9xkqzkvy).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.2](kindle_split_012_split_002.xhtml#ch02ex02) 的代码可在网上找到，链接为 [https://codesandbox.io/s/vj9xkqzkvy](https://codesandbox.io/s/vj9xkqzkvy)。'
- en: 2.2.1\. Creating React elements
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 创建 React 元素
- en: 'So far, your code won’t do much of anything except download the React libraries
    and find the `root` DOM element. To make something substantial happen, you need
    to use `React DOM`. You’ll need to call its `render` method for React to create
    and manage your component. You’ll call this method with a component to render
    and `container` (which will be the DOM element you stored in a variable earlier).
    The signature of `ReactDOM.render` looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的代码除了下载React库和找到`root` DOM元素之外，不会做太多的事情。要使某些实质性的事情发生，你需要使用`React DOM`。你需要调用它的`render`方法，React才能创建和管理你的组件。你将使用一个组件来调用这个方法，以及`container`（这将是之前存储在变量中的DOM元素）。`ReactDOM.render`的签名看起来像这样：
- en: '[PRE2]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`React DOM` needs an element of type `ReactElement` and a DOM element. You’ve
    created a valid DOM element that you can use, but now you need to create a React
    element. But what’s a React element?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`React DOM`需要一个类型为`ReactElement`的元素和一个DOM元素。你已经创建了一个有效的DOM元素可以使用，但现在你需要创建一个React元素。但什么是React元素呢？'
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: 'A *React element* is a light, stateless, immutable primitive in React. There
    are two types: `ReactComponentElement` and `ReactDOMElement`. `ReactDOMElement`s
    are virtual representations of DOM elements. `ReactComponentElement`s reference
    either a function or a class corresponding to a React component.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*React元素*是React中一个轻量级、无状态、不可变的原语。有两种类型：`ReactComponentElement`和`ReactDOMElement`。`ReactDOMElement`s是DOM元素的虚拟表示。`ReactComponentElement`s引用一个与React组件对应的函数或类。'
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '*Elements* are the descriptors we use to tell React what we want to see on
    the screen and are a central concept in React. Most of your components will be
    collections of React elements; they’ll create a “boundary” of sorts around a portion
    of your UI so you can group functionality, markup, and styles together. But what
    does it mean for a React element to be a virtual representation of a DOM element?
    This means that React elements are to React what DOM elements are to the DOM—the
    basic primitives that compose a UI. When you’re creating plain old HTML markup,
    you use a variety of element types (`div`, `span`, `section`, `p`, `img`, and
    so on) to contain and structure information. In React, you can use React elements—which
    tell React about either React components or regular DOM elements you want rendered—to
    compose and build your UI.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*元素*是我们用来告诉React我们在屏幕上想要看到什么内容的描述符，并且在React中是一个核心概念。你大部分的组件都将是React元素的集合；它们会在你的UI的一部分周围创建一种“边界”，这样你就可以将功能、标记和样式组合在一起。但是，对于一个React元素来说，成为DOM元素的虚拟表示意味着什么呢？这意味着React元素对于React来说，就像DOM元素对于DOM一样——组成UI的基本原语。当你创建普通的HTML标记时，你使用各种元素类型（如`div`、`span`、`section`、`p`、`img`等）来包含和结构化信息。在React中，你可以使用React元素——这些元素告诉React你想要渲染的React组件或常规DOM元素——来组合和构建你的UI。'
- en: 'Maybe the parallel between DOM elements and React elements didn’t click for
    you immediately. That’s okay. Remember how React is supposed to help you by creating
    a better mental model to work with? The parallel between DOM elements and React
    elements is one way in which it does that. It means that you get a familiar mental
    structure to work with: a tree structure of elements that are like regular DOM
    elements. [Figure 2.6](kindle_split_012_split_002.xhtml#ch02fig06) will help you
    visualize some of the similarities between React elements and DOM elements.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可能DOM元素和React元素之间的平行关系一开始没有立即让你感到共鸣。没关系。记得React应该通过创建更好的心智模型来帮助你吗？DOM元素和React元素之间的平行关系是它这样做的一种方式。这意味着你得到了一个熟悉的心智结构来工作：一个类似于常规DOM元素的元素树结构。[图2.6](kindle_split_012_split_002.xhtml#ch02fig06)将帮助你可视化React元素和DOM元素之间的一些相似之处。
- en: Figure 2.6\. The virtual and “real” DOM share a similar tree-like structure,
    which makes it easy for you to think about the structure of your components and
    overall application in React in similar ways. The DOM is comprised of `DOMElements`
    (`HTMLElements` and `SVGElements`), whereas React’s virtual DOM is comprised of
    React elements.
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6。虚拟的“真实”DOM共享一个类似的树状结构，这使得你在React中以类似的方式思考组件和整体应用程序的结构变得容易。DOM由`DOMElements`（`HTMLElements`和`SVGElements`）组成，而React的虚拟DOM由React元素组成。
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig06_alt.jpg)'
- en: Another way to think of React elements is as a set of basic instructions for
    React to use, like a blueprint for a DOM element. React elements are what `React
    DOM` will take and use to update the DOM. In [figure 2.7](kindle_split_012_split_002.xhtml#ch02fig07)
    React elements are being used in the overall process of a React application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考 React 元素的方式是将其视为一组基本指令，供 React 使用，就像 DOM 元素的蓝图。React 元素是 `React DOM` 将取用并用于更新
    DOM 的。在 [图 2.7](kindle_split_012_split_002.xhtml#ch02fig07) 中，React 元素被用于 React
    应用程序的整体过程中。
- en: Figure 2.7\. React elements are what React uses to create a virtual DOM that
    `React DOM` will manage and use to reconcile and update the actual DOM. They are
    simple blueprints for React to use in creating and managing elements.
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.7\. React 元素是 React 用于创建虚拟 DOM 的，`React DOM` 将会管理和使用它来协调和更新实际的 DOM。它们是 React
    创建和管理元素的简单蓝图。
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: 'You now know a little more about React elements in general, but how do they
    get created and what goes into creating them? You create React elements with `React.createElement`—go
    figure! Let’s look at its function signature to find out how you should use it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对 React 元素有了更多的了解，但它们是如何被创建的，以及创建它们时发生了什么？你使用 `React.createElement` 来创建 React
    元素—想想看！让我们看看它的函数签名，以了解如何使用它：
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`React.createElement` takes a string or component (either a class extending
    `React.Component` or a function), a props object, and children and returns a React
    element. Remember, a React element is a lightweight representation of something
    you want React to render. It can indicate either a DOM element or another React
    component.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement` 接收一个字符串或组件（要么是一个扩展 `React.Component` 的类，要么是一个函数），一个 props
    对象，以及子元素，并返回一个 React 元素。记住，React 元素是你想要 React 渲染的东西的轻量级表示。它可以指示一个 DOM 元素或另一个 React
    组件。'
- en: 'Let’s look more closely at each of these basic instructions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些基本指令中的每一个：
- en: '**`type`—** You can pass in either a string that is the tag name of the HTML
    element to be created (`"div"`, `"span"`, `"a"`, and so on) or a React class,
    which we’ll look at shortly. Think of this argument as React asking, “What type
    of thing am I going to be creating?”'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`type`—** 你可以传入一个字符串，它是要创建的 HTML 元素的标签名（例如 `"div"`，`"span"`，`"a"` 等）或一个 React
    类，我们稍后会讨论。把这个参数想象成 React 在问，“我将要创建什么类型的东西？”'
- en: '**`props`—** Short for *properties*. The `props` object provides a way of specifying
    which attributes will be defined on the HTML element (if in the context of a `ReactDOMElement`)
    or will be available to a component class instance.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`props`—** 简称 *属性*。`props` 对象提供了一种指定在 HTML 元素上定义哪些属性（如果是在 `ReactDOMElement`
    的上下文中）或将可用于组件类实例的方法。'
- en: '**`children...`—** Remember how I said React components are *composable*? This
    is where you can do some composing. Using `children...`, the arguments passed
    after `type` and `props` let you nest, order, and even further nest other React
    elements. As you can see in [listing 2.3](kindle_split_012_split_002.xhtml#ch02ex03),
    you can nest React elements by nesting calls to `React.createElement` in `children...`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`children...`—** 记得我之前说过 React 组件是 *可组合* 的吗？这就是你可以进行组合的地方。使用 `children...`，在
    `type` 和 `props` 之后传入的参数让你可以嵌套、排序，甚至进一步嵌套其他 React 元素。正如你在 [列表 2.3](kindle_split_012_split_002.xhtml#ch02ex03)
    中可以看到的，你可以在 `children...` 中通过嵌套对 `React.createElement` 的调用来嵌套 React 元素。'
- en: '`React.createElement` asks, “What am I creating?”, “How should I configure
    it?”, and “What does it contain?” The following listing shows how you might use
    `React.createElement`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement` 会问，“我在创建什么？”，“我应该如何配置它？”，“它包含什么？”下面的列表展示了如何使用 `React.createElement`。'
- en: Listing 2.3\. Using `React.createElement`
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 使用 `React.createElement`
- en: '[PRE4]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Import React and React DOM for use.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 React 和 React DOM 以便使用。**'
- en: '***2* React.createElement returns a single React element, so that’s what you’ll
    store in root for later use.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* React.createElement 返回一个单一的 React 元素，所以这就是你将存储在 root 中以供以后使用的内容。**'
- en: '***3* Whitespace shows the nesting better, but don’t miss how you’re nesting
    several React.createElement calls within respective children... parameters.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 空白字符有助于更好地显示嵌套，但不要错过你如何在各自的子...参数中嵌套多个 React.createElement 调用。**'
- en: '***4* Creating an anchor link—note the mailto property you’ve set, like how
    you might in regular HTML.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个锚点链接—注意你设置的 mailto 属性，就像在常规 HTML 中做的那样。**'
- en: '***5* Inner text can also be passed in children....**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 子元素也可以传入内联文本。**'
- en: '***6* Call the render method we talked about earlier.**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 调用我们之前提到的 render 方法。**'
- en: Code for [listing 2.3](kindle_split_012_split_002.xhtml#ch02ex03) is available
    online at [https://codesandbox.io/s/qxx7z86q4w](https://codesandbox.io/s/qxx7z86q4w).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.3](kindle_split_012_split_002.xhtml#ch02ex03) 的代码可在网上找到，链接为 [https://codesandbox.io/s/qxx7z86q4w](https://codesandbox.io/s/qxx7z86q4w)。'
- en: 2.2.2\. Rendering your first component
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 渲染你的第一个组件
- en: You should now be able see something besides a blank page, as shown in [figure
    2.8](kindle_split_012_split_002.xhtml#ch02fig08). You just created your first
    React component! Using the developer tools for your browser, try opening up the
    page and inspecting the HTML. You should see HTML elements that correspond to
    what you created using React. Note that the properties you passed have made it
    through, too, so you can click the link and send me an email telling me how much
    you’re loving learning about React.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到除了空白页面之外的内容，如图 2.8 所示。你刚刚创建了你第一个React组件！使用浏览器中的开发者工具，尝试打开页面并检查HTML。你应该看到与使用React创建的HTML元素相对应的内容。请注意，你传递的属性也已经通过，所以你可以点击链接并发送电子邮件告诉我你对学习React有多喜爱。
- en: Figure 2.8\. Your first component. It’s not much, but you’ve successfully created
    a component using React.
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8\. 你的第一个组件。它不多，但你已成功使用React创建了一个组件。
- en: '![](Images/02fig08.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.8](Images/02fig08.jpg)'
- en: This is great, but you may be wondering how React turns your many `React.createElement`s
    into what you see on the screen. React uses the React elements you provide to
    create a virtual DOM that `React DOM` can use as it manages the browser DOM. Remember
    from [figure 2.4](kindle_split_012_split_001.xhtml#ch02fig04) that the virtual
    and real DOMs share similar structures? Well, React needs to form its own virtual
    DOM tree structure from your React elements before it can do its work.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但你可能想知道React是如何将你的许多`React.createElement`转换成你在屏幕上看到的内容的。React使用你提供的React元素创建一个虚拟DOM，`React
    DOM`可以使用它来管理浏览器DOM。记得从图 2.4 中了解虚拟和真实DOM具有相似的结构吗？嗯，React需要在开始工作之前，从你的React元素中形成自己的虚拟DOM树结构。
- en: To do that, React will recursively evaluate all of the `children...` properties
    of every `React.createElement` call, passing the result up to the parent element.
    You can think of React doing this as being like a small child asking, “What is
    *X*?” repeatedly until they understand every little thing about *X*. [Figure 2.9](kindle_split_012_split_002.xhtml#ch02fig09)
    shows how you might think about React evaluating nested React elements. Follow
    the arrows down and across to the right to see how React examines the `children...`
    of every React element until it can form a complete tree.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，React会递归地评估每个`React.createElement`调用中的所有`children...`属性，并将结果传递给父元素。你可以将React这样做想象成一个小孩反复地问，“X是什么？”直到他们理解X的每一个细节。[图
    2.9](kindle_split_012_split_002.xhtml#ch02fig09) 展示了你如何思考React评估嵌套的React元素。沿着箭头向下和向右移动，看看React是如何检查每个React元素的`children...`，直到它能形成一个完整的树。
- en: Figure 2.9\. React will recursively evaluate a series of React elements to determine
    how it should form a virtual DOM tree structure for your components. It will also
    check for more React elements in `children...` to evaluate. React will go through
    every possible path, like a child asking, “What is X?” until they know everything.
    You can follow the arrows down and across to the right to get a sense of how React
    might evaluate nested React elements as well as what each parameter is asking.
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.9\. React会递归地评估一系列React元素，以确定它应该如何为你的组件形成虚拟DOM树结构。它还会检查`children...`中的更多React元素以进行评估。React会遍历所有可能的路径，就像一个孩子问，“X是什么？”直到他们知道一切。你可以沿着箭头向下和向右移动，以了解React如何评估嵌套的React元素以及每个参数在询问什么。
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.8](Images/02fig09_alt.jpg)'
- en: Now that you’ve created your first component, you may have a few questions and
    even some concerns. Even with some formatting help, it’s clear that it will be
    difficult to read through components that are nested even a few levels deep. We’ll
    explore better ways to write components, so don’t worry—you won’t be nesting `React.createElement`
    hundreds of times. Using it now will give you a better sense of what `React.createElement`
    does and will hopefully help you appreciate JSX when you start using it that much
    more.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了你的第一个组件，你可能会有一些疑问，甚至一些担忧。即使有一些格式化帮助，很明显，阅读嵌套几层深的组件将会很困难。我们将探讨更好的编写组件的方法，所以请不要担心——你不会将`React.createElement`嵌套数百次。现在使用它将帮助你更好地理解`React.createElement`的作用，并希望在你开始大量使用它时，能更欣赏JSX。
- en: 'You also may be concerned that what you’ve created seems too simple. So far,
    React seems like it might be a verbose JavaScript templating system. But there’s
    much more that React can do: enter components.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还担心您所创建的内容似乎过于简单。到目前为止，React 似乎像是一个冗长的 JavaScript 模板系统。但 React 可以做更多的事情：进入组件。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**React elements**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**React 元素**'
- en: 'Before moving on to components, check your understanding of React elements.
    Either on paper or in your mind, list out a few of the characteristics of a React
    element. Here are a few characteristics of React elements to refresh your memory
    before moving on:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续学习组件之前，检查您对 React 元素的了解。无论是在纸上还是在您的脑海中，列出一些 React 元素的特征。在继续学习之前，这里有一些 React
    元素的特征来帮助您回忆：
- en: React elements take a string to create a type of DOM element (`div`, `a`, `p`,
    and so on).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 元素接受一个字符串来创建一种 DOM 元素（例如 `div`、`a`、`p` 等）。
- en: You can provide configuration to the React element via a props object; these
    are analogous to attributes DOM elements can have `(<img src="aUrl"/>`, for example).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过 props 对象向 React 元素提供配置；这些类似于 DOM 元素可以有的属性（例如 `<img src="aUrl"/>`）。
- en: React elements are nestable and you can provide other React elements as the
    children of an element.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 元素是可嵌套的，并且您可以为元素提供其他 React 元素作为子元素。
- en: React uses React elements to create a virtual DOM that `React DOM` can use as
    it updates the browser DOM.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 使用 React 元素来创建虚拟 DOM，而 `React DOM` 可以在更新浏览器 DOM 时使用它。
- en: React elements are what components are made from in React.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 元素是 React 中组件的构成部分。
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.2.3\. Creating React components
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 创建 React 组件
- en: As you can probably already tell, using only React elements and `React.createElement`
    to create parts of your UI doesn’t do much for you beyond managing the DOM. You
    could still pass in event handlers as props to handle clicks or input changes,
    pass in other data to display, and even nest elements. But you’d still be missing
    the *persistent state* provided by React, lifecycle methods that would give you
    predictable ways to work with a component, and, for that matter, any sort of logical
    grouping together that a component could give you. You definitely want to find
    a way to group React elements together.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，仅使用 React 元素和 `React.createElement` 来创建 UI 的部分对您来说并没有什么帮助，除了管理 DOM。您仍然可以将事件处理程序作为
    props 传递以处理点击或输入更改，传递其他数据以显示，甚至嵌套元素。但您仍然会错过 React 提供的 *持久状态*、生命周期方法，这些方法将为您提供与组件交互的预测性方式，以及组件可能提供的任何类型的逻辑分组。您肯定想找到一种方法来将
    React 元素组合在一起。
- en: You can do that through components. Components serve to bundle up and group
    functionality, markup, styles, and other related bits of your UI together. They
    act as a sort of boundary around parts of your UI that can also contain other
    components. Components can then be independent, reusable pieces that allow you
    think about each piece in isolation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过组件来实现这一点。组件的作用是将功能、标记、样式和其他相关的 UI 元素捆绑和分组在一起。它们充当 UI 部分的一种边界，这些部分还可以包含其他组件。组件可以是独立且可重用的部分，允许您单独考虑每个部分。
- en: 'You can create two primary types of components using functions and JavaScript
    classes. I’ll cover the first type, *stateless functional components*, in future
    chapters. For now we’ll talk about the second type: *stateful* React components
    created with JavaScript classes. From here on, when I refer to a React component,
    I’m referring to a component that’s a created from either a class or a function.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用函数和 JavaScript 类创建两种主要类型的组件。我将在未来的章节中介绍第一种类型，即无状态函数式组件。现在我们将讨论第二种类型：使用
    JavaScript 类创建的 *有状态* React 组件。从现在开始，当我提到 React 组件时，我指的是由类或函数创建的组件。
- en: 2.2.4\. Creating React classes
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 创建 React 类
- en: 'To start really building something, you need more than just React elements;
    you need components. As mentioned, React components (components created from functions)
    are like React elements but with more features. Components in React are classes
    that help group together React elements and functionality. They can be created
    as classes that extend the `React.Component` base class or functions. This section
    explores React classes and how to use this type of component in React. Let’s look
    at how you create a React class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正开始构建某些内容，您需要的不仅仅是 React 元素；您还需要组件。如前所述，React 组件（由函数创建的组件）类似于 React 元素，但具有更多功能。React
    中的组件是帮助将 React 元素和功能组合在一起的类。它们可以作为扩展 `React.Component` 基类或函数的类来创建。本节将探讨 React
    类以及如何在 React 中使用此类组件。让我们看看如何创建一个 React 类：
- en: '[PRE5]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rather than invoke a specific method from the React library as you did with
    `React.createElement`, creating a component from `React.Component` is done by
    declaring a JavaScript class that inherits from the `React.Component` abstract
    base class. That inheriting class will typically need to define at least a render
    method that will return a single React element or an array of React elements.
    The old way to create React classes was with the `createClass` method. This has
    since changed with the advent of classes in JavaScript and is now discouraged,
    although you can still use the `create-react-class` module, available on npm.
    For more on using React without ES2015+ JavaScript, check out [https://reactjs.org/docs/react-without-es6.html](https://reactjs.org/docs/react-without-es6.html).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与您使用 `React.createElement` 时调用 React 库中的特定方法不同，从 `React.Component` 创建组件是通过声明一个继承自
    `React.Component` 抽象基类的 JavaScript 类来完成的。这个继承类通常需要定义至少一个将返回单个 React 元素或 React
    元素数组的渲染方法。创建 React 类的旧方法是通过 `createClass` 方法。随着 JavaScript 中类的出现，这种方法已经改变，现在不推荐使用，尽管您仍然可以使用在
    npm 上可用的 `create-react-class` 模块。有关使用 ES2015+ JavaScript 之外的 React 的更多信息，请参阅 [https://reactjs.org/docs/react-without-es6.html](https://reactjs.org/docs/react-without-es6.html)。
- en: 2.2.5\. The render method
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.5\. 渲染方法
- en: We’ll start our exploration of creating components as React classes with the
    `render` method mentioned earlier. This is one of the most common methods you’ll
    see in React applications, and almost any component that renders something to
    a screen will have a `render` method. We’ll eventually explore components that
    don’t directly render anything but instead modify or enhance other components
    (known sometimes as *higher-order* components).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始通过前面提到的 `render` 方法探索创建作为 React 类的组件。这是您在 React 应用程序中看到的最常见方法之一，几乎任何将内容渲染到屏幕上的组件都将有一个
    `render` 方法。我们最终将探索那些不直接渲染任何内容，而是修改或增强其他组件（有时称为 *高阶* 组件）的组件。
- en: The render method needs to return exactly one React element. In this way, the
    render method is similar to how React elements are created—they can be nested
    but at the topmost level there’s a single node. However, unlike React elements,
    the `render` methods of React classes have access to embedded data (persisted
    internal component state) as well as component methods and additional methods
    inherited from the `React.Component` abstract base class (all of which I’ll cover).
    The persistent state I mentioned is available to the entire component because
    React creates a “backing instance” for this type of component. That’s also why
    you’ll hear these sorts of components referred to as *stateful* components.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染方法需要返回恰好一个 React 元素。以这种方式，渲染方法与创建 React 元素的方式相似——它们可以嵌套，但在最高级别只有一个节点。然而，与
    React 元素不同，React 类的 `render` 方法可以访问嵌入的数据（持久内部组件状态）以及组件方法和从 `React.Component` 抽象基类继承的额外方法（所有这些我将在后面介绍）。我提到的持久状态对整个组件都是可用的，因为
    React 为此类组件创建了一个“后备实例”。这也是为什么您会听到这些类型的组件被称为 *有状态* 组件的原因。
- en: All this means that React will create and keep track of a special data object
    for an instance of a React class (not the blueprint itself) that stays around
    over time and can be updated through special React functions. I’ll cover this
    more in future chapters, but [figure 2.10](kindle_split_012_split_002.xhtml#ch02fig10)
    illustrates how React classes get backing instances and React elements don’t.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着 React 将为 React 类的一个实例（不是蓝图本身）创建并跟踪一个特殊的数据对象，这个对象会随时间保持存在，并且可以通过特殊的
    React 函数进行更新。我将在未来的章节中详细介绍这一点，但 [图 2.10](kindle_split_012_split_002.xhtml#ch02fig10)
    展示了 React 类如何获得后备实例，而 React 元素则不会。
- en: Figure 2.10\. React will create a backing instance in memory for components
    created as React component classes. As you can see, React component classes get
    one, and React elements and non-React class components don’t. Remember that React
    elements are mirrors of the DOM and components are ways to group them together.
    The backing instance is a way of providing data storage and access for a specific
    component. The data stored in the instance will be made available to the component’s
    render method through specific API methods. This means that you get access to
    data that you can change and that will persist over time.
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.10\. React 将在内存中为作为 React 组件类创建的组件创建一个后备实例。正如您所看到的，React 组件类会得到一个，而 React
    元素和非 React 类组件则不会。请记住，React 元素是 DOM 的镜像，而组件是分组它们的方式。后备实例是为特定组件提供数据存储和访问的一种方式。存储在实例中的数据将通过特定的
    API 方法提供给组件的渲染方法。这意味着您可以访问可以更改并且会随时间持久化的数据。
- en: '![](Images/02fig10.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig10.jpg)'
- en: When using a React class to create a component, you also have access to props—data
    that you can pass to your component and that it can in turn pass to child components.
    You may remember this props data as a parameter you passed to `React.createElement`.
    As before, you can use it to specify properties of components at the time of creation.
    Props shouldn’t be modified within a component, but you’ll soon discover ways
    for updating data in React components.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 React 类创建组件时，你还可以访问 props——你可以传递给组件的数据，组件也可以将其传递给子组件。你可能记得这些 props 数据是传递给
    `React.createElement` 的参数。和之前一样，你可以用它来指定组件在创建时的属性。props 不应在组件内部修改，但你很快就会发现更新 React
    组件中数据的方法。
- en: 'In [listing 2.5](kindle_split_012_split_002.xhtml#ch02ex05) in the next section
    you’ll see a React class component in action and how you’ve created more nested
    React elements and passed in your custom data using `this.props`. When you see
    props being used with React classes, it’s as if you were creating a custom HTML
    element like `Jedi` and giving it a custom attribute like “name”: `<Jedi name="Obi
    Wan"/>`. I’ll cover the `this` JavaScript keyword more in future chapters, but
    note that in this case the reserved JavaScript keyword `this` points to the component
    instance.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节的 [列表 2.5](kindle_split_012_split_002.xhtml#ch02ex05) 中，你将看到 React 类组件的实际应用，以及你如何使用
    `this.props` 创建更多嵌套的 React 元素并传递自定义数据。当你看到 React 类中使用 props 时，就好像你创建了一个自定义 HTML
    元素，比如 `Jedi`，并给它一个自定义属性，比如“name”：`<Jedi name="Obi Wan"/>`。我将在未来的章节中更详细地介绍 `this`
    JavaScript 关键字，但请注意，在这种情况下，保留的 JavaScript 关键字 `this` 指的是组件实例。
- en: 2.2.6\. Property validation via PropTypes
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.6. 通过 PropTypes 进行属性验证
- en: 'You know that React class components are free to use custom properties, and
    this sounds great; it’s as if you can create your own custom HTML elements but
    with even more functionality. Remember that with great power comes great responsibility.
    You need to provide some sort of way to validate which properties you’ll be using
    so you can prevent bugs and plan the sorts of data your components will use. To
    do that, you can use validators available from a namespace within React: `PropTypes`.
    The `PropTypes` set of validators used to be included with the React core library,
    but was later broken out and deprecated within React in version 15.5\. To use
    `PropTypes`, you’ll need to install the `prop-types` package, which is still part
    of the React toolchain but is no longer included in the core library. This package
    will be included in the application source code and the CodeSandbox examples that
    you’ve been using in this chapter.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 React 类组件可以自由使用自定义属性，这听起来很棒；就好像你可以创建自己的自定义 HTML 元素，但功能更强大。记住，权力越大，责任越大。你需要提供某种方式来验证你将使用的属性，以便防止错误并规划组件将使用的数据类型。为此，你可以使用
    React 命名空间内提供的验证器：`PropTypes`。`PropTypes` 验证器集最初包含在 React 核心库中，但后来在 React 15.5
    版本中被拆分并弃用。要使用 `PropTypes`，你需要安装 `prop-types` 包，这个包仍然是 React 工具链的一部分，但不再包含在核心库中。这个包将包含在应用源代码和你在本章中使用的
    CodeSandbox 示例中。
- en: The `prop-types` library provides a set of validators that will let you specify
    what props your component needs or expects. For example, if you were going to
    build a ProfilePicture component, it wouldn’t be of much use without a picture
    (or the logic to handle not having one available). You could use `PropTypes` to
    specify which props your ProfilePicture component would need to work and what
    those props would look like.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`prop-types` 库提供了一套验证器，让你可以指定组件需要或期望的 props。例如，如果你要构建一个 ProfilePicture 组件，没有图片（或处理没有图片的逻辑）将毫无用处。你可以使用
    `PropTypes` 来指定 ProfilePicture 组件需要哪些 props 来工作，以及这些 props 应该是什么样子。'
- en: You can think of `PropTypes` as providing a sort of contract that can be fulfilled
    or broken by other developers and your future self. Using `PropTypes` isn’t strictly
    necessary for React to work, but should be used for bug prevention and ease of
    debugging. Another benefit of using `PropTypes` is that if you specify what props
    you expect first, you get a chance to think through what your component will need
    to work.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `PropTypes` 理解为提供一种合同，其他开发者和你未来的自己可以履行或违反这个合同。使用 `PropTypes` 并非 React 运作所必需的，但应该用于防止错误和简化调试。使用
    `PropTypes` 的另一个好处是，如果你首先指定了你期望的 props，你就有机会思考你的组件需要什么才能工作。
- en: 'When using `PropTypes`, you need to add a `propTypes` property to the `React.Component`
    class via a static class property or by simple property assignment after the class
    definition. Note the lowercasing of the property on the class but not the one
    from the `React` object, as it can be easy to mix them up. [Listing 2.4](kindle_split_012_split_002.xhtml#ch02ex04)
    shows how you can use `PropTypes`, as well as return React elements from React
    class components. In this listing, you’ll bring together a few things: creating
    a `React` class that you can pass to `createElement`, adding a `render` method,
    and specifying `propTypes`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `PropTypes` 时，您需要通过静态类属性或类定义后的简单属性赋值在 `React.Component` 类中添加一个 `propTypes`
    属性。注意类属性的小写，而不是来自 `React` 对象的属性，因为这很容易混淆。 [列表 2.4](kindle_split_012_split_002.xhtml#ch02ex04)
    展示了如何使用 `PropTypes`，以及从 React 类组件返回 React 元素。在这个列表中，您将结合几个方面：创建一个可以传递给 `createElement`
    的 `React` 类，添加一个 `render` 方法，并指定 `propTypes`。
- en: Listing 2.4\. Using `PropTypes` and the `render` method
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 使用 `PropTypes` 和 `render` 方法
- en: '[PRE6]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Import React, React DOM, and prop-types.**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 React、React DOM 和 prop-types。**'
- en: '***2* Create a React class as your Post component. In this case, you’re only
    specifying propTypes and a render method.**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个 React 类作为您的 Post 组件。在这种情况下，您只指定了 propTypes 和一个 render 方法。**'
- en: '***3* Create a div element that has a class ‘post’.**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个具有类名 ''post'' 的 div 元素。**'
- en: '***4* What this refers to can sometimes be confusing in JavaScript—here it
    will refer to the component instance, not your React class blueprint.**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在 JavaScript 中，这有时可能会令人困惑——在这里，它将指代组件实例，而不是您的 React 类蓝图。**'
- en: '***5* Using className instead of class for the Dom element’s CSS class name**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 className 而不是 class 作为 DOM 元素的 CSS 类名**'
- en: '***6* Again, the content prop is the inner content of a span element you’re
    creating.**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 再次，内容属性是您创建的 span 元素的内部内容。**'
- en: '***7* Properties can be optional or required, have a type, and can even be
    required to have a certain “shape” (an object with certain properties, for example).**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 属性可以是可选的或必需的，具有类型，甚至可能需要具有某种“形状”（例如具有某些属性的对象）。**'
- en: '***8* Pass the Post React Class to React.createElement along with some props
    to create something. React DOM can render—try changing the data to see how the
    render for your component output changes.**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将 Post React 类及其一些属性传递给 React.createElement 以创建某些内容。React DOM 可以渲染——尝试更改数据以查看您的组件输出如何变化。**'
- en: Code for [listing 2.4](kindle_split_012_split_002.xhtml#ch02ex04) is available
    online at [https://codesandbox.io/s/3yj462omrq](https://codesandbox.io/s/3yj462omrq).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.4](kindle_split_012_split_002.xhtml#ch02ex04) 的代码可在网上找到，网址为 [https://codesandbox.io/s/3yj462omrq](https://codesandbox.io/s/3yj462omrq)。'
- en: 'You should see some text appear: “mark said: This is a post!” If you hadn’t
    provided any of the required props, you’d see a warning in the developer console.
    Failure to provide certain props might break your app because of what components
    need to work, but the validation step won’t. In other words, if you forget to
    provide a crucial piece of data to your application, it might break, but using
    `PropTypes` validation won’t—it’ll just let you know that you forgot the prop.
    Because `PropTypes` only does type evaluation in development mode, your app running
    in production won’t expend the extra effort to do the work of `PropTypes`.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '您应该看到一些文本出现：“mark said: This is a post！”如果您没有提供任何必需的属性，您将在开发者控制台中看到警告。由于某些组件需要工作，未提供某些属性可能会破坏您的应用程序，但验证步骤不会。换句话说，如果您忘记向应用程序提供关键数据，它可能会损坏，但使用
    `PropTypes` 验证不会——它只会让您知道您忘记了属性。因为 `PropTypes` 只在开发模式下进行类型评估，所以您的生产环境应用程序不会额外消耗努力来执行
    `PropTypes` 的工作。'
- en: 'Now that you’re creating a component and passing in some data, you can try
    nesting components. I’ve mentioned this possibility before, and it’s part of what
    makes React a pleasure to work with and so powerful: you can create components
    from other components. [Listing 2.5](kindle_split_012_split_002.xhtml#ch02ex05)
    illustrates this and shows a special use of the `children` property. I’ll cover
    this more in future chapters when you work with routing and higher-order components.
    When you use the `this.props.children` prop, it’s like an outlet for nested data
    to come through. In this case, you’ll create a `Comment` component, pass it as
    the argument, and achieve nesting it.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在创建一个组件并传递一些数据，你可以尝试嵌套组件。我之前提到过这种可能性，这也是 React 让人愉快工作并如此强大的原因之一：你可以从其他组件中创建组件。[列表
    2.5](kindle_split_012_split_002.xhtml#ch02ex05) 说明了这一点，并展示了 `children` 属性的特殊用法。我将在未来的章节中更详细地介绍这一点，当你处理路由和高级组件时。当你使用
    `this.props.children` 属性时，它就像一个通道，让嵌套数据通过。在这种情况下，你将创建一个 `Comment` 组件，将其作为参数传递，并实现嵌套。
- en: Listing 2.5\. Adding a nested component
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 添加嵌套组件
- en: '[PRE7]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Add this.props.children to the Post component so it can render children.**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 this.props.children 添加到 Post 组件中，以便它可以渲染子组件。**'
- en: '***2* Create a Comment component, similarly to how you created a Post component.**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个 Comment 组件，类似于创建 Post 组件的方式。**'
- en: '***3* Declare propTypes.**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明 propTypes。**'
- en: '***4* Nest the Comment component within the Post component.**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在 Post 组件内部嵌套 Comment 组件。**'
- en: Code for [listing 2.5](kindle_split_012_split_002.xhtml#ch02ex05) is available
    online at [https://codesandbox.io/s/k2vn448pn3](https://codesandbox.io/s/k2vn448pn3).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.5](kindle_split_012_split_002.xhtml#ch02ex05) 的代码可在网上找到，链接为 [https://codesandbox.io/s/k2vn448pn3](https://codesandbox.io/s/k2vn448pn3)。'
- en: Now that you’ve created a nested component, you should be able to see more in
    your browser. Next, we’ll see how you can use the embedded state mentioned earlier
    that comes with React classes to create dynamic components.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个嵌套组件，你应该能在浏览器中看到更多内容。接下来，我们将看到如何使用之前提到的与 React 类一起提供的嵌入状态来创建动态组件。
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Reverse engineering a component tree**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆向工程组件树**'
- en: 'Before moving on, check your understanding by reverse-engineering a component
    tree from a site like GitHub. Open your developer tools, pick a DOM element that’s
    not too deeply nested, and reconstruct a React class from it. Consider the following
    DOM element:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过像 GitHub 这样的网站逆向工程一个组件树来检验你的理解。打开你的开发者工具，选择一个不太深层的 DOM 元素，并从中重构一个 React
    类。考虑以下 DOM 元素：
- en: '![](Images/042fig01_alt.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/042fig01_alt.jpg)'
- en: How would you structure a similar component structure but in React? (Feel free
    to not add every CSS class name.)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何在 React 中构建类似的组件结构？（请随意不添加每个 CSS 类名。）
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3\. The life and times of a component
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 组件的生与死
- en: In this section, you’re going to add to your Post and Comment components to
    make them interactive. Earlier, we discovered that components created as React
    classes get some special ways to store and access data through “backing instances.”
    To understand how, let’s revisit the big picture of how React works. [Figure 2.11](kindle_split_012_split_003.xhtml#ch02fig11)
    sums up what you’ve learned so far. You can create components from React classes
    that are made from React elements (elements that map to the DOM). What I’m calling
    *React classes* are sub-classes of `React.Component` that `React.createElement`
    can use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将向你的 Post 和 Comment 组件添加交互功能。之前，我们发现作为 React 类创建的组件可以通过“后端实例”获得一些特殊的方式来存储和访问数据。为了理解这一点，让我们回顾一下
    React 的工作原理的大致情况。[图 2.11](kindle_split_012_split_003.xhtml#ch02fig11) 总结了你迄今为止所学的知识。你可以从
    React 类创建组件，这些类是由 React 元素（映射到 DOM 的元素）组成的。我所说的 *React 类* 是 `React.Component`
    的子类，`React.createElement` 可以使用它。
- en: Figure 2.11\. Zooming in on rendering in React. React classes and React elements
    are used by React to create an in-memory virtual DOM that manages the real DOM.
    It also creates a “synthetic” event system so that you can still react to events
    from the browser (such as clicks, scrolls, and other user-caused events).
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11\. React 中渲染的放大视图。React 类和 React 元素被 React 用于创建一个内存中的虚拟 DOM，该 DOM 管理着真实的
    DOM。它还创建了一个“合成”的事件系统，这样你仍然可以响应来自浏览器的事件（如点击、滚动和其他由用户引起的事件）。
- en: '![](Images/02fig11_alt.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig11_alt.jpg)'
- en: Components created from React classes have backing instances that let you store
    data and need to have a `render` method that returns exactly one React element.
    React will take React elements and create an in-memory virtual DOM from them,
    and it will handle managing and updating the DOM.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由 React 类创建的组件有后端实例，允许你存储数据，并且需要有一个返回精确一个 React 元素的 `render` 方法。React 会从 React
    元素中创建一个内存中的虚拟 DOM，并处理 DOM 的管理和更新。
- en: You’ve added a `render` method and some `PropTypes` validation to your React
    classes. But you’re going to need more than that to create dynamic components.
    React classes can have some special methods that will be called in a certain order
    as React manages the virtual DOM. `render`, which you’ve used to return React
    elements, is just one of those methods.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为你的 React 类添加了 `render` 方法和一些 `PropTypes` 验证。但是，要创建动态组件，你需要更多。React 类可以有一些特殊的方法，这些方法会在
    React 管理虚拟 DOM 时按特定顺序被调用。你用来返回 React 元素的 `render` 方法只是其中之一。
- en: In addition to the reserved lifecycle methods, you can add your own methods.
    React gives you the freedom and flexibility to add whatever functionality you
    need to your components. Pretty much anything that’s valid JavaScript is useable
    in React. If you look back at [figure 1.1](kindle_split_011_split_001.xhtml#ch01fig01)
    in [chapter 1](kindle_split_011_split_000.xhtml#ch01), you’ll notice that lifecycle
    methods, special properties, and custom code make up most of a React component.
    What’s left?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保留的生命周期方法，你还可以添加自己的方法。React 给你自由和灵活性，让你可以为组件添加任何需要的功能。几乎任何有效的 JavaScript 都可以在
    React 中使用。如果你回顾一下[第 1 章](kindle_split_011_split_000.xhtml#ch01)中的[图 1.1](kindle_split_011_split_001.xhtml#ch01fig01)，你会注意到生命周期方法、特殊属性和自定义代码构成了
    React 组件的大部分。剩下的是什么？
- en: 2.3.1\. A React state of mind
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. React 状态思维
- en: Along with custom methods and lifecycle methods, React classes also gives you
    state (data) that can persist with the component. This comes from the backing
    instance I’ve mentioned. *State* is a big topic—I won’t cover it all in this chapter,
    but you can learn enough about it for now to be able to make your components interactive
    and lively. What’s state? Another way to think about it is as *information about
    something at a given time*. You could, for example, get the “state” of your friend
    by asking “How are you today?”
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自定义方法和生命周期方法，React 类还提供了可以与组件持久化的状态（数据）。这来自于我提到的后端实例。*状态*是一个很大的主题——我不会在这一章中涵盖所有内容，但你现在可以学到足够多的知识，以便能够使你的组件交互和生动。什么是状态？另一种思考方式是将其视为*关于某个特定时间的信息*。例如，你可以通过问“你今天怎么样？”来获取你朋友的“状态”。
- en: 'There are two general types of state: *mutable* and *immutable*. A simple way
    to think about the difference between them is to think in terms of time. Can something
    change after being created? If so, it can be called mutable. If not, it can be
    called immutable. There are in-depth academic areas of study on these topics,
    so I won’t go into depth on them here.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 状态主要有两种类型：*可变*和*不可变*。简单来说，可以通过时间来区分它们。创建后能否改变？如果可以，那么它就是可变的。如果不可以，那么它就是不可变的。关于这些主题有深入研究的学术领域，所以在这里我不会深入探讨。
- en: In React, components created as JavaScript classes ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes))
    that extend `React.Component` may have both mutable and immutable state, whereas
    components created from functions (stateless functional components) only have
    access to immutable state (props). I’ll cover these in future chapters; for now
    I’ll stick to components that inherit from `React.Component` and get state and
    additional methods. In these sorts of components, state is accessible from the
    `this.state` property of the instance of the class. The immutable state made available
    to you is accessed with `this.props`, which you’ve been using already to create
    static components.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，作为 JavaScript 类([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes))创建的组件，如果扩展了
    `React.Component`，则可能具有可变和不可变的状态，而由函数（无状态函数组件）创建的组件只能访问不可变状态（属性）。我将在未来的章节中介绍这些内容；现在，我将坚持使用继承自
    `React.Component` 并获取状态和额外方法的组件。在这些类型的组件中，状态可以通过类的实例的 `this.state` 属性访问。你可以通过
    `this.props` 访问提供的不可变状态，这你已经用来创建静态组件了。
- en: '`this.props` shouldn’t be modified from within the component. You’ll see ways
    to provide data that changes over time to components in future chapters. For now,
    all you need to know is that you can’t directly mutate `this.props`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.props` 不应在组件内部被修改。你将在未来的章节中看到如何向组件提供随时间变化的数据。现在，你需要知道的是，你不能直接修改 `this.props`。'
- en: You may be wondering how you might use `state` and `props` in React. The answer
    is pretty much how you would use data passed to or used in a function. That includes
    calculations, display, parsing, business logic, and any other data-related tasks.
    In fact, props and state are the primary ways that you can utilize dynamic or
    static data in your UI (showing user information, passing data to event handlers,
    and so forth).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何在 React 中使用 `state` 和 `props`。答案基本上是你会如何使用传递给函数或函数中使用的数据。这包括计算、显示、解析、业务逻辑以及任何其他与数据相关的任务。实际上，props
    和 state 是你在 UI 中利用动态或静态数据的主要方式（显示用户信息、传递数据到事件处理器等等）。
- en: State and props are vehicles for the data that make up your app and make it
    useful. If you’re creating a social network application (and you will in future
    chapters), you’ll often use a combination of props and state to build components
    that display and update user information, updates, and more. If you’re using React
    for data visualization, you might use props and state as inputs for visualization
    libraries like `D3.js`. Whatever you’re building, you’ll probably use state and
    props to manage and funnel information within your React application.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: State 和 props 是构成你的应用程序并使其有用的数据载体。如果你正在创建一个社交网络应用程序（你将在未来的章节中这样做），你通常会使用 props
    和 state 的组合来构建显示和更新用户信息、更新等组件。如果你使用 React 进行数据可视化，你可能将 props 和 state 作为可视化库（如
    `D3.js`）的输入。无论你正在构建什么，你很可能会使用 state 和 props 来管理和在你的 React 应用程序中引导信息。
- en: '|  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mutable vs. immutable**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变与不可变**'
- en: 'Before moving on, check your understanding by thinking about the differences
    between the two main types of data in React: mutable and immutable. Mark each
    statement as true or false:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过思考 React 中两种主要数据类型之间的区别来检查你的理解：可变和不可变。将每个陈述标记为真或假：
- en: 'Mutable means that data can change over time: T | F'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变意味着数据可以随时间改变：T | F
- en: 'State is accessed with the `this.state` property in React: T | F'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: State 通过 React 中的 `this.state` 属性访问：T | F
- en: '`props` is a mutable object provided by React: T | F'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`props` 是 React 提供的可变对象：T | F'
- en: 'Immutable data doesn’t change over time: T | F'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据不会随时间改变：T | F
- en: 'Props are accessed via `this.props`: T | F'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props 通过 `this.props` 访问：T | F
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.3.2\. Setting initial state
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 设置初始状态
- en: When should you use state and how do you get started using it? For now, the
    simple answer is *when you want to make changes to data stored within a component*.
    I said props were immutable (not modifiable), so if you need to change data, you
    need mutable state. In React, data that tends to need to be mutable often comes
    from or is the result of user input (often text, files, toggled options, and so
    on), but could be many other things. To keep track of user interactions with form
    elements, you need to provide an initial state and then change that state over
    time. You can use the constructor of the component to set the initial state for
    your component, a comment box component that builds on the ideas and concepts
    from earlier code listings. It will allow you to add comments to a post via a
    simple form. The following listing shows how to set up the component and set initial
    state.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何时使用状态以及如何开始使用它？现在，简单的答案是 *当你想要更改组件内部存储的数据时*。我说过 props 是不可变的（不可修改的），所以如果你需要更改数据，你需要可变的状态。在
    React 中，通常需要可变的数据往往来自用户输入（通常是文本、文件、切换选项等），但也可能是许多其他事物。为了跟踪用户与表单元素的交互，你需要提供一个初始状态，然后随着时间的推移改变该状态。你可以使用组件的构造函数来设置组件的初始状态，一个基于早期代码列表中思想和概念的评论框组件。它将允许你通过简单的表单添加评论。以下列表显示了如何设置组件和设置初始状态。
- en: Listing 2.6\. Setting initial state
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 设置初始状态
- en: '[PRE8]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Call super in the class constructor and assign the initial state object
    to the instance of the class’s state property—note that you won’t normally assign
    state like this except in the constructor of the component class.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在类构造函数中调用 super 并将初始状态对象分配给类的状态属性实例——请注意，你通常不会以这种方式分配状态，除非是在组件类的构造函数中。**'
- en: '***2* Create a component as a React class that will have some input fields
    for the user—I’ll cover forms in more detail in future chapters.**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个作为 React 类的组件，该组件将包含一些用户输入字段——我将在未来的章节中更详细地介绍表单。**'
- en: '***3* Add CreateComment to the App component.**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 CreateComment 添加到 App 组件中。**'
- en: The code for [listing 2.6](kindle_split_012_split_003.xhtml#ch02ex06) is available
    online at [https://codesandbox.io/s/p5r3kwqx5q](https://codesandbox.io/s/p5r3kwqx5q).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.6](kindle_split_012_split_003.xhtml#ch02ex06) 的代码可在网上找到，链接为 [https://codesandbox.io/s/p5r3kwqx5q](https://codesandbox.io/s/p5r3kwqx5q)。'
- en: 'To update the state that you initialized in the component class’s constructor,
    you need to use a special method; you can’t just overwrite `this.state` like you
    might in a non-React situation. That’s because React needs to keep track of state
    and ensure that the virtual DOM and real DOM are kept in sync. To update state
    within a React class component, you’ll use `this.setState`; look at the basic
    usage. It takes an updater function to use for updating state and doesn’t return
    anything:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新在组件类构造函数中初始化的状态，你需要使用一个特殊的方法；你不能像在非 React 情况下那样直接覆盖 `this.state`。这是因为 React
    需要跟踪状态并确保虚拟 DOM 和真实 DOM 保持同步。要在 React 类组件中更新状态，你将使用 `this.setState`；查看基本用法。它接受一个用于更新状态的更新函数，并且不返回任何内容：
- en: '[PRE9]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`this.setState` takes an updater function that returns object that will get
    shallowly merged into state. For example, if you had initially set a property
    of `username` to be an empty string, you’d use `this.setState` to set a new username
    value for your component’s state. React will take that value and update the backing
    instance and DOM with your new value.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`this.setState` 接收一个更新函数，该函数返回的对象将被浅合并到状态中。例如，如果你最初将 `username` 属性设置为空字符串，你会使用
    `this.setState` 来为你的组件状态设置新的用户名值。React 将获取该值并更新后端实例和 DOM 中的新值。'
- en: One key difference between updating or reassigning a value in JavaScript and
    using `setState` is that React can choose to batch updates based on state changes
    to maximize efficiency. This means that when you call `setState` to perform a
    state update, it won’t necessarily happen right away. Think of it more as an acknowledgement
    that React will update the DOM based on new state in the most efficient way possible,
    as soon as possible.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中更新或重新分配值与使用 `setState` 之间的一个关键区别是，React 可以根据状态变化来批量更新，以最大化效率。这意味着当你调用
    `setState` 来执行状态更新时，它不一定立即发生。更准确地说，这更像是一种确认，React 将尽可能高效地根据新状态更新 DOM，尽可能快地完成。
- en: What would cause React to update? JavaScript is event-driven, so it’ll probably
    be in response to some sort of user input (at least in the browser). That might
    be a click, key press, or many of the other events supported by browsers. How
    do events work with React? React implements a synthetic event system as a part
    of the virtual DOM that will translate events in the browser into events for your
    React application. You can set up event handlers that can respond to events from
    the browser, as you normally would in JavaScript. One difference is that React
    event handlers are set up on React elements or components themselves (as opposed
    to using `addEventListener`). You can update the state of your component using
    the data from these events (text from an input, a radio button value, or even
    the target of the event).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 什么会导致 React 更新？JavaScript 是事件驱动的，所以它可能是对某种用户输入的响应（至少在浏览器中是这样）。这可能是一个点击、按键或浏览器支持的其他许多事件之一。事件如何与
    React 一起工作？React 实现了一个合成事件系统，作为虚拟 DOM 的一部分，它将浏览器中的事件转换为 React 应用程序的事件。你可以设置事件处理程序来响应来自浏览器的事件，就像你通常在
    JavaScript 中做的那样。一个区别是，React 事件处理程序是在 React 元素或组件本身上设置的（而不是使用 `addEventListener`）。你可以使用这些事件的数据（输入框中的文本、单选按钮的值，甚至是事件的目标）来更新组件的状态。
- en: '[Listing 2.7](kindle_split_012_split_003.xhtml#ch02ex07) shows how to put into
    practice what you’ve learned about setting initial state and setting up event
    handlers. There are many different events you can listen for in the browser, encompassing
    virtually every possible user interaction (clicking, typing, forms, scrolling,
    and so on). Here we’re most concerned with two main ones: when the form input
    values change, and when the form is submitted. By listening for those events,
    you can receive and use data to create new comments.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码示例2.7](kindle_split_012_split_003.xhtml#ch02ex07)展示了如何将你关于设置初始状态和设置事件处理器的知识应用到实践中。浏览器中可以监听许多不同的事件，几乎涵盖了所有可能的用户交互（点击、输入、表单、滚动等）。我们最关心的是两个主要事件：当表单输入值发生变化时，以及当表单被提交时。通过监听这些事件，你可以接收并使用数据来创建新的评论。'
- en: Listing 2.7\. Setting up event handlers
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 设置事件处理器
- en: '[PRE10]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Because components created with classes don’t auto bind component methods,
    you need to bind them to this in the constructor.**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由于使用类创建的组件不会自动绑定组件方法，你需要在构造函数中将它们绑定到this上。**'
- en: '***2* Assign an event handler to handle changes to the author field—you get
    the value of the input element with event.target.value and use this.setState to
    update the component’s state.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为作者字段的变化分配一个事件处理器——你可以通过event.target.value获取输入元素的值，并使用this.setState来更新组件的状态。**'
- en: '***3* Create an event handler with similar functionality for the comment content.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为评论内容创建一个具有类似功能的事件处理器。**'
- en: '***4* Event handler for form submission event**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 表单提交事件的事件处理器**'
- en: '***5* Reset the input field after submission so the user can submit further
    comments.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 提交后重置输入字段，以便用户可以提交更多评论。**'
- en: The code for [listing 2.7](kindle_split_012_split_003.xhtml#ch02ex07) is available
    online at [https://codesandbox.io/s/x9mxo31pxp](https://codesandbox.io/s/x9mxo31pxp).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码示例2.7](kindle_split_012_split_003.xhtml#ch02ex07)的代码可在网上找到，网址为[https://codesandbox.io/s/x9mxo31pxp](https://codesandbox.io/s/x9mxo31pxp)。'
- en: Did you notice how you used `.bind` in the constructor of the component class?
    In previous versions of React, React would *auto bind* methods to the instance
    of your component for you. With the switch to JavaScript classes, though, you
    need to bind methods yourself. If you define a component method and it’s not working,
    confirm that you’ve correctly bound your methods—it can be easy to forget when
    first starting out with React.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到你在组件类的构造函数中使用了`.bind`了吗？在React的早期版本中，React会为你自动绑定方法到组件的实例上。但是，随着JavaScript类的引入，你需要自己绑定方法。如果你定义了一个组件方法但它不起作用，请确认你已经正确地绑定了你的方法——在刚开始使用React时很容易忘记。
- en: Next, try leaving out the `onChange` event handlers and see if you can type
    anything into the form inputs. You won’t be able to because React is ensuring
    that the DOM stays in sync with the virtual DOM, which isn’t being updated and
    thus won’t let the DOM change. If this doesn’t make perfect sense right now, don’t
    worry—[chapters 5](kindle_split_016_split_000.xhtml#ch05) and [6](kindle_split_017_split_000.xhtml#ch06)
    cover forms more extensively.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试省略`onChange`事件处理器，看看你是否能在表单输入中输入任何内容。你将无法做到这一点，因为React正在确保DOM与虚拟DOM保持同步，而虚拟DOM没有更新，因此不会允许DOM发生变化。如果你现在还不完全明白，不要担心——[第5章](kindle_split_016_split_000.xhtml#ch05)和[第6章](kindle_split_017_split_000.xhtml#ch06)更详细地介绍了表单。
- en: Now that you have a way of listening for events and modifying the component’s
    state, you can implement a way to create new comments using unidirectional data
    flow. In React, data flows top-down, as an input from parents to children. When
    you create composite components, you can pass information to child components
    via props and make use of it in child components. That means you could store the
    data from the `CreateComment` component in a parent component and from there pass
    the data to child components. But how can you get the data from a new comment
    (in the form that the user types text into) in a child component back into the
    parent and into the child? [Figure 2.12](kindle_split_012_split_003.xhtml#ch02fig12)
    shows an example of the sort of data flow you need.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了监听事件和修改组件状态的方法，你可以实现使用单向数据流创建新评论的方式。在React中，数据是自上而下流动的，作为从父组件到子组件的输入。当你创建复合组件时，你可以通过props将信息传递给子组件并在子组件中使用它。这意味着你可以在父组件中存储`CreateComment`组件的数据，并从那里将数据传递给子组件。但是，你如何在子组件中将新评论（用户输入文本的形式）的数据返回到父组件和子组件中？[图2.12](kindle_split_012_split_003.xhtml#ch02fig12)展示了你需要的数据流示例。
- en: Figure 2.12\. To add a post, you need to capture the data from input fields
    and somehow send it to the parent component, and then that updated data will be
    used to render out the posts.
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12。要添加帖子，你需要从输入字段捕获数据，并以某种方式将其发送到父组件，然后更新后的数据将用于渲染帖子。
- en: '![](Images/02fig12.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig12.jpg)'
- en: How can you make this happen? One kind of data we haven’t looked at passing
    via props is functions. Because functions can be passed as arguments to other
    functions in JavaScript, you can use this to your advantage. You can define a
    method on a parent component and give it to the child component as a property.
    That way, the child component can send data back up to its parent without having
    to know how the parent will handle the data. If you needed to change what happened
    with the data, you wouldn’t need to do anything to the `CreateComment` component.
    To execute a function passed as a prop, the child only needs to call the method
    and pass any data to it. The following listing shows how to use functions as props.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这一点？我们还没有探讨过通过属性传递函数这一种数据类型。因为函数可以作为参数传递给JavaScript中的其他函数，你可以利用这一点。你可以在父组件上定义一个方法，并将其作为属性传递给子组件。这样，子组件就可以将数据发送回父组件，而无需知道父组件如何处理这些数据。如果你需要更改数据的行为，你不需要对`CreateComment`组件做任何操作。要执行作为属性传递的函数，子组件只需要调用该方法并传递任何数据给它。下面的列表展示了如何使用函数作为属性。
- en: Listing 2.8\. Using functions as props
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8。使用函数作为属性
- en: '[PRE11]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Call the onCommentSubmit function that’s been passed as a prop by the
    parent—you’re passing in data from the form and resetting the form so the user
    knows their action was successful.**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用由父组件传递的属性`onCommentSubmit`函数——你正在将表单数据传递进去并重置表单，这样用户就知道他们的操作已经成功了。**'
- en: '***2* Don’t forget to bind the method you’ve set up to the onSubmit event—without
    it, there won’t be any connection between the right event and your method.**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 不要忘记将你设置的方法绑定到`onSubmit`事件上——没有它，正确的事件和你的方法之间将没有连接。**'
- en: The code for [listing 2.8](kindle_split_012_split_003.xhtml#ch02ex08) is available
    online at [https://codesandbox.io/s/p3mk26v3lx](https://codesandbox.io/s/p3mk26v3lx).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.8](kindle_split_012_split_003.xhtml#ch02ex08)的代码可在网上找到，网址为[https://codesandbox.io/s/p3mk26v3lx](https://codesandbox.io/s/p3mk26v3lx)。'
- en: Now that your component can pass new comment data to a parent, you’ll need to
    include some mock data so you can get started commenting. In future chapters,
    you’ll work with the Fetch API and a RESTful JSON API, but using some fake data
    you create will be fine for now. The following listing shows how you might go
    about mocking out some basic post data with associated comments.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你的组件可以将新的评论数据传递给父组件，你需要包含一些模拟数据，这样你就可以开始评论了。在未来的章节中，你将使用Fetch API和RESTful
    JSON API，但使用你创建的一些假数据现在就足够了。下面的列表展示了你如何模拟一些基本的帖子数据及其关联的评论。
- en: Listing 2.9\. Mocking out API data
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9。模拟API数据
- en: '[PRE12]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Set up the mock data for your CommentBox component.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为你的CommentBox组件设置模拟数据。**'
- en: '***2* You’ll use these comment objects as the existing comments.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你将使用这些评论对象作为现有的评论。**'
- en: '***3* You’ll use these comment objects as the existing comments.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你将使用这些评论对象作为现有的评论。**'
- en: Next, you need a way to show all the comments. In React, that’s easy to do.
    You already have a component that will display a comment. Because all you need
    to work with React components is regular JavaScript, you can use the `.map()`
    function to return a new array of React elements. You can’t use `.forEach()` in-line
    because it doesn’t return an array and would leave `React.createElement()` with
    nothing to use. You could, however, build an array using `forEach` and then pass
    that in.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一种方式来显示所有评论。在React中，这很容易做到。你已经有了一个可以显示评论的组件。因为与React组件一起工作只需要常规的JavaScript，你可以使用`.map()`函数来返回一个新的React元素数组。你不能使用`.forEach()`内联，因为它不会返回一个数组，并且会留下`React.createElement()`没有可用的内容。然而，你可以使用`forEach`构建一个数组，然后将其传递进去。
- en: 'Aside from iterating over the existing comments, you need to define a method
    you can pass to the CreateComment component. It needs to modify the list of comments
    in its state by receiving data from the child component. Both the submission method
    and the state need to go in a new parent component: CommentBox. The following
    listing shows how to create the component and set up these methods.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迭代现有的评论外，你还需要定义一个可以传递给CreateComment组件的方法。它需要通过从子组件接收数据来修改其状态中的评论列表。提交方法和状态都需要放入一个新的父组件：CommentBox。下面的列表展示了如何创建该组件并设置这些方法。
- en: Listing 2.10\. Handling comment submissions and iterating over elements
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.10\. 处理评论提交和遍历元素
- en: '[PRE13]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Pass in the comments data at the topmost level to CommentBox.**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将评论数据在最高级别传递给CommentBox。**'
- en: '***2* Never directly modify state—instead, make a copy.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 永远不要直接修改状态——相反，创建一个副本。**'
- en: '***3* As before, pass in the data variable at the topmost level to access the
    post data.**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如前所述，将数据变量在最高级别传递以访问帖子数据。**'
- en: '***4* Map over the comments in this.state.comments and return a React element
    for each one.**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 遍历this.state.comments中的评论，并为每个评论返回一个React元素。**'
- en: '***5* Give the parent’s handleComment-Submit method to the CreateComment component
    to use.**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将父组件的handleComment-Submit方法传递给CreateComment组件以使用。**'
- en: '***6* Pass in the mock data to the CommentBox component as a prop.**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将模拟数据作为属性传递给CommentBox组件。**'
- en: The code for [listing 2.10](kindle_split_012_split_003.xhtml#ch02ex10) is available
    online at [https://codesandbox.io/s/z6o64oljn4](https://codesandbox.io/s/z6o64oljn4).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.10](kindle_split_012_split_003.xhtml#ch02ex10)的代码可在网上找到，网址为[https://codesandbox.io/s/z6o64oljn4](https://codesandbox.io/s/z6o64oljn4)。'
- en: At this point you have an unsightly, untested, but functional component that
    will perform validation on props, update state, and enable you to add new comments.
    It doesn’t look like much, so I leave it as a challenge to you to make the comment
    box worthy of our fictional company, Letters.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你有一个外观不佳、未经测试但功能性的组件，它将对属性进行验证、更新状态，并允许你添加新的评论。它看起来不多，所以我把它留给你作为一个挑战，让你把评论框做得值得我们的虚构公司Letters。
- en: 2.4\. Meet JSX
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 了解JSX
- en: 'You’ve created your first dynamic React component. If you found it easy, great!
    If you found parts of the code hard to read through with all the nested `React.createElement`s,
    that’s fine, too. We’re about to discuss some easier ways to create components,
    but needed to focus on the fundamentals first. Learning almost anything else in
    the reverse way (“magic” and ease first, fundamentals and details later) is usually
    much easier, but it can inhibit you in the long run because you haven’t done the
    hard work of understanding how an underlying mechanism works. If you look back
    at your mock data, you may remember this quote, which is timely:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了你的第一个动态React组件。如果你觉得很容易，那太好了！如果你发现代码中嵌套的`React.createElement`难以阅读，那也无所谓。我们即将讨论一些创建组件的更简单方法，但首先需要关注基础。几乎任何其他事情以相反的方式学习（“魔法”和容易先，基础和细节后）通常要容易得多，但长期来看可能会阻碍你，因为你没有做理解底层机制如何工作的艰苦工作。如果你回顾你的模拟数据，你可能记得这句话，它很及时：
- en: '*What we hope ever to do with ease, we must first learn to do with diligence.*'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们希望轻松完成的事情，我们首先必须学会勤奋地去做。*'
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Samuel Johnson*'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*塞缪尔·约翰逊*'
- en: 2.4.1\. Creating components using JSX
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 使用JSX创建组件
- en: 'It’s important to master the fundamentals, but that doesn’t mean we have to
    make things difficult for ourselves. There are, it turns out, easier and better
    ways to create React components than only using `React.createElement`. Meet JSX:
    the better way.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 精通基础很重要，但这并不意味着我们必须让自己难堪。实际上，创建React组件比仅使用`React.createElement`有更简单、更好的方法。那就是JSX：更好的方法。
- en: What is JSX? It’s an XML-like syntax extension to ECMAScript without any defined
    semantics, intended specifically for use by preprocessors. In other words, JSX
    is an extension of JavaScript that’s similar to XML and is only intended for use
    by code-transformation tools. It’s not something you’ll see incorporated into
    the ECMAScript specification at any point.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是什么？它是对ECMAScript的一种类似于XML的语法扩展，没有定义任何语义，专门用于预处理器的使用。换句话说，JSX是JavaScript的一个扩展，类似于XML，并且仅用于代码转换工具。这不是你会在任何ECMAScript规范中看到被整合的东西。
- en: JSX helps by allowing you to write XML-style (think HTML) code in place of using
    `React.createClass`. In other words, it lets you write code that *looks* like
    HTML but isn’t. A JSX preprocessor program like Babel—a transpiler that turns
    your JavaScript code into code that’s compatible with older browsers—will go through
    and convert all your JSX code to regular JavaScript like we’ve written so far.
    One implication is that running untransformed JSX code natively in the browser
    won’t work—you’ll get all sorts of syntax errors when your JavaScript is parsed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: JSX通过允许你使用XML风格的（想想HTML）代码代替`React.createClass`来帮助你。换句话说，它让你写出的代码看起来像HTML，但实际上不是。像Babel这样的JSX预处理器程序——一个将你的JavaScript代码转换为与旧浏览器兼容的代码的转换器——会遍历并转换你所有的JSX代码，就像我们之前写的那样。一个影响是，在浏览器中直接运行未经转换的JSX代码将不起作用——当你的JavaScript被解析时，你会得到各种语法错误。
- en: Writing XML-style, HTML-like code in your JavaScript might set your warning
    instincts off, but there are plenty of good reasons to use JSX, and I’ll cover
    them. For now, look at [listing 2.11](kindle_split_012_split_004.xhtml#ch02ex11)
    to see what your comment box component might look like with JSX. I’ve omitted
    some code to make it easier to focus on the JSX syntax. Note that Babel is included
    as part of the environment on CodeSandbox. Normally, you’ll use a build tool like
    Webpack to transpile your JavaScript, but you can also import Babel and have it
    work without a build step. That’s much slower, though, and should never be done
    in production. You can learn more at [https://babeljs.io](https://babeljs.io).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中编写类似XML、类似HTML的代码可能会触发你的警告本能，但使用JSX有很多很好的理由，我将在后面介绍。现在，查看[列表2.11](kindle_split_012_split_004.xhtml#ch02ex11)以了解你的注释框组件可能的样子。我已经省略了一些代码，以便更容易地关注JSX语法。请注意，Babel是CodeSandbox环境的一部分。通常，你会使用像Webpack这样的构建工具来转换你的JavaScript，但你也可以导入Babel并在没有构建步骤的情况下使用它。但这会慢得多，而且不应该在生产环境中这样做。你可以在[https://babeljs.io](https://babeljs.io)了解更多信息。
- en: Listing 2.11\. Rewriting components using JSX
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 使用JSX重写组件
- en: '[PRE14]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Instead of creating props on an object, in JSX you create them like you
    would in HTML—to pass in expressions, you use the `{}` syntax.**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在JSX中，你创建属性的方式与在HTML中一样——要传入表达式，请使用 `{}` 语法。**'
- en: '***2* This is the Post React class you created before—note now it’s much clearer
    that it’s a custom component you created and looks like it would belong right
    at home in HTML.**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是你在之前创建的Post React类——注意现在它更清楚地表明它是一个你创建的自定义组件，看起来它非常适合在HTML中使用。**'
- en: '***3* Use regular JavaScript inside of {} to iterate over comments and create
    a comment component for each.**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在{}内部使用常规JavaScript遍历注释并为每个注释创建一个注释组件。**'
- en: '***4* Pass in the handleComment-Submit handler as a property.**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 handleComment-Submit 处理程序作为属性传入。**'
- en: '***5* At the top level, CommentBox is also a custom component you give props
    to and pass to React DOM to render.**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在顶级上，CommentBox也是一个你提供属性并传递给React DOM以进行渲染的自定义组件。**'
- en: The code for [listing 2.11](kindle_split_012_split_004.xhtml#ch02ex11) is available
    online at [https://codesandbox.io/s/vnwz6y28x5](https://codesandbox.io/s/vnwz6y28x5).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.11](kindle_split_012_split_004.xhtml#ch02ex11)的代码可在网上找到，网址为[https://codesandbox.io/s/vnwz6y28x5](https://codesandbox.io/s/vnwz6y28x5)。'
- en: 2.4.2\. Benefits of JSX and differences from HTML
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. JSX的优势和与HTML的区别
- en: 'Now that you’ve seen JSX in action, you may feel a little less skeptical about
    it. If you’re still wary, it’s important to consider the many benefits it brings
    to working with components in React. Here are two of those benefits:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了JSX的实际应用，你可能对它不那么怀疑了。如果你仍然谨慎，重要的是要考虑它为React中的组件工作带来的许多好处。以下是其中两个好处：
- en: '***Similarity to HTML and simpler syntax*—** If writing `React.createElement`
    repeatedly felt tedious or if you found the nesting hard to follow, you’re not
    alone. JSX’s similarity to HTML makes declaring your component’s structure in
    a familiar way much easier and dramatically improves readability.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***与HTML的相似性和更简单的语法*—** 如果反复编写 `React.createElement` 感到繁琐，或者发现嵌套难以理解，你并不孤单。JSX与HTML的相似性使得以熟悉的方式声明组件的结构变得容易得多，并且显著提高了可读性。'
- en: '***Declarative and encapsulated*—** By including the code that will make up
    your view alongside any related methods, you create a group of functionality.
    Essentially everything you need to know about the component is in one place. Nothing
    is unnecessarily hidden from you, which means you can reason about your components
    more easily and be more fully aware of how it works as a system.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***声明性和封装性*—** 通过将构成视图的代码以及任何相关的方法一起包含，你创建了一个功能组。本质上，关于组件你需要知道的一切都在一个地方。没有任何东西是不必要地隐藏起来的，这意味着你可以更容易地推理你的组件，并且可以更全面地了解它作为一个系统是如何工作的。'
- en: It may feel like a trip back to the late 90s to be writing your markup right
    alongside your JavaScript, but that doesn’t mean it’s a bad idea.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 感觉像是回到了90年代末编写你的标记与JavaScript一起，但这并不意味着这是一个坏主意。
- en: 'It’s important to note that JSX is not HTML (or XML)—it will only transpile
    into regular React code just like you’ve used so far, and it doesn’t share the
    exact same syntax and conventions. There are subtle differences that you’ll need
    to look out for. Future chapters will go into these differences more fully, but
    I’ll note a few of them briefly:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，JSX 不是 HTML（或 XML）——它只会编译成你迄今为止使用的常规 React 代码，并且它不共享完全相同的语法和约定。存在一些细微的差异，你需要留意。未来的章节将更全面地介绍这些差异，但我会简要地指出其中的一些：
- en: '***HTML tags versus React components*—** Custom React components you created
    using `React.createClass` are by convention capitalized so you can determine the
    difference between custom and native HTML components.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HTML 标签与 React 组件*—**使用 `React.createClass` 创建的自定义 React 组件按照约定首字母大写，这样你可以确定自定义和原生
    HTML 组件之间的区别。'
- en: '***Attribute expressions*—** When you want to use a JavaScript expression as
    an attribute value, wrap the expression in a pair of curly braces (`<Comment a={this.props.b}/>`)
    instead of quotes `(<User a="this.props.b"/>`) as shown in [listing 2.8](kindle_split_012_split_003.xhtml#ch02ex08).'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***属性表达式*—**当你想将 JavaScript 表达式用作属性值时，将表达式包裹在一对大括号中（`<Comment a={this.props.b}/>`），而不是使用引号（`<User
    a="this.props.b"/>`），如[列表 2.8](kindle_split_012_split_003.xhtml#ch02ex08)所示。'
- en: '***Boolean attributes*—** Omitting the value of an attribute (`<Plan active/>`,
    `<Input checked/>`) causes JSX to treat it as `true`. To pass a false value, you
    have to use an attribute expression (`attribute={false}`).'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***布尔属性*—**省略属性的值（`<Plan active/>`，`<Input checked/>`）会使 JSX 将其视为 `true`。要传递一个假值，你必须使用属性表达式（`attribute={false}`）。'
- en: '***Nested expressions*—** To insert the value of an expression *inside* an
    element, you also use a pair of curly braces (`<p>{this.props.content}</p>`).'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***嵌套表达式*—**要在元素内部插入表达式的值，你也使用一对大括号（`<p>{this.props.content}</p>`）。'
- en: There are subtle differences in JSX and even the occasional “gotcha,” but later
    chapters will cover all that and more. You’ll be using JSX extensively in your
    components, and now that you’ve started using JSX, you’ll be able to create, read
    through, and think about your components that much more easily.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 和偶尔的“陷阱”存在细微的差异，但后面的章节将涵盖所有这些内容，并且更多。你将在你的组件中广泛使用 JSX，现在你已经开始使用 JSX，你将能够更容易地创建、阅读和思考你的组件。
- en: 2.5\. Summary
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 摘要
- en: 'We spent a lot of time talking about components in this chapter, so let’s review
    some of the key points:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花了很多时间讨论组件，所以让我们回顾一些关键点：
- en: 'There are two main types of elements that we work with to create components
    in React: React elements and React classes. React elements are “what you want
    to see on the screen” and are comparable to DOM elements. React classes, on the
    other hand, are JavaScript classes that inherit from the `React.Component` class.
    These are what we normally call *components* in general. They’re created from
    either classes (usually extending `React.Component`) or functions (stateless functional
    components, covered in later chapters).'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 React 中创建组件时主要使用两种类型的元素：React 元素和 React 类。React 元素是“你希望在屏幕上看到的内容”，可以与 DOM
    元素相媲美。另一方面，React 类是从 `React.Component` 类继承的 JavaScript 类。这些就是我们通常所说的 *组件*。它们可以是类（通常扩展
    `React.Component`）或函数（无状态函数组件，将在后面的章节中介绍）。
- en: React classes get access to state that can change over time (mutable state),
    but all React elements get access to props that shouldn’t be modified (immutable
    state).
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 类可以访问随时间变化的状态（可变状态），但所有 React 元素都可以访问不应修改的 props（不可变状态）。
- en: React classes also have special methods called *lifecycle methods* that will
    be called by React in a particular order during the rendering and update process.
    This makes your components more predictable to work with and allows you to easily
    hook into the component update process.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 类还有称为 *生命周期方法* 的特殊方法，React 在渲染和更新过程中会按特定顺序调用这些方法。这使得你的组件更容易预测和操作，并允许你轻松地挂钩到组件更新过程。
- en: React classes can have custom methods defined on them to perform tasks such
    as mutating state.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 类可以定义自定义方法来执行诸如修改状态等任务。
- en: React components communicate via props and have child-parent relationships.
    Parent components can pass data to children, but children can’t modify parents.
    They can pass data back to parents via callbacks, but don’t have direct access
    to parents.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 组件通过 props 进行通信，并具有父子关系。父组件可以向子组件传递数据，但子组件不能修改父组件。它们可以通过回调将数据传递回父组件，但不能直接访问父组件。
- en: JSX is an XML-like extension of JavaScript that lets you write components in
    a much easier and more familiar way. It may feel strange at first to write what
    looks like HTML in your JavaScript, but JSX can make writing markup in React more
    familiar and is generally easier to read than `React.createElement` calls.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是 JavaScript 的一个类似 XML 的扩展，它允许你以更简单、更熟悉的方式编写组件。一开始在 JavaScript 中编写看起来像 HTML
    的内容可能会感觉有些奇怪，但 JSX 可以使你在 React 中编写标记更加熟悉，并且通常比 `React.createElement` 调用更容易阅读。
- en: You created your first component, but you’ve only brushed the surface of what’s
    possible with React. In the next chapter, you’ll start to explore how to work
    with more complicated data, learn about different types of components, and delve
    further into state as we expand your React horizons.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了你的第一个组件，但你只是触及了 React 所能实现的一小部分。在下一章中，你将开始探索如何处理更复杂的数据，了解不同类型的组件，并随着我们扩展你的
    React 视野，进一步深入研究状态。
