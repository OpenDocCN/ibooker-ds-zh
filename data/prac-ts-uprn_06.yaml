- en: Chapter 6\. Statistical Models for Time Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。时间序列统计模型
- en: In this chapter, we study some linear statistical models for time series. These
    models are related to linear regression but account for the correlations that
    arise between data points in the same time series, in contrast to the standard
    methods applied to cross-sectional data, in which it is assumed that each data
    point is independent of the others in the sample.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了一些时间序列的线性统计模型。这些模型与线性回归有关，但考虑到同一时间序列中数据点之间的相关性，与应用于横断面数据的标准方法形成对比，在后者中假设样本中的每个数据点独立于其他数据点。
- en: 'The specific models we will discuss are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的具体模型包括：
- en: Autoregressive (AR) models, moving average (MA) models, and autoregressive integrated
    moving average (ARIMA) models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自回归（AR）模型，移动平均（MA）模型和自回归积分移动平均（ARIMA）模型
- en: Vector autoregression (VAR)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量自回归（VAR）
- en: Hierarchical models.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次模型。
- en: These models have traditionally been the workhorses of time series forecasting,
    and they continue to be applied in a wide range of situations, from academic research
    to industry modeling.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型传统上是时间序列预测的主力军，并继续在从学术研究到工业建模的广泛情境中应用。
- en: Why Not Use a Linear Regression?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不使用线性回归？
- en: 'As a data analyst, you are probably already familiar with linear regressions.
    If you are not, they can be defined as follows: a linear regression assumes you
    have *independently and identically distributed* (iid) data. As we have discussed
    at length in earlier chapters, this is not the case with time series data. In
    time series data, points near in time tend to be strongly correlated with one
    another. In fact, when there aren’t temporal correlations, time series data is
    hardly useful for traditional time series tasks, such as predicting the future
    or understanding temporal dynamics.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据分析师，您可能已经对线性回归非常熟悉。如果不熟悉，可以定义如下：线性回归假设您拥有*独立同分布*（iid）的数据。正如我们在前几章节中详细讨论的那样，这在时间序列数据中并非如此。在时间序列数据中，接近时间的点往往彼此强相关。事实上，如果没有时间相关性，时间序列数据几乎无法用于传统的时间序列任务，如预测未来或理解时间动态。
- en: 'Sometimes time series tutorials and textbooks or give an undue impression that
    linear regression is not useful for time series. They make students think that
    simple linear regressions simply will not cut it. Luckily this is not the case
    at all. Ordinary least squares linear regression can be applied to time series
    data provided the following conditions hold:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，时间序列教程和教科书会给人一种错误的印象，即线性回归对于时间序列没有用处。他们让学生认为简单的线性回归根本行不通。幸运的是，这完全不是事实。普通最小二乘线性回归可以应用于时间序列数据，只要以下条件成立：
- en: '*Assumptions with respect to the behavior of the time series*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于时间序列行为的假设*'
- en: The time series has a linear response to its predictors.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列对其预测变量具有线性响应。
- en: No input variable is constant over time or perfectly correlated with another
    input variable. This simply extends the traditional linear regression requirement
    of independent variables to account for the temporal dimension of the data.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有输入变量在时间上是恒定的或与另一个输入变量完全相关的。这简单地扩展了传统线性回归对独立变量的要求，以考虑数据的时间维度。
- en: '*Assumptions with respect to the error*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于误差的假设*'
- en: For each point in time, the expected value of the error, given all explanatory
    variables for all time periods (forward and backward), is 0\.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个时间点，考虑到所有时间段（向前和向后）的所有解释变量，误差的期望值为0。
- en: The error at any given time period is uncorrelated with the inputs at any time
    period in the past or future. So a plot of the autocorrelation function of the
    errors will not indicate any pattern.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意给定时间点上的误差与过去或未来的输入是不相关的。因此，误差的自相关函数图表不会显示任何模式。
- en: Variance of the error is independent of time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 误差的方差与时间无关。
- en: If these assumptions hold, then ordinary least squares regression is an unbiased
    estimator of the coefficients given the inputs, even for time series data.^([1](ch06.html#idm45576038971656))
    In this case, the sample variances of the estimates have the same mathematical
    form as they do for standard linear regression. So if your data meets the assumptions
    just listed, you can apply a linear regression, which will no doubt help to offer
    clear and simple intuitions for your time series behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些假设成立，那么普通最小二乘回归是系数的无偏估计，即使对于时间序列数据也是如此。^([1](ch06.html#idm45576038971656))
    在这种情况下，估计量的样本方差具有与标准线性回归相同的数学形式。因此，如果你的数据符合刚刚列出的假设，你可以应用线性回归，这无疑会帮助你提供时间序列行为的清晰和简单的直觉。
- en: The data requirements just described are similar to those for standard linear
    regression applied to cross-sectional data. What we have added is an emphasis
    on the temporal qualities of the data set.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚描述的数据要求类似于应用于横截面数据的标准线性回归的要求。我们增加的是对数据集时间特性的强调。
- en: Warning
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Don’t force linear regression. Some of the consequences of applying linear
    regression when your data doesn’t meet the required assumptions are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不要强行使用线性回归。当你的数据不满足所需的假设时，应用线性回归可能会产生一些后果：
- en: Your coefficients will not minimize the error of your model.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的系数将不会最小化模型的误差。
- en: Your *p*-values for determining whether your coefficients are nonzero will be
    incorrect because they rely on assumptions that are not met. This means your assessments
    of coefficient significance could be wrong.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于依赖未满足的假设，你用于确定系数是否为非零的*p*值将是错误的。这意味着你对系数显著性的评估可能是错误的。
- en: Linear regressions can be helpful in offering simplicity and transparency when
    appropriate, but an incorrect model certainly isn’t transparent!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当合适时，线性回归可以提供简单和透明性，但错误的模型肯定不是透明的！
- en: It’s fair to question whether time series analysts are overly rigid in applying
    the assumptions required by standard linear regression so stringently they cannot
    use the linear regression technique. Real-world analysts take liberties with model
    assumptions from time to time. This can be productive so long as the potential
    downsides of doing so are understood.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以质疑时间序列分析师是否过于严格地应用标准线性回归所需的假设，以至于不能使用线性回归技术。现实世界的分析师偶尔在模型假设上取得一些自由是有益的，只要了解这样做的潜在风险。
- en: The importance of adhering to a model’s assumptions depends strongly on the
    domain. Sometimes a model is applied in full knowledge that its baseline assumptions
    are not met because the consequences are not too serious relative to the payoff.
    For example, in high-frequency trading, linear models are quite popular for a
    number of reasons despite no one believing that the data strictly follows all
    the standard assumptions.^([2](ch06.html#idm45576038962824))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守模型假设的重要性在很大程度上取决于领域。有时候，模型会在明知其基本假设未被满足的情况下应用，因为相对于回报来说，后果并不严重。例如，在高频交易中，尽管没有人相信数据严格遵循所有标准假设，线性模型因为多种原因而非常受欢迎。^([2](ch06.html#idm45576038962824))
- en: What Is An Unbiased Estimator?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是无偏估计量？
- en: If an estimate is not an overestimate or underestimate, it is using an unbiased
    estimator. This tends to be a good thing, although you should be aware of the
    *bias-variance trade-off*, which is a description of the problem for both statistical
    and machine learning problems wherein models with a lower bias in their parameter
    estimates tend to have a higher variance of the estimate of the parameter. The
    variance of the parameter’s estimate reflects how variable an estimate will be
    across different samples of the data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个估计值既不是过高也不是过低，那么它使用的是一个无偏估计量。这通常是一件好事，尽管你应该注意*偏差-方差权衡*，这是对统计和机器学习问题的描述，在这些问题中，参数估计偏差较小的模型往往会有更高的参数估计方差。参数估计的方差反映了估计在不同数据样本中的变化程度。
- en: If you find yourself in a situation where a linear regression may be a good
    fit for your forecasting task, consider taking advantage of `tslm()`, a function
    in the `forecast` [package](https://perma.cc/TR6C-4BUZ) designed to provide easy
    linear regression methodologies for time series data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己的情况适合使用线性回归进行预测任务，考虑利用`tslm()`，这是`forecast`[包](https://perma.cc/TR6C-4BUZ)中设计的提供时间序列数据的简易线性回归方法的函数。
- en: Statistical Methods Developed for Time Series
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为时间序列开发的统计方法
- en: We consider statistical methods developed specifically for time series data.
    We first study methods developed for univariate time series data, beginning with
    the very simple case of an autoregressive model, which is a model that says that
    future values of a time series are a function of its past values. We then work
    our way up to increasingly complex models, concluding with a discussion of vector
    autoregression for multivariate time series and of some additional specialized
    time series methods, such as GARCH models and hierarchical modeling.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑专门为时间序列数据开发的统计方法。我们首先研究为单变量时间序列数据开发的方法，从自回归模型的非常简单的情况开始，即一个模型，它表示时间序列的未来值是其过去值的函数。然后，我们逐步深入复杂的模型，最后讨论多元时间序列的向量自回归以及一些额外的专门的时间序列方法，例如GARCH模型和层次建模。
- en: Autoregressive Models
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自回归模型
- en: The autoregressive (AR) model relies on the intuition that the past predicts
    the future and so posits a time series process in which the value at a point in
    time *t* is a function of the series’s values at earlier points in time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归(AR)模型依赖于过去预测未来的直觉，因此假设一个时间序列过程，在这个过程中，时间*t*的值是该系列在早期时间点的值的函数。
- en: Our discussion of this model will be more detailed to give you a sense of how
    statisticians think about these models and their properties. For this reason,
    we start with a fairly lengthy theory overview. You can skim this if you are not
    interested in the mechanics behind how statistical model properties are derived
    for time series.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个模型的讨论将更为详细，以便让您了解统计学家如何考虑这些模型及其特性。因此，我们从一个相当详细的理论概述开始。如果您对如何推导时间序列的统计模型特性不感兴趣，可以略读这部分内容。
- en: Using algebra to understand constraints on AR processes
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代数来理解AR过程的约束条件。
- en: 'Autoregression looks like what many people would use as a first attempt to
    fit a time series, particularly if they had no information other than the time
    series itself. It is exactly what its name implies: a regression on past values
    to predict future values.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归看起来就像许多人在尝试拟合时间序列时会使用的第一种方法，特别是如果除了时间序列本身外没有其他信息的话。它确实如其名称所示：对过去值进行回归以预测未来值。
- en: 'The simplest AR model, an AR(1) model, describes a system as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的AR模型，即AR(1)模型，描述如下：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: The value of the series at time *t* is a function of a constant *b[0]*, its
    value at the previous time step multiplied by another constant <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>b</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math>
    and an error term that also varies with time *e[t]*. This error term is assumed
    to have a constant variance and a mean of 0\. We denote an autoregressive term
    that looks back only to the immediately prior time as an AR(1) model because it
    includes a lookback of one lag.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间*t*的系列值是一个常数*b[0]*、其前一个时间步的值乘以另一个常数 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>b</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math>
    和一个也随时间变化的误差项*e[t]*的函数。假定这个误差项具有恒定的方差和均值为0。我们将仅回顾前一个时间点的自回归项称为AR(1)模型，因为它包括一个一期滞后的查看。
- en: 'Incidentally, the AR(1) model has an identical form to a simple linear regression
    model with only one explanatory variable. That is, it maps to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，AR(1)模型与仅有一个解释变量的简单线性回归模型具有相同的形式。也就是说，它映射为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Y</mi> <mo>=</mo>
    <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi> <mn>1</mn></msub>
    <mo>×</mo> <mi>x</mi> <mo>+</mo> <mi>e</mi></mrow></math>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Y</mi> <mo>=</mo>
    <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi> <mn>1</mn></msub>
    <mo>×</mo> <mi>x</mi> <mo>+</mo> <mi>e</mi></mrow></math>
- en: We can calculate both the expected value of *y*[*t*] and its variance, given
    *y*[*t*–1], if we know the value of *b*[0] and *b*[1]. See [Equation 6-1](#equation-1).^([3](ch06.html#idm45576038906200))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道*b*[0]和*b*[1]的值，我们可以计算*y*[*t*]的期望值和方差，给定*y*[*t*–1]。参见[Equation 6-1](#equation-1).^([3](ch06.html#idm45576038906200))
- en: Equation 6-1\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi>
    <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>|</mo> <msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>=</mo>
    <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 6-1. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>|</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>=</mo> <msub><mi>b</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>b</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>V</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>|</mo> <msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mi>V</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo> <msub><mi>e</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>V</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo>
    <mi>e</mi> <mo>)</mo></mrow></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>V</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>|</mo> <msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mi>V</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo> <msub><mi>e</mi> <mi>t</mi></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mi>V</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo>
    <mi>e</mi> <mo>)</mo></mrow></mrow></math>
- en: The generalization of this notation allows the present value of an AR process
    to depend on the *p* most recent values, producing an AR(*p*) process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此表示法的推广允许 AR 过程的当前值依赖于最近的 *p* 个值，从而产生 AR(*p*) 过程。
- en: 'We now switch to more traditional notation, which uses *ϕ* to denote the autoregression
    coefficients:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向更传统的符号表示，使用 *ϕ* 表示自回归系数：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>ϕ</mi> <mi>p</mi></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mi>p</mi></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>ϕ</mi> <mi>p</mi></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mi>p</mi></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: As discussed in [Chapter 3](ch03.html#exploratory_data_analysis_for_time_series),
    stationarity is a key concept in time series analysis because it is required by
    many time series models, including AR models.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 3 章](ch03.html#exploratory_data_analysis_for_time_series) 中讨论的，稳定性是时间序列分析中的关键概念，因为许多时间序列模型，包括
    AR 模型，都需要它。
- en: We can determine the conditions for an AR model to be stationary from the definition
    of stationarity. We continue our focus on the simplest AR model, AR(1) in [Equation
    6-2](#equation-2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从稳定性的定义中确定 AR 模型保持稳定的条件。我们继续关注最简单的 AR 模型，即 AR(1) 在 [方程 6-2](#equation-2)
    中。
- en: Equation 6-2\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 6-2\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: 'We assume the process is stationary and then work “backward” to see what that
    implies about the coefficients. First, from the assumption of stationarity, we
    know that the expected value of the process must be the same at all times. We
    can rewrite *y[t]* per the equation for an AR(1) process:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设过程是稳定的，然后“向后”推导看看这对系数意味着什么。首先，根据稳定性的假设，我们知道过程的期望值在所有时间点上必须相同。我们可以按照 AR(1)
    过程的方程重新表述 *y[t]*：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>μ</mi> <mo>=</mo>
    <mi>E</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>μ</mi> <mo>=</mo>
    <mi>E</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow></mrow></math>
- en: 'By definition, *e[t]* has an expected value of 0\. Additionally the phis are
    constants, so their expected values are their constant values. [Equation 6-2](#equation-2)
    reduces on the lefthand side to:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，*e[t]* 的期望值为 0。此外，phises 是常数，因此它们的期望值就是它们的恒定值。[方程 6-2](#equation-2) 在左侧简化为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow> <mo>=</mo> <mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo> <mo>=</mo> <mi>μ</mi></mrow></math>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo> <mo>=</mo> <mi>μ</mi></mrow></math>
- en: 'And on the righthand side to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以及右侧为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ϕ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mo>×</mo> <mi>μ</mi> <mo>+</mo>
    <mn>0</mn></mrow></math>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ϕ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mo>×</mo> <mi>μ</mi> <mo>+</mo>
    <mn>0</mn></mrow></math>
- en: 'This simplifies to:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mi>μ</mi></mrow></math>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mi>μ</mi></mrow></math>
- en: which in turn implies that ([Equation 6-3](#equation-3)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来意味着 ([方程 6-3](#equation-3))。
- en: Equation 6-3\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi>
    <mo>=</mo> <mfrac><msub><mi>ϕ</mi> <mn>0</mn></msub> <mrow><mn>1</mn><mo>-</mo><msub><mi>ϕ</mi>
    <mn>1</mn></msub></mrow></mfrac></mrow></math>
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 6-3\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi> <mo>=</mo>
    <mfrac><msub><mi>ϕ</mi> <mn>0</mn></msub> <mrow><mn>1</mn><mo>-</mo><msub><mi>ϕ</mi>
    <mn>1</mn></msub></mrow></mfrac></mrow></math>
- en: So we find a relationship between the mean of the process and the underlying
    AR(1) coefficients.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们找到了过程的均值与基础 AR(1) 系数之间的关系。
- en: We can take similar steps to look at how a constant variance and covariance
    impose conditions on the *ϕ* coefficients. We begin by substituting the value
    of *ϕ*[0], which we can derive [Equation 6-4](#equation-4) from [Equation 6-3](#equation-3).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取类似的步骤来查看恒定方差和协方差如何对 *ϕ* 系数施加条件。我们首先用 *ϕ*[0] 的值代替，我们可以从 [方程 6-3](#equation-3)
    推导出 [方程 6-4](#equation-4)。
- en: Equation 6-4\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ϕ</mi>
    <mn>0</mn></msub> <mo>=</mo> <mi>μ</mi> <mo>×</mo> <mrow><mo>(</mo> <mn>1</mn>
    <mo>–</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 6-4\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>ϕ</mi>
    <mn>0</mn></msub> <mo>=</mo> <mi>μ</mi> <mo>×</mo> <mrow><mo>(</mo> <mn>1</mn>
    <mo>–</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mo>)</mo></mrow></mrow></math>
- en: 'into [Equation 6-2](#equation-2):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [方程 6-2](#equation-2)：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mrow><mo>(</mo> <mi>μ</mi> <mo>–</mo> <mi>μ</mi> <mo>×</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mrow><mo>(</mo> <mi>μ</mi> <mo>–</mo> <mi>μ</mi> <mo>×</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>–</mo>
    <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>–</mo>
    <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: If you inspect [Equation 6-4](#equation-4), what should jump out at you is that
    it has very similar expressions on the lefthand and righthand sides, namely <math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>–</mo> <mi>€</mi> <mi>“</mi> <mi>μ</mi></mrow></math> and <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>–</mo> <mi>€</mi> <mi>“</mi>
    <mi>μ</mi></mrow></math> . Given that this time series is stationary, we know
    that the math at time *t* – 1 should be the same as the math at time *t*. We rewrite
    [Equation 6-4](#equation-4) in the frame of a time one step earlier as [Equation
    6-5](#equation-5).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查[方程 6-4](#equation-4)，你会发现左右两边的表达式非常相似，即 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>–</mo> <mi>€</mi> <mi>“</mi> <mi>μ</mi></mrow></math> 和
    <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>–</mo> <mi>€</mi> <mi>“</mi> <mi>μ</mi></mrow></math> 。考虑到这个时间序列是平稳的，我们知道时间
    *t* 的数学应与时间 *t*–1 的数学相同。我们将[方程 6-4](#equation-4)重新写成一个时间步骤较早的[方程 6-5](#equation-5)。
- en: Equation 6-5\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>–</mo> <mi>μ</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>–</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math>
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程式 6-5\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>–</mo> <mi>μ</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>–</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></math>
- en: 'We can then substitute this into [Equation 6-4](#equation-4) as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其代入[方程 6-4](#equation-4)如下：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>–</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>–</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: We rearrange for clarity in [Equation 6-6](#equation-6).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了清晰起见重新排列[方程 6-6](#equation-6)。
- en: Equation 6-6\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>e</mi> <mi>t</mi></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>-</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方程 6-6\. <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>e</mi> <mi>t</mi></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>–</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: 'It should catch your eye that another substitution is possible in [Equation
    6-6](#equation-6) for <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>-</mo> <mi>μ</mi></mrow></math>
    using the same recursive substitution we used earlier, but instead of working
    on *y*[*t*–1] we will work on *y*[*t*–2]. If you do this substitution, the pattern
    becomes clear:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到在[方程 6-6](#equation-6)中还可以进行另一次替换，使用我们早期使用的同样递归替换，但这次不是在 *y*[t–1] 上工作，而是在
    *y*[t–2] 上工作。如果你进行这种替换，模式就变得清晰了。
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>+</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>3</mn></mrow></msub>
    <mo>-</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>+</mo>
    <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub> <mo>+</mo> <msub><mi>ϕ</mi>
    <mn>1</mn></msub> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>3</mn></mrow></msub>
    <mo>-</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>)</mo></mrow></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo> <msub><mi>e</mi>
    <mi>t</mi></msub> <mo>+</mo> <mi>ϕ</mi> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msup><mi>ϕ</mi> <mn>2</mn></msup> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msup><mi>ϕ</mi> <mn>3</mn></msup> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>3</mn></mrow></msub>
    <mo>+</mo> <mtext>(expressions</mtext> <mtext>still</mtext> <mtext>to</mtext>
    <mtext>be</mtext> <mtext>substituted)</mtext></mrow></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo> <msub><mi>e</mi>
    <mi>t</mi></msub> <mo>+</mo> <mi>ϕ</mi> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msup><mi>ϕ</mi> <mn>2</mn></msup> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msup><mi>ϕ</mi> <mn>3</mn></msup> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>3</mn></mrow></msub>
    <mo>+</mo> <mtext>(expressions</mtext> <mtext>still</mtext> <mtext>to</mtext>
    <mtext>be</mtext> <mtext>substituted)</mtext></mrow></math>
- en: So we can conclude more generally that <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>∞</mi></msubsup> <msubsup><mi>ϕ</mi> <mn>1</mn> <mi>i</mi></msubsup> <mo>×</mo>
    <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub></mrow></math>
    .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以更一般地得出结论，<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi>
    <mi>t</mi></msub> <mo>–</mo> <mi>μ</mi> <mo>=</mo> <msubsup><mo>∑</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow>
    <mi>∞</mi></msubsup> <msubsup><mi>ϕ</mi> <mn>1</mn> <mi>i</mi></msubsup> <mo>×</mo>
    <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub></mrow></math>
    。
- en: In plain English, *y[t]* minus the process mean is a linear function of the
    error terms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，*y[t]* 减去过程均值是误差项的线性函数。
- en: 'This result can then be used to compute the expectation of <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi>
    <mo>[</mo> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>-</mo> <mi>μ</mi>
    <mo>)</mo></mrow> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>]</mo> <mo>=</mo> <mn>0</mn></mrow></math> given that the values of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>e</mi> <mi>t</mi></msub></math>
    at different *t* values are independent. From this we can conclude that the covariance
    of *y*[*t*–1] and *e[t]* is 0, as it should be. We can apply similar logic to
    calculate the variance of *y[t]* by squaring this equation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以用来计算给定<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi>
    <mo>[</mo> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>-</mo> <mi>μ</mi>
    <mo>)</mo></mrow> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>]</mo> <mo>=</mo> <mn>0</mn></mrow></math>的期望值，假设在不同*t*值上<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>e</mi>
    <mi>t</mi></msub></math>的值是独立的。由此我们可以得出结论，*y*[*t*–1]和*e[t]*的协方差为0，这正如预期的那样。我们可以类似地应用逻辑来计算*y[t]*的方差通过平方这个等式：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>-</mo>
    <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>-</mo> <mi>μ</mi> <mo>=</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>-</mo>
    <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <msubsup><mi>ϕ</mi> <mn>1</mn> <mn>2</mn></msubsup> <mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>v</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo>
    <msub><mi>e</mi> <mi>t</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <msubsup><mi>ϕ</mi> <mn>1</mn> <mn>2</mn></msubsup> <mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <mi>v</mi> <mi>a</mi> <mi>r</mi> <mrow><mo>(</mo>
    <msub><mi>e</mi> <mi>t</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: 'Because the variance quantities on each side of the equation must be equal
    due to stationarity, such that (*var*(*y*[t]) = *var*(*y*[t] – 1), this implies
    that:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为由于平稳性方程两边的方差数量必须相等，所以(*var*(*y*[t]) = *var*(*y*[t] – 1)，这意味着：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mo>(</mo><msub><mi>e</mi>
    <mi>t</mi></msub> <mo>)</mo></mrow> <mrow><mn>1</mn><mo>–</mo><msubsup><mi>ϕ</mi>
    <mn>1</mn> <mn>2</mn></msubsup></mrow></mfrac></mrow></math>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>v</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mo>(</mo><msub><mi>e</mi>
    <mi>t</mi></msub> <mo>)</mo></mrow> <mrow><mn>1</mn><mo>–</mo><msubsup><mi>ϕ</mi>
    <mn>1</mn> <mn>2</mn></msubsup></mrow></mfrac></mrow></math>
- en: Given that the variance must be greater than or equal to 0 by definition, we
    can see that <math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>ϕ</mi>
    <mn>1</mn> <mn>2</mn></msubsup></math> must be less than 1 to ensure a positive
    value on the righthand side of the preceding equation. This implies that for a
    stationary process we must have –1 < *ϕ[1]* < 1\. This is a necessary and sufficient
    condition for weak stationarity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于方差根据定义必须大于或等于0，我们可以看到，<math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mi>ϕ</mi>
    <mn>1</mn> <mn>2</mn></msubsup></math>必须小于1，以确保在前述方程的右侧有正值。这意味着对于平稳过程，我们必须有 –1
    < *ϕ[1]* < 1。这是弱平稳的必要和充分条件。
- en: We studied the AR(1) process because it is the simplest autoregressive process.
    In practice, you will fit more complex models all the time. It is possible to
    derive similar conditions for stationarity for an arbitrary order AR(*p*), and
    there are many books where this is demonstrated. If you are interested in seeing
    this worked out more explicitly, take a look at the resources listed at the end
    of the chapter. The most important takeaway from this discussion is that time
    series are quite approachable with some algebra and statistics, and that stationarity
    is not simply a matter of graphing a model but rather a mathematical concept that
    can be worked out with respect to the specifics of any given statistical model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了AR(1)过程，因为它是最简单的自回归过程。在实践中，您将一直拟合更复杂的模型。可以推导出任意阶AR(*p*)过程的类似平稳条件，并且有许多书籍在其中进行了演示。如果您有兴趣更详细地了解这一点，请查看本章末尾列出的资源。从这次讨论中最重要的收获是，通过一些代数和统计学，时间序列是非常易于理解的，并且平稳性不仅仅是绘制模型的问题，而是可以根据任何给定统计模型的具体情况进行计算的数学概念。
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A *distribution* is a statistical function describing the probability for all
    possible values that a particular value will be generated by a process. While
    you might not have encountered this term formally, you have undoubtedly encountered
    this concept. For example, consider the *bell curve*, which is a probability distribution
    indicating that most measurements will fall close to, and be distributed equally
    on both sides of, the mean. It’s usually called a *normal* or *Gaussian distribution*
    in statistics.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*分布*是描述由过程生成特定值的所有可能值的概率的统计函数。虽然您可能尚未正式遇到此术语，但无疑已经遇到了此概念。例如，考虑*钟形曲线*，它是一个概率分布，指出大多数测量值将接近并均匀分布在平均值的两侧。在统计学中通常称为*正态*或*高斯分布*。'
- en: Choosing parameters for an AR(p) model
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择AR(p)模型的参数
- en: To assess the appropriateness of an AR model for your data, begin by plotting
    the process and its *partial autocorrelation function* (PACF).The PACF of an AR
    process should cut off to zero beyond the order *p* of an AR(*p*) process, giving
    a concrete and visual indication of the order of an AR process empirically seen
    in the data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估AR模型对数据的适用性，请从绘制过程及其*偏自相关函数*（PACF）开始。AR过程的PACF应在AR(*p*)过程的阶数*p*之外截尾为零，从而在数据中以实证方式给出AR过程的阶数的明确和视觉指示。
- en: 'On the other hand, an AR process will not have an informative autocorrelation
    function (ACF), although it will have the characteristic shape of an ACF: exponential
    tapering with increasing time offset.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，AR过程不会有信息性的自相关函数（ACF），尽管它将具有ACF的特征形状：随着时间偏移增加呈指数衰减。
- en: Let’s take a look at this with some actual data. We use some demand forecasting
    data published in the [UCI Machine Learning Repository](https://perma.cc/B7EQ-DNLU).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实际数据来看看这个。我们使用了发布在[UCI机器学习库](https://perma.cc/B7EQ-DNLU)中的一些需求预测数据。
- en: First we plot the data in chronological order ([Figure 6-1](#fig-0601)). Since
    we will model this as an AR process, we look to the PACF to set a cutoff on the
    order of the process ([Figure 6-2](#fig-0602)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按时间顺序绘制数据（[图 6-1](#fig-0601)）。由于我们将其建模为AR过程，我们查看偏自相关函数以设置过程的阶数阈值（[图 6-2](#fig-0602)）。
- en: '![](assets/ptsa_0601.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0601.png)'
- en: Figure 6-1\. Daily number of Banking orders (2).
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 每日银行订单数（2）。
- en: '![](assets/ptsa_0602.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0602.png)'
- en: Figure 6-2\. PACF of the untransformed orders time series pictured in [Figure 6-1](#fig-0601).
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 未转换订单时间序列的偏自相关图，如[图 6-1](#fig-0601)所示。
- en: 'We can see that the value of the PACF crosses the 5% significance threshold
    at lag 3\. This is consistent with the results from the `ar()` function available
    in R’s `stats` package. `ar()` automatically chooses the order of an autoregressive
    model if one is not specified:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到PACF的值在滞后3处穿过了5%的显著性阈值。这与R语言`stats`包中的`ar()`函数的结果一致。如果没有指定自回归模型的阶数，`ar()`函数会自动选择其阶数：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we look at the [documentation](https://perma.cc/8H8Z-CX9R) for the `ar()`
    function, we can see that the order selected is determined (with the default parameters
    we left undisturbed) based on the *Akaike information criterion* (AIC). This is
    helpful to know because it shows that the visual selection we made by examining
    the PACF is consistent with the selection that would be made by minimizing an
    information criterion. These are two different ways of selecting the order of
    the model, but in this case they are consistent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`ar()`函数的[文档](https://perma.cc/8H8Z-CX9R)，我们可以看到所选的阶数是根据*赤池信息准则*（AIC）确定的（我们保持了默认参数未改变）。这是有帮助的，因为它显示我们通过检查PACF所做的视觉选择与通过最小化信息准则进行的选择是一致的。这两种选择模型阶数的方式是不同的，但在这种情况下它们是一致的。
- en: Notice that the `ar()` function has also provided us with the coefficients for
    the model. We may, however, want to limit the coefficients. For example, looking
    at the PACF, we might wonder whether we really want to include a coefficient for
    the lag – 1 term or whether we should assign that term a mandatory coefficient
    of 0 given that its PACF value is well below the threshold used for significance.
    In this case, we can use the `arima()` function also from the `stats` package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ar()`函数还为我们提供了模型的系数。然而，我们可能希望限制这些系数。例如，观察PACF，我们可能会想知道是否真的要包括滞后-1项的系数，或者是否应该将该项的系数指定为强制的0，因为其PACF值远低于显著性阈值。在这种情况下，我们还可以使用`stats`包中的`arima()`函数。
- en: 'Here, we demonstrate how to call the function to fit an AR(3), by setting the
    order parameter to `c(3, 0, 0)`, where 3 refers to the order of the AR component
    (in later examples we will specify other components for the differencing and moving
    average parameters covered in the next few pages of this chapter):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何调用函数来拟合AR(3)模型，通过将阶数参数设置为`c(3, 0, 0)`，其中3指的是AR分量的阶数（在后续示例中，我们将指定本章后几页中涵盖的差分和移动平均参数的其他分量）：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To inject prior knowledge or opinion into our model, we can constraint a coefficient
    to be 0\. For example, if we want to constrain the lag – 1 term to remain 0 in
    our model, we use the following call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的模型中注入先验知识或观点，我们可以将一个系数约束为0。例如，如果我们想要在我们的模型中将滞后-1项的系数约束为0，我们可以使用以下调用：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Setting a value in the vector passed to the fixed parameter of the `arima`
    function to 0 rather than `NA` will constraint that value to remain 0:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给`arima`函数的固定参数向量中的一个值设置为0而不是`NA`，将约束该值保持为0：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now inspect our model performance on our training data to assess the goodness
    of fit of our model to this data set. We can do this in two ways. First, we plot
    the ACF of the residuals (that, is the errors) to see if there is a pattern of
    self-correlation that our model does not cover.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在检查我们模型在训练数据上的表现，以评估我们模型对这个数据集的拟合程度。我们可以通过两种方式来做这件事。首先，我们绘制残差的自相关函数（即误差），以查看是否存在模型未覆盖的自相关模式。
- en: 'Plotting the residuals is quite simple thanks to the output of the `arima()`
    function (see [Figure 6-3](#fig-0603)):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`arima()`函数的输出，绘制残差非常简单（见[图6-3](#fig-0603)）：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](assets/ptsa_0603.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0603.png)'
- en: Figure 6-3\. ACF of the residuals of the AR(3) model we fit forcing the lag
    – 1 parameter to 0.
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3\. 我们拟合的AR(3)模型的残差的ACF，强制滞后 - 1参数为0。
- en: None of the values of the ACF cross the significance threshold. Of course, we
    should not blindly yield to a significance threshold to assess or reject significance,
    but this observation is a helpful data point in a model that we already believe
    reasonable for other reasons.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ACF的值都未超过显著性阈值。当然，我们不应盲目依赖显著性阈值来评估或拒绝显著性，但这一观察结果是我们已认为合理的模型中的一个有用数据点。
- en: We do not see a pattern of self-correlation here among the residuals (i.e.,
    the error terms). If we had seen such a pattern, we would likely want to return
    to our original model and consider including additional terms to add complexity
    to account for the significant autocorrelation of the residuals.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的残差（即误差项）中没有看到自相关的模式。如果我们看到这样的模式，我们可能会希望回到原始模型，并考虑包括额外的项以增加复杂性，以解释残差的显著自相关。
- en: 'Another test that is commonly performed is the *Ljung-Box test*, an overall
    test of the randomness of a time series. More formally it poses the following
    null and alternate hypotheses:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的测试是*Ljung-Box测试*，这是对时间序列随机性的整体测试。更正式地提出了以下零假设和备择假设：
- en: 'H0: The data does not exhibit serial correlation.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'H0: 数据不表现出串行相关。'
- en: 'H1: The data does exhibit serial correlation.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'H1: 数据表现出串行相关。'
- en: 'This test is commonly applied to AR (and more generally, ARIMA) models, and
    more specifically to the residuals from the model fit rather than to the model
    itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试通常适用于AR（更广义地说，是ARIMA）模型，更具体地说是适用于模型拟合的残差而不是模型本身：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We apply the Ljung-Box test to our `est.1` model to assess its goodness of fit.
    We cannot reject the null hypothesis that the data does not exhibit serial correlation.
    This is confirmation of what we just found by plotting the ACF of the residuals.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的`est.1`模型应用Ljung-Box测试来评估其拟合优度。我们无法拒绝数据不表现出串行相关的零假设。这证实了我们刚刚通过绘制残差的ACF发现的结果。
- en: Forecasting with an AR(p) process
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AR(p)过程进行预测
- en: In the following sections we will illustrate how to make forecasts with AR processes.
    We first explore the case of one time step ahead and then discuss how predicting
    multiple steps ahead differs from the further case. The good news is that from
    a coding perspective there is not much difference, although the underlying mathematics
    is more elaborate in the latter case.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将说明如何使用AR过程进行预测。我们首先探讨了一步预测的情况，然后讨论了多步预测与进一步情况的区别。好消息是从编码的角度来看，并没有太大的差异，尽管后者的基础数学更为复杂。
- en: Forecasting one time step ahead
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向前预测一步
- en: We first consider the case that we want to forecast one time step ahead with
    a known (or estimated) AR model. In such a case, we actually have all the information
    we need.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑我们想要用已知（或估计）的AR模型预测一步的情况。在这种情况下，我们实际上拥有所有所需的信息。
- en: We continue working with the model from the demand data, with the lag – 1 coefficient
    constrained to 0 (fit as `est.1` earlier).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用需求数据的模型，将滞后 - 1系数约束为0（之前作为`est.1`拟合）。
- en: 'We plot the forecast using the `fitted()` function from the `forecast` package.
    Here is the code in full; it’s quite easy to do:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`forecast`包中的`fitted()`函数绘制预测图。这里是完整的代码；这样做非常简单：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This results in the plot shown in [Figure 6-4](#fig-0604).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了[图6-4](#fig-0604)所示的绘图结果。
- en: '![](assets/ptsa_0604.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0604.png)'
- en: Figure 6-4\. Here we see the original time series in the solid line and the
    fitted time series in the dashed line.
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4\. 这里我们看到实线表示的原始时间序列和虚线表示的拟合时间序列。
- en: AR(p) Models Are Moving Window Functions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AR(p)模型是移动窗口函数。
- en: 'We have an option beyond using the `forecast` package’s fitted functionality
    to produce a forecast from our AR(3) model: we could handcode a forecast more
    explicitly by using the `zoo` package’s `rollapply()` function, which we discussed
    previously. That function to compute window functions can also compute an AR process.
    To do this we would take the coefficients from the `ar()` fit and apply these
    weights to an input vector representing the values of the different lags to produce
    a forecast at each point. I leave this as an exercise for you.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们除了使用`forecast`包的拟合功能来从我们的AR(3)模型生成预测之外，还有一种选择：我们可以更明确地手工编写一个预测，通过使用`zoo`包的`rollapply()`函数来实现，这是我们之前讨论过的。该函数可以计算窗口函数，也可以计算AR过程。为此，我们将从`ar()`拟合中获取系数，并将这些权重应用于表示不同滞后值的输入向量，以在每个点上生成预测。我留给你作为一个练习。
- en: Now let’s think about the quality of the forecast. If we calculate the correlation
    between the predicted value and the actual value, we get 0.29\. This is not bad
    in some contexts, but remember that sometimes differencing the data will remove
    what seemed like a strong relationship and replace it with one that is essentially
    random.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑预测的质量。如果我们计算预测值与实际值之间的相关性，我们得到0.29。在某些情境下这并不差，但请记住，有时候对数据进行差分会消除看似强关系，取而代之的是一种基本上是随机的关系。
- en: This will be the case particularly if the data was not truly stationary when
    we fit it, so that an unidentified trend masquerades as good model performance
    when it is actually a trait of the data we should have addressed before modeling.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在拟合数据时数据确实不是真正稳定的，那么未识别的趋势就会伪装成良好的模型性能，而实际上它是我们在建模之前应该解决的数据特征。
- en: We can difference both the series and the predicted values to see whether the
    change from one time period to the next is well predicted by the model. Even after
    differencing, our predictions and the data show similar patterns, suggesting our
    model is a meaningful one (see [Figure 6-5](#fig-0605)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对系列数据和预测值同时进行差分，以查看模型是否能够良好地预测一个时间段到下一个时间段的变化。即使在差分之后，我们的预测和数据显示出相似的模式，这表明我们的模型是有效的（参见[图6-5](#fig-0605)）。
- en: '![](assets/ptsa_0605.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0605.png)'
- en: Figure 6-5\. The differenced series and the differenced predictions are strongly
    correlated, suggesting an underlying relationship is indeed identified by the
    model.
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5。差分系列和差分预测之间存在强相关性，表明模型确实识别出了一种潜在的关系。
- en: We can also test whether we predict the same moves at the same time, by plotting
    the differenced series and looking at that correlation. This plot reveals some
    correlation, which we can confirm by calculating the correlation value. The model
    works even for predicting the change from one time step to the next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过绘制差分系列并观察其相关性来测试我们是否在同一时间预测相同的移动。此图表显示了一些相关性，我们可以通过计算相关值来确认。即使用于预测从一个时间步到下一个时间步的变化，该模型也能够正常工作。
- en: Looking back at the original plot of the forecast versus actual values, we see
    that the main difference between the forecast and the data is that the forecast
    is less variable than the data. It may predict the direction of the future correctly,
    but not the scale of the change from one time period to another. This is not a
    problem per se but rather reflects the fact that forecasts are means of the predicted
    distributions and so necessarily will have lower variability than sampled data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾预测与实际值的原始图表，我们可以看到预测与数据之间的主要区别在于预测的变化幅度比数据小。它可能能够正确预测未来的方向，但无法准确预测不同时间段之间的变化幅度。这本身并不是问题，而是反映了预测是预测分布的均值，因此必然比采样数据具有更低的变异性。
- en: This property of statistical models is sometimes forgotten in the ease of fast
    visualizations that tend to suggest a more stable future than will usually be
    the case. When you present visualizations, make sure to remind your audience of
    what is being plotted. In this case, our forecasts suggest a much smoother future
    than is likely to be the case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模型的这一属性有时会在快速可视化的便利性中被忽视，这些可视化往往倾向于表明未来会比实际情况更加稳定。在呈现可视化数据时，请务必提醒观众正在绘制的内容。在这种情况下，我们的预测表明未来会比实际情况平稳得多。
- en: Forecasting many steps into the future
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预测未来多个时间步
- en: So far we have done a single-step-ahead forecast. However, we may want to predict
    even further into the future. Let’s imagine that we wanted to produce a two-step-ahead
    forecast instead of a one-step-ahead forecast. What we would do is first produce
    the one-step-ahead forecast, and then use this to furnish the <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi>
    <mi>t</mi></msub></math> value we need to predict <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi>
    <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></math> .
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了单步预测。但是，我们可能希望进一步预测未来更长的时间。让我们想象一下，我们想要生成一个两步预测，而不是一个步预测。我们首先会生成一个步预测，然后使用这个预测值来确定我们需要预测的
    <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi> <mi>t</mi></msub></math>
    的值，以便预测 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>y</mi> <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
    。
- en: Notice that in our current model, the shift from a one-step-ahead forecast to
    a two-step-ahead forecast would actually not require these gymnastics because
    the *y*[*t* – 1] value is not used when predicting *y*[*t*]. Everything we need
    to know to make a prediction two time steps ahead is known and there is no need
    to guesstimate. In fact, we should come up with the same series of values as we
    did for the one-step-ahead prediction—there will be no new sources of error or
    variability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们当前的模型中，从一步预测转变为两步预测实际上不需要这些复杂的操作，因为在预测 *y*[*t*] 时并没有使用 *y*[*t* – 1] 的值。我们知道所有需要知道的内容来进行两步预测，并且不需要估计。事实上，我们应该得到与一步预测相同的一系列值——不会有新的错误或变异源。
- en: If we want to predict even further, however, we will need to generate forecasted
    future values as inputs into our prediction. Let’s predict *y*[*t*+3]. This will
    involve a model with coefficients depending on *y*[*t*+1] and *y[t]*. So we will
    need to predict both of these values—*y*[*t* + 1] and *y*[*t*]—and then in turn
    use these estimated values in the prediction for *y*[*t*+3]. As before, we can
    use the `fitted()` function for the `forecast` package to do this—it’s no more
    difficult codewise than the one-step-ahead forecast. As mentioned previously,
    this can also be done with a `rollapply()` method, but it’s more work and more
    error prone.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们希望预测更远的时间，我们需要生成预测的未来值作为预测的输入。让我们预测 *y*[*t*+3]。这将涉及一个模型，其系数依赖于 *y*[*t*+1]
    和 *y[t]*。因此，我们需要预测这两个值——*y*[*t* + 1] 和 *y*[*t*]——然后依次使用这些估计值来预测 *y*[*t*+3]。与之前一样，我们可以使用
    `forecast` 包中的 `fitted()` 函数来实现这一点——在编码上并不比单步预测更难。正如之前提到的，这也可以通过 `rollapply()`
    方法来完成，但这样做需要更多的工作并且更容易出错。
- en: 'We use the `fitted()` function with an additional parameter now, `h` for horizon.
    As a reminder, our object `est.1` represents an AR(3) process with the lag – 1
    (time minus 1) coefficient constrained to be 0:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `fitted()` 函数，增加了一个额外的参数 `h` 作为预测的时间跨度。提醒一下，我们的对象 `est.1` 表示一个 AR(3)
    过程，其滞后 -1 (时间减一) 的系数被限制为 0：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can use the ease of predicting many time steps into the future to generate
    many multi-step-ahead forecasts for different horizons. In the next example, we
    can see the variance for forecasts made increasingly far into the future from
    the same underlying model. (Note that in the display, rounding and comma delineations
    modify the original output so it’s easier to see what is happening with the variance
    of the estimation as the forward horizon increases.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用预测多个时间步骤的便利性，为不同的时间跨度生成多步预测。在下一个例子中，我们可以看到从同一基础模型生成的预测值随着前瞻时间增加而增加的方差。（注意，在显示中，四舍五入和逗号分隔修改了原始输出，以便更清楚地看到随着前瞻时间增加时估计方差的变化。）
- en: 'As you can see in [Figure 6-6](#fig-0606), the variance of the prediction decreases
    with increasing forward horizon. The reason for this—which highlights an important
    limitation of the model—is that the further forward in time we go, the less the
    actual data matters because the coefficients for input data look only at a finite
    previous set of time points (in this model, going back only to lag – 3; i.e.,
    time – 3). One way of putting this is that forecasts further out in time converge
    to being the unconditional prediction—that is, unconditioned on data. The future
    prediction approaches the mean value of the series as the time horizon grows,
    and hence the variance of both the error term and of the forecast values shrinks
    to 0 as the forecast values tend toward the unconditional mean value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图6-6](#fig-0606)中所见，随着预测时间的增加，预测的方差减少。这突显了模型的一个重要限制，即随着时间推移，实际数据的影响越来越小，因为输入数据的系数仅考虑有限的前几个时间点（在此模型中，仅回溯到滞后
    - 3；即时间 - 3）。可以这样说，随着时间的推移，预测越来越接近无条件预测，即不受数据条件的影响。未来的预测接近于系列的均值，因此误差项和预测值的方差收缩为0：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Forecasts for sufficiently far out in the future will merely predict the mean
    of the process, which makes sense. At some point in the distant future, our current
    data does not give us specific sensible information relevant to the future, and
    so our forecast increasingly reverts to the baseline properties known about the
    process, such as its mean.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未来足够遥远的预测将仅仅预测过程的均值，这是有道理的。在未来某个时间点，我们当前的数据不会给我们提供与未来相关的具体合理信息，因此我们的预测逐渐回归到已知过程的基本特性，比如其均值。
- en: '![](assets/ptsa_0606.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0606.png)'
- en: Figure 6-6\. Plots of predictions into the future. The values spanned by the
    y-axis increasingly narrow as we predict further into the future and the model
    more closely appears to provide a constant prediction of the mean value of the
    process. The horizons predicted increase from top to bottom and are 3, 10, and
    30 time steps, respectively.
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-6. 对未来的预测绘图。随着预测时间的延长，y轴的值范围越来越窄，模型越来越接近提供过程均值的常数预测。预测的视角从上到下分别是3、10和30个时间步。
- en: The important point to remember from this is that AR (as well as MA, ARMA, and
    ARIMA, which will be discussed shortly) models are best for making short-term
    predictions. These models lose predictive power for large future horizons.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从中要记住的重要一点是，AR（以及MA、ARMA和ARIMA，稍后将讨论）模型最适合进行短期预测。这些模型对于较长时间段的预测失去了预测能力。
- en: For the remaining models, we will go through a similar treatment as we have
    given to the autoregressive models, albeit with less overall detail. A full discussion
    is available in all the standard textbooks on time series analysis.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的模型，我们将进行类似的处理，尽管总体上的细节较少。关于时间序列分析的所有标准教科书都有详细讨论。
- en: Moving Average Models
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平均模型
- en: A moving average (MA) model relies on a picture of a process in which the value
    at each point in time is a function of the recent past value “error” terms, each
    of which is independent from the others. We will review this model in the same
    series of steps we used to study AR models.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均（MA）模型依赖于一个过程的图像，在这个过程中，每个时间点的值是最近过去值的“误差”项的函数，每个项相互独立。我们将在同样的步骤中回顾这个模型，就像我们研究AR模型一样。
- en: AR MA Equivalence
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AR MA 等效性
- en: In many cases, an MA process can be expressed as an infinite order AR process.
    Likewise, in many cases an AR process can be expressed as an infinite order MA
    process. To learn more, look into [invertibility of an MA process](https://perma.cc/GJ6B-YASH),
    the [Wold representation theorem](https://perma.cc/B3DW-5QGB), and the [duality
    of MA/AR](https://perma.cc/K78H-YA6U) processes generally. The mathematics involved
    is well beyond the scope of this book!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一个MA过程可以被表达为一个无限阶的AR过程。同样地，在许多情况下，一个AR过程可以被表达为一个无限阶的MA过程。要了解更多，请查看[MA过程的可逆性](https://perma.cc/GJ6B-YASH)，[Wold表示定理](https://perma.cc/B3DW-5QGB)，以及一般的[MA/AR对偶性](https://perma.cc/K78H-YA6U)过程。这涉及到的数学远远超出了本书的范围！
- en: The model
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 该模型
- en: 'A moving average model can be expressed similarly to an autoregressive model
    except that the terms included in the linear equation refer to present and past
    error terms rather than present and past values of the process itself. So an MA
    model of order *q* is expressed as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均模型可以类似于自回归模型来表达，只是线性方程中包含的项是现在和过去的误差项，而不是过程本身的现在和过去的值。因此，一个阶数为 *q* 的 MA
    模型表示为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>q</mi></msub>
    <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>q</mi></mrow></msub></mrow></math>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>q</mi></msub>
    <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>q</mi></mrow></msub></mrow></math>
- en: Warning
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do not confuse the MA model with a moving average. They are not the same thing.
    Once you know how to fit a moving average process, you can even compare the fit
    of an MA model to a moving average of the underlying time series. I leave this
    as an exercise for you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 MA 模型与移动平均混淆。它们并不相同。一旦您知道如何拟合移动平均过程，甚至可以将 MA 模型的拟合与底层时间序列的移动平均进行比较。我留这个作为一个练习给你。
- en: Economists talk about these error terms as “shocks” to the system, while someone
    with an electrical engineering background could talk about this as a series of
    impulses and the model itself as a finite impulse response filter, meaning that
    the effects of any particular impulse remain only for a finite period of time.
    The wording is unimportant, but the concept of many independent events at different
    past times affecting the current value of the process, each making an individual
    contribution, is the main idea.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 经济学家将这些误差项称为系统的“冲击”，而具有电气工程背景的人则可能将其视为一系列脉冲和模型本身作为有限脉冲响应滤波器，这意味着任何特定脉冲的影响仅保留有限时间。措辞并不重要，但许多独立事件在不同的过去时间影响当前过程值，每个事件都作出个别贡献，这是主要思想。
- en: 'MA models are by definition weakly stationary without the need to impose any
    constraints on their parameters. This is because the mean and variance of an MA
    process are both finite and invariant with time because the error terms are assumed
    to be iid with mean 0\. We can see this as:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: MA 模型根据定义是弱平稳的，无需对其参数施加任何约束。这是因为 MA 过程的均值和方差都是有限的，并且随时间不变，因为误差项被假定为均值为 0 的独立同分布。我们可以看到这样的表达式：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi>
    <mi>t</mi></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>q</mi></msub>
    <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>q</mi></mrow></msub>
    <mo>)</mo></mrow></math>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mo>(</mo>
    <msub><mi>y</mi> <mi>t</mi></msub> <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi>
    <mi>t</mi></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>q</mi></msub>
    <mo>×</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mi>q</mi></mrow></msub>
    <mo>)</mo></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo> <mi>E</mi>
    <mrow><mo>(</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mn>0</mn> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mo>×</mo>
    <mn>0</mn> <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>=</mo> <mi>μ</mi></mrow></math>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo> <mi>E</mi>
    <mrow><mo>(</mo> <mi>μ</mi> <mo>)</mo></mrow> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mn>0</mn> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mo>×</mo>
    <mn>0</mn> <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>=</mo> <mi>μ</mi></mrow></math>
- en: 'For calculating the variance of the process, we use the fact that the *e[t]*
    terms are iid and also the general statistical property that the variance of the
    sum of two random variables is the same as their individual variances plus two
    times their covariance. For iid variables the covariance is 0\. This yields the
    expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算过程方差的事实是 *e[t]* 项是独立同分布的，并且还有一个一般的统计性质，即两个随机变量的和的方差等于它们各自方差的总和加上两倍的协方差。对于独立同分布变量，协方差为
    0。这导致了以下表达式：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>V</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>+</mo> <msubsup><mi>θ</mi> <mn>1</mn>
    <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mi>θ</mi> <mn>2</mn> <mn>2</mn></msubsup>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msubsup><mi>θ</mi>
    <mi>q</mi> <mn>2</mn></msubsup> <mo>)</mo></mrow> <mo>×</mo> <msubsup><mi>σ</mi>
    <mi>e</mi> <mn>2</mn></msubsup></mrow></math>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>V</mi> <mi>a</mi>
    <mi>r</mi> <mrow><mo>(</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>+</mo> <msubsup><mi>θ</mi> <mn>1</mn>
    <mn>2</mn></msubsup> <mo>+</mo> <msubsup><mi>θ</mi> <mn>2</mn> <mn>2</mn></msubsup>
    <mo>+</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <msubsup><mi>θ</mi>
    <mi>q</mi> <mn>2</mn></msubsup> <mo>)</mo></mrow> <mo>×</mo> <msubsup><mi>σ</mi>
    <mi>e</mi> <mn>2</mn></msubsup></mrow></math>
- en: So both the mean and variance of an MA process are constant with time regardless
    of the parameter values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论参数值如何，MA 过程的均值和方差都是随时间恒定的。
- en: Selecting parameters for an MA(q) process
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 MA(q) 过程选择参数
- en: 'We fit an MA model to the same data used fit to AR model, and we can use the
    ACF to determine the order of the MA process (see [Figure 6-7](#fig-0607)). Before
    reading on, think about how an MA process works and see if you can reason out
    why we use the ACF rather than the PACF to determine the order of the process:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对同样的数据拟合了一个 MA 模型，可以使用 ACF 来确定 MA 过程的阶数（见 [Figure 6-7](#fig-0607)）。在继续阅读之前，请考虑一下
    MA 过程的工作原理，并看看是否能理解为什么我们使用 ACF 而不是 PACF 来确定过程的阶数：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](assets/ptsa_0607.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0607.png)'
- en: Figure 6-7\. We use the ACF of the demand time series to determine the order
    of the MA model.
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 我们使用需求时间序列的 ACF 来确定 MA 模型的阶数。
- en: ACF and PACF Patterns Differ from MA and AR Processes
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACF 和 PACF 模式与 MA 和 AR 过程不同。
- en: Unlike an autoregressive process, which has a slowly decaying ACF, the definition
    of the MA process ensures a sharp cutoff of the ACF for any value greater than
    *q*, the order of the MA process. This is because an autoregressive process depends
    on previous terms, and they incorporate previous impulses to the system, whereas
    an MA model, incorporating the impulses directly through their value, has a mechanism
    to stop the impulse propagation from progressing indefinitely.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于自回归过程，其自相关函数缓慢衰减，MA 过程的定义确保了对于大于 *q* 的任何值，自相关函数具有尖锐的截断。这是因为自回归过程依赖于先前的项，并且它们通过先前的冲击对系统进行了融入，而
    MA 模型则通过它们的值直接融入冲击，从而有一种机制可以阻止冲击传播无限期。
- en: 'We see significant values at lags 3 and 9, so we fit an MA model with these
    lags. We need to be careful that we don’t accidentally constrain the wrong coefficients
    to 0 in the model, which we can confirm by printing the display:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在滞后3和9处有显著的值，因此我们拟合了包含这些滞后的MA模型。我们需要注意，我们不要错误地将模型中的错系数约束为0，我们可以通过打印显示来确认：
- en: '[PRE10]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should also check our fit, as we did for the AR model, by plotting the ACF
    of the residuals of the model and, as a second, separate test of model performance,
    running the Ljung-Box test to check for overall randomness in any fit to the residuals.
    Note that the `Box.test()` input requires us to specify the number of degrees
    of freedom—that is, how many model parameters were free to be estimated rather
    than being constrained to a specific value. In this case, the free parameters
    were the intercept as well as the MA3 and MA9 terms:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该检查我们的拟合，就像我们对AR模型所做的那样，通过绘制模型残差的ACF，并作为模型性能的第二个单独测试，运行Ljung-Box测试以检查残差的整体随机性。请注意，`Box.test()`的输入要求我们指定自由度的数量，即可以估计的模型参数数量，而不是被约束为特定值的数量。在这种情况下，自由参数是截距以及MA3和MA9项：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We cannot reject the null hypothesis that there is no temporal correlation between
    residual points. Likewise, a plot of the ACF of the residuals suggests no temporal
    correlation (this is left as an exercise for the reader).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能拒绝无残差点之间的时间相关性的原假设。同样，残差的ACF图表明没有时间相关性（这留作读者的练习）。
- en: Forecasting an MA(q) process
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预测一个MA(q)过程
- en: 'We can generate a forecast again using the techniques shown earlier for an
    AR process, relying on the `fitted()` method of the `forecast` package:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用`forecast`包的`fitted()`方法生成预测，这是用于AR过程的技术：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: MA models exhibit strong mean reversion and so forecasts rapidly converge to
    the mean of the process. This makes sense given that the process is considered
    to be a function of white noise.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: MA模型表现出强烈的均值回归，因此预测迅速收敛到过程的均值。这是合理的，因为该过程被认为是白噪声的函数。
- en: 'If you forecast beyond the range of the model established by its order, the
    forecast will necessarily be the mean of the process by definition of the process.
    Consider an MA(1) model:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您预测超出模型通过其顺序建立的范围，则预测将根据过程的定义必然是过程的均值。考虑一个MA(1)模型：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo>
    <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo>
    <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <mi>μ</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo>
    <msub><mi>e</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub> <mo>+</mo>
    <msub><mi>e</mi> <mi>t</mi></msub></mrow></math>
- en: 'To predict one time step in the future, our estimate for *y*[*t*+1] is <math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mi>t</mi></msub> <mo>+</mo> <msub><mi>e</mi>
    <mi>t</mi></msub></mrow></math> . If we want to predict two time steps in the
    future, our estimate is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要预测未来一个时间步长，我们对*y*[*t*+1]的估计是 <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mi>t</mi></msub>
    <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub></mrow></math> 。如果我们想预测未来两个时间步长，我们的估计是：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>=</mo>
    <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <mo>;</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mi>μ</mi> <mo>+</mo> <mn>0</mn> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mn>0</mn> <mo>=</mo> <mi>μ</mi></mrow></math>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi> <mrow><mo>(</mo>
    <msub><mi>y</mi> <mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub> <mo>=</mo>
    <mi>μ</mi> <mo>+</mo> <msub><mi>e</mi> <mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mo>×</mo> <mo>;</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub> <mo>)</mo></mrow> <mo>=</mo>
    <mi>μ</mi> <mo>+</mo> <mn>0</mn> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <mo>×</mo> <mn>0</mn> <mo>=</mo> <mi>μ</mi></mrow></math>
- en: With an MA(1) process we cannot offer an informed prediction beyond one step
    ahead, and for an MA(*q*) process in general we cannot offer a more informed prediction
    beyond *q* steps than the mean value emitted by the process. By *informed* prediction,
    I mean one in which our most recent measurements have an impact on the forecast.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MA(1)过程，我们无法在一步之后提供有根据的预测，对于一般的MA(*q*)过程，我们不能在比过程发射的均值更有根据地提供超过*q*步的预测。通过“有根据的”预测，我指的是我们最近的测量对预测的影响。
- en: Traditional Notation Is Negative
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统符号为负
- en: Note that the MA model is not typically written as it was here. Traditionally,
    the sign in front of the theta coefficients is negative. This is for reasons of
    how it can be derived, and one way to think about an MA model is as an AR model
    with constraints on its parameters. This formulation, with a lot of algebra, leads
    to negative coefficients on the theta.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MA模型通常不像这里描述的那样编写。传统上，θ系数前的符号是负的。这是由于推导的原因，而将MA模型视为AR模型并对其参数施加约束的一种方式。这种公式，通过大量的代数运算，导致θ的系数为负。
- en: 'We can see this by producing predictions with our MA(9) model that we just
    fit, and for which we now seek predictions 10 time steps ahead:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们刚刚拟合的MA(9)模型生成预测，我们现在寻求未来10个时间步长的预测：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we attempt to predict 10 time steps into the future, we predict the mean
    for every time step. We could have done that without a fancy statistical model!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图预测未来的10个时间步长时，我们预测每个时间步长的均值。即使没有花哨的统计模型，我们也可以做到这一点！
- en: Common sense is important. If you apply a model without understanding how it
    works, you can do embarrassing things such as sending your boss the exact same
    forecast every day after you wasted previous time and computing resources chugging
    out a model inappropriate to the question you are asking.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 常识很重要。如果你在不理解其工作原理的情况下应用模型，可能会出现一些令人尴尬的事情，比如在你浪费了先前的时间和计算资源后，每天都向老板发送完全相同的预测。
- en: Autoregressive Integrated Moving Average Models
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自回归积分移动平均模型
- en: Now we that we have examined AR and MA models individually, we look to the Autoregressive
    Integrated Moving Average (ARIMA) model, which combines these, recognizing that
    the same time series can have both underlying AR and MA model dynamics. This alone
    would lead us to an ARMA model, but we extend to the ARIMA model, which accounts
    for differencing, a way of removing trends and rendering a time series stationary.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分别检验了AR和MA模型，我们转向自回归积分移动平均（ARIMA）模型，该模型结合了这两者，认识到同一时间序列可能具有同时存在的AR和MA模型动态。这本身将导致一个ARMA模型，但我们扩展到ARIMA模型，它考虑了差分，一种去除趋势并使时间序列平稳的方法。
- en: ARIMA models continue to deliver near state-of-the-art performance, particularly
    in cases of small data sets where more sophisticated machine learning or deep
    learning models are not at their best. However, even ARIMA models pose the danger
    of overfitting despite their relative simplicity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型继续在性能上保持接近最先进的状态，特别是在数据集较小的情况下，更复杂的机器学习或深度学习模型表现不佳的情况下。然而，即使是ARIMA模型，尽管相对简单，也存在过拟合的危险。
- en: The model
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'You are probably scratching your head at this point if you’ve been paying attention
    because I’ve just fit the same data to both an AR and an MA process without commenting
    on it. This is the sort of irritating habit you may sometimes run into in time
    series analysis textbooks. Some authors will cop to this data laziness, while
    others will blandly ignore it. We have not investigated in depth whether either
    of our previous models is a particularly good fit, but it does seem clear from
    the fitting process we used that there are defensible arguments to describing
    the data with either an AR or an MA model. This raises the question: might it
    not be helpful to incorporate both behaviors into the same model?'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在认真关注，那么此时你可能会摸不着头脑，因为我刚刚将同样的数据拟合到了AR和MA过程中，却没有加以评论。这是你在时间序列分析教材中有时会遇到的令人恼火的习惯。一些作者会承认这种数据的懒惰，而其他人则会漠然地忽视它。我们并没有深入调查我们之前的模型是否特别合适，但从我们使用的拟合过程中，似乎清楚地表明可以用AR或MA模型描述数据是有辩护理由的。这引发了一个问题：将这两种行为结合到同一个模型中是否有帮助？
- en: '[Table 6-1](#table-0601) can be a handy way of examining a time series process
    to see whether an AR, MA, or ARMA description of the process is best.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 6-1](#table-0601) 可以是检查时间序列过程的一个方便方法，以确定AR、MA或ARMA描述的最佳模型。'
- en: Table 6-1\. Determining which model best describes our time series
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 6-1\. 确定最佳描述我们时间序列的模型
- en: '| Kind of plot | AR(p) | MA(q) | ARMA |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 绘图类型 | AR(p) | MA(q) | ARMA |'
- en: '| --- | --- | --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ACF behavior | Falls off slowly | Sharp drop after lag = *q* | No sharp cutoff
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| ACF行为 | 缓慢下降 | 滞后 = *q*后急剧下降 | 无急剧截断 |'
- en: '| PACF behavior | Sharp drop after lag = p | Falls off slowly | No sharp cutoff
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| PACF行为 | 滞后 = p后急剧下降 | 缓慢下降 | 无急剧截断 |'
- en: This brings us to an autoregressive moving average (ARMA) model, which is applied
    in the case that neither AR nor MA terms alone sufficiently describe the empirical
    dynamics. This is a likely case when diagnostics for AR and MA order statistics
    (PACF and ACF, respectively) point to nonzero values, indicating a term of a given
    order for either an AR or an MA term. These can be combined with an ARMA model.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们引向自回归移动平均（ARMA）模型，该模型适用于当AR和MA项单独描述的情况不足以充分描述经验动态时。这是一个常见情况，当AR和MA的诊断统计（PACF和ACF）指向非零值时，表明某个阶数的AR或MA项。这些可以结合到ARMA模型中。
- en: Wold’s Theorem
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沃尔德定理
- en: Wold’s theorem tells us that every covariance-stationary time series can be
    written as the sum of two time series, one deterministic and one stochastic. Based
    on this theorem, we can also say that a stationary process can be reasonably approximated
    by an ARMA model, although it can of course be quite difficult to find the appropriate
    model.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 沃尔德定理告诉我们，每个协方差平稳时间序列可以被写成两个时间序列的和，一个确定性的和一个随机的。根据这个定理，我们也可以说，一个平稳过程可以被ARMA模型合理地近似，尽管找到适当的模型当然可能相当困难。
- en: 'Here we switch to more traditional statistics notation by applying negative
    signs to the MA process coefficients:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过对MA过程系数应用负号来切换到更传统的统计符号表示方式：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <mo>∑</mo> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mi>i</mi></msub> <mo>×</mo> <mo>;</mo> <msub><mi>r</mi> <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>–</mo> <mo>∑</mo>
    <mrow><mo>(</mo> <msub><mi>θ</mi> <mi>i</mi></msub> <mo>×</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mi>t</mi></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <mo>∑</mo> <mrow><mo>(</mo>
    <msub><mi>ϕ</mi> <mi>i</mi></msub> <mo>×</mo> <mo>;</mo> <msub><mi>r</mi> <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub>
    <mo>)</mo></mrow> <mo>+</mo> <msub><mi>e</mi> <mi>t</mi></msub> <mo>–</mo> <mo>∑</mo>
    <mrow><mo>(</mo> <msub><mi>θ</mi> <mi>i</mi></msub> <mo>×</mo> <msub><mi>e</mi>
    <mrow><mi>t</mi><mo>-</mo><mi>i</mi></mrow></msub> <mo>)</mo></mrow></mrow></math>
- en: The stationarity of the ARMA process comes down to the stationarity of its AR
    component and is controlled by the same characteristic equation that controls
    whether an AR model is stationary.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ARMA过程的平稳性取决于其AR组分的平稳性，并由相同的特征方程控制，该特征方程决定了AR模型是否平稳。
- en: From an ARMA model, it is a simple transition to an ARIMA model. The difference
    between an ARMA model and an ARIMA model is that the ARIMA model includes the
    term *integrated*, which refers to how many times the modeled time series must
    be differenced to produce stationarity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从ARMA模型到ARIMA模型的转变非常简单。ARIMA模型与ARMA模型的区别在于ARIMA模型包括“整合”术语，这指的是模拟时间序列必须进行多少次差分以产生平稳性。
- en: 'ARIMA models are far more widely deployed in practice, particularly in academic
    research and forecasting problems, than are AR, MA, and ARMA models. A quick Google
    scholar search reveals ARIMA applied to a variety of forecasting problems including:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型在实践中被广泛应用，特别是在学术研究和预测问题中，远远超过了AR、MA和ARMA模型。快速的Google学者搜索显示ARIMA被应用于各种预测问题，包括：
- en: Inbound air travel passengers to Taiwan
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往台湾的入境航空旅客
- en: Energy demand in Turkey by fuel type
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 土耳其能源需求按燃料类型
- en: Daily sales in a wholesale vegetable market in India
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 印度批发蔬菜市场的日销售量
- en: Emergency room demand in the western United States
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国西部的急诊室需求
- en: Importantly, the order of differencing should not be too great. In general,
    the value of each parameter of an ARIMA(*p, d, q*) model should be kept as small
    as possible to avoid unwarranted complexity and overfitting to the sample data.
    As a not-at-all-universal rule of thumb, you should be quite skeptical of values
    of *d* over 2 and values of *p* and *q* over 5 or so. Also, you should expect
    either the *p* or *q* term to dominate and the other to be relatively small. These
    are practitioner notes gathered from analysts and not hard-and-fast mathematical
    truths.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，差分的次数不应过大。一般来说，ARIMA（*p, d, q*）模型的每个参数值都应尽可能保持较小，以避免不必要的复杂性和对样本数据的过度拟合。作为一个并非普遍适用的经验法则，你应对*d*超过2和*p*和*q*超过5或左右持怀疑态度。此外，你应该预计*p*或*q*项将主导，并且另一个将相对较小。这些都是从分析师那里收集到的实践者笔记，并非硬性数学真理。
- en: Selecting parameters
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择参数
- en: The ARIMA model is specified in terms of the parameters (*p, d, q*). We select
    the values of *p*, *d*, and *q* that are appropriate given the data we have.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型在参数（*p, d, q*）方面进行规定。我们根据手头的数据选择合适的*p, d,*和*q*值。
- en: 'Here are some well-known examples from the Wikipedia description of ARIMA models:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是维基百科描述ARIMA模型的一些知名示例：
- en: ARIMA(0, 0, 0) is a white noise model.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(0, 0, 0)是一个白噪声模型。
- en: ARIMA(0, 1, 0) is a random walk, and ARIMA(0, 1, 0) with a nonzero constant
    is a random walk with drift.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(0, 1, 0)是一个随机游走，带非零常数的ARIMA(0, 1, 0)是带漂移的随机游走。
- en: ARIMA(0, 1, 1) is an exponential smoothing model, and an ARIMA(0, 2, 2) is the
    same as Holt’s linear method, which extends exponential smoothing to data with
    a trend, so that it can be used to forecast data with an underlying trend.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARIMA(0, 1, 1)是指数平滑模型，ARIMA(0, 2, 2)与Holt线性方法相同，将指数平滑扩展到带趋势的数据，以便用于具有潜在趋势的数据预测。
- en: We choose the order of our model based on a combination of domain knowledge,
    various fitting evaluation metrics (such as the AIC), and general knowledge of
    how the PACF and ACF should appear for a given underlying process (as described
    in [Table 6-1](#table-0601)). Next we will demonstrate fitting an ARIMA model
    to a process using both a manual iterative process based on the PACF and ACF and
    also based on an automated parameter selection tool via the `forecast` package’s
    `auto.arima()` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据领域知识的结合、各种拟合评估指标（如AIC）以及对给定基础过程的PACF和ACF应如何出现的一般知识（如[表6-1](#table-0601)中描述的）来选择我们模型的顺序。接下来，我们将展示如何使用基于PACF和ACF的手动迭代过程以及基于`forecast`包的`auto.arima()`函数的自动参数选择工具来拟合ARIMA模型。
- en: Manually fitting a model
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动拟合模型
- en: 'There are heuristics for choosing the parameters of an ARIMA model, where *parsimony
    is paramount*. One popular and longstanding method is the Box-Jenkins method,
    which is an iterative multistep process:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有关选择ARIMA模型参数的启发法则，其中“简洁性至上”是首要考虑的。一个流行且长期存在的方法是Box-Jenkins方法，这是一个迭代的多步骤过程：
- en: Use your data, visualizations, and underlying knowledge to select a class of
    model appropriate to your data.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用你的数据、可视化和基础知识来选择适合你数据的模型类别。
- en: Estimate the parameters given your training data.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的训练数据估计参数。
- en: Evaluate the performance of your model based on your training data and tweak
    the parameters of the model to address the weaknesses you see in the performance
    diagnostics.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据训练数据评估你的模型性能，并调整模型参数以解决性能诊断中发现的弱点。
- en: 'Let’s work through one example of fitting data. First, we need some data. In
    this case, for purposes of transparency and knowing the right answer, we generate
    our data from an ARMA process:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个拟合数据的例子来逐步进行。首先，我们需要一些数据。在这种情况下，为了透明和知道正确答案，我们从ARMA过程生成我们的数据：
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try not to look at the order of the model created just yet; let’s focus on treating
    this as a mystery. First, we should plot the time series, as we always do, to
    see whether it appears stationary ([Figure 6-8](#fig-0608)). Then we examine the
    ACF and PACF of *y* ([Figure 6-9](#fig-0609)) and compare it with [Table 6-1](#table-0601).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要关注创建的模型顺序；让我们把这当作一个谜题来解决。首先，我们应该绘制时间序列，正如我们总是做的，看它是否呈现稳态（[图 6-8](#fig-0608)）。然后，我们检查*y*的ACF和PACF（[图 6-9](#fig-0609)），并与[表 6-1](#table-0601)
    进行比较。
- en: '![](assets/ptsa_0608.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0608.png)'
- en: Figure 6-8\. Plot of our time series.
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. 我们时间序列的绘图。
- en: '![](assets/ptsa_0609.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0609.png)'
- en: Figure 6-9\. ACF and PACF of our time series.
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 我们时间序列的ACF和PACF。
- en: 'We can see that neither the ACF nor the PACF appears to have a sharp cutoff,
    suggesting (see [Table 6-1](#table-0601)) that this is an ARMA process. We start
    by fitting a relatively simple ARIMA(1, 0, 1) model, as we see no need for differencing
    and no evidence ([Figure 6-10](#fig-0610)):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，无论是ACF还是PACF都没有明显的截尾，这表明（见[表 6-1](#table-0601)），这是一个ARMA过程。我们首先拟合一个相对简单的ARIMA(1,
    0, 1)模型，因为我们看不到差分的必要性，也没有证据（[图 6-10](#fig-0610)）。
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](assets/ptsa_0610.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0610.png)'
- en: Figure 6-10\. ACF and PACF of the residuals of an ARIMA(1, 0, 1) model.
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-10\. ARIMA(1, 0, 1)模型残差的ACF和PACF。
- en: 'The residuals in [Figure 6-10](#fig-0610) show particularly large PACF values,
    suggesting that we have not fully described the autoregressive behavior. For this
    reason, we build out the model by adding a higher-order AR component, testing
    an ARIMA(2, 0, 1) model in the following code, and then plotting the ACF and PACF
    of the residuals of this more complex model ([Figure 6-11](#fig-0611)):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-10](#fig-0610) 中的残差显示出特别大的PACF值，表明我们还没有完全描述自回归行为。因此，我们通过添加更高阶的AR分量来扩展模型，在下面的代码中测试ARIMA(2,
    0, 1)模型，并绘制此更复杂模型残差的ACF和PACF（[图 6-11](#fig-0611)）：'
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](assets/ptsa_0611.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0611.png)'
- en: Figure 6-11\. ACF and PACF of the residuals of an ARIMA(2, 0, 1) model.
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-11\. ARIMA(2, 0, 1)模型残差的ACF和PACF。
- en: 'The residuals in [Figure 6-11](#fig-0611) no longer show large values for either
    the ACF or the PACF. Given our desire for a parsimonious model and the dangers
    of overfitting an ARIMA model, a wise analyst would likely stop here, not seeing
    any further behavior in the residuals that needs to be fit via an autoregressive,
    moving average, or differencing component. It is left as an exercise for the reader
    to consider fitting more complicated models. Though the plots are not shown here,
    I attempted with the following code to fit more complex models. What I saw was
    that they did not substantially improve the fit of the model to the data, nor
    did they contribute to diminishing the ACF or PACF values any further than the
    previous model. You can verify this for yourself:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-11](#fig-0611) 中的残差再也不显示ACF或PACF的大值了。考虑到我们对一个简约模型的渴望以及过度拟合ARIMA模型的危险，一个明智的分析师可能会停在这里，因为在残差中没有进一步需要通过自回归、移动平均或差分组件进行拟合的行为。留给读者作为练习来考虑拟合更复杂的模型。尽管这里没有展示图形，我尝试用以下代码拟合更复杂的模型。我看到它们并没有显著改进模型与数据的拟合，也没有比前一个模型进一步降低ACF或PACF值。你可以自行验证：'
- en: '[PRE17]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One quick way of comparing the models is shown here, where I look at how well
    the forecasts from a fitted model correlate to the actual values:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速比较模型的方法在这里展示，我看看拟合模型的预测与实际值的相关性有多好：
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see a substantial improvement transitioning from an ARIMA(1, 0, 1) model
    to an ARIMA(2, 0, 1) model (the first two models), as the correlation goes from
    0.3 to 0.47\. On the other hand, as we add more complexity, we do not see substantial
    improvements in the correlation. This offers additional support for the conclusion
    we drew earlier that the ARIMA(2, 0, 1) model seemed to describe the model behavior
    well and that there was no need to add further AR or MA components to improve
    the fit.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从ARIMA(1, 0, 1)模型转换到ARIMA(2, 0, 1)模型（前两个模型）后，我们看到了显著的改善，相关性从0.3增加到了0.47。另一方面，随着我们增加复杂性，相关性并没有显著提高。这进一步支持了我们早前得出的结论，即ARIMA(2,
    0, 1)模型似乎很好地描述了模型行为，并且没有必要添加更多的AR或MA分量来改善拟合。
- en: 'Incidentally, we can see how well the fit did below, by comparing the original
    fit coefficients (shown here, though obscured before) with the fit coefficients:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们可以通过比较原始拟合系数（此处显示，之前被掩盖）与拟合系数来看一下拟合效果：
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is a good match between the fitted coefficients and the actual coefficients
    used to simulate the data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合系数与用于模拟数据的实际系数之间存在良好的匹配。
- en: There is more to fitting an ARIMA model manually than we have demonstrated here.
    Over decades, practitioners have developed good rules of thumb for identifying
    problems such as when there are too many terms of a certain kind, when a model
    has been overdifferenced, when the pattern in residuals points to certain problems,
    and so on. One good starting resource is a guide written by a Penn State professor
    available [online](https://perma.cc/P9BK-764B).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 手动拟合ARIMA模型不仅仅是我们在这里展示的那样简单。几十年来，从业者们已经发展出了一些好的经验法则，用于识别问题，例如当某种类型的项过多时，当模型被过度差分时，当残差模式指向特定问题时等等。一个很好的起步资源是宾夕法尼亚州立大学一位教授编写的在线指南，可在[此处](https://perma.cc/P9BK-764B)获取。
- en: There are some legitimate criticisms of fitting an ARIMA process “by hand.”
    Fitting by hand can be a somewhat poorly specified process and puts a lot of pressure
    on the analyst’s discretion, and can be time-consuming and path-dependent as to
    the ultimate outcome. It’s a good solution that has worked well for decades to
    produce actual forecasts used in the real world, but it’s not perfect.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些对手动拟合ARIMA过程的合理批评。手动拟合可能是一个定义不太清晰的过程，对分析师的判断力施加了很大压力，并且可能耗时且最终结果依赖路径。几十年来，这是一个表现良好的解决方案，用于生成实际世界中使用的预测，但并非完美。
- en: Using automated model fitting
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用自动模型拟合
- en: 'Nowadays we can get away from a manually iterative fitting process in favor
    of an automated model selection in some cases. Our model selection can be driven
    according to various information loss criteria, such as the AIC we discussed briefly
    via the `auto.arima()` function in the `forecast` package:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在某些情况下，我们可以放弃手动迭代拟合过程，转而采用自动模型选择。我们的模型选择可以根据各种信息损失准则进行驱动，例如我们通过`forecast`包中的`auto.arima()`函数简要讨论的AIC：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case we put a one-liner with some prior knowledge from our earlier exploration
    into configuring the inputs. Namely, we specified the maximum order of the AR
    and MA process that we were prepared to accept, and in fact the model selection
    chose a much more parsimonious model than we specified, including no AR terms
    at all. Nonetheless, this model fits well, and we shouldn’t data-snoop too much
    trying to beat it unless we have a principled reason for doing so. Note that according
    to the AIC criteria, our hand-chosen MA model in the previous section does just
    slightly better than this model, but the difference does not seem meaningful when
    we look at plots.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过比较我们早期探索中的一行配置输入的先验知识，来放置了一个一行描述。换句话说，我们指定了AR和MA过程的最大阶数，我们准备接受的，实际上，模型选择选择了一个比我们指定的更加简洁的模型，包括没有AR项。尽管如此，这个模型拟合效果很好，除非我们有充分的理由这样做，否则我们不应该过多地对数据进行窥探。请注意，根据AIC标准，我们在前一节手动选择的MA模型略优于这个模型，但当我们查看图表时，这种差异似乎不具有意义。
- en: Left for an exercise for the reader is plotting the model against the predictions
    as well as checking the residuals of this automatically selected model and confirming
    that the model used does not appear to leave any residual behavior that needs
    to be addressed by the addition of more terms. The code is no different from what
    we have used in the previous AR and MA sections. This is also true for the case
    of making forecasts, and so that is omitted here given that the ARIMA model we
    selected is not very different from the MA model discussed and used for a forecast
    earlier.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 留给读者的练习是将模型绘制为预测的模型，以及检查这个自动选择的模型的残差，并确认使用的模型似乎没有留下需要通过增加更多项来解决的残差行为。代码与我们在之前的AR和MA部分使用的代码没有区别。对于制作预测的情况也是如此，因此在此处省略了，因为我们选择的ARIMA模型与之前讨论和用于预测的MA模型并没有太大不同。
- en: 'We can also quickly study how `auto.arima()` would have performed on the model
    we generated in the previous section when we fit the model by hand:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以快速研究当我们手动拟合模型时，`auto.arima()`在我们在上一节中生成的模型上的表现如何：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We did not even use the optional parameters to suggest to `auto.arima()` where
    it should start its model search, and yet it converged to the same solution as
    we did. So, as we can see here, in some cases we will find the same solution with
    different methodologies. We drove our analysis by looking at the ACF and PACF
    of the residuals of simpler models to build more complex models, whereas `auto.arima()`
    is largely driven by a grid search to minimize the AIC. Of course, given that
    we generated the original data from an ARIMA process, this represents a more straightforward
    case than much real-world data. In the latter case, it won’t always be true that
    our manual fits and the automated model selection come to the same conclusion.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有使用`auto.arima()`的可选参数建议模型搜索从哪里开始，但它却收敛到了与我们相同的解决方案。因此，正如我们在这里所看到的，在某些情况下，我们会发现不同方法得出相同的解决方案。我们通过查看更简单模型的残差的ACF和PACF来驱动我们的分析，以构建更复杂的模型，而`auto.arima()`主要通过网格搜索来最小化AIC来驱动。当然，鉴于我们是从ARIMA过程生成原始数据，这代表了一个比许多现实数据更简单的情况。在后一种情况下，并不总是我们的手动拟合和自动模型选择得出相同的结论。
- en: If you are going to make `auto.arima()` or a similar automated model selection
    tool an important part of your analysis, it’s important to read the documentation,
    experiment with synthetic data, and also read about other analysts’ experiences
    with this function. There are some known scenarios where the function will not
    perform as naively expected, and there are also known workarounds. Overall this
    is an excellent solution but not a perfect one.^([4](ch06.html#idm45576035870200))
    Also, for a good description of how `auto.arima()` works, take a look at the [online
    textbook chapter on this topic](https://perma.cc/P92B-6QXR) written by the author
    of the function, Professor Rob Hyndman.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`auto.arima()`或类似的自动模型选择工具作为分析的重要组成部分，重要的是要阅读文档，尝试合成数据，并阅读其他分析师对此函数的使用经验。已知存在一些情况，该函数的表现不如预期简单，并且已知有一些解决方法。总体而言，这是一个很好的解决方案，但并不完美。^([4](ch06.html#idm45576035870200))
    另外，关于`auto.arima()`的工作方式的良好描述，请参阅该主题的[在线教科书章节](https://perma.cc/P92B-6QXR)，该章节由该函数的作者罗布·亨德曼教授撰写。
- en: 'We have demonstrated two distinct ways of estimating parameters: either by
    following a Box-Jenkins approach to fitting the model or using an automated fit
    from the `forecast` package. In fact, practitioners have very strong opinions
    on this, with some fiercely advocating only in favor of manual iteration and others
    equally fiercely in favor of automated selection tools. This remains an ongoing
    debate in the field. In the long run, as big data takes over more and more of
    time series analysis, it is likely that automatic exploration and fitting of models
    will come to dominate large data set time series analysis.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了两种不同的参数估计方式：要么遵循Box-Jenkins方法来拟合模型，要么使用`forecast`包中的自动拟合。实际上，从业者对此有很强烈的意见，有些人激烈主张只支持手动迭代，而另一些人则坚决支持自动选择工具。这仍然是该领域的一个持续争论。从长远来看，随着大数据在时间序列分析中占据越来越多的地位，自动探索和模型拟合可能会主导大数据集时间序列分析。
- en: Vector Autoregression
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量自回归
- en: In the real world, we are often lucky enough to have several time series in
    parallel that are presumably related to one another. We already examined how to
    clean and align such data, and now we can learn how to make maximal use of it.
    We can do so by generating an AR(*p*) model to the case of multiple variables.
    The beauty of such a model is that it provides for the fact that variables both
    influence one another and are in turn influenced—that is, there is no privileged
    *y* while everything else is designated as *x*. Instead, the fitting is symmetric
    with respect to all variables. Note that differencing can be applied as is in
    other models previously if the series are not stationary.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们经常很幸运地有几个平行的时间序列，这些序列可能相互关联。我们已经探讨了如何清理和对齐这些数据，现在我们可以学习如何最大化利用它们。我们可以通过将AR(*p*)模型推广到多变量的情况来做到这一点。这种模型的美妙之处在于它考虑了变量相互影响并相互影响——也就是说，并不存在一个特权的*y*，而其他所有变量都被指定为*x*。相反，拟合是对所有变量对称的。请注意，如果系列不是平稳的，可以像以前的其他模型一样应用差分。
- en: Exogenous and Endogenous Variables
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外生和内生变量
- en: In statistical speak, once we employ a model where the variables influence one
    another, we call those variables *endogenous*, meaning their values are explained
    by what we see within the model. By contrast, *exogenous* variables are those
    that are not explained within the model—that is, they cannot be explained by assumption—and
    so we accept their values and do not question the dynamics of how they came to
    be.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，一旦我们采用了变量相互影响的模型，我们称这些变量为*内生变量*，意味着它们的值由模型内部的内容解释。相反，*外生变量*是那些在模型内部无法解释的变量——也就是说，它们的值不能通过假设来解释，因此我们接受它们的值，不质疑它们产生的动态过程。
- en: 'Since every time series putatively predicts every other as well as itself,
    we will have one equation per variable. Let’s say we have three time series: we
    will denote the value of these time series at time *t* as *y*[1, *t*] and *y*[2,
    *t*] and *y*[3, *t*]. Then we can write the vector autoregression (VAR) equations
    of order 2 (factoring in two time lags) as:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个时间序列都被认为预测其他时间序列以及自身，我们将为每个变量拥有一个方程。假设我们有三个时间序列：我们将这些时间序列在时间*t*的值表示为*y*[1,
    *t*]、*y*[2, *t*]和*y*[3, *t*]。然后，我们可以将二阶（考虑两个时间滞后）向量自回归（VAR）方程写为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>01</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>11</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>12</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>13</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>11</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>12</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>13</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>01</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>11</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>12</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>13</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>11</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>12</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>13</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>02</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>21</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>22</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>23</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>21</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>22</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>23</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>02</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>21</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>22</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>23</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>21</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>22</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>23</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>03</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>31</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>32</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>33</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>31</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>32</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>33</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi></mrow></msub>
    <mo>=</mo> <msub><mi>ϕ</mi> <mn>03</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>31</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>32</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>33</mn><mo>,</mo><mn>1</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>31</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>1</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>32</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>2</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mrow><mn>33</mn><mo>,</mo><mn>2</mn></mrow></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mn>3</mn><mo>,</mo><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
- en: Matrix Multiplication
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: 'As you will have noticed if you are familiar with linear algebra, expressing
    the relationships shown in the three previous equations is much simpler when you
    are using matrix notation. In particular, you can write a VAR in a very similar
    manner to an AR. In the matrix form, the three equations could be expressed as:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉线性代数，你会注意到，在矩阵表示法中，表达前面三个方程中显示的关系要简单得多。特别是，你可以以非常类似的方式编写VAR。在矩阵形式中，这三个方程可以表示为：
- en: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi> <mo>=</mo>
    <msub><mi>ϕ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>ϕ</mi> <mn>1</mn></msub>
    <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>ϕ</mi> <mn>2</mn></msub> <mo>×</mo> <msub><mi>y</mi> <mrow><mi>t</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
- en: where the *y* and *ϕ[0]* are 3 × 1 matrices, and the other *ϕ* matrices are
    3 × 3 matrices.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*y*和*ϕ[0]*是3 × 1矩阵，而其他*ϕ*矩阵是3 × 3矩阵。
- en: Even for a simple case, you can see that the number of parameters in the model
    grows very quickly. For example, if we have *p* lags and *N* variables, we can
    see that the predictor equation for each variable is <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn>
    <mo>+</mo> <mi>p</mi> <mo>×</mo> <mi>N</mi></mrow></math> values. Since we have
    *N* values to predict, this translates to <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi>
    <mo>+</mo> <mi>p</mi> <mo>×</mo> <msup><mi>N</mi> <mn>2</mn></msup></mrow></math>
    total variables, meaning that the number of variables grows in <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi>
    <mo>(</mo> <msup><mi>N</mi> <mn>2</mn></msup> <mo>)</mo></mrow></math> proportion
    to the number of time series studied. Hence, we should not throw in time series
    gratuitously simply because we have the data but instead reserve this method for
    when we really expect a relationship.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是简单的情况，你也可以看到模型中的参数数量增长得非常快。例如，如果我们有*p*个滞后和*N*个变量，我们可以看到每个变量的预测方程为<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn>
    <mo>+</mo> <mi>p</mi> <mo>×</mo> <mi>N</mi></mrow></math>个值。由于我们有*N*个值要预测，这转化为<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>N</mi> <mo>+</mo> <mi>p</mi>
    <mo>×</mo> <msup><mi>N</mi> <mn>2</mn></msup></mrow></math>总变量，这意味着变量数量与研究的时间序列数量成<math
    xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi> <mo>(</mo> <msup><mi>N</mi>
    <mn>2</mn></msup> <mo>)</mo></mrow></math>比例增长。因此，我们不应仅仅因为有数据而随意引入时间序列，而应该将此方法保留给我们真正预期有关系的情况。
- en: VAR models are most often used in econometrics. They sometimes come under fire
    because they do not have any structure beyond the hypothesis that all values influence
    one another. It is precisely for this reason that the model’s goodness of fit
    can be difficult to assess. However, VAR models are still useful—for example,
    in testing whether one variable causes another variable. They are also useful
    for situations where a number of variables need to be forecasted and the analyst
    does not have domain knowledge to assert any particular kind of relationship.
    They can also sometimes be helpful in determining how much variance in a forecast
    of a value is attributable to its underlying “causes.”
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: VAR 模型最常用于计量经济学。它们有时会受到批评，因为除了所有值互相影响的假设外，它们没有任何结构。正是因为这个原因，模型的拟合优度可能很难评估。然而，VAR
    模型仍然很有用——例如，用于测试一个变量是否导致另一个变量。它们在需要预测多个变量并且分析师没有领域知识来确定任何特定关系的情况下，有时也会很有帮助。它们有时还可以帮助确定预测值的方差有多少归因于其基础“原因”。
- en: Here’s a quick demonstration. Let’s look at the underlying UCI demand information
    and consider using a second column to predict Banking orders (2) rather than just
    its own data (note that we will also predict that column due to the symmetric
    way in which the variables are treated). Let’s consider using orders from the
    traffic control sector. That sounds like it should be quite different, so it may
    provide a fairly independent source of information relative to the fiscal sector’s
    own past orders. We can also imagine that each column offers underlying information
    about how the economy is doing and whether demand will increase or decrease in
    the future.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速演示。让我们看看基础的UCI需求信息，并考虑使用第二列来预测银行订单 (2)，而不仅仅是它自己的数据（注意，由于对称处理变量的方式，我们也将预测该列）。让我们考虑使用来自交通控制部门的订单。听起来这应该是完全不同的，因此它可能提供相对于财政部门自身过去订单的相当独立的信息源。我们还可以想象，每列提供了有关经济状况以及未来需求增减的基础信息。
- en: 'To determine what parameters to use, we use the `vars` package, which comes
    with a `VARselect()` method:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定要使用的参数，我们使用 `vars` 包，该包带有 `VARselect()` 方法：
- en: '[PRE22]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see that the function provides a variety of information criteria to
    choose from. Also note that we indicated we wanted to fit a `"const"` term to
    accommodate a nonzero mean. We could also elect to fit a drift term or both or
    neither, but the `"const"` option seems the best fit for our data. Here we will
    start by looking at the three lags and see how that does:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该函数提供了各种信息准则供选择。还请注意，我们指出我们希望拟合一个 `"const"` 项来适应非零均值。我们还可以选择拟合漂移项，或者二者都不拟合，但是
    `"const"` 选项似乎最适合我们的数据。在这里，我们将从查看三个滞后开始，看看效果如何：
- en: '[PRE23]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code produces the plots shown in Figures [6-12](#fig-0612) and [6-13](#fig-0613).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成了图表显示在 [6-12](#fig-0612) 和 [6-13](#fig-0613) 中所示的图形。
- en: '![](assets/ptsa_0612.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0612.png)'
- en: Figure 6-12\. At the top we see the actual (solid) versus predicted (dashed)
    values for Banking orders (2), and at the bottom we see the same for the Banking
    orders (3). Interestingly, the top plot looks more like a typical forecast, where
    the forecast is somewhat “slow” in changing relative to the real data, whereas
    in the bottom plot we see the forecast actually predicted changes somewhat in
    advance of when they happen. This suggests that Banking orders (2) “lead” Banking
    orders (3), meaning that Banking orders (2) are helpful in predicting traffic
    controller orders, but possibly not the inverse, or at least not to such a degree.
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-12\. 在顶部，我们看到了银行订单 (2) 的实际值（实线）与预测值（虚线），在底部，我们看到了银行订单 (3) 的同样情况。有趣的是，顶部的图表更像是一个典型的预测，其中预测相对于实际数据的变化有些“缓慢”，而在底部的图表中，我们看到预测实际上提前预测了变化。这表明银行订单
    (2) “领先于” 银行订单 (3)，这意味着银行订单 (2) 在预测交通控制器订单方面是有帮助的，但可能不是反过来，或者至少不是在这种程度上。
- en: '![](assets/ptsa_0613.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0613.png)'
- en: Figure 6-13\. We plot the autocorrelation function of the residuals for each
    time series. Note that for both series there is some borderline significant autocorrelation
    of the errors at lag 3 that may not be fully accounted for in the model.
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-13\. 我们绘制了每个时间序列残差的自相关函数。请注意，对于两个序列，误差在滞后 3 处存在一些边缘显著的自相关，可能在模型中没有完全解释。
- en: 'The ACF is not as clearly supportive of no autocorrelation in the residuals
    as we might like, so in this case we can also apply the *Portmanteau test* for
    serial correlation via the `vars` package `serial.test()` method. This test is
    similar to the serial correlation tests we have looked at in the univariate case:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ACF并未如我们所希望地清楚地支持残差中的无自相关性，因此在这种情况下，我们还可以通过`vars`包的`serial.test()`方法应用*Portmanteau测试*来检验串行相关性。这个测试类似于我们在单变量情况下看到的串行相关性测试：
- en: '[PRE24]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because the *p*-value is so high, we cannot reject the null hypothesis that
    there is no serial correlation in the residuals. This gives us further evidence
    that the model does an acceptable job.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*p*值如此之高，我们无法拒绝不存在残差中串行相关的零假设。这为我们提供了进一步的证据，证明该模型做得相当不错。
- en: Given that for univariate models we examined a variety of models, leading up
    to the ARMA and ARIMA versions, you may wonder whether there is a VARIMA model.
    There is indeed, but it is not used very much given that VAR performs relatively
    well and is already quite complicated. In practice for industrial and academic
    use cases, you will overwhelmingly see the use of VAR rather than VARIMA.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于对于我们检验的单变量模型，我们逐步分析了各种模型，一直到ARMA和ARIMA版本，您可能会想知道是否存在VARIMA模型。确实存在，但由于VAR表现相对较好且已相当复杂，因此并不经常使用。在工业和学术用例中，您会发现使用VAR远远超过VARIMA的情况。
- en: Another related class of model is the CVAR model, which is the cointegrated
    vector autoregression. This refers to the case where the individual time series
    are not stationary, but a linear combination of the time series is stationary
    without differencing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的模型类是CVAR模型，即共整合向量自回归模型。这指的是个别时间序列不是平稳的，但时间序列的线性组合在不经过差分的情况下是平稳的。
- en: Variations on Statistical Models
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计模型的变体
- en: There are many other kinds of statistical models developed for time series data.
    Some of these expand the ARIMA model, while others make different underlying assumptions
    about the temporal dynamics than those used in the ARIMA model. In this section
    we briefly discuss some of the most commonly used and well-known statistical time
    series models.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多其他类型的针对时间序列数据开发的统计模型。其中一些扩展了ARIMA模型，而其他一些则对时间动态的基本假设与ARIMA模型不同。在本节中，我们简要讨论一些最常用和知名的统计时间序列模型。
- en: Seasonal ARIMA
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 季节性ARIMA
- en: A Seasonal ARIMA (SARIMA) model assumes multiplicative seasonality. For this
    reason, a SARIMA model can be expressed as ARIMA (*p, d, q*) × (*P, D, Q*)*m*.
    The model postulates that the seasonal behavior itself can be thought of as an
    ARIMA process, with *m* specifying the number of time steps per seasonal cycle.
    What is important in this factoring is that the model recognizes that adjacent
    points in time can have an influence on one another, either within the same season
    or in different seasons, but through the usual methods of being temporally proximate.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性ARIMA（SARIMA）模型假设存在乘法季节性。因此，SARIMA模型可以表示为ARIMA（*p, d, q*）×（*P, D, Q*）*m*。该模型假设季节性行为本身可以被视为ARIMA过程，*m*指定每个季节周期中的时间步数。在这个因子中重要的是，该模型认识到时间相邻点可以互相影响，无论是在同一个季节内还是在不同季节内，但通过通常的时间接近方法。
- en: Identifying a SARIMA is even trickier than identifying an ARIMA model precisely
    because you need to address seasonal effects. Luckily, `auto.arima()` in the `forecasts`
    package can handle this just as it handles a standard ARIMA estimation task. As
    discussed earlier, there are good reasons to go with automated parameter selection
    unless you have strong knowledge that suggests you override the selected model
    determined by automated methods.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 确定SARIMA甚至比确定ARIMA模型更加棘手，因为您需要处理季节效应。幸运的是，在`forecasts`包中的`auto.arima()`可以像处理标准ARIMA估计任务一样处理这一点。正如早些时候讨论的那样，除非您有强有力的知识表明需要覆盖自动方法确定的选择模型，否则有很多理由选择自动参数选择。
- en: ARCH, GARCH, and their many brethren
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ARCH、GARCH及其众多类似模型
- en: ARCH stands for “Autoregressive Conditional Heteroskedasticity.” This model
    is used almost exclusively in the finance industry. It is often covered in time
    series courses, so it is worth mentioning here. This class of models is based
    on the observation that stock prices do not have constant variance, and that in
    fact the variance itself seems autoregressive conditional on the earlier variances
    (for example, high-volatility days on the stock exchange come in clusters). In
    these models, it is the variance of a process that is modeled as an autoregressive
    process rather than the process itself.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ARCH代表“条件异方差自回归”，这种模型几乎专门用于金融行业。它经常出现在时间序列课程中，因此在这里值得一提。这类模型基于这样一个观察结果：股票价格的方差并非恒定，实际上方差本身在较早的方差条件下似乎是自回归的（例如，股票交易所的高波动日出现成簇）。在这些模型中，被建模的是过程的方差，而不是过程本身。
- en: Hierarchical time series models
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层时间序列模型
- en: 'Hierarchical time series are quite common in the real world, although they
    are not presented as such. You can easily formulate situations in which they can
    arise:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，分层时间序列非常常见，尽管它们并未以此形式呈现。你可以轻松地构想出它们可能出现的情况：
- en: Total dollar monthly demand for a company’s products, which can then be broken
    down by SKU number
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司产品的总月需求金额，然后可以按SKU编号进行细分。
- en: Weekly political polling data for the electorate as a whole, and then that same
    polling data broken down by demographics (overlapping or nonoverlapping), such
    as female versus male or Hispanic versus African American
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全体选民的每周政治民意调查数据，然后根据不同的人口统计学特征（重叠或非重叠），比如女性与男性，或者西班牙裔与非裔美国人。
- en: Total count of tourists landing in the EU daily versus counts of tourists landing
    in each member nation in particular
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天进入欧盟的游客总数与特定成员国每天进入的游客数量的总计
- en: One convenient way to handle hierarchical time series is via R’s `hts` package.
    This package can be used both to visualize hierarchical time series data and to
    generate forecasts.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 处理分层时间序列的一个方便的方法是通过R的`hts`包。这个包既可以用于可视化分层时间序列数据，也可以用于生成预测。
- en: 'Forecasts can be generated with a number of different methodologies that have
    historically been available with this package:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一些历史上已经在这个包中可用的不同方法生成预测：
- en: Generate the lowest-level forecasts (the most individualized) and aggregate
    these up to produce the higher-level forecasts.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成最低级的预测（最个性化的），然后将其汇总以生成更高级别的预测。
- en: Generate the highest-level forecasts and then generate lower-level forecasts
    based on the historical proportions of each component of the aggregate. This methodology
    tends to be less accurate at making low-level predictions, although this can be
    somewhat mitigated with a variety of techniques for predicting how proportions
    of the aggregate will themselves change over time.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成最高级别的预测，然后基于聚合每个组成部分的历史比例生成低级别的预测。这种方法在进行低级别预测时往往不太准确，尽管可以通过多种技术来预测聚合比例本身随时间的变化。
- en: It is possible to try to obtain the best of each methodology by choosing a “middle”
    approach where a mid-level forecast is generated (assuming you have several layers
    of hierarchy). This is then propagated up and down in generality to make the other
    predictions.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以尝试通过选择“中间”方法来获取每种方法的最佳效果，其中会生成中层预测（假设你有多层级）。然后在广义上向上下传播，以进行其他预测。
- en: Ultimately, the gold standard with the `hts` package is that, for all levels
    of hierarchy, forecasts can be generated that are independent of other levels
    of the hierarchy. `hts` then combines these forecasts to assure consistency in
    a method as per [Hyndman et al.](https://perma.cc/G4EG-6SMP).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`hts`包的黄金标准在于，可以为所有层次的分层生成独立的预测。然后`hts`结合这些预测，以保证方法的一致性，如[Hyndman et al.](https://perma.cc/G4EG-6SMP)中所述。
- en: Many of the statistical models we have discussed in this chapter would in turn
    be applied to the problem of forecasting whatever level of time series was settled
    upon. The hierarchical portion of the analysis tends to be a wrapper around these
    fundamental models.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章讨论的许多统计模型反过来又会应用于决定预测哪个层次的时间序列的问题。分层分析部分往往是围绕这些基础模型的一个包装器。
- en: Advantages and Disadvantages of Statistical Methods for Time Series
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列统计方法的优缺点
- en: When you are contemplating whether to apply one of the statistical models described
    here to a time series problem, it can be good to start with an inventory of advantages
    and disadvantages. These are laid out in this section.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在考虑是否将此处描述的某个统计模型应用于时间序列问题时，从优缺点的库存开始可能是个不错的方法。这些优缺点在本节中详细列出。
- en: Advantages
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 优点
- en: These models are simple and transparent, so they can be understood clearly in
    terms of their parameters.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些模型简单透明，因此可以清晰地理解其参数。
- en: Because of the simple mathematical expressions that define these models, it
    is possible to derive their properties of interest in a rigorous statistical way.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于定义这些模型的简单数学表达式，可以以严格的统计方式推导出它们的有趣属性。
- en: You can apply these models to fairly small data sets and still get good results.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将这些模型应用于相对较小的数据集，仍然可以获得良好的结果。
- en: These simple models and related modifications perform extremely well, even in
    comparison to very complicated machine learning models. So you get good performance
    without the danger of overfitting.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些简单模型及其相关修改表现非常出色，甚至与非常复杂的机器学习模型相比也不遑多让。因此，您可以在不过度拟合的情况下获得良好的性能。
- en: Well-developed automated methodologies for choosing orders of your models and
    estimating their parameters make it simple to generate these forecasts.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展模型的订单和估计其参数的自动化方法非常成熟，因此可以轻松生成这些预测。
- en: Disadvantages
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点
- en: Because these models are quite simple, they don’t always improve performance
    when given large data sets. If you are working with extremely large data sets,
    you may do better with the complex models of machine learning and neural network
    methodologies.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这些模型相当简单，因此在处理大数据集时并不总是能提升性能。如果您正在处理极大数据集，则可能更适合使用机器学习和神经网络方法的复杂模型。
- en: These statistical models put the focus on point estimates of the mean value
    of a distribution rather than on the distribution. True, you can derive sample
    variances and the like as some proxy for uncertainty in your forecasts, but your
    fundamental model offers only limited ways to express uncertainty relative to
    all the choices you make in selecting a model.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些统计模型侧重于分布的均值点估计，而不是分布本身。的确，您可以推导出样本方差等作为预测不确定性的某种替代，但您的基本模型只提供了有限的表达方式来相对于您在选择模型时所做的所有选择来表达不确定性。
- en: By definition, these models are not built to handle nonlinear dynamics and will
    do a poor job describing data where nonlinear relationships are dominant.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据定义，这些模型并非用于处理非线性动态，并且在描述非线性关系占主导地位的数据时表现不佳。
- en: More Resources
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: 'Classic texts:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典文本：
- en: 'Rob J. Hyndman and George Athanasopoulos, [*Forecasting: Principles and Practice*](https://perma.cc/9JNK-K6US),
    2nd ed. (Melbourne: OTexts, 2018), https://perma.cc/9JNK-K6US.'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 罗伯特·J·亨德曼和乔治·阿瑟纳索普洛斯，《*预测：原理与实践*》第二版（墨尔本：OTexts，2018），https://perma.cc/9JNK-K6US。
- en: This practical and highly accessible textbook offers an excellent introduction
    in R, for free, on the internet, of all the basics of preprocessing time series
    data and using that data to make forecasts. The emphasis is on getting readers
    up to speed and competent in using practical methods for time series forecasting.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本实用且极易接近的教科书免费介绍了在R中预处理时间序列数据的所有基础知识以及利用该数据进行预测的方法。重点是让读者迅速掌握并熟练使用时间序列预测的实用方法。
- en: 'Ruey Tsay, *Analysis of Financial Time Series* (Hoboken, NJ: John Wiley & Sons,
    2001).'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 蔡瑞，《*金融时间序列分析*》（霍博肯，新泽西州：约翰·威利·父子，2001）。
- en: This classic textbook introduces a variety of time series models, including
    a very thorough and accessible chapter on developing AR, MA, and ARIMA models,
    with applications to historical stock prices. Extensive R examples are also included.
    This is a middle-of-the-road book in terms of accessibility, presuming some familiarity
    with statistics and other mathematics but quite readable to anyone with high school
    calculus and an introductory statistics course under their belt.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本经典教材介绍了各种时间序列模型，包括对开发AR、MA和ARIMA模型的非常详尽和易于理解的章节，应用于历史股票价格。还包括大量的R实例。就可访问性而言，这是一本中等难度的书籍，假设读者具有某些统计学和其他数学知识，但对于已掌握高中微积分和入门统计学课程的任何人来说都是相当易读的。
- en: 'Robert H. Shumway, *Time Series Analysis and Its Applications* (NY, NY: Springer-International,
    2017).'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 罗伯特·H·舒姆韦，《*时间序列分析及其应用*》（纽约，纽约州：斯普林格国际，2017）。
- en: This is another classic textbook written at a somewhat more theoretical and
    less accessible level. It’s best to have a look at Tsay’s book first, but this
    book includes additional discussions of the mathematical processes of statistical
    time series models. It also includes a wider variety of data analysis stemming
    from the sciences as well as from economic data sources. This book is a more challenging
    read than the other textbooks listed, but this is because it is dense and informative
    and not because it requires a much higher level of mathematical proficiency (it
    does not, although it can feel like it if you read too quickly).
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是另一本经典教科书，内容稍微更为理论化且不易理解。最好先看看 Tsay 的书，但这本书包括了更多关于统计时间序列模型数学过程的讨论。它还包括了从科学和经济数据源中得出的更广泛的数据分析。这本书比其他列出的教科书更具挑战性，但这是因为它内容密集且信息丰富，并不是因为它需要更高的数学能力水平（实际上并不需要，尽管如果读得太快可能会有这种感觉）。
- en: 'Heuristical guidance:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启发性指导：
- en: Robert Nau, [“Summary of Rules for Identifying ARIMA Models,”](https://perma.cc/37BY-9RAZ)
    course notes from Fuqua School of Business, Duke University, https://perma.cc/37BY-9RAZ.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Robert Nau，[“识别 ARIMA 模型的规则总结，”](https://perma.cc/37BY-9RAZ) 来自杜克大学 Fuqua 商学院的课程笔记，https://perma.cc/37BY-9RAZ。
- en: These notes give you detailed guidance on how to choose the three parameters
    of an ARIMA model. You will immediately notice a strong emphasis on parsimonious
    models when you read this summary.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些笔记详细指导您如何选择 ARIMA 模型的三个参数。当您阅读本摘要时，您会立即注意到对简约模型的强调。
- en: 'National Insitute of Standards and Technology (NIST), [“Box-Jenkins Models,”](https://perma.cc/3XSC-Y7AG)
    in *NIST/SEMATECH e-Handbook of Statistical Methods* (Washington, DC: NIST, US
    Department of Commerce, 2003), https://perma.cc/3XSC-Y7AG.'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 美国国家标准与技术研究院（NIST），[“Box-Jenkins 模型，”](https://perma.cc/3XSC-Y7AG) 收录于 *NIST/SEMATECH
    统计方法 e-Handbook*（华盛顿特区：NIST，美国商务部，2003 年），https://perma.cc/3XSC-Y7AG。
- en: This section of the online NIST handbook offers concrete steps to implement
    the Box-Jenkins method, a commonly used methodology for ARIMA parameter selection.
    It’s also a good example of the resources NIST produces for statistical analysis
    of time series more generally, as part of the larger meticulously compiled handbook
    of best practices for time series analysis.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这部分在线 NIST 手册提供了实施 Box-Jenkins 方法的具体步骤，这是一种常用的 ARIMA 参数选择方法学。这也是 NIST 为时间序列统计分析提供的资源的一个很好的例子，作为更大型精心编纂的最佳实践手册的一部分。
- en: Rob J. Hyndman, [“The ARIMAX Model Muddle,”](https://perma.cc/4W44-RQZB) Hyndsight
    blog, October 4, 2010, https://perma.cc/4W44-RQZB.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rob J. Hyndman，[“ARIMAX 模型的混淆问题，”](https://perma.cc/4W44-RQZB) Hyndsight 博客，2010
    年 10 月 4 日，https://perma.cc/4W44-RQZB。
- en: This concise blog post from noted forecaster Rob Hyndman describes incorporating
    covariates into ARIMA models, an alternative methodology to VAR for handling multivariate
    time series.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这篇简洁的博客文章来自著名预测专家 Rob Hyndman，描述了将协变量纳入 ARIMA 模型的方法，这是处理多变量时间序列的 VAR 替代方法。
- en: 'Richard Hardy, [“Cross Validation: Regularization for ARIMA Models,”](https://perma.cc/G8NQ-RCCU)
    question posted on Cross Validated, StackExchange, May 13, 2015, https://perma.cc/G8NQ-RCCU.'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Richard Hardy，[“ARIMA 模型的交叉验证和正则化问题，”](https://perma.cc/G8NQ-RCCU) Cross Validated,
    StackExchange 上的问题，2015 年 5 月 13 日，https://perma.cc/G8NQ-RCCU。
- en: In the scenario of a high order of autoregressive terms or many inputs in the
    case of VAR, it can make sense to regularize, and in many industries this leads
    to substantial performance improvements. This post on the Cross Validated Q&A
    site provides some preliminary discussion as well as links to a computational
    implementation and related academic research.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在自回归项较高或在 VAR 的情况下输入较多的情况下，正则化是有意义的，在许多行业中，这会带来显著的性能改进。这篇关于 Cross Validated
    问答网站的帖子提供了一些初步讨论以及与计算实现和相关学术研究的链接。
- en: ^([1](ch06.html#idm45576038971656-marker)) Note that ordinary least squares
    is unbiased even in the case of removing some of these conditions. For example,
    when errors are correlated and heteroskedastic, ordinary least squares can still
    provide an unbiased estimate of coefficients, although there are efficiency concerns.
    For more information about efficiency, start with [Wikipedia](https://perma.cc/4M4H-YKPS).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm45576038971656-marker)) 请注意，即使在移除某些条件的情况下，普通最小二乘法仍然是无偏的。例如，当误差相关且异方差时，普通最小二乘法仍然可以提供系数的无偏估计，尽管存在效率问题。有关效率的更多信息，请参阅
    [Wikipedia](https://perma.cc/4M4H-YKPS)。
- en: ^([2](ch06.html#idm45576038962824-marker)) There are some mitigating factors
    to justify the use of standard linear regression in that case. First, some believe
    that at sufficiently short scales the movements of the financial markets are independent
    of one another (iid). Second, because linear regressions are so computationally
    efficient, a fast model, even if inaccurate in its assumptions, is a good model
    in an industry driven by speed. Third, businesses that use these models manage
    to make money, so they must be doing something right.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#idm45576038962824-marker)) 在这种情况下，有一些缓解因素可以证明使用标准线性回归的合理性。首先，有人认为在足够短的时间尺度上，金融市场的波动彼此独立（iid）。其次，由于线性回归计算效率高，即使在假设不准确的情况下，快速模型在追求速度的行业中仍然是一个好模型。第三，使用这些模型的企业能够赚钱，因此他们一定是做对了什么。
- en: ^([3](ch06.html#idm45576038906200-marker)) Only equations referenced subsequently
    are numbered.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#idm45576038906200-marker)) 只有随后引用的方程式才编号。
- en: ^([4](ch06.html#idm45576035870200-marker)) For some sample discussions, see
    examples such as [Stack Overflow](https://perma.cc/2KM3-Z4R4) and [Rob Hyndman’s
    blog](https://perma.cc/9DH6-LGNW).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#idm45576035870200-marker)) 对于一些示例讨论，请参阅诸如 [Stack Overflow](https://perma.cc/2KM3-Z4R4)
    和 [Rob Hyndman’s blog](https://perma.cc/9DH6-LGNW)。
