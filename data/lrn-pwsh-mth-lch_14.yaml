- en: 14 Multitasking with background jobs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 使用后台作业进行多任务处理
- en: Everyone’s always telling you to *multitask*, right? Why shouldn’t PowerShell
    help you with that by doing more than one thing at a time? It turns out that PowerShell
    can do exactly that, particularly for longer-running tasks that might involve
    multiple target computers. Make sure you’ve read chapter 13 before you dive into
    this chapter, because we’ll be taking those remoting concepts a step further.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人总是告诉你要“多任务处理”，对吧？为什么 PowerShell 不能通过一次做几件事来帮助你呢？事实证明，PowerShell 确实可以这样做，特别是对于可能涉及多个目标计算机的长时间运行的任务。在深入本章之前，请确保你已经阅读了第
    13 章，因为我们将进一步探讨那些远程概念。
- en: Heads Up We will be using a lot of the Az cmdlets in this chapter, which does
    require an active Azure subscription. These are just the examples we chose to
    highlight.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章中，我们将使用大量的 Az 命令，这需要有效的 Azure 订阅。这些只是我们选择突出显示的示例。
- en: 14.1 Making PowerShell do multiple things at the same time
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 让 PowerShell 同时执行多项任务
- en: You should think of PowerShell as a single-threaded application, meaning that
    it can do only one thing at a time. You type a command, you press Enter, and the
    shell waits for that command to execute. You can’t run a second command until
    the first command finishes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将 PowerShell 视为一个单线程应用程序，这意味着它一次只能做一件事。你输入一个命令，按下 Enter，外壳等待该命令执行。你无法在第一个命令完成之前运行第二个命令。
- en: But with its background jobs functionality, PowerShell has the ability to move
    a command onto a separate background thread or a separate background PowerShell
    process. That enables the command to run in the background as you continue to
    use the shell for another task. You have to make that decision before running
    the command; after you press Enter, you can’t decide to move a long-running command
    into the background.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但凭借其后台作业功能，PowerShell 有能力将命令移动到单独的后台线程或单独的后台 PowerShell 进程。这使命令能够在后台运行，同时你继续使用外壳执行其他任务。在运行命令之前，你必须做出这个决定；按下
    Enter 后，你不能决定将长时间运行的命令移入后台。
- en: After commands are in the background, PowerShell provides mechanisms to check
    on their status, retrieve any results, and so forth.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 命令进入后台后，PowerShell 提供了检查其状态、检索任何结果等机制。
- en: 14.2 Synchronous vs. asynchronous
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 同步与异步
- en: 'Let’s get some terminology out of the way first. PowerShell runs normal commands
    *synchronously*, meaning you press Enter and then wait for the command to complete.
    Moving a job into the background allows it to run *asynchronously*, meaning you
    can continue to use the shell for other tasks as the command completes. Let’s
    look at some important differences between running commands in these two ways:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先澄清一些术语。PowerShell 以同步方式运行正常命令，这意味着你按下 Enter 然后等待命令完成。将作业移动到后台允许它异步运行，这意味着你可以在命令完成时继续使用外壳执行其他任务。让我们看看以这两种方式运行命令的一些重要区别：
- en: When you run a command synchronously, you can respond to input requests. When
    you run commands in the background, there’s no opportunity to see input requests—in
    fact, they’ll stop the command from running.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你同步运行一个命令时，你可以响应输入请求。当你后台运行命令时，没有机会看到输入请求——实际上，它们会阻止命令运行。
- en: Synchronous commands produce error messages when something goes wrong. Background
    commands produce errors, but you won’t see them immediately. You’ll have to make
    arrangements to capture them, if necessary. (Chapter 24 discusses how you do that.)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步命令在出错时会产生错误消息。后台命令会产生错误，但你不会立即看到它们。如果需要，你必须做出安排来捕获它们。（第 24 章讨论了如何做到这一点。）
- en: If you omit a required parameter on a synchronous command, PowerShell can prompt
    you for the missing information. On a background command, it can’t, so the command
    will fail.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你省略了同步命令上的必需参数，PowerShell 可以提示你输入缺失的信息。在后台命令上，它不能这样做，因此命令将失败。
- en: The results of a synchronous command start displaying as soon as they become
    available. With a background command, you wait until the command finishes running
    and then retrieve the cached results.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步命令的结果一旦可用就开始显示。对于后台命令，你等待命令运行完成，然后检索缓存的成果。
- en: We typically run commands synchronously to test them out and get them working
    properly, and run them in the background only after we know they’re fully debugged
    and working as we expect. We follow these measures to ensure that the command
    will run without problems and that it will have the best chance of completing
    in the background. PowerShell refers to background commands as *jobs*. You can
    create jobs in several ways, and you can use several commands to manage them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常同步运行命令以测试它们并确保它们正常工作，只有在我们知道它们已经完全调试并且按预期工作后，才在后台运行它们。我们采取这些措施以确保命令可以无问题运行，并且有最大的机会在后台完成。PowerShell
    将后台命令称为 *作业*。你可以通过多种方式创建作业，并且可以使用多个命令来管理它们。
- en: Above and beyond
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: Technically, the jobs we discuss in this chapter are only a few kinds of jobs
    you’ll encounter. Jobs are an extension point for PowerShell, meaning it’s possible
    for someone (either in Microsoft or as a third party) to create other things called
    jobs that look and work a bit differently than what we describe in this chapter.
    You may run into other kinds of jobs as you extend the shell for various purposes.
    We want you to understand that little detail and to know that what you’re learning
    in this chapter applies only to the native, regular jobs that come with PowerShell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，本章所讨论的工作岗位只是你可能会遇到的一小部分工作。工作（Job）是 PowerShell 的一个扩展点，这意味着任何人（无论是微软内部人员还是第三方）都可以创建其他被称为工作（Job）的东西，这些工作看起来和运作方式与本章所描述的略有不同。当你为了各种目的扩展
    shell 时，可能会遇到其他类型的工作。我们希望你能理解这个细节，并知道你在本章所学的内容仅适用于 PowerShell 自带的、常规的工作岗位。
- en: 14.3 Creating a process job
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 创建进程工作（Process Job）
- en: 'The first type of job we cover is perhaps the easiest: a process job. This
    is a command that runs in another PowerShell process on your machine in the background.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍的工作类型可能是最简单的：进程工作（Process Job）。这是一个在机器上的另一个 PowerShell 进程中后台运行的命令。
- en: 'To launch one of these jobs, you use the `Start-Job` command. A `-ScriptBlock`
    parameter lets you specify the command (or commands) to run. PowerShell makes
    up a default job name (`Job1`, `Job2`, etc.), or you can specify a custom job
    name by using the `-Name` parameter. Rather than specifying a script block, you
    can specify the `-FilePath` parameter to have the job execute an entire script
    file full of commands. Here’s a simple example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动这些作业之一，你使用 `Start-Job` 命令。一个 `-ScriptBlock` 参数允许你指定要运行的命令（或命令序列）。PowerShell
    会自动生成一个默认作业名称（`Job1`、`Job2` 等），或者你可以使用 `-Name` 参数指定一个自定义作业名称。你不必指定脚本块，也可以指定 `-FilePath`
    参数，让作业执行一个包含多个命令的整个脚本文件。以下是一个简单的示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command creates the job object, and as the previous example shows, the job
    begins running immediately. The job is also assigned a sequential job ID number,
    which is shown in the table.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建作业对象，正如前面的示例所示，作业立即开始运行。作业还分配了一个顺序作业 ID 号，如表中所示。
- en: 'The command also has a `-WorkingDirectory` parameter that allows you to change
    where your job starts on the filesystem. By default, it always starts in the home
    directory. Don’t ever make assumptions about file paths from within a background
    job: use absolute paths to make sure you can refer to whatever files your job
    command may require, or use the `-WorkingDirectory` parameter. Here’s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令还有一个 `-WorkingDirectory` 参数，允许你更改工作在文件系统中的起始位置。默认情况下，它始终从主目录开始。绝不要在后台作业中假设文件路径：使用绝对路径以确保你可以引用作业命令可能需要的任何文件，或者使用
    `-WorkingDirectory` 参数。以下是一个示例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sharp-eyed readers will note that the first job we created is named `Job1` and
    given the ID `1`, but the second job is `Job3` with ID `3`. It turns out that
    every job has at least one *child job*, and the first child job (a child of `Job1`)
    is given the name `Job2` and the ID `2`. We’ll get to child jobs later in this
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的读者会注意到，我们创建的第一个作业被命名为 `Job1` 并分配了 ID `1`，但第二个作业是 `Job3`，ID 为 `3`。实际上，每个作业至少有一个
    *子作业*，第一个子作业（`Job1` 的子作业）被命名为 `Job2` 并分配了 ID `2`。我们将在本章后面讨论子作业。
- en: 'Here’s something to keep in mind: although process jobs run locally, they do
    require PowerShell remoting to be enabled, which we covered in chapter 13.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的事项：尽管进程工作在本地运行，但它们确实需要启用 PowerShell 远程，这在第 13 章中已经介绍过。
- en: 14.4 Creating a thread job
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 创建线程工作（Thread Job）
- en: 'There’s a second type of job that ships as part of PowerShell that we’d like
    to talk about. It’s called a *thread job*. Rather than running in a totally different
    PowerShell process, a thread job will spin up another thread in the *same* process.
    Here’s an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想讨论 PowerShell 中作为其一部分提供的第二种作业类型。它被称为 *线程作业*。线程作业不会在完全不同的 PowerShell 进程中运行，而是在
    *同一* 进程中启动另一个线程。以下是一个示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Looks very similar to the previous job output, huh? Only two differences—the
    `PSJobTypeName`, which is `ThreadJob`, and the `Location`, which is `PowerShell`.
    This tells us that this job ran within the process that we’re currently using,
    but in a different thread.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来与上一个作业输出非常相似，对吧？只有两个区别——`PSJobTypeName`，它是 `ThreadJob`，以及 `Location`，它是 `PowerShell`。这告诉我们这个作业是在我们目前正在使用的进程中运行的，但在不同的线程中。
- en: Since the overhead of spinning up a new thread is drastically faster than spinning
    up a new process, thread jobs are fantastic for short-term scripts and commands
    that you want to start fast and run in the background. Inversely, you can use
    process jobs for long-running scripts on your machine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于启动新线程的开销比启动新进程快得多，因此线程作业非常适合短期脚本和您希望快速启动并在后台运行的命令。相反，您可以使用进程作业在您的机器上运行长时间运行的脚本。
- en: Heads Up Although thread jobs start faster, keep in mind that one process can
    only have so many threads running at the same time before it starts to slow down.
    PowerShell baked in a “throttle limit” of 10 to help prevent you from bogging
    down PowerShell too much. This means that only 10 thread jobs can run at the same
    time. If you want to up the limit, you can. Just specify the `-ThrottleLimit`
    parameter and pass in the new limit you want to use. You’ll eventually start seeing
    diminishing returns if you start 50, 100, 200 thread jobs at a time. Keep that
    in mind.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管线程作业启动得更快，但请记住，在进程开始变慢之前，一个进程只能同时运行这么多线程。PowerShell 内置了一个“节流限制”为 10，以帮助您防止
    PowerShell 过度负载。这意味着一次只能运行 10 个线程作业。如果您想提高限制，可以这样做。只需指定 `-ThrottleLimit` 参数并传递您想要使用的新限制。如果您一次启动
    50、100 或 200 个线程作业，您最终会看到收益递减。请记住这一点。
- en: 14.5 Remoting, as a job
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 作为作业的远程
- en: 'Let’s review the final technique you can use to create a new job: PowerShell’s
    remoting capabilities, which you learned about in chapter 13\. There’s an important
    difference: whatever command you specify in the `-scriptblock` (or `-command`,
    which is an alias for the same parameter) will be transmitted in parallel to each
    computer you specify. Up to 32 computers can be contacted at once (unless you
    modify the `-throttleLimit` parameter to allow more or fewer), so if you specify
    more than 32 computer names, only the first 32 will start. The rest will start
    after the first set begins to finish, and the top-level job will show a completed
    status after all of the computers finish.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下您可以使用来创建新作业的最终技术：PowerShell 的远程功能，您在第 13 章中已经学过。有一个重要的区别：您在 `-scriptblock`（或
    `-command`，它是同一参数的别名）中指定的任何命令都将并行传输到您指定的每台计算机。一次最多可以联系 32 台计算机（除非您修改 `-throttleLimit`
    参数以允许更多或更少的计算机），因此如果您指定了超过 32 台计算机的名称，只有前 32 台将启动。其余的将在第一组开始完成后启动，并且顶级作业将在所有计算机完成后显示完成状态。
- en: Unlike the other two ways to start a job, this technique requires you to have
    PowerShell v6 or higher installed on each target computer and remoting over SSH
    to be enabled in PowerShell on each target computer. Because the command physically
    executes on each remote computer, you’re distributing the computing workload,
    which can help improve performance for complex or long-running commands. The results
    come back to your computer and are stored with the job until you’re ready to review
    them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与启动作业的其他两种方式不同，这种技术要求您在每个目标计算机上安装 PowerShell v6 或更高版本，并在每个目标计算机上的 PowerShell
    中启用 SSH 远程。因为命令在每台远程计算机上物理执行，所以您正在分配计算工作负载，这可以帮助提高复杂或长时间运行的命令的性能。结果将返回到您的计算机，并在您准备好查看之前与作业一起存储。
- en: 'In the following example, you’ll also see the `-JobName` parameter that lets
    you specify a job name other than the boring default:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您还将看到 `-JobName` 参数，它允许您指定除无聊的默认值以外的作业名称：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 14.6 Jobs in the wild
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 野外的作业
- en: 'We wanted to use this section to show an example of a PowerShell module that
    exposes its own PSJobs so you can look out for this pattern in your PowerShell
    journey. Let’s take the command `New-AzVm`, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想用这个部分来展示一个 PowerShell 模块，该模块公开了自己的 PSJobs，这样您可以在 PowerShell 的旅程中寻找这种模式。以命令
    `New-AzVm` 为例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice a familiar parameter? `-AsJob`! Let’s see what it does in this command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一个熟悉的参数吗？`-AsJob`！让我们看看它在命令中做了什么：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This parameter tells `New-AzVM` to return a `Job`. If we fire off that cmdlet,
    after we put in a username and password for the VM, we’ll see that we get a `Job`
    back.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数告诉`New-AzVM`返回一个`Job`。如果我们执行此命令，并在为虚拟机输入用户名和密码后，我们会看到我们得到了一个`Job`。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What makes this so awesome is that you can manage these jobs just as you would
    the jobs that were returned from `Start-Job` or `Start-ThreadJob`. You’ll see
    later how we go about managing jobs, but this is an example of how custom jobs
    might appear. Look for the `-AsJob` parameter!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以如此出色，是因为您可以像管理从`Start-Job`或`Start-ThreadJob`返回的作业一样管理这些作业。您将在稍后看到我们如何管理作业，但这是一个自定义作业可能出现的示例。寻找`-AsJob`参数！
- en: 14.7 Getting job results
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.7 获取作业结果
- en: 'The first thing you’ll probably want to do after starting a job is to check
    whether your job has finished. The `Get-Job` cmdlet retrieves every job currently
    defined by the system and shows you each one’s status:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动作业后，您可能首先想要做的是检查作业是否已完成。`Get-Job`命令检索系统当前定义的每个作业，并显示每个作业的状态：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also retrieve a specific job by using its ID or its name. We suggest
    that you do that and pipe the results to `Format-List *`, because you’ve gathered
    some valuable information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过其ID或其名称检索特定作业。我们建议您这样做，并将结果管道到`Format-List *`，因为您已经收集了一些有价值的信息：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try it Now If you’re following along, keep in mind that your job IDs and names
    might be different from ours. Focus on the output of `Get-Job` to retrieve your
    job IDs and names, and substitute yours in the examples. Also keep in mind that
    Microsoft has expanded the job object over the last few PowerShell versions, so
    your output when looking at all properties might be different.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 如果您正在跟随，请记住，您的作业ID和名称可能与我们的不同。关注`Get-Job`的输出以检索您的作业ID和名称，并在示例中替换您的信息。此外，请记住，Microsoft在过去的几个PowerShell版本中扩展了作业对象，因此您查看所有属性时的输出可能不同。
- en: 'The `ChildJobs` property is one of the most important pieces of information,
    and we’ll cover it in a moment. To retrieve the results from a job, use `Receive-Job`.
    But before you run this, you need to know a few things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildJobs`属性是最重要的信息之一，我们将在稍后讨论。要从作业中检索结果，请使用`Receive-Job`。但在运行此命令之前，您需要了解一些事情：'
- en: You have to specify the job from which you want to receive results. You can
    do this by job ID or job name, or by getting jobs with `Get-Job` and piping them
    to `Receive-Job`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须指定您想要接收结果的作业。您可以通过作业ID或作业名称来做到这一点，或者通过使用`Get-Job`并使用管道将它们传递到`Receive-Job`来获取作业。
- en: If you receive the results of the parent job, those results will include all
    output from all child jobs. Alternatively, you can choose to get the results from
    one or more child jobs.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您接收父作业的结果，这些结果将包括所有子作业的所有输出。或者，您可以选择从一个或多个子作业中获取结果。
- en: Typically, receiving the results from a job clears them out of the job output
    cache, so you can’t get them a second time. Specify `-keep` to keep a copy of
    the results in memory. Or you can output the results to a CLIXML file, if you
    want to retain a copy to work with.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，从作业中接收结果会将其从作业输出缓存中清除，因此您无法再次获取它们。指定`-keep`以在内存中保留结果的副本。或者，如果您想保留一个副本以供工作使用，可以将结果输出到CLIXML文件。
- en: The job results may be deserialized objects, which you learned about in chapter
    13\. These are snapshots from the point in time when they were generated, and
    they may not have any methods that you can execute. But you can pipe the job results
    directly to cmdlets such as `Sort-Object`, `-Format-List`, `Export-CSV`, `ConvertTo-HTML`,
    `Out-File`, and so on, if desired.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业结果可能是反序列化对象，您在第13章中了解过。这些是从它们生成时的快照，它们可能没有任何您可以执行的方法。但根据需要，您可以将作业结果直接管道到`Sort-Object`、`-Format-List`、`Export-CSV`、`ConvertTo-HTML`、`Out-File`等命令。
- en: 'Here’s an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding output shows an interesting set of results. Here’s a quick reminder
    of the command that launched this job in the first place:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了一组有趣的结果。这是启动此作业的命令的快速提醒：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we received the results from `Job1`, we didn’t specify `-keep`. If we
    try to get those same results again, we’ll get nothing, because the results are
    no longer cached with the job:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从`Job1`接收结果时，我们没有指定`-keep`。如果我们尝试再次获取相同的结果，我们将一无所获，因为结果不再与作业一起缓存：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here’s how to force the results to stay cached in memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是强制结果保留在内存中的方法：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You’ll eventually want to free up the memory that’s being used to cache the
    job results, and we’ll cover that in a bit. But first, let’s look at a quick example
    of piping the job results directly to another cmdlet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会想要释放用于缓存作业结果的内存，我们稍后会讨论这一点。但首先，让我们看看一个将作业结果直接管道传输到另一个 cmdlet 的快速示例：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This was the job we started by using `Invoke-Command`. The cmdlet has added
    the `PSComputerName` property so we can keep track of which object came from which
    computer. Because we retrieved the results from the top-level job, this includes
    all of the computers we specified, which allows this command to sort them on the
    computer name and then create an individual table group for each computer. `Get-Job`
    can also keep you informed about which jobs have results remaining:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `Invoke-Command` 启动的作业。该 cmdlet 添加了 `PSComputerName` 属性，这样我们就可以跟踪哪个对象来自哪个计算机。因为我们从顶级作业中检索了结果，这包括我们指定的所有计算机，这使得这个命令可以根据计算机名称对它们进行排序，并为每个计算机创建一个单独的表格组。`Get-Job`
    也可以让你了解哪些作业还有剩余结果：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `HasMoreData` column will be `False` when no output is cached with that
    job. In the case of `Job1` and `MyRemoteJob`, we’ve already received those results
    and didn’t specify `-keep` at that time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有输出与该作业一起缓存时，`HasMoreData` 列将显示为 `False`。在 `Job1` 和 `MyRemoteJob` 的情况下，我们已经收到了那些结果，当时没有指定
    `-keep`。
- en: 14.8 Working with child jobs
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.8 与子作业一起工作
- en: 'We mentioned earlier that most jobs consist of one top-level parent job and
    at least one child job. Let’s look at a job again:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，大多数作业由一个顶级父作业和至少一个子作业组成。让我们再次看看一个作业：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Try it Now Don’t follow along for this part, because if you’ve been following
    along up to now, you’ve already received the results of `Job1`. If you’d like
    to try this, start a new job by running `Start-Job` `-script` `{` `dir` `}`, and
    use that new job’s ID instead of the ID number 1 we used in our example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 不要跟随这一部分，因为如果你到现在一直跟着做，你已经收到了 `Job1` 的结果。如果你想尝试这个，通过运行 `Start-Job` `-script`
    `{` `dir` `}` 开始一个新的作业，并使用那个新作业的 ID 而不是我们示例中使用的 ID 号 1。
- en: 'You can see that `Job1` has a child job, `Job2`. You can get it directly now
    that you know its name:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `Job1` 有一个子作业，`Job2`。现在你知道它的名字，你可以直接获取它：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Sometimes a job has too many child jobs to list in that form, so you may want
    to list them a bit differently, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个作业有太多的子作业，无法以那种形式列出，因此你可能想以不同的方式列出它们，如下所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This technique creates a table of the child jobs for job ID 1, and the table
    can be whatever length it needs to be to list them all. You can receive the results
    from any individual child job by specifying its name or ID with `Receive-Job`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术为作业 ID 1 创建了一个子作业表，表可以扩展到任何长度，以列出所有子作业。你可以通过指定其名称或 ID 来接收任何单个子作业的结果，使用 `Receive-Job`。
- en: 14.9 Commands for managing jobs
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.9 管理作业的命令
- en: 'Jobs also use three more commands. For each of these, you can specify a job
    either by giving its ID, giving its name, or getting the job and piping it to
    one of these cmdlets:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作业还使用三个额外的命令。对于这些命令中的每一个，你可以通过提供其 ID、提供其名称或获取作业并将其管道传输到这些 cmdlet 之一来指定一个作业：
- en: '`Remove-Job`—This deletes a job, and any output still cached with it, from
    memory.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove-Job`——这个命令会从内存中删除一个作业及其任何仍然缓存的输出。'
- en: '`Stop-Job`—If a job seems to be stuck, this command terminates it. You can
    still receive whatever results were generated to that point.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stop-Job`——如果一个作业看起来卡住了，这个命令会终止它。你仍然可以接收到目前为止生成的任何结果。'
- en: '`Wait-Job`—This is useful if a script is going to start a job or jobs and you
    want the script to continue only when the job is done. This command forces the
    shell to stop and wait until the job (or jobs) is completed, and then allows the
    shell to continue.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait-Job`——如果脚本将要启动一个作业或多个作业，而你又想让脚本仅在作业完成后继续执行，这个命令非常有用。这个命令会强制 shell 停止并等待作业（或多个作业）完成，然后允许
    shell 继续执行。'
- en: 'For example, to remove the jobs that we’ve already received output from, we’d
    use the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了删除我们已经收到输出的作业，我们会使用以下命令：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Jobs can also fail, meaning that something went wrong with their execution.
    Consider this example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作业也可能失败，这意味着它们的执行过程中出现了问题。考虑以下示例：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we started a job with a bogus command and targeted a nonexistent computer.
    The job immediately failed, as shown in its status. We don’t need to use `Stop-Job`
    at this point; the job isn’t running. But we can get a list of its child jobs:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个无效的命令并针对一个不存在的计算机启动了一个作业。作业立即失败，如其状态所示。此时我们不需要使用 `Stop-Job`；作业没有在运行。但我们可以获取其子作业的列表：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And we can then get that child job:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以获取那个子作业：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, no output was created for this job, so you won’t have any results
    to retrieve. But the job’s errors are stored in the results, and you can get them
    by using `Receive-Job`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个任务没有创建任何输出，所以你不会有任何结果可以检索。但任务中的错误存储在结果中，你可以通过使用 `Receive-Job` 来获取它们：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The full error is much longer; we truncated it here to save space. You’ll notice
    that the error includes the hostname that the error came from, `[notonline]`.
    What happens if only one of the computers can’t be reached? Let’s try:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的错误信息要长得多；我们在这里截断以节省空间。你会注意到错误中包含了错误来源的主机名 `[notonline]`。如果只有一台计算机无法连接会发生什么？让我们试试：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After waiting for a bit, we run the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微等待一下，我们运行以下命令：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The job still fails, but let’s look at the individual child jobs:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 任务仍然失败，但让我们看看单个子任务：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Okay, they both fail. We have a feeling we know why `Job14` doesn’t work, but
    what’s wrong with `Job15`?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它们两个都失败了。我们感觉我们知道为什么 `Job14` 不工作，但 `Job15` 有什么问题？
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ah, that’s right, we told it to run a bogus command. As you can see, each child
    job can fail for different reasons, and PowerShell tracks each one individually.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，没错，我们告诉它运行一个虚假命令。正如你所见，每个子任务可能会因为不同的原因而失败，而 PowerShell 会单独跟踪每一个。
- en: 14.10 Common points of confusion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.10 常见混淆点
- en: 'Jobs are usually straightforward, but we’ve seen folks do one thing that causes
    confusion. Don’t do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任务通常很简单，但我们见过有人做了一件事导致混淆。不要这样做：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Doing so starts up a temporary connection to `Server-R2` and starts a local
    job. Unfortunately, that connection immediately terminates, so you have no way
    to reconnect and retrieve that job. In general, then, don’t mix and match the
    three ways of starting jobs. The following is also a bad idea:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会启动到 `Server-R2` 的临时连接并启动一个本地任务。不幸的是，这个连接立即终止，所以你无法重新连接并检索该任务。总的来说，不要混合使用启动任务的三种方式。以下也是一个坏主意：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That’s completely redundant; keep the `Invoke-Command` section and use the `-AsJob`
    parameter to have it run in the background.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是多余的；保留 `Invoke-Command` 部分，并使用 `-AsJob` 参数使其在后台运行。
- en: 'Less confusing, but equally interesting, are the questions new users often
    ask about jobs. Probably the most important of these is, “Can we see jobs started
    by someone else?” The answer is no. Jobs and thread jobs are contained entirely
    within the PowerShell process, and although you can see that another user is running
    PowerShell, you can’t see inside that process. It’s like any other application:
    you can see that another user is running Microsoft Word, for example, but you
    can’t see what documents that user is editing, because those documents exist entirely
    inside of Word’s process.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更少混淆但同样有趣的是，新用户经常询问关于任务的问题。其中最重要的问题可能是，“我们能看到别人启动的任务吗？”答案是不了。任务和线程任务完全包含在 PowerShell
    进程中，尽管你可以看到另一个用户正在运行 PowerShell，但你无法看到那个进程内部。就像任何其他应用程序一样：你可以看到另一个用户正在运行 Microsoft
    Word，例如，但你无法看到该用户正在编辑哪些文档，因为那些文档完全存在于 Word 的进程内部。
- en: Jobs last only as long as your PowerShell session is open. After you close it,
    any jobs defined within it disappear. Jobs aren’t defined anywhere outside PowerShell,
    so they depend on its process continuing to run in order to maintain themselves.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 任务只在你打开 PowerShell 会话期间存在。在你关闭它之后，其中定义的任何任务都会消失。任务不在 PowerShell 之外定义，因此它们依赖于其进程继续运行以维持自身。
- en: 14.11 Lab
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.11 实验室
- en: The following exercises should help you understand how to work with various
    types of jobs and tasks in PowerShell. As you work through these exercises, don’t
    feel you have to write a one-line solution. Sometimes it’s easier to break things
    down into separate steps.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习应该有助于你了解如何在 PowerShell 中处理各种类型的任务和作业。在完成这些练习时，不要觉得你必须写出一个单行解决方案。有时将事情分解成单独的步骤更容易。
- en: Create a one-time thread job to find all the text files (`*.txt`) on the filesystem.
    Any task that might take a long time to complete is a great candidate for a job.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个一次性线程任务来查找文件系统中的所有文本文件（`*.txt`）。任何可能需要很长时间才能完成的任务都是使用任务的绝佳候选。
- en: You realize it would be helpful to identify all text files on some of your servers.
    How would you run the same command from task 1 on a group of remote computers?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会意识到识别你服务器上的一些文本文件将是有帮助的。你将如何从任务 1 在一组远程计算机上运行相同的命令？
- en: What cmdlet would you use to get the results of a job, and how would you save
    the results in the job queue?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会用哪个 cmdlet 来获取任务的结果，以及你将如何将结果保存在任务队列中？
- en: 14.12 Lab answers
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.12 实验答案
- en: '`Start-ThreadJob {gci / -recurse –filter ''*.txt''}`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start-ThreadJob {gci / -recurse –filter ''*.txt''}`'
- en: '`Invoke-Command –scriptblock {gci / -recurse –filter *.txt}`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-Command –scriptblock {gci / -recurse –filter *.txt}`'
- en: '`–computername (get-content computers.txt) -asjob`'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`–computername (get-content computers.txt) -asjob`'
- en: '`Receive-Job –id 1 –keep`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Receive-Job –id 1 –keep`'
- en: Of course, you would use whatever job ID was applicable or the job name.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你会使用适用的作业ID或作业名称。
