- en: 1 Why Julia?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 为什么选择Julia？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The type of problems Julia solves
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia解决的问题类型
- en: The benefits of a fast, dynamically typed language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速、动态类型语言的优点
- en: How Julia increases programmer productivity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia如何提高程序员的生产力
- en: You can choose from hundreds of programming languages—many of them much more
    popular than Julia. So why pick Julia?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从数百种编程语言中选择——其中许多比Julia更受欢迎。那么，为什么选择Julia呢？
- en: How would you like to write code faster than you have done before? How about
    building systems with a fraction of the number of lines of code you normally require?
    Surely, such productivity will come at the cost of deplorable performance and
    high memory consumption. Nope. In fact, Julia is the language of choice for next-generation
    climate models, which have extreme performance and memory requirements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望比以前更快地编写代码吗？用你通常需要的代码行数的一小部分来构建系统怎么样？当然，这样的生产力可能会以糟糕的性能和高内存消耗为代价。不，实际上，Julia是下一代气候模型的首选语言，这些模型对性能和内存有极端的要求。
- en: I know such accolades may come across like a bad sales pitch from a used car
    salesman, but there is no denying that Julia, in many ways, is a revolutionary
    programming language. You may ask, “If Julia is so great, then why isn’t everybody
    using it? Why are so many people still using the C programming language?” Familiarity,
    packages, libraries, and community matter. Mission-critical software built up
    in large organizations isn’t just transitioned away from on a whim.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这样的赞誉可能听起来像二手车销售员的糟糕推销，但不可否认的是，Julia在许多方面是一种革命性的编程语言。你可能会问：“如果Julia如此出色，那么为什么不是每个人都使用它？为什么还有这么多人还在使用C编程语言？”熟悉度、包、库和社区都很重要。在大组织中建立起来的关键任务软件并不是一时兴起就放弃的。
- en: 'Many of you reading this book may not care about having the more efficient
    and productive programming language. Instead, what you care about is what you
    can build with it. The simple answer is: anything. Julia is a general-purpose
    programming language.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的许多人可能并不关心拥有更高效、更有生产力的编程语言。相反，你关心的是你可以用它构建什么。简单的答案是：任何东西。Julia是一种通用编程语言。
- en: That may not be a satisfactory answer. You could build anything with JavaScript
    too, in principle. Yet you know JavaScript dominates frontend web development.
    You could write anything with Lua as well, but it is mostly used as a scripting
    language for computer games. Your primary interest in reading this book may be
    the kind of job Julia can land you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是一个令人满意的答案。原则上，你也可以用JavaScript构建任何东西。然而，你知道JavaScript主导着前端Web开发。你也可以用Lua编写任何东西，但它主要被用作计算机游戏的脚本语言。你阅读这本书的主要兴趣可能在于Julia能为你带来什么样的工作。
- en: Presently, the Julia community is strongest within scientific computing, data
    science, and machine learning. But learning Julia is also a bet on the future.
    A language with such strong capabilities will not remain within a small niche.
    If you read on, it will become clearer what Julia is and why it has such potential.
    I will also cover areas where Julia is not ideal.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Julia社区在科学计算、数据科学和机器学习方面最为强大。但学习Julia也是一种对未来的赌注。具有如此强大能力的语言不会局限于一个小众领域。如果你继续阅读，将会更清楚地了解Julia是什么以及它为什么具有如此大的潜力。我还会涵盖Julia不理想的应用领域。
- en: 1.1 What is Julia?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是Julia？
- en: Julia is a general-purpose, multi-platform programming language that is
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是一种通用、多平台的编程语言，它是
- en: Suited for numerical analysis and computational science
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合数值分析和计算科学
- en: Dynamically typed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型
- en: High performance and just-in-time compiled
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能和即时编译
- en: Using automatic memory management (garbage collection)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动内存管理（垃圾回收）
- en: Composable
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可组合
- en: That’s a lot, and some of these things sound like contradictions. So how can
    Julia be a general-purpose language and also tailored toward numerical programming?
    It’s general-purpose because, like Python, Julia can be used for almost anything.
    It’s numerical because, like MATLAB, it is well suited for numerical programming.
    But it isn’t limited to numerical programming; it’s good for other uses as well.
    By *composable* I mean that Julia makes it easy to express many object-oriented
    and functional programming patterns facilitating code reuse.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很多，其中一些东西似乎相互矛盾。那么，Julia如何成为一个通用语言，同时又针对数值编程进行了定制？它之所以是通用的，是因为，像Python一样，Julia可以用于几乎任何东西。它之所以适合数值编程，是因为，像MATLAB一样，它非常适合数值编程。但它并不局限于数值编程；它也适合其他用途。通过“可组合”我指的是Julia使得表达许多面向对象和函数式编程模式变得容易，从而促进代码重用。
- en: 1.1.1 Pros and cons of statically and dynamically typed languages
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 静态类型和动态类型语言的优缺点
- en: 'Let’s focus on one aspect of Julia: the fact that it’s dynamically typed. Usually,
    programming languages are divided into two broad categories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注 Julia 的一个方面：它是动态类型的事实。通常，编程语言被分为两大类：
- en: Dynamically typed
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型
- en: Statically typed
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型
- en: In static languages, expressions have types; in dynamic languages, values have
    types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态语言中，表达式有类型；在动态语言中，值有类型。
- en: —Stefan Karpinski Julia Creator
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ——Julia 创始人 Stefan Karpinski
- en: Examples of statically typed languages are C/C++, C#, Java, Swift, Go, Rust,
    Pascal, and Fortran. In a statically typed language, type checks are performed
    on all your code before your program is allowed to run.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言的例子有 C/C++、C#、Java、Swift、Go、Rust、Pascal 和 Fortran。在静态类型语言中，在程序允许运行之前，对所有的代码执行类型检查。
- en: Examples of dynamically typed languages are Python, Perl, Ruby, JavaScript,
    MATLAB, and LISP. Dynamically typed languages perform type checks while the program
    is running. Unfortunately, dynamically typed languages tend to be very slow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言的例子有 Python、Perl、Ruby、JavaScript、MATLAB 和 LISP。动态类型语言在程序运行时执行类型检查。不幸的是，动态类型语言往往非常慢。
- en: In dynamic languages values such as numbers, characters, and strings have attached
    tags that say what type they are. These tags allow programs written in a dynamically
    typed language to check type correctness at runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态语言中，数值、字符和字符串等值都附有标签，表明它们的类型。这些标签允许使用动态类型语言的程序在运行时检查类型正确性。
- en: Julia is unusual in that it is both a dynamically typed language and high performance.
    To many, this is a contradiction. This unique trait of Julia is made possible
    because the language was explicitly designed for just-in-time (JIT) compilation
    and uses a feature called *multiple-dispatch* for all function calls. Languages
    such as C/C++ and Fortran use ahead-of-time (AOT) compilation. A compiler translates
    the whole program into machine code before it can run. Other languages, such as
    Python, Ruby, and Basic, use an interpreter. With interpreted languages, a program
    reads each line of source code and interprets it at runtime to carry out the instructions
    given. Now that you have an idea of what kind of language Julia is, I can begin
    discussing the appeal of Julia.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 很特别，它既是一种动态类型语言，又具有高性能。对许多人来说，这似乎是一种矛盾。Julia 的这一独特特性得以实现，是因为该语言被明确设计用于即时编译（JIT），并且对所有函数调用使用了一种称为
    *多分派* 的特性。C/C++ 和 Fortran 等语言使用编译前（AOT）编译。编译器在程序运行之前将整个程序翻译成机器代码。其他语言，如 Python、Ruby
    和 Basic，使用解释器。在解释性语言中，程序读取每一行源代码并在运行时解释它以执行给定的指令。现在你已经了解了 Julia 是什么类型的语言，我可以开始讨论
    Julia 的吸引力了。
- en: Language design and JIT compilation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 语言设计和 JIT 编译
- en: In principle, a programming language is decoupled from the method used to run
    it. Yet you will find that I talk about Julia as a JIT-compiled language and Fortran
    as an AOT compiled language. Strictly speaking, this is imprecise. For instance,
    Julia can run through an interpreter as well. However, most languages have been
    designed for a particular form of execution. Julia was designed for JIT compilation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，编程语言与其运行方法解耦。然而，你会发现我谈论 Julia 时将其称为 JIT 编译语言，而将 Fortran 称为 AOT 编译语言。严格来说，这是不准确的。例如，Julia
    也可以通过解释器运行。然而，大多数语言都是为特定形式的执行而设计的。Julia 是为 JIT 编译而设计的。
- en: 1.2 Julia combines elegance, productivity, and performance
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 Julia 结合了优雅、生产力和性能
- en: While performance is one of the key selling points of Julia, what caught my
    attention back in 2013 when I first discovered it was how well thought out, powerful,
    and easy to use it was. I had a program I had rewritten in several languages to
    compare how expressive, easy to use, and productive each language was. With Julia,
    I managed to make the most elegant, compact, and easily readable variant of this
    code ever. Since then, I have tried many programming languages but have never
    gotten close to what I achieved with Julia. Here are some one-liners that exemplify
    the expressiveness of Julia.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 performance 是 Julia 的关键卖点之一，但当我2013年第一次发现它时，吸引我注意的是它如何考虑周到、功能强大且易于使用。我有一个程序，我用几种不同的语言重写了它，以比较每种语言的表述性、易用性和生产力。使用
    Julia，我成功地制作出了这个代码最优雅、紧凑和易于阅读的版本。从那时起，我尝试了许多编程语言，但从未接近我在 Julia 中所取得的成就。以下是一些体现
    Julia 表述性的单行代码示例。
- en: Listing 1.1 Julia one-liners
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 Julia 单行代码示例
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Having been programming since the 1990s, I have had periods where I have felt
    I had enough of programming; Julia helped me regain my joy for programming. Part
    of the reason is that once you master Julia, you will feel that you have a language
    in your toolbox that works as a member of your team rather than against you. I
    think many of us have had the experience of working on a problem we have a good
    idea of how to solve, but the language we are using is getting in our way. The
    limitations of the language force us to add one hack after another. With Julia,
    I can build software the way I want without the language putting up obstacles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自1990年代以来，我有过编程已经足够多的时期；Julia帮助我重新找回了编程的乐趣。部分原因在于，一旦你掌握了Julia，你会觉得你有一个工具箱中的语言，它作为团队的一员而不是对立面来工作。我认为我们很多人都有过这样的经历：我们有一个很好的解决方案，但我们使用的语言却在阻碍我们。语言的限制迫使我们一个接一个地添加黑客技巧。有了Julia，我可以按照自己的意愿构建软件，而不会遇到语言的障碍。
- en: Another aspect that adds to your productivity and sense of fun is that Julia
    comes bundled with a rich standard library. You hit the ground running. You can
    get a lot done without hunting all over the web for some library to do what you
    want. Julia has you covered, whether you want to do linear algebra, statistics,
    HTTP, or string manipulation or you want to work with different date formats.
    And if the capability you want isn’t in the standard library, Julia has a tightly
    integrated package manager that makes adding third-party libraries a walk in the
    park. Programming with Julia almost makes you feel guilty or spoiled because you
    can build rich and elegant abstractions without taking a performance hit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于提高你的生产力和乐趣的方面是，Julia附带了一个丰富的标准库。你可以立即上手。你可以在不四处寻找库的情况下完成很多事情。无论你想进行线性代数、统计学、HTTP还是字符串操作，或者你想处理不同的日期格式，Julia都能满足你的需求。而且，如果你需要的功能不在标准库中，Julia有一个紧密集成的包管理器，使得添加第三方库变得轻而易举。用Julia编程几乎会让你感到内疚或被宠坏了，因为你可以在不牺牲性能的情况下构建丰富而优雅的抽象。
- en: 'Another essential advantage of Julia is that it is easy to learn. This ease
    of learning can help Julia gain a larger community over time. To understand why
    Julia is easy to learn, consider the famous *Hello world* program written in Julia:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的另一个基本优势是它易于学习。这种学习的便利性可以帮助Julia随着时间的推移获得更大的社区。要了解为什么Julia容易学习，可以考虑用Julia编写的著名*Hello
    world*程序：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When run, this code writes the text *Hello world* to the screen. While trivial,
    many languages require a lot of complex scaffolding to do something that simple.
    The following is a Java program which does the same thing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，它会在屏幕上写入文本*Hello world*。虽然这很简单，但许多语言都需要很多复杂的框架才能完成这样的事情。以下是一个执行相同操作的Java程序：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That exposes the beginner to a lot more concepts all at once, which can be overwhelming.
    Julia is easier to learn because you can focus on learning one concept at a time.
    You can learn to write a function without ever seeing a type definition. With
    a lot of functionality available out of the box, you don’t even need to know how
    to import external libraries to write helpful code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这会让初学者一次性接触到很多概念，可能会感到不知所措。Julia更容易学习，因为你可以一次专注于学习一个概念。你可以学习编写一个函数，而无需看到类型定义。由于提供了许多开箱即用的功能，你甚至不需要知道如何导入外部库就能编写有用的代码。
- en: 1.3 Why Julia was created
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 为什么创建Julia
- en: To truly understand what Julia brings to the table, you need to understand better
    *why* Julia was created in the first place. The creators of the Julia programming
    language wanted to solve what they have called the *two-language problem*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解Julia能为桌面带来什么，你需要更好地理解它最初为什么被创建。Julia编程语言的创造者想要解决他们所说的*两种语言问题*。
- en: This problem refers to the fact that a lot of software is written using two
    different programming languages, each with different characteristics. In the scientific
    domain, machine learning and data analysis dynamic languages are often preferred.
    However, these languages usually don’t give good enough performance. Thus solutions
    often have to be rewritten in higher-performance, statically typed languages.
    But why does this preference exist? Why not write everything in a traditional
    high-performance, statically typed language?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题指的是很多软件都是用两种不同的编程语言编写的，每种语言都有不同的特性。在科学领域，机器学习和数据分析动态语言通常更受欢迎。然而，这些语言通常性能不足。因此，解决方案通常需要用性能更高、静态类型化的语言重写。但为什么会有这种偏好呢？为什么不用传统的、高性能的静态类型语言来编写一切呢？
- en: 1.3.1 Scientists need the interactive programming that dynamically typed languages
    offer
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 科学家需要动态类型语言提供的交互式编程
- en: Scientists began writing software, including large weather simulations, in Fortran^([1](#pgfId-1012368))
    and neural networks^([2](#pgfId-1012381)) in C or C++.^([3](#pgfId-1012394)) These
    languages offer the kind of performance you need to tackle these large-scale problems.
    However, these languages come at a price. They tend to be rigid, verbose, and
    lacking in expressiveness—all of which reduce programmer productivity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家开始用Fortran[1](#pgfId-1012368)编写软件，包括大型天气模拟，以及用C或C++编写神经网络[2](#pgfId-1012381)。[3](#pgfId-1012394)
    这些语言提供了解决这些大规模问题所需的那种性能。然而，这些语言也有代价。它们往往很僵化、冗长且缺乏表现力——所有这些都降低了程序员的效率。
- en: The fundamental problem, however, is that these languages are not suited for
    *interactive programming*. What do I mean by that? Interactive programming is
    the ability to write code and get immediate feedback.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基本问题是这些语言不适合*交互式编程*。我指的是什么？交互式编程是编写代码并获得即时反馈的能力。
- en: Interactive programming matters a lot in data science and machine learning.
    In a typical data analysis process, data is explored by a developer loading large
    amounts of data into an interactive programming environment. Then the developer
    performs various analyses of this data. These analyses could include finding averages
    and maximum values or plotting a histogram. The results of the first analysis
    tell the programmer what the next steps should be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式编程在数据科学和机器学习中非常重要。在典型数据分析过程中，开发者通过将大量数据加载到交互式编程环境中来探索数据。然后开发者对这份数据执行各种分析。这些分析可能包括寻找平均值和最大值或绘制直方图。第一次分析的结果告诉程序员下一步应该做什么。
- en: Figure 1.1 shows this process in a dynamically typed language. You start by
    running the code, which loads the data, which you can then observe. However, you
    don’t have to go through this whole process after you change the code. You can
    change the code and observe changes immediately. You don’t need to load massive
    amounts of data over again.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1展示了在动态类型语言中这个过程。你首先运行代码，加载数据，然后你可以观察它。然而，在你更改代码后，你不必再次经历整个过程。你可以更改代码并立即观察变化。你不需要再次加载大量数据。
- en: '![01-01](../Images/01-01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![01-01](../Images/01-01.png)'
- en: Figure 1.1 In dynamically typed languages you can ping-pong between coding and
    observing. Large data sets do not need to be reloaded into memory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 在动态类型语言中，你可以在编码和观察之间来回切换。大型数据集不需要重新加载到内存中。
- en: 'Let’s contrast this experience with the use of a statically typed language,
    such as Fortran, C/C++, or Java.^([4](#pgfId-1012471)) The developer would write
    some code to load the data and explore it, without knowing anything about what
    the data looks like. They would then have to wait for the program to do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对比一下使用静态类型语言（如Fortran、C/C++或Java）的经验。[4](#pgfId-1012471) 开发者会编写一些代码来加载数据并探索它，而不知道数据看起来像什么。然后他们必须等待程序执行以下操作：
- en: Compile
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译
- en: Launch, then load a large amount of data
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动，然后加载大量数据
- en: At this point the developer sees a plot of the data and statistics, which gives
    them the information they need to choose the next analysis. But choosing the next
    analysis would require repeating the whole cycle over again. The large blob of
    data has to be reloaded on every iteration. This makes each iteration exceedingly
    slow, which slows down the whole analysis process. This is a static, noninteractive
    way of programming (figure 1.2).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此时开发者会看到数据的图表和统计数据，这为他们提供了选择下一步分析所需的信息。但选择下一步分析将需要再次重复整个循环。在每次迭代中都必须重新加载数据的大块。这使得每次迭代都极其缓慢，从而减慢了整个分析过程。这是一种静态的、非交互式的编程方式（图1.2）。
- en: '![01-02](../Images/01-02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![01-02](../Images/01-02.png)'
- en: Figure 1.2 Statically typed languages require the whole loop to be repeated.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 静态类型语言需要重复整个循环。
- en: 1.3.2 Developers in other fields also need the interactivity a dynamically typed
    language offers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 其他领域的开发者也需要动态类型语言提供的交互性
- en: This problem isn’t unique to scientists; game developers have long faced the
    same problem. Game engines are usually written in a language such as C or C++,
    which can compile to fast machine code. This part of the software often does well-understood
    and well-defined things, such as drawing objects on the screen and checking if
    they collide with each other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题并不仅限于科学家；游戏开发者长期以来一直面临相同的问题。游戏引擎通常是用C或C++这样的语言编写的，可以编译成快速的机器代码。软件的这一部分通常执行众所周知且定义良好的任务，例如在屏幕上绘制对象并检查它们是否相互碰撞。
- en: Like a data analyst, a game developer has a lot of code, which will need numerous
    iterations to work satisfactorily. Specifically, developing good game play requires
    a lot of experimentation and iteration. One has to tweak and alter code for how
    characters in the game behave. The layout of a map or level has to be experimented
    with repeatedly to get it right. For this reason, almost all game engines use
    a second language that allows on-the-fly change of code. Frequently, this is a
    language such as Lua,^([5](#pgfId-1012573)) JavaScript, and Python.^([6](#pgfId-1012586))
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数据分析师一样，游戏开发者有很多代码，需要多次迭代才能满意地工作。具体来说，开发良好的游戏玩法需要大量的实验和迭代。必须调整和修改游戏角色的代码。地图或级别的布局必须反复实验才能正确。因此，几乎所有的游戏引擎都使用第二种语言，允许即时更改代码。通常，这种语言是Lua、^([5](#pgfId-1012573))
    JavaScript和Python.^([6](#pgfId-1012586))
- en: With these languages, the code for game characters and maps can be changed without
    requiring a recompile and reloading of maps, levels, and characters. Thus one
    can experiment with game play, pause, make code changes, and continue straight
    away with the new changes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些语言，可以更改游戏角色和地图的代码，而无需重新编译和重新加载地图、级别和角色。因此，可以实验游戏玩法，暂停，进行代码更改，并立即继续使用新的更改。
- en: Machine learning professionals face similar challenges. They build predictive
    models, such as neural networks, which they feed large amounts of data to train.
    This is often as much of a science as an art. Getting it right requires experimentation.
    If you need to reload training data every time you modify your model, you will
    slow down the development process. For this reason, dynamically typed languages,
    such as Python, R, and MATLAB, became very popular in the scientific community.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习专业人士面临着类似的挑战。他们构建预测模型，例如神经网络，并将大量数据输入到模型中进行训练。这既是科学也是艺术。正确地完成它需要实验。如果你每次修改模型时都需要重新加载训练数据，这将减慢开发过程。因此，像Python、R和MATLAB这样的动态类型语言在科学界变得非常流行。
- en: However, because these languages aren’t very fast, they get paired with languages
    such as Fortran and C/C++ to get good performance. A neural network made with
    TensorFlow^([7](#pgfId-1012617)) or PyTorch^([8](#pgfId-1012630)) is made up of
    components written in C/C++. Python is used to arrange and connect these components.
    Thus at runtime you can rearrange these components using Python, without reloading
    the whole program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这些语言速度不快，它们通常与Fortran和C/C++这样的语言配对以获得良好的性能。用TensorFlow^([7](#pgfId-1012617))或PyTorch^([8](#pgfId-1012630))制作的神经网络由用C/C++编写的组件组成。Python用于安排和连接这些组件。因此，在运行时，可以使用Python重新排列这些组件，而无需重新加载整个程序。
- en: Climate and macroeconomic models may get developed in a dynamic language first
    and tested on a small dataset while being developed. Once the model is finished,
    many organizations hire C/C++ or Fortran developers to rewrite the solution in
    a high-performance language. Thus there is an extra step, complicating the development
    processes and adding costs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 气候和宏观经济模型可能首先在动态语言中开发，并在开发过程中在小数据集上进行测试。一旦模型完成，许多组织会雇佣C/C++或Fortran开发者将解决方案重写为高性能语言。因此，这增加了一个额外的步骤，使开发过程复杂化并增加了成本。
- en: 1.4 Julia’s higher performance solves the two-language problem
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Julia的高性能解决了两种语言的问题
- en: 'Julia was created to solve the problem of needing to use two languages. It
    makes it possible to combine the flexibility of a dynamically typed language with
    the performance of a statically typed language. That’s why the following saying
    has gained some popularity:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的创建是为了解决需要使用两种语言的问题。它使得将动态类型语言的灵活性与静态类型语言的性能结合起来成为可能。这就是为什么以下说法已经获得了一些流行度：
- en: Julia walks like Python, runs like C.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Julia像Python一样走路，像C一样奔跑。
- en: —Popular saying in Julia community
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ——Julia社区流行说法
- en: Using Julia, developers within many fields can write code with the same productivity
    as with languages such as Python, Ruby, R, and MATLAB. Because of this, Julia
    has had a profound impact on the industry. In the July 2019 edition of *Nature*,
    several interviews were conducted with various scientists about their use of Julia.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Julia，许多领域的开发者可以写出与Python、Ruby、R和MATLAB等语言具有相同生产力的代码。正因为如此，Julia对行业产生了深远的影响。在2019年7月的《自然》杂志中，对多位科学家进行了关于他们使用Julia的访谈。
- en: For instance, the University of Melbourne has seen an 800x improvement by porting
    computational models from R to Julia. Jane Herriman, Materials Science Caltech,
    reports seeing tenfold-faster runs since rewriting her Python code in Julia.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，墨尔本大学通过将计算模型从R迁移到Julia，实现了800倍的性能提升。材料科学加州理工学院（Caltech）的简·赫尔里曼报告说，自从将她的Python代码重写为Julia后，运行速度提高了十倍。
- en: You can do things in an hour that would otherwise take weeks or months.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个小时内完成的事情，否则可能需要几周或几个月。
- en: —Michael Stumpf
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ——迈克尔·斯特普夫
- en: At the International Conference for Supercomputing in 2019 (SC19), Alan Edelman,
    one of the Julia creators, recounts how a group at the Massachusetts Institute
    of Technology (MIT) rewrote part of their Fortran climate model into Julia. They
    determined ahead of time that they would tolerate a 3x slowdown of their code.
    That was an acceptable tradeoff for gaining access to a high-level language with
    higher productivity, in their view. Instead, they got a 3x speed boost by switching
    to Julia.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年国际超级计算会议（SC19）上，Julia的创造者之一艾伦·埃德尔曼回忆了一个麻省理工学院（MIT）的研究小组如何将他们的一部分Fortran气候模型重写为Julia。他们事先决定可以容忍代码速度降低3倍。在他们看来，这是为了获得一个具有更高生产力的高级语言而可以接受的权衡。然而，通过切换到Julia，他们反而获得了3倍的速度提升。
- en: These are just a few of the many stories that abound today about how Julia is
    revolutionizing scientific computing and high-performance computing in general.
    By avoiding the two-language problem, scientists can work much faster than before.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是今天关于Julia如何革命性地改变科学计算和通用高性能计算的许多故事中的一部分。通过避免双语言问题，科学家可以比以前工作得更快。
- en: 1.5 Julia is for everyone
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 Julia适合每个人
- en: These stories might give the false impression that Julia is a language for brainiacs
    in white lab coats. But nothing could be further from the truth. It turns out
    that a lot of the traits that make Julia a great language for scientists also
    make it an excellent language for everybody else. Julia offers
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些故事可能会给人一种错误的印象，即Julia是一种适合穿白大褂的学霸的语言。但事实并非如此。实际上，使Julia成为科学家优秀语言的许多特质，也使其对其他人来说是一个极好的语言。Julia提供
- en: Strong facilities for modularizing and reusing code.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的模块化和代码重用功能。
- en: A strict type system that helps catch bugs in your code when it runs.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格的类型系统，有助于在代码运行时捕捉到错误。
- en: A sophisticated system for reducing repetitive boilerplate code (metaprogramming^([9](#pgfId-1012807))).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于减少重复样板代码（元编程^([9](#pgfId-1012807)）的复杂系统。
- en: A rich and flexible type system that allows you to model a wide variety of problems.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个丰富且灵活的类型系统，允许你模拟各种各样的问题。
- en: A well-equipped standard library and various third-party libraries to handle
    various tasks.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个装备齐全的标准库和各种第三方库，用于处理各种任务。
- en: Great string processing facilities. This ability is usually a key selling point
    for any Swiss-Army-knife-style programming language. It is what initially made
    languages such as Perl, Python, and Ruby popular.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的字符串处理功能。这种能力通常是任何瑞士军刀式编程语言的关键卖点。这也是最初使Perl、Python和Ruby等语言流行的原因。
- en: Easy interfacing with a variety of other programming languages and tools.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与各种其他编程语言和工具的简单接口。
- en: While Julia’s big selling point is that it fixes the two-language problem, that
    does not mean the need to interface with existing Fortran, C, or C++ code is alleviated.
    The point of fixing the two-language problem is to avoid having to write Fortran
    or C code each time you hit a performance problem. You can stick with Julia the
    whole way.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Julia的最大卖点在于解决了双语言问题，但这并不意味着与现有的Fortran、C或C++代码的接口需求得到了缓解。解决双语言问题的目的是避免每次遇到性能问题时都必须编写Fortran或C代码。你可以全程使用Julia。
- en: However, if somebody has already solved a problem you have in another language,
    it may not make sense for you to rewrite that solution from scratch in Julia.
    Python, R, C, C++, and Fortran have large packages that have been built over many
    years, and the Julia community can’t replace those overnight. To be productive,
    Julia developers need to be able to take advantage of existing software solutions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有人已经用另一种语言解决了你遇到的问题，那么你可能没有必要从头开始在 Julia 中重写那个解决方案。Python、R、C、C++ 和 Fortran
    拥有经过多年构建的大型包，Julia 社区不可能一夜之间取代它们。为了提高生产力，Julia 开发者需要能够利用现有的软件解决方案。
- en: In the long term, there is an obvious advantage to transitioning legacy software
    to Julia. Maintaining old Fortran libraries will often require a lot more developer
    effort than maintaining a Julia library.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，将遗留软件迁移到 Julia 有一个明显的优势。维护旧的 Fortran 库通常需要比维护 Julia 库更多的开发者工作量。
- en: The greatest benefit is probably in the combinatorial power Julia gives. There
    are certain types of problems that require the construction of large monolithic
    libraries. Julia, in contrast, is exceptionally well suited for making small libraries
    that can easily be combined to match the functionality offered by large monolithic
    libraries in other languages. Let me give one example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的好处可能是 Julia 提供的组合能力。有一些类型的问题需要构建大型单体库。相比之下，Julia 极其适合构建小型库，这些库可以轻松组合以匹配其他语言中大型单体库提供的功能。让我举一个例子。
- en: Machine learning, a hot topic, powers self-driving cars, face recognition, voice
    recognition, and many other innovative technologies. The most famous packages
    for machine learning are PyTorch and TensorFlow. These packages are enormous monoliths
    maintained by large teams. There is no code sharing between them. Julia has a
    multitude of machine learning libraries, such as Knet, Flux (see [https://fluxml.ai](https://fluxml.ai)),
    and Mocha (see [http://mng.bz/epxG](http://mng.bz/epxG)). These libraries are
    tiny in comparison. Why? Because the capabilities of PyTorch and TensorFlow can
    be matched by combining multiple small libraries in Julia. Explaining more about
    why this works is a complex topic that requires a much deeper knowledge of Julia
    and how neural network libraries work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个热门话题，它推动了自动驾驶汽车、人脸识别、语音识别和其他许多创新技术。最著名的机器学习包是 PyTorch 和 TensorFlow。这些包是巨大的单体，由大型团队维护。它们之间没有代码共享。Julia
    有许多机器学习库，如 Knet、Flux（见 [https://fluxml.ai](https://fluxml.ai)）和 Mocha（见 [http://mng.bz/epxG](http://mng.bz/epxG)）。与它们相比，这些库非常小巧。为什么？因为
    PyTorch 和 TensorFlow 的功能可以通过在 Julia 中结合多个小型库来实现。更深入地解释为什么这有效是一个复杂的话题，需要更深入地了解
    Julia 以及神经网络库的工作原理。
- en: Having many small libraries is an advantage for general applications. Anyone
    building any kind of software will benefit from the ability to reuse existing
    pieces of software in a multitude of new ways, instead of having to reinvent the
    wheel. With legacy programming languages, one often needs to repeatedly implement
    the same functionality. TensorFlow and PyTorch, for instance, have a lot of duplicate
    functionality. Julia avoids duplication by putting a lot more functionality in
    libraries shared between many machine learning libraries. As you work through
    the chapters in this book, it will become increasingly clear how Julia can pull
    this off and why this capability is hard to achieve in many other languages.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有许多小型库对于通用应用来说是一个优势。任何构建软件的人都将从能够以多种新方式重用现有软件组件的能力中受益，而不是不得不重新发明轮子。在传统的编程语言中，人们经常需要反复实现相同的功能。例如，TensorFlow
    和 PyTorch 就有大量的重复功能。Julia 通过在许多机器学习库之间共享库来避免重复，随着你阅读本书的章节，将越来越清楚地了解 Julia 如何实现这一点，以及为什么这种能力在许多其他语言中很难实现。
- en: 1.6 What can I build with Julia?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 我可以用 Julia 做些什么？
- en: In principle, you can use Julia to build anything. However, every language has
    an ecosystem of packages and a community that may push you toward some types of
    development over others. Julia is no different.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，你可以使用 Julia 来构建任何东西。然而，每种语言都有其生态系统和社区，可能会推动你向某些类型的开发倾斜，而不是其他类型。Julia 也不例外。
- en: 1.6.1 Julia in the sciences
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 Julia 在科学领域
- en: Julia has a strong presence in the sciences. It is used, for example, in
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 在科学领域有着强大的影响力。例如，它被用于
- en: Computational biology
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算生物学
- en: Statistics
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计学
- en: Machine learning
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习
- en: Image processing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理
- en: Computational calculus
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算微积分
- en: Physics
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理学
- en: But Julia covers many more areas. For instance, it’s used in energy trading.
    The American Federal Reserve uses it to build complex macroeconomic models. Nobel
    Laureate Thomas J. Sargent founded QuantEcon, a platform that advances pedagogy
    in quantitative economics using both Julia and Python. He is a strong proponent
    of Julia, since the big problems in macroeconomics will be difficult to solve
    with other programming languages. In interviews with Lukas Biewald, Peter Norvig,
    a famous artificial intelligence (AI) researcher working at Google, has expressed
    how he thinks the machine learning world would benefit greatly from switching
    to Julia.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Julia 涵盖了许多更多领域。例如，它在能源交易中被使用。美国联邦储备银行使用它来构建复杂的宏观经济模型。诺贝尔奖获得者托马斯·J·萨金特创立了
    QuantEcon，这是一个利用 Julia 和 Python 推动定量经济学教学的平台。他是 Julia 的强烈支持者，因为用其他编程语言解决宏观经济中的大问题将会很困难。在与卢卡斯·比沃尔德的访谈中，谷歌著名的人工智能（AI）研究员彼得·诺维格表达了他认为机器学习世界将极大地从转向
    Julia 中受益的观点。
- en: I would be happier if Julia were the main language for AI.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Julia 成为人工智能的主要语言，我会更高兴。
- en: —Peter NorvigAuthor of *Artificial Intelligence, A Modern Approach*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ——彼得·诺维格，《人工智能：一种现代方法》的作者
- en: Life sciences is another obvious area for Julia. By 2025, 2-40 exabytes of human
    genome data will be collected every year. Most mainstream software cannot handle
    data at that scale. You will need a high-performance language, such as Julia,
    that can work with a variety of formats on a variety of hardware at the highest
    possible performance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生命科学是 Julia 另一个明显的应用领域。到 2025 年，每年将收集 2-40 兆字节的人类基因组数据。大多数主流软件都无法处理如此规模的数据。你需要一种高性能的语言，如
    Julia，它可以在各种硬件上以最高性能处理各种格式。
- en: At the time of writing this chapter, COVID-19 is still a major challenge in
    the world. The Julia package Pathogen is used to model infectious disease and
    has been used by COVID-19 researchers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章时，COVID-19 仍然是世界上的一个重大挑战。Julia 包 Pathogen 用于模拟传染病，并被 COVID-19 研究人员使用。
- en: 1.6.2 Nonscience uses of Julia
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 Julia 的非科学用途
- en: 'What about its nonscience uses? Julia also has a multitude of packages for
    other interests:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于它的非科学用途？Julia 也有许多用于其他兴趣的包：
- en: Genie—A full-stack MVC web framework
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Genie——一个全栈 MVC 网络框架
- en: Blink—For creating Electron GUI apps in Julia
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blink——用于在 Julia 中创建 Electron GUI 应用程序
- en: GTK—For making Julia GUI applications using the popular Linux GUI toolkit GTK
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GTK——用于使用流行的 Linux GUI 工具包 GTK 制作 Julia GUI 应用程序
- en: QML—For creating cross-platform GUIs using the QML markup language used in the
    Qt GUI toolkit
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML——用于使用 Qt GUI 工具包中使用的 QML 标记语言创建跨平台 GUI
- en: GameZero—For beginner game developing
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameZero——用于初学者游戏开发
- en: Luxor—For drawing vector images
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Luxor——用于绘制矢量图像
- en: Miletus—For writing financial contracts
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Miletus——用于编写金融合约
- en: TerminalMenus—For allowing interactive menus in the terminal
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TerminalMenus——用于在终端中允许交互式菜单
- en: Gumbo—For parsing HTML pages
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gumbo——用于解析 HTML 页面
- en: Cascadia—A CSS selector library for web scraping, extracting useful information
    from web pages
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cascadia——一个用于网络爬取的 CSS 选择器库，用于从网页中提取有用信息
- en: QRCode—For creating images of QR codes popular with ads to show machine-readable
    URLs
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QRCode——用于创建流行的广告 QR 码图像，以显示可读 URL
- en: As you can see, Julia has packages for general-purpose programming.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Julia 有用于通用编程的包。
- en: 1.7 Where Julia is less ideal
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 Julia 不太理想的应用场景
- en: In principle, Julia can be used for almost anything, but being a young language
    means the selection of libraries is not equally comprehensive in every area. For
    example, the selection of packages for web development is limited. Building something
    like a mobile application would not work well with Julia. It is also not great
    for small, short-running scripts—the kind you often write in Bash, Python, or
    Ruby. These limitations are due to Julia being JIT compiled.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，Julia 可以用于几乎任何事情，但作为一个年轻的语言，意味着在各个领域的库选择并不在所有领域都同样全面。例如，网络开发包的选择有限。使用 Julia
    构建类似移动应用这样的东西可能不会很好。它也不适合小型、短运行脚本——这类脚本你通常会在 Bash、Python 或 Ruby 中编写。这些限制是由于 Julia
    是即时编译的。
- en: That means Julia programs start more slowly than, for example, Python or Bash
    programs but begin to run much faster once the JIT compiler has converted critical
    parts of the code to machine code. There is an ongoing effort in the Julia community
    to reduce this problem, and there are myriad ways it can be tackled. Solutions
    include better caching of previous JIT compilations to being more selective about
    when something is JIT compiled.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Julia 程序的启动速度比 Python 或 Bash 程序慢，但一旦 JIT 编译器将代码的关键部分转换为机器代码，它们就会开始运行得更快。Julia
    社区正在进行一项持续的努力来减少这个问题，并且有无数种方法可以解决这个问题。解决方案包括更好地缓存之前的 JIT 编译，以及更谨慎地选择何时进行 JIT 编译。
- en: Julia is also not ideal for real-time systems. In a real-time system, the software
    must respond to things that happen in the real world. You can contrast this with,
    for instance, a weather simulator. With a weather simulator, it doesn’t matter
    what happens in the world outside the computer running the simulation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 也不适合实时系统。在实时系统中，软件必须对现实世界发生的事情做出反应。你可以将此与，例如，天气模拟器进行对比。在天气模拟器中，计算机运行模拟时外部世界发生的事情并不重要。
- en: However, if your program has to process data arriving from a measuring instrument
    every millisecond, then you can’t have sudden hiccups or delays. Otherwise, you
    risk losing important measurements. Julia is a garbage-collected language. That
    means data no longer used in your program gets automatically recycled for other
    purposes. The process of determining what memory to recycle tends to introduce
    small random delays and hiccups in program execution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的程序必须以每毫秒处理来自测量仪器的数据，那么你不能有突然的痉挛或延迟。否则，你可能会丢失重要的测量数据。Julia 是一种垃圾回收语言。这意味着程序中不再使用的数據会自动回收用于其他目的。确定要回收的内存的过程往往会引入程序执行中的小随机延迟和痉挛。
- en: This problem cannot be overstated. Robotics that require real-time behavior
    are being done in Julia. Researchers at MIT have simulated real-time control of
    the Boston Dynamics Atlas humanoid robot balancing on flat ground, which was done
    to prove that Julia can be used for online control of robots by tweaking how it
    allocates and releases memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题不容忽视。需要实时行为的机器人学正在使用 Julia 进行。麻省理工学院的学者们已经模拟了 Boston Dynamics Atlas 人形机器人平衡在平坦地面上的实时控制，这是为了证明可以通过调整内存的分配和释放来使用
    Julia 进行机器人的在线控制。
- en: Julia is not well suited for embedded systems with limited memory. The reason
    is that Julia achieves high performance by creating highly specialized versions
    of the same code. Hence memory usage for the code itself would be higher in Julia
    than for, say, C, C++, or Python.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 不适合内存有限的嵌入式系统。原因是 Julia 通过创建相同代码的高度专业化版本来实现高性能。因此，Julia 中代码本身的内存使用量会比
    C、C++ 或 Python 高。
- en: Finally, just like Python, Ruby, and other dynamic languages, Julia is not suited
    for typical systems programming, such as making database systems or operating
    system kernels. These tasks tend to require detailed control of resource usage,
    which Julia does not offer. Julia is a high-level language aimed at ease of use,
    which means many details about resource usage get abstracted away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像 Python、Ruby 和其他动态语言一样，Julia 也不适合典型的系统编程，如数据库系统或操作系统内核的开发。这些任务通常需要详细控制资源使用，而
    Julia 并不提供这些功能。Julia 是一种面向易用性的高级语言，这意味着许多关于资源使用的细节都被抽象化了。
- en: 1.8 What you will learn in this book
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 本书你将学到什么
- en: 'If you already program in another language, this book is for you. Every programming
    language has a unique set of features, tools, and communities. In this book, I
    focus on Julia’s unique characteristics as a language and on the tools and programming
    community built up around Julia, including the following integral aspects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在另一种语言中编程，这本书适合你。每种编程语言都有其独特的一套特性、工具和社区。在这本书中，我专注于 Julia 作为语言的独特特性，以及围绕
    Julia 建立的工具和编程社区，包括以下关键方面：
- en: Interactive programming using a read-evaluate-print loop (REPL)^([10](#pgfId-1014152))
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用读取-评估-打印循环（REPL）进行交互式编程^([10](#pgfId-1014152))
- en: Science- and mathematics-oriented code examples
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以科学和数学为导向的代码示例
- en: Julia’s unique *multiple-dispatch* feature and type system
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 独特的 *多重分派* 功能和类型系统
- en: Functional programming and how it compares with object-oriented programming
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程及其与面向对象编程的比较
- en: Package-oriented development over app-oriented development
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以包为导向的开发优于以应用为导向的开发
- en: 'Julia’s REPL-based development means you can launch the Julia command-line
    tool and start typing Julia expressions, which get evaluated when you press Enter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的基于REPL的开发意味着你可以启动Julia命令行工具并开始输入Julia表达式，当你按下Enter键时，这些表达式将被评估：
- en: '[PRE3]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I follow this approach through most of the book; it may be unfamiliar to readers
    who come from languages such as C/C++, Java, and C#, but in the Julia community,
    this development style is often favored. The REPL environment is used for experimentation,
    testing, and debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书的大部分内容中遵循这种方法；对于来自C/C++、Java和C#等语言的读者来说，这可能会感到陌生，但在Julia社区中，这种开发风格通常很受欢迎。REPL环境被用于实验、测试和调试。
- en: Because Julia is used heavily in data science, machine learning, mathematics,
    and science, I use many science- and math-oriented examples in this book, such
    as calculating sine values or simulating a rocket launch, rather than building
    a website or an inventory system. I keep the mathematics in this text at a high-school
    level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Julia在数据科学、机器学习、数学和科学领域被广泛使用，我在本书中使用了大量以科学和数学为导向的示例，例如计算正弦值或模拟火箭发射，而不是构建网站或库存系统。我在本文中的数学内容保持在高中水平。
- en: In this book, you will find in-depth coverage of Julia’s multiple-dispatch system
    and type system. These systems matter because they are a crucial reason Julia
    achieves such high performance. Because many Julia beginners are confused about
    these systems, I go into somewhat greater detail on these topics.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将找到对Julia的多重分派系统和类型系统的深入探讨。这些系统之所以重要，是因为它们是Julia实现如此高性能的关键原因。由于许多Julia初学者对这些系统感到困惑，我在这些主题上进行了更详细的阐述。
- en: Because the software industry is still dominated by object-oriented programming
    languages, it can be disorienting to jump into the more functional programming
    style of Julia. Thus I have devoted space to show how the same problems can be
    solved in a functional and object-oriented style. Many of the preferred functional
    programming practices are used throughout the book.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件行业仍然由面向对象的编程语言主导，跳入Julia的更函数式编程风格可能会让人感到困惑。因此，我专门留出空间来展示相同的问题可以用函数式和面向对象的方式解决。本书中使用了许多首选的函数式编程实践。
- en: When working through this book, you will not see a lot of applications made—that
    is, the kind where you click an icon, and it launches. Nor will you see command-line
    tools made in Julia that can be run from the console. This choice will be new
    to, for example, Ruby and Python developers, who are very accustomed to building
    software as command-line tools.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书的过程中，你不会看到很多应用程序的制作——也就是说，点击图标即可启动的那种。你也不会看到在控制台中可以运行的Julia制作的命令行工具。对于Ruby和Python开发者来说，这种选择可能会感到新颖，他们非常习惯于将软件作为命令行工具来构建。
- en: The Julia community is, instead, very package oriented. They encourage you to
    build packages over standalone applications, as these can more easily be shared
    with others and reused. This preference is reflected in the Julia toolchain and
    package manager. Julia doesn’t prevent you from building applications, but this
    book will get you into the package-first mindset. Build a package first, and then
    turn that into an application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Julia社区非常注重包。他们鼓励你构建包而不是独立的应用程序，因为这些包更容易与他人共享和重用。这种偏好反映在Julia的工具链和包管理器中。Julia不会阻止你构建应用程序，但本书将帮助你形成以包为先的思维模式。首先构建一个包，然后将其转化为应用程序。
- en: The package-oriented mindset is visible in how Julia’s tools tend to be delivered.
    The package manager and debugger are handled by loading particular packages into
    the Julia interactive environment and issuing commands there instead of in the
    shell. This way of working might be familiar to MATLAB and R users. One tends
    to focus on packages rather than applications in these two languages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 包导向的思维模式在Julia的工具交付方式中也很明显。包管理器和调试器是通过将特定的包加载到Julia交互式环境中并在此处发出命令来处理的，而不是在shell中。这种工作方式可能对MATLAB和R用户来说很熟悉。在这两种语言中，人们往往更关注包而不是应用程序。
- en: A typical statistician, scientist, or data analyst using Julia may load up favored
    packages into their Julia environment and execute Julia commands rather than clicking
    on some application made using Julia. The Julia REPL will typically be an integral
    part of most Julia workflows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Julia的典型统计学家、科学家或数据分析师可能会将他们偏好的包加载到他们的Julia环境中，并执行Julia命令，而不是点击使用Julia制作的某些应用程序。Julia的REPL通常是大多数Julia工作流程的一个组成部分。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Static typing makes it easier to construct high-performance programming languages
    and catch type mistakes before the program is run.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型使构建高性能编程语言和捕捉程序运行前类型错误变得更容易。
- en: Dynamic typing makes it possible to make highly interactive programming languages.
    For programming that requires rapid iteration, this is an advantage.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类型使得创建高度交互式的编程语言成为可能。对于需要快速迭代的编程，这是一个优势。
- en: Development of scientific code often requires the ability to experiment on large
    datasets easily. This requires interactive programming offered by dynamically
    typed languages.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学代码的开发通常需要能够轻松地在大型数据集上进行实验的能力。这需要动态类型语言提供的交互式编程。
- en: Scientific code often needs high performance, which dynamically typed languages
    normally cannot offer.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 科学代码通常需要高性能，而动态类型语言通常无法提供。
- en: Julia is able to solve the two-language problem by offering a high-performance,
    dynamically typed language. This ability drives the adoption of Julia in performance-demanding
    fields, such as climate modeling, astronomy, and macro-economic simulations.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia通过提供高性能、动态类型语言来解决两种语言问题。这种能力推动了Julia在性能要求高的领域（如气候建模、天文学和宏观经济模拟）的应用。
- en: Julia is not limited to science but is also an excellent general-purpose programming
    language.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia不仅限于科学，而且也是一种优秀的通用编程语言。
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)Fortran is an old language for scientific computing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)Fortran是一种用于科学计算的古老语言。
- en: ^(2.)Neural networks are a kind of algorithm inspired by the workings of the
    human brain.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)神经网络是一种受人类大脑工作原理启发的算法。
- en: ^(3.)C and C++ are related and widely used statically typed languages for systems
    programming.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (3.)C和C++是系统编程中广泛使用的相关静态类型语言。
- en: ^(4.)Java is used for a lot of web server software and Android phones.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (4.)Java被广泛应用于许多网络服务器软件和Android手机。
- en: ^(5.)Lua was originally made as a configuration language, but today it is primarily
    used to write games.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (5.)Lua最初被设计为一种配置语言，但如今主要用于编写游戏。
- en: ^(6.)Python is one of the most popular languages for data science and machine
    learning today.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (6.)Python是目前最受欢迎的数据科学和机器学习语言之一。
- en: ^(7.)TensorFlow is a popular machine learning library and platform for Python.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (7.)TensorFlow是一个流行的Python机器学习库和平台。
- en: ^(8.)PyTorch is a popular machine learning framework for Python.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (8.)PyTorch是一个流行的Python机器学习框架。
- en: ^(9.)Metaprogramming is code that writes code. It is an advanced concept not
    covered in this book.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (9.)元编程是编写代码的代码。这是一个本书未涉及的高级概念。
- en: ^(10.)REPL refers to an interactive command line for a programming language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (10.)REPL指的是一种编程语言的交互式命令行。
