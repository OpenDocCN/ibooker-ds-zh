- en: '8 Apples and Bananas: Find and replace'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 苹果和香蕉：查找和替换
- en: '| Have you ever misspelled a word? I haven’t, but I’ve heard that many other
    people often do. We can use computers to find and replace all instances of a misspelled
    word with the correction. Or maybe you’d like to replace all mentions of your
    ex’s name in your poetry with your new love’s name? Find and replace is your friend.
    | ![](../Images/8-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 你有没有拼写错过一个单词？我没有，但我听说很多人经常这样做。我们可以使用计算机来查找并替换所有拼写错误的单词。或者你可能想在你的诗歌中用你新爱人的名字替换你前任的名字？查找和替换是你的朋友。
    | ![图片](../Images/8-unnumb-1.png)  |'
- en: 'To get us started, let’s consider the children’s song “Apples and Bananas,”
    wherein we intone our favorite fruits to consume:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们开始，让我们考虑儿童歌曲“苹果和香蕉”，其中我们吟唱我们最喜欢的水果来食用：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Subsequent verses substitute the main vowel sound in the fruits for various
    other vowel sounds, such as the long “a” sound (as in “hay”):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的诗句将水果中的主要元音音素替换为各种其他的元音音素，例如长元音“a”音（如在“hay”中）：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or the ever-popular long “e” (as in “knee”):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 或者流行的长元音“e”音（如在“knee”中）：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And so forth. In this exercise, we’ll write a Python program called apples.py
    that takes some text, given as a single positional argument, and replaces all
    the vowels in the text with the given `-v` or `--vowel` options (with the default
    being `a`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推。在这个练习中，我们将编写一个名为 apples.py 的 Python 程序，该程序接受一些文本，作为单个位置参数，并将文本中的所有元音替换为给定的
    `-v` 或 `--vowel` 选项（默认为 `a`）。
- en: 'The program should be written in the 08_apples_and_bananas directory and should
    handle text on the command line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该编写在 `08_apples_and_bananas` 目录中，并应处理命令行上的文本：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And accept the `-v` or `--vowel` option:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并接受 `-v` 或 `--vowel` 选项：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Your program should *preserve the case* of the input vowels:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应该 *保留输入元音的大小写*：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As with the Howler program in chapter 5, the text argument may name a file,
    in which case your program should read the contents of the file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与第5章中的 Howler 程序一样，文本参数可能是一个文件名，在这种情况下，您的程序应该读取文件的内容：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 8.1 shows a diagram of the program’s inputs and output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1显示了程序输入和输出的示意图。
- en: '![](../Images/8-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/8-1.png)'
- en: Figure 8.1 Our program will accept some text and possibly a vowel. All the vowels
    in the given text will be changed to the same vowel, resulting in hilarity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：我们的程序将接受一些文本和一个可能的元音。给定文本中的所有元音都将被更改为相同的元音，从而产生幽默。
- en: 'Here is the usage statement that should print when there are no arguments:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是当没有参数时应该打印的用法说明：
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the program should always print usage for the `-h` and `--help` flags:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 并且程序应该始终打印 `-h` 和 `--help` 标志的用法：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| The program should complain if the `--vowel` argument is not a single, lowercase
    vowel:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '| 如果 `--vowel` 参数不是一个单独的小写元音，程序应该报错：'
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| ![](../Images/8-unnumb-2.png)  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| ![图片](../Images/8-unnumb-2.png)  |'
- en: 'Your program is going to need to do the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序需要执行以下操作：
- en: Take a positional argument that might be some plain text or may name a file
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个位置参数，该参数可能是某些纯文本或可能是一个文件名
- en: If the argument is a file, use the contents as the input text
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数是一个文件，则使用文件内容作为输入文本
- en: Take an optional `-v` or `--vowel` argument that should default to the letter
    “a”
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个可选的 `-v` 或 `--vowel` 参数，该参数默认为字母“a”
- en: Verify that the `--vowel` option is in the set of vowels “a,” “e,” “i,” “o,”
    and “u”
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 `--vowel` 选项是否在元音集合“a”、“e”、“i”、“o”和“u”中
- en: Replace all instances of vowels in the input text with the specified (or default)
    `--vowel` argument
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入文本中的所有元音替换为指定的（或默认的）`--vowel` 参数
- en: Print the new text to `STDOUT`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新文本打印到 `STDOUT`
- en: 8.1 Altering strings
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 修改字符串
- en: 'So far in our discussions of Python strings, numbers, lists, and dictionaries,
    we’ve seen how easily we can change or *mutate* variables. There is a problem,
    however, in that *strings are immutable*. Suppose we have a `text` variable that
    holds our input text:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的 Python 字符串、数字、列表和字典的讨论中，我们看到了我们如何轻松地更改或 *修改* 变量。然而，有一个问题，那就是 *字符串是不可变的*。假设我们有一个
    `text` 变量，它包含我们的输入文本：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we wanted to turn the first “e” (at index 2) into an “i,” we cannot do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将第一个“e”（索引为2）变成“i”，我们无法这样做：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To change `text`, we need to set it equal to an entirely new value. In chapter
    4 you saw that you can use a `for` loop to iterate over the characters in a string.
    For instance, I could laboriously uppercase `text` like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 `text`，我们需要将其设置为完全新的值。在第4章中，你看到可以使用 `for` 循环遍历字符串中的字符。例如，我可以这样费力地将 `text`
    转换为大写：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Initialize a variable equal to the empty string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个变量等于空字符串。
- en: ② Iterate through each character in the text.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ② 遍历文本中的每个字符。
- en: ③ Append the uppercase version of the character to the variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将字符的大写版本追加到变量中。
- en: 'We can inspect the value of `new` to verify that it is all uppercase:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查`new`的值来验证它是否全部为大写：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this idea, you could iterate through the characters of `text` and build
    up a new string. Whenever the character is a vowel, you could change it for the
    given `vowel`; otherwise, you could use the character itself. We had to identify
    vowels in chapter 2, so you can refer back to how you did that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个想法，你可以遍历`text`中的字符并构建一个新的字符串。每当字符是元音时，你可以用给定的`vowel`替换它；否则，你可以使用字符本身。我们在第2章中识别了元音，所以你可以回顾一下你是如何做到这一点的。
- en: 8.1.1 Using the str.replace() method
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 使用`str.replace()`方法
- en: 'In chapter 4 we talked about using the `str.replace()` method to replace all
    the numbers in a string with a different number. Maybe that would be a good way
    to solve this problem? Let’s look at the documentation for that using `help(str.replace)`
    in the REPL:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们讨论了使用`str.replace()`方法将字符串中的所有数字替换为不同的数字。这可能是一个解决问题的好方法？让我们使用REPL中的`help(str.replace)`查看该方法的文档：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s give that a try. We could replace “T” with “X”:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。我们可以将“T”替换为“X”：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This seems promising! Can you see a way to replace all the vowels using this
    idea? Remember that this method never mutates the given string but instead returns
    a new string that you will need to assign to a variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很有希望！你能看到一种用这个想法替换所有元音的方法吗？记住，这个方法永远不会修改给定的字符串，而是返回一个新的字符串，你需要将其赋值给一个变量。
- en: 8.1.2 Using str.translate()
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 使用`str.translate()`
- en: We also looked at the `str.translate()` method in chapter 4\. There we created
    a dictionary that described how to turn one character, like “1,” into another
    string like “9.” Any character not mentioned in the dictionary was left alone.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在第4章中讨论了`str.translate()`方法。在那里，我们创建了一个字典，描述了如何将一个字符，例如“1”，转换成另一个字符串，例如“9”。任何在字典中没有提到的字符都被保留原样。
- en: 'The documentation for this method is a bit more cryptic:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的文档有点晦涩：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In my solution, I created the following dictionary:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的解决方案中，我创建了以下字典：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That is the argument to the `str.maketrans()` function, which creates a translation
    table that is then used with `str.translate()` to change all the characters present
    as keys in the dictionary to their corresponding values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是传递给`str.maketrans()`函数的参数，它创建了一个转换表，然后与`str.translate()`一起使用，将字典中作为键的所有字符转换为它们的对应值：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What keys and values should you have in a dictionary if you want to change all
    the vowels, both lower- and uppercase, to some other value?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将所有大小写字母的元音都转换为其他值，字典中应该有哪些键和值？
- en: 8.1.3 Other ways to mutate strings
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 其他修改字符串的方法
- en: If you know about regular expressions, that’s a strong solution. If you haven’t
    heard of them, don’t worry--I’ll introduce them in the discussion.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解正则表达式，这是一个强大的解决方案。如果你还没有听说过它们，不要担心——我将在讨论中介绍它们。
- en: The point is for you to *play* with this and come up with a solution. I found
    eight ways to change all the vowels to a new character, so there are many ways
    you could approach this. How many *different* methods can you find on your own
    before you look at my solution?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是让你*玩*这个，并找到解决方案。我发现有八种方法可以将所有元音转换为新的字符，所以有几种方法可以解决这个问题。在你查看我的解决方案之前，你能找到多少种*不同*的方法？
- en: 'Here are a few hints:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Consider using the `choices` option in the `argparse` documentation to constrain
    the `--vowel` options. Be sure to read section A.4.3 in the appendix for an example.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在`argparse`文档中使用`choices`选项来约束`--vowel`选项。务必阅读附录中的A.4.3部分以获取示例。
- en: Be sure to change both lower- and uppercase versions of the vowels, preserving
    the case of the input characters.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保更改元音字母的大小写版本，同时保留输入字符的大小写。
- en: Now is the time to dig in and see what you can do before you look at my solution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是深入挖掘并看看在你查看我的解决方案之前你能做什么的时候了。
- en: 8.2 Solution
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 解决方案
- en: Here is the first solution I wanted to share. After this, we’ll explore several
    more.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想分享的第一个解决方案。在此之后，我们将探索更多。
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① The input might be text or a filename, so I defined it as a string.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 输入可能是文本或文件名，所以我将其定义为字符串。
- en: ② Use “choices” to restrict the user to one of the listed vowels.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用“choices”限制用户只能选择列表中的一个元音字母。
- en: ③ Check if the text argument is a file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查文本参数是否是文件。
- en: ④ If it is, read the file using str.rstrip() to remove any trailing whitespace.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果是，使用`str.rstrip()`读取文件以删除任何尾随空格。
- en: ⑤ Create a new list to hold the characters for the transformed text.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建一个新的列表来保存转换文本的字符。
- en: ⑥ Iterate through each character of the text.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 遍历文本中的每个字符。
- en: ⑦ Check if the current character is in the list of lowercase vowels.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 检查当前字符是否在小写元音字母的列表中。
- en: ⑧ If it is, use the vowel value instead of the character.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果是，使用元音值而不是字符。
- en: ⑨ Check if the current character is in the list of uppercase vowels.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 检查当前字符是否在大写元音字母的列表中。
- en: ⑩ If it is, use the value of vowel.upper() instead of the character.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果是，使用元音字母的大写形式而不是字符。
- en: ⑪ Otherwise, use the character itself.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 否则，使用字符本身。
- en: ⑫ Print a new string made by joining the new text list on the empty string.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 打印一个新的字符串，通过空字符串连接新的文本列表。
- en: 8.3 Discussion
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 讨论
- en: I came up with eight ways to write my solution. All of them start with the same
    `get_args()` function, so let’s look at that first.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我想出了八种编写解决方案的方法。它们都以相同的 `get_args()` 函数开始，所以让我们先看看这个函数。
- en: 8.3.1 Defining the parameters
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 定义参数
- en: This is one of those problems that has many valid and interesting solutions.
    The first problem to solve is, of course, getting and validating the user’s input.
    As always, I will use `argparse`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这类问题有很多有效且有趣的解决方案。当然，首先要解决的问题当然是获取和验证用户的输入。像往常一样，我会使用 `argparse`。
- en: 'I usually define all my required parameters first. The `text` parameter is
    a positional string that *might* be a filename:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常首先定义所有必需的参数。`text` 参数是一个位置字符串，*可能*是一个文件名：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `--vowel` option is also a string, and I decided to use the `choices` option
    to have `argparse` validate that the user’s input is in the `list(''aeiou'')`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`--vowel` 选项也是一个字符串，我决定使用 `choices` 选项让 `argparse` 验证用户的输入是否在 `list(''aeiou'')`
    中：'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That is, `choices` wants a `list` of options. I could pass in `[''a'',` `''e'',`
    `''i'',` `''o'',` `''u'']`, but that’s a lot of typing on my part. It’s much easier
    to type `list(''aeiou'')` and have Python turn the `str` “aeiou” into a `list`
    of the characters. Both approaches produce the same results, because `list(str)`
    creates a `list` of the individual characters in a given string. And remember,
    the use of single or double quotes doesn’t matter. Any value enclosed in either
    type of quotes is a `str`, even if it’s just one character:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 即，`choices` 需要一个选项的 `list`。我可以传入 `['a', 'e', 'i', 'o', 'u']`，但这需要我输入很多。使用 `list('aeiou')`
    并让 Python 将字符串 “aeiou” 转换为字符的 `list` 要简单得多。两种方法都会产生相同的结果，因为 `list(str)` 会创建一个包含给定字符串中各个字符的
    `list`。记住，使用单引号或双引号无关紧要。任何用这两种类型之一括起来的值都是 `str`，即使它只是一个字符：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can even write a test for this. The absence of any error means that it’s
    OK:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以为此编写一个测试。没有错误意味着它是可以的：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next task is detecting whether `text` is the name of a file that should
    be read for the text, or if it is the text itself. This is the same code I used
    in chapter 5, and again I chose to handle the `text` argument inside the `get_args()`
    function so that, by the time I get `text` inside `main()`, it’s all been handled.
    Figure 8.2 illustrates how we can chain the `open()` function to the `read()`
    method of a file handle to the `rstrip()` method of a string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是检测 `text` 是否是应该读取文本的文件名，或者它本身是文本。这是我在第5章中使用过的相同代码，而且我又选择在 `get_args()`
    函数内部处理 `text` 参数，这样，当我得到 `main()` 中的 `text` 时，它已经被处理过了。图8.2说明了我们如何将 `open()` 函数链接到文件句柄的
    `read()` 方法，再链接到字符串的 `rstrip()` 方法。
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/8-2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图8-2](../Images/8-2.png)'
- en: Figure 8.2 We can chain methods together to create pipelines of operations.
    The open() returns a file handle that we can read. The `read()` operation returns
    a string that we strip of whitespace.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 我们可以将方法链式连接起来以创建操作管道。`open()` 返回一个我们可以读取的文件句柄。`read()` 操作返回一个字符串，我们将它去除空白字符。
- en: 'At this point, the user’s arguments to the program have been fully vetted.
    We’ve got `text` either from the command line or from a file, and we’ve verified
    that the `--vowel` value is one of the allowed characters. To me, this code is
    a single “unit” where I’ve handled the arguments. Processing can now go forward
    by returning the arguments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，程序的用户参数已经全部经过审查。我们得到了来自命令行或文件的 `text`，并且我们已经验证了 `--vowel` 的值是允许的字符之一。对我来说，这段代码是一个单一的“单元”，我在其中处理了参数。现在可以通过返回参数来继续处理：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 8.3.2 Eight ways to replace the vowels
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 八种替换元音的方法
- en: How many ways did you find to replace the vowels? You only needed one, of course,
    to pass the tests, but I hope you probed the edges of the language to see how
    many different techniques there are. I know that the Zen of Python says
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您找到了多少种替换元音的方法？当然，您只需要一种方法来通过测试，但我希望您探索了语言的边缘，看看有多少不同的技术。我知道Python之禅说
- en: There should be one--and preferably only one--obvious way to do it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应该只有一个——最好是只有一个——明显的方法来做这件事。
- en: '[www.python.org/dev/peps/pep-0020/](http://www.python.org/dev/peps/pep-0020/)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.python.org/dev/peps/pep-0020/](http://www.python.org/dev/peps/pep-0020/)'
- en: But I really come from the Perl mentality, where “There Is More Than One Way
    To Do It” (TIMTOWTDI or “Tim Toady”).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但我实际上来自Perl思维模式，其中“有多种方法可以做到”（TIMTOWTDI或“Tim Toady”）。
- en: 'Method 1: Iterating through every character'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：遍历每个字符
- en: 'The first method is similar to what we did in chapter 4, where we used a `for`
    loop on a string to access each character. Here is some code you can copy and
    paste into the `ipython` REPL:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法与我们在第4章中做的方法类似，我们在字符串上使用`for`循环来访问每个字符。以下是一些您可以复制并粘贴到`ipython` REPL中的代码：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Set text to the string “Apples and Bananas!”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将文本设置为字符串“苹果和香蕉！”
- en: ② Set the vowel variable to the string “o”. That is, we’ll replace all the vowels
    with this one.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将元音变量设置为字符串“o”。也就是说，我们将用这个字符替换所有的元音。
- en: ③ Set the new_text variable to an empty list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将new_text变量设置为空列表。
- en: ④ Use a for to iterate text, putting each character into the char variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用for循环遍历文本，将每个字符放入char变量中。
- en: ⑤ If the character is in the set of lowercase vowels, add the vowel “o” to the
    new text.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果字符在小写元音集合中，将元音“o”添加到新文本中。
- en: ⑥ If the character is in the set of uppercase vowels, substitute the vowel.upper()
    version “O” into the new text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果字符在 uppercase 元音集合中，将vowel.upper()版本的“O”替换到新文本中。
- en: ⑦ Otherwise, add the current character to the new text.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 否则，将当前字符添加到新文本中。
- en: ⑧ Turn the new_text list into a new str by joining it on the empty string ('').
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将new_text列表通过空字符串（''）连接成一个新字符串。
- en: 'Note that it would be just fine to start off making `new_text` an empty string
    and then concatenating the new characters. With that approach, you wouldn’t have
    to `str.join()` them at the end. Whatever you prefer:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一开始将`new_text`设为空字符串，然后连接新字符是完全可行的。采用这种方法，您就不需要在最后使用`str.join()`了。无论您喜欢哪种方式：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next I’m going to show you several alternate solutions. They’re all functionally
    equivalent because they all pass the tests--the point here is to explore the Python
    language and understand it. For the alternate solutions, I’ll just show the `main()`
    function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将向您展示几个替代解决方案。它们在功能上是等效的，因为它们都通过了测试——这里的目的是探索Python语言并理解它。对于替代解决方案，我将只展示`main()`函数。
- en: 'Method 2: Using the str.replace() method'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：使用str.replace()方法
- en: 'Here is a way to solve the problem using the `str.replace()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`str.replace()`方法解决问题的方法：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① Iterate through the list of vowels. We don’t have to say list('aeiou') here--Python
    will automatically treat the string 'aeiou' like a list because we are using it
    in a list context with the for loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ① 遍历元音列表。我们不必在这里说list('aeiou')——Python会自动将字符串'aeiou'视为列表，因为我们正在使用它作为for循环中的列表上下文。
- en: ② Use the str.replace() method twice to replace both the lower- and uppercase
    versions of the vowel in the text.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用str.replace()方法两次来替换文本中元音的两种大小写版本。
- en: 'Earlier in the chapter, I mentioned the `str.replace()` method, which will
    return a new string with all instances of one string replaced by another:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我提到了`str.replace()`方法，它将返回一个新的字符串，其中所有实例的一个字符串都被另一个字符串替换：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that the original string remains unchanged:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，原始字符串保持不变：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You don’t have to chain the two `str.replace()` methods. It could be written
    as two separate statements, as illustrated in figure 8.3\.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必链式调用两个`str.replace()`方法。它可以写成两个单独的语句，如图8.3所示。
- en: '![](../Images/8-3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-3.png)'
- en: Figure 8.3 The chained calls to `str.replace()` can be written as two separate
    statements if you prefer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 如果您更喜欢，可以将`str.replace()`的链式调用写成两个单独的语句。
- en: 'Method 3: Using the str.translate() method'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法3：使用str.translate()方法
- en: 'Can we use the `str.translate()` method to solve this? I showed in chapter
    4 how you could use a dictionary called `jumper` to change a character like “1”
    to the character “9.” In this problem, we need to change all the lower- and uppercase
    vowels (10 total) to some given `vowel`. For instance, to change all the vowels
    into the letter “o,” we could create a translation table `t` like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `str.translate()` 方法解决这个问题吗？我在第4章展示了如何使用一个名为 `jumper` 的字典将字符“1”转换为字符“9”。在这个问题中，我们需要将所有的小写和大写元音（总共10个）转换为某个给定的
    `vowel`。例如，要将所有元音转换为字母“o”，我们可以创建一个转换表 `t`，如下所示：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We could use `t` with the `str.translate()` method:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `t` 与 `str.translate()` 方法一起使用：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you read the documentation for `str.maketrans()`, you will find that another
    way to specify the translation table is to supply two strings of equal lengths:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读 `str.maketrans()` 的文档，您会发现指定转换表的另一种方法是提供两个长度相等的字符串：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first string should contain the letters you want to replace, which are
    the lower- and uppercase vowels `''aeiouAEIOU''`. The second string is composed
    of the letters to use for substitution. We want to use `''ooooo''` for `''aeiou''`
    and `''OOOOO''` for `''AEIOU''`. We can repeat `vowel` five times using the `*`
    operator that you’ll normally associate with numeric multiplication. This is (sort
    of) “multiplying” a string, so, OK, I guess:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串应包含要替换的字母，即小写和大写元音 `'aeiouAEIOU'`。第二个字符串由用于替换的字母组成。我们希望用 `'ooooo'` 替换
    `'aeiou'`，用 `'OOOOO'` 替换 `'AEIOU'`。我们可以使用 `*` 操作符（你通常将其与数值乘法关联）重复 `vowel` 五次。这（某种程度上）是“乘以”一个字符串，所以，好吧，我想：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next we handle the uppercase version:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们处理大写版本：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And now we can make the translation table in one line of code like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用一行代码创建转换表，如下所示：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s inspect the `trans` table. We’ll use the `pprint.pprint()` (pretty-print)
    function so we can read it easily:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `trans` 表。我们将使用 `pprint.pprint()`（美化打印）函数，这样我们就可以轻松地阅读它：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The enclosing curlies `{}` tell us that `trans` is a `dict`. Each character
    is represented by its *ordinal* value, which is the character’s position in the
    ASCII table ([www.asciitable.com](http://www.asciitable.com)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 包围的括号 `{}` 告诉我们 `trans` 是一个 `dict`。每个字符都由其 *序数值* 表示，这是字符在ASCII表中的位置（[www.asciitable.com](http://www.asciitable.com)）。
- en: 'You can go back and forth between characters and their ordinal values by using
    the `chr()` and `ord()` functions. We will explore and use these functions later
    in chapter 18\. Here are the `ord()` values for the vowels:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `chr()` 和 `ord()` 函数在字符和它们的序数值之间来回转换。我们将在第18章中探索并使用这些函数。以下是元音的 `ord()`
    值：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can create the same output by starting with the `ord()` values to get the
    `chr()` values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从 `ord()` 值开始来创建相同的输出，以获取 `chr()` 值：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you’d like to inspect all the ordinal values for all the printable characters,
    you can run this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查所有可打印字符的所有序数值，您可以运行此命令：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I haven’t included the output because there are 100 printable characters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有包括输出，因为有100个可打印字符：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So the `trans` table is a mapping from one character to another, just like
    in the “Jump the Five” exercise in chapter 4\. The lowercase vowels (“aeiou”)
    all map to the ordinal value `111`, which is “o.” The uppercase vowels (“AEIOU”)
    map to 79, which is “O.” You can use the `dict.items()` method to iterate over
    the key/value pairs of `trans` to verify that this is the case:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`trans` 表是从一个字符到另一个字符的映射，就像在第4章的“跳过五个”练习中一样。小写元音（“aeiou”）都映射到序数值 `111`，即“o”。大写元音（“AEIOU”）映射到
    `79`，即“O”。您可以使用 `dict.items()` 方法遍历 `trans` 的键/值对以验证这一点：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The original `text` will be unchanged by the `str.translate()` method, so we
    can overwrite `text` with the new version. Here’s how I wrote that idea in my
    solution:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `text` 不会被 `str.translate()` 方法更改，因此我们可以用新版本覆盖 `text`。以下是我如何在解决方案中写下这个想法：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Create a translation table from each of the vowels, both lower- and uppercase,
    to their respective characters. The lowercase vowels will be matched to the lowercase
    vowel argument, and the uppercase vowels will be matched to the uppercase vowel
    argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从每个元音（大小写）创建一个转换表，将其映射到相应的字符。小写元音将匹配小写元音参数，大写元音将匹配大写元音参数。
- en: ② Call the str.translate() method on the text variable, passing the translation
    table as an argument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在文本变量上调用 `str.translate()` 方法，并将转换表作为参数传递。
- en: That was a lot of explanation about `ord()` and `chr()` and dictionaries and
    such, but look how simple and elegant that solution is. This is much shorter than
    method 1\. Fewer lines of code (LOC) means fewer opportunities for bugs!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ord()`和`chr()`以及字典等的解释很多，但看看这个解决方案是多么简单和优雅。这比方法1短得多。更少的代码行（LOC）意味着更少的错误机会！
- en: 'Method 4: Using a list comprehension'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法4：使用列表推导式
- en: 'Following up on method 1, we can use a *list comprehension* to significantly
    shorten the `for` loop. In chapter 7 we looked at a dictionary comprehension as
    a one-line method to create a new dictionary using a `for` loop. Here we can do
    the same, creating a new `list`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法1的基础上，我们可以使用列表推导式来显著缩短`for`循环。在第7章中，我们研究了字典推导式，作为使用`for`循环创建新字典的单行方法。这里我们可以做同样的事情，创建一个新的`list`：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Use a list comprehension to process all the characters in args.text to create
    a new list called text.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用列表推导式处理`args.text`中的所有字符，创建一个名为`text`的新列表。
- en: '② Use a compound if expression to handle three cases: lowercase vowel, uppercase
    vowel, and the default.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用复合`if`表达式来处理三种情况：小写元音，大写元音和默认情况。
- en: ③ Print the translated string by joining the text list on the empty string.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 通过在空字符串上连接`text`列表来打印翻译后的字符串。
- en: 'Let’s talk just a bit more about list comprehensions. As an example, we can
    generate a list of the squared values of the numbers 1 through 4 by using the
    `range()` function to get the numbers from a starting number to an ending number
    (not inclusive). In the REPL, we must use the `list()` function to force the production
    of the values, but usually your code won’t need to do this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈列表推导式。例如，我们可以通过使用`range()`函数从起始数字到结束数字（不包括）获取数字，来生成1到4的数字的平方值的列表。在REPL中，我们必须使用`list()`函数来强制生成值，但通常你的代码不需要这样做：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note `range()` is another example of a *lazy* function in Python, which means
    it won’t actually produce values until your program needs them--a lazy function
    is a promise to do something. If your program branches in such a way that you
    never need to produce the values, the work is never done, meaning your code is
    more efficient.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`range()`是Python中另一个*惰性*函数的例子，这意味着它实际上不会产生值，直到你的程序需要它们--一个惰性函数是一个承诺去做某事。如果你的程序以这种方式分支，以至于你永远不会需要产生值，那么工作就不会完成，这意味着你的代码更高效。
- en: 'We can write a `for` loop to `print()` the squares:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写一个`for`循环来`print()`平方数：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead of printing the values, imagine that we wanted to create a new `list`
    that contains those values. One way to do this would be to create an empty `list`
    and then use `list.append()` to add each value in a `for` loop:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是打印值，想象一下我们想要创建一个包含这些值的新`list`。一种方法是在`for`循环中创建一个空的`list`，然后使用`list.append()`在循环中添加每个值：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we can verify that we have our squares:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证我们得到了我们的平方数：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can achieve the same result in fewer lines of code using a list comprehension
    to generate our new `list`, as shown in figure 8.4.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用列表推导式在更少的代码行中实现相同的结果，如图8.4所示。
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](../Images/8-4.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图8-4](../Images/8-4.png)'
- en: Figure 8.4 A list comprehension creates a new list using a `for` loop to iterate
    over the source values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 列表推导式通过一个`for`循环遍历源值来创建一个新的列表。
- en: 'We can assign this list to the variable `squares` and verify that we still
    have what we expected. Ask yourself which version of the code you’d rather maintain:
    the longer one with the `for` loop, or the shorter one with the list comprehension?'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个列表赋值给变量`squares`并验证我们是否仍然得到了预期的结果。问问自己，你更愿意维护哪种版本的代码：带有`for`循环的较长的版本，还是带有列表推导式的较短的版本？
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For this version of the program, we’ll condense the `if`/`elif`/`else` logic
    from method 1 into a compound `if` expression. First let’s see how we could shorten
    the `for` loop version:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序的版本，我们将把方法1中的`if`/`elif`/`else`逻辑压缩成一个复合`if`表达式。首先，让我们看看我们如何缩短`for`循环版本：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Figure 8.5 shows how the parts of the expression match up to the original `if`/`elif`/
    `else`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5显示了表达式的各个部分如何与原始的`if`/`elif`/`else`匹配：
- en: '![](../Images/8-5.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图8-5](../Images/8-5.png)'
- en: Figure 8.5 The three conditional branches can be written using two `if` expressions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 三种条件分支可以用两个`if`表达式来编写。
- en: 'Now let’s turn that into a list comprehension:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其转换为列表推导式：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① Select the character using the compound if expression.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用复合`if`表达式选择字符。
- en: ② Perform this action for each character in the text.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ② 对文本中的每个字符执行此操作。
- en: The code is denser than the previous `for` loop, but it has advantages in that
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码比之前的`for`循环更密集，但它在以下方面有优势：
- en: The list comprehension is shorter and generates our list rather than using the
    side effects of `list.append()`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式更短，并生成我们的列表，而不是使用`list.append()`的副作用。
- en: The compound `if` expression will not compile if we forget one of the conditional
    branches.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们忘记其中一个条件分支，复合`if`表达式将无法编译。
- en: 'Method 5: Using a list comprehension with a function'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法5：使用带有函数的列表推导式
- en: 'The compound `if` expression inside the list comprehension is complicated enough
    that it probably should be a function. We can *define* a new function with the
    `def` statement and call it `new_char()`. It accepts a character we’ll call `c`.
    After that, we can use the same compound `if` expression as before:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式中的复合`if`表达式足够复杂，可能应该是一个函数。我们可以使用`def`语句定义一个新的函数，并调用它`new_char()`。它接受一个我们将称之为`c`的字符。之后，我们可以使用与之前相同的复合`if`表达式：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① Define a function to choose a new character. Note that it uses the vowel variable
    because the function has been declared in the same scope. This is called a closure,
    because new_char() closes over the variable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个函数来选择新字符。请注意，它使用元音变量，因为函数是在同一作用域内声明的。这被称为闭包，因为`new_char()`封闭在变量上。
- en: ② Use the compound if expression to select the correct character.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用复合`if`表达式选择正确的字符。
- en: ③ Use a list comprehension to process all the characters in text.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用列表推导式处理文本中的所有字符。
- en: 'You can play with the `new_char()` function by putting this into your REPL:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在你的REPL中放入以下内容来玩`new_char()`函数：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It should always return the letter “o” if the argument is a lowercase vowel:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是元音字母，它应该始终返回字母“o”：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It should return “O” if the argument is an uppercase vowel:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是大写元音，它应该返回“O”：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Otherwise, it should return the given character:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它应该返回给定的字符：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can use the `new_char()` function to process all the characters in `text`,
    using a list comprehension:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`new_char()`函数通过列表推导式处理`text`中的所有字符：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the `new_char()` function is declared *inside* the `main()` function.
    Yes, you can do that! The function is then only “visible” inside the `main()`
    function. I’ve done this because we want to reference the `vowel` variable inside
    the function without passing it as an argument.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`new_char()`函数是在`main()`函数内部声明的。是的，你可以这样做！然后函数就只在`main()`函数内部“可见”。我这样做是因为我们想在函数内部引用`vowel`变量，而不需要将其作为参数传递。
- en: As an example, let’s define a `foo()` function that has a `bar()` function inside
    it. We can call `foo()`, and it will call `bar()`. But from outside of `foo()`,
    the `bar()` function does not exist (it “is not visible” or “is not in scope”).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义一个`foo()`函数，它内部有一个`bar()`函数。我们可以调用`foo()`，然后它会调用`bar()`。但从`foo()`外部，`bar()`函数不存在（它“不可见”或“不在作用域内”）。
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: I declared the `new_char()` function inside `main()` because I wanted to reference
    the `vowel` variable inside the function, as shown in figure 8.6\. Because `new_char()`
    “closes” around the `vowel`, it is a special type of function called a *closure*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`main()`内部声明了`new_char()`函数，因为我想要在函数内部引用`vowel`变量，如图8.6所示。因为`new_char()`“封闭”在`vowel`周围，它是一种特殊类型的函数，称为*闭包*。
- en: '![](../Images/8-6.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-6.png)'
- en: Figure 8.6 The `new_char()` function can only be seen within the `main()` function.
    It creates a closure because it references the `vowel` variable. Code outside
    of `main()` cannot see or call `new_char()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 `new_char()`函数只能在`main()`函数内部看到。它创建了一个闭包，因为它引用了`vowel`变量。`main()`外部代码无法看到或调用`new_char()`。
- en: 'If we don’t write this as a closure, we will have to pass the `vowel` as an
    argument:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不将其作为闭包编写，我们将不得不将`vowel`作为参数传递：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ① We need to pass args.vowel as an argument to the new_char() function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们需要将`args.vowel`作为参数传递给`new_char()`函数。
- en: ② The vowel is only visible inside the main() function. Since new_char() is
    no longer declared in the same scope, we need to accept vowel as an argument.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ② 元音只可见于`main()`函数内部。由于`new_char()`不再在同一作用域内声明，我们需要将元音作为参数接受。
- en: While the closure method is interesting, this version is arguably easier to
    understand. It would also be easier to write a unit test for it, which is something
    we’ll start doing soon.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管闭包方法很有趣，但这个版本可能更容易理解。它也更容易为它编写单元测试，这是我们很快就会开始做的事情。
- en: 'Method 6: Using the map() function'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法6：使用`map()`函数
- en: 'For this method, I’ll introduce the `map()` function, as it’s quite similar
    to a list comprehension. The `map()` function accepts two arguments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种方法，我将介绍`map()`函数，因为它与列表推导式非常相似。`map()`函数接受两个参数：
- en: A function
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数
- en: An iterable like a list, a lazy function, or a generator
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个像列表、惰性函数或生成器这样的可迭代对象
- en: '![](../Images/8-unnumb-3.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图8-unnumb-3.png](../Images/8-unnumb-3.png)'
- en: I like to think of `map()` like a paint booth--you load up the booth with, say,
    blue paint. Unpainted cars go in, blue paint is applied, and blue cars come out.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把`map()`想象成一个喷漆间--你把喷漆间装满，比如说，蓝色油漆。未上漆的汽车进去，涂上蓝色油漆，然后蓝色的汽车出来。
- en: 'We can create a function to “paint” cars by adding the string “blue” to the
    beginning:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在前面添加字符串“blue”来创建一个“paint”汽车的功能：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| The first argument you see here starts with the keyword `lambda`, which is
    used to create an *anonymous* function. With the regular `def` keyword, the function
    name follows. With `lambda`, there is no name, only the list of parameters and
    the function body. | ![](../Images/8-unnumb-4.png)  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 你在这里看到的第一个参数以关键字`lambda`开头，它用于创建一个*匿名*函数。使用常规的`def`关键字时，函数名跟在后面。使用`lambda`时，没有名字，只有参数列表和函数体。|
    ![图8-unnumb-4.png](../Images/8-unnumb-4.png) |'
- en: 'For example, an `add1()` function that adds `1` to a value is a regular named
    function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`add1()`函数将`1`加到值上是一个常规的命名函数：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It works as expected:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它按预期工作：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Compare the preceding definition to one created using `lambda`, which we assign
    to the variable `add1`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的定义与使用`lambda`创建的、分配给变量`add1`的定义进行比较：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This definition of `add1` is functionally equivalent to the first version.
    We call it just like the `add1()` function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`add1`的定义在功能上与第一个版本等效。我们像调用`add1()`函数一样调用它：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The body for a `lambda` is a brief (usually one-line) expression. There is no
    `return` statement because the final evaluation of the expression is returned
    automatically. In figure 8.7, you can see that the `lambda` will return the result
    of `n` `+` `1`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`的体是一个简短的表达式（通常是单行）。因为没有`return`语句，所以表达式的最终评估是自动返回的。在图8.7中，你可以看到`lambda`将返回`n
    + 1`的结果。'
- en: '![](../Images/8-7.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7](../Images/8-7.png)'
- en: Figure 8.7 Both `def` and `lambda` are used to create functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 `def`和`lambda`都用于创建函数。
- en: In both versions of the `add1` definition, using `def` and `lambda`, the argument
    to the function is `n`. In the usual named function, `def` `add(n)`, the argument
    is defined in the parentheses just after the function name. In the `lambda` `n`
    version, there is no function name and no parentheses around the function’s parameter,
    `n`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add1`定义的两个版本中，无论是使用`def`还是`lambda`，函数的参数都是`n`。在常规的命名函数中，`def add(n)`，参数定义在函数名后的括号内。而在`lambda
    n`版本中，没有函数名，也没有围绕参数`n`的括号。
- en: 'There is no difference in how you can use the two types of functions. They
    are both functions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这两种类型的函数的方式没有区别。它们都是函数：
- en: '[PRE66]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you are comfortable with using `add1()` in a list comprehension, like this,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于在列表推导中使用`add1()`，就像这样，
- en: '[PRE67]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: it’s a short step to using the `map()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map()`函数只需很短的一步。
- en: The `map()` function is a lazy function, like the `range()` function we looked
    at earlier. It won’t create the values until you actually need them, as compared
    to a list comprehension, which will produce the resulting `list` immediately.
    I don’t personally tend to worry about the performance of the code as much as
    I do the readability. When I write code for myself, I prefer to use `map()`, but
    you should write code that makes the most sense for you and your teammates.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是一个惰性函数，就像我们之前看过的`range()`函数。它不会在真正需要时创建值，而列表推导则会立即生成结果列表。我个人不太担心代码的性能，而更关心可读性。当我为自己编写代码时，我更喜欢使用`map()`，但你应该编写对你和你的队友最有意义的代码。'
- en: 'To force the results from `map()` in the REPL, we need to use the `list()`
    function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要在REPL中强制`map()`的结果，我们需要使用`list()`函数：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '| We can write the list comprehension with the `add1()` code in line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们可以在一行中用`add1()`代码编写列表推导：'
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That looks very similar to the `lambda` code (as illustrated in figure 8.8):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常类似于`lambda`代码（如图8.8所示）：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is how we could use `map()`: | ![](../Images/8-8.png)Figure 8.8 The `map()`
    function will create a new list from processing each element of an iterable through
    a given function. |'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用`map()`的示例：| ![图8.8](../Images/8-8.png)图8.8 `map()`函数将创建一个新的列表，通过将可迭代对象的每个元素通过给定的函数进行处理。
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ① The map() function wants a function for the first argument and an iterable
    for the second.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ① `map()`函数的第一个参数需要一个函数，第二个参数需要一个可迭代对象。
- en: ② Use lambda to create an anonymous function that accepts a character, c.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用`lambda`创建一个接受字符`c`的匿名函数。
- en: ③ args.text is the second argument to map(). Technically, args.text is a string,
    but, because map() expects this argument to be a list, the string will be coerced
    to a list.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `args.text` 是 `map()` 的第二个参数。技术上，`args.text` 是一个字符串，但由于 `map()` 预期这个参数是一个列表，字符串将被强制转换为列表。
- en: ④ map() returns a new list to the text variable. We join it on the empty string
    to print it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `map()` 将新的列表返回到 `text` 变量。我们使用空字符串将其连接起来以打印它。
- en: Higher-order functions
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数
- en: The `map()` function is called a *higher-order function* (HOF) because it takes
    *another function* as an argument, which is wicked cool. Later we’ll use another
    HOF called `filter()`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 函数被称为 *高阶函数* (HOF)，因为它接受 *另一个函数* 作为参数，这非常酷。稍后我们将使用另一个名为 `filter()`
    的高阶函数。'
- en: 'Method 7: Using map() with a named function'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 7：使用带命名函数的 `map()`
- en: 'We are not required to use `map()` with a `lambda` expression. Any function
    at all will work, so let’s go back to using our `new_char()` function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用带有 `lambda` 表达式的 `map()`。任何函数都可以工作，所以让我们回到使用我们的 `new_char()` 函数：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ① Define a function that will return the proper character. Note that I’m using
    the closure version so as to reference the “vowel” argument.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个将返回正确字符的函数。请注意，我正在使用闭包版本以便引用“元音”参数。
- en: ② Use map() to apply new_char() to all the characters in args.text. The result
    is a list of characters, and we can use str.join() to turn them into a new string
    for print().
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 `map()` 将 `new_char()` 函数应用于 `args.text` 中的所有字符。结果是字符列表，我们可以使用 `str.join()`
    将它们转换成一个新的字符串以供打印。
- en: 'Notice that `map()` uses `new_char` *without parentheses* as the first argument.
    If you added the parentheses, you’d be *calling* the function and would see this
    error:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `map()` 使用 `new_char` *不带括号* 作为第一个参数。如果你添加了括号，你将 *调用* 函数，并会看到这个错误：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As shown in figure 8.9, `map()` takes each character from `text` and passes
    it as the argument to the `new_char()` function, which decides whether to return
    a `vowel` or the original character. The result of mapping these characters is
    a new list of characters that we `str.join()` on the empty string to create a
    new version of `text`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 8.9 所示，`map()` 从 `text` 中取每个字符，并将其作为参数传递给 `new_char()` 函数，该函数决定是否返回一个 `元音`
    或原始字符。映射这些字符的结果是一个新的字符列表，我们使用空字符串 `str.join()` 来创建 `text` 的新版本。
- en: '![](../Images/8-9.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8-9.png)'
- en: Figure 8.9 `map()` will apply a given function to each element of an iterable.
    A string will be processed as a list of characters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 `map()` 将给定的函数应用于可迭代对象的每个元素。字符串将被处理为字符列表。
- en: 'Method 8: Using regular expressions'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 8：使用正则表达式
- en: A *regular expression* is a way to describe patterns of text. Regular expressions
    (also called “regexes”) are a separate domain-specific language (DSL). They really
    have nothing whatsoever to do with Python. They have their own syntax and rules,
    and they are used in many places, from command-line tools to databases. Regexes
    are incredibly powerful and well worth the effort to learn.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式* 是描述文本模式的一种方式。正则表达式（也称为“regexes”）是一个独立的领域特定语言（DSL）。它们实际上与 Python 完全无关。它们有自己的语法和规则，并且被用于许多地方，从命令行工具到数据库。正则表达式非常强大，值得花时间学习。'
- en: 'To use regular expressions, you must `import` `re` in your code to import the
    regular expression module:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正则表达式，你必须在你的代码中 `import` `re` 来导入正则表达式模块：
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this example, we’re trying to find characters that are vowels, which we
    can define as the letters “a,” “e,” “i,” “o,” and “u.” To describe this idea using
    a regular expression, we put those characters inside square brackets:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们试图找到元音字符，我们可以将其定义为字母“a”、“e”、“i”、“o”和“u”。为了使用正则表达式描述这个想法，我们将这些字符放在方括号内：
- en: '[PRE75]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We can use the “substitute” function, `re.sub()`, to find all the vowels and
    replace them with the given `vowel`. The square brackets around the vowels `'[aeiou]'`
    create a *character class*, meaning anything matching one of the characters listed
    inside the brackets.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“替换”函数 `re.sub()` 来查找所有元音并将其替换为给定的 `元音`。元音 `'[aeiou]'` 两侧的方括号创建了一个 *字符类*，意味着匹配方括号内列出的任何字符。
- en: 'The second argument is the string that will replace the found strings--here
    it is the `vowel` provided by the user. The third argument is the string we want
    to change, which is the `text` from the user:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是要替换的字符串，这里它是用户提供的 `vowel`。第三个参数是我们想要更改的字符串，即用户的 `text`：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'That misses the capital “A,” so we’ll have to handle both lower- and uppercase.
    Here is how we could write that:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就遗漏了大写字母“A”，所以我们必须同时处理大小写。下面是我们可以这样写的示例：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ① Substitute any of the lowercase vowels with the given vowel (which is lowercase
    because of the restrictions in get_args()).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将任何小写元音替换为给定的元音（由于get_args()中的限制，它是小写的）。
- en: ② Substitute any of the uppercase vowels with the uppercase vowel.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将任何大写元音替换为大写元音。
- en: 'If you prefer, we could squash the two calls to `re.sub()` into one, just as
    we did with the `str.replace()` method shown earlier:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，我们可以将两个`re.sub()`调用压缩成一个，就像我们之前展示的`str.replace()`方法一样：
- en: '[PRE78]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: One of the biggest differences between this solution and all the others is that
    we use regular expressions to describe what we are looking for. We didn’t have
    to write the code to identify the vowels. This is more along the lines of *declarative*
    programming. We declare what we want, and the computer does the grunt work!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他所有解决方案相比，最大的不同之处在于我们使用正则表达式来描述我们正在寻找的内容。我们不必编写识别元音的代码。这更像是*声明式*编程。我们声明我们想要什么，然后计算机完成繁重的工作！
- en: 8.4 Refactoring with tests
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用测试进行重构
- en: There are many ways to solve this problem. The most important step is to get
    your program to work properly. Tests let you know when you’ve reached that point.
    From there, you can explore other ways to solve the problem and keep using the
    tests to ensure you still have a correct program.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法有很多。最重要的步骤是确保你的程序能够正常工作。测试让你知道何时达到这一点。从那里，你可以探索其他解决问题的方法，并继续使用测试来确保你的程序仍然是正确的。
- en: Tests provide you with great freedom to be creative. Always be thinking about
    tests you can write for your own programs, so that when you change them later,
    they will always keep working.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 测试为你提供了极大的创造性自由。始终思考你可以为你的程序编写的测试，这样当你在以后更改它们时，它们总是会保持工作。
- en: I showed many ways to solve this seemingly trivial problem. Some of the techniques
    using higher-order functions and regular expression are quite advanced techniques.
    It might seem like driving a finishing nail with a sledgehammer, but I want to
    start introducing you to programming ideas that I’ll visit again and again in
    later chapters.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示了多种解决这个看似简单问题的方法。其中一些使用高阶函数和正则表达式的技术相当高级。这可能会感觉像是用大锤敲打钉子，但我想开始介绍一些编程思想，这些思想我将在后面的章节中反复提及。
- en: If you only really understood the first few solutions, that’s fine! Just stick
    with me. The more times you see these ideas applied in different contexts, the
    more they will begin to make sense.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只真正理解了前几个解决方案，那也行！只要跟着我。你看到这些想法在不同环境中应用得越多，它们就越会开始变得有意义。
- en: 8.5 Going further
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 进一步探索
- en: Write a version of the program that collapses multiple adjacent vowels into
    a single substituted value. For example, “quick” should become “qack” and not
    “qaack.”
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个版本的程序，将多个相邻的元音压缩成一个替换值。例如，“quick”应该变成“qack”，而不是“qaack”。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use `argparse` to limit an argument’s values to a `list` of `choices`
    that you define.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`argparse`将一个参数的值限制为你定义的`choices`列表。
- en: Strings cannot be directly modified, but the `str.replace()` and `str.translate()`
    methods can create a *new, modified string* from an existing string.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串不能直接修改，但`str.replace()`和`str.translate()`方法可以从现有字符串创建一个*新修改过的字符串*。
- en: A `for` loop on a string will iterate the characters of the string.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串上的`for`循环将迭代字符串的字符。
- en: A list comprehension is a shorthand way to write a `for` loop inside `[]` to
    create a new `list`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导是一种简写方式，可以在`[]`内编写`for`循环以创建一个新的`list`。
- en: Functions can be defined inside other functions. Their visibility is then limited
    to the enclosing function.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以定义在其他函数内部。它们的可见性因此限制在封装函数内。
- en: Functions can reference variables declared within the same scope, creating a
    closure.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以引用同一作用域内声明的变量，从而创建闭包。
- en: The `map()` function is similar to a list comprehension. It will create a new,
    modified list by applying some function to every member of a given list. The original
    list will not be changed.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`函数类似于列表推导。它将通过将某个函数应用于给定列表的每个成员来创建一个新的、修改后的列表。原始列表将不会被改变。'
- en: Regular expressions provide a syntax for describing patterns of text with the
    `re` module. The `re.sub()` method will substitute found patterns with new text.
    The original text will be unchanged.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式通过`re`模块提供了一种描述文本模式的语法。`re.sub()`方法将找到的模式替换为新文本。原文将保持不变。
