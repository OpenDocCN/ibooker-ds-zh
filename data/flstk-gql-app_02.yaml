- en: 1 What is full stack GraphQL?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 什么是全栈GraphQL？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Components that make up a typical full stack GraphQL application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成典型全栈GraphQL应用程序的组件
- en: Technologies used throughout the book (GraphQL, React, Apollo, and Neo4j Database)
    and how each piece fits together in the context of a full stack application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书使用的技术（GraphQL、React、Apollo和Neo4j数据库）以及每个组件在全栈应用程序上下文中的结合方式
- en: Requirements for the application we will build throughout the book
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本书中构建的应用程序的要求
- en: 1.1 A look at full stack GraphQL
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 全栈GraphQL概述
- en: 'In this chapter, we take an introductory look at the technologies we will use
    throughout the book. Specifically, we’ll look at the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍本书中将要使用的技术。具体来说，我们将查看以下内容：
- en: GraphQL—For building our API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL—用于构建我们的API
- en: React—For building our user interface and JavaScript client web application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React—用于构建我们的用户界面和JavaScript客户端Web应用程序
- en: Apollo—Tools for working with GraphQL, on both the server and client
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo—用于在服务器和客户端处理GraphQL的工具
- en: Neo4j Database—The database we will use for storing and manipulating our application
    data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j数据库—我们将用于存储和操作应用程序数据的数据库
- en: Building a full stack GraphQL application involves working with a multitier
    architecture, commonly known as a *three-tier application*, which consists of
    a frontend application, the API layer, and a database. In figure 1.1 we see the
    individual components of a full stack GraphQL application and how they interact
    with each other.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 构建全栈GraphQL应用程序涉及与多层架构（通常称为三层应用）一起工作，该架构包括前端应用程序、API层和数据库。在图1.1中，我们可以看到全栈GraphQL应用程序的各个组件以及它们如何相互交互。
- en: '![CH01_F01_Lyon](../../OEBPS/Images/CH01_F01_Lyon.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F01_Lyon](../../OEBPS/Images/CH01_F01_Lyon.png)'
- en: 'Figure 1.1 The components of a full stack GraphQL application: GraphQL, React,
    Apollo, and Neo4j Database'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 全栈GraphQL应用程序的组件：GraphQL、React、Apollo和Neo4j数据库
- en: Throughout this book, we will use these technologies to build a simple business
    review application, working through each technology component as we implement
    it in the context of our application. In the last section of this chapter, we
    review the basic requirements of the application we will be building throughout
    the book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用这些技术构建一个简单的商业评论应用程序，在实现应用程序的上下文中逐一处理每个技术组件。在本章的最后部分，我们将回顾本书中将要构建的应用程序的基本要求。
- en: The focus of this book is learning how to build applications with GraphQL, so
    as we cover GraphQL, we’ll do so in the context of building a full stack application
    and using GraphQL with other technologies, including designing our schema, integrating
    with a database, building a web application that can query our GraphQL API, adding
    authentication to our application, and so on. As a result, this book assumes some
    basic knowledge of how web applications are typically built, but it does not necessarily
    require experience with each specific technology. To be successful, the reader
    should have a basic familiarity with JavaScript, both client side and Node.js,
    and concepts such as APIs and databases. You should have installed node and should
    be familiar with the basics of the npm command line tool (or yarn) and how to
    use it to create Node.js projects and install dependencies. We will use the latest
    LTS version of Node.js as of this writing (16.14.2), which is available to download
    at [https://nodejs.org/](https://nodejs.org/). You may wish to use a Node.js version
    manager such as nvm for managing Node versions. See [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)
    for more information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的核心是学习如何使用GraphQL构建应用程序，因此在我们介绍GraphQL时，我们将将其置于构建全栈应用程序的背景下，并使用其他技术，包括设计我们的模式、与数据库集成、构建可以查询我们的GraphQL
    API的Web应用程序、为我们的应用程序添加身份验证等。因此，本书假设读者对如何构建Web应用程序有一些基本知识，但并不一定需要每个特定技术的经验。为了成功，读者应该对JavaScript有基本的了解，包括客户端和Node.js，以及诸如API和数据库等概念。你应该已经安装了node，并且应该熟悉npm命令行工具（或yarn）的基本用法以及如何使用它来创建Node.js项目和安装依赖项。我们将使用本书撰写时的最新LTS版本Node.js（16.14.2），该版本可在[https://nodejs.org/](https://nodejs.org/)下载。你可能希望使用Node.js版本管理器，如nvm来管理Node版本。有关更多信息，请参阅[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)。
- en: We include a brief introduction to each technology and suggest other resources
    for more in-depth coverage where needed by the reader. It is also important to
    note that we will cover specific technologies to be used alongside GraphQL and
    that at each phase, a similar technology could be substituted (e.g., we could
    build our frontend using Vue instead of React). Ultimately, the goal of this book
    is to show how these technologies fit together and provide the reader with a full
    stack framework for thinking about and building applications with GraphQL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每种技术进行了简要介绍，并在需要时建议读者查阅其他资源以进行更深入的覆盖。同样重要的是要注意，我们将涵盖与 GraphQL 一起使用的特定技术，并且在每个阶段，可以替换为类似的技术（例如，我们可以使用
    Vue 而不是 React 来构建我们的前端）。最终，本书的目标是展示这些技术如何相互配合，并为读者提供一个全栈框架来思考和构建使用 GraphQL 的应用程序。
- en: 1.2 GraphQL
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 GraphQL
- en: At its core, GraphQL is a specification for building APIs. The GraphQL specification
    describes an API query language and a way of fulfilling those requests. When building
    a GraphQL API, we describe the data available using a strict type system. These
    type definitions become the specification for the API, and the client is free
    to request the data it requires based on these type definitions, which also define
    the entry points for the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，GraphQL 是构建 API 的规范。GraphQL 规范描述了一种 API 查询语言和满足这些请求的方式。当构建 GraphQL API
    时，我们使用严格的类型系统描述可用的数据。这些类型定义成为 API 的规范，客户端可以基于这些类型定义请求所需的数据，这些类型定义也定义了 API 的入口点。
- en: GraphQL is typically framed as an alternative to REST, which is the API paradigm
    you are mostly likely to be familiar with. This can be true in some cases; however,
    GraphQL can also wrap existing REST APIs or other data sources. This is due to
    the benefit of GraphQL being data-layer-agnostic, meaning we can use GraphQL with
    any data source.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 通常被视为 REST 的替代品，这是你最可能熟悉的 API 范式。在某些情况下这可能成立；然而，GraphQL 也可以包装现有的 REST
    API 或其他数据源。这是由于 GraphQL 的数据层无关性带来的好处，这意味着我们可以使用 GraphQL 与任何数据源一起使用。
- en: '*GraphQL is a query language for APIs and a runtime for fulfilling those queries
    with your existing data. GraphQL provides a complete and understandable description
    of the data in your API, gives clients the power to ask for exactly what they
    need and nothing more, makes it easier to evolve APIs over time, and enables powerful
    developer tools.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL 是一种 API 查询语言，也是满足这些查询的运行时。GraphQL 提供了 API 中数据的完整和可理解的描述，使客户端能够请求他们确切需要的东西，而无需更多，这使得随着时间的推移更容易演变
    API，并使强大的开发者工具成为可能。*'
- en: —[graphql.org](https://graphql.org/)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: —[graphql.org](https://graphql.org/)
- en: Let’s dive into some more specific aspects of GraphQL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 GraphQL 的更多具体方面。
- en: 1.2.1 GraphQL type definitions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 GraphQL 类型定义
- en: Rather than being organized around endpoints that map to resources (as with
    REST), GraphQL APIs are centered around type definitions that define the data
    types, fields, and how they are connected in the API. These type definitions become
    the schema of the API, which is served from a single endpoint.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与围绕映射到资源的端点组织（如 REST）不同，GraphQL API 是围绕类型定义的中心，这些定义了数据类型、字段以及它们在 API 中的连接方式。这些类型定义成为
    API 的模式，并从单个端点提供。
- en: Since GraphQL services can be implemented in any language, a language-agnostic
    GraphQL Schema Definition Language (SDL) is used to define GraphQL types. Let’s
    look at an example in figure 1.2, motivated by considering a simple movie application.
    Imagine you’ve been hired to create a website that allows users to search a movie
    catalog for movie details, such as title, actors, and description, as well as
    show recommendations for similar movies the user may find interesting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GraphQL 服务可以用任何语言实现，因此使用一种与语言无关的 GraphQL 模式定义语言（SDL）来定义 GraphQL 类型。让我们看看图
    1.2 中的示例，这个示例是由考虑一个简单的电影应用程序而激发的。想象一下，你被雇佣来创建一个网站，允许用户搜索电影目录以获取电影详情，例如标题、演员和描述，以及显示用户可能感兴趣的类似电影推荐。
- en: '![CH01_F02_Lyon](../../OEBPS/Images/CH01_F02_Lyon.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F02_Lyon](../../OEBPS/Images/CH01_F02_Lyon.png)'
- en: Figure 1.2 A simple movie web application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 一个简单的电影网络应用程序
- en: Let’s start in the next listing by creating some simple GraphQL type definitions
    that will define the data domain of our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一个列表开始，创建一些简单的 GraphQL 类型定义，这些定义将定义我们应用程序的数据域。
- en: Listing 1.1 Simple GraphQL type definitions for a movie GraphQL API
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 为电影 GraphQL API 定义的简单 GraphQL 类型定义
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Movie is a GraphQL object type, which means a type that contains one or more
    fields.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 电影是一个 GraphQL 对象类型，这意味着包含一个或多个字段的类型。
- en: ❷ title is a field on the Movie type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标题是 Movie 类型上的一个字段。
- en: ❸ Fields can reference other types, such as a list of Actor objects in this
    case.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 字段可以引用其他类型，例如在这种情况下 Actor 对象的列表。
- en: ❹ actorId is a required (or non-nullable) field on the Actor type, which is
    indicated by the ! character.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ actorId 是 Actor 类型上的一个必需（或非可空）字段，这由 ! 字符表示。
- en: ❺ The Query type is a special type in GraphQL, which indicates the entry points
    for the API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 查询类型是 GraphQL 中的一个特殊类型，它表示 API 的入口点。
- en: '❻ Fields can also have arguments; in this case, the movieSearch field takes
    a required string argument: searchString.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 字段也可以有参数；在这种情况下，movieSearch 字段需要一个必需的字符串参数：searchString。
- en: Our GraphQL type definitions declare the types used in the API, their fields,
    and how they are connected. When defining an object type (such as Movie), all
    fields available on the object and the type of each field are also specified (we
    can also add fields later, using the extend keyword). In this case, we define
    title to be a scalar String type—a type that resolves to a single value, as opposed
    to an object type, which can contain multiple fields and references to other types.
    Here actors is a field on the Movie type that resolves to an array of Actor objects,
    indicating that the actors and movies are connected (the foundation of the “graph”
    in GraphQL).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 GraphQL 类型定义声明了 API 中使用的类型、它们的字段以及它们是如何连接的。当定义一个对象类型（如 Movie）时，对象上所有可用的字段以及每个字段的类型也会被指定（我们也可以稍后添加字段，使用
    extend 关键字）。在这种情况下，我们定义标题为一个标量 String 类型——一个解析为单个值的类型，与可以包含多个字段和其他类型引用的对象类型相对。这里
    actors 是一个在 Movie 类型上的字段，它解析为一个 Actor 对象数组，表示演员和电影是连接的（GraphQL 中“图形”的基础）。
- en: Fields can be either optional or required. The actorId field on the Actor object
    type is required (or non-nullable). This means that every Actor object must have
    a value for actorId. Fields that do not include a ! are nullable, meaning values
    for those fields are optional.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字段可以是可选的或必需的。Actor 对象类型上的 actorId 字段是必需的（或非可空的）。这意味着每个 Actor 对象都必须有一个 actorId
    的值。不包括 ! 的字段是可空的，这意味着这些字段的值是可选的。
- en: The fields of the Query type become the entry points for queries into the GraphQL
    service. GraphQL schemas may also contain a Mutation type, which defines the entry
    points for write operations into the API. A third special entry-point-related
    type is the Subscription type, which defines events to which a client can subscribe.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查询类型的字段成为查询 GraphQL 服务的入口点。GraphQL 模式还可以包含一个突变类型，它定义了写入 API 的入口点。与入口点相关的第三个特殊类型是订阅类型，它定义了客户端可以订阅的事件。
- en: Note We’re skipping over many important GraphQL concepts here, such as mutation
    operations, interface and union types, and so on, but don’t worry; we’re just
    getting started and will get to these soon enough!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这里我们跳过了许多重要的 GraphQL 概念，例如突变操作、接口和联合类型等，但请放心；我们只是刚开始，很快就会涉及到这些内容！
- en: At this point, you may be wondering where the *graph* is in GraphQL. It turns
    out that we’ve defined a graph using our GraphQL type definitions. A graph is
    a data structure composed of nodes (the entities or objects in our data model)
    and relationships that connect nodes, which is exactly the structure we’ve defined
    in our type definitions using SDL. The GraphQL type definitions previously shown
    have defined a simple graph with the following structure (see figure 1.3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道 GraphQL 中的“图形”在哪里。实际上，我们已经使用我们的 GraphQL 类型定义定义了一个图形。图形是由节点（我们数据模型中的实体或对象）和连接节点的边组成的数据结构，这正是我们在类型定义中使用
    SDL 定义的。之前显示的 GraphQL 类型定义已经定义了一个具有以下结构的简单图形（见图 1.3）。
- en: '![CH01_F03_Lyon](../../OEBPS/Images/CH01_F03_Lyon.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F03_Lyon](../../OEBPS/Images/CH01_F03_Lyon.png)'
- en: Figure 1.3 GraphQL type definitions for our movie web application expressed
    as a graph diagram
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3. 以图形图表示的我们的电影网络应用程序的 GraphQL 类型定义
- en: Graphs are all about describing connected data, and here we’ve defined how our
    movies and actors are connected in a graph. GraphQL allows us to model application
    data as a graph and traverse the data graph through GraphQL operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图形都是关于描述连接数据的，在这里我们定义了我们的电影和演员如何在图形中连接。GraphQL 允许我们将应用程序数据建模为图形，并通过 GraphQL
    操作遍历数据图形。
- en: When a GraphQL service receives an operation (e.g., a GraphQL query), it is
    validated and executed against the GraphQL schema defined by these type definitions.
    Let’s look at an example query that could be executed against a GraphQL service
    defined using the previously shown type definitions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GraphQL 服务接收到一个操作（例如，一个 GraphQL 查询）时，它将根据这些类型定义定义的 GraphQL 模式进行验证和执行。让我们看看一个可以针对使用之前显示的类型定义定义的
    GraphQL 服务执行的示例查询。
- en: 1.2.2 Querying with GraphQL
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 使用 GraphQL 进行查询
- en: GraphQL queries define a traversal through the data graph defined by our type
    definitions and request a subset of fields to be returned by the query—this is
    known as the *selection set*. In this query, we start from the allMovies query
    field entry point and traverse the graph to find actors connected to each movie
    (see the next listing). Then, for each of these actors, we traverse to all the
    other movies they are connected to.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 查询定义了通过我们的类型定义定义的数据图进行遍历，并请求查询返回的字段子集——这被称为 *选择集*。在这个查询中，我们从 allMovies
    查询字段入口点开始遍历图，以找到与每部电影相关的演员（参见下一列表）。然后，对于这些演员中的每一个，我们遍历到他们与之相连的所有其他电影。
- en: Listing 1.2 A GraphQL query to find movies and actors
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 一个用于查找电影和演员的 GraphQL 查询
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This is the optional naming of the operation. query is the default operation
    and can, therefore, be omitted. Naming the query—in this case, FetchSomeMovies—is
    also optional and can be omitted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是操作的可选命名。query 是默认操作，因此可以省略。命名查询——在这种情况下，FetchSomeMovies——也是可选的，可以省略。
- en: ❷ Here we specify the entry point, which is a field on either the Query or Mutation
    type. In this case, our entry point for the query is the allMovies query field.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这里，我们指定入口点，它是 Query 或 Mutation 类型上的一个字段。在这种情况下，我们的查询入口点是 allMovies 查询字段。
- en: ❸ The selection set defines the fields to be returned by the query.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择集定义了查询要返回的字段。
- en: ❹ In the case of object fields, a nested selection set is used to specify the
    fields to be returned.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在对象字段的情况下，使用嵌套选择集来指定要返回的字段。
- en: ❺ A further nested selection is needed for the fields on movies to be returned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 需要进一步嵌套的选择集来返回电影上的字段。
- en: Note that our query is nested and describes how to traverse the graph of related
    objects (in this case, movies and actors). We can represent this traversal through
    the data graph and the results visually (see figure 1.4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的查询是嵌套的，描述了如何遍历相关对象（在这种情况下，电影和演员）的图。我们可以通过数据图和结果的可视化来表示这种遍历（参见图 1.4）。
- en: '![CH01_F04_Lyon](../../OEBPS/Images/CH01_F04_Lyon.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F04_Lyon](../../OEBPS/Images/CH01_F04_Lyon.png)'
- en: Figure 1.4 A GraphQL query traversal through the movies data graph
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 通过电影数据图进行 GraphQL 查询遍历
- en: Although we can represent the traversal of the traversal of the data graph visually,
    the typical result of a GraphQL query is a JSON document, as shown in the next
    listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过可视化表示数据图的遍历，但 GraphQL 查询的典型结果是下一个列表中显示的 JSON 文档。
- en: Listing 1.3 JSON query results
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 JSON 查询结果
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from the results, the response matches the shape of the query’s
    selection set—exactly the fields requested in the query are returned. But where
    does the data come from? The data-fetching logic for GraphQL APIs is defined in
    functions called *resolver functions*, which contain the logic for resolving the
    data for an arbitrary GraphQL request from the data layer. GraphQL is data-layer-agnostic,
    so the resolvers could query one or more databases or fetch data from another
    API—even a REST API. We will cover resolvers in depth in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从结果中看到的，响应与查询选择集的形状相匹配——查询中请求的恰好是返回的字段。但数据从哪里来呢？GraphQL API 的数据获取逻辑定义在称为 *解析函数*
    的函数中，这些函数包含从数据层解析任意 GraphQL 请求数据的逻辑。GraphQL 是数据层无关的，因此解析器可以查询一个或多个数据库或从另一个 API（甚至是一个
    REST API）获取数据。我们将在下一章深入探讨解析器。
- en: 1.2.3 Advantages of GraphQL
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 GraphQL 的优势
- en: Now that we’ve seen our first GraphQL query, you may be thinking, “OK, that’s
    nice, but I can fetch data about movies with REST, too. What’s so great about
    GraphQL?” Let’s review some of the benefits of GraphQL.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们的第一个 GraphQL 查询，你可能正在想，“好吧，这很好，但我也可以使用 REST 获取有关电影的数据。GraphQL 有什么了不起的？”让我们回顾一下
    GraphQL 的一些好处。
- en: Overfetching and underfetching
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 过度获取和不足获取
- en: '*Overfetching* refers to a pattern commonly associated with REST, in which
    unnecessary and unused data is sent over the network in response to an API request.
    Since REST is modeling resources, when we make a GET request for, say, /movie/tt0105265,
    we get back the representation of that movie—nothing more, nothing less.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*过度获取* 是与 REST 常见相关的一种模式，在这种模式中，不必要的和未使用的数据会在响应 API 请求时通过网络发送。由于 REST 是对资源的建模，当我们发出针对，例如，/movie/tt0105265
    的 GET 请求时，我们得到该电影的表示——不多也不少。'
- en: Listing 1.4 REST API response for GET /movie/tt0105265
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 GET /movie/tt0105265 的 REST API 响应
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But what if the view of our application only needs to render the title and year
    of the movie? Then we’ve unnecessarily sent too much data over the network. Further,
    some of those movie fields may be expensive to compute. For example, if we need
    to calculate averageReviews by aggregating across all movie reviews for each request,
    but we’re not even showing that in the application view, that’s a lot of wasted
    compute time, which unnecessarily impacts the performance of our API. (Of course,
    in the real world, we may cache this, but that adds additional complexity as well.)
    Similarly, underfetching is a pattern associated with REST, in which insufficient
    data is returned by the request.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们应用程序的视图只需要渲染电影的标题和年份呢？那么我们就无谓地发送了过多的数据。此外，一些电影字段可能计算成本很高。例如，如果我们需要通过聚合每个请求的所有电影评论来计算
    averageReviews，但我们甚至没有在应用程序视图中显示这一点，那么这将浪费大量的计算时间，这无谓地影响了我们 API 的性能。（当然，在现实世界中，我们可能会缓存这些数据，但这也会增加额外的复杂性。）同样，不足获取是与
    REST 相关的一种模式，其中请求返回的数据不足。
- en: 'Let’s say our application view needs to render the name of each actor in a
    movie. First, we make a GET request for /movie/tt0105265. As previously shown,
    we have an array of IDs for the actors connected to this movie. Now, to get the
    data required for our application, we need to iterate over this array of actor
    IDs to get the name of each actor by making another API request for each actor
    to be rendered in our view:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序视图需要渲染电影中每位演员的姓名。首先，我们发出针对 /movie/tt0105265 的 GET 请求。如前所述，我们有一个与这部电影相连的演员
    ID 数组。现在，为了获取我们应用程序所需的数据，我们需要遍历这个演员 ID 数组，通过为要在视图中渲染的每位演员发出另一个 API 请求来获取每位演员的姓名：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With GraphQL, since the client is in control of the data requested, we can accomplish
    this in a single request by specifying exactly the data needed by the application
    view in the selection set of the GraphQL query, solving both the overfetching
    and underfetching problems. This results in improved performance on the server
    side, as we are spending less compute resources at the data layer, there is less
    overall data sent over the network, and latency is reduced by being able to render
    our application view with a single network request to the API service.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL，由于客户端控制所需的数据，我们可以通过在 GraphQL 查询的选择集中指定应用程序视图所需的确切数据，在一个请求中完成此操作，从而解决过度获取和不足获取的问题。这导致服务器端性能得到改善，因为我们花费在数据层的计算资源更少，网络发送的总数据更少，并且通过能够通过向
    API 服务发出单个网络请求来渲染我们的应用程序视图，降低了延迟。
- en: GraphQL specification
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 规范
- en: GraphQL is a specification for client-server communication that describes the
    features, functionality, and capability of the GraphQL API query language. Having
    this specification gives a clear guide of how to implement your GraphQL API and
    clearly defines what is and what is not GraphQL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是一种客户端-服务器通信规范，它描述了 GraphQL API 查询语言的功能、功能性和能力。拥有这个规范为如何实现你的 GraphQL
    API 提供了清晰的指南，并明确定义了什么是 GraphQL，什么不是 GraphQL。
- en: REST does not have a specification; instead, there are many different implementations,
    from what might be considered merely REST-ish to hypermedia as the engine of application
    state (HATEOAS). Having a specification as part of GraphQL simplifies debates
    over endpoints, status codes, and documentation. All of this comes built in with
    GraphQL, which leads to productivity wins for developers and API designers. The
    specification provides a clear path for API implementors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: REST 没有规范；相反，有许多不同的实现，从可能被认为是仅仅类似于 REST 的到超媒体作为应用程序状态引擎（HATEOAS）。将规范作为 GraphQL
    的一部分简化了关于端点、状态码和文档的辩论。所有这些都内置在 GraphQL 中，这为开发人员和 API 设计师带来了生产力的提升。规范为 API 实现者提供了清晰的路径。
- en: With GraphQL, it’s graphs all the way down
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GraphQL，一切皆图
- en: REST models itself as a hierarchy of resources, yet most interactions with APIs
    are done in terms of relationships. For example, given our previous movie query—for
    this movie, show me all of the actors connected to it, and for each actor, show
    me all the other movies they’ve acted in—we’re querying for relationships between
    actors and movies. This concept of relationships is even more prominent in real
    world applications, when we might be working with the relationships connecting
    customers and the products in their orders or users and their messages to other
    users in the context of a conversation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: REST 模型本身是一个资源层次结构，然而与 API 的交互大多数是以关系为单位的。例如，给定我们之前的电影查询——对于这部电影，显示所有与之相关的演员，以及对于每位演员，显示他们参演的其他所有电影——我们正在查询演员和电影之间的关系。这种关系概念在现实世界应用中更为突出，当我们可能正在处理连接客户和他们在订单中的产品或用户和他们在对话中发送给其他用户的消息之间的关系时。
- en: GraphQL can also help unify data from disparate systems. Since GraphQL is data-layer-agnostic,
    we can build GraphQL APIs that integrate data from multiple services together
    and provide a clear way to integrate data from these different systems into a
    single unified GraphQL schema.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 还可以帮助统一来自不同系统的数据。由于 GraphQL 对数据层是中立的，我们可以构建 GraphQL API，将来自多个服务的数据进行整合，并提供一个清晰的方式来将这些不同系统的数据集成到单个统一的
    GraphQL 模式中。
- en: GraphQL can also be used to compartmentalize data fetching in the application
    in a component-based data interaction pattern. Since each GraphQL query can describe
    exactly the graph traversal and fields to be returned, encapsulating these queries
    with application components can help simplify application development and testing.
    We’ll see how to apply this once we start building our React application in chapter
    5\.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 还可以用于在应用程序中以基于组件的数据交互模式对数据获取进行分块。由于每个 GraphQL 查询可以精确描述图遍历和要返回的字段，将这些查询与应用程序组件封装起来可以帮助简化应用程序的开发和测试。我们将在第
    5 章开始构建我们的 React 应用程序时看到如何应用这一点。
- en: Introspection
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自省
- en: '*Introspection* is a powerful feature of GraphQL that allows us to ask a GraphQL
    API for the types and queries it supports. Introspection becomes a way of self-documenting
    the API. Tools that make use of introspection can provide human-readable API documentation,
    as well as visualization tooling, and leverage code generation to create API clients.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*自省* 是 GraphQL 的一个强大功能，它允许我们向 GraphQL API 询问它支持的类型和查询。自省成为了一种自我文档化的方式。利用自省的工具可以提供可读性强的
    API 文档，以及可视化工具，并利用代码生成来创建 API 客户端。'
- en: 1.2.4 Disadvantages of GraphQL
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 GraphQL 的缺点
- en: Of course, GraphQL is not a silver bullet, and we should not think of it as
    the solution to all of our API-related problems. One of the most notable challenges
    of adopting GraphQL is that some well-understood practices from REST don’t apply
    when using GraphQL. For example, HTTP status codes are commonly used to convey
    success, failure, and other cases of a REST request; *200 OK* means our request
    was successful, and *404 Not Authorized* means we forgot an auth token or don’t
    have the correct permissions for the resource requested. However, with GraphQL,
    each request returns 200 OK, regardless of whether the request was a complete
    success. This makes error handling a bit different in the GraphQL world. Instead
    of a single status code describing the result of our request, GraphQL errors are
    typically returned at the field level. This means we may have successfully retrieved
    part of our GraphQL query, while other fields returned errors and will need to
    be handled appropriately.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，GraphQL 并非万能的银弹，我们不应将其视为解决所有 API 相关问题的方案。采用 GraphQL 最大的挑战之一是，当使用 GraphQL
    时，一些从 REST 中理解良好的实践并不适用。例如，HTTP 状态码通常用于传达 REST 请求的成功、失败和其他情况；“200 OK”表示我们的请求成功，而“404
    Not Authorized”表示我们忘记了一个身份验证令牌或没有请求资源的正确权限。然而，在 GraphQL 中，每个请求都返回 200 OK，无论请求是否完全成功。这使得在
    GraphQL 世界中的错误处理略有不同。与描述我们请求结果的单一状态码不同，GraphQL 错误通常在字段级别返回。这意味着我们可能成功检索了我们的 GraphQL
    查询的一部分，而其他字段返回了错误，需要适当处理。
- en: '*Caching* is another well-understood area of REST that is handled a bit differently
    with GraphQL. With REST, caching the response for /movie/123 is possible because
    we can return the same exact result for each GET request. This isn’t possible
    with GraphQL because each request could contain a different selection set, meaning
    we can’t simply return a cached result for the whole request. This is mitigated
    by most GraphQL clients implementing client caches at the application level, and
    in practice, much of the time, our GraphQL requests are in an authenticated environment,
    where caching isn’t applicable.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓存* 是 REST 中另一个被广泛理解的领域，但在 GraphQL 中处理方式略有不同。在使用 REST 时，缓存 /movie/123 的响应是可能的，因为我们可以为每个
    GET 请求返回完全相同的结果。但在 GraphQL 中，由于每个请求可能包含不同的选择集，这意味着我们不能简单地为整个请求返回缓存的响应。这可以通过大多数
    GraphQL 客户端在应用级别实现客户端缓存来缓解，实际上，我们的 GraphQL 请求大多数时间都在一个认证环境中，那里不适用缓存。'
- en: Another challenge is exposing arbitrary complexity to the client along with
    related performance considerations. If the client is free to compose queries as
    they wish, how can we ensure these queries don’t become so complex as to impact
    performance significantly or overwhelm the computing resources of our backend
    infrastructure? Fortunately, GraphQL tooling allows us to restrict the depth of
    the queries used and further restrict the queries that can be run to a whitelisted
    selection of queries (known as persisted queries). A related challenge is implementing
    rate limiting. With REST, we could simply restrict the number of requests that
    can be made in a certain time period; however, with GraphQL, this becomes more
    complicated, since the client could be requesting multiple objects in a single
    query. This results in bespoke query-costing implementations to address rate limiting.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是向客户端暴露任意复杂性以及相关的性能考虑。如果客户端可以自由地按自己的意愿组合查询，我们如何确保这些查询不会变得过于复杂，从而显著影响性能或耗尽我们后端基础设施的计算资源？幸运的是，GraphQL
    工具允许我们限制查询的深度，并进一步限制可以运行的查询，到一个白名单选择查询（称为持久化查询）。另一个相关挑战是实现速率限制。在使用 REST 时，我们可以简单地限制在特定时间段内可以发出的请求数量；然而，在使用
    GraphQL 时，这变得更加复杂，因为客户端可能在单个查询中请求多个对象。这导致需要定制查询成本实现来解决速率限制问题。
- en: Finally, the so-called *n* + 1 query problem is a common problem in GraphQL
    data fetching implementations that can result in multiple round trips to the data
    layer and can negatively impact performance. Consider the case in which we request
    information about a movie and all actors in the movie. In the database, we might
    store a list of actor IDs associated with each movie, which is returned with our
    request for the movie details. In a naive GraphQL implementation, we would then
    need to retrieve the actor details, and we would need to make a separate request
    to the database for each actor object, resulting in a total of *n* (i.e., the
    number of actors) + 1 (i.e., the movie) queries to the database. To address the
    *n* + 1 query problem, tools like DataLoader allow us to batch and cache requests
    to the database, increasing performance. Another approach to addressing the *n*
    + 1 query problem is employing GraphQL database integrations, such as the Neo4j
    GraphQL library and PostGraphile, which allow us to generate a single database
    query from an arbitrary GraphQL request, ensuring only a single roundtrip to the
    database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所谓的 *n* + 1 查询问题是在 GraphQL 数据获取实现中常见的一个问题，可能导致多次往返数据层，并可能对性能产生负面影响。考虑这种情况，我们请求有关一部电影及其所有演员的信息。在数据库中，我们可能存储与每部电影关联的演员
    ID 列表，该列表与我们的电影详情请求一起返回。在简单的 GraphQL 实现中，我们随后需要检索演员详情，并且我们需要为每个演员对象向数据库发出单独的请求，从而导致总共
    *n*（即演员数量）+ 1（即电影）次数据库查询。为了解决 *n* + 1 查询问题，像 DataLoader 这样的工具允许我们批量缓存对数据库的请求，从而提高性能。解决
    *n* + 1 查询问题的另一种方法是通过使用 GraphQL 数据库集成，例如 Neo4j GraphQL 库和 PostGraphile，这些库允许我们从任意
    GraphQL 请求生成单个数据库查询，确保只进行一次数据库往返。
- en: GraphQL limitations
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 限制
- en: While we’re talking about databases, it is important to understand that GraphQL
    is an API query language and not a database query language. GraphQL lacks semantics
    for many complex operations required of database query languages, such as aggregations,
    projects, and variable length path traversals.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据库时，重要的是要理解 GraphQL 是一种 API 查询语言，而不是数据库查询语言。GraphQL 缺乏数据库查询语言所需的许多复杂操作的语义，例如聚合、投影和可变长度路径遍历。
- en: 1.2.5 GraphQL tooling
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 GraphQL 工具
- en: In this section, we review some GraphQL-specific tooling that will help us build,
    test, and query our GraphQL API. These tools leverage GraphQL’s introspection
    feature, allowing for extracting the schema of a deployed GraphQL endpoint to
    generate documentation, query validation, auto-completion, and other useful development
    functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了一些特定的 GraphQL 工具，这些工具将帮助我们构建、测试和查询我们的 GraphQL API。这些工具利用 GraphQL 的
    introspection 功能，允许提取已部署的 GraphQL 端点的模式以生成文档、查询验证、自动完成和其他有用的开发功能。
- en: GraphiQL
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GraphiQL
- en: GraphiQL is an in-browser tool for exploring and querying GraphQL APIs. With
    GraphiQL, we can execute GraphQL queries against a GraphQL API and view the results.
    Thanks to GraphQL’s introspection feature, we can view the types, fields, and
    queries supported by the GraphQL API we’ve connected to. In addition, because
    of the GraphQL type system, we have immediate query validation as we construct
    our query. GraphiQL is an open source package now maintained by the GraphQL Foundation.
    GraphiQL is packaged as either a stand-alone tool or a React component and, therefore,
    is often embedded in larger web applications (see figure 1.5).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: GraphiQL 是一个浏览器内工具，用于探索和查询 GraphQL API。使用 GraphiQL，我们可以对 GraphQL API 执行 GraphQL
    查询并查看结果。多亏了 GraphQL 的 introspection 功能，我们可以查看我们连接的 GraphQL API 支持的类型、字段和查询。此外，由于
    GraphQL 类型系统，我们在构建查询时立即进行查询验证。GraphiQL 是一个由 GraphQL 基金会维护的开源软件包。GraphiQL 可以打包成一个独立工具或
    React 组件，因此通常嵌入到更大的 Web 应用程序中（见图 1.5）。
- en: '![CH01_F05_Lyon](../../OEBPS/Images/CH01_F05_Lyon.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F05_Lyon](../../OEBPS/Images/CH01_F05_Lyon.png)'
- en: Figure 1.5 GraphiQL screenshot
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 GraphiQL 截图
- en: GraphQL Playground
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL Playground
- en: Like GraphiQL, GraphQL Playground is an in-browser tool for executing GraphQL
    queries, viewing the results, and exploring the GraphQL API’s schema, powered
    by GraphQL’s introspection feature (see figure 1.6). GraphQL Playground has a
    few additional features, such as viewing GraphQL type definitions, searching through
    the GraphQL schema, and easily adding request headers (e.g., those required for
    authentication). GraphQL Playground was once included by default in server implementations,
    such as Apollo Server; however, it has since been deprecated and is no longer
    actively maintained. We include GraphQL Playground here, since it is still deployed
    in many GraphQL endpoints, and you will likely come across it at some point.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GraphiQL 类似，GraphQL Playground 是一个浏览器内工具，用于执行 GraphQL 查询、查看结果和探索 GraphQL API
    的模式，它由 GraphQL 的 introspection 功能提供支持（见图 1.6）。GraphQL Playground 有一些额外的功能，例如查看
    GraphQL 类型定义、搜索 GraphQL 模式，以及轻松添加请求头（例如，用于身份验证所需的头）。GraphQL Playground 曾经默认包含在服务器实现中，如
    Apollo Server；然而，它已被弃用，并且不再积极维护。我们在这里包含 GraphQL Playground，因为它仍然部署在许多 GraphQL
    端点中，你可能会在某个时刻遇到它。
- en: '![CH01_F06_Lyon](../../OEBPS/Images/CH01_F06_Lyon.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F06_Lyon](../../OEBPS/Images/CH01_F06_Lyon.png)'
- en: Figure 1.6 GraphQL Playground screenshot
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 GraphQL Playground 截图
- en: Apollo Studio
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Studio
- en: Apollo Studio is a cloud platform from Apollo that includes many features for
    building, validating, and securing GraphQL APIs (see figure 1.7). Apollo Studio
    is included in this section because the *Explorer* feature of Studio is similar
    to the GraphiQL and GraphQL Playground tools, mentioned previously, for creating
    and running GraphQL operations. Also, the Explorer in Apollo Studio is now used
    by default by Apollo Server (as of version 3 of Apollo Server), so we will be
    using Apollo Studio throughout this book to run GraphQL operations against our
    GraphQL API as we develop it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Studio 是 Apollo 提供的一个云平台，包括许多用于构建、验证和保障 GraphQL API 的功能（见图 1.7）。Apollo
    Studio 包含在本节中，因为 Studio 的 *探索者* 功能与之前提到的 GraphiQL 和 GraphQL Playground 工具类似，用于创建和运行
    GraphQL 操作。此外，Apollo Studio 中的探索者现在默认由 Apollo Server（截至 Apollo Server 版本 3）使用，因此我们将在这本书中使用
    Apollo Studio 来运行 GraphQL 操作，以开发我们的 GraphQL API。
- en: '![CH01_F07_Lyon](../../OEBPS/Images/CH01_F07_Lyon.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F07_Lyon](../../OEBPS/Images/CH01_F07_Lyon.png)'
- en: Figure 1.7 Apollo Studio screenshot
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 Apollo Studio 截图
- en: 1.3 React
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 React
- en: React is a declarative, component-based library for building user interfaces
    using JavaScript. React uses a virtual DOM (a copy of the actual document object
    model) to efficiently calculate DOM updates required to render views as application
    state and data changes. This means users simply design views that map to application
    data and React handles rendering the DOM updates efficiently. Components encapsulate
    data handling and user interface rendering logic without exposing their internal
    structure, so they can easily be composed together to build more complex user
    interfaces and applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于使用 JavaScript 构建用户界面的声明式、基于组件的库。React 使用虚拟 DOM（实际文档对象模型的副本）来高效地计算渲染视图所需的
    DOM 更新，以适应应用程序状态和数据的变化。这意味着用户只需设计映射到应用程序数据的视图，React 就会高效地处理 DOM 更新。组件封装了数据处理和用户界面渲染逻辑，而不暴露其内部结构，因此可以轻松组合在一起以构建更复杂用户界面和应用。
- en: 1.3.1 React components
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 React 组件
- en: Let’s examine a simple React component in the next listing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中检查一个简单的 React 组件。
- en: Listing 1.5 A simple React component
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 一个简单的 React 组件
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We import React and the useState hook for managing state variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们导入 React 和 useState 钩子以管理状态变量。
- en: ❷ Our component is a function that is passed props or values from other components
    higher in the React component hierarchy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的组件是一个函数，它从 React 组件层次结构中更高的组件接收 props 或值。
- en: ❸ Using the useState hook, we create a new state variable and the associated
    function for updating this value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 useState 钩子，我们创建一个新的状态变量及其关联的更新函数。
- en: ❹ Here we access the movieTitle value from our component state and render that
    inside a div tag.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这里，我们从组件状态中访问 movieTitle 值，并在 div 标签内渲染它。
- en: ❺ We export this component so it can be composed in other React components.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们导出这个组件，以便它可以在其他 React 组件中组合使用。
- en: Component libraries
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 组件库
- en: Since components encapsulate data handling and user interface rendering logic
    and are easily composable, it becomes practical to distribute libraries of components
    that can be used as dependencies of our project for quickly leveraging complex
    styling and user interface design. Using such component libraries is beyond the
    scope of this book; however, a good example is the Material UI component library,
    which allows us to import many popular, common user interface components, such
    as a grid layout, data table, navigation, and inputs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件封装了数据处理和用户界面渲染逻辑，并且易于组合，因此将组件库分发给项目作为依赖项以快速利用复杂的样式和用户界面设计变得实用。使用此类组件库超出了本书的范围；然而，一个很好的例子是
    Material UI 组件库，它允许我们导入许多流行的、常见的用户界面组件，例如网格布局、数据表、导航和输入。
- en: 1.3.2 JSX
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 JSX
- en: React is typically used with a JavaScript language extension called JSX. JSX
    looks similar to XML and is a powerful way of building user interfaces in React
    and composing React components. It is possible to use React without JSX, but most
    users prefer the readability and maintainability that JSX offers. We will introduce
    JSX in chapter 5 as well as a number of other React concepts, such as unidirectional
    data flow, props and state, and data fetching with React.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: React 通常与一个名为 JSX 的 JavaScript 语言扩展一起使用。JSX 看起来类似于 XML，并且是构建 React 用户界面和组合 React
    组件的强大方式。虽然可以使用 React 而不使用 JSX，但大多数用户更喜欢 JSX 提供的可读性和可维护性。我们将在第 5 章中介绍 JSX 以及其他一些
    React 概念，例如单向数据流、props 和 state，以及使用 React 进行数据获取。
- en: 1.3.3 React tooling
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 React 工具
- en: Next we’ll review some useful tooling that will help us build, develop, and
    troubleshoot React applications. There is a healthy ecosystem of tooling for developing
    with React applications, so don’t consider this a complete list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾一些有用的工具，这些工具将帮助我们构建、开发和调试 React 应用程序。对于使用 React 应用程序进行开发，有一个健康的工具生态系统，所以不要认为这是一个完整的列表。
- en: Create React App
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App
- en: Create React App is a command line tool that can be used to quickly create the
    scaffolding for a React application, taking care of configuring build settings,
    installing dependencies, and templating a simple React application to get started.
    We will use Create React App later in chapter 5 when we begin building the frontend
    of our application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Create React App 是一个命令行工具，可以用来快速创建 React 应用程序的框架，包括配置构建设置、安装依赖项以及模板化一个简单的 React
    应用程序以开始开发。我们将在第 5 章中介绍如何使用 Create React App 来构建应用程序的前端。
- en: React Chrome DevTools
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: React Chrome DevTools
- en: React DevTools is a browser extension that lets us inspect a React application
    and see the component hierarchy, props, and state of each component under the
    hood while our application is running, which enables debugging of our React applications.
    It can be very useful to see how our components are structured under different
    usage scenarios (see figure 1.8).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React DevTools是一个浏览器扩展，允许我们在应用程序运行时检查React应用程序，并查看组件层次结构、props和每个组件的内部状态，从而实现React应用程序的调试。在查看我们的组件在不同使用场景下的结构时，它非常有用（见图1.8）。
- en: '![CH01_F08_Lyon](../../OEBPS/Images/CH01_F08_Lyon.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F08_Lyon](../../OEBPS/Images/CH01_F08_Lyon.png)'
- en: Figure 1.8 React Chrome DevTools
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 React Chrome DevTools
- en: 1.4 Apollo
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 Apollo
- en: Apollo is a collection of tools that make it easier to use GraphQL, including
    on the server, the client, and in the cloud. We will make use of Apollo Server,
    a Node.js library for building our GraphQL API, and Apollo Client, a client-side
    JavaScript library for querying our GraphQL API from our application, as well
    as Apollo Studio’s Explorer for building and running queries, which was introduced
    previously.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo是一组工具，使使用GraphQL变得更容易，包括在服务器、客户端和云中。我们将使用Apollo Server，这是一个Node.js库，用于构建我们的GraphQL
    API，以及Apollo Client，这是一个客户端JavaScript库，用于从我们的应用程序查询GraphQL API，以及之前介绍的Apollo Studio的Explorer，用于构建和运行查询。
- en: 1.4.1 Apollo Server
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 Apollo Server
- en: 'Apollo Server allows us to easily spin up a Node.js server serving a GraphQL
    endpoint by defining our type definitions and resolver functions. Apollo Server
    can be used with many different web frameworks; however, the default and most
    popular is Express.js. Apollo Server can also be used with serverless functions,
    such as Amazon Lambda and Google Cloud Functions. Apollo Server can be installed
    with npm: npm install apollo-server.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Server 允许我们通过定义我们的类型定义和解析函数，轻松启动一个Node.js服务器，该服务器提供GraphQL端点。Apollo Server可以与许多不同的Web框架一起使用；然而，默认且最受欢迎的是Express.js。Apollo
    Server还可以与无服务器函数一起使用，例如Amazon Lambda和Google Cloud Functions。Apollo Server可以使用npm安装：npm
    install apollo-server。
- en: 1.4.2 Apollo Client
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 Apollo Client
- en: 'Apollo Client is a JavaScript library for querying GraphQL APIs and has integrations
    with many frontend frameworks, including React and Vue.js, as well as native mobile
    versions for iOS and Android. We will make use of the React Apollo Client integration
    to implement data fetching via GraphQL in our React components. Apollo Client
    handles client data caching and can also be used to manage local state data. The
    React Apollo Client library can be installed with npm: npm install @apollo/client.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Client是一个用于查询GraphQL API的JavaScript库，并与许多前端框架集成，包括React和Vue.js，以及原生移动版本iOS和Android。我们将使用React
    Apollo Client集成在React组件中实现通过GraphQL的数据获取。Apollo Client处理客户端数据缓存，也可以用于管理本地状态数据。React
    Apollo Client库可以使用npm安装：npm install @apollo/client。
- en: 1.5 Neo4j Database
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 Neo4j数据库
- en: Neo4j is an open source native graph database. Unlike other databases that use
    tables or documents for the data model, the data model used with Neo4j is a graph,
    specifically known as the *property graph data model*, which allows us to model,
    store, and query our data as a graph. Graph databases like Neo4j are optimized
    for working with graph data and executing complex graph traversals, such as those
    defined by GraphQL queries.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j是一个开源的原生图数据库。与其他使用表或文档作为数据模型的数据库不同，Neo4j使用的数据模型是一个图，具体称为*属性图数据模型*，它允许我们将数据作为图进行建模、存储和查询。像Neo4j这样的图数据库针对处理图数据和执行复杂的图遍历进行了优化，例如由GraphQL查询定义的遍历。
- en: One of the benefits of using a graph database with GraphQL is that we maintain
    the same graph data model throughout our application stack, working with graphs
    on both the frontend, backend, and database. Another benefit has to do with the
    performance optimizations graph databases make versus other database systems,
    such as relational databases. Many GraphQL queries end up being nested several
    levels deep—the equivalent of a JOIN operation in a relational database. Graph
    databases are optimized for performing these graph traversal operations very efficiently
    and, therefore, are a natural fit for the backend of a GraphQL API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图数据库与GraphQL的一个好处是我们可以在整个应用程序堆栈中保持相同的图数据模型，在前端、后端和数据库中处理图。另一个好处与图数据库相对于其他数据库系统（如关系数据库）的性能优化有关。许多GraphQL查询最终会嵌套多层——相当于关系数据库中的JOIN操作。图数据库针对执行这些图遍历操作进行了优化，因此是GraphQL
    API后端的自然选择。
- en: Note It’s important to note that we aren’t querying the database directly with
    GraphQL. While there are database integrations for GraphQL, the GraphQL API is
    a layer that sits between our application and the database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：需要注意的是，我们并不是直接使用 GraphQL 查询数据库。虽然 GraphQL 有数据库集成，但 GraphQL API 是位于我们的应用程序和数据库之间的一层。
- en: 1.5.1 Property graph data model
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 属性图数据模型
- en: Like many graph databases, Neo4j uses a property graph model (see figure 1.9).
    The components of the property graph model are
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多图数据库一样，Neo4j 使用属性图模型（见图 1.9）。属性图模型的组成部分包括
- en: Nodes—The entities or objects in our data model
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点—我们数据模型中的实体或对象
- en: Relationships—Connections between nodes
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系—节点之间的连接
- en: Labels—A grouping semantic for nodes
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签—节点的分组语义
- en: Properties—Key-value pair attributes, stored on nodes and relationships
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性—存储在节点和关系上的键值对属性
- en: '![CH01_F09_Lyon](../../OEBPS/Images/CH01_F09_Lyon.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F09_Lyon](../../OEBPS/Images/CH01_F09_Lyon.png)'
- en: Figure 1.9 Property graph example of books, publisher, customers, and orders
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 书籍、出版社、客户和订单的属性图示例
- en: The property graph data model allows us to express complex, connected data in
    a flexible way. This data model also has the additional benefit of closely mapping
    to the way we often think about data when dealing with a domain.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图数据模型允许我们以灵活的方式表达复杂、连接的数据。这种数据模型还具有额外的优势，即与我们在处理领域数据时通常考虑数据的方式紧密映射。
- en: 1.5.2 Cypher query language
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 Cypher 查询语言
- en: 'Cypher is a declarative graph query language used by Neo4j and other graph
    databases and graph compute engines. You can think of Cypher as being similar
    to SQL, but instead of working with tables, Cypher is designed for graph data.
    A major feature of Cypher is *pattern matching*. With graph pattern matching in
    Cypher, we can define the graph pattern using an ASCII-art-like notation. In the
    next listing, let’s look at a simple Cypher example: querying for movies and actors
    connected to these movies.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher 是由 Neo4j 和其他图数据库以及图计算引擎使用的声明式图查询语言。你可以将 Cypher 视为类似于 SQL，但 Cypher 是为图数据设计的，而不是处理表。Cypher
    的一个主要特性是 *模式匹配*。在 Cypher 中的图模式匹配中，我们可以使用类似 ASCII 艺术的符号来定义图模式。在下一个列表中，让我们看看一个简单的
    Cypher 示例：查询与这些电影相连的电影和演员。
- en: Listing 1.6 Simple Cypher query querying for movies and actors
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 简单的 Cypher 查询，查询电影和演员
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Describing a graph pattern to find data in the database
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 描述图模式以在数据库中查找数据
- en: ❷ We return the data matching the graph pattern described.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们返回与所描述的图模式匹配的数据。
- en: In our Cypher query, MATCH is followed by a graph pattern described using an
    ASCII-art-like notation. In this pattern, nodes are defined within parentheses—for
    example, (m:Movie). The :Movie indicates we should match nodes with the label
    Movie, and the m before the colon becomes a variable that is bound to any nodes
    that match the pattern. We can refer to m later throughout the query.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Cypher 查询中，MATCH 后跟一个使用类似 ASCII 艺术的符号描述的图模式。在这个模式中，节点定义在括号内——例如，(m:Movie)。:Movie
    表示我们应该匹配标签为 Movie 的节点，冒号前的 m 成为一个变量，它绑定到匹配该模式的任何节点。我们可以在整个查询中引用 m。
- en: Relationships are defined by square brackets (e.g., <-[r:ACTED_IN]-) and follow
    a similar convention, in which :ACTED_IN declares the ACTED_IN relationship type,
    and r becomes a variable we can refer to later in the query to represent any relationships
    matching that pattern.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关系由方括号定义（例如，<-[r:ACTED_IN]-）并遵循类似的约定，其中 :ACTED_IN 声明 ACTED_IN 关系类型，r 成为一个可以在查询中引用的变量，用于表示匹配该模式的任何关系。
- en: In the RETURN clause, we specify the data to be returned by the query. Here,
    we specify the variables m, r, and a, which are variables that were defined in
    the MATCH clause and are bound to nodes and relationships in the database that
    match elements of the graph pattern.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RETURN 子句中，我们指定查询要返回的数据。在这里，我们指定了变量 m、r 和 a，这些变量是在 MATCH 子句中定义的，并且与数据库中匹配图模式元素的节点和关系绑定。
- en: 1.5.3 Neo4j tooling
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.3 Neo4j 工具
- en: We will make use of Neo4j Desktop for managing our Neo4j instances locally and
    on Neo4j Browser, a developer tool for querying and interacting with our Neo4j
    database. For querying Neo4j from our GraphQL API, we will use the JavaScript
    Neo4j client driver as well as the Neo4j GraphQL library, a Node.js GraphQL integration
    for Neo4j.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Neo4j Desktop 来管理本地和 Neo4j Browser 上的 Neo4j 实例，Neo4j Browser 是一个用于查询和与我们的
    Neo4j 数据库交互的开发者工具。为了从我们的 GraphQL API 查询 Neo4j，我们将使用 JavaScript Neo4j 客户端驱动程序以及
    Neo4j GraphQL 库，这是一个用于 Neo4j 的 Node.js GraphQL 集成。
- en: Neo4j Desktop
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j Desktop
- en: Neo4j Desktop is Neo4j’s command center (see figure 1.10). From Neo4j Desktop
    we can manage Neo4j database instances, including editing configuration, installing
    plugins and graph apps (e.g., visualization tools), and accessing admin level
    features, such as dump/load database. Neo4j Desktop is the default download experience
    for Neo4j and can be downloaded at [neo4j.com/download](https://neo4j.com/download/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j Desktop 是 Neo4j 的指挥中心（见图 1.10）。从 Neo4j Desktop 我们可以管理 Neo4j 数据库实例，包括编辑配置、安装插件和图形应用（例如，可视化工具），以及访问管理员级别的功能，如导出/导入数据库。Neo4j
    Desktop 是 Neo4j 的默认下载体验，可在 [neo4j.com/download](https://neo4j.com/download/) 下载。
- en: '![CH01_F10_Lyon](../../OEBPS/Images/CH01_F10_Lyon.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F10_Lyon](../../OEBPS/Images/CH01_F10_Lyon.png)'
- en: Figure 1.10 Neo4j Desktop
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 Neo4j Desktop
- en: Neo4j AuraDB
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j AuraDB
- en: Neo4j AuraDB is Neo4j’s fully managed cloud service that offers hosted Neo4j
    instances in the cloud. AuraDB includes a free tier, which makes it a great option
    for developing and deploying hobby projects. We will cover Neo4j AuraDB in more
    detail in chapter 8 when we explore deploying our full stack application making
    use of cloud services. You can get started with Neo4j AuraDB for free at [dev.neo4j.com/neo4j-aura](https://neo4j.com/cloud/platform/aura-graph-database/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j AuraDB 是 Neo4j 的完全托管云服务，在云中提供托管的 Neo4j 实例。AuraDB 包括免费层，这使得它成为开发和个人项目的绝佳选择。我们将在第
    8 章中更详细地介绍 Neo4j AuraDB，当时我们将探讨使用云服务部署我们的全栈应用程序。您可以在 [dev.neo4j.com/neo4j-aura](https://neo4j.com/cloud/platform/aura-graph-database/)
    免费开始使用 Neo4j AuraDB。
- en: Neo4j Browser
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 浏览器
- en: Neo4j Browser is an in-browser query workbench for Neo4j and is one of the primary
    ways of interacting with Neo4j during development (see figure 1.11). With Neo4j
    Browser, we can query the database with Cypher and visualize the results, either
    as a graph visualization or with tabular results.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 浏览器是 Neo4j 的浏览器内查询工作台，是开发期间与 Neo4j 交互的主要方式之一（见图 1.11）。使用 Neo4j 浏览器，我们可以使用
    Cypher 查询数据库并可视化结果，无论是作为图形可视化还是以表格形式的结果。
- en: '![CH01_F11_Lyon](../../OEBPS/Images/CH01_F11_Lyon.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F11_Lyon](../../OEBPS/Images/CH01_F11_Lyon.png)'
- en: Figure 1.11 Neo4j Browser
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 Neo4j 浏览器
- en: Neo4j client drivers
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 客户端驱动程序
- en: Since our end goal is to build an application that talks to our Neo4j database,
    we will make use of the language drivers for Neo4j. Client drivers are available
    in many languages (Java, Python, .Net, JavaScript, Go, etc.), but we will use
    the Neo4j JavaScript driver.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的最终目标是构建一个与我们的 Neo4j 数据库通信的应用程序，我们将利用 Neo4j 的语言驱动程序。客户端驱动程序在许多语言中可用（Java、Python、.Net、JavaScript、Go
    等），但我们将使用 Neo4j JavaScript 驱动程序。
- en: Note The Neo4j JavaScript driver has both a Node.js and browser version (allowing
    connections to the database directly from the browser); however, in this book,
    we will only use the Node.js version.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Neo4j JavaScript 驱动程序既有 Node.js 版本也有浏览器版本（允许从浏览器直接连接到数据库）；然而，在这本书中，我们只会使用
    Node.js 版本。
- en: 'The Neo4j JavaScript driver is installed using npm:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j JavaScript 驱动程序使用 npm 安装：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following listing, let’s look at an example: using the Neo4j JavaScript
    driver to execute a Cypher query and log the results.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，让我们看看一个示例：使用 Neo4j JavaScript 驱动程序执行 Cypher 查询并记录结果。
- en: Listing 1.7 Basic Neo4j JavaScript driver usage
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.7 基本Neo4j JavaScript 驱动程序使用
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Importing the neo4j-driver module
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 neo4j-driver 模块
- en: ❷ Creating a driver instance and specifying the database connection string
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建驱动程序实例并指定数据库连接字符串
- en: ❸ Specifying the database user and password
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定数据库用户名和密码
- en: ❹ Sessions are more lightweight and should be instantiated for a specific block
    of work.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 会话更轻量级，应该为特定的工作块实例化。
- en: ❺ Run the query in an auto-commit transaction; it returns a promise.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在自动提交事务中运行查询；它返回一个承诺。
- en: ❻ The promise resolves to a result set.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 承诺解析为结果集。
- en: ❼ Accessing the records of the result set and selecting the first record
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 访问结果集的记录并选择第一条记录
- en: ❽ Be sure to close the session.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 一定要关闭会话。
- en: We will learn how to make use of the Neo4j JavaScript driver in our GraphQL
    resolver functions as one way to implement data fetching in our GraphQL API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在我们的 GraphQL 解析函数中利用 Neo4j JavaScript 驱动程序，作为在我们的 GraphQL API 中实现数据获取的一种方式。
- en: The Neo4j GraphQL Library
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL 库
- en: 'The Neo4j GraphQL Library is a GraphQL-to-Cypher query execution layer for
    Neo4j. It works with any of the JavaScript GraphQL server implementations, such
    as Apollo Server. We will learn how to use this library for the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j GraphQL 库是 Neo4j 的 GraphQL 到 Cypher 查询执行层。它与任何 JavaScript GraphQL 服务器实现（如
    Apollo Server）一起工作。我们将学习如何使用此库来完成以下任务：
- en: Using GraphQL type definitions to drive the Neo4j database schema
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GraphQL 类型定义驱动 Neo4j 数据库模式
- en: Generating a full CRUD GraphQL API from GraphQL type definitions
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GraphQL 类型定义生成完整的 CRUD GraphQL API
- en: Generating a single Cypher database query for arbitrary GraphQL requests (solving
    the *n* + 1 query problem)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为任意 GraphQL 请求生成单个 Cypher 数据库查询（解决 *n* + 1 查询问题）
- en: Adding custom logic to our GraphQL API using Cypher
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Cypher 在我们的 GraphQL API 中添加自定义逻辑
- en: While GraphQL is data-layer-agnostic—GraphQL APIs can be implemented using any
    data source or database—when used with a graph database, there are benefits, such
    as reducing mapping and translation of the data model and performance optimizations
    for addressing complex traversals defined with GraphQL. The Neo4j GraphQL library
    helps to build GraphQL APIs backed by the Neo4j graph database. Using the Neo4j
    GraphQL library is covered beginning in chapter 4, and you can read more about
    the library at [dev.neo4j.com/graphql](https://neo4j.com/product/graphql-library/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GraphQL 是数据层无关的——可以使用任何数据源或数据库实现 GraphQL API——但是当与图数据库一起使用时，有一些好处，例如减少数据模型映射和转换，以及针对使用
    GraphQL 定义的复杂遍历的性能优化。Neo4j GraphQL 库有助于构建由 Neo4j 图数据库支持的 GraphQL API。从第 4 章开始介绍使用
    Neo4j GraphQL 库，你可以在 [dev.neo4j.com/graphql](https://neo4j.com/product/graphql-library/)
    上了解更多关于该库的信息。
- en: 1.6 How it all fits together
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 如何整体结合
- en: 'Now that we’ve taken a look at each individual piece of our GraphQL stack,
    let’s see how everything fits together in the context of a full stack application,
    using the movie search application as our example. Our imaginary movie application
    has three simple requirements:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了我们 GraphQL 栈的每个单独部分，让我们看看在完整栈应用程序的上下文中，所有这些是如何结合在一起的，我们以电影搜索应用程序为例。我们虚构的电影应用程序有三个简单的要求：
- en: Allow the user to search for a movie by title.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许用户通过标题搜索电影。
- en: Display any matching results and details of those movies, such as rating or
    genre, to the user.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户显示任何匹配的结果和电影的详细信息，例如评分或类型。
- en: Show a list of similar movies that might be a good recommendation if the user
    liked the matching movie.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示与用户喜欢的匹配电影相似的影片列表，这可能是一个不错的推荐。
- en: Figure 1.12 shows how the different components would fit together, following
    the flow of a request from the client application, searching for movies by title,
    to the GraphQL API, then resolving data from the Neo4j database, and back to the
    client, rendering the results in an updated user interface view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 展示了不同组件如何组合在一起，从客户端应用程序的请求流程开始，通过标题搜索电影，到 GraphQL API，然后从 Neo4j 数据库解析数据，最后返回客户端，在更新的用户界面视图中呈现结果。
- en: '![CH01_F12_Lyon](../../OEBPS/Images/CH01_F12_Lyon.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F12_Lyon](../../OEBPS/Images/CH01_F12_Lyon.png)'
- en: Figure 1.12 Following a movie search request through a full stack GraphQL application
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 随着电影搜索请求通过完整的 GraphQL 应用程序
- en: '1.6.1 React and Apollo Client: Making the request'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 React 和 Apollo Client：发起请求
- en: The frontend of our application is built in React; specifically, we have a MovieSearch
    React component, which renders a text box that accepts user input (a movie search
    string to be provided by the user). This MovieSearch component also contains the
    logic for taking the user input, combining it with a GraphQL query, and sending
    this query to the GraphQL server to resolve the data using the Apollo Client React
    integration. The following listing shows what the GraphQL query sent to the API
    might look like if the user searched for “River Runs Through It.”
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的前端是用 React 构建的；具体来说，我们有一个 MovieSearch React 组件，它渲染一个接受用户输入的文本框（用户将提供要搜索的电影字符串）。这个
    MovieSearch 组件还包含将用户输入与 GraphQL 查询结合，并通过 Apollo Client React 集成将其发送到 GraphQL 服务器以解析数据的逻辑。以下列表显示了如果用户搜索“河上河”，发送到
    API 的 GraphQL 查询可能的样子。
- en: Listing 1.8 GraphQL query searching for movies matching “River Runs Through
    It”
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.8 搜索匹配“河上河”电影的 GraphQL 查询
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This data-fetching logic is enabled by Apollo Client, which we use in the MovieSearch
    component. Apollo Client implements a cache, so when the user enters their search
    query, Apollo Client first checks the cache to see if a GraphQL query has previously
    been handled for this search string. If not, then the query is sent to the GraphQL
    server as an HTTP POST request to /graphql.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据获取逻辑是通过 Apollo Client 实现的，我们在 MovieSearch 组件中使用它。Apollo Client 实现了一个缓存，所以当用户输入他们的搜索查询时，Apollo
    Client 首先检查缓存，看是否已经处理过这个搜索字符串的 GraphQL 查询。如果没有，那么查询将以 HTTP POST 请求的形式发送到 GraphQL
    服务器上的 /graphql。
- en: 1.6.2 Apollo Server and GraphQL backend
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.2 Apollo Server 和 GraphQL 后端
- en: The backend for our movie application is a Node.js application that uses Apollo
    Server and the Express web server library to serve a /graphql endpoint over HTTP.
    A GraphQL server is composed of the network layer, which is responsible for processing
    HTTP requests, extracting the GraphQL operation, and returning HTTP responses,
    and the GraphQL schema, which defines the entry points and data structures for
    the API and is responsible for resolving the data from the data layer by executing
    resolver functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电影应用程序的后端是一个 Node.js 应用程序，它使用 Apollo Server 和 Express 网络服务器库通过 HTTP 提供一个
    /graphql 端点。一个 GraphQL 服务器由网络层组成，负责处理 HTTP 请求、提取 GraphQL 操作并返回 HTTP 响应，以及 GraphQL
    模式，它定义了 API 的入口点和数据结构，并负责通过执行解析函数从数据层解析数据。
- en: When Apollo Client makes its request, our GraphQL server handles the request
    by validating the query and then begins to resolve the request by first calling
    the root level resolver function, which, in this case, is Query.moviesByTitle.
    This resolver function is passed the title argument—the value the user typed into
    the search text box. Inside our resolver function, we have the logic for querying
    the database to find movies with titles matching the search query, retrieving
    the movie details, and finding a list of other recommended movies for each matching
    movie.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Apollo 客户端发起请求时，我们的 GraphQL 服务器通过验证查询来处理请求，然后首先调用根级别的解析函数，在这个例子中是 Query.moviesByTitle。这个解析函数接收标题参数——用户在搜索文本框中输入的值。在我们的解析函数内部，我们拥有查询数据库以找到与搜索查询匹配的电影、检索电影详情以及为每部匹配电影找到其他推荐电影的逻辑。
- en: Resolver implementation
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数实现
- en: 'In this book, we will show two methods for implementing resolver functions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将展示两种实现解析函数的方法：
- en: The *naive* approach of defining database queries inside individual resolvers
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各个解析函数内部定义数据库查询的 *天真* 方法
- en: Auto-generating resolvers using GraphQL *engine* libraries, such as the Neo4j
    GraphQL library
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraphQL *引擎* 库自动生成解析函数，例如 Neo4j GraphQL 库
- en: This example covers only the first case.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只涵盖了第一种情况。
- en: Resolver functions are executed in a nested fashion (see figure 1.13)—in this
    case, starting with the moviesByTitle query field resolver, which is the root
    level resolver for this operation. The moviesByTitle resolver will return a list
    of movies, and then the resolver for each field requested in the query will be
    called and passed an item from the list of movies returned by moviesByTitle—essentially
    iterating over this list of movies.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解析函数以嵌套的方式执行（参见图 1.13）——在这个例子中，从 moviesByTitle 查询字段解析函数开始，这是此操作的根级别解析函数。moviesByTitle
    解析函数将返回一个电影列表，然后查询中请求的每个字段的解析函数将被调用，并传递 moviesByTitle 返回的电影列表中的一个项目——本质上是对这个电影列表进行迭代。
- en: '![CH01_F13_Lyon](../../OEBPS/Images/CH01_F13_Lyon.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F13_Lyon](../../OEBPS/Images/CH01_F13_Lyon.png)'
- en: Figure 1.13 GraphQL resolver functions are called in a nested fashion.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 GraphQL 解析函数以嵌套方式调用。
- en: Each resolver function contains logic for resolving data for a piece of the
    overall GraphQL schema. For example, the recommendedMovies resolver, when given
    a movie, has the logic to find similar movies that the viewer might also enjoy.
    In this case, this is done by querying the database, using a simple Cypher query
    to search for users who have viewed the movie, and traversing out to find other
    movies those users have viewed to provide a collaborative filtering recommendation,
    as shown in the following listing. This query is executed in Neo4j using the Node.js
    JavaScript Neo4j client driver.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解析函数都包含解析整体 GraphQL 模式一部分数据的逻辑。例如，当推荐电影解析函数接收到一部电影时，它有找到观众可能也喜欢的类似电影的逻辑。在这种情况下，这是通过查询数据库，使用简单的
    Cypher 查询来搜索观看过该电影的用户，并遍历以找到这些用户观看的其他电影来提供协同过滤推荐，如以下列表所示。此查询在 Neo4j 中使用 Node.js
    JavaScript Neo4j 客户端驱动程序执行。
- en: Listing 1.9 A simple movie recommendation Cypher query
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.9 一个简单的电影推荐 Cypher 查询
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*n* + 1 query problem'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* + 1 查询问题'
- en: Here we have a perfect demonstration of the *n* + 1 query problem. Our root-level
    resolver returns a list of movies. Now, to resolve our GraphQL query, we need
    to call the actors resolver once for each movie. This results in multiple requests
    to the database, which can impact performance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们完美地展示了 *n* + 1 查询问题。我们的根级别解析函数返回一个电影列表。现在，为了解析我们的 GraphQL 查询，我们需要为每部电影调用一次演员解析函数。这会导致对数据库的多次请求，可能会影响性能。
- en: 'Ideally, we instead make a single request to the database, which fetches all
    data needed to resolve the GraphQL query in a single request. There are a few
    solutions to this problem:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们向数据库发送单个请求，该请求获取解决 GraphQL 查询所需的所有数据。对此问题有几个解决方案：
- en: The DataLoader library allows us to batch our requests together.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataLoader 库允许我们将请求批量处理。
- en: GraphQL engine libraries, like the Neo4j GraphQL library, can generate a single
    database query from an arbitrary GraphQL request, leveraging the graph nature
    of GraphQL without negative performance impacts from multiple database calls.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 引擎库，如 Neo4j GraphQL 库，可以从任意 GraphQL 请求生成单个数据库查询，利用 GraphQL 的图特性，而不会因多次数据库调用而产生负面的性能影响。
- en: '1.6.3 React and Apollo Client: Handling the response'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.3 React 和 Apollo 客户端：处理响应
- en: Once our data fetching is complete and the data is sent back to Apollo Client,
    the cache is updated, so if this same search query is executed in the future,
    the data will be retrieved from the cache, instead of requesting the data from
    the GraphQL server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的数据获取完成并将数据发送回 Apollo 客户端，缓存就会更新，因此如果将来执行相同的搜索查询，数据将从缓存中检索，而不是从 GraphQL
    服务器请求数据。
- en: Our MovieSearch React component passes the results of the GraphQL query to a
    MovieList component as props, which, in turn, renders a series of Movie components,
    updating the view to show the movie details for each matching movie—in this case,
    just one. And our user is presented with a list of movie search results (see figure
    1.14)!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 MovieSearch React 组件将 GraphQL 查询的结果作为 props 传递给 MovieList 组件，该组件随后渲染一系列
    Movie 组件，更新视图以显示每个匹配电影的详细信息——在这种情况下，只有一个。我们的用户将看到一个电影搜索结果列表（见图 1.14）！
- en: '![CH01_F14_Lyon](../../OEBPS/Images/CH01_F14_Lyon.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![CH01_F14_Lyon](../../OEBPS/Images/CH01_F14_Lyon.png)'
- en: Figure 1.14 React components are composed together to build a complex user interface.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 React 组件组合在一起构建复杂的用户界面。
- en: The goal of this example is to show how GraphQL, React, Apollo, and Neo4j Database
    are used together to build a simple full stack application. We’ve omitted many
    details, such as authentication, authorization, and optimizing performance, but
    don’t worry, we will cover all this in detail throughout the book!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目标是展示如何将 GraphQL、React、Apollo 和 Neo4j 数据库结合使用来构建一个简单的全栈应用程序。我们省略了许多细节，例如身份验证、授权和优化性能，但请放心，我们将在整本书中详细讲解这些内容！
- en: 1.7 What we will build in this book
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 本书我们将构建的内容
- en: The simple movie search example we’ve used throughout the chapter was, hopefully,
    a decent introduction to the concepts we’ll learn throughout this book. Instead
    of building a movie search application, let’s start from scratch and build a new
    application, working through the requirements and GraphQL API design together
    as we build up our knowledge of GraphQL. To demonstrate the concepts covered in
    this book, we will build a web application that makes use of GraphQL, React, Apollo,
    and Neo4j. This web application will be a simple business review application.
    The requirements of the application are
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用的简单电影搜索示例，希望是对我们将在这本书中学到的概念的一个不错的介绍。我们不是构建一个电影搜索应用程序，而是从头开始构建一个新的应用程序，在构建过程中，我们将一起处理需求并设计
    GraphQL API，以此构建我们对 GraphQL 的知识。为了展示本书中涵盖的概念，我们将构建一个利用 GraphQL、React、Apollo 和
    Neo4j 的 Web 应用程序。这个 Web 应用程序将是一个简单的企业评论应用程序。该应用程序的需求包括
- en: Listing businesses and business details
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出企业和企业详细信息
- en: Allowing users to write reviews of businesses
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户对商业机构撰写评论
- en: Allowing users to search for businesses and showing personalized recommendations
    to the user
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户搜索商业机构并向用户展示个性化推荐
- en: To implement this application, we will need to design and implement our GraphQL
    API, user interface, and database. We will need to handle issues such as authentication
    and authorization and deploy our application to the cloud.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现此应用程序，我们需要设计和实现我们的 GraphQL API、用户界面和数据库。我们需要处理身份验证、授权等问题，并将我们的应用程序部署到云端。
- en: 1.8 Exercises
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 练习
- en: To familiarize yourself with GraphQL and writing GraphQL queries, explore the
    public movies GraphQL API at [https://movies.neo4j-graphql.com](https://movies.neo4j-graphql.com).
    Open the URL in a web browser to access GraphQL Playground, and explore the DOCS
    and SCHEMA tabs to view the type definitions.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了熟悉 GraphQL 和编写 GraphQL 查询，请探索公共电影 GraphQL API，网址为 [https://movies.neo4j-graphql.com](https://movies.neo4j-graphql.com)。在网页浏览器中打开此
    URL 以访问 GraphQL Playground，并探索 DOCS 和 SCHEMA 标签以查看类型定义。
- en: 'Try writing queries to respond to the following prompts:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试编写查询以响应以下提示：
- en: Find the titles of the first 10 movies, ordered by title.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按标题顺序查找前 10 部电影的标题。
- en: Who acted in the movie *Jurassic Park*?
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁出演了电影《侏罗纪公园》？
- en: What are the genres of *Jurassic Park*? What other movies are in those genres?
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《侏罗纪公园》的流派是什么？还有哪些电影属于这些流派？
- en: What movie has the highest imdbRating?
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪部电影具有最高的 imbdRating？
- en: Consider the business review application we described earlier in the chapter.
    See if you can create the GraphQL type definitions necessary for this application.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑我们在本章中描述过的业务评论应用程序。看看你是否可以创建此应用程序所需的 GraphQL 类型定义。
- en: Download Neo4j, and familiarize yourself with Neo4j Desktop and Neo4j Browser.
    Work through a Neo4j Sandbox example dataset guide at [neo4j.com/sandbox](https://neo4j.com/sandbox/).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Neo4j，熟悉 Neo4j Desktop 和 Neo4j Browser。在 [neo4j.com/sandbox](https://neo4j.com/sandbox/)
    上完成 Neo4j Sandbox 示例数据集指南。
- en: 'You can find solutions to the exercises as well as code samples from this book
    in the GitHub repository for this book: [github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到练习的解决方案以及代码示例：[github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book)。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: GraphQL is an API query language and runtime for fulfilling requests. We can
    use GraphQL with any data layer. To build a GraphQL API, we first define the types,
    which include the fields available on each type and how they are connected, and
    describe the data graph.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 是一种用于满足请求的 API 查询语言和运行时。我们可以使用 GraphQL 与任何数据层结合。要构建 GraphQL API，我们首先定义类型，包括每个类型上可用的字段以及它们是如何连接的，并描述数据图。
- en: React is a JavaScript library for building user interfaces. We use JSX to construct
    components that encapsulate data and logic. These components can be composed together,
    allowing for building complex user interfaces.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 是一个用于构建用户界面的 JavaScript 库。我们使用 JSX 构建封装数据和逻辑的组件。这些组件可以组合在一起，从而允许构建复杂用户界面。
- en: Apollo is a collection of tools for working with GraphQL, both on the client
    and the server. Apollo Server is a Node.js library for building GraphQL APIs.
    Apollo Client is a JavaScript GraphQL client that has integrations for many frontend
    frameworks, including React.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo 是一套用于处理 GraphQL 的工具集合，适用于客户端和服务器端。Apollo Server 是一个用于构建 GraphQL API 的
    Node.js 库。Apollo Client 是一个 JavaScript GraphQL 客户端，它集成了许多前端框架，包括 React。
- en: Neo4j is an open source graph database that uses the property graph data model,
    which consists of nodes, relationships, labels, and properties. We use the Cypher
    query language for interacting with Neo4j.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j 是一个开源的图数据库，它使用属性图数据模型，该模型由节点、关系、标签和属性组成。我们使用 Cypher 查询语言与 Neo4j 交互。
- en: These technologies can be used together to build full stack GraphQL applications.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些技术可以一起使用来构建全栈 GraphQL 应用程序。
