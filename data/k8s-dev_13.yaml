- en: '11 GitOps: Configuration as code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 GitOps：配置即代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using namespaces and configuration files to replicate environments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间和配置文件来复制环境
- en: The benefits of treating Kubernetes workload configuration like source code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Kubernetes 工作负载配置视为源代码的好处
- en: Using Git pull requests to drive operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Git pull 请求来驱动操作
- en: Handling secrets without storing them in plain text in version control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在版本控制中不存储明文形式的机密信息
- en: You may have noticed in this book so far that we’ve been writing a lot of YAML
    configuration files. It is possible to interact with most Kubernetes objects without
    writing configuration files using imperative `kubectl` commands such as `kubectl`
    `run`, and these are arguably easier to learn. So why did I use the declarative
    configuration-based approach throughout? One reason is that as you take an app
    to production, you can start treating the configuration like code, with version
    control and code reviews.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这本书中，我们一直在编写大量的 YAML 配置文件。在不编写配置文件的情况下，你可以使用命令式 `kubectl` 命令（如 `kubectl
    run`）与大多数 Kubernetes 对象进行交互，这些命令的学习难度相对较低。那么，为什么我一直在使用基于声明的配置方法呢？一个原因是当你将应用程序部署到生产环境时，你可以开始将配置视为代码，使用版本控制和代码审查。
- en: Another reason is it allows you to easily spin up multiple environments with
    the same configuration. Let’s say you want a staging and a production environment
    that are as similar as possible for better testing. With your workloads defined
    in configuration files, it’s possible to replicate the environments easily. Kubernetes
    has a namespaces feature that makes this possible without needing to worry about
    name collisions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是它允许你轻松地使用相同的配置启动多个环境。比如说，你想要一个尽可能相似的开发测试环境和生产环境，以便进行更好的测试。在你的工作负载定义在配置文件中时，可以轻松地复制这些环境。Kubernetes
    的命名空间功能使得无需担心名称冲突即可实现这一点。
- en: 11.1 Production and staging environments using namespaces
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 使用命名空间的生产和开发测试环境
- en: As you prepare your application for production, you’ll likely want to create
    a staging environment where changes can be tested before the live production application
    is updated. Kubernetes makes this easy with namespaces.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为应用程序准备生产环境时，你可能会想要创建一个开发测试环境，以便在更新实时生产应用程序之前测试更改。Kubernetes 通过命名空间使这变得简单。
- en: Namespaces, as their name suggests, provide name uniqueness within a single
    logical space. So you can set up a production namespace and a staging namespace
    and have the Deployment `foo-deployment` and Service `foo-service` in each of
    them (figure 11.1). This avoids the need to excessively modify your configuration
    for the different environments, like creating a differently named `foo-staging-deployment`
    and `foo-staging-service`, and provides some protection against accidental changes
    as, by default, `kubectl` commands only apply to the namespace that’s currently
    active.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间，正如其名所示，在单个逻辑空间内提供名称的唯一性。因此，你可以设置一个生产命名空间和一个开发测试命名空间，并在每个命名空间中设置 Deployment
    `foo-deployment` 和 Service `foo-service`（如图 11.1）。这避免了你需要过度修改配置以适应不同环境的需求，例如创建不同名称的
    `foo-staging-deployment` 和 `foo-staging-service`，并且提供了一些防止意外更改的保护，因为默认情况下，`kubectl`
    命令仅应用于当前活动的命名空间。
- en: '![11-01](../../OEBPS/Images/11-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![11-01](../../OEBPS/Images/11-01.png)'
- en: Figure 11.1 A Kubernetes cluster with two namespaces. Note that the Deployment
    and Service objects in these namespaces have the same name in both.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 一个具有两个命名空间的 Kubernetes 集群。请注意，这些命名空间中的 Deployment 和 Service 对象名称相同。
- en: The main configuration differences between your production and staging are typically
    things like the scale (number of replicas) and any external service credentials
    for services not deployed as part of the namespace.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你的生产环境和开发测试环境之间的主要配置差异通常是诸如规模（副本数量）和任何未作为命名空间一部分部署的服务的外部服务凭证等事项。
- en: TIP As the complexity of your application workloads or the number of differently
    configured environments increases, you may wish to consider using a templating
    engine such as Kustomize or Helm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：随着你的应用程序工作负载的复杂性或不同配置环境的数量增加，你可能希望考虑使用模板引擎，如 Kustomize 或 Helm。
- en: To create a namespace named `staging` to host a new instance of the application,
    you can run
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个名为 `staging` 的命名空间以托管应用程序的新实例，你可以运行
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To interact with this namespace, you can either add `--namespace` `staging`
    (or `-n` `staging` for short) to every `kubectl` command you run or change the
    `kubectl` context so that all commands will run in this new namespace. I highly
    recommend the latter, as you don’t want to forget the `-n` flag and accidentally
    run a command in the wrong namespace. Better to switch contexts each time. You
    can list the available namespaces with `kubectl` `get` `namespace` and then set
    the context to be the namespace of your choosing:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要与此命名空间交互，你可以在运行的每个`kubectl`命令中添加`--namespace` `staging`（或简写为`-n` `staging`）或更改`kubectl`上下文，以便所有命令都在这个新命名空间中运行。我强烈推荐后者，因为你不想忘记`-n`标志并意外在错误的命名空间中运行命令。最好每次都切换上下文。你可以使用`kubectl`
    `get` `namespace`列出可用的命名空间，然后设置上下文为你的选择：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When listing the namespaces, you may notice that Kubernetes comes with a few
    namespaces out of the box. `kube-system` is where the system Pods go—best not
    to touch this one unless you know what you’re doing. `default` is the default
    user namespace which is fine to use, but I recommend creating your own dedicated
    ones, one for each application environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当列出命名空间时，你可能注意到Kubernetes自带了一些命名空间。`kube-system`是系统Pod所在的地方——除非你清楚自己在做什么，否则最好不要触碰这个。`default`是默认用户命名空间，使用它是可以的，但我建议创建你自己的专用命名空间，每个应用环境一个。
- en: 'I find the `kubectl` context setting command tedious and highly recommend setting
    up your shell with a utility to make it simpler to switch. The one I use is `kubectx`
    + `kubens`.[¹](#pgfId-1023511) With `kubens` installed, you can run `kubens` to
    list the namespaces, and the following to set the context:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得`kubectl`上下文设置命令很繁琐，并强烈推荐设置你的shell，使用一个工具使其更简单。我使用的是`kubectx` + `kubens`。[¹](#pgfId-1023511)
    安装`kubens`后，你可以运行`kubens`来列出命名空间，并使用以下命令设置上下文：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The other included utility, `kubectx,` can be used to quickly switch between
    different clusters entirely. These scripts are just shorthand for the longer `kubectl`
    `config` `set-context` commands, so you can go back to using `kubectl` as normal
    once the context is set.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个包含的实用工具`kubectx,`可以用来在完全不同的集群之间快速切换。这些脚本只是较长`kubectl` `config` `set-context`命令的简写，所以一旦设置了上下文，你就可以像平常一样使用`kubectl`。
- en: 11.1.1 Deploying to our new namespace
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 部署到我们的新命名空间
- en: 'Once you have the namespace created, you can deploy your application easily
    from the configuration. This is why this book has been using configuration files
    in every case. Instead of rerunning a bunch of imperative commands to re-create
    your workloads, you can simply run the following command from the folder with
    your configuration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了命名空间，你就可以轻松地从配置中部署应用程序。这就是为什么这本书在每种情况下都使用配置文件的原因。你不必重新运行一系列强制命令来重新创建你的工作负载，你只需从包含你的配置文件的文件夹中运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And if you make any changes to the configuration or need to deploy it to yet
    another namespace, you just rerun that command each time to roll out your changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改配置或将其部署到另一个命名空间，你只需每次重新运行该命令即可推出你的更改。
- en: In fact, creating new environments with namespaces in Kubernetes is so trivial
    to configure that if you were sharing a single staging environment in the past
    on other platforms, you may see some benefit to having a lot of different environments.
    You can have a namespace per developer or team, one for staging, another for integration
    testing, and so forth. Generally, the namespaces are free (of course, the compute
    resources used by duplicating your Pods are not).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Kubernetes中使用命名空间创建新环境非常简单，以至于如果你过去在其他平台上共享单个预发布环境，你可能看到拥有许多不同环境的一些好处。你可以为每个开发者或团队创建一个命名空间，一个用于预发布，另一个用于集成测试，等等。通常，命名空间是免费的（当然，复制你的Pod所使用的计算资源除外）。
- en: 11.1.2 Syncing mutations from the cluster
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 从集群同步变更
- en: But what about any changes that were made imperatively, outside of configuration?
    Perhaps you scaled a workload with `kubectl` `scale`, changed the image with `kubectl`
    `set-image`, or created a Deployment with `kubectl` `run`. It happens; I won’t
    judge.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于任何在配置之外强制执行的更改怎么办？也许你使用`kubectl` `scale`扩展了工作负载，使用`kubectl` `set-image`更改了镜像，或者使用`kubectl`
    `run`创建了Deployment。这种情况是会发生的；我不会评判。
- en: 'Kubernetes lets you view and export configuration with the `--output` parameter
    (`-o` for short) on any `get` request. For example, to get the latest YAML configuration
    for a Deployment use the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许你使用`--output`参数（简写为`-o`）在任意的`get`请求中查看和导出配置。例如，要获取Deployment的最新YAML配置，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ View the Deployment as YAML.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以YAML格式查看Deployment。
- en: ❷ Pipe the Deployment YAML config to a file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 Deployment YAML 配置管道传输到文件。
- en: The catch is that Kubernetes adds a lot of extra fields that you don’t really
    want in your on-disk configuration, like status messages, and so forth. There
    used to be a handy `--export` option that would strip these, but sadly it was
    deprecated. So it’s a bit of an art to figure out which lines you can delete and
    which you need to keep. But you can compare the YAML files you get this way to
    the ones in this book to see which lines are important.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是 Kubernetes 添加了许多你实际上不希望在磁盘配置中出现的额外字段，比如状态消息等等。曾经有一个方便的 `--export` 选项可以去除这些字段，但遗憾的是它已被弃用。因此，确定哪些行可以删除以及哪些需要保留需要一点技巧。但你可以将这种方式得到的
    YAML 文件与本书中的文件进行比较，以查看哪些行是重要的。
- en: If you plan to use the configuration in multiple namespaces, which is common,
    you will definitely want to delete the `metadata` `→` `namespace` field. Removing
    it will allow you to deploy the configuration in the current namespace (keeping
    it will mean any changes will update the object in whatever namespace was specified).
    The danger I see in keeping the namespace is you might accidentally have some
    configuration in your staging folder set to the production namespace. Section
    11.3 discusses some tactics on safety around rollouts to different namespaces,
    but it relies on *not* specifying the namespace in resource objects directly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划在多个命名空间中使用配置，这是常见的，你肯定希望删除 `metadata` `→` `namespace` 字段。移除它将允许你在当前命名空间中部署配置（保留它将意味着任何更改都会更新在指定命名空间中的对象）。我看到保持命名空间的风险是你可能会意外地将一些配置设置在生产命名空间中的预发布文件夹中。第
    11.3 节讨论了关于在不同命名空间中滚动部署的一些安全策略，但它依赖于*不*在资源对象中直接指定命名空间。
- en: Other fields to consider for removal for cleanliness are from the `metadata`
    section, the fields `uid`, `resourceVersion`, `generation`, `creationTimestamp`,
    and the entire `status` section. These fields won’t prevent you from reusing the
    configuration in other namespaces or clusters but don’t really have meaning outside
    their deployed context, so best to keep it out of version control to avoid confusion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持清洁，可以考虑移除的其它字段来自 `metadata` 部分，包括字段 `uid`、`resourceVersion`、`generation`、`creationTimestamp`
    以及整个 `status` 部分。这些字段不会阻止你在其他命名空间或集群中重用配置，但它们在其部署上下文之外并没有实际意义，因此最好将其排除在版本控制之外，以避免混淆。
- en: 11.2 Configuration as code the Kubernetes way
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 Kubernetes 方式的配置即代码
- en: When you have a bug in your source code, you can inspect the version history
    to see when the code was changed (such as with `git` `log` and `git` `blame`)
    and might occasionally roll back a commit to get back to the previous working
    state. When you treat your configuration as code (by committing it to your version
    control system), you can perform similar actions but with your production systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在源代码中遇到错误时，你可以检查版本历史记录以查看代码何时被更改（例如使用 `git log` 和 `git blame`），有时可能会回滚提交以回到之前的工作状态。当你将配置视为代码（通过将其提交到版本控制系统）时，你可以执行类似操作，但针对的是生产系统。
- en: If you have a code review process, you can use the same process for Kubernetes
    configuration. After all, the configuration affects the running system just as
    much as the code does. Code review on configuration repositories can help to catch
    errors before they are rolled out. For example, if you accidently delete all the
    replicas of a Deployment in a configuration change, your colleague has a chance
    to catch the mistake during the code review.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个代码审查流程，你可以用同样的流程来审查 Kubernetes 配置。毕竟，配置对运行系统的影响和代码一样大。在配置仓库上进行代码审查可以帮助在它们被部署之前捕捉到错误。例如，如果你在配置更改中意外删除了
    Deployment 的所有副本，你的同事在代码审查过程中有机会捕捉到这个错误。
- en: You’ll find this pattern used at all major internet companies. Most Google services,
    for example, are developed and deployed out of a single code repository,[²](#pgfId-1023560)
    so the service configuration sits right beside the code. The exact same code review
    practices are followed for code and service configuration, although the list of
    owners (the engineers that can approve the changes for merging) may differ.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这种模式在所有主要的互联网公司中都有应用。例如，大多数 Google 服务都是在单个代码仓库中开发和部署的，[²](#pgfId-1023560)
    因此服务配置紧挨着代码。代码和服务配置遵循完全相同的代码审查实践，尽管可以批准合并更改的所有者（工程师）名单可能不同。
- en: There’s no obligation to store the configuration in the same repository as the
    code like Google, though. This is mostly a matter of taste (and endless technical
    debate). The model I’ll present here for storing Kubernetes configuration in Git
    is just an example of what I’ve found works for me, but you should adapt it to
    your own engineering practices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有义务像谷歌一样将配置存储在与代码相同的仓库中，但这主要是一个品味（以及无休止的技术辩论）的问题。我将在这里展示的用于在Git中存储Kubernetes配置的模型只是我找到对我有效的一个例子，但你应该根据自己的工程实践进行调整。
- en: I use a single Git repository to represent all the Kubernetes objects deployed
    in a single cluster. In this repo is a folder for each Kubernetes namespace, and
    in those folders are the YAML files for the objects in the namespace (figure 11.2).
    An alternative is to use a separate branch for each namespace, which has some
    nice properties, like being able to merge changes as they go from staging to production.
    However, as there are likely some changes you *don’t* want to merge, it can get
    messy (e.g., you wouldn’t want to accidentally merge your staging-only changes
    to production).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用单个Git仓库来表示单个集群中部署的所有Kubernetes对象。在这个仓库中，每个Kubernetes命名空间都有一个文件夹，这些文件夹中包含了命名空间中对象的YAML文件（图11.2）。另一种选择是为每个命名空间使用单独的分支，这有一些很好的特性，比如能够将更改从预发布合并到生产。然而，由于可能有一些你不想合并的更改，这可能会变得混乱（例如，你不会希望不小心将仅用于预发布的更改合并到生产中）。
- en: '![11-02](../../OEBPS/Images/11-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![11-02](../../OEBPS/Images/11-02.png)'
- en: Figure 11.2 Git repository folder structure and the relationship to Kubernetes
    namespaces
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 Git仓库文件夹结构和与Kubernetes命名空间的关系
- en: 'Here’s an example directory layout:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例目录布局：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ A directory for any debug scripts you wish to store for all developers
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任何你希望存储供所有开发者使用的调试脚本目录
- en: ❷ The cluster configuration (e.g., the namespace configuration files). These
    are only used during cluster creation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 集群配置（例如，命名空间配置文件）。这些文件仅在集群创建期间使用。
- en: ❸ The environment configuration folders
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 任何你希望存储供所有开发者使用的调试脚本目录
- en: Each directory in this repository is mapped to a Kubernetes namespace. The beauty
    of such a 1:1 mapping is that it allows you to confidently execute a `kubectl`
    `apply` `-f` `.` command to roll out all changes in the directory to the active
    namespace. Cloning the environment is as simple as duplicating the entire folder
    and then deploying it to its own namespace.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该仓库中的每个目录都映射到一个Kubernetes命名空间。这种1:1映射的优点是它允许你自信地执行`kubectl apply -f .`命令，将目录中的所有更改部署到活动命名空间。克隆环境就像复制整个文件夹并将其部署到其自己的命名空间一样简单。
- en: It’s common—particularly for smaller-scale workload deployments—to share a cluster
    with multiple environment namespaces. Sharing a cluster can reduce the direct
    costs and operational overhead of managing multiple clusters, and allow workloads
    to share a common pool of compute resources. As the deployments get larger, it
    may be desirable to separate environments into their own clusters to provide an
    extra level of access control and resource isolation (figure 11.3). The good news
    is that the configuration repository doesn’t care where these namespaces are;
    it’s totally fine for them to exist in different clusters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小规模的工作负载部署，共享多个环境命名空间的集群是很常见的。共享集群可以减少管理多个集群的直接成本和运营开销，并允许工作负载共享一个共同的计算资源池。随着部署规模的扩大，可能需要将环境分离到它们自己的集群中，以提供额外的访问控制和资源隔离级别（图11.3）。好消息是配置仓库并不关心这些命名空间的位置；它们存在于不同的集群中是完全没问题的。
- en: '![11-03](../../OEBPS/Images/11-03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![11-03](../../OEBPS/Images/11-03.png)'
- en: Figure 11.3 Configuration repository with environments in multiple clusters
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 多集群环境配置的配置仓库
- en: 'Once your configuration repository is set up, the development process looks
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的配置仓库设置完成，开发过程看起来就像这样：
- en: Make changes to the configuration for the desired environment.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所需环境的配置进行更改。
- en: Commit those changes.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交这些更改。
- en: Update the live state by setting the current namespace context with `kubectl`
    and then running `kubectl` `apply` `-f` `.` on the matching directory.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置当前命名空间上下文并运行`kubectl apply -f .`在匹配的目录中来更新实时状态。
- en: With this, you’re following a configuration as code pattern, but there is more
    you can do. One danger with the setup as described so far is that you can accidently
    roll out the configuration from one folder to the wrong namespace. The next sections
    cover how to roll out safely and avoid this problem and how to level up to a full
    GitOps-style process where the `git` `push` on the configuration repository triggers
    the rollout automatically.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您正在遵循配置即代码的模式，但您还可以做更多。到目前为止的设置中存在的一个危险是您可能会意外地将配置从一个文件夹滚动到错误的命名空间。接下来的几节将介绍如何安全地滚动发布并避免这个问题，以及如何提升到完整的
    GitOps 流程，其中配置仓库的 `git` `push` 自动触发滚动发布。
- en: 11.3 Rolling out safely
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 安全地滚动发布
- en: With your configuration as a code repository set up, there is now a question
    of how best to roll out the changes in the repo. Sure, you can simply check out
    the repository and run `kubectl` `apply` `-f` `.` as we did earlier, but this
    can be dangerous. You could accidentally deploy the wrong configuration into the
    wrong namespace. Since we’re reusing object names in multiple environments, this
    could be quite bad, indeed. Also, there’s nothing to stop you from changing the
    live cluster state directly without committing the configuration change to the
    repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的配置作为代码仓库设置好后，现在有一个问题，那就是如何最好地在仓库中滚动更改。当然，您可以简单地检出仓库并运行 `kubectl` `apply`
    `-f` `.`，就像我们之前做的那样，但这可能很危险。您可能会意外地将错误的配置部署到错误的命名空间。由于我们在多个环境中重复使用对象名称，这确实可能很糟糕。此外，没有阻止您直接更改实时集群状态而不将配置更改提交到仓库。
- en: 'To tackle the wrong-namespace problem, I recommend putting some guardrails
    in place to avoid accidentally deploying the wrong configuration to the wrong
    namespace. Instead of simply running `kubectl` `apply` `-f` `.` as we did earlier,
    wrap it up in a script that performs a check to ensure you’re deploying into the
    right namespace. If we name our folders the same as the namespace, then the check
    is simple: if the current namespace is equal to the folder name, deploy; otherwise,
    don’t. The following listing provides an example script that compares the current
    directory name to the current namespace and exits with an error status if they
    don’t match.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决错误的命名空间问题，我建议设置一些防护措施以避免意外将错误的配置部署到错误的命名空间。我们之前简单地运行 `kubectl` `apply` `-f`
    `.`，现在将其包装在一个脚本中，该脚本执行检查以确保您正在部署到正确的命名空间。如果我们命名文件夹与命名空间相同，那么检查就很简单：如果当前命名空间等于文件夹名称，则部署；否则，不部署。以下列表提供了一个示例脚本，该脚本比较当前目录名称与当前命名空间，如果不匹配则退出错误状态。
- en: Listing 11.1 Chapter11/gitops/gitops_check.sh
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 第11章/gitops/gitops_check.sh
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Get the last directory component of the current path.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取当前路径的最后一个目录组件。
- en: ❷ Retrieve the current namespace.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取当前命名空间。
- en: ❸ Exit with error if this script was run from a directory that doesn’t match
    the namespace name.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果此脚本从与命名空间名称不匹配的目录中运行，则退出错误。
- en: ❹ Otherwise, exit with the success status.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，以成功状态退出。
- en: You can then use this in any other scripts, like the following rollout script.
    Instead of running `kubectl` `apply` `-f` `.` directly, you would run this script,
    which verifies the correct directory/namespace combination.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在任何其他脚本中使用这个脚本，如下面的滚动发布脚本所示。您不会直接运行 `kubectl` `apply` `-f` `.`，而是运行这个脚本，该脚本会验证正确的目录/命名空间组合。
- en: Listing 11.2 Chapter11/gitops/production/rollout.sh
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 第11章/gitops/production/rollout.sh
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Verify that the directory name matches the namespace.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 验证目录名称是否与命名空间匹配。
- en: ❷ Run kubectl apply as normal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正常运行 kubectl apply。
- en: A full GitOps folder structure, including these scripts, is provided in the
    samples in *Chapter11/gitops*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第11章/gitops* 中的示例中提供了一个完整的 GitOps 文件夹结构，包括这些脚本。
- en: This isn’t the only option, of course. Another approach would be to set the
    desired namespace in your rollout script and then deploy. Just be sure that if
    the `set` `namespace` step fails, the whole thing will bail out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是唯一的选择。另一种方法是在您的滚动发布脚本中设置所需的命名空间，然后进行部署。只是确保如果 `set` `namespace` 步骤失败，整个过程将退出。
- en: For these scripts to work, though, you’ll need to ensure that none of your configuration
    files specify a `metadata` `→` `namespace` field directly. If they have a namespace
    set, it will ignore the current context, so the script won’t prevent updates in
    that case.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些脚本可以工作，但您需要确保您的配置文件中没有直接指定 `metadata` `→` `namespace` 字段。如果它们设置了命名空间，它将忽略当前上下文，因此脚本不会阻止该情况下的更新。
- en: To really follow the GitOps methodology, you’ll want to add an additional guarantee
    that the configuration deployed at all times is what is actually in the repository.
    The best way to solve that is to remove the human from the loop completely and
    configure a deployment pipeline or a GitOps operator.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正遵循GitOps方法，你将需要添加一个额外的保证，即始终部署的配置与存储库中实际存在的配置相匹配。解决这个问题的最佳方法是完全移除人工干预，并配置一个部署管道或GitOps操作员。
- en: 11.3.1 Deployment pipelines
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 部署管道
- en: 'A deployment pipeline is simply a set of functions that run based on a code
    repository trigger—for example, “When a code is pushed to the configuration repository,
    deploy the configuration to a Kubernetes cluster” (figure 11.4). Using pipelines
    guarantees that the configuration being deployed matches what was committed. If
    the operator needs to make additional changes after the deployment (e.g., to correct
    an error), they make them in the configuration code repository like normal: push
    the change and trigger the pipeline rollout once again.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 部署管道简单来说是一组基于代码存储库触发器运行的函数——例如，“当代码被推送到配置存储库时，将配置部署到Kubernetes集群”（图11.4）。使用管道可以保证正在部署的配置与提交的内容相匹配。如果操作员在部署后需要做出额外的更改（例如，更正错误），他们将在配置代码存储库中像平常一样进行更改：推送更改并再次触发管道部署。
- en: '![11-04](../../OEBPS/Images/11-04.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![11-04](../../OEBPS/Images/11-04.png)'
- en: Figure 11.4 A continuous deployment pipeline to Kubernetes
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 Kubernetes的持续部署管道
- en: With your pipeline configured, you can push to producing by merging a code on
    your Git repo (i.e., Git-driven operations, or GitOps). The key is to not make
    any changes on the cluster directly; all changes go through the configuration
    repository and the continuous deployment pipeline.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好你的管道后，你可以通过将Git存储库中的代码合并到生产环境中来推送生产内容（即Git驱动的操作，或GitOps）。关键是不直接在集群上做出任何更改；所有更改都通过配置存储库和持续部署管道进行。
- en: 11.3.2 Continuous deployment with Cloud Build
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 使用Cloud Build进行持续部署
- en: To implement a deployment pipeline in practice, there are many products on the
    market. For Google Kubernetes Engine (GKE) users, one option is Cloud Build. You
    can set up a trigger so that when your configuration repository is pushed, it
    will run `kubectl` `apply` `-f` `.`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中实现部署管道，市场上有很多产品。对于Google Kubernetes Engine (GKE)用户来说，一个选项是Cloud Build。你可以设置一个触发器，以便当你的配置存储库被推送到时，它会运行`kubectl`
    `apply` `-f` `.`。
- en: 'To set it up, use the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置它，请按照以下步骤操作：
- en: Configure IAM permissions[³](#pgfId-1023644) for the Cloud Build service account
    to give it permission to act on your GKE cluster.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Cloud Build服务账户配置IAM权限[³](#pgfId-1023644)，以授予其在你的GKE集群上执行操作的权限。
- en: Create a new trigger (set to fire when your configuration repository is pushed).
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的触发器（设置为在配置存储库被推送到时触发）。
- en: Add a Cloud Build configuration file to your repository such as the one in the
    following listing, and reference it in the trigger.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的存储库中添加一个Cloud Build配置文件，例如以下列表中的文件，并在触发器中引用它。
- en: Listing 11.3 Chapter11/11.3.2_CloudBuild/cloudbuild-deploy.yaml
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.3 第11章/11.3.2_CloudBuild/cloudbuild-deploy.yaml
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just scratching the surface of continuous delivery. If you’re using
    Cloud Build, you can consult the excellent “GitOps-Style Continuous Delivery with
    Cloud Build” guide,[⁴](#pgfId-1023666) which goes further and sets up a complete
    end-to-end CI/CD flow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对持续交付的表面探讨。如果你使用Cloud Build，你可以参考优秀的“使用Cloud Build进行GitOps风格的持续交付”指南[⁴](#pgfId-1023666)，它进一步深入并设置了一个完整的端到端CI/CD流程。
- en: Continuous reconciliation
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 持续校准
- en: The method described here can be further improved by using a GitOps operator.
    This is a control loop that runs in the cluster and constantly reconciles what
    is running in the cluster to what is present in the configuration repository.
    The end result is similar to the previously described event-driven pipeline with
    the advantage that it can perform additional reconciliation if there is ever a
    divergence, while the pipeline approach relies on the Git push event to trigger.
    Flux ([https://fluxcd.io/](https://fluxcd.io/)) is one such GitOps operator.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的方法可以通过使用GitOps操作员进一步改进。这是一个在集群中运行的控制系统循环，它不断将集群中运行的内容与配置存储库中存在的内容进行校准。最终结果是类似于之前描述的事件驱动管道，其优点是当出现偏差时可以执行额外的校准，而管道方法依赖于Git推送事件来触发。Flux
    ([https://fluxcd.io/](https://fluxcd.io/))就是这样一种GitOps操作员。
- en: 11.4 Secrets
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 密钥
- en: 'A Git repo is a great place to store your Kubernetes configuration, but there
    is some data that probably shouldn’t be stored there: secret values like database
    passwords and API keys. If such secrets are embedded in the code itself or in
    environment variables, it means that anyone with access to your source code will
    have the secret. An improvement would be that only those who can access your production
    system would have access to this data. You can go further, of course, but in the
    context of this chapter on GitOps, I’ll focus on how to separate your secrets
    from your code and config repositories.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Git仓库是一个存储Kubernetes配置的好地方，但有一些数据可能不应该存储在那里：如数据库密码和API密钥这样的机密值。如果这些机密被嵌入到代码本身或环境变量中，这意味着任何可以访问你的源代码的人都可以获得这些机密。一个改进的方法是，只有那些可以访问你的生产系统的人才能访问这些数据。当然，你可以更进一步，但在本章关于GitOps的背景下，我将专注于如何将你的机密与代码和配置仓库分离。
- en: Kubernetes actually has an object for storing secrets, aptly named Secrets.
    These objects are a way to provide information such as credentials and keys to
    workloads in a way that separates them from the configuration of the workload
    itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes实际上有一个用于存储机密的对象，恰当地命名为Secrets。这些对象提供了一种方式，可以将诸如凭证和密钥等信息以与工作负载本身配置分离的方式提供给工作负载。
- en: 11.4.1 String-based (password) secrets
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 基于字符串（密码）的机密
- en: If you’ve been embedding secrets like passwords in plain environment variables
    in the workload configuration, now would be a good time to migrate them to Secrets.
    Let’s say we have a secret with a value of `secret_value` (in reality, this might
    be a key obtained from your cloud provider). We can encapsulate our `secret_value`
    into a Kubernetes Secret object like in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直将密码等机密像明文环境变量一样嵌入到工作负载配置中，现在就是迁移到Secrets的好时机。假设我们有一个值为`secret_value`的机密（实际上，这可能是从你的云服务提供商那里获得的一个密钥）。我们可以将我们的`secret_value`封装到一个Kubernetes
    Secret对象中，如下所示。
- en: Listing 11.4 Chapter11/11.4.1_StringSecrets/secret.yaml
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 Chapter11/11.4.1_StringSecrets/secret.yaml
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Secrets can be provided to Pods as a file mounted into the container or as an
    environment variable. You would use the file method for secret data that your
    application will access as a configuration file (e.g., a private SSL key), and
    the environment variable for items like database passwords. Since our secret in
    listing 11.4 is a simple string, we’ll use the environment variable method to
    reference it in a Deployment in the following listing (see section 11.4.3 for
    an example of a file-based secret).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 机密可以作为文件挂载到容器中或作为环境变量提供给Pods。你会使用文件方法来访问作为配置文件（例如，私有SSL密钥）的机密数据，而使用环境变量来处理数据库密码等项。由于列表11.4中的机密是一个简单的字符串，我们将使用环境变量方法在下面的列表中引用它（有关基于文件的机密示例，请参阅11.4.3节）。
- en: Listing 11.5 Chapter11/11.4.1_StringSecrets/deploy.yaml
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 Chapter11/11.4.1_StringSecrets/deploy.yaml
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ A regular plain-text environment variable
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个普通的纯文本环境变量
- en: ❷ An environment variable populated from a Secret
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从机密中填充的环境变量
- en: To verify that everything worked correctly, create the Secret and Deployment
    objects in the Chapter11/11.4.1_StringSecrets folder and run
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正确工作，请在Chapter11/11.4.1_StringSecrets文件夹中创建Secret和Deployment对象，并运行
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should see the secret in the output. Our application now has access to the
    secret via the `SECRET_KEY` environment variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在输出中看到这个机密。我们的应用程序现在可以通过`SECRET_KEY`环境变量访问这个机密。
- en: 11.4.2 Base64 encoded secrets
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 Base64编码的机密
- en: You may encounter Kubernetes documentation and other resources that demonstrate
    secrets where the value is base64 encoded (using the `data` field rather than
    `stringData`). This isn’t done for security (base64 is an encoding, not encryption)
    but rather so that you can represent data that can’t easily be defined in YAML.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到Kubernetes文档和其他资源，它们展示了机密值以base64编码的形式（使用`data`字段而不是`stringData`）。这不是为了安全起见（base64是一种编码，而不是加密），而是为了能够表示那些难以在YAML中定义的数据。
- en: I don’t routinely base64 encode secrets by default, as I find that this mostly
    serves to obfuscate the data without adding much value. However, if you have a
    string that you can’t easily represent in YAML, like if your secret is an entire
    file, then it makes sense to base64-encode the data. The following listing provides
    an equivalent base64 encoded representation of the `SECRET_KEY` secret shown in
    listing 11.4.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不会默认使用 base64 编码密钥，因为我觉得这主要只是模糊了数据，并没有增加多少价值。然而，如果你有一个难以在 YAML 中表示的字符串，比如你的密钥是一个完整的文件，那么对数据进行
    base64 编码是有意义的。以下列表提供了 11.4 列表中显示的 `SECRET_KEY` 密钥的等效 base64 编码表示。
- en: Listing 11.6 Chapter11/11.4.2_Base64Secrets/secret-base64.yaml
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 第 11 章/11.4.2_Base64Secrets/secret-base64.yaml
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To do the encoding and decoding, on any Unix-like system, you can do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行编码和解码，在任何类 Unix 系统上，你可以执行以下操作：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can include both `data` and `stringData` in the same configuration file
    if you have some values that need base64-encoding and others that don’t. You can
    also store multiple secrets in each Kubernetes Secret object (one per line). The
    following listing provides an example that defines three secrets, two using plain
    text and one using base64.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些需要 base64 编码的值和一些不需要的值，你可以在同一个配置文件中包含 `data` 和 `stringData`。你还可以在每个 Kubernetes
    Secret 对象中存储多个密钥（每行一个）。以下列表提供了一个示例，定义了三个密钥，其中两个使用纯文本，一个使用 base64。
- en: Listing 11.7 Chapter11/11.4.2_Base64Secrets/secrets-multiple.yaml
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 第 11 章/11.4.2_Base64Secrets/secrets-multiple.yaml
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you are retrieving secrets from the server via the command line, you’ll get
    the base64 encoded form and will need to decode them to view the plain-text values
    (they are provided to your application code already decoded, however).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过命令行从服务器检索密钥，你会得到 base64 编码的形式，并且需要解码它们以查看纯文本值（然而，它们已经解码并提供给应用程序代码）。
- en: I personally have one secret object for each of my namespaces, each with multiple
    secrets. However, I store them in a separate repo from the rest of my config.
    In section 11.4.4, I’ll discuss some options for how to store secrets apart from
    your main configuration repository while still using a GitOps approach.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人为每个命名空间创建一个密钥对象，每个对象包含多个密钥。然而，我将它们存储在与配置文件的其他部分分开的仓库中。在第 11.4.4 节中，我将讨论一些选项，如何在仍然使用
    GitOps 方法的同时，将密钥存储在主配置仓库之外。
- en: 11.4.3 File-based secrets
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 基于文件的密钥
- en: Sometimes you’ll be dealing with secrets that you want to access from your application
    as files rather than strings from environment variables. Kubernetes has you covered
    here as well. Creating the secret is actually the same, but I’ll provide a fresh
    example of a multiline text file since how such data is represented in YAML has
    some nuance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会处理一些密钥，你希望将它们作为文件而不是环境变量的字符串从应用程序中访问。Kubernetes 在这里也为你提供了支持。创建密钥实际上是一样的，但我将提供一个多行文本文件的全新示例，因为这种数据在
    YAML 中的表示有一些细微差别。
- en: 'Say we have a private key to store. Here’s one I generated using `openssl`
    `genrsa` `256` `-out example.key` (normally you’d use a 2048 bit key or higher,
    but for brevity, I’ll use 256):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要存储一个私钥。以下是一个使用 `openssl genrsa 256 -out example.key` 生成的示例（通常你会使用 2048
    位或更高的密钥，但为了简洁，我将使用 256 位）：
- en: Listing 11.8 Chapter11/11.4.3_FileSecrets/example.key
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8 第 11 章/11.4.3_文件密钥/example.key
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This file’s data can be represented in YAML in the following way. Note the all-important
    pipe character, which will preserve the line endings in the data value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的数据可以用以下方式在 YAML 中表示。注意至关重要的管道字符，它将保留数据值中的行结束符。
- en: Listing 11.9 Chapter11/11.4.3_FileSecrets/secret_file.yaml
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 第 11 章/11.4.3_文件密钥/secret_file.yaml
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you’re tired of wrestling with YAML syntax by now, you can base64-encode
    the file data instead by using `cat` `example.key` `|` `base64` and represent
    it like in the following listing (with the data truncated for readability). Note
    that the entire base64 string is placed on one line (no line breaks!).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在已经厌倦了与 YAML 语法搏斗，你可以通过使用 `cat example.key | base64` 对文件数据进行 base64 编码，并像以下列表（为了可读性，数据已截断）那样表示。注意，整个
    base64 字符串放在一行上（没有换行符！）。
- en: Listing 11.10 Chapter11/11.4.3_FileSecrets/secret_file_base64.yaml
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 第 11 章/11.4.3_文件密钥/secret_file_base64.yaml
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It’s a bit tedious creating these configuration files for secrets by hand.
    A more automated approach is to use `kubectl` to create the files for you. The
    following command will create the same functional output (note that the base64
    string is truncated for readability):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建这些密钥配置文件确实有点繁琐。一个更自动化的方法是使用 `kubectl` 为你创建文件。以下命令将创建相同的功能输出（注意，为了可读性，base64
    字符串已截断）：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `--dry-run=client` `-o` `yaml` part means that you won’t actually create
    the secret on the server and, instead, output it as YAML (for you to place in
    a configuration file, to be later applied to the server with `kubectl` `apply`
    `-f` `secret.yaml`). Omitting the `--dry-run`, would create the secret directly
    on the cluster (i.e., the imperative style of creating Kubernetes objects). In
    fact, every example given in this section could have been written as an imperative
    `kubectl` command, but there are durable benefits to a declarative, configuration-driven
    approach to operating your cluster, including those covered earlier in this chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dry-run=client` `-o` `yaml`部分的意思是实际上你不会在服务器上创建机密，而是将其作为YAML输出（供你放入配置文件中，稍后用`kubectl
    apply -f secret.yaml`应用到服务器上）。省略`--dry-run`将直接在集群上创建机密（即创建Kubernetes对象的命令式风格）。实际上，本节中给出的每个示例都可以写成命令式的`kubectl`命令，但声明式、配置驱动的集群操作方法具有持久的好处，包括本章前面提到的那些。'
- en: 'Once created, you can mount all the files in the Secret as a folder in your
    container. The following listing mounts our `secret-files` Secret to the location
    `/etc/config`. Each of the data keys is mounted as its own file. In our case,
    there was only one: `example.key.`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，你就可以将Secret中的所有文件挂载为容器中的一个文件夹。以下列表将我们的`secret-files` Secret挂载到位置`/etc/config`。每个数据键都挂载为其自己的文件。在我们的例子中，只有一个：`example.key`。
- en: Listing 11.11 Chapter11/11.4.3_FileSecrets/deploy.yaml
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 第11章/11.4.3_文件机密/deploy.yaml
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The path the file secrets will be mounted at.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 文件secrets将被挂载的路径。
- en: ❷ Reference to the Secrets object
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对Secret对象的引用
- en: 'To verify that everything worked correctly, create the Secret and Deployment
    objects and use `exec` to list the directory. You should see our file `example.key`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正确工作，创建Secret和Deployment对象，并使用`exec`列出目录。你应该看到我们的文件`example.key`：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To view the file itself, replace the `ls` command with `cat` `/etc/config/example.key`.
    Now you can point your code to this file, just like any other file on the system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件本身，将`ls`命令替换为`cat /etc/config/example.key`。现在你可以将代码指向这个文件，就像指向系统上的任何其他文件一样。
- en: 11.4.4 Secrets and GitOps
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 Secrets和GitOps
- en: Using Secrets is only one part of the equation. Now, you’ll need to figure out
    how to store them. If you place them in the same configuration repository, you
    may as well have just used plain environment variables and skipped the step in
    the previous section. There’s no silver bullet to this problem, but here are a
    few ideas, presented in increasing order of complexity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Secrets只是方程的一部分。现在，你需要弄清楚如何存储它们。如果你将它们放在同一个配置仓库中，那么你实际上可以直接使用普通的环境变量，并跳过上一节中的步骤。这个问题没有银弹，但这里有一些想法，按复杂度递增的顺序列出。
- en: Separate repository
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 独立仓库
- en: A simple option is to have a separate configuration repository for your secrets
    with fewer users granted access than your regular repos. You still have all the
    benefits of configuration as code (e.g., code reviews, rollback, and so forth)
    but can limit the audience. If you operate a repository with granular access control,
    you could place the secrets in an access-controlled folder of that repo.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的选择是为你的机密信息创建一个独立的配置仓库，其用户权限少于常规仓库。你仍然可以享受配置代码的所有好处（例如，代码审查、回滚等），但可以限制受众。如果你操作一个具有细粒度访问控制的仓库，你可以在该仓库的一个受控文件夹中放置机密信息。
- en: One logical place for this repository to be located would be together with your
    production resources at your cloud provider, with the same access control as your
    production environment. Since anyone with access to your production environment
    has the secrets anyway, this model doesn’t provide any additional access if someone
    compromises the account.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仓库的一个合理位置是与你的云提供商的生产资源一起，具有与生产环境相同的安全控制。由于任何有权访问你的生产环境的人实际上已经有了这些机密，因此这种模型不会为账户被破坏的人提供任何额外的访问权限。
- en: Sealed Secrets
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 密封机密
- en: 'The Sealed Secrets[⁵](#pgfId-1023888) project has an interesting approach:
    you encrypt your secrets before storing in Git (so nobody can read them), and
    they’re decoded by a controller in the cluster using a private key. While you
    still end up with the same problem of where to store that private key, it means
    that the encrypted secrets can be included in the main configuration repository
    with all the benefits that this entails, like rollback.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secrets[⁵](#pgfId-1023888) 项目采用了一种有趣的方法：你在将秘密存储到 Git 之前对其进行加密（这样就没有人能读取它们），然后由集群中的控制器使用私钥进行解密。虽然你最终还是面临着存储私钥的问题，但这意味着加密的秘密可以包含在主配置仓库中，从而获得所有相关的优势，例如回滚。
- en: Secrets service
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密服务
- en: Another option is to run a separate service that can inject secrets into your
    cluster. Vault by HashiCorp[⁶](#pgfId-1023898) is a popular implementation of
    this concept and is available as open source if you wish to run it yourself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是运行一个独立的服务，该服务可以将秘密注入到你的集群中。HashiCorp 的 Vault[⁶](#pgfId-1023898) 是这个概念的流行实现，如果你希望自行运行，它也是开源的。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Use namespaces to separate different environments, like production and staging,
    and different applications.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间来区分不同的环境，如生产环境和预发布环境，以及不同的应用程序。
- en: Treating configuration as code allows you to easily duplicate and maintain multiple
    environments.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置视为代码允许你轻松地复制和维护多个环境。
- en: Follow the configuration as code methodology by storing Kubernetes configuration
    in version control as you would code (including conducting code reviews if you
    do them).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 Kubernetes 配置存储在版本控制中，就像存储代码一样（包括进行代码审查，如果你这样做的话），遵循配置即代码的方法论。
- en: Instead of making changes directly to the live cluster, make the changes to
    configuration first, commit to version control, then apply them.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要直接对实时集群进行更改，而是首先更改配置，提交到版本控制，然后应用这些更改。
- en: A deployment pipeline can be used to automatically roll out changes when they
    are committed and pushed to the configuration repository.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用部署管道在将更改提交并推送到配置仓库时自动部署这些更改。
- en: A GitOps operator like Flux can be used to provide continuous reconciliation
    of the configuration repository.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用像 Flux 这样的 GitOps 操作员来提供配置仓库的持续协调。
- en: Utilize Kubernetes Secrets to store sensitive information such as database keys
    in separate Kubernetes objects. Store that configuration in a way that limits
    access.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes Secrets 存储敏感信息，如数据库密钥，在单独的 Kubernetes 对象中。以限制访问的方式存储该配置。
- en: '* * *'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) [https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx)'
- en: ^(2.) [https://research.google/pubs/pub45424/](https://research.google/pubs/pub45424/)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://research.google/pubs/pub45424/](https://research.google/pubs/pub45424/)'
- en: ^(3.) [https://cloud.google.com/build/docs/securing-builds/configure-access-for-cloud-build-service-account](https://cloud.google.com/build/docs/securing-builds/configure-access-for-cloud-build-service-account)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cloud.google.com/build/docs/securing-builds/configure-access-for-cloud-build-service-account](https://cloud.google.com/build/docs/securing-builds/configure-access-for-cloud-build-service-account)'
- en: ^(4.) [https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build](https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build](https://cloud.google.com/kubernetes-engine/docs/tutorials/gitops-cloud-build)'
- en: ^(5.) [https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)'
- en: ^(6.) [https://www.vaultproject.io/](https://www.vaultproject.io/)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.vaultproject.io/](https://www.vaultproject.io/)'
