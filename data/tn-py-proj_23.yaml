- en: '22 Tic-Tac-Toe redux: An interactive version with type hints'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22 井字棋重制：带有类型提示的交互式版本
- en: '| In this last exercise, we’re going to revisit the Tic-Tac-Toe game from the
    previous chapter. That version played one turn of the game by accepting an initial
    `--board` and then modifying it if there were also valid options for `--player`
    and `--cell`. It printed the one board and the winner, if any. We’re going to
    extend those ideas into a version that will always start from an empty board and
    will play as many turns as needed to complete a game, ending with a winner or
    a draw. | ![](../Images/22-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 在这个最后一个练习中，我们将回顾上一章的井字棋游戏。那个版本通过接受一个初始 `--board` 并在 `--player` 和 `--cell`
    存在有效选项时修改它来玩一局游戏。它打印了一个板和获胜者（如果有的话）。我们将扩展这些想法到一个版本，它将始终从一个空板开始，并玩尽可能多的回合来完成游戏，以获胜或平局结束。
    | ![](../Images/22-unnumb-1.png)  |'
- en: This program will be different from all the other programs in this book because
    it will accept no command-line arguments. The game will always start with a blank
    “board” and with the X player going first. It will use the `input()` function
    to interactively ask each player, X and then O, for a move. Any invalid move,
    such as choosing an occupied or non-existing cell, will be rejected. At the end
    of each turn, the game will decide to stop if it determines there is a win or
    a draw.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将与其他本书中的所有程序不同，因为它不接受任何命令行参数。游戏将始终从一个空白的“板”开始，并以 X 玩家为先手。它将使用 `input()`
    函数交互式地询问每个玩家（X 和 O），请求移动。任何无效的移动，如选择已占用的或不存在单元格，都将被拒绝。在每个回合结束时，游戏将决定停止，如果它确定有胜利或平局。
- en: In this chapter you will
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将
- en: Use and break out of an infinite loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并跳出无限循环
- en: Add type hints to your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的代码添加类型提示
- en: Explore tuples, named tuples, and typed dictionaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索元组、命名元组和类型化字典
- en: Use `mypy` to analyze code for errors, especially misuse of types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mypy` 分析代码中的错误，特别是类型误用
- en: 22.1 Writing itictactoe.py
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.1 编写 itictactoe.py
- en: This is the one program where I won’t provide an integration test. The program
    doesn’t take any arguments, and I can’t easily write tests that will interact
    dynamically with the program. This also makes it difficult to show a string diagram,
    because the output of the program will be different depending on the moves you
    make. Still, figure 22.1 is an approximation of how you could think of the program
    starting with no inputs and then looping until some outcome is determined, or
    the player quits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我不会提供集成测试的一个程序。程序不接收任何参数，我无法轻松编写与程序动态交互的测试。这也使得展示字符串图变得困难，因为程序输出的结果将取决于你的操作。尽管如此，图22.1是你可以如何思考程序从没有输入开始，然后循环直到确定某个结果或玩家退出的大致情况。
- en: '![](../Images/22-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/22-1.png)'
- en: Figure 22.1 This version of Tic-Tac-Toe accepts no arguments and will play in
    an infinite loop until some conclusion like a win, draw, or forfeit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图22.1 这个版本的井字棋不接受任何参数，将在无限循环中玩，直到得出结论，如胜利、平局或弃权。
- en: 'I encourage you to start off by running the solution1.py program to play a
    few rounds of the game. The first thing you may notice is that the program clears
    the screen of any text and shows you an empty board, along with a prompt for the
    X player’s move. I’ll type `1` and press Enter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你首先运行 solution1.py 程序，玩几轮游戏。你可能会注意到的第一件事是程序清除了屏幕上的所有文本，并显示了一个空板，以及 X 玩家的移动提示。我会输入
    `1` 并按 Enter：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you will see that cell `1` is now occupied by X, and the player has switched
    to O:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会看到单元格 `1` 现在已被 X 占用，玩家已切换到 O：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If I choose `1` again, I am told that cell is already taken:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我再次选择 `1`，我会被告知该单元格已被占用：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the player is still O because the previous move was invalid. The
    same happens if I put in some value that cannot be converted to an integer:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，玩家仍然是 O，因为之前的操作无效。如果输入的值无法转换为整数，也会发生相同的情况：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or if I enter an integer that is out of range:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果输入的整数超出了范围：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should be able to reuse many of the ideas from chapter 21’s version of the
    game to validate the user input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够重用第21章版本游戏中的一些想法来验证用户输入。
- en: 'If I play the game to a conclusion where one player gets three in a row, it
    prints the winning board and proclaims the victor:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我把游戏玩到一方连赢三行，它会打印获胜的板并宣布胜利者：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 22.1.1 Tuple talk
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.1 元组讨论
- en: 'In this version, we’ll write an interactive game that always starts with an
    empty grid and plays as many rounds as necessary to reach a conclusion with a
    win or a draw. The idea of “state” in the last game was limited to the board--which
    players were in which cells. This version requires us to track quite a few more
    variables in our game state:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们将编写一个交互式游戏，它总是从一个空白的网格开始，并玩尽可能多的回合，以达到一个有赢或平局的结论。上一轮游戏中“状态”的概念仅限于棋盘——哪些玩家在哪些单元格。这个版本要求我们在游戏状态中跟踪更多变量：
- en: The cells of the board, like `..XO..X.O`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋盘的单元格，例如`..XO..X.O`
- en: The current player, either `X` or `O`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前玩家，即`X`或`O`
- en: Any error, such as the player entering a cell that is occupied or that does
    not exist or a value that cannot be converted to a number
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何错误，例如玩家输入一个已被占用或不存在或无法转换为数字的单元格
- en: Whether the user wishes to quit the game early
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否希望提前退出游戏
- en: Whether the game is a draw, which happens when all the cells of the grid are
    occupied but there is no winner
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不论游戏是否平局，这种情况发生在网格的所有单元格都被占用，但没有赢家
- en: The winner, if any, so we know when the game is over
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，赢家，这样我们知道游戏何时结束
- en: You don’t need to write your program exactly the way I wrote mine, but you still
    may find yourself needing to keep track of many items. A `dict` is a natural data
    structure for that, but I’d like to introduce a new data structure called a “named
    tuple,” as it plays nicely with Python’s type hints, which will figure prominently
    in my solution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要按照我写的方式编写你的程序，但你仍然可能发现自己需要跟踪许多项目。`dict`是一个自然的数据结构，但我想要介绍一个新的数据结构，称为“命名元组”，因为它与Python的类型提示配合得很好，这将在我的解决方案中占重要地位。
- en: We’ve encountered tuples throughout the exercises. They’ve been returned by
    something like `match.groups()` when a regular expression contains capturing parentheses,
    like in chapters 14 and 17; when using `zip` to combine two lists, like in chapter
    19; or when using `enumerate()` to get a list of index values and elements from
    a `list`. A `tuple` is an immutable `list`, and we’ll explore how that immutability
    can prevent us from introducing subtle bugs into our programs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习中我们已经遇到了元组。它们在正则表达式中包含捕获括号时被返回，例如在第14章和第17章；当使用`zip`组合两个列表时，例如在第19章；或者当使用`enumerate()`从`list`中获取索引值和元素时。`tuple`是一个不可变的`list`，我们将探讨这种不可变性如何防止我们在程序中引入微妙的错误。
- en: 'You create a `tuple` whenever you put commas between values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你在值之间放置逗号时创建`tuple`：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s most common to put parentheses around them to make it more explicit:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在它们周围加上括号以使其更明确：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could assign this to a variable called `state`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其分配给一个名为`state`的变量：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We index into a `tuple` using `list` index values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`list`索引值来索引`tuple`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unlike with a `list`, we cannot change any of the values inside the `tuple`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与`list`不同，我们无法更改`tuple`内的任何值：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s going to be inconvenient remembering that the first position is the `cell`
    and the second position is the `player`, and it will get much worse when we add
    all the other fields. We could switch to using a `dict` so that we can use strings
    to access the values of `state`, but dictionaries are mutable, and it’s also easy
    to misspell a key name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第一个位置是`cell`，第二个位置是`player`会有些不方便，当我们添加所有其他字段时，情况会变得更糟。我们可以切换到使用`dict`，这样我们就可以使用字符串来访问`state`的值，但字典是可变的，而且很容易拼写键名错误。
- en: 22.1.2 Named tuples
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.2 命名元组
- en: 'It would be nice to combine the safety of an immutable `tuple` with named fields,
    which is exactly what we get with the `namedtuple()` function. First, you must
    import it from the `collections` module:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将不可变的`tuple`与命名字段结合起来会很方便，这正是`namedtuple()`函数所提供的。首先，你必须从`collections`模块导入它：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `namedtuple()` function allows us to describe a new `class` for values.
    Let’s say we want to create a class that describes the idea of `State`. A class
    is a group of variables, data, and functions that together can be used to represent
    some idea. The Python language itself, for example, has the `str` class, which
    represents the idea of a sequence of characters that can be contained in a variable
    that has some `len` (length), and which can be converted to uppercase with `str.upper()`,
    can be iterated with a `for` loop, and so forth. All these ideas are grouped into
    the `str` class, and we’ve used `help(str)` to read the documentation for that
    class inside the REPL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple()`函数允许我们描述一个用于值的新的`class`。假设我们想要创建一个描述`State`概念的`class`。一个`class`是一组变量、数据和函数的组合，可以一起用来表示某个概念。例如，Python语言本身就有`str`类，它表示可以包含在具有某些`len`（长度）的变量中的字符序列的概念，并且可以使用`str.upper()`将其转换为大写，可以使用`for`循环迭代，等等。所有这些概念都被组合到`str`类中，我们使用`help(str)`在REPL中读取该类的文档。'
- en: 'The class name is the first argument we pass to `namedtuple()`, and the second
    argument is a `list` of the field names in the class. It’s common practice to
    capitalize class names:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类名是我们传递给`namedtuple()`的第一个参数，第二个参数是类中字段名称的`list`。将类名首字母大写是一种常见的做法：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve just created a new `type` called `State`!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个名为`State`的新`type`！
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Just as there is a function called `list()` to create a `list` type, we can
    now use the `State()` function to create a named tuple of the type `State` that
    has two named fields, `cell` and `player`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有一个名为`list()`的函数来创建`list`类型一样，我们现在可以使用`State()`函数来创建一个具有两个命名字段`cell`和`player`的`State`类型的命名元组：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can still access the fields with index values, like any `list` or `tuple`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用索引值来访问字段，就像任何`list`或`tuple`一样：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But we can also use their names, which is much nicer. Notice that there are
    no parentheses at the end, as we are accessing a field, not calling a method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用它们的名称，这要优雅得多。注意，末尾没有括号，因为我们是在访问一个字段，而不是调用一个方法：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because `state` is a `tuple`, we cannot mutate the value once it has been created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`state`是一个元组，所以我们一旦创建了它的值，就不能再修改它：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is actually *good* in many instances. It’s often quite dangerous to change
    your data values once your program has started. You should use tuples or named
    tuples whenever you want a list- or dictionary-like structure that cannot be accidentally
    modified.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在许多情况下是**好的**。一旦程序开始运行，更改数据值通常是非常危险的。当你想要一个不能意外修改的列表或字典样式的结构时，你应该使用元组或命名元组。
- en: There is a problem, however, in that there’s nothing to prevent us from instantiating
    a `state` with the fields out of order *and of the wrong types* --`cell` should
    be an `int`, and `player` should be a `str`!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个问题，那就是没有任何东西可以阻止我们用一个**乱序**且**类型错误**的`state`字段实例化——`cell`应该是`int`类型，而`player`应该是`str`类型！
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In order to avoid that, you can use the field names, so that their order no
    longer matters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，你可以使用字段名称，这样它们的顺序就不再重要了：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now you have a data structure that looks like a `dict` but has the immutability
    of a `tuple`!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个看起来像`dict`但具有`tuple`不可变性的数据结构！
- en: 22.1.3 Adding type hints
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.3 添加类型提示
- en: 'We still have a big problem in that there’s nothing preventing us from assigning
    a `str` to the `cell`, which ought to be an `int`, and vice versa for `int` and
    `player`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们仍然有一个大问题，那就是没有任何东西可以阻止我们将一个`str`赋值给`cell`，而`cell`应该是一个`int`，反之亦然，对于`int`和`player`：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Starting in Python 3.6, the `typing` module allows you to add *type hints* to
    describe the data types for variables. You should read PEP 484 (www.python.org/dev/peps/pep-0484/)
    for more information, but the basic idea is that we can use this module to describe
    the appropriate types for variables and type signatures for functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.6开始，`typing`模块允许你添加**类型提示**来描述变量的数据类型。你应该阅读PEP 484（www.python.org/dev/peps/pep-0484/）以获取更多信息，但基本思想是我们可以使用这个模块来描述变量的适当类型和函数的类型签名。
- en: 'I’m going to improve our `State` class by using the `NamedTuple` class from
    the `typing` module as the base class. First we need to import from the `typing`
    module the classes we’ll need, such as `NamedTuple`, `List`, and `Optional`, the
    last of which describes a type that could be `None` or some other class like a
    `str`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算通过使用`typing`模块中的`NamedTuple`类作为基类来改进我们的`State`类。首先，我们需要从`typing`模块中导入我们将需要的类，例如`NamedTuple`、`List`和`Optional`，其中`Optional`描述了一种可以是`None`或像`str`这样的其他类的类型：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can specify a `State` class with named fields, types, and even default
    values to represent the initial state of the game where the board is empty (all
    dots) and player X goes first. Note that I decided to store the `board` as a `list`
    of characters rather than a `str`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指定一个具有命名字段、类型甚至默认值的 `State` 类来表示游戏的初始状态，其中棋盘为空（所有点）且玩家 X 先走。注意，我决定将 `board`
    存储为一个字符 `list` 而不是字符串：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use the `State()` function to create a new value that’s set to the initial
    state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `State()` 函数来创建一个设置为初始状态的新的值：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can override any default value by providing the field name and a value.
    For instance, we could start the game off with player `O` by specifying `player=''O''`.
    Any field we don’t specify will use the default:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供字段名和值来覆盖任何默认值。例如，我们可以通过指定 `player='O'` 来以玩家 `O` 开始游戏。任何我们没有指定的字段将使用默认值：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get an exception if we misspell a field name, like `playre` instead of `player`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拼写字段名错误，比如将 `playre` 而不是 `player`，我们会得到一个异常：
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 22.1.4 Type verification with Mypy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.4 使用 Mypy 进行类型验证
- en: 'As nice as all the above is, *Python will not generate a runtime error if we
    assign an incorrect type*. For instance, I can assign `quit` a `str` value of
    `''True''` instead of the `bool` value `True`, and nothing at all happens:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述内容都很不错，但 *Python 不会在赋值错误时生成运行时错误*。例如，我可以将 `quit` 赋值为字符串 `'True'` 而不是布尔值
    `True`，而什么都不会发生：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The benefit of type hints comes from using a program like Mypy to check our
    code. Let’s place all this code into a small program called typehints.py in the
    repo:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的好处来自于使用像 Mypy 这样的程序来检查我们的代码。让我们将所有这些代码放入一个名为 typehints.py 的小程序中，存放在仓库里：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① quit is defined as a bool, which means it should only allow values of True
    and False.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ① `quit` 被定义为布尔类型，这意味着它只能允许 True 和 False 的值。
- en: ② We are assigning the str value 'True' instead of the bool value True, which
    might be an easy mistake to make, especially in a very large program. We’d like
    to know this type of error will be caught!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们正在将字符串值 'True' 而不是布尔值 True 赋值给，这可能会是一个容易犯的错误，尤其是在一个非常大的程序中。我们希望知道这种错误会被捕获！
- en: 'The program will execute *with no errors*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将 *无错误地执行*：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But the Mypy program will report the error of our ways:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Mypy 程序会报告我们的错误：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If I correct the program like so,
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我像这样纠正程序，
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Again, quit is a bool value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ① 再次，`quit` 是一个布尔值。
- en: ② We have to assign an actual bool value in order to pass muster with Mypy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们必须分配一个实际的布尔值才能通过 Mypy 的检查。
- en: 'now Mypy will be satisfied:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Mypy 会满意：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 22.1.5 Updating immutable structures
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.5 更新不可变结构
- en: 'If one of the advantages of using `NamedTuples` is their *immutability*, how
    will we keep track of changes to our program? Consider our initial state of an
    empty grid with the player X going first:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `NamedTuples` 的一个优点是它们的不可变性，我们将如何跟踪程序中的更改？考虑我们的初始状态是一个空网格，玩家 X 先走：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Imagine X takes cell 1, so we need to change `board` to `X........` and the
    `player` to `O`. We can’t directly modify `state`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 X 取了第 1 个格子，因此我们需要将 `board` 改为 `X........`，并将 `player` 改为 `O`。我们不能直接修改 `state`：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We could use the `State()` function to create a new value to overwrite the existing
    `state`. That is, since we can’t change anything *inside* the `state` variable,
    we could instead point `state` to an entirely new value. We did this in the second
    solution in chapter 8, where we needed to change a `str` value, because they are
    also immutable in Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `State()` 函数来创建一个新的值来覆盖现有的 `state`。也就是说，由于我们无法更改 `state` 变量内部的任何内容，我们可以改为将
    `state` 指向一个全新的值。我们在第 8 章的第二种解决方案中就是这样做的，因为我们需要更改一个 `str` 值，因为它们在 Python 中也是不可变的。
- en: 'To do this, we can copy all the current values that haven’t changed and combine
    them with the changed values:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以复制所有未更改的当前值，并将它们与更改的值结合起来：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `namedtuple._replace()` method, however, provides a much simpler way to
    do this. Only the values we provide are changed, and the result is a new `State`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`namedtuple._replace()` 方法提供了一个更简单的方式来做到这一点。只有我们提供的值会被改变，结果是一个新的 `State`：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We overwrite our `state` variable with the return from `state._replace()`,
    just as we have repeatedly overwritten string variables with new values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `state._replace()` 的返回值覆盖 `state` 变量，就像我们反复用新值覆盖字符串变量一样：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is much more convenient than having to list all the fields--we only need
    to specify the fields that have changed. We are also prevented from accidentally
    modifying any of the other fields, and we are likewise prevented from forgetting
    or misspelling any fields or setting them to the wrong types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这比列出所有字段要方便得多——我们只需要指定已更改的字段。我们还防止意外修改其他任何字段，同样也防止忘记或拼写字段错误，或者将它们设置为错误的类型。
- en: 22.1.6 Adding type hints to function definitions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.6 在函数定义中添加类型提示
- en: Now let’s look at how we can add type hints to our function definitions. For
    an example, we can modify our `format_board()` function to indicate that it takes
    a parameter called `board`, which is a list of string values, by adding `board:`
    `List[str]`. Additionally, the function returns a `str` value, so we can add `->`
    `str` after the colon on the `def` to indicate this, as in figure 22.2.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以在函数定义中添加类型提示。例如，我们可以修改我们的 `format_board()` 函数，通过添加 `board:` `List[str]`
    来指示它接受一个名为 `board` 的参数，该参数是一个字符串值的列表。此外，该函数返回一个 `str` 值，因此我们可以在 `def` 后的冒号后添加
    `->` `str` 来表示这一点，如图 22.2 所示。
- en: '![](../Images/22-2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/22-2.png)'
- en: Figure 22.2 Adding type hints to describe the type of the parameter and the
    return value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.2 添加类型提示来描述参数和返回值的类型
- en: The annotation for `main()` indicates that the `None` value is returned, as
    shown in figure 22.3.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 的注解表明返回 `None` 值，如图 22.3 所示。'
- en: '![](../Images/22-3.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/22-3.png)'
- en: Figure 22.3 The `main()` function accepts no parameters and returns `None`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.3 `main()` 函数不接受任何参数并返回 `None`。
- en: What’s really terrific is that we can define a function that takes a value of
    the type `State`, and Mypy will check that this kind of value is actually being
    passed (see figure 22.4).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人兴奋的是，我们可以定义一个接受 `State` 类型值的函数，Mypy 将检查是否实际传递了这种类型的值（见图 22.4）。
- en: '![](../Images/22-4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/22-4.png)'
- en: Figure 22.4 We can use custom types in type hints. This function takes and returns
    a value of the type `State`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22.4 我们可以在类型提示中使用自定义类型。此函数接受并返回 `State` 类型的值。
- en: Try playing my version of the game and then writing your own that behaves similarly.
    Then take a look at how I wrote an interactive solution that incorporates these
    ideas of data immutability and type safety.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩我的游戏版本，然后编写一个行为类似的自己的游戏。然后看看我是如何编写一个结合了数据不可变性和类型安全性的交互式解决方案的。
- en: 22.2 Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.2 解决方案
- en: This is the last program! I hope that writing the simpler version in the previous
    chapter gave you ideas for making this work. Did the type hints and unit tests
    also help?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最后一个程序！我希望在前一章中编写的简单版本能给你一些想法，让你能够使这个程序工作。类型提示和单元测试也帮到了你吗？
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Import the classes we’ll need from the typing module.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 `typing` 模块导入我们需要的类。
- en: ② Declare a class that is based on the NamedTuple class. Define field names,
    types, and defaults for the values this class can hold.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ② 声明一个基于 `NamedTuple` 类的类。定义该类可以持有的字段名称、类型和默认值。
- en: ③ Instantiate the initial state as an empty grid and the first player as X.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将初始状态实例化为一个空网格，并将第一个玩家标记为 X。
- en: ④ Start an infinite loop. When we have a reason to stop, we can break out of
    the loop.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 开始一个无限循环。当我们有理由停止时，我们可以退出循环。
- en: ⑤ Print a special sequence that most terminals will interpret as a command to
    clear the screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印一个特殊序列，大多数终端都会将其解释为清除屏幕的命令。
- en: ⑥ Print the current state of the board.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 打印当前棋盘的状态。
- en: ⑦ Print any errors, such as the user not choosing a valid cell.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 打印任何错误，例如用户没有选择有效的单元格。
- en: ⑧ If there is a winner, proclaim the victor and break out of the loop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果有胜者，宣布胜利者并退出循环。
- en: ⑨ Get the next move from the player. The get_move() function accepts a State
    type and returns one too. We overwrite the existing state variable each time through
    the loop.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 从玩家那里获取下一步行动。`get_move()` 函数接受一个 `State` 类型并返回一个。我们每次通过循环都会覆盖现有的状态变量。
- en: ⑩ If the user has decided to withdraw from the game prematurely, insult them,
    and break from the loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果用户决定提前退出游戏，侮辱他们并退出循环。
- en: ⑪ If the game has reached a stalemate where all cells are occupied but there
    is no winner, declare a draw and break from the loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 如果游戏达到了僵局，所有单元格都被占用但没有胜者，宣布平局并退出循环。
- en: ⑫ Define a get_move() function that takes and returns a State type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 定义一个 `get_move()` 函数，它接受并返回一个 `State` 类型。
- en: ⑬ Copy the player from the state, since we’ll refer to it several times in the
    function body.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 从状态中复制玩家，因为我们将在函数体中多次引用它。
- en: ⑭ Use the input() function to ask the player for their next move. Tell them
    how to quit the game early so they don’t have to use Ctrl-C to interrupt the program.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 使用 input() 函数询问玩家他们的下一步移动。告诉他们如何提前退出游戏，这样他们就不必使用 Ctrl-C 来中断程序。
- en: ⑮ First check if the user wants to quit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 首先检查用户是否想要退出。
- en: ⑯ If so, replace the quit value of the state with True and return with the new
    state. Note that no other values in the state are modified.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 如果是，将状态中的退出值替换为 True 并返回新状态。注意状态中的其他值没有修改。
- en: ⑰ Check if the user entered a value that can be converted to a digit using str.isdigit()
    and if the integer version of the value is in the valid range.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 检查用户输入的值是否可以使用 str.isdigit() 转换为数字，以及该值的整数版本是否在有效范围内。
- en: ⑱ If not, return an updated state that has an error. Note that the current state
    and player remain unchanged so that the same player has a retry with the same
    board until they provide valid input.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 如果不是，则返回一个带有错误的更新后的状态。注意当前状态和玩家保持不变，以便相同的玩家可以在相同的棋盘上重试，直到他们提供有效的输入。
- en: ⑲ After we have verified that cell is a valid integer value, convert it to an
    integer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 在我们验证单元格是一个有效的整数值之后，将其转换为整数。
- en: ⑳ See if the board is open at the indicated cell.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ⑳ 检查指示的单元格是否开放。
- en: ㉑ If not, return an updated state with an error. Again, nothing else about the
    state is changed, so we retry the round with the same player and state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ㉑ 如果不是，则返回一个带有错误的更新后的状态。同样，状态的其他部分没有改变，所以我们使用相同的玩家和状态重试这一轮。
- en: ㉒ Copy the current board because we need to modify it and state.board is immutable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ㉒ 复制当前棋盘，因为我们需要修改它，而 state.board 是不可变的。
- en: ㉓ Use the cell value to update the board with the current player.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ㉓ 使用单元格值来更新棋盘，以当前玩家为准。
- en: ㉔ Return a new state value with the new board value, the current player switched
    to the other player, and if there is a winner or a draw.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ㉔ 返回一个新状态值，包含新的棋盘值，当前玩家切换到另一玩家，以及是否有胜者或平局。
- en: ㉕ The only change from the previous version of this function is the addition
    of type hints. The function accepts a list of string values (the current board)
    and returns a formatted grid of the board state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ㉕ 与此函数的先前版本相比，唯一的更改是添加了类型提示。该函数接受一个字符串值列表（当前棋盘），并返回一个格式化的棋盘状态网格。
- en: ㉖ This is also the same function as before, but with type hints. The function
    accepts the board as a list of strings and returns an optional string value, which
    means it could also return None.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ㉖ 这与之前的功能相同，但增加了类型提示。该函数接受一个字符串列表作为棋盘，并返回一个可选的字符串值，这意味着它也可以返回 None。
- en: 22.2.1 A version using TypedDict
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2.1 使用 TypedDict 的版本
- en: 'New to Python 3.8 is the `TypedDict` class, which looks very similar to a `NamedTuple`.
    Let’s look at how using this as the base class changes parts of our program. One
    crucial difference is that you cannot (yet) set default values for the fields:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8 的新特性是 `TypedDict` 类，它看起来与 `NamedTuple` 非常相似。让我们看看使用这个作为基类如何改变我们的程序的一部分。一个关键的区别是，你（目前）不能为字段设置默认值：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Import TypedDict instead of NamedTuple.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 TypedDict 而不是 NamedTuple。
- en: ② Base State on a TypedDict.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在 TypedDict 上建立基础状态。
- en: 'We have to set our initial values when we instantiate a new `state`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个新的 `state` 时，我们必须设置我们的初始值：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Syntactically, I prefer using `state.board` with the named tuple rather than
    the dictionary access of `state[''board'']`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法上，我更喜欢使用 `state.board` 而不是 `state['board']` 的字典访问：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Beyond the convenience of accessing the fields, I prefer the read-only nature
    of the `NamedTuple` to the mutable `TypedDict`. Note how in the `get_move()` function,
    we can change the `state`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问字段带来的便利之外，我更喜欢 `NamedTuple` 的只读特性，而不是可变的 `TypedDict`。注意在 `get_move()` 函数中，我们可以改变
    `state`：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Here we are directly modifying the TypedDict, whereas the NamedTuple version
    used state._replace() to return an entirely new state value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这里我们直接修改了 TypedDict，而 NamedTuple 版本使用 state._replace() 来返回一个全新的状态值。
- en: ② Another place where the state is directly modifiable. You may prefer this
    approach.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ② 另一个可以直接修改状态的地方。你可能更喜欢这种方法。
- en: In my opinion, a `NamedTuple` has nicer syntax, default values, and immutability
    over the `TypedDict` version, so I prefer it. Regardless of which you choose,
    the greater lesson I hope to impart is that we should try to be explicit about
    the “state” of the program and when and how it changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`NamedTuple` 拥有更简洁的语法、默认值和不可变性，优于 `TypedDict` 版本，所以我更喜欢它。无论你选择哪个，我希望传达的更重要的教训是，我们应该尽量明确程序的“状态”以及何时以及如何改变它。
- en: 22.2.2 Thinking about state
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2.2 思考状态
- en: '| The idea of program state is that a program can remember changes to variables
    over time. In the previous chapter, our program accepted a given `--board` and
    possible values for `--cell` and `--player` that might alter the board. Then the
    game printed a representation of the board. In this chapter’s interactive version,
    the board always begins as an empty grid and changes with each turn, which we
    modeled as an infinite loop. | ![](../Images/22-unnumb-2.png)  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 程序状态的概念是程序可以记住变量随时间的变化。在前一章中，我们的程序接受一个给定的 `--board` 和 `--cell` 以及 `--player`
    的可能值，这些值可能会改变棋盘。然后游戏打印出棋盘的表示。在本章的交互式版本中，棋盘始终是一个空网格，并且随着每一回合的变化而变化，我们将它建模为一个无限循环。|
    ![图片](../Images/22-unnumb-2.png) |'
- en: It is common in programs like this to see programmers use *global variables*
    that are declared at the top of the program outside of any function definitions
    so that they are *globally* visible throughout the program. While common, it’s
    not considered a best practice, and I would discourage you from ever using globals
    unless you can see no other way. I would suggest, instead, that you stick to using
    small functions that accept all the values required and return a single type of
    value. I would also suggest you use data structures like typed, named tuples to
    represent program state, and that you guard the changes to state very carefully.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这类程序中，程序员通常会在程序顶部声明全局变量，这些变量在函数定义之外，以便在整个程序中全局可见。虽然很常见，但这并不是最佳实践，我建议你除非没有其他选择，否则永远不要使用全局变量。相反，我建议你坚持使用接受所有所需值并返回单一类型值的函数。我还建议你使用像类型化、命名元组这样的数据结构来表示程序状态，并且要非常小心地保护状态的变化。
- en: 22.3 Going further
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.3 进一步探索
- en: Incorporate spicier insults. Maybe bring in the Shakespearean generator?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入更辛辣的侮辱性言语。也许可以引入莎士比亚风格的生成器？
- en: Write a version that allows the user to start a new game without quitting and
    restarting the program.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个版本，允许用户在不退出和重新启动程序的情况下开始新游戏。
- en: Write other games like Hangman.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写其他游戏，如猜谜游戏。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Type hints allow you to annotate variables as well as function parameters and
    return values with the types of the values.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示允许你注释变量以及函数参数和返回值，并指定它们的类型。
- en: Python itself will ignore type hints at runtime, but Mypy can use type hints
    to find errors in your code before you ever run it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 本身会在运行时忽略类型提示，但 Mypy 可以在运行代码之前使用类型提示来查找错误。
- en: A `NamedTuple` behaves a bit like a dictionary and a bit like an object but
    retains the immutability of tuples.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedTuple` 的行为有点像字典和对象，但保留了元组的不可变性。'
- en: Both `NamedTuple` and `TypedDict` allow you to create a novel type with defined
    fields and types that you can use as type hints to your own functions.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamedTuple` 和 `TypedDict` 都允许你创建一个具有定义字段和类型的全新类型，你可以将其用作自己函数的类型提示。'
- en: Our program used a `NamedTuple` to create a complex data structure to represent
    the state of our program. The state included many variables, such as the current
    board, the current player, any errors, the winner, and so on, each of which was
    described using type hints.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们程序使用 `NamedTuple` 创建了一个复杂的数据结构来表示程序的状态。状态包括许多变量，例如当前棋盘、当前玩家、任何错误、获胜者等，每个变量都使用类型提示进行了描述。
- en: While it is difficult to write integration tests for an interactive program,
    we can still break a program into small functions (such as `format_board()` or
    `get_winner()`) for which we write and run unit tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然为交互式程序编写集成测试很困难，但我们仍然可以将程序分解成小的函数（例如 `format_board()` 或 `get_winner()`），为这些函数编写和运行单元测试。
