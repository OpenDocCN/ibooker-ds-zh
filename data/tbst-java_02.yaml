- en: 1 Revealing an app’s obscurities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 揭示应用程序的隐蔽之处
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The definition of a code investigation technique
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码调查技术的定义
- en: What code investigation techniques we use to understand Java apps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用哪些代码调查技术来理解Java应用程序
- en: A software developer has various responsibilities—most of which depend on how
    they understand the code they are working with. Software developers spend much
    of their time analyzing code to figure out how to correct issues, implement new
    capabilities, and even learn new technologies. And time is precious, so developers
    need efficient investigation techniques to be productive. Learning how to be efficient
    in understanding your code is the main topic of this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者有多种责任——其中大部分取决于他们如何理解他们正在工作的代码。软件开发者花费大量时间分析代码，以弄清楚如何纠正问题、实现新功能，甚至学习新技术。时间是宝贵的，因此开发者需要高效的调查技术以提高生产力。学习如何高效地理解你的代码是本书的主要内容。
- en: NOTE Software developers generally spend more time understanding how the software
    works than writing code to implement new features or correct errors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：软件开发者通常花更多的时间理解软件的工作方式，而不是编写代码来实现新功能或纠正错误。
- en: '![](../../OEBPS/Images/icon_girl.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl.png)'
- en: 'Often, software developers use the word *debugging* for any investigation techniques;
    however, this is only one of the various tools available for examining logic implemented
    as code. While debugging should mean “finding issues and solving them,” developers
    use it to name different purposes for analyzing how code works:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件开发者使用“调试”一词来指代任何调查技术；然而，这只是用于检查作为代码实现的逻辑的多种工具之一。虽然调试应该意味着“发现问题并解决它们”，但开发者使用它来命名分析代码工作方式的不同目的：
- en: Learning a new framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一个新的框架
- en: Finding the root cause of a problem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到问题的根本原因
- en: Understanding existing logic to extend it with new capabilities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解现有逻辑以扩展其新功能
- en: 1.1 How to more easily understand your app
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 如何更容易地理解你的应用程序
- en: First, it is important to understand what investigating code is and how developers
    do it. In this next section, we look at several commonly encountered scenarios
    in which you can apply the techniques you’ll learn in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，了解代码调查是什么以及开发者如何进行代码调查非常重要。在接下来的这一节中，我们将探讨一些常见的场景，在这些场景中你可以应用本书中将要学习的技术。
- en: 'I define *investigating code* as being the process of analyzing a software
    capability’s specific behavior. You might wonder, “Why such a generic definition?
    What is the investigation’s purpose?” Early in the history of software development,
    looking through code had one precise purpose: finding and correcting software
    errors (i.e., *bugs*). This is why many developers still use the term *debugging*
    for these techniques. Look at the way the word *debug* is formed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我将“调查代码”定义为分析软件能力特定行为的过程。你可能想知道，“为什么有这样的通用定义？调查的目的是什么？”在软件开发历史的早期，查看代码有一个明确的目的：找到和纠正软件错误（即“错误”）。这就是为什么许多开发者仍然使用“调试”这个术语。看看“调试”这个词是如何构成的：
- en: '**de-bug** = take out bugs, eliminate errors'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**de-bug** = 消除错误，消除错误'
- en: In many cases today, we still debug apps to find and correct errors. But unlike
    the early days of software development, apps today are more complex. In many cases,
    developers find themselves investigating how a particular software capability
    works, simply to learn a specific technology or library. Debugging is no longer
    only about finding a particular issue; it is also about correctly understanding
    its behavior (figure 1.1; see also [http://mng.bz/M012](http://mng.bz/M012)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们仍然调试应用程序以查找和纠正错误。但与软件开发早期相比，现在的应用程序更加复杂。在许多情况下，开发者发现自己正在调查特定软件能力的工作方式，仅仅是为了学习特定的技术或库。调试不再仅仅是找到特定问题；它还关于正确理解其行为（图1.1；参见[http://mng.bz/M012](http://mng.bz/M012)）。
- en: '![](../../OEBPS/Images/CH01_F01_Spilca3.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F01_Spilca3.png)'
- en: Figure 1.1 Code investigation is not only about finding problems in software.
    Today, apps are complex. We often use investigation techniques to understand an
    app’s behavior or simply to learn new technologies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 代码调查不仅关于在软件中找到问题。如今，应用程序复杂。我们经常使用调查技术来理解应用程序的行为，或者简单地学习新技术。
- en: Why do we analyze code in apps?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要分析应用程序中的代码？
- en: To find a particular issue
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到特定问题
- en: To understand how a particular software capability works so we can enhance it
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解特定软件能力的工作方式，以便我们可以增强它
- en: To learn a specific technology or library
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习特定的技术或库
- en: Many developers also investigate code for fun, because exploring how code works
    is fun. It can sometimes become frustrating as well, but nothing compares to the
    feeling of finding the root cause of an issue or finally understanding how things
    work (figure 1.2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者也因为乐趣而调查代码，因为探索代码的工作原理很有趣。有时它也可能变得令人沮丧，但没有什么能比找到问题的根本原因或最终理解事物是如何工作的感觉更好（图1.2）。
- en: '![](../../OEBPS/Images/CH01_F02_Spilca3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F02_Spilca3.png)'
- en: Figure 1.2 Investigating code doesn’t require much physical effort, but debugging
    sometimes makes you feel like Lara Croft or Indiana Jones. Many developers enjoy
    the unique sensation of solving the puzzle of a software issue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 调查代码不需要太多的体力劳动，但调试有时会让你感觉像劳拉·克劳馥或印第安纳·琼斯。许多开发者享受解决软件问题谜团的独特感觉。
- en: There are various investigation techniques we can apply to investigate how software
    behaves. As we’ll discuss later in the chapter, developers (especially beginners)
    often wrongly consider debugging equivalent to using a debugger tool. The debugger
    is a software program you can use to read and more easily understand the source
    code of an application, usually by pausing the execution on specific instructions
    and running the code step by step. It is a common way to investigate software
    behavior (and usually the first one a developer learns). But it is not the only
    technique you can use, and it doesn’t help you in every scenario. We’ll discuss
    both standard and more advanced ways of using a debugger in chapters 2 and 3\.
    Figure 1.3 presents the various investigation techniques you’ll learn throughout
    this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用各种调查技术来研究软件的行为。正如我们将在本章后面讨论的，开发者（尤其是初学者）常常错误地认为调试等同于使用调试器工具。调试器是一个你可以用来读取并更轻松地理解应用程序源代码的软件程序，通常是通过在特定指令上暂停执行并逐步运行代码来实现的。这是研究软件行为的一种常见方式（通常是开发者首先学习的方式）。但并非只有这一种技术，而且它并不适用于所有场景。我们将在第2章和第3章中讨论使用调试器的标准和更高级的方法。图1.3展示了你将在本书中学到的各种调查技术。
- en: '![](../../OEBPS/Images/CH01_F03_Spilca3.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F03_Spilca3.png)'
- en: Figure 1.3 Code investigation techniques. Depending on the case, a developer
    can choose from one or more of these techniques to understand how a certain capability
    works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 代码调查技术。根据具体情况，开发者可以选择使用这些技术中的一种或多种来理解某个功能是如何工作的。
- en: When a developer solves a bug, they spend most of their time on understanding
    a particular feature. The changes they end up making sometimes reduce the problem
    to a single line of code—a missing condition, a missing instruction, or a misused
    operator. It’s not writing the code but rather understanding how the app works
    that occupies most of a developer's time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者解决一个错误时，他们大部分时间都在理解一个特定的功能。他们最终做出的更改有时会将问题简化到一行代码——一个缺失的条件、一个缺失的指令或一个误用的运算符。不是编写代码，而是理解应用程序的工作原理占据了开发者的大部分时间。
- en: In some cases, simply reading the code is enough to understand it, but reading
    code is not like reading a book. When we read code, we don’t read nice short paragraphs
    written in a logical order from top to bottom. Instead, we step from one method
    to another, from one file to another; we sometimes feel like we advance in a vast
    labyrinth and get lost. (On this subject, I recommend the excellent book *The
    Programmer’s Brain* by Felienne Hermans [Manning, 2021]).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，仅仅阅读代码就足以理解它，但阅读代码并不像阅读一本书。当我们阅读代码时，我们不会从上到下按逻辑顺序阅读漂亮的短段落。相反，我们从一种方法跳到另一种方法，从一个文件跳到另一个文件；有时我们感觉自己像是在一个庞大的迷宫中前进并迷失方向。（关于这个话题，我推荐Felienne
    Hermans写的优秀书籍《程序员的大脑》[Manning, 2021]）。
- en: 'In many cases, the source code is written in a way that doesn’t make it easy
    to read. Yes, I know what you are thinking: it should be. And I agree with you.
    Today, we learn many patterns and principles for code design and how to avoid
    code smells, but let’s be honest: developers still don’t use these principles
    properly in too many cases. Moreover, legacy apps usually don’t follow these principles,
    simply because the principles didn’t exist many years ago when those capabilities
    were written. But you still need to be able to investigate such code.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，源代码的编写方式并不易于阅读。是的，我知道你在想什么：它应该是这样的。我也同意你的看法。今天，我们学习了许多代码设计模式和原则以及如何避免代码异味，但让我们说实话：在太多情况下，开发者并没有正确地使用这些原则。此外，遗留应用程序通常不遵循这些原则，仅仅是因为这些原则在那些功能编写时很多年前并不存在。但你还必须能够调查这样的代码。
- en: Look at listing 1.1\. Suppose you find this piece of code while trying to identify
    the root cause of a problem in an app you’re working on. This code definitely
    needs refactoring. But before you can refactor it, you need to understand what
    it is doing. I know some developers out there can read through this code and immediately
    understand what it does, but I’m not one of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表1.1。假设你在尝试确定你正在工作的应用中问题根本原因时找到了这段代码。这段代码肯定需要重构。但在你重构它之前，你需要了解它在做什么。我知道有些开发者可以阅读这段代码并立即理解它在做什么，但我不属于他们。
- en: To easily understand the logic in listing 1.1, I use a *debugger*—a tool that
    allows me to pause the execution on specific lines and manually run each instruction
    while observing how the data changes—to go through each line to observe how it
    works with the given input (as we’ll discuss in chapter 2). With a bit of experience
    and some tricks (that we’ll discuss in chapters 2 and 3), you will find, by parsing
    this code a few times, that it calculates the maximum between the given inputs.
    This code is part of the project da-ch1-ex1 provided with the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地理解列表1.1中的逻辑，我使用了一个*调试器*——一个允许我在特定行上暂停执行并手动运行每个指令，同时观察数据如何变化，以便逐行检查它如何与给定的输入一起工作（如我们将在第2章中讨论）。凭借一些经验和一些技巧（我们将在第2章和第3章中讨论），你会发现通过解析这段代码几次，它计算了给定输入之间的最大值。这段代码是本书提供的da-ch1-ex1项目的一部分。
- en: Listing 1.1 Hard-to-read logic that requires use of a debugger
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 需要使用调试器的难以阅读的逻辑
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some scenarios don’t allow you to navigate through the code, or they make navigating
    it more challenging. Today, most apps rely on dependencies such as libraries or
    frameworks. In most cases, even when you have access to the source code (when
    you use an open source dependency), it’s still difficult to follow the source
    code that defines a framework’s logic. Sometimes, you don’t even know where to
    start. In such cases, you must use different techniques to understand the app.
    For example, you could use a profiler tool (as you’ll learn in chapters 6 through
    9) to identify what code executes before deciding where to start the investigation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有些场景不允许你导航代码，或者使导航更加困难。今天，大多数应用依赖于库或框架等依赖项。在大多数情况下，即使你有访问源代码的权限（当你使用开源依赖项时），仍然很难跟踪定义框架逻辑的源代码。有时，你可能甚至不知道从哪里开始。在这种情况下，你必须使用不同的技术来理解应用。例如，你可以使用分析器工具（如你将在第6章到第9章中学习的）来识别在决定开始调查之前执行的代码。
- en: Other scenarios will not give you the chance to have a running app. In some
    cases, you’ll have to investigate a problem that made the app crash. If the application
    that encountered problems and stopped is a production service, you need to make
    it available again quickly. So, you need to collect details and use them to identify
    the problem and improve the app to avoid the same problem in the future. This
    investigation, which relies on collected data after the app crashes, is called
    a *postmortem investigation*. For such cases, you can use logs, heap dumps, or
    thread dumps—troubleshooting instruments that we’ll discuss in chapters 10 and
    11.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其他场景不会给你运行应用的机会。在某些情况下，你可能需要调查导致应用崩溃的问题。如果遇到问题的应用是一个生产服务，你需要快速使其可用。因此，你需要收集详细信息并使用它们来识别问题，并改进应用以避免未来出现相同的问题。这种依赖于应用崩溃后收集的数据的调查称为*事后调查*。对于此类案例，你可以使用日志、堆转储或线程转储——我们在第10章和第11章中将讨论的故障排除工具。
- en: 1.2 Typical scenarios for using investigation techniques
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 使用调查技术的典型场景
- en: 'Let’s discuss some common scenarios for using code investigation approaches.
    We must look at some typical cases from real-world apps and analyze them to emphasize
    the importance of this book’s subject matter:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些使用代码调查方法的常见场景。我们必须从现实世界的应用中分析一些典型案例，以强调本书主题的重要性：
- en: To understand why a particular piece of code or software capability provides
    a different result than expected
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么特定的代码或软件功能提供的不同结果与预期不符
- en: To learn how the technologies the app uses as dependencies work
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何应用所使用的依赖技术工作
- en: To identify causes for performance issues such as app slowness
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别导致应用缓慢等性能问题的原因
- en: To find out root causes for cases in which an app suddenly stops
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出应用突然停止的案例的根本原因
- en: For each presented case, you’ll find one or more techniques helpful in investigating
    the app’s logic. Later, we’ll dive into these techniques and demonstrate, with
    examples, how to use them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个展示的案例，你都会发现一或多个有助于调查应用逻辑的技术。稍后，我们将深入探讨这些技术，并通过示例演示如何使用它们。
- en: 1.2.1 Demystifying the unexpected output
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 揭秘意外输出
- en: The most frequent scenario in which you’ll need to analyze code is when some
    logic ends up with a different output than expected. This might sound simple,
    but it isn’t necessarily easy to solve.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要分析代码的最常见场景是某些逻辑最终产生了与预期不同的输出。这听起来可能很简单，但解决起来并不一定容易。
- en: First, let’s define *output*. This term might have many definitions for an app.
    Output could be some text in the app’s console, or it could be some records changed
    in a database. We can consider output an HTTP request the app sends to a different
    system or some data sent in the HTTP response to a client’s request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义*输出*。对于应用来说，这个术语可能有多种定义。输出可能是应用控制台中的某些文本，也可能是数据库中更改的某些记录。我们可以将输出视为应用发送到不同系统的HTTP请求或客户端请求的HTTP响应中发送的数据。
- en: definition Any result of executing a piece of logic that might result in data
    change, the exchange of information, or action against a different component or
    system is an *output*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：执行可能引起数据变化、信息交换或对不同组件或系统采取行动的逻辑的任何结果，都是一种*输出*。
- en: How do we investigate a case in which a specific part of the app doesn’t have
    the expected execution result? We do so by choosing the proper technique based
    on the expected output. Let’s look at some examples.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何调查一个特定部分的应用没有达到预期执行结果的情况？我们通过根据预期输出选择适当的技术来实现。让我们看看一些例子。
- en: 'Scenario 1: The simple case'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 场景1：简单情况
- en: Suppose an app should insert some records into a database. Yet, the app adds
    only part of the records. That is, you expected to find more data in the database
    than the app actually produces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个应用应该将一些记录插入到数据库中。然而，应用只添加了部分记录。也就是说，你期望在数据库中找到比应用实际产生的更多数据。
- en: The simplest way to analyze this is to use a debugger tool to follow the code
    execution and understand how it works (figure 1.4). You’ll learn about the main
    features of a debugger in chapters 2 and 3\. The debugger adds a breakpoint to
    pause the app execution at a specific line of code of your choosing, and then
    it allows you to continue the execution manually. You run code instructions one
    by one so you can see how the values of the variables change and evaluate expressions
    on the fly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分析的最简单方法就是使用调试工具来跟踪代码执行并理解其工作原理（图1.4）。你将在第2章和第3章中学习调试器的主要功能。调试器会在你选择的特定代码行处添加断点，暂停应用执行，然后允许你手动继续执行。你可以逐条运行代码指令，以便查看变量值的变化并即时评估表达式。
- en: '![](../../OEBPS/Images/CH01_F04_Spilca3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH01_F04_Spilca3.png)'
- en: Figure 1.4 Using a debugger, you can pause the execution before a particular
    instruction and then observe how the app’s logic changes the data by manually
    running the instructions step by step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 使用调试器，你可以在特定指令之前暂停执行，然后通过手动逐条运行指令来观察应用逻辑如何通过改变数据。
- en: This scenario is the simplest, and by learning how to use all the relevant debugger
    features properly, you can find solutions to such issues in no time. Unfortunately,
    other cases are more complex, and a debugger tool isn’t always enough to solve
    the puzzle and find the cause of the problem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景是最简单的，通过正确学习使用所有相关的调试器功能，你可以迅速找到此类问题的解决方案。不幸的是，其他情况更为复杂，调试工具并不总是足以解决谜题并找到问题的原因。
- en: TIP In many cases, one investigative technique isn’t enough to understand the
    app’s behavior. You’ll need to combine various approaches to more quickly understand
    more complex behavior
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在许多情况下，一种调查技术不足以理解应用的行为。你需要结合各种方法来更快地理解更复杂的行为。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_guy.png)'
- en: 'Scenario 2: The where-should-I-start-debugging case?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 场景2：我应该从哪里开始调试的情况？
- en: Sometimes you won’t be able to use a debugger simply because you don’t know
    what to debug. Suppose your app is a complex service with many lines of code.
    You investigate an issue in which the app doesn’t store the expected records in
    a database. It’s definitely a problem of output, but out of the thousands of lines
    of code defining your app, you don’t know what part implements the capability
    you need to fix.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能无法使用调试器，仅仅是因为你不知道要调试什么。假设你的应用程序是一个包含许多代码行的复杂服务。你调查了一个问题，其中应用程序没有在数据库中存储预期的记录。这肯定是一个输出问题，但出于定义你的应用程序的数千行代码之外，你不知道哪个部分实现了你需要修复的功能。
- en: 'I remember a colleague who was investigating such a problem. Stressed from
    not being able to find where to start, he exclaimed: “I wish debuggers had a way
    for you to add a breakpoint on all the lines of an app so you could see what it
    actually uses.”'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得有一个同事正在调查这样一个问题。由于找不到入手的地方而感到压力，他大声说道：“我希望调试器有一个方法，可以让你在应用程序的所有行上添加断点，这样你就可以看到它实际使用了什么。”
- en: My colleague’s statement was funny, but having such a feature in a debugger
    wouldn’t be a solution. We have other ways to approach this problem. You would
    most likely narrow the possibilities of lines where you could add a breakpoint
    by using a profiler.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我同事的说法很有趣，但在调试器中拥有这样的功能并不是解决方案。我们还有其他方法来解决这个问题。你很可能会通过使用性能分析器来缩小可以添加断点的代码行的可能性。
- en: A *profiler* is a tool you can use to identify what code executes while the
    app is running (figure 1.5). This is an excellent option for our scenario because
    it would give you an idea of where to start the investigation with a debugger.
    We’ll discuss using a profiler in chapters 6 through 9, where you’ll learn that
    you have more options than simply observing the code in execution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能分析器*是一个你可以用来识别应用程序运行时执行了哪些代码的工具（图1.5）。这对于我们的场景是一个很好的选择，因为它会给你一个关于如何使用调试器开始调查的想法。我们将在第6章到第9章中讨论使用性能分析器，你将了解到你拥有的选项不仅仅只是观察执行中的代码。'
- en: '![](../../OEBPS/Images/CH01_F05_Spilca3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH01_F05_Spilca3.png)'
- en: Figure 1.5 Identifying code in execution with a profiler. If you don’t know
    where to start debugging, the profiler can help you to identify the code that
    is running and give you an idea of where you can use the debugger.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 使用性能分析器识别执行中的代码。如果你不知道从哪里开始调试，性能分析器可以帮助你识别正在运行的代码，并给你一个关于你可以使用调试器的想法。
- en: 'Scenario 3: A multithreaded app'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 场景3：多线程应用程序
- en: Situations become even more complicated when dealing with logic implemented
    through multiple threads, or a *multithreaded architecture*. In many such cases,
    using a debugger is not an option because multithreaded architectures tend to
    be sensitive to interference.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理通过多个线程实现的逻辑或*多线程架构*时，情况变得更加复杂。在许多这类情况下，使用调试器并不是一个选择，因为多线程架构往往对干扰很敏感。
- en: In other words, the way the app behaves is different when you use the debugger.
    Developers call this characteristic a *Heisenberg execution* or *Heisenbug* (figure
    1.6). The name comes from the twentieth-century physicist Werner Heisenberg, who
    formulated the uncertainty principle, which states that once you interfere with
    a particle, it behaves differently, so you cannot accurately predict both its
    velocity and position simultaneously ([https://plato.stanford.edu/entries/qt-uncertainty/](https://plato.stanford.edu/entries/qt-uncertainty/)).
    A multithreaded architecture might change the way it behaves if you interfere
    with it, just like if you interfere with a quantum mechanics particle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当使用调试器时，应用程序的行为方式会有所不同。开发者将这种特性称为*海森堡执行*或*海森堡虫*（图1.6）。这个名字来源于20世纪的物理学家维尔纳·海森堡，他提出了不确定性原理，该原理指出，一旦你干扰了一个粒子，它的行为就会改变，因此你不能同时准确地预测它的速度和位置（[https://plato.stanford.edu/entries/qt-uncertainty/](https://plato.stanford.edu/entries/qt-uncertainty/)）。如果你干扰了多线程架构，它可能会改变其行为方式，就像你干扰量子力学粒子一样。
- en: '![](../../OEBPS/Images/CH01_F06_Spilca3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH01_F06_Spilca3.png)'
- en: Figure 1.6 A Heisenberg execution. In a multithreaded app, when a debugger interferes
    with the app’s execution, it might change how the app behaves. This change doesn’t
    allow you to correctly investigate the initial app behavior that you wanted to
    research.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 海森堡执行。在多线程应用程序中，当调试器干扰应用程序的执行时，它可能会改变应用程序的行为。这种变化不允许你正确调查你想要研究的初始应用程序行为。
- en: For multithreaded functionality, we have a large variety of cases. That’s what
    makes such scenarios, in my opinion, the most difficult to test. Sometimes a profiler
    is a good option, but even the profiler might interfere with the app’s execution,
    so that may not work either. Another alternative is to use logging (which we discuss
    in chapter 5) in the app. For certain issues, you can find a way to reduce the
    number of threads to one so that you can use a debugger for the investigation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多线程功能，我们有大量的案例。这就是为什么我认为这些场景是最难测试的。有时分析器是一个好选择，但即使是分析器也可能干扰应用程序的执行，所以这也不一定有效。另一个选择是在应用程序中使用日志（我们将在第5章中讨论）。对于某些问题，你可以找到一种方法将线程数减少到一个，这样你就可以使用调试器进行调查。
- en: 'Scenario 4: Sending the wrong calls to a given service'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 场景4：向特定服务发送错误的调用
- en: You may need to investigate a scenario in which the app doesn’t correctly interact
    with another system component or an external system. Suppose your app sends HTTP
    requests to another app. You get notified by the maintainers of the second app
    that the HTTP requests don’t have the right format (maybe a header is missing
    or the request body contains wrong data). Figure 1.7 visually presents this case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要调查一个应用程序没有正确与其他系统组件或外部系统交互的场景。假设你的应用程序向另一个应用程序发送HTTP请求。你被第二个应用程序的维护者通知，HTTP请求没有正确的格式（可能缺少一个标题或请求体包含错误的数据）。图1.7直观地展示了这个案例。
- en: '![](../../OEBPS/Images/CH01_F07_Spilca3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F07_Spilca3.png)'
- en: Figure 1.7 A wrong output can be your app sending erroneous requests to another
    system component. You may be asked to investigate such a behavior and find its
    root cause.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 错误的输出可能是你的应用程序向另一个系统组件发送错误请求。你可能会被要求调查这种行为并找到其根本原因。
- en: This is a *wrong output* scenario. How could you approach it? First, you need
    to identify what part of the code sends the requests. If you already know, you
    can use a debugger to investigate how the app creates the request and identify
    what is going wrong. If you need to find what part of the app sends a request,
    you may need to use a profiler, as you’ll learn in chapters 6 through 9\. You
    can use a profiler to determine what code acts at a given time in the execution
    process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*错误输出*场景。你该如何处理它？首先，你需要确定代码的哪个部分发送请求。如果你已经知道，你可以使用调试器来调查应用程序是如何创建请求的，并确定出了什么问题。如果你需要找到应用程序的哪个部分发送请求，你可能需要使用分析器，正如你将在第6章到第9章中学到的。你可以使用分析器来确定在执行过程中的某个时刻正在执行什么代码。
- en: 'Here’s a trick I always use when I have to deal with a complex case like this
    one, in which, for some reason, I can’t straightforwardly identify where the app
    sends the request to/from: I replace the other app (the one my app wrongly sends
    requests to) with a stub. A *stub* is a fake application that I can control to
    help me identify the issue. For example, to determine what part of the code sends
    the requests, I can make my stub block the request so my app indefinitely waits
    for a response. Then, I simply use a profiler to determine what code is being
    stuck by the stub. Figure 1.8 shows the usage of a stub. Compare this figure to
    figure 1.7 to understand how the stub replaced the real app.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我经常使用的小技巧，当我必须处理像这样一个复杂的案例时，由于某种原因，我无法直接识别应用程序发送请求的地址：我将其他应用程序（我的应用程序错误地发送请求的应用程序）替换为一个存根。一个*存根*是一个我可以控制以帮助我识别问题的假应用程序。例如，为了确定代码的哪个部分发送请求，我可以让我的存根阻止请求，这样我的应用程序就会无限期地等待响应。然后，我简单地使用一个分析器来确定被存根阻止的代码。图1.8展示了存根的使用。将此图与图1.7进行比较，以了解存根是如何替换真实应用程序的。
- en: '![](../../OEBPS/Images/CH01_F08_Spilca3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F08_Spilca3.png)'
- en: Figure 1.8 You can replace the system component your app calls with a stub.
    You control the stub to quickly determine where your app sends the request from.
    You can also use the stub to test your solution after you correct the issue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 你可以用存根替换你的应用程序调用的系统组件。你控制存根以快速确定你的应用程序从哪里发送请求。你还可以在修复问题后使用存根来测试你的解决方案。
- en: 1.2.2 Learning certain technologies
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 学习某些技术
- en: Another use of investigative techniques for analyzing code is learning how certain
    technologies work. Some developers joke that 6 hours of debugging can save 5 minutes
    of reading the documentation. While it’s true that reading documentation is also
    essential when learning something new, some technologies are too complex to learn
    just from reading books or the specifications. I always advise my students to
    dive deeper into a specific framework or library to understand it properly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 调查技术分析代码的另一种用途是了解某些技术是如何工作的。一些开发者开玩笑说，6小时的调试可以节省5分钟阅读文档的时间。虽然阅读文档在学习新事物时也是必不可少的，但有些技术仅通过阅读书籍或规范是难以学会的。我总是建议我的学生深入一个特定的框架或库，以正确理解它。
- en: TIP For any technology (framework or library) you learn, spend some time reviewing
    the code you write. Always try to go deeper and debug the framework’s code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 对于你学习的任何技术（框架或库），花些时间回顾你写的代码。总是尝试更深入，调试框架的代码。
- en: '![](../../OEBPS/Images/icon_guy.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_guy.png)'
- en: I’ll start with my favorite, Spring Security. At first glance, Spring Security
    may seem trivial. It’s just implementing authentication and authorization, isn’t
    it? In fact, it is—until you discover the variety of ways to configure these two
    capabilities into your app. You mix them wrong, and you may get in trouble. When
    things don’t work, you have to deal with what isn’t working, and the best choice
    to deal with what isn’t working is by investigating Spring Security’s code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从我最喜欢的Spring Security开始。乍一看，Spring Security可能看起来微不足道。它只是实现认证和授权，对吧？事实上，它确实是——直到你发现将这两种能力配置到应用程序中的各种方法。如果你配置错误，你可能会遇到麻烦。当事情不工作时，你必须处理那些不工作的事情，而处理这些不工作的事情的最佳选择就是调查Spring
    Security的代码。
- en: More than anything else, debugging helped me to understand Spring Security.
    To help others, I put my experience and knowledge into a book, *Spring Security
    in Action* (Manning, 2020). In it, I provide more than 70 projects for you to
    not only re-create and run, but also for you to debug. I invite you to debug all
    examples provided with books you read to learn various technologies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 莫过于调试帮助我理解Spring Security。为了帮助他人，我将我的经验和知识融入了一本书中，*《Spring Security in Action》*（Manning，2020）。在这本书中，我提供了70多个项目供你使用，不仅是为了重新创建和运行，也是为了调试。我邀请你调试你阅读的书籍中提供的所有示例，以学习各种技术。
- en: The second example of a technology I learned mostly through debugging is Hibernate.
    Hibernate is a high-level framework used for implementing an app’s capability
    to work with a SQL database. Hibernate is one of the best-known and most-used
    frameworks in the Java world, so it’s a must-learn for any Java developer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过调试学到的第二种技术是Hibernate。Hibernate是一个用于实现应用程序与SQL数据库交互能力的高级框架。Hibernate是Java世界中知名度最高、使用最广泛的框架之一，因此对于任何Java开发者来说，学习它都是必须的。
- en: Learning Hibernate’s basics is easy, and you can do this by simply reading books.
    But in the real world, using Hibernate (the how and the where) includes so much
    more than the basics. And for me, without digging deep into Hibernate’s code,
    I definitely wouldn’t have learned as much about this framework as I know today.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Hibernate的基础知识很容易，你可以通过简单地阅读书籍来完成。但在现实世界中，使用Hibernate（包括如何使用和在哪里使用）远不止基础知识那么简单。对我来说，如果不深入研究Hibernate的代码，我肯定不会像现在这样对这一框架了解得这么多。
- en: 'My advice for you is simple: for any technology (framework or library) you
    learn, spend some time reviewing the code you write. Always try to go deeper and
    debug the framework’s code. This will make you a better developer.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你的建议很简单：对于你学习的任何技术（框架或库），花些时间回顾你写的代码。总是尝试更深入，调试框架的代码。这将使你成为一个更好的开发者。
- en: 1.2.3 Clarifying slowness
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 澄清缓慢的原因
- en: Performance issues occur now and then in apps, and, like any other problem,
    you need to investigate them before you know how to solve them. Learning the proper
    use of different debugging techniques to identify the causes of performance issues
    is vital.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中偶尔会出现性能问题，就像任何其他问题一样，在你知道如何解决它们之前，你需要先调查它们。学习正确使用不同的调试技术来识别性能问题的原因至关重要。
- en: In my experience, the most frequent performance issues that occur in apps are
    related to how quickly an app responds. However, even if most developers consider
    slowness and performance equal, that’s not the case. Slowness problems (situations
    in which an app responds slowly to a given trigger) are just one kind of performance
    issue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，在应用程序中最常见的性能问题与应用程序响应速度有关。然而，尽管大多数开发者认为缓慢和性能是等同的，但这并不正确。缓慢问题（应用程序对给定触发器响应缓慢的情况）只是性能问题的一种。
- en: For example, I once had to debug a mobile app that was consuming the device’s
    battery too quickly. I had an Android app using a library that connected to an
    external device via Bluetooth. For some reason, the library was creating lots
    of threads without closing them. These threads, which remain open and run without
    purpose, are called *zombie threads* and typically cause performance and memory
    issues. They are also usually challenging to investigate.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我曾经不得不调试一个消耗设备电池过快的移动应用程序。我有一个使用连接到外部设备的蓝牙库的Android应用程序。由于某种原因，该库在未关闭的情况下创建了大量的线程。这些保持打开状态且无目的运行的线程被称为*僵尸线程*，通常会导致性能和内存问题。它们通常也很难调查。
- en: However, this type of issue in which the battery is being consumed too fast
    is also an app performance issue. An app using too much network bandwidth while
    transferring data over the network is another good example of a performance issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种电池消耗过快的类型的问题也是应用程序性能问题。在网络上传输数据时使用过多网络带宽的应用程序是另一个性能问题的良好例子。
- en: Let’s stick to slowness problems, which are the most often encountered. Many
    developers fear slowness problems. Usually, that’s not because those problems
    are difficult to identify, but because they can be challenging to solve. Finding
    the cause of a performance problem is usually an easy job with a profiler, as
    you’ll learn in chapters 6 through 9\. In addition to identifying which code executes,
    as discussed in section 1.2.1, a profiler also displays the time the app spends
    on each instruction (figure 1.9).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于缓慢问题，这是最常遇到的。许多开发者害怕缓慢问题。通常，这并不是因为这些问题的识别很困难，而是因为它们可能很难解决。使用性能分析器找到性能问题的原因通常是一项容易的工作，正如你将在第6章到第9章中了解到的那样。除了识别哪些代码执行外，正如第1.2.1节中讨论的，性能分析器还会显示应用程序在每条指令上花费的时间（图1.9）。
- en: '![](../../OEBPS/Images/CH01_F09_Spilca3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F09_Spilca3.png)'
- en: Figure 1.9 Investigating slowness problems with a profiler. The profiler shows
    you the time spent on each instruction during code execution. This profiler feature
    is excellent for identifying the root causes of performance problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 使用性能分析器调查缓慢问题。性能分析器显示了代码执行期间每条指令花费的时间。这个性能分析器功能对于识别性能问题的根本原因非常出色。
- en: In many cases, slowness problems are caused by I/O calls, such as reading or
    writing from a file or a database or sending data over the network. For this reason,
    developers often act empirically to find the cause of the problem. If you know
    what capability is affected, you can focus on the I/O calls that capability executes.
    This approach also helps in minimizing the scope of the problem, but you usually
    still need a tool to identify its exact location.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，缓慢问题是由I/O调用引起的，例如从文件或数据库读取或写入，或通过网络发送数据。因此，开发者通常会采取经验主义的方法来找出问题的原因。如果你知道哪个功能受到影响，你可以专注于该功能执行的I/O调用。这种方法也有助于缩小问题范围，但通常你仍然需要一个工具来识别其确切位置。
- en: 1.2.4 Understanding app crashes
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 理解应用程序崩溃
- en: Sometimes apps completely stop responding for various reasons. These kinds of
    problems are usually considered more challenging to investigate than others. In
    many cases, app crashes occur only under specific conditions, so you can’t reproduce
    (make the problem happen on purpose) them in the local environment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应用程序由于各种原因完全停止响应。这类问题通常被认为比其他问题更难调查。在许多情况下，应用程序崩溃仅在特定条件下发生，因此你无法在本地环境中重现（故意制造问题）。
- en: Every time you investigate a problem, you should first try to reproduce it in
    an environment where you can study the problem. This approach gives your investigation
    more flexibility and helps you to confirm your solution. However, we’re not always
    lucky enough to be able to reproduce a problem. And app crashes are usually not
    easy to reproduce.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调查问题时，你都应该首先尝试在一个可以研究问题的环境中重现它。这种方法给你的调查提供了更多的灵活性，并帮助你确认你的解决方案。然而，我们并不总是幸运到能够重现一个问题。应用程序崩溃通常也不容易重现。
- en: 'We find app crash scenarios in two main flavors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两种主要类型的应用程序崩溃场景中找到问题：
- en: The app completely stops.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序完全停止。
- en: The app still runs but doesn’t respond to requests.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序仍在运行，但不会响应用户请求。
- en: When the app completely stops, it’s usually because it encountered an error
    from which it couldn’t recover. Most often, a memory error causes such behavior.
    For a Java app, the situation in which the heap memory fills and the app no longer
    works is represented by an `OutOfMemoryError` message.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序完全停止时，通常是因为它遇到了无法恢复的错误。最常见的情况是内存错误导致这种行为。对于Java应用程序，堆内存填满且应用程序不再工作的情况由`OutOfMemoryError`消息表示。
- en: To investigate heap memory issues, we use *heap dumps*, which provide a snapshot
    of what the heap memory contains at a specific time. You can configure a Java
    process to automatically generate such a snapshot when an `OutOfMemoryError` message
    occurs and the app crashes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查堆内存问题，我们使用*堆转储*，它提供了特定时间点堆内存内容的快照。你可以配置Java进程，在发生`OutOfMemoryError`消息并且应用程序崩溃时自动生成这样的快照。
- en: Heap dumps are powerful tools that give you plenty of details about how an app
    internally processes the data. We’ll discuss more about how to use them in chapter
    11\. But let’s take a quick look at a short example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 堆转储是强大的工具，可以提供大量关于应用程序内部如何处理数据的详细信息。我们将在第11章中更详细地讨论如何使用它们。但让我们先快速看一下一个简短的例子。
- en: Listing 1.2 shows you a small code snippet that fills the memory with instances
    of a class named `Product`. You can find this app in project da-ch1-ex2 provided
    with the book. The app continuously adds `Product` instances to a list, causing
    an intended `OutOfMemoryError` message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2展示了填充内存的`Product`类实例的小代码片段。你可以在书中提供的项目da-ch1-ex2中找到这个应用程序。该应用程序持续向列表中添加`Product`实例，导致预期的`OutOfMemoryError`消息。
- en: Listing 1.2 An app example causing an `OutOfMemoryError` message
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2 一个导致`OutOfMemoryError`消息的应用程序示例
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ We declare a list that stores references of Product objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们声明了一个存储`Product`对象引用的列表。
- en: ❷ We continuously add Product instances to the list until the heap memory completely
    fills.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们持续向列表中添加`Product`实例，直到堆内存完全填满。
- en: ❸ Each Product instance has a String attribute. We use a unique random identifier
    as its value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每个产品实例都有一个字符串属性。我们使用一个唯一的随机标识符作为其值。
- en: Figure 1.10 shows a heap dump created for one execution of this app. You can
    easily see that `Product` and `String` instances fill most of the heap memory.
    A heap dump is like a map of the memory. It gives you many details, including
    the relationships between instances as well as values. For example, even if you
    don’t see the code, you can still notice a connection between the `Product` and
    the `String` instances based on how close the numbers of these instances are.
    Don’t worry if these aspects look complex. We’ll discuss in detail everything
    you need to know about using heap dumps in chapter 11.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10显示了为该应用程序的一次执行创建的堆转储。你可以轻松地看到`Product`和`String`实例占据了大部分堆内存。堆转储就像内存的地图。它提供了许多细节，包括实例之间的关系以及值。例如，即使你看不到代码，你仍然可以根据这些实例的数量接近程度注意到`Product`和`String`实例之间的联系。不用担心这些方面看起来很复杂。我们将在第11章中详细讨论你需要了解的所有关于使用堆转储的知识。
- en: '![](../../OEBPS/Images/CH01_F10_Spilca3.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F10_Spilca3.png)'
- en: Figure 1.10 A heap dump is like a map of the heap memory. If you learn how to
    read it, it gives you invaluable clues about how the app internally processes
    data. A heap dump helps you investigate memory problems or performance issues.
    In this example, you can easily find which object fills most of the app’s memory
    and that the `Product` and `String` instances are related.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 堆转储就像堆内存的地图。如果你学会如何阅读它，它就会给你提供关于应用程序内部如何处理数据的宝贵线索。堆转储有助于你调查内存问题或性能问题。在这个例子中，你可以轻松地找到哪个对象占据了应用程序的大部分内存，以及`Product`和`String`实例之间的关系。
- en: If the app still runs but stops responding to requests, then a *thread dump*
    is the best tool to analyze what is happening. Figure 1.11 shows you an example
    of a thread dump and some of the details this tool provides. In chapter 10, we’ll
    discuss generating and analyzing thread dumps to investigate code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序仍在运行但停止响应用户请求，那么*线程转储*是分析发生情况的最佳工具。图1.11展示了线程转储的示例以及该工具提供的一些详细信息。在第10章中，我们将讨论生成和分析线程转储以调查代码。
- en: '![](../../OEBPS/Images/CH01_F11_Spilca3.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH01_F11_Spilca3.png)'
- en: Figure 1.11 A thread dump provides details about the threads that were running
    when the dump was taken. It includes thread states and the stack traces, which
    tell you what the threads were executing or what blocked them. These details are
    valuable for investigating why an app is stuck or is having performance problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 线程转储提供了在转储时正在运行的线程的详细信息。它包括线程状态和堆栈跟踪，这些信息告诉你线程正在执行什么或是什么阻止了它们。这些细节对于调查为什么应用卡住或遇到性能问题非常有价值。
- en: 1.3 What you will learn in this book
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 你将在本书中学到什么
- en: This book is for Java developers with various levels of experience, from beginners
    to experts. You’ll learn various code investigation techniques, the best scenarios
    in which to apply them, and how to apply them to save you troubleshooting and
    investigation time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为具有各种经验水平的Java开发者编写的，从初学者到专家。你将学习各种代码调查技术、应用它们的最佳场景以及如何应用它们以节省你在故障排除和调查上的时间。
- en: If you are a junior developer, you’ll most likely learn many things from this
    book. Some developers master all these techniques only after years of experience;
    others never master them. If you are already an expert, you may find many things
    you already know, but you still have a good chance of finding new and exciting
    approaches you may not have had the opportunity to encounter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名初级开发者，你很可能会从这本书中学到很多东西。有些开发者可能只有在多年的经验之后才掌握所有这些技术；而有些人可能永远也掌握不了。如果你已经是专家，你可能发现你已经知道了很多东西，但你仍然有很大机会找到你以前没有机会遇到的新颖和令人兴奋的方法。
- en: 'When you finish the book, you will have learned the following skills:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这本书后，你将学会以下技能：
- en: Applying different approaches to using a debugger to understand an app’s logic
    or find an issue
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用不同的方法使用调试器来理解应用的逻辑或找到问题
- en: Investigating hidden functionality with a profiler to better understand how
    your app or a specific dependency of your app works
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析器调查隐藏的功能，以更好地理解你的应用或应用的具体依赖项是如何工作的
- en: Analyzing code techniques to determine whether your app or one of its dependencies
    causes a certain problem
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析代码技术以确定你的应用或其依赖项是否导致了某个问题
- en: Investigating data in an app’s memory snapshot to identify potential problems
    with how the app processes data
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查应用内存快照中的数据以识别应用处理数据时可能存在的问题
- en: Using logging to identify problems in an app’s behavior or to identify security
    breaches
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志来识别应用行为中的问题或识别安全漏洞
- en: Using remote debugging to identify problems you can’t reproduce in a different
    environment
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程调试来识别你在不同环境中无法重现的问题
- en: Correctly choosing what app investigation techniques to use to make your investigation
    faster
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确选择使用哪些应用调查技术以使你的调查更快
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can use various investigation techniques to analyze software behavior.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用各种调查技术来分析软件行为。
- en: Depending on your situation, one investigation technique may work better than
    another. You need to know how to choose the correct approach to make your investigation
    more efficient.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你的情况，一种调查技术可能比另一种更有效。你需要知道如何选择正确的方法来使你的调查更高效。
- en: For some scenarios, using a combination of techniques helps you to identify
    a problem faster. Learning how each analyzing technique works gives you an excellent
    advantage in dealing with complex problems.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，结合使用多种技术可以帮助你更快地识别问题。了解每种分析技术的工作原理，将使你在处理复杂问题时具有很大的优势。
- en: In many cases, developers use investigation techniques to learn new things rather
    than to solve problems. When learning complex frameworks such as Spring Security
    or Hibernate, simply reading books or the documentation isn’t enough. An excellent
    way to accelerate your learning is to debug examples that use a technology you
    want to better understand.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多情况下，开发者使用调查技术来学习新知识，而不是解决问题。当学习像Spring Security或Hibernate这样的复杂框架时，仅仅阅读书籍或文档是不够的。加速学习的一个极好方法是调试使用你想要更好地理解的技术示例。
- en: A situation is easier to investigate if you can reproduce it in an environment
    where you can study it. Reproducing a problem not only helps you find its root
    cause more easily, but it also helps you to confirm that a solution works when
    it is applied.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能在可以研究的环境中重现一个情况，那么调查这个情况会更容易。重现问题不仅可以帮助你更容易地找到其根本原因，而且还可以帮助你确认当解决方案应用时它是有效的。
