- en: 6 Session-based recommendations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 会话推荐
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Implementing recommendation systems by using session data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用会话数据实现推荐系统
- en: Designing graph models for session-based recommendation engines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于会话的推荐引擎设计图模型
- en: Importing existing datasets into the graph models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有数据集导入图模型
- en: 'Chapters 4 and 5 introduced two of the most common approaches to implementing
    recommendation engines: content-based and collaborative filtering. The advantages
    of each approach were highlighted, but several drawbacks also emerged during the
    discussion. Notably, these techniques require information about users that is
    not always available. This chapter covers another approach to recommendations
    that is useful when it is difficult or impossible to get access to user interaction
    history or other details about the users. In such cases, applying the classic
    approaches would not produce good results.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章和第5章介绍了实现推荐引擎的两种最常见方法：基于内容和协同过滤。每种方法的优点都得到了强调，但在讨论中也出现了几个缺点。值得注意的是，这些技术需要关于用户的信息，而这些信息并不总是可用。本章介绍了一种在难以或无法获取用户互动历史或其他用户细节时有用的推荐方法。在这种情况下，应用经典方法不会产生好的结果。
- en: 6.1 The session-based approach
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 会话方法
- en: Suppose that you would like to build a recommendation engine for an online travel
    site. The site offers lodging reservations but doesn’t require login or registration
    in the early stages of the process. Using a session-based recommendation engine,
    it is possible to deliver recommendations even in cases like this one, in which
    little about the user is known.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想为在线旅游网站构建一个推荐引擎。该网站提供住宿预订，但在流程的早期阶段不需要登录或注册。使用基于会话的推荐引擎，即使在用户信息很少的情况下，也可以提供推荐。
- en: This scenario is common on websites that book accommodations. On this type of
    website, as well as in many other real-life recommendation scenarios, users generally
    don’t log in or even register—until the end of the selection process. Only after
    they’ve selected their accommodations do users log in or register to complete
    the reservation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景在预订住宿的网站上很常见。在这类网站上，以及在许多其他现实生活中的推荐场景中，用户通常不会登录或注册，直到选择过程的最后。只有在他们选择了住宿之后，用户才会登录或注册以完成预订。
- en: Conventional recommendation approaches rely on user profiles created from purchase
    history, explicit ratings, or other past interactions, such as views and comments.
    They use these long-term preference models to determine the items to be presented
    to the user. More specifically, content-based approaches recommend items based
    on their similarity to those present in the user’s profile, whereas collaborative
    filtering approaches make predictions based on the choices of users who have similar
    profiles. In both cases, informative user profiles are assumed to be available.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的推荐方法依赖于从购买历史、显式评分或其他过去互动（如查看和评论）创建的用户资料。它们使用这些长期偏好模型来确定要向用户展示的项目。更具体地说，基于内容的推荐方法根据项目与用户资料中存在的项目的相似性推荐项目，而协同过滤方法基于具有相似资料的用户的选项进行预测。在这两种情况下，都假设可用的用户资料是信息丰富的。
- en: In many recommendation scenarios, however, like the one described here, such
    long-term user models are not available for a large fraction of the users because
    they are first-time visitors or are not logged in. In these circumstances, the
    users are largely anonymous, so the recommender systems we’ve looked at so far
    cannot deliver accurate results. Although other methods of user identification
    are available, such as cookies and fingerprinting techniques, the applicability
    of these methods is limited because of their relatively low reliability and privacy
    concerns [Tuan and Phuong, 2017]. In addition, the creation of an informative
    profile requires the user to have had sufficient interactions with the system
    in the past.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多推荐场景中，例如这里所描述的，由于大部分用户是首次访问者或未登录，因此他们没有可用的长期用户模型。在这种情况下，用户基本上是匿名的，所以我们之前考虑的推荐系统无法提供准确的结果。尽管有其他用户识别方法，如cookies和指纹技术，但由于它们的相对低可靠性和隐私问题，这些方法的适用性有限
    [Tuan and Phuong, 2017]。此外，创建一个信息丰富的个人资料需要用户在过去与系统有足够的互动。
- en: Nevertheless, providing effective recommendations that will be capable of capturing
    the current user’s interests and needs is the key to delivering a high-quality
    service, increasing user satisfaction, and getting users to come back again. Therefore,
    suitable recommendations have to be determined based on other types of information.
    Although the data available is not in the classic format, all is not lost; it
    is possible to use the user’s most recent interactions with the site or application
    as a basis for recommendations. In this case, interactions between an anonymous,
    unique user and the system can be organized into sessions. Recommendation techniques
    that rely solely on the user’s actions in an ongoing session and that adapt their
    recommendations to the user’s actions are called *session-based recommendation
    approaches* [Quadrana et al., 2018]. Figure 6.1 describes the key elements of
    a session-based recommendation engine and their relationships.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提供能够捕捉当前用户兴趣和需求的有效推荐是提供高质量服务、提高用户满意度和吸引用户再次访问的关键。因此，必须根据其他类型的信息确定合适的推荐。尽管可用数据不是经典格式，但并非一切都已失去；可以使用用户与网站或应用的最新互动作为推荐的基础。在这种情况下，匿名、独特用户与系统之间的交互可以组织成会话。仅依赖于用户在当前会话中的行为并适应其推荐的推荐技术被称为*基于会话的推荐方法*
    [Quadrana 等人，2018]。图 6.1 描述了基于会话的推荐引擎的关键元素及其关系。
- en: '![CH06_F01_Negro](../Images/CH06_F01_Negro.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Negro](../Images/CH06_F01_Negro.png)'
- en: Figure 6.1 Session-based recommendation mental model
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 基于会话的推荐心智模型
- en: A *session* is a chunk of interactions that take place within a given time frame.
    It may span a single day, several days, weeks, or even months. A session usually
    has a time-limited goal, such as finding a restaurant for dinner tonight, listening
    to music of a certain style or mood, or looking for a location for one’s next
    holiday. Figure 6.2 shows how a user searching for a holiday location changes
    their mind until finding the right place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话*是在给定时间段内发生的一系列交互。它可能跨越一天、几天、几周甚至几个月。会话通常有一个时间限制的目标，例如今晚找餐厅吃饭，听某种风格或情绪的音乐，或寻找下一个假期的地点。图
    6.2 展示了用户在找到合适的地点之前如何改变主意。'
- en: '![CH06_F02_Negro](../Images/CH06_F02_Negro.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Negro](../Images/CH06_F02_Negro.png)'
- en: Figure 6.2 A user searching for a holiday location
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 用户搜索假日地点
- en: 'Based on the information available from the user session, the recommender system
    should create a model for the user and make predictions. Session data has many
    important characteristics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户会话中可用的信息，推荐系统应该为用户创建一个模型并做出预测。会话数据具有许多重要特征：
- en: Session clicks and navigation are sequential by nature. The order of clicks
    as well as the navigational path may contain information about user intent.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话点击和导航本质上是顺序的。点击顺序以及导航路径可能包含关于用户意图的信息。
- en: Viewed items often have metadata such as names, categories, and descriptions,
    that provides information about the user’s tastes and what they are looking for.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看的项目通常具有诸如名称、类别和描述等元数据，这些信息提供了关于用户品味和他们在寻找什么的线索。
- en: 'Sessions are limited in time and scope. A session has a specific goal and generally
    ends when that goal is accomplished: rent a hotel for a business trip, find a
    restaurant for a romantic date, and so on. The session has intrinsic informational
    power related to a specific item, such as the hotel or restaurant that’s eventually
    booked.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话在时间和范围上都是有限的。一个会话有一个特定的目标，通常在目标达成时结束：为商务旅行租酒店，为浪漫约会找餐厅，等等。会话与特定项目（如最终预订的酒店或餐厅）相关的内在信息能力。
- en: When their use is practical and makes sense, session-based recommendation engines
    can deliver high-quality recommendations that predict the final goal of the user
    with high accuracy, shortening the navigational path and the time required to
    satisfy the user’s specific needs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话推荐的使用既实用又合理时，会话推荐引擎可以提供高质量的推荐，以高精度预测用户的最终目标，缩短导航路径和满足用户特定需求所需的时间。
- en: Problem solved, right? We can easily provide recommendations even when the user
    is anonymous. Awesome!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决了吗？我们可以轻松提供推荐，即使用户是匿名的。太棒了！
- en: Unfortunately, the situation is not that simple. The problem of working with
    sessions is that it is not always easy to recognize when a session starts and
    ends (when the task has been accomplished or the session is not relevant anymore).
    Think about your own experiences. How many times have you started thinking about
    where you might go on your next vacation during a work break? You start looking
    at hotels in one of the locations you’re dreaming about; then you have to get
    back to work. You might come back to the task days or even weeks later, maybe
    with a different idea of where you’d like to go. For a system, understanding when
    a session can be considered closed or not relevant anymore is a hard task. Luckily,
    some domain-specific best practices can be applied to identify the end of a search
    session, such as considering the days of inactivity or the successful booking
    of a hotel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，情况并不那么简单。处理会话的问题在于，并不总是容易识别会话何时开始和结束（任务完成时或会话不再相关）。想想你自己的经历。你在工作休息期间有多少次开始考虑你可能在下一个假期去哪里？你开始查看你梦想中的某个地点的酒店；然后你必须回去工作。你可能几天或几周后回到任务，也许会有不同的想法想去哪里。对于一个系统来说，理解何时可以认为会话已经结束或不再相关是一个困难的任务。幸运的是，一些特定领域的最佳实践可以应用于识别搜索会话的结束，例如考虑不活跃的天数或酒店的成功预订。
- en: This chapter’s example scenario illustrates some methods for implementing a
    session- based recommendation engine. Such methods help you deal with situations
    in which user-item interaction data is not available.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例场景说明了实现基于会话的推荐引擎的一些方法。这些方法有助于你处理用户-物品交互数据不可用的情况。
- en: In the literature, sequential recommendation problems (and, hence, session-based
    recommendations) are typically implemented as the task of predicting the next
    user action. From an algorithmic perspective, early prediction approaches were
    based on sequential pattern mining techniques. Later, more sophisticated methods
    based on Markov models were proposed and successfully applied to the problem.
    Most recently, the use of deep learning approaches based on artificial neural
    networks has been explored as another solution. Recurrent neural networks (RNNs),[¹](#pgfId-1006915)
    which are capable of learning models from sequentially ordered data, are a natural
    choice for this problem, and significant advances in the prediction accuracy of
    such algorithms have been reported in recent literature [Devooght and Bersini,
    2017; Hidasi and Karatzoglou, 2018; Hidasi et al., 2016 a, b; Tan et al., 2016].
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，顺序推荐问题（以及因此的基于会话的推荐）通常被实现为预测下一个用户行为的任务。从算法的角度来看，早期的预测方法基于顺序模式挖掘技术。后来，基于马尔可夫模型更复杂的方法被提出并成功应用于该问题。最近，基于人工神经网络的深度学习方法的运用被探索作为另一种解决方案。循环神经网络（RNNs），[¹](#pgfId-1006915)
    能够从顺序排列的数据中学习模型，对于这个问题是一个自然的选择，最近文献中报道了此类算法预测精度的显著提高 [Devooght and Bersini, 2017;
    Hidasi and Karatzoglou, 2018; Hidasi et al., 2016 a, b; Tan et al., 2016]。
- en: Some results presented by Ludewig and Jannach [2018] and in previous work [Verstrepen
    and Goethals, 2014; Jannach and Ludewig, 2017 a; Kamehkhosh et al., 2017] show
    that computationally and conceptually, nearest neighbor-based approaches often
    lead to predictions that are as accurate as, or even better than, those of current
    techniques based on deep learning models. Different nearest neighbor schemes exist,
    and all of them fit well with a graph-based approach to data modeling and recommendations.
    For these reasons, this section focuses on such methods. Figure 6.3 depicts the
    recommendation process for this scenario.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ludewig和Jannach [2018] 以及之前的工作 [Verstrepen and Goethals, 2014; Jannach and Ludewig,
    2017 a; Kamehkhosh et al., 2017] 展示的一些结果表明，在计算和概念上，基于最近邻的方法通常会导致与基于深度学习模型的当前技术相当准确，甚至更好的预测。存在不同的最近邻方案，并且它们都与基于图的数据建模和推荐方法很好地匹配。因此，本节重点介绍这些方法。图6.3描述了该场景的推荐过程。
- en: '![CH06_F03_Negro](../Images/CH06_F03_Negro.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Negro](../Images/CH06_F03_Negro.png)'
- en: Figure 6.3 A graph-powered session-based recommender system diagram
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 一个基于图的会话推荐系统示意图
- en: Section 6.2 describes how to model session data in the form of a graph. Section
    6.3 illustrates various techniques for building predictive models and providing
    recommendations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2节描述了如何将会话数据建模为图的形式。6.3节说明了构建预测模型和提供推荐的各种技术。
- en: 6.2 The events chain and the session graph
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 事件链和会话图
- en: 'Session data can be modeled in several ways, according to the type of learning
    algorithm and the nature of the data available. First, consider some of the desired
    properties of a session-based recommendation engine [Tuan and Phuong, 2017], related
    to the way in which the training data is modeled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 会话数据可以根据学习算法的类型和可用数据的性质以多种方式建模。首先，考虑一些基于会话的推荐引擎的期望属性[Tuan and Phuong, 2017]，这些属性与训练数据建模的方式相关：
- en: The data representation should be able to model sequential patterns in streams
    of clicks. One of the most popular methods, and one of the selected approaches
    in our scenario, is item-to-item *k*-NN. This method makes recommendations based
    on item co-occurrences but ignores the order of clicks. To solve this problem
    partially, we can introduce a time decay or a relevance window to consider only
    a small portion of a longer sequence of events.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据表示应该能够模拟点击流中的顺序模式。最流行的方法之一，也是我们场景中选定的方法之一，是项目到项目的 *k*-NN 方法。这种方法基于项目的共现进行推荐，但忽略了点击的顺序。为了部分解决这个问题，我们可以引入时间衰减或相关性窗口，只考虑较长事件序列中的一小部分。
- en: The method should provide a simple way to represent and combine item IDs with
    metadata. Usually, an item is associated with features of different types. A product
    may have an ID, a name, and a description, for example, and it generally belongs
    to one or more categories (sometimes organized in category hierarchies). It would
    be more convenient to have a general way to represent different feature types
    and jointly model their interactions, taking into account relationships and dependencies
    among them.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法应提供一种简单的方式来表示和组合项目ID与元数据。通常，一个项目与不同类型的特征相关联。例如，一个产品可能有一个ID、一个名称和一个描述，它通常属于一个或多个类别（有时组织在类别层次结构中）。有一个通用的方式来表示不同的特征类型，并共同建模它们的交互，考虑到它们之间的关系和依赖性会更为方便。
- en: User interests and goals evolve during the navigation. Step by step, the user
    focuses on a more specific goal; their idea gets clearer with each click. Thus,
    an item clicked at the beginning of the selection process is less relevant than
    one clicked later. Time has to be modeled properly to assign more value to more
    recent items than to older ones.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户兴趣和目标在导航过程中会演变。一步一步地，用户会专注于更具体的目标；他们的想法随着每一次点击而变得更加清晰。因此，在选择过程开始时点击的项目与后来点击的项目相比，相关性较低。时间必须得到适当的建模，以便为较新的项目分配比旧项目更多的价值。
- en: The graph model in figure 6.4 represents the session data, taking into account
    the required properties.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4中的图模型表示会话数据，考虑了所需的属性。
- en: '![CH06_F04_Negro](../Images/CH06_F04_Negro.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Negro](../Images/CH06_F04_Negro.png)'
- en: Figure 6.4 A session graph for the session-based recommendation schema
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 会话推荐方案的会话图
- en: 'This model satisfies all the requirements and supports different types of recommendation
    algorithms. Let’s describe it in more detail:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型满足所有要求，并支持不同类型的推荐算法。让我们更详细地描述它：
- en: The main entities (nodes) in the model are sessions, users, items, and clicks.
    These elements represent the steps of the entire navigation path.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型中的主要实体（节点）是会话、用户、项目和点击。这些元素代表了整个导航路径的步骤。
- en: 'Users can be split into two categories: anonymous users and registered/logged-in
    users. Both types of users can be connected to a session, even at the same time,
    because an anonymous user has to log in or register to complete a booking or purchase.
    The relationship between the anonymous user and the related registered user is
    tracked, so it is possible to keep track of all the items a user clicked in their
    history. Such information is useful for a more traditional collaborative filtering
    approach on a simple User-Item dataset. This information could be relevant for
    sending custom emails or other types of marketing activities (such as an offline
    marketing campaign).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以分为两类：匿名用户和注册/登录用户。这两种类型的用户都可以连接到一个会话，甚至可以同时连接，因为匿名用户必须登录或注册才能完成预订或购买。匿名用户和相关的注册用户之间的关系会被追踪，因此可以记录下用户在历史记录中点击的所有项目。此类信息对于在简单的用户-项目数据集上进行更传统的协同过滤方法非常有用。这些信息可能与发送定制电子邮件或其他类型的营销活动（如线下营销活动）相关。
- en: The session is the click aggregator. All the clicks happen in a specific session
    to which they are connected. Each session belongs to a user. Sessions can have
    some contextual information, such as a start time, end time, location, and device.
    Such contextual information can be relevant for improving the quality of the recommendations.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话是点击聚合器。所有点击都发生在与它们连接的特定会话中。每个会话属于一个用户。会话可以包含一些上下文信息，如开始时间、结束时间、位置和设备。这样的上下文信息对于提高推荐质量可能是相关的。
- en: '*Item* is a wide concept, representing several elements of interest, such as
    pages, products, search items, and search queries. Each item holds some properties
    that describe some specific features. As in the content-based approach, some properties
    are modeled as nodes and then are connected to the items; others (those specific
    to an item, such as ID) are modeled as properties of the item node.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目*是一个广泛的概念，代表多个感兴趣元素，如页面、产品、搜索项和搜索查询。每个项目都包含一些描述特定特征的属性。与基于内容的方法类似，一些属性被建模为节点，然后连接到项目上；其他（特定于项目的，如ID）被建模为项目节点的属性。'
- en: A click connects a session to an item. It also contains some information, such
    as time and location. The click stream defines a path and contains terrifically
    valuable information. It represents not only a navigational path, but also a mental
    path. During navigation, the user refines the search, clarifying their goals and
    applying some filters. This information is valuable and has to be modeled effectively.
    In the model depicted in figure 6.4, the navigation is stored by using the NEXT
    relationship, which connects each click with the next one. For performance reasons,
    a connection with the session is also stored.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点击将一个会话与一个项目连接起来。它还包含一些信息，如时间和位置。点击流定义了一条路径，并包含极其有价值的信息。它不仅代表了一个导航路径，还代表了一个心理路径。在导航过程中，用户细化搜索，明确他们的目标并应用一些过滤器。这些信息很有价值，必须有效地进行建模。在图6.4所示的模型中，导航是通过使用NEXT关系来存储的，该关系将每个点击与下一个点击连接起来。出于性能考虑，还存储了一个与会话的连接。
- en: 'The user refines their thoughts and goals during the navigation; the first
    click is less relevant than the last one. For that reason, it is important to
    model (at least conceptually) a relevance decay in the model. Different options
    exist for taking time into account during learning and prediction. Consider two
    of them:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在导航过程中细化他们的思考和目标；第一个点击的相关性不如最后一个点击。因此，在模型中（至少在概念上）模拟相关性衰减是很重要的。在学习和预测期间考虑时间因素有多种选择。考虑其中两种：
- en: '*Time decay*—A lower weight is assigned to older clicks. If the last click
    is weighted at (has a relevance of) 1.0, a click two hours ago might have a relevance
    of 0.8 or 0.5\. Different decay functions—such as linear ad exponential—can be
    defined, depending on how fast the algorithm should forget about past events.'
  id: totrans-45
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间衰减*—对较老的点击分配较低的权重。如果最后一个点击的权重为（相关性为）1.0，那么两个小时的点击可能的相关性为0.8或0.5。根据算法应该多快忘记过去事件，可以定义不同的衰减函数，如线性或指数。'
- en: '*Relevance window*—One or more sliding windows that include only the last *N*
    (with *N* configurable) clicks limit the amount of data considered during model
    training or prediction.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相关性窗口*—一个或多个仅包含最后 *N* 个（*N* 可配置）点击的滑动窗口，限制了在模型训练或预测期间考虑的数据量。'
- en: A session can last for a long time and contain a lot of clicks. A threshold,
    specified in terms of time or number of clicks, can be defined to consider only
    the relevant clicks and throw away the others. This approach helps reduce the
    size of the database, ensuring that only relevant information is stored and guaranteeing
    high performance over time.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个会话可以持续很长时间，包含大量的点击。可以定义一个阈值，以时间或点击次数来指定，以考虑仅相关的点击并丢弃其他点击。这种方法有助于减少数据库的大小，确保只存储相关信息，并保证长期的高性能。
- en: A final piece of relevant information is how the session ends up—whether it
    concludes with a purchase or a leave. This information is modeled in the graph
    representation by marking the last item with a specific label, AddToCartItem.
    The final decision not only represents valuable information, because it allows
    us to recognize a successful session, but also, some approaches compute only the
    distance between each item and items with the label AddToCartItem.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一条相关信息是会话如何结束的——是否以购买或离开结束。在图表示法中，通过将最后一个项目标记为特定的标签AddToCartItem来模拟这一信息。最终决策不仅代表有价值的信息，因为它使我们能够识别一个成功的会话，而且，一些方法仅计算每个项目与标记为AddToCartItem的项目之间的距离。
- en: It is worth noting that the model defined here is not only useful for the purpose
    of session-based recommendation, but also represents a way of modeling any sequential
    events to facilitate further analysis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这里定义的模型不仅对基于会话的推荐目的有用，而且代表了一种建模任何顺序事件以促进进一步分析的方法。
- en: 'Now that we’ve defined the graph for modeling the events chain, let’s consider
    a real example, which we’ll import by using the schema defined for our graph database.
    The dataset we’ll use is provided in the context of the ACM RecSys 2015 Challenge[²](#pgfId-1006951)
    and contains recorded click sequences (item views and purchases) for six months.
    The dataset consists of two files:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了用于建模事件链的图，让我们考虑一个真实示例，我们将使用为我们的图数据库定义的模式导入它。我们将使用的数据集是在 ACM RecSys
    2015 挑战赛[²](#pgfId-1006951) 的背景下提供的，包含六个月的记录点击序列（项目浏览和购买）。数据集由两个文件组成：
- en: '*yoochoose-clicks.dat*—Click events. Each record/line in the file has the following
    fields:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*yoochoose-clicks.dat*—点击事件。文件中的每个记录/行具有以下字段：'
- en: '*Session ID*—The ID of the session. One session may have one or many clicks.'
  id: totrans-52
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*会话 ID*—会话的 ID。一个会话可能包含一个或多个点击。'
- en: '*Timestamp*—The time when the click occurred.'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间戳*—点击发生的时间。'
- en: '*Item ID*—The unique identifier of the item.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目 ID*—项目的唯一标识符。'
- en: '*Category*—The category of the item.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类别*—项目的类别。'
- en: '*yoochoose-buys.dat*—Buy events. Each record/line in the file has the following
    fields:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*yoochoose-buys.dat*—购买事件。文件中的每个记录/行具有以下字段：'
- en: '*Session ID*—The ID of the session. One session may have one or many buying
    events.'
  id: totrans-57
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*会话 ID*—会话的 ID。一个会话可能包含一个或多个购买事件。'
- en: '*Timestamp*—The time when the buy occurred.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间戳*—购买发生的时间。'
- en: '*Item ID*—The unique identifier of the item.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目 ID*—项目的唯一标识符。'
- en: '*Price*—The price of the item.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*价格*—项目的价格。'
- en: '*Quantity*—How many units of this item were bought.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数量*—购买此项目的单位数量。'
- en: The session ID in yoochoose-buys.dat will always exist in the yoochoose-clicks.dat
    file; the records with the same session ID together form the sequence of click
    events of a certain user during the session. The session could be short (a few
    minutes) or long (a few hours), and it could have one click or hundreds of clicks.
    Everything depends on the activity of the user. The following listing shows the
    code that creates the session data according to the model designed so far.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 yoochoose-buys.dat 文件中，会话 ID 总是存在于 yoochoose-clicks.dat 文件中；具有相同会话 ID 的记录一起形成用户在会话期间点击事件的序列。会话可能很短（几分钟）或很长（几小时），可能包含一个点击或数百个点击。一切取决于用户的活动。以下列表显示了根据迄今为止设计的模型创建会话数据的代码。
- en: Listing 6.1 Importing session data from yoochoose file
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 从 yoochoose 文件导入会话数据
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates constraints to guarantee the uniqueness of the sessions and items
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建约束以保证会话和项目的唯一性
- en: ❷ Checks for the existence of the session and the item; otherwise, creates them
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查会话和项目是否存在；否则，创建它们
- en: ❸ Creates the click and all the relationships among the item, click, and session
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建点击以及项目、点击和会话之间的所有关系
- en: ❹ Defines the types for the imported CSV file (helpful in Pandas to prevent
    issues with typecasting)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义导入 CSV 文件的类型（在 Pandas 中有助于防止类型转换问题）
- en: ❺ Reads the CSV file and commits in chunks of 10^6 rows to speed the process
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 以10^6行为单位读取 CSV 文件并分批提交以加快处理速度
- en: ❻ Loops over the rows and runs the queries, passing the parameters to create
    new clicks for each session
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 遍历行并运行查询，为每个会话传递参数以创建新的点击
- en: Each line in the CSV file contains a click of a specific item. The MERGE clauses
    allow us to create the session and the item only once; then the click node connects
    the session to the item. The following listing adds information on buys to the
    existing sessions that ended with a purchase.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件中的每一行都包含特定项目的点击。MERGE 子句允许我们只创建一次会话和项目；然后点击节点将会话连接到项目。以下列表向已结束购买的现有会话添加购买信息。
- en: Listing 6.2 Importing buys data from yoochoose file
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 从 yoochoose 文件导入购买数据
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Searches for the session and the item
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 搜索会话和项目
- en: ❷ Creates the buy (a special type of click) and all the relationships among
    the item, buy, and session
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建购买（一种特殊的点击）以及项目、购买和会话之间的所有关系
- en: ❸ Defines the types for the imported CSV file (helpful in Pandas to prevent
    issues with typecasting)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义导入 CSV 文件的类型（在 Pandas 中有助于防止类型转换问题）
- en: ❹ Reads the CSV file in chunks of 10^6 rows to speed the process
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 以10^6行为单位读取 CSV 文件以加快处理速度
- en: ❺ Loops over the rows and runs the queries, passing the parameters to create
    new clicks for each session
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 遍历行并运行查询，为每个会话传递参数以创建新的点击
- en: This code, though correct, is slow. It’s simple to understand and linear, which
    is why it’s preferred here, but it can run for hours. In the code repository for
    this chapter, you will find a different version that’s much more performant but
    also more complex.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码是正确的，但运行速度较慢。它易于理解且线性，这就是为什么在这里被优先选择，但它可能需要运行数小时。在本章的代码仓库中，你可以找到一个性能更好但也更复杂的不同版本。
- en: Regardless of which version you run, the result will be the same. The following
    query allows you to visualize the result of the import, considering a single session
    (the one with ID 140837).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你运行哪个版本，结果都将相同。以下查询允许你可视化导入的结果，考虑单个会话（ID为140837的那个会话）。
- en: Listing 6.3 Query to show the subgraph related to a specific session
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 查询以显示与特定会话相关的子图
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Exercises
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Play with the new database, and write queries to find the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用新的数据库，并编写查询以找到以下内容：
- en: The 10 most-clicked items
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被点击最多的10个项目
- en: The 10 most-purchased items (did they match?)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买量最多的10个商品（它们匹配吗？）
- en: The longest session (did it contain a purchase?)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最长的会话（它是否包含购买？）
- en: 6.3 Providing recommendations
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 提供推荐
- en: The model designed in section 6.2 is flexible enough to serve different recommendation
    approaches. As described in the introduction to this chapter, session-based recommendation
    engines are useful in a lot of scenarios. This topic is widely investigated, and
    a great variety of solutions have been proposed to provide the best recommendations
    possible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第6.2节设计的模型足够灵活，可以服务于不同的推荐方法。正如本章引言中所述，基于会话的推荐引擎在许多场景中都很有用。这个主题已经被广泛研究，已经提出了各种各样的解决方案，以提供尽可能好的推荐。
- en: A first natural approach consists of using a collaborative filtering method,
    specifically, the k-nearest neighbor approach, by using session-item data in place
    of the user-item matrix. Nevertheless, due to the sequential nature of the events
    in the chain, some researchers have proposed the use of RNNs or convolutional
    neural networks (CNNs)[³](#pgfId-1006967) to reveal sequential patterns in sessions
    and use them to provide recommendations [Jannach and Ludewig, 2017 a; Quadrana
    et al., 2018; Tuan and Phuong, 2017]. Compared with the collaborative filtering
    approach, which fundamentally ignores the actual sequence of actions, RNNs and
    CNNs consider the overall navigation path and can model sequential patterns of
    session clicks. Although it has been proved that such methods can deliver high-quality
    recommendations, they are quite complex to implement and require a lot of data
    to be properly trained. Moreover, if properly implemented. The *k*-NN approach
    can outperform deep learning methods in both efficiency and quality [Jannach and
    Ludewig, 2017 a; Ludewig and Jannach, 2018].
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种自然的方法是使用协同过滤方法，具体来说，是使用k近邻方法，通过使用会话-项目数据代替用户-项目矩阵。尽管如此，由于事件链的顺序性质，一些研究人员提出了使用RNN或卷积神经网络（CNNs）[³](#pgfId-1006967)来揭示会话中的顺序模式，并使用它们来提供推荐[Jannach
    and Ludewig, 2017 a; Quadrana et al., 2018; Tuan and Phuong, 2017]。与基本忽略实际动作顺序的协同过滤方法相比，RNN和CNN考虑了整体的导航路径，并且可以模拟会话点击的顺序模式。尽管已经证明这些方法可以提供高质量的推荐，但它们的实现相当复杂，并且需要大量数据进行适当的训练。此外，如果正确实现，*k*-NN方法在效率和品质上都可以优于深度学习方法[Jannach
    and Ludewig, 2017 a; Ludewig and Jannach, 2018]。
- en: For these reasons, in this section we’ll consider different *k*-NN approaches
    to the problem of suggesting a top-*N* list of items in session-based recommendation
    engines. Over the years, multiple implementations have been proposed for such
    a task. The most relevant for our scenario and the purpose of this section [Ludewig
    and Jannach, 2018] are
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，在本节中，我们将考虑不同的 *k*-NN 方法来解决基于会话推荐引擎中建议前-*N* 个项目的问题。多年来，已经提出了多种实现此类任务的方案。对我们场景和本节目的最相关的是[Ludewig
    and Jannach, 2018]。
- en: '*Item-based k-NN (Item-KNN)*—This method, introduced by Hidasi et al. [2016
    a], considers only the last element in a given session (the current one) and recommends
    those items that are most similar to it in terms of their co-occurrence in other
    sessions. If the user is currently looking at a villa in Bilbao, the system will
    suggest other villas that appear frequently in other sessions when the user was
    looking at the same villa in Bilbao.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于物品的k-NN（Item-KNN）*—这种方法，由Hidasi等人[2016 a]提出，仅考虑给定会话（当前会话）中的最后一个元素，并推荐那些在其他会话中与其共现最相似的物品。如果用户当前正在查看比利亚尔巴的别墅，系统将建议其他在用户查看比利亚尔巴的同一别墅时也频繁出现的别墅。'
- en: '*Session-based k-NN (SKNN)*—This method, instead of considering only the last
    event in the current session, compares the entire current session (or a significant
    part of it, considering only the latest N clicks) with the past sessions in the
    training data to determine the items to be recommended [Bonnin and Jannach, 2014;
    Hariri et al., 2012; Lerche et al., 2016]. If a user viewed villas in Bilbao,
    Barcelona, and Madrid, the algorithm would search for similar sessions (similar
    because they contain more or less the same entries) and compute the scores of
    items to suggest by considering how many similar sessions contain the target item.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于会话的k-NN（SKNN）*—这种方法不是只考虑当前会话中的最后一个事件，而是将整个当前会话（或其重要部分，仅考虑最新的N次点击）与训练数据中的过去会话进行比较，以确定要推荐的物品[Bonnin和Jannach,
    2014; Hariri等人，2012; Lerche等人，2016]。如果一个用户在比利亚尔巴、巴塞罗那和马德里看过别墅，算法将搜索类似会话（因为它们包含或多或少相同的条目）并计算建议物品的分数。'
- en: The second approach is a bit more complex to implement than the first, of course,
    but its accuracy is comparable with that of more complex implementations such
    as RNNs and CNNs while requiring less data for training the model. Even the item-based
    approach can provide valuable features, however, so the following sections consider
    both approaches.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法比第一种方法更复杂一些，但它的准确度与更复杂的实现（如RNNs和CNNs）相当，同时训练模型所需的数据更少。然而，基于物品的方法也能提供有价值的特征，因此以下章节将考虑这两种方法。
- en: 6.3.1 Item-based k-NN
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 基于物品的k-NN
- en: Suppose that you’re browsing for shoes. Would it be useful if the system showed
    you shoes similar to the ones you’re currently looking at, based on what other
    users were looking at before and after they reached the same pair of shoes as
    you? The item-based *k*-NN approach uses session data to compute similarities
    between pairs of items. The overall approach is the same as in the case of item-based
    collaborative filtering; the only difference is that instead of a User-Item matrix,
    the session-item data is used. As in the classic approach, the first step is representing
    the item in a vector space model (VSM) in which each element corresponds to a
    session and is set to 1 if the item appeared in the session. The similarity of
    two items can be determined by using the cosine similarity measure, for example,
    and the number of neighbors *k* is implicitly defined by the desired recommendation
    list length. The overall process is depicted in figure 6.5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在浏览鞋子。如果系统根据其他用户在到达与你相同的鞋子之前和之后查看的内容向你展示类似鞋子，这会有用吗？基于物品的*k*-NN方法使用会话数据来计算成对物品之间的相似性。整体方法与基于物品的协同过滤案例相同；唯一的区别是，不是使用用户-物品矩阵，而是使用会话-物品数据。与经典方法一样，第一步是将物品表示为向量空间模型（VSM），其中每个元素对应一个会话，如果物品出现在会话中，则设置为1。两个物品的相似度可以通过使用余弦相似度度量来确定，例如，邻居数量*k*隐式地由期望的推荐列表长度定义。整个过程在图6.5中展示。
- en: '![CH06_F05_Negro](../Images/CH06_F05_Negro.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Negro](../Images/CH06_F05_Negro.png)'
- en: Figure 6.5 Session-based recommendation schema using Item-KNN
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 使用Item-KNN的基于会话的推荐方案
- en: Conceptually, the method implements a form of “Customers who bought . . . also
    bought.” The use of the cosine similarity metric makes the method less susceptible
    to popularity bias. Although item-to-item approaches are comparably simple, they
    are commonly used in practice and sometimes considered to represent a strong baseline
    [Davidson et al., 2010; Linden et al., 2003]. It’s worth noting that item metadata
    information can be used in this case, even in combination with session data, to
    compute similarities between items. This technique is useful when you have a new
    item without any history.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，该方法实现了一种“购买了 . . . 的客户也购买了”的形式。使用余弦相似度指标使该方法对流行度偏差的敏感性降低。尽管项目到项目的方案相对简单，但它们在实践中被广泛使用，有时被认为是一个强大的基线
    [Davidson 等人，2010；Linden 等人，2003]。值得注意的是，在这种情况下可以使用项目元数据信息，即使与会话数据结合使用，也可以计算项目之间的相似度。当您有一个没有历史记录的新项目时，这种技术非常有用。
- en: In terms of the implementation, all similarity values can be precomputed and
    sorted in the training process to ensure fast responses at recommendation time.
    Updates are required on a time basis (every *x* hours) or on a session volume
    basis (every *x* new session clicks).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，所有相似度值都可以在训练过程中预先计算并排序，以确保在推荐时的快速响应。需要根据时间（每 *x* 小时）或会话量（每 *x* 次新的会话点击）进行更新。
- en: Consider an example with trivial data, and follow the process step by step.
    Suppose that we have the five sessions described in table 6.1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有平凡数据示例，并逐步跟踪整个过程。假设我们有表 6.1 中描述的五个会话。
- en: Table 6.1 Session examples
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 会话示例
- en: '| Session # | Session content (ordered list of item IDs) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 会话编号 | 会话内容（项目 ID 的有序列表） |'
- en: '| 1 | [Item 12, Item 23, Item 7, Item 562, Item 346, Item 85] |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [项目 12, 项目 23, 项目 7, 项目 562, 项目 346, 项目 85] |'
- en: '| 2 | [Item 23, Item 65, Item 12, Item 3, Item 9, Item 248] |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [项目 23, 项目 65, 项目 12, 项目 3, 项目 9, 项目 248] |'
- en: '| 3 | [Item 248, Item 12, Item 7, Item 9, Item 346] |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [项目 248, 项目 12, 项目 7, 项目 9, 项目 346] |'
- en: '| 4 | [Item 85, Item 65, Item 248, Item 12, Item 346, Item 9] |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [项目 85, 项目 65, 项目 248, 项目 12, 项目 346, 项目 9] |'
- en: '| 5 | [Item 346, Item 7, Item 9, Item 3, Item 12] |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 5 | [项目 346, 项目 7, 项目 9, 项目 3, 项目 12] |'
- en: The goal is to suggest something to the user in session 5\. The current item
    is 12\. The first step consists of computing the distance between this item and
    all the not-yet-seen items. Table 6.2 (the VSM representation) is useful for easily
    extracting the vector representations of the items, as we saw in chapter 5.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是在会话 5 中向用户推荐一些内容。当前项目是 12。第一步包括计算此项目与所有尚未查看的项目之间的距离。表 6.2（VSM 表示）有助于轻松提取项目的向量表示，正如我们在第
    5 章中看到的。
- en: Table 6.2 Sessions of table 6.1 represented in VSM
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 表 6.1 的会话以 VSM 表示
- en: '| Session # | 3 | 7 | 9 | 12 | 23 | 65 | 85 | 248 | 346 | 562 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 会话编号 | 3 | 7 | 9 | 12 | 23 | 65 | 85 | 248 | 346 | 562 |'
- en: '| 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
- en: '| 2 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |'
- en: '| 3 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 |'
- en: '| 4 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |'
- en: '| 5 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
- en: It is important to notice that the click order is lost. The following piece
    of code does all the necessary computations for you. Using it is easier than doing
    the computations manually, and it introduces sklearn,[⁴](#pgfId-1006990) which
    is a powerful machine learning library.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意点击顺序已丢失。以下代码片段为您执行所有必要的计算。使用它比手动计算要容易，并且它引入了 sklearn[⁴](#pgfId-1006990)，这是一个强大的机器学习库。
- en: Listing 6.4 Computing similarity between item 12 and all the not-yet-seen items
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 计算项目 12 与所有尚未查看的项目之间的相似度
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the most similar item is item 248\. Other items have the same
    similarity score or even higher, such as items 9 and 346, but in our recommendation
    policy, we decided to avoid showing items that the user has already seen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，最相似的项目是项目 248。其他项目具有相同的相似度得分或甚至更高，例如项目 9 和 346，但根据我们的推荐策略，我们决定避免展示用户已经看到的项目。
- en: Now that the process is clear, let’s move from the trivial example to our real
    database. We will split the process into two parts. The first part will precompute
    similarity among items and store the top k-nearest neighbors, and the second will
    provide recommendations. Listing 6.5 shows the code for similarity precomputation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过程已经清楚，让我们从平凡示例转移到我们的真实数据库。我们将过程分为两部分。第一部分将预先计算项目之间的相似度并存储最接近的 k 个邻居，第二部分将提供推荐。列表
    6.5 显示了相似度预计算的代码。
- en: Listing 6.5 Extracting item vectors from graph; computing and storing similarities
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 从图中提取项目向量；计算和存储相似度
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Entry point that processes all the items
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理所有项目的入口点
- en: ❷ Searches for items and creates the vectors for each
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 搜索项目并为每个项目创建向量
- en: ❸ Query that gets the list of items
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取项目列表的查询
- en: ❹ Query that extracts the vector for each item based on sessions it belongs
    to
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据所属会话提取每个项目的向量
- en: ❺ Entry point that processes all the items
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 处理所有项目的入口点
- en: ❻ For each item, computes the top k-nearest neighbors among all the other items
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于每个项目，计算所有其他项目中的前k个最近邻
- en: ❼ Computes the cosine similarity between two sparse vectors
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 计算两个稀疏向量之间的余弦相似度
- en: ❽ Sorts the neighbor based on similarity value
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 根据相似度值对邻居进行排序
- en: ❾ Stores the model (the k-NN)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 存储模型（k-NN）
- en: ❿ Cleans up the old model for the node
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 清理节点的旧模型
- en: ⓫ Stores the new model as the relationship SIMILAR_TO between the current item
    and the top k similar items
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将新模型存储为当前项目与最相似的前k个项目的相似关系SIMILAR_TO
- en: Notice that this code is similar to the code we used for item-based recommendation
    in the collaborative filtering approach. Such code has to be executed periodically
    to keep the similarity values up to date.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码与我们用于基于项目的协同过滤方法中的代码相似。这样的代码需要定期执行以保持相似度值最新。
- en: Before moving on, I would like to mention an issue you may encounter. Although
    it’s formally correct, the code in the preceding listing will take a while (a
    long while, actually) to complete. This problem is common in working with nearest
    neighbors in general. So far, we’ve been working with small datasets, so it hasn’t
    been an issue, but as I promised you at the beginning, this book aims to be a
    concrete book that helps you solve real machine learning problems, not trivial
    examples. Computing nearest neighbors requires you to compute N × N similarities,
    and when you have a lot of items, this process can take a long time. Moreover,
    considering that occasionally you also have to update the nearest neighbor network
    to keep it aligned with the latest clicks by the user, the preceding code is not
    useful in production-ready projects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想提到一个问题，你可能会遇到。尽管它是形式上正确的，但前面列表中的代码将需要一段时间（实际上是很长一段时间）才能完成。这个问题在处理最近邻时是常见的。到目前为止，我们一直在处理小数据集，所以这不是一个问题，但正如我一开始承诺的，这本书旨在成为一本具体的书，帮助你解决真正的机器学习问题，而不是简单的例子。计算最近邻需要你计算N
    × N的相似度，当你有很多项目时，这个过程可能需要很长时间。此外，考虑到你偶尔还需要更新最近邻网络以保持其与用户最新点击的一致性，前面的代码在可生产的项目中并不实用。
- en: You can use different techniques to solve this problem. If your goal is to compute
    the similarity of every pair, there is nothing you can do to reduce the work,
    although parallel processing can reduce the elapsed time. You can use analytics
    engines for large-scale data processing, such as Apache Spark[⁵](#pgfId-1007005)
    or Apache Flink.[⁶](#pgfId-1007020)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用不同的技术来解决此问题。如果你的目标是计算每一对的相似度，你无法做任何事情来减少工作量，尽管并行处理可以减少经过的时间。你可以使用用于大规模数据处理的分析引擎，如Apache
    Spark[⁵](#pgfId-1007005)或Apache Flink。[⁶](#pgfId-1007020)
- en: Another approach is to consider only an approximate version of the k-nearest
    neighbors. Often, we want only the most similar pairs or all pairs that are above
    some lower bound in similarity. In that case, we can focus our attention only
    on pairs that are likely to be similar without investigating every pair. Different
    algorithms exist for computing approximate versions of k-NN. One of those algorithms,
    illustrated in figure 6.6, is called *locality-sensitive hashing (LSH) or near-neighbor
    search* [Ullman and Rajaraman, 2011].
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是只考虑k-最近邻的近似版本。通常，我们只想找到最相似的成对或所有相似度高于某个下限的成对。在这种情况下，我们只需关注可能相似的成对，而不必调查每一对。存在不同的算法用于计算k-NN的近似版本。其中之一，如图6.6所示，被称为*局部敏感哈希（LSH）或近邻搜索*
    [Ullman and Rajaraman, 2011]。
- en: '![CH06_F06_Negro](../Images/CH06_F06_Negro.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Negro](../Images/CH06_F06_Negro.png)'
- en: Figure 6.6 The mental model explaining LSH
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 解释LSH的心智模型
- en: One general approach to LSH is to hash items several times, in such a way that
    similar items are more likely to be hashed to the same bucket than dissimilar
    items are. Then we consider any pair that hashed to the same bucket on any occasion
    to be a candidate pair, and we check only the candidate pairs for similarity.
    The hope is that most of the dissimilar pairs will never hash to the same bucket
    and therefore will never be checked. Those dissimilar pairs that do hash to the
    same bucket are false positives; we hope that these pairs will be only a small
    fraction of all pairs. We also hope that most of the truly similar pairs will
    hash to the same bucket at least once. Those that do not are false negatives,
    and we hope that they will be a small fraction of the truly similar pairs. An
    implementation that uses this technique is available in the code repository as
    an advanced version of listing 6.5.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: LSH的一种通用方法是对项目进行多次哈希，使得相似的项目更有可能被哈希到同一个桶中，而不相似的项目则不太可能。然后我们考虑在任何时候被哈希到同一个桶中的任何一对作为候选对，并且只检查候选对以确定相似度。希望大多数不相似的对永远不会被哈希到同一个桶中，因此永远不会被检查。那些确实被哈希到同一个桶中的不相似对是假阳性；我们希望这些对只占所有对的一小部分。我们也希望大多数真正相似的对至少会哈希到同一个桶中一次。那些没有这样做的是假阴性，我们希望它们只占真正相似对的一小部分。使用这种技术的实现可以在代码仓库中找到，作为列表6.5的高级版本。
- en: When the k-NN for each item has been precomputed, the recommendation process
    is a trivial query such as the following.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个项目的k-NN已经被预先计算后，推荐过程就是一个简单的查询，如下所示。
- en: Listing 6.6 Query for providing recommendations by using the Item KNN approach
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 使用项目KNN方法提供推荐的查询
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This query takes 1 ms to complete on my laptop because everything is precomputed,
    and navigating the graph of similarities is fast.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询在我的笔记本电脑上完成只需要1毫秒，因为所有内容都是预先计算的，导航相似度图非常快。
- en: Exercises
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'In the database, do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中执行以下操作：
- en: Find the 10 closest items.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最接近的10个项目。
- en: The results of the preceding query will show that a lot of them have similarity
    values close to 1 or even higher due to approximation. Navigate that portion of
    the graph to see why.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个查询的结果将显示，由于近似，很多项目的相似度值接近1甚至更高。导航这部分图，看看原因。
- en: Search for the best seller items and their neighbors. Are they also best sellers?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索最佳卖家项目和它们的邻居。它们也是最佳卖家吗？
- en: Through the queries, you will notice how simple it is to navigate the graph.
    Try to get more insights from the graph yourself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询，你会注意到导航图是多么简单。尝试自己从图中获取更多见解。
- en: 6.3.2 Session-based k-NN
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 基于会话的k-NN
- en: The key differentiator of the session-based approach, compared with the previous
    one, is that the similarity is computed among sessions instead of among items.
    Such similarities, stored in the graph as k-NN, are used to score the items and
    return recommendations to the user. The overall approach is described in figure
    6.7.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法相比，基于会话的方法的关键区别在于，它是计算会话之间的相似度，而不是项目之间的相似度。这些相似度以k-NN的形式存储在图中，用于评估项目并向用户返回推荐。整体方法在图6.7中描述。
- en: '![CH06_F07_Negro](../Images/CH06_F07_Negro.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F07_Negro](../Images/CH06_F07_Negro.png)'
- en: Figure 6.7 Session-based recommendation schema using SKNN
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 使用SKNN的基于会话的推荐方案
- en: 'In this case metadata, such as a title, description, or list of features, is
    not relevant for the algorithm selected. Another interesting aspect of this approach
    is the fact that it doesn’t require a lot of information to be effective. In more
    detail, given a session s, the recommendation process is structured in the following
    way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，元数据，如标题、描述或特征列表，对于所选算法来说并不相关。这种方法另一个有趣的特点是它不需要太多信息就能有效。更详细地说，给定一个会话s，推荐过程的结构如下：
- en: Compute the k most similar past sessions (neighbors) by applying a suitable
    session similarity measure, such as the Jaccard index or cosine similarity on
    binary vectors over the item space [Bonnin and Jannach, 2014]. According to Quadrana
    [2017], the binary cosine similarity measure leads to the best results. Moreover,
    as Jannach and Ludewig [2017 a] show, using k = 500 as the number of neighbors
    to consider leads to good performance results for many datasets.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用合适的会话相似度度量，如项目空间上的二进制向量上的Jaccard指数或余弦相似度，计算k个最相似的过去会话（邻居）。根据Quadrana [2017]的研究，二进制余弦相似度度量能带来最佳结果。此外，正如Jannach和Ludewig
    [2017 a]所展示的，使用k = 500作为考虑的邻居数量，对于许多数据集来说，能带来良好的性能结果。
- en: Given the current session s, its neighbors k, and the similarity values, compute
    the score for each item, order them, and return the top N.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定当前会话s，其邻居k和相似度值，计算每个项目的分数，对它们进行排序，并返回前N个。
- en: It is possible to use different formulas as scoring functions. One function
    that leads to good results [Bonnin and Jannach, 2014] is
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不同的公式作为评分函数。一个导致良好结果[邦宁和贾纳奇，2014]的函数是
- en: '![CH06_F07_Negro_EQ01](../Images/CH06_F07_Negro_EQ01.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F07_Negro_EQ01](../Images/CH06_F07_Negro_EQ01.png)'
- en: where
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: KNN(s) is the k-nearest neighbors network for s.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KNN(s)是s的k近邻网络。
- en: sim(s,n) represents the cosine similarity between the sessions s and n.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sim(s,n)表示会话s和n之间的余弦相似度。
- en: 1[n](i) is a function that returns 1 if the session n contains the target item
    i and 0 otherwise. (This function allows us to consider only the sessions that
    contain the target items, filtering out the others.)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1[n](i)是一个函数，如果会话n包含目标项目i，则返回1，否则返回0。（此函数允许我们仅考虑包含目标项目的会话，过滤掉其他会话。）
- en: To understand the formula and the overall process, consider again our sample
    sessions from table 6.1 and their VSM representation, shown again for your convenience
    in table 6.3.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解公式和整体过程，请再次考虑表6.1中的示例会话及其VSM表示，为了您的方便，再次在表6.3中展示。
- en: Table 6.3 Sessions of table 6.1 represented in VSM
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3表6.1的会话以VSM表示
- en: '| Session # | 3 | 7 | 9 | 12 | 23 | 65 | 85 | 248 | 346 | 562 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 会话编号 | 3 | 7 | 9 | 12 | 23 | 65 | 85 | 248 | 346 | 562 |'
- en: '| 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 1 |'
- en: '| 2 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 0 |'
- en: '| 3 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0 |'
- en: '| 4 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0 | 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 |'
- en: '| 5 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |'
- en: In this case, we are interested in the session vectors, which we can extract
    by reading line by line. In the following listing, we compute the distances between
    session 5 (our target) and all the other sessions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们感兴趣的是会话向量，我们可以通过逐行读取来提取它们。在下面的列表中，我们计算会话5（我们的目标）与其他所有会话之间的距离。
- en: Listing 6.7 Computing similarity between item 12 and all the not-yet-seen items
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7计算项目12与所有尚未查看的项目之间的相似度
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can compute the scores for all the not-yet-seen items as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式计算所有尚未查看项目的分数：
- en: '*score*(item 23, session 5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 1 + 0.547 × 1 =
    1.894'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*score*(项目23，会话5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 1 + 0.547 × 1 = 1.894'
- en: '*score*(item 65, session 5) = 0.547 × 1 + 0.547 × 1 + 0.8 × 0 + 0.547 × 0 =
    1.094'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*score*(项目65，会话5) = 0.547 × 1 + 0.547 × 1 + 0.8 × 0 + 0.547 × 0 = 1.094'
- en: '*score*(item 85, session 5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 0 + 0.547 × 1 =
    1.094'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*score*(项目85，会话5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 0 + 0.547 × 1 = 1.094'
- en: '*score*(item 248, session 5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 1 + 0.547 × 1
    = 1.894'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*score*(项目248，会话5) = 0.547 × 0 + 0.547 × 1 + 0.8 × 1 + 0.547 × 1 = 1.894'
- en: '*score*(item 562, session 5) = 0.547 × 1 + 0.547 × 0 + 0.8 × 0 + 0.547 × 0
    = 0.547'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*score*(项目562，会话5) = 0.547 × 1 + 0.547 × 0 + 0.8 × 0 + 0.547 × 0 = 0.547'
- en: In this case, the highest score is achieved by items 23 and 248.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最高分数由项目23和248获得。
- en: During the recommendation phase, time constraints mean that determining the
    similarity of the current session with millions of past sessions and then computing
    the score for each not-yet-seen item is not practical. A variety of approaches
    can be implemented to optimize and speed this process, and many of them could
    use the graph model. We will consider two approaches here.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐阶段，时间限制意味着确定当前会话与数百万个过去会话之间的相似度，然后计算每个尚未查看项目的分数是不切实际的。可以实施各种方法来优化和加速此过程，其中许多方法可以使用图模型。我们在这里将考虑两种方法。
- en: First optimization
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次优化
- en: 'This technique provides optimization by using the graph model in the following
    ways:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过以下方式使用图模型提供优化：
- en: k-*NN precomputation*—It is possible, as in the previous case, to precompute
    (and keep updated) the k-nearest neighbors stored as relationships among the sessions.
    A background process can update these relationships according to some criteria,
    such as time or volume.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k-*NN预计算*——与上一个案例一样，可以预先计算（并保持更新）存储为会话之间关系的k近邻。后台进程可以根据某些标准，如时间或数量，更新这些关系。
- en: '*Postfiltering*—For each item, we already have a relationship with all the
    sessions in which the item appears. These relationships can be used to filter
    out all the sessions in the k-NN(s) that don’t contain the item.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后过滤*——对于每个项目，我们已与其中出现该项目的所有会话建立了关系。这些关系可以用来过滤掉k-NN(s)中不包含该项目的所有会话。'
- en: Considering the graph model designed for this scenario, shown in figure 6.4,
    the following listing shows how to precompute the similarities among all the sessions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为此场景设计的图模型，如图6.4所示，以下列表显示了如何预先计算所有会话之间的相似度。
- en: Listing 6.8 Computing and storing in graph the k-NN for each session
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 在图中计算和存储每个会话的k-NN
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ TEntry-point function that computes and stores the k-NN model for all the
    sessions
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算并存储所有会话的k-NN模型的入口点函数
- en: ❷ Function that computes the similarities
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算相似度的函数
- en: ❸ Searches for the session and creates the related vector for each based on
    items clicked
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 搜索会话并为每个基于点击的项目创建相关向量
- en: ❹ Query that cleans up the existing model for the current session
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 清理当前会话现有模型的查询
- en: ❺ Query that creates the new model
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建新模型的查询
- en: The postfiltering, which will help us consider only the sessions in k-NN that
    contain the current item, can be implemented by using the following query.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 后过滤，它将帮助我们仅考虑包含当前项目的k-NN中的会话，可以通过以下查询实现。
- en: Listing 6.9 Query for implementing postfiltering
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 实现后过滤的查询
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Starting from this query, it is possible to generalize it so that we can generate
    the list of recommendations using the score function defined.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个查询开始，可以将其推广，以便我们可以使用定义的得分函数生成推荐列表。
- en: Listing 6.10 Recommendation process using this optimization
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 使用此优化进行推荐的推荐过程
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, so good, but if you run the whole process with the sample dataset, it
    will take a while and require a lot of memory to compute the k-NN. After it is
    computed, the recommendation process requires only a few milliseconds. As usual,
    in the code repository you’ll find an advanced version, which uses a Python library
    called Annoy[7](#pgfId-1007035) (Approximate Nearest Neighbors Oh Yeah) as an
    alternative to LSH. But for our dataset, which contains 850,000 sessions, it still
    takes a long time to complete.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但如果使用样本数据集运行整个流程，将需要一段时间，并且需要大量的内存来计算k-NN。计算完成后，推荐过程只需要几毫秒。通常，在代码仓库中，你可以找到一个高级版本，它使用一个名为Annoy[7](#pgfId-1007035)（近似最近邻，是的）的Python库作为LSH的替代品。但是，对于包含850,000个会话的数据集，它仍然需要很长时间才能完成。
- en: To solve these issues, I’m going to propose a second optimization that takes
    advantage of the graph way of storing the data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我将提出第二种优化方法，该方法利用了数据存储的图方式。
- en: Second optimization
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种优化
- en: 'This technique optimizes the process in the following way:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术以下列方式优化了过程：
- en: 'k*-NN elements sampling*—From the set of possible neighbors, a subsample of
    M sessions is extracted by choosing them randomly or using a heuristic. One of
    the most effective heuristics consists in focusing on the most recent sessions,
    if such information is available; focusing on recent trends (sessions) has proved
    to be effective for recommendations in e-commerce [Jannach and Ludewig, 2017 b]
    and led to even better results than when all past sessions were taken into account.
    From the set of M sessions, the k-nearest neighbors of the current session s are
    extracted: the k-NN(s).'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k*-NN元素采样*—从可能的邻居集中，通过随机选择或使用启发式方法提取M个会话的子样本。最有效的启发式方法之一是关注最近的会话，如果可用的话；关注最近趋势（会话）已被证明对电子商务中的推荐有效[Jannach和Ludewig，2017
    b]，并且比考虑所有过去会话时得到的结果更好。从M个会话集中，提取当前会话s的k个最近邻居：k-NN(s)。
- en: '*Score computation prefiltering*—The set of recommendable items R is extracted,
    considering only items that appear in one of the sessions in the k-NN(s). Finally,
    the algorithm computes the scores for the items in R by using the formula described
    previously.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*得分计算预过滤*—从k-NN(s)中出现的会话中提取推荐项目集R，仅考虑这些项目。最后，算法使用之前描述的公式计算R集中项目的得分。'
- en: The k-NN(s) are highly variable because new sessions are created continuously.
    Therefore, the k-NN(s) for each session are not stored as relationships in the
    graph (they are computed in real time), but the graph is used during sampling
    and prefiltering. The second optimization allows operations such as similarity
    computations and the final predictions to be done efficiently. In the experiments
    reported by Jannach and Ludewig [2017 a], it was sufficient to consider, for example,
    only the 1,000 most recent sessions from several million existing ones and still
    obtain high-quality results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: k-NN(s) 的变化很大，因为会话是持续创建的。因此，每个会话的 k-NN(s) 并不以图中的关系存储（它们是实时计算的），但在采样和预过滤过程中使用图表。第二次优化允许高效地进行相似度计算和最终预测。在
    Jannach 和 Ludewig [2017 a] 报道的实验中，例如，只需要考虑几百万个现有会话中的前 1,000 个最新会话，就可以获得高质量的结果。
- en: 6.4 Advantages of the graph approach
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 图形方法的优点
- en: In this chapter, we’ve discussed how to create a session-based recommendation
    engine that uses a nearest neighbor approach. The proposed solutions are well
    suited to a graph representation of the data, which provides the right indexing
    structure for speeding the recommendation process. Moreover, the different optimizations
    can use a graph approach to optimize computation and accuracy. Specifically, the
    main aspects and advantages of the graph-based approach to session-based recommendation
    engines implemented using nearest neighbor methods are
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何创建一个使用最近邻方法的基于会话的推荐引擎。所提出的解决方案非常适合数据图表示，它为加快推荐过程提供了正确的索引结构。此外，不同的优化可以使用图方法来优化计算和准确性。具体来说，基于图的方法在实现最近邻方法的基于会话的推荐引擎中的主要方面和优势是
- en: The events chain, such as the order of clicks in a session, is easily represented
    in a graph model.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件链，如会话中点击的顺序，在图模型中容易表示。
- en: Graphs make it easy to access the events in order and focus on the more recent
    events, discarding or discounting older events and sessions, simplifying implementation
    of the deletion policy.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表使得按顺序访问事件变得容易，可以专注于最近的事件，同时丢弃或降低旧事件和会话的优先级，从而简化删除策略的实施。
- en: The graph provides the necessary flexibility to add item metadata that is relevant
    for some algorithms, such as CNNs [Tuan and Phuong, 2017].
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表提供了必要的灵活性，可以添加与某些算法（如CNNs）相关的项目元数据 [Tuan and Phuong, 2017]。
- en: During the recommendation process, specifically for the algorithms described
    in this chapter, graphs provide a natural indexing structure that enables us to
    access the relevant information faster. In non-graph-based approaches, it is often
    necessary to create indexing and other caching data structures to speed the recommendation
    process. Graphs provide all the data access patterns required by the algorithm,
    reducing the need for other tools.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推荐过程中，特别是对于本章中描述的算法，图表提供了一个自然的索引结构，使我们能够更快地访问相关信息。在非图方法中，通常需要创建索引和其他缓存数据结构以加快推荐过程。图表为算法提供了所需的所有数据访问模式，减少了其他工具的需求。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented session-based recommendation engines. The various data
    models show how the flexibility of graphs enables them to satisfy many needs in
    terms of training data and model storage. In this chapter, you learned
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了基于会话的推荐引擎。各种数据模型展示了图表的灵活性如何满足在训练数据和模型存储方面的许多需求。在本章中，你学习了
- en: How to implement a recommendation engine when the users are largely anonymous,
    using a session-based approach
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户大多匿名时，如何使用基于会话的方法实现推荐引擎
- en: How to model the training data and the models for the session-based approach
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对基于会话的方法进行训练数据和模型建模
- en: How to use different approaches for providing recommendations by using session
    data
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用不同的方法通过会话数据提供推荐
- en: How to optimize the k-NN computation by using different techniques, such as
    LSH
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用不同的技术（如LSH）优化 k-NN 计算
- en: References
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Bonnin and Jannach, 2014] Bonnin, Geoffray, and Dietmar Jannach. “Automated
    Generation of Music Playlists: Survey and Experiments.” *ACM Computing Surveys*
    47:2 (2014): Article 26.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bonnin and Jannach, 2014] Bonnin, Geoffray, and Dietmar Jannach. “Automated
    Generation of Music Playlists: Survey and Experiments.” *ACM Computing Surveys*
    47:2 (2014): Article 26.'
- en: '[Davidson et al., 2010] Davidson, James, Benjamin Liebald, Junning Liu, Palash
    Nandy, Taylor Van Vleet, Ullas Gargi, Sujoy Gupta, Yu He, Mike Lambert, Blake
    Livingston, and Dasarathi Sampath. “The YouTube Video Recommendation System.”
    *Proceedings of the 4th ACM Conference on Recommender Systems* (2010): 293-296.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[Davidson et al., 2010] Davidson, James, Benjamin Liebald, Junning Liu, Palash
    Nandy, Taylor Van Vleet, Ullas Gargi, Sujoy Gupta, Yu He, Mike Lambert, Blake
    Livingston, 和 Dasarathi Sampath. “YouTube视频推荐系统。” *第4届ACM推荐系统会议论文集* (2010): 293-296.'
- en: '[Devooght and Bersini, 2017] Devooght, Robin, and Hugues Bersini. “Long and
    Short-Term Recommendations with Recurrent Neural Networks.” *Proceedings of the
    25th Conference on User Modeling, Adaptation and Personalization* (2017): 13-21.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[Devooght and Bersini, 2017] Devooght, Robin, 和 Hugues Bersini. “基于循环神经网络的长期和短期推荐。”
    *第25届用户建模、自适应和个性化会议论文集* (2017): 13-21.'
- en: '[Goodfellow et al., 2016] Goodfellow, Ian, Yoshua Bengio, and Aaron Courville.
    2016\. *Deep Learning*. The MIT Press.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[Goodfellow et al., 2016] Goodfellow, Ian, Yoshua Bengio, 和 Aaron Courville.
    2016\. *深度学习*。麻省理工学院出版社。'
- en: '[Hariri et al., 2012] Hariri, Negar, Bamshad Mobasher, and Robin Burke. “Context-Aware
    Music Recommendation Based on Latent Topic Sequential Patterns.” *Proceedings
    of the 6th ACM Conference on Recommender Systems* (2012): 131-138.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[Hariri et al., 2012] Hariri, Negar, Bamshad Mobasher, 和 Robin Burke. “基于潜在主题序列模式的上下文感知音乐推荐。”
    *第6届ACM推荐系统会议论文集* (2012): 131-138.'
- en: '[Hidasi and Karatzoglou, 2018] Hidasi, Balázs, and Alexandros Karatzoglou.
    “Recurrent Neural Networks with Top-k Gains for Session-Based Recommendations.”
    *Proceedings of the 27th ACM International Conference on Information and Knowledge
    Management* (2018): 843-852.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[Hidasi and Karatzoglou, 2018] Hidasi, Balázs, 和 Alexandros Karatzoglou. “基于Top-k增益的会话推荐循环神经网络。”
    *第27届ACM国际信息与知识管理会议论文集* (2018): 843-852.'
- en: '[Hidasi et al., 2016 a] Hidasi, Balázs, Alexandros Karatzoglou, Linas Baltrunas,
    and Domonkos Tikk. “Session-Based Recommendations with Recurrent Neural Networks.”
    *Proceedings of the 4th International Conference on Learning Representations*
    (2016).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[Hidasi et al., 2016 a] Hidasi, Balázs, Alexandros Karatzoglou, Linas Baltrunas,
    和 Domonkos Tikk. “基于循环神经网络的会话推荐。” *第4届国际学习表示会议论文集* (2016).'
- en: '[Hidasi et al., 2016 b] Hidasi, Balázs, Massimo Quadrana, Alexandros Karatzoglou,
    and Domonkos Tikk. “Parallel Recurrent Neural Network Architectures for Feature-Rich
    Session-Based Recommendations.” *Proceedings of the 10th ACM Conference on Recommender
    Systems* (2016): 241-248.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[Hidasi et al., 2016 b] Hidasi, Balázs, Massimo Quadrana, Alexandros Karatzoglou,
    和 Domonkos Tikk. “用于特征丰富会话推荐的并行循环神经网络架构。” *第10届ACM推荐系统会议论文集* (2016): 241-248.'
- en: '[Jannach and Ludewig, 2017 a] Jannach, Dietmar, and Malte Ludewig. “When Recurrent
    Neural Networks Meet the Neighborhood for Session-Based Recommendation.” *Proceedings
    of the 11th ACM Conference on Recommender Systems* (2017): 306-310.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jannach and Ludewig, 2017 a] Jannach, Dietmar, 和 Malte Ludewig. “循环神经网络与邻域在会话推荐中的应用。”
    *第11届ACM推荐系统会议论文集* (2017): 306-310.'
- en: '[Jannach and Ludewig, 2017 b] Jannach, Dietmar, and Malte Ludewig. “Determining
    Characteristics of Successful Recommendations from Log Data: A Case Study.” *Proceedings
    of the Symposium on Applied Computing* (2017): 1643-1648.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jannach and Ludewig, 2017 b] Jannach, Dietmar, 和 Malte Ludewig. “从日志数据中确定成功推荐的特性：一个案例研究。”
    *应用计算研讨会论文集* (2017): 1643-1648.'
- en: '[Kamehkhosh et al., 2017] Kamehkhosh, Iman, Dietmar Jannach, and Malte Ludewig.
    “A Comparison of Frequent Pattern Techniques and a Deep Learning Method for Session-Based
    Recommendation.” *Proceedings of the 1st Workshop on Temporal Reasoning in Recommender
    Systems* (2017): 50-56.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kamehkhosh et al., 2017] Kamehkhosh, Iman, Dietmar Jannach, 和 Malte Ludewig.
    “基于频繁模式技术和深度学习方法的会话推荐比较。” *第1届推荐系统时间推理研讨会论文集* (2017): 50-56.'
- en: '[Lerche et al., 2016] Lerche, Lukas, Dietmar Jannach, and Malte Ludewig. “On
    the Value of Reminders Within E-Commerce Recommendations.” *Proceedings of the
    24th Conference on User Modeling, Adaptation and Personalization* (2016): 27-35.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[Lerche et al., 2016] Lerche, Lukas, Dietmar Jannach, 和 Malte Ludewig. “电子商务推荐中提醒的价值。”
    *第24届用户建模、自适应和个性化会议论文集* (2016): 27-35.'
- en: '[Linden et al., 2003] Linden, Greg, Brent Smith, and Jeremy York. “Amazon.com
    Recommendations: Item-to-Item Collaborative Filtering.” *IEEE Internet Computing*
    7:1 (2003): 76-80.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[Linden et al., 2003] Linden, Greg, Brent Smith, 和 Jeremy York. “Amazon.com推荐：物品到物品的协同过滤。”
    *IEEE互联网计算* 7:1 (2003): 76-80.'
- en: '[Ludewig and Jannach, 2018] Ludewig, Malte, and Dietmar Jannach. “Evaluation
    of Session-Based Recommendation Algorithms.” arXiv preprint arXiv:1803.09587 (2018).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ludewig and Jannach, 2018] Ludewig, Malte, and Dietmar Jannach. “基于会话的推荐算法评估。”
    arXiv预印本 arXiv:1803.09587（2018年）。'
- en: '[Quadrana, 2017] Quadrana, Massimo. “Algorithms for Sequence-Aware Recommender
    Systems.” PhD dissertation, Politecnico di Milano (2017).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quadrana, 2017] Quadrana, Massimo. “序列感知推荐系统的算法。” 博士学位论文，米兰理工大学（2017年）。'
- en: '[Quadrana et al., 2017] Quadrana, Massimo, Alexandros Karatzoglou, Balázs Hidasi,
    and Paolo Cremonesi. “Personalizing Session-Based Recommendations with Hierarchical
    Recurrent Neural Networks.” *Proceedings of the 11th ACM Conference on Recommender
    Systems* (2017): 130-137.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quadrana et al., 2017] Quadrana, Massimo, Alexandros Karatzoglou, Balázs Hidasi,
    and Paolo Cremonesi. “使用分层循环神经网络进行基于会话的推荐个性化。” *第11届ACM推荐系统会议论文集*（2017年）：130-137。'
- en: '[Quadrana et al., 2018] Quadrana, Massimo, Paolo Cremonesi, and Dietmar Jannach.
    “Sequence-Aware Recommender Systems.” *ACM Computing Surveys* 51:4 (2018): Article
    66.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[Quadrana et al., 2018] Quadrana, Massimo, Paolo Cremonesi, and Dietmar Jannach.
    “序列感知推荐系统。” *ACM计算评论* 51:4（2018年）：文章66。'
- en: '[Tan et al., 2016] Tan, Yong Kiam, Xinxing Xu, and Yong Liu. “Improved Recurrent
    Neural Networks for Session-Based Recommendations.” *Proceedings of the 1st Workshop
    on Deep Learning for Recommender Systems* (2016): 17-22.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tan et al., 2016] Tan, Yong Kiam, Xinxing Xu, and Yong Liu. “用于基于会话推荐的改进循环神经网络。”
    *第1届深度学习推荐系统研讨会论文集*（2016年）：17-22。'
- en: '[Tuan and Phuong, 2017] Tuan, Trinh Xuan, and Tu Minh Phuong. “3D Convolutional
    Networks for Session-Based Recommendation with Content Features.” *Proceedings
    of the 11th ACM Conference on Recommender Systems* (2017): 138-146.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tuan and Phuong, 2017] Tuan, Trinh Xuan, and Tu Minh Phuong. “具有内容特征的基于会话的推荐的三维卷积网络。”
    *第11届ACM推荐系统会议论文集*（2017年）：138-146。'
- en: '[Ullman and Rajaraman, 2011] Ullman, Jeffrey David, and Anand Rajaraman. *Mining
    of Massive Datasets*. Cambridge, UK: Cambridge University Press, 2011.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ullman and Rajaraman, 2011] Ullman, Jeffrey David, and Anand Rajaraman. *大规模数据集挖掘*.
    英国剑桥：剑桥大学出版社，2011年。'
- en: '[Verstrepen and Goethals, 2014] Verstrepen, Koen, and Bart Goethals. “Unifying
    Nearest Neighbors Collaborative Filtering.” *Proceedings of the 8th ACM Conference
    on Recommender Systems* (2014): 177-184.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[Verstrepen and Goethals, 2014] Verstrepen, Koen, and Bart Goethals. “统一最近邻协同过滤。”
    *第8届ACM推荐系统会议论文集*（2014年）：177-184。'
- en: '* * *'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)RNNs are distributed real-valued hidden state models with nonlinear dynamics.
    At each time step, the hidden state of the RNN is computed from the current input
    in the sequence and the hidden state from the previous step. Then the hidden state
    is used to predict the probability of the next items in the sequence. The recurrent
    feedback mechanism memorizes the influence of each past data sample in the hidden
    state of the RNN, overcoming the fundamental limitation of Markov chains. Therefore,
    RNNs are well suited to modeling the complex dynamics in user action sequences
    [Quadrana et al., 2017].
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1.）循环神经网络（RNNs）是具有非线性动力学的分布式实值隐藏状态模型。在每个时间步，RNN的隐藏状态是从序列中的当前输入和前一步的隐藏状态计算得出的。然后，隐藏状态用于预测序列中下一个项目的概率。循环反馈机制在RNN的隐藏状态中记住每个过去数据样本的影响，克服了马尔可夫链的基本限制。因此，RNN非常适合模拟用户动作序列中的复杂动态[Quadrana
    et al., 2017]。
- en: ^(2.)[https://recsys.acm.org/recsys15/challenge](https://recsys.acm.org/recsys15/challenge).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2.）[https://recsys.acm.org/recsys15/challenge](https://recsys.acm.org/recsys15/challenge)。
- en: ^(3.)CNNs are neural networks specialized for processing data that has a known
    gridlike topology, such as a User-Item matrix or time-series data that can be
    modeled as a one-dimensional matrix. The name *convolutional* derives from the
    mathematical linear operation, convolution, used in the neural network in place
    of the general matrix multiplication in at least one of their layers [Goodfellow
    et al., 2016].
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^（3.）卷积神经网络（CNNs）是专门用于处理具有已知网格拓扑结构的数据的神经网络，例如用户-物品矩阵或可以建模为一维矩阵的时间序列数据。名称“卷积”来自神经网络中使用的数学线性运算，卷积，它至少在它们的层中替代了通用的矩阵乘法[Goodfellow
    et al., 2016]。
- en: ^(4.)[https://scikit-learn.org](https://scikit-learn.org/).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^（4.）[https://scikit-learn.org](https://scikit-learn.org/)。
- en: ^(5.)[https://spark.apache.org](https://spark.apache.org/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^（5.）[https://spark.apache.org](https://spark.apache.org/)。
- en: ^(6.)[https://flink.apache.org](https://flink.apache.org/).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^（6.）[https://flink.apache.org](https://flink.apache.org/)。
- en: ^(7.)[https://github.com/spotify/annoy](https://github.com/spotify/annoy).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^（7.）[https://github.com/spotify/annoy](https://github.com/spotify/annoy)。
