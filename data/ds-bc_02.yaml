- en: 1 Computing probabilities using Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 使用Python计算概率
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: What are the basics of probability theory?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率论的基本原理是什么？
- en: Computing probabilities of a single observation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单个观察的概率
- en: Computing probabilities across a range of observations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一系列观察中计算概率
- en: Few things in life are certain; most things are driven by chance. Whenever we
    cheer for our favorite sports team, or purchase a lottery ticket, or make an investment
    in the stock market, we hope for some particular outcome, but that outcome cannot
    ever be guaranteed. Randomness permeates our day-to-day experiences. Fortunately,
    that randomness can still be mitigated and controlled. We know that some unpredictable
    events occur more rarely than others and that certain decisions carry less uncertainty
    than other much-riskier choices. Driving to work in a car is safer than riding
    a motorcycle. Investing part of your savings in a retirement account is safer
    than betting it all on a single hand of blackjack. We can intrinsically sense
    these trade-offs in certainty because even the most unpredictable systems still
    show some predictable behaviors. These behaviors have been rigorously studied
    using *probability theory*. Probability theory is an inherently complex branch
    of math. However, aspects of the theory can be understood without knowing the
    mathematical underpinnings. In fact, difficult probability problems can be solved
    in Python without needing to know a single math equation. Such an equation-free
    approach to probability requires a baseline understanding of what mathematicians
    call a *sample space*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 生活中很少有事情是确定的；大多数事情都是由机会驱动的。无论何时我们为我们的最喜欢的运动队欢呼，或者购买彩票，或者在股市中进行投资，我们都希望得到某种特定的结果，但这个结果永远不能得到保证。随机性渗透到我们的日常生活中。幸运的是，这种随机性仍然可以减轻和控制。我们知道某些不可预测的事件发生的频率比其他事件低，而且某些决策的不确定性比其他风险更高的选择要小。开车上班比骑摩托车安全。将部分储蓄投资到退休账户比将所有筹码都押在一手黑杰克上要安全。我们可以本能地感觉到这些确定性的权衡，因为即使是最不可预测的系统仍然显示出一些可预测的行为。这些行为已经通过**概率论**进行了严格的研究。概率论是数学的一个本质上复杂的分支。然而，理论的一些方面可以在不了解数学基础的情况下理解。事实上，复杂的概率问题可以在Python中解决，而不需要知道任何数学方程。这种无方程式的方法需要了解数学家所说的**样本空间**的基础知识。
- en: '1.1 Sample space analysis: An equation-free approach for measuring uncertainty
    in outcomes'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 样本空间分析：一种无需方程式的方法来衡量结果的不确定性
- en: 'Certain actions have measurable outcomes. A *sample space* is the set of all
    the possible outcomes an action could produce. Let’s take the simple action of
    flipping a coin. The coin will land on either heads or tails. Thus, the coin flip
    will produce one of two measurable outcomes: *heads* or *tails*. By storing these
    outcomes in a Python set, we can create a sample space of coin flips.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 某些行为会产生可衡量的结果。**样本空间**是指一个行为可能产生的所有可能结果的集合。让我们以抛硬币这个简单的行为为例。硬币将落在正面或反面。因此，抛硬币将产生两种可衡量的结果：**正面**或**反面**。通过将这些结果存储在Python集合中，我们可以创建一个抛硬币的样本空间。
- en: Listing 1.1 Creating a sample space of coin flips
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 创建抛硬币的样本空间
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Storing elements in curly brackets creates a Python set. A Python set is a
    collection of unique, unordered elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用花括号存储元素创建Python集合。Python集合是一组唯一的、无序的元素集合。
- en: Suppose we choose an element of `sample_space` at random. What fraction of the
    time will the chosen element equal `Heads`? Well, our sample space holds two possible
    elements. Each element occupies an equal fraction of the space within the set.
    Therefore, we expect `Heads` to be selected with a frequency of 1/2\. That frequency
    is formally defined as the *probability* of an outcome. All outcomes within `sample_space`
    share an identical probability, which is equal to `1 / len(sample_space)`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们随机选择`sample_space`中的一个元素。所选元素等于`正面`的频率是多少？我们的样本空间包含两个可能的元素。每个元素在集合内的空间中占据相等的比例。因此，我们预计正面将以1/2的频率被选中。这个频率正式定义为结果**概率**。`sample_space`中的所有结果都具有相同的概率，该概率等于`1
    / len(sample_space)`。
- en: Listing 1.2 Computing the probability of heads
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2 计算正面的概率
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The probability of choosing `Heads` equals 0.5\. This relates directly to the
    action of flipping a coin. We’ll assume the coin is unbiased, which means the
    coin is equally likely to fall on either heads or tails. Thus, a coin flip is
    conceptually equivalent to choosing a random element from `sample_space`. The
    probability of the coin landing on heads is therefore 0.5; the probability of
    it landing on tails is also equal to 0.5.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `正面` 的概率等于 0.5。这直接关系到抛硬币的动作。我们假设硬币是不偏不倚的，这意味着硬币落在正面或反面是同等可能的。因此，抛硬币在概念上等同于从
    `sample_space` 中选择一个随机元素。因此，硬币落在正面的概率是 0.5；它落在反面的概率也等于 0.5。
- en: We’ve assigned probabilities to our two measurable outcomes. However, there
    are additional questions we could ask. What is the probability that the coin lands
    on either heads or tails? Or, more exotically, what is the probability that the
    coin will spin forever in the air, landing on neither heads nor tails? To find
    rigorous answers, we need to define the concept of an *event*. An event is the
    subset of those elements within `sample_space` that satisfy some *event condition*
    (as shown in figure 1.1). An event condition is a simple Boolean function whose
    input is a single `sample_space` element. The function returns `True` only if
    the element satisfies our condition constraints.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们两个可测量的结果分配了概率。然而，我们还可以提出其他问题。硬币落在正面或反面的概率是多少？或者，更奇特的是，硬币在空中旋转永远不落在正面或反面的概率是多少？为了找到严格的答案，我们需要定义事件的定义。事件是
    `sample_space` 中满足某些 *事件条件*（如图 1.1 所示）的元素子集。事件条件是一个简单的布尔函数，其输入是一个单个 `sample_space`
    元素。该函数仅在元素满足我们的条件约束时返回 `True`。
- en: '![](../Images/01-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01-01.png)'
- en: 'Figure 1.1 Four event conditions applied to a sample space. The sample space
    contains two outcomes: heads and tails. Arrows represent the event conditions.
    Every event condition is a yes-or-no function. Each function filters out those
    outcomes that do not satisfy its terms. The remaining outcomes form an event.
    Each event contains a subset of the outcomes found in the sample space. Four events
    are possible: heads, tails, heads or tails, and neither heads nor tails.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 将四个事件条件应用于样本空间。样本空间包含两个结果：正面和反面。箭头代表事件条件。每个事件条件都是一个是或否函数。每个函数过滤掉那些不满足其条款的结果。剩余的结果形成一个事件。每个事件包含样本空间中找到的结果的子集。可能存在四个事件：正面、反面、正面或反面，以及既不是正面也不是反面。
- en: 'Let’s define two event conditions: one where the coin lands on either heads
    or tails, and another where the coin lands on neither heads nor tails.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个事件条件：一个硬币落在正面或反面，另一个硬币既不落在正面也不落在反面。
- en: Listing 1.3 Defining event conditions
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 定义事件条件
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Also, for the sake of completeness, let’s define event conditions for the two
    basic events in which the coin satisfies exactly one of our two potential outcomes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了完整性，让我们为满足我们两个潜在结果之一的基本事件定义事件条件。
- en: Listing 1.4 Defining additional event conditions
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 定义附加事件条件
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can pass event conditions into a generalized `get_matching_event` function.
    That function is defined in listing 1.5\. Its inputs are an event condition and
    a generic sample space. The function iterates through the generic sample space
    and returns the set of outcomes where `event_condition(outcome)` is `True`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将事件条件传递给一个通用的 `get_matching_event` 函数。该函数在列表 1.5 中定义。其输入是一个事件条件和通用样本空间。该函数遍历通用样本空间，并返回满足
    `event_condition(outcome)` 为 `True` 的结果集。
- en: Listing 1.5 Defining an event-detection function
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 定义事件检测函数
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let’s execute `get_matching_event` on our four event conditions. Then we’ll
    output the four extracted events.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的四个事件条件上执行 `get_matching_event`。然后我们将输出四个提取的事件。
- en: Listing 1.6 Detecting events using event conditions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 使用事件条件检测事件
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Prints the name of an event_condition function
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印事件条件函数的名称
- en: We’ve successfully extracted four events from `sample_space`. What is the probability
    of each event occurring? Earlier, we showed that the probability of a single-element
    outcome for a fair coin is `1 / len(sample_space)`. This property can be generalized
    to include multi-element events. The probability of an event is equal to `len(event)
    / len(sample_space)`, but only if all outcomes are known to occur with equal likelihood.
    In other words, the probability of a multi-element event for a fair coin is equal
    to the event size divided by the sample space size. We now use event size to compute
    the four event probabilities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功从 `sample_space` 中提取了四个事件。每个事件发生的概率是多少？之前我们展示了公平硬币单个元素结果的概率是 `1 / len(sample_space)`。这个性质可以推广到多元素事件。事件的概率等于
    `len(event) / len(sample_space)`，但前提是所有结果都以相同的可能性发生。换句话说，公平硬币的多元素事件的概率等于事件大小除以样本空间大小。我们现在使用事件大小来计算四个事件的概率。
- en: Listing 1.7 Computing event probabilities
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.7 计算事件概率
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The compute_probability function extracts the event associated with an inputted
    event condition to compute its probability.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `compute_probability` 函数提取与输入事件条件相关的事件以计算其概率。
- en: ❷ Probability is equal to event size divided by sample space size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 概率等于事件大小除以样本空间大小。
- en: The executed code outputs a diverse range of event probabilities, the smallest
    of which is 0.0 and the largest of which is 1.0\. These values represent the lower
    and upper bounds of probability; no probability can ever fall below 0.0 or rise
    above 1.0.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的代码输出了各种事件概率，最小值为 0.0，最大值为 1.0。这些值代表概率的下限和上限；没有任何概率会低于 0.0 或高于 1.0。
- en: 1.1.1 Analyzing a biased coin
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 分析有偏硬币
- en: We computed probabilities for an unbiased coin. What would happen if that coin
    was biased? Suppose, for instance, that a coin is four times more likely to land
    on heads relative to tails. How do we compute the likelihoods of outcomes that
    are not weighted in an equal manner? Well, we can construct a weighted sample
    space represented by a Python dictionary. Each outcome is treated as a key whose
    value maps to the associated weight. In our example, `Heads` is weighted four
    times as heavily as `Tails`, so we map `Tails` to `1` and `Heads` to `4`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了一个无偏硬币的概率。如果这个硬币是有偏的，会发生什么？例如，假设一个硬币相对于尾巴落在头部的可能性是四倍。我们如何计算那些不以相等方式加权的结果的概率？嗯，我们可以构建一个由
    Python 字典表示的加权样本空间。每个结果被视为一个键，其值映射到相关的权重。在我们的例子中，`Heads` 的权重是 `Tails` 的四倍，所以我们把
    `Tails` 映射到 `1`，把 `Heads` 映射到 `4`。
- en: Listing 1.8 Representing a weighted sample space
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.8 表示加权样本空间
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our new sample space is stored in a dictionary. This allows us to redefine the
    size of the sample space as the sum of all dictionary weights. Within `weighted_sample_
    space`, that sum will equal 5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新样本空间存储在字典中。这允许我们将样本空间的大小重新定义为所有字典权重的总和。在 `weighted_sample_space` 中，这个总和将是
    5。
- en: Listing 1.9 Checking the weighted sample space size
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.9 检查加权样本空间大小
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can redefine event size in a similar manner. Each event is a set of outcomes,
    and those outcomes map to weights. Summing over the weights yields the event size.
    Thus, the size of the event satisfying the `is_heads_or_tails` event condition
    is also 5.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式重新定义事件大小。每个事件是一组结果，这些结果映射到权重。对权重求和得到事件大小。因此，满足 `is_heads_or_tails`
    事件条件的事件大小也是 5。
- en: Listing 1.10 Checking the weighted event size
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.10 检查加权事件大小
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ As a reminder, this function iterates over each outcome in the inputted sample
    space. Thus, it will work as expected on our dictionary input. This is because
    Python iterates over dictionary keys, not key-value pairs as in many other popular
    programming languages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，这个函数遍历输入样本空间中的每个结果。因此，它将在我们的字典输入上按预期工作。这是因为 Python 遍历字典键，而不是像许多其他流行编程语言中的键值对。
- en: Our generalized definitions of sample space size and event size permit us to
    create a `compute_event_probability` function. The function takes as input a `generic_sample_
    space` variable that can be either a weighted dictionary or an unweighted set.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对样本空间大小和事件大小的推广定义使我们能够创建一个 `compute_event_probability` 函数。该函数接受一个 `generic_sample_space`
    变量作为输入，该变量可以是加权字典或无加权集合。
- en: Listing 1.11 Defining a generalized event probability function
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.11 定义一个推广的事件概率函数
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Checks whether generic_event_space is a set
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查 generic_event_space 是否为集合
- en: We can now output all the event probabilities for the biased coin without needing
    to redefine our four event condition functions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以输出所有偏硬币的事件概率，而无需重新定义我们的四个事件条件函数。
- en: Listing 1.12 Computing weighted event probabilities
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.12 计算加权事件概率
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With just a few lines of code, we have constructed a tool for solving many problems
    in probability. Let’s apply this tool to problems more complex than a simple coin
    flip.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码，我们就构建了一个用于解决概率中许多问题的工具。让我们将这个工具应用于比简单抛硬币更复杂的问题。
- en: 1.2 Computing nontrivial probabilities
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 计算非平凡概率
- en: We’ll now solve several example problems using `compute_event_probability`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `compute_event_probability` 解决几个示例问题。
- en: '1.2.1 Problem 1: Analyzing a family with four children'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 问题 1：分析一个有四个孩子的家庭
- en: Suppose a family has four children. What is the probability that exactly two
    of the children are boys? We’ll assume that each child is equally likely to be
    either a boy or a girl. Thus we can construct an unweighted sample space where
    each outcome represents one possible sequence of four children, as shown in figure
    1.2.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个家庭有四个孩子。恰好有两个孩子是男孩的概率是多少？我们将假设每个孩子成为男孩或女孩的可能性是相等的。因此，我们可以构建一个无权样本空间，其中每个结果代表四个孩子的一种可能的序列，如图
    1.2 所示。
- en: '![](../Images/01-02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/01-02.png)'
- en: 'Figure 1.2 The sample space for four sibling children. Each row in the sample
    space contains 1 of 16 possible outcomes. Every outcome represents a unique combination
    of four children. The sex of each child is indicated by a letter: B for boy and
    G for girl. Outcomes with two boys are marked by an arrow. There are six such
    arrows; thus, the probability of two boys equals 6 / 16.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 四个兄弟姐妹的样本空间。样本空间中的每一行包含 16 种可能结果中的 1 种。每个结果代表四个孩子的唯一组合。每个孩子的性别由一个字母表示：B
    代表男孩，G 代表女孩。有两个男孩的结果用箭头标记。有六个这样的箭头；因此，有两个男孩的概率等于 6 / 16。
- en: Listing 1.13 Computing the sample space of children
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.13 计算孩子的样本空间
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Each possible sequence of four children is represented by a four-element tuple.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个四个孩子的可能序列由一个四元素元组表示。
- en: We ran four nested `for` loops to explore the sequence of four births. This
    is not an efficient use of code. We can more easily generate our sample space
    using Python’s built-in `itertools.product` function, which returns all pairwise
    combinations of all elements across all input lists. Next, we input four instances
    of the `possible_children` list into `itertools.product`. The product function
    then iterates over all four instances of the list, computing all the combinations
    of list elements. The final output equals our sample space.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了四个嵌套的 `for` 循环来探索四个出生的序列。这不是代码的高效使用。我们可以更轻松地使用 Python 内置的 `itertools.product`
    函数来生成我们的样本空间，该函数返回所有输入列表中所有元素的成对组合。接下来，我们将四个 `possible_children` 列表的实例输入到 `itertools.product`
    中。然后，乘积函数遍历列表的所有四个实例，计算列表元素的组合。最终输出等于我们的样本空间。
- en: Listing 1.14 Computing the sample space using `product`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.14 使用 `product` 计算样本空间
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The * operator unpacks multiple arguments stored within a list. These arguments
    are then passed into a specified function. Thus, calling product(*(4 * [possible_children]))
    is equivalent to calling product(possible_children, possible_children, possible_children,
    possible_children).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 星号运算符 (`*`) 解包存储在列表中的多个参数。然后，这些参数被传递到指定的函数中。因此，调用 `product(*(4 * [possible_children]))`
    等同于调用 `product(possible_children, possible_children, possible_children, possible_children)`。
- en: ❷ Note that after running this line, all_combinations will be empty. This is
    because product returns a Python iterator, which can be iterated over only once.
    For us, this isn’t an issue. We are about to compute the sample space even more
    efficiently, and all_combinations will not be use in future code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注意，运行此行后，all_combinations 将为空。这是因为乘积返回一个 Python 迭代器，它只能迭代一次。对我们来说，这不是问题。我们即将更高效地计算样本空间，并且
    all_combinations 不会在未来的代码中使用。
- en: We can make our code even more efficient by executing `set(product(possible_
    children, repeat=4))`. In general, running `product(possible_children, repeat=n)`
    returns an iterable over all possible combinations of `n` children.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行 `set(product(possible_children, repeat=4))`，我们可以使我们的代码更加高效。一般来说，运行 `product(possible_children,
    repeat=n)` 返回一个关于 `n` 个孩子所有可能组合的可迭代对象。
- en: Listing 1.15 Passing `repeat` into `product`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.15 将 `repeat` 传递给 `product`
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s calculate the fraction of `sample_space` that is composed of families
    with two boys. We define a `has_two_boys` event condition and then pass that condition
    into `compute_event_probability`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算 `sample_space` 中由有两个男孩的家庭组成的比例。我们定义一个 `has_two_boys` 事件条件，然后将其传递给 `compute_event_probability`。
- en: Listing 1.16 Computing the probability of two boys
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.16 计算两个男孩的概率
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The probability of exactly two boys being born in a family of four children
    is 0.375\. By implication, we expect 37.5% of families with four children to contain
    an equal number of boys and girls. Of course, the actual observed percentage of
    families with two boys will vary due to random chance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有四个孩子的家庭中，恰好有两个男孩出生的概率是0.375。由此推断，我们预计有37.5%的四个孩子的家庭将包含相等数量的男孩和女孩。当然，实际观察到的有两个男孩的家庭百分比将因随机机会而有所不同。
- en: '1.2.2 Problem 2: Analyzing multiple die rolls'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 问题2：分析多次掷骰子
- en: Suppose we’re shown a fair six-sided die whose faces are numbered from 1 to
    6\. The die is rolled six times. What is the probability that these six die rolls
    add up to 21?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们展示了一个公平的六面骰子，其面值从1到6。骰子被掷了六次。这六个掷骰子的总和为21的概率是多少？
- en: We begin by defining the possible values of any single roll. These are integers
    that range from 1 to 6.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义任何单次掷骰子的可能值。这些是介于1到6之间的整数。
- en: Listing 1.17 Defining all possible rolls of a six-sided die
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.17 定义六面骰子的所有可能掷法
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we create the sample space for six consecutive rolls using the `product`
    function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `product` 函数创建六次连续掷骰子的样本空间。
- en: Listing 1.18 Sample space for six consecutive die rolls
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.18 六次连续掷骰子的样本空间
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we define a `has_sum_of_21` event condition that we’ll subsequently
    pass into `compute_event_probability`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个 `has_sum_of_21` 事件条件，然后将其传递给 `compute_event_probability`。
- en: Listing 1.19 Computing the probability of a die-roll sum
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.19 计算掷骰子总和的概率
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Conceptually, rolling a single die six times is equivalent to rolling six
    dice simultaneously.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从概念上讲，掷一个骰子六次等同于同时掷六个骰子。
- en: The six die rolls will sum to 21 more than 9% of the time. Note that our analysis
    can be coded more concisely using a lambda expression. *Lambda expressions* are
    one-line anonymous functions that do not require a name. In this book, we use
    lambda expressions to pass short functions into other functions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 六次掷骰子的总和为21的概率超过9%。请注意，我们的分析可以使用lambda表达式更简洁地编码。*Lambda表达式* 是一行匿名函数，不需要名称。在这本书中，我们使用lambda表达式将简短函数传递给其他函数。
- en: Listing 1.20 Computing the probability using a lambda expression
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.20 使用lambda表达式计算概率
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '❶ Lambda expressions allow us to define short functions in a single line of
    code. Coding lambda x: is functionally equivalent to coding func(x):. Thus, lambda
    x: sum(x) == 21 is functionally equivalent to has_sum_of_21\.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ Lambda表达式允许我们在一行代码中定义简短函数。编码 lambda x: 等同于编码 func(x):。因此，lambda x: sum(x)
    == 21 等同于 has_sum_of_21\。'
- en: '1.2.3 Problem 3: Computing die-roll probabilities using weighted sample spaces'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 问题3：使用加权样本空间计算掷骰子概率
- en: We’ve just computed the likelihood of six die rolls summing to 21\. Now, let’s
    recompute that probability using a weighted sample space. We need to convert our
    unweighted sample space set into a weighted sample space dictionary; this will
    require us to identify all possible die-roll sums. Then we must count the number
    of times each sum appears across all possible die-roll combinations. These combinations
    are already stored in our computed `sample_space` set. By mapping the die-roll
    sums to their occurrence counts, we will produce a `weighted_sample_space` result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚计算了六次掷骰子总和为21的概率。现在，让我们使用加权样本空间重新计算这个概率。我们需要将我们的未加权样本空间集合转换为加权样本空间字典；这需要我们识别所有可能的掷骰子总和。然后我们必须计算每个总和在所有可能的掷骰子组合中出现的次数。这些组合已经存储在我们的计算过的
    `sample_space` 集合中。通过将掷骰子总和映射到它们的出现次数，我们将产生一个 `weighted_sample_space` 结果。
- en: Listing 1.21 Mapping die-roll sums to occurrence counts
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.21 将掷骰子总和映射到出现次数
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ This module returns dictionaries whose keys are all assigned a default value.
    For instance, defaultdict(int) returns a dictionary where the default value for
    each key is set to zero.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此模块返回所有键都分配了默认值的字典。例如，defaultdict(int) 返回一个字典，其中每个键的默认值设置为零。
- en: ❷ The weighted_sample dictionary maps each summed six-die-roll combination to
    its occurrence count.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ weighted_sample 字典将每个总和的六次掷骰子组合映射到其出现次数。
- en: ❸ Each outcome contains a unique combination of six die rolls.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每个结果都包含六个掷骰子的唯一组合。
- en: ❹ Computes the summed value of six unique die rolls
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算六个独特骰子掷出的总和
- en: ❺ Updates the occurrence count for a summed dice value
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新求和骰子值的出现次数
- en: 'Before we recompute our probability, let’s briefly explore the properties of
    `weighted_ sample_space`. Not all weights in the sample space are equal—some of
    the weights are much smaller than others. For instance, there is only one way
    for the rolls to sum to 6: we must roll precisely six 1s to achieve that dice-sum
    combination. Hence, we expect `weighted_sample_space[6]` to equal 1\. We expect
    `weighted_sample_space[36]` to also equal 1, since we must roll six 6s to achieve
    a sum of 36.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重新计算概率之前，让我们简要地探讨一下`weighted_sample_space`的性质。样本空间中的所有权重并不相等——有些权重比其他权重小得多。例如，要使骰子点数之和为6，只有一种方式：必须恰好掷出六个1才能达到这种骰子点数组合。因此，我们预计`weighted_sample_space[6]`等于1。我们也预计`weighted_sample_space[36]`也等于1，因为我们必须掷出六个6才能达到总和36。
- en: Listing 1.22 Checking very rare die-roll combinations
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.22 检查非常罕见的掷骰子组合
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Meanwhile, the value of `weighted_sample_space[21]` is noticeably higher.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，`weighted_sample_space[21]`的值明显更高。
- en: Listing 1.23 Checking a more common die-roll combination
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.23 检查更常见的掷骰子组合
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the output shows, there are 4,332 ways for six die rolls to sum to 21\. For
    example, we could roll four 4s, followed by a 3 and then a 2\. Or we could roll
    three 4s followed by a 5, a 3, and a 1\. Thousands of other combinations are possible.
    This is why a sum of 21 is much more probable than a sum of 6.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，有4,332种方式可以使六个骰子掷出的点数之和为21。例如，我们可以掷出四个4，然后是一个3和一个2。或者我们可以掷出三个4，然后是一个5、一个3和一个1。还有成千上万的其他组合是可能的。这就是为什么21的和比6的和更可能的原因。
- en: Listing 1.24 Exploring different ways of summing to 21
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.24 探索不同的求和方式以得到21
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the observed count of 4,332 is equal to the length of an unweighted
    event whose die rolls add up to 21\. Also, the sum of values in `weighted_sample`
    is equal to the length of `sample_space`. Hence, a direct link exists between
    unweighted and weighted event probability computation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，观察到的4,332次出现次数等于掷骰子点数之和为21的未加权事件的长度。此外，`weighted_sample`中的值之和等于`sample_space`的长度。因此，未加权事件和加权事件概率计算之间存在直接联系。
- en: Listing 1.25 Comparing weighted events and regular events
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.25 比较加权事件和常规事件
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let’s now recompute the probability using the `weighted_sample_space` dictionary.
    The final probability of rolling a 21 should remain unchanged.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`weighted_sample_space`字典重新计算概率。掷出21的最终概率应该保持不变。
- en: Listing 1.26 Computing the weighted event probability of die rolls
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.26 计算掷骰子的加权事件概率
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What is the benefit of using a weighted sample space over an unweighted one?
    Less memory usage! As we see next, the unweighted `sample_space` set has on the
    order of 150 times more elements than the weighted sample space dictionary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加权样本空间而不是未加权样本空间的优点是什么？更少的内存使用！正如我们接下来要看到的，未加权的`sample_space`集合比加权样本空间字典多约150倍元素。
- en: Listing 1.27 Comparing weighted to unweighted event space size
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.27 比较加权与未加权事件空间大小
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 1.3 Computing probabilities over interval ranges
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 在区间范围内计算概率
- en: So far, we’ve only analyzed event conditions that satisfy some single value.
    Now we’ll analyze event conditions that span intervals of values. An *interval*
    is the set of all the numbers between and including two boundary cutoffs. Let’s
    define an `is_in_interval` function that checks whether a number falls within
    a specified interval. We’ll control the interval boundaries by passing a `minimum`
    and a `maximum` parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只分析了满足某个单一值的事件条件。现在我们将分析跨越数值区间的的事件条件。一个*区间*是介于两个边界截止点之间（包括这两个边界点）的所有数字的集合。让我们定义一个`is_in_interval`函数，该函数检查一个数字是否落在指定的区间内。我们将通过传递`minimum`和`maximum`参数来控制区间边界。
- en: Listing 1.28 Defining an interval function
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.28 定义区间函数
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Defines a closed interval in which the min/max boundaries are included. However,
    it’s also possible to define open intervals when needed. In open intervals, at
    least one of the boundaries is excluded.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个包含最小/最大边界的闭区间。然而，在需要时也可以定义开区间。在开区间中，至少有一个边界被排除。
- en: Given the `is_in_interval` function, we can compute the probability that an
    event’s associated value falls within some numeric range. For instance, let’s
    compute the likelihood that our six consecutive die rolls sum to a value between
    10 and 21 (inclusive).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`is_in_interval`函数，我们可以计算事件相关值落在某个数值范围内的概率。例如，让我们计算连续掷六个骰子点数之和在10到21（包括21）之间的可能性。
- en: Listing 1.29 Computing the probability over an interval
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.29 计算区间概率
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Lambda function that takes some input x and returns True if x falls in an
    interval between 10 and 21\. This one-line lambda function serves as our event
    condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个接受输入x并返回x是否落在10到21之间的区间的Lambda函数。这个单行Lambda函数作为我们的事件条件。
- en: The six die rolls will fall into that interval range more than 54% of the time.
    Thus, if a roll sum of 13 or 20 comes up, we should not be surprised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 六次骰子投掷中有超过54%的时间会落在该区间范围内。因此，如果出现13或20的点数总和，我们不应该感到惊讶。
- en: 1.3.1 Evaluating extremes using interval analysis
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 使用区间分析评估极端值
- en: 'Interval analysis is critical to solving a whole class of very important problems
    in probability and statistics. One such problem involves the evaluation of extremes:
    the problem boils down to whether observed data is too extreme to be believable.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 区间分析对于解决概率和统计学中一类非常重要的问题至关重要。这类问题之一涉及极端值的评估：这个问题归结为观察到的数据是否过于极端以至于不可信。
- en: 'Data seems extreme when it is too unusual to have occurred by random chance.
    For instance, suppose we observe 10 flips of an allegedly fair coin, and that
    coin lands on heads 8 out of 10 times. Is this a sensible result for a fair coin?
    Or is our coin secretly biased toward landing on heads? To find out, we must answer
    the following question: what is the probability that 10 fair coin flips lead to
    an extreme number of heads? We’ll define an extreme head count as eight heads
    or more. Thus, we can describe the problem as follows: what is the probability
    that 10 fair coin flips produce from 8 to 10 heads?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据过于不寻常，以至于不可能由随机机会发生时，数据看起来就极端。例如，假设我们观察到一个声称是公平的硬币的10次投掷，并且该硬币有8次落在正面。这是公平硬币的一个合理结果吗？或者我们的硬币是否秘密偏向于落在正面？为了找出答案，我们必须回答以下问题：10次公平硬币投掷导致极端数量的正面的概率是多少？我们将极端正面数定义为8个或更多。因此，我们可以将问题描述如下：10次公平硬币投掷产生8到10个正面的概率是多少？
- en: We’ll find our answer by computing an interval probability. However, first we
    need the sample space for every possible sequence of 10 flipped coins. Let’s generate
    a weighted sample space. As previously discussed, this is more efficient than
    using a non-weighted representation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过计算区间概率来找到答案。然而，首先我们需要每个可能的10次投掷硬币序列的样本空间。让我们生成一个加权的样本空间。如前所述，这比使用非加权表示更有效。
- en: The following code creates a `weighted_sample_space` dictionary. Its keys equal
    the total number of observable heads, ranging from 0 through 10\. These head counts
    map to values. Each value holds the number of coin-flip combinations that contain
    the associated head count. We thus expect `weighted_sample_space[10]` to equal
    1, since there is just one possible way to flip a coin 10 times and get 10 heads.
    Meanwhile, we expect `weighted_sample_space[9]` to equal 10, since a single tail
    among 9 heads can occur across 10 different positions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个`weighted_sample_space`字典。其键等于可观察到的总正面数，范围从0到10。这些正面数对应于值。每个值包含包含相关正面数的硬币投掷组合数。因此，我们预计`weighted_sample_space[10]`等于1，因为只有一种可能的方式连续投掷硬币10次并得到10个正面。同时，我们预计`weighted_sample_space[9]`等于10，因为在一个9个正面的组合中，一个反面可以出现在10个不同的位置。
- en: Listing 1.30 Computing the sample space for 10 coin flips
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.30 计算10次硬币投掷的样本空间
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ For reusability, we define a general function that returns a weighted sample
    space for num_flips coin flips. The num_flips parameter is preset to 10 coin flips.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为了可重用性，我们定义了一个通用函数，该函数返回num_flips次硬币投掷的加权样本空间。num_flips参数预设为10次硬币投掷。
- en: ❷ Number of heads in a unique sequence of num_flips coin flips
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在num_flips次硬币投掷的独特序列中正面的数量
- en: Our weighted sample space is ready. We now compute the probability of observing
    an interval from 8 to 10 heads.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了加权的样本空间。我们现在计算观察到一个从8到10个正面的区间的概率。
- en: Listing 1.31 Computing an extreme head-count probability
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.31 计算极端正面数的概率
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ten fair coin flips produce more than seven heads approximately 5% of the time.
    Our observed head count does not commonly occur. Does this mean the coin is biased?
    Not necessarily. We haven’t yet considered extreme tail counts. If we had observed
    eight tails and not eight heads, we would have still been suspicious of the coin.
    Our computed interval did not take this extreme into account—instead, we treated
    eight or more tails as just another normal possibility. To evaluate the fairness
    of our coin, we must include the likelihood of observing eight tails or more.
    This is equivalent to observing two heads or fewer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 抛掷十次公平的硬币，出现超过七个正面的情况大约有5%的时间。我们观察到的正面数量并不常见。这难道意味着硬币是偏的？不一定。我们还没有考虑极端的尾数。如果我们观察到八个尾数而不是八个正面，我们仍然会对硬币表示怀疑。我们计算出的区间没有考虑这种极端情况——相反，我们将八个或更多的尾数视为另一种正常可能性。为了评估硬币的公平性，我们必须包括观察到八个或更多尾数的可能性。这相当于观察到两个或更少的正面。
- en: 'Let’s formulate the problem as follows: what is the probability that 10 fair
    coin flips produce either 0 to 2 heads or 8 to 10 heads? Or, stated more concisely,
    what is the probability that the coin flips do *not* produce from 3 to 7 heads?
    That probability is computed here.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将问题表述如下：十次公平的硬币抛掷产生0到2个正面或8到10个正面的概率是多少？或者，更简洁地说，硬币抛掷不产生3到7个正面的概率是多少？这个概率在这里被计算出来。
- en: Listing 1.32 Computing an extreme interval probability
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.32 计算极端区间概率
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Ten fair coin flips produce at least eight identical results approximately 10%
    of the time. That probability is low but still within the realm of plausibility.
    Without additional evidence, it’s difficult to decide whether the coin is truly
    biased. So, let’s collect that evidence. Suppose we flip the coin 10 additional
    times, and 8 more heads come up. This brings us to 16 heads out of 20 coin flips
    total. Our confidence in the fairness of the coin has been reduced, but by how
    much? We can find out by measuring the change in probability. Let’s find the probability
    of 20 fair coin flips *not* producing from 5 to 15 heads.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 抛掷十次公平的硬币，至少出现八个相同结果的情况大约有10%的时间。这个概率很低，但仍在可接受的范围内。没有额外的证据，很难判断硬币是否真正偏斜。所以，让我们收集这些证据。假设我们再抛掷硬币十次，并且出现8个更多的正面。这使我们的总抛掷次数达到20次，其中正面数为16次。我们对硬币公平性的信心已经降低，但降低了多少？我们可以通过测量概率的变化来找出答案。让我们找出20次公平的硬币抛掷不产生5到15个正面的概率。
- en: Listing 1.33 Analyzing extreme head counts for 20 fair coin flips
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.33 分析20次公平硬币抛掷的极端正面计数
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The updated probability has dropped from approximately 0.1 to approximately
    0.01\. Thus, the added evidence has caused a tenfold decrease in our confidence
    in the coin’s fairness. Despite this probability drop, the ratio of heads to tails
    has remained constant at 4 to 1\. Both our original and updated experiments produced
    80% heads and 20% tails. This leads to an interesting question: why does the probability
    of observing an extreme result decrease as the coin is flipped more times? We
    can find out through detailed mathematical analysis. However, a much more intuitive
    solution is to just visualize the distribution of head counts across our two sample
    space dictionaries. The visualization would effectively be a plot of keys (head
    counts) versus values (combination counts) present in each dictionary. We can
    carry out this plot using Matplotlib, Python’s most popular visualization library.
    In the subsequent section, we discuss Matplotlib usage and its application to
    probability theory.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的概率已从大约0.1下降到大约0.01。因此，新增的证据导致我们对硬币公平性的信心下降了十倍。尽管概率有所下降，但正面与尾数的比例仍然保持在4比1。我们的原始和更新后的实验都产生了80%的正面和20%的尾数。这引发了一个有趣的问题：为什么随着硬币抛掷次数的增加，观察极端结果的可能性会下降？我们可以通过详细的数学分析来找出答案。然而，一个更直观的解决方案是可视化我们两个样本空间字典中头数分布。这种可视化将有效地是键（头数）与值（组合计数）的图表。我们可以使用Matplotlib来完成这个图表，这是Python最受欢迎的可视化库。在下一节中，我们将讨论Matplotlib的使用及其在概率论中的应用。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A *sample space* is the set of all the possible outcomes an action can produce.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*样本空间*是所有可能结果的总和，一个动作可以产生这些结果。'
- en: An *event* is a subset of the sample space containing just those outcomes that
    satisfy some *event condition*. An event condition is a Boolean function that
    takes as input an outcome and returns either `True` or `False`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*事件*是样本空间的一个子集，只包含满足某些*事件条件*的那些结果。事件条件是一个布尔函数，它接受一个结果作为输入，并返回`True`或`False`。'
- en: The *probability* of an event equals the fraction of event outcomes over all
    the possible outcomes in the entire sample space.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的**概率**等于事件结果在整个样本空间所有可能结果中的比例。
- en: Probabilities can be computed over *numeric intervals*. An interval is defined
    as the set of all the numbers sandwiched between two boundary values.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率可以在**数值区间**上计算。区间被定义为介于两个边界值之间的所有数字的集合。
- en: Interval probabilities are useful for determining whether an observation appears
    extreme.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区间概率对于确定一个观察值是否显得异常非常有用。
