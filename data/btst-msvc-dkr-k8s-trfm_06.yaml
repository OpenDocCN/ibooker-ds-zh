- en: 6 Creating your production environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 创建您的生产环境
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building production infrastructure for your application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序构建生产基础设施
- en: Working with Terraform to script the creation of infrastructure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform脚本创建基础设施
- en: Creating a Kubernetes cluster to host microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Kubernetes集群以托管微服务
- en: Interacting with your Kubernetes cluster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您的Kubernetes集群交互
- en: Finally, we arrive at the most exciting chapters of the book! The next two chapters
    are also probably the hardest so far, but do follow along with the examples. That’s
    how you’ll learn the most and gain real experience bringing your own application
    to production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了这本书中最激动人心的章节！接下来的两个章节也可能是迄今为止最难的，但请务必跟随示例进行学习。这样你才能学到最多，并获得将自己的应用程序投入生产的真实经验。
- en: 'In this chapter and the next, we will create a Kubernetes cluster and deploy
    containers to it: a MongoDB database, a RabbitMQ server, and of course, our video
    streaming microservice. In the next chapter, we’ll also build a continuous delivery
    (CD) pipeline that automatically deploys our updated code to production. The examples
    in these two chapters are designed for you to follow along with step by step to
    build our infrastructure and application. This closely emulates the real process
    of prototyping new infrastructure and is close to what I really do in my own development.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，我们将创建一个Kubernetes集群并将容器部署到其中：一个MongoDB数据库，一个RabbitMQ服务器，当然还有我们的视频流微服务。在下一章中，我们还将构建一个持续交付（CD）管道，该管道会自动将我们的更新代码部署到生产环境中。这两个章节中的示例旨在让您逐步跟随构建我们的基础设施和应用。这紧密地模拟了原型化新基础设施的真实过程，并且接近我在自己开发中真正做的事情。
- en: These chapters are two parts of what we need for production deployment. In chapter
    6, this chapter, we’ll build our production infrastructure. By the end of this
    chapter, we’ll have a fresh container registry and an empty Kubernetes cluster
    ready and waiting to host our application. In chapter 7, we’ll continue the effort
    and learn how to deploy our microservices through an automated deployment pipeline.
    Let’s begin!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节是我们进行生产部署所需的两部分。在第6章，也就是本章，我们将构建我们的生产基础设施。到本章结束时，我们将拥有一个全新的容器注册库和一个空白的Kubernetes集群，它们都准备好了，等待托管我们的应用程序。在第7章，我们将继续努力，学习如何通过自动化部署管道部署我们的微服务。让我们开始吧！
- en: 6.1 New tools
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 新工具
- en: 'This chapter introduces two new tools: Kubernetes and Terraform. These tools
    are so important that they made it into the title of the book! We’ll use Terraform
    to create the infrastructure for our microservices application, including our
    Kubernetes cluster.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两个新工具：Kubernetes和Terraform。这两个工具如此重要，以至于它们成为了本书的标题！我们将使用Terraform为我们微服务应用程序创建基础设施，包括我们的Kubernetes集群。
- en: Table 6.1 New tools in chapter 6
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1第6章中的新工具
- en: '| Tool | Version | Purpose |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 目的 |'
- en: '| Kubernetes | 1.18.8 | Kubernetes is the computing platform that we use to
    host our microservices in production. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Kubernetes | 1.18.8 | Kubernetes是我们用于在生产中托管微服务的计算平台。|'
- en: '| Terraform | 0.12.29 | Terraform allows us to script the creation of cloud
    resources and application infrastructure. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Terraform | 0.12.29 | Terraform允许我们脚本化创建云资源和应用程序基础设施。|'
- en: '| Kubectl | 1.18.6 | Kubectl is the command-line tool for interacting with
    a Kubernetes cluster. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Kubectl | 1.18.6 | Kubectl是与Kubernetes集群交互的命令行工具。|'
- en: '| Azure CLI | 2.9.1 | We’ll use the Azure command-line tool to authenticate
    with Azure and give Terraform access to our Azure account.This tool is generally
    useful for managing Azure accounts and cloud resources. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Azure CLI | 2.9.1 | 我们将使用Azure命令行工具对Azure进行身份验证，并允许Terraform访问我们的Azure账户。此工具通常用于管理Azure账户和云资源。|'
- en: 6.2 Getting the code
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 获取代码
- en: To follow along with this chapter, you need to download the code or clone the
    repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章，您需要下载代码或克隆存储库。
- en: 'Download a zip file of the code from here:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这里下载代码的zip文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-6](https://github.com/bootstrapping-microservices/chapter-6)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-6](https://github.com/bootstrapping-microservices/chapter-6)'
- en: 'You can clone the code using Git like this:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Git克隆代码如下：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-6.git`'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-6.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如需安装和使用Git的帮助，请参阅第2章。如果您在代码方面遇到问题，请在GitHub的存储库中记录一个问题。
- en: 6.3 Getting to production
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 进入生产
- en: The day has arrived. We are taking our application to production. It might seem
    like it is too early to take this small application to production, but actually,
    in normal development situations, I really do advocate going to production as
    early as possible. Maybe not as early as this, but I do believe it’s a good idea
    to go to production while your application is still small. Why is that?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那一天已经到来。我们将我们的应用程序部署到生产环境。虽然看起来将这个小型应用程序部署到生产环境可能还为时尚早，但实际上，在正常开发情况下，我确实主张尽可能早地将应用程序部署到生产环境。也许不会像现在这样早，但我确实认为当你的应用程序仍然很小时进入生产环境是一个好主意。那为什么？
- en: Going to production means putting our application where our customers can see
    it and use it. Putting our product in front of users is essential to getting feedback,
    adapting to their needs, and building valuable features. If we don’t go to production,
    we won’t get that feedback. Having a deployment pipeline that allows for rapid
    and reliable updates is the best tool we have for experimenting and figuring out
    how to make a great product.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 进入生产意味着将我们的应用程序放置在客户可以看到并使用它的位置。将我们的产品展示给用户是获取反馈、适应他们的需求并构建有价值功能的关键。如果我们不进入生产，我们就不会得到那些反馈。拥有允许快速可靠更新的部署管道是我们进行实验和找出如何制作出优秀产品的最佳工具。
- en: Also, while our application is still small, this is the best time to build a
    CD pipeline and to go to production. When our application is small, it’s easier
    to deploy. But this task becomes progressively more difficult as our application
    grows larger.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们的应用程序仍然很小的时候，这是构建CD管道并进入生产阶段的最佳时机。当我们的应用程序很小的时候，部署起来更容易。但随着我们的应用程序变得越来越大，这项任务会变得越来越困难。
- en: Figure 6.1 shows what we’ll do in this chapter. We’ll use Terraform on our development
    workstation (or personal computer) to build infrastructure in the cloud. We’ll
    use code to create our container registry and our Kubernetes cluster. Then, in
    chapter 7, we’ll learn how to put this on automatic with continuous delivery (CD).
    But for now, we’ll learn to evolve our development infrastructure by manually
    invoking Terraform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1展示了本章我们将做什么。我们将在我们的开发工作站（或个人电脑）上使用Terraform在云中构建基础设施。我们将使用代码创建我们的容器注册表和Kubernetes集群。然后，在第7章中，我们将学习如何通过持续交付（CD）自动化这一切。但就目前而言，我们将学习通过手动调用Terraform来演进我们的开发基础设施。
- en: '![](../Images/CH06_F01_Davis4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F01_Davis4.png)'
- en: Figure 6.1 Prototyping our infrastructure with Terraform
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 使用Terraform原型化我们的基础设施
- en: 6.4 Infrastructure as code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 基础设施即代码
- en: Infrastructure as code is the name of the technique we’ll use in this chapter
    to bring our application to production. It’s called *infrastructure as code* because
    rather than manually creating infrastructure (say, through a GUI, as we did with
    our private container registry in chapter 3), we will write code that creates
    our infrastructure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码是我们将在本章中使用的技术，以将我们的应用程序部署到生产环境。它被称为*基础设施即代码*，因为与手动创建基础设施（例如，通过GUI，就像我们在第3章中为我们的私有容器注册表所做的那样）不同，我们将编写创建我们基础设施的代码。
- en: Not only will this code describe our infrastructure, but we will also execute
    it to actually create our infrastructure. Using code to create infrastructure
    means that we can reliably and repeatedly create and recreate our infrastructure
    on demand and as often as we like.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅此代码将描述我们的基础设施，我们还将执行它以实际创建我们的基础设施。使用代码创建基础设施意味着我们可以可靠地、重复地按需创建和重新创建我们的基础设施，并且可以像我们喜欢的那样频繁地这样做。
- en: The fact that this code both describes and builds our infrastructure makes it
    a form of *executable documentation.* It’s a statement about how we want our infrastructure
    to look, and unlike normal (i.e., non-executable) documentation, it’s a form of
    documentation that’s never going to go out of date.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不仅描述了我们的基础设施，还构建了它，这使得它成为一种*可执行文档*。它是对我们希望基础设施看起来怎样的声明，并且与正常的（即不可执行的）文档不同，这是一种永远不会过时的文档形式。
- en: Through infrastructure as code, creating and updating our infrastructure becomes
    a kind of coding task. The best form of infrastructure as code uses a declarative
    language instead of a procedural one. This means it describes the configuration
    and layout of the infrastructure instead of the step-by-step instructions for
    building it. We prefer the declarative format because we can let our tools do
    the heavy lifting, and these can figure out the best way to make changes to our
    infrastructure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基础设施即代码，创建和更新我们的基础设施变成了一种编码任务。最佳的基础设施即代码形式使用声明性语言而不是过程性语言。这意味着它描述了基础设施的配置和布局，而不是构建它的逐步指令。我们更喜欢声明性格式，因为我们可以让我们的工具承担繁重的工作，并且这些工具可以找出更改我们基础设施的最佳方式。
- en: Figure 6.2 illustrates the concept of infrastructure as code. The code for our
    infrastructure lives in a code repository such as Git. From there, we execute
    it to create, configure, and maintain our cloud-based infrastructure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 阐述了基础设施即代码的概念。我们的基础设施代码存储在代码仓库中，例如 Git。从那里，我们执行它以创建、配置和维护基于云的基础设施。
- en: '![](../Images/CH06_F02_Davis4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F02_Davis4.png)'
- en: Figure 6.2 Infrastructure as code uses executable code to create infrastructure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 基础设施即代码使用可执行代码来创建基础设施。
- en: Infrastructure as code is not just important because we can use our well-tested
    code to reliably and repeatedly create our infrastructure. It’s also important
    because it’s what allows us to automate the creation and maintenance of our infrastructure.
    As such, it’s a crucial enabler for continuous delivery, which we’ll see in the
    next chapter where we build our automated deployment pipeline.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码之所以重要，不仅是因为我们可以使用经过良好测试的代码来可靠地重复创建我们的基础设施。它还重要，因为它允许我们自动化基础设施的创建和维护。因此，它是持续交付的关键推动者，我们将在下一章中看到，我们将构建我们的自动化部署管道。
- en: 6.5 Hosting microservices on Kubernetes
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 在 Kubernetes 上托管微服务
- en: By the end of the next chapter, we’ll run multiple containers in the production
    environment for our application. These containers are hosted on a managed version
    of Kubernetes that is running in the cloud (you can think of this as Kubernetes
    as a *service*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到下一章结束时，我们将在我们的应用程序的生产环境中运行多个容器。这些容器托管在云中运行的 Kubernetes 的管理版本上（你可以将其视为 Kubernetes
    作为 *服务* 的形式）。
- en: Note Kubernetes is a computing platform for managing container-based applications.
    It was originally created by Google but is now managed by the Cloud Native Computing
    Foundation, a committee that has huge industry support and is also responsible
    for many other interesting projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Kubernetes 是一个用于管理基于容器的应用程序的计算平台。它最初由谷歌创建，但现在由云原生计算基金会管理，该基金会拥有巨大的行业支持，并负责许多其他有趣的项目。
- en: Kubernetes is commonly known as a container orchestration platform. This tells
    us all we need to know. Kubernetes can manage and automate the deployment and
    scaling of our containers. Kubernetes is the production backbone of our microservices
    application. I like to think of it as *a platform for microservices.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通常被称为容器编排平台。这告诉我们所有需要知道的信息。Kubernetes 可以管理和自动化容器的部署和扩展。Kubernetes
    是我们微服务应用程序的生产骨干。我喜欢将其视为 *微服务平台*。
- en: 6.5.1 Why Kubernetes?
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 为什么选择 Kubernetes？
- en: There are many reasons to use Kubernetes. The simplest reason is to avoid vendor
    lock-in. All the main cloud vendors offer their own container orchestration services
    that are good in their own right. But each of these also offers a managed Kubernetes
    service, so why use a proprietary service when you can instead use Kubernetes?
    Using Kubernetes means our application can be portable to any cloud vendor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 有许多原因。最简单的原因是避免供应商锁定。所有主要的云供应商都提供自己的容器编排服务，这些服务本身很好。但每个供应商也提供了一种管理的
    Kubernetes 服务，所以为什么要在可以使用 Kubernetes 的情况下使用专有服务呢？使用 Kubernetes 意味着我们的应用程序可以迁移到任何云供应商。
- en: I believe it’s worthwhile to learn Kubernetes (at least the basics) because
    the knowledge is transferable. Although, in this book, we host our Kubernetes
    cluster on Microsoft Azure, you can take the Kubernetes skills with you and use
    them on whichever cloud you most prefer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为学习 Kubernetes（至少是基础知识）是值得的，因为这种知识是可以迁移的。尽管，在这本书中，我们在微软 Azure 上托管我们的 Kubernetes
    集群，但你可以将 Kubernetes 技能随身携带，并在你最喜欢的云平台上使用。
- en: Kubernetes has a reputation for being complicated. And certainly, it is if you
    want to install it on your own hardware or if you want to deep dive and become
    an expert. Fortunately, for the rest of us, building a managed Kubernetes cluster
    in our favorite cloud platform is much easier, to the point where (at least on
    Azure) we can create it in the GUI in a handful of clicks. We won’t create our
    infrastructure manually through a GUI though. Instead, we’ll create our cluster
    through Terraform code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 以其复杂性而闻名。当然，如果你想在自己的硬件上安装它，或者你想深入研究并成为专家，它确实很复杂。幸运的是，对于其他人来说，在我们的首选云平台上构建托管的
    Kubernetes 集群要容易得多，至少在 Azure 上，我们可以在几个点击中通过 GUI 创建它。不过，我们不会通过 GUI 手动创建我们的基础设施。相反，我们将通过
    Terraform 代码创建我们的集群。
- en: Kubernetes emerged from the vast experience of Google, then it was turned over
    to the community. This means you can fork the code and contribute to Kubernetes
    yourself-assuming you have a desire to be lost down that particular rabbit hole!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是从 Google 的丰富经验中诞生的，然后它被转交给社区。这意味着你可以分叉代码并自己为 Kubernetes 做贡献——前提是你有意愿陷入那个特定的兔子洞！
- en: Kubernetes allows us to build applications that are scalable in multiple ways.
    That’s something we’ll talk more about in chapters 10 and 11\. In this chapter
    and the next, however, we’ll learn the absolute basics. That’s enough to build
    a production cluster to which we can deploy our small microservices application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 允许我们构建以多种方式可扩展的应用程序。这一点我们将在第 10 章和第 11 章中详细讨论。然而，在本章和下一章中，我们将学习绝对的基础知识。这足以构建一个生产集群，我们可以将我们的小型微服务应用程序部署到该集群。
- en: Most importantly, Kubernetes has an automatable API. This is what will allow
    us to build our automated deployment pipeline in chapter 7\. Kubernetes is becoming
    an industry standard for microservices, and I expect it to continue in that direction.
    It’s well supported and has a great community and a large ecosystem of tools.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，Kubernetes 有一个可自动化的 API。这将使我们能够在第 7 章中构建我们的自动化部署管道。Kubernetes 正在成为微服务行业的标准，我预计它将继续朝这个方向发展。它得到了很好的支持，拥有一个庞大的社区和工具生态系统。
- en: 'To me, Kubernetes is the *universal computing platform.* It’s supported by
    all the major cloud players. No matter where we end up, we can take Kubernetes
    with us. Kubernetes is open source and you can find the code here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，Kubernetes 是一个*通用的计算平台*。它得到了所有主要云服务提供商的支持。无论我们最终在哪里，我们都可以带着 Kubernetes
    一起走。Kubernetes 是开源的，你可以在以下位置找到代码：
- en: '[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)'
- en: 6.5.2 How does Kubernetes work?
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 Kubernetes 是如何工作的？
- en: A Kubernetes cluster is composed of multiple computers. Each computer is called
    a *node*. Each node is actually a virtual machine (VM). We can add as many VMs
    as we need to our cluster to control the amount of computing power available to
    our application. And, each node can host multiple pods. A *pod* is the basic unit
    of computation in Kubernetes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群由多台计算机组成。每台计算机被称为一个*节点*。每个节点实际上是一个虚拟机（VM）。我们可以根据需要向我们的集群添加任意数量的虚拟机，以控制应用程序可用的计算能力。每个节点还可以托管多个
    Pod。*Pod* 是 Kubernetes 中计算的基本单元。
- en: Figure 6.3 illustrates an example of the arrangement of nodes and pods. The
    depicted cluster has three nodes (it is powered by three VMs). However, the cluster
    we create in this chapter only has a single node. That’s because our simple application
    doesn’t need much computing power. It also means we won’t pay for more VMs than
    we actually need. Scaling up to more nodes is easy though, and we’ll look at a
    real example in chapter 11.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 展示了节点和 Pod 的排列示例。图中所示的集群有三个节点（由三个虚拟机供电）。然而，在本章中我们创建的集群只有一个节点。这是因为我们的简单应用程序不需要太多的计算能力。这也意味着我们不会为超过我们实际需要的虚拟机付费。不过，扩展到更多节点很容易，我们将在第
    11 章中看到一个真实示例。
- en: '![](../Images/CH06_F03_Davis4.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F03_Davis4.png)'
- en: Figure 6.3 The structure of a Kubernetes cluster
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 Kubernetes 集群的结构
- en: Each pod can actually host multiple containers, as figure 6.4 shows. This can
    be the basis for many interesting architectural patterns (such as the well-known
    sidecar pattern for proxies and authentication).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 6.4 所示，每个 Pod 实际上可以托管多个容器。这可以成为许多有趣架构模式的基础（例如，代理和身份验证中广为人知的边车模式）。
- en: In this book, though, we are keeping things simple. Each pod will host only
    a single container or microservice*.* Even though figure 6.4 shows a pod with
    multiple containers, for the purposes of this book, you can think of a pod as
    a container or as a microservice if that’s a simplification that is helpful for
    you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这本书中，我们尽量保持简单。每个 pod 只会托管一个容器或微服务*.* 即使图 6.4 显示了一个包含多个容器的 pod，但对于本书的目的，你可以将
    pod 视为一个容器或微服务，如果这对你来说是一种有用的简化。
- en: '![](../Images/CH06_F04_Davis4.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F04_Davis4.png)'
- en: Figure 6.4 The structure of a Kubernetes pod
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 Kubernetes pod 的结构
- en: 6.6 Working with the Azure CLI
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 使用 Azure CLI
- en: Before we can start working with Terraform, we need the Azure CLI up and running.
    That’s the simplest way for us to authenticate Terraform so that it has access
    to our Azure account and to give it permission to create infrastructure on our
    behalf in Azure. It’s also really handy to have the Azure CLI because it’s a useful
    way to interact with our Azure account and manage our cloud resources.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Terraform 之前，我们需要确保 Azure CLI 正在运行。这是让我们能够认证 Terraform 的最简单方式，以便它能够访问我们的
    Azure 账户，并授予它代表我们在 Azure 上创建基础设施的权限。同时，拥有 Azure CLI 也非常方便，因为它是一种与我们的 Azure 账户交互和管理云资源的有用方式。
- en: 6.6.1 Installing the Azure CLI
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 安装 Azure CLI
- en: 'You can find the instructions for installing the Azure CLI here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到安装 Azure CLI 的说明：
- en: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
- en: 'Choose your platform and follow the instructions to install it. After installing
    the Azure CLI, you can test it from your terminal with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的平台并按照说明进行安装。安装 Azure CLI 后，你可以使用以下命令从终端测试它：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At the time of writing, I’m using version 2.9.1\. Future versions should be
    backward compatible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我正在使用版本 2.9.1。未来的版本应该具有向后兼容性。
- en: Azure CLI is preinstalled in the Vagrant VM
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI 已在 Vagrant 虚拟机中预安装
- en: If you are using the Vagrant VM included in the chapter 6 code repository, you’ll
    find all the tools you need already installed. This includes the Azure CLI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用第 6 章代码库中包含的 Vagrant 虚拟机，你将发现所有需要的工具都已经安装好了。这包括 Azure CLI。
- en: If you are working on Linux, take a look at the shell script scripts/provision-dev-vm.sh
    in the chapter 6 code repository. This shell script installs the tools in the
    VM so you can use it as an example of how to install the Azure CLI on a Linux
    computer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Linux，请查看第 6 章代码库中的 shell 脚本 `scripts/provision-dev-vm.sh`。这个 shell
    脚本在虚拟机中安装工具，以便你可以将其作为在 Linux 计算机上安装 Azure CLI 的示例。
- en: See appendix A for more information on using Vagrant.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 Vagrant 的更多信息，请参阅附录 A。
- en: 6.6.2 Authenticating with Azure
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 使用 Azure 进行认证
- en: 'The main reason we install the Azure CLI is simply to authenticate with our
    Azure account. We can do that from the terminal by running the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装 Azure CLI 的主要原因仅仅是用于与我们的 Azure 账户进行认证。我们可以通过在终端运行以下命令来完成：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running this command opens a browser so you can sign in to your Azure account.
    If it doesn’t automatically open your browser, you’ll have to manually check the
    output, open the URL, and then enter the code. The output of the command gives
    instructions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会打开浏览器，以便你可以登录到你的 Azure 账户。如果浏览器没有自动打开，你需要手动检查输出，打开 URL，然后输入代码。命令的输出提供了以下说明：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After entering the code, click Next. Now sign in to your Azure account with
    your username and password. After signing in, you will see a message in your browser
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输入代码后，点击“下一步”。现在使用你的用户名和密码登录到你的 Azure 账户。登录后，你将在浏览器中看到如下消息：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can now close your browser and return to the terminal. The `az login` command
    completes and displays a JSON formatted list of your Azure subscriptions. If you
    only just signed up for Azure for this book, you should see only one subscription.
    If you already use Azure for work you might see multiple subscriptions listed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以关闭浏览器并返回终端。`az login` 命令完成并显示一个以 JSON 格式化的你的 Azure 订阅列表。如果你只为这本书刚刚注册了
    Azure，你应该只看到一个订阅。如果你已经使用 Azure 进行工作，你可能会看到多个订阅的列表。
- en: 'The authentication is saved locally, and from now on, you can issue other commands
    against your Azure account without having to sign in each time. We can test which
    Azure subscription we are working with using this command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 认证信息被保存在本地，从现在开始，你可以发出针对你的 Azure 账户的其他命令，而无需每次都登录。我们可以使用以下命令测试我们正在使用的 Azure
    订阅：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output from this command shows us the current default subscription. We
    can view a list of all subscriptions with this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出显示了当前默认订阅。我们可以使用此命令查看所有订阅的列表：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output is a JSON formatted list of subscriptions. Each subscription has
    an `id` field that is a unique ID for the subscription. You’ll also notice that
    the current default subscription is marked by having its `isDefault` field set
    to `true`. This field is set to `false` for any other subscriptions in the list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个以 JSON 格式显示的订阅列表。每个订阅都有一个 `id` 字段，它是订阅的唯一标识符。您还会注意到，当前默认订阅通过将其 `isDefault`
    字段设置为 `true` 来标记。列表中的任何其他订阅的此字段都设置为 `false`。
- en: 'At this point, you should verify that you are using the right subscription
    to follow along with the examples in this book. For example, if you have access
    to subscriptions from your employer, you probably shouldn’t use those for your
    own learning and experimentation (or at least, check with your boss first). If
    you need to change the current working subscription, you can set a new default
    with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该验证您正在使用正确的订阅来跟随本书中的示例。例如，如果您有权访问雇主的订阅，您可能不应该使用这些订阅进行自己的学习和实验（或者至少，先与您的老板确认）。如果您需要更改当前的工作订阅，可以使用以下命令设置新的默认值：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace `<subscription-id>` with the ID of the subscription that you want to
    set as the default. After changing the default subscription, double-check it again
    with this command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<subscription-id>` 替换为您想要设置为默认的订阅的 ID。更改默认订阅后，请再次使用此命令进行双重检查：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is just to be absolutely sure that we are using our own subscription to
    follow along with the examples. We don’t want to accidentally use an Azure subscription
    from our employer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了确保我们正在使用自己的订阅来跟随示例。我们不希望不小心使用我们雇主的 Azure 订阅。
- en: 6.6.3 Which version of Kubernetes?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.3 哪个版本的 Kubernetes？
- en: Let’s do something practical with the Azure CLI to understand how it can be
    useful. Toward the end of this chapter, we’ll create our managed Kubernetes cluster.
    It will be helpful to know in advance which versions of Kubernetes are available
    in the location where we are creating it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Azure CLI 做一些实际操作，以了解它如何有用。在本章的末尾，我们将创建我们的托管 Kubernetes 集群。提前了解我们创建它的位置可用的
    Kubernetes 版本将很有帮助。
- en: 'To interact with the Azure Kubernetes service via the Azure CLI, we’ll use
    the `aks` subcommand. Here’s an example that lists versions of Kubernetes in the
    West US region:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Azure CLI 与 Azure Kubernetes 服务交互，我们将使用 `aks` 子命令。以下是一个列出西 US 区域 Kubernetes
    版本的示例：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is a JSON formatted list that shows the available versions of Kubernetes
    in that location. The output will be more readable for us if use the *table style*
    of output like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个以 JSON 格式显示的列表，其中显示了该位置可用的 Kubernetes 版本。如果使用如下所示的 *表格样式* 输出，输出对我们来说将更容易阅读：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should now see something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该看到类似以下内容：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From this list, you should select the most recent stable (non-preview) version
    of Kubernetes. That’s 1.18.8 at the time of writing. But by the time you read
    this, there will be a more recent version. It’s quite possible that version 1.18.8
    will have also been expired (no longer available through Azure). *Be sure to choose
    a version number that’s currently available!*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从此列表中，您应选择最新的稳定（非预览）版本的 Kubernetes。在撰写本文时，这是 1.18.8 版本。但到您阅读本文时，可能会有更新的版本。完全有可能
    1.18.8 版本已经过期（不再通过 Azure 提供）。*务必选择当前可用的版本号！*
- en: Make a note of the version number. We’ll need it soon to create our cluster.
    You could choose a preview version of Kubernetes, say, if you wanted to evaluate
    the latest release. But normally for production use, we’d prefer to use the latest
    stable version.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记下版本号。我们很快就需要它来创建我们的集群。如果您想评估最新发布版本，可以选择 Kubernetes 的预览版本。但通常对于生产使用，我们更愿意使用最新的稳定版本。
- en: 6.6.4 What have we achieved?
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.4 我们取得了什么成果？
- en: We’ve installed the Azure command-line tool (Azure CLI). This is a useful tool
    for interacting with our Azure account from the terminal. We used it to authenticate
    with our Azure account.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已安装 Azure 命令行工具（Azure CLI）。这是一个从终端与我们的 Azure 账户交互的有用工具。我们用它来验证我们的 Azure 账户。
- en: Note Terraform needs to be authenticated with Azure so that it can create infrastructure
    on our behalf.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Terraform 需要使用 Azure 进行身份验证，以便它能够代表我们创建基础设施。
- en: As a practical example, we used the Azure CLI to query for the versions of Kubernetes
    that are available for use in our chosen location. We noted the most recent version
    number of Kubernetes, and we’ll use that later to create our cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实际示例，我们使用 Azure CLI 查询我们选择位置可用的 Kubernetes 版本。我们记录了 Kubernetes 的最新版本号，稍后我们将使用它来创建我们的集群。
- en: 6.7 Creating infrastructure with Terraform
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 使用 Terraform 创建基础设施
- en: Now we are coming to the point where we’ll actually start to create our infrastructure!
    We could build our infrastructure manually, either using the GUI from our cloud
    vendor (e.g., the Azure portal) or via the command line (e.g., the Azure CLI).
    In this book, though, we’ll build our infrastructure in an automated fashion using
    code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正来到一个点，我们将真正开始创建我们的基础设施！我们可以手动构建我们的基础设施，无论是使用云供应商的 GUI（例如 Azure 门户）还是通过命令行（例如
    Azure CLI）。然而，在这本书中，我们将使用代码以自动化的方式构建我们的基础设施。
- en: From here on in, we’ll use *infrastructure as code* to automate the process
    of infrastructure creation and, hence, make it reliable and repeatable. Automation
    allows us to later scale up our application without scaling up our manual workload.
    We’ll do this with Terraform, an amazingly flexible tool for executing Hashicorp
    Configuration Language (HCL) code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用 *基础设施即代码*来自动化基础设施创建过程，从而使其可靠且可重复。自动化使我们能够在不增加手动工作负载的情况下扩展我们的应用程序。我们将使用
    Terraform 来完成这项工作，这是一个执行 HashiCorp 配置语言 (HCL) 代码的惊人灵活的工具。
- en: HCL is the declarative configuration language in which we’ll define our infrastructure.
    Executing this code with Terraform actually creates our infrastructure in the
    cloud.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 是我们定义基础设施的声明性配置语言。使用 Terraform 执行此代码实际上在云中创建我们的基础设施。
- en: Note In the future, I’ll refer to HCL simply as *Terraform code*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在未来，我将简单地将 HCL 称为 *Terraform 代码*。
- en: Terraform supports multiple cloud vendors through plugin providers as figure
    6.5 illustrates. For the examples in this chapter, we use Terraform to create
    infrastructure on Microsoft Azure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 通过插件提供者支持多个云供应商，如图 6.5 所示。在本章的示例中，我们使用 Terraform 在 Microsoft Azure
    上创建基础设施。
- en: 'If learning HCL seems in any way daunting, remember this: HCL is actually just
    like YAML or JSON, but it’s a different format. Hashicorp created HCL to be a
    human-readable configuration format that is also machine-translatable to YAML
    and JSON. Think of it as YAML or JSON but structured so that it’s more friendly
    for humans.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果学习 HCL 似乎有任何令人畏惧的地方，请记住这一点：HCL 实际上就像 YAML 或 JSON 一样，但它是一种不同的格式。HashiCorp 创建
    HCL 以使其成为一个可读性强的配置格式，同时也可以机器翻译成 YAML 和 JSON。将其视为 YAML 或 JSON，但结构上更便于人类阅读。
- en: '![](../Images/CH06_F05_Davis4.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F05_Davis4.png)'
- en: Figure 6.5 Using Terraform to build infrastructure with various cloud vendors
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 使用 Terraform 与各种云供应商构建基础设施
- en: 6.7.1 Why Terraform?
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 为什么选择 Terraform？
- en: Terraform is a tool and a language for configuring infrastructure for cloud-based
    applications. Terraform makes it easy to reliably and repeatedly configure cloud
    infrastructure. It’s incredibly flexible, as its functionality is extended through
    plugin providers. This is how it supports multiple cloud vendors! Terraform already
    has robust providers implemented for Azure, AWS, and Google Cloud.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一种用于配置云应用程序基础设施的工具和语言。Terraform 使配置云基础设施变得可靠且可重复。它非常灵活，因为其功能可以通过插件提供者扩展。这就是它支持多个云供应商的原因！Terraform
    已经为 Azure、AWS 和 Google Cloud 实现了强大的提供者。
- en: Just like with Kubernetes, we’ll again learn transferable skills that can be
    used with all the major cloud vendors. No matter which cloud we use, we can make
    use of Terraform to build our infrastructure. We can even create our own providers
    and extend Terraform to work with platforms that it doesn’t yet support. To seal
    the deal, Terraform supports Kubernetes, and we’ll also use it to deploy containers
    to our cluster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Kubernetes 一样，我们还将学习可转移的技能，这些技能可以用于所有主要的云供应商。无论我们使用哪种云，我们都可以利用 Terraform
    来构建我们的基础设施。我们甚至可以创建自己的提供者，并将 Terraform 扩展到它尚未支持的平台。为了巩固这一点，Terraform 支持 Kubernetes，我们还将使用它来将容器部署到我们的集群中。
- en: Terraform does just about everything we need to create our application’s automated
    deployment pipeline. It’s an all-in-one tool for scripting infrastructure because,
    even for the things it can’t do, we can fill the gaps ourselves. In the next chapter,
    you’ll see one simple method we can use to extend the functionality of Terraform
    to cover those areas that it can’t yet handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 几乎可以完成我们创建应用程序自动化部署管道所需的所有工作。它是一个用于脚本化基础设施的全能工具，因为即使对于它无法完成的事情，我们也可以自己填补空白。在下一章中，你将看到一种简单的方法，我们可以用它来扩展
    Terraform 的功能，以覆盖它目前还无法处理的领域。
- en: 'To me, Terraform seems like the *universal configuration language*. It’s one
    language we can use to create all of our infrastructure. Terraform is open source,
    and you can find the code here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，Terraform 好像是一种**通用配置语言**。这是我们用来创建所有基础设施的一种语言。Terraform 是开源的，你可以在以下位置找到代码：
- en: '[https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/hashicorp/terraform](https://github.com/hashicorp/terraform)'
- en: 6.7.2 Installing Terraform
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 安装 Terraform
- en: 'Installing Terraform is simply a matter of downloading the binary executable
    for your operating system and moving it to a directory that’s included in your
    system’s PATH environment variable. Download the latest version of Terraform from
    here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Terraform 只是一个下载适用于您操作系统的二进制可执行文件并将其移动到包含在您的系统 PATH 环境变量中的目录的过程。从这里下载 Terraform
    的最新版本：
- en: '[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)'
- en: 'After installing Terraform, test it from your terminal with the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Terraform 后，使用以下命令从您的终端测试它：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the time of writing, I’m using version 0.12.29\. Future versions should be
    backward compatible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我正在使用版本 0.12.29。未来的版本应该具有向后兼容性。
- en: Terraform is preinstalled in the Vagrant VM
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 在 Vagrant VM 中预先安装
- en: If you are using the Vagrant VM included in the chapter 6 code repository, you’ll
    find that all the tools you need, including Terraform, are already installed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用第 6 章代码库中包含的 Vagrant VM，你会发现你需要的所有工具，包括 Terraform，都已经安装好了。
- en: If you are working from Linux, take a look at the shell script scripts/provision-dev-vm.sh
    in the chapter 6 code repository. This shell script installs the tools in the
    Vagrant VM, and it contains an example of how to install Terraform on a Linux
    computer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Linux 进行工作，请查看第 6 章代码库中的 shell 脚本 scripts/provision-dev-vm.sh。这个 shell
    脚本会在 Vagrant VM 中安装工具，并包含如何在 Linux 计算机上安装 Terraform 的示例。
- en: 6.7.3 Terraform project setup
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.3 Terraform 项目设置
- en: Before we get started with Terraform, let’s become familiar with what a Terraform
    project looks like. Figure 6.6 shows a fleshed out Terraform project. This is
    what example-3 from chapter 7 looks like. You don’t have to look at chapter 7
    yet or even open that particular code example right now. We are just looking at
    the structure of that project in figure 6.6 to become familiar with what a Terraform
    project looks like.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Terraform 之前，让我们熟悉一下 Terraform 项目的外观。图 6.6 展示了一个完整的 Terraform 项目。这就是第
    7 章中的 example-3 的样子。你现在不必查看第 7 章，甚至不必现在就打开那个特定的代码示例。我们只是在图 6.6 中查看该项目的结构，以便熟悉
    Terraform 项目的外观。
- en: As you can see in figure 6.6, a Terraform project is composed of a number of
    Terraform code files; those are the files ending in the .tf extension. These files
    contain the Terraform code that, when executed by Terraform, creates the infrastructure
    for our application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图 6.6 中所见，一个 Terraform 项目由多个 Terraform 代码文件组成；这些文件以 .tf 扩展名结尾。这些文件包含 Terraform
    代码，当由 Terraform 执行时，会为我们的应用程序创建基础设施。
- en: There are a lot of files here. That’s because we are looking at a more complex
    example from the next chapter. Don’t be concerned! In a moment, we’ll start with
    example-1 from this chapter (chapter 6), which is much simpler.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多文件。那是因为我们正在查看下一章的更复杂示例。不要担心！很快，我们将从本章（第 6 章）的 example-1 开始，它要简单得多。
- en: 'You should be able to read the filenames in figure 6.6 and get an idea of their
    purpose. That’s because I’ve used a naming convention where each script file is
    named according to the piece of infrastructure that it creates. When you read
    through the filenames in figure 6.6 (or any project in chapters 6 and 7), you
    should read it like this: *resource-group.tf* is responsible for creating an Azure
    resource group; *database.tf* is responsible for deploying the database; and so
    on.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够阅读图6.6中的文件名，并了解它们的作用。这是因为我已经使用了一种命名约定，其中每个脚本文件都根据它创建的基础设施部分命名。当你阅读图6.6中的文件名（或第6章和第7章中的任何项目）时，你应该这样阅读：*resource-group.tf*
    负责创建Azure资源组；*database.tf* 负责部署数据库；等等。
- en: Let’s try this now. Read through the filenames in figure 6.6 and have a go at
    guessing the purpose of each one. Mostly, it should be obvious; although, there
    are a couple of files that are outside the naming convention. Don’t be concerned
    if you can’t figure it all out; all will be explained throughout this chapter
    and the next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来试试这个。阅读图6.6中的文件名，并尝试猜测每个文件的作用。大多数情况下，应该是显而易见的；尽管如此，有几份文件超出了命名约定。如果你无法全部弄清楚，不要担心；所有内容将在本章和下一章中解释。
- en: '![](../Images/CH06_F06_Davis4.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F06_Davis4.png)'
- en: Figure 6.6 The structure of a more complete Terraform project (we have jumped
    forward to see example-3 from chapter 7).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 更完整Terraform项目的结构（我们已跳转到第7章的示例-3）。
- en: Note in figure 6.6 that we have co-located the code for the video streaming
    microservice alongside the Terraform code files. It lives under the video-streaming
    subdirectory in the same code repository. This should explain why we are storing
    the Terraform code files under the scripts subdirectory. That keeps our infrastructure
    code separate from the code for our microservices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图6.6中，我们将视频流微服务的代码与Terraform代码文件放在同一位置。它位于同一代码仓库中的video-streaming子目录下。这应该解释了为什么我们将Terraform代码文件存储在scripts子目录下。这样，我们的基础设施代码与微服务代码保持分离。
- en: The structure and filenames in this example project are not dictated by Terraform.
    It just happens to be the convention we’ll use in these examples. For your own
    projects, a different structure might be better, so feel free to experiment and
    find the best structure for your own project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例项目的结构和文件名不是由Terraform决定的。这仅仅是我们将在这些示例中使用的约定。对于你自己的项目，可能存在不同的结构会更好，所以请自由实验，找到最适合你自己的项目的最佳结构。
- en: To keep things simple while learning, and because this is a good way to start
    a new microservices project, we’ll co-locate our infrastructure and microservices
    code. You might already realize that this monolith-like project structure eliminates
    some of the benefits of using microservices in the first place. Don’t worry too
    much about that right now. Just know that this simple structure is only for the
    early days of our new application. As we grow our application, we’ll need to convert
    it to a more scalable structure, but that’s something we’ll discuss in chapter
    11\. For the moment, let’s stick with this simple project structure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在学习过程中保持简单，并且因为这是启动一个新微服务项目的好方法，我们将把我们的基础设施和微服务代码放在同一个位置。你可能已经意识到，这种类似单体项目的结构在最初使用微服务时消除了一些好处。现在不必过于担心这一点。只需知道，这种简单的结构仅适用于我们新应用的早期阶段。随着我们应用的增长，我们需要将其转换为更可扩展的结构，但这将在第11章中讨论。目前，让我们坚持这种简单的项目结构。
- en: 6.8 Creating an Azure resource group for your application
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 为您的应用程序创建Azure资源组
- en: After looking at the advanced project structure of example-3 from the next chapter,
    let’s now dial back the complexity and look at the much simpler example-1 from
    this chapter. We need to start our Terraform journey somewhere, and our starting
    points should always be simple. This is the case with example-1, which contains
    the simplest Terraform code from which we can start to create our deployment pipeline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看下一章示例-3的高级项目结构之后，现在让我们降低复杂性，看看本章的更简单的示例-1。我们需要从某个地方开始我们的Terraform之旅，我们的起点应该是简单的。示例-1就是这样，它包含了我们可以从中开始创建部署管道的最简单Terraform代码。
- en: The first thing we do is to create an Azure resource group that groups together
    all the other Azure resources we’ll build throughout this chapter. Back in chapter
    3, we manually created a resource group through the Azure Portal GUI. Now, we
    create a resource group again, but this time, we aren’t doing it manually. We’ll
    build it through code using Terraform.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个 Azure 资源组，将本章中我们将构建的所有其他 Azure 资源组合在一起。在第三章中，我们通过 Azure Portal
    GUI 手动创建了一个资源组。现在，我们再次创建一个资源组，但这次我们不是手动创建。我们将通过代码使用 Terraform 来构建它。
- en: 'Figure 6.7 shows what we’ll do in this section. Example-1 contains two Terraform
    code files: providers.tf and resource-group.tf. The script file, resource-group.tf,
    is the one that actually creates the resource group. The other file, providers.tf,
    contains configurations for the Terraform provider plugins.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 展示了本节我们将要做什么。Example-1 包含两个 Terraform 代码文件：providers.tf 和 resource-group.tf。脚本文件
    resource-group.tf 是实际创建资源组的文件。另一个文件 providers.tf 包含 Terraform 提供者插件的配置。
- en: We will use the `terraform` `apply` command to execute our Terraform code. Figure
    6.7 shows how our code files are input to Terraform, which executes our code and
    creates a FlixTube resource group in Azure (shown on the right of figure 6.7).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `terraform` `apply` 命令来执行我们的 Terraform 代码。图 6.7 显示了我们的代码文件是如何输入到 Terraform
    中，它执行我们的代码并在 Azure 中创建一个 FlixTube 资源组（如图 6.7 右侧所示）。
- en: '![](../Images/CH06_F07_Davis4.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_Davis4.png)'
- en: Figure 6.7 Using Terraform to create an Azure resource group
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 使用 Terraform 创建 Azure 资源组
- en: The file providers.tf isn’t technically necessary to this process. We could
    delete it, and this example would still work. It’s useful to have this file, though,
    because this is where we can put our code for configuring the providers that we
    use. In a moment, we’ll talk about providers.tf in more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 providers.tf 从技术上讲不是这个过程所必需的。我们可以删除它，这个示例仍然可以工作。然而，拥有这个文件是有用的，因为这是我们放置我们用于配置提供者的代码的地方。稍后，我们将更详细地讨论
    providers.tf。
- en: 6.8.1 Evolutionary architecture with Terraform
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.1 使用 Terraform 的进化式架构
- en: Terraform is a tool for building our infrastructure in an iterative fashion-something
    we call *evolutionary architecture*. In this chapter, you can experience this
    iterative method of building infrastructure for yourself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一种以迭代方式构建我们基础设施的工具——我们称之为 *进化式架构*。在本章中，您可以亲自体验这种构建基础设施的迭代方法。
- en: 'At this point, we will start to write Terraform code. You have a choice about
    how to follow along with the examples in this chapter and the next one:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将开始编写 Terraform 代码。您可以选择如何跟随本章和下一章中的示例进行学习：
- en: Start with example-1 and then iteratively update your example project to evolve
    your infrastructure as you read through this chapter and the next
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 example-1 开始，然后随着您阅读本章和下一章，迭代地更新您的示例项目以演进您的基础设施
- en: Start each example fresh and build new infrastructure for each example in this
    chapter and the next
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个示例从头开始，并在本章和下一章中为每个示例构建新的基础设施
- en: 'All of the examples in chapters 6 and 7 can run standalone, so you can easily
    start your infrastructure from any point by jumping ahead to any of the examples
    and invoking Terraform for that code. However, the best way for you to follow
    along, the way that is most like “real” development, is to iteratively update
    your code and evolve your infrastructure in a step-by-step manner (that’s the
    first option mentioned). To follow along in this way, you should create a separate
    working directory for your evolving project, for example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章和第 7 章中的所有示例都可以独立运行，因此您可以从任何示例开始轻松地启动您的基础设施，只需跳转到任何示例并调用该代码的 Terraform
    即可。然而，最适合您跟随的方式，最接近“真实”开发的方式，是迭代地更新您的代码，以逐步的方式演进您的基础设施（这是提到的第一个选项）。要以此方式跟随，您应该为您的演进项目创建一个单独的工作目录，例如：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then copy the example-1 code to it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将 example-1 代码复制到其中：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now you can follow along with the examples in chapters 6 and 7\. Each time
    you get to a new example, copy over the new code to your working project like
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以跟随第 6 章和第 7 章中的示例。每次您到达一个新的示例时，就像这样将新代码复制到您的工作项目中：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To execute these commands on Windows, you should consider installing Git for
    Windows. It comes with many Linux commands compiled to work under Windows. Here’s
    the link:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上执行这些命令，您应该考虑安装 Git for Windows。它包含许多编译在 Windows 下工作的 Linux 命令。以下是链接：
- en: '[https://gitforwindows.org](https://gitforwindows.org)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gitforwindows.org](https://gitforwindows.org)'
- en: Alternatively, on Windows you can use WSL2 or Linux running under a Vagrant
    VM. See chapter 3 and appendix A for more details.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 Windows 上，您可以使用 WSL2 或在 Vagrant VM 下运行的 Linux。有关更多详细信息，请参阅第 3 章和附录 A。
- en: The example code in chapters 6 and 7 is designed to be used in this evolutionary
    way, and thus, emulates the real iterative process of infrastructure development.
    Figure 6.8 shows this process. Note how we use multiple iterations of the `terraform`
    `apply` command as we edit our infrastructure code. Through this, we progressively
    add to and update our growing infrastructure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章和第 7 章中的示例代码旨在以这种方式使用，因此模拟了基础设施开发的实际迭代过程。图 6.8 展示了此过程。注意我们如何在我们编辑基础设施代码时使用多个
    `terraform apply` 命令的迭代。通过这种方式，我们逐步添加和更新我们不断增长的基础设施。
- en: Tip It’s best to use Git to keep track of the updated code that you copy into
    your working project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 使用 Git 来跟踪您复制到工作项目中的更新代码是最佳选择。
- en: After copying the code from example-1, create a new Git code repository and
    commit the code. Then, after you copy each new example to your working project,
    you can use `git diff` to understand the new changes that are going in. At each
    iteration, commit the updated code and continue with the next example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 example-1 复制代码后，创建一个新的 Git 代码仓库并提交代码。然后，在您将每个新示例复制到工作项目后，您可以使用 `git diff`
    来理解正在进行的新的更改。在每个迭代中，提交更新后的代码并继续下一个示例。
- en: '![](../Images/CH06_F08_Davis4.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F08_Davis4.png)'
- en: Figure 6.8 Iterative evolution of infrastructure with Terraform
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 Terraform 基础设施迭代进化
- en: This might all seem like a lot of work. I understand you are busy, and you might
    not have time to follow along using the evolutionary method. If that’s the case,
    feel free to jump directly to any example in this chapter that you might like
    to run. These are all designed to run standalone, so you can follow along whichever
    way you like.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一项大量工作。我理解您很忙，可能没有时间使用进化方法跟随。如果是这样，您可以自由地直接跳转到本章中您可能想运行的任何示例。这些示例都是设计为独立运行的，因此您可以按照您喜欢的任何方式跟随。
- en: I will say this, though, if you do want to follow along with every example,
    then the iterative evolutionary approach is actually more efficient. That’s because
    at each step of the iteration, Terraform only creates those resources that don’t
    already exist.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我要说的是，如果您确实想跟随每个示例，那么迭代进化方法实际上更有效。这是因为迭代过程中的每个步骤，Terraform 只会创建那些尚未存在的资源。
- en: If instead, you run each example on its own, you will end up running Terraform
    to create a complete infrastructure for each example. That’s the least efficient
    way to do this. Creating a Kubernetes cluster from scratch is slow, but updating
    an existing Kubernetes cluster is much quicker! Following along with the evolutionary
    approach can actually save you some time!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单独运行每个示例，您将最终运行 Terraform 来为每个示例创建完整的基础设施。这是最不有效的方法。从头开始创建 Kubernetes 集群很慢，但更新现有的
    Kubernetes 集群要快得多！跟随进化方法实际上可以为您节省一些时间！
- en: 6.8.2 Scripting infrastructure creation
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.2 编写基础设施创建脚本
- en: Listing 6.1 shows our first Terraform code file. It doesn’t get much simpler
    than this. Using the Azure provider, we will create an Azure resource group simply
    by declaring it in three lines of Terraform code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 展示了我们的第一个 Terraform 代码文件。这已经非常简单了。通过使用 Azure 提供程序，我们只需在 Terraform 代码中声明三行即可创建
    Azure 资源组。
- en: Listing 6.1 Creating an Azure resource group (chapter-6/example-1/scripts/resource-group.tf)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 创建 Azure 资源组（第 6 章/example-1/scripts/resource-group.tf）
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Declares an Azure resource group. This resource group will contain all the
    resources we create, so it’s a fundamental beginning for our new infrastructure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明一个 Azure 资源组。此资源组将包含我们创建的所有资源，因此它是我们新基础设施的基本起点。
- en: ② Sets the name of the resource group
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置资源组的名称
- en: ③ Sets the location (data center) where the resource group will be created
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置资源组创建的位置（数据中心）
- en: Through Terraform code, we are defining the components of our infrastructure.
    In listing 6.1, we have defined the first piece of our infrastructure. We have
    declared an Azure resource group called `flixtube` that has the type, `azurerm_resource_group`*.*
    This is a Terraform resource type that comes from the Azure provider and gives
    us the ability to create a resource group on Azure. Soon we’ll run Terraform,
    and it will create this resource group in our Azure account just how we have configured
    it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Terraform 代码，我们正在定义我们的基础设施组件。在列表 6.1 中，我们定义了我们的基础设施的第一部分。我们声明了一个名为 `flixtube`
    的 Azure 资源组，其类型为 `azurerm_resource_group`*.* 这是一种来自 Azure 提供程序的 Terraform 资源类型，它使我们能够在
    Azure 上创建资源组。很快，我们将运行 Terraform，它将在我们的 Azure 账户中创建这个资源组，正如我们配置的那样。
- en: 6.8.3 Initializing Terraform
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.3 初始化 Terraform
- en: We have taken the first steps in creating our infrastructure. We wrote a simple
    script that creates an Azure resource group. But before we invoke Terraform and
    execute this script, we must first initialize Terraform.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建我们的基础设施方面已经迈出了第一步。我们编写了一个简单的脚本，用于创建 Azure 资源组。但在调用 Terraform 并执行此脚本之前，我们必须首先初始化
    Terraform。
- en: 'When we initialize Terraform, it downloads the provider plugins required for
    our script. At this point, we only need the Azure provider. To initialize Terraform,
    first change directory to the location of the Terraform code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化 Terraform 时，它会下载我们脚本所需的提供程序插件。此时，我们只需要 Azure 提供程序。要初始化 Terraform，首先将目录更改为
    Terraform 代码的位置：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now run the `terraform` `init` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `terraform init` 命令：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see some output indicating that the Azure provider plugin is downloaded;
    for example,
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一些输出，表明 Azure 提供程序插件已下载；例如，
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once this completes, we are now ready to execute our Terraform code. We must
    always run the `terraform` `init` command at least once for each Terraform project
    before we execute any Terraform code in that directory. You must also run it at
    least once for each new provider that you use. Each time you invoke `terraform`
    `init`, it only downloads those providers that it has not yet cached.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们现在就可以执行我们的 Terraform 代码了。在执行该目录中的任何 Terraform 代码之前，我们必须为每个 Terraform
    项目至少运行一次 `terraform init` 命令。您还必须为每个新提供的程序至少运行一次。每次调用 `terraform init` 时，它只会下载尚未缓存的提供程序。
- en: If you are following along with the examples in chapters 6 and 7 in the evolutionary
    way proposed in section 6.8.1, then you only need to do the initialization for
    each example that includes a new provider. Otherwise, if you run each example
    standalone, you’ll just need to remember to run `terraform init` for each example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照 6.8.1 节中提出的进化方式跟随第 6 章和第 7 章的示例，那么您只需要为包含新提供程序的每个示例进行初始化。否则，如果您独立运行每个示例，您只需记住为每个示例运行
    `terraform init` 即可。
- en: Don’t worry if you forget to run `terraform init`, it won’t cause you any problem.
    When you forget, Terraform reminds you that you need to do that first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记运行 `terraform init`，请不要担心，它不会给您带来任何问题。当您忘记时，Terraform 会提醒您需要先做这件事。
- en: 6.8.4 By-products of Terraform initialization
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.4 Terraform 初始化的副产品
- en: With Terraform initialized, we can now inspect the files that the `init` command
    has created or downloaded in the scripts subdirectory. Have a look through the
    scripts directory and see what you can find. Figure 6.9 shows the example-1 project
    after running `terraform init`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 初始化后，我们现在可以检查 `init` 命令在脚本子目录中创建或下载的文件。浏览脚本目录，看看你能找到什么。图 6.9 展示了运行
    `terraform init` 后的 example-1 项目。
- en: '![](../Images/CH06_F09_Davis4.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F09_Davis4.png)'
- en: Figure 6.9 Files downloaded or created while running `terraform` `init`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 展示了运行 `terraform init` 时下载或创建的文件。
- en: You’ll notice there’s a hidden subdirectory, `.terraform`, that was created,
    and it contains a bunch of files. This is the place where Terraform stores the
    provider plugins that it has downloaded. These are cached here so they can be
    reused each time we invoke Terraform.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到创建了一个隐藏的子目录 `.terraform`，其中包含了一些文件。这是 Terraform 存储已下载的提供程序插件的地方。这些文件被缓存在这里，以便每次调用
    Terraform 时可以重复使用。
- en: 6.8.5 Fixing provider version numbers
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.5 修复提供程序版本号
- en: Before we invoke Terraform for the first time, let’s talk about that other file
    in our project. Listing 6.2 shows the code for providers.tf. This is the file
    where we define and configure all of our Terraform provider plugins.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次调用 Terraform 之前，让我们谈谈我们项目中那个其他文件。列表 6.2 展示了 providers.tf 的代码。这是我们定义和配置所有
    Terraform 提供程序插件的文件。
- en: Listing 6.2 Configuring Terraform provider plugins (chapter-6/example-1/scripts/providers.tf)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 配置 Terraform 供应商插件（第 6 章/示例 1/脚本/providers.tf）
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Sets the name of the provider plugin
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置供应商插件的名称
- en: ② Sets the version of the provider plugin to download and use
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置要下载和使用的供应商插件的版本
- en: Technically, we don’t need this file yet, and we don’t need to declare our providers
    ahead of time. We can simply invoke `terraform init`, and it is smart enough to
    figure out which providers we need and download those for us.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们目前不需要这个文件，也不需要提前声明我们的供应商。我们可以简单地调用 `terraform init`，它足够智能，能够找出我们需要哪些供应商，并为我们下载它们。
- en: 'This is convenient when starting a new project. We can simply start writing
    Terraform code to create our cloud infrastructure, and we don’t have to declare
    our providers upfront. Then, when we invoke `terraform init`, it downloads the
    latest versions of the providers we need. Terraform lists the versions of the
    plugins it downloads in the output, like this extract from the earlier output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新项目时，这很方便。我们可以简单地开始编写 Terraform 代码来创建我们的云基础设施，而且我们不需要提前声明我们的供应商。然后，当我们调用
    `terraform init` 时，它会下载我们需要的供应商的最新版本。Terraform 会列出它下载的插件的版本，就像以下从早期输出中的摘录：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a great way to get started, but it can lead to unexpected problems down
    the road. For example, in the future, you might find yourself unwittingly upgraded
    to a new version of the Azure provider that isn’t 100% backward compatible with
    the version you originally used (yes, that happened to me). As a result, your
    Terraform code can break in ways that are often difficult to predict or understand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种很好的入门方式，但它可能会导致未来出现意外的麻烦。例如，将来，你可能会发现自己无意中升级到了一个与最初使用的版本不100% 兼容的新版本的 Azure
    供应商（是的，这发生在我身上）。结果，你的 Terraform 代码可能会以难以预测或理解的方式中断。
- en: Fortunately, we can preemptively solve this by fixing our versions to those
    that we have tested and that we trust. You can see the current version of any
    provider by inspecting the output from `terraform init` and then hard-code this
    version number into your providers.tf file (as shown in listing 6.2).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过将版本固定为我们已测试并信任的版本来预先解决这个问题。你可以通过检查 `terraform init` 的输出来查看任何供应商的当前版本，然后将此版本号硬编码到你的
    providers.tf 文件中（如列表 6.2 所示）。
- en: Eventually, our Terraform code must run completely unattended in our automated
    CD pipeline (which we’ll create in chapter 7). Our code must be bullet-proof and
    fixing our version numbers makes our Terraform code more reliable. This means
    that in the future, we won’t be exposed to having our dependencies changed underneath
    us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们的 Terraform 代码必须在我们的自动化 CD 管道中完全无人值守地运行（我们将在第 7 章中创建它）。我们的代码必须是坚不可摧的，修复我们的版本号使我们的
    Terraform 代码更加可靠。这意味着在未来，我们不会暴露在依赖项在我们不知情的情况下被更改的风险中。
- en: We can also use the providers.tf as a place to configure other parameters to
    providers. We’ll see an example of this in the next chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 providers.tf 用作配置其他供应商参数的地方。我们将在下一章中看到一个例子。
- en: 6.8.6 Building your infrastructure
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.6 构建你的基础设施
- en: 'After initializing our Terraform project, we are ready to invoke the `terraform`
    `apply` command to execute our Terraform code and build the first iteration of
    our infrastructure. If you need to, refer back to figure 6.8 for a graphical depiction
    of the `apply` command. From the same directory where you invoked the `init` command,
    run this command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化我们的 Terraform 项目后，我们就可以调用 `terraform apply` 命令来执行我们的 Terraform 代码并构建我们基础设施的第一迭代。如果你需要，可以参考图
    6.8 来了解 `apply` 命令的图形表示。从调用 `init` 命令的同一目录中运行此命令：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `apply` command gathers together and executes all of our Terraform code
    files. (So far we only have two code files, but soon we’ll have more.) When you
    invoke the apply command you’ll see output like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 命令会收集并执行我们所有的 Terraform 代码文件。（到目前为止我们只有两个代码文件，但很快我们会更多。）当你调用 apply
    命令时，你会看到如下输出：'
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This output describes the planned update to our infrastructure. Terraform is
    telling us the changes that it is about to make. (You can also use the `terraform`
    `plan` command to get this output separately.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出描述了我们对基础设施的计划更新。Terraform 正在告诉我们它即将做出的更改。（你还可以使用 `terraform plan` 命令单独获取此输出。）
- en: Terraform is now waiting for us to approve the plan before it continues and
    actually makes the update to our infrastructure. It’s a good idea at this point
    to scan the output and double-check that the upcoming changes are OK and what
    we expect. Once happy with the plan, type `yes` and press Enter to allow Terraform
    to proceed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform现在正在等待我们批准计划，然后才会继续并实际上对我们的基础设施进行更新。此时检查输出并确保即将到来的更改是OK的，符合我们的预期是个好主意。一旦对计划满意，输入`yes`并按Enter键允许Terraform继续。
- en: 'Terraform now creates the infrastructure we requested. In this case, on our
    first invocation of Terraform, the flixtube resource group is created in our Azure
    account. This should happen pretty quickly (because at the moment it’s still a
    small script and doesn’t do much). Then you’ll see a success message like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform现在正在创建我们请求的基础设施。在这种情况下，在我们首次调用Terraform时，flixtube资源组被创建在我们的Azure账户中。这应该会很快发生（因为目前它仍然是一个小脚本，并没有做太多）。然后你会看到一条成功消息，如下所示：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output gives a quick summary of what was added, changed, and deleted. In
    this case, it confirms what we already know, that we have created one cloud resource,
    our Azure resource group.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给出了一个快速总结，说明了添加了什么、更改了什么、删除了什么。在这种情况下，它确认了我们已经知道的事情，即我们创建了一个云资源，我们的Azure资源组。
- en: Now let’s manually check what the change looks like. Open your web browser and
    navigate to the Azure portal at [https://portal.azure.com/](https://portal.azure.com/).
    You can check for yourself that an Azure resource group has indeed been created
    in your Azure account. In the portal, click Resource Groups and verify that the
    flixtube resource group is now in the list. This is what your first Terraform
    code just created!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们手动检查更改看起来像什么。打开你的网络浏览器，导航到Azure门户[https://portal.azure.com/](https://portal.azure.com/)。你可以亲自检查，确认确实在你的Azure账户中创建了一个Azure资源组。在门户中，点击资源组并验证flixtube资源组现在是否在列表中。这就是你的第一个Terraform代码刚刚创建的内容！
- en: Of course, you don’t always need to check that every resource has been created
    by manually inspecting the Azure portal. We are only doing this in the first instance
    so that you can connect the dots about what just happened.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必总是通过手动检查Azure门户来确认每个资源是否已创建。我们在这里这样做只是为了让你能够理解刚才发生的事情。
- en: 6.8.7 Understanding Terraform state
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.7 理解Terraform状态
- en: At this point, after invoking `terraform` `apply` in our project for the first
    time, Terraform will have generated its state file terraform.tfstate. You should
    see this file in the same directory as your Terraform code files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，在我们项目中对`terraform` `apply`进行首次调用后，Terraform将生成其状态文件`terraform.tfstate`。你应该能在与你的Terraform代码文件相同的目录中看到这个文件。
- en: It’s important that we understand Terraform’s persistent state management; although,
    most of the time we won’t care what’s in the state file. But it’s good to know
    why it’s there and how to deal with it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Terraform的持久状态管理很重要；尽管大多数时候我们不会关心状态文件中的内容。但了解为什么它存在以及如何处理它是很好的。
- en: 'Let’s take a look at our Terraform state file and see what it looks like after
    we have created our first piece of infrastructure. This is a good time to look
    at the state file: while it’s still small and easily understandable. Invoke the
    `cat` command to display the state file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们的Terraform状态文件，看看在我们创建了第一件基础设施之后它看起来像什么。这是一个查看状态文件的好时机：因为此时它仍然很小，很容易理解。调用`cat`命令来显示状态文件：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Your output will look something like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将类似于以下内容：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that our Terraform state file has one item in the `resources` field.
    The details of the resource group we just created were recorded in this state
    file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们的Terraform状态文件在`resources`字段中有一个条目。我们刚刚创建的资源组的详细信息都记录在这个状态文件中。
- en: The first time we invoked `terraform` `apply`, the state file is generated.
    Subsequent invocations of `terraform` `apply` use the state file as input. Terraform
    loads the state file and then *refreshes* it from the live infrastructure. Figure
    6.10 shows how successive invocations of Terraform are connected by both the live
    infrastructure and the state file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次调用`terraform` `apply`时，会生成状态文件。随后的`terraform` `apply`调用将使用状态文件作为输入。Terraform加载状态文件，然后从实时基础设施中*刷新*它。图6.10显示了连续调用Terraform是如何通过实时基础设施和状态文件连接起来的。
- en: 'You might like to know at this point what exactly is the point of the state
    file? If our infrastructure is defined in our Terraform code, and Terraform can
    know the current state directly from the live infrastructure, why must it persist
    the state in a separate file? There are two points to consider to understand why
    the state file is necessary:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道此时状态文件的确切作用是什么？如果我们的基础设施定义在我们的Terraform代码中，并且Terraform可以直接从实际基础设施中知道当前状态，为什么它必须将状态保存在单独的文件中？有两个要点需要考虑，以理解为什么状态文件是必要的：
- en: This Terraform project doesn’t *own* all the infrastructure in your Azure account.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个Terraform项目并不*拥有*你Azure账户中的所有基础设施。
- en: As we make changes to our Terraform code (to change our infrastructure), it
    becomes out of sync with the live infrastructure. (We are relying on Terraform
    to change the live infrastructure to make it look like our declared infrastructure.)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们更改我们的Terraform代码（以更改我们的基础设施）时，它与实际基础设施就不再同步。（我们依赖Terraform更改实际基础设施，使其看起来像我们声明的基础设施。）
- en: '![](../Images/CH06_F10_Davis4.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 理解Terraform状态对于使用Terraform至关重要](../Images/CH06_F10_Davis4.png)'
- en: Figure 6.10 Understanding Terraform state is crucial to working with Terraform.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 理解Terraform状态对于使用Terraform至关重要。
- en: Let’s consider the first point. An Azure subscription may well be shared among
    multiple projects. Infrastructure in that account can have been created by other
    Terraform projects or even by entirely different means (e.g., created manually
    in the Azure portal or with the Azure CLI tool).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第一个点。Azure订阅可能被多个项目共享。该账户中的基础设施可能是由其他Terraform项目创建的，甚至可能是由完全不同的方式（例如，在Azure门户中手动创建或使用Azure
    CLI工具）创建的。
- en: As you follow the examples in this book, you most likely have an entire Azure
    subscription dedicated to it. But this won’t be the case if you are working for
    a company that is managing multiple projects or if you are managing multiple projects
    yourself. In that case, an Azure subscription is shared between projects, with
    the subscription containing multiple sets of infrastructure.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在这本书中的示例，你很可能有一个整个Azure订阅都为此而设。但如果你是在管理多个项目的公司工作，或者你自己正在管理多个项目，情况就不同了。在这种情况下，Azure订阅将在项目之间共享，订阅包含多套基础设施。
- en: The point I’m making is that Terraform *can’t* and, indeed, *doesn’t* assume
    that it owns everything in the Azure account that it is allowed to access. What
    this means is that Terraform can’t simply read the live infrastructure and assume
    that it owns everything. It can only assume ownership of infrastructure that is
    either declared in our infrastructure code or that is recorded in the state file.
    The first thing that Terraform does is load your code and your state file. That’s
    how it *knows* which set of infrastructure it owns.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我要说明的是，Terraform*不能*，实际上*也不*假设它拥有它被允许访问的Azure账户中的所有内容。这意味着Terraform不能简单地读取实际基础设施并假设它拥有所有内容。它只能假设拥有在基础设施代码中声明或记录在状态文件中的基础设施。Terraform首先做的事情是加载你的代码和状态文件。这就是它*知道*它拥有哪套基础设施。
- en: Terraform always wants to be up to date though, so after loading the state file,
    it refreshes the state directly from the live infrastructure. This allows Terraform
    to handle configuration drift when the actual state has changed (e.g., because
    someone tweaked it manually) from the previously recorded state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Terraform总是希望保持最新状态，因此加载状态文件后，它会直接从实际基础设施刷新状态。这允许Terraform处理实际状态已从先前记录的状态发生变化时的配置漂移（例如，因为有人手动调整了它）。
- en: You can see how this might affect performance as well. Terraform only queries
    those parts of the live infrastructure for which it is responsible; those parts
    which it knows about because of the recorded state. If, instead, it queried *all*
    live infrastructure, that could be an expensive and time-consuming operation,
    depending on the total amount of infrastructure that exists in our Azure account.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这可能会如何影响性能。Terraform只查询它负责的实时基础设施的部分；那些因为它记录的状态而知道的部分。相反，如果它查询*所有*实时基础设施，这可能是一个昂贵且耗时的操作，具体取决于我们Azure账户中存在的总基础设施量。
- en: Now, let’s consider the second point mentioned. As we change our Terraform code
    (to change our infrastructure), it becomes out of sync with our live infrastructure.
    That’s because we are leading changes to the infrastructure with changes in the
    code. That’s why we call it *infrastructure as code*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑提到的第二点。当我们更改我们的Terraform代码（以更改我们的基础设施）时，它与我们的实际基础设施就不再同步。这是因为我们通过代码的更改来引导基础设施的变更。这就是为什么我们称之为*基础设施即代码*。
- en: We can add, update, and delete infrastructure by modifying our code. How does
    Terraform know what’s changed? Terraform compares its recorded state with what’s
    in our code. Terraform then automatically figures out the precise set of changes
    it needs to update our infrastructure. It’s amazing when you think it through,
    just how smart Terraform is and how much work it can do on your behalf.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的代码来添加、更新和删除基础设施。Terraform 如何知道发生了什么变化？Terraform 将其记录的状态与我们的代码中的内容进行比较。然后，Terraform
    自动确定需要更新我们的基础设施的确切更改集。当你仔细思考时，你会发现 Terraform 是多么聪明，它能为您做多少工作。
- en: Now you know more than you probably wanted to about Terraform state, but honestly,
    it’s crucial that we have a good understanding of Terraform state before we can
    implement it properly in our CD pipeline. We’ll come to that in the next chapter.
    As you proceed through the examples in this chapter and the next, feel free to
    look at the state file again to see how it grows and changes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能已经了解得比您想要的更多关于 Terraform 状态的信息，但说实话，在我们能够正确地在我们的 CD 流水线中实施它之前，我们有一个很好的理解是非常重要的。我们将在下一章中讨论这一点。随着您在本章和下一章的示例中前进，请随时再次查看状态文件，以查看它是如何增长和变化的。
- en: 6.8.8 Destroying and recreating your infrastructure
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.8 销毁和重新创建您的基础设施
- en: We have bootstrapped our infrastructure! It’s not much yet, but it’s a good
    start. Before we continue evolving our infrastructure, let’s take some time out
    to experiment with destroying and rebuilding it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了我们的基础设施！目前它还不算多，但这是一个良好的开始。在我们继续演进我们的基础设施之前，让我们花些时间来尝试销毁和重建它。
- en: The reason we are choosing this moment to experiment is that it’s more efficient
    to do this experimentation while our infrastructure is small. At the end of this
    chapter, we’ll have added a Kubernetes cluster, and that will take much more time
    to destroy and rebuild.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这个时刻进行实验的原因是，当我们的基础设施规模较小时，进行这种实验更有效率。在本章结束时，我们将添加一个 Kubernetes 集群，这将需要更多的时间来销毁和重建。
- en: Not to mention that eventually, you’ll need to clean up these Azure resources
    anyway. You don’t want to end up paying for those (unless, of course, you are
    developing a real product). *It costs money to run this infrastructure* ; although,
    I hope you are starting with the free credit from Azure. But don’t leave it running
    longer than you need it!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更不用说最终，您仍然需要清理这些 Azure 资源。您不希望最终为此付费（除非，当然，您正在开发一个真实的产品）。*运行此基础设施需要花费金钱*；尽管如此，我希望您是从
    Azure 的免费信用额度开始的。但不要让它运行超过您需要的时长！
- en: 'Now, go ahead and destroy your current infrastructure with the Terraform `destroy`
    command like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请使用 Terraform 的 `destroy` 命令像这样销毁您当前的基础设施：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Your output will look something like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将类似于以下内容：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Just like the `apply` command, `destroy` shows us its plan. These are the changes
    it will make. To continue, we must type `yes` and press Enter. Terraform does
    the work and displays a summary:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `apply` 命令一样，`destroy` 会显示其计划。这些都是它将做出的更改。要继续，我们必须输入 `yes` 并按 Enter 键。Terraform
    完成工作并显示摘要：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you have finished with each example in the book, you should invoke `destroy`
    to clean up the infrastructure that you created. If you are evolving your infrastructure
    using the iterative method from section 6.8.1 and following this all the way to
    the end of chapter 7, then you won’t need to invoke `destroy` again until the
    end.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成书中的每个示例后，您应该调用 `destroy` 来清理您创建的基础设施。如果您正在使用第 6.8.1 节中描述的迭代方法演进您的基础设施，并且一直做到第
    7 章的结尾，那么您不需要再次调用 `destroy`，直到书的结尾。
- en: You could also manually delete Azure resources through the Azure portal or the
    Azure CLI tool. But it’s easier to do this with the `destroy` command. It also
    means you won’t accidentally delete other infrastructure, say, if you are sharing
    the Azure subscription with other projects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 Azure 门户或 Azure CLI 工具手动删除 Azure 资源。但使用 `destroy` 命令来做这件事更简单。这也意味着您不会意外地删除其他基础设施，比如说，如果您与其他项目共享
    Azure 订阅的话。
- en: 'After your practice run with `terraform destroy`, it’s simple to rebuild your
    infrastructure. For that, we’ll simply invoke `terraform apply` again:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 `terraform destroy` 进行练习运行后，重新构建您的基础设施变得简单。为此，我们只需再次调用 `terraform apply`：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Practice this as many times as you want. This process of destroying and rebuilding
    your infrastructure helps you comprehend the fact that you are actually managing
    infrastructure with executable code! You can destroy and create your infrastructure
    at will with no manual effort. At this early stage, this doesn’t seem like much,
    but the significance of this increases as your infrastructure and application
    grow larger and more complex.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尽可能多地练习这个过程。销毁和重建你的基础设施的过程有助于你理解你实际上是在用可执行代码管理基础设施！你可以随意销毁和创建你的基础设施，无需任何手动操作。在这个早期阶段，这看起来可能不多，但随着你的基础设施和应用程序变得更大、更复杂，其重要性会逐渐增加。
- en: In fact, you may have already realized that we can use our Terraform code to
    create multiple copies of our infrastructure! In chapter 11, we’ll learn how to
    parameterize our Terraform code to create separate instances for development,
    testing, and production. If that doesn’t excite you, I don’t know what will.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能已经意识到我们可以使用我们的 Terraform 代码来创建我们基础设施的多个副本！在第 11 章中，我们将学习如何参数化我们的 Terraform
    代码，以创建用于开发、测试和生产的独立实例。如果这还不能让你兴奋，我不知道还有什么能让你兴奋。
- en: 6.8.9 What have we achieved?
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8.9 我们取得了什么成果？
- en: We now have Terraform installed and we have built our fledgling infrastructure.
    Terraform is the tool we use for *infrastructure as code*. This is the technique
    where we store our infrastructure configuration as executable code (e.g., in Terraform
    code files) that we can use to create, manage, and destroy our infrastructure.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Terraform，并且我们已经构建了我们初生的基础设施。Terraform 是我们用于 *基础设施即代码* 的工具。这是一种技术，我们将基础设施配置存储为可执行代码（例如，在
    Terraform 代码文件中），我们可以使用它来创建、管理和销毁我们的基础设施。
- en: We also created our first Terraform code files and initialized our project using
    `terraform init`. Then we invoked `terraform apply` to create an Azure resource
    group. And we learned how to destroy and recreate our infrastructure using `terraform
    destroy` followed by `terraform` `apply`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了我们的第一个 Terraform 代码文件，并使用 `terraform init` 初始化了我们的项目。然后我们调用了 `terraform
    apply` 来创建一个 Azure 资源组。我们还学习了如何使用 `terraform destroy` 后跟 `terraform apply` 来销毁和重新创建我们的基础设施。
- en: 6.9 Creating your container registry
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 创建你的容器注册库
- en: The next step for our infrastructure is to create a private container registry.
    We’ll use this registry in the next chapter to publish Docker images for our microservices.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基础设施的下一步是创建一个私有容器注册库。我们将在下一章中使用这个注册库来发布我们的微服务的 Docker 镜像。
- en: If you remember back in chapter 3, we learned how to build and publish Docker
    images. In that chapter, we manually created a container registry through the
    GUI in the Azure portal. Now that we have a basic understanding of Terraform,
    we will revisit that territory and create our registry with code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得在第三章，我们学习了如何构建和发布 Docker 镜像。在那个章节中，我们通过 Azure 门户中的 GUI 手动创建了一个容器注册库。现在，我们已经对
    Terraform 有了一个基本的了解，我们将重新访问那个领域，并使用代码创建我们的注册库。
- en: 6.9.1 Continuing the evolution of our infrastructure
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 我们基础设施的持续进化
- en: 'We are now moving to example-2 in the chapter 6 code repository. At this point,
    if you are working in an iterative manner and continuing onward from example-1,
    you should copy the example-2 code to the working directory you created earlier
    in section 6.8.1:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在将第 6 章代码库中的 example-2 移动到下一步。在这个阶段，如果你是以迭代的方式工作，并从 example-1 继续前进，你应该将
    example-2 的代码复制到你在 6.8.1 节中创建的工作目录中：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you are instead working with each example as a separate project, you should
    destroy the infrastructure you created from example-1:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是将每个示例作为一个独立的项目来处理，你应该销毁从 example-1 创建的基础设施：
- en: '[PRE31]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After destroying the example-1 infrastructure, you can move to example-2 and
    initialize it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在销毁 example-1 基础设施之后，你可以移动到 example-2 并初始化它：
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 6.9.2 Creating the container registry
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 创建容器注册库
- en: Listing 6.3 shows the newest Terraform code file that creates our container
    registry. To get this code to work you need to change the name of the registry.
    That’s because Azure container registry names must be unique. It won’t let you
    use the same name I have chosen (flixtube).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 展示了创建我们容器注册库的最新 Terraform 代码文件。要让这段代码工作，你需要更改注册库的名称。这是因为 Azure 容器注册库的名称必须是唯一的。它不会允许你使用我选择的相同名称（flixtube）。
- en: If you are following along, go into container-registry.tf now. Change the name
    of the registry to something else.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，现在进入 container-registry.tf。将注册库的名称更改为其他名称。
- en: Listing 6.3 Creating our private container registry (extract from chapter-6/example-2/scripts/container-registry.tf)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 创建我们的私有容器注册库（摘自 chapter-6/example-2/scripts/container-registry.tf）
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ① Declares the container registry resource
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明容器注册库资源
- en: ② Sets the name of the container registry. This has to be unique, so you must
    change this to something else.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置容器注册库的名称。这必须是唯一的，所以你必须将其更改为其他内容。
- en: ③ Sets the name of the resource group and creates a link to another resource
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置资源组的名称并创建到另一个资源的链接
- en: ④ Sets the location of the container registry
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 设置容器注册库的位置
- en: ⑤ Enables the admin account so we can remotely authenticate with the registry
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 启用管理员账户，以便我们可以远程对注册库进行身份验证
- en: ⑥ Using the basic SKU costs less and is easier because storage is managed automatically.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 使用基本SKU成本更低，也更简单，因为存储是自动管理的。
- en: Note In case you were wondering, a SKU or *stock keeping unit* is a different
    version of a product. What this means here is that we are using the Basic version
    of the container registry.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您有所疑问，SKU（库存单位）或*库存保持单元*是产品的不同版本。在这里这意味着我们正在使用容器注册库的基本版本。
- en: Take note of how the value of `resource_group_name` is set from the properties
    of a resource that is defined in another file (the file resource-group.tf that
    we looked at in figure 6.1). These two resources are now linked via the Terraform
    *resource graph*. This is how Terraform manages the dependencies between resources.
    It’s how Terraform knows the order in which it should execute our script files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`resource_group_name`的值是如何从另一个文件（我们在图6.1中查看的`resource-group.tf`文件）中定义的资源属性中设置的。这两个资源现在通过Terraform的*资源图*相互链接。这就是Terraform管理资源之间依赖关系的方式。这是Terraform知道它应该按什么顺序执行我们的脚本文件的方式。
- en: 'Terraform must create the resource group *before* it can populate our Azure
    account with other resources (such as the new container registry). Let’s invoke
    the `apply` command to add this new piece of infrastructure:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform必须在将其他资源（如新的容器注册库）填充到我们的Azure账户之前创建资源组。让我们调用`apply`命令来添加这个新的基础设施部分：
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we use the `-auto-approve` argument this time. That means we don’t
    have to type `yes` each time to approve the changes. This is convenient while
    we are prototyping our infrastructure, but it becomes essential in the next chapter,
    when we create our CD pipeline. At that point, we will need to invoke Terraform
    in an automated and unattended manner. There will be no person there to do the
    approval! Because of this, we’ll now start using `-auto-approve` to run Terraform
    in *non-interactive* mode.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次我们使用了`-auto-approve`参数。这意味着我们不必每次都输入`yes`来批准更改。在我们原型化我们的基础设施时，这很方便，但在下一章，当我们创建我们的持续交付（CD）管道时，这变得至关重要。到那时，我们将需要以自动和无人值守的方式调用Terraform。那里将没有人来进行批准！正因为如此，我们现在开始使用`-auto-approve`以*非交互式*模式运行Terraform。
- en: We start to create more complex infrastructure now, so you might have to wait
    a bit longer than last time. Once it’s finished, you’ll see output similar to
    before; Terraform is showing us what’s changed in our infrastructure. Tacked on
    the end, though, you’ll see some new output. This gives us the details we need
    to authenticate with our new container registry. We’ll learn more about this new
    output in the next section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始创建更复杂的基础设施，所以你可能需要比上次等待更长的时间。一旦完成，你将看到与之前类似的输出；Terraform正在向我们展示我们的基础设施中发生了什么变化。然而，在末尾，你将看到一些新的输出。这为我们提供了与我们的新容器注册库进行身份验证所需的详细信息。我们将在下一节中了解更多关于这个新输出的信息。
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 6.9.3 Terraform outputs
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.3 Terraform输出
- en: Terraform (or the underlying plugin providers) often produces configuration
    information that we need to know. In the previous section, we created our new
    container registry. In listing 6.3, you saw that we enabled the admin user for
    the registry. This allows us to authenticate and interact with our registry (pushing
    and pulling Docker images).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform（或其底层的插件提供者）通常会生成我们需要了解的配置信息。在上一节中，我们创建了新的容器注册库。在列表6.3中，你看到我们为注册库启用了管理员用户。这允许我们进行身份验证并与我们的注册库（推送和拉取Docker镜像）进行交互。
- en: Note Enabling the admin user causes Terraform to generate a username and password.
    We need to take note of these details so we can later use those to login to our
    registry.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：启用管理员用户会导致Terraform生成用户名和密码。我们需要注意这些细节，以便我们可以在以后使用这些信息登录到我们的注册库。
- en: We can use *Terraform outputs* to extract generated configuration details from
    our Terraform code. In listing 6.4, you can see multiple outputs declared. This
    causes these values to be displayed in the terminal when we execute this code.
    We’ll also use outputs in multiple other code files, so look for these in future
    code listings.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *Terraform输出* 从我们的Terraform代码中提取生成的配置细节。在列表6.4中，你可以看到声明了多个输出。这导致在执行此代码时，这些值将在终端中显示。我们还会在多个其他代码文件中使用输出，所以请在未来的代码列表中寻找这些输出。
- en: Listing 6.4 Terraform outputs (extract from chapter-6/example-2/scripts/container-registry.tf)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 Terraform输出（章节-6/示例-2/脚本/container-registry.tf的摘录）
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Creates an output
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个输出
- en: ② Sets the values to be output
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置要输出的值
- en: 6.9.4 What have we achieved?
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.4 我们取得了什么成果？
- en: We have continued to evolve our infrastructure by creating a container registry.
    This is something we’ll need in the next chapter, when we publish Docker images
    for our microservices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建容器注册库继续演变我们的基础设施。这是我们在下一章中为我们的微服务发布Docker镜像时需要的东西。
- en: In this section, we added a new Terraform code file and executed it. This created
    the new container registry in our Azure account. Finally, we learned about how
    we can use Terraform outputs to display pertinent information about the resources
    and infrastructure that was created.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了一个新的Terraform代码文件并执行了它。这在我们Azure账户中创建了一个新的容器注册库。最后，我们学习了如何使用Terraform输出显示有关创建的资源和管理基础设施的相关信息。
- en: 6.10 Refactoring to share configuration data
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10 重构以共享配置数据
- en: You might have noticed in recent code listings that we are starting to repeat
    certain configuration values from file to file. This can be a problem when it
    comes to changing these values. Ideally, we’d like to be able to change important
    values in one place and have these shared between all our Terraform code files.
    We can achieve this with *Terraform variables*, so now we’ll refactor our code
    to share configuration data.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在最近的代码列表中，我们开始重复某些配置值从文件到文件。当需要更改这些值时，这可能会成为一个问题。理想情况下，我们希望能够在一个地方更改重要的值，并且这些值可以在所有我们的Terraform代码文件之间共享。我们可以通过使用
    *Terraform变量* 来实现这一点，因此现在我们将重构我们的代码以共享配置数据。
- en: 6.10.1 Continuing the evolution of our infrastructure
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.10.1 继续我们基础设施的演变
- en: 'We now move to example-3 in the chapter 6 code repository. At this point, if
    you are working in an iterative manner and continuing from earlier examples, you
    can now copy the example-4 code to the working directory you created earlier in
    6.8.1:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向章节6代码库中的示例-3。在此阶段，如果你以迭代方式工作并从早期示例继续，你现在可以将示例-4代码复制到你在6.8.1中创建的早期工作目录中：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Otherwise, you can jump directly to example-3 and run `terraform` `init` in
    the chapter-6/ example-3/scripts directory. If you do this, don’t forget to first
    destroy any infrastructure you created for earlier examples.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以直接跳转到示例-3并在章节-6/example-3/scripts目录中运行 `terraform` `init`。如果你这样做，别忘了首先销毁为早期示例创建的任何基础设施。
- en: 6.10.2 Introducing Terraform variables
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.10.2 介绍Terraform变量
- en: Example-3 in the chapter 6 code repository is a refactoring of example-2, modified
    to share configuration values between code files, adding a new file called variables.tf.
    Listing 6.5 shows the new code file.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 章节第6代码库中的示例-3是对示例-2的重构，修改为在代码文件之间共享配置值，添加了一个名为variables.tf的新文件。列表6.5显示了新的代码文件。
- en: In the listing, you can see how Terraform global variables are defined for some
    of our most important configuration values. We have variables defined for the
    name of our application (flixtube), the location of our data center (West US),
    and more like that.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，你可以看到Terraform全局变量是如何定义我们一些最重要的配置值的。我们为我们的应用程序名称（flixtube）、数据中心位置（西US）等定义了变量。
- en: Listing 6.5 Setting Terraform global variables (chapter-6/example-3/scripts/variables.tf)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 设置Terraform全局变量（章节-6/示例-3/脚本/variables.tf）
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Sets default values for global variables that we use across multiple Terraform
    code files
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为我们在多个Terraform代码文件中使用的全局变量设置默认值
- en: At this point, if you are following along, you should edit variables.tf and
    set a *unique* name for your application. In listing 6.5, the name is set to `flixtube`.
    There are various Azure resource names that will be set from this variable and
    some will need to be unique for your own version of this project (e.g., the name
    of your container registry).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你一直在跟随，你应该编辑 variables.tf 并为你的应用程序设置一个 *唯一的* 名称。在列表 6.5 中，名称被设置为 `flixtube`。将从这个变量设置各种
    Azure 资源名称，其中一些将需要为这个项目的你的版本唯一（例如，你的容器注册表的名称）。
- en: Listings 6.6 and 6.7 show how we use our new variables. You can see that the
    name of our resource group and the name of our container registry are both set
    from the value of the `app_name` variable. We can also set the locations of these
    resources from the `location` variable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 和 6.7 展示了我们如何使用我们的新变量。你可以看到，我们的资源组名称和我们的容器注册表名称都是从 `app_name` 变量的值设置的。我们还可以从
    `location` 变量设置这些资源的地理位置。
- en: Listing 6.6 Resource group configuration with variables (chapter-6/example-3/scripts/resource-group.tf)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 使用变量配置资源组（第 6 章/示例 3/脚本/resource-group.tf）
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Sets the name of the resource group from the app_name variable
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 app_name 变量设置资源组的名称
- en: ② Sets the location from the location variable
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从位置变量设置位置
- en: Listing 6.7 Container registry configuration with variables (extract from chapter-6/example-3/scripts/container-registry.tf)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 使用变量配置容器注册表（摘自第 6 章/示例 3/脚本/container-registry.tf）
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Sets the name of the container registry from the app_name variable
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 app_name 变量设置容器注册表的名称
- en: ② Sets the location from the location variable
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从位置变量设置位置
- en: We have refactored our Terraform code and shared some pertinent configuration
    values between our code files using Terraform variables. We now have one convenient
    place to go to change these values. For example, let’s say that we want to change
    the location of our application. We can do this simply by changing the `location`
    variable in variables.tf.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了我们的 Terraform 代码，并使用 Terraform 变量在我们的代码文件之间共享了一些相关的配置值。我们现在有一个方便的地方可以更改这些值。例如，假设我们想更改应用程序的位置。我们可以简单地通过更改
    variables.tf 中的 `location` 变量来实现这一点。
- en: 6.11 Creating our Kubernetes cluster
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.11 创建我们的 Kubernetes 集群
- en: Now we arrive at our most vital piece of infrastructure. We need a platform
    on which to host our microservices in production, and for this, we’ll use Terraform
    to create a Kubernetes cluster in our Azure account.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了我们最关键的基础设施部分。我们需要一个平台来托管我们的微服务在生产环境中，为此，我们将使用 Terraform 在我们的 Azure 账户中创建一个
    Kubernetes 集群。
- en: 6.11.1 Scripting creation of your cluster
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11.1 脚本化创建你的集群
- en: Continuing with example-3, now let’s look at the code to create our Kubernetes
    cluster. Listing 6.8 is a new Terraform code file that defines the configuration
    of our cluster.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用示例-3，现在让我们看看创建我们的 Kubernetes 集群的代码。列表 6.8 是一个新的 Terraform 代码文件，它定义了我们的集群配置。
- en: We are making continued use of our Terraform variables here, and some of these
    fields will already be familiar to you. Fields such as `name`, `location`, and
    `resource _group_name` require no new explanation. However, there are other fields
    that will be completely new.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里继续使用我们的 Terraform 变量，并且其中一些字段你可能已经熟悉。例如 `name`、`location` 和 `resource_group_name`
    字段不需要新的解释。然而，还有一些字段将完全陌生。
- en: Listing 6.8 Creating our Kubernetes cluster (chapter-6/example-3/scripts/kubernetes-cluster.tf)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 创建我们的 Kubernetes 集群（第 6 章/示例 3/脚本/kubernetes-cluster.tf）
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Declares the resource for our Kubernetes cluster
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ① 声明我们的 Kubernetes 集群的资源
- en: ② Specifies the version of Kubernetes we are using. By the time you run this
    code, this version may no longer be available on Azure. See section 6.6.3 for
    how to choose a version number.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指定我们正在使用的 Kubernetes 版本。当你运行此代码时，这个版本可能已不再在 Azure 上可用。请参阅第 6.6.3 节了解如何选择版本号。
- en: ③ Sets authentication details for our cluster
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 设置我们集群的认证详情
- en: ④ Configures the nodes for our cluster
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 配置我们集群的节点
- en: ⑤ Configures authentication details to allow the cluster to interact with Azure
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 配置认证详情以允许集群与 Azure 交互
- en: Notice in listing 6.8 how we specify which version of Kubernetes to use. If
    you’ll recall, we decided on this back in section 6.6.3\. Then we provide an SSH
    key that we can use to interact with our cluster. We are linking to the `tls_private_key`
    resource that is defined in the file private-key.tf. In this code file, we use
    a different Terraform provider to generate an SSH key. You haven’t seen this yet
    in a code listing. But if you are curious and want to understand how the SSH key
    is generated, take a look for yourself in the file example-3/scripts/private-key.tf.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表6.8中我们如何指定要使用的Kubernetes版本。如果你还记得，我们是在6.6.3节中决定的。然后我们提供了一个SSH密钥，我们可以使用它来与我们的集群交互。我们正在链接到在`private-key.tf`文件中定义的`tls_private_key`资源。在这个代码文件中，我们使用不同的Terraform提供程序来生成SSH密钥。你还没有在代码列表中看到这一点。但如果你好奇并想了解SSH密钥是如何生成的，请自己查看文件`example-3/scripts/private-key.tf`。
- en: 'Listing 6.8 is also where we define the nodes and VM size that powers our cluster.
    Note here that we are building our cluster on only a single node. Although we
    could easily add more, but we’ll save that for chapter 11\. For now, configuration
    of the service principal is what we must focus on next. Repeated here from listing
    6.8, we link Azure authentication details into the configuration of our cluster:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8也是我们定义集群节点和虚拟机大小的位置。注意，我们正在仅使用单个节点来构建我们的集群。虽然我们可以轻松地添加更多节点，但我们将把这一点留到第11章。现在，我们必须专注于服务主体的配置。以下是从列表6.8中重复的内容，我们将Azure认证详情链接到我们的集群配置中：
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A *service principal* is an authentication mechanism for Azure. It allows our
    cluster to authenticate with Azure so that it can create Azure load balancers
    as external endpoints for our customer-facing microservices (e.g., our front-end
    gateway).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务主体*是Azure的认证机制。它允许我们的集群与Azure进行认证，以便它可以创建Azure负载均衡器作为面向客户的微服务（例如，我们的前端网关）的外部端点。'
- en: We use two new Terraform variables, `client_id` and `client_secret`, which are
    defined in the latest version of variables.tf. We didn’t give these variables
    default values. That’s because these contain sensitive authentication details,
    and for security reasons, we’d prefer not to include their values in our codebase.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个新的Terraform变量，`client_id`和`client_secret`，这些变量定义在最新的`variables.tf`版本中。我们没有为这些变量提供默认值。这是因为这些变量包含敏感的认证信息，出于安全原因，我们更愿意不在代码库中包含它们的值。
- en: 6.11.2 Cluster authentication with Azure
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11.2 使用Azure进行集群认证
- en: We can’t create our cluster just yet. If we invoke the `apply` command at this
    point, Terraform will ask us to provide values for the variables `client_id` and
    `client_secret` `(`because we didn’t supply default values for these in the code).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还不能创建我们的集群。如果我们现在调用`apply`命令，Terraform将会要求我们提供`client_id`和`client_secret`变量的值（因为我们没有在代码中为这些变量提供默认值）。
- en: These variables provide our Kubernetes cluster with the authentication details
    for our Azure subscription. To fulfill these variables, we must first create a
    service principal in Azure. That’s like a separate access account that allows
    our cluster to interact with Azure on our behalf.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量为我们Kubernetes集群提供了我们的Azure订阅的认证详情。为了满足这些变量，我们首先必须在Azure中创建一个服务主体。这就像是一个单独的访问账户，允许我们的集群代表我们与Azure交互。
- en: It is possible to create the service principal completely in Terraform, and
    it would be ideal if we could do that. After all, the service principal is only
    another aspect of our infrastructure, and we’d prefer to have our entire infrastructure
    created by Terraform.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 完全在Terraform中创建服务主体是可能的，如果我们能这样做将是理想的。毕竟，服务主体只是我们基础设施的另一个方面，我们更愿意让我们的整个基础设施都由Terraform创建。
- en: Unfortunately, at the time of writing, this doesn’t work reliably. Although
    the Azure provider does cater to creating service principals, for some reason,
    it doesn’t deal with the timing of creation properly. It takes time for the service
    principal to propagate through Azure, and there is no way of delaying the creation
    of the cluster until the service principal is ready. If we attempt this in Terraform,
    we will end up creating a cluster before the service principal exists. This results
    in an error because the creation of the cluster requires the service principal
    to already be in place.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，这并不稳定。尽管Azure提供程序确实支持创建服务主体，但出于某种原因，它没有正确处理创建的时间。服务主体需要时间才能在Azure中传播，而且没有方法可以延迟集群的创建直到服务主体就绪。如果我们尝试在Terraform中这样做，我们最终会在服务主体存在之前创建集群。这会导致错误，因为集群的创建需要服务主体已经存在。
- en: 'Due to this problem with the Azure provider (which might be fixed by the time
    you read this), we can’t reliably create the service principal from Terraform.
    Instead, we’ll resort to using the Azure CLI tool for this task. This is actually
    OK because we only have to create the service principal once, and thereafter,
    we will simply continue using it. Before you can create the service principal,
    you must know the ID of your Azure subscription, which you can do with the following
    command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Azure 提供者存在此问题（可能在你阅读本文时已修复），我们无法从 Terraform 中可靠地创建服务主体。相反，我们将求助于使用 Azure
    CLI 工具来完成此任务。这实际上是可以接受的，因为我们只需要创建一次服务主体，之后我们将简单地继续使用它。在您能够创建服务主体之前，您必须知道您的 Azure
    订阅 ID，您可以使用以下命令来完成：
- en: '[PRE43]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Pick out the value from the `id` field and use it create your service principal:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `id` 字段中提取值，并使用它来创建您的服务主体：
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you run that command, you should replace `<subscription-id>` with your
    own subscription ID. The output from the command will look something like the
    following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行该命令时，应将 `<subscription-id>` 替换为您自己的订阅 ID。命令的输出将类似于以下内容：
- en: '[PRE45]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have created a service principal for our cluster to authenticate with Azure.
    Jot down your own values for the fields `appId` and `password` (these will be
    different than mine!). You’ll need these in a moment to input the values for the
    Terraform variables `client_id` and `client_secret`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的集群创建了一个服务主体，用于与 Azure 进行身份验证。记下您自己的 `appId` 和 `password` 字段值（这些将不同于我的值！）。您稍后需要这些值来输入
    Terraform 变量的 `client_id` 和 `client_secret`。
- en: 6.11.3 Building your cluster
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11.3 构建您的集群
- en: 'We are now ready to run our latest Terraform code to create our Kubernetes
    cluster. Invoke the `apply` command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行最新的 Terraform 代码来创建我们的 Kubernetes 集群。调用 `apply` 命令：
- en: '[PRE46]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Terraform prompts you to enter the variables that don’t have values. The first
    is `client _id`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 会提示您输入没有值的变量。第一个是 `client_id`：
- en: '[PRE47]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here you should enter the `appId` value for your service principal. Then Terraform
    prompts you for `client_secret`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您应输入您服务主体的 `appId` 值。然后 Terraform 会提示您输入 `client_secret`：
- en: '[PRE48]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now enter the `password` value for your service principal. Terraform now creates
    your Kubernetes cluster. This can take some time; you might like to grab a cup
    of coffee.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入您服务主体的 `password` 值。Terraform 现在创建您的 Kubernetes 集群。这可能需要一些时间；您可能想喝杯咖啡。
- en: Note If you have a problem with the version number I’ve used (1.18.8), it is
    probably because that version is no longer available on Azure. See section 6.6.3
    for instructions on how to choose an available version.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您遇到我使用的版本号（1.18.8）的问题，这可能是由于该版本在 Azure 上不再可用。请参阅 6.6.3 节以获取如何选择可用版本的说明。
- en: At the end, you’ll see a load of Terraform outputs that give you configuration
    and authentication details for your new cluster. Take note of these following
    values. These are the credentials we need to interface with our new Kubernetes
    cluster.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您会看到大量的 Terraform 输出，这些输出提供了您新集群的配置和身份验证细节。请注意以下值。这些是我们与新的 Kubernetes 集群接口所需的凭证。
- en: '`cluster_client_certificate`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_client_certificate`'
- en: '`cluster_client_key`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_client_key`'
- en: '`cluster_cluster_ca_certificate`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_cluster_ca_certificate`'
- en: 6.11.4 What have we achieved?
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11.4 我们取得了什么成就？
- en: Well done! We just created a Kubernetes cluster. If you had previously been
    convinced that Kubernetes is complicated, you might now be surprised at just how
    simple this was!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们刚刚创建了一个 Kubernetes 集群。如果您之前认为 Kubernetes 很复杂，您可能会对它的简单性感到惊讶！
- en: This is a significant achievement on the road to production. Again, we continued
    the evolution of our architecture, adding a Kubernetes cluster to our existing
    infrastructure. Along the way, we did some refactoring and used Terraform variables
    to share important values between our various Terraform code files.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通往生产之路上的一个重大成就。再次强调，我们继续演进我们的架构，将 Kubernetes 集群添加到现有的基础设施中。在这个过程中，我们进行了一些重构，并使用
    Terraform 变量在各个 Terraform 代码文件之间共享重要值。
- en: We also created a service principal for authentication with Azure. The Kubernetes
    cluster uses this when it needs to create Azure load balancers. We’ll talk about
    those in the next chapter.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个服务主体，用于与 Azure 进行身份验证。Kubernetes 集群在需要创建 Azure 负载均衡器时使用它。我们将在下一章中讨论这些内容。
- en: 6.12 Interacting with Kubernetes
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.12 与 Kubernetes 交互
- en: Now that we have a Kubernetes cluster, how do we interact with it? Figure 6.11
    shows the methods of interaction we have at our disposal. Briefly, these are
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 Kubernetes 集群，我们如何与之交互呢？图 6.11 展示了我们可用的交互方法。简要来说，这些方法是
- en: The Kubernetes CLI tool, Kubectl
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 命令行工具，Kubectl
- en: Terraform, the primary method we use in this book
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform，本书中我们使用的主要方法
- en: The Kubernetes dashboard
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板
- en: In this chapter, we created a Kubernetes cluster using Terraform. In the next
    chapter, we’ll expand on this and learn how to interact with the cluster to deploy
    containers. Once again, we’ll use Terraform.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Terraform 创建了一个 Kubernetes 集群。在下一章中，我们将在此基础上扩展，学习如何与集群交互以部署容器。我们再次将使用
    Terraform。
- en: In this book, the primary way we interact with Kubernetes is with Terraform.
    But it’s also useful for us to understand the other methods of interaction so
    we can test the cluster we just created. We’ll round out this chapter by interacting
    with our cluster using Kubectl and the Kubernetes dashboard.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们与 Kubernetes 交互的主要方式是使用 Terraform。但了解其他交互方法对我们来说也很有用，这样我们就可以测试我们刚刚创建的集群。我们将通过使用
    Kubectl 和 Kubernetes 仪表板与我们的集群交互来结束本章。
- en: '![](../Images/CH06_F11_Davis4.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F11_Davis4.png)'
- en: Figure 6.11 Methods of interacting with Kubernetes
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 与 Kubernetes 交互的方法
- en: 6.12.1 Kubernetes authentication
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.1 Kubernetes 认证
- en: Before interacting with your Kubernetes cluster, we must first authenticate
    with it. In section 6.11.3, you took note of the following outputs from Terraform.
    These are the credentials you need to authenticate with your cluster.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在与你的 Kubernetes 集群交互之前，我们首先必须对其进行认证。在第 6.11.3 节中，你注意到了 Terraform 的以下输出。这些是你用于与集群认证所需的凭据。
- en: '`cluster_client_certificate`'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_client_certificate`'
- en: '`cluster_client_key`'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_client_key`'
- en: '`cluster_cluster_ca_certificate`'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster_cluster_ca_certificate`'
- en: 'At this point, you could try and manually set up your authentication details.
    To do this, you would create the file .kube/config under your home directory and
    then type into it your Kubernetes credentials. Unfortunately, this setup is not
    a trivial exercise! But happily, we are using Azure and the Azure CLI tools to
    automate this set up for us with the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以尝试手动设置你的认证细节。为此，你需要在你的主目录下创建 .kube/config 文件，然后输入你的 Kubernetes 凭据。不幸的是，这个设置不是一项简单的练习！但幸运的是，我们正在使用
    Azure 和 Azure CLI 工具来自动化这个设置，以下是一个命令：
- en: '[PRE49]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you invoke `aks get-credentials`, be sure to replace both instances of
    `flixtube` with the name of your own application. This is the name that you set
    for your `app_name` variable back in section 6.10\. Invoke the command according
    to this template:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `aks get-credentials` 时，请确保将两个 `flixtube` 实例替换为你自己的应用程序名称。这是你在第 6.10 节中为
    `app_name` 变量设置的名称。根据以下模板调用命令：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After running this command, the Azure CLI tool creates your Kubectl config
    file. You can take a look at it with the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Azure CLI 工具将创建你的 Kubectl 配置文件。你可以使用以下命令查看它：
- en: '[PRE51]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can learn more about the manual setup of the Kubectl config file here:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多关于手动设置 Kubectl 配置文件的信息：
- en: '[http://mng.bz/op8D](http://mng.bz/op8D)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mng.bz/op8D](http://mng.bz/op8D)'
- en: 6.12.2 The Kubernetes CLI
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.2 Kubernetes 命令行界面
- en: With the configuration in place, we can now use the Kubernetes CLI (Kubectl)
    to interact with our cluster.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置就绪后，我们现在可以使用 Kubernetes 命令行（Kubectl）与我们的集群交互。
- en: Installing the Kubernetes CLI
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 命令行
- en: 'Instructions for installing Kubectl can be found here:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Kubectl 的说明可以在此处找到：
- en: '[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)'
- en: 'Installation is simply a matter of downloading the correct binary executable
    for your operating system and adding it to your system path. When you have installed
    Kubectl, you can test it with the following command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 安装只是下载适合你操作系统的正确二进制可执行文件并将其添加到系统路径中。当你安装了 Kubectl 后，你可以使用以下命令测试它：
- en: '[PRE52]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This shows you the version numbers for both Kubectl on your local computer
    and for your Kubernetes cluster, which might look something like this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了你的本地计算机上的 Kubectl 和你的 Kubernetes 集群版本号，可能看起来像这样：
- en: '[PRE53]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is a little hard to read! But if you scan across from `Client Version`,
    you’ll find `GitVersion`, which shows you the version of Kubectl. You can see
    that I am using version 1.19.3\. You can then scan across from `Server Version`
    to find `GitVersion`, which shows you the version of Kubernetes. You can see that
    my cluster is on version 1.18.8 of Kubernetes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以阅读！但如果你从 `Client Version` 开始扫描，你会找到 `GitVersion`，它显示了 Kubectl 的版本。你可以看到我正在使用
    1.19.3 版本。然后你可以从 `Server Version` 开始扫描，找到 `GitVersion`，它显示了 Kubernetes 的版本。你可以看到我的集群正在使用
    Kubernetes 的 1.18.8 版本。
- en: Using Kubectl
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubectl
- en: Kubectl is the official and primary method of interaction with Kubernetes. Anything
    that can be done with Kubernetes can be done from Kubectl-configuration, deployment
    of containers, and even monitoring live applications.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl 是与 Kubernetes 交互的官方和主要方法。任何可以用 Kubernetes 做的事情都可以从 Kubectl 中完成——配置、容器部署，甚至是监控实时应用程序。
- en: In this book, we mostly control Kubernetes through Terraform code. That’s a
    higher level and more expressive way to work with Kubernetes. It’s also nice that
    we can maintain a simple deployment pipeline and keep all of our infrastructure
    and deployment code in Terraform. But that’s not always possible in real-world
    production systems; although, we are able to achieve that for the simple examples
    in this book.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们主要通过 Terraform 代码来控制 Kubernetes。这是一种更高级、更易于表达的方式来与 Kubernetes 交互。而且，我们还可以保持一个简单的部署管道，并将所有基础设施和部署代码都放在
    Terraform 中。但在现实世界的生产系统中，这并不总是可能的；尽管如此，我们能够在本书中的简单示例中实现这一点。
- en: 'We should, however, learn the basics of Kubectl because it is the official
    interface to Kubernetes, and it is also what underlies the Kubernetes provider
    for Terraform. We need to know it at least because it’s the best way to debug
    our Kubernetes cluster, which is something we’ll look at in chapter 10\. With
    that in mind, let’s test the authenticated connection to our Kubernetes cluster
    with the following command:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该学习 Kubectl 的基础知识，因为它是 Kubernetes 的官方接口，也是 Terraform Kubernetes 提供商的基础。我们至少需要了解它，因为它是调试我们的
    Kubernetes 集群的最佳方式，这一点我们将在第 10 章中探讨。考虑到这一点，让我们使用以下命令测试到我们的 Kubernetes 集群的认证连接：
- en: '[PRE54]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `get` `nodes` command shows the list of the nodes that are powering our
    cluster. We have created a cluster with a single node, so the output will be quite
    short; something like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`get nodes` 命令显示了为我们集群提供动力的节点列表。我们创建了一个包含单个节点的集群，所以输出将会非常短；类似于以下内容：'
- en: '[PRE55]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'That’s it for now. We’ll return to Kubectl and learn more commands in upcoming
    chapters. If you desire, you can continue to learn and experiment with Kubectl
    here:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止。我们将在接下来的章节中返回 Kubectl 并学习更多命令。如果你愿意，你可以在以下位置继续学习和实验 Kubectl：
- en: '[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)'
- en: 6.12.3 The Kubernetes dashboard
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.3 Kubernetes 仪表板
- en: Kubectl is one way to interact with Kubernetes. Another is through the Kubernetes
    dashboard, and once we have Kubectl setup and authenticated, we can use it to
    access the dashboard.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl 是与 Kubernetes 交互的一种方式。另一种是通过 Kubernetes 仪表板，一旦我们设置了 Kubectl 并进行了认证，我们就可以使用它来访问仪表板。
- en: Installing the Kubernetes dashboard
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 仪表板
- en: 'The Kubernetes dashboard is not installed by default. Although, we can install
    it easily with the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板默认未安装。尽管如此，我们可以使用以下命令轻松安装它：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Connecting to the Kubernetes dashboard
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 Kubernetes 仪表板
- en: 'We can’t directly connect to the Kubernetes dashboard. It’s simply not exposed
    to the public. However, given that we have already authenticated Kubectl to connect
    to our cluster, we can use Kubectl to create a proxy that allows us to access
    the dashboard from our development workstation:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法直接连接到 Kubernetes 仪表板。它简单地没有向公众开放。然而，鉴于我们已经通过 Kubectl 认证来连接到我们的集群，我们可以使用
    Kubectl 创建一个代理，允许我们从我们的开发工作站访问仪表板：
- en: '[PRE57]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you are running the proxy within a Vagrant VM and want to access it from
    your host operating system, you need to change its bound IP address so that it’s
    externally accessible:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个 Vagrant 虚拟机中运行代理，并想从你的主机操作系统访问它，你需要更改它的绑定 IP 地址，使其外部可访问：
- en: '[PRE58]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The proxy allows us to use the full Kubernetes REST API, which is accessible
    at http://localhost:8001\. You can open that URL in your browser and see what
    it returns.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许我们使用完整的 Kubernetes REST API，该 API 可在 http://localhost:8001 访问。你可以在浏览器中打开这个
    URL，查看它返回的内容。
- en: 'If you’d like to explore the Kubernetes HTTP API, you can do so using the `curl`
    command, Postman, or Visual Studio Code REST Client. You can learn more about
    the proxy command here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索 Kubernetes HTTP API，你可以使用 `curl` 命令、Postman 或 Visual Studio Code REST
    客户端来做到这一点。你可以在这里了解更多关于代理命令的信息：
- en: '[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#proxy](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#proxy)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#proxy](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#proxy)'
- en: 'Now with the REST API available, we can go through the proxy to get to the
    dashboard. Open this rather long and awkward URL in your web browser:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了REST API，我们可以通过代理访问仪表板。在你的网络浏览器中打开这个相当长且不自然的URL：
- en: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
- en: After opening the dashboard, we come to its authentication screen. We can authenticate
    by selecting our Kubeconfig file as shown in figure 6.12\. This config file is
    the one we looked at earlier in section 6.12.1, which you can find in your home
    directory at ~/.kube/config.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 打开仪表板后，我们来到其身份验证屏幕。我们可以通过选择如图6.12所示的Kubeconfig文件进行身份验证。这个配置文件就是我们之前在第6.12.1节中查看过的，你可以在你的家目录中找到它，路径为~/.kube/config。
- en: Note If you are working under a Vagrant VM, you must copy this file out of the
    VM to your host operating system so that you can select it and authenticate with
    the dashboard.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你在一个Vagrant虚拟机下工作，你必须将此文件从虚拟机复制到你的主机操作系统，这样你才能选择它并使用仪表板进行身份验证。
- en: 'To learn more about installing and connecting to the Kubernetes dashboard,
    read the information on this web page:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于安装和连接到Kubernetes仪表板的信息，请阅读此网页上的信息：
- en: '[https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
- en: '![](../Images/CH06_F12_Davis4.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F12_Davis4.png)'
- en: Figure 6.12 Authentication for the Kubernetes dashboard
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 Kubernetes仪表板的身份验证
- en: Exploring the Kubernetes dashboard
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Kubernetes仪表板
- en: With the Kubernetes dashboard open in our browser, we can graphically inspect
    our cluster using the GUI. This is a great way to understand our cluster and learn
    about Kubernetes! I encourage you to spend some time exploring this dashboard
    by yourself before moving on. As you work through the next chapter, you’ll be
    able to return to this dashboard and see the containers that we will soon deploy.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开Kubernetes仪表板后，我们可以使用GUI图形化地检查我们的集群。这是了解我们的集群和学习Kubernetes的绝佳方式！我鼓励你在继续之前花些时间自己探索这个仪表板。当你完成下一章的学习时，你将能够返回到这个仪表板，并看到我们即将部署的容器。
- en: Figure 6.13 shows you the overview page of the dashboard. This is where you
    will start your exploration. The dashboard is the first place to come, especially
    in the early days, when something is wrong with your cluster or any of the containers
    it is hosting. We’ll learn more about how the dashboard can help with debugging
    in chapter 10.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13显示了仪表板的概览页面。这就是你开始探索的地方。仪表板是首先需要访问的地方，尤其是在集群或其托管的任何容器出现问题时，尤其是在早期。在第10章中，我们将了解更多关于仪表板如何帮助调试的信息。
- en: '![](../Images/CH06_F13_Davis4.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F13_Davis4.png)'
- en: Figure 6.13 The Kubernetes dashboard
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 Kubernetes仪表板
- en: 6.12.4 What have we achieved?
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.4 我们取得了什么成果？
- en: 'We have our Kubernetes cluster online and are ready to start deploying our
    microservices to it. In this book, we mostly use Terraform code to interact with
    our cluster, but we just learned about two other ways of interacting with it:
    the Kubernetes CLI and the Kubernetes dashboard.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将Kubernetes集群上线，并准备好开始部署我们的微服务。在这本书中，我们主要使用Terraform代码与我们的集群交互，但我们刚刚学习了两种其他与之交互的方式：Kubernetes
    CLI和Kubernetes仪表板。
- en: '*The Kubernetes CLI (known as Kubectl) is used to configure and query our cluster
    from the terminal.* It gives us a lower-level API for administration and debugging.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes CLI（也称为kubectl）用于从终端配置和查询我们的集群。* 它为我们提供了更低级别的API用于管理和调试。'
- en: '*The Kubernetes dashboard is a visual GUI for interacting with our cluster.*
    It allows us to visually explore the variety of resources that are available to
    use with Kubernetes. As well as being a good tool for debugging, it’s also a great
    educational tool to better understand Kubernetes.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes仪表板是我们与集群交互的图形化GUI。* 它允许我们直观地探索Kubernetes可用的各种资源。除了是一个很好的调试工具外，它也是一个很好的教育工具，有助于更好地理解Kubernetes。'
- en: In the next chapter, we’ll continue to learn about interacting with Kubernetes
    through Terraform code.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续学习如何通过Terraform代码与Kubernetes交互。
- en: 6.13 Terraform review
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.13 Terraform复习
- en: This has been another big chapter! I bet it now makes the Docker chapter look
    a lot simpler in retrospect.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个重要的章节！我相信现在回想起来，Docker章节看起来要简单得多。
- en: To review, Terraform is a universal tool for the creation and configuration
    of cloud-based infrastructure. So far, we have used it to create the entire infrastructure
    for our microservices application (with the exception of the Azure service principal).
    Before continuing, let’s review the Terraform commands we have added to our toolkit.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，Terraform 是一个用于创建和配置基于云的基础设施的通用工具。到目前为止，我们已经用它来创建我们的微服务应用程序的全部基础设施（除了 Azure
    服务主体）。在继续之前，让我们回顾一下我们添加到工具箱中的 Terraform 命令。
- en: Table 6.2 Review of Terraform commands
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 Terraform 命令回顾
- en: '| Command | Description |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `terraform init` | Initializes a Terraform project and downloads the provider
    plugins |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `terraform init` | 初始化 Terraform 项目并下载提供者插件 |'
- en: '| `terraform`➥ `apply -auto-approve` | Executes Terraform code files in the
    working directory to incrementally apply changes to our infrastructure |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `terraform`➥ `apply -auto-approve` | 在工作目录中执行 Terraform 代码文件，以增量方式应用更改到我们的基础设施
    |'
- en: '| `terraform destroy` | Destroys all infrastructure that was created by the
    Terraform project |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `terraform destroy` | 销毁由 Terraform 项目创建的所有基础设施 |'
- en: 6.14 Continue your learning
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.14 继续学习
- en: In this chapter, we learned how to create a production environment based on
    Kubernetes. To build our production environment, we used Terraform and the technique
    called infrastructure as code. We’ll continue to learn more about both Terraform
    and Kubernetes in the next chapter.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何基于 Kubernetes 创建生产环境。为了构建我们的生产环境，我们使用了 Terraform 和基础设施即代码的技术。我们将在下一章继续学习更多关于
    Terraform 和 Kubernetes 的内容。
- en: 'Kubernetes itself is a deep and complex technology, definitely the most complex
    we will talk about in this book. You might spend many months working with it before
    you dig all the way to the bottom! In this book, we barely scratched the surface,
    but we covered enough to get our application deployed to production. To dive deeper
    into these topics, I recommend the following books:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 本身是一个深奥且复杂的技术，绝对是我们在这本书中讨论的最复杂的技术。你可能会花上几个月的时间与之打交道，才能彻底了解它！在这本书中，我们只是触及了表面，但我们覆盖了足够的内容，以便将我们的应用程序部署到生产环境中。要深入了解这些主题，我推荐以下书籍：
- en: '*Core Kubernetes* by Jay Vyas and Chris Love (Manning, est. Summer 2021)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*核心 Kubernetes* 由 Jay Vyas 和 Chris Love 合著（Manning，预计 2021 年夏季）'
- en: '*Kubernetes in Action* by Marko Lukša (Manning, 2017)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes 实战* 由 Marko Lukša 编著（Manning，2017 年）'
- en: '*Terraform in Action* by Scott Winkler (Manning, est. Spring 2021)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform 实战* 由 Scott Winkler 编著（Manning，预计 2021 年春季）'
- en: '*GitOps and Kubernetes* by Billy Yuen, Alexander Matyushentsev, et. al. (Manning,
    est. Spring 2021)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GitOps 和 Kubernetes* 由 Billy Yuen、Alexander Matyushentsev 等人合著（Manning，预计
    2021 年春季）'
- en: '*Kubernetes Quickly* by William Denniss (Manning, est. Summer 2021)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes 快速入门* 由 William Denniss 编著（Manning，预计 2021 年夏季）'
- en: '*Learn Kubernetes in a Month of Lunches* by Elton Stoneman (Manning, est. February
    2021)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个月午餐学会 Kubernetes* 由 Elton Stoneman 编著（Manning，预计 2021 年 2 月）'
- en: 'You can learn more about Kubernetes by reading the Kubernetes documentation
    here:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读 Kubernetes 文档来了解更多关于 Kubernetes 的信息：
- en: '[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
- en: 'The documentation for Terraform is available here:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的文档可在以下位置找到：
- en: '[https://www.terraform.io/docs/index.html](https://www.terraform.io/docs/index.html)'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.terraform.io/docs/index.html](https://www.terraform.io/docs/index.html)'
- en: 'To find out what else you can do with the Azure CLI tool, read the documentation
    here:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Azure CLI 工具还能做什么，请在此处阅读文档：
- en: '[https://docs.microsoft.com/en-us/cli/azure/](https://docs.microsoft.com/en-us/cli/azure/)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/cli/azure/](https://docs.microsoft.com/en-us/cli/azure/)'
- en: 'You can read more about the managed Kubernetes service on Azure here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多关于 Azure 上托管 Kubernetes 服务的信息：
- en: '[https://docs.microsoft.com/en-au/azure/aks](https://docs.microsoft.com/en-au/azure/aks)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-au/azure/aks](https://docs.microsoft.com/en-au/azure/aks)'
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Infrastructure as code is a technique where we store our infrastructure configuration
    as code. Editing and executing that code is how we update our infrastructure.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码是一种技术，我们将基础设施配置存储为代码。编辑和执行该代码是我们更新基础设施的方式。
- en: We use Terraform to script the creation of cloud resources and application infrastructure
    from code.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Terraform 从代码中编写创建云资源和应用程序基础设施的脚本。
- en: Terraform must be initialized before it can be used, and we should fix our provider
    version numbers to avoid nasty surprises.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用之前，必须初始化 Terraform，并且我们应该修复我们的提供者版本号以避免不愉快的惊喜。
- en: Terraform state maintains a record of the system we created and makes future
    modifications to the system more efficient.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 状态维护了我们创建的系统的记录，并使对系统的未来修改更加高效。
- en: 'We created production infrastructure for our application on Azure: a container
    registry and a Kubernetes cluster.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 Azure 上为我们的应用程序创建了生产基础设施：一个容器注册库和一个 Kubernetes 集群。
- en: We can use Terraform outputs to find out key details of the infrastructure that
    was created.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Terraform 输出来找出所创建基础设施的关键细节。
- en: The Terraform resource graph ensures that resources created by Terraform are
    created in the correct order.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 资源图确保由 Terraform 创建的资源按正确的顺序创建。
- en: Kubernetes is a computing platform with support for multiple cloud vendors.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是一个支持多个云供应商的云计算平台。
- en: Kubernetes has an automatable API. This allows us to build a continuous delivery
    pipeline (more in the next chapter).
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 拥有一个可自动化的 API。这允许我们构建持续交付管道（更多内容将在下一章中介绍）。
- en: We interact with our cluster not only using Terraform, but also with the Kubernetes
    CLI (kubectl) and the Kubernetes dashboard.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不仅使用 Terraform，还使用 Kubernetes CLI（kubectl）和 Kubernetes 仪表板与我们的集群进行交互。
