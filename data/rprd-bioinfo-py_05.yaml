- en: 'Chapter 4\. Creating the Fibonacci Sequence: Writing, Testing, and Benchmarking
    Algorithms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。创建斐波那契序列：编写、测试和基准算法
- en: 'Writing an implementation of the Fibonacci sequence is another step in the
    hero’s journey to becoming a coder. [The Rosalind Fibonacci description](https://oreil.ly/7vkRw)
    notes that the genesis for the sequence was a mathematical simulation of breeding
    rabbits that relies on some important (and unrealistic) assumptions:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写斐波那契序列的实现是成为编程英雄的旅程中的又一步。[Rosalind斐波那契描述](https://oreil.ly/7vkRw)指出，序列的起源是对一些重要（而不现实）假设进行数学模拟的兔子繁殖：
- en: The first month starts with a pair of newborn rabbits.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个月从一对新生兔子开始。
- en: Rabbits can reproduce after one month.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兔子可以在一个月后繁殖。
- en: Every month, every rabbit of reproductive age mates with another rabbit of reproductive
    age.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个月，具有生育能力的每只兔子都与另一只具有生育能力的兔子交配。
- en: Exactly one month after two rabbits mate, they produce a litter of the same
    size.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兔子交配后一个月，它们产生与同等大小的一窝幼崽。
- en: Rabbits are immortal and never stop mating.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兔子是不朽的，永远不会停止交配。
- en: The sequence always begins with the numbers 0 and 1. The subsequent numbers
    can be generated *ad infinitum* by adding the two immediately previous values
    in the list, as shown in [Figure 4-1](#fig_4.1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 序列始终以数字0和1开始。随后的数字可以通过在列表中添加前两个立即前值来生成*无限*，如[图4-1](#fig_4.1)所示。
- en: '![mpfb 0401](assets/mpfb_0401.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0401](assets/mpfb_0401.png)'
- en: Figure 4-1\. The first eight numbers of the Fibonacci sequence—after the initial
    0 and 1, subsequent numbers are created by adding the two previous numbers
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。斐波那契序列的前八个数字——在初始的0和1之后，后续数字是通过将前两个数字相加而创建的
- en: If you search the internet for solutions, you’ll find dozens of different ways
    to generate the sequence. I want to focus on three fairly different approaches.
    The first solution uses an *imperative* approach where the algorithm strictly
    defines every step. The next solution uses a *generator* function, and the last
    will focus on a *recursive* solution. Recursion, while interesting, slows drastically
    as I try to generate more of the sequence, but it turns out the performance problems
    can be solved using caching.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搜索互联网上的解决方案，你会发现有几十种不同的生成序列的方式。我想专注于三种非常不同的方法。第一个解决方案使用*命令式*方法，其中算法严格定义了每一步。下一个解决方案使用*生成器*函数，最后一个将专注于*递归*解决方案。递归虽然有趣，但随着我尝试生成更多的序列，速度会显着减慢，但事实证明性能问题可以通过缓存来解决。
- en: 'You will learn:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: How to manually validate arguments and throw errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何手动验证参数并抛出错误
- en: How to use a list as a stack
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用列表作为堆栈
- en: How to write a generator function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写生成器函数
- en: How to write a recursive function
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写递归函数
- en: Why recursive functions can be slow and how to fix this with memoization
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数为什么可能会慢，以及如何使用记忆化来修复这个问题
- en: How to use function decorators
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用函数装饰器
- en: Getting Started
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'The code and tests for this chapter are found in the *04_fib* directory. Start
    by copying the first solution to `fib.py`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此章节的代码和测试位于*04_fib*目录中。首先将第一个解决方案复制到`fib.py`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ask for the usage to see how the parameters are defined. You can use `n` and
    `k`, but I chose to use the names `generations` and `litter`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要求使用情况以查看参数的定义。你可以使用`n`和`k`，但我选择使用名称`generations`和`litter`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will be the first program to accept arguments that are not strings. The
    Rosalind challenge indicates that the program should accept two positive integer
    values:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是第一个接受非字符串参数的程序。Rosalind挑战指出该程序应该接受两个正整数值：
- en: '`n` ≤ 40 representing the number of generations'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` ≤ 40 代表代数的数量'
- en: '`k` ≤ 5 representing the litter size produced by mate pairs'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k` ≤ 5 代表配对产生的一窝幼崽的大小'
- en: 'Try to pass noninteger values and notice how the program fails:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试传递非整数值并注意程序的失败：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can’t tell, but in addition to printing the brief usage and a helpful error
    message, the program also generated a nonzero exit value. On the Unix command
    line, an exit value of `0` indicates success. I think of this as “zero errors.”
    In the `bash` shell, I can inspect the `$?` variable to look at the exit status
    of the most recent process. For instance, the command `echo Hello` should exit
    with a value of `0`, and indeed it does:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法察觉，但除了打印简要的使用说明和有用的错误消息外，该程序还生成了一个非零的退出值。在Unix命令行上，退出值为`0`表示成功。我把这看作是“零错误”。在`bash`
    shell中，我可以检查`$?`变量来查看最近进程的退出状态。例如，命令`echo Hello`应该以值`0`退出，确实如此：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Try the previously failing command again, and then inspect `$?`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试之前失败的命令，然后检查 `$?`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That the exit status is `2` is not as important as the fact that the value is
    not zero. This is a well-behaved program because it rejects an invalid argument,
    prints a useful error message, and exits with a nonzero status. If this program
    were part of a pipeline of data processing steps (such as a *Makefile*, discussed
    in [Appendix A](app01.html#app1_makefiles)), a nonzero exit value would cause
    the entire process to stop, which is a good thing. Programs that silently accept
    invalid values and fail quietly or not at all can lead to unreproducible results.
    It’s vitally important that programs properly validate arguments and fail very
    convincingly when they cannot proceed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态为 `2` 并不像数值非零那样重要。这是一个表现良好的程序，因为它拒绝了无效的参数，打印了有用的错误消息，并以非零状态退出。如果该程序是数据处理步骤管道的一部分（比如*Makefile*，见附录
    [A](app01.html#app1_makefiles)），非零的退出值会导致整个流程停止，这是一件好事。接受无效值并悄悄失败或根本不失败的程序可能会导致无法重现的结果。程序正确验证参数并在无法继续时明确失败非常重要。
- en: 'The program is very strict even about the type of number it accepts. The values
    must be integers. It will also repel any floating-point values:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序对接受的数字类型非常严格。值必须是整数。它还会排斥任何浮点数值：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All command-line arguments to the program are technically received as strings.
    Even though `5` on the command line looks like the *number* 5, it’s the *character*
    “5”. I am relying on `argparse` in this situation to attempt to convert the value
    from a string to an integer. When that fails, `argparse` generates these useful
    error messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接收的所有命令行参数在技术上都作为字符串接收。即使命令行上的 `5` 看起来像*数字* 5，实际上是*字符*“5”。在这种情况下，我依赖 `argparse`
    尝试将值从字符串转换为整数。当这种转换失败时，`argparse` 生成这些有用的错误消息。
- en: 'Additionally, the program rejects values for the `generations` and `litter`
    parameters that are not in the allowed ranges. Notice that the error message includes
    the name of the argument and the offending value to provide sufficient feedback
    to the user so you can fix it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，程序还会拒绝不在允许范围内的 `generations` 和 `litter` 参数的值。请注意，错误消息包括参数的名称和违规值，以提供足够的反馈，以便用户修复它：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-1)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-1)'
- en: The `generations` argument of `-3` is not in the stated range of values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`-3` 的 `generations` 参数不在指定的数值范围内。'
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-2)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO1-2)'
- en: The `litter` argument of `10` is too high.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`litter` 参数为 `10` 太高了。'
- en: 'Look at the first part of the solution to see how to make this work:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看解决方案的第一部分以了解如何使其工作：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-1)'
- en: The `generations` field must be an `int`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`generations` 字段必须是 `int` 类型。'
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-2)'
- en: The `litter` field must also be an `int`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`litter` 字段也必须是 `int` 类型。'
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-3)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-3)'
- en: The `gen` positional parameter is defined first, so it will receive the first
    positional value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen` 位置参数首先定义，因此将接收第一个位置值。'
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-4)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-4)'
- en: The `type=int` indicates the required class of the value. Notice that `int`
    indicates the class itself, not the name of the class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`type=int` 表示所需数值的类别。请注意，`int` 表示的是类别本身，而不是类别的名称。'
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-5)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-5)'
- en: The `litter` positional parameter is defined second, so it will receive the
    second positional value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`litter` 位置参数其次定义，因此将接收第二个位置值。'
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-6)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-6)'
- en: Attempt to parse the arguments. Any failure will result in error messages and
    the program exiting with a nonzero value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解析参数。任何失败都将导致错误消息，并以非零值退出程序。
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-7)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-7)'
- en: The `args.gen` value is now an actual `int` value, so it’s possible to perform
    numeric comparisons on it. Check if it is in the acceptable range.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`args.gen`的值现在是一个实际的`int`值，因此可以对其进行数值比较。检查它是否在可接受的范围内。'
- en: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-8)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-8)'
- en: Use the `parser.error()` function to generate an error and exit the program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parser.error()`函数生成错误并退出程序。
- en: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-9)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-9)'
- en: Likewise check the value of the `args.litter` argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样检查`args.litter`参数的值。
- en: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-10)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-10)'
- en: Generate an error that includes information the user needs to fix the problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个错误，其中包含用户需要修复问题的信息。
- en: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-11)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO2-11)'
- en: If the program makes it to this point, then the arguments are valid integer
    values in the accepted range, so return the `Args`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序成功运行到这一点，则参数是接受范围内的有效整数值，因此返回`Args`。
- en: I could check that the `generations` and `litter` values are in the correct
    ranges in the `main()` function, but I prefer to do as much argument validation
    as possible inside the `get_args()` function so that I can use the `parser.error()`
    function to generate useful messages and exit the program with a nonzero value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在`main()`函数中检查`generations`和`litter`值是否在正确的范围内，但我更喜欢尽可能在`get_args()`函数内进行尽可能多的参数验证，以便我可以使用`parser.error()`函数生成有用的消息并以非零值退出程序。
- en: 'Remove the `fib.py` program and start anew with **`new.py`** or your preferred
    method for creating a program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`fib.py`程序，然后使用**`new.py`**或您喜欢的方法重新开始创建程序：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can replace the `get_args()` definition with the preceding code, then modify
    your `main()` function like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`get_args()`定义替换为前面的代码，然后像这样修改您的`main()`函数：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run your program with invalid inputs and verify that you see the kinds of error
    messages shown earlier. Try your program with acceptable values and verify that
    you see this kind of output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无效输入运行您的程序，并验证您是否看到早期显示的错误消息类型。使用可接受的值尝试您的程序，并验证您是否看到此类输出：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run **`pytest`** to see what your program passes and fails. You should pass
    the first four tests and fail the fifth:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`pytest`**来查看您的程序通过和未通过的测试。您应该通过前四个测试，并未通过第五个：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-1)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-1)'
- en: The first failing test. Testing halts here because of the `-x` flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个失败的测试。由于`-x`标志的存在，测试在此处停止。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-2)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-2)'
- en: The program is run with `5` for the number of generations and `3` for the litter
    size.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序以`5`作为生成数量和`3`作为每胎大小来运行。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-3)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-3)'
- en: The output should be `19`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应为`19`。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-4)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-4)'
- en: This shows the two strings being compared are not equal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两个字符串的比较结果不相等。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-5)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-5)'
- en: The expected value was `19`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 预期值为`19`。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-6)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO3-6)'
- en: This is the output that was received.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接收到的输出。
- en: The output from `pytest` is trying very hard to point out exactly what went
    wrong. It shows how the program was run and what was expected versus what was
    produced. The program is supposed to print 19, which is the fifth number of the
    Fibonacci sequence when using a litter size of 3. If you want to finish the program
    on your own, please jump right in. You should use **`pytest`** to verify that
    you are passing all the tests. Also, run **`make test`** to check your program
    using `pylint`, `flake8`, and `mypy`. If you want some guidance, I’ll cover the
    first approach I described.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`的输出非常努力地指出了发生了什么问题。它显示了程序的运行方式及期望的结果与实际产生的结果之间的差异。程序应该打印19，这是使用每胎数量为3时斐波那契数列的第五个数字。如果您想独自完成程序，请直接开始。您应该使用**`pytest`**验证是否通过了所有测试。另外，运行**`make
    test`**以使用`pylint`、`flake8`和`mypy`检查您的程序。如果您需要一些指导，我将介绍我描述的第一种方法。'
- en: An Imperative Approach
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种命令式方法
- en: '[Figure 4-2](#fig_4.2) depicts the growth of the Fibonacci sequence. The smaller
    rabbits indicate nonbreeding pairs that must mature into larger, breeding pairs.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#fig_4.2)描述了斐波那契数列的增长。较小的兔子表示必须成熟为较大的繁殖对的非繁殖对。'
- en: '![mpfb 0402](assets/mpfb_0402.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0402](assets/mpfb_0402.png)'
- en: Figure 4-2\. A visualization of the growth of the Fibonacci sequence as mating
    pairs of rabbits using a litter size of 1
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 使用每胎数量为1的兔子配对作为斐波那契数列增长的可视化
- en: 'You can see that to generate any number after the first two, I need to know
    the two previous numbers. I can use this formula to describe the value of any
    position *n* of the Fibonacci sequence (*F*):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，要生成前两个数之后的任何数字，我需要知道前两个数。我可以使用这个公式来描述斐波那契数列（*F*）的任意位置*n*的值：
- en: <math alttext="upper F Subscript n Baseline equals upper F Subscript n minus
    1 Baseline plus upper F Subscript n minus 2" display="block"><mrow><msub><mi>F</mi>
    <mi>n</mi></msub> <mo>=</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper F Subscript n Baseline equals upper F Subscript n minus
    1 Baseline plus upper F Subscript n minus 2" display="block"><mrow><msub><mi>F</mi>
    <mi>n</mi></msub> <mo>=</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
    <mo>+</mo> <msub><mi>F</mi> <mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></math>
- en: 'What kind of a data structure in Python would allow me to keep a sequence of
    numbers in order and refer to them by their position? A list. I’ll start off with
    *F*[1] = 0 and *F*[2] = 1:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，哪种数据结构可以让我按顺序保留一系列数字并按其位置引用它们？列表。我将从*F*[1] = 0和*F*[2] = 1开始：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The *F*[3] value is *F*[2] + *F*[1] = 1 + 0 = 1. When generating the next number,
    I’ll always be referencing the *last two* elements of the sequence. It will be
    easiest to use negative indexing to indicate a position from the *end* of the
    list. The last value in a list is always at position `-1`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[3]值为*F*[2] + *F*[1] = 1 + 0 = 1。在生成下一个数字时，我将始终引用序列的*最后两个*元素。使用负索引最容易指示从列表*末尾*的位置。列表中的最后一个值始终位于位置`-1`：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The penultimate value is at `-2`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二个值是`-2`：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I need to multiply this value by the litter size to calculate the number of
    offspring that generation created. To start, I’ll consider a litter size of 1:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将这个值乘以每胎数量来计算该代产生的后代数量。首先，我将考虑每胎数量为1：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I want to add these two numbers together and append the result to the list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要将这两个数字加在一起，并将结果附加到列表中：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If I do this again, I can see that the correct sequence is emerging:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我再做一次，我可以看到正确的序列正在出现：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I need to repeat this action `generations` times. (Technically it will be `generations`-1
    times because Python uses 0-based indexing.) I can use Python’s `range()` function
    to generate a list of numbers from `0` up to but not including the end value.
    I’m calling this function solely for the side effect of iterating a particular
    number of times and so don’t need the values produced by the `range()` function.
    It’s common to use the underscore (`_`) variable to indicate one’s intent to ignore
    a value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要重复这个动作`generations`次。（从技术上讲，实际上是`generations`-1次，因为Python使用基于0的索引。）我可以使用Python的`range()`函数生成从`0`到结束值但不包括结束值的数字列表。我调用这个函数仅仅是为了迭代特定次数，所以不需要`range()`函数生成的值。习惯上使用下划线（`_`）变量表示忽略某个值的意图：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This should be enough for you to create a solution that passes the tests. In
    the next section, I’ll cover two other solutions that highlight some very interesting
    parts of Python.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够让您创建一个通过测试的解决方案。在下一节中，我将介绍另外两个解决方案，突出Python的一些非常有趣的部分。
- en: Solutions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: All the following solutions share the same `get_args()` shown previously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下解决方案都共享相同的`get_args()`如前所示。
- en: 'Solution 1: An Imperative Solution Using a List as a Stack'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1：使用列表作为堆栈的命令式解决方案
- en: 'Here is how I wrote my imperative solution. I’m using a list as a kind of *stack*
    to keep track of past values. I don’t need all the values, just the last two,
    but it’s pretty easy to keep growing the list and referring to the last two values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我写的命令式解决方案。我使用列表作为*栈*来跟踪过去的值。我不需要所有的值，只需要最后两个，但是保持列表不断增长并引用最后两个值是相当容易的：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-1)'
- en: Start with `0` and `1`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从`0`和`1`开始。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-2)'
- en: Use the `range()` function to create the right number of loops.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range()`函数创建正确数量的循环。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-3)'
- en: Append the next value to the sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将下一个值附加到序列中。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-4)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO4-4)'
- en: Print the last number of the sequence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打印序列的最后一个数字。
- en: I used the `_` variable name in the `for` loop to indicate that I don’t intend
    to use the variable. The underscore is a valid Python identifier, and it’s also
    a convention to use this to indicate a *throwaway* value. Linting tools, for instance,
    might see that I’ve assigned a variable some value but never used it, which would
    normally indicate a possible error. The underscore variable shows that I do not
    intend to use the value. In this case, I’m using the `range()` function purely
    for the side effect of creating the number of loops needed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中使用`_`变量名表明我不打算使用该变量。下划线是一个有效的Python标识符，并且也是一种约定，用于表示*丢弃*值。例如，代码检查工具可能会看到我给变量赋了一个值但从未使用它，这通常会被视为可能的错误。下划线变量表明我不打算使用该值。在这种情况下，我仅仅使用`range()`函数是为了产生所需的循环次数。
- en: This is considered an *imperative* solution because the code directly encodes
    every instruction of the algorithm. When you read the recursive solution, you
    will see that the algorithm can be written in a more declarative manner, which
    also has unintended consequences that I must handle.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这被认为是一个*命令式*解决方案，因为代码直接编码了算法的每一个指令。当你阅读递归解决方案时，你会看到算法可以以更声明性的方式编写，这也带来了我必须处理的意外后果。
- en: 'A slight variation on this would be to place this code inside a function I’ll
    call `fib()`. Note that it’s possible in Python to declare a function inside another
    function, as here I’ll create `fib()` inside `main()`. I do this so I can reference
    the `args.litter` parameter, creating a *closure* because the function is capturing
    the runtime value of the litter size:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微变化的方式是将这段代码放在一个我称之为`fib()`的函数中。请注意，在Python中可以在另一个函数内部声明函数，例如我将在`main()`内部创建`fib()`。我这样做是为了可以引用`args.litter`参数，因为函数正在捕获垃圾的运行时值，从而创建了一个*闭包*：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-1)'
- en: Create a function called `fib()` that accepts an integer parameter `n` and returns
    an integer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`fib()`的函数，接受一个整数参数`n`并返回一个整数。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-2)'
- en: This is the same code as before. Note this list is called `nums` so it doesn’t
    clash with the function name.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码相同。请注意，此列表称为`nums`，以避免与函数名冲突。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-3)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-3)'
- en: Use the `range()` function to iterate the generations. Use `_` to ignore the
    values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range()`函数迭代生成。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-4)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-4)'
- en: The function references the `args.litter` parameter and so creates a closure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数引用`args.litter`参数，因此创建了一个闭包。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-5)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-5)'
- en: Use `return` to send the final value back to the caller.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`return`将最终值发送回调用者。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-6)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO5-6)'
- en: Call the `fib()` function with the `args.generations` parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`args.generations`参数调用`fib()`函数。
- en: The scope of the `fib()` function in the preceding example is limited to the
    `main()` function. *Scope* refers to the part of the program where a particular
    function name or variable is visible or legal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`fib()`函数的作用域仅限于`main()`函数。*作用域*指的是程序中特定函数名称或变量可见或合法的部分。
- en: 'I don’t have to use a closure. Here is how I can express the same idea with
    a standard function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我不必使用闭包。以下是我如何使用标准函数表达相同的想法：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-1)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-1)'
- en: The `fib()` function must be called with two arguments.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`fib()`必须使用两个参数调用。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-2)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO6-2)'
- en: The function requires both the number of generations and the litter size. The
    function body is essentially the same.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数需要世代数和窝大小。函数体本质上相同。
- en: In the preceding code, you see that I must pass two arguments to `fib()`, whereas
    the closure required only one argument because the `litter` was captured. Binding
    values and reducing the number of parameters is a valid reason for creating a
    closure. Another reason to write a closure is to limit the scope of a function.
    The closure definition of `fib()` is valid only inside the `main()` function,
    but the preceding version is visible throughout the program. Hiding a function
    inside another function makes it harder to test. In this case, the `fib()` function
    is almost the entire program, so the tests have already been written in *tests/fib_test.py*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以看到我必须向`fib()`传递两个参数，而闭包只需要一个参数，因为捕获了`litter`。绑定值并减少参数数量是创建闭包的有效原因之一。另一个编写闭包的原因是限制函数的作用域。`fib()`函数的闭包定义仅在`main()`函数内有效，而前一个版本在整个程序中都可见。将一个函数隐藏在另一个函数中会使测试变得更加困难。在本例中，`fib()`函数几乎是整个程序，因此测试已在*tests/fib_test.py*中编写。
- en: 'Solution 2: Creating a Generator Function'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：创建生成器函数
- en: In the previous solution, I generated the Fibonacci sequence up to the value
    requested and then stopped; however, the sequence is infinite. Could I create
    a function that could generate *all* the numbers of the sequence? Technically,
    yes, but it would never finish, what with being infinite and all.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的解决方案中，我生成了请求值之前的斐波那契数列，然后停止；但是，这个序列是无限的。我能否创建一个可以生成*所有*序列数的函数？从技术上讲，可以，但它永远不会完成，毕竟它是无限的。
- en: 'Python has a way to suspend a function that generates a possibly infinite sequence.
    I can use `yield` to return a value from a function, temporarily leaving the function
    later to resume at the same state when the next value is requested. This kind
    of function is called a *generator*, and here is how I can use it to generate
    the sequence:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种方法可以挂起生成可能无限序列的函数。我可以使用`yield`从函数中返回一个值，稍后再从函数中暂时离开，以在请求下一个值时恢复到相同状态。这种函数称为*生成器*，以下是我如何使用它生成序列：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-1)'
- en: The type signature indicates the function takes the parameter `k` (litter size),
    which must be an `int`. It returns a special function of the type `Generator`
    which yields `int` values and has no send or return types.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名表明该函数接受参数`k`（窝大小），必须是`int`类型。它返回一种`Generator`类型的特殊函数，该函数生成`int`值且没有发送或返回类型。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-2)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-2)'
- en: I only ever need to track the last two generations, which I initialize to `0`
    and `1`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我只需要跟踪最后两代，我将它们初始化为`0`和`1`。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-3)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-3)'
- en: Yield the `0`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`0`。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-4)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-4)'
- en: Create an infinite loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个无限循环。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-5)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-5)'
- en: Yield the last generation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 生成最后一代。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-6)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO7-6)'
- en: Set `x` (two generations back) to the current generation times the litter size.
    Set `y` (one generation back) to the sum of the two current generations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`（前两代）设置为当前代乘以幼崽数量。将`y`（前一代）设置为两个当前代的和。
- en: A generator acts like an iterator, producing values as requested by the code
    until it is exhausted. Since this generator will only generate yield values, the
    send and return types are `None`. Otherwise, this code does exactly what the first
    version of the program did, only inside a fancy-pants generator function. See
    [Figure 4-3](#fig_4.3) to consider how the function works for two different litter
    sizes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器像迭代器一样工作，根据代码请求生成值，直到耗尽。由于这个生成器只生成yield值，因此发送和返回类型为`None`。除此之外，这段代码完全与程序的第一个版本相同，只是内部使用了一个花哨的生成器函数。查看[图4-3](#fig_4.3)以考虑该函数如何适用于两种不同的幼崽数量。
- en: '![mpfb 0403](assets/mpfb_0403.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0403](assets/mpfb_0403.png)'
- en: Figure 4-3\. A depiction of how the `fib()` generator’s state changes over time
    (`n`=5) for two litter sizes (`k`=1 and `k`=3)
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3\. 展示了`fib()`生成器在时间上如何变化（`n`=5），适用于两个不同的幼崽数量（`k`=1 和 `k`=3）。
- en: The type signature for `Generator` looks a little complicated since it defines
    types for yield, send, and return. I don’t need to dive into it further here,
    but I recommend you read the docs on [the `typing` module](https://oreil.ly/Oir3d).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator`的类型签名看起来有点复杂，因为它定义了yield、send和return的类型。我不需要在这里进一步深入，但建议您阅读关于[typing模块的文档](https://oreil.ly/Oir3d)。'
- en: 'Here’s how to use this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用的：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-1)'
- en: The `fib()` function takes the litter size as an argument and returns a generator.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`fib()`函数接受幼崽数量作为参数并返回一个生成器。'
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-2)'
- en: Use the `next()` function to retrieve the next value from a generator. Use a
    list comprehension to do this the correct number of times to generate the sequence
    up to the requested value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`next()`函数从生成器中获取下一个值。使用列表推导来正确次数生成序列，直至请求的值。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-3)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO8-3)'
- en: Print the last number in the sequence.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打印序列中的最后一个数字。
- en: The `range()` is function different because the first version already had the
    `0` and `1` in place. Here I have to call the generator two extra times to produce
    those values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数的功能不同，因为第一个版本已经包含了`0`和`1`。在这里，我必须额外调用两次生成器才能产生这些值。'
- en: 'Although I prefer the list comprehension, I don’t need the entire list. I only
    care about the final value, so I could have written it like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我更喜欢列表推导，但我不需要整个列表。我只关心最后的值，所以可以这样写：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-1)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-1)'
- en: Initialize the answer to `0`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将答案初始化为`0`。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-2)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-2)'
- en: Create the correct number of loops.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建正确数量的循环。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-3)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-3)'
- en: Get the value for the current generation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前代的值。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-4)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO9-4)'
- en: Print the answer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打印答案。
- en: 'As it happens, it’s quite common to call a function repeatedly to generate
    a list, so there is a function to do this for us. The `itertools.islice()` function
    will “Make an iterator that returns selected elements from the iterable.” Here
    is how I can use it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好，经常多次调用函数生成列表，所以有一个函数来为我们做这个。`itertools.islice()` 函数将“生成一个迭代器，从可迭代对象中返回选定的元素。”这是我如何使用它的方法：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-1)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-1)'
- en: The first argument to `islice()` is the function that will be called, and the
    second argument is the number of times to call it. The function is lazy, so I
    use `list()` to coerce the values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`islice()` 的第一个参数是将被调用的函数，第二个参数是调用它的次数。该函数是惰性的，因此我使用 `list()` 强制生成值。'
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-2)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO10-2)'
- en: Print the last value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打印最后一个值。
- en: 'Since I only use the `seq` variable one time, I could eschew that assignment.
    If benchmarking proved the following to be the best-performing version, I might
    be willing to write a one-liner:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我只使用 `seq` 变量一次，我可以避免那个赋值。如果基准测试证明以下是性能最佳的版本，我可能愿意写成一行：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Clever code is fun but can become unreadable.^([1](ch04.html#idm45963635588216))
    You have been warned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的代码很有趣，但可能变得难以阅读。^([1](ch04.html#idm45963635588216)) 你已经被警告过了。
- en: Generators are cool but more complex than generating a list. They are the appropriate
    way to generate a very large or potentially infinite sequence of values because
    they are lazy, only computing the next value when your code requires it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器很酷，但比生成列表更复杂。它们是生成非常大或潜在无限序列值的适当方式，因为它们是惰性的，在你的代码需要时才计算下一个值。
- en: 'Solution 3: Using Recursion and Memoization'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3：使用递归和记忆化
- en: 'While there are many more fun ways to write an algorithm to produce an infinite
    series of numbers, I’ll show just one more using *recursion*, which is when a
    function calls itself:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多更有趣的方法来编写生成无限数列的算法，但我只展示使用*递归*的另一种方法：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-1)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-1)'
- en: Define a function called `fib()` that takes the number of the generation wanted
    as an `int` and returns an `int`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `fib()` 的函数，它接受所需代数作为 `int` 并返回 `int`。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-2)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-2)'
- en: If the generation is `1` or `2`, return `1`. This is the all-important base
    case that does not make a recursive call.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代数为 `1` 或 `2`，返回 `1`。这是非常重要的基础情况，不会进行递归调用。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-3)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-3)'
- en: For all other cases, call the `fib()` function twice, once for two generations
    back and another for the previous generation. Factor in the litter size as before.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他情况，调用 `fib()` 函数两次，一次用于前两代，另一次用于前一代。与以往一样考虑每胎的数量。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-4)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO11-4)'
- en: Print the results of the `fib()` function for the given generations.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 打印给定代数的 `fib()` 函数的结果。
- en: Here’s another instance where I define a `fib()` function as a closure *inside*
    the `main()` function so as to use the `args.litter` value inside the `fib()`
    function. This is to close around `args.litter`, effectively binding that value
    to the function. If I had defined the function outside the `main()` function,
    I would have had to pass the `args.litter` argument on the recursive calls.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里又是一个例子，我在 `main()` 函数内部定义了一个作为闭包的 `fib()` 函数，以便在 `fib()` 函数内使用 `args.litter`
    值。这样可以将 `args.litter` 绑定到函数中。如果我在 `main()` 函数外定义了该函数，我将不得不在递归调用时传递 `args.litter`
    参数。
- en: This is a really elegant solution that gets taught in pretty much every introductory
    computer science class. It’s fun to study, but it turns out to be wicked slow
    because I end up calling the function so many times. That is, `fib(5)` needs to
    call `fib(4)` and `fib(3)` to add those values. In turn, `fib(4)` needs to call
    `fib(3)` and `fib(2)`, and so on. [Figure 4-4](#fig_4.4) shows that `fib(5)` results
    in 14 function calls to produce 5 distinct values. For instance, `fib(2)` is calculated
    three times, but we only need to calculate it once.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常优雅的解决方案，在几乎每个计算机科学的入门课程中都会教授。研究起来很有趣，但事实证明它非常慢，因为我最终需要调用该函数很多次。也就是说，`fib(5)`需要调用`fib(4)`和`fib(3)`来添加这些值。而`fib(4)`需要调用`fib(3)`和`fib(2)`，依此类推。图 4-4 显示，`fib(5)`导致14次函数调用以产生5个不同的值。例如，`fib(2)`被计算了三次，但我们只需要计算一次。
- en: '![mpfb 0404](assets/mpfb_0404.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0404](assets/mpfb_0404.png)'
- en: Figure 4-4\. The call stack for `fib(5)` results in many recursive calls to
    the function, with their number increasing approximately exponentially as the
    input value increases
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 调用`fib(5)`的调用堆栈导致多次递归调用函数，随着输入值的增加，递归调用次数增加大约呈指数级增长
- en: 'To illustrate the problem, I’ll take a sampling of how long this program takes
    to finish up to the maximum `n` of 40. Again, I’ll use a `for` loop in `bash`
    to show you how I would commonly benchmark such a program on the command line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，我将采样这个程序在最大`n`为40时完成所需的时间。同样，我将使用`bash`中的`for`循环来展示如何在命令行中常见地对这样一个程序进行基准测试：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The jump from 0.29s for `n`=`30` to 31s for `n`=`40` is huge. Imagine going
    to 50 and beyond. I need to either find a way to speed this up or abandon all
    hope for recursion. The solution is to cache previously calculated results. This
    is called *memoization*, and there are many ways to implement this. The following
    is one method. Note you will need to import `typing.Callable`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从`n`=`30`的0.29秒到`n`=`40`的31秒的跳跃是巨大的。想象一下去到50及以上。我需要找到一种方法来加快这个过程或放弃递归的所有希望。解决方法是缓存先前计算的结果。这被称为*记忆化*，有许多实现方法。以下是一种方法。注意，您需要导入`typing.Callable`：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-1)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-1)'
- en: Define a function that takes a function (something that is *callable*) and returns
    a function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个接受函数（即*可调用对象*）并返回函数的函数。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-2)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-2)'
- en: Use a dictionary to store cached values.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典来存储缓存值。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-3)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-3)'
- en: Define `memo()` as a closure around the cache. The function will take some parameter
    `x` when called.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将`memo()`定义为对缓存的闭包。在调用时，该函数将接受某些参数`x`。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-4)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-4)'
- en: See if the argument value is in the cache.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 检查缓存中是否存在参数值。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-5)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-5)'
- en: If not, call the function with the argument and set the cache for that argument
    value to the result.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，使用参数调用函数，并将该参数值的缓存设置为结果。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-6)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-6)'
- en: Return the cached value for the argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 返回参数的缓存值。
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-7)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO12-7)'
- en: Return the new function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新函数。
- en: Note that the `memoize()` function returns a new function. In Python, functions
    are considered *first-class objects*, meaning they can be used like other kinds
    of variables—you can pass them as arguments and overwrite their definitions. The
    `memoize()` function is an example of a *higher-order function* (HOF) because
    it takes other functions as arguments. I’ll be using other HOFs, like `filter()`
    and `map()`, throughout the book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`memoize()`函数返回一个新函数。在Python中，函数被认为是*一级对象*，意味着它们可以像其他类型的变量一样使用——你可以将它们作为参数传递并覆盖它们的定义。`memoize()`函数是*高阶函数*（HOF）的一个例子，因为它接受其他函数作为参数。我将在本书中使用其他HOF，如`filter()`和`map()`。
- en: 'To use the `memoize()` function, I will define `fib()` and then *redefine it*
    with the memoized version. If you run this, you will see an almost instantaneous
    result no matter how high `n` goes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`memoize()`函数，我将定义`fib()`，然后用记忆化版本*重新定义*它。如果你运行这个程序，无论`n`多大，你都会看到几乎瞬间的结果：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO13-1)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO13-1)'
- en: Overwrite the existing `fib()` definition with the memoized function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 用记忆化函数覆盖现有的`fib()`定义。
- en: 'A preferred method to accomplish this uses a *decorator*, which is a function
    that modifies another function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此目标的首选方法是使用*装饰器*，即修改其他函数的函数：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO14-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO14-1)'
- en: Decorate the `fib()` function with the `memoize()` function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`memoize()`函数装饰`fib()`函数。
- en: 'As fun as writing memoization functions is, it again turns out that this is
    such a common need that others have already solved it for us. I can remove the
    `memoize()` function and instead import the `functools.lru_cache` (least-recently-used
    cache) function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写记忆化函数很有趣，但事实证明这是一个常见的需求，其他人已经为我们解决了。我可以移除`memoize()`函数，而是导入`functools.lru_cache`（最近最少使用缓存）函数：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Decorate the `fib()` function with the `lru_cache()` function to get memoization
    with minimal distraction:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lru_cache()`函数装饰`fib()`函数以实现记忆化，尽量减少干扰：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO15-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO15-1)'
- en: Memoize the `fib()` function via decoration with the `lru_cache()` function.
    Note that Python 3.6 requires the parentheses, but 3.8 and later versions do not.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`lru_cache()`函数装饰`fib()`函数进行记忆化。注意，Python 3.6需要括号，但3.8及更高版本不需要。
- en: Benchmarking the Solutions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试解决方案的性能
- en: 'Which is the fastest solution? I’ve shown you how to use a `for` loop in `bash`
    with the `time` command to compare the runtimes of commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个是最快的解决方案？我已经向你展示了如何在`bash`中使用`for`循环和`time`命令来比较命令的运行时间：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It would appear that the recursive solution using LRU caching is the fastest,
    but again I have very little data—just one run per program. Also, I have to eyeball
    this data and figure out which is the fastest.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来使用LRU缓存的递归解决方案是最快的，但我只有很少的数据——每个程序只运行一次。此外，我需要凭眼观察数据并确定哪个最快。
- en: 'There’s a better way. I have installed a tool called [`hyperfine`](https://oreil.ly/shqOS)
    to run each command many times and compare the results:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有更好的方法。我安装了一个名为[`hyperfine`](https://oreil.ly/shqOS)的工具来多次运行每个命令并比较结果：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It appears that `hyperfine` ran each command 60-66 times, averaged the results,
    and found that the `solution3_recursion_lru_cache.py` program is perhaps slightly
    faster. Another benchmarking tool you might find useful is [`bench`](https://oreil.ly/FKnmd),
    but you can search for other benchmarking tools on the internet that might suit
    your tastes more. Whatever tool you use, benchmarking along with testing is vital
    to challenging assumptions about your code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`hyperfine`运行了每个命令60-66次，取平均结果，并发现`solution3_recursion_lru_cache.py`程序可能稍快。另一个你可能找到有用的基准工具是[`bench`](https://oreil.ly/FKnmd)，但你可以在互联网上搜索其他更适合你口味的基准工具。无论你使用什么工具，基准测试以及测试对挑战代码假设至关重要。
- en: I used the `--prepare` option to tell `hyperfine` to remove the *pycache* directory
    before running the commands. This is a directory created by Python to cache *bytecode*
    of the program. If a program’s source code hasn’t changed since the last time
    it was run, then Python can skip compilation and use the bytecode version that
    exists in the *pycache* directory. I needed to remove this as `hyperfine` detected
    statistical outliers when running the commands, probably due to caching effects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了 `--prepare` 选项告诉 `hyperfine` 在运行命令之前删除 *pycache* 目录。这是 Python 创建的目录，用于缓存程序的
    *bytecode*。如果程序的源代码自上次运行以来没有改变，那么 Python 可以跳过编译，直接使用 *pycache* 目录中存在的 bytecode
    版本。我需要删除它，因为 `hyperfine` 在运行命令时检测到统计异常值，可能是缓存效应导致的。
- en: Testing the Good, the Bad, and the Ugly
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试好的、坏的和丑陋的
- en: 'For every challenge, I hope you spend part of your time reading through the
    tests. Learning how to design and write tests is as important as anything else
    I’m showing you. As I mentioned before, my first tests check that the expected
    program exists and will produce usage statements on request. After that, I usually
    give invalid inputs to ensure the program fails. I would like to highlight the
    tests for bad `n` and `k` parameters. They are essentially the same, so I’ll just
    show the first one as it demonstrates how to randomly select an invalid integer
    value—one that is possibly negative or too high:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个挑战，希望你花些时间阅读测试内容。学习如何设计和编写测试与我展示的任何其他内容同样重要。如我之前提到的，我的第一个测试检查预期的程序是否存在，并且在需要时产生使用说明。接着，我通常会输入无效的数据来确保程序失败。我想强调的是针对不良
    `n` 和 `k` 参数的测试。它们本质上是相同的，所以我只展示第一个作为示例，演示如何随机选择一个无效的整数值，例如可能是负数或者太大：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-1)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-1)'
- en: Join the two lists of invalid number ranges and randomly select one value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个无效数字范围列表连接起来，并随机选择一个值。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-2)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-2)'
- en: Select a random integer in the range from `1` to `5` (both bounds inclusive).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个从 `1` 到 `5`（包括边界）的随机整数。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-3)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-3)'
- en: Run the program with the arguments and capture the output.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有参数的程序，并捕获输出。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-4)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-4)'
- en: Make sure the program reported a failure (nonzero exit value).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序报告了失败（非零退出值）。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-5)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-5)'
- en: Check the output begins with a usage statement.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出是否以使用说明开头。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-6)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO16-6)'
- en: Look for an error message describing the problem with the `n` argument.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找描述 `n` 参数问题的错误消息。
- en: 'I often like to use randomly selected invalid values when testing. This partially
    comes from writing tests for students so that they won’t write programs that fail
    on a single bad input, but I also find it helps me to not accidentally code for
    a specific input value. I haven’t yet covered the `random` module, but it gives
    you a way to make pseudorandom choices. First, you need to import the module:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常喜欢在测试时使用随机选择的无效值。这在某种程度上是为了给学生编写测试，以防止他们在单个坏输入上失败，但我也发现这有助于我避免意外地编写特定输入值的代码。我还未介绍
    `random` 模块，但它可以让你进行伪随机选择。首先，你需要导入该模块：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For instance, you can use `random.randint()` to select a single integer from
    a given range:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `random.randint()` 来从给定范围内选择一个整数：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Or use the `random.choice()` function to randomly select a single value from
    some sequence. Here I wanted to construct a discontiguous range of negative numbers
    separated from a range of positive numbers:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `random.choice()` 函数从某个序列中随机选择一个值。在这里，我想构建一个不连续的负数范围，与一个正数范围分开：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The tests that follow all provide good inputs to the program. For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的测试提供了程序的有效输入。例如：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-1)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-1)'
- en: These are values I was given while attempting to solve the Rosalind challenge.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我在尝试解决Rosalind挑战时收到的值。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-2)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-2)'
- en: The program should not fail on this input.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不应在此输入上失败。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-3)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO17-3)'
- en: This is the correct answer per Rosalind.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Rosalind的正确答案。
- en: Testing, like documentation, is a love letter to your future self. As tedious
    as testing may seem, you’ll appreciate failing tests when you try to add a feature
    and end up accidentally breaking something that previously worked. Assiduously
    writing and running tests can prevent you from deploying broken programs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，就像文档一样，是写给未来自己的一封情书。尽管测试看起来可能很乏味，但当您尝试添加功能并意外破坏以前工作的东西时，您会感激失败的测试。认真地编写和运行测试可以防止您部署损坏的程序。
- en: Running the Test Suite on All the Solutions
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在所有解决方案上运行测试套件
- en: 'You’ve seen that in each chapter I write multiple solutions to explore various
    ways to solve the problems. I completely rely on my tests to ensure my programs
    are correct. You might be curious to see how I’ve automated the process of testing
    every single solution. Look at the *Makefile* and find the `all` target:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，在每章中，我会写多个解决方案来探索解决问题的各种方法。我完全依赖我的测试来确保我的程序是正确的。您可能会好奇看看我如何自动化测试每个解决方案的过程。查看*Makefile*并找到`all`目标：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `all_test.py` program will overwrite the `fib.py` program with each of the
    solutions before running the test suite. This could overwrite your solution. Be
    sure you commit your version to Git or at least make a copy before you run `make
    all` or you could lose your work.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 程序`all_test.py`会在运行测试套件之前用每个解决方案覆盖程序`fib.py`。这可能会覆盖您的解决方案。在运行`make all`之前，请确保您将您的版本提交到Git或至少复制一份，否则可能会丢失您的工作。
- en: 'The following is the `all_test.py` program that is run by the `all` target.
    I’ll break it into two parts, starting with the first part up to `get_args()`.
    Most of this should be familiar by now:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是由`all`目标运行的`all_test.py`程序。我将其分成两部分，从第一部分到`get_args()`。大部分内容现在应该已经很熟悉了：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-1)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-1)'
- en: The name of the program to test, which in this case is `fib.py`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试的程序名称，在本例中为`fib.py`。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-2)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-2)'
- en: A Boolean value of `True` or `False` to create more or less output.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个布尔值`True`或`False`来创建更多或更少的输出。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-3)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-3)'
- en: The default type is `str`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认类型是`str`。
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-4)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO18-4)'
- en: The `action='store_true'` makes this a Boolean flag. If the flag is present
    the value will be `True`, and it will be `False` otherwise.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`action=''store_true''`使其成为布尔标志。如果标志存在，则值为`True`；否则为`False`。'
- en: 'The `main()` function is where the testing happens:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数是进行测试的地方：'
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-1)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-1)'
- en: Get the current working directory, which will be the *04_fib* directory if you
    are in that directory when running the command.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前工作目录，如果您在运行命令时位于该目录中，则为*04_fib*目录。
- en: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-2)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-2)'
- en: Find all the `solution*.py` files in the current directory.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 查找当前目录中的所有`solution*.py`文件。
- en: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-3)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-3)'
- en: Both `filter()` and `partial()` are HOFs; I’ll explain them next.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`和`partial()`都是高阶函数；接下来我将解释它们。'
- en: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-4)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-4)'
- en: The filenames will be in random order, so iterate through the sorted files.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名将以随机顺序排列，因此需要遍历排序后的文件。
- en: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-5)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-5)'
- en: Copy the `solution*.py` file to the testing filename.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将`solution*.py`文件复制到测试文件名。
- en: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-6)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-6)'
- en: Make the program executable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序可执行。
- en: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-7)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-7)'
- en: Run the `make test` command, and capture the return value and output.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make test`命令，并捕获返回值和输出。
- en: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-8)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-8)'
- en: See if the return value is not `0`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 检查返回值是否不为`0`。
- en: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-9)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-9)'
- en: Exit this program while printing the output from the testing and returning a
    nonzero value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 退出此程序时，打印测试输出并返回非零值。
- en: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-10)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-10)'
- en: Unless the program is supposed to be quiet, print the testing output.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除非程序需要静默运行，否则打印测试输出。
- en: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-11)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_creating_the_fibonacci_sequence__writing__testing__and_benchmarking_algorithms_CO19-11)'
- en: Let the user know the program finishes normally.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户知道程序正常结束。
- en: 'In the preceding code, I’m using `sys.exit()` to immediately halt the program,
    print an error message, and return a nonzero exit value. If you consult the documentation,
    you’ll find you can invoke `sys.exit()` with no arguments, an integer value, or
    a object like a string, which is what I’m using:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我使用`sys.exit()`来立即停止程序，打印错误消息，并返回一个非零的退出值。如果查阅文档，您会发现可以用没有参数、一个整数值或像字符串这样的对象调用`sys.exit()`，这正是我所使用的：
- en: '[PRE44]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding program also uses the functions `filter()` or `partial()`, which
    I haven’t covered yet. Both of these are HOFs. I’ll explain how and why I’m using
    them. To start, the `os.listdir()` function will return the entire contents of
    a directory, including files and directories:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序还使用了`filter()`或`partial()`函数，这两者都是高阶函数。我将解释我如何以及为什么使用它们。首先，`os.listdir()`函数将返回目录的全部内容，包括文件和子目录：
- en: '[PRE45]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There’s a lot there, so I’ll import the `pprint()` function from the `pprint`
    module to *pretty-print* this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，所以我将从`pprint`模块导入`pprint()`函数以*漂亮打印*它：
- en: '[PRE46]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I want to filter those to names that start with *solution* and end with *.py*.
    On the command line, I would match this pattern using a *file glob* like `solution*.py`,
    where the `*` means *zero or more of any character* and the `.` is a literal dot.
    A regular expression version of this pattern is the slightly more complicated
    `solution.*\.py`, where `.` (dot) is a regex metacharacter representing *any character*,
    and `*` (star or asterisk) means *zero or more* (see [Figure 4-5](#fig_4.5)).
    To indicate a literal dot, I need to escape it with a backslash (`\.`). Note that
    it’s prudent to use the r-string (*raw* string) to enclose this pattern.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要过滤出以*solution*开头且以*.py*结尾的文件名。在命令行中，我可以使用`solution*.py`这样的*文件通配符*模式，其中`*`表示*任意数量的任何字符*，`.`是一个字面上的点。这个模式的正则表达式版本稍微复杂一些，是`solution.*\.py`，其中`.`（点）是正则表达式元字符，代表*任何字符*，`*`（星号）表示*零个或多个*（见[图 4-5](#fig_4.5)）。为了表示字面上的点，我需要用反斜杠进行转义（`\.`）。注意，最好使用r字符串（*原始*字符串）来包围这个模式。
- en: '![mpfb 0405](assets/mpfb_0405.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0405](assets/mpfb_0405.png)'
- en: Figure 4-5\. A regular expression to find files matching the file glob `solution*.py`
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 用于找到与文件通配符`solution*.py`匹配的文件的正则表达式
- en: 'When the match is successful, a `re.Match` object is returned:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配成功时，将返回一个`re.Match`对象：
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When a match fails, the `None` value is returned. I have to use `type()` here
    because the `None` value is not displayed in the REPL:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配失败时，将返回`None`值。我必须在这里使用`type()`，因为在REPL中不显示`None`值：
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I want to apply this match to all the files returned by `os.listdir()`. I can
    use `filter()` and the `lambda` keyword to create an *anonymous* function. Each
    filename in `files` is passed as the `name` argument used in the match. The `filter()`
    function will only return elements that return a truthy value from the given function,
    so those filenames that return `None` when they fail to match are excluded:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将此匹配应用于`os.listdir()`返回的所有文件。我可以使用`filter()`和`lambda`关键字来创建一个*匿名*函数。将`files`中的每个文件名作为`name`参数传递给匹配。`filter()`函数将只返回给定函数中返回真值的元素，因此那些无法匹配时返回`None`的文件名将被排除：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You see that the `re.match()` function takes two arguments—a pattern and a
    string to match. The `partial()` function allows me to *partially apply* the function,
    and the result is a new function. For example, the `operator.add()` function expects
    two values and returns their sum:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`re.match()`函数接受两个参数——模式和要匹配的字符串。`partial()`函数允许我*部分应用*函数，并返回一个新函数。例如，`operator.add()`函数期望两个值并返回它们的和：
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'I can create a function that adds `1` to any value, like so:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以创建一个函数，用于将任何值加`1`，就像这样：
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `succ()` function requires one argument, and will return the successor:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`succ()`函数需要一个参数，并返回其后继：'
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Likewise, I can create a function `f()` that partially applies the `re.match()`
    function with its first argument, a regular expression pattern:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我可以创建一个函数`f()`，部分应用`re.match()`函数的第一个参数，即正则表达式模式：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `f()` function is waiting for a string to apply the match:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`f()`函数正在等待一个字符串来应用匹配：'
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you call it without an argument, you will get an exception:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不带参数调用它，将会收到一个异常：
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'I can replace the `lambda` with the partially applied function as the first
    argument to `filter()`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用部分应用函数替换`lambda`作为`filter()`的第一个参数：
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: My programming style leans heavily on purely functional programming ideas. I
    find this style to be like playing with LEGO bricks—small, well-defined, and tested
    functions can be composed into larger programs that work well.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我的编程风格在很大程度上倾向于纯函数式编程思想。我发现这种风格就像玩乐高积木一样——小而明确定义的测试函数可以组合成运行良好的更大程序。
- en: Going Further
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解
- en: There are many different styles of programming, such as procedural, functional,
    object-oriented, and so forth. Even within an object-oriented language like Python,
    I can use very different approaches to writing code. The first solution could
    be considered a *dynamic programming* approach because you try to solve the larger
    problem by first solving smaller problems. If you find recursive functions interesting,
    the Tower of Hanoi problem is another classic exercise. Purely functional languages
    like Haskell mostly avoid constructs like `for` loops and rely heavily on recursion
    and higher-order functions. Both spoken and programming languages shape the way
    we think, and I encourage you to try solving this problem using other languages
    you know to see how you might write different solutions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 编程有许多不同的风格，如过程化、函数式、面向对象等等。即使在像Python这样的面向对象语言中，我也可以使用非常不同的编程方法。第一种解决方案可以被认为是*动态规划*方法，因为你首先通过解决较小的问题来解决更大的问题。如果你觉得递归函数有趣，汉诺塔问题是另一个经典练习。像Haskell这样的纯函数式语言大多避免像`for`循环这样的构造，而是严重依赖递归和高阶函数。口语和编程语言塑造了我们思考问题的方式，我鼓励你尝试使用你了解的其他语言解决这个问题，看看你可能会写出不同的解决方案。
- en: Review
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要点：
- en: Inside the `get_args()` function, you can perform manual validation of arguments
    and use the `parser.error()` function to manually generate `argparse` errors.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`get_args()`函数内部，您可以对参数进行手动验证，并使用`parser.error()`函数手动生成`argparse`错误。
- en: You can use a list as a stack by pushing and popping elements.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过推送和弹出元素来使用列表作为堆栈。
- en: Using `yield` in a function turns it into a generator. When the function yields
    a value, the value is returned and the state of the function is preserved until
    the next value is requested. Generators can be used to create a potentially infinite
    stream of values.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中使用`yield`将其转换为生成器。当函数生成一个值时，该值被返回，并保留函数的状态，直到下一个值被请求。生成器可用于创建潜在的无限值流。
- en: A recursive function calls itself, and the recursion can cause serious performance
    issues. One solution is to use memoization to cache values and avoid recomputation.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数调用自身，递归可能导致严重的性能问题。一种解决方法是使用记忆化来缓存值并避免重新计算。
- en: Higher-order functions are functions that take other functions as arguments.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数是接受其他函数作为参数的函数。
- en: Python’s function decorators apply HOFs to other functions.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的函数装饰器将高阶函数应用于其他函数。
- en: Benchmarking is an important technique for determining the best-performing algorithm.
    The `hyperfine` and `bench` tools allow you to compare runtimes of commands over
    many iterations.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试是确定最佳性能算法的重要技术。`hyperfine` 和 `bench` 工具允许您比较多次迭代的命令运行时间。
- en: The `random` module offers many functions for the pseudorandom selection of
    values.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random` 模块提供了许多用于伪随机选择值的函数。'
- en: ^([1](ch04.html#idm45963635588216-marker)) As the legendary David St. Hubbins
    and Nigel Tufnel observed, “It’s such a fine line between stupid and clever.”
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm45963635588216-marker)) 正如传奇般的大卫·圣·哈宾斯和奈杰尔·塔夫内尔所观察到的，“愚蠢和聪明之间只有一线之隔。”
