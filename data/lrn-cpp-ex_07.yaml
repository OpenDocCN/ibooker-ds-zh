- en: 7 Associative containers and files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 关联容器和文件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Filling and using associative containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充和使用关联容器
- en: Pairs and tuples
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对和元组
- en: Reading from files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: Random samples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机样本
- en: We have used vectors several times now but haven’t used an associative container
    yet. An associative container holds key-value pairs, giving us a lookup table
    or dictionary. In this chapter, we will use dictionaries to create a game of answer
    smash. We’ll provide two clues, each a definition of a word. The end of the first
    word will overlap with the start of the next word, giving the answer. For example,
    a *vector* is a “sequential container supporting dynamic resizing,” and a *torch*
    could be defined as a “lit stick carried in one’s hand,” so smashing together
    the words vector and torch gives the answer *vectorch*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用过向量，但还没有使用过关联容器。关联容器持有键值对，为我们提供了一个查找表或字典。在这一章中，我们将使用字典来创建一个答案破坏游戏。我们将提供两个提示，每个都是一个单词的定义。第一个单词的结尾将与下一个单词的开始重叠，给出答案。例如，一个*vector*是一个“支持动态调整大小的顺序容器”，一个*torch*可以定义为“用手携带的点燃的棍子”，所以将单词vector和torch结合起来给出答案*vectorch*。
- en: We’ll start by storing a dictionary in an `std::map` defined in the `map` header,
    which existed before C++11, and then consider other types of associative containers
    too. We will use the newer `std::unordered_map` in the next chapter, so using
    `std::map` in this chapter will be a useful revision, and we will learn about
    an `std::pair` and the more general `std::tuple` on the way. We will start with
    hardcoded dictionaries and read data from a file afterward using a random sample
    to create variety when we play the game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`map`头中定义的`std::map`中存储一个字典，这个`std::map`在C++11之前就存在了，然后考虑其他类型的关联容器。我们将在下一章中使用更新的`std::unordered_map`，因此在这一章中使用`std::map`将是一个有用的复习，我们还将了解`std::pair`和更通用的`std::tuple`。我们将从硬编码的字典开始，之后使用随机样本从文件中读取数据，以在玩游戏时增加多样性。
- en: 7.1 Hardcoded answer smash
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 硬编码答案破坏
- en: We’ll begin by hardcoding the words and definitions. We can put these directly
    into a dictionary or `map`. A `map` allows us to store *values* against *keys*.
    If a key already exists, we can replace the existing entry, but we cannot have
    two entries with the same key. Now, a language dictionary can have multiple definitions
    for the same word, so we will need a data structure allowing more than one value
    per key when we use a proper dictionary. We will start with one definition per
    word, but the `map` header also provides a `multimap`, which does support multiple
    entries, so we can have several definitions later. Let’s start with the old-school
    `std::map` using one value per key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过硬编码单词和定义来开始。我们可以直接将这些内容放入一个字典或`map`中。一个`map`允许我们根据`keys`存储`values`。如果键已存在，我们可以替换现有条目，但不能有两个具有相同键的条目。现在，语言字典可以为同一个单词提供多个定义，因此当我们使用合适的字典时，我们需要一个允许每个键有多个值的数结构。我们将从每个单词一个定义开始，但`map`头也提供了一个`multimap`，它支持多个条目，因此我们可以在以后有多个定义。让我们从使用每个键一个值的传统`std::map`开始。
- en: 7.1.1 Creating and using an std::map
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 创建和使用 std::map
- en: 'As with all containers, the `map` is a class template, so we need to state
    the type of key and value. Both will be strings, so we need a `map` of `string`s
    to `string`s:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有容器一样，`map`是一个类模板，因此我们需要声明键和值的类型。两者都将使用字符串，因此我们需要一个`string`到`string`的`map`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use `operator[]` to both query and insert key-value pairs. To add or
    overwrite an entry, we say
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`operator[]`来查询和插入键值对。要添加或覆盖条目，我们可以说
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then have one item in the `dictionary`, with the key `"assume"` and value
    `"take for granted, take to be the case"`. We can look up a string using the same
    operator; for example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`dictionary`中有一个条目，键为`"assume"`，值为`"take for granted, take to be the case"`。我们可以使用相同的操作符来查找字符串；例如：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we do this, the `new_value` is a defaulted string, as `"fictional"` was
    not in the dictionary. After the call to `operator[]`, the new key `"fictional"`
    and defaulted `string` value end up in the dictionary, which might not be our
    intention. Let’s make a `map` and prove this to ourselves.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，`new_value`是一个默认的字符串，因为`"fictional"`不在字典中。在调用`operator[]`之后，新的键`"fictional"`和默认的字符串值最终出现在字典中，这可能不是我们的意图。让我们创建一个`map`并证明这一点。
- en: We’ll create a `map` of `string` keys to `string` values and stream the contents
    to `std::cout`, so we need to include the `map`, `string`, and `iostream` headers`.`
    When we streamed out a `vector`, we used a range-based `for` loop along the lines
    of
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `string` 键到 `string` 值的 `map`，并将内容流出到 `std::cout`，因此我们需要包含 `map`、`string`
    和 `iostream` 头文件`.` 当我们流出一个 `vector` 时，我们使用了类似于以下范围的 `for` 循环
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can do the same with a `map`, and we will use a `const` reference to avoid
    copies. Each `map` item comprises two strings bundled together as an `std::pair`,
    which has a `first` and `second` method to access each element. We’ll look at
    this in a bit more detail shortly. For now, we can try to query a `map` for a
    nonexistent element and see what happens.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用同样的方式处理 `map`，并且我们将使用 `const` 引用来避免复制。每个 `map` 元素由两个捆绑在一起作为 `std::pair`
    的字符串组成，它有 `first` 和 `second` 方法来访问每个元素。我们将在稍后更详细地探讨这个问题。现在，我们可以尝试查询一个不存在的元素并看看会发生什么。
- en: Listing 7.1 Creating and displaying a `map`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 创建和显示 `map`
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Declares dictionary
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明字典
- en: ❷ Adds an item
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加项目
- en: ❸ Queries nonexistent item
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查询不存在的项目
- en: ❹ const auto & to avoid copies
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 `const auto &` 来避免复制
- en: ❺ Displays pairs
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示对
- en: 'When we run this code, we can see the query for `"fictional"` has added an
    empty string to the dictionary:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们可以看到对 `"fictional"` 的查询向字典中添加了一个空字符串：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This behavior is unintuitive and can cause problems. We have deliberately used
    a `const` reference to containers when we pass them as parameters to functions.
    We want references, so we do not copy the entire container, but we often only
    want to query rather than change the elements, so flag the parameter as `const`.
    If we try to do the same with a `map`
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为不符合直觉，可能会引起问题。当我们将容器作为参数传递给函数时，我们故意使用了 `const` 引用。我们想要引用，所以我们不复制整个容器，但通常我们只想查询而不是更改元素，因此将参数标记为
    `const`。如果我们尝试用 `map` 做同样的事情
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'we get a compile error, telling us there is no `operator[]` taking a `const`
    map. Instead, we can call the `at` method, which is a `const` member function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个编译错误，告诉我们没有接受 `const` `map` 的 `operator[]`。相反，我们可以调用 `at` 方法，它是一个 `const`
    成员函数：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the key does not exist, an `std::out_of_range` exception is thrown. Using
    this alternative method allows us to pass a `map` by `const` reference, which
    will come in handy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不存在，将抛出 `std::out_of_range` 异常。使用这种替代方法允许我们通过 `const` 引用传递 `map`，这将很有用。
- en: The `operator[]` will also replace an existing entry because a `map` only has
    one value per key. If we say
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator[]` 也会替换现有条目，因为 `map` 对每个键只有一个值。如果我们说'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'the fictional entry then has the value `"made up"`. We can avoid overwriting
    existing entries if we use the `insert` method instead. There are various overloads
    of `insert` (see [http://mng.bz/5oEq](http://mng.bz/5oEq)), but the simplest version
    returns two things, an iterator and a `bool`, also bundled as an `std::pair`.
    When we try to insert a new item, we can pass an initializer list for the key
    and value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那个虚构条目现在具有值 `"made up"`。如果我们使用 `insert` 方法，我们可以避免覆盖现有条目。`insert` 有多种重载（见 [http://mng.bz/5oEq](http://mng.bz/5oEq)），但最简单的版本返回两个东西，一个迭代器和
    `bool`，也捆绑为 `std::pair`。当我们尝试插入一个新项目时，我们可以传递一个键和值的初始化列表：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `result`’s second item is true because the new entry was added. The first
    item holds an iterator to the newly added item. If we try to overwrite an existing
    item
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 的第二个项目是真实的，因为新条目已被添加。第一个项目包含指向新添加项目的迭代器。如果我们尝试覆盖现有项目'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: the `next_result`’s second item is false, and the first item holds an iterator
    to the existing item, which allows us to see the existing value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_result` 的第二个项目是假的，第一个项目包含一个指向现有项目的迭代器，这允许我们看到现有值。'
- en: We can now make a dictionary, which is a useful start. Before building our answer
    smash game, let’s pause to consider the `std::pair`, which has cropped up several
    times now, in a bit more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个字典，这是一个有用的起点。在我们构建答案砸游戏之前，让我们暂停一下，更详细地考虑一下 `std::pair`，它现在已经出现好几次了。
- en: 7.1.2 Pairs, tuples, and structured bindings
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 对，元组，和结构化绑定
- en: 'The `std::pair` lives in the `utility` header and is defined by a class `template`,
    based on two types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::pair` 存在于 `utility` 头文件中，它是由一个类模板定义的，基于两种类型：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve used the member variables `first` and `second` already. The `utility`
    header also provides a helper function, called `make_pair`, which creates the
    pair we want and also deduces the type for us. If we say
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `first` 和 `second` 成员变量。`utility` 头文件还提供了一个名为 `make_pair` 的辅助函数，它为我们创建所需的
    `pair` 并推断类型。如果我们说
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'we get a pair of `const char *s`. We could use the string literal `operator
    ""s` to obtain a pair of `std::string`s instead:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一对 `const char *s`。我们可以使用字符串字面量 `operator ""s` 来获取一对 `std::string`s：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rather than using `auto`, we can say `std::pair` and use an initializer list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `auto`，我们可以直接说 `std::pair` 并使用初始化列表：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We don’t need to spell out the type of the pair of items, as CTAD deduces an
    `std::string` for each item. The types do not need to be identical, so we can
    have a pair of two different types if we want. For example
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要明确指定这对元素的类型，因为 CTAD 会为每个元素推导出 `std::string`。类型不需要相同，所以如果我们想的话，我们可以有一个包含两种不同类型的对。例如
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: is `std::pair` holding an `int` and a `double`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 是 `std::pair` 持有一个 `int` 和一个 `double`。
- en: 'Now, a pair holds two elements, but C++11 introduced a generalization called
    a `tuple`, which can hold any number of items. Nobody agrees on how to pronounce
    tuple, so choose one of “two-pel,” “tupp-ell,” or “chewple.” The `tuple` lives
    in the `tuple` header and is defined using the parameter pack (three dots) we
    have met before:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个对（pair）包含两个元素，但 C++11 引入了一种泛化，称为 `tuple`，它可以包含任意数量的项。没有人同意如何发音 `tuple`，所以你可以选择“two-pel”、“tupp-ell”或“chewple”。`tuple`
    位于 `tuple` 头文件中，并使用我们之前遇到的参数包（三个点）定义：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There’s a `make_tuple` function to create a tuple, so we can make a tuple holding
    three strings like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `make_tuple` 函数可以创建元组，所以我们可以创建一个包含三个字符串的元组，如下所示：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, we can equally say
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以这样表达
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: and CTAD will kick in, deducing we have a tuple of three `std::string`s. As
    with the `std::pair`, we can have various types in a tuple, so
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 CTAD 会启动，推导出我们有一个包含三个 `std::string`s 的元组。与 `std::pair` 一样，元组中可以包含各种类型，所以
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: is an `std::tuple` of `int`, `double`, and `float`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个 `std::tuple`，包含 `int`、`double` 和 `float`。
- en: Now, `std::pair` has `first` and `second` members to access either element,
    but `std::tuple` might not hold two elements. We used a `variant` in chapter 5
    when we had a card or a joker and used `std::get` to access the elements. The
    `tuple` header has an overload of `std::get` that we can use to retrieve a `tuple`
    element, stating the index of the item we want. For example, calling
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`std::pair` 有 `first` 和 `second` 成员来访问任意元素，但 `std::tuple` 可能不包含两个元素。我们在第五章中使用
    `variant` 时有一个牌或小丑，并使用 `std::get` 来访问元素。`tuple` 头文件有一个 `std::get` 的重载，我们可以用它来检索
    `tuple` 元素，指定我们想要的项的索引。例如，调用
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: will return the first string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回第一个字符串。
- en: In listing 7.1, we used an `std::pair` when we displayed the dictionary, hiding
    behind the `auto` in
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 7.1 列表中，当我们显示字典时使用了 `std::pair`，隐藏在 `auto` 后面
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `item` is actually a pair of strings, so we needed to call `first` and `second`
    to display the dictionary entries. We can do something neater. C++17 introduced
    *structured bindings*, allowing us to bind names to pairs, tuples, and more (see
    [http://mng.bz/g7De](http://mng.bz/g7De)). If we want our three numbers
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`item` 实际上是一对字符串，所以我们需要调用 `first` 和 `second` 来显示字典条目。我们可以做得更整洁。C++17 引入了 *结构化绑定*，允许我们将名称绑定到对、元组和更多（见
    [http://mng.bz/g7De](http://mng.bz/g7De)）上。如果我们想将三个数字'
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'unpacked into three variables, we could get each element ourselves:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解包到三个变量中，我们可以自己获取每个元素：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Structured binding allows us to get all three items in one line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定允许我们在一行中获取所有三个项目：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have to use `auto`, followed by the variable names we want in the `[]`.
    In effect, the structured binding is syntactic sugar for the handwritten unpacking,
    but it makes a copy of a hidden tuple or pair. Using C++ Insights (see [https://cppinsights.io/s/0579bdbb](https://cppinsights.io/s/0579bdbb))
    for our three numbers, we see a copy of the `tuple`, with a made-up name `__three_numbers6`
    and three named variables referring to the three elements:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `auto`，然后是我们在 `[]` 中想要的变量名。实际上，结构化绑定是手动解包的语法糖，但它会复制一个隐藏的元组或对。使用 C++ Insights（见
    [https://cppinsights.io/s/0579bdbb](https://cppinsights.io/s/0579bdbb)）查看我们的三个数字，我们看到一个
    `tuple` 的副本，有一个虚构的名字 `__three_numbers6` 和三个命名变量，分别指向三个元素：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We’ve met the rvalue reference `&&` before in chapter 2\. We can avoid the
    copy if we use references instead:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中已经遇到过右值引用 `&&`。如果我们使用引用而不是复制，就可以避免复制：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The hidden `__three_numbers6` is then a reference, giving us a reference for
    each number because the `&&` is subject to *reference collapsing,* so it happily
    binds to references.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的 `__three_numbers6` 就是一个引用，因为它遵循 *引用折叠* 规则，所以它愉快地绑定到引用上。
- en: We can bind to arrays and even a structure’s nonstatic members too. For example,
    given
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绑定到数组，甚至结构的非静态成员。例如，给定
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: we can write
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写成
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In each case, we use `auto` and bind to an existing object. The technical editor
    for this book, Tim van Deurzen, gave a great lightning talk on structured bindings
    at Meeting C++ in 2019, if you want to know more (see [https://www.youtube.com/watch?v=YC_
    TMAbHyQU)](https://www.youtube.com/watch?v=YC_TMAbHyQU))).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们使用`auto`并将其绑定到现有对象。本书的技术编辑Tim van Deurzen在2019年Meeting C++上就结构化绑定进行了精彩的闪电演讲，如果您想了解更多信息（见[https://www.youtube.com/watch?v=YC_TMAbHyQU](https://www.youtube.com/watch?v=YC_TMAbHyQU)）。
- en: We were considering how we used an `std::pair` when we displayed the `dictionary`
    in listing 7.1\. We can now bind the `dictionary`’s key-value pair to two names,
    writing
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在考虑如何在列表7.1中显示`dictionary`时使用了`std::pair`。我们现在可以将`dictionary`的键值对绑定到两个名称，编写
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: so we can use the `key` and `value` directly, without having to call `first`
    and `second` on the pair.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以直接使用`key`和`value`，而无需在键值对上调用`first`和`second`。
- en: Listing 7.2 Using structure bindings to access `map` items
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 使用结构绑定访问`map`项
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Binds the structure to key and value
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将结构绑定到键和值
- en: ❷ Displays key and value
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示键和值
- en: 'Similarly, if we use `insert`, we can use a structured binding to hold the
    result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们使用`insert`，我们也可以使用结构绑定来保存结果：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can then use the iterator `it` and the bool `result` directly, rather than
    using `first` to get the iterator and `second` to get the `result`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以直接使用迭代器`it`和布尔值`result`，而无需使用`first`来获取迭代器，使用`second`来获取`result`。
- en: The `pair` and `tuple` can be used in a variety of situations, including returning
    more than one value from a function, as we saw when we considered the `map`’s
    `insert` function. The structured binding also allows us to write clearer code
    when we use the returned values. Armed with the basics of `map` and `pair`, we
    can now make a simple answer smash game.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`pair`和`tuple`可以在各种情况下使用，包括从函数中返回多个值，正如我们在考虑`map`的`insert`函数时所见。结构化绑定还允许我们在使用返回值时编写更清晰的代码。掌握了`map`和`pair`的基础知识后，我们现在可以制作一个简单的答案砸游戏。'
- en: 7.1.3 A simple answer smash game
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 一个简单的答案砸游戏
- en: We will create two dictionaries to play answer smash. One will have C++ keywords
    and types along with their definitions, so we can revise a bit when we play. The
    second will have English words and definitions. We can use `operator[]` to make
    the dictionary of keywords.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个字典来玩答案砸游戏。一个将包含C++关键字和它们的定义，这样我们就可以在玩游戏时稍作复习。第二个将包含英文单词及其定义。我们可以使用`operator[]`来创建关键字字典。
- en: Listing 7.3 Using `operator` `[]` to populate a `map`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 使用`operator[]`填充`map`
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Constructs dictionary
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建字典
- en: ❷ Fills dictionary
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 填充字典
- en: 'To use `operator[]`, we need a mutable rather than `const` `map`, but once
    we have set up the dictionaries, we won’t need to change them. Now, we noticed
    we can pass an initializer list for the key and value to `insert` earlier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`operator[]`，我们需要一个可变的而不是`const`的`map`，但一旦我们设置了字典，我们就不需要更改它们。现在，我们注意到我们可以在`insert`之前传递键和值的初始化列表：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Likewise, we can use an initializer list of pairs, or even an initializer list
    of initializer lists comprising two strings to construct our dictionary.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用一对初始化列表，或者甚至是一个包含两个字符串的初始化列表的初始化列表来构建我们的字典。
- en: Listing 7.4 Using initializer lists to populate a `map`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 使用初始化列表填充`map`
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Constructs dictionary
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建字典
- en: ❷ Fills it with pairs of initializer lists
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用初始化列表的键值对填充它
- en: The second approach means we can mark the dictionary as `const` to ensure we
    don’t accidentally change its contents later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法意味着我们可以将字典标记为`const`，以确保我们不会意外地更改其内容。
- en: 'We can iterate over the keywords, using a structured binding to the key and
    value by `const` reference to avoid copying the strings:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历关键字，通过`const`引用使用结构绑定来访问键和值，以避免复制字符串：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For each keyword, we need a word from the dictionary that overlaps so we can
    smash the keyword and dictionary word together. Given the word `"char"`, we could
    look for something in the dictionary starting with `"char"`, but the whole word
    could get swallowed rather than overlapping. That is fine, but it might be more
    fun to avoid this. Instead, we could try to find something starting with `"har"`.
    Therefore, we need to start with the substring beginning at the second character,
    or index `1`, and make a stem or start of the word to look up:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个关键词，我们需要从字典中找到一个与之重叠的单词，这样我们才能将关键词和字典单词结合起来。给定单词 `"char"`，我们可以在字典中查找以 `"char"`
    开头的条目，但整个单词可能会被完全吞没而不是重叠。这没问题，但避免这种情况可能会更有趣。相反，我们可以尝试查找以 `"har"` 开头的条目。因此，我们需要从第二个字符（或索引
    `1`）开始的子字符串，或者说是单词的词干或起始部分来查找：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can then go through the dictionary looking for words starting with that stem.
    We need to check if a key's substring starting at index `0` of length `stem.size()`
    is equal to the stem `"har"`, so we would find `"harsh"` in our dictionary. In
    the worst case, this does mean we will plod through each key and may not find
    a word. We'll see a more efficient way to look up keys in a `map` shortly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历字典，寻找以该词干开头的单词。我们需要检查键的子字符串是否从索引 `0` 开始，长度为 `stem.size()`，与词干 `"har"`
    相等，因此我们会在我们的字典中找到 `"harsh"`。在最坏的情况下，这意味着我们可能需要逐个检查每个键，并且可能找不到一个单词。我们很快就会看到在 `map`
    中查找键的更有效的方法。
- en: If nothing matches the stem `"har"`, we can try again starting at the next letter,
    so we use `"ar"`. There happens to be a match for `"har"`, so we have a suitable
    word and don’t need to check further. Some words, like `"struct"`, need more searching.
    We drop the initial `'s'` and search for the stem `"truct"`. However, nothing
    in the dictionary starts with `"truct"`, so we could then try `"ruct"` and keep
    trying until we try to match the single letter `"t"`. We need at least one overlapping
    letter to smash two words together. Some words may have no match at all, so we
    can indicate this with an empty string. We could return an `optional` instead
    or even a `tuple` with a Boolean to indicate we cannot find a suitable word, but
    an empty string works too. Try these different approaches for extra practice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配到词干 `"har"`，我们可以再次尝试，从下一个字母开始，所以我们使用 `"ar"`。碰巧有一个 `"har"` 的匹配项，所以我们找到了一个合适的单词，不需要进一步检查。有些单词，如
    `"struct"`，需要更多的搜索。我们去掉初始的 `'s'` 并搜索词干 `"truct"`。然而，字典中没有以 `"truct"` 开头的条目，所以我们可以尝试
    `"ruct"` 并继续尝试，直到我们尝试匹配单个字母 `"t"`。我们需要至少一个重叠字母来将两个单词结合起来。有些单词可能根本找不到匹配项，因此我们可以用一个空字符串来表示这一点。我们也可以返回一个
    `optional` 或甚至一个带有布尔值的 `tuple` 来指示我们找不到合适的单词，但空字符串也行。尝试这些不同的方法以获得额外的练习。
- en: Writing the search in a separate function means we can test it. We can put the
    function in a new source file, called `Smash.cpp`, and use a namespace along with
    a header file, `Smash.h`, to declare the functions we need. The search function
    takes the word we want to match and a dictionary to search. We need to return
    a key from the dictionary if we find a word or an empty string otherwise. If we
    return the offset used too, the calling code can smash together the two words
    without having to rediscover where the overlap is. As we have seen, a simple way
    to return two values from a function is via an `std::pair`, so we can do that
    here, putting the code in `Smash.cpp` and declaring the function in the corresponding
    header.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将搜索编写为单独的函数意味着我们可以对其进行测试。我们可以将函数放入一个新的源文件中，称为 `Smash.cpp`，并使用命名空间以及头文件 `Smash.h`
    来声明所需的函数。搜索函数接受我们想要匹配的单词和要搜索的字典。如果我们找到一个单词，我们需要返回字典中的一个键，如果没有找到，则返回空字符串。如果我们还返回使用的偏移量，调用代码可以在不重新发现重叠位置的情况下将两个单词结合起来。正如我们所见，从函数中返回两个值的一个简单方法是通过
    `std::pair`，所以我们在这里可以这样做，将代码放在 `Smash.cpp` 中，并在相应的头文件中声明函数。
- en: Listing 7.5 Finding an overlapping word
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 查找重叠单词
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Starts at the second letter of the word
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从单词的第二个字母开始
- en: ❷ Considers the start of each key
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 考虑每个键的起始部分
- en: ❸ Finds a match
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 找到匹配项
- en: ❹ Did not find a match
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 未找到匹配项
- en: Although we are potentially checking all the keys, the overlap function is good
    enough for a first attempt at answer smash. We need a function taking the two
    dictionaries, one of keywords and one of more general words, both with definitions
    to use as clues. For each keyword, we’ll try to find an overlapping word, and
    if we do find a word, we will display both definitions as clues. If we don’t,
    we get an empty string and offset of `-1` back, so we will continue to the next
    keyword. If we find a suitable word, the correct answer is the start of the keyword
    concatenated with the second word. We can create the answer using `operator+:`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能正在检查所有键，但重叠函数对于 answer smash 的第一次尝试已经足够好了。我们需要一个函数，它接受两个字典，一个是关键字字典，另一个是更通用的单词字典，两者都包含用作提示的定义。对于每个关键字，我们将尝试找到一个重叠的单词，如果我们找到一个单词，我们将显示两个定义作为提示。如果没有找到，我们将返回一个空字符串和偏移量
    `-1`，因此我们将继续到下一个关键字。如果我们找到一个合适的单词，正确的答案就是关键字的起始部分与第二个单词的连接。我们可以使用 `operator+`
    来创建答案。
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, the substring creates a temporary string, and the concatenation then creates
    another string, so this approach is not very efficient. We do not need to copy
    the substring. C++17 introduced a `string_view` in the `string_view` header, which
    provides a *view* rather than a *copy* of a string. The `std::string_view` gives
    us read-only access to an existing string, which means the existing string needs
    to remain in scope for the view to be valid. We can take a view of the first part
    of the first word, avoiding a copy, and use `std::format`, which we saw in chapter
    2, to make the answer. We can therefore say
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，子字符串创建了一个临时字符串，然后连接操作又创建了一个新的字符串，因此这种方法效率不高。我们不需要复制子字符串。C++17 在 `string_view`
    头文件中引入了 `string_view`，它提供的是字符串的视图而不是副本。`std::string_view` 给我们提供了对现有字符串的只读访问，这意味着视图有效时，现有字符串需要保持作用域。我们可以获取第一个单词的前一部分的视图，避免复制，并使用我们在第
    2 章中看到的 `std::format` 来制作答案。因此，我们可以说
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: and avoid the temporary copy of the substring. For further details, see [http://mng.bz/amzj](http://mng.bz/amzj).
    Using a `string_view` is often more efficient, but as it is a view of another
    object, we need to be careful not to use the view after the original string has
    gone out of scope. We’ll stick with `operator+` in this example for simplicity.
    It’s useful to be aware that we are making an extra copy and don’t need to, though.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 避免临时复制子字符串。有关更多详细信息，请参阅[http://mng.bz/amzj](http://mng.bz/amzj)。使用`string_view`通常更高效，但由于它是对另一个对象的视图，我们需要注意在原始字符串超出作用域后不要使用该视图。为了简单起见，我们将在本例中坚持使用`operator+`。了解我们正在创建额外的副本并且不需要它是很有用的。
- en: We can use `std::getline` to read the guess. The player can simply press Enter
    to give up. We can compare the response with the answer to determine whether the
    guess is correct or not, again putting code in `Smash.cpp` and declaring the function
    in `Smash.h`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `std::getline` 来读取猜测。玩家可以简单地按 Enter 键放弃。我们可以将响应与答案进行比较，以确定猜测是否正确，再次将代码放在
    `Smash.cpp` 中，并在 `Smash.h` 中声明该函数。
- en: Listing 7.6 A simple answer smash game
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 一个简单的 answer smash 游戏
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ For each keyword
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于每个关键字
- en: ❷ Finds an overlap
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找重叠
- en: ❸ Checks we have a suitable word
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查是否有合适的单词
- en: ❹ Uses at for a const map rather than operator[]
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 at 而不是 operator[] 对 const map 进行操作
- en: ❺ Displays both definitions
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示两个定义
- en: ❻ Smashes the two words together
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将两个单词合并在一起
- en: ❼ Gets the response
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 获取响应
- en: ❽ Sees whether the guess is correct
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 检查猜测是否正确
- en: We can call this from `main` and play our game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 `main` 中调用它并玩游戏。
- en: Listing 7.7 Playing the first version of answer smash
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 玩第一个版本的 answer smash
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Includes header declaring simple_answer_smash
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含声明 simple_answer_smash 的头文件
- en: ❷ Sets up keywords
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置关键字
- en: ❸ Sets up dictionary
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置字典
- en: ❹ Plays the game
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 玩游戏
- en: We thought about the first keyword, `"char"`, and the dictionary word `"harsh"`.
    For this combination, we see the clue
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了第一个关键字 `"char"` 和字典单词 `"harsh"`。对于这个组合，我们看到提示
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can either try a guess or just press Enter and see the answer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试猜测或直接按 Enter 键查看答案：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have a simple game. If we take a deeper dive into the `map` and other associative
    containers, we will see how to make the search for an overlap more efficient and
    learn more C++ too.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的游戏。如果我们更深入地研究`map`和其他关联容器，我们将看到如何使重叠搜索更高效，并学习更多 C++。
- en: 7.2 Associative containers
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 关联容器
- en: We’ve used the `std::map` to build a hardcoded game. If we learn about what
    is going on inside the structure, we will be able to make some slight performance
    improvements. With these in hand, we need a related data structure, the `std::multimap`,
    to allow storage of a proper language dictionary, which lets us have more than
    one value per key. After all, words sometimes have more than one definition, so
    when we use a proper dictionary in the final section of this chapter, we may need
    to store several values for a single key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`std::map`构建了一个硬编码的游戏。如果我们了解该结构内部的工作原理，我们将能够进行一些轻微的性能改进。有了这些，我们需要一个相关的数据结构，即`std::multimap`，以便存储合适的语言字典，这使我们能够为每个键存储多个值。毕竟，单词有时有多个定义，所以当我们在本章的最后部分使用合适的字典时，我们可能需要为单个键存储多个值。
- en: 7.2.1 The map type in more detail
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 更详细地了解`map`类型
- en: We know both a `vector` and `array` store their elements contiguously, and we
    can dynamically resize a `vector` but not the `array`. If we search for an item
    in a `vector`, we might have to iterate over all the elements before finding what
    we need, potentially getting to the end without finding the item. If we have `n`
    elements in a `vector`, we may need to check all `n` elements, which is described
    as `O(n)`, or linear complexity. We’ve seen that we can dynamically add pairs
    to a `map`, but we haven’t thought about how elements are stored, so we don’t
    know how a search works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`vector`和`array`都连续存储它们的元素，我们可以动态调整`vector`的大小，但不能调整`array`的大小。如果我们在一个`vector`中搜索一个项目，我们可能需要遍历所有元素才能找到我们需要的，可能到达末尾也找不到项目。如果我们有一个`vector`中有`n`个元素，我们可能需要检查所有`n`个元素，这被描述为`O(n)`，或线性复杂度。我们已经看到我们可以动态地向`map`中添加对，但我们还没有考虑元素是如何存储的，所以我们不知道搜索是如何工作的。
- en: A `map` is designed so we can search for items more quickly. Rather than storing
    the elements next to each other, the map stores them in a *binary tree*. A binary
    tree has nodes, storing elements and pointers to other child nodes, like branches
    in a tree, and has at most two branches at any node; hence the name binary. The
    nodes are ordered, giving us a *binary search tree*, with smaller elements going
    to the left and larger elements going to the right. For a `map`, our elements
    are a key and value, and the key is used to decide whether an item goes to the
    left or right.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`被设计成我们可以更快地搜索项目。而不是将元素存储在一起，`map`将它们存储在一个*二叉树*中。二叉树有节点，存储元素和指向其他子节点的指针，就像树中的分支一样，并且任何节点最多有两个分支；因此得名二叉。节点是有序的，这给了我们一个*二叉搜索树*，较小的元素位于左侧，较大的元素位于右侧。对于`map`，我们的元素是一个键和一个值，键用于决定一个项目是向左还是向右移动。'
- en: If we put `{1:a}`, `{3:c}`, and `{5:e}` in a `map`, we start with a single node
    `{1:a}` and then add `{3:c}`. As the key `3` is larger than `1`, the new element
    `{3:c}` goes to the right, as shown in figure 7.1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`map`中放入`{1:a}`、`{3:c}`和`{5:e}`，我们开始时有一个单个节点`{1:a}`，然后添加`{3:c}`。由于键`3`大于`1`，新元素`{3:c}`将向右移动，如图7.1所示。
- en: '![CH07_F01_Buontempo](../Images/CH07_F01_Buontempo.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Buontempo](../Images/CH07_F01_Buontempo.png)'
- en: 'Figure 7.1 `Map` with two nodes: the first node `{1:a}` at the top and the
    next larger node `{3:c}` to the right'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 有两个节点的`Map`：顶部的第一个节点`{1:a}`和右侧的下一个较大的节点`{3:c}`
- en: When we add the final element `{5:e}`, two things happen. First, the new node
    is larger than `{3:c}`, so it would go below and to the right, but adding a child
    node here means the tree is unbalanced. In effect, we have a chain of `{1:a}`,
    `{3:c}`, and `{5:e}` rather than a balanced tree, as we have lots of right branches
    and no left branches. Pulling `{3:c}` up to be the top node rebalances the tree,
    keeping smaller elements on the left and larger elements on the right, giving
    the layout as shown in figure 7.2.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加最后一个元素`{5:e}`时，会发生两件事。首先，新节点比`{3:c}`大，所以它将位于下方和右侧，但在这里添加一个子节点意味着树变得不平衡。实际上，我们有一个由`{1:a}`、`{3:c}`和`{5:e}`组成的链，而不是一个平衡的树，因为我们有很多右分支而没有左分支。将`{3:c}`提升为顶级节点可以平衡树，使较小的元素位于左侧，较大的元素位于右侧，如图7.2所示。
- en: '![CH07_F02_Buontempo](../Images/CH07_F02_Buontempo.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Buontempo](../Images/CH07_F02_Buontempo.png)'
- en: 'Figure 7.2 Three elements in a balanced binary search tree: nodes with smaller
    keys go on the left and larger keys on the right.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 在平衡的二叉搜索树中的三个元素：具有较小键的节点位于左侧，具有较大键的节点位于右侧。
- en: Having put elements in a `map`, we can now search it. If we want to know if
    `{2:b}` is in the `map`, we start with the top node, `{3:c}`, and since the key
    is `2`, which is less than `3`, we move down to the left node `{1:a}`. That is
    not equal to `2` and furthermore is a *leaf* or *terminating node*, so our search
    is done. We only considered half of the tree. Because the tree is a balanced binary
    tree, we will either search a left or a right branch, so we have logarithmic complexity,
    `O(log(n))`. In fact, search, removal, and insertion operations all have logarithmic
    complexity. If we double the number of elements, we only need one extra set of
    comparisons when we search. For the vector, searching is `O(n)`. If we double
    the number of elements, we might double the number of comparisons when we search.
    We might get lucky and find an element at the start, but in the worst case, we
    must check all the items. Figure 7.3 shows the worst case for constant big-O,
    `O(n)`, and logarithmic, `O(log(n))`, big-O.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在将元素放入`map`之后，我们现在可以搜索它。如果我们想知道`{2:b}`是否在`map`中，我们从顶层节点`{3:c}`开始，因为键是`2`，小于`3`，所以我们向下移动到左节点`{1:a}`。这并不等于`2`，而且它是一个*叶节点*或*终止节点*，所以我们的搜索完成了。我们只考虑了树的一半。因为树是一个平衡的二叉树，所以我们将搜索左分支或右分支，因此我们具有对数复杂度，`O(log(n))`。实际上，搜索、删除和插入操作都具有对数复杂度。如果我们加倍元素的数量，我们在搜索时只需要额外一组比较。对于向量，搜索是`O(n)`。如果我们加倍元素的数量，我们在搜索时可能加倍比较的数量。我们可能会幸运地找到元素在开始处，但在最坏的情况下，我们必须检查所有项目。图7.3显示了常数大-O，`O(n)`，和对数大-O，`O(log(n))`的最坏情况。
- en: '![CH07_F03_Buontempo](../Images/CH07_F03_Buontempo.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Buontempo](../Images/CH07_F03_Buontempo.png)'
- en: 'Figure 7.3 Constant time complexity: `O(n)` grows much faster than logarithmic
    complexity, `O(log(n))`, as the number of elements is increased.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 常数时间复杂度：`O(n)`随着元素数量的增加增长得比对数复杂度`O(log(n))`快得多。
- en: The rebalancing keeps searching efficient. C++ maps are usually implemented
    as red-black trees. The color is extra information on each node, used when insertions
    or deletions take place. To keep the searches to `O(log(n))`, the tree needs to
    be *balanced*. If there are many more nodes down one branch than another, searching
    through the largest side takes longer. A classic resource for tree data structures
    and algorithms is Donald Knuth’s *The Art of Computer Programming*, Volume 3 (Addison-Wesley
    Professional, 1998).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重新平衡保持了搜索的高效性。C++ maps通常实现为红黑树。颜色是每个节点上的额外信息，用于插入或删除时使用。为了将搜索保持在对数复杂度`O(log(n))`，树需要保持*平衡*。如果一个分支的节点比另一个分支多得多，那么通过最大侧搜索会花费更长的时间。关于树数据结构和算法的经典资源是Donald
    Knuth的《计算机程序设计艺术》第三卷（Addison-Wesley Professional，1998）。
- en: If we look at CppReference (see [https://en.cppreference.com/w/cpp/container/map](https://en.cppreference.com/w/cpp/container/map)),
    we are told that a map is a *sorted* associative container. C++11 introduced *unordered*
    containers, which we will look at in the next chapter. We had to specify the key
    and value types for our maps, but a `map` also takes a comparison type, used to
    place nodes in the tree. The comparison defaults to `std::less<Key>`. For the
    `std::string`, we get a default of `std::less<std::string>`, which equates to
    `operator<` for `std::string`. We can specify other ways to compare. For example,
    we may want to make all our strings lowercase first. For a user-defined type,
    we might need to write a comparison operator or define the spaceship operator
    to use our type in a `map`. If we have a user-defined type, even a simple struct
    such as
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看CppReference（见[https://en.cppreference.com/w/cpp/container/map](https://en.cppreference.com/w/cpp/container/map)），我们被告知map是一个*排序的*关联容器。C++11引入了*无序*容器，我们将在下一章中探讨。我们必须指定我们map的键和值类型，但`map`还接受一个比较类型，用于在树中放置节点。比较默认为`std::less<Key>`。对于`std::string`，我们得到默认的`std::less<std::string>`，这等同于`std::string`的`operator<`。我们可以指定其他比较方式。例如，我们可能希望首先将所有字符串转换为小写。对于用户定义的类型，我们可能需要编写比较运算符或定义飞船运算符以在`map`中使用我们的类型。如果我们有一个用户定义的类型，即使是一个简单的结构体，例如
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'we get a compile error if we try to use `Stuff` in a map as the key:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将`Stuff`用作map中的键，我们会得到编译错误：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All we need to do is add the spaceship operator to the struct
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是将飞船运算符添加到结构体
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: and we can then use it in the lookup.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其用于查找。
- en: The C++ standard often tells us the complexity of operations on a container,
    helping us make sensible choices when we code. The big-O or complexity is the
    worst case. For example, a search described as `O(n)` may only look at one element
    if the first element inspected is a match. At worst, all the elements will be
    compared. The complexity is a guideline to how many operations might happen, not
    a guarantee of efficiency. We might still need to benchmark our code to see how
    fast it is, and a profiler can help us find bottlenecks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准通常告诉我们容器上操作的计算复杂度，这有助于我们在编码时做出明智的选择。大O或复杂度是最坏情况。例如，一个描述为`O(n)`的搜索可能只需查看一个元素，如果第一个检查的元素就是匹配项。在最坏的情况下，所有元素都会被比较。复杂度是指导可能发生多少操作的指南，而不是效率的保证。我们可能仍然需要基准测试我们的代码以查看其速度，并且性能分析器可以帮助我们找到瓶颈。
- en: Now, when we built our simple answer smash in listing 7.6, we manually checked
    the keys, so we potentially compared our stem word against all `n` keys, giving
    us `O(n)`. Without profiling, we can improve on this, using other facilities offered
    by the `std::map`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建列表7.6中的简单答案粉碎器时，我们手动检查了键，因此我们可能将我们的词干词与所有`n`个键进行了比较，这给我们带来了`O(n)`。在没有性能分析的情况下，我们可以通过使用`std::map`提供的其他功能来改进这一点。
- en: 7.2.2 Using lower and upper bound to find a key more efficiently
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 使用上下界来更高效地查找键
- en: The `std::map` has a `lower_bound` and an `upper_bound` function, which help
    us query the map more effectively. Both functions find the position at which an
    element would be inserted. The `lower_bound` finds the first element greater than
    or equal to the queried element, while the `upper_bound` finds the position of
    an element with a greater value. Nicolai Josuttis’ book *The C++ Standard Library,
    Second Edition* (Addison-Wesley Professional, 2012), is an excellent reference
    book for further details. The `std::set` and `std::multiset` also support these
    functions. We haven’t used these containers yet. A set allows us to keep a collection
    of unique values, like a `map` but with keys only, and the multiset allows us
    to have duplicate keys.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`有一个`lower_bound`和`upper_bound`函数，这些函数帮助我们更有效地查询映射。这两个函数都找到元素将被插入的位置。`lower_bound`找到第一个大于或等于查询元素的元素，而`upper_bound`找到具有更大值的元素的位置。Nicolai
    Josuttis的书籍《C++标准库，第二版》（Addison-Wesley Professional，2012年），是一本关于进一步详细信息的优秀参考书。`std::set`和`std::multiset`也支持这些函数。我们还没有使用这些容器。集合允许我们保持一组唯一的值，就像映射一样，但只有键，而多重集合允许我们有重复的键。'
- en: 'There are free functions, `std::lower_bound` and `std::upper_bound`, as well,
    which can be used on other containers, provided the elements are ordered by `operator<`.
    We could therefore use these functions on a sorted `vector`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有免费函数`std::lower_bound`和`std::upper_bound`，也可以用于其他容器，前提是元素按`operator<`排序。因此，我们可以将这些函数用于已排序的`vector`：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This might be quicker than iterating through the elements trying to find `3`.
    The upper and lower bound both point to the third element, `4`, as shown in figure
    7.4.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比通过迭代元素尝试找到`3`要快。上下界都指向第三个元素`4`，如图7.4所示。
- en: '![CH07_F04_Buontempo](../Images/CH07_F04_Buontempo.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Buontempo](../Images/CH07_F04_Buontempo.png)'
- en: Figure 7.4 The lower bound, `lb`, and upper bound, `ub`, of `3` in a sorted
    vector
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 已排序向量中`3`的上下界，`lb`和`ub`
- en: When the lower and upper bound match, the item is not present. If we insert
    `3` and run the query again, `lower_bound` would then return an iterator to the
    `3`, and `upper_bound` would still return an iterator to the value `4`. Because
    the positions do not match, we have found the value `3`. The lower bound is greater
    than or equal to the element, and the upper bound is always greater than the element,
    so matching bounds mean they are both greater, whereas different bounds mean the
    lower bound is at the first such element.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下界匹配时，表示该项不存在。如果我们插入`3`并再次运行查询，`lower_bound`将返回指向`3`的迭代器，而`upper_bound`仍然返回指向值`4`的迭代器。因为位置不匹配，我们找到了值`3`。下界大于或等于元素，而上界总是大于元素，所以匹配的界限意味着它们都是更大的，而不同的界限意味着下界位于第一个这样的元素。
- en: 'We can also find the lower and upper bounds in one call to `equal_range`. This
    returns an `std::pair` of iterators, so we can use structured bindings again to
    obtain the lower and upper bounds:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`equal_range`的一次调用中找到上下界。这个函数返回一个迭代器对，因此我们可以再次使用结构化绑定来获取上下界：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `std::map`, along with other containers mentioned, has member functions
    behaving the same way. We sometimes find containers have specialized versions
    of general functions for performance reasons.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map` 以及提到的其他容器具有相同行为的成员函数。我们有时会发现容器为了性能原因，对通用函数有专门的版本。'
- en: We can rewrite our find overlap function using the `lower_bound` and `upper_bound`
    member functions, thereby avoiding potentially checking through all the keys.
    Previously, in listing 7.5, we iterated over all the keys, dropping out of the
    loop if we found a match to the stem. Now, we can use `equal_range` instead to
    find the lower and upper bound of the stem, as this function bundles the results
    of `lower_bound` and `upper_bound` into an `std::pair`. The lower bound finds
    the insertion point if the word isn’t there, so we could be at the end of the
    dictionary or at a nonmatching word. We need to check that the lower bound isn’t
    at the end of the dictionary before comparing the stem with the first part of
    the lower bound’s key
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `lower_bound` 和 `upper_bound` 成员函数重写我们的查找重叠函数，从而避免可能检查所有键。之前，在第 7.5 节的列表中，我们遍历了所有键，如果找到与词干匹配的键，就退出循环。现在，我们可以使用
    `equal_range` 来找到词干的上下界，因为这个函数将 `lower_bound` 和 `upper_bound` 的结果打包成一个 `std::pair`。下界如果词干不存在，则找到插入点，所以我们可能位于字典的末尾或一个不匹配的词。在将词干与下界键的第一部分比较之前，我们需要检查下界不是在字典的末尾。
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: to discover whether we have found a suitable word. Pulling this together gives
    us the following function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 来发现我们是否找到了合适的单词。将这些组合起来，我们得到以下函数。
- en: Listing 7.8 Finding an overlapping word more efficiently
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 更高效地查找重叠单词
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ No for loop any more
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不再需要循环
- en: ❷ Have we found a suitable overlap?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们是否找到了合适重叠？
- en: ❸ Returns word and offset
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回单词和偏移量
- en: We can use this function in our game instead of the original version we wrote
    in listing 7.5.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的游戏中使用这个函数来代替我们在列表 7.5 中编写的原始版本。
- en: We will only find the first matching word when we call `find_overlapping_word`,
    which we can improve on. There might be more than one word that overlaps, and
    furthermore, a proper dictionary might have more than one entry for a word. We
    can make a random choice when we have more than one suitable word, which will
    add some variety to our game. We can also use an `std::multimap` to support more
    than one entry per key. While we are thinking about associative containers, let’s
    learn about multimaps, and then we will be ready to make a new version of our
    game using a proper dictionary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `find_overlapping_word` 时，我们只会找到第一个匹配的单词，我们可以改进这一点。可能存在多个重叠的单词，而且一个合适的字典可能对一个单词有多个条目。当我们有多个合适的单词时，我们可以随机选择，这将为我们的游戏增加一些多样性。我们还可以使用
    `std::multimap` 来支持每个键的多个条目。当我们思考关联容器时，让我们了解多映射，然后我们将准备好使用合适的字典制作我们游戏的新版本。
- en: 7.2.3 Multimaps
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 多映射
- en: 'An `std::multimap` also lives in the `map` header and uses a key and value;
    for example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::multimap` 也位于 `map` 头文件中，并使用键和值；例如：'
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `multimap` supports multiple values for the same key and behaves like an
    `std::map` but with a `vector` of values per key.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`multimap` 支持相同键的多个值，并且像 `std::map` 一样行为，但每个键都有一个值的 `vector`。'
- en: 'To insert items, we can use `insert`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入项，我们可以使用 `insert`：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: or `emplace:`
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 `emplace`：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we saw for a `vector` in chapter 2, `insert` needs an element, so we would
    use `std::pair` for the `multimap` version, while `emplace` constructs the element
    from the provided arguments. The key-value pairs still live in nodes in a tree,
    but we can have several to search through, as figure 7.5 shows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中看到的 `vector`，`insert` 需要一个元素，因此对于 `multimap` 版本，我们会使用 `std::pair`，而
    `emplace` 则从提供的参数构建元素。键值对仍然生活在树中的节点中，但我们可以有多个来搜索，如图 7.5 所示。
- en: '![CH07_F05_Buontempo](../Images/CH07_F05_Buontempo.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Buontempo](../Images/CH07_F05_Buontempo.png)'
- en: Figure 7.5 A multimap with multiple values for a given key
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 给定键的多个值的 multimap
- en: To retrieve values, we need to cope with potentially having more than one value
    per key. Furthermore, the `std::multimap` has no `operator[]` or `at` function,
    so we need to do something else. Fortunately, using `lower_bound` and `upper_bound`
    or `equal_range` gives us what we need, allowing us to find all values corresponding
    to a given key. These functions return iterators, letting us use all the values
    corresponding to a key if there are any.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索值，我们需要处理每个键可能有多个值的情况。此外，`std::multimap`没有`operator[]`或`at`函数，因此我们需要做其他事情。幸运的是，使用`lower_bound`和`upper_bound`或`equal_range`可以给我们所需的结果，允许我们找到与给定键对应的所有值。这些函数返回迭代器，如果存在与键对应的值，我们可以使用所有这些值。
- en: 'Let’s consider the following example. Using namespace literals, we can make
    a `multimap` matching figure 7.5:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例。使用命名空间字面量，我们可以创建一个与图7.5匹配的`multimap`：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we search for `mm.equal_range(2)`, we get an iterator to the node with element
    `3:c` for both the lower and upper bound. This means an element with key 2 would
    be inserted there. If we search for `mm.equal_range(3)` instead, the lower bound
    is `3:c`, being the first element not less than the key `3`, and the upper bound
    is `5:e`, being the first element greater than the key `3`. We then have a pair
    of iterators to use to walk over all the elements with key `3`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索`mm.equal_range(2)`，我们将得到一个指向元素`3:c`的迭代器，对于下界和上界都是如此。这意味着具有键2的元素将被插入那里。如果我们搜索`mm.equal_range(3)`而不是`mm.equal_range(2)`，下界是`3:c`，是第一个不小于键`3`的元素，上界是`5:e`，是第一个大于键`3`的元素。然后我们有一对迭代器，可以用来遍历所有键为`3`的元素。
- en: We need to find a word starting with a stem so we can find the lower bound
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一个以词根开头的单词，这样我们才能找到下界
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: when the dictionary is a `multimap`. The upper bound we need is any word after
    the stem. If we copy the stem
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当字典是一个`multimap`时。我们需要的是任何在词根之后的单词。如果我们复制词根
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: we can add a character after a `'z'` to get beyond the possible stems of words
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`'z'`之后添加一个字符来超越单词可能的词根
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'and use this to find the upper bound:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用它来找到上界：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We then get the start and end of a range of words if there are matches. We will
    use the `multimap` to build a better game, randomly choosing a suitable word from
    this range.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有匹配项，我们将得到一个单词范围的起始和结束。我们将使用`multimap`构建一个更好的游戏，从这个范围内随机选择一个合适的单词。
- en: 7.3 File-based answer smash
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 基于文件的答案砸游戏
- en: We made a simple answer smash game using hardcoded keywords and a tiny dictionary.
    We can make a more interesting game by loading data from a file. The code provided
    with this book has two `csv` files in the folder for this chapter. One has a selection
    of C++ keywords, using definitions based on CppReference (see [https://en.cppreference.com/w/cpp/keyword](https://en.cppreference.com/w/cpp/keyword)),
    and the second has various English words based on a subset of Wordnetcode (see
    [http://mng.bz/M9KQ](http://mng.bz/M9KQ)).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用硬编码的关键词和一个小型词典制作了一个简单的答案砸游戏。通过从文件中加载数据，我们可以制作一个更有趣的游戏。本书提供的代码中，该章节文件夹中有两个`csv`文件。一个包含C++关键词的选择，基于CppReference的定义（见[https://en.cppreference.com/w/cpp/keyword](https://en.cppreference.com/w/cpp/keyword)），另一个包含基于Wordnetcode子集的各种英文单词（见[http://mng.bz/M9KQ](http://mng.bz/M9KQ)）。
- en: 7.3.1 Loading data from a file
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 从文件中加载数据
- en: We haven’t used files yet, but we have used streams, such as `std::cout` and
    `std::cin`, and C++ treats files as streams. Files live in the `fstream` header.
    We can open an input file, `ifstream`, using a filename
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用文件，但我们已经使用了流，例如`std::cout`和`std::cin`，C++将文件视为流。文件位于`fstream`头文件中。我们可以使用文件名
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'and use the stream in a Boolean context to see whether it is open:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 并在布尔上下文中使用流来查看它是否打开：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A file is automatically closed when the variable goes out of scope, so the file
    streams use *resource acquisition is initialization* (RAII), which we met in the
    last chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量超出作用域时，文件会自动关闭，因此文件流使用*资源获取即初始化*（RAII），这是我们上一章遇到的。
- en: Files can be written in text or binary, so we can specify the mode in the constructor
    (see [http://mng.bz/yZDp](http://mng.bz/yZDp)). Our dictionary is text, so the
    default text mode works for us. If we want to write to a file, we use an output
    file stream, `ofstream`. An output file stream can be text or binary as well,
    but we might also want to truncate an existing file or append at the end. We can
    specify open for output and append using bitwise `OR (|)` of the input output
    stream (`ios`) openmodes `out` and `app`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以是文本或二进制格式，因此我们可以在构造函数中指定模式（见[http://mng.bz/yZDp](http://mng.bz/yZDp)）。我们的字典是文本格式，所以默认的文本模式对我们来说就足够了。如果我们想写入文件，我们使用输出文件流`ofstream`。输出文件流也可以是文本或二进制格式，但我们可能还想截断现有文件或追加到文件末尾。我们可以使用输入输出流的位或`OR
    (|)`操作符来指定打开输出和追加，即输入输出流(`ios`)的打开模式`out`和`app`
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: and so on (see [http://mng.bz/Xqy9](http://mng.bz/Xqy9)). To read from a file,
    we can either use `operator>>` or `std::getline`, which we used with `std::cin`
    in chapter 3\. For the output stream, we would use `operator<<`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 等等（见[http://mng.bz/Xqy9](http://mng.bz/Xqy9)）。要从文件中读取，我们可以使用`operator>>`或`std::getline`，我们在第3章中使用`std::cin`时就是这样做的。对于输出流，我们会使用`operator<<`。
- en: The words in our file are stored in mixed case, but we don’t want `Int` and
    `int` to be treated as different words. We should, therefore, make the keys lowercase
    so we can compare directly with lowercased input. We need to write something ourselves,
    so guided by CppReference, we can transform a `string`, making each character
    lowercase. We can use `transform` from the `algorithm` header and C’s `tolower`
    function from the `cctype` header (see [https://shortener.manning.com/QR66](https://shortener.manning.com/QR66)).
    The `tolower` function operates on `int`s, rather than `char`s, so we must be
    careful. We need to treat each character as an `unsigned char` because the behavior
    of `std::tolower` is undefined if the argument’s value is neither an end of file
    (EOF) nor representable as an unsigned `char`. We therefore use a lambda taking
    an `unsigned char` in the transformation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文件中的单词以混合大小写存储，但我们不希望`Int`和`int`被视为不同的单词。因此，我们应该将键转换为小写，以便可以直接与转换为小写的输入进行比较。我们需要自己编写一些代码，因此，在
    CppReference 的指导下，我们可以将一个`string`转换为小写，使每个字符都变为小写。我们可以使用`algorithm`头文件中的`transform`函数和`cctype`头文件中的
    C 的`tolower`函数（见[https://shortener.manning.com/QR66](https://shortener.manning.com/QR66)）。`tolower`函数作用于`int`，而不是`char`，因此我们必须小心。我们需要将每个字符视为一个`unsigned
    char`，因为如果参数的值既不是文件结束（EOF）也不是可表示为无符号`char`的值，`std::tolower`的行为是未定义的。因此，我们在转换中使用了接受`unsigned
    char`的lambda表达式。
- en: Listing 7.9 Transforming a string to lowercase
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 将字符串转换为小写
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can now write a function to load a dictionary from a file. Each line will
    have a word, a comma, and a definition:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写一个函数来从文件中加载字典。每一行将有一个单词、一个逗号和一个定义：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can walk through the file one line at a time and try to find the first comma:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以逐行遍历文件，并尝试找到第一个逗号：
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If the `position` is `std::string::npos`, we have an invalid line, which we
    can log and ignore. Otherwise, we can split the line into a key and value. The
    key is the substring up to the comma’s position
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`position`是`std::string::npos`，则表示无效行，我们可以记录并忽略它。否则，我们可以将行分割成键和值。键是逗号位置之前的子字符串
- en: '[PRE65]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'and the definition is the substring starting after the comma’s position up
    to the end of the line:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 定义是逗号位置之后的子字符串，直到行尾：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we use an `std::string` for the filename, we can write a function returning
    a `multimap` to use in our improved game. The `multimap` allows more than one
    definition per word.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`std::string`作为文件名，我们可以编写一个返回`multimap`的函数，以便在我们的改进游戏中使用。`multimap`允许每个单词有多个定义。
- en: Listing 7.10 Loading a file into a `multimap`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10 将文件加载到`multimap`
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Creates and opens a file for reading
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建并打开一个文件用于读取
- en: ❷ Reads each line
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取每一行
- en: ❸ Splits on the comma
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在逗号处分割
- en: ❹ Lowercases the key
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将键转换为小写
- en: ❺ Adds key-value pair to multimap
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将键值对添加到multimap
- en: 'We can use this function to load the keywords and the dictionary. File paths
    have backslashes on some operating systems, so something like `"c:\"` might cause
    problems in code because the backslash is also used to escape a special character.
    We can use raw strings, introduced in C++11, indicated with `R()` around a string.
    If we keep the files in the working directory, we don’t need to use a raw string,
    but it’s another new feature that’s worth being aware of:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来加载关键词和字典。在某些操作系统中，文件路径上有反斜杠，所以像 `"c:\"` 这样的路径可能会在代码中引起问题，因为反斜杠也用于转义特殊字符。我们可以使用
    C++11 中引入的原始字符串，用 `R()` 包围字符串来表示。如果我们把文件保存在工作目录中，我们不需要使用原始字符串，但这又是一个值得注意的新特性：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There is more to raw strings, but we will stick with the `string` filename here.
    We need to remember that the code needs to be run from a directory containing
    the files; otherwise, the code won’t find the input files.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串还有更多内容，但在这里我们将坚持使用 `string` 文件名。我们需要记住，代码需要在包含文件的目录中运行；否则，代码将找不到输入文件。
- en: Raw strings and the filesystem type
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串和文件系统类型
- en: We can use various start and stop characters beyond the brackets `'(' and ')'`
    in raw strings (see [http://mng.bz/46ER](http://mng.bz/46ER)). We could even use
    the filesystem path introduced in C++17 (see [https://en.cppreference.com/w/cpp/filesystem/path](https://en.cppreference.com/w/cpp/filesystem/path))
    to represent file paths.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在原始字符串中使用各种括号 `'(' 和 ')'` 之外的起始和结束字符（见 [http://mng.bz/46ER](http://mng.bz/46ER)）。我们甚至可以使用
    C++17 中引入的文件系统路径（见 [https://en.cppreference.com/w/cpp/filesystem/path](https://en.cppreference.com/w/cpp/filesystem/path)）来表示文件路径。
- en: 7.3.2 Picking a word randomly using std::sample
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 使用 std::sample 随机选择一个单词
- en: Rather than using all the keywords, we can randomly pick a few to play the game.
    We can also pick one of several overlapping words from the dictionary. C++17 introduced
    a `sample` function, which allows us to choose some items from a range without
    replacement. Each item is equally likely. The `std::sample` function lives in
    the `algorithm` header. It takes a first and last iterator, an output iterator
    to write the samples to, how many samples to pick, and a random number generator.
    We can therefore include the `random` header to make a generator
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随机选择一些关键词来玩游戏，而不是使用所有关键词。我们还可以从字典中选择几个重叠的单词。C++17 引入了一个 `sample` 函数，它允许我们从范围中选择一些项目而不进行替换。每个项目被选中的概率是相等的。`std::sample`
    函数位于 `algorithm` 头文件中。它需要一个第一个和最后一个迭代器，一个输出迭代器来写入样本，选择多少个样本，以及一个随机数生成器。因此，我们可以包含
    `random` 头文件来创建一个生成器
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'and find the entries matching the stem of a word. The lower bound matches the
    stem:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 并找到与单词词干匹配的条目。下限与词干匹配：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The lower bound may or may not match the stem we want. For the upper bound,
    we want one beyond the stem:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下限可能与我们要的词干匹配，也可能不匹配。对于上限，我们想要一个比词干更大的值：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Going beyond the stem ensures we find any word whose first few letters match.
    If we are looking for `"pet"`, we want to include `"petal"`, and any other words
    starting with `"pet"` as well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 超出词干可以确保我们找到任何以几个字母匹配的单词。如果我们正在寻找 `"pet"`，我们希望包括 `"petal"` 以及任何以 `"pet"` 开头的其他单词。
- en: 'If the lower and upper bounds, `lb` and `ub`, are equal, we cannot find a suitable
    word; otherwise, we can sample one item from the range into a `vector`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下限和上限 `lb` 和 `ub` 相等，我们无法找到一个合适的单词；否则，我们可以从这个范围内采样一个项目到一个 `vector` 中：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Back in chapter 2, we discovered that Pascal’s triangle told us how many combinations
    we can have for tossing a coin or, in this case, selecting an entry from a dictionary.
    Selecting a single item isn’t difficult, but picking more than one is more complicated,
    so C++ is doing the hard work for us. C++20 introduced a ranges version of the
    `sample` algorithm, which we can use to pick a few of the keywords. If we load
    the keywords using listing 7.10, we can pick `5` using `sample`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第 2 章，我们发现帕斯卡三角告诉我们抛硬币或在这种情况下从字典中选择条目可以有多少种组合。选择单个项目并不困难，但选择多个就更加复杂了，因此 C++
    为我们做了这项艰苦的工作。C++20 引入了 `sample` 算法的范围版本，我们可以用它来选择一些关键词。如果我们使用列表 7.10 加载关键词，我们可以使用
    `sample` 选择 `5` 个：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now we have all the parts we need to create an answer smash game based on words
    and definitions in files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建基于文件中单词和定义的答案砸游戏所需的所有部分。
- en: 7.3.3 Answer smash
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 答案砸
- en: First, we need a function to select an overlapping word in a `multimap`. Because
    we may get more than one matching word or a matching word with two different definitions,
    we will select one using the random `sample` function we just met. If we make
    a function template, we can send in a sample function, which makes testing easier.
    We can use a lambda instead to either perform a random sample or always pick the
    first or last item and so on for testing. Using a template means we should put
    the function in a header file, so we use our `Smash.h` header.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个函数来在`multimap`中选择一个重叠的单词。因为我们可能得到多个匹配的单词或者一个具有两个不同定义的匹配单词，我们将使用我们刚刚遇到的随机`sample`函数来选择一个。如果我们创建一个函数模板，我们可以传入一个sample函数，这使得测试更容易。我们可以使用lambda来执行随机抽样或者总是选择第一个或最后一个项目等等，用于测试。使用模板意味着我们应该将函数放在头文件中，所以我们使用我们的`Smash.h`头文件。
- en: In listing 7.8, we found an overlapping word and reported the overlap. We could
    return the definition as well to save the extra lookup, so we can use a `tuple`
    to return the word, definition, and offset using
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.8中，我们找到了一个重叠的单词并报告了重叠。我们可以返回定义以节省额外的查找，因此我们可以使用`tuple`来返回单词、定义和偏移量，使用
- en: '[PRE74]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We’ll need several headers: `map`, `string`, `tuple`, and `vector`. Then we
    can write our function.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要几个头文件：`map`、`string`、`tuple`和`vector`。然后我们可以编写我们的函数。
- en: Listing 7.11 Selecting a word from a `multimap`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11 从`multimap`中选择单词
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ❶ Finds suitable words
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 找到合适的单词
- en: ❷ Checks whether we found suitable words
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否找到了合适的单词
- en: ❸ Picks a dictionary entry
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择字典条目
- en: ❹ Didn’t find a word, so try again
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 没有找到单词，所以再试一次
- en: ❺ None found
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 没有找到
- en: We can test this function. In listing 6.12, we used a fake generator and distribution,
    but here we use only a single lambda to pick an item. We can always pick the first
    or last item for testing. The first item is the lower bound
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这个函数。在列表6.12中，我们使用了一个假的生成器和分布，但在这里我们只使用一个lambda来选择一个项目。我们可以总是选择第一个或最后一个项目进行测试。第一个项目是下界
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'and the last item is one before the upper bound:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 并且最后一个项目是上界之前的一个：
- en: '[PRE77]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can test our `select_overlapping_word_from_dictionary` function in a `check_properties`
    function using the `assert` function again.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`check_properties`函数中使用`assert`函数再次测试我们的`select_overlapping_word_from_dictionary`函数。
- en: Listing 7.12 Testing properties
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12 测试属性
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ Uses empty multimap and lambda
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用空multimap和lambda
- en: ❷ No suitable word found
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 未找到合适的单词
- en: 'Finally, we need a new answer smash function taking two multimaps. This is
    very similar to the hardcoded version with maps we built in listing 7.6, but it
    now samples one item from the dictionary using a lambda:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个新的答案smash函数，它接受两个multimap。这与我们在列表7.6中构建的带有map的硬编码版本非常相似，但现在它使用lambda从字典中采样一个项目：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Five keywords are sampled, and overlapping items from the dictionary are found,
    giving a `tuple` with a `word`, `definition`, and `offset` to save the extra lookup
    for the clue.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 抽取了五个关键词，并找到了字典中的重叠项，给出一个包含`word`、`definition`和`offset`的`tuple`以保存额外的查找线索。
- en: Listing 7.13 A better answer smash game
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13 更好的答案smash游戏
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ❶ Wraps std::sample in a lambda
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将std::sample包装在lambda中
- en: ❷ Samples five keywords
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 抽样五个关键词
- en: ❸ Looks for a suitable word
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 寻找合适的单词
- en: ❹ None found, so try again
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 没有找到，所以再试一次
- en: ❺ Displays clues
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 显示线索
- en: ❻ Checks lowercased response
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查小写响应
- en: We can call the game from `main` and see how well we do.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`main`中调用游戏并看看我们做得怎么样。
- en: Listing 7.14 A proper answer smash game
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.14 合适的答案smash游戏
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Don’t forget to include a `Smash.cpp` file in your build, and the code needs
    to be run from a directory containing the dictionary and keyword files or the
    path changed in the code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在构建中包含`Smash.cpp`文件，并且代码需要从包含字典和关键词文件的目录中运行，或者更改代码中的路径。
- en: You should get various clues when you play the game. Some are quite pleasing.
    For example, the clue
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，你应该得到各种线索。有些相当令人愉悦。例如，线索
- en: '[PRE82]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: smashed `"this"` and `"history"` together to give `"thistory"`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 将`"this"`和`"history"`合并为`"thistory"`。
- en: We’ve built the answer smash game we set out to create and revised using the
    `std::map` and `std::multimap` along the way. We noted that C++ introduced unordered
    maps, so we will look at these in more detail in the next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了我们最初设定的答案smash游戏，并在使用`std::map`和`std::multimap`的过程中进行了修订。我们注意到C++引入了无序映射，所以我们将在下一章更详细地探讨这些内容。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Associative containers are part of the standard template library (STL).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联容器是标准模板库（STL）的一部分。
- en: An `std::pair` holds two values of any type, and we use `first` and `second`
    to access the values.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::pair`可以持有任何类型的两个值，我们使用`first`和`second`来访问这些值。'
- en: The `std::tuple` is a generalization of an `std::pair`, and we use `std::get`
    to access values.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::tuple` 是 `std::pair` 的一般化，我们使用 `std::get` 来访问值。'
- en: We can use structured bindings to bind pairs, tuples, and more directly into
    variables.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用结构化绑定将对、元组等直接绑定到变量中。
- en: The `std::map`’s `operator[]` can be used to query and insert elements, so use
    the `at` function instead to query if you don’t want to add an element by accident.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 的 `operator[]` 可以用来查询和插入元素，所以如果你想避免意外添加元素，请使用 `at` 函数来查询。'
- en: An `std::string_view` can be used to avoid copies of strings, but care must
    be taken over lifetimes.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string_view` 可以用来避免字符串的复制，但必须注意其生命周期。'
- en: The `std::map` search, removal, and insertion operations have logarithmic complexity.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 的搜索、删除和插入操作具有对数复杂度。'
- en: An `std::map` key must be supported by the `std::less` operator, so we might
    need to add the spaceship operator to a user defined type to use it as a dictionary
    key.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 的键必须支持 `std::less` 操作符，因此我们可能需要向用户定义的类型添加关系运算符，以便将其用作字典键。'
- en: The `std::map`, `std::multimap`, and `std::set` are ordered associative containers,
    often implemented as red-black trees.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`、`std::multimap` 和 `std::set` 是有序关联容器，通常实现为红黑树。'
- en: An `std::multimap` supports non-unique keys.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::multimap` 支持非唯一键。'
- en: Use the lower and upper bound member functions of the ordered associative containers
    for efficiency.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高效率，请使用有序关联容器的下界和上界成员函数。
- en: Files are streams, so they support `operator<<` and `operator>>`. We can also
    use `std::getline` to read a whole line from an input file stream.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件是流，因此它们支持 `operator<<` 和 `operator>>` 操作符。我们还可以使用 `std::getline` 从输入文件流中读取整行。
- en: The `std::sample` function selects a sample of `k` items from a range without
    replacement.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sample` 函数可以从一个范围中选择 `k` 个不重复的样本。'
