- en: Part 1\. Fundamentals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分\. 基础知识
- en: This first part of the book provides the fundamentals to help you get started
    with the new Java ideas introduced in Java 8. By the end of this first part, you’ll
    have a full understanding of what lambda expressions are, and you’ll be able to
    write code that’s both concise and flexible enough to easily adapt to changing
    requirements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一部分提供了基础知识，帮助你开始使用Java 8引入的新Java思想。到第一部分的结尾，你将全面了解lambda表达式是什么，你将能够编写既简洁又灵活的代码，以便轻松适应不断变化的需求。
- en: In [chapter 1](kindle_split_011.xhtml#ch01), we summarize the main changes to
    Java (lambda expressions, method references, streams, and default methods) and
    set the scene for the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](kindle_split_011.xhtml#ch01)中，我们总结了Java的主要变化（lambda表达式、方法引用、流和默认方法）并为本书设定了场景。
- en: In [chapter 2](kindle_split_012.xhtml#ch02), you’ll learn about behavior parameterization,
    a software development pattern that Java 8 relies heavily on and is the motivation
    for lambda expressions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](kindle_split_012.xhtml#ch02)中，你将了解行为参数化，这是一种Java 8高度依赖的软件开发模式，也是lambda表达式产生的动机。
- en: '[Chapter 3](kindle_split_013.xhtml#ch03) gives a full explanation, with code
    examples and quizzes at every step, of the concepts of lambda expressions and
    method references.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](kindle_split_013.xhtml#ch03)提供了完整的解释，包括代码示例和每一步的测验，解释了lambda表达式和方法引用的概念。'
- en: 'Chapter 1\. Java 8, 9, 10, and 11: what’s happening?'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章\. Java 8、9、10和11：发生了什么？
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why Java keeps changing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Java一直在变化
- en: Changing computing background
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算背景的变化
- en: Pressures for Java to evolve
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java进化的压力
- en: Introducing new core features of Java 8 and 9
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Java 8和9的新核心特性
- en: 'Since the release of Java Development Kit (JDK 1.0) in 1996, Java has won a
    large following of students, project managers, and programmers who are active
    users. It’s an expressive language and continues to be used for projects both
    large and small. Its evolution (via the addition of new features) from Java 1.1
    (1997) to Java 7 (2011) has been well managed. Java 8 was released in March 2014,
    Java 9 in September 2017, Java 10 in March 2018, and Java 11 planned for September
    2018\. The question is this: Why should you care about these changes?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1996年Java开发工具包（JDK 1.0）发布以来，Java赢得了大量学生、项目经理和程序员的关注，他们是活跃的用户。它是一种表达性语言，并且继续被用于大小项目。从Java
    1.1（1997）到Java 7（2011）的演变得到了很好的管理。Java 8于2014年3月发布，Java 9于2017年9月发布，Java 10于2018年3月发布，Java
    11计划于2018年9月发布。问题是：为什么你应该关心这些变化？
- en: 1.1\. So, what’s the big story?
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 那么，重大新闻是什么呢？
- en: We argue that the changes to Java 8 were in many ways more profound than any
    other changes to Java in its history (Java 9 adds important, but less-profound,
    productivity changes, as you’ll see later in this chapter, while Java 10 makes
    much smaller adjustments to type inference). The good news is that the changes
    enable you to write programs more easily. For example, instead of writing verbose
    code (to sort a list of apples in `inventory` based on their weight) like
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为Java 8的变化在很多方面比Java历史上的任何其他变化都更为深刻（Java 9添加了重要但影响较小的生产力变化，你将在本章后面看到，而Java
    10对类型推断进行了许多较小的调整）。好消息是这些变化使你更容易编写程序。例如，你不需要编写冗长的代码（根据重量对`inventory`中的苹果列表进行排序）如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'in Java 8 you can write more concise code that reads a lot closer to the problem
    statement, like the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，你可以编写更简洁的代码，这些代码更接近于问题陈述，如下所示：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The first Java 8 code of the book!**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 本书的第一段Java 8代码！**'
- en: It reads “sort inventory comparing apple weight.” Don’t worry about this code
    for now. This book will explain what it does and how you can write similar code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 它读作“按苹果重量排序库存。”现在不用担心这段代码。本书将解释它做什么以及你如何编写类似的代码。
- en: 'There’s also a hardware influence: commodity CPUs have become multicore—the
    processor in your laptop or desktop machine probably contains four or more CPU
    cores. But the vast majority of existing Java programs use only one of these cores
    and leave the other three idle (or spend a small fraction of their processing
    power running part of the operating system or a virus checker).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，硬件也有影响：通用CPU已经变成了多核——你笔记本电脑或台式机的处理器可能包含四个或更多的CPU核心。但绝大多数现有的Java程序只使用这些核心中的一个，而让其他三个闲置（或者只使用一小部分处理能力运行操作系统或病毒检查器）。
- en: Prior to Java 8, experts might tell you that you have to use threads to use
    these cores. The problem is that working with threads is difficult and error-prone.
    Java has followed an evolutionary path of continually trying to make concurrency
    easier and less error-prone. Java 1.0 had threads and locks and even a memory
    model—the best practice at the time—but these primitives proved too difficult
    to use reliably in nonspecialist project teams. Java 5 added industrial-strength
    building blocks like thread pools and concurrent collections. Java 7 added the
    fork/join framework, making parallelism more practical but still difficult. Java
    8 gave us a new, simpler way of thinking about parallelism. But you still have
    to follow some rules, which you’ll learn in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 之前，专家可能会告诉你必须使用线程来使用这些核心。问题是与线程一起工作既困难又容易出错。Java 一直遵循着一条不断尝试使并发更容易、更不易出错的进化道路。Java
    1.0 有线程、锁甚至内存模型——当时最好的实践，但这些原语在非专业项目团队中证明太难可靠地使用。Java 5 添加了工业级的构建块，如线程池和并发集合。Java
    7 添加了 fork/join 框架，使并行性更实用，但仍然困难。Java 8 给我们提供了一种新的、更简单的方式来思考并行性。但你还必须遵循一些规则，你将在本书中学到这些规则。
- en: As you’ll see later in this book, Java 9 adds a further structuring method for
    concurrency—reactive programming. Although this has more-specialist use, it standardizes
    a means of exploiting the RxJava and Akka reactive streams toolkits that are becoming
    popular for highly concurrent systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本书后面看到的那样，Java 9 添加了另一种并发结构方法——响应式编程。尽管这有更专业的用途，但它标准化了利用越来越受欢迎的 RxJava
    和 Akka 响应式流工具包的方法，这些工具包适用于高度并发的系统。
- en: 'From the previous two desiderata (more concise code and simpler use of multicore
    processors) springs the whole consistent edifice captured by Java 8\. We start
    by giving you a quick taste of these ideas (hopefully enough to intrigue you,
    but short enough to summarize them):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前两个愿望（更简洁的代码和更简单的多核处理器使用）中产生了整个由 Java 8 捕获的统一结构。我们首先给你一个这些想法的快速尝鲜（希望足够吸引你，但足够简短以总结它们）：
- en: The Streams API
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streams API
- en: Techniques for passing code to methods
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码传递给方法的技巧
- en: Default methods in interfaces
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口中的默认方法
- en: Java 8 provides a new API (called Streams) that supports many parallel operations
    to process data and resembles the way you might think in database query languages—you
    express what you want in a higher-level manner, and the implementation (here the
    Streams library) chooses the best low-level execution mechanism. As a result,
    it avoids the need for you to write code that uses `synchronized`, which is not
    only highly error-prone but also more expensive than you may realize on multicore
    CPUs.^([[1](#ch01fn01)])
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 提供了一个新的 API（称为 Streams），它支持许多并行操作来处理数据，类似于你可能认为的数据库查询语言的方式——你以更高级的方式表达你想要的内容，而实现（在这里是
    Streams 库）选择最佳的底层执行机制。因此，它避免了你需要编写使用 `synchronized` 的代码的需求，这不仅高度易出错，而且在多核 CPU
    上可能比你想象的更昂贵。[1](#ch01fn01)
- en: ¹
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Multicore CPUs have separate caches (fast memory) attached to each processor
    core. Locking requires these to be synchronized, requiring relatively slow cache-coherency-protocol
    inter-core communication.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多核 CPU 为每个处理器核心配备了独立的缓存（快速内存）。锁定需要这些缓存同步，这要求相对较慢的缓存一致性协议跨核心通信。
- en: 'From a slightly revisionist viewpoint, the addition of Streams in Java 8 can
    be seen as a direct cause of the two other additions to Java 8: *concise techniques
    to pass code to methods* (method references, lambdas) and *default methods* in
    interfaces.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从稍微有些修正的观点来看，Java 8 中 Streams 的添加可以看作是 Java 8 中其他两个添加的直接原因：*将代码传递给方法的简洁技巧*（方法引用、lambda）和接口中的*默认方法*。
- en: But thinking of passing code to methods as a mere consequence of Streams downplays
    its range of uses within Java 8\. It gives you a new concise way to express *behavior
    parameterization*. Suppose you want to write two methods that differ in only a
    few lines of code. You can now simply pass the code of the parts that differ as
    an argument (this programming technique is shorter, clearer, and less error-prone
    than the common tendency to use copy and paste). Experts will here note that behavior
    parameterization could, prior to Java 8, be encoded using anonymous classes—but
    we’ll let the example at the beginning of this chapter, which shows increased
    code conciseness with Java 8, speak for itself in terms of clarity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但将传递代码给方法仅仅视为Streams的后果，就低估了它在Java 8中的用途范围。它为你提供了一种新的简洁方式来表达*行为参数化*。假设你想编写两个只有几行代码不同的方法。现在你可以简单地传递不同部分的代码作为参数（这种编程技术比常见的复制粘贴方法更短、更清晰、更不容易出错）。专家们在这里会指出，在Java
    8之前，行为参数化可以使用匿名类来编码——但我们让本章开头的例子自己说话，这个例子展示了Java 8如何提高代码的简洁性，从清晰度的角度来看。
- en: The Java 8 feature of passing code to methods (and being able to return it and
    incorporate it into data structures) also provides access to a range of additional
    techniques that are commonly referred to as *functional-style programming*. In
    a nutshell, such code, called *functions* in the functional programming community,
    can be passed around and combined in a way to produce powerful programming idioms
    that you’ll see in Java guise throughout this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8将代码传递给方法（并能返回它并将其纳入数据结构）的功能还提供了访问一系列通常被称为*函数式编程*的附加技术。简而言之，在函数式编程社区中被称为*函数*的这种代码，可以通过传递和组合的方式产生强大的编程习惯，你将在本书中看到这些习惯以Java的形式出现。
- en: The meat of this chapter begins with a high-level discussion on why languages
    evolve, continues with sections on the core features of Java 8, and then introduces
    the ideas of functional-style programming that the new features simplify using
    and that new computer architectures favor. In essence, [section 1.2](#ch01lev1sec2)
    discusses the evolution process and the concepts, which Java was previously lacking,
    to exploit multicore parallelism in an easy way. [Section 1.3](#ch01lev1sec3)
    explains why passing code to methods in Java 8 is such a powerful new programming
    idiom, and [section 1.4](#ch01lev1sec4) does the same for Streams—the new Java
    8 way of representing sequenced data and indicating whether these can be processed
    in parallel. [Section 1.5](#ch01lev1sec5) explains how the new Java 8 feature
    of default methods enables interfaces and their libraries to evolve with less
    fuss and less recompilation; it also explains the *modules* addition to Java 9,
    which enables components of large Java systems to be specified more clearly than
    “just a JAR file of packages.” Finally, [section 1.6](#ch01lev1sec6) looks ahead
    at the ideas of functional-style programming in Java and other languages sharing
    the JVM. In summary, this chapter introduces ideas that are successively elaborated
    in the rest of the book. Enjoy the ride!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心内容从对语言演化的高层次讨论开始，接着讨论Java 8的核心特性，然后介绍了新特性简化了使用并受到新计算机架构青睐的函数式编程理念。本质上，[第1.2节](#ch01lev1sec2)讨论了演化过程和Java之前所缺乏的概念，以简单的方式利用多核并行性。[第1.3节](#ch01lev1sec3)解释了为什么在Java
    8中将代码传递给方法是一种如此强大的新编程习惯，而[第1.4节](#ch01lev1sec4)则对Streams——Java 8表示有序数据的新方式以及这些数据是否可以并行处理进行了同样的解释。[第1.5节](#ch01lev1sec5)解释了新的Java
    8特性默认方法如何使接口及其库能够以更少的麻烦和更少的重新编译来演化；它还解释了Java 9中添加的*模块*，这使得大型Java系统的组件比“只是一个包的JAR文件”更清晰地被指定。最后，[第1.6节](#ch01lev1sec6)展望了Java和其他共享JVM的语言中函数式编程的理念。总之，本章介绍了在本书其余部分逐步阐述的理念。享受这次旅程吧！
- en: 1.2\. Why is Java still changing?
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 为什么Java还在不断变化？
- en: With the 1960s came the quest for the perfect programming language. Peter Landin,
    a famous computer scientist of his day, noted in 1966 in a landmark article^([[2](#ch01fn02)])
    that there had *already* been 700 programming languages and speculated on what
    the next 700 would be like—including arguments for functional-style programming
    similar to that in Java 8.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪60年代，人们开始寻找完美的编程语言。Landin，这位时代的著名计算机科学家，在1966年的一篇里程碑式的文章中指出，已经有700种编程语言，并推测了接下来的700种编程语言会是什么样子——包括类似于Java
    8中的函数式编程的论点。
- en: ²
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: P. J. Landin, “The Next 700 Programming Languages,” CACM 9(3):157–65, March
    1966.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: P. J. Landin, “The Next 700 Programming Languages,” CACM 9(3):157–65, March
    1966.
- en: 'Many thousands of programming languages later, academics have concluded that
    programming languages behave like ecosystems: new languages appear, and old languages
    are supplanted unless they evolve. We all hope for a perfect universal language,
    but in reality certain languages are better fitted for certain niches. For example,
    C and C++ remain popular for building operating systems and various other embedded
    systems because of their small runtime footprint and in spite of their lack of
    programming safety. This lack of safety can lead to programs crashing unpredictably
    and exposing security holes for viruses and the like; indeed, type-safe languages
    such as Java and C# have supplanted C and C++ in various applications when the
    additional runtime footprint is acceptable.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在数以千计的编程语言之后，学者们得出结论，编程语言的行为类似于生态系统：新的语言出现，而旧的语言除非它们进化，否则将被取代。我们都希望有一个完美的通用语言，但现实中某些语言更适合某些领域。例如，C和C++由于其小巧的运行时占用和尽管缺乏编程安全性而仍然受到欢迎，用于构建操作系统和各种其他嵌入式系统。这种缺乏安全性可能导致程序不可预测地崩溃，并暴露出病毒等的安全漏洞；确实，当额外的运行时占用可以接受时，类型安全的语言如Java和C#已经取代了C和C++在各个应用中的地位。
- en: Prior occupancy of a niche tends to discourage competitors. Changing to a new
    language and tool chain is often too painful for just a single feature, but newcomers
    will eventually displace existing languages, unless they evolve fast enough to
    keep up. (Older readers are often able to quote a range of such languages in which
    they’ve previously coded but whose popularity has since waned—Ada, Algol, COBOL,
    Pascal, Delphi, and SNOBOL, to name but a few.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 早期占据一个领域往往会使竞争对手望而却步。仅仅为了一个新特性而改变语言和工具链通常是痛苦的，但新来者最终会取代现有语言，除非它们足够快地进化以跟上。 （较老的读者通常能够引用他们之前编写过但后来流行度下降的一系列语言——Ada、Algol、COBOL、Pascal、Delphi和SNOBOL，仅举几个例子。）
- en: You’re a Java programmer, and Java has been successful at colonizing (and displacing
    competitor languages in) a large ecosystem niche of programming tasks for nearly
    20 years. Let’s examine some reasons for that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一名Java程序员，Java在占领（并取代竞争语言）编程任务的大生态系统领域方面取得了成功，近20年来一直如此。让我们来探讨一下其中的原因。
- en: 1.2.1\. Java’s place in the programming language ecosystem
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. Java在编程语言生态系统中的位置
- en: Java started well. Right from the start, it was a well-designed object-oriented
    language with many useful libraries. It also supported small-scale concurrency
    from day one with its integrated support for threads and locks (and with its early
    prescient acknowledgment, in the form of a hardware-neutral memory model, that
    concurrent threads on multicore processors can have unexpected behaviors in addition
    to those that happen on single-core processors). Also, the decision to compile
    Java to JVM bytecode (a virtual machine code that soon every browser supported)
    meant that it became the language of choice for internet applet programs (do you
    remember applets?). Indeed, there’s a danger that the Java Virtual Machine (JVM)
    and its bytecode will be seen as more important than the Java language itself
    and that, for certain applications, Java might be replaced by one of its competing
    languages such as Scala, Groovy, or Kotlin, which also run on the JVM. Various
    recent updates to the JVM (for example, the new `invokedynamic` bytecode in JDK7)
    aim to help such competitor languages run smoothly on the JVM—and to interoperate
    with Java. Java has also been successful at colonizing various aspects of embedded
    computing (everything from smart cards, toasters, and set-top boxes to car-braking
    systems).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Java起步良好。从一开始，它就是一个设计精良的面向对象语言，拥有许多有用的库。它还从第一天起就支持小规模并发，这得益于其对线程和锁的集成支持（以及其早期对多核处理器上并发线程可能表现出意外行为的硬件中立内存模型的先见之明）。此外，将Java编译成JVM字节码（一种很快就被所有浏览器支持的虚拟机代码）意味着它成为了网络小程序（你还记得小程序吗？）的首选语言。确实，存在一种危险，即Java虚拟机（JVM）及其字节码将被视为比Java语言本身更重要，并且对于某些应用程序，Java可能会被其竞争对手之一（如Scala、Groovy或Kotlin）所取代，这些语言也运行在JVM上。JVM的各种最近更新（例如，JDK7中的新`invokedynamic`字节码）旨在帮助这些竞争语言在JVM上顺利运行，并且与Java进行互操作。Java还在占领嵌入式计算的各种方面（从智能卡、烤面包机、机顶盒到汽车制动系统）方面取得了成功。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How did Java get into a general programming niche?**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java是如何进入通用编程领域的？**'
- en: 'Object orientation became fashionable in the 1990s for two reasons: its encapsulation
    discipline resulted in fewer software engineering issues than those of C; and
    as a mental model it easily captured the WIMP programming model of Windows 95
    and up. This can be summarized as follows: everything is an object; and a mouse
    click sends an event message to a handler (invokes the `clicked` method in a `Mouse`
    object). The write-once, run-anywhere model of Java and the ability of early browsers
    to (safely) execute Java code applets gave it a niche in universities, whose graduates
    then populated industry. There was initial resistance to the additional run cost
    of Java over C/C++, but machines got faster, and programmer time became more and
    more important. Microsoft’s C# further validated the Java-style object-oriented
    model.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，面向对象编程因其封装纪律而变得流行，它比C语言产生的软件工程问题要少；并且作为一种心智模型，它很容易捕捉到Windows 95及以后的WIMP编程模型。这可以总结如下：一切都是对象；鼠标点击向处理器发送事件消息（在`Mouse`对象中调用`clicked`方法）。Java的“一次编写，到处运行”模型以及早期浏览器的（安全地）执行Java代码小程序的能力，使它在大学中占有一席之地，而这些大学的毕业生后来填充了工业界。最初对Java相对于C/C++的额外运行成本存在抵制，但随着机器速度的提高，程序员的时间变得越来越重要。微软的C#进一步验证了Java风格的面向对象模型。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'But the climate is changing for the programming language ecosystem; programmers
    are increasingly dealing with so-called *big data* (data sets of terabytes and
    up) and wishing to exploit multicore computers or computing clusters effectively
    to process it. And this means using parallel processing—something Java wasn’t
    previously friendly to. You may have come across ideas from other programming
    niches (for example, Google’s map-reduce or the relative ease of data manipulation
    using database query languages such as SQL) that help you work with large volumes
    of data and multicore CPUs. [Figure 1.1](#ch01fig01) summarizes the language ecosystem
    pictorially: think of the landscape as the space of programming problems and the
    dominant vegetation for a particular bit of ground as the favorite language for
    that program. Climate change is the idea that new hardware or new programming
    influences (for example, “Why can’t I program in an SQL-like style?”) mean that
    different languages become the language of choice for new projects, just like
    increasing regional temperatures mean grapes now thrive in higher latitudes. But
    there’s hysteresis—many an old farmer will keep raising traditional crops. In
    summary, new languages are appearing and becoming increasingly popular because
    they’ve adapted quickly to the climate change.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但编程语言生态系统的气候正在变化；程序员越来越多地处理所谓的*大数据*（数据集达到数太字节及以上）并希望有效地利用多核计算机或计算集群来处理它们。这意味着使用并行处理——这是Java之前并不友好的。你可能已经接触过来自其他编程领域的想法（例如，谷歌的map-reduce或使用SQL等数据库查询语言进行数据操作的相对容易性），这些想法有助于你处理大量数据和多核CPU。图1.1([Figure
    1.1](#ch01fig01))以图示方式总结了语言生态系统：将景观视为编程问题的空间，将特定地面的主要植被视为该程序的首选语言。气候变化是指新的硬件或新的编程影响（例如，“为什么我不能用类似SQL的风格编程？”）意味着不同的语言成为新项目的首选语言，就像气温升高意味着葡萄现在在更高的纬度地区生长一样。但存在滞后性——许多老农民会继续种植传统作物。总之，新语言正在出现并变得越来越受欢迎，因为它们迅速适应了气候变化。
- en: Figure 1.1\. Programming-language ecosystem and climate change
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1\. 编程语言生态系统与气候变化
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](Images/01fig01_alt.jpg)'
- en: The main benefit of the Java 8 additions for a programmer is that they provide
    more programming tools and concepts to solve new or existing programming problems
    more quickly or, more importantly, in a more concise, more easily maintainable
    way. Although the concepts are new to Java, they’ve proved powerful in niche research-like
    languages. In the following sections, we’ll highlight and develop the ideas behind
    three such programming concepts that have driven the development of the Java 8
    features to exploit parallelism and write more concise code in general. We’ll
    introduce them in a slightly different order from the rest of the book to enable
    a Unix-based analogy and to expose the “need *this* because of *that*” dependencies
    in Java 8’s new parallelism for multicore.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，Java 8 增加的主要好处是它们提供了更多的编程工具和概念，以更快地解决新的或现有的编程问题，或者更重要的是，以更简洁、更易于维护的方式。尽管这些概念对
    Java 来说是新的，但它们在类似的研究型语言中已被证明是强大的。在接下来的几节中，我们将突出和阐述三个推动 Java 8 功能开发以利用并行性和编写更简洁代码的编程概念背后的思想。我们将以与其他章节略有不同的顺序介绍它们，以便进行基于
    Unix 的类比，并揭示 Java 8 新并行性中“需要*这个*因为*那个*”的依赖关系。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Another climate-change factor for Java**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 的另一个气候变化因素**'
- en: One climate-change factor involves how large systems are designed. Nowadays,
    it’s common for a large system to incorporate large component subsystems from
    elsewhere, and perhaps these are built on top of other components from other vendors.
    Worse still, these components and their interfaces also tend to evolve. Java 8
    and Java 9 have addressed these aspects by providing default methods and modules
    to facilitate this design style.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个气候变化因素涉及如何设计大型系统。如今，一个大型系统通常包含来自其他地方的大型组件子系统，也许这些组件是基于其他供应商的组件构建的。更糟糕的是，这些组件及其接口也倾向于演变。Java
    8 和 Java 9 通过提供默认方法和模块来解决这个问题，以促进这种设计风格。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next three sections examine the three programming concepts that drove the
    design of Java 8.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下三个部分将探讨推动 Java 8 设计的三个编程概念。
- en: 1.2.2\. Stream processing
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 流处理
- en: The first programming concept is *stream processing*. For introductory purposes,
    a *stream* is a sequence of data items that are conceptually produced one at a
    time. A program might read items from an input stream one by one and similarly
    write items to an output stream. The output stream of one program could well be
    the input stream of another.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个编程概念是*流处理*。为了介绍的目的，一个*流*是一系列数据项的序列，这些数据项在概念上一次产生一个。一个程序可能一次从输入流中读取一个项目，并类似地写入输出流。一个程序输出流可能正好是另一个程序的输入流。
- en: 'One practical example is in Unix or Linux, where many programs operate by reading
    data from standard input (*stdin* in Unix and C, `System.in` in Java), operating
    on it, and then writing their results to standard output (*stdout* in Unix and
    C, `System.out` in Java). First, a little background: Unix `cat` creates a stream
    by concatenating two files, `tr` translates the characters in a stream, `sort`
    sorts lines in a stream, and `tail -3` gives the last three lines in a stream.
    The Unix command line allows such programs to be linked together with pipes (`|`),
    giving examples such as'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的例子是在 Unix 或 Linux 中，许多程序通过从标准输入（Unix 和 C 中的 *stdin*，Java 中的 `System.in`）读取数据，对其进行操作，然后将结果写入标准输出（Unix
    和 C 中的 *stdout*，Java 中的 `System.out`）来运行。首先，有一点背景：Unix 的 `cat` 命令通过连接两个文件创建一个流，`tr`
    将流中的字符进行转换，`sort` 对流中的行进行排序，而 `tail -3` 则给出流中的最后三行。Unix 命令行允许这些程序通过管道（`|`）链接在一起，例如
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: which (supposing `file1` and `file2` contain a single word per line) prints
    the three words from the files that appear latest in dictionary order, after first
    translating them to lowercase. We say that `sort` takes a *stream* of lines^([[3](#ch01fn03)])
    as input and produces another stream of lines as output (the latter being sorted),
    as illustrated in [figure 1.2](#ch01fig02). Note that in Unix these commands (`cat`,
    `tr`, `sort`, and `tail`) are executed concurrently, so that `sort` can be processing
    the first few lines before `cat` or `tr` has finished. A more mechanical analogy
    is a car-manufacturing assembly line where a stream of cars is queued between
    processing stations that each take a car, modify it, and pass it on to the next
    station for further processing; processing at separate stations is typically concurrent
    even though the assembly line is physically a sequence.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`which`（假设`file1`和`file2`每行包含一个单词）打印出字典顺序中最后出现的三个单词，在将它们转换为小写之前。我们说`sort`以*流*形式的行作为输入，并产生另一个流形式的行作为输出（后者是排序后的），如图
    1.2 所示（[图 1.2](#ch01fig02)）。请注意，在 Unix 中，这些命令（`cat`、`tr`、`sort`和`tail`）是并发执行的，这样`sort`就可以在`cat`或`tr`完成之前处理前几行。一个更机械的类比是一个汽车制造装配线，其中一串汽车在各个处理站之间排队，每个站都取一辆车，对其进行修改，并将其传递到下一个站进行进一步处理；尽管装配线在物理上是序列，但各个站点的处理通常是并发的。'
- en: ³
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Purists will say a “stream of characters,” but it’s conceptually simpler to
    think that `sort` reorders *lines*.
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 纯粹主义者会说“字符流”，但概念上更简单的是认为`sort`重新排序了*行*。
- en: Figure 1.2\. Unix commands operating on streams
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2\. Unix 命令在流上操作
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.2](Images/01fig02_alt.jpg)'
- en: Java 8 adds a Streams API (note the uppercase *S*) in `java.util.stream` based
    on this idea; `Stream<T>` is a sequence of items of type `T`. You can think of
    it as a fancy iterator for now. The Streams API has many methods that can be chained
    to form a complex pipeline just like Unix commands were chained in the previous
    example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 在`java.util.stream`中基于这个想法添加了一个 Streams API（注意大写的 *S*）；`Stream<T>`是类型为
    `T` 的项的序列。你现在可以将其视为一个花哨的迭代器。Streams API 有许多方法可以链接起来形成一个复杂的管道，就像在先前的例子中 Unix 命令被链接起来一样。
- en: The key motivation for this is that you can now program in Java 8 at a higher
    level of abstraction, structuring your thoughts of turning a stream of this into
    a stream of that (similar to how you think when writing database queries) rather
    than one item at a time. Another advantage is that Java 8 can transparently run
    your pipeline of `Stream` operations on several CPU cores on disjoint parts of
    the input—this is parallelism *almost for free* instead of hard work using `Thread`s.
    We cover the Java 8 Streams API in detail in [chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键动机在于，你现在可以用 Java 8 在更高的抽象级别上进行编程，将这种流转换为那种流的思考方式（类似于你编写数据库查询时的思考方式），而不是逐个处理。另一个优点是
    Java 8 可以透明地在输入的不同部分上并行运行你的`Stream`操作管道——这是几乎不费力的并行性，而不是使用`Thread`的艰苦工作。我们将在第
    4 章（[kindle_split_015.xhtml#ch04]）到第 7 章（[kindle_split_018.xhtml#ch07]）中详细介绍 Java
    8 Streams API。
- en: 1.2.3\. Passing code to methods with behavior parameterization
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 将代码传递给具有行为参数化的方法
- en: The second programming concept added to Java 8 is the ability to pass a piece
    of code to an API. This sounds awfully abstract. In the Unix example, you might
    want to tell the `sort` command to use a custom ordering. Although the `sort`
    command supports command-line parameters to perform various predefined kinds of
    sorting such as reverse order, these are limited.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 添加的第二个编程概念是能够将一段代码传递给一个 API。这听起来非常抽象。在 Unix 的例子中，你可能想告诉`sort`命令使用自定义排序。尽管`sort`命令支持命令行参数来执行各种预定义的排序类型，如逆序排序，但这些是有限的。
- en: 'For example, let’s say you have a collection of invoice IDs with a format similar
    to 2013UK0001, 2014US0002, and so on. The first four digits represent the year,
    the next two letters a country code, and last four digits the ID of a client.
    You may want to sort these invoice IDs by year or perhaps using the customer ID
    or even the country code. What you want is the ability to tell the `sort` command
    to take as an argument an ordering defined by the user: a separate piece of code
    passed to the `sort` command.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一组发票 ID，其格式类似于 2013UK0001、2014US0002 等。前四位数字代表年份，接下来的两个字母代表国家代码，最后四位数字代表客户的
    ID。你可能想按年份或客户 ID 或甚至国家代码对这些发票 ID 进行排序。你想要的是告诉`sort`命令接受一个用户定义的排序作为参数：传递给`sort`命令的一段单独的代码。
- en: Now, as a direct parallel in Java, you want to tell a `sort` method to compare
    using a customized order. You could write a method `compareUsingCustomerId` to
    compare two invoice IDs, but, prior to Java 8, you couldn’t pass this method to
    another method! You could create a `Comparator` object to pass to the `sort` method
    as we showed at the start of this chapter, but this is verbose and obfuscates
    the idea of simply reusing an existing piece of behavior. Java 8 adds the ability
    to pass methods (your code) as arguments to other methods. [Figure 1.3](#ch01fig03),
    based on [figure 1.2](#ch01fig02), illustrates this idea. We also refer to this
    conceptually as *behavior parameterization*. Why is this important? The Streams
    API is built on the idea of passing code to parameterize the behavior of its operations,
    just as you passed `compareUsingCustomerId` to parameterize the behavior of `sort`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一个直接的Java并行，你想要告诉`sort`方法使用自定义的顺序进行比较。你可以编写一个`compareUsingCustomerId`方法来比较两个发票ID，但在Java
    8之前，你不能将这个方法传递给另一个方法！你可以创建一个`Comparator`对象，就像我们在本章开头所展示的那样，将其传递给`sort`方法，但这很冗长，并且模糊了简单重用现有行为的概念。Java
    8增加了将方法（你的代码）作为参数传递给其他方法的能力。[图1.3](#ch01fig03)，基于[图1.2](#ch01fig02)，说明了这个概念。我们也将这个概念称为*行为参数化*。为什么这很重要？Streams
    API建立在传递代码来参数化其操作行为的基础上，就像你传递`compareUsingCustomerId`来参数化`sort`的行为一样。
- en: Figure 1.3\. Passing method `compareUsingCustomerId` as an argument to `sort`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 将方法`compareUsingCustomerId`作为参数传递给`sort`
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig03_alt.jpg)'
- en: We summarize how this works in [section 1.3](#ch01lev1sec3) of this chapter,
    but leave full details to [chapters 2](kindle_split_012.xhtml#ch02) and [3](kindle_split_013.xhtml#ch03).
    [Chapters 18](kindle_split_033.xhtml#ch18) and [19](kindle_split_034.xhtml#ch19)
    look at more advanced things you can do using this feature, with techniques from
    the *functional programming* community.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的[第1.3节](#ch01lev1sec3)中总结了这是如何工作的，但将全部细节留给[第2章](kindle_split_012.xhtml#ch02)和[第3章](kindle_split_013.xhtml#ch03)。[第18章](kindle_split_033.xhtml#ch18)和[第19章](kindle_split_034.xhtml#ch19)将探讨使用此功能可以执行的一些更高级的操作，以及来自*函数式编程*社区的技术。
- en: 1.2.4\. Parallelism and shared mutable data
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4\. 并行性和共享可变数据
- en: The third programming concept is rather more implicit and arises from the phrase
    “parallelism almost for free” in our previous discussion on stream processing.
    What do you have to give up? You may have to make some small changes in the way
    you code the behavior passed to stream methods. At first, these changes might
    feel a little uncomfortable, but once you get used to them, you’ll love them.
    You must provide behavior that *is safe to execute* concurrently on different
    pieces of the input. Typically this means writing code that doesn’t access shared
    mutable data to do its job. Sometimes these are referred to as pure functions
    or side-effect-free functions or stateless functions, and we’ll discuss these
    in detail in [chapters 18](kindle_split_033.xhtml#ch18) and [19](kindle_split_034.xhtml#ch19).
    The previous parallelism arises only by assuming that multiple copies of your
    piece of code can work independently. If there’s a shared variable or object,
    which is written to, then things no longer work. What if two processes want to
    modify the shared variable at the same time? ([Section 1.4](#ch01lev1sec4) gives
    a more detailed explanation with a diagram.) You’ll find more about this style
    throughout the book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个编程概念更为隐晦，它源于我们之前在流处理讨论中提到的“几乎免费的并行性”。你需要放弃什么？你可能需要在编写传递给流方法的行为的方式上做一些小的改变。一开始，这些改变可能会让你感到有些不舒服，但一旦习惯了，你会喜欢它们的。你必须提供在输入的不同部分上安全并发执行的行为。通常这意味着编写不访问共享可变数据来完成其工作的代码。有时这些被称为纯函数或无副作用函数或无状态函数，我们将在第[18章](kindle_split_033.xhtml#ch18)和第[19章](kindle_split_034.xhtml#ch19)中详细讨论这些。之前的并行性仅通过假设你的代码的多个副本可以独立工作而产生。如果有一个被写入的共享变量或对象，那么事情就不再有效了。如果两个进程同时想要修改共享变量怎么办？([第1.4节](#ch01lev1sec4)提供了一个带有图表的更详细解释。)你将在整本书中找到更多关于这种风格的内容。
- en: Java 8 streams exploit parallelism more easily than Java’s existing Threads
    API, so although it’s *possible* to use `synchronized` to break the no-shared-mutable-data
    rule, it’s fighting the system in that it’s abusing an abstraction optimized around
    that rule. Using `synchronized` across multiple processing cores is often far
    more expensive than you expect, because synchronization forces code to execute
    sequentially, which works against the goal of parallelism.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8流比Java现有的线程API更容易利用并行性，所以尽管使用`synchronized`来打破没有共享可变数据规则是可能的，但它是在与系统作对，因为它是在围绕该规则优化的抽象中滥用。在多个处理核心上使用`synchronized`通常比你预期的要昂贵得多，因为同步迫使代码按顺序执行，这与并行化的目标相悖。
- en: Two of these points (no shared mutable data and the ability to pass methods
    and functions—code—to other methods) are the cornerstones of what’s generally
    described as the paradigm of *functional programming*, which you’ll see in detail
    in [chapters 18](kindle_split_033.xhtml#ch18) and [19](kindle_split_034.xhtml#ch19).
    In contrast, in the *imperative programming* paradigm you typically describe a
    program in terms of a sequence of statements that mutate state. The no-shared-mutable-data
    requirement means that a method is perfectly described solely by the way it transforms
    arguments to results; in other words, it behaves as a mathematical function and
    has no (visible) side effects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两点（没有共享可变数据和能够传递方法及函数—代码—到其他方法的能力）是通常所说的*函数式编程*范式的基石，你将在第[18章](kindle_split_033.xhtml#ch18)和第[19章](kindle_split_034.xhtml#ch19)中详细了解。相比之下，在*命令式编程*范式中，你通常用一系列改变状态的语句来描述程序。没有共享可变数据的要求意味着一个方法完全可以通过它如何将参数转换为结果来描述；换句话说，它表现得像一个数学函数，并且没有（可见的）副作用。
- en: 1.2.5\. Java needs to evolve
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.5\. Java 需要进化
- en: You’ve seen evolution in Java before. For example, the introduction of generics
    and using `List<String>` instead of just `List` may initially have been irritating.
    But you’re now familiar with this style and the benefits it brings (catching more
    errors at compile time and making code easier to read, because you now know what
    something is a list of).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前已经看到了Java的进化。例如，泛型的引入和使用`List<String>`而不是仅仅`List`可能最初令人烦恼。但现在你已经熟悉了这种风格及其带来的好处（在编译时捕获更多错误，并使代码更容易阅读，因为你现在知道某个东西是一个列表）。
- en: Other changes have made common things easier to express (for example, using
    a `for-each` loop instead of exposing the boilerplate use of an `Iterator)`. The
    main changes in Java 8 reflect a move away from classical object orientation,
    which often focuses on mutating existing values, and toward the functional-style
    programming spectrum in which *what* you want to do in broad-brush terms (for
    example, *create a value* representing all transport routes from A to B for less
    than a given price) is considered prime and separated from *how* you can achieve
    this (for example, *scan* a data structure *modifying* certain components). Note
    that classical object-oriented programming and functional programming, as extremes,
    might appear to be in conflict. But the idea is to get the best from both programming
    paradigms, so you have a better chance of having the right tool for the job. We
    discuss this in detail in [sections 1.3](#ch01lev1sec3) and [1.4](#ch01lev1sec4).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其他变化使得常见的事情更容易表达（例如，使用`for-each`循环而不是暴露`Iterator`的样板代码使用）。Java 8的主要变化反映了一种从关注于改变现有值的经典面向对象，转向功能式编程谱系，其中*你想要做什么*（例如，*创建一个表示从A到B的所有运输路线且价格低于给定价格的值*）被视为首要的，并且与*你如何实现它*（例如，*扫描*一个数据结构*修改*某些组件）分离。请注意，经典面向对象编程和函数式编程作为极端，可能会显得相互冲突。但理念是从两种编程范式中获得最佳之处，这样你就有更大的机会拥有适合工作的正确工具。我们将在[1.3节](#ch01lev1sec3)和[1.4节](#ch01lev1sec4)中详细讨论这一点。
- en: 'A takeaway line might be this: languages need to evolve to track changing hardware
    or programmer expectations (if you need convincing, consider that COBOL was once
    one of the most important languages commercially). To endure, Java has to evolve
    by adding new features. This evolution will be pointless unless the new features
    are used, so in using Java 8 you’re protecting your way of life as a Java programmer.
    On top of that, we have a feeling you’ll love using Java 8’s new features. Ask
    anyone who’s used Java 8 whether they’re willing to go back! Additionally, the
    new Java 8 features might, in the ecosystem analogy, enable Java to conquer programming-task
    territory currently occupied by other languages, so Java 8 programmers will be
    even more in demand.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以吸取的要点可能是这样的：语言需要进化以跟踪不断变化的硬件或程序员期望（如果您需要说服，请考虑COBOL曾经是商业上最重要的语言之一）。为了生存，Java必须通过添加新功能来进化。如果没有使用新功能，这种进化将是徒劳的，因此在使用Java
    8时，您正在保护作为Java程序员的生活方式。除此之外，我们有一种感觉，您会喜欢使用Java 8的新功能。问问任何使用过Java 8的人，他们是否愿意回去！此外，新的Java
    8功能可能在生态系统类比中使Java能够征服其他语言目前占据的编程任务领域，因此Java 8程序员的需求将更加旺盛。
- en: We now introduce the new concepts in Java 8, one by one, pointing out the chapters
    that cover these concepts in more detail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们逐一介绍Java 8的新概念，并指出涵盖这些概念的章节，以更详细地介绍这些概念。
- en: 1.3\. Functions in Java
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. Java中的函数
- en: The word *function* in programming languages is commonly used as a synonym for
    *method*, particularly a static method; this is in addition to it being used for
    *mathematical function*, one without side effects. Fortunately, as you’ll see,
    when Java 8 refers to functions these usages nearly coincide.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中，*函数*一词通常用作*方法*的同义词，尤其是静态方法；除此之外，它还用于*数学函数*，即没有副作用的一个。幸运的是，正如您将看到的，当Java
    8提到函数时，这些用法几乎是一致的。
- en: Java 8 adds functions as new forms of value. These facilitate the use of streams,
    covered in [section 1.4](#ch01lev1sec4), which Java 8 provides to exploit parallel
    programming on multicore processors. We start by showing that functions as values
    are useful in themselves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8将函数作为新的值形式添加。这促进了流的使用，如[第1.4节](#ch01lev1sec4)所述，Java 8提供了流来利用多核处理器上的并行编程。我们首先展示函数作为值本身是有用的。
- en: Think about the possible values manipulated by Java programs. First, there are
    primitive values such as 42 (of type `int`) and 3.14 (of type `double`). Second,
    values can be objects (more strictly, references to objects). The only way to
    get one of these is by using `new`, perhaps via a factory method or a library
    function; object references point to *instances* of a class. Examples include
    `"abc"` (of type `String`), `new Integer(1111)` (of type `Integer`), and the result
    `new HashMap<Integer, String>(100)` of explicitly calling a constructor for `HashMap`.
    Even arrays are objects. What’s the problem?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Java程序可能操作的可能值。首先，有原始值，如42（类型为`int`）和3.14（类型为`double`）。其次，值可以是对象（更严格地说，是对象的引用）。获取这些值的唯一方法是通过使用`new`，可能通过工厂方法或库函数；对象引用指向类的*实例*。例如，`"abc"`（类型为`String`），`new
    Integer(1111)`（类型为`Integer`），以及显式调用`HashMap`构造函数的结果`new HashMap<Integer, String>(100)`。甚至数组也是对象。问题是什么？
- en: To help answer this, we’ll note that the whole point of a programming language
    is to manipulate values, which, following historical programming-language tradition,
    are therefore called first-class values (or citizens, in the terminology borrowed
    from the 1960s civil rights movement in the United States). Other structures in
    our programming languages, which perhaps help us express the structure of values
    but which can’t be passed around during program execution, are second-class citizens.
    Values as listed previously are first-class Java citizens, but various other Java
    concepts, such as methods and classes, exemplify second-class citizens. Methods
    are fine when used to define classes, which in turn may be instantiated to produce
    values, but neither are values themselves. Does this matter? Yes, it turns out
    that being able to pass methods around at runtime, and hence making them first-class
    citizens, is useful in programming, so the Java 8 designers added the ability
    to express this directly in Java. Incidentally, you might wonder whether making
    other second-class citizens such as classes into first-class-citizen values might
    also be a good idea. Various languages such as Smalltalk and JavaScript have explored
    this route.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将指出，编程语言的全部目的就是操纵值，根据历史编程语言的传统，这些值因此被称为一等值（或公民，借用自20世纪60年代美国民权运动中的术语）。我们编程语言中的其他结构，可能有助于我们表达值的结构，但在程序执行期间不能传递，因此被称为二等公民。之前列出的值是一等Java公民，但各种其他Java概念，如方法和类，是二等公民的例子。当使用方法来定义类时，方法是很好的，这些类反过来可以实例化以产生值，但它们本身并不是值。这有什么关系吗？是的，结果证明，在运行时传递方法，并使它们成为一等公民，在编程中非常有用，因此Java
    8的设计者添加了在Java中直接表达这种能力。顺便说一句，你可能想知道将其他二等公民（如类）变成一等公民值是否也是一个好主意。像Smalltalk和JavaScript这样的各种语言已经探索了这条路线。
- en: 1.3.1\. Methods and lambdas as first-class citizens
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 方法和lambda作为一等公民
- en: Experiments in other languages, such as Scala and Groovy, have determined that
    allowing concepts like methods to be used as first-class values made programming
    easier by adding to the toolset available to programmers. And once programmers
    become familiar with a powerful feature, they become reluctant to use languages
    without it! The designers of Java 8 decided to allow methods to be values—to make
    it easier for you to program. Moreover, the Java 8 feature of methods as values
    forms the basis of various other Java 8 features (such as Streams).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言（如Scala和Groovy）中的实验已经确定，允许像方法这样的概念作为一等值使用，通过增加程序员可用的工具集，使得编程变得更加容易。一旦程序员熟悉了一个强大的特性，他们就不愿意使用没有这个特性的语言！Java
    8的设计者决定允许方法作为值存在——以便于你编程。此外，Java 8中将方法作为值的功能是其他各种Java 8特性（如Streams）的基础。
- en: 'The first new Java 8 feature we introduce is that of *method references*. Suppose
    you want to filter all the hidden files in a directory. You need to start writing
    a method that, given a `File`, will tell you whether it’s hidden. Fortunately,
    there’s such a method in the `File` class called `isHidden`. It can be viewed
    as a function that takes a `File` and returns a `boolean`. But to use it for filtering,
    you need to wrap it into a `FileFilter` object that you then pass to the `File.listFiles`
    method, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍的新Java 8特性是*方法引用*。假设你想要过滤目录中的所有隐藏文件。你需要编写一个方法，给定一个`File`对象，它会告诉你该文件是否隐藏。幸运的是，`File`类中有一个名为`isHidden`的方法可以实现这个功能。它可以看作是一个接受`File`对象并返回`boolean`值的函数。但为了用于过滤，你需要将其包装成一个`FileFilter`对象，然后将该对象传递给`File.listFiles`方法，如下所示：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Filtering hidden files!**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 过滤隐藏文件！**'
- en: Yuck! That’s horrible. Although it’s only three significant lines, it’s three
    opaque lines—we all remember saying “Do I really have to do it this way?” on first
    encounter. You already have the method `isHidden` that you could use. Why do you
    have to wrap it up in a verbose `FileFilter` class and then instantiate it? Because
    that’s what you had to do prior to Java 8.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这太糟糕了。尽管这只有三行重要的代码，但它却是三行晦涩难懂的代码——我们都会记得第一次遇到时会说“我真的必须这样做吗？”你已经有了可以使用的`isHidden`方法。为什么你还要把它封装在一个冗长的`FileFilter`类中，然后实例化它呢？因为在Java
    8之前你必须这样做。
- en: 'Now, you can rewrite that code as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将那段代码重写如下：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Wow! Isn’t that cool? You already have the function `isHidden` available, so
    you pass it to the `listFiles` method using the Java 8 *method reference* :: syntax
    (meaning “use this method as a value”); note that we’ve also slipped into using
    the word *function* for methods. We’ll explain later how the mechanics work. One
    advantage is that your code now reads closer to the problem statement.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '哇！这不是很酷吗？你已经有`isHidden`函数可用，所以你可以使用Java 8的*方法引用* :: 语法（意味着“使用这个方法作为值”）将其传递给`listFiles`方法；注意我们也在使用“函数”这个词来指代方法。我们稍后会解释其工作机制。一个优点是，你的代码现在读起来更接近问题陈述。'
- en: 'Here’s a taste of what’s coming: methods are no longer second-class values.
    Analogous to using an *object reference* when you pass an object around (and object
    references are created by `new`), in Java 8 when you write `File::isHidden,` you
    create a *method reference*, which can similarly be passed around. This concept
    is discussed in detail in [chapter 3](kindle_split_013.xhtml#ch03). Given that
    methods contain code (the executable body of a method), using method references
    enables passing code around as in [figure 1.3](#ch01fig03). [Figure 1.4](#ch01fig04)
    illustrates the concept. You’ll also see a concrete example (selecting apples
    from an inventory) in the next section.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角：方法不再是二等公民。类似于传递对象时使用对象引用（对象引用是通过`new`创建的），在Java 8中，当你写下`File::isHidden`时，你创建了一个方法引用，它可以像对象引用一样被传递。这一概念在[第3章](kindle_split_013.xhtml#ch03)中有详细讨论。鉴于方法包含代码（方法的可执行体），使用方法引用使得代码可以被传递，就像[图1.3](#ch01fig03)中所示。[图1.4](#ch01fig04)展示了这一概念。你还会在下一节看到一个具体示例（从库存中选择苹果）。
- en: Figure 1.4\. Passing the method reference `File::isHidden` to the method `listFiles`
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4：将方法引用`File::isHidden`传递给`listFiles`方法
- en: '![](Images/01fig04_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig04_alt.jpg)'
- en: 'Lambdas: anonymous functions'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Lambda：匿名函数
- en: As well as allowing (named) methods to be first-class values, Java 8 allows
    a richer idea of *functions as values,* including *lambdas*^([[4](#ch01fn04)])
    (or anonymous functions). For example, you can now write `(int x) -> x + 1` to
    mean “the function that, when called with argument x, returns the value x + 1.”
    You might wonder why this is necessary, because you could define a method `add1`
    inside a class `MyMathsUtils` and then write `MyMaths-Utils::add1`! Yes, you could,
    but the new lambda syntax is more concise for cases where you don’t have a convenient
    method and class available. [Chapter 3](kindle_split_013.xhtml#ch03) explores
    lambdas in detail. Programs using these concepts are said to be written in functional-programming
    style; this phrase means “writing programs that pass functions around as first-class
    values.”
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许（命名）方法成为一等公民外，Java 8还允许更丰富的*函数作为值*的概念，包括*lambda*^([[4](#ch01fn04)])（或匿名函数）。例如，你现在可以写`(int
    x) -> x + 1`来表示“当用参数x调用时，返回值x + 1的函数。”你可能想知道为什么这有必要，因为你可以在`MyMathsUtils`类内部定义一个名为`add1`的方法，然后写`MyMaths-Utils::add1`！是的，你可以这样做，但新的lambda语法在没有方便的方法和类可用的情况下更为简洁。[第3章](kindle_split_013.xhtml#ch03)详细探讨了lambda。使用这些概念的程序被称为函数式编程风格的程序；这个短语意味着“编写将函数作为一等值传递的程序。”
- en: ⁴
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Originally named after the Greek letter λ (lambda). Although the symbol isn’t
    used in Java, its name lives on.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最初以希腊字母λ（lambda）命名。虽然这个符号在Java中未使用，但其名称仍然存在。
- en: '1.3.2\. Passing code: an example'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2. 传递代码：一个示例
- en: 'Let’s look at an example of how this helps you write programs (discussed in
    more detail in [chapter 2](kindle_split_012.xhtml#ch02)). All the code for the
    examples is available on a GitHub repository and as a download via the book’s
    website. Both links may be found at [www.manning.com/books/modern-java-in-action](http://www.manning.com/books/modern-java-in-action).
    Suppose you have a class `Apple` with a method `getColor` and a variable `inventory`
    holding a list of `Apples`; then you might wish to select all the green apples
    (here using a `Color` enum type that includes values `GREEN` and `RED`) and return
    them in a list. The word *filter* is commonly used to express this concept. Before
    Java 8, you might write a method `filterGreenApples`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个如何帮助你编写程序（在[第2章](kindle_split_012.xhtml#ch02)中有更详细的讨论）。所有示例代码都可在GitHub仓库和书籍网站上找到，两个链接都可以在[www.manning.com/books/modern-java-in-action](http://www.manning.com/books/modern-java-in-action)找到。假设你有一个名为`Apple`的类，它有一个`getColor`方法和一个包含`Apples`列表的变量`inventory`；那么你可能希望选择所有绿色的苹果（这里使用包含值`GREEN`和`RED`的`Color`枚举类型），并将它们作为一个列表返回。*filter*这个词通常用来表达这个概念。在Java
    8之前，你可能写一个名为`filterGreenApples`的方法：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* The result list accumulates the result; it starts as empty, and then
    green apples are added one by one.**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 结果列表累积结果；它最初是空的，然后逐个添加绿色苹果。**'
- en: '***2* The highlighted text selects only green apples.**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 高亮显示的文本只选择绿色苹果。**'
- en: 'But next, somebody would like the list of heavy apples (say over 150 g), and
    so, with a heavy heart, you’d write the following method to achieve this (perhaps
    even using copy and paste):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来，有人可能想要重苹果的列表（比如超过 150 克），因此，带着沉重的心情，你会编写以下方法来实现这一点（可能甚至使用复制粘贴）：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Here the highlighted text selects only heavy apples.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里高亮显示的文本只选择重苹果。**'
- en: 'We all know the dangers of copy and paste for software engineering (updates
    and bug fixes to one variant but not the other), and hey, these two methods vary
    only in one line: the highlighted condition inside the `if` construct. If the
    difference between the two method calls in the highlighted code had been what
    weight range was acceptable, then you could have passed lower and upper acceptable
    weights as arguments to `filter`—perhaps (`150, 1000`) to select heavy apples
    (over 150 g) or (`0, 80`) to select light apples (under 80 g).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道复制粘贴对软件工程的危险（对一个变体的更新和错误修复，但没有对另一个变体进行），嘿，这两个方法只在一条线上有所不同：高亮显示的 `if` 结构内的条件。如果高亮代码中两个方法调用之间的差异是可接受的重量范围，那么你可以将可接受的上下限重量作为参数传递给
    `filter`——比如 (`150, 1000`) 来选择重苹果（超过 150 克）或 (`0, 80`) 来选择轻苹果（低于 80 克）。
- en: 'But as we mentioned previously, Java 8 makes it possible to pass the code of
    the condition as an argument, avoiding code duplication of the `filter` method.
    You can now write this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们之前提到的，Java 8 使得将条件代码作为参数传递成为可能，避免了 `filter` 方法的代码重复。现在你可以这样写：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Included for clarity (normally imported from java.util.function)**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为了清晰起见（通常从 java.util.function 导入）**'
- en: '***2* A method is passed as a Predicate parameter named p (see the sidebar
    “[What’s a Predicate?](#ch01sb03)”).**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 方法作为名为 p 的谓词参数传递（参见侧边栏“[什么是谓词？](#ch01sb03)”）。**'
- en: '***3* Does the apple match the condition represented by p?**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 苹果是否匹配由 p 表示的条件？**'
- en: And to use this, you call either
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个，你可以调用以下任何一个：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: or
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We explain how this works in detail in the next two chapters. The key idea to
    take away for now is that you can pass around a method in Java 8.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的两个章节中详细解释它是如何工作的。现在要记住的关键思想是，你可以在 Java 8 中传递一个方法。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What’s a Predicate?**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是谓词？**'
- en: The previous code passed a method `Apple::isGreenApple` (which takes an `Apple`
    for argument and returns a `boolean`) to `filterApples`, which expected a `Predicate
    <Apple>` parameter. The word *predicate* is often used in mathematics to mean
    something function-like that takes a value for an argument and returns `true`
    or `false`. As you’ll see later, Java 8 would also allow you to write `Function<Apple,
    Boolean>`—more familiar to readers who learned about functions but not predicates
    at school—but using `Predicate<Apple>` is more standard (and slightly more efficient
    because it avoids boxing a `boolean` into a `Boolean`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码传递了一个方法 `Apple::isGreenApple`（它接受一个 `Apple` 参数并返回一个布尔值）到 `filterApples`，该方法期望一个
    `Predicate <Apple>` 参数。在数学中，*谓词*一词常用来表示一种类似于函数的东西，它接受一个参数的值并返回 `true` 或 `false`。正如你稍后将会看到的，Java
    8 也允许你编写 `Function<Apple, Boolean>`——对于在学校学习过函数但没有学习过谓词的读者来说可能更熟悉——但使用 `Predicate<Apple>`
    更为标准（并且稍微高效一些，因为它避免了将 `boolean` 包装成 `Boolean`）。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.3.3\. From passing methods to lambdas
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 从传递方法到lambda表达式
- en: Passing methods as values is clearly useful, but it’s annoying having to write
    a definition for short methods such as `isHeavyApple` and `isGreenApple` when
    they’re used perhaps only once or twice. But Java 8 has solved this, too. It introduces
    a new notation (anonymous functions, or lambdas) that enables you to write just
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法作为值传递显然很有用，但当你可能只使用一次或两次时，不得不为短方法（如 `isHeavyApple` 和 `isGreenApple`）编写定义确实很烦人。但
    Java 8 也解决了这个问题。它引入了一种新的表示法（匿名函数，或lambda表达式），它允许你只写
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: or
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: or even
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: or
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You don’t even need to write a method definition that’s used only once; the
    code is crisper and clearer because you don’t need to search to find the code
    you’re passing. But if such a lambda exceeds a few lines in length (so that its
    behavior isn’t instantly clear), you should instead use a method reference to
    a method with a descriptive name instead of using an anonymous lambda. Code clarity
    should be your guide.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要编写只使用一次的方法定义；代码更加清晰，因为你不需要搜索来找到你传递的代码。但是，如果这样的 lambda 表达式长度超过几行（以至于其行为不是立即清晰的），则应改用具有描述性名称的方法引用，而不是使用匿名
    lambda。代码的清晰度应该是你的指南。
- en: The Java 8 designers could almost have stopped here, and perhaps they would
    have done so before multicore CPUs. Functional-style programming as presented
    so far turns out to be powerful, as you’ll see. Java might then have been rounded
    off by adding `filter` and a few friends as generic library methods, such as
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的设计者几乎可以在这里停下来，也许在多核 CPU 之前他们会这样做。到目前为止所展示的函数式编程证明是强大的，你将会看到。Java 可能会通过添加
    `filter` 和一些其他作为通用库方法的“朋友”来完善，例如
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You wouldn’t even have to write methods like `filterApples` because, for example,
    the previous call
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要编写像 `filterApples` 这样的方法，因为例如，前面的调用
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'could be written as a call to the library method `filter`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成对库方法 `filter` 的调用：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: But, for reasons centered on better exploiting parallelism, the designers didn’t
    do this. Java 8 instead contains a new Collection-like API called Stream, containing
    a comprehensive set of operations similar to the `filter` operation that functional
    programmers may be familiar with (for example, `map` and `reduce`), along with
    methods to convert between `Collection`s and `Stream`s, which we now investigate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，出于更好地利用并行性的原因，设计者没有这样做。Java 8 代替地包含了一个新的类似于集合的 API，称为 Stream，它包含了一组类似于 `filter`
    操作的操作，这些操作可能是函数式程序员所熟悉的（例如，`map` 和 `reduce`），以及用于在 `Collection`s 和 `Stream`s 之间转换的方法，我们现在将研究这些方法。
- en: 1.4\. Streams
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 流
- en: 'Nearly every Java application *makes* and *processes* collections. But working
    with collections isn’t always ideal. For example, let’s say you need to filter
    expensive transactions from a list and then group them by currency. You’d need
    to write a lot of boilerplate code to implement this data-processing query, as
    shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 Java 应用程序都会 *创建* 和 *处理* 集合。但是，与集合一起工作并不总是理想的。例如，假设你需要从列表中过滤出昂贵的交易，然后按货币分组。你需要编写大量的样板代码来实现这个数据处理查询，如下所示：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Creates the Map where the grouped transaction will be accumulated**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个映射，其中将累积分组交易**'
- en: '***2* Iterates the List of transactions**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历交易列表**'
- en: '***3* Filters expensive transactions**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 过滤昂贵的交易**'
- en: '***4* Extracts the transaction’s currency**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 提取交易的货币**'
- en: '***5* If there isn’t an entry in the grouping Map for this currency, create
    it.**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果分组映射中没有该货币的条目，则创建它。**'
- en: '***6* Adds the currently traversed transaction to the List of transactions
    with the same currency**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将当前遍历的交易添加到具有相同货币的交易列表中**'
- en: In addition, it’s difficult to understand at a glance what the code does because
    of the multiple nested control-flow statements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于存在多个嵌套的控制流语句，因此很难一眼看出代码的功能。
- en: 'Using the Streams API, you can solve this problem as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Streams API，你可以这样解决这个问题：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Filters expensive transactions**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 过滤昂贵的交易**'
- en: '***2* Groups them by currency**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 按货币分组**'
- en: Don’t worry about this code for now because it may look like a bit of magic.
    [Chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07) are
    dedicated to explaining how to make sense of the Streams API. For now, it’s worth
    noticing that the Streams API provides a different way to process data in comparison
    to the Collections API. Using a collection, you’re managing the iteration process
    yourself. You need to iterate through the elements one by one using a `for-each`
    loop processing them in turn. We call this way of iterating over data *external
    iteration*. In contrast, using the Streams API, you don’t need to think in terms
    of loops. The data processing happens internally inside the library. We call this
    idea *internal iteration*. We come back to these ideas in [chapter 4](kindle_split_015.xhtml#ch04).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心这段代码，因为它可能看起来有点像魔法。第4章到第7章（[Chapters 4](kindle_split_015.xhtml#ch04)–[7](kindle_split_018.xhtml#ch07)）专门解释了如何理解Streams
    API。现在，值得注意的是，Streams API提供了与Collections API不同的数据处理方式。使用集合，你需要自己管理迭代过程。你需要使用`for-each`循环逐个遍历元素，依次处理它们。我们称这种方式为数据的外部迭代。相比之下，使用Streams
    API，你不需要考虑循环。数据处理在库内部发生。我们称这个想法为内部迭代。我们将在第4章（[chapter 4](kindle_split_015.xhtml#ch04)）中回到这些想法。
- en: As a second pain point of working with collections, think for a second about
    how you would process the list of transactions if you had a vast number of them;
    how can you process this huge list? A single CPU wouldn’t be able to process this
    large amount of data, but you probably have a multicore computer on your desk.
    Ideally, you’d like to share the work among the different CPU cores available
    on your machine to reduce the processing time. In theory, if you have eight cores,
    they should be able to process your data eight times as fast as using one core,
    because they work in parallel.^([[5](#ch01fn05)])
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与集合一起工作的第二个痛点，先想想如果你有大量交易列表，你会如何处理它；你该如何处理这个庞大的列表？单个CPU无法处理如此大量的数据，但你可能桌上有多核计算机。理想情况下，你希望将工作分配给你的机器上可用的不同CPU核心，以减少处理时间。从理论上讲，如果你有八个核心，它们应该能够以使用一个核心八倍的速度处理你的数据，因为它们是并行工作的.^([[5](#ch01fn05)])
- en: ⁵
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This naming is unfortunate in some ways. Each of the cores in a multicore chip
    is a full-fledged CPU. But the phrase multicore CPU has become common, so core
    is used to refer to the individual CPUs.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种命名在某种程度上是不幸的。多核芯片中的每个核心都是一个完整的CPU。但“多核CPU”这个短语已经变得很常见，所以“核心”用来指代单个CPU。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Multicore computers**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**多核计算机**'
- en: All new desktop and laptop computers are multicore computers. Instead of a single
    CPU, they have four or eight or more CPUs (usually called Cores5). The problem
    is that a classic Java program uses just a single one of these cores, and the
    power of the others is wasted. Similarly, many companies use *computing clusters*
    (computers connected together with fast networks) to be able to process vast amounts
    of data efficiently. Java 8 facilitates new programming styles to better exploit
    such computers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的台式机和笔记本电脑都是多核计算机。它们不是单个CPU，而是有四个、八个或更多的CPU（通常称为核心5）。问题是经典的Java程序只使用这些核心中的一个，其他核心的功率被浪费了。同样，许多公司使用*计算集群*（通过快速网络连接在一起的计算机）来有效地处理大量数据。Java
    8简化了新的编程风格，以更好地利用这类计算机。
- en: Google’s search engine is an example of a piece of code that’s too big to run
    on a single computer. It reads every page on the internet and creates an index,
    mapping every word appearing on any internet page back to every URL containing
    that word. Then, when you do a Google search involving several words, software
    can quickly use this index to give you a set of web pages containing those words.
    Try to imagine how you might code this algorithm in Java (even for a smaller index
    than Google’s, you’d need to exploit all the cores in your computer).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的搜索引擎是一个例子，它太大，无法在单个计算机上运行。它读取互联网上的每一页，并创建一个索引，将任何互联网页面上出现的每个单词映射回包含该单词的每个URL。然后，当你进行涉及多个单词的谷歌搜索时，软件可以快速使用这个索引给你提供包含这些单词的网页集合。试着想象你如何用Java编写这个算法（即使对于比谷歌的小的索引，你也需要利用你电脑上的所有核心）。
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.4.1\. Multithreading is difficult
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1. 多线程是困难的
- en: 'The problem is that exploiting parallelism by writing *multithreaded* code
    (using the Threads API from previous versions of Java) is difficult. You have
    to think differently: threads can access and update shared variables at the same
    time. As a result, data could change unexpectedly if not coordinated^([[6](#ch01fn06)])
    properly. This model is harder to think about^([[7](#ch01fn07)]) than a step-by-step
    sequential model. For example, [figure 1.5](#ch01fig05) shows a possible problem
    with two threads trying to add a number to a shared variable `sum` if they’re
    not synchronized properly.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，通过编写**多线程**代码（使用Java先前版本中的Threads API）来利用并行性是困难的。你必须以不同的方式思考：线程可以同时访问和更新共享变量。结果，如果没有适当协调^([[6](#ch01fn06)]),
    数据可能会意外改变。这种模型比逐步顺序模型更难思考^([[7](#ch01fn07)]). 例如，[图1.5](#ch01fig05)展示了两个线程试图在不正确同步的情况下向共享变量`sum`添加数字时可能出现的潜在问题。
- en: ⁶
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Traditionally via the keyword `synchronized`, but many subtle bugs arise from
    its misplacement. Java 8’s `Stream`-based parallelism encourages a functional
    programming style where `synchronized` is rarely used; it focuses on partitioning
    the data rather than coordinating access to it.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传统上通过`synchronized`关键字实现，但许多微妙的错误都源于其位置不当。基于`Stream`的Java 8并行性鼓励一种函数式编程风格，其中`synchronized`很少使用；它侧重于数据分区而不是协调对数据的访问。
- en: ⁷
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Aha—a source of pressure for the language to evolve!
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 啊哈——这是推动语言进化的压力来源！
- en: Figure 1.5\. A possible problem with two threads trying to add to a shared `sum`
    variable. The result is 105 instead of an expected result of 108.
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5\. 两个线程试图向共享的`sum`变量添加时可能出现的潜在问题。结果是105，而不是预期的108。
- en: '![](Images/01fig05_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig05_alt.jpg)'
- en: 'Java 8 also addresses both problems (boilerplate and obscurity involving processing
    collections and difficulty exploiting multicore) with the Streams API (`java.util.stream`).
    The first design motivator is that there are many data-processing patterns (similar
    to `filterApples` in the previous section or operations familiar from database
    query languages such as SQL) that occur over and over again and that would benefit
    from forming part of a library: *filtering* data based on a criterion (for example,
    heavy apples), *extracting* data (for example, extracting the weight field from
    each apple in a list), or *grouping* data (for example, grouping a list of numbers
    into separate lists of even and odd numbers), and so on. The second motivator
    is that such operations can often be parallelized. For instance, as illustrated
    in [figure 1.6](#ch01fig06), filtering a list on two CPUs could be done by asking
    one CPU to process the first half of a list and the second CPU to process the
    other half of the list. This is called the *forking step* (1). The CPUs then filter
    their respective half-lists (2). Finally (3), one CPU would join the two results.
    (This is closely related to how Google searches work so quickly, using many more
    than two processors.)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8也通过Streams API（`java.util.stream`）解决了这两个问题（与处理集合相关的样板代码和模糊性以及利用多核的困难）。第一个设计动机是存在许多数据处理的模式（类似于前一小节中的`filterApples`或来自数据库查询语言（如SQL）的熟悉操作），这些模式反复出现，并且会从成为库的一部分中受益：基于标准（例如，重苹果）**过滤**数据，**提取**数据（例如，从列表中的每个苹果中提取重量字段），或**分组**数据（例如，将数字列表分组为偶数和奇数列表），等等。第二个动机是这些操作通常可以并行化。例如，如图1.6所示，在两个CPU上过滤列表可以通过要求一个CPU处理列表的前半部分，而另一个CPU处理列表的后半部分来实现。这被称为**分叉步骤**（1）。然后，CPU过滤它们各自的半列表（2）。最后（3），一个CPU将合并两个结果。（这与Google搜索快速工作的方式密切相关，使用了两个以上的处理器。）
- en: Figure 1.6\. Forking `filter` onto two CPUs and joining the result
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6\. 将`filter`分叉到两个CPU上并合并结果
- en: '![](Images/01fig06_alt.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig06_alt.jpg)'
- en: 'For now, we’ll just say that the new Streams API behaves similarly to Java’s
    existing Collections API: both provide access to sequences of data items. But
    it’s useful for now to keep in mind that Collections is mostly about storing and
    accessing data, whereas Streams is mostly about describing computations on data.
    The key point here is that the Streams API allows and encourages the elements
    within a stream to be processed in parallel. Although it may seem odd at first,
    often the fastest way to filter a collection (for example, to use `filterApples`
    in the previous section on a list) is to convert it to a stream, process it in
    parallel, and then convert it back to a list. Again, we’ll just say “parallelism
    almost for free” and provide a taste of how you can filter heavy apples from a
    list sequentially or in parallel using streams and a lambda expression.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只能说新的Streams API的行为与Java现有的Collections API类似：两者都提供了对数据项序列的访问。但记住这一点是有用的，即Collections主要是关于存储和访问数据，而Streams主要是关于对数据进行计算。这里的关键点是Streams
    API允许并鼓励流内的元素并行处理。虽然一开始可能看起来很奇怪，但过滤集合（例如，在上一个章节中对列表使用`filterApples`）最快的方法通常是将其转换为流，并行处理，然后再将其转换回列表。我们再次只是说“几乎免费获得并行处理”，并展示如何使用流和lambda表达式按顺序或并行地从列表中过滤出重苹果。
- en: 'Here’s an example of sequential processing:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个顺序处理的例子：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here it is using parallel processing:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看并行处理的应用：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Parallelism in Java and no shared mutable state**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java中的并行处理和无共享可变状态**'
- en: People have always said parallelism in Java is difficult, and all this stuff
    about `synchronized` is error-prone. Where’s the magic bullet in Java 8?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说Java中的并行处理很困难，所有关于`synchronized`的内容都容易出错。Java 8中有什么神奇的子弹吗？
- en: There are two magic bullets. First, the library handles partitioning—breaking
    down a big stream into several smaller streams to be processed in parallel for
    you. Second, this parallelism almost for free from streams, works only if the
    methods passed to library methods like `filter` don’t interact (for example, by
    having mutable shared objects). But it turns out that this restriction feels natural
    to a coder (see, by way of example, our `Apple::isGreenApple` example). Although
    the primary meaning of *functional* in *functional programming* means “using functions
    as first-class values,” it often has a secondary nuance of “no interaction during
    execution between components.”
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个神奇的子弹。首先，库处理分区——将大流分解成几个较小的流以供你并行处理。其次，这种从流中几乎免费获得的并行处理，仅在传递给库方法（如`filter`）的方法不交互（例如，通过具有可变共享对象）时才有效。但结果证明，这种限制对程序员来说感觉是自然的（例如，通过我们的`Apple::isGreenApple`示例）。尽管在**函数式编程**中，“函数式”的主要含义是“将函数作为一等值使用”，但它通常还有一个次要的含义，即“组件在执行期间不交互。”
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Chapter 7](kindle_split_018.xhtml#ch07) explores parallel data processing
    in Java 8 and its performance in more detail. One of the practical issues the
    Java 8 developers found in evolving Java with all these new goodies was that of
    evolving existing interfaces. For example, the method `Collections.sort` belongs
    to the `List` interface but was never included. Ideally, you’d like to do `list.sort(comparator)`
    instead of `Collections.sort(list, comparator)`. This may seem trivial but, prior
    to Java 8 you can update an interface only if you update all the classes that
    implement it—a logistical nightmare! This issue is resolved in Java 8 by *default
    methods*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](kindle_split_018.xhtml#ch07)详细探讨了Java 8中的并行数据处理及其性能。Java 8开发者在将所有这些新特性引入Java的过程中发现的一个实际问题，是现有接口的演变。例如，`Collections.sort`方法属于`List`接口，但从未被包含在内。理想情况下，你希望执行`list.sort(comparator)`而不是`Collections.sort(list,
    comparator)`。这看起来可能微不足道，但在Java 8之前，只有当你更新实现它的所有类时，你才能更新一个接口——这是一个后勤噩梦！这个问题在Java
    8中通过**默认方法**得到了解决。'
- en: 1.5\. Default methods and Java modules
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 默认方法和Java模块
- en: As we mentioned earlier, modern systems tend to be built from components—perhaps
    bought-in from elsewhere. Historically, Java had little support for this, apart
    from a JAR file containing a set of Java packages with no particular structure.
    Moreover, evolving interfaces to such packages was hard—changing a Java interface
    meant changing every class that implements it. Java 8 and 9 have started to address
    this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，现代系统往往是由组件构建的——可能是从其他地方购买的。从历史上看，Java在这方面支持很少，除了包含一组没有特定结构的Java包的JAR文件。此外，将这些接口演变到这样的包中也很困难——更改Java接口意味着更改实现它的每个类。Java
    8和9开始着手解决这个问题。
- en: First, Java 9 provides a module system that provide you with syntax to define
    *modules* containing collections of packages—and keep much better control over
    visibility and namespaces. Modules enrich a simple JAR-like component with structure,
    both as user documentation and for machine checking; we explain them in detail
    in [chapter 14](kindle_split_027.xhtml#ch14). Second, Java 8 added default methods
    to support *evolvable* interfaces. We cover these in detail in [chapter 13](kindle_split_026.xhtml#ch13).
    They’re important because you’ll increasingly encounter them in interfaces, but
    because relatively few programmers will need to write default methods themselves
    and because they facilitate program evolution rather than helping write any particular
    program, we keep the explanation here short and example-based.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Java 9提供了一个模块系统，它提供了定义包含包集合的*模块*的语法，并更好地控制可见性和命名空间。模块通过结构丰富了一个简单的JAR-like组件，既作为用户文档，也用于机器检查；我们将在[第14章](kindle_split_027.xhtml#ch14)中详细解释它们。其次，Java
    8添加了默认方法来支持*可进化*的接口。我们将在[第13章](kindle_split_026.xhtml#ch13)中详细讨论这些内容。它们很重要，因为您将越来越多地在接口中遇到它们，但由于相对较少的程序员需要自己编写默认方法，并且它们有助于程序进化而不是帮助编写任何特定的程序，所以我们在这里简要介绍并基于示例进行说明。
- en: 'In [section 1.4](#ch01lev1sec4), we gave the following example Java 8 code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1.4节](#ch01lev1sec4)中，我们给出了以下Java 8代码示例：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But there’s a problem here: a `List<T>` prior to Java 8 doesn’t have `stream`
    or `parallel-Stream` methods—and neither does the `Collection<T>` interface that
    it implements—because these methods hadn’t been conceived of. And without these
    methods, this code won’t compile. The simplest solution, which you might employ
    for your own interfaces, would have been for the Java 8 designers to add the `stream`
    method to the `Collection` interface and add the implementation in the `ArrayList`
    class.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题：Java 8之前的`List<T>`没有`stream`或`parallel-Stream`方法，并且它实现的`Collection<T>`接口也没有这些方法——因为这些方法还没有被构想出来。没有这些方法，这段代码将无法编译。对于您自己的接口，最简单的解决方案可能是Java
    8设计者将`stream`方法添加到`Collection`接口中，并在`ArrayList`类中添加实现。
- en: 'But doing this would have been a nightmare for users. Many alternative collection
    frameworks implement interfaces from the Collections API. Adding a new method
    to an interface means all concrete classes must provide an implementation for
    it. Language designers have no control over existing implementations of `Collection`,
    so you have a dilemma: How can you evolve published interfaces without disrupting
    existing implementations?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做对用户来说将是一场噩梦。许多替代集合框架实现了Collections API的接口。向接口添加新方法意味着所有具体的类都必须为其提供实现。语言设计者无法控制`Collection`的现有实现，因此您面临一个困境：如何在不破坏现有实现的情况下进化已发布的接口？
- en: 'The Java 8 solution is to break the last link: an interface can now contain
    method signatures for which an implementing class doesn’t provide an implementation.
    Then who implements them? The missing method bodies are given as part of the interface
    (hence default implementations) rather than in the implementing class.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8的解决方案是打破最后一个链接：接口现在可以包含实现类不提供实现的方法定义。那么谁来实现它们呢？缺失的方法体作为接口的一部分（因此是默认实现）而不是在实现类中给出。
- en: This provides a way for an interface designer to enlarge an interface beyond
    those methods that were originally planned—without breaking existing code. Java
    8 allows the existing `default` keyword to be used in interface specifications
    to achieve this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这为接口设计者提供了一种方法，可以在不破坏现有代码的情况下扩展接口——超出最初计划的方法。Java 8允许在接口规范中使用现有的`default`关键字来实现这一点。
- en: 'For example, in Java 8, you can call the `sort` method directly on a list.
    This is made possible with the following default method in the Java 8 `List` interface,
    which calls the static method `Collections.sort`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Java 8中，您可以直接在列表上调用`sort`方法。这是通过Java 8 `List`接口中的以下默认方法实现的，它调用静态方法`Collections.sort`：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means any concrete classes of `List` don’t have to explicitly implement
    `sort`, whereas in previous Java versions such concrete classes would fail to
    recompile unless they provided an implementation for `sort`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何具体的`List`类都不需要显式实现`sort`方法，而在之前的Java版本中，这些具体的类如果没有提供`sort`方法的实现就无法重新编译。
- en: But wait a second. A single class can implement multiple interfaces, right?
    If you have multiple default implementations in several interfaces, does that
    mean you have a form of multiple inheritance in Java? Yes, to some extent. We
    show in [chapter 13](kindle_split_026.xhtml#ch13) that there are some rules that
    prevent issues such as the infamous *diamond inheritance problem* in C++.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。一个类可以实现多个接口，对吧？如果你在几个接口中有多个默认实现，这意味着你在 Java 中有某种形式的多重继承吗？是的，在某种程度上。我们在第
    [13 章](kindle_split_026.xhtml#ch13) 中展示了某些规则，这些规则防止了像 C++ 中臭名昭著的 *菱形继承问题* 这样的问题。
- en: 1.6\. Other good ideas from functional programming
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 函数式编程中的其他好想法
- en: 'The previous sections introduced two core ideas from functional programming
    that are now part of Java: using methods and lambdas as first-class values, and
    the idea that calls to functions or methods can be efficiently and safely executed
    in parallel in the absence of mutable shared state. Both of these ideas are exploited
    by the new Streams API we described earlier.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节介绍了函数式编程的两个核心思想，现在已成为 Java 的一部分：使用方法和 lambda 表达式作为一等值，以及在没有可变共享状态的情况下，函数或方法调用可以高效且安全地并行执行的想法。这两个想法都被我们之前描述的新
    Streams API 所利用。
- en: 'Common functional languages (SML, OCaml, Haskell) also provide further constructs
    to help programmers. One of these is avoiding `null` by explicit use of more descriptive
    data types. Tony Hoare, one of the giants of computer science, said this in a
    presentation at QCon London 2009:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的函数式语言（SML、OCaml、Haskell）还提供了其他构造来帮助程序员。其中之一是通过显式使用更具描述性的数据类型来避免 `null`。计算机科学巨匠之一托尼·霍尔在
    2009 年伦敦 QCon 的一个演讲中说：
- en: '*I call it my billion-dollar mistake. It was the invention of the null reference
    in 1965\. . . .I couldn’t resist the temptation to put in a null reference, simply
    because it was so easy to implement.*'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我称之为我的十亿美元的错误。这是 1965 年对空引用的发明……我无法抗拒加入空引用的诱惑，仅仅因为它如此容易实现。*'
- en: Java 8 introduced the `Optional<T>` class that, if used consistently, can help
    you avoid null-pointer exceptions. It’s a container object that may or may not
    contain a value. `Optional<T>` includes methods to explicitly deal with the case
    where a value is absent, and as a result you can avoid null-pointer exceptions.
    It uses the type system to allow you to indicate when a variable is anticipated
    to potentially have a missing value. We discuss `Optional<T>` in detail in [chapter
    11](kindle_split_024.xhtml#ch11).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了 `Optional<T>` 类，如果一致使用，可以帮助你避免空指针异常。它是一个可能包含或不包含值的容器对象。`Optional<T>`
    包含处理值不存在情况的方法，因此你可以避免空指针异常。它使用类型系统来允许你指示一个变量预期可能缺少值。我们在第 [11 章](kindle_split_024.xhtml#ch11)
    中详细讨论了 `Optional<T>`。
- en: 'A second idea is that of *(structural) pattern matching*.^([[8](#ch01fn08)])
    This is used in mathematics. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个想法是关于 *(结构化)模式匹配*。^([[8](#ch01fn08)]) 这在数学中有所应用。例如：
- en: ⁸
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This phrase has two uses. Here we mean the one familiar from mathematics and
    functional programming whereby a function is defined by cases, rather than using
    `if-then-else`. The other meaning concerns phrases like “find all files of the
    form ‘IMG*.JPG’ in a given directory” associated with so-called regular expressions.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个短语有两个用途。在这里，我们指的是从数学和函数式编程中熟悉的用法，即函数通过情况定义，而不是使用 `if-then-else`。另一个含义涉及像“在给定目录中查找所有形式为‘IMG*.JPG’的文件”这样的短语，这与所谓的正则表达式相关。
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Java, you would write an `if-then-else` or a `switch` statement. Other languages
    have shown that, for more complex data types, pattern matching can express programming
    ideas more concisely compared to using `if-then-else`. For such data types, you
    might also use polymorphism and method overriding as an alternative to `if-then-else`,
    but there’s ongoing language-design discussion as to which is more appropriate.^([[9](#ch01fn09)])
    We’d say that both are useful tools and that you should have both in your armory.
    Unfortunately, Java 8 doesn’t have full support for pattern matching, although
    we show how it can be expressed in [chapter 19](kindle_split_034.xhtml#ch19).
    A Java Enhancement Proposal is also being discussed to support pattern matching
    in a future version of Java (see [http://openjdk.java.net/jeps/305](http://openjdk.java.net/jeps/305)).
    In the meantime, let’s illustrate with an example expressed in the Scala programming
    language (another Java-like language using the JVM that has inspired some aspects
    of Java evolution; see [chapter 20](kindle_split_035.xhtml#ch20)). Suppose you
    want to write a program that does basic simplifications on a tree representing
    an arithmetic expression. Given a data type `Expr` representing such expressions,
    in Scala you can write the following code to decompose an `Expr` into its parts
    and then return another `Expr`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你会写一个`if-then-else`或`switch`语句。其他语言已经表明，对于更复杂的数据类型，与使用`if-then-else`相比，模式匹配可以更简洁地表达编程思想。对于此类数据类型，你也可能使用多态性和方法重写作为`if-then-else`的替代方案，但关于哪种更合适，语言设计讨论仍在进行中。[9](#ch01fn09)]
    我们会说两者都是有用的工具，你应该两者都具备。不幸的是，Java 8没有对模式匹配提供全面支持，尽管我们在第19章中展示了如何表达它。还正在讨论一个Java增强提案，以支持Java未来版本中的模式匹配（见[http://openjdk.java.net/jeps/305](http://openjdk.java.net/jeps/305)）。同时，让我们用一个在Scala编程语言中表达（另一种使用JVM的类似Java的语言，它启发了Java的一些演变方面；见第20章）的例子来说明。假设你想编写一个程序，对表示算术表达式的树进行基本简化。给定一个表示此类表达式的数据类型`Expr`，在Scala中，你可以编写以下代码来分解一个`Expr`并返回另一个`Expr`：
- en: ⁹
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Wikipedia article on the “expression problem” (a term coined by Phil Wadler)
    provides an entry to the discussion.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于“表达式问题”（由Phil Wadler提出的术语）的维基百科文章为讨论提供了入口。
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Adds 0**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 加0**'
- en: '***2* Subtracts 0**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 减去0**'
- en: '***3* Multiplies by 1**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 乘以1**'
- en: '***4* Divides by 1**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 除以1**'
- en: '***5* Can’t be simplified with these cases, so leave alone**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 这些情况无法简化，所以可以忽略**'
- en: Here Scala’s syntax `expr match` corresponds to Java’s `switch (expr)`. Don’t
    worry about this code for now—you’ll read more on pattern matching in [chapter
    19](kindle_split_034.xhtml#ch19). For now, you can think of pattern matching as
    an extended form of `switch` that can decompose a data type into its components
    at the same time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里Scala的语法`expr match`对应于Java的`switch (expr)`。现在不必担心这段代码——你将在第19章中了解更多关于模式匹配的内容。现在，你可以将模式匹配视为`switch`的扩展形式，它可以在分解数据类型的同时将其分解为其组件。
- en: 'Why should the `switch` statement in Java be limited to primitive values and
    strings? Functional languages tend to allow `switch` to be used on many more data
    types, including allowing pattern matching (in the Scala code, this is achieved
    using a `match` operation). In object-oriented design, the visitor pattern is
    a common pattern used to walk through a family of classes (such as the different
    components of a car: wheel, engine, chassis, and so on) and apply an operation
    to each object visited. One advantage of pattern matching is that a compiler can
    report common errors such as, “Class `Brakes` is part of the family of classes
    used to represent components of class `Car`. You forgot to explicitly deal with
    it.”'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Java中的`switch`语句仅限于原始值和字符串？函数式语言通常允许`switch`在更多数据类型上使用，包括允许模式匹配（在Scala代码中，这是通过使用`match`操作实现的）。在面向对象设计中，访问者模式是一种常用的模式，用于遍历一组类（例如汽车的各个部件：轮胎、引擎、底盘等）并对每个访问的对象应用操作。模式匹配的一个优点是编译器可以报告常见的错误，例如，“类`Brakes`是用于表示`Car`类组件的类族的一部分。你忘记显式处理它了。”
- en: '[Chapters 18](kindle_split_033.xhtml#ch18) and [19](kindle_split_034.xhtml#ch19)
    give a full tutorial introduction to functional programming and how to write functional-style
    programs in Java 8—including the toolkit of functions provided in its library.
    [Chapter 20](kindle_split_035.xhtml#ch20) follows by discussing how Java 8 features
    compare to those in Scala—a language that, like Java, is implemented on top of
    the JVM and that has evolved quickly to threaten some aspects of Java’s niche
    in the programming language ecosystem. This material is positioned toward the
    end of the book to provide additional insight into why the new Java 8 and Java
    9 features were added.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 18 章](kindle_split_033.xhtml#ch18) 和 [第 19 章](kindle_split_034.xhtml#ch19)
    提供了关于函数式编程的全面教程介绍以及如何在 Java 8 中编写函数式风格的程序——包括其库中提供的函数工具包。[第 20 章](kindle_split_035.xhtml#ch20)
    接着讨论了 Java 8 的特性与 Scala 语言中的特性相比——Scala 语言与 Java 类似，也是基于 JVM 实现的，并且迅速进化以威胁到 Java
    在编程语言生态系统中的某些领域。这些内容位于本书的末尾，以提供更多关于为什么添加了新的 Java 8 和 Java 9 特性的见解。'
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Java 8, 9, 10, and 11 features: Where do you start?**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 8、9、10 和 11 特性：从哪里开始？**'
- en: Java 8 and Java 9 both provided significant updates to Java. But as a Java programmer,
    it’s likely to be the Java 8 additions that affect you most on a daily small-scale-coding
    basis—the idea of passing a method or a lambda is rapidly becoming vital Java
    knowledge. In contrast, the Java 9 enhancements enrich our ability to define and
    use larger-scale components, be it structuring a system using modules or importing
    a reactive-programming toolkit. Finally, Java 10 is a much smaller increment compared
    to previous upgrades and consists of allowing type inference for local variables,
    which we discuss briefly in [chapter 21](kindle_split_036.xhtml#ch21), where we
    also mention the related richer syntax for arguments of lambda expressions due
    to be introduced in Java 11\. At the time of writing, Java 11 is scheduled to
    be released in September 2018\. Java 11 also brings a new asynchronous HTTP client
    library ([http://openjdk.java.net/jeps/321](http://openjdk.java.net/jeps/321))
    that leverages the Java 8 and Java 9 developments (details in [chapters 15](kindle_split_029.xhtml#ch15),
    [16](kindle_split_030.xhtml#ch16), and [17](kindle_split_031.xhtml#ch17)) of `CompletableFuture`
    and reactive programming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 和 Java 9 都对 Java 进行了重大更新。但作为一名 Java 程序员，你每天在小型编码基础上最可能受到影响的是 Java 8 的新增功能——传递方法或
    lambda 的概念正迅速成为至关重要的 Java 知识。相比之下，Java 9 的增强功能丰富了定义和使用更大规模组件的能力，无论是使用模块来构建系统还是导入响应式编程工具包。最后，Java
    10 相比之前的升级要小得多，它允许局部变量的类型推断，我们将在 [第 21 章](kindle_split_036.xhtml#ch21) 中简要讨论这一点，在那里我们还将提到由于
    Java 11 的引入而带来的 lambda 表达式参数的更丰富语法。在撰写本文时，Java 11 预计将于 2018 年 9 月发布。Java 11 还引入了一个新的异步
    HTTP 客户端库 ([http://openjdk.java.net/jeps/321](http://openjdk.java.net/jeps/321))，该库利用了
    Java 8 和 Java 9 的发展（详情见 [第 15 章](kindle_split_029.xhtml#ch15)、[第 16 章](kindle_split_030.xhtml#ch16)
    和 [第 17 章](kindle_split_031.xhtml#ch17)）中的 `CompletableFuture` 和响应式编程。
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Keep in mind the idea of the language ecosystem and the consequent evolve-or-wither
    pressure on languages. Although Java may be supremely healthy at the moment, we
    can recall other healthy languages such as COBOL that failed to evolve.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住语言生态系统的理念以及随之而来的语言进化或衰败的压力。尽管 Java 目前可能非常健康，但我们也可以回忆起其他健康的语言，如 COBOL，这些语言未能进化。
- en: The core additions to Java 8 provide exciting new concepts and functionality
    to ease the writing of programs that are both effective and concise.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 的核心新增功能提供了令人兴奋的新概念和功能，以简化编写既有效又简洁的程序。
- en: Multicore processors aren’t fully served by pre-Java-8 programming practice.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多核处理器并没有完全由 Java 8 之前的编程实践所充分利用。
- en: Functions are first-class values; remember how methods can be passed as functional
    values and how anonymous functions (lambdas) are written.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是一等值；记住方法可以作为函数值传递，以及匿名函数（lambda）是如何编写的。
- en: The Java 8 concept of streams generalizes many aspects of collections, but the
    former often enables more readable code and allows elements of a stream to be
    processed in parallel.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 的流概念概括了许多集合的方面，但前者通常使代码更易读，并允许流中的元素并行处理。
- en: Large-scale component-based programming, and evolving a system’s interfaces,
    weren’t historically well served by Java. You can now specify modules to structure
    systems in Java 9 and use default methods to allow an interface to be enhanced
    without changing all the classes that implement it.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大规模基于组件的编程，以及系统接口的演变，在历史上并没有得到Java的良好服务。现在你可以在Java 9中指定模块来结构化系统，并使用默认方法来允许在不更改实现它的所有类的情况下增强接口。
- en: Other interesting ideas from functional programming include dealing with `null`
    and using pattern matching.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程中的其他有趣想法包括处理 `null` 和使用模式匹配。
- en: Chapter 2\. Passing code with behavior parameterization
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章：使用行为参数化传递代码
- en: '*This chapter covers*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Coping with changing requirements
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对变化的需求
- en: Behavior parameterization
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为参数化
- en: Anonymous classes
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类
- en: Preview of lambda expressions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda表达式的预览
- en: 'Real-world examples: `Comparator`, `Runnable`, and GUI'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界的例子：`Comparator`、`Runnable` 和 GUI
- en: A well-known problem in software engineering is that no matter what you do,
    user requirements will change. For example, imagine an application to help a farmer
    understand his inventory. The farmer might want a functionality to find all green
    apples in his inventory. But the next day he might tell you, “Actually, I also
    want to find all apples heavier than 150 g.” Two days later, the farmer comes
    back and adds, “It would be really nice if I could find all apples that are green
    *and* heavier than 150 g.” How can you cope with these changing requirements?
    Ideally, you’d like to minimize your engineering effort. In addition, similar
    new functionalities ought to be straightforward to implement and maintainable
    in the long term.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程中一个众所周知的问题是，无论你做什么，用户需求都会改变。例如，想象一个帮助农民了解其库存的应用程序。农民可能希望有一个功能来查找他库存中所有绿色的苹果。但第二天他可能会告诉你，“实际上，我还想找到所有重量超过150克的苹果。”两天后，农民回来并补充说，“如果我能找到所有既绿色又重量超过150克的苹果那就太好了。”你如何应对这些不断变化的需求？理想情况下，你希望最小化你的工程努力。此外，类似的新功能应该易于实现且长期可维护。
- en: '*Behavior parameterization* is a software development pattern that lets you
    handle frequent requirement changes. In a nutshell, it means taking a block of
    code and making it available without executing it. This block of code can be called
    later by other parts of your programs, which means that you can defer the execution
    of that block of code. For instance, you could pass the block of code as an argument
    to another method that will execute it later. As a result, the method’s behavior
    is parameterized based on that block of code. For example, if you process a collection,
    you may want to write a method that'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*行为参数化*是一种软件开发模式，它允许你处理频繁的需求变更。简而言之，这意味着取一段代码并使其可用而不执行它。这段代码可以在稍后由程序的其他部分调用，这意味着你可以延迟执行这段代码。例如，你可以将这段代码作为参数传递给另一个稍后执行它的方法。因此，方法的行为是根据这段代码参数化的。例如，如果你处理一个集合，你可能想编写一个方法，'
- en: Can do “something” for every element of a list
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以对列表中的每个元素执行“某种”操作
- en: Can do “something else” when you finish processing the list
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理完列表后可以执行“另一件事”
- en: Can do “yet something else” if you encounter an error
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到错误，可以执行“另一件事”
- en: 'This is what *behavior parameterization* refers to. Here’s an analogy: your
    roommate knows how to drive to the supermarket and back home. You can tell him
    to buy a list of things such as bread, cheese, and wine. This is equivalent to
    calling a method `goAndBuy` passing a list of products as its argument. But one
    day you’re at the office, and you need him to do something he’s never done before—pick
    up a package from the post office. You need to pass him a list of instructions:
    go to the post office, use this reference number, talk to the manager, and pick
    up the parcel. You could pass him the list of instructions by email, and when
    he receives it, he can follow the instructions. You’ve now done something a bit
    more advanced that’s equivalent to a method `goAndDo`, which can execute various
    new behaviors as arguments.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*行为参数化*所指的内容。这里有一个类比：你的室友知道如何开车去超市并回家。你可以告诉他去买一些东西，比如面包、奶酪和酒。这相当于调用一个方法 `goAndBuy`，传递一个产品列表作为其参数。但有一天你在办公室，你需要他做他以前从未做过的事情——从邮局取包裹。你需要给他一个指令列表：去邮局，使用这个参考号，和经理交谈，取回包裹。你可以通过电子邮件给他这个指令列表，当他收到时，他可以按照指令行事。你现在做了一件稍微复杂一点的事情，这相当于一个方法
    `goAndDo`，它可以执行各种新的行为作为参数。
- en: We’ll start this chapter by walking you through an example of how you can evolve
    your code to be more flexible for changing requirements. Building on this knowledge,
    we show how to use behavior parameterization for several real-world examples.
    For example, you may have used the behavior parameterization pattern already,
    using existing classes and interfaces in the Java API to sort a `List`, to filter
    names of files, or to tell a `Thread` to execute a block of code or even perform
    GUI event handling. You’ll soon realize that this pattern is historically verbose
    in Java. Lambda expressions in Java 8 onward tackle the problem of verbosity.
    We’ll show in [chapter 3](kindle_split_013.xhtml#ch03) how to construct lambda
    expressions, where to use them, and how you can make your code more concise by
    adopting them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，通过一个例子向您展示您如何使代码更具灵活性，以适应不断变化的需求。基于这个知识，我们展示了如何为几个现实世界的例子使用行为参数化。例如，您可能已经使用过行为参数化模式，使用Java
    API中的现有类和接口来排序`List`，过滤文件名，或者告诉`Thread`执行代码块，甚至执行GUI事件处理。您很快就会意识到这个模式在Java中历史性地很冗长。从Java
    8开始的Lambda表达式解决了冗长的问题。我们将在[第3章](kindle_split_013.xhtml#ch03)中展示如何构造Lambda表达式，在哪里使用它们，以及如何通过采用它们使您的代码更简洁。
- en: 2.1\. Coping with changing requirements
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 应对变化需求
- en: Writing code that can cope with changing requirements is difficult. Let’s walk
    through an example that we’ll gradually improve, showing some best practices for
    making your code more flexible. In the context of a farm-inventory application,
    you have to implement a functionality to filter *green* apples from a list. Sounds
    easy, right?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 编写能够应对变化需求的代码是困难的。让我们通过一个我们将逐步改进的例子来探讨，展示一些使您的代码更具灵活性的最佳实践。在农场库存应用程序的背景下，您必须实现一个从列表中过滤*绿色*苹果的功能。听起来很简单，对吧？
- en: '2.1.1\. First attempt: filtering green apples'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 第一次尝试：过滤绿色苹果
- en: 'Assume, as in [chapter 1](kindle_split_011.xhtml#ch01), you have a `Color`
    enum available to represent different colors of an apple:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，如[第1章](kindle_split_011.xhtml#ch01)中所述，您有一个`Color`枚举可用，用于表示苹果的不同颜色：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A first solution might be as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案可能是以下这样：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* An accumulator list for apples**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 苹果的累加列表**'
- en: '***2* Selects only green apples**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仅选择绿色苹果**'
- en: 'The highlighted line shows the condition required to select green apples. You
    can assume that you have a `Color` enum with a set of colors, such as `GREEN`,
    available. But now the farmer changes his mind and wants to also filter *red*
    apples. What can you do? A naïve solution would be to duplicate your method, rename
    it as `filterRedApples`, and change the `if` condition to match red apples. However,
    this approach doesn’t cope well with changes if the farmer wants multiple colors.
    A good principle is this: when you find yourself writing nearly repeated code,
    try to abstract instead.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了选择绿色苹果所需的条件。您可以假设您有一个包含一组颜色，如`GREEN`的`Color`枚举。但现在农民改变了主意，想要过滤*红色*苹果。您能做什么？一个简单的方法是复制您的函数，将其重命名为`filterRedApples`，并将`if`条件更改为匹配红色苹果。然而，如果农民想要多种颜色，这种方法并不能很好地处理变化。一个好的原则是：当你发现自己正在编写几乎重复的代码时，尝试进行抽象。
- en: '2.1.2\. Second attempt: parameterizing the color'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 第二次尝试：参数化颜色
- en: 'How do we avoid duplicating most of the code in `filterGreenApples` to make
    `filter-RedApples`? To parameterize the color and be more flexible to such changes,
    what you could do is add a parameter to your method:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免在`filterGreenApples`中复制大部分代码来创建`filter-RedApples`？为了参数化颜色并使代码更灵活以适应此类变化，您可以在方法中添加一个参数：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can now make the farmer happy and invoke your method as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以让农民满意，并按如下方式调用您的函数：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Too easy, right? Let’s complicate the example a bit. The farmer comes back to
    you and says, “It would be really cool to differentiate between light apples and
    heavy apples. Heavy apples typically have a weight greater than 150 g.”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 太简单了，对吧？让我们稍微复杂化一下例子。农民回到你那里说：“区分轻苹果和重苹果真的很酷。重苹果的重量通常大于150克。”
- en: 'Wearing your software engineering hat, you realize in advance that the farmer
    may want to vary the weight. So you create the following method to cope with various
    weights through an additional parameter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 穿上你的软件工程帽子，你事先意识到农民可能想要改变重量。因此，你创建以下方法来通过一个额外的参数处理各种重量：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a good solution, but notice how you have to duplicate most of the implementation
    for traversing the inventory and applying the filtering criteria on each apple.
    This is somewhat disappointing because it breaks the DRY (don’t repeat yourself)
    principle of software engineering. What if you want to alter the filter traversing
    to enhance performance? You now have to modify the implementation of *all* of
    your methods instead of only a single one. This is expensive from an engineering-effort
    perspective.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的解决方案，但请注意，你必须复制大部分遍历库存和将过滤标准应用于每个苹果的实现。这有点令人失望，因为它打破了软件工程的DRY（不要重复自己）原则。如果你想要改变过滤遍历来提高性能，你现在必须修改所有方法的实现，而不仅仅是单个方法。从工程努力的角度来看，这是昂贵的。
- en: You could combine the color and weight into one method, called `filter`. But
    then you’d still need a way to differentiate what attribute you want to filter
    on. You could add a flag to differentiate between color and weight queries. (But
    never do this! We’ll explain why shortly.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将颜色和重量合并到一个名为`filter`的方法中。但这样你仍然需要一个方法来区分你想要过滤的属性。你可以添加一个标志来区分颜色和重量查询。（但永远不要这样做！我们很快就会解释原因。）
- en: '2.1.3\. Third attempt: filtering with every attribute you can think of'
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3\. 第三次尝试：使用你能想到的所有属性进行过滤
- en: 'An ugly attempt to merge all attributes might be as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将所有属性合并的丑陋方法可能如下所示：
- en: '[PRE29]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* An ugly way to select color or weight**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择颜色或重量的丑陋方式**'
- en: 'You could use this as follows (but it’s ugly):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用（但看起来很丑）：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This solution is extremely bad. First, the client code looks terrible. What
    do `true` and `false` mean? In addition, this solution doesn’t cope well with
    changing requirements. What if the farmer asks you to filter with different attributes
    of an apple, for example, its size, its shape, its origin, and so on? Furthermore,
    what if the farmer asks you for more complicated queries that combine attributes,
    such as green apples that are also heavy? You’d either have multiple duplicated
    `filter` methods or one hugely complex method. So far, you’ve parameterized the
    `filterApples` method *with values* such as a `String`, an `Integer`, an enum
    type, or a `boolean`. This can be fine for certain well-defined problems. But
    in this case, what you need is a better way to tell your `filterApples` method
    the selection criteria for apples. In the next section, we describe how to make
    use of *behavior parameterization* to attain that flexibility.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案非常糟糕。首先，客户端代码看起来很糟糕。`true`和`false`代表什么？此外，这个解决方案不太适应不断变化的需求。如果农民要求你根据苹果的不同属性进行过滤，例如大小、形状、产地等，怎么办？此外，如果农民要求你进行更复杂的查询，结合属性，例如既绿色又重的苹果，怎么办？你将要么有多个重复的`filter`方法，要么有一个极其复杂的方法。到目前为止，你已经用`String`、`Integer`、枚举类型或`boolean`等值对`filterApples`方法进行了参数化。这对于某些定义明确的问题来说可能很好。但在这个情况下，你需要一种更好的方式来告诉`filterApples`方法苹果的选择标准。在下一节中，我们将描述如何利用*行为参数化*来实现这种灵活性。
- en: 2.2\. Behavior parameterization
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 行为参数化
- en: 'You saw in the previous section that you need a better way than adding lots
    of parameters to cope with changing requirements. Let’s step back and find a better
    level of abstraction. One possible solution is to model your selection criteria:
    you’re working with apples and returning a `boolean` based on some attributes
    of `Apple.` For example, is it green? Is it heavier than 150 g? We call this a
    *predicate* (a function that returns a `boolean`). Let’s therefore define an interface
    *to model the selection criteria*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前一节中看到，你需要一种比添加大量参数更好的方法来应对不断变化的需求。让我们退一步，找到一个更好的抽象层次。一个可能的解决方案是模拟你的选择标准：你正在处理苹果，并根据`Apple`的一些属性返回一个`boolean`。例如，它是绿色的吗？它的重量是否超过150克？我们称这为*谓词*（返回`boolean`的函数）。因此，让我们定义一个接口*来模拟选择标准*：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can now declare multiple implementations of `ApplePredicate` to represent
    different selection criteria, as shown in the following (and illustrated in [figure
    2.1](#ch02fig01)):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以声明多个`ApplePredicate`的实现，以表示不同的选择标准，如下所示（并在[图2.1](#ch02fig01)中说明）：
- en: Figure 2.1\. Different strategies for selecting an `Apple`
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 选择`Apple`的不同策略
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Selects only heavy apples**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只选择重苹果**'
- en: '***2* Selects only green apples**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只选择绿色苹果**'
- en: You can see these criteria as different behaviors for the `filter` method. What
    you just did is related to the strategy design pattern (see [http://en.wikipedia.org/wiki/Strategy_pattern](http://en.wikipedia.org/wiki/Strategy_pattern)),
    which lets you define a family of algorithms, encapsulate each algorithm (called
    a strategy), and select an algorithm at run time. In this case the family of algorithms
    is `ApplePredicate` and the different strategies are `AppleHeavyWeightPredicate`
    and `AppleGreenColorPredicate`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些标准视为 `filter` 方法的不同行为。你所做的与策略设计模式（见 [http://en.wikipedia.org/wiki/Strategy_pattern](http://en.wikipedia.org/wiki/Strategy_pattern)）相关，它允许你定义一组算法，封装每个算法（称为策略），并在运行时选择一个算法。在这种情况下，算法组是
    `ApplePredicate`，不同的策略是 `AppleHeavyWeightPredicate` 和 `AppleGreenColorPredicate`。
- en: 'But how can you make use of the different implementations of `ApplePredicate`?
    You need your `filterApples` method to accept `ApplePredicate` objects to test
    a condition on an `Apple`. This is what *behavior parameterization* means: the
    ability to tell a method to *take* multiple behaviors (or strategies) as parameters
    and use them internally to *accomplish* different behaviors.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何利用 `ApplePredicate` 的不同实现呢？你需要让 `filterApples` 方法接受 `ApplePredicate` 对象来测试
    `Apple` 上的条件。这就是**行为参数化**的含义：告诉方法**接受**多种行为（或策略）作为参数，并在内部使用它们来实现不同的行为。
- en: 'To achieve this in the running example, you add a parameter to the `filterApples`
    method to take an `ApplePredicate` object. This has a great software engineering
    benefit: you can now separate the logic of iterating the collection inside the
    `filter-Apples` method with the behavior you want to apply to each element of
    the collection (in this case a predicate).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行示例中实现这一点，你需要在 `filterApples` 方法中添加一个参数来接受 `ApplePredicate` 对象。这带来了巨大的软件工程效益：你现在可以分离
    `filter-Apples` 方法内部迭代的集合逻辑与应用于集合每个元素的**行为**（在这种情况下是一个谓词）。
- en: '2.2.1\. Fourth attempt: filtering by abstract criteria'
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 第四次尝试：通过抽象标准进行过滤
- en: 'Our modified `filter` method, which uses an `ApplePredicate`, looks like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改后的使用 `ApplePredicate` 的 `filter` 方法看起来是这样的：
- en: '[PRE33]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Predicate `p` encapsulates the condition to test on an apple.**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 判定 `p` 封装了对苹果进行测试的条件。**'
- en: Passing code/behavior
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传递代码/行为
- en: 'It’s worth pausing for a moment for a small celebration. This code is much
    more flexible than our first attempt, but at the same time it’s easy to read and
    to use! You can now create different `ApplePredicate` objects and pass them to
    the `filterApples` method. Free flexibility! For example, if the farmer asks you
    to find all red apples that are heavier than 150 g, all you need to do is create
    a class that implements the `ApplePredicate` accordingly. Your code is now flexible
    enough for any change of requirements involving the attributes of `Apple`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 值得停下来稍作庆祝。这段代码比我们的第一次尝试更加灵活，但同时也易于阅读和使用！你现在可以创建不同的 `ApplePredicate` 对象并将它们传递给
    `filterApples` 方法。自由灵活性！例如，如果农民要求你找到所有重量超过 150 克的红苹果，你所需要做的就是创建一个实现了 `ApplePredicate`
    的类。你的代码现在足够灵活，可以应对任何涉及 `Apple` 属性的要求变化：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You’ve achieved something cool; the behavior of the `filterApples` method depends
    on the *code you pass* to it via the `ApplePredicate` object. You’ve parameterized
    the behavior of the `filterApples` method!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经实现了一些酷炫的功能；`filterApples` 方法的**行为**取决于你通过 `ApplePredicate` 对象传递给它的**代码**。你已经参数化了
    `filterApples` 方法的**行为**！
- en: Note that in the previous example, the only code that matters is the implementation
    of the `test` method, as illustrated in [figure 2.2](#ch02fig02); this is what
    defines the new behaviors for the `filterApples` method. Unfortunately, because
    the `filterApples` method can only take objects, you have to wrap that code inside
    an `ApplePredicate` object. What you’re doing is similar to passing code inline,
    because you’re passing a `boolean` expression through an object that implements
    the `test` method. You’ll see in [section 2.3](#ch02lev1sec3) (and in more detail
    in [chapter 3](kindle_split_013.xhtml#ch03)) that by using lambdas, you can directly
    pass the expression `RED.equals(apple.getColor()) && apple.getWeight() > 150`
    to the `filterApples` method without having to define multiple `ApplePredicate`
    classes. This removes unnecessary verbosity.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，唯一重要的代码是`test`方法的实现，如图2.2所示；这是定义`filterApples`方法新行为的地方。不幸的是，因为`filterApples`方法只能接受对象，你必须将这段代码包裹在一个`ApplePredicate`对象中。你所做的是类似于内联传递代码，因为你通过实现`test`方法的对象传递了一个`boolean`表达式。你将在第2.3节（以及在第3章中更详细地）看到，通过使用lambda表达式，你可以直接将表达式`RED.equals(apple.getColor())
    && apple.getWeight() > 150`传递给`filterApples`方法，而无需定义多个`ApplePredicate`类。这减少了不必要的冗余。
- en: Figure 2.2\. Parameterizing the behavior of `filterApples` and passing different
    filter strategies
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 参数化`filterApples`的行为并传递不同的过滤策略
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig02_alt.jpg)'
- en: Multiple behaviors, one parameter
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多种行为，一个参数
- en: As we explained earlier, behavior parameterization is great because it enables
    you to separate the logic of iterating the collection to filter and the behavior
    to apply on each element of that collection. As a consequence, you can reuse the
    same method and give it different behaviors to achieve different things, as illustrated
    in [figure 2.3](#ch02fig03). This is why *behavior parameterization* is a useful
    concept you should have in your toolset for creating flexible APIs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所解释的，行为参数化非常出色，因为它允许你将迭代集合以进行过滤的逻辑与应用于该集合每个元素的行为分开。因此，你可以重用相同的方法，并给它赋予不同的行为以实现不同的功能，如图2.3所示。这就是为什么*行为参数化*是一个你应该在你的工具集中拥有的有用概念，用于创建灵活的API。
- en: Figure 2.3\. Parameterizing the behavior of `filterApples` and passing different
    filter strategies
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 参数化`filterApples`的行为并传递不同的过滤策略
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: To make sure you feel comfortable with the idea of behavior parameterization,
    try to do quiz 2.1!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你对行为参数化的概念感到舒适，尝试做练习2.1！
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 2.1: Write a flexible `prettyPrintApple` method**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习2.1：编写一个灵活的`prettyPrintApple`方法**'
- en: 'Write a `prettyPrintApple` method that takes a `List` of `Apple`s and that
    can be parameterized with multiple ways to generate a `String` output from an
    `apple` (a bit like multiple customized `toString` methods). For example, you
    could tell your `pretty-PrintApple` method to print only the weight of each apple.
    In addition, you could tell your `prettyPrintApple` method to print each apple
    individually and mention whether it’s heavy or light. The solution is similar
    to the filtering examples we’ve explored so far. To help you get started, we provide
    a rough skeleton of the `pretty-PrintApple` method:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`prettyPrintApple`方法，它接受一个`Apple`的`List`，并且可以通过多种方式参数化，从`apple`生成一个`String`输出（有点像多个定制的`toString`方法）。例如，你可以告诉你的`pretty-PrintApple`方法只打印每个苹果的重量。此外，你可以告诉你的`prettyPrintApple`方法逐个打印每个苹果，并说明它是重还是轻。解决方案与我们已经探索过的过滤示例类似。为了帮助你开始，我们提供了一个`pretty-PrintApple`方法的粗略框架：
- en: '[PRE35]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Answer:**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'First, you need a way to represent a behavior that takes an `Apple` and returns
    a formatted `String` result. You did something similar when you created an `Apple-Predicate`
    interface:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一种方式来表示一个接受`Apple`并返回格式化`String`结果的行为。你在创建`Apple-Predicate`接口时做过类似的事情：
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can now represent multiple formatting behaviors by implementing the `Apple-Formatter`
    interface:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过实现`Apple-Formatter`接口来表示多个格式化行为：
- en: '[PRE37]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, you need to tell your `prettyPrintApple` method to take `AppleFormatter`
    objects and use them internally. You can do this by adding a parameter to `pretty-PrintApple`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要告诉你的`prettyPrintApple`方法接受`AppleFormatter`对象并内部使用它们。你可以通过向`pretty-PrintApple`添加一个参数来实现这一点：
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Bingo! You’re now able to pass multiple behaviors to your `prettyPrintApple`
    method. You do this by instantiating implementations of `AppleFormatter` and giving
    them as arguments to `prettyPrintApple`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Bingo！你现在能够将多个行为传递给 `prettyPrintApple` 方法。你是通过实例化 `AppleFormatter` 的实现并将它们作为参数传递给
    `prettyPrintApple` 来做到这一点的：
- en: '[PRE39]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will produce an output along the lines of
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下输出的结果
- en: '[PRE40]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or try this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者试试这个：
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will produce an output along the lines of
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下输出的结果
- en: '[PRE42]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve seen that you can abstract over behavior and make your code adapt to
    requirement changes, but the process is verbose because you need to declare multiple
    classes that you instantiate only once. Let’s see how to improve that.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你可以抽象行为并使你的代码适应需求变化，但这个过程很冗长，因为你需要声明多个你只实例化一次的类。让我们看看如何改进这一点。
- en: 2.3\. Tackling verbosity
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 解决冗余
- en: We all know that a feature or concept that’s cumbersome to use will be avoided.
    At the moment, when you want to pass new behavior to your `filterApples` method,
    you’re forced to declare several classes that implement the `ApplePredicate` interface
    and then instantiate several `ApplePredicate` objects that you allocate only once,
    as shown in the following listing that summarizes what you’ve seen so far. There’s
    a lot of verbosity involved and it’s a time-consuming process!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，使用起来不方便的功能或概念会被避免。目前，当你想要将新行为传递给 `filterApples` 方法时，你必须声明几个实现 `ApplePredicate`
    接口的类，然后实例化几个你只分配一次的 `ApplePredicate` 对象，如下列所示，总结了到目前为止你所看到的。这涉及到很多冗余，并且是一个耗时过程！
- en: 'Listing 2.1\. Behavior parameterization: filtering apples with predicates'
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. 行为参数化：使用谓词过滤苹果
- en: '[PRE43]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Selects heavy apples**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择重苹果**'
- en: '***2* Selects green apples**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 选择绿色苹果**'
- en: '***3* Results in a List containing one Apple of 155 g**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 结果是一个包含一个155克苹果的列表**'
- en: '***4* Results in a List containing two green Apples**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 结果是一个包含两个绿色苹果的列表**'
- en: This is unnecessary overhead. Can you do better? Java has mechanisms called
    *anonymous classes*, which let you declare and instantiate a class at the same
    time. They enable you to improve your code one step further by making it a little
    more concise. But they’re not entirely satisfactory. [Section 2.3.3](#ch02lev2sec7)
    anticipates the next chapter with a short preview of how lambda expressions can
    make your code more readable.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不必要的开销。你能做得更好吗？Java有称为 *匿名类* 的机制，它允许你同时声明和实例化一个类。它们使你能够通过使代码更加简洁来进一步提高你的代码。但它们并不完全令人满意。[第2.3.3节](#ch02lev2sec7)
    预览了下一章，简要介绍了lambda表达式如何使你的代码更易读。
- en: 2.3.1\. Anonymous classes
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 匿名类
- en: '*Anonymous classes* are like the local classes (a class defined in a block)
    that you’re already familiar with in Java. But anonymous classes don’t have a
    name. They allow you to declare and instantiate a class at the same time. In short,
    they allow you to create ad hoc implementations.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名类* 就像你在Java中已经熟悉的局部类（在代码块中定义的类）。但匿名类没有名字。它们允许你同时声明和实例化一个类。简而言之，它们允许你创建临时的实现。'
- en: '2.3.2\. Fifth attempt: using an anonymous class'
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 第五次尝试：使用匿名类
- en: 'The following code shows how to rewrite the filtering example by creating an
    object that implements `ApplePredicate` using an anonymous class:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何通过创建一个实现 `ApplePredicate` 的对象来使用匿名类重写过滤示例：
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Parameterizes the behavior of the method filterApples with an anonymous
    class.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用匿名类参数化方法 filterApples 的行为。**'
- en: 'Anonymous classes are often used in the context of GUI applications to create
    event-handler objects. We don’t want to bring back painful memories of Swing,
    but the following is a common pattern that you see in practice (here using the
    JavaFX API, a modern UI platform for Java):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类常用于GUI应用程序的上下文中，用于创建事件处理对象。我们不想唤起Swing的痛苦记忆，但以下是在实践中常见的模式（这里使用JavaFX API，Java的现代UI平台）：
- en: '[PRE45]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But anonymous classes are still not good enough. First, they tend to be bulky
    because they take a lot of space, as shown in the boldface code here using the
    same two examples used previously:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 但匿名类仍然不够好。首先，它们往往很庞大，因为它们占用了很多空间，正如这里使用加粗的代码所展示的，使用了之前相同的两个示例：
- en: '[PRE46]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Lots of boilerplate code**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 大量样板代码**'
- en: Second, many programmers find them confusing to use. For example, quiz 2.2 shows
    a classic Java puzzler that catches most programmers off guard! Try your hand
    at it.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，许多程序员发现它们难以使用。例如，练习2.2展示了一个经典的Java难题，它会让大多数程序员措手不及！试试你的手。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 2.2: Anonymous class puzzler**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2.2：匿名类难题**'
- en: 'What will the output be when this code is executed: `4`, `5`, `6`, or `42`?'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码执行时，输出将会是 `4`、`5`、`6` 还是 `42`？
- en: '[PRE47]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* What’s the output of this line?**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这行代码的输出是什么？**'
- en: '**Answer:**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: The answer is `5`, because `this` refers to the enclosing `Runnable`, not the
    enclosing class `MeaningOfThis`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 `5`，因为 `this` 指的是封装的 `Runnable`，而不是封装的类 `MeaningOfThis`。
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Verbosity in general is bad; it discourages the use of a language feature because
    it takes a long time to write and maintain verbose code, and it’s not pleasant
    to read! Good code should be easy to comprehend at a glance. Even though anonymous
    classes somewhat tackle the verbosity associated with declaring multiple concrete
    classes for an interface, they’re still unsatisfactory. In the context of passing
    a simple piece of code (for example, a `boolean` expression representing a selection
    criterion), you still have to create an object and explicitly implement a method
    to define a new behavior (for example, the method `test` for `Predicate` or the
    method `handle` for `EventHandler`).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，冗长性是坏事；它因为编写和维护冗长的代码需要很长时间，而且阅读起来不愉快，所以会阻碍语言特性的使用！好的代码应该一眼就能理解。尽管匿名类在一定程度上解决了为接口声明多个具体类所关联的冗长性，但它们仍然不尽如人意。在传递简单代码片段（例如，表示选择标准的
    `boolean` 表达式）的上下文中，你仍然需要创建一个对象并显式实现一个方法来定义新的行为（例如，`Predicate` 的 `test` 方法或 `EventHandler`
    的 `handle` 方法）。
- en: Ideally we’d like to encourage programmers to use the behavior parameterization
    pattern, because as you’ve just seen, it makes your code more adaptive to requirement
    changes. In [chapter 3](kindle_split_013.xhtml#ch03), you’ll see that the Java
    8 language designers solved this problem by introducing lambda expressions, a
    more concise way to pass code. Enough suspense; here’s a short preview of how
    lambda expressions can help you in your quest for clean code.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望鼓励程序员使用行为参数化模式，因为正如你所看到的，它使你的代码更能适应需求变化。在[第 3 章](kindle_split_013.xhtml#ch03)中，你将看到
    Java 8 语言设计者通过引入 lambda 表达式，一种更简洁的传递代码的方式，解决了这个问题。悬念已经足够；以下是对 lambda 表达式如何帮助你追求干净代码的简要预览。
- en: '2.3.3\. Sixth attempt: using a lambda expression'
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 第六次尝试：使用 lambda 表达式
- en: 'The previous code can be rewritten as follows in Java 8 using a lambda expression:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可以用以下方式在 Java 8 中使用 lambda 表达式重写：
- en: '[PRE48]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You have to admit this code looks a lot cleaner than our previous attempts!
    It’s great because it’s starting to look a lot closer to the problem statement.
    We’ve now tackled the verbosity issue. [Figure 2.4](#ch02fig04) summarizes our
    journey so far.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须承认，这段代码看起来比我们之前的尝试干净得多！它很棒，因为它开始看起来与问题陈述非常接近。我们现在已经解决了冗长性问题。[图 2.4](#ch02fig04)
    总结了到目前为止的旅程。
- en: Figure 2.4\. Behavior parameterization versus value parameterization
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4\. 行为参数化与值参数化
- en: '![](Images/02fig04_alt.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig04_alt.jpg)'
- en: '2.3.4\. Seventh attempt: abstracting over List type'
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4\. 第七次尝试：在 List 类型上抽象
- en: 'There’s one more step that you can do in your journey toward abstraction. At
    the moment, the `filterApples` method works only for `Apple`. But you can also
    abstract on the `List` type to go beyond the problem domain you’re thinking of,
    as shown:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在你向抽象化迈进的过程中，你还可以做一步。目前，`filterApples` 方法只适用于 `Apple`。但你也可以对 `List` 类型进行抽象，从而超越你思考的问题域，如下所示：
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Introduces a type parameter T**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引入类型参数 T**'
- en: 'You can now use the method `filter` with a `List` of bananas, oranges, `Integer`s,
    or `String`s! Here’s an example, using lambda expressions:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用 `filter` 方法与香蕉、橙子、`Integer` 或 `String` 的 `List`！以下是一个使用 lambda 表达式的示例：
- en: '[PRE50]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Isn’t it cool? You’ve managed to find the sweet spot between flexibility and
    conciseness, which wasn’t possible prior to Java 8!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这不酷吗？你成功地找到了灵活性和简洁性之间的甜点，这在 Java 8 之前是不可能的！
- en: 2.4\. Real-world examples
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 现实世界示例
- en: 'You’ve now seen that behavior parameterization is a useful pattern to easily
    adapt to changing requirements. This pattern lets you encapsulate a behavior (a
    piece of code) and parameterize the behavior of methods by passing and using these
    behaviors you create (for example, different predicates for an `Apple`). We mentioned
    earlier that this approach is similar to the strategy design pattern. You may
    have already used this pattern in practice. Many methods in the Java API can be
    parameterized with different behaviors. These methods are often used together
    with anonymous classes. We show four examples, which should solidify the idea
    of passing code for you: sorting with a `Comparator`, executing a block of code
    with `Runnable`, returning a result from a task using `Callable`, and GUI event
    handling.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到，行为参数化是一种有用的模式，可以轻松适应不断变化的需求。此模式允许你封装一个行为（一段代码），并通过传递和使用你创建的行为（例如，为`Apple`的不同谓词）来参数化方法的行为。我们之前提到，这种方法类似于策略设计模式。你可能已经在实践中使用过这种模式。Java
    API中的许多方法可以用不同的行为进行参数化。这些方法通常与匿名类一起使用。我们展示了四个示例，这些示例应该会巩固你传递代码的想法：使用`Comparator`进行排序、使用`Runnable`执行代码块、使用`Callable`从任务返回结果以及GUI事件处理。
- en: 2.4.1\. Sorting with a Comparator
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 使用Comparator进行排序
- en: Sorting a collection is a recurring programming task. For example, say your
    farmer wants you to sort the inventory of apples based on their weight. Or perhaps
    he changes his mind and wants you to sort the apples by color. Sound familiar?
    Yes, you need a way to represent and use different sorting behaviors to easily
    adapt to changing requirements.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 对集合进行排序是一个常见的编程任务。例如，假设你的农民想要你根据苹果的重量对库存进行排序。或者，也许他改变了主意，想要你按颜色对苹果进行排序。听起来熟悉吗？是的，你需要一种方式来表示和使用不同的排序行为，以便轻松适应不断变化的需求。
- en: 'From Java 8, a `List` comes with a `sort` method (you could also use `Collections.sort`).
    The behavior of `sort` can be parameterized using a `java.util.Comparator` object,
    which has the following interface:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8开始，`List`自带了一个`sort`方法（你也可以使用`Collections.sort`）。`sort`的行为可以使用`java.util.Comparator`对象进行参数化，该对象具有以下接口：
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can therefore create different behaviors for the `sort` method by creating
    an ad hoc implementation of `Comparator`. For example, you can use it to sort
    the inventory by increasing weight using an anonymous class:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以通过创建一个专门实现的`Comparator`来为`sort`方法创建不同的行为。例如，你可以使用它来按增加的重量对库存进行排序，使用匿名类：
- en: '[PRE52]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the farmer changes his mind about how to sort apples, you can create an
    ad hoc `Comparator` to match the new requirement and pass it to the `sort` method.
    The internal details of how to sort are abstracted away. With a lambda expression
    it would look like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果农民改变了他对如何排序苹果的想法，你可以创建一个专门匹配新要求的`Comparator`并将其传递给`sort`方法。如何排序的内部细节被抽象掉了。使用lambda表达式，它将如下所示：
- en: '[PRE53]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Again, don’t worry about this new syntax for now; the next chapter covers in
    detail how to write and use lambda expressions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，现在不必担心这个新的语法；下一章将详细介绍如何编写和使用lambda表达式。
- en: 2.4.2\. Executing a block of code with Runnable
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 使用Runnable执行代码块
- en: Java *threads* allow a block of code to be executed concurrently with the rest
    of the program. But how can you tell a thread what block of code it should run?
    Several threads may each run different code. What you need is a way to represent
    a piece of code to be executed later. Until Java 8, only objects could be passed
    to the `Thread` constructor, so the typical clumsy usage pattern was to pass an
    anonymous class containing a `run` method that returns `void` (no result). Such
    anonymous classes implement the `Runnable` interface.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Java *线程*允许代码块与程序的其他部分并发执行。但你怎么告诉一个线程它应该运行哪个代码块？可能有几个线程各自运行不同的代码。你需要一种方式来表示稍后要执行的代码。在Java
    8之前，只能将对象传递给`Thread`构造函数，因此典型的笨拙使用模式是将包含返回`void`（无结果）的`run`方法的匿名类传递给`Thread`构造函数。这样的匿名类实现了`Runnable`接口。
- en: 'In Java, you can use the `Runnable` interface to represent a block of code
    to be executed; note that the code returns `void` (no result):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，你可以使用`Runnable`接口来表示要执行的代码块；请注意，代码返回`void`（无结果）：
- en: '[PRE54]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can use this interface to create threads with your choice of behavior,
    as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此接口创建具有你选择的行为的线程，如下所示：
- en: '[PRE55]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But since Java 8 you can use a lambda expression, so the call to `Thread` would
    look like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 但自从Java 8以来，你可以使用lambda表达式，因此对`Thread`的调用将如下所示：
- en: '[PRE56]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 2.4.3\. Returning a result using Callable
  id: totrans-394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3\. 使用Callable返回结果
- en: 'You may be familiar with the `ExecutorService` abstraction that was introduced
    in Java 5\. The `ExecutorService` interface decouples how tasks are submitted
    and executed. What’s useful in comparison to using threads and `Runnable` is that
    by using an `Executor-Service` you can send a task to a pool of threads and have
    its result stored in a `Future`. Don’t worry if this is unfamiliar, we will revisit
    this topic in later chapters when we discuss concurrency in more detail. For now,
    all you need to know is that the `Callable` interface is used to model a task
    that returns a result. You can see it as an upgraded `Runnable`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉Java 5中引入的`ExecutorService`抽象。与使用线程和`Runnable`相比，`ExecutorService`接口解耦了任务提交和执行的方式。与使用线程和`Runnable`相比，`ExecutorService`的好处是，通过使用`ExecutorService`，你可以将任务发送到线程池，并将结果存储在`Future`中。不用担心这对你来说不熟悉，我们将在后续章节中详细讨论并发时再次回到这个话题。现在，你需要知道的是，`Callable`接口用于模拟返回结果的任务。你可以将其视为升级版的`Runnable`：
- en: '[PRE57]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can use it, as follows, by submitting a task to an executor service. Here
    you return the name of the `Thread` that is responsible for executing the task:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提交任务到执行服务来使用它。在这里，你返回负责执行任务的`Thread`的名称：
- en: '[PRE58]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using a lambda expression, this code simplifies to the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式，这段代码可以简化为以下形式：
- en: '[PRE59]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 2.4.4\. GUI event handling
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4. GUI事件处理
- en: 'A typical pattern in GUI programming is to perform an action in response to
    a certain event such as clicking or hovering over text. For example, if the user
    clicks the Send button, you may wish to display a pop up or perhaps log the action
    in a file. Again, you need a way to cope with changes; you should be able to perform
    any response. In JavaFX, you can use an `EventHandler` to represent a response
    to an event by passing it to `setOnAction`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形用户界面编程中，一个典型的模式是在响应某些事件时执行一个动作，例如点击或悬停在文本上。例如，如果用户点击发送按钮，你可能希望显示一个弹出窗口或者记录这个动作到一个文件中。再次强调，你需要一种应对变化的方法；你应该能够执行任何响应。在JavaFX中，你可以使用`EventHandler`通过将其传递给`setOnAction`来表示对事件的响应：
- en: '[PRE60]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, the behavior of the `setOnAction` method is parameterized with `EventHandler`
    objects. With a lambda expression it would look like the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setOnAction`方法的行为通过`EventHandler`对象进行参数化。使用lambda表达式，它看起来如下：
- en: '[PRE61]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Behavior parameterization is the ability for a method to *take* multiple different
    behaviors as parameters and use them internally to *accomplish* different behaviors.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为参数化是方法能够*接受*多种不同的行为作为参数，并在内部使用它们来实现不同的行为的能力。
- en: Behavior parameterization lets you make your code more adaptive to changing
    requirements and saves on engineering efforts in the future.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为参数化使你的代码更能适应不断变化的需求，并在未来节省工程努力。
- en: Passing code is a way to give new behaviors as arguments to a method. But it’s
    verbose prior to Java 8\. Anonymous classes helped a bit before Java 8 to get
    rid of the verbosity associated with declaring multiple concrete classes for an
    interface that are needed only once.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码作为参数传递是一种将新的行为作为参数传递给方法的方式。但在Java 8之前，这种方式比较冗长。匿名类在Java 8之前有所帮助，可以减少为仅需要一次的接口声明多个具体类时的冗长。
- en: The Java API contains many methods that can be parameterized with different
    behaviors, which include sorting, threads, and GUI handling.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java API包含许多可以参数化不同行为的方法，包括排序、线程和GUI处理。
- en: Chapter 3\. Lambda expressions
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章。Lambda表达式
- en: '*This chapter covers*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Lambdas in a nutshell
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，lambda
- en: Where and how to use lambdas
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda的使用位置和方式
- en: The execute-around pattern
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行环绕模式
- en: Functional interfaces, type inference
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式接口，类型推断
- en: Method references
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用
- en: Composing lambdas
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合lambda
- en: In the previous chapter, you saw that passing code with behavior parameterization
    is useful for coping with frequent requirement changes in your code. It lets you
    define a block of code that represents a behavior and then pass it around. You
    can decide to run that block of code when a certain event happens (for example,
    a button click) or at certain points in an algorithm (for example, a predicate
    such as “only apples heavier than 150 g” in the filtering algorithm or the customized
    comparison operation in sorting). In general, using this concept you can write
    code that’s more flexible and reusable.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到使用行为参数化传递代码对于应对代码中频繁的需求变化是有用的。它允许你定义一个表示行为的代码块，然后将其传递。你可以决定在某个事件发生时（例如，按钮点击）或在算法的某些点上（例如，过滤算法中的“只有重量超过
    150 克的苹果”谓词或排序中的自定义比较操作）运行该代码块。一般来说，使用这个概念，你可以编写更灵活和可重用的代码。
- en: 'But you saw that using anonymous classes to represent different behaviors is
    unsatisfying. It’s verbose, which doesn’t encourage programmers to use behavior
    parameterization in practice. In this chapter, we’ll teach you about a new feature
    in Java 8 that tackles this problem: lambda expressions. They let you represent
    a behavior or pass code in a concise way. For now you can think of lambda expressions
    as anonymous functions, methods without declared names, but which can also be
    passed as arguments to a method as you can with an anonymous class.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 但你看到使用匿名类来表示不同的行为是不令人满意的。它很冗长，这并不鼓励程序员在实际中采用行为参数化。在本章中，我们将向你介绍 Java 8 中的一个新特性，它解决了这个问题：lambda
    表达式。它们允许你以简洁的方式表示行为或传递代码。目前你可以将 lambda 表达式视为匿名函数，即没有声明名称的方法，但也可以像匿名类一样将其作为方法参数传递。
- en: We’ll show how to construct them, where to use them, and how you can make your
    code more concise by using them. We also explain some new goodies such as type
    inference and new important interfaces available in the Java 8 API. Finally, we
    introduce method references, a useful new feature that goes hand in hand with
    lambda expressions.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何构建它们，在哪里使用它们，以及如何通过使用它们来使你的代码更简洁。我们还解释了一些新的特性，如类型推断和 Java 8 API 中可用的新的重要接口。最后，我们介绍了方法引用，这是一个与
    lambda 表达式相辅相成的新特性。
- en: This chapter is organized in such a way as to teach you step-by-step how to
    write more concise and flexible code. At the end of this chapter, we bring together
    all the concepts taught into a concrete example; we take the sorting example shown
    in [chapter 2](kindle_split_012.xhtml#ch02) and gradually improve it using lambda
    expressions and method references to make it more concise and readable. This chapter
    is important in itself and also because you’ll use lambdas extensively throughout
    the book.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的组织方式旨在逐步教你如何编写更简洁和灵活的代码。在本章结束时，我们将所有教授的概念结合到一个具体的例子中；我们采用第 2 章中展示的排序示例，并逐步使用
    lambda 表达式和方法引用来改进它，使其更简洁、更易读。本章本身很重要，而且因为你将在整本书中广泛使用 lambda 表达式。
- en: 3.1\. Lambdas in a nutshell
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. Lambda 简述
- en: 'A *lambda expression* can be understood as a concise representation of an anonymous
    function that can be passed around. It doesn’t have a name, but it has a list
    of parameters, a body, a return type, and also possibly a list of exceptions that
    can be thrown. That’s one big definition; let’s break it down:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式*可以理解为一种匿名函数的简洁表示，它可以被传递。它没有名称，但它有一个参数列表、一个主体、一个返回类型，也可能有一个可以抛出的异常列表。这是一个很大的定义；让我们将其分解：'
- en: '***Anonymous*—** We say *anonymous* because it doesn’t have an explicit name
    like a method would normally have; less to write and think about!'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***匿名***—**我们称之为“匿名”，因为它没有像方法那样具有显式的名称；写起来更少，思考起来也更少！'
- en: '***Function*—** We say *function* because a lambda isn’t associated with a
    particular class like a method is. But like a method, a lambda has a list of parameters,
    a body, a return type, and a possible list of exceptions that can be thrown.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数***—**我们称之为“函数”，因为 lambda 并不与特定的类相关联，就像方法一样。但像方法一样，lambda 有一个参数列表、一个主体、一个返回类型，以及可能抛出的异常列表。'
- en: '***Passed around*—** A lambda expression can be passed as argument to a method
    or stored in a variable.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***传递***—**Lambda 表达式可以作为方法参数传递或存储在变量中。'
- en: '***Concise*—** You don’t need to write a lot of boilerplate like you do for
    anonymous classes.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***简洁***—**你不需要像匿名类那样编写很多样板代码。'
- en: If you’re wondering where the term *lambda* comes from, it originates from a
    system developed in academia called *lambda calculus*, which is used to describe
    computations.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道术语*lambda*的来源，它起源于一个在学术界开发的系统，称为*lambda calculus*，用于描述计算。
- en: Why should you care about lambda expressions? You saw in the previous chapter
    that passing code is currently tedious and verbose in Java. Well, good news! Lambdas
    fix this problem; they let you pass code in a concise way. Lambdas technically
    don’t let you do anything that you couldn’t do prior to Java 8\. But you no longer
    have to write clumsy code using anonymous classes to benefit from behavior parameterization!
    Lambda expressions will encourage you to adopt the style of behavior parameterization
    that we described in the previous chapter. The net result is that your code will
    be clearer and more flexible. For example, using a lambda expression you can create
    a custom `Comparator` object in a more concise way.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么应该关注lambda表达式？你在上一章中看到，在Java中传递代码目前既繁琐又冗长。好消息是！Lambdas解决了这个问题；它们让你以简洁的方式传递代码。从技术上讲，Lambdas并没有让你做任何在Java
    8之前做不到的事情。但你不再需要编写使用匿名类的笨拙代码来从行为参数化中受益！Lambda表达式将鼓励你采用我们在上一章中描述的行为参数化风格。最终结果是，你的代码将更加清晰和灵活。例如，使用lambda表达式，你可以以更简洁的方式创建一个自定义的`Comparator`对象。
- en: 'Before:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前：
- en: '[PRE62]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After (with lambda expressions):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用lambda表达式之后：
- en: '[PRE63]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You must admit that the code looks clearer! Don’t worry if all the parts of
    the lambda expression don’t make sense yet; we’ll explain all the pieces soon.
    For now, note that you’re literally passing only the code that’s needed to compare
    two apples using their weight. It looks like you’re passing the body of the method
    `compare`. You’ll learn soon that you can simplify your code even more. We’ll
    explain in the next section exactly where and how you can use lambda expressions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须承认代码看起来更清晰！如果你觉得lambda表达式的所有部分现在还不明白，不用担心；我们很快就会解释所有这些部分。现在，请注意，你实际上只传递了比较两个苹果重量的所需代码。这看起来像是传递了`compare`方法体的内容。你很快就会学到你可以进一步简化你的代码。我们将在下一节中解释你可以在哪里以及如何使用lambda表达式。
- en: 'The lambda we just showed you has three parts, as shown in [figure 3.1](#ch03fig01):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示的lambda有三个部分，如图3.1所示：
- en: Figure 3.1\. A lambda expression is composed of parameters, an arrow, and a
    body.
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. lambda表达式由参数、箭头和体组成。
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig01_alt.jpg)'
- en: '***A list of parameters*—** In this case it mirrors the parameters of the `compare`
    method of a `Comparator`—two `Apple`s.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***参数列表*——** 在这种情况下，它反映了`Comparator`的`compare`方法的参数——两个`Apple`。'
- en: '***An arrow*—** The arrow `->` separates the list of parameters from the body
    of the lambda.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***箭头*——** 箭头`->`将参数列表与lambda体分开。'
- en: '***The body of the lambda*—** Compare two `Apple`s using their weights. The
    expression is considered the lambda’s return value.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***lambda体的内容*——** 使用它们的重量比较两个`Apple`。表达式被认为是lambda的返回值。'
- en: To illustrate further, the following listing shows five examples of valid lambda
    expressions in Java 8.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明，以下列表显示了Java 8中五个有效的lambda表达式示例。
- en: Listing 3.1\. Valid lambda expressions in Java 8
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. Java 8中的有效lambda表达式
- en: '[PRE64]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Takes one parameter of type String and returns an int. It has no return
    statement as return is implied.**'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 接受一个类型为String的参数，并返回一个int。它没有返回语句，因为返回是隐含的。**'
- en: '***2* Takes one parameter of type Apple and returns a boolean (whether the
    apple is heavier than 150 g).**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 接受一个类型为Apple的参数，并返回一个布尔值（苹果是否重于150克）。**'
- en: '***3* Takes two parameters of type int and returns no value (void return).
    Its body contains two statements.**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 接受两个类型为int的参数，不返回任何值（void返回）。它的体包含两个语句。**'
- en: '***4* Takes no parameter and returns the int 42**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不接受任何参数，返回int 42**'
- en: '***5* Takes two parameters of type Apple and returns an int representing the
    comparison of their weights**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 接受两个类型为Apple的参数，并返回一个表示它们重量比较的int**'
- en: This syntax was chosen by the Java language designers because it was well received
    in other languages, such as C# and Scala. JavaScript has a similar syntax. The
    basic syntax of a lambda is either (referred to as an *expression-style* lambda)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法是由Java语言设计者选择的，因为它在其他语言中得到了很好的反响，例如C#和Scala。JavaScript有类似的语法。lambda的基本语法是（称为*表达式式*lambda）
- en: '[PRE65]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: or (note the curly braces for statements, this lambda is often called a *block-style*
    lambda)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 或（注意语句的括号，这种lambda通常被称为*块式*lambda）
- en: '[PRE66]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, lambda expressions follow a simple syntax. Working through quiz
    3.1 should let you know if you understand the pattern.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，lambda表达式遵循简单的语法。通过练习3.1应该会让你知道你是否理解了这个模式。
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.1: Lambda syntax**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习3.1：Lambda语法**'
- en: Based on the syntax rules just shown, which of the following are not valid lambda
    expressions?
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚刚展示的语法规则，以下哪些不是有效的lambda表达式？
- en: '`() -> {}`'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`() -> {}`'
- en: '`() -> "Raoul"`'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`() -> "Raoul"`'
- en: '`() -> { return "Mario"; }`'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`() -> { return "Mario"; }`'
- en: '`(Integer i) -> return "Alan" + i;`'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(Integer i) -> return "Alan" + i;`'
- en: '`(String s) -> { "Iron Man"; }`'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(String s) -> { "Iron Man"; }`'
- en: '**Answer:**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: '4 and 5 are invalid lambdas; the rest are valid. Details:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 4和5不是有效的lambda表达式；其余的都是有效的。详情：
- en: 'This lambda has no parameters and returns `void`. It’s similar to a method
    with an empty body: `public void run() { }`. Fun fact: this is usually called
    the burger lambda. Take a look at it from the side, and you will see it has a
    burger shape with two buns.'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个lambda没有参数，并返回`void`。它类似于一个空体的方法：`public void run() { }`。有趣的事实：这通常被称为汉堡lambda。从侧面看看它，你会发现它有两个面包的形状，像汉堡。
- en: This lambda has no parameters and returns a `String` as an expression.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个lambda没有参数，并返回一个`String`作为表达式。
- en: This lambda has no parameters and returns a `String` (using an explicit return
    statement, within a block).
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个lambda没有参数，并返回一个`String`（使用显式的返回语句，在块中）。
- en: '`return` is a control-flow statement. To make this lambda valid, curly braces
    are required as follows: `(Integer i) -> { return "Alan" + i; }`.'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`return`是一个控制流语句。为了使这个lambda有效，需要花括号，如下所示：`(Integer i) -> { return "Alan" +
    i; }`。'
- en: '“Iron Man” is an expression, not a statement. To make this lambda valid, you
    can remove the curly braces and semicolon as follows: `(String s) -> "Iron Man"`.
    Or if you prefer, you can use an explicit return statement as follows: `(String
    s) -> { return "Iron Man"; }`.'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “钢铁侠”是一个表达式，不是一个语句。为了使这个lambda有效，你可以像下面这样移除花括号和分号：`(String s) -> "Iron Man"`。或者如果你更喜欢，你可以使用显式的返回语句，如下所示：`(String
    s) -> { return "Iron Man"; }`。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 3.1](#ch03table01) This provides a list of example lambdas with examples
    of use cases.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.1](#ch03table01) 这提供了一个带有用例示例的lambda表达式列表。'
- en: Table 3.1\. Examples of lambdas
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.1\. lambda表达式示例
- en: '| Use case | Examples of lambdas |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | lambda表达式示例 |'
- en: '| --- | --- |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A boolean expression | (List<String> list) -> list.isEmpty() |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔表达式 | (List<String> list) -> list.isEmpty() |'
- en: '| Creating objects | () -> new Apple(10) |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 创建对象 | () -> new Apple(10) |'
- en: '| Consuming from an object | (Apple a) -> { System.out.println(a.getWeight());'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从对象中消费 | (Apple a) -> { System.out.println(a.getWeight()); }'
- en: '} |'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '} |'
- en: '| Select/extract from an object | (String s) -> s.length() |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 从对象中选择/提取 | (String s) -> s.length() |'
- en: '| Combine two values | (int a, int b) -> a * b |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 合并两个值 | (int a, int b) -> a * b |'
- en: '| Compare two objects | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
    |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 比较两个对象 | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
    |'
- en: 3.2\. Where and how to use lambdas
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 哪里以及如何使用lambda表达式
- en: 'You may now be wondering where you’re allowed to use lambda expressions. In
    the previous example, you assigned a lambda to a variable of type `Comparator<Apple>`.
    You could also use another lambda with the `filter` method you implemented in
    the previous chapter:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在想知道你可以在哪里使用lambda表达式。在之前的例子中，你将一个lambda赋值给了一个类型为`Comparator<Apple>`的变量。你也可以使用另一个lambda，这是你在上一章中实现的`filter`方法：
- en: '[PRE67]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Where exactly can you use lambdas? You can use a lambda expression in the context
    of a functional interface. In the code shown here, you can pass a lambda as second
    argument to the method `filter` because it expects an object of type `Predicate<T>`,
    which is a functional interface. Don’t worry if this sounds abstract; we’ll now
    explain in detail what this means and what a functional interface is.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 你在哪里可以使用lambda表达式？你可以在函数式接口的上下文中使用lambda表达式。在下面的代码中，你可以将一个lambda作为`filter`方法的第二个参数传递，因为该方法期望一个类型为`Predicate<T>`的对象，这是一个函数式接口。不用担心这听起来很抽象；我们现在将详细解释这意味着什么以及什么是函数式接口。
- en: 3.2.1\. Functional interface
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 函数式接口
- en: 'Remember the interface `Predicate<T>` you created in [chapter 2](kindle_split_012.xhtml#ch02)
    so you could parameterize the behavior of the `filter` method? It’s a functional
    interface! Why? Because `Predicate` specifies only one abstract method:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你在[第2章](kindle_split_012.xhtml#ch02)中创建的`Predicate<T>`接口，以便你可以参数化`filter`方法的行为？它是一个函数式接口！为什么？因为`Predicate`只指定了一个抽象方法：
- en: '[PRE68]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In a nutshell, a *functional interface* is an interface that specifies exactly
    one abstract method. You already know several other functional interfaces in the
    Java API such as `Comparator` and `Runnable`, which we explored in [chapter 2](kindle_split_012.xhtml#ch02):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*功能接口*是一个指定恰好一个抽象方法的接口。你已经在Java API中知道了几个其他功能接口，如`Comparator`和`Runnable`，我们在[第2章](kindle_split_012.xhtml#ch02)中探讨了这些接口：
- en: '[PRE69]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* java.util.Comparator**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* java.util.Comparator**'
- en: '***2* java.lang.Runnable**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* java.lang.Runnable**'
- en: '***3* java.awt.event.ActionListener**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* java.awt.event.ActionListener**'
- en: '***4* java.util.concurrent.Callable**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* java.util.concurrent.Callable**'
- en: '***5* java.security.PrivilegedAction**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* java.security.PrivilegedAction**'
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see in [chapter 13](kindle_split_026.xhtml#ch13) that interfaces can
    now also have *default methods* (a method with a body that provides some default
    implementation for a method in case it isn’t implemented by a class). An interface
    is still a functional interface if it has many default methods as long as it specifies
    *only one abstract method*.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在[第13章](kindle_split_026.xhtml#ch13)中看到，接口现在也可以有*默认方法*（一个具有主体并提供某些默认实现的方法，以防类没有实现该方法）。只要它指定*仅一个抽象方法*，接口仍然是功能接口。
- en: '|  |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To check your understanding, quiz 3.2 should let you know if you grasp the concept
    of a functional interface.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验你的理解，练习3.2应该让你知道你是否掌握了功能接口的概念。
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.2: Functional interface**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习3.2：功能接口**'
- en: Which of these interfaces are functional interfaces?
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些接口是功能接口？
- en: '[PRE70]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**Answer:**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: Only `Adder` is a functional interface.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`Adder`是功能接口。
- en: '`SmartAdder` isn’t a functional interface because it specifies two abstract
    methods called `add` (one is inherited from `Adder`).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmartAdder`不是一个功能接口，因为它指定了两个名为`add`的抽象方法（其中一个是从`Adder`继承的）。'
- en: '`Nothing` isn’t a functional interface because it declares no abstract method
    at all.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing`不是一个功能接口，因为它根本不声明任何抽象方法。'
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'What can you do with functional interfaces? Lambda expressions let you provide
    the implementation of the abstract method of a functional interface directly inline
    and *treat the whole expression as an instance of a functional interface* (more
    technically speaking, an instance of a *concrete implementation* of the functional
    interface). You can achieve the same thing with an anonymous inner class, although
    it’s clumsier: you provide an implementation and instantiate it directly inline.
    The following code is valid because `Runnable` is a functional interface defining
    only one abstract method, `run`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用功能接口做什么？Lambda表达式让你可以直接内联提供功能接口的抽象方法实现，并将整个表达式*视为功能接口的一个实例*（更技术地说，是功能接口的一个*具体实现*的实例）。你也可以用匿名内部类实现相同的功能，尽管这样做比较笨拙：你提供实现并直接内联实例化。以下代码是有效的，因为`Runnable`是一个只定义了一个抽象方法`run`的功能接口：
- en: '[PRE71]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Uses a lambda**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Lambda表达式**'
- en: '***2* Uses an anonymous class**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用匿名内部类**'
- en: '***3* Prints “Hello World 1”**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印“Hello World 1”**'
- en: '***4* Prints “Hello World 2”**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印“Hello World 2”**'
- en: '***5* Prints “Hello World 3” with a lambda passed directly**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用Lambda表达式直接传递打印“Hello World 3”**'
- en: 3.2.2\. Function descriptor
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 函数描述符
- en: The signature of the abstract method of the functional interface describes the
    signature of the lambda expression. We call this abstract method a *function descriptor*.
    For example, the `Runnable` interface can be viewed as the signature of a function
    that accepts nothing and returns nothing (`void`) because it has only one abstract
    method called `run`, which accepts nothing and returns nothing (`void`).^([[1](#ch03fn01)])
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 功能接口的抽象方法签名描述了Lambda表达式的签名。我们称这个抽象方法为*函数描述符*。例如，`Runnable`接口可以被视为一个接受无参数并返回无参数（`void`）的函数签名，因为它只有一个名为`run`的抽象方法，它接受无参数并返回无参数（`void`）。^([[1](#ch03fn01)])
- en: ¹
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some languages such as Scala provide explicit type annotations in their type
    system to describe the type of a function (called function types). Java reuses
    existing nominal types provided by functional interfaces and maps them into a
    form of function types behind the scenes.
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些语言，如Scala，在其类型系统中提供显式的类型注解来描述函数的类型（称为函数类型）。Java重用功能接口提供的现有命名类型，并在幕后将它们映射为函数类型的形式。
- en: We use a special notation throughout this chapter to describe the signatures
    of lambdas and functional interfaces. The notation `() -> void` represents a function
    with an empty list of parameters returning `void`. This is exactly what the `Runnable`
    interface represents. As another example, `(Apple, Apple) -> int` denotes a function
    taking two `Apple`s as parameters and returning an `int`. We will provide more
    information about function descriptors in [section 3.4](#ch03lev1sec4) and [table
    3.2](#ch03table02) later in the chapter.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用了特殊的符号来描述lambda表达式和函数式接口的签名。符号`() -> void`表示一个没有参数列表且返回`void`的函数。这正是`Runnable`接口所表示的。作为另一个例子，`(Apple,
    Apple) -> int`表示一个接受两个`Apple`作为参数并返回`int`的函数。我们将在本章后面的[第3.4节](#ch03lev1sec4)和[表3.2](#ch03table02)中提供更多关于函数描述符的信息。
- en: 'You may already be wondering how lambda expressions are type checked. We detail
    how the compiler checks whether a lambda is valid in a given context in [section
    3.5](#ch03lev1sec5). For now, it suffices to understand that a lambda expression
    can be assigned to a variable or passed to a method expecting a functional interface
    as argument, provided the lambda expression has the same signature as the abstract
    method of the functional interface. For instance, in our earlier example, you
    could pass a lambda directly to the `process` method as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在想lambda表达式是如何进行类型检查的。我们将在[第3.5节](#ch03lev1sec5)中详细说明编译器是如何检查一个lambda表达式在特定上下文中是否有效的。现在，只需理解一个lambda表达式可以被赋值给一个变量或者传递给期望一个函数式接口作为参数的方法，前提是这个lambda表达式的签名与函数式接口的抽象方法相同。例如，在我们之前的例子中，你可以直接将一个lambda表达式传递给`process`方法，如下所示：
- en: '[PRE72]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This code when executed will print “This is awesome!!” The lambda expression
    `() -> System.out.println("This is awesome!!")` takes no parameters and returns
    `void`. This is exactly the signature of the `run` method defined in the `Runnable`
    interface.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码执行时，将打印出“这是惊人的！！”这个lambda表达式`() -> System.out.println("This is awesome!!")`不接受任何参数并返回`void`。这正是`Runnable`接口中定义的`run`方法的签名。
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lambdas and void method invocation**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda表达式和void方法调用**'
- en: 'Although this may feel weird, the following lambda expression is valid:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能会感觉有些奇怪，但以下lambda表达式是有效的：
- en: '[PRE73]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After all, `System.out.println` returns `void` so this is clearly not an expression!
    Why don’t we have to enclose the body with curly braces like this?
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`System.out.println`返回`void`，所以这显然不是一个表达式！为什么我们不需要像这样用大括号括起主体呢？
- en: '[PRE74]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It turns out that there’s a special rule for a void method invocation defined
    in the Java Language Specification. You don’t have to enclose a single void method
    invocation in braces.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Java语言规范中定义了一个特殊的规则，用于void方法调用。你不需要将单个void方法调用用大括号括起来。
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may be wondering, “Why can we pass a lambda only where a functional interface
    is expected?” The language designers considered alternative approaches such as
    adding function types (a bit like the special notation we introduced to describe
    the signature of lambda expressions—we’ll revisit this topic in [chapters 20](kindle_split_035.xhtml#ch20)
    and [21](kindle_split_036.xhtml#ch21)) to Java. But they chose this way because
    it fits naturally without increasing the complexity of the language. In addition,
    most Java programmers are already familiar with the idea of an interface with
    a single abstract method (for example, for event handling). However, the most
    important reason is that functional interfaces were already extensively used before
    Java 8\. This means that they provide a nice migration path for using lambda expressions.
    In fact, if you’ve been using functional interfaces such as `Comparator` and `Runnable`
    or even your own interfaces that happen to define only a single abstract method,
    you can now use lambda expressions without changing your APIs. Try quiz 3.3 to
    test your knowledge of where lambdas can be used.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，“为什么我们只能在期望函数式接口的地方传递lambda表达式？”语言设计者考虑了其他方法，例如添加函数类型（有点像我们用来描述lambda表达式签名的特殊符号——我们将在[第20章](kindle_split_035.xhtml#ch20)和[第21章](kindle_split_036.xhtml#ch21)中重新讨论这个话题）到Java中。但他们选择了这种方式，因为它自然地适应了语言，而没有增加语言的复杂性。此外，大多数Java程序员已经熟悉只有一个抽象方法的接口的概念（例如，用于事件处理）。然而，最重要的原因是函数式接口在Java
    8之前已经被广泛使用。这意味着它们为使用lambda表达式提供了一个很好的迁移路径。实际上，如果你一直在使用`Comparator`和`Runnable`这样的函数式接口，或者甚至是你自己的只定义了一个抽象方法的接口，你现在可以使用lambda表达式而不需要更改你的API。尝试练习3.3来测试你对lambda表达式可用位置的了解。
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.3: Where can you use lambdas?**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习3.3：你可以在哪里使用lambda表达式？**'
- en: Which of the following are valid uses of lambda expressions?
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是 lambda 表达式的有效用法？
- en: '[PRE75]'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Answer:**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: Only 1 and 2 are valid.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 1 和 2 是有效的。
- en: The first example is valid because the lambda `() -> {}` has the signature `()
    -> void`, which matches the signature of the abstract method `run` defined in
    `Runnable`. Note that running this code will do nothing because the body of the
    lambda is empty!
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是有效的，因为 lambda 表达式 `() -> {}` 的签名是 `() -> void`，这与在 `Runnable` 中定义的抽象方法
    `run` 的签名相匹配。请注意，运行此代码将不会做任何事情，因为 lambda 表达式的主体是空的！
- en: The second example is also valid. Indeed, the return type of the method `fetch`
    is `Callable<String>`. `Callable<String>` defines a method with the signature
    `() -> String` when `T` is replaced with `String`. Because the lambda `() -> "Tricky
    example ;-)"` has the signature `() -> String`, the lambda can be used in this
    context.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例也是有效的。实际上，方法 `fetch` 的返回类型是 `Callable<String>`。当 `T` 被替换为 `String` 时，`Callable<String>`
    定义了一个具有签名 `() -> String` 的方法。因为 lambda 表达式 `() -> "Tricky example ;-)"` 的签名是 `()
    -> String`，所以这个 lambda 表达式可以用于这个上下文中。
- en: 'The third example is invalid because the lambda expression `(Apple a) -> a.getWeight()`
    has the signature `(Apple) -> Integer`, which is different from the signature
    of the method `test` defined in `Predicate<Apple>: (Apple) -> boolean`.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例是无效的，因为 lambda 表达式 `(Apple a) -> a.getWeight()` 的签名是 `(Apple) -> Integer`，这与在
    `Predicate<Apple>` 中定义的方法 `test` 的签名不同：`(Apple) -> boolean`。
- en: '|  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What about @FunctionalInterface?**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 @FunctionalInterface 呢？**'
- en: If you explore the new Java API, you will notice that functional interfaces
    are *generally* annotated with `@FunctionalInterface.` (We show an extensive list
    in [section 3.4](#ch03lev1sec4), where we explore how to use functional interfaces
    in depth.) This annotation is used to indicate that the interface is intended
    to be a functional interface and is therefore useful for documentation. In addition,
    the compiler will return a meaningful error if you define an interface using the
    `@FunctionalInterface` annotation, and it isn’t a functional interface. For example,
    an error message could be “Multiple non-overriding abstract methods found in interface
    Foo” to indicate that more than one abstract method is available. Note that the
    `@FunctionalInterface` annotation isn’t mandatory, but it’s good practice to use
    it when an interface is designed for that purpose. You can think of it like the
    `@Override` notation to indicate that a method is overridden.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你探索新的 Java API，你会注意到功能接口通常都带有 `@FunctionalInterface.` 注解（我们在 [第 3.4 节](#ch03lev1sec4)
    中展示了详尽的列表，其中我们深入探讨了如何使用功能接口。）这个注解用于指示该接口旨在作为功能接口，因此对文档很有用。此外，如果你使用 `@FunctionalInterface`
    注解定义了一个接口，但该接口不是功能接口，编译器将返回一个有意义的错误。例如，错误信息可能是“接口 Foo 中发现多个非覆盖的抽象方法”，这表明有多个抽象方法可用。请注意，`@FunctionalInterface`
    注解不是强制的，但在设计接口用于此目的时使用它是良好的实践。你可以将其视为表示方法被重写的 `@Override` 注解。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '3.3\. Putting lambdas into practice: the execute-around pattern'
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 将 lambda 表达式应用于实践：执行周围模式
- en: 'Let’s look at an example of how lambdas, together with behavior parameterization,
    can be used in practice to make your code more flexible and concise. A recurrent
    pattern in resource processing (for example, dealing with files or databases)
    is to open a resource, do some processing on it, and then close the resource.
    The setup and cleanup phases are always similar and surround the important code
    doing the processing. This is called the *execute-around* pattern, as illustrated
    in [figure 3.2](#ch03fig02). For example, in the following code, the highlighted
    lines show the boilerplate code required to read one line from a file (note also
    that you use Java 7’s try-with-resources statement, which already simplifies the
    code, because you don’t have to close the resource explicitly):'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 lambda 表达式与行为参数化结合使用的一个示例，如何在实践中使用它们使代码更加灵活和简洁。在资源处理（例如，处理文件或数据库）中，一个常见的模式是打开资源，对其进行一些处理，然后关闭资源。设置和清理阶段总是相似的，并围绕着执行处理的重要代码。这被称为
    *执行周围* 模式，如图 3.2 所示。例如，在下面的代码中，突出显示的行显示了从文件中读取一行所需的样板代码（注意，你还使用了 Java 7 的 try-with-resources
    语句，这已经简化了代码，因为你不需要显式关闭资源）：
- en: Figure 3.2\. Tasks A and B are surrounded by boilerplate code responsible for
    preparation/cleanup.
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2. 任务 A 和 B 被负责准备/清理的样板代码所包围。
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig02_alt.jpg)'
- en: '[PRE78]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* This is the line that does useful work.**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是执行有用工作的行。**'
- en: '3.3.1\. Step 1: Remember behavior parameterization'
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 第 1 步：记住行为参数化
- en: This current code is limited. You can read only the first line of the file.
    What if you’d like to return the first two lines instead or even the word used
    most frequently? Ideally, you’d like to reuse the code doing setup and cleanup
    and tell the `processFile` method to perform different actions on the file. Does
    this sound familiar? Yes, you need to parameterize the behavior of `processFile`.
    You need a way to pass behavior to `processFile` so it can execute different behaviors
    using a `BufferedReader`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这段当前代码有限。您只能读取文件的第一行。如果您想返回前两行，甚至是最常用的单词怎么办？理想情况下，您希望重用设置和清理的代码，并告诉 `processFile`
    方法对文件执行不同的操作。这听起来熟悉吗？是的，您需要参数化 `processFile` 的行为。您需要一种方式将行为传递给 `processFile`，以便它可以使用
    `BufferedReader` 执行不同的行为。
- en: 'Passing behavior is exactly what lambdas are for. What should the new `processFile`
    method look like if you want to read two lines at once? You need a lambda that
    takes a `BufferedReader` and returns a `String`. For example, here’s how to print
    two lines of a `BufferedReader`:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 传递行为正是 lambda 表达式的用途。如果您想一次读取两行，新的 `processFile` 方法应该是什么样子？您需要一个接受 `BufferedReader`
    并返回 `String` 的 lambda 表达式。例如，以下是如何打印 `BufferedReader` 的两行：
- en: '[PRE79]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '3.3.2\. Step 2: Use a functional interface to pass behaviors'
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 第 2 步：使用函数式接口传递行为
- en: 'We explained earlier that lambdas can be used only in the context of a functional
    interface. You need to create one that matches the signature `BufferedReader ->
    String` and that may throw an `IOException`. Let’s call this interface `BufferedReaderProcessor`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前解释过，lambda 表达式只能在函数式接口的上下文中使用。您需要创建一个与签名 `BufferedReader -> String` 匹配的接口，并且可能抛出
    `IOException`。让我们称这个接口为 `BufferedReaderProcessor`：
- en: '[PRE80]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can now use this interface as the argument to your new `processFile` method:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用此接口作为您新 `processFile` 方法的参数：
- en: '[PRE81]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '3.3.3\. Step 3: Execute a behavior!'
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.3\. 第 3 步：执行行为！
- en: 'Any lambdas of the form `BufferedReader -> String` can be passed as arguments,
    because they match the signature of the `process` method defined in the `Buffered-ReaderProcessor`
    interface. You now need only a way to execute the code represented by the lambda
    inside the body of `processFile`. Remember, lambda expressions let you provide
    the implementation of the abstract method of a functional interface directly inline,
    and they *treat the whole expression as an instance of a functional interface*.
    You can therefore call the method `process` on the resulting `BufferedReaderProcessor`
    object inside the `processFile` body to perform the processing:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 任何形式为 `BufferedReader -> String` 的 lambda 表达式都可以作为参数传递，因为它们与 `BufferedReaderProcessor`
    接口中定义的 `process` 方法的签名相匹配。现在您只需要一种方式来执行 lambda 表达式在 `processFile` 方法体中代表的代码。记住，lambda
    表达式允许您直接内联提供函数式接口抽象方法的实现，并且它们 *将整个表达式视为函数式接口的一个实例*。因此，您可以在 `processFile` 方法体内部调用
    `process` 方法来执行处理：
- en: '[PRE82]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Processes the BufferedReader object**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理 BufferedReader 对象**'
- en: '3.3.4\. Step 4: Pass lambdas'
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.4\. 第 4 步：传递 lambda 表达式
- en: You can now reuse the `processFile` method and process files in different ways
    by passing different lambdas.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以重用 `processFile` 方法，并通过传递不同的 lambda 表达式以不同的方式处理文件。
- en: 'The following shows processing one line:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了处理单行的示例：
- en: '[PRE83]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following shows processing two lines:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了处理两行的示例：
- en: '[PRE84]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[Figure 3.3](#ch03fig03) summarizes the four steps taken to make the `processFile`
    method more flexible.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.3](#ch03fig03) 总结了使 `processFile` 方法更灵活所采取的四个步骤。'
- en: Figure 3.3\. Four-step process to apply the execute-around pattern
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. 应用执行环绕模式的四步过程
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig03_alt.jpg)'
- en: We’ve shown how you can make use of functional interfaces to pass lambdas. But
    you had to define your own interfaces. In the next section, we explore new interfaces
    that were added to Java 8 that you can reuse to pass multiple different lambdas.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用函数式接口来传递 lambda 表达式。但您必须定义自己的接口。在下一节中，我们将探讨 Java 8 中添加的新接口，您可以使用这些接口重用来传递多个不同的
    lambda 表达式。
- en: 3.4\. Using functional interfaces
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 使用函数式接口
- en: As you learned in [section 3.2.1](#ch03lev2sec1), a functional interface specifies
    exactly one abstract method. Functional interfaces are useful because the signature
    of the abstract method can describe the signature of a lambda expression. The
    signature of the abstract method of a functional interface is called a *function
    descriptor*. In order to use different lambda expressions, you need a set of functional
    interfaces that can describe common function descriptors. Several functional interfaces
    are already available in the Java API such as `Comparable`, `Runnable`, and `Callable`,
    which you saw in [section 3.2](#ch03lev1sec2).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 [3.2.1 节](#ch03lev2sec1) 中所学，函数式接口指定了恰好一个抽象方法。函数式接口很有用，因为抽象方法的签名可以描述 lambda
    表达式的签名。函数式接口中抽象方法的签名被称为 *函数描述符*。为了使用不同的 lambda 表达式，你需要一组可以描述常见函数描述符的函数式接口。Java
    API 中已经存在几个函数式接口，如 `Comparable`、`Runnable` 和 `Callable`，这些你在 [3.2 节](#ch03lev1sec2)
    中已经看到。
- en: The Java library designers for Java 8 have helped you by introducing several
    new functional interfaces inside the `java.util.function` package. We’ll describe
    the interfaces `Predicate`, `Consumer`, and `Function` next. A more complete list
    is available in [table 3.2](#ch03table02) at the end of this section.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 的库设计者通过在 `java.util.function` 包内引入了几个新的函数式接口来帮助你。接下来我们将描述 `Predicate`、`Consumer`
    和 `Function` 接口。更完整的列表可以在本节末尾的 [表 3.2](#ch03table02) 中找到。
- en: 3.4.1\. Predicate
  id: totrans-583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 断言
- en: The `java.util.function.Predicate<T>` interface defines an abstract method named
    `test` that accepts an object of generic type `T` and returns a `boolean`. It’s
    exactly the same one that you created earlier, but it’s available out of the box!
    You might want to use this interface when you need to represent a boolean expression
    that uses an object of type `T`. For example, you can define a lambda that accepts
    `String` objects, as shown in the following listing.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function.Predicate<T>` 接口定义了一个名为 `test` 的抽象方法，它接受一个泛型类型 `T` 的对象并返回一个
    `boolean`。它与之前你创建的那个完全相同，但它直接可用！当你需要表示使用类型 `T` 的对象的布尔表达式时，你可能想使用这个接口。例如，你可以定义一个接受
    `String` 对象的 lambda，如下所示。'
- en: Listing 3.2\. Working with a `Predicate`
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 使用 `Predicate`
- en: '[PRE85]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you look up the Javadoc specification of the `Predicate` interface, you may
    notice additional methods such as `and` and `or`. Don’t worry about them for now.
    We’ll come back to these in [section 3.8](#ch03lev1sec8).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `Predicate` 接口的 Javadoc 规范，你可能会注意到额外的 `and` 和 `or` 方法。现在不必担心它们。我们将在 [3.8
    节](#ch03lev1sec8) 回到这些内容。
- en: 3.4.2\. Consumer
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. Consumer
- en: The `java.util.function.Consumer<T>` interface defines an abstract method named
    `accept` that takes an object of generic type `T` and returns no result (`void`).
    You might use this interface when you need to access an object of type `T` and
    perform some operations on it. For example, you can use it to create a method
    `forEach`, which takes a list of `Integers` and applies an operation on each element
    of that list. In the following listing, you’ll use this `forEach` method combined
    with a lambda to print all the elements of the list.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function.Consumer<T>` 接口定义了一个名为 `accept` 的抽象方法，它接受一个泛型类型 `T` 的对象并返回无结果（`void`）。当你需要访问类型
    `T` 的对象并对它执行一些操作时，你可能使用这个接口。例如，你可以使用它来创建一个 `forEach` 方法，该方法接受一个 `Integer` 列表并对该列表的每个元素执行操作。在下面的列表中，你将使用这个
    `forEach` 方法结合 lambda 来打印列表中的所有元素。'
- en: Listing 3.3\. Working with a `Consumer`
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 使用 `Consumer`
- en: '[PRE86]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* The lambda is the implementation of the accept method from Consumer.**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Lambda 是 Consumer 接口中 accept 方法的实现。**'
- en: 3.4.3\. Function
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. Function
- en: The `java.util.function.Function<T, R>` interface defines an abstract method
    named `apply` that takes an object of generic type `T` as input and returns an
    object of generic type `R`. You might use this interface when you need to define
    a lambda that maps information from an input object to an output (for example,
    extracting the weight of an apple or mapping a string to its length). In the listing
    that follows, we show how you can use it to create a method `map` to transform
    a list of `String`s into a list of `Integer`s containing the length of each `String`.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function.Function<T, R>` 接口定义了一个名为 `apply` 的抽象方法，它接受一个泛型类型 `T` 的对象作为输入并返回一个泛型类型
    `R` 的对象。当你需要定义一个将信息从输入对象映射到输出（例如，提取苹果的重量或将字符串映射到其长度）的 lambda 时，你可能使用这个接口。在下面的列表中，我们展示了如何使用它来创建一个
    `map` 方法，将 `String` 列表转换为包含每个 `String` 长度的 `Integer` 列表。'
- en: Listing 3.4\. Working with a `Function`
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 使用 `Function`
- en: '[PRE87]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* Implements the apply method of Function**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实现 Function 的 apply 方法**'
- en: Primitive specializations
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原始特化
- en: 'We described three functional interfaces that are generic: `Predicate<T>`,
    `Consumer<T>`, and `Function<T, R>`. There are also functional interfaces that
    are specialized with certain types.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了三个泛型功能接口：`Predicate<T>`、`Consumer<T>`和`Function<T, R>`。还有一些针对特定类型进行了特化的功能接口。
- en: 'To refresh a little: every Java type is either a reference type (for example,
    `Byte`, `Integer`, `Object`, `List`) or a primitive type (for example, `int`,
    `double`, `byte`, `char`). But generic parameters (for example, the `T` in `Consumer<T>`)
    can be bound only to reference types. This is due to how generics are internally
    implemented.^([[2](#ch03fn02)]) As a result, in Java there’s a mechanism to convert
    a primitive type into a corresponding reference type. This mechanism is called
    *boxing*. The opposite approach (converting a reference type into a corresponding
    primitive type) is called *unboxing*. Java also has an *autoboxing* mechanism
    to facilitate the task for programmers: boxing and unboxing operations are done
    automatically. For example, this is why the following code is valid (an `int`
    gets boxed to an `Integer`):'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微回顾一下：每个 Java 类型要么是引用类型（例如，`Byte`、`Integer`、`Object`、`List`），要么是原始类型（例如，`int`、`double`、`byte`、`char`）。但泛型参数（例如，`Consumer<T>`中的`T`）只能绑定到引用类型。这是由于泛型在内部实现的方式。因此，在
    Java 中有一个机制将原始类型转换为相应的引用类型。这个机制称为*装箱*。相反的方法（将引用类型转换为相应的原始类型）称为*拆箱*。Java 还有一个*自动装箱*机制来简化程序员的任务：装箱和拆箱操作是自动完成的。例如，这就是为什么以下代码是有效的（一个`int`被装箱为一个`Integer`）：
- en: ²
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some other languages, such as C#, don’t have this restriction. Other languages,
    such as Scala, have only reference types. We revisit this issue in [chapter 20](kindle_split_035.xhtml#ch20).
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些其他语言，如 C#，没有这种限制。其他语言，如 Scala，只有引用类型。我们将在第 20 章中重新讨论这个问题。[第 20 章](kindle_split_035.xhtml#ch20)。
- en: '[PRE88]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: But this comes with a performance cost. Boxed values are a wrapper around primitive
    types and are stored on the heap. Therefore, boxed values use more memory and
    require additional memory lookups to fetch the wrapped primitive value.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会带来性能成本。装箱值是原始类型的包装，存储在堆上。因此，装箱值使用更多的内存，并且需要额外的内存查找来获取包装的原始值。
- en: 'Java 8 also added a specialized version of the functional interfaces we described
    earlier in order to avoid autoboxing operations when the inputs or outputs are
    primitives. For example, in the following code, using an `IntPredicate` avoids
    a boxing operation of the value `1000`, whereas using a `Predicate<Integer>` would
    box the argument `1000` to an `Integer` object:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 还添加了我们之前描述的功能接口的特化版本，以避免在输入或输出为原始类型时进行自动装箱操作。例如，在以下代码中，使用`IntPredicate`避免了将值`1000`装箱的操作，而使用`Predicate<Integer>`则会将参数`1000`装箱为一个`Integer`对象：
- en: '[PRE89]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* True (no boxing)**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 真的（没有装箱）**'
- en: '***2* False (boxing)**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 假的（装箱）**'
- en: 'In general, the appropriate primitive type precedes the names of functional
    interfaces that have a specialization for the input type parameter (for example,
    `DoublePredicate`, `IntConsumer`, `LongBinaryOperator`, `IntFunction`, and so
    on). The `Function` interface also has variants for the output type parameter:
    `ToIntFunction<T>`, `IntToDoubleFunction`, and so on.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，对于具有针对输入类型参数的特化的功能接口，合适的原始类型会位于其名称之前（例如，`DoublePredicate`、`IntConsumer`、`LongBinaryOperator`、`IntFunction`等）。`Function`接口也有针对输出类型参数的变体：`ToIntFunction<T>`、`IntToDoubleFunction`等。
- en: '[Table 3.2](#ch03table02) summarizes the most commonly used functional interfaces
    available in the Java API and their function descriptors, along with their primitive
    specializations. Keep in mind that these are only a starter kit, and you can always
    create your own if needed (quiz 3.7 invents `TriFunction` for this purpose). Creating
    your own interfaces can also help when a domain-specific name will help with program
    comprehension and maintenance. Remember, the notation `(T, U) -> R` shows how
    to think about a function descriptor. The left side of the arrow is a list representing
    the types of the arguments, and the right side represents the types of the results.
    In this case, it represents a function with two arguments of respectively generic
    type `T` and `U` and that has a return type of `R`.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3.2](#ch03table02) 总结了 Java API 中最常用的功能接口及其函数描述符，以及它们的原始特殊化。请记住，这些只是一个入门套件，如果需要，你总是可以创建自己的（练习
    3.7 为此创造了 `TriFunction`）。创建自己的接口还可以帮助当特定领域的名称有助于程序理解和维护时。记住，符号 `(T, U) -> R` 显示了如何考虑函数描述符。箭头的左侧是一个表示参数类型的列表，右侧表示结果的类型。在这种情况下，它表示一个具有两个参数的函数，分别具有泛型类型
    `T` 和 `U`，并且返回类型为 `R`。'
- en: Table 3.2\. Common functional interfaces added in Java 8
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.2\. Java 8 中添加的常见功能接口
- en: '| Functional interface | Predicate<T> | Consumer<T> |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 功能接口 | Predicate<T> | Consumer<T> |'
- en: '| --- | --- | --- |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Predicate<T> | T -> boolean | IntPredicate, LongPredicate, DoublePredicate
    |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| Predicate<T> | T -> boolean | IntPredicate, LongPredicate, DoublePredicate
    |'
- en: '| Consumer<T> | T -> void | IntConsumer, LongConsumer, DoubleConsumer |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| Consumer<T> | T -> void | IntConsumer, LongConsumer, DoubleConsumer |'
- en: '| Function<T, R> | T -> R | IntFunction<R>, IntToDoubleFunction,'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '| Function<T, R> | T -> R | IntFunction<R>, IntToDoubleFunction,'
- en: IntToLongFunction,
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: IntToLongFunction,
- en: LongFunction<R>,
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: LongFunction<R>,
- en: LongToDoubleFunction,
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: LongToDoubleFunction,
- en: LongToIntFunction,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: LongToIntFunction,
- en: DoubleFunction<R>,
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleFunction<R>,
- en: DoubleToIntFunction,
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleToIntFunction,
- en: DoubleToLongFunction,
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleToLongFunction,
- en: ToIntFunction<T>,
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ToIntFunction<T>,
- en: ToDoubleFunction<T>,
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ToDoubleFunction<T>,
- en: ToLongFunction<T> |
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ToLongFunction<T> |
- en: '| Supplier<T> | () -> T | BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier
    |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| Supplier<T> | () -> T | BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier
    |'
- en: '| UnaryOperator<T> | T -> T | IntUnaryOperator, LongUnaryOperator,'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '| UnaryOperator<T> | T -> T | IntUnaryOperator, LongUnaryOperator,'
- en: DoubleUnaryOperator |
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleUnaryOperator |
- en: '| BinaryOperator<T> | (T, T) -> T | IntBinaryOperator, LongBinaryOperator,'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '| BinaryOperator<T> | (T, T) -> T | IntBinaryOperator, LongBinaryOperator,'
- en: DoubleBinaryOperator |
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleBinaryOperator |
- en: '| BiPredicate<T, U> | (T, U) -> boolean |  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| BiPredicate<T, U> | (T, U) -> boolean |  |'
- en: '| BiConsumer<T, U> | (T, U) -> void | ObjIntConsumer<T>, ObjLongConsumer<T>,'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '| BiConsumer<T, U> | (T, U) -> void | ObjIntConsumer<T>, ObjLongConsumer<T>,'
- en: ObjDoubleConsumer<T> |
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ObjDoubleConsumer<T> |
- en: '| BiFunction<T, U, R> | (T, U) -> R | ToIntBiFunction<T, U>, ToLongBiFunction<T,
    U>,'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '| BiFunction<T, U, R> | (T, U) -> R | ToIntBiFunction<T, U>, ToLongBiFunction<T,
    U>,'
- en: ToDoubleBiFunction<T, U> |
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: ToDoubleBiFunction<T, U> |
- en: You’ve now seen a lot of functional interfaces that can be used to describe
    the signature of various lambda expressions. To check your understanding so far,
    try quiz 3.4.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了许多可以用来描述各种 lambda 表达式签名的功能接口。为了检验你到目前为止的理解，尝试练习 3.4。
- en: '|  |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.4: Functional interfaces**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3.4：功能接口**'
- en: What functional interfaces would you use for the following function descriptors
    (lambda-expression signatures)? You’ll find most of the answers in [table 3.2](#ch03table02).
    As a further exercise, come up with valid lambda expressions that you can use
    with these functional interfaces.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用哪些功能接口来描述以下函数描述符（lambda 表达式签名）？你将在 [表 3.2](#ch03table02) 中找到大部分答案。作为进一步练习，提出可以与这些功能接口一起使用的有效
    lambda 表达式。
- en: '`T -> R`'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T -> R`'
- en: '`(int, int) -> int`'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(int, int) -> int`'
- en: '`T -> void`'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T -> void`'
- en: '`() -> T`'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`() -> T`'
- en: '`(T, U) -> R`'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(T, U) -> R`'
- en: '**Answers:**'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: '`Function<T, R>` is a good candidate. It’s typically used for converting an
    object of type `T` into an object of type `R` (for example, `Function<Apple, Integer>`
    to extract the weight of an apple).'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Function<T, R>` 是一个好的候选者。它通常用于将类型为 `T` 的对象转换为类型为 `R` 的对象（例如，`Function<Apple,
    Integer>` 用于提取苹果的重量）。'
- en: '`IntBinaryOperator` has a single abstract method called `applyAsInt` representing
    a function descriptor `(int, int) -> int`.'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IntBinaryOperator` 有一个名为 `applyAsInt` 的单个抽象方法，表示函数描述符 `(int, int) -> int`。'
- en: '`Consumer<T>` has a single abstract method called `accept` representing a function
    descriptor `T -> void`.'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer<T>` 有一个名为 `accept` 的单个抽象方法，表示函数描述符 `T -> void`。'
- en: '`Supplier<T>` has a single abstract method called `get` representing a function
    descriptor `() -> T`.'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Supplier<T>` 有一个名为 `get` 的单个抽象方法，表示函数描述符 `() -> T`。'
- en: '`BiFunction<T, U, R>` has a single abstract method called `apply` representing
    a function descriptor `(T, U) -> R`.'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BiFunction<T, U, R>` 有一个名为 `apply` 的单个抽象方法，表示函数描述符 `(T, U) -> R`。'
- en: '|  |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To summarize the discussion about functional interfaces and lambdas, [table
    3.3](#ch03table03) provides a summary of use cases, examples of lambdas, and functional
    interfaces that can be used.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结关于功能接口和 Lambda 表达式的讨论，[表 3.3](#ch03table03) 提供了用例、Lambda 表达式示例和可用的功能接口的总结。
- en: Table 3.3\. Examples of lambdas with functional interfaces
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.3\. 使用功能接口的 Lambda 表达式示例
- en: '| Use case | Example of lambda | Matching functional interface |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | Lambda 示例 | 匹配功能接口 |'
- en: '| --- | --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A boolean expression | (List<String> list) -> list.isEmpty() | Predicate<List<String>>
    |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| 一个布尔表达式 | (List<String> list) -> list.isEmpty() | Predicate<List<String>>
    |'
- en: '| Creating objects | () -> new Apple(10) | Supplier<Apple> |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| 创建对象 | () -> new Apple(10) | Supplier<Apple> |'
- en: '| Consuming from an object | (Apple a) -> System.out.println(a.getWeight())
    | Consumer<Apple> |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| 从对象中消费 | (Apple a) -> System.out.println(a.getWeight()) | Consumer<Apple>
    |'
- en: '| Select/extract from an object | (String s) -> s.length() | Function<String,
    Integer> or'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '| 从对象中选择/提取 | (String s) -> s.length() | Function<String, Integer> 或'
- en: ToIntFunction<String> |
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ToIntFunction<String> |
- en: '| Combine two values | (int a, int b) -> a * b | IntBinaryOperator |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| 合并两个值 | (int a, int b) -> a * b | IntBinaryOperator |'
- en: '| Compare two objects | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '| 比较两个对象 | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight'
- en: ()) | Comparator<Apple> or BiFunction<Apple, Apple,
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: ()) | Comparator<Apple> 或 BiFunction<Apple, Apple,
- en: Integer> or
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: Integer> 或
- en: ToIntBiFunction<Apple,
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: ToIntBiFunction<Apple,
- en: Apple> |
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Apple> |
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What about exceptions, lambdas, and functional interfaces?**'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于异常、Lambda 表达式和功能接口，有什么看法？**'
- en: 'Note that none of the functional interfaces allow for a checked exception to
    be thrown. You have two options if you need the body of a lambda expression to
    throw an exception: define your own functional interface that declares the checked
    exception, or wrap the lambda body with a `try/catch` block.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有任何功能接口允许抛出检查异常。如果您需要 Lambda 表达式的主体抛出异常，您有两个选择：定义自己的功能接口以声明检查异常，或者用 `try/catch`
    块包装 Lambda 表达式的主体。
- en: 'For example, in [section 3.3](#ch03lev1sec3) we introduced a new functional
    interface `Buffered-Reader-Processor` that explicitly declared an `IOException`:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第 3.3 节](#ch03lev1sec3)中，我们介绍了一个新的功能接口 `Buffered-Reader-Processor`，该接口明确声明了
    `IOException`：
- en: '[PRE90]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'But you may be using an API that expects a functional interface such as `Function<T,
    R>` and there’s no option to create your own. You’ll see in the next chapter that
    the Streams API makes heavy use of the functional interfaces from [table 3.2](#ch03table02).
    In this case, you can explicitly catch the checked exception:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能正在使用一个期望功能接口（如 `Function<T, R>`）的 API，并且没有创建自己的选项。您将在下一章中看到，Streams API
    严重依赖于[表 3.2](#ch03table02)中的功能接口。在这种情况下，您可以显式捕获检查异常：
- en: '[PRE91]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’ve now seen how to create lambdas and where and how to use them. Next,
    we’ll explain some more advanced details: how lambdas are type checked by the
    compiler and rules you should be aware of, such as lambdas referencing local variables
    inside their body and void-compatible lambdas. There’s no need to fully understand
    the next section right away, and you may wish to come back to it later and move
    on to [section 3.6](#ch03lev1sec6) about method references.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了如何创建 Lambda 表达式以及在哪里如何使用它们。接下来，我们将解释一些更高级的细节：编译器如何检查 Lambda 表达式的类型以及您应该注意的规则，例如
    Lambda 表达式在其主体内部引用局部变量以及与 void 兼容的 Lambda 表达式。您无需立即完全理解下一节，您可能希望稍后返回并继续阅读关于[第
    3.6 节](#ch03lev1sec6)的方法引用。
- en: 3.5\. Type checking, type inference, and restrictions
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 类型检查、类型推断和限制
- en: When we first mentioned lambda expressions, we said that they let you generate
    an instance of a functional interface. Nonetheless, a lambda expression itself
    doesn’t contain the information about which functional interface it’s implementing.
    In order to have a more formal understanding of lambda expressions, you should
    know what the type of a lambda is.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初提到 Lambda 表达式时，我们说它们允许您生成功能接口的一个实例。尽管如此，Lambda 表达式本身并不包含它实现哪个功能接口的信息。为了对
    Lambda 表达式有一个更正式的理解，您应该知道 Lambda 表达式的类型。
- en: 3.5.1\. Type checking
  id: totrans-680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. 类型检查
- en: 'The type of a lambda is deduced from the context in which the lambda is used.
    The type expected for the lambda expression inside the context (for example, a
    method parameter that it’s passed to or a local variable that it’s assigned to)
    is called the *target- type*. Let’s look at an example to see what happens behind
    the scenes when you use a lambda expression. [Figure 3.4](#ch03fig04) summarizes
    the type-checking process for the following code:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 的类型是从 lambda 被使用的上下文中推断出来的。上下文中 lambda 表达式期望的类型（例如，它传递给的方法参数或它被分配到的局部变量）被称为
    *目标类型*。让我们通过一个例子来看看使用 lambda 表达式时幕后发生了什么。[图 3.4](#ch03fig04) 总结了以下代码的类型检查过程：
- en: Figure 3.4\. Deconstructing the type-checking process of a lambda expression
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4\. 解构 lambda 表达式的类型检查过程
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig04_alt.jpg)'
- en: '[PRE92]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The type-checking process is deconstructed as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查过程如下分解：
- en: First, you look up the declaration of the `filter` method.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，查找 `filter` 方法的声明。
- en: Second, it expects, as the second formal parameter, an object of type `Predicate<Apple>`
    (the target type).
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，它期望第二个形式参数是一个 `Predicate<Apple>` 类型的对象（目标类型）。
- en: Third, `Predicate<Apple>` is a functional interface defining a single abstract
    method called `test`.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，`Predicate<Apple>` 是一个定义了单个抽象方法 `test` 的函数式接口。
- en: Fourth, the `test` method describes a function descriptor that accepts an `Apple`
    and returns a `boolean`.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，`test` 方法描述了一个接受 `Apple` 并返回 `boolean` 类型的函数描述符。
- en: Finally, any argument to the `filter` method needs to match this requirement.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，任何传递给 `filter` 方法的参数都需要满足这一要求。
- en: The code is valid because the lambda expression that we’re passing also takes
    an `Apple` as parameter and returns a `boolean`. Note that if the lambda expression
    was throwing an exception, then the declared `throws` clause of the abstract method
    would also have to match.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是有效的，因为传递的 lambda 表达式也接受一个 `Apple` 参数并返回 `boolean`。注意，如果 lambda 表达式抛出异常，则抽象方法的声明
    `throws` 子句也必须匹配。
- en: 3.5.2\. Same lambda, different functional interfaces
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 相同的 lambda，不同的函数式接口
- en: 'Because of the idea of *target typing*, the same lambda expression can be associated
    with different functional interfaces if they have a compatible abstract method
    signature. For example, both interfaces `Callable` and `PrivilegedAction` described
    earlier represent functions that accept nothing and return a generic type `T`.
    The following two assignments are therefore valid:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *目标类型* 的概念，如果不同的函数式接口具有兼容的抽象方法签名，相同的 lambda 表达式可以与不同的函数式接口相关联。例如，前面描述的接口
    `Callable` 和 `PrivilegedAction` 都代表接受无参数并返回泛型类型 `T` 的函数。因此，以下两个赋值是有效的：
- en: '[PRE93]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In this case the first assignment has target type `Callable<Integer>` and the
    second assignment has target type `PrivilegedAction<Integer>`.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，第一个赋值的目标类型为 `Callable<Integer>`，第二个赋值的目标类型为 `PrivilegedAction<Integer>`。
- en: 'In [table 3.3](#ch03table03) we showed a similar example; the same lambda can
    be used with multiple different functional interfaces:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 3.3](#ch03table03) 中，我们展示了类似的例子；相同的 lambda 可以与多个不同的函数式接口一起使用：
- en: '[PRE94]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '|  |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Diamond operator**'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '**菱形运算符**'
- en: 'Those of you who are familiar with Java’s evolution will recall that Java 7
    had already introduced the idea of types being inferred from context with generic
    inference using the diamond operator (`<>`) (this idea can be found even earlier
    with generic methods). A given class-instance expression can appear in two or
    more different contexts, and the appropriate type argument will be inferred as
    exemplified here:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Java 发展历程的各位来说，会记得 Java 7 已经通过使用菱形运算符 (`<>`) 引入了从上下文中推断类型的概念（这个想法在泛型方法中也可以找到）。一个给定的类实例表达式可以出现在两个或更多不同的上下文中，适当类型参数将被推断，如下例所示：
- en: '[PRE95]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Special void-compatibility rule**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊的 void 兼容规则**'
- en: 'If a lambda has a statement expression as its body, it’s compatible with a
    function descriptor that returns `void` (provided the parameter list is compatible,
    too). For example, both of the following lines are legal even though the method
    `add` of a `List` returns a `boolean` and not `void` as expected in the `Consumer`
    context (`T -> void`):'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 lambda 表达式的主体是一个语句表达式，它与返回 `void` 的函数描述符兼容（前提是参数列表也兼容）。例如，以下两行都是合法的，尽管
    `List` 的 `add` 方法返回的是 `boolean` 类型，而不是在 `Consumer` 上下文（`T -> void`）中期望的 `void`
    类型：
- en: '[PRE96]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By now you should have a good understanding of when and where you’re allowed
    to use lambda expressions. They can get their target type from an assignment context,
    method-invocation context (parameters and return), and a cast context. To check
    your knowledge, try quiz 3.5.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经很好地理解了何时何地可以使用 lambda 表达式。它们可以从赋值上下文、方法调用上下文（参数和返回值）以及类型转换上下文中获取目标类型。为了检验你的知识，尝试练习题
    3.5。
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.5: Type checking—why won’t the following code compile?**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习题 3.5：类型检查——为什么以下代码无法编译？**'
- en: How could you fix the problem?
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 你该如何解决这个问题？
- en: '[PRE97]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '**Answer:**'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'The context of the lambda expression is `Object` (the target type). But `Object`
    isn’t a functional interface. To fix this you can change the target type to `Runnable`,
    which represents a function descriptor `() -> void`:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式的上下文是 `Object`（目标类型）。但 `Object` 不是一个功能接口。为了解决这个问题，你可以将目标类型更改为 `Runnable`，它代表函数描述符
    `() -> void`：
- en: '[PRE98]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: You could also fix the problem by casting the lambda expression to `Runnable`,
    which explicitly provides a target type.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将 lambda 表达式转换为 `Runnable` 来解决这个问题，这明确提供了目标类型。
- en: '[PRE99]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This technique can be useful in the context of overloading with a method taking
    two different functional interfaces that have the same function descriptor. You
    can cast the lambda in order to explicitly disambiguate which method signature
    should be selected.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在处理具有相同函数描述符的两个不同功能接口的方法重载的上下文中非常有用。你可以将 lambda 表达式进行类型转换，以明确指定应该选择哪个方法签名。
- en: 'For example, the call `execute(() -> {})` using the method `execute`, as shown
    in the following, would be ambiguous, because both `Runnable` and `Action` have
    the same function descriptor:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下使用 `execute` 方法的 `execute(() -> {})` 调用将是模糊的，因为 `Runnable` 和 `Action` 都具有相同的函数描述符：
- en: '[PRE100]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'But, you can explicitly disambiguate the call by using a cast expression: `execute
    ((Action) () -> {});`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可以通过使用类型转换表达式来明确消除调用歧义：`execute ((Action) () -> {});`
- en: '|  |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’ve seen how the target type can be used to check whether a lambda can be
    used in a particular context. It can also be used to do something slightly different:
    infer the types of the parameters of a lambda.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用目标类型来检查 lambda 是否可以在特定上下文中使用。它还可以用来做稍微不同的事情：推断 lambda 参数的类型。
- en: 3.5.3\. Type inference
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3\. 类型推断
- en: You can simplify your code one step further. The Java compiler deduces what
    functional interface to associate with a lambda expression from its surrounding
    context (the target type), meaning it can also deduce an appropriate signature
    for the lambda because the function descriptor is available through the target
    type. The benefit is that the compiler has access to the types of the parameters
    of a lambda expression, and they can be omitted in the lambda syntax. The Java
    compiler infers the types of the parameters of a lambda as shown here:^([[3](#ch03fn03)])
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步简化你的代码。Java 编译器根据 lambda 表达式周围的上下文（目标类型）推断出与 lambda 表达式关联的功能接口，这意味着它也可以根据目标类型推断出
    lambda 的适当签名。好处是编译器可以访问 lambda 表达式参数的类型，并且可以在 lambda 语法中省略这些类型。Java 编译器推断 lambda
    表达式参数的类型，如下所示：^([[3](#ch03fn03)])
- en: ³
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that when a lambda has a single parameter whose type is inferred, the parentheses
    surrounding the parameter name can also be omitted.
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，当一个 lambda 表达式具有单个参数且其类型被推断时，参数名称周围的括号也可以省略。
- en: '[PRE101]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* No explicit type on the parameter apple**'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 参数 apple 没有显式类型**'
- en: 'The benefits of code readability are more noticeable with lambda expressions
    that have several parameters. For example, here’s how to create a `Comparator`
    object:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 当 lambda 表达式具有多个参数时，代码可读性的好处更为明显。例如，以下是如何创建一个 `Comparator` 对象的示例：
- en: '[PRE102]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '***1* Without type inference**'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 没有类型推断**'
- en: '***2* With type inference**'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 带类型推断**'
- en: Note that sometimes it’s more readable to include the types explicitly, and
    sometimes it’s more readable to exclude them. There’s no rule for which way is
    better; developers must make their own choices about what makes their code more
    readable.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时明确包含类型可以使代码更易读，有时省略类型可以使代码更易读。没有规则说明哪种方式更好；开发者必须根据自己的判断来决定哪种方式能使他们的代码更易读。
- en: 3.5.4\. Using local variables
  id: totrans-736
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.4\. 使用局部变量
- en: 'All the lambda expressions we’ve shown so far used only their arguments inside
    their body. But lambda expressions are also allowed to use *free variables* (variables
    that aren’t the parameters and are defined in an outer scope) like anonymous classes
    can. They’re called *capturing lambdas.* For example, the following lambda captures
    the variable `portNumber`:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示的所有lambda表达式在其体内只使用了它们的参数。但是，lambda表达式也可以像匿名类一样使用*自由变量*（不是参数，而是在外部作用域中定义的变量）。它们被称为*捕获lambda*。例如，以下lambda捕获了变量`portNumber`：
- en: '[PRE103]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Nonetheless, there’s a small twist. There are some restrictions on what you
    can do with these variables. Lambdas are allowed to capture (to reference in their
    bodies) instance variables and static variables without restrictions. But when
    local variables are captured, they have to be explicitly declared `final` or be
    effectively `final`. Lambda expressions can capture local variables that are assigned
    to only once. (Note: capturing an instance variable can be seen as capturing the
    final local variable `this`.) For example, the following code doesn’t compile
    because the variable `portNumber` is assigned to twice:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一些小的变化。对这些变量可以做什么有一些限制。Lambda允许无限制地捕获（在其体内引用）实例变量和静态变量。但是，当捕获本地变量时，它们必须显式声明为`final`或实际上是`final`。Lambda表达式可以捕获只被分配一次的本地变量。（注意：捕获实例变量可以看作是捕获了最终的本地变量`this`。）例如，以下代码无法编译，因为变量`portNumber`被分配了两次：
- en: '[PRE104]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '***1* Error: local variable portNumber is not final or effectively final.**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：本地变量portNumber不是final或实际上是final。**'
- en: Restrictions on local variables
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地变量的限制
- en: You may be asking yourself why local variables have these restrictions. First,
    there’s a key difference in how instance and local variables are implemented behind
    the scenes. Instance variables are stored on the heap, whereas local variables
    live on the stack. If a lambda could access the local variable directly and the
    lambda was used in a thread, then the thread using the lambda could try to access
    the variable after the thread that allocated the variable had deallocated it.
    Hence, Java implements access to a free local variable as access to a copy of
    it, rather than access to the original variable. This makes no difference if the
    local variable is assigned to only once—hence the restriction.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己在想，为什么本地变量会有这些限制。首先，在幕后实现实例变量和本地变量之间存在一个关键的区别。实例变量存储在堆上，而本地变量则存在于栈上。如果lambda可以直接访问本地变量，并且lambda被用在线程中，那么使用lambda的线程可能会在分配变量的线程释放变量之后尝试访问该变量。因此，Java通过访问其副本而不是原始变量来实现对空闲本地变量的访问。如果本地变量只被分配一次，这并不会造成任何区别——这就是限制的原因。
- en: Second, this restriction also discourages typical imperative programming patterns
    (which, as we explain in later chapters, prevent easy parallelization) that mutate
    an outer variable.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这个限制也阻止了典型的命令式编程模式（正如我们在后面的章节中解释的，这些模式阻止了轻松的并行化），这些模式会修改外部变量。
- en: '|  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Closure**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包**'
- en: 'You may have heard of the term *closure* and may be wondering whether lambdas
    meet the definition of a closure (not to be confused with the Clojure programming
    language). To put it scientifically, a *closure* is an instance of a function
    that can reference nonlocal variables of that function with no restrictions. For
    example, a closure could be passed as argument to another function. It could also
    *access and modify* variables defined outside its scope. Now, Java 8 lambdas and
    anonymous classes do something similar to closures: they can be passed as argument
    to methods and can access variables outside their scope. But they have a restriction:
    they can’t modify the content of local variables of a method in which the lambda
    is defined. Those variables have to be implicitly final. It helps to think that
    lambdas close over *values* rather than *variables*. As explained previously,
    this restriction exists because local variables live on the stack and are implicitly
    confined to the thread they’re in. Allowing capture of mutable local variables
    opens new thread-unsafe possibilities, which are undesirable (instance variables
    are fine because they live on the heap, which is shared across threads).'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过“闭包”这个术语，也许正在想lambda是否满足闭包的定义（不要与Clojure编程语言混淆）。从科学的角度来说，一个“闭包”是一个函数的实例，它可以无限制地引用该函数的非局部变量。例如，闭包可以作为另一个函数的参数传递。它还可以*访问和修改*其作用域之外定义的变量。现在，Java
    8的lambda和匿名类与闭包有类似的行为：它们可以作为方法的参数传递，并且可以访问其作用域之外的变量。但是，它们有一个限制：它们不能修改lambda定义的方法中局部变量的内容。这些变量必须是隐式final的。有助于思考的是，lambda是封闭于*值*而不是*变量*。如前所述，这个限制存在是因为局部变量存在于栈上，并且隐式地限制在它们所在的线程中。允许捕获可变局部变量会打开新的线程不安全可能性，这是不希望的（实例变量是可以的，因为它们存在于堆上，堆是线程间共享的）。
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'We’ll now describe another great feature that was introduced in Java 8 code:
    *method references*. Think of them as shorthand versions of certain lambdas.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将描述Java 8代码中引入的另一个伟大特性：*方法引用*。把它们看作是某些lambda的简写版本。
- en: 3.6\. Method references
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 方法引用
- en: Method references let you reuse existing method definitions and pass them like
    lambdas. In some cases they appear more readable and feel more natural than using
    lambda expressions. Here’s our sorting example written with a method reference
    and a bit of help from the updated Java 8 API (we explore this example in more
    detail in [section 3.7](#ch03lev1sec7)).
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用允许你重用现有的方法定义，并将它们像lambda一样传递。在某些情况下，它们比使用lambda表达式更易于阅读，感觉更自然。以下是我们使用方法引用和更新的Java
    8 API的一点点帮助编写的排序示例（我们将在[第3.7节](#ch03lev1sec7)中更详细地探讨这个示例）。
- en: 'Before:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前：
- en: '[PRE105]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'After (using a method reference and `java.util.Comparator.comparing`):'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 之后（使用方法引用和`java.util.Comparator.comparing`）：
- en: '[PRE106]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Your first method reference**'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你的第一个方法引用**'
- en: Don’t worry about the new syntax and how things work. You’ll learn that over
    the next few sections!
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心新的语法和它们是如何工作的。你将在接下来的几节中了解到这些！
- en: 3.6.1\. In a nutshell
  id: totrans-758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1\. 简而言之
- en: Why should you care about method references? Method references can be seen as
    shorthand for lambdas calling only a specific method. The basic idea is that if
    a lambda represents “call this method directly,” it’s best to refer to the method
    by name rather than by a description of how to call it. Indeed, a method reference
    lets you create a lambda expression from an existing method implementation. But
    by referring to a method name explicitly, your code *can gain better readability*.
    How does it work? When you need a method reference, the target reference is placed
    before the delimiter `::` and the name of the method is provided after it. For
    example, `Apple::getWeight` is a method reference to the method `getWeight` defined
    in the `Apple` class. (Remember that no brackets are needed after `getWeight`
    because you’re not calling it at the moment, you’re merely quoting its name.)
    This method reference is shorthand for the lambda expression `(Apple apple) ->
    apple.getWeight()`. [Table 3.4](#ch03table04) gives a few more examples of possible
    method references in Java 8.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该关注方法引用？方法引用可以看作是仅调用特定方法的 lambda 的简写。基本思想是，如果 lambda 代表“直接调用此方法”，那么最好通过方法名来引用它，而不是通过如何调用的描述。确实，方法引用允许你从一个现有的方法实现创建
    lambda 表达式。但通过明确引用方法名，你的代码可以*提高可读性*。它是如何工作的？当你需要一个方法引用时，目标引用放在分隔符 `::` 前面，方法名在后面提供。例如，`Apple::getWeight`
    是指向在 `Apple` 类中定义的 `getWeight` 方法的引用方法。（记住，在 `getWeight` 后面不需要括号，因为你现在不是在调用它，你只是在引用它的名字。）这个方法引用是
    lambda 表达式 `(Apple apple) -> apple.getWeight()` 的简写。[表 3.4](#ch03table04) 给出了
    Java 8 中一些可能的方法引用的更多示例。
- en: Table 3.4\. Examples of lambdas and method reference equivalents
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.4\. Lambda 和方法引用等价的示例
- en: '| Lambda | Method reference equivalent |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| Lambda | 方法引用等价 |'
- en: '| --- | --- |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (Apple apple) -> apple.getWeight() | Apple::getWeight |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| (Apple apple) -> apple.getWeight() | Apple::getWeight |'
- en: '| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack
    |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| () -> Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack
    |'
- en: '| (str, i) -> str.substring(i) | String::substring |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| (str, i) -> str.substring(i) | String::substring |'
- en: '| (String s) -> System.out.println(s) (String s) -> this.isValidName(s) | System.out::println
    this::isValidName |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| (String s) -> System.out.println(s) (String s) -> this.isValidName(s) | System.out::println
    this::isValidName |'
- en: You can think of method references as syntactic sugar for lambdas that refer
    only to a single method because you write less to express the same thing.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将方法引用看作是 lambda 的语法糖，因为它只引用单个方法，因为你可以用更少的代码来表达相同的内容。
- en: Recipe for constructing method references
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建方法引用的食谱
- en: 'There are three main kinds of method references:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用主要有三种类型：
- en: A method reference to a *static method* (for example, the method `parseInt`
    of `Integer`, written `Integer::parseInt`)
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指向静态方法的引用方法（例如，`Integer` 的 `parseInt` 方法，写作 `Integer::parseInt`）
- en: A method reference to an instance method of an arbitrary type (for example,
    the method `length` of a `String`, written `String::length`)
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指向任意类型实例方法的引用方法（例如，`String` 的 `length` 方法，写作 `String::length`）
- en: A method reference to an *instance method of an existing object or expression*
    (for example, suppose you have a local variable `expensiveTransaction` that holds
    an object of type `Transaction`, which supports an instance method `getValue`;
    you can write `expensiveTransaction::getValue`)
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个指向现有对象或表达式实例方法的引用方法（例如，假设你有一个局部变量 `expensiveTransaction`，它包含一个 `Transaction`
    类型的对象，该对象支持实例方法 `getValue`；你可以写 `expensiveTransaction::getValue`）
- en: 'The second and third kinds of method references may be a bit overwhelming at
    first. The idea with the second kind of method references, such as `String::length`,
    is that you’re referring to a method to an object that will be supplied as one
    of the parameters of the lambda. For example, the lambda expression `(String s)
    -> s.toUpperCase()` can be rewritten as `String::toUpperCase`. But the third kind
    of method reference refers to a situation when you’re calling a method in a lambda
    to an external object that already exists. For example, the lambda expression
    `() -> expensiveTransaction.getValue()` can be rewritten as `expensiveTransaction::getValue`.
    This third kind of method reference is particularly useful when you need to pass
    around a method defined as a private helper. For example, say you defined a helper
    method `isValidName`:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种和第三种方法引用可能在最初显得有些令人不知所措。第二种方法引用的想法，例如 `String::length`，是指向一个对象的方法，该对象将被作为
    lambda 的参数之一提供。例如，lambda 表达式 `(String s) -> s.toUpperCase()` 可以重写为 `String::toUpperCase`。但第三种方法引用指的是在
    lambda 中调用外部已存在的对象的方法。例如，lambda 表达式 `() -> expensiveTransaction.getValue()` 可以重写为
    `expensiveTransaction::getValue`。这种第三种方法引用在需要传递定义为私有辅助方法的函数时特别有用。例如，假设你定义了一个辅助方法
    `isValidName`：
- en: '[PRE107]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'You can now pass this method around in the context of a `Predicate<String>`
    using a method reference:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用方法引用在 `Predicate<String>` 的上下文中传递这个方法：
- en: '[PRE108]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: To help you digest this new knowledge, the shorthand rules to refactor a lambda
    expression to an equivalent method reference follow simple recipes, shown in [figure
    3.5](#ch03fig05).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你消化这些新知识，将 lambda 表达式重构为等效方法引用的简写规则遵循简单的食谱，如图 3.5 所示。
- en: Figure 3.5\. Recipes for constructing method references for three different
    types of lambda expressions
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. 构造三种不同类型 lambda 表达式的方法引用
- en: '![](Images/03fig05_alt.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig05_alt.jpg)'
- en: 'Note that there are also special forms of method references for constructors,
    array constructors, and super-calls. Let’s apply method references in a concrete
    example. Say you’d like to sort a `List` of strings, ignoring case differences.
    The `sort` method on a `List` expects a `Comparator` as parameter. You saw earlier
    that `Comparator` describes a function descriptor with the signature `(T, T) ->
    int`. You can define a lambda expression that uses the method `compareToIgnoreCase`
    in the `String` class as follows (note that `compareToIgnoreCase` is predefined
    in the `String` class):'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有针对构造函数、数组构造函数和超调用的特殊形式的方法引用。让我们通过一个具体的例子来应用方法引用。假设你想要对一个字符串的 `List` 进行排序，忽略大小写差异。`List`
    上的 `sort` 方法期望一个 `Comparator` 作为参数。你之前看到 `Comparator` 描述了一个具有签名 `(T, T) -> int`
    的函数描述符。你可以定义一个使用 `String` 类中的 `compareToIgnoreCase` 方法的 lambda 表达式，如下所示（注意，`compareToIgnoreCase`
    在 `String` 类中是预定义的）：
- en: '[PRE109]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The lambda expression has a signature compatible with the function descriptor
    of `Comparator`. Using the recipes described previously, the example can also
    be written using a method reference; this results in more concise code, as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式的签名与 `Comparator` 的函数描述符兼容。使用之前描述的食谱，示例也可以使用方法引用来编写；这导致代码更加简洁，如下所示：
- en: '[PRE110]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Note that the compiler goes through a similar type-checking process as for lambda
    expressions to figure out whether a method reference is valid with a given functional
    interface. The signature of the method reference has to match the type of the
    context.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器会像对 lambda 表达式进行类型检查一样，来确定方法引用是否与给定的函数接口有效。方法引用的签名必须与上下文类型匹配。
- en: To check your understanding of method references, do try quiz 3.6!
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验你对方法引用的理解，请尝试练习题 3.6！
- en: '|  |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 3.6: Method references**'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习题 3.6：方法引用**'
- en: What are equivalent method references for the following lambda expressions?
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 lambda 表达式的等效方法引用是什么？
- en: '[PRE111]'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '**Answers:**'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'This lambda expression forwards its argument to the static method `parseInt`
    of `Integer`. This method takes a `String` to parse and returns an `int`. As a
    result, the lambda can be rewritten using recipe ***1*** from [figure 3.5](#ch03fig05)
    (lambda expressions calling a static method) as follows:'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个 lambda 表达式将其参数传递给 `Integer` 的静态方法 `parseInt`。这个方法接受一个要解析的 `String` 并返回一个
    `int`。因此，可以使用图 3.5 中的食谱 ***1***（调用静态方法的 lambda 表达式）重写 lambda，如下所示：
- en: '[PRE114]'
  id: totrans-794
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This lambda uses its first argument to call the method `contains` on it. Because
    the first argument is of type `List`, you can use recipe ***2*** from [figure
    3.5](#ch03fig05) as follows:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个lambda表达式使用它的第一个参数来调用其上的`contains`方法。因为第一个参数是`List`类型，你可以按照以下方式使用[图3.5](#ch03fig05)中的**2**号配方：
- en: '[PRE115]'
  id: totrans-796
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This is because the target type describes a function descriptor `(List<String>,
    String) -> boolean,` and `List::contains` can be unpacked to that function descriptor.
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为目标类型描述了一个函数描述符`(List<String>, String) -> boolean`，而`List::contains`可以被解包到该函数描述符。
- en: 'This expression-style lambda invokes a private helper method. You can use recipe
    ***3*** from [figure 3.5](#ch03fig05) as follows:'
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个表达式风格的lambda调用了一个私有辅助方法。你可以按照以下方式使用[图3.5](#ch03fig05)中的**3**号配方：
- en: '[PRE116]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '|  |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We’ve shown only how to reuse existing method implementations and create method
    references. But you can do something similar with constructors of a class.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何重用现有的方法实现和创建方法引用。但你可以用类似的方法来处理类的构造函数。
- en: 3.6.2\. Constructor references
  id: totrans-802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.2\. 构造函数引用
- en: 'You can create a reference to an existing constructor using its name and the
    keyword `new` as follows: `ClassName::new`. It works similarly to a reference
    to a static method. For example, suppose there’s a zero-argument constructor.
    This fits the signature `() -> Apple` of `Supplier`; you can do the following:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用构造函数的名称和关键字`new`来创建现有构造函数的引用，如下所示：`ClassName::new`。它的工作方式与静态方法的引用类似。例如，假设有一个无参构造函数。这符合`Supplier`的签名`()
    -> Apple`，你可以这样做：
- en: '[PRE117]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* Constructor reference to the default Apple() constructor**'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认Apple()构造函数的构造函数引用**'
- en: '***2* Calling Supplier’s get method produces a new Apple.**'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用供应商的get方法会产生一个新的Apple。**'
- en: which is equivalent to
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下等价
- en: '[PRE118]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '***1* Lambda expression to create an Apple using the default constructor**'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用默认构造函数创建Apple的Lambda表达式**'
- en: '***2* Calling Supplier’s get method produces a new Apple.**'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用供应商的get方法会产生一个新的Apple。**'
- en: If you have a constructor with signature `Apple(Integer weight)`, it fits the
    signature of the `Function` interface, so you can do this
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个签名`Apple(Integer weight)`的构造函数，它符合`Function`接口的签名，所以你可以这样做
- en: '[PRE119]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '***1* Constructor reference to Apple (Integer weight)**'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Apple类的构造函数引用（Integer weight）**'
- en: '***2* Calling Function’s apply method with a given weight produces an Apple.**'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用给定的重量调用Function的apply方法会产生一个Apple。**'
- en: which is equivalent to
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下等价
- en: '[PRE120]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Lambda expression to create an Apple with a given weight**'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用给定重量的Lambda表达式创建Apple**'
- en: '***2* Calling Function’s apply method with a given weight produces a new Apple
    object.**'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用给定的重量调用Function的apply方法会产生一个新的Apple对象。**'
- en: 'In the following code, each element of a `List` of `Integer`s is passed to
    the constructor of `Apple` using a similar `map` method we defined earlier, resulting
    in a `List` of apples with various weights:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，将`Integer`类型的`List`中的每个元素传递给`Apple`的构造函数，使用我们之前定义的类似`map`方法，结果得到一个具有各种重量的苹果`List`：
- en: '[PRE121]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '***1* Passing a constructor reference to the map method**'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将构造函数引用传递给map方法**'
- en: 'If you have a two-argument constructor, `Apple (Color color, Integer weight)`,
    it fits the signature of the `BiFunction` interface, so you can do this:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个带有两个参数的构造函数`Apple(Color color, Integer weight)`，它符合`BiFunction`接口的签名，所以你可以这样做：
- en: '[PRE122]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '***1* Constructor reference to Apple (Color color, Integer weight)**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Apple类的构造函数引用（Color color, Integer weight）**'
- en: '***2* BiFunction’s apply method with a given color and weight produces a new
    Apple object.**'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 带有给定颜色和重量的BiFunction的apply方法会产生一个新的Apple对象。**'
- en: which is equivalent to
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下等价
- en: '[PRE123]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1* Lambda expression to create an Apple with a given color and weight**'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用给定的颜色和重量创建Apple的Lambda表达式**'
- en: '***2* BiFunction’s apply method with a given color and weight produces a new
    Apple object.**'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 带有给定颜色和重量的BiFunction的apply方法会产生一个新的Apple对象。**'
- en: 'The capability of referring to a constructor without instantiating it enables
    interesting applications. For example, you can use a `Map` to associate constructors
    with a string value. You can then create a method `giveMeFruit` that, given a
    `String` and an `Integer`, can create different types of fruits with different
    weights, as follows:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 指向构造函数而不实例化的能力使得一些有趣的应用成为可能。例如，你可以使用`Map`将构造函数与字符串值关联起来。然后你可以创建一个名为`giveMeFruit`的方法，给定一个`String`和一个`Integer`，可以创建不同重量不同类型的果实，如下所示：
- en: '[PRE124]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '***1* Get a Function<Integer, Fruit> from the map**'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从map中获取Function<Integer, Fruit>**'
- en: '***2* Function’s apply method with an Integer weight parameter creates the
    requested Fruit.**'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Function的apply方法带有Integer weight参数，创建所需的Fruit。**'
- en: To check your understanding of method and constructor references, try out quiz
    3.7.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你对方法和构造函数引用的理解，请尝试3.7的测验。
- en: '|  |'
  id: totrans-835
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quiz 3.7: Constructor references**'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**测验3.7：构造函数引用**'
- en: You saw how to transform zero-, one-, and two-argument constructors into constructor
    references. What would you need to do in order to use a constructor reference
    for a three-argument constructor such as `RGB(int, int, int)`?
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何将零参数、一参数和二参数构造函数转换为构造函数引用。为了使用一个三参数构造函数，例如`RGB(int, int, int)`，你需要做什么？
- en: '**Answer:**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'You saw that the syntax for a constructor reference is `ClassName::new`, so
    in this case it’s `RGB::new`. But you need a functional interface that will match
    the signature of that constructor reference. Because there isn’t one in the functional
    interface starter set, you can create your own:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到构造函数引用的语法是`ClassName::new`，所以在这种情况下是`RGB::new`。但是，你需要一个与该构造函数引用签名匹配的函数式接口。因为函数式接口起始集中没有，你可以创建自己的：
- en: '[PRE125]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And you can now use the constructor reference as follows:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用构造函数引用如下：
- en: '[PRE126]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|  |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'We’ve gone through a lot of new information: lambdas, functional interfaces,
    and method references. We’ll put it all into practice in the next section.'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了很多新的信息：lambda表达式、函数式接口和方法引用。我们将在下一节中将所有这些内容付诸实践。
- en: 3.7\. Putting lambdas and method references into practice
  id: totrans-845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7. 将lambda表达式和方法引用付诸实践
- en: 'To wrap up this chapter and our discussion on lambdas, we’ll continue with
    our initial problem of sorting a list of `Apple`s with different ordering strategies.
    And we’ll show how you can progressively evolve a naïve solution into a concise
    solution, using all the concepts and features explained so far in the book: behavior
    parameterization, anonymous classes, lambda expressions, and method references.
    The final solution we’ll work toward is the following (note that all source code
    is available on the book’s website: [www.manning.com/books/modern-java-in-action](http://www.manning.com/books/modern-java-in-action)):'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章以及我们对lambda表达式的讨论，我们将继续我们最初的问题，即使用不同的排序策略对`Apple`列表进行排序。我们将展示如何逐步将一个原始解决方案演变成一个简洁的解决方案，使用本书中解释的所有概念和功能：行为参数化、匿名类、lambda表达式和方法引用。我们将努力实现的最终解决方案如下（注意，所有源代码都可在本书的网站上找到：[www.manning.com/books/modern-java-in-action](http://www.manning.com/books/modern-java-in-action)）：
- en: '[PRE127]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '3.7.1\. Step 1: Pass code'
  id: totrans-848
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1. 步骤1：传递代码
- en: 'You’re lucky; the Java 8 API already provides you with a `sort` method available
    on `List` so you don’t have to implement it. The hard part is done! But how can
    you pass an ordering strategy to the `sort` method? Well, the `sort` method has
    the following signature-:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '你很幸运；Java 8 API已经为`List`提供了可用的`sort`方法，因此你不需要自己实现它。困难的部分已经完成了！但是，你该如何将排序策略传递给`sort`方法呢？嗯，`sort`方法具有以下签名-:'
- en: '[PRE128]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'It expects a `Comparator` object as argument to compare two `Apple`s! This
    is how you can pass different strategies in Java: they have to be wrapped in an
    object. We say that the *behavior* of `sort` is *parameterized*: its behavior
    will be different based on different ordering strategies passed to it.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 它期望一个`Comparator`对象作为参数来比较两个`Apple`对象！这就是你如何在Java中传递不同策略的方式：它们必须被封装在对象中。我们说`sort`的*行为*是*参数化的*：它的行为将根据传递给它的不同排序策略而有所不同。
- en: 'Your first solution looks like this:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个解决方案看起来像这样：
- en: '[PRE129]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '3.7.2\. Step 2: Use an anonymous class'
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2. 步骤2：使用匿名类
- en: 'Rather than implementing `Comparator` for the purpose of instantiating it once,
    you saw that you could use an *anonymous class* to improve your solution:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为了实例化一次而实现`Comparator`，你看到你可以使用一个*匿名类*来改进你的解决方案：
- en: '[PRE130]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '3.7.3\. Step 3: Use lambda expressions'
  id: totrans-857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.3. 步骤3：使用lambda表达式
- en: 'But your current solution is still verbose. Java 8 introduced lambda expressions,
    which provide a lightweight syntax to achieve the same goal: *passing code*. You
    saw that a lambda expression can be used where a *functional interface* is expected.
    As a reminder, a functional interface is an interface defining only one abstract
    method. The signature of the abstract method (called *function descriptor*) can
    describe the signature of a lambda expression. In this case, the `Comparator`
    represents a function descriptor `(T, T) -> int`. Because you’re using Apples,
    it represents more specifically `(Apple, Apple) -> int`. Your new improved solution
    looks therefore as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 但你当前解决方案仍然很冗长。Java 8 引入了 lambda 表达式，它提供了一种轻量级的语法来实现相同的目标：*传递代码*。你看到 lambda 表达式可以在期望
    *函数式接口* 的地方使用。作为提醒，函数式接口是一个只定义一个抽象方法的接口。抽象方法的签名（称为 *函数描述符*）可以描述 lambda 表达式的签名。在这种情况下，`Comparator`
    代表一个函数描述符 `(T, T) -> int`。因为你在使用 Apples，所以它更具体地代表 `(Apple, Apple) -> int`。因此，你的新改进的解决方案看起来如下：
- en: '[PRE131]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We explained that the Java compiler could *infer the types* of the parameters
    of a lambda expression by using the context in which the lambda appears. You can
    therefore rewrite your solution as follows:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了 Java 编译器可以通过 lambda 出现的上下文来推断 lambda 表达式参数的类型。因此，你可以将你的解决方案重写如下：
- en: '[PRE132]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Can you make your code even more readable? `Comparator` includes a static helper
    method called `comparing` that takes a `Function` extracting a `Comparable` key
    and produces a `Comparator` object (we explain why interfaces can have static
    methods in [chapter 13](kindle_split_026.xhtml#ch13)). It can be used as follows
    (note that you now pass a lambda with only one argument; the lambda specifies
    how to extract the key for comparison from an `Apple`):'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 你能让你的代码更加易读吗？`Comparator` 包含一个名为 `comparing` 的静态辅助方法，它接受一个提取 `Comparable` 键的
    `Function`，并生成一个 `Comparator` 对象（我们将在第 13 章中解释为什么接口可以有静态方法[chapter 13](kindle_split_026.xhtml#ch13)）。它可以如下使用（注意现在你传递一个只有一个参数的
    lambda；lambda 指定了如何从一个 `Apple` 中提取用于比较的键）：
- en: '[PRE133]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can now rewrite your solution in a slightly more compact form:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以以稍微紧凑的形式重写你的解决方案：
- en: '[PRE134]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '3.7.4\. Step 4: Use method references'
  id: totrans-866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.4. 第 4 步：使用方法引用
- en: 'We explained that method references are syntactic sugar for lambda expressions
    that forwards their arguments. You can use a method reference to make your code
    slightly less verbose (assuming a static import of `java.util.Comparator.comparing`):'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了方法引用是 lambda 表达式的语法糖，它将它们的参数传递过去。你可以使用方法引用来使你的代码稍微不那么冗长（假设静态导入 `java.util.Comparator.comparing`）：
- en: '[PRE135]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Congratulations, this is your final solution! Why is this better than code prior
    to Java 8? It’s not only because it’s shorter; it’s also obvious what it means.
    The code reads like the problem statement “sort inventory comparing the weight
    of the apples.”
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这是你的最终解决方案！为什么这比 Java 8 之前的代码更好？这不仅因为它更短；它还非常明确其含义。代码读起来就像问题陈述“按苹果的重量排序库存。”
- en: 3.8\. Useful methods to compose lambda expressions
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8. 有用的方法来组合 lambda 表达式
- en: Several functional interfaces in the Java 8 API contain convenience methods.
    Specifically, many functional interfaces such as `Comparator`, `Function`, and
    `Predicate` that are used to pass lambda expressions provide methods that allow
    composition. What does this mean? In practice it means you can combine several
    simple lambda expressions to build more complicated ones. For example, you can
    combine two predicates into a larger predicate that performs an `or` operation
    between the two predicates. Moreover, you can also compose functions such that
    the result of one becomes the input of another function. You may wonder how it’s
    possible that there are additional methods in a functional interface. (After all,
    this goes against the definition of a functional interface!) The trick is that
    the methods that we’ll introduce are called *default methods* (they’re not abstract
    methods). We explain them in detail in [chapter 13](kindle_split_026.xhtml#ch13).
    For now, trust us and read [chapter 13](kindle_split_026.xhtml#ch13) later, when
    you want to find out more about default methods and what you can do with them.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 API 中的几个函数式接口包含便利方法。具体来说，许多函数式接口，如 `Comparator`、`Function` 和 `Predicate`，它们用于传递
    lambda 表达式，提供了允许组合的方法。这是什么意思呢？在实践中，这意味着你可以组合几个简单的 lambda 表达式来构建更复杂的表达式。例如，你可以将两个谓词组合成一个更大的谓词，该谓词在两个谓词之间执行
    `or` 操作。此外，你还可以组合函数，使得一个函数的结果成为另一个函数的输入。你可能想知道为什么函数式接口中会有额外的函数。（毕竟，这与函数式接口的定义相矛盾！）诀窍在于我们将要介绍的方法被称为
    *默认方法*（它们不是抽象方法）。我们将在 [第 13 章](kindle_split_026.xhtml#ch13) 中详细解释它们。现在，请相信我们，当你想了解更多关于默认方法和你可以用它们做什么时，再阅读
    [第 13 章](kindle_split_026.xhtml#ch13)。
- en: 3.8.1\. Composing Comparators
  id: totrans-872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8.1\. 比较器组合
- en: 'You’ve seen that you can use the static method `Comparator.comparing` to return
    a `Comparator` based on a `Function` that extracts a key for comparison as follows:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你可以使用静态方法 `Comparator.comparing` 来返回一个基于 `Function` 提取比较键的 `Comparator`，如下所示：
- en: '[PRE136]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Reversed order
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逆序
- en: 'What if you wanted to sort the apples by decreasing weight? There’s no need
    to create a different instance of a `Comparator`. The interface includes a default
    method `reversed` that reverses the ordering of a given comparator. You can modify
    the previous example to sort the apples by decreasing weight by reusing the initial
    `Comparator`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想按重量降序对苹果进行排序，不需要创建不同的 `Comparator` 实例。该接口包括一个默认方法 `reversed`，它反转给定比较器的排序顺序。你可以通过重用初始
    `Comparator` 来修改前面的示例，按重量降序对苹果进行排序：
- en: '[PRE137]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '***1* Sorts by decreasing weight**'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 按重量降序排序**'
- en: Chaining Comparators
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 链式连接比较器
- en: 'This is all nice, but what if you find two apples that have the same weight?
    Which apple should have priority in the sorted list? You may want to provide a
    second `Comparator-` to further refine the comparison. For example, after two
    apples are compared based on their weight, you may want to sort them by country
    of origin. The `thenComparing` method allows you to do that. It takes a function
    as parameter (like the method `comparing`) and provides a second `Comparator`
    if two objects are considered equal using the initial `Comparator`. You can solve
    the problem elegantly again as follows:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，但如果你发现两个苹果的重量相同怎么办？在排序列表中哪个苹果应该有优先级？你可能想提供一个第二个 `Comparator` 来进一步细化比较。例如，在根据重量比较两个苹果之后，你可能想按原产国对它们进行排序。`thenComparing`
    方法允许你这样做。它接受一个函数作为参数（就像 `comparing` 方法一样）并在使用初始 `Comparator` 认定两个对象相等时提供一个第二个
    `Comparator`。你可以再次优雅地解决这个问题，如下所示：
- en: '[PRE138]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '***1* Sorts by decreasing weight**'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 按重量降序排序**'
- en: '***2* Sorts further by country when two apples have same weight**'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当两个苹果重量相同时，按国家进一步排序**'
- en: 3.8.2\. Composing Predicates
  id: totrans-884
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8.2\. 谓词组合
- en: 'The `Predicate` interface includes three methods that let you reuse an existing
    `Predicate` to create more complicated ones: `negate`, `and`, and `or`. For example,
    you can use the method `negate` to return the negation of a `Predicate`, such
    as an apple that is not red:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate` 接口包括三个方法，允许你重用现有的 `Predicate` 来创建更复杂的谓词：`negate`、`and` 和 `or`。例如，你可以使用
    `negate` 方法来返回 `Predicate` 的否定，例如一个非红色的苹果：'
- en: '[PRE139]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '***1* Produces the negation of the existing Predicate object redApple**'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成现有谓词对象 redApple 的否定**'
- en: 'You may want to combine two lambdas to say that an apple is both red and heavy
    with the `and` method:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想使用 `and` 方法将两个 lambda 表达式组合起来，以表明一个苹果既是红色的又是重的：
- en: '[PRE140]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '***1* Chains two predicates to produce another Predicate object**'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将两个谓词链式连接以产生另一个谓词对象**'
- en: 'You can combine the resulting predicate one step further to express apples
    that are red and heavy (above 150 g) or only green apples:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将生成的谓词进一步组合，以表达红色且重的苹果（重量超过150克）或仅绿色的苹果：
- en: '[PRE141]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '***1* Chains three predicates to construct a more complex Predicate object**'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将三个谓词链起来构建一个更复杂的谓词对象**'
- en: Why is this great? From simpler lambda expressions you can represent more complicated
    lambda expressions that still read like the problem statement! Note that the precedence
    of methods `and` and `or` in the chain is from left to right—there is no equivalent
    of bracketing. So `a.or(b).and(c)` must be read as `(a || b) && c`. Similarly,
    `a.and(b).or(c)` must be read as as `(a && b) || c`.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很棒？从更简单的lambda表达式，你可以表示更复杂的lambda表达式，它们仍然像问题陈述一样易读！请注意，链中方法`and`和`or`的优先级是从左到右的——没有括号等价物。所以`a.or(b).and(c)`必须读作`(a
    || b) && c`。同样，`a.and(b).or(c)`必须读作`(a && b) || c`。
- en: 3.8.3\. Composing Functions
  id: totrans-895
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.8.3\. 组合函数
- en: Finally, you can also compose lambda expressions represented by the `Function`
    interface. The `Function` interface comes with two default methods for this, `andThen`
    and `compose`, which both return an instance of `Function`.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以组合由`Function`接口表示的lambda表达式。`Function`接口为此提供了两个默认方法，`andThen`和`compose`，这两个方法都返回一个`Function`实例。
- en: 'The method `andThen` returns a function that first applies a given function
    to an input and then applies another function to the result of that application.
    For example, given a function `f` that increments a number `(x -> x + 1)` and
    another function `g` that multiples a number by 2, you can combine them to create
    a function `h` that first increments a number and then multiplies the result by
    2:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`andThen`返回一个函数，它首先对一个输入应用一个给定的函数，然后将另一个函数应用于该应用的结果。例如，给定一个函数`f`，它增加一个数字`(x
    -> x + 1)`，以及另一个函数`g`，它将一个数字乘以2，你可以将它们组合起来创建一个函数`h`，该函数首先增加一个数字，然后将结果乘以2：
- en: '[PRE142]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '***1* In mathematics you’d write g(f(x)) or (g o f)(x).**'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在数学中，你会写成g(f(x))或(g o f)(x)。**'
- en: '***2* This returns 4.**'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这返回4。**'
- en: 'You can also use the method `compose` similarly to first apply the function
    given as argument to `compose` and then apply the function to the result. For
    example, in the previous example using `compose`, it would mean `f(g(x))` instead
    of `g(f(x))` using `andThen`:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像使用`compose`一样使用方法`compose`，首先应用作为`compose`参数给出的函数，然后将函数应用于结果。例如，在之前的`compose`示例中，这意味着`f(g(x))`而不是使用`andThen`的`g(f(x))`：
- en: '[PRE143]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '***1* In mathematics you’d write f(g(x)) or (f o g)(x).**'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在数学中，你会写成f(g(x))或(f o g)(x)。**'
- en: '***2* This returns 3.**'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这返回3。**'
- en: '[Figure 3.6](#ch03fig06) illustrates the difference between `andThen` and `compose`.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.6](#ch03fig06)说明了`andThen`和`compose`之间的区别。'
- en: Figure 3.6\. Using `andThen` versus `compose`
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6\. 使用`andThen`与`compose`的比较
- en: '![](Images/03fig06_alt.jpg)'
  id: totrans-907
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig06_alt.jpg)'
- en: 'This all sounds a bit too abstract. How can you use these in practice? Let’s
    say you have various utility methods that do text transformation on a letter represented
    as a `String`:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来有点抽象。你如何在实践中使用它们？假设你有一些对表示为`String`的字母进行文本转换的实用方法：
- en: '[PRE144]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'You can now create various transformation pipelines by composing the utility
    methods. For example, creating a pipeline that first adds a header, then checks
    spelling, and finally adds a footer, as shown in the following (and as illustrated
    in [figure 3.7](#ch03fig07)):'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过组合实用方法创建各种转换管道。例如，创建一个管道，首先添加标题，然后检查拼写，最后添加页脚，如下所示（如图3.7所示）：
- en: Figure 3.7\. A transformation pipeline using `andThen`
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7\. 使用`andThen`的转换管道
- en: '![](Images/03fig07_alt.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig07_alt.jpg)'
- en: '[PRE145]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'A second pipeline might be only adding a header and footer without checking
    for spelling:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个管道可能只是添加标题和页脚，而不检查拼写：
- en: '[PRE146]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 3.9\. Similar ideas from mathematics
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.9\. 来自数学的类似想法
- en: If you feel comfortable with high school mathematics, this section gives another
    viewpoint of the idea of lambda expressions and passing around functions. Feel
    free to skip it; nothing else in the book depends on it. But you may enjoy seeing
    another perspective.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉高中数学，本节提供了对lambda表达式和函数传递概念的另一种观点。请随意跳过；本书中的其他内容都不依赖于它。但你可能会喜欢看到另一个视角。
- en: 3.9.1\. Integration
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.1\. 集成
- en: Suppose you have a (mathematical, not Java) function `f`, perhaps defined by
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个（数学的，不是Java的）函数`f`，可能定义为
- en: '*f*(*x*) = *x* + 10'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *x* + 10'
- en: Then, one question that’s often asked (at school and in science and engineering
    degrees) is to find the area beneath the function when drawn on paper (counting
    the x-axis as the zero line). For example, you write
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个经常被问到的问题（在学校以及科学和工程学位中）是在纸上绘制函数时找到函数下方的面积（将 x 轴视为零线）。例如，你写下
- en: '![](Images/f0077-01.jpg)'
  id: totrans-922
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0077-01.jpg)'
- en: for the area shown in [figure 3.8](#ch03fig08).
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图 3.8 中显示的区域[figure 3.8](#ch03fig08)。
- en: Figure 3.8\. Area under the function `f(x) = x + 10` for `x` from 3 to 7
  id: totrans-924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 函数 `f(x) = x + 10` 在 `x` 从 3 到 7 下的面积
- en: '![](Images/03fig08.jpg)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig08.jpg)'
- en: 'In this example, the function `f` is a straight line, and so you can easily
    work out this area by the trapezium method (drawing triangles and rectangles)
    to discover the solution:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数 `f` 是一条直线，因此你可以通过梯形法（绘制三角形和矩形）轻松计算出这个面积，以找到解决方案：
- en: 1/2 × ((3 + 10) + (7 + 10)) × (7 – 3) = 60
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 1/2 × ((3 + 10) + (7 + 10)) × (7 – 3) = 60
- en: Now, how might you express this in Java? Your first problem is reconciling the
    strange notation like the integration symbol or `dy/dx` with familiar programming
    language notation.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你如何在 Java 中表达这个想法？你的第一个问题是调和像积分符号或 `dy/dx` 这样的奇怪符号与熟悉的编程语言符号。
- en: 'Indeed, thinking from first principles you need a method, perhaps called `integrate`,
    that takes three arguments: one is `f`, and the others are the limits (3.0 and
    7.0 here). Thus, you want to write in Java something that looks like this, where
    the function `f` is passed as an argument:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，从第一性原理出发，你需要一个方法，可能叫做 `integrate`，它接受三个参数：一个是 `f`，其余的是极限（这里分别是 3.0 和 7.0）。因此，你希望在
    Java 中编写类似以下内容，其中函数 `f` 作为参数传递：
- en: '[PRE147]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note that you can’t write something as simple as
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能像在数学中那样编写如此简单的代码：
- en: '[PRE148]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: for two reasons. First, the scope of `x` is unclear, and second, this would
    pass a value of `x+10` to integrate instead of passing the function `f`.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个原因。首先，`x` 的作用域不明确，其次，这将传递 `x+10` 的值进行积分，而不是传递函数 `f`。
- en: Indeed, the secret role of `dx` in mathematics is to say “that function taking
    argument `x` whose result is `x + 10`.”
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，数学中 `dx` 的秘密角色是表示“接受参数 `x` 并返回 `x + 10` 的函数。”
- en: 3.9.2\. Connecting to Java 8 lambdas
  id: totrans-935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.9.2\. 连接到 Java 8 的 lambda 表达式
- en: As we mentioned earlier, Java 8 uses the notation `(double x) -> x + 10` (a
    lambda expression) for exactly this purpose; hence you can write
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，Java 8 使用 `(double x) -> x + 10`（一个 lambda 表达式）的符号来精确地实现这个目的；因此你可以写出
- en: '[PRE149]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: or
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE150]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: or, using a method reference as mentioned earlier,
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用前面提到的方法引用，
- en: '[PRE151]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: if `C` is a class containing `f` as a static method. The idea is that you’re
    passing the code for `f` to the method `integrate`.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `C` 是一个包含 `f` 作为静态方法的类。这个想法是你将 `f` 的代码传递给 `integrate` 方法。
- en: 'You may now wonder how you’d write the method `integrate` itself. Continue
    to suppose that `f` is a linear function (straight line). You’d probably like
    to write in a form similar to mathematics:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会想知道如何编写 `integrate` 方法本身。继续假设 `f` 是一个线性函数（直线）。你可能希望以类似于数学的形式编写：
- en: '[PRE152]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '***1* Incorrect Java code! (You can’t write functions as you do in mathematics.)**'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误的 Java 代码！（你不能像在数学中那样编写函数。）**'
- en: 'But because lambda expressions can be used only in a context expecting a functional
    interface (in this case, `DoubleFunction`^([[4](#ch03fn04)])), you have to write
    it the following way:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为 lambda 表达式只能在期望功能接口（在这种情况下，`DoubleFunction`^([[4](#ch03fn04)])) 的上下文中使用，所以你必须按照以下方式编写：
- en: ⁴
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using `DoubleFunction<Double>` is more efficient than using `Function<Double,Double>`
    as it avoids boxing the result.
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `DoubleFunction<Double>` 比使用 `Function<Double,Double>` 更高效，因为它避免了装箱结果。
- en: '[PRE153]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'or using `DoubleUnaryOperator`, which also avoids boxing the result:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 `DoubleUnaryOperator`，这也避免了装箱结果：
- en: '[PRE154]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: As a side remark, it’s a bit of a shame that you have to write `f.apply(a)`
    instead of simply writing `f(a)` as in mathematics, but Java just can’t get away
    from the view that everything is an object instead of the idea of a function being
    truly independent!
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，有点遗憾的是，你必须编写 `f.apply(a)` 而不是简单地像在数学中那样编写 `f(a)`，但 Java 只能摆脱一切都是对象的观点，而不是函数真正独立的概念！
- en: Summary
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'A *lambda expression* can be understood as a kind of anonymous function: it
    doesn’t have a name, but it has a list of parameters, a body, a return type, and
    also possibly a list of exceptions that can be thrown.'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lambda 表达式* 可以理解为一种匿名函数：它没有名字，但它有一系列参数、一个主体、一个返回类型，以及可能抛出的异常列表。'
- en: Lambda expressions let you pass code concisely.
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式让你可以简洁地传递代码。
- en: A *functional interface* is an interface that declares exactly one abstract
    method.
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*功能接口* 是一个声明恰好一个抽象方法的接口。'
- en: Lambda expressions can be used only where a functional interface is expected.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式只能在期望功能接口的地方使用。
- en: Lambda expressions let you provide the implementation of the abstract method
    of a functional interface directly inline and *treat the whole expression as an
    instance of a functional interface*.
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式允许你直接内联提供功能接口的抽象方法实现，并将整个表达式 *视为功能接口的一个实例*。
- en: Java 8 comes with a list of common functional interfaces in the `java.util .function`
    package, which includes `Predicate<T>`, `Function<T`, `R>`, `Supplier<T>`, `Consumer<T>`,
    and `BinaryOperator<T>`, described in [table 3.2](#ch03table02).
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 在 `java.util.function` 包中提供了一系列常见的功能接口，包括 `Predicate<T>`、`Function<T,
    R>`、`Supplier<T>`、`Consumer<T>` 和 `BinaryOperator<T>`，这些接口在[表 3.2](#ch03table02)
    中进行了描述。
- en: 'Primitive specializations of common generic functional interfaces such as `Predicate<T>`
    and `Function<T, R>` can be used to avoid boxing operations: `IntPredicate`, `IntToLongFunction`,
    and so on.'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Predicate<T>` 和 `Function<T, R>` 等常见泛型功能接口的原生特殊化，可以使用它们来避免装箱操作：`IntPredicate`、`IntToLongFunction`
    等等。
- en: The execute-around pattern (for when you need to execute some given behavior
    in the middle of boilerplate code that’s necessary in a method, for example, resource
    allocation and cleanup) can be used with lambdas to gain additional flexibility
    and reusability.
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要在方法中执行一些必要的中间行为（例如资源分配和清理）时，可以使用 lambda 表达式来获得额外的灵活性和可重用性。
- en: The type expected for a lambda expression is called the *target* type.
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda 表达式期望的类型称为 *目标* 类型。
- en: Method references let you reuse an existing method implementation and pass it
    around directly.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用允许你重用现有的方法实现，并直接传递它。
- en: Functional interfaces such as `Comparator`, `Predicate`, and `Function` have
    several default methods that can be used to combine lambda expressions.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 `Comparator`、`Predicate` 和 `Function` 的功能接口有几个默认方法，可以用来组合 lambda 表达式。
