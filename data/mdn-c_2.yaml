- en: Level 2\. Cognition
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二级\. 认知
- en: '![](pg_147.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_147.jpg)'
- en: '*The Eurasian jay may be solitary or found in pairs. It is known for its mimicry
    of other bird calls, for its alertness, and for its dispersal of seeds that contribute
    to forest expansion.*'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*欧亚松鸡可能是独居的，或者成对出现。它以其模仿其他鸟鸣声、警觉性和散播种子以促进森林扩张而闻名。*'
- en: 'Now we are advanced enough to go to the heart of C. Completing this level should
    enable you to write C code professionally; it therefore begins with an essential
    discussion about the writing and organization of C programs. Then it fills in
    the gaps for the major C constructs that we have skipped so far: it fully explains
    pointers, familiarizes you with C’s memory model and with dynamic memory allocation,
    and allows you to understand most of C’s library interface.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经足够深入地了解了 C 的核心。完成这一级应该能够让你专业地编写 C 代码；因此，它从关于 C 程序的编写和组织的基本讨论开始。然后它填补了我们之前跳过的主要
    C 构造的空白：它全面解释了指针，使你熟悉 C 的内存模型和动态内存分配，并让你理解 C 的大多数库接口。
- en: Chapter 9\. Style
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章\. 风格
- en: This chapter covers
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Writing readable code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可读的代码
- en: Formatting code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化代码
- en: Naming identifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名标识符
- en: 'Programs serve both sides: first, as we have already seen, they serve to give
    instructions to the compiler and the final executable. But equally important,
    they document the intended behavior of a system for the people (users, customers,
    maintainers, lawyers, and so on) who have to deal with it.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序服务于双方：首先，正如我们之前所看到的，它们服务于向编译器和最终可执行文件发出指令。但同样重要的是，它们为必须与之打交道的人（用户、客户、维护者、律师等等）记录了系统的预期行为。
- en: 'Therefore, we have a prime directive:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个首要指令：
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway C
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 C
- en: '*All C code must be readable.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有 C 代码都必须可读。*'
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The difficulty with that directive is knowing what constitutes “readable.”
    Not all experienced C programmers agree, so we will begin by trying to establish
    a minimal list of necessities. The first things we must have in mind when discussing
    the human condition is that it is constrained by two major factors: physical ability
    and cultural baggage.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那个指令的困难在于知道什么构成了“可读性”。并不是所有经验丰富的 C 程序员都同意，因此我们将从尝试建立一个最小必需列表开始。在讨论人类状况时，我们必须牢记的两个主要因素是：身体能力和文化负担。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.1
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.1 摘要
- en: '*Short-term memory and the field of vision are small.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*短期记忆和视野范围都很小。*'
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Torvalds et al. [[1996](kindle_split_036.html#bib18)], the coding style for
    the Linux kernel, is a good example that insists on that aspect and certainly
    is worth a detour, if you haven’t read it yet. Its main assumptions are still
    valid: a programming text has to be represented in a relatively small “window”
    (be it a console or a graphical editor) that consists of roughly 30 lines of 80
    columns, making a “surface” of 2,400 characters. Everything that doesn’t fit has
    to be memorized. For example, our very first program in [listing 1.1](kindle_split_008.html#ch01ex01)
    fits into these constraints.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Torvalds 等人 [[1996](kindle_split_036.html#bib18)]，Linux 内核的编码风格，是坚持这一方面并确实值得一看的例子，如果你还没有读过的话。其主要假设仍然有效：编程文本必须在一个相对较小的“窗口”（无论是控制台还是图形编辑器）中呈现，大约有
    80 列的 30 行，形成一个 2,400 个字符的“表面”。所有不适合的内容都必须记住。例如，我们非常第一个程序在 [列表 1.1](kindle_split_008.html#ch01ex01)
    中符合这些限制。
- en: 'By its humorous reference to Kernighan and Ritchie [[1978](kindle_split_036.html#bib8)],
    the Linux coding style also refers to another fundamental fact:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对其幽默地引用 Kernighan 和 Ritchie [[1978](kindle_split_036.html#bib8)]，Linux 编码风格也指出了另一个基本事实：
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.2
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 9.2 摘要
- en: '*Coding style is not a question of taste but of culture.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*编码风格不是品味问题，而是文化问题。*'
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Ignoring this easily leads to endless and fruitless debates about not much at
    all.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略这一点很容易导致关于许多事情的无休止且毫无结果的争论。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.3
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 9.3
- en: '*When you enter an established project, you enter a new cultural space.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你进入一个成熟的项目时，你就进入了一个新的文化空间。*'
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Try to adapt to the habits of the inhabitants. When you create your own project,
    you have a bit of freedom to establish your own rules. But be careful if you want
    others to adhere to them; you must not deviate too much from the common sense
    that reigns in the corresponding community.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试适应居民的习惯。当你创建自己的项目时，你有一点点自由来建立自己的规则。但如果你希望其他人遵守这些规则，你必须小心不要偏离在相应社区中占主导地位的常识。
- en: 9.1\. Formatting
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 格式化
- en: The C language itself is relatively tolerant of formatting issues. Under normal
    circumstances, a C compiler will dumbly parse an entire program that is written
    on a single line with minimal white space and where all identifiers are composed
    of the letter l and the digit `1`. The need for code formatting originates in
    human incapacity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C语言本身对格式化问题相对宽容。在正常情况下，一个C编译器会愚蠢地解析一个整个程序，该程序写在单行上，最小化空白，并且所有标识符都由字母l和数字`1`组成。代码格式化的需求源于人类的无能。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.4
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获9.4
- en: '*Choose a consistent strategy for white space and other text formatting.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择一个一致的策略来处理空白和其他文本格式。*'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Formatting concerns indentation, placement of parentheses and all kinds of brackets
    (`{}`, `[]`, and `()`), spaces before and after operators, trailing spaces, and
    multiple new lines. The human eye and brain are quite peculiar in their habits,
    and to ensure that they work properly and efficiently, everything must be in sync.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化问题包括缩进、括号和各种括号（`{}`, `[]`, 和 `()`）的位置、操作符前后空格、尾随空格以及多行换行。人眼和大脑在习惯上相当独特，为了确保它们能够正常高效地工作，一切必须保持同步。
- en: 'In the introduction for [level 1](kindle_split_010.html#part01), you saw a
    lot of the coding style rules applied to the code in this book. Take them as an
    example of one style; you will most likely encounter other styles as you go along.
    Let us recall some of the rules and introduce some others that have not yet been
    presented:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[级别 1](kindle_split_010.html#part01)的介绍中，你看到了许多应用于本书代码中的编码风格规则。把它们作为一种风格的例子；你可能会在继续的过程中遇到其他风格。让我们回顾一些规则，并介绍一些尚未介绍的其他规则：
- en: 'We use prefix notation for code blocks: that is, an opening `{` is at the end
    of a line.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用前缀记法来表示代码块：也就是说，一个开括号 `{` 在一行的末尾。
- en: We bind type modifiers and qualifiers to the left. We bind function `()` to
    the left, but `()` of conditions are separated from their keyword (such as **`if`**
    or **`for`**) with a space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将类型修饰符和限定符绑定到左边。我们将函数 `()` 绑定到左边，但条件中的 `()` 与其关键字（如**`if`**或**`for`**）之间用空格隔开。
- en: A ternary expression has spaces around the `?` and the `:`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元表达式在`?`和`:`周围有空格。
- en: Punctuation marks (`:`, `;`, and `,`) have no space before them but either one
    space or a new line after.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号（`:`, `;`, 和 `,`）前面没有空格，但后面有一个空格或一个新行。
- en: As you see, when written out, these rules can appear quite cumbersome and arbitrary.
    They have no value as such; they are visual aids that help you and your collaborators
    understand new code in the blink of an eye. They are not meant to be meticulously
    typed by you directly, but you should acquire and learn the tools that can help
    you with them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当写出来时，这些规则可能显得相当繁琐和任意。它们本身没有价值；它们是视觉辅助工具，帮助你和你合作者一眼就能理解新的代码。它们不是让你直接仔细输入的，但你应该掌握并学习可以帮助你的工具。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.5
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获9.5
- en: '*Have your text editor automatically format your code correctly.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*让文本编辑器自动格式化你的代码。*'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I personally use Emacs ([https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/))
    for that task (yes, I am that old). For *me*, it is ideal since it understands
    a lot of the structure of a C program by itself. Your mileage will probably vary,
    but don’t use a tool in everyday life that gives you less. Text editors, integrated
    development environments (IDEs), and code generators are there for us, not the
    other way around.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人使用Emacs([https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/))来完成这项任务（是的，我真的很老）。对我来说，它是理想的，因为它可以自己理解C程序的结构。你的体验可能不同，但不要在日常生活中使用那些给你带来更少帮助的工具。文本编辑器、集成开发环境（IDE）和代码生成器都是为了我们而存在的，而不是相反。
- en: In bigger projects, you should enforce such a formatting policy for all the
    code that circulates and is read by others. Otherwise, it will become difficult
    to track differences between versions of programming text. This can be automated
    by command-line tools that do the formatting. Here, I have a long-time preference
    for `astyle` (artistic style [http://sourceforge.net/projects/astyle/](http://sourceforge.net/projects/astyle/).
    Again, your mileage may vary; choose anything that ensures the task.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的项目中，你应该为所有流通和被他人阅读的代码强制执行这种格式化策略。否则，将难以追踪编程文本版本之间的差异。这可以通过命令行工具自动完成，这些工具会进行格式化。在这里，我长期偏好`astyle`（艺术风格[http://sourceforge.net/projects/astyle/](http://sourceforge.net/projects/astyle/)）。再次强调，你的体验可能不同；选择任何能确保任务完成的工具。
- en: 9.2\. Naming
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 命名
- en: The limit of such automatic formatting tools is reached when it comes to naming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名方面，这种自动格式化工具的局限性达到了极限。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.6
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 9.6
- en: '*Choose a consistent naming policy for all identifiers.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*为所有标识符选择一个一致的命名策略*。'
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are two different aspects to naming: technical restrictions on one hand
    and semantic conventions on the other. Unfortunately, they are often mixed up
    and the subject of endless ideological debate.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的两个方面：一方面是技术限制，另一方面是语义约定。不幸的是，它们经常被混淆，成为无休止的意识形态争论的主题。
- en: 'For C, various technical restrictions apply; they are meant to help you, so
    take them seriously. First of all, we target *all identifiers*: types (**`struct`**
    or not), **`struct`** and **`union`** members, variables, enumerations, macros,
    functions, function-like macros. There are so many tangled *name spaces**^C* that
    you have to be careful.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C，适用各种技术限制；它们旨在帮助你，所以要认真对待。首先，我们针对 *所有标识符*：类型（**`struct`** 或不是），**`struct`**
    和 **`union`** 成员，变量，枚举，宏，函数，函数式宏。有如此多的 *命名空间**^C* 混乱，你必须小心。
- en: 'In particular, the interaction between header files and macro definitions can
    have surprising effects. Here is a seemingly innocent example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，头文件和宏定义之间的交互可能产生意想不到的效果。以下是一个看似无害的例子：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: N is a capitalized identifier, and thus your collaborator could be tempted to
    define a macro N as a big number.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: N 是一个大写标识符，因此你的合作者可能会被诱惑定义一个宏 N 为一个大数字。
- en: I is used for the root of – 1 as soon as someone includes `complex.h`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人包含 `complex.h` 时，I 被用作 -1 的根。
- en: The identifier strip might be used by a C implementation for a library function
    or macro.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符 `strip` 可能会被 C 实现用于库函数或宏。
- en: The identifier memory_sum might be used by the C standard for a type name in
    the future.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符 `memory_sum` 可能会被 C 标准用于未来的类型名称。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<complex.h>`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`<complex.h>`'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.7
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 9.7
- en: '*Any identifier that is visible in a header file must be conforming.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何在头文件中可见的标识符都必须符合规范*。'
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here, *conforming* is a wide field. In C jargon, an identifier is *reserved**^C*
    if its meaning is fixed by the C standard and you may not redefine it otherwise:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*符合性*是一个广泛的领域。在 C 术语中，如果标识符的意义由 C 标准固定，并且你无法重新定义它，则该标识符是 *保留**^C* 的：
- en: Names starting with an underscore and a second underscore or a capital letter
    are reserved for language extensions and other internal use.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下划线和第二个下划线或大写字母开头的名称保留用于语言扩展和其他内部使用。
- en: Names starting with an underscore are reserved for file scope identifiers and
    for **`enum`**, **`struct`** and **`union`** tags.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下划线开头的名称保留用于文件作用域标识符以及 **`enum`**、**`struct`** 和 **`union`** 标签。
- en: Macros have all-caps names.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的名称全部为大写字母。
- en: All identifiers that have a predefined meaning are reserved and cannot be used
    in file scope. This includes a lot of identifiers, such as all functions in the
    C library, all identifiers starting with str (like our strip, earlier), all identifiers
    starting with E, all identifiers ending in **`_t`**, and many more.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有具有预定义意义的标识符都已被保留，不能在文件作用域中使用。这包括许多标识符，例如 C 库中的所有函数，所有以 str 开头的标识符（如我们之前的 strip），所有以
    E 开头的标识符，所有以 **`_t`** 结尾的标识符，以及许多其他标识符。
- en: What makes all of these rules relatively difficult is that you might not detect
    any violation for years; and then, all of a sudden, on a new client machine, after
    the introduction of the next C standard and compiler or after a simple system
    upgrade, your code explodes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则相对困难的原因是，你可能多年都不会发现任何违规行为；然后，突然之间，在新客户端机器上，在引入下一个 C 标准、编译器或进行简单系统升级后，你的代码崩溃了。
- en: A simple strategy to keep the probability of naming conflicts low is to expose
    as few names as possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一种降低命名冲突概率的简单策略是尽可能少地暴露名称。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.8
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果 9.8
- en: '*Don’t pollute the global space of identifiers.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要污染标识符的全局空间*。'
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Expose only types and functions as interfaces that are part of the *application
    programming interface**^C* (*API**^C*): that is, those that are supposed to be
    used by users of your code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将类型和函数作为接口暴露，这些接口是 *应用程序编程接口**^C* (*API**^C*) 的一部分：即那些预期将被你的代码的用户使用。
- en: A good strategy for a library that is used by others or in other projects is
    to use naming prefixes that are unlikely to create conflicts. For example, many
    functions and types in the POSIX thread API are prefixed with pthread_. For my
    tool box P99, I use the prefixes p99_ and P99_ for API interfaces and p00_ and
    P00_ for internals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他人或项目使用的库，一个好的策略是使用不太可能引起冲突的命名前缀。例如，POSIX线程API中的许多函数和类型都以前缀pthread_开头。对于我的工具箱P99，我使用前缀p99_和P99_用于API接口，p00_和P00_用于内部。
- en: 'There are two sorts of names that may interact badly with macros that another
    programmer writes and which you might not think of immediately:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种名称可能会与另一个程序员编写的宏产生不良交互，而你可能不会立即想到：
- en: Member names of **`struct`** and **`union`**
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`struct`**和**`union`**的成员名称'
- en: Parameter names in function interfaces.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接口中的参数名称。
- en: 'The first point is the reason why the members in standard structures usually
    have a prefix to their names: **`struct`** **`timespec`** has **`tv_sec`** as
    a member name, because an uneducated user might declare a macro sec that would
    interfere in unpredictable ways when including `time.h`. For the second point,
    we saw an example earlier. In P99, I would specify such a function something like
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是为什么标准结构中的成员通常在其名称前有一个前缀的原因：**`struct`** **`timespec`**的成员名称是**`tv_sec`**，因为一个未受过教育的用户可能会声明一个宏sec，当包含`time.h`时可能会以不可预测的方式干扰。对于第二点，我们之前已经看到了一个例子。在P99中，我会指定这样的函数如下：
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<time.h>`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time.h>`'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This problem gets worse when we are also exposing program internals to the
    public view. This happens in two cases:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们也将程序内部暴露给公众时，这个问题变得更糟。这发生在两种情况下：
- en: So-called **`inline`** functions, which are functions whose definition (not
    only declaration) is visible in a header file
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所说的**`inline`**函数，这些函数的定义（不仅是声明）在头文件中可见
- en: Function-like macros
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数宏
- en: We will discuss these features much later, see [section 15.1](kindle_split_026.html#ch15lev1sec1)
    and [chapter 16](kindle_split_027.html#ch16).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论这些特性，参见[第15.1节](kindle_split_026.html#ch15lev1sec1)和[第16章](kindle_split_027.html#ch16)。
- en: Now that we have clarified the technical points of naming, we will look at the
    semantic aspect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经明确了命名的技术要点，我们将看看语义方面。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.9
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果9.9
- en: '*Names must be recognizable and quickly distinguishable.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称必须是可识别的和快速可区分的*。'
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'That has two parts: distinguishable *and* quickly. Compare the identifiers
    in [table 9.1](#ch09table01).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个部分：可区分的和快速。比较[表9.1](#ch09table01)中的标识符。
- en: 'For your personal taste, the answers on the right side of this table may be
    different. This reflects *my* taste: an implicit context for such names is part
    of my personal expectation. The difference between n and m on one side and for
    ffs and clz on the other is an implicit semantic.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你个人的口味，这张表右侧的答案可能不同。这反映了我的口味：这样的名称的隐含上下文是我个人期望的一部分。n和m在一侧与ffs和clz在另一侧之间的差异是一种隐含的语义。
- en: Table 9.1\. Some examples of well and badly distinguishable identifiers
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. 一些易于和难以区分的标识符的例子
- en: '|   |   | Recognizable | Distinguishable | Quickly |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 可识别的 | 可区分的 | 快速 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| lllll1llOll | llllll1l0ll | No | No | No |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| lllll1llOll | llllll1l0ll | 否 | 否 | 否 |'
- en: '| myLineNumber | myLimeNumber | Yes | Yes | No |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 我的行号 | 我的列号 | 是 | 是 | 否 |'
- en: '| n | m | Yes | Yes | Yes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| n | m | 是 | 是 | 是 |'
- en: '| ffs | clz | No | Yes | Yes |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ffs | clz | 否 | 是 | 是 |'
- en: '| lowBit | highBit | Yes | Yes | Yes |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| lowBit | highBit | 是 | 是 | 是 |'
- en: '| p00Orb | p00Urb | No | Yes | No |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| p00Orb | p00Urb | 否 | 是 | 否 |'
- en: '| p00_orb | p00_urb | Yes | Yes | Yes |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| p00_orb | p00_urb | 是 | 是 | 是 |'
- en: For me, because I have a heavily biased mathematical background, single-letter
    variable names from i to n, such as n and m, are integer variables. These usually
    occur inside a quite restricted scope as loop variables or similar. Having a single-letter
    identifier is fine (we always have the declaration in view), and they are quickly
    distinguished.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，因为我有深厚的数学背景，从i到n的单字母变量名，如n和m，是整数变量。它们通常在非常有限的范围内出现，作为循环变量或类似的东西。单字母标识符是可以的（我们总是有声明在眼前），并且它们很容易区分。
- en: 'The function names ffs and clz are different because they compete with all
    other three-letter acronyms that could potentially be used for function names.
    Incidentally, here, ffs is shorthand for *find first (bit) set*, but this is not
    immediately obvious to me. What that would mean is even less clear: which bit
    is first, the most significant bit or the least significant?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称 ffs 和 clz 是不同的，因为它们与其他所有可能用作函数名称的三字母缩写词竞争。顺便说一下，在这里，ffs 是 *find first (bit)
    set* 的缩写，但这对我来说并不立即明显。这意味着什么将更不清楚：哪个位是第一个，最显著的位还是最不显著的位？
- en: 'There are several conventions that combine multiple words in one identifier.
    Among the most commonly used are the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种约定将多个单词组合在一个标识符中。其中最常用的有以下几种：
- en: '*Camel case**^C*, using internalCapitalsToBreakWords'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*驼峰命名法**^C**，使用内部大写字母来分隔单词。'
- en: '*Snake case**^C*, using internal_underscores_to_break_words'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*蛇形命名法**^C**，使用内部下划线来分隔单词。'
- en: '*Hungarian notation**^C*,^([[1](#ch09fn01)]) which encodes type information
    in the prefix of the identifiers, such as szName, where sz stands for *string*
    and *zero terminated*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*匈牙利命名法**^C**，在标识符的前缀中编码类型信息，例如 szName，其中 sz 代表 *字符串* 和 *以零结尾的*。'
- en: ¹
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Invented in Simonyi [[1976](kindle_split_036.html#bib16)], the PhD thesis of
    Simonyi Károly
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由 Simonyi [[1976](kindle_split_036.html#bib16)] 发明，Simonyi Károly 的博士论文。
- en: 'As you might imagine, none of these is ideal. The first two tend to obscure
    our view: they easily clog up a whole precious line of programming text with an
    unreadable expression:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，这些都不理想。前两个往往模糊了我们的视线：它们很容易用难以阅读的表达式填满宝贵的编程文本的一整行：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Hungarian notation, in turn, tends to use obscure abbreviations for types or
    concepts, produces unpronounceable identifiers, and completely breaks down if
    you have an API change.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法反过来又倾向于使用类型或概念的晦涩缩写，产生难以发音的标识符，并且在 API 更改时完全崩溃。
- en: So, in my opinion, none of these rules or strategies have absolute values. I
    encourage you to take a pragmatic approach to the question.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我看来，这些规则或策略都没有绝对的价值。我鼓励你对此问题采取实用主义的方法。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.10
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 9.10
- en: '*Naming is a creative act.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名是一种创造性行为*。'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It is not easily subsumed by simple technical rules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它不容易被简单的技术规则所包含。
- en: 'Obviously, good naming is more important the more widely an identifier is used.
    So, it is particularly important for identifiers for which the declaration is
    generally out of view of the programmer: global names that constitute the API.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，标识符使用得越广泛，良好的命名就越重要。因此，对于声明通常不在程序员视线范围内的标识符来说，这一点尤为重要：构成 API 的全局名称。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.11
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 9.11
- en: '*File-scope identifiers must be comprehensive.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件作用域的标识符必须是全面的*。'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What constitutes *comprehensive* here should be derived from the type of the
    identifier. Type names, constants, variables, and functions generally serve different
    purposes, so different strategies apply.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所说的 *全面性* 应该从标识符的类型中得出。类型名称、常量、变量和函数通常服务于不同的目的，因此应用不同的策略。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.12
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 9.12
- en: '*A type name identifies a concept.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型名称标识一个概念*。'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Examples of such concepts are *time* for **`struct`** **`timespec`**, *size*
    for **`size_t`**, a collection of corvidae for **`enum`** corvid, *person* for
    a data structure that collects data about people, *list* for a chained list of
    items, *dictionary* for a query data structure, and so on. If you have difficulty
    coming up with a concept for a data structure, an enumeration, or an arithmetic
    type, you should probably revisit your design.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种概念的例子包括 *time* 用于 **`struct`** **`timespec`**，*size* 用于 **`size_t`**，一组乌鸦用于
    **`enum`** 乌鸦，*person* 用于收集有关人们数据的结构，*list* 用于项目的链表，*dictionary* 用于查询数据结构，等等。如果你在为数据结构、枚举或算术类型构思概念时遇到困难，你可能需要重新审视你的设计。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 9.13
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得 9.13
- en: '*A global constant identifies an artifact.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局常量标识一个工件*。'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That is, a constant *stands out* for some reason from the other possible constants
    of the same type: it has a special meaning. It may have this meaning for some
    external reason beyond our control (M_PI for π), because the C standard says so
    (**`false`**, **`true`**), because of a restriction of the execution platform
    (**`SIZE_MAX`**), to be factual (corvid_num), for a reason that is culturally
    motivated (fortytwo), or as a design decision.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 即，一个常数 *因其某种原因而突出* 出于其他相同类型的可能常数：它具有特殊的意义。它可能具有这种意义是因为一些超出我们控制的外部原因（M_PI 对于
    π），因为C标准这么说（**`false`**，**`true`**），因为执行平台的限制（**`SIZE_MAX`**），为了真实（corvid_num），因为文化上的原因（fortytwo），或者作为设计决策。
- en: Generally, we will see shortly that file-scope variables (*globals*) are much
    frowned upon. Nevertheless, they are sometimes unavoidable, so we have to have
    an idea how to name them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们很快就会看到，文件作用域变量（*全局变量*）是不被看好的。尽管如此，它们有时是不可避免的，因此我们必须有一个命名它们的概念。
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.14
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 9.14
- en: '*A global variable identifies state.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局变量标识状态*。'
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Typical names for such variables are toto_initialized to encode the fact that
    library *toto* has already been initialized, onError for a file-scope but internal
    variable that is set in a library that must be torn down, and visited_entries
    for a hash table that collects shared data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的变量通常命名为 toto_initialized，以表示库 *toto* 已经被初始化，onError 用于文件作用域但内部变量，该变量在必须拆除的库中设置，visited_entries
    用于收集共享数据的哈希表。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 9.15
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 9.15
- en: '*A function or functional macro identifies an action.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数或功能宏标识一个动作*。'
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Not all, but many, of the functions in the C standard library follow that rule
    and use verbs as a component of their names. Here are some examples:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有，但许多C标准库中的函数都遵循该规则，并使用动词作为它们名称的组成部分。以下是一些示例：
- en: A standard function that compares two strings is **strcmp**.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个比较两个字符串的标准函数是 **strcmp**。
- en: A standard macro that queries for a property is **`isless`**.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个查询属性的标准化宏是 **`isless`**。
- en: A function that accesses a data member could be called toto_getFlag.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据成员的函数可以被称为 toto_getFlag。
- en: The corresponding one that sets such a member would be toto_setFlag.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置此类成员的对应函数将是 toto_setFlag。
- en: A function that multiples two matrices is matrixMult.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个乘以两个矩阵的函数是 matrixMult。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Coding style is a matter of culture. Be tolerant and patient.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码风格是一个文化问题。要有耐心和宽容。
- en: Code formatting is a matter of visual habits. It should be automatically provided
    by your environment such that you and your co-workers can read and write code
    effortlessly.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码格式化是视觉习惯的问题。它应该由你的环境自动提供，这样你和你的同事就可以轻松地阅读和编写代码。
- en: Naming of variables, functions, and types is an art and plays a central role
    in the comprehensiveness of your code.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量、函数和类型的命名是一门艺术，并在你代码的全面性中扮演着核心角色。
- en: Chapter 10\. Organization and documentation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 组织和文档
- en: This chapter covers
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How to document interfaces
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何记录接口
- en: How to explain implementations
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解释实现
- en: 'Being an important societal, cultural, and economic activity, programming needs
    a certain form of organization to be successful. As with coding style, beginners
    tend to underestimate the effort that should be put into code and project organization
    and documentation: unfortunately, many of us have to go through the experience
    of reading our own code some time after we wrote it, and not having any clue what
    it was all about.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项重要的社会、文化和经济活动，编程需要一定的组织形式才能成功。就像编码风格一样，初学者往往低估了应该投入到代码、项目和文档中的努力：不幸的是，我们中的许多人不得不在写完代码一段时间后阅读自己的代码，却对它是什么毫无头绪。
- en: 'Documenting or, more generally, explaining program code is not an easy task.
    We have to find the right balance between providing context and necessary information
    and boringly stating the obvious. Let’s have a look at the two following lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记录或更普遍地说，解释程序代码不是一件容易的任务。我们必须在提供上下文和必要信息以及枯燥地陈述显而易见的事实之间找到正确的平衡。让我们看看以下两行：
- en: '[PRE3]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line isn’t good, because it uses magic constants, a function name
    that doesn’t tell what is going on, and a variable name that does not have much
    meaning, at least to me. The smiley comment indicates that the programmer had
    fun when writing this, but it is not very helpful to the casual reader or maintainer.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行不太好，因为它使用了魔法常量，一个不说明正在发生什么的函数名，以及一个没有太多意义的变量名，至少对我来说是这样。笑脸注释表明程序员在编写这个时很开心，但这对于普通读者或维护者来说并不很有帮助。
- en: In the second line, the comment is superfluous and states what any even not-so-experienced
    programmer knows about the `++` operator.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，注释是多余的，它陈述了任何甚至不太有经验的程序员都知道的关于`++`操作符的知识。
- en: 'Compare this to the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与以下内容进行比较：
- en: '[PRE4]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we may deduce a lot more. I’d expect u to be a floating-point value, probably
    **`double`**: that is, subject to an approximation procedure. That procedure runs
    in steps, indexed by i, and needs some additional arguments that are subject to
    a primality condition.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以推断出更多。我预计u是一个浮点值，可能是**`double`**：即，受近似过程的影响。这个过程分步骤进行，由i索引，并需要一些额外的参数，这些参数需要满足素性条件。
- en: 'Generally, we have the *what*, *what for*, *how*, and *in which manner* rules,
    in order of their importance:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我们按照重要性的顺序有*什么*、*为什么*、*如何*和*以何种方式*规则：
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.1 (what)
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.1（什么）
- en: '*Function interfaces describe* what *is done.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数接口描述*了*做了什么*。'
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.2 (what for)
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.2（为什么）
- en: '*Interface comments document the purpose of a function.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口注释记录了函数的目的*。'
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.3 (how)
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.3（如何）
- en: '*Function code tells* how *the function is organized.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数代码说明*了函数是如何组织的。'
- en: '|  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.4 (in which manner)
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.4（以何种方式）
- en: '*Code comments explain the manner in which function details are implemented.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码注释解释了函数细节是如何实现的*。'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In fact, if you think of a larger library project that is used by others, you’d
    expect that all users will read the interface specification (such as in the synopsis
    part of a `man` page), and most of them will read the explanation about these
    interfaces (the rest of the `man` page). Much fewer of them will look at the source
    code and read about *how* or *in which manner* a particular interface implementation
    does things the way it does them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你考虑一个更大的库项目，该项目被其他人使用，你预计所有用户都会阅读接口规范（例如在`man`页面的概要部分），其中大多数人会阅读关于这些接口的解释（`man`页面的其余部分）。其中很少有人会查看源代码并了解*如何*或*以何种方式*一个特定的接口实现以这种方式做事。
- en: A first consequence of these rules is that code structure and documentation
    go hand in hand. The distinction between interface specification and implementation
    is expecially important.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的一个直接后果是代码结构和文档是相辅相成的。接口规范和实现之间的区别尤为重要。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.5
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.5
- en: '*Separate interface and implementation.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*分离接口和实现*。'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This rule is reflected in the use of two different kinds of C source files:
    *header files**^C*, usually ending with ".h"; and *translation units**^C* (*TU*),
    ending with ".c".'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则体现在使用两种不同的C源文件：*头文件**^C*，通常以".h"结尾；和*翻译单元**^C*（*TU*），通常以".c"结尾。
- en: 'Syntactical comments have two distinct roles in those two kinds of source files
    that should be separated:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 语法注释在这两种源文件中有两个不同的角色，应该分开：
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.6
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.6
- en: '*Document the interface—explain the implementation.*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录接口—解释实现*。'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. Interface documentation
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 接口文档
- en: 'In contrast to more recent languages such as Java and Perl, C has no “built-in”
    documentation standard. But in recent years, a cross-platform public domain tool
    has been widely adopted in many projects: doxygen ([http://www.doxygen.nl/](http://www.doxygen.nl/)).
    It can be used to automatically produce web pages, PDF manuals, dependency graphs,
    and a lot more. But even if you don’t use doxygen or another equivalent tool,
    you should use its syntax to document interfaces.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java和Perl等更现代的语言相比，C没有“内置”的文档标准。但近年来，一个跨平台的公共领域工具在许多项目中得到了广泛采用：doxygen ([http://www.doxygen.nl/](http://www.doxygen.nl/))。它可以用来自动生成网页、PDF手册、依赖图等等。但即使你不使用doxygen或其他等效工具，你也应该使用它的语法来记录接口。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.7
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要10.7
- en: '*Document interfaces thoroughly.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*彻底记录接口*。'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Doxygen has a lot of categories that help with that, but an extended discussion
    goes far beyond the scope of this book. Just consider the following example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen有很多类别可以帮助你做到这一点，但更深入的讨论超出了本书的范围。只需考虑以下示例：
- en: '`heron_k.h`'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`heron_k.h`'
- en: '[PRE5]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Doxygen produces online documentation for that function that looks similar
    to [figure 10.1](#ch10fig01) and also is able to produce formatted text that we
    can include in this book:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 为该函数生成在线文档，其外观类似于[图10.1](#ch10fig01)，并且能够生成我们可以包含在这本书中的格式化文本：
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`heron_k.h`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`heron_k.h`'
- en: 'heron: use the Heron process to approximate *a* to the power of `1`/k'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: heron：使用Heron过程将*a*的`1`/k次幂近似
- en: Or in other words this computes the *k**^(th)* root of *a*. As a special feature,
    if *k* is `-1` it computes the multiplicative inverse of *a*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者换句话说，这是计算 *a* 的 *k* 次根。作为一个特殊功能，如果 *k* 是 `-1`，它将计算 *a* 的乘法逆。
- en: '**Parameters:**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数：**'
- en: '| a | must be greater than 0.0 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| a | 必须大于 0.0 |'
- en: '| k | should | not | be | 0 | and | otherwise | be | between |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| k | 应该 | 不 | 是 | 0 | 并且 | 否则 | 应该 | 在 |'
- en: '|   | **DBL_MIN_EXP***FLT_RDXRDX and **DBL_MAX_EXP***FLT_RDXRDX. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|   | **DBL_MIN_EXP***FLT_RDXRDX 和 **DBL_MAX_EXP***FLT_RDXRDX。|'
- en: '**See also:** FLT_RDXRDX'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**另请参阅:** FLT_RDXRDX'
- en: '[PRE6]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`heron_k.h`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`heron_k.h`'
- en: 'FLT_RDXRDX: the radix base 2 of **`FLT_RADIX`**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'FLT_RDXRDX: **`FLT_RADIX`** 的基数2'
- en: This is needed internally for some of the code below.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于下面的一些代码在内部是必需的。
- en: '[PRE7]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 10.1\. Documentation produced by doxygen
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. doxygen生成的文档
- en: '![](10fig01_alt.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig01_alt.jpg)'
- en: 'As you have probably guessed, words starting with @ have a special meaning
    for doxygen: they start its keywords. Here we have @param, @a, and @brief. The
    first documents a function parameter, the second refers to such a parameter in
    the rest of the documentation, and the last provides a brief synopsis of the function.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，以 @ 开头的单词对doxygen有特殊意义：它们是其关键字的开始。这里我们有 @param、@a 和 @brief。第一个记录函数参数，第二个在文档的其余部分引用该参数，最后一个提供了函数的简要概述。
- en: Additionally, we see that there is some markup capacity inside comments, and
    also that doxygen was able to identify the place in translation unit "heron_k.c"
    that defines the function and the call graph of the different functions involved
    in the implementation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们注意到在注释中存在一些标记能力，并且doxygen能够识别翻译单元 "heron_k.c" 中定义函数及其涉及实现的不同函数的调用图。
- en: To provide good project organization, it is important that users of your code
    be able to easily find connected pieces and not have to search all over the place.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供良好的项目组织，重要的是用户能够轻松地找到相关的部分，而无需四处搜索。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.8
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获10.8
- en: '*Structure your code in units that have strong semantic connections.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*将代码组织成具有强语义连接的单元。*'
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Most often, this is simply done by grouping all functions that treat a specific
    data type in one header file. A typical header file "brian.h" for **`struct`**
    brian would be like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法是将处理特定数据类型的所有函数分组到一个头文件中。对于 **`struct`** brian的典型头文件 "brian.h" 可能如下所示：
- en: '[PRE8]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That file comprises all the interfaces that are necessary to use the **`struct`**.
    It also includes other header files that might be needed to compile these interfaces
    and protect against multiple inclusion with *include guards**^C*, here the macro
    BRIAN_H.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含使用 **`struct`** 所必需的所有接口。它还包括可能需要编译这些接口并使用 *include guards**^C*（这里宏为 BRIAN_H）来防止多次包含的其他头文件。
- en: 10.2\. Implementation
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 实现
- en: If you read code that is written by good programmers (and you should do that
    often!), you’ll notice that it is often scarcely commented. Nevertheless, it may
    be quite readable, provided the reader has basic knowledge of the C language.
    Good programming only needs to explain the ideas and prerequisites that are *not*
    obvious (the difficult part). The structure of the code shows what it does and
    how.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读的是优秀程序员编写的代码（你应该经常这样做！），你会注意到它通常注释很少。然而，如果读者具备C语言的基本知识，它可能仍然很容易阅读。优秀的编程只需要解释那些不明显的想法和前提（困难的部分）。代码的结构显示了它做什么以及如何做。
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.9
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获10.9
- en: '*Implement literally.*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接实现。*'
- en: '|  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A C program is a descriptive text about what is to be done. The rules for naming
    entities that we introduced earlier play a crucial role in making that descriptive
    text readable and clear. Another requirement is to have an obvious flow of control
    through visually clearly distinctive structuring in `{}` blocks that are linked
    together with comprehensive control statements.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C程序是对要做什么的描述性文本。我们之前引入的实体命名规则对于使描述性文本可读和清晰起着至关重要的作用。另一个要求是，通过视觉上明显区分的 `{}` 块的结构，以及与之相关的综合控制语句，要有明显的控制流程。
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.10
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获10.10
- en: '*Control flow must be obvious.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制流程必须明显。*'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'There are many possibilities to obfuscate control flow. The most important
    are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以混淆控制流程。以下是最重要的几种：
- en: '*Buried jumps:* – **`break`**, **`continue`**, **`return`**, and **`goto`**^([[1](#ch10fn01)])
    statements that are buried in a complicated nested structure of **`if`** or **`switch`**
    statements, eventually combined with loop structures.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌套跳转:* – 隐藏在复杂的嵌套结构中的**`break`**、**`continue`**、**`return`**和**`goto`**^([[1](#ch10fn01)])语句，最终与循环结构结合。'
- en: ¹
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: These will be discussed in [sections 13.2.2](kindle_split_023.html#ch13lev2sec4)
    and [14.5](kindle_split_024.html#ch14lev1sec5).
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些内容将在[第13.2.2节](kindle_split_023.html#ch13lev2sec4)和[第14.5节](kindle_split_024.html#ch14lev1sec5)中讨论。
- en: '*Flyspeck expressions:* – Controlling expressions that combine a lot of operators
    in an unusual way (for example, `!!++``*`p`--` or a `--> 0`) such that they must
    be examined with a magnifying glass to understand where the control flow goes
    from here.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*飞蛾扑火表达式:* – 控制表达式，以不寻常的方式组合大量运算符（例如，`!!++``*`p`--`或`--> 0`），以至于必须用放大镜检查才能理解控制流从这里开始。'
- en: 'In the following section, we will focus on two concepts that can be crucial
    for readability and performance of C code. A *macro* can be a convenient tool
    to abbreviate a certain feature, but, if used carelessly, may also obfuscate code
    that uses it and trigger subtle bugs ([section 10.2.1](#ch10lev2sec1)). As we
    saw previously, functions are the primary choice in C for modularization. Here,
    a particular property of some functions is especially important: a function that
    is *pure* only interacts with the rest of the program via its interface. Thereby,
    pure functions are easily understandable by humans and compilers and generally
    lead to quite efficient implementations ([section 10.2.2](#ch10lev2sec2)).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将关注两个对于C代码的可读性和性能至关重要的概念。一个*宏*可以是一个方便的工具，用于简写某个功能，但如果使用不当，也可能使使用它的代码变得晦涩，并触发微妙的错误([第10.2.1节](#ch10lev2sec1))。正如我们之前所看到的，函数是C中模块化的主要选择。在这里，某些函数的特定属性特别重要：一个*纯*函数仅通过其接口与程序的其他部分交互。因此，纯函数对人类和编译器来说很容易理解，并且通常会导致相当高效的实现([第10.2.2节](#ch10lev2sec2))。
- en: 10.2.1\. Macros
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 宏
- en: 'We already know one tool that can be abused to obfuscate control flow: macros.
    As you hopefully remember from [sections 5.6.3](kindle_split_013.html#ch05lev2sec8)
    and [8.1.2](kindle_split_016.html#ch08lev2sec2), macros define textual replacements
    that can contain almost any C text. Because of the problems we will illustrate
    here, many projects ban macros completely. This is not the direction the evolution
    of the C standard goes, though. As we have seen, for example, type-generic macros
    are *the* modern interface to mathematical functions (see [8.2](kindle_split_016.html#ch08lev1sec2));
    macros should be used for initialization constants ([section 5.6.3](kindle_split_013.html#ch05lev2sec8))
    or used to implement compiler magic (**`errno`**, [section 8.1.3](kindle_split_016.html#ch08lev2sec3)).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道一个可能被滥用的工具来混淆控制流：宏。正如你希望从[第5.6.3节](kindle_split_013.html#ch05lev2sec8)和[第8.1.2节](kindle_split_016.html#ch08lev2sec2)中回忆起来的那样，宏定义了可以包含几乎任何C文本的文本替换。由于我们将在这里展示的问题，许多项目完全禁止使用宏。尽管如此，C标准的演变方向并不是这个。例如，正如我们所见，类型通用的宏是数学函数的*现代接口*（参见[第8.2节](kindle_split_016.html#ch08lev1sec2)）；宏应该用于初始化常量([第5.6.3节](kindle_split_013.html#ch05lev2sec8))或用于实现编译器魔法(**`errno`**，[第8.1.3节](kindle_split_016.html#ch08lev2sec3))。
- en: So instead of denying it, we should try to tame the beast and set up some simple
    rules that confine the possible damage.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不应该否认这一点，而应该尝试驯服这个野兽，并制定一些简单的规则来限制可能的损害。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.11
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得成果10.11
- en: '*Macros should not change control flow in a surprising way.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏不应该以令人惊讶的方式改变控制流。*'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Notorious examples that pop up in discussion with beginners from time to time
    are things like these:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在与初学者讨论时偶尔会出现的臭名昭著的例子包括这些：
- en: '[PRE9]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Don’t do that. The visual habits of C programmers and our tools don’t easily
    work with something like that, and if you use such things in complicated code,
    they will almost certainly go wrong.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。C程序员的视觉习惯和我们的工具不太容易与这类东西配合，如果在复杂的代码中使用这类东西，它们几乎肯定会出错。
- en: 'Here, the ERRORCHECK macro is particularly dangerous. Its name doesn’t suggest
    that a nonlocal jump such as a **`return`** might be hidden in there. And its
    implementation is even more dangerous. Consider the following two lines:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，ERRORCHECK宏尤其危险。其名称并不暗示其中可能隐藏着非局部跳转，例如**`return`**。其实现方式甚至更加危险。考虑以下两行：
- en: '[PRE10]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These lines are rewritten as
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行被重写为
- en: '[PRE11]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **`else`**-clause (a so-called *dangling* **`else`***^C*) is attached to
    the innermost **`if`**, which we don’t see. So this is equivalent to
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**`else`**-子句（所谓的*悬挂* **`else`**）附加在最内层的 **`if`** 上，我们看不到。所以这相当于'
- en: '[PRE12]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: which is probably quite surprising to the casual reader.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对普通读者来说相当令人惊讶。
- en: 'This doesn’t mean control structures shouldn’t be used in macros at all. They
    just should not be hidden and should have no surprising effects. This macro by
    itself is probably not as obvious, but its *use* has no surprises:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着在宏中完全不应用控制结构。只是它们不应该被隐藏，并且不应该产生令人惊讶的效果。这个宏本身可能并不那么明显，但它的*使用*并没有令人惊讶：
- en: '[PRE13]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The name of the following macro makes it explicit that there might be a **`return`**.
    The dangling **`else`** problem is handled by the replaced text:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下宏的名称明确表示可能存在一个**`return`**。悬而未决的**`else`**问题通过替换后的文本得到处理：
- en: '[PRE14]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next example structures the code as expected, with the **`else`** associated
    with the first **`if`**:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例按照预期结构化了代码，其中**`else`**与第一个**`if`**相关联：
- en: '[PRE15]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The **`do`**`-`**`while`**`(`**`false`**`)`-trick is obviously ugly, and you
    shouldn’t abuse it. But it is a standard trick to surround one or several statements
    with a `{}` block without changing the block structure that is visible to the
    naked eye.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**`do`**`-`**`while`**`(`**`false`**`)`-技巧显然很丑陋，你不应该滥用它。但这是一个标准的技巧，用于在不改变肉眼可见的块结构的情况下，用
    `{}` 块包围一个或多个语句。'
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.12
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取走 10.12
- en: '*Function-like macros should syntactically behave like function calls.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式宏在语法上应该表现得像函数调用。*'
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Possible pitfalls are:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的陷阱包括：
- en: '****if** *without* **else***:*** Already demonstrated.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****if** *without* **else***:*** 已经演示过。'
- en: '**Trailing semicolons*:*** These can terminate an external control structure
    in a surprising way.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾随分号**：*这些可以以令人惊讶的方式终止外部控制结构。*'
- en: '**Comma operators*:*** The comma is an ambiguous fellow in C. In most contexts,
    it is used as a list separator, such as for function calls, enumerator declarations,
    or initializers. In the context of expressions, it is a control operator. Avoid
    it.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逗号运算符**：*** 逗号在C语言中是一个模糊的角色。在大多数情况下，它被用作列表分隔符，例如用于函数调用、枚举声明或初始化器。在表达式的上下文中，它是一个控制运算符。避免使用它。'
- en: '***Continuable expressions:*** Expressions that will bind to operators in an
    unexpected way when put into a nontrivial context.^([[[Exs 1]](#ch10fn-ex01)])
    In the replacement text, put parentheses around parameters and expressions.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可续表达式：*** 当放入非平凡上下文中时，这些表达式将以意想不到的方式绑定到运算符上.^([[[Exs 1]](#ch10fn-ex01)])
    在替换文本中，将参数和表达式用括号括起来。'
- en: ^([Exs 1])
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider a macro su`m(`a`,` b`)` that is implemented as a`+`b. What is the result
    of su`m(5, 2)``*``7`?
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑一个宏函数`su`m(`a`,` b`)`，它被实现为`a``+`b。`su`m(`5, 2`)``*``7`的结果是什么？
- en: '***Multiple evaluation:*** Macros are textual replacements. If a macro parameter
    is used twice (or more), its effects are done twice.^([[[Exs 2]](#ch10fn-ex02)])'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***多重评估：*** 宏是文本替换。如果一个宏参数被使用两次（或更多），其效果会被执行两次.^([[[Exs 2]](#ch10fn-ex02)])'
- en: ^([Exs 2])
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 2])
- en: ''
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let max`(`a`,` b`)` be implemented as `((`a`) < (`b`) ? (`b`) : (`a`))`. What
    happens for max`(`i`++, 5)`?'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '让`max(a, b)`的实现为`((a) < (b) ? (b) : (a))`。对于`max(i++, 5)`会发生什么？'
- en: 10.2.2\. Pure functions
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 纯函数
- en: 'Functions in C such as size_min ([section 4.4](kindle_split_012.html#ch04lev1sec4))
    and gcd ([section 7.3](kindle_split_015.html#ch07lev1sec3)), which we declared
    ourselves, have a limit in terms of what we are able to express: they don’t operate
    on objects but rather on values. In a sense, they are extensions of the value
    operators in [table 4.1](kindle_split_012.html#ch04table01) and not of the object
    operators in [table 4.2](kindle_split_012.html#ch04table02).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.13
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 10.13
- en: '*Function parameters are passed by value.*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数参数是通过值传递的*。'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That is, when we call a function, all parameters are evaluated, and the parameters
    (variables that are local to the function) receive the resulting values as initialization.
    The function then does whatever it has to do and sends back the result of its
    computation through the return value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当我们调用一个函数时，所有参数都会被评估，并且参数（函数局部变量）会接收到这些值的初始化。然后函数执行它需要做的操作，并通过返回值发送计算结果。
- en: 'For the moment, the only possibility that we have for two functions to manipulate
    the same *object* is to declare an object such that the declaration is visible
    to both functions. Such *global variables**^C* have a lot of disadvantages: they
    make code inflexible (the object to operate on is fixed), are difficult to predict
    (the places of modification are scattered all over), and are difficult to maintain.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们让两个函数操作同一*对象*的唯一可能性是声明一个对象，使得声明对两个函数都是可见的。这样的*全局变量**^C*有很多缺点：它们使代码缺乏灵活性（要操作的对象是固定的）、难以预测（修改的位置散布各处），并且难以维护。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.14
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 10.14
- en: '*Global variables are frowned upon.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局变量是不受欢迎的。*'
- en: '|  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A function with the following two properties is called *pure**^C*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 具有以下两个特性的函数被称为*纯**^C*函数：
- en: The function has no effects other than returning a value.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数除了返回值外没有其他影响。
- en: The function return value only depends on its parameters.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回值只取决于其参数。
- en: The only interest in the execution of a pure function is its result, and that
    result only depends on the arguments that are passed. From the point of view of
    optimization, pure functions can be moved around or even executed in parallel
    to other tasks. Execution can start at any point when its parameters are available
    and must be finished before the result is used.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对纯函数执行的唯一兴趣是其结果，而这个结果只取决于传递的参数。从优化的角度来看，纯函数可以被移动或甚至与其他任务并行执行。执行可以在参数可用时开始，必须在结果被使用之前完成。
- en: Effects that would disqualify a function from being pure would be all those
    that change the abstract state machine other than by providing the return value.
    For example,
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 会使函数失去纯性的影响包括所有那些除了提供返回值之外改变抽象状态机的操作。例如，
- en: The function reads part of the program’s changeable state by means other than
    through its arguments.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数通过除其参数之外的其他方式读取程序的可变状态。
- en: The function modifies a global object.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数修改了一个全局对象。
- en: The function keeps a persistent internal state between calls.^([[2](#ch10fn02)])
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数在调用之间保持持久内部状态.^([[2](#ch10fn02)])
- en: ²
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Persistent state between calls to the same function can be established with
    local **`static`** variables. We will see this concept in [section 13.2](kindle_split_023.html#ch13lev1sec2).
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在对同一函数的多次调用之间，可以使用局部**`static`**变量来建立持久状态。我们将在[第13.2节](kindle_split_023.html#ch13lev1sec2)中看到这个概念。
- en: The function does IO.^([[3](#ch10fn03)])
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数执行IO.^([[3](#ch10fn03)])
- en: ³
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Such an IO would occur, for example, by using **printf**.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，通过使用**printf**可以发生这样的IO。
- en: Pure functions are a very good model for functions that perform small tasks,
    but they are pretty limited once we have to perform more complex ones. On the
    other hand, optimizers *love* pure functions, since their impact on the program
    state can simply be described by their parameters and return value. The influence
    on the abstract state machine that a pure function can have is very local and
    easy to describe.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是执行小任务的函数的一个非常好的模型，但一旦我们需要执行更复杂的任务，它们的局限性就变得相当明显。另一方面，优化器*喜欢*纯函数，因为它们对程序状态的影响可以简单地通过它们的参数和返回值来描述。纯函数对抽象状态机可能产生的影响非常局部且易于描述。
- en: '|  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 10.15
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 10.15
- en: '*Express small tasks as pure functions whenever possible.*'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能将小任务表示为纯函数。*'
- en: '|  |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'With pure functions, we can go surprisingly far, even for an object-oriented
    programming style, if for a first approach we are willing to accept a little bit
    of copying data around. Consider the following structure type rat that is supposed
    to be used for rational arithmetic:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯函数，即使是在面向对象编程风格中，我们也可以走得很远，如果我们愿意在第一次尝试时接受一点数据复制的代价。考虑以下结构类型rat，它被用来进行有理数运算：
- en: '`rationals.h`'
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.h`'
- en: '[PRE16]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a direct implementation of such a type, and nothing you should use
    as a library outside the scope of this learning experience. For simplicity, it
    has a numerator and denominator of identical type (**`size_t`**) and keeps track
    of the sign of the number in member .sign. A first (pure) function is rat_get,
    which takes two numbers and returns a rational number that represents their quotient:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对这种类型的直接实现，而且你绝对不应该将其用作库，除非在这个学习经验的范围内。为了简单起见，它有一个与分子相同的类型(**`size_t`**)的分母，并通过成员.sign跟踪数字的符号。第一个（纯）函数是rat_get，它接受两个数字并返回一个表示它们商的有理数：
- en: '`rationals.c`'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE17]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the function is quite simple. It just initializes a compound
    literal with the correct sign and numerator and denominator values. Notice that
    if we define a rational number this way, several representations will represent
    the same rational number. For example, the number ![](6by15.jpg) is the same as
    ![](2by5.jpg).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数相当简单。它只是使用正确的符号、分子和分母值初始化一个复合字面量。请注意，如果我们以这种方式定义一个有理数，几个表示将代表相同的有理数。例如，数字![6by15.jpg](https://example.org/6by15.jpg)与![2by5.jpg](https://example.org/2by5.jpg)相同。
- en: 'To deal with this equivalence in the representations, we need functions that
    do maintenance. The main idea is that such rational numbers should always be normalized:
    that is, use the representation such that numerator and denominator have the fewest
    factors. Not only is this easier for humans to capture, but it also may avoid
    overflows while doing arithmetic:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种表示中的等价性，我们需要维护函数。主要思想是这些有理数应该始终是归一化的：也就是说，使用分子和分母具有最少因子的表示。这不仅更容易为人类所理解，而且在执行算术运算时也可能避免溢出：
- en: '`rationals.c`'
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE18]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the gcd function is as we described earlier.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，gcd函数正如我们之前所描述的那样。
- en: 'Another function does the inverse of normalization; it multiplies the numerator
    and denominator by a redundant factor:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数执行归一化的逆操作；它通过一个冗余因子乘以分子和分母：
- en: '`rationals.c`'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE19]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This way, we may define functions that are supposed to be used by others: rat_get_prod
    and rat_get_sum.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以定义其他人应该使用的函数：rat_get_prod和rat_get_sum。
- en: 'Have a look at rat_get_prod:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 看看rat_get_prod：
- en: '`rationals.c`'
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE20]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It first computes a representation of the result in a simple way: by just multiplying
    numerators and denominators, respectively. Then, the resulting representation
    might not be normalized, so we call rat_get_normal when we return the result.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先以简单的方式计算结果的一种表示：通过分别相乘分子和分母。然后，得到的表示可能没有归一化，因此我们在返回结果时调用rat_get_normal。
- en: 'Now rat_get_sum is a bit more complicated. We have to find the common denominator
    before we can compute the numerator of the result:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，rat_get_sum要复杂一些。在我们可以计算结果的分子之前，我们必须找到公共分母：
- en: '`rationals.c`'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE21]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Also, we have to keep track of the signs of the two rational numbers to see
    how we should add up the numerators.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须跟踪两个有理数的符号，以了解我们应该如何将分子相加。
- en: As you can see, the fact that these are all pure functions ensures that they
    can be easily used, even in our own implementation here. The only thing we have
    to watch is to always assign the return values of our functions to a variable,
    such as on line 38\. Otherwise, since we don’t operate on the object x but only
    on its value, changes during the function would be lost.^([[[Exs 3]](#ch10fn-ex03)])
    ^([[[Exs 4]](#ch10fn-ex04)])
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些函数都是纯函数，这确保了它们可以很容易地使用，即使在我们的实现中也是如此。我们唯一需要关注的是始终将函数的返回值分配给一个变量，例如在第38行。否则，由于我们不操作对象x，而只是操作它的值，函数中的更改将会丢失.^([[[Exs
    3]](#ch10fn-ex03)]) ^([[[Exs 4]](#ch10fn-ex04)])
- en: ^([Exs 3])
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function rat_get_prod can produce intermediate values that may cause it
    to produce wrong results, even if the mathematical result of the multiplication
    is representable in rat. How is that?
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数rat_get_prod可能会产生中间值，这可能导致它产生错误的结果，即使乘法的数学结果可以在rat中表示。这是怎么回事？
- en: ^([Exs 4])
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reimplement the rat_get_prod function such that it produces a correct result
    every time the mathematical result value is representable in a rat. This can be
    done with two calls to rat_get_normal instead of one.
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重新实现rat_get_prod函数，使其每次数学结果值可以在rat中表示时都产生正确的结果。这可以通过两次调用rat_get_normal而不是一次来实现。
- en: 'As mentioned earlier, because of the repeated copies, this may result in compiled
    code that is not as efficient as it could be. But this is not dramatic at all:
    the overhead from the copy operation can be kept relatively low by good compilers.
    With optimization switched on, they usually can operate directly on the structure
    in place, as it is returned from such a function. Then such worries might be completely
    premature, because your program is short and sweet anyhow, or because its real
    performance problems lay elsewhere. Usually this should be completely sufficient
    for the level of programming skills that we have reached so far. Later, we will
    learn how to use that strategy efficiently by using the **`inline`** functions
    ([section 15.1](kindle_split_026.html#ch15lev1sec1)) and *link-time optimization*
    that many modern tool chains provide.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于重复复制，这可能会导致编译后的代码效率不如预期。但这根本不算什么：通过良好的编译器，复制操作的开销可以保持相对较低。当开启优化时，它们通常可以直接在结构体上操作，就像它从这样的函数返回一样。然后，这样的担忧可能完全过早，因为你的程序既短又简单，或者因为它的真正性能问题在于其他地方。通常，这对于我们迄今为止达到的编程技能水平来说应该完全足够。稍后，我们将学习如何通过使用
    **`inline`** 函数 ([第 15.1 节](kindle_split_026.html#ch15lev1sec1)) 和许多现代工具链提供的 *链接时间优化*
    来有效地使用这种策略。
- en: '[Listing 10.1](#ch10ex08) lists all the interfaces of the rat type that we
    have seen so far (first group). We have already looked at the interfaces to other
    functions that work on *pointers* to rat. These will be explained in more detail
    in [section 11.2](kindle_split_021.html#ch11lev1sec2).'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.1](#ch10ex08) 列出了我们迄今为止看到的 rat 类型的所有接口（第一组）。我们已经研究了其他函数的接口，这些函数在 *指针*
    上工作。这些将在 [第 11.2 节](kindle_split_021.html#ch11lev1sec2) 中更详细地解释。'
- en: Listing 10.1\. A type for computation with rational numbers.
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 用于有理数计算的类型。
- en: '[PRE22]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: For each part of a program, we have to distinguish the object (what are we doing?),
    the purpose (what are we doing it for?), the method (how are we doing it?) and
    the implementation (in which manner are we doing it?).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于程序的每一部分，我们必须区分对象（我们在做什么？）、目的（我们为什么要这样做？）、方法（我们如何做？）和实现（我们以何种方式做？）。
- en: The function and type interfaces are the essence of software design. Changing
    them later is expensive.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和类型接口是软件设计的精髓。更改它们是昂贵的。
- en: An implementation should be as literal as possible and obvious in its control
    flow. Complicated reasoning should be avoided and made explicit where necessary.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应该尽可能直接，并且其控制流程应该明显。应避免复杂的推理，并在必要时明确表达。
- en: Chapter 11\. Pointers
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章\. 指针
- en: This chapter covers
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introduction to pointer operations
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针操作简介
- en: Using pointers with structs, arrays, and functions
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针与结构体、数组和函数
- en: Pointers are the first real hurdle to a deeper understanding of C. They are
    used in contexts where we have to be able to access objects from different points
    in the code, or where data is structured dynamically on the fly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是深入理解 C 的第一个真正障碍。它们用于需要从代码的不同点访问对象或动态结构化数据的上下文中。
- en: The confusion of inexperienced programmers between pointers and arrays is notorious,
    so be warned that you might encounter difficulties in getting the terms correct.
    On the other hand, pointers are one of the most important features of C. They
    are a big plus to help us abstract from the bits and odds of a particular platform
    and enable us to write portable code. So please, equip yourself with patience
    when you work through this chapter, because it is crucial for the understanding
    of most of the rest of this book.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 不经验丰富的程序员在指针和数组之间的混淆是出了名的，所以请小心，你可能会在正确使用这些术语时遇到困难。另一方面，指针是 C 最重要的特性之一。它们是一个很大的优势，可以帮助我们抽象出特定平台的位和奇偶性，并使我们能够编写可移植的代码。所以，当你处理本章内容时，请务必保持耐心，因为这对于理解本书的大部分内容至关重要。
- en: 'The term *pointer**^C* stands for a special derived type construct that “points”
    or “refers” to something. We have seen the syntax for this construct, a type (the
    *referenced type**^C*) that is followed by a `*` character. For example, p0 is
    a pointer to a **`double`**:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 *指针**^C* 代表一种特殊的派生类型构造，它“指向”或“引用”某个东西。我们已经看到了这种构造的语法，即一个类型（*引用类型**^C*），后面跟着一个
    `*` 字符。例如，p0 是一个指向 **`double`** 的指针：
- en: '[PRE23]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The idea is that we have one variable (the pointer) that points to the memory
    of another object:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是我们有一个变量（指针），它指向另一个对象的内存：
- en: '![](pg_169.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_169.jpg)'
- en: An import distinction that we will have to make throughout this chapter is between
    the pointer (on the left of the arrow) and the unnamed object that is pointed
    to (on the right).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要区分指针（箭头左侧）和被指向的无名对象（箭头右侧）。
- en: 'Our first usage of a pointer will be to break the barrier between the code
    of the caller of a function and the code inside a function, and thus allow us
    to write functions that are *not* pure. This example will be a function with this
    prototype:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次使用指针将打破函数调用者的代码和函数内部代码之间的障碍，从而允许我们编写*非纯*函数。这个示例将是一个具有以下原型的函数：
- en: '[PRE24]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we see two function arguments that “point” to objects of type **`double`**.
    In the example, the function double_swap is supposed to interchange (*swap*) the
    contents of these two objects. For example, when the function is called, p0 and
    p1 could be pointing to **`double`** variables d0 and d1, respectively, that are
    defined by the caller:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到两个函数参数“指向”**`double`**类型的对象。在示例中，函数double_swap旨在交换（*交换*）这两个对象的内容。例如，当函数被调用时，p0和p1可能分别指向由调用者定义的**`double`**变量d0和d1，这些变量如下所示：
- en: '![](pg_170-01_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_170-01_alt.jpg)'
- en: 'By receiving information about two such objects, the function double_swap can
    effectively change the contents of the two **`double`** objects without changing
    the pointers themselves:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接收有关两个此类对象的信息，函数double_swap可以有效地更改两个**`double`**对象的内容，而不会更改指针本身：
- en: '![](pg_170-02_alt.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](pg_170-02_alt.jpg)'
- en: Using pointers, the function will be able to apply the change directly to the
    variables of the calling function; a pure function without pointers or arrays
    would not be able to do this.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针，函数将能够直接更改调用函数的变量；没有指针或数组的纯函数无法做到这一点。
- en: 'In this chapter, we will go into the details of different operations with pointers
    ([section 11.1](#ch11lev1sec1)) and specific types for which pointers have particular
    properties: structures ([section 11.2](#ch11lev1sec2)), arrays ([section 11.3](#ch11lev1sec3)),
    and functions ([section 11.4](#ch11lev1sec4)).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍与指针相关的不同操作（[第11.1节](#ch11lev1sec1)）以及指针具有特定属性的特定类型：结构体（[第11.2节](#ch11lev1sec2)）、数组（[第11.3节](#ch11lev1sec3)）和函数（[第11.4节](#ch11lev1sec4)）。
- en: 11.1\. Pointer operations
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 指针操作
- en: 'Pointers are an important concept, so there are several C language operations
    and features just for them. Most importantly, specific operators allow us to deal
    with the “pointing-to” and “pointed-to” relation between pointers and the objects
    to which they point ([section 11.1.1](#ch11lev2sec1)). Also, pointers are considered
    *scalars**^C*: arithmetic operations are defined for them, offset additions ([section
    11.1.2](#ch11lev2sec2)) and subtractions ([section 11.1.3](#ch11lev2sec3)); they
    have state ([section 11.1.4](#ch11lev2sec4)); and they have a dedicated “null”
    state ([section 11.1.5](#ch11lev2sec5)).'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是一个重要的概念，因此有几种专门针对它们的C语言操作和特性。最重要的是，特定的运算符允许我们处理指针与其所指向的对象之间的“指向”和“被指向”关系（[第11.1.1节](#ch11lev2sec1)）。此外，指针被认为是*标量**^C*：为它们定义了算术运算，偏移量加法（[第11.1.2节](#ch11lev2sec2)）和减法（[第11.1.3节](#ch11lev2sec3)）；它们具有状态（[第11.1.4节](#ch11lev2sec4)）；并且它们有一个专门的“空”状态（[第11.1.5节](#ch11lev2sec5)）。
- en: 11.1.1\. Address-of and object-of operators
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. 地址运算符和对象运算符
- en: If we have to perform tasks that can’t be expressed with pure functions, things
    get more involved. We have to poke around in objects that are not variables of
    the function. Pointers are a suitable abstraction to do this.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须执行无法用纯函数表达的任务，事情会变得更加复杂。我们必须在不是函数变量的对象中“探索”。指针是进行这种抽象的合适工具。
- en: 'So, let us use the function double_swap from earlier to swap the contents of
    two **`double`** objects d0 and d1. For the call, we use the unary *address-of**^C*
    operator *“**`&`**”*. It allows us to refer to an object through its *address**^C*.
    A call to our function could look like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用之前提到的double_swap函数来交换两个**`double`**对象d0和d1的内容。对于调用，我们使用一元*地址运算符**^C*“**`&`**”。它允许我们通过其*地址**^C*来引用一个对象。对我们的函数的调用可能如下所示：
- en: '[PRE25]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The type that the address-of operator returns is a *pointer type**^C* and can
    be specified with the `*` notation that we have seen. An implementation of the
    function could look like this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 地址运算符返回的类型是*指针类型**^C*，可以使用我们已看到的`*`符号指定。函数的一个实现可能如下所示：
- en: '[PRE26]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the function, pointers p0 and p1 hold the addresses of the objects on
    which the function is supposed to operate: in our example, the addresses of d0
    and d1. But the function knows nothing about the names of the two variables d0
    and d1; it only knows p0 and p1.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，指针p0和p1持有函数应该操作的对象的地址：在我们的例子中，d0和d1的地址。但函数对d0和d1这两个变量的名称一无所知；它只知道p0和p1。
- en: '![](pg_171-01_alt.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_171-01_alt.jpg)'
- en: 'To access them, another construct that is the inverse of the address-of operator
    is used: the unary *object-of**^C* operator *“**`*`**”*: `*`p0 then is the object
    corresponding to the first argument. With the previous call, that would be d0,
    and similarly `*`p1 is the object d1.^([[[Exs 1]](#ch11fn-ex01)])'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问它们，使用另一个与取地址运算符相反的构造：一元*对象*^C*运算符*“**`*`**”：`*`p0对应于第一个参数的对象。在上一次调用中，那将是d0，同样`*`p1是对象d1.^([[[Exs
    1]](#ch11fn-ex01)])
- en: ^([Exs 1])
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function that receives pointers to three objects and that shifts the
    values of these objects cyclically.
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接收指向三个对象的指针，并循环地移动这些对象的值。
- en: '![](pg_171-02_alt.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_171-02_alt.jpg)'
- en: Please note that the `*` character plays two different roles in the definition
    of double_swap. In a declaration, it creates a new type (a pointer type), whereas
    in an expression it *dereferences**^C* the object to which a pointer *refers**^C*.
    To help distinguish these two usages of the same symbol, we usually flush the
    `*` to the left with no blanks in between if it modifies a type (such as **`double`**`*`)
    and to the right if it dereferences a pointer (`*`p0).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`double_swap`的定义中，`*`字符扮演着两种不同的角色。在声明中，它创建了一个新类型（指针类型），而在表达式中，它*取消引用*^C指向的对象，即指针*引用*^C的对象。为了帮助区分这两个相同符号的用法，我们通常在它修改类型（如**`double`**`*`）时将`*`向左对齐且中间不留空格，如果它取消引用指针（`*`p0）时则向右对齐。
- en: Remember from [section 6.2](kindle_split_014.html#ch06lev1sec2) that in addition
    to holding a valid address, pointers may also be null or indeterminate.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从[第6.2节](kindle_split_014.html#ch06lev1sec2)中提到的，除了持有有效的地址外，指针还可能是空或不确定的。
- en: '|  |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.1
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.1节要点
- en: '*Using* *`*`* *with an indeterminate or null pointer has undefined behavior.*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用不确定或空指针时会有未定义的行为。*'
- en: '|  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In practice, though, both cases will usually behave differently. The first might
    access a random object in memory and modify it. Often this leads to bugs that
    are difficult to trace because it will poke into objects it is not supposed to.
    The second, if the pointer is null, will manifest early during development and
    nicely crash our program. Consider this to be a feature.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，这两种情况通常会表现出不同的行为。第一种可能会访问内存中的随机对象并修改它。这通常会导致难以追踪的bug，因为它会进入它不应该进入的对象。第二种，如果指针为空，则会在开发早期就表现出来，并且会优雅地崩溃我们的程序。请将此视为一个特性。
- en: 11.1.2\. Pointer addition
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 指针加法
- en: 'We already have seen that a valid pointer holds the address of an object of
    its reference type, but actually C assumes more than that:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，一个有效的指针持有其引用类型对象的地址，但实际上C语言假设的更多：
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.2
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.2节要点
- en: '*A valid pointer refers to the first element of an array of the reference type.*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*有效的指针指向引用类型数组的第一个元素。*'
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Or, in other words, a pointer may be used to refer not only to one instance
    of the reference type, but also to an array of an unknown length *n*.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 或者换句话说，指针不仅可以用来引用引用类型的单个实例，还可以用来引用长度为未知*n*的数组。
- en: '![](pg_171-03.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_171-03.jpg)'
- en: This entanglement between the concept of pointers and arrays is taken an important
    step further in the syntax. In fact, for the specification of the function double_swap,
    we wouldn’t even need the pointer notation. In the notation we have used so far,
    it can equally be written as
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法上，指针和数组之间的这种纠缠关系又向前迈出了重要的一步。事实上，对于`double_swap`函数的指定，我们甚至可能不需要指针表示法。在我们已经使用的表示法中，它也可以写成
- en: '[PRE27]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both the use of array notation for the interface and the use of `[0]` to access
    the first element are simple *rewrite operations**^C* that are built into the
    C language. We will see more of this later.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用数组表示法作为接口，还是使用`[0]`来访问第一个元素，都是简单的*重写操作*^C，这些操作都内置于C语言中。我们稍后会看到更多这方面的内容。
- en: 'Simple additive arithmetic allows us to access the following elements of this
    array. This function sums all elements of an array:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的加法运算允许我们访问数组的以下元素。此函数计算数组的所有元素之和：
- en: '[PRE28]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the expression `a`+i is a pointer that points to the *i*^(th) element
    in the array:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，表达式`a`+i是一个指针，它指向数组的第*i*^(th)个元素：
- en: '![](pg_172_alt.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_172_alt.jpg)'
- en: 'Pointer addition can be done in different ways, so the following functions
    sum up the array in exactly the same order:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 指针加法可以以不同的方式完成，所以以下函数以完全相同的顺序累加数组：
- en: '[PRE29]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In iteration *i* of function sum1, we have the following picture:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 sum1 的迭代 *i* 中，我们有以下情况：
- en: '![](pg_173-01_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_173-01_alt.jpg)'
- en: The pointer p walks through the elements of the array until it is greater than
    or equal to a`+`len, the first pointer value that lies beyond the array.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 指针 p 遍历数组的元素，直到它大于或等于 a`+`len，这是第一个位于数组之外的指针值。
- en: 'For function sum2, we have the following picture:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数 sum2，我们有以下情况：
- en: '![](pg_173-02_alt.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_173-02_alt.jpg)'
- en: Here, a refers to the *i*^(th) element of the array. The 0^(th) element is not
    referenced again inside the function, but the information about the end of the
    array is kept in the variable aStop.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，a 指向数组的 *i*^(th) 个元素。0^(th) 个元素在函数内部不再引用，但数组结束的信息保存在变量 aStop 中。
- en: 'These functions can then be called analogously to the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以像以下这样调用：
- en: '[PRE31]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, there is no way to know the length of the array that is hidden
    behind a pointer, so we have to pass it as a parameter into the function. The
    trick with **`sizeof`**, which we saw in [section 6.1.3](kindle_split_014.html#ch06lev2sec3),
    doesn’t work.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有方法知道隐藏在指针后面的数组长度，因此我们必须将长度作为参数传递给函数。我们在[第 6.1.3 节](kindle_split_014.html#ch06lev2sec3)中看到的**`sizeof`**技巧不起作用。
- en: '|  |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.3
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 11.3
- en: '*The length of an array object cannot be reconstructed from a pointer.*'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组对象的长度不能从指针中重建*。'
- en: '|  |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So here, we see a first important difference from arrays.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们看到与数组的一个主要区别。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.4
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 11.4
- en: '*Pointers are not arrays.*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针不是数组*。'
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If we pass arrays through pointers to a function, it is important to retain
    the real length of the array. This is why we prefer the array notation for pointer
    interfaces throughout this book:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数组通过指针传递给函数，保留数组的实际长度很重要。这就是为什么我们在这本书中更喜欢使用数组表示法作为指针接口：
- en: '[PRE32]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These specify exactly the same interfaces as shown earlier, but they clarify
    to the casual reader of the code that a is expected to have len elements.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指定了与之前显示的完全相同的接口，但它们向代码的普通读者阐明了 a 应该有 len 个元素。
- en: 11.1.3\. Pointer subtraction and difference
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3\. 指针减法和差
- en: 'Pointer arithmetic we have discussed so far concerned addition of an integer
    and a pointer. There is also an inverse operation that can subtract an integer
    from a pointer. If we wanted to visit the elements of the array downward, we could
    use this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的指针算术主要涉及整数和指针的加法。还有一个相反的操作，可以从指针中减去一个整数。如果我们想向下遍历数组元素，我们可以使用这个：
- en: '[PRE33]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, p starts out at `a+(`len`-1)`, and in the *i*^(th) iteration the picture
    is:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，p 从 `a+(`len`-1)` 开始，在 *i*^(th) 次迭代中的情况如下：
- en: '![](pg_174_alt.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_174_alt.jpg)'
- en: Note that the summation order in this function is inverted.^([[1](#ch11fn01)])
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个函数中的求和顺序是反转的.^([[1](#ch11fn01)])
- en: ¹
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because of differences in rounding, the result might be slightly different than
    for the first three functions in this series.
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于四舍五入的差异，结果可能略不同于本系列前三个函数。
- en: There is also an operation, *pointer difference**^C*, that takes two pointers
    and evaluates to an integer value their distance apart in number of elements.
    To see that, we extend sum3 to a new version that checks for an error condition
    (one of the array elements being an infinity). In that case, we want to print
    a comprehensive error message and return the culprit to the caller:^([[2](#ch11fn02)])
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个操作，*指针差**^C*，它接受两个指针并计算它们之间元素数量的整数值。为了说明这一点，我们将 sum3 扩展到新版本，该版本检查错误条件（数组中的一个元素是无穷大）。在这种情况下，我们想要打印一个全面的错误信息并将罪魁祸首返回给调用者:^([[2](#ch11fn02)])
- en: ²
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`isinf`** comes from the `math.h` header.'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`isinf`** 来自 `math.h` 头文件。'
- en: '[PRE34]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we use the expression p`-`a to compute the position of the actual element
    in the array.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用表达式 p`-`a 来计算数组中实际元素的位置。
- en: 'This is allowed only if the two pointers refer to elements of the same array
    object:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这只允许两个指针指向同一数组对象的元素：
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.5
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 11.5
- en: '*Only subtract pointers from elements of an array object.*'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*只能从数组对象的元素中减去指针*。'
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The value of such a difference then is simply the difference of the indices
    of the corresponding array elements:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差值的值仅仅是相应数组元素的索引之差：
- en: '[PRE35]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have stressed the fact that the correct type for sizes of objects is **`size_t`**,
    an unsigned type that on many platforms is different from **`unsigned`**. This
    has its correspondence in the type of a pointer difference: in general, we cannot
    assume that a simple **`int`** is wide enough to hold the possible values. Therefore,
    the standard header `stddef.h` provides us with another type. On most architectures,
    it is just the signed integer type that corresponds to **`size_t`**, but we shouldn’t
    care much.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调过，对于对象大小正确的类型是 **`size_t`**，这是一个无符号类型，在许多平台上与 **`unsigned`** 不同。这在指针差类型中也有对应：一般来说，我们不能假设一个简单的
    **`int`** 就足够容纳所有可能的值。因此，标准头文件 `stddef.h` 为我们提供了另一个类型。在大多数架构上，它只是与 **`size_t`**
    对应的有符号整数类型，但我们不必过于关心。
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<stddef.h>`'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有指针差都有类型* **`ptrdiff_t`***.*'
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: 在早期（[要点 11.1](#ch11note01)），我们看到了我们必须小心指针包含的地址（或没有包含的地址）。指针有一个值，即它们包含的地址，而这个值可能会改变。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: 要点 11.8
- en: Takeaway 11.6
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在大多数情况下，确保这一点最简单的方法是显式初始化指针变量（[要点 6.22](kindle_split_014.html#ch06note23)）。
- en: '*All pointer differences have type* **`ptrdiff_t`***.*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.7
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '*使用* **`ptrdiff_t`** *来编码位置或大小的有符号差值。*'
- en: '*Use* **`ptrdiff_t`** *to encode signed differences of positions or sizes.*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1.4\. 指针有效性
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Function sum4 also shows a recipe to print a pointer value for debugging purposes.
    We use the format character `%`p, and the pointer argument is *cast* by `(`**`void`**`*``)`a
    to the obscure type **`void`**`*`. For the moment, take this recipe as a given;
    we do not yet have all the baggage to understand it in full (more details will
    follow in [section 12.4](kindle_split_022.html#ch12lev1sec4)).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要点 11.7
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '`<stddef.h>`'
- en: Takeaway 11.8
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数 `sum4` 也展示了用于调试目的打印指针值的配方。我们使用格式字符 `%`p，并将指针参数通过 `(`**`void`**`*``)`a 转换为神秘的类型
    **`void`**`*`。目前，将这个配方视为已知；我们还没有全部的负担来完全理解它（更多细节将在 [第 12.4 节](kindle_split_022.html#ch12lev1sec4)
    中介绍）。
- en: '*For printing, cast pointer values to* **`void`***`*`**, and use the format*
    *`%`**`p`**.*'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.1.4\. Pointer validity
  id: totrans-495
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要点 11.6
- en: Earlier ([takeaway 11.1](#ch11note01)), we saw that we must be careful about
    the address that a pointer contains (or does not contain). Pointers have a value,
    the address they contain, and that value can change.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Setting a pointer to 0 if it does not have a valid address is very important
    and should not be forgotten. It helps to check and keep track of whether a pointer
    has been set.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针没有有效的地址，将其设置为 0 非常重要，不应被遗忘。这有助于检查和跟踪指针是否已被设置。
- en: '|  |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '*打印时，将指针值转换为* **`void`***`*`**，并使用格式* *`%`**`p`***。'
- en: Takeaway 11.9
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们看到了一些不同类型 *表示* 的例子：也就是说，平台在对象中存储特定类型值的方式。例如，类型 **`size_t`** 的表示可能对另一个类型，例如
    **`double`**，完全无意义。只要我们只直接使用变量，C 的类型系统就会保护我们免受这些表示的任何混淆；一个 **`size_t`** 对象将始终按此类访问，永远不会被解释为（无意义的）**`double`**。
- en: '*Pointers have truth.*'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽快将指针变量设置为* *`0`* *。*'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To avoid clunky comparisons ([takeaway 3.3](kindle_split_011.html#ch03note04)),
    in C programs you often will see code like this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免笨拙的比较（[要点 3.3](kindle_split_011.html#ch03note04)），在 C 程序中你经常会看到这样的代码：
- en: '[PRE36]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Therefore, it is important to control the state of all pointer variables. We
    have to ensure that pointer variables are always null, unless they point to a
    valid object that we want to manipulate.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，控制所有指针变量的状态非常重要。我们必须确保指针变量始终为空，除非它们指向我们想要操作的有效对象。
- en: '|  |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: 要点 11.10
- en: Takeaway 11.10
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '|'
- en: '*Set pointer variables to* *`0`* *as soon as you can.*'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In most cases, the simplest way to ensure this is to initialize pointer variables
    explicitly ([takeaway 6.22](kindle_split_014.html#ch06note23)).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'We have seen some examples of *representations* of different types: that is,
    the way the platform stores the value of a particular type in an object. The representation
    of one type, **`size_t`**, say, could be completely senseless to another type,
    for example **`double`**. As long as we only use variables directly, C’s type
    system will protect us from any mixup of these representations; a **`size_t`**
    object will always be accessed as such and never be interpreted as a (senseless)
    **`double`**.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针有真值。*'
- en: 'If we did not use them carefully, pointers could break that barrier and lead
    us to code that tries to interpret the representation of a **`size_t`** as **`double`**.
    More generally, C even has coined a term for bit patterns that are nonsense when
    they are interpreted as a specific type: a *trap representation**^C* for that
    type. This choice of words (*trap*) is meant to intimidate.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不小心使用它们，指针可能会打破这个障碍，并导致我们尝试将**`size_t`**的表示解释为**`double`**。更普遍地说，C甚至为当它们被解释为特定类型时没有意义的位模式创造了一个术语：该类型的*陷阱表示**^C*。这种用词（*trap*）是为了恐吓。
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.11
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.11
- en: '*Accessing an object that has a trap representation of its type has undefined
    behavior.*'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问具有其类型陷阱表示的对象具有未定义的行为。*'
- en: '|  |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Ugly things can happen if you do, so please don’t try.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，会发生丑陋的事情，所以请不要尝试。
- en: Thus, not only must a pointer be set to an object (or null), but such an object
    also must have the correct type.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不仅指针必须设置为一个对象（或空），而且这样的对象还必须具有正确的类型。
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.12
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.12
- en: '*When dereferenced, a pointed-to object must be of the designated type.*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '*当解引用时，指向的对象必须是指定的类型。*'
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As a direct consequence, a pointer that points beyond array bounds must not
    be dereferenced:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 作为直接后果，指向数组界限之外的指针不得被解引用：
- en: '[PRE37]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, on the last line, p has a value that is beyond the bounds of the array.
    Even if this might be the address of a valid object, we don’t know anything about
    the object it is pointing to. So even if p is valid at that point, accessing the
    contents as a type of **`double`** makes no sense, and C generally forbids such
    access.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在最后一行，p的值超出了数组的界限。即使这可能是一个有效对象的地址，我们也不知道它指向的对象是什么。所以即使在这个点上p是有效的，将其内容作为**`double`**类型访问也没有意义，C通常禁止这种访问。
- en: In the previous example, the pointer addition itself is correct, as long as
    we don’t access the object on the last line. The valid values of pointers are
    all addresses of array elements *and* the address beyond the array. Otherwise,
    **`for`** loops with pointer addition as in the example wouldn’t work reliably.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，指针加法本身是正确的，只要我们不访问最后一行的对象。指针的有效值是数组元素的地址*以及*数组之外的地址。否则，像例子中的那样使用指针加法的**`for`**循环将无法可靠地工作。
- en: '|  |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.13
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.13
- en: '*A pointer must point to a valid object or one position beyond a valid object
    or be null.*'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个指针必须指向一个有效对象或一个有效对象之后的位置，或者为空。*'
- en: '|  |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'So the example only worked up to the last line because the last `++`p left
    the pointer value just one element after the array. This version of the example
    still follows a similar pattern as the one before:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个例子只工作到最后一行，因为最后的`++`p将指针值留在了数组之后的一个元素。这个例子版本仍然遵循与之前类似的模式：
- en: '[PRE38]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Whereas this last example may crash at the increment operation:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这个最后的例子中，增量操作可能会导致崩溃：
- en: '[PRE39]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 11.1.5\. Null pointers
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.5\. 空指针
- en: You may have wondered why, in all this discussion about pointers, the macro
    **`NULL`** has not yet been used. The reason is that, unfortunately, the simple
    concept of a “generic pointer of value 0” didn’t succeed very well.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，在所有关于指针的讨论中，为什么还没有使用宏**`NULL`**。原因是，不幸的是，“值为0的通用指针”这个简单概念并没有取得很好的成功。
- en: C has the concept of a *null pointer**^C* that corresponds to a 0 value of any
    pointer type.^([[3](#ch11fn03)]) Here,
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: C有一个与任何指针类型的0值相对应的*空指针**^C*概念。在这里，
- en: ³
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note the different capitalization of *null* versus **`NULL`**.
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意*null*与**`NULL`**的不同大小写。
- en: '[PRE40]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: nix and nax would be pointer objects of value 0\. But unfortunately, a *null
    pointer constant**^C* is then not what you’d expect.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: nix和nax将是值为0的指针对象。但不幸的是，一个*空指针常数**^C*并不是你所期望的。
- en: 'First, here the term *constant* refers to a compile-time constant, not to a
    **`const`***-qualified* object. So for that reason, both pointer objects *are
    not* null pointer constants. Second, the permissible type for these constants
    is restricted: it may be any constant expression of integer type or of type **`void`**`*`.
    Other pointer types are not permitted, and we will learn about pointers of that
    “type” in [section 12.4](kindle_split_022.html#ch12lev1sec4).'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里的术语*constant*指的是编译时常数，而不是**`const`***-qualified*对象。因此，出于这个原因，指针对象*不是*空指针常数。其次，这些常数的允许类型受到限制：它可以是任何整数类型或**`void`**类型的常数表达式。不允许其他指针类型，我们将在[第12.4节](kindle_split_022.html#ch12lev1sec4)中了解那种“类型”的指针。
- en: 'The definition in the C standard of a possible expansion of the macro **`NULL`**
    is quite loose; it just has to be a null pointer constant. Therefore, a C compiler
    could choose any of the following for it:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: C标准中对宏 **`NULL`** 的可能扩展定义相当宽松；它只需要是一个空指针常量。因此，C编译器可以选择以下任何一个用于它：
- en: '| Expansion | Type |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| 扩展 | 类型 |'
- en: '| --- | --- |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0U | **unsigned** |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| 0U | **无符号** |'
- en: '| 0 | **signed** |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| 0 | **有符号** |'
- en: '| ''\0'' |   |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| ''\0'' |   |'
- en: '| Enumeration constant of value 0 |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 值为0的枚举常量 |'
- en: '| 0UL | **unsigned long** |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| 0UL | **无符号长整型** |'
- en: '| 0L | **signed long** |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 0L | **有符号长整型** |'
- en: '| 0ULL | **unsigned long long** |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 0ULL | **无符号长整型** |'
- en: '| 0LL | **signed long** |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 0LL | **有符号长整型** |'
- en: '| (**void***)0 | **void*** |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| (**void***)0 | **void*** |'
- en: Commonly used values are `0`, `0`L, and `(`**`void`**`*``)0`.^([[4](#ch11fn04)])
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 常用值是 `0`，`0`L，以及 `(`**`void`**`*``)0`。^([[4](#ch11fn04)])
- en: ⁴
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In theory, there are even more possible expansions for **`NULL`**, such as `((`**`char`**`)+0)`
    and `((`**`short`**`)-0)`.
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理论上，**`NULL`** 的可能扩展甚至更多，例如 `((`**`char`**`)+0)` 和 `((`**`short`**`)-0)`。
- en: 'It is important that the type behind **`NULL`** is not prescribed by the C
    standard. Often, people use it to emphasize that they are talking about a pointer
    constant, which it simply isn’t on many platforms. Using **`NULL`** in a context
    that we have not mastered completely is even dangerous. This will in particular
    appear in the context of functions with a variable number of arguments, which
    will be discussed in [section 16.5.2](kindle_split_027.html#ch16lev2sec2). For
    the moment, we will go for the simplest solution:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，**`NULL`** 后面的类型并没有由C标准规定。通常，人们用它来强调他们正在谈论的是一个指针常量，这在许多平台上并不是这样。在不完全掌握的情况下使用
    **`NULL`** 甚至可能是危险的。这将在 [第16.5.2节](kindle_split_027.html#ch16lev2sec2) 中讨论的函数具有可变数量参数的上下文中出现。目前，我们将采取最简单的解决方案：
- en: '|  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.14
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得第11.14条经验
- en: '*Don’t use* **`NULL`***.*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要使用**`NULL`***.*'
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`NULL`** hides more than it clarifies. Either use `0` or, if you really want
    to emphasize that the value is a pointer, use the magic token sequence `(`**`void`**`*``)0`
    directly.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**`NULL`** 隐藏的比它阐明的多。要么使用 `0`，要么如果你真的想强调该值是一个指针，直接使用魔法令牌序列 `(`**`void`**`*``)0`。'
- en: 11.2\. Pointers and structures
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 指针和结构
- en: 'Pointers to structure types are crucial for most coding in C, so some specific
    rules and tools have been put in place to ease this typical usage. For example,
    let us consider the task of normalizing a **`struct`** **`timespec`** as we have
    encountered it previously. The use of a pointer parameter in the following function
    allows us to manipulate the objects directly:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类型的指针对于大多数C语言编程至关重要，因此已经制定了一些特定的规则和工具来简化这种典型用法。例如，让我们考虑一个任务，即规范化我们之前遇到的 **`struct`**
    **`timespec`**。在以下函数中使用指针参数允许我们直接操作对象：
- en: '`timespec.c`'
  id: totrans-567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`timespec.c`'
- en: '[PRE41]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For convenience, here we use a new operator, `->`. Its arrow-like symbol is
    meant to represent a pointer as the left operand that “points” to a member of
    the underlying **`struct`** as the right operand. It is equivalent to a combination
    of `*` and `..` To have the same effect, we would have to use parentheses and
    write `(``*`a`).`**`tv_sec`** instead of a`->`**`tv_sec`**. This could quickly
    become a bit clumsy, so the `->` operator is what everybody uses.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们在这里使用一个新的运算符，`->`。其箭头符号旨在表示一个指针作为左操作数，指向底层 **`struct`** 的成员作为右操作数。它相当于
    `*` 和 `..` 的组合。为了达到相同的效果，我们可能需要使用括号并写成 `(``*`a`).`**`tv_sec`** 而不是 `a->tv_sec`。这可能会很快变得有些笨拙，所以
    `->` 运算符是大家普遍使用的。
- en: '![](pg_179.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_179.jpg)'
- en: Observe that a construct like a`->`**`tv_nsec`** is *not* a pointer, but an
    object of type **`long`**, the number itself.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，像 `a->tv_nsec` 这样的结构不是指针，而是一个类型为 **`long`** 的对象，即这个数字本身。
- en: 'As another example, let us again consider the type rat for rational numbers
    that we introduced in [section 10.2.2](kindle_split_020.html#ch10lev2sec2). The
    functions operating on pointers to that type in [listing 10.1](kindle_split_020.html#ch10ex08)
    could be written as follows:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们再次考虑我们在 [第10.2.2节](kindle_split_020.html#ch10lev2sec2) 中引入的有理数类型rat。在
    [列表10.1](kindle_split_020.html#ch10ex08) 中操作该类型指针的函数可以写成如下：
- en: '`rationals.c`'
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE42]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The function rat_destroy ensures that all data that might be present in the
    object is erased and set to all-bits `0`:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 rat_destroy 确保对象中可能存在的所有数据都被擦除并设置为全零位 `0`：
- en: '`rationals.c`'
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE43]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`rationals.c`'
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE44]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`rationals.c`'
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE45]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The other three functions are simple *wrappers**^C* around the pure functions
    that we already know. We use two pointer operations to test validity and then,
    if the pointer is valid, to refer to the object in question. So, these functions
    can be safely used, even if the pointer argument is null.^([[[Exs 2]](#ch11fn-ex02)])^([[[Exs
    3]](#ch11fn-ex03)])
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个函数是围绕我们已知的纯函数的简单**包装器**。我们使用两个指针操作来测试有效性，然后，如果指针有效，就引用相关的对象。因此，即使指针参数为空，这些函数也可以安全使用。^([[[Exs
    2]](#ch11fn-ex02)])^([[[Exs 3]](#ch11fn-ex03)])
- en: ^([Exs 2])
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement function rat_print as declared in [listing 10.1](kindle_split_020.html#ch10ex08).
    This function should use `->` to access the members of its rat`*` argument. The
    printout should have the form –*nom*/*denum*.
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现函数rat_print，如[列表10.1](kindle_split_020.html#ch10ex08)中声明的那样。这个函数应该使用`->`来访问其rat`*`参数的成员。打印输出应采用形式
    –*nom*/*denum*。
- en: ^([Exs 3])
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement rat_print_normalized by combining rat_normalize and rat_print.
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过结合rat_normalize和rat_print实现rat_print_normalized。
- en: 'All four functions check and return their pointer argument. This is a convenient
    strategy to compose such functions, as we can see in the definitions of the following
    two arithmetic functions:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个函数都会检查并返回它们的指针参数。这是一种方便的策略来组合这样的函数，正如我们可以在以下两个算术函数的定义中看到：
- en: '`rationals.c`'
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE46]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function rat_rma (“rational multiply add”) comprehensively shows its purpose:
    to add the product of the two other function arguments to the object referred
    to by rp. It uses the following function for the addition:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 函数rat_rma（“有理数乘加”）全面展示了其目的：将两个其他函数参数的乘积加到rp所引用的对象上。它使用以下函数进行加法：
- en: '`rationals.c`'
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`rationals.c`'
- en: '[PRE47]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The function rat_sumup is a more complicated example, where we apply two maintenance
    functions to the pointer arguments.^([[[Exs 4]](#ch11fn-ex04)])
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 函数rat_sumup是一个更复杂的例子，其中我们应用了两个维护函数到指针参数上。^([[[Exs 4]](#ch11fn-ex04)])
- en: ^([Exs 4])
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the function rat_dotproduct from [listing 10.1](kindle_split_020.html#ch10ex08)
    such that it computes ![](180fig01.jpg) and returns that value in `*`rp.
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现函数rat_dotproduct，使其从[列表10.1](kindle_split_020.html#ch10ex08)计算![](180fig01.jpg)，并将该值返回到`*`rp。
- en: 'Another special rule applies to pointers to structure types: they can be used
    even if the structure type itself is unknown. Such *opaque structures**^C* are
    often used to strictly separate the interface of a library and its implementation.
    For example, a fictive type toto could be presented in an include file as follows:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构类型指针还有一个特殊的规则：即使结构类型本身是未知的，也可以使用它们。这种**不透明结构**^C*通常用于严格分离库的接口和实现。例如，一个虚构的类型toto可以在包含文件中如下表示：
- en: '[PRE48]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Neither the programmer nor the compiler would need more than that to use the
    type **`struct`** toto. The function toto_get could be used to obtain a pointer
    to an object of type **`struct`** toto, regardless how it might have been defined
    in the compilation unit that defines the functions. And the compiler gets away
    with it because it knows that all pointers to structures have the same representation,
    regardless of the specific definition of the underlying type.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员和编译器都不需要更多东西来使用类型**`struct`** toto。函数toto_get可以用来获取类型**`struct`** toto的对象指针，无论它在定义函数的编译单元中是如何定义的。编译器能够这样做是因为它知道所有结构指针都有相同的表示，无论底层类型的具体定义如何。
- en: 'Often, such interfaces use the fact that null pointers are special. In the
    previous example, toto_doit`(0, 42)` could be a valid use case. This is why many
    C programmers don’t like it if pointers are hidden inside **`typedef`**:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样的接口会使用null指针是特殊的事实。在之前的例子中，toto_doit`(0, 42)`可能是一个有效的用例。这就是为什么许多C程序员不喜欢将指针隐藏在**`typedef`**中：
- en: '[PRE49]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is valid C, but it hides the fact that `0` is a special value that toto_doit
    may receive.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是有效的C代码，但它隐藏了`0`是一个特殊值，toto_doit可能会接收到的这一事实。
- en: '|  |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.15
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得11.15
- en: '*Don’t hide pointers in a* **`typedef`***.*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将指针隐藏在**`typedef`**中*。'
- en: '|  |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is not the same as just introducing a **`typedef`** name for the **`struct`**,
    as we have done before:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前所做的为**`struct`**引入一个**`typedef`**名称不同：
- en: '[PRE50]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the fact that the interface receive a pointer is still sufficiently visible.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，接口接收指针的事实仍然足够明显。
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Text processor**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本处理器**'
- en: For a text processor, can you use a doubly linked list to store text? The idea
    is to represent a “blob” of text through a **`struct`** that contains a string
    (for the text) and pointers to preceding and following blobs.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个文本处理器，你能使用双链表来存储文本吗？想法是通过一个包含字符串（用于文本）和指向先前和后续块的指针的**`struct`**来表示一个“文本块”。
- en: Can you build a function that splits a text blob in two at a given point?
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你能构建一个函数，在给定点将文本块分成两部分吗？
- en: One that joins two consecutive text blobs?
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将两个连续的文本块连接起来的？
- en: One that runs through the entire text and puts it in the form of one blob per
    line?
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将整个文本运行并通过每行一个文本块的形式呈现的？
- en: Can you create a function that prints the entire text or prints until the text
    is cut off due to the screen size?
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 你能创建一个函数来打印整个文本，或者打印直到文本因为屏幕大小而被截断吗？
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.3\. Pointers and arrays
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3. 指针和数组
- en: 'We are now able to attack the major hurdles to understanding the relationship
    between arrays and pointers: the fact that C uses the same syntax for pointer
    and array element access *and* that it rewrites array parameters of functions
    to pointers. Both features provide convenient shortcuts for the experienced C
    programmer but also are a bit difficult for novices to digest.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够克服理解数组和指针之间关系的主要障碍：C语言使用相同的语法进行指针和数组元素访问，并且它将函数的数组参数重写为指针。这两个特性为经验丰富的C程序员提供了方便的快捷方式，但对于新手来说可能有点难以消化。
- en: 11.3.1\. Array and pointer access are the same
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1. 数组和指针访问相同
- en: 'The following statement holds regardless of whether A is an array or a pointer:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句无论A是数组还是指针都成立：
- en: '|  |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.16
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.16节要点
- en: '*The two expressions* *A**`[`**`i`**]* *and* *`*`**`(`**`A`**`+`**`i`**`)`*
    *are equivalent.*'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '*两个表达式* *A**`[`**`i`**]* *和* *`*`**`(`**`A`**`+`**`i`**`)`* *是等价的。*'
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If it is a pointer, we understand the second expression. Here, it just says
    that we may write the same expression as A`[`i`]`. Applying this notion of array
    access to pointers should improve the readability of your code. The equivalence
    does not mean that all of the sudden an array object appears where there was none.
    If A is null, A`[`i`]` should crash nicely, as should `*``(`A`+`i`)`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个指针，我们理解第二个表达式。这里，它只是说我们可以写出与A`[`i`]`相同的表达式。将数组访问的概念应用到指针上应该可以提高你代码的可读性。等价性并不意味着突然在没有任何数组对象的地方出现了一个数组。如果A为空，A`[`i`]`应该优雅地崩溃，就像`*(`A`+`i`)`一样。
- en: 'If A is an array, `*``(`A`+`i`)` shows our first application of one of the
    most important rules in C, called *array-to-pointer decay**^C*:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A是一个数组，`*(`A`+`i`)`展示了C语言中最重要规则之一的应用，称为*数组到指针退化*^C：
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.17 (array decay)
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.17节要点（数组退化）
- en: '*Evaluation of an array* *`A`* *returns* *`&`**`A`**`[0]`**.*'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组* *`A`* *的评估返回* *`&`**`A`**`[0]`**.*'
- en: '|  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In fact, this is the reason there are no “array values” and all the difficulties
    they entail ([takeaway 6.3](kindle_split_014.html#ch06note03)). Whenever an array
    occurs that requires a value, it decays to a pointer, and we lose all additional
    information.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是为什么没有“数组值”以及它们带来的所有困难（[要点6.3](kindle_split_014.html#ch06note03)）。每当出现需要值的数组时，它都会退化成指针，我们就会失去所有额外的信息。
- en: 11.3.2\. Array and pointer parameters are the same
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2. 数组和指针参数相同
- en: Because of the decay, arrays cannot be function arguments. There would be no
    way to call such a function with an array parameter; before any call to the function,
    an array that we feed into it would decay into a pointer, and thus the argument
    type wouldn’t match.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 由于退化，数组不能作为函数参数。没有方法可以用数组参数调用这样的函数；在调用函数之前，我们传入的数组会退化成一个指针，因此参数类型不匹配。
- en: But we have seen declarations of functions with array parameters, so how did
    they work? The trick C gets away with is to rewrite array parameters to pointers.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经看到了具有数组参数的函数声明，那么它们是如何工作的呢？C语言通过将数组参数重写为指针来规避这个问题。
- en: '|  |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.18
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 11.18节要点
- en: '*In a function declaration, any array parameter rewrites to a pointer.*'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '*在函数声明中，任何数组参数都会重写为一个指针。*'
- en: '|  |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Think of this and what it means for a while. Understanding this “chief feature”
    (or character flaw) is central for coding easily in C.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这一点以及它对C语言编程的意义。理解这个“主要特性”（或性格缺陷）对于轻松编程至关重要。
- en: 'To come back to our examples from [section 6.1.5](kindle_split_014.html#ch06lev2sec5),
    the functions that were written with array parameters could be declared as follows:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们[第6.1.5节](kindle_split_014.html#ch06lev2sec5)中的例子，使用数组参数编写的函数可以声明如下：
- en: '[PRE51]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These are completely equivalent, and any C compiler should be able to use both
    forms interchangeably.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式完全等价，任何C编译器都应该能够互换使用这两种形式。
- en: Which one to use is a question of habit, culture, or other social contexts.
    The rule that we follow in this book to use array notation if we suppose it can’t
    be null, and pointer notation if it corresponds to a single item of the base type
    that also can be null to indicate a special condition.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种表示法是一个关于习惯、文化或其他社会背景的问题。在这本书中，我们遵循的规则是，如果我们认为数组表示法不能为空，就使用数组表示法；如果它对应于基类型的单个项，并且也可以为空以表示特殊条件，就使用指针表示法。
- en: If semantically a parameter is an array, we also note what size we expect the
    array to be, if possible. And to make it possible, it is usually better to specify
    the length before the arrays/pointers. An interface such as
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从语义上讲一个参数是一个数组，我们还注意如果可能的话，我们期望数组的大小是多少。为了使其成为可能，通常最好在数组/指针之前指定长度。一个如下的接口
- en: '[PRE52]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'tells a whole story. This becomes even more interesting if we handle two-dimensional
    arrays. A typical matrix multiplication could look as follows:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这讲述了一个完整的故事。如果我们处理二维数组，这会变得更加有趣。一个典型的矩阵乘法可能看起来如下：
- en: '[PRE53]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The prototype is equivalent to the less readable and Observe that once we have
    rewritten
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 原型等同于不那么易读的，并注意一旦我们重写
- en: '[PRE54]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: the innermost dimension as a pointer, the parameter type is not an array anymore,
    but a *pointer to array*. So there is no need to rewrite the subsequent dimensions.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 将最内层维度作为指针，参数类型不再是数组，而是一个*指向数组的指针*。因此，没有必要重写后续的维度。
- en: '|  |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.19
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.19
- en: '*Only the innermost dimension of an array parameter is rewritten.*'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '*只有数组参数的最内层维度会被重写。*'
- en: '|  |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Finally, we have gained a lot by using array notation. We have without any
    trouble passed pointers to VLAs into the function. Inside the function, we can
    use conventional indexing to access the elements of the matrices. Not much in
    the way of acrobatics is required to keep track of the array lengths:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使用数组表示法获得了许多好处。我们无需任何麻烦就能将指向可变长度数组（VLA）的指针传递给函数。在函数内部，我们可以使用传统的索引来访问矩阵的元素。为了跟踪数组长度，不需要太多的技巧：
- en: '|  |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.20
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.20
- en: '*Declare length parameters before array parameters.*'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '*在数组参数之前声明长度参数。*'
- en: '|  |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: They simply have to be known at the point where you use them first.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 它们必须在你首次使用它们的地方被知晓。
- en: Unfortunately, C generally gives no guarantee that a function with array-length
    parameters is always called correctly.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C语言通常不保证具有数组长度参数的函数总是被正确调用。
- en: '|  |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.21
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.21
- en: '*The validity of array arguments to functions must be guaranteed by the programmer.*'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数的数组参数有效性必须由程序员保证。*'
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If the array lengths are known at compile time, compilers may be able to issue
    warnings, though. But when array lengths are dynamic, you are mostly on your own:
    be careful.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组长度在编译时已知，编译器可能能够发出警告。但是，当数组长度是动态的，你基本上只能靠自己：要小心。
- en: 11.4\. Function pointers
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 函数指针
- en: 'There is yet another construct for which the address-of operator `&` can be
    used: functions. We saw this concept pop up when discussing the **atexit** function
    ([section 8.7](kindle_split_017.html#ch08lev1sec7)), which is a function that
    receives a function argument. The rule is similar to that for array decay, which
    we described earlier:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个可以使用取地址运算符`&`的结构，我们可以使用函数。我们在讨论**atexit**函数（[第8.7节](kindle_split_017.html#ch08lev1sec7)）时看到了这个概念的出现，这是一个接收函数参数的函数。规则与之前描述的数组衰减规则类似：
- en: '|  |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 11.22 (function decay)
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 11.22（函数衰减）
- en: '*A function* f *without a following opening* *`(`* *decays to a pointer to
    its start.*'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个没有后续开括号`(`的函数* f *衰减为其起始指针。*'
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Syntactically, functions and function pointers are also similar to arrays in
    type declarations and as function parameters:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型声明和作为函数参数时，函数和函数指针在语法上与数组相似：
- en: '[PRE56]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Which of the semantically equivalent ways of writing the function declaration
    is more readable could certainly be the subject of much debate. The second version,
    with the `(``*`f`)` parentheses, quickly gets difficult to read; and the fifth
    is frowned upon because it hides a pointer in a type. Among the others, I personally
    slightly prefer the fourth over the first.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数声明语义上等效的写法哪种更易读，这肯定是一个值得广泛讨论的话题。第二个版本，使用`(``*`f`)`括号，很快就会变得难以阅读；第五个版本则因为将指针隐藏在类型中而不被看好。在其他的写法中，我个人稍微更喜欢第四个版本，而不是第一个版本。
- en: 'The C library has several functions that receive function parameters. We have
    seen **atexit** and **at_quick_exit**. Another pair of functions in `stdlib.h`
    provides generic interfaces for searching (**bsearch**) and sorting (**qsort**):'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: C库有几个接收函数参数的函数。我们已经看到了**atexit**和**at_quick_exit**。`stdlib.h`中的另一对函数提供了搜索（**bsearch**）和排序（**qsort**）的通用接口：
- en: '|  |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`<stdlib.h>`'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdlib.h>`'
- en: '|  |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE57]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Both receive an array base as argument on which they perform their task. The
    address to the first element is passed as a **`void`** pointer, so all type information
    is lost. To be able to handle the array properly, the functions have to know the
    size of the individual elements (size) and the number of elements (n).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都接收一个数组基作为参数，并在其上执行任务。第一个元素的地址作为**`void`**指针传递，因此所有类型信息都丢失了。为了能够正确处理数组，函数必须知道单个元素的大小（size）和元素的数量（n）。
- en: In addition, they receive a comparison function as a parameter that provides
    the information about the sort order between the elements. By using such a function
    pointer, the **bsearch** and **qsort** functions are very generic and can be used
    with any data model that allows for an ordering of values. The elements referred
    by the base parameter can be of any type T (**`int`**, **`double`**, string, or
    application defined) as long as the size parameter correctly describes the size
    of T and as long as the function pointed to by compar knows how to compare values
    of type T consistently.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们接收一个比较函数作为参数，该参数提供了关于元素之间排序顺序的信息。通过使用这样的函数指针，**bsearch**和**qsort**函数非常通用，可以与任何允许对值进行排序的数据模型一起使用。基参数引用的元素可以是任何类型T（**`int`**、**`double`**、字符串或应用定义），只要size参数正确描述了T的大小，并且只要指向compar的函数知道如何一致地比较类型T的值。
- en: 'A simple version of such a function would look like this:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数的一个简单版本看起来可能是这样的：
- en: '[PRE58]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The convention is that the two arguments point to elements that are to be compared,
    and the return value is strictly negative if a is considered less than b, `0`
    if they are equal, and strictly positive otherwise.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，两个参数指向要比较的元素，如果认为a小于b，则返回值严格为负，如果它们相等，则返回`0`，否则严格为正。
- en: 'The return type of **`int`** seems to suggest that **`int`** comparison could
    be done more simply:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型为**`int`**似乎暗示着**`int`**的比较可以更简单地完成：
- en: '[PRE59]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: But this is not correct. For example, if `*`A is big, say **`INT_MAX`**, and
    `*`B is negative, the mathematical value of the difference can be larger than
    **`INT_MAX`**.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是不正确的。例如，如果`*`A很大，比如说**`INT_MAX`**，而`*`B是负数，那么差值的数学值可能大于**`INT_MAX`**。
- en: 'Because of the **`void`** pointers, a usage of this mechanism should always
    take care that the type conversions are encapsulated similar to the following:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在**`void`**指针，使用这种机制时应该始终注意类型转换被封装，类似于以下内容：
- en: '[PRE60]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, **bsearch** (binary search) searches for an element that compares equal
    to key`[0]` and returns it, or returns a null pointer if no such element is found.
    It supposes that array base is already sorted consistently to the ordering that
    is given by the comparison function. This assumption helps to speed up the search.
    Although this is not explicitly specified in the C standard, you can expect that
    a call to **bsearch** will never make more than *⌈*log[2](*n*)*⌉* calls to compar.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**bsearch**（二分查找）搜索与key`[0]`比较相等的元素并返回它，如果没有找到这样的元素，则返回一个空指针。它假设数组基础已经按照比较函数给出的顺序排序。这个假设有助于加快搜索速度。尽管这并没有在C标准中明确指定，但你可以预期对**bsearch**的调用不会超过*⌈*log[2](*n*)*⌉*次比较调用。
- en: If **bsearch** finds an array element that is equal to `*`key, it returns the
    pointer to this element. Note that this drills a hole in C’s type system, since
    this returns an unqualified pointer to an element whose effective type might be
    **`const`** qualified. Use with care. In our example, we simply convert the return
    value to **`unsigned const`**`*`, such that we will never even see an unqualified
    pointer at the call side of bsearch_unsigned.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**bsearch**找到一个与`*`key相等的数组元素，它将返回指向该元素的指针。请注意，这会在C的类型系统中钻一个洞，因为这将返回一个未限定的指向可能具有**`const`**限定符的元素的指针。请谨慎使用。在我们的例子中，我们简单地将返回值转换为**`unsigned
    const`**`*`，这样我们甚至不会在bsearch_unsigned的调用端看到未限定的指针。
- en: The name **qsort** is derived from the *quick sort* algorithm. The standard
    doesn’t impose the choice of the sorting algorithm, but the expected number of
    comparison calls should be of the magnitude of *n* log[2](*n*), just like quick
    sort. There are no guarantees for upper bounds; you may assume that its worst-case
    complexity is at most quadratic, *O*(*n*²).
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**qsort**这个名字来源于**快速排序**算法。标准并没有强制选择排序算法，但预期的比较调用次数应该与*n* log[2](*n*)的数量级相当，就像快速排序一样。没有对上限的保证；你可以假设其最坏情况复杂度至多为二次方，*O*(*n*²)。'
- en: Whereas there is a catch-all pointer type, **`void`**`*`, that can be used as
    a generic pointer to object types, no such generic type or implicit conversion
    exists for function pointers.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个通用的指针类型**`void`**`*`，可以用作对象类型的通用指针，但没有这样的通用类型或隐式转换存在于函数指针中。
- en: '|  |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.23
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**总结 11.23**'
- en: '*Function pointers must be used with their exact type.*'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数指针必须使用其确切类型。*'
- en: '|  |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Such a strict rule is necessary because the calling conventions for functions
    with different prototypes may be quite different^([[5](#ch11fn05)]) and the pointer
    itself does not keep track of any of this.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的严格规则是必要的，因为具有不同原型函数的调用约定可能相当不同^([[5](#ch11fn05)])，而指针本身并不跟踪任何这些。
- en: ⁵
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The platform application binary interface (ABI) may, for example, pass floating
    points in special hardware registers.
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，平台应用程序二进制接口（ABI）可能通过特殊硬件寄存器传递浮点数。
- en: 'The following function has a subtle problem because the types of the parameters
    are different than what we expect from a comparison function:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数存在一个微妙的问题，因为参数的类型与我们期望的比较函数的类型不同：
- en: '[PRE61]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When you try to use this function with **qsort**, your compiler should complain
    that the function has the wrong type. The variant that we gave earlier using intermediate
    **`void const`**`*` parameters should be almost as efficient as this invalid example,
    but it also can be guaranteed to be correct on all C platforms.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用此函数与**qsort**一起时，你的编译器应该会抱怨该函数类型不正确。我们之前给出的使用中间**`void const`**`*`参数的变体应该几乎与这个无效示例一样高效，但它也可以保证在所有C平台上都是正确的。
- en: '*Calling* functions and function pointers with the `(...)` operator has rules
    similar to those for arrays and pointers and the `[...]` operator:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用*函数和函数指针使用`(...)`运算符的规则与数组和指针以及`[...]`运算符的规则类似：'
- en: '|  |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 11.24
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**总结 11.24**'
- en: '*The function call operator* *`(...)`* *applies to function pointers.*'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数调用运算符* *`(...)`* *适用于函数指针。*'
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE62]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So technically, in terms of the abstract state machine, the pointer decay is
    always performed, and the function is called via a function pointer. The first,
    “natural” call has a hidden evaluation of the f identifier that results in the
    function pointer.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从技术上来说，在抽象状态机的术语中，指针退化总是执行的，并且通过函数指针调用函数。第一个，“自然”的调用有一个对f标识符的隐藏评估，这导致了函数指针。
- en: 'Given all this, we can use function pointers almost like functions:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们可以几乎像使用函数一样使用函数指针：
- en: '[PRE63]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This declares a global variable logger that will point to a function that prints
    out logging information. Using a function pointer will allow the user of this
    module to choose a particular function dynamically:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个全局变量logger，它将指向一个打印日志信息的函数。使用函数指针将允许此模块的用户动态地选择特定的函数：
- en: '[PRE64]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we are defining tools that implement this approach. In particular, function
    pointers can be used as a base type for arrays (here loggers). Observe that we
    use two external functions (**printf** and logger_verbose) and one **`static`**
    function (logger_ignore) for the array initialization: the storage class is not
    part of the function interface.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义实现此方法的工具。特别是，函数指针可以用作数组（此处为loggers）的基本类型。注意，我们使用两个外部函数（**printf**和logger_verbose）和一个**`static`**函数（logger_ignore）来初始化数组：存储类不是函数接口的一部分。
- en: The logger variable can be assigned just like any other pointer type. Somewhere
    at startup we can have
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: logger变量可以被分配，就像任何其他指针类型一样。在启动时，我们可能有
- en: '[PRE65]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then this function pointer can be used anywhere to call the corresponding function:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个函数指针可以在任何地方用来调用相应的函数：
- en: '[PRE66]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This call uses the special macros **`__LINE__`** and **`__FILE__`** for the
    line number and the name of the source file. We will discuss these in more detail
    in [section 16.3](kindle_split_027.html#ch16lev1sec3).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用使用了特殊的宏**`__LINE__`**和**`__FILE__`**来表示行号和源文件名。我们将在[第16.3节](kindle_split_027.html#ch16lev1sec3)中更详细地讨论这些内容。
- en: When using pointers to functions, you should always be aware that doing so introduces
    an indirection to the function call. The compiler first has to fetch the contents
    of logger and can only then call the function at the address it found there. This
    has a certain overhead and should be avoided in time-critical code.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用函数指针时，你应该始终意识到这样做会在函数调用中引入间接引用。编译器首先必须获取 logger 的内容，然后才能调用它在其中找到的地址。这有一定的开销，应该避免在时间敏感的代码中这样做。
- en: '|  |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Generic derivative**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用导数**'
- en: Can you extend the real and complex derivatives ([challenges 2](kindle_split_011.html#ch03sb02)
    and [5](kindle_split_013.html#ch05sb01)) such that they receive the function F
    and the value x as a parameter?
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将实数和复数导数（[挑战 2](kindle_split_011.html#ch03sb02) 和 [5](kindle_split_013.html#ch05sb01)）扩展，以便它们接收函数
    F 和值 x 作为参数吗？
- en: Can you use the generic real derivatives to implement Newton’s method for finding
    roots?
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 你能使用通用实数导数来实现牛顿法来寻找根吗？
- en: Can you find the real zeros of polynomials?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到多项式的实数零点吗？
- en: Can you find the complex zeros of polynomials?
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到多项式的复数零点吗？
- en: '|  |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Generic sorting**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用排序**'
- en: Can you extend your sorting algorithms ([challenge 1](kindle_split_011.html#ch03sb01))
    to other sort keys?
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将你的排序算法（[挑战 1](kindle_split_011.html#ch03sb01)）扩展到其他排序键吗？
- en: 'Can you condense your functions for different sort keys to functions that have
    the same signature as **qsort**: that is, receive generic pointers to data, size
    information, and a comparison function as parameters?'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将针对不同排序键的函数压缩为与 **qsort** 具有相同签名的函数：即，接收数据、大小信息和比较函数作为参数的通用指针？
- en: Can you extend the performance comparison of your sorting algorithms ([challenge
    10](kindle_split_017.html#ch08sb06)) to the C library function **qsort**?
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 你能将你的排序算法的性能比较（[挑战 10](kindle_split_017.html#ch08sb06)）扩展到 C 库函数 **qsort** 吗？
- en: '|  |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Pointers can refer to objects and to functions.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针可以指向对象和函数。
- en: Pointers are not arrays but refer to arrays.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针不是数组，但指向数组。
- en: Array parameters of functions are automatically rewritten as object pointers.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的数组参数自动重写为对象指针。
- en: Function parameters of functions are automatically rewritten as function pointers.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的函数参数自动重写为函数指针。
- en: Function pointer types must match exactly when they are assigned or called.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数指针类型在赋值或调用时必须完全匹配。
- en: Chapter 12\. The C memory model
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章。C 内存模型
- en: This chapter covers
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding object representations
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象表示
- en: Working with untyped pointers and casts
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无类型指针和类型转换操作
- en: Restricting object access with effective types and alignment
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有效类型和对齐限制对象访问
- en: Pointers present us with a certain abstraction of the environment and state
    in which our program is executed, the *C memory model*. We may apply the unary
    operator `&` to (almost) all objects^([[1](#ch12fn01)]) to retrieve their address
    and use it to inspect and change the state of our execution.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 指针为我们提供了一种对程序执行的环境和状态的抽象，即 *C 内存模型*。我们可以在（几乎）所有对象上应用一元运算符 `&` 来检索它们的地址，并使用它来检查和改变我们的执行状态。
- en: ¹
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only objects that are declared with keyword **`register`** don’t have an address;
    see [section 13.2.2](kindle_split_023.html#ch13lev2sec4) on [level 2](kindle_split_018.html#part02).
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有使用关键字 **`register`** 声明的对象没有地址；参见 [第 13.2.2 节](kindle_split_023.html#ch13lev2sec4)
    关于 [第 2 层](kindle_split_018.html#part02)。
- en: This access to objects via pointers is still an abstraction, because seen from
    C, no distinction of the “real” location of an object is made. It could reside
    in your computer’s RAM or on a disk file, or correspond to an IO port of a temperature
    sensor on the moon; you shouldn’t care. C is supposed to do the right thing, regardless.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指针访问对象仍然是一种抽象，因为从 C 的角度来看，没有对对象的“真实”位置的区分。它可能位于你的计算机的 RAM 中，或者在一个磁盘文件中，或者对应于月球上温度传感器的
    IO 端口；你不应该关心。C 应该做正确的事情，不管怎样。
- en: 'And indeed, on modern operating systems, all you get via pointers is something
    called *virtual memory*, basically a fiction that maps the *address space* of
    your process to physical memory addresses of your machine. All this was invented
    to ensure certain properties of your program executions:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在现代操作系统上，通过指针获得的所有内容都是所谓的 *虚拟内存*，基本上是一种虚构，它将你的进程的 *地址空间* 映射到机器的物理内存地址。所有这些都是为了确保你的程序执行的一定属性：
- en: '***portable:*** You do not have to care about physical memory addresses on
    a specific machine.'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***便携性：*** 你不需要关心特定机器上的物理内存地址。'
- en: '***safe:*** Reading or writing virtual memory that your process does not own
    will affect neither your operating system nor any other process.'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***安全：*** 读取或写入你进程不拥有的虚拟内存将不会影响你的操作系统或任何其他进程。'
- en: The only thing C must care about is the *type* of the object a pointer addresses.
    Each pointer type is derived from another type, its base type, and each such derived
    type is a distinct new type.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: C 必须关注的唯一事情是指针指向的对象的 *类型*。每个指针类型都源自另一个类型，即其基类型，并且每种这样的派生类型都是一个新的独立类型。
- en: Figure 12.1\. The different levels of the value-memory model for an **int32_t**.
    Example of a platform that maps this type to a 32-bit signed int that has two’s
    complement sign representation and little-endian object representation.
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1. **int32_t** 的值-内存模型的不同级别。将此类型映射到具有二进制补码符号表示和小端对象表示的 32 位有符号整数的平台示例。
- en: '![](12fig01_alt.jpg)'
  id: totrans-762
  prefs: []
  type: TYPE_IMG
  zh: '![12fig01_alt.jpg](12fig01_alt.jpg)'
- en: '|  |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.1
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 12.1
- en: '*Pointer types with distinct base types are distinct.*'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有不同基类型的指针类型是不同的*。'
- en: '|  |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In addition to providing a virtual view of physical memory, the memory model
    also simplifies the view of objects themselves. It makes the assumption that each
    object is a collection of bytes, the *object representation* ([section 12.1](#ch12lev1sec1));^([[2](#ch12fn02)])
    see [figure 12.1](#ch12fig01) for a schematic view. A convenient tool to inspect
    that object representation is *unions* ([section 12.2](#ch12lev1sec2)). Giving
    direct access to the object representation ([section 12.3](#ch12lev1sec3)) allows
    us to do some fine tuning; but on the other hand, it also opens the door to unwanted
    or conscious manipulations of the state of the abstract machine: tools for that
    are untyped pointers ([section 12.4](#ch12lev1sec4)) and casts ([section 12.5](#ch12lev1sec5)).
    Effective types ([section 12.6](#ch12lev1sec6)) and alignment ([section 12.7](#ch12lev1sec7))
    describe formal limits and platform constraints for such manipulations.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供物理内存的虚拟视图外，内存模型还简化了对象本身的视图。它假定每个对象是一系列字节，即 *对象表示* ([章节 12.1](#ch12lev1sec1))；^([[2](#ch12fn02)])参见
    [图 12.1](#ch12fig01) 以了解示意图。检查这种对象表示的方便工具是 *联合* ([章节 12.2](#ch12lev1sec2))。直接访问对象表示
    ([章节 12.3](#ch12lev1sec3)) 允许我们做一些微调；但另一方面，这也打开了抽象机器状态的不希望或故意的操作之门：用于此的工具是无类型指针
    ([章节 12.4](#ch12lev1sec4)) 和类型转换 ([章节 12.5](#ch12lev1sec5))。有效的类型 ([章节 12.6](#ch12lev1sec6))
    和对齐 ([章节 12.7](#ch12lev1sec7)) 描述了此类操作的形式限制和平台约束。
- en: ²
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The object representation is related to but not the same thing as the *binary
    representation* that we saw in [section 5.1.3](kindle_split_013.html#ch05lev2sec3).
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象表示与我们在 [章节 5.1.3](kindle_split_013.html#ch05lev2sec3) 中看到的 *二进制表示* 相关，但不是同一件事。
- en: 12.1\. A uniform memory model
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 统一内存模型
- en: 'Even though generally all objects are typed, the memory model makes another
    simplification: that all objects are an assemblage of *bytes**^C*. The **`sizeof`**
    operator that we introduced in the context of arrays measures the size of an object
    in terms of the bytes that it uses. There are three distinct types that by definition
    use exactly one byte of memory: the character types **`char`**, **`unsigned char`**,
    and **`signed char`**.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常所有对象都有类型，但内存模型做了另一个简化：即所有对象都是 *字节**^C* 的集合。我们在数组上下文中引入的 **`sizeof`** 运算符用于衡量对象的大小，即它使用的字节数。有三种类型在定义上恰好使用一个字节的内存：字符类型
    **`char`**、**`unsigned char`** 和 **`signed char`**。
- en: '|  |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.2
  id: totrans-774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 12.2
- en: '*`sizeof(char)`* *is* *`1`* *by definition.*'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '*`sizeof(char)`* *定义为* *`1`*。'
- en: '|  |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Not only can all objects be “accounted” in size as character types on a lower
    level, they can even be inspected and manipulated as if they were arrays of such
    character types. A little later, we will see how this can be achieved, but for
    the moment we will just note the following:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅所有对象都可以在较低级别上按字符类型“计算”大小，它们甚至可以像这样的字符类型数组一样进行检查和操作。稍后我们将看到如何实现这一点，但此时我们只需注意以下内容：
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.3
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 12.3
- en: '*Every object* *`A`* *can be viewed as* **`unsigned char`***`[`***`sizeof`**
    *A**`]`.*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个对象* *`A`* *都可以被视为* **`unsigned char`***`[`***`sizeof`** *A**`]`*。'
- en: '|  |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.4
  id: totrans-783
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 12.4
- en: '*Pointers to character types are special.*'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符类型的指针是特殊的*。'
- en: '|  |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unfortunately, the types that are used to compose all other object types are
    derived from **`char`**, the type we looked at for the characters of strings.
    This is merely a historical accident, and you shouldn’t read too much into it.
    In particular, you should clearly distinguish the two different use cases.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用于组成所有其他对象类型的类型都派生自 **`char`**，这是我们查看字符串字符的类型。这仅仅是一个历史事件，你不应该对此过分解读。特别是，你应该清楚地区分两种不同的使用场景。
- en: '![](193fig01.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![](193fig01.jpg)'
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.5
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 12.5
- en: '*Use the type* **`char`** *for character and string data.*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用类型* **`char`** *用于字符和字符串数据。*'
- en: '|  |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.6
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 12.6
- en: '*Use the type* **`unsigned char`** *as the atom of all object types.*'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用类型* **`unsigned char`** *作为所有对象类型的原子。*'
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The type **`signed char`** is of much less importance than the two others.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 **`signed char`** 比其他两种类型的重要性要小得多。
- en: As we have seen, the **`sizeof`** operator counts the size of an object in terms
    of how many **`unsigned char`** s it occupies.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，**`sizeof`**运算符根据对象占用多少**`unsigned char`**来计算对象的大小。
- en: '|  |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.7
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 12.7
- en: '*The* **`sizeof`** *operator can be applied to objects and object types.*'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*`sizeof`* *运算符可以应用于对象和对象类型。*'
- en: '|  |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the previous discussion, we can also distinguish two syntactic variants
    for **`sizeof`**: with and without parentheses. Whereas the syntax for an application
    to objects can have both forms, the syntax for types needs parentheses:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，我们还可以区分两种 **`sizeof`** 的语法变体：带括号和不带括号。虽然应用于对象的语法可以有两种形式，但类型的语法需要括号：
- en: '|  |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.8
  id: totrans-804
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取得要点 12.8
- en: '*The size of all objects of type* *`T`* *is given by* **`sizeof`***`(`**`T`**`)`**.*'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型* *`T`* *的所有对象的大小由* **`sizeof`***`(`**`T`**`)`**.* *给出*。'
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.2\. Unions
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 联合
- en: 'Let us now look at a way to examine the individual bytes of objects. Our preferred
    tool for this is the **`union`**. These are similar in declaration to **`struct`**
    but have different semantics:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何检查对象的单个字节。我们首选的工具是 **`union`**。这些在声明上与 **`struct`** 类似，但具有不同的语义：
- en: '`endianness.c`'
  id: totrans-809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`endianness.c`'
- en: '[PRE67]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The difference here is that such a **`union`** doesn’t collect objects of different
    type into one bigger object, but rather *overlays* an object with a different
    type interpretation. That way, it is the perfect tool to inspect the individual
    bytes of an object of another type.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别是，这样的**`union`**不会将不同类型的对象收集到一个更大的对象中，而是*覆盖*具有不同类型解释的对象。这样，它就是检查另一种类型对象的单个字节的最佳工具。
- en: 'Let us first try to figure out what values we would expect for the individual
    bytes. In a slight abuse of language, let us speak of the different parts of an
    unsigned number that correspond to the bytes as *representation digits*. Since
    we view the bytes as being of type **`unsigned char`**, they can have values `0`
    . . . **`UCHAR_MAX`**, inclusive, and thus we interpret the number as written
    with a base of **`UCHAR_MAX`**`+1`. In the example, on my machine, a value of
    type **`unsigned`** can be expressed with **`sizeof`**`(`**`unsigned`**`) == 4`
    such representation digits, and I chose the values `0`xAA, `0`xBB, `0`xCC, and
    `0`xDD for the highest- to lowest-order representation digit. The complete **`unsigned`**
    value can be computed using the following expression, where **`CHAR_BIT`** is
    the number of bits in a character type:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先尝试弄清楚我们期望的各个字节的值。在轻微的语言滥用中，让我们将对应于字节的未签名字段称为*表示数字*。由于我们将字节视为**`unsigned
    char`**类型，它们的值可以是`0` . . . **`UCHAR_MAX`**，包括，因此我们将数字解释为以**`UCHAR_MAX`**`+1`为基数。在示例中，在我的机器上，类型**`unsigned`**的值可以用**`sizeof`**`(`**`unsigned`**`)
    == 4`这样的表示数字表示，我选择了最高到最低顺序的表示数字`0xAA`、`0xBB`、`0xCC`和`0xDD`。完整的**`unsigned`**值可以使用以下表达式计算，其中**`CHAR_BIT`**是字符类型中的位数：
- en: '[PRE68]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'With the **`union`** defined earlier, we have two different facets to look
    at the same twofold object: twofold.val presents it as being an **`unsigned`**,
    and twofold.bytes presents it as an array of **`unsigned char`**. Since we chose
    the length of twofold.bytes to be exactly the size of twofold.val, it represents
    exactly its bytes, and thus gives us a way to inspect the *object representation**^C*
    of an **`unsigned`** value: all its representation digits:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前定义的 **`union`**，我们可以从两个不同的角度观察同一个双向对象：双向.val将其表示为**`unsigned`**，而双向.bytes将其表示为一个**`unsigned
    char`**数组。由于我们选择了双向.bytes的长度正好等于双向.val的大小，它正好表示其字节，因此为我们提供了检查**`unsigned`**值**对象表示**的方法：所有其表示数字：
- en: '`endianness.c`'
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`endianness.c`'
- en: '[PRE69]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: On my computer, I receive a result as shown here:^([[3](#ch12fn03)])
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，我得到的结果如下所示：^([[3](#ch12fn03)])
- en: ³
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test the code on your own machine.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你自己的机器上测试代码。
- en: '`Terminal`'
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE70]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For my machine, we see that the output has the low-order representation digits
    of the integer first, then the next-lower order digits, and so on. At the end,
    the highest-order digits are printed. So the in-memory representation of such
    an integer on my machine has the low-order representation digits before the high-order
    ones.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的机器，我们看到输出首先打印整数的低位表示数字，然后是次低位数字，依此类推。最后，打印最高位数字。因此，在我的机器上，此类整数的内存表示中，低位表示数字位于高位表示数字之前。
- en: This is *not* normalized by the standard, but is an implementation-defined behavior.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是标准化的，而是实现定义的行为。
- en: '|  |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.9
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.9 总结
- en: '*The in-memory order of the representation digits of an arithmetic type is
    implementation defined.*'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术类型的表示数字的内存顺序是实现定义的*。'
- en: '|  |'
  id: totrans-828
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That is, a platform provider might decide to provide a storage order that has
    the highest-order digits first, and then print lower-order digits one by one.
    The storage order, the *endianness**^C*, as given for my machine, is called *little-endian**^C*.
    A system that has high-order representation digits first is called *big-endian**^C*.^([[4](#ch12fn04)])
    Both orders are commonly used by modern processor types. Some processors are even
    able to switch between the two orders on the fly.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，平台提供商可能会决定提供一个存储顺序，首先存储最高位数字，然后逐个打印低位数字。存储顺序，即 *字节序**^C*，如我的机器所示，称为 *小端序**^C*。一个首先存储高位表示数字的系统称为
    *大端序**^C*。^([[4](#ch12fn04)]) 两种顺序在现代处理器类型中都很常见。一些处理器甚至能够在运行时在这两种顺序之间切换。
- en: ⁴
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The names are derived from the fact that the big or small “end” of a number
    is stored first.
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些名称来源于数字的大或小“端”首先存储的事实。
- en: 'The previous output also shows another implementation-defined behavior: I used
    the feature of my platform that one representation digit can be printed nicely
    by using two hexadecimal digits. In other words, I assumed that **`UCHAR_MAX`**`+1`
    is `256` and that the number of value bits in an **`unsigned char`**, **`CHAR_BIT`**,
    is `8`. Again, this is implementation-defined behavior: although the vast majority
    of platforms have these properties,^([[5](#ch12fn05)]) there are still some around
    that have wider character types.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的输出还显示了另一个实现定义的行为：我使用了我的平台的一个特性，即一个表示数字可以通过使用两个十六进制数字来很好地打印。换句话说，我假设 **`UCHAR_MAX`**`+1`
    是 `256`，并且一个 **`unsigned char`**，**`CHAR_BIT`** 的值位是 `8`。同样，这也是实现定义的行为：尽管大多数平台都有这些属性，^([[5](#ch12fn05)])
    但仍然有一些平台具有更宽的字类型。
- en: ⁵
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In particular, all POSIX systems.
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尤其是所有 POSIX 系统。
- en: '|  |'
  id: totrans-837
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.10
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12.10 总结
- en: '*On most architectures,* **`CHAR_BIT`** *is* *`8`* *and* **`UCHAR_MAX`** *is*
    *`255`**.*'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '*在大多数架构中，* **`CHAR_BIT`** *是* *`8`* *并且* **`UCHAR_MAX`** *是* *`255`**.*'
- en: '|  |'
  id: totrans-840
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the example, we have investigated the in-memory representation of the simplest
    arithmetic base types, unsigned integers. Other base types have in-memory representations
    that are more complicated: signed integer types have to encode the sign; floating-point
    types have to encode the sign, mantissa, and exponent; and pointer types may follow
    any internal convention that fits the underlying architecture.^([[[Exs 1]](#ch12fn-ex01)])^([[[Exs
    2]](#ch12fn-ex02)])^([[[Exs 3]](#ch12fn-ex03)])'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们研究了最简单的算术基类型，无符号整数的内存表示。其他基类型有更复杂的内存表示：有符号整数类型必须编码符号；浮点类型必须编码符号、尾数和指数；指针类型可能遵循适合底层架构的任何内部约定.^([[[Exs
    1]](#ch12fn-ex01)])^([[[Exs 2]](#ch12fn-ex02)])^([[[Exs 3]](#ch12fn-ex03)])
- en: ^([Exs 1])
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Design a similar **`union`** type to investigate the bytes of a pointer type,
    such as **`double`**`*`.
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设计一个类似的 **`union`** 类型来调查指针类型的字节，例如 **`double`**`*`。
- en: ^([Exs 2])
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With such a **`union`**, investigate the addresses of two consecutive elements
    of an array.
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这样的 **`union`**，调查数组中连续两个元素的地址。
- en: ^([Exs 3])
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Compare the addresses of the same variable between different executions.
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 比较不同执行中相同变量的地址。
- en: 12.3\. Memory and state
  id: totrans-851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 内存和状态
- en: The value of all objects constitutes the state of the abstract state machine,
    and thus the state of a particular execution. C’s memory model provides something
    like a unique location for (almost) all objects through the `&` operator, and
    that location can be accessed and modified from different parts of the program
    through pointers.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对象的价值构成了抽象状态机的状态，因此也是特定执行的状态。C的内存模型通过`&`操作符为（几乎）所有对象提供了一个类似唯一的位置，并且可以通过指针从程序的不同部分访问和修改该位置。
- en: 'Doing so makes the determination of the abstract state of an execution much
    more difficult, if not impossible in many cases:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做使得确定一个执行过程的抽象状态变得非常困难，在许多情况下甚至是不可能的：
- en: Here, we (as well as the compiler) only see a declaration of function blub,
    with no definition. So we cannot conclude much about what that function does to
    the objects its arguments point to. In particular, we don’t know if the variable
    d is modified, so the sum c `+` d could be anything. The program really has to
    inspect the object d in memory to find out what the values *after* the call to
    blub are.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们（以及编译器）只看到了函数blub的声明，没有定义。因此，我们无法得出太多关于该函数对其参数指向的对象做了什么结论。特别是，我们不知道变量d是否被修改，因此c
    `+` d的值可以是任何值。程序实际上必须检查内存中的对象d，以找出blub调用后的值。
- en: 'Now let us look at such a function that receives two pointer arguments:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这样一个接收两个指针参数的函数：
- en: '[PRE71]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Such a function can operate under two different assumptions. First, if called
    with two distinct addresses as arguments, `*`a will be unchanged, and the return
    value will be the same as myA. But if both arguments are the same, such as if
    the call is blub`(`&`c,` &`c)`, the assignment to `*`b will change `*`a, too.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 此类函数可以在两种不同的假设下运行。首先，如果用两个不同的地址作为参数调用，`*a`将保持不变，返回值将与myA相同。但如果两个参数都是相同的，例如如果调用是blub(`&c`,
    `&c`)，对`*b`的赋值也会改变`*a`。
- en: The phenomenon of accessing the same object through different pointers is called
    *aliasing**^C*; it is a common cause for missed optimization. In both cases, either
    that two pointers always alias or that they never alias, the abstract state of
    an execution is much reduced, and the optimizer often can take much advantage
    of that knowledge. Therefore, C forcibly restricts the possible aliasing to pointers
    of the same type.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不同的指针访问相同对象的现象称为*别名**^C*；它是错过优化的常见原因。在这两种情况下，无论是两个指针始终别名还是它们永远不会别名，执行的抽象状态都会大大减少，优化器通常可以充分利用这一知识。因此，C强制限制可能的别名仅为相同类型的指针。
- en: '|  |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.11 (Aliasing)
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结12.11（别名）
- en: '*With the exclusion of character types, only pointers of the same base type
    may alias.*'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了字符类型外，只有相同基类型的指针可以别名。*'
- en: '|  |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'To see this rule in effect, consider a slight modification of our previous
    example:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这条规则的实际效果，考虑对我们之前的例子进行轻微的修改：
- en: '[PRE73]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Because here the two parameters have different types, C *assumes* that they
    don’t address the same object. In fact, it would be an error to call that function
    as blob`(`&`e,` &`e)`, since this would never match the prototype of blob. So
    at the **`return`** statement, we can be sure that the object `*`a hasn’t changed
    and that we already hold the needed value in variable myA.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这里两个参数的类型不同，C *假设*它们不指向同一对象。实际上，将函数作为blob(`&e`, `&e`)调用将是错误的，因为这永远不会匹配blob的原型。因此，在**`return`**语句中，我们可以确信对象`*a`没有改变，并且我们已经在变量myA中持有所需的价值。
- en: 'There are ways to fool the compiler and to call such a function with a pointer
    that addresses the same object. We will see some of these cheats later. Don’t
    do this: it is a road to much grief and despair. *If* you do so, the behavior
    of the program becomes undefined, so you have to guarantee (prove!) that no aliasing
    takes place.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以欺骗编译器，并用指向同一对象的指针调用此类函数。我们将在稍后看到一些这些技巧。不要这样做：这是一条通往许多痛苦和绝望的道路。*如果*这样做，程序的行为将是不确定的，因此你必须保证（证明！）没有别名发生。
- en: In the contrary, we should try to write our programs so they protect our variables
    from ever being aliased, and there is an easy way to achieve that.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该尝试编写我们的程序，以保护我们的变量免受别名的影响，并且有一个简单的方法可以实现这一点。
- en: '|  |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.12
  id: totrans-870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 总结12.12
- en: '*Avoid the* *`&`* *operator.*'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免使用* *`&`* *操作符。*'
- en: '|  |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Depending on the properties of a given variable, the compiler may see that the
    address of the variable is never taken, and thus the variable can’t alias at all.
    In [section 13.2](kindle_split_023.html#ch13lev1sec2), we will see which properties
    of a variable or object may influence such decisions and how the **`register`**
    keyword can protect us from taking addresses inadvertently. Later, in [section
    15.2](kindle_split_026.html#ch15lev1sec2), we will see how the **`restrict`**
    keyword allows us to specify aliasing properties of pointer arguments, even if
    they have the same base type.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 根据给定变量的属性，编译器可能会发现变量的地址永远不会被取用，因此变量根本不能别名。在[第13.2节](kindle_split_023.html#ch13lev1sec2)中，我们将看到哪些变量的属性或对象可能影响此类决策，以及**`register`**关键字如何保护我们免受意外取地址的影响。稍后，在第15.2节中，我们将看到**`restrict`**关键字如何允许我们指定指针参数的别名属性，即使它们具有相同的基类型。
- en: 12.4\. Pointers to unspecific objects
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 指向非特定对象的指针
- en: As we have seen, the object representation provides a view of an object X as
    an array **`unsigned char`**`[`**`sizeof`** X`]`. The starting address of that
    array (of type **`unsigned char`**`*`) provides access to memory that is stripped
    of the original type information.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，对象表示提供了将对象X视为一个**`unsigned char`**`[`**`sizeof`** X`]`数组的视图。该数组的起始地址（类型为**`unsigned
    char`**`*`）提供了访问去除原始类型信息的内存的途径。
- en: C has invented a powerful tool to handle such pointers more generically. These
    are pointers to a sort of *non-type*, **`void`**.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: C语言发明了一种强大的工具来更通用地处理此类指针。这些是指向一种*非类型*，**`void`**的指针。
- en: '|  |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.13
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要12.13
- en: '*Any object pointer converts to and from* **`void`***`*`**.*'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何对象指针都可以转换为**`void`***`*`**并从其转换回来*。'
- en: '|  |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Note that this only talks about object pointers, not function pointers. Think
    of a **`void`**`*` pointer that holds the address of an existing object as a pointer
    into a *storage instance* that holds the object; see [figure 12.1](#ch12fig01).
    As an analogy for such a hierarchy, you could think of entries in a phone book:
    a person’s name corresponds to the identifier that refers to an object; their
    categorization with a “mobile,” “home,” or “work” entry corresponds to a type;
    and their phone number itself is some sort of address (in which, by itself, you
    typically are not interested). But then, even the phone number abstracts away
    from the specific information of where the other phone is located (which would
    be the storage instance underneath the object), or of specific information about
    the other phone itself, for example if it is on a landline or the mobile network,
    and what the network has to do to actually connect you to the person at the other
    end.'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅涉及对象指针，而不是函数指针。想象一个**`void`**`*`指针，它持有现有对象的地址，就像一个指向*存储实例*的指针，该实例包含对象；参见[图12.1](#ch12fig01)。作为此类层次结构的类比，你可以将电话簿中的条目想象成这样：一个人的名字对应于指向对象的标识符；他们与“手机”、“家庭”或“工作”条目的分类对应于类型；而他们的电话号码本身则是一种地址（其中，通常你对此不感兴趣）。但是，即使电话号码也抽象掉了其他电话具体位置的信息（这将是对象下面的存储实例），或者关于其他电话本身的特定信息，例如它是否是固定电话还是移动网络，以及网络需要做什么才能实际上将你连接到另一端的某人。
- en: '|  |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.14
  id: totrans-883
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要12.14
- en: '*An object has storage, type, and value.*'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个对象具有存储、类型和值*。'
- en: '|  |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Not only is the conversion to **`void`**`*` well defined, but it also is guaranteed
    to behave well with respect to the pointer value.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅转换为**`void`**`*`是明确定义的，而且它还保证了与指针值的行为良好。
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.15
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要12.15
- en: '*Converting an object pointer to* **`void`***`*`* *and then back to the same
    type is the identity operation.*'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '*将对象指针转换为**`void`***`*`**然后再转换回相同类型是恒等操作*。'
- en: '|  |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So the only thing that we lose when converting to **`void`**`*` is the type
    information; the value remains intact.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们转换为**`void`**`*`时，唯一失去的是类型信息；值保持不变。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 12.16 (a**void*²**)
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要12.16 (a**void*²**)
- en: '*A*void **`void`***`*`**.*'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '*`void`***`*`.*'
- en: '|  |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It completely removes any type information that was associated with an address.
    Avoid it whenever you can. The other way around is much less critical, in particular
    if you have a C library call that returns a **`void`**`*`.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 它完全移除了与地址相关联的任何类型信息。尽可能避免使用它。反过来，情况则不那么关键，特别是如果你有一个返回**`void`**`*`的C库调用。
- en: '**`void`** as a type by itself shouldn’t be used for variable declarations
    since it won’t lead to an object with which we could do anything.'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**`void`**作为一个单独的类型不应用于变量声明，因为它不会导致我们可以对其执行任何操作的对象。'
- en: 12.5\. Explicit conversions
  id: totrans-898
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5. 显式转换
- en: 'A convenient way to look at the object representation of object X would be
    to somehow convert a pointer to X to a pointer of type **`unsigned char`**`*`:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 查看对象 X 的对象表示的一个方便方法是将指向 X 的指针以某种方式转换为**`unsigned char`**`*`类型的指针：
- en: '[PRE74]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Fortunately, such an implicit conversion of a **`double`**`*` to **`unsigned
    char`**`*` is not allowed. We would have to make this conversion somehow explicit.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不允许将**`double`**`*`隐式转换为**`unsigned char`**`*`。我们必须以某种方式明确地进行这种转换。
- en: 'We already have seen that in many places, a value of a certain type is implicitly
    converted to a value of a different type ([section 5.4](kindle_split_013.html#ch05lev1sec4)),
    and that narrow integer types are first converted to **`int`** before any operation.
    In view of that, narrow types only make sense in very special circumstances:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在许多地方，某种类型的值会隐式转换为另一种类型的值（[第5.4节](kindle_split_013.html#ch05lev1sec4)），并且窄整数类型在执行任何操作之前首先转换为**`int`**。考虑到这一点，窄类型只在非常特殊的情况下才有意义：
- en: You have to save memory. You need to use a really big array of small values.
    *Really big* here means potentially millions or billions. In such a situation,
    storing these values may gain you something.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须节省内存。你需要使用一个非常大的小值数组。这里的*非常大*意味着可能是数百万或数十亿。在这种情况下，存储这些值可能会给你带来一些好处。
- en: You use **`char`** for characters and strings. But then you wouldn’t do arithmetic
    with them.
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用**`char`**来表示字符和字符串。但然后你不会对它们进行算术运算。
- en: You use **`unsigned char`** to inspect the bytes of an object. But then, again,
    you wouldn’t do arithmetic with them.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用**`unsigned char`**来检查对象的字节。但然后，再次，你不会对它们进行算术运算。
- en: 'Conversions of pointer types are more delicate, because they can change the
    type interpretation of an object. Only two forms of implicit conversions are permitted
    for data pointers: conversions from and to **`void`**`*`, and conversions that
    add a qualifier to the target type. Let’s look at some examples:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型的转换更为微妙，因为它们可能会改变对象的类型解释。对于数据指针，只允许两种形式的隐式转换：从和到**`void`**`*`的转换，以及向目标类型添加限定符的转换。让我们看看一些例子：
- en: '[PRE75]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The first two conversions that use **`void`**`*` (pv and pfv) are already a
    bit tricky: we convert a pointer back and forth, but we watch that the target
    type of pfv is the same as f so everything works out fine.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个使用**`void`**`*`（pv 和 pfv）的转换已经有点棘手了：我们来回转换指针，但我们要注意 pfv 的目标类型必须与 f 相同，这样一切才能顺利进行。
- en: 'Then comes the erroneous part. In the initialization of pd, the compiler can
    protect us from a severe fault: assigning a pointer to a type that has a different
    size and interpretation can and will lead to serious damage. Any conforming compiler
    *must* give a diagnosis for this line. As you have by now understood well that
    your code should not produce compiler warnings ([takeaway 1.4](kindle_split_008.html#ch01note05)),
    you know that you should not continue until you have repaired such an error.'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是错误的部分。在 pd 的初始化中，编译器可以保护我们免受严重错误的侵害：将指针赋给具有不同大小和解释的类型可以并且将会导致严重损坏。任何符合规范的编译器*必须*对这一行给出诊断。正如你现在已经很好地理解的那样，你的代码不应该产生编译器警告（[要点
    1.4](kindle_split_008.html#ch01note05)），你知道你应该在修复这种错误之前继续下去。
- en: 'The last line is worse: it has an error, but that error is syntactically correct.
    The reason this error might go undetected is that our first conversion for pv
    has stripped the pointer from all type information. So, in general, the compiler
    can’t know what type of object is behind the pointer.'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行更糟糕：它有一个错误，但这个错误在语法上是正确的。这个错误可能没有被察觉的原因是，我们为 pv 的第一次转换已经从指针中移除了所有类型信息。所以，一般来说，编译器无法知道指针后面的对象类型是什么。
- en: 'In addition to the implicit conversions that we have seen until now, C also
    allows us to convert explicitly using *casts**^C*.^([[6](#ch12fn06)]) With a cast,
    you are telling the compiler that you know better than it does, that the type
    of the object behind the pointer is not what it thinks, and that it should shut
    up. In most use cases that I have come across in real life, the compiler was right
    and the programmer was wrong: even experienced programmers tend to abuse casts
    to hide poor design decisions concerning types.'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前看到的隐式转换之外，C 还允许我们使用*类型转换符*（*casts**^C*）显式转换。使用类型转换符，你是在告诉编译器你比它更了解情况，即指针后面的对象类型不是它所认为的那样，并且它应该闭嘴。在我遇到的大多数实际用例中，编译器是对的，程序员是错的：即使是经验丰富的程序员也倾向于滥用类型转换来隐藏有关类型的糟糕设计决策。
- en: ⁶
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A cast of an expression X to type T has the form (`T)`X. Think of it like “*to
    cast a spell*.”
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式 X 转换为类型 T 的形式为 (`T`)X。把它想象成“*施法*”。
- en: '|  |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.17
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点12.17
- en: '*Don’t use casts.*'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要使用类型转换*。'
- en: '|  |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: They deprive you of precious information, and if you chose your types carefully,
    you will only need them for very special occasions.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 它们剥夺了你宝贵的信息，如果你仔细选择类型，你将只需要它们在非常特殊的情况下。
- en: 'One such occasion is when you want to inspect the contents of an object on
    the byte level. Constructing a **`union`** around an object, as we saw in [section
    12.2](#ch12lev1sec2), might not always be possible (or may be too complicated),
    so here we can go for a cast:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况是这样的，当你想检查对象的字节级内容时。正如我们在 [第12.2节](#ch12lev1sec2) 中看到的，围绕一个对象构造一个 **`union`**
    可能并不总是可能（或者可能过于复杂），因此这里我们可以选择进行类型转换：
- en: '`endianness.c`'
  id: totrans-921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`endianness.c`'
- en: '[PRE76]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In that direction (from “pointer to object” to a “pointer to character type”),
    a cast is mostly harmless.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个方向（从“对象指针”到“字符类型指针”），类型转换大多是无害的。
- en: 12.6\. Effective types
  id: totrans-924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6. 有效类型
- en: To cope with different views of the same object that pointers may provide, C
    has introduced the concept of *effective types*. It heavily restricts how an object
    can be accessed.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对指针可能提供的相同对象的多种视图，C 语言引入了有效类型的概念。它极大地限制了对象可以如何被访问。
- en: '|  |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.18 (Effective Type)
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点12.18（有效类型）
- en: '*Objects must be accessed through their effective type or through a pointer
    to a character type.*'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象的有效成员类型可以在任何时候访问，只要字节表示是访问类型的有效值*。'
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Because the effective type of a **`union`** variable is the **`union`** type
    and none of the member types, the rules for **`union`** members can be relaxed:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 **`union`** 变量的有效类型是 **`union`** 类型，而不是任何成员类型，所以 **`union`** 成员的规则可以放宽：
- en: '|  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.19
  id: totrans-932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点12.19
- en: '*Any member of an object that has an effective* **`union`** *type can be accessed
    at any time, provided the byte representation amounts to a valid value of the
    access type.*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*只要字节表示是访问类型的有效值，任何具有有效**`union`**类型的对象成员都可以在任何时候访问*。'
- en: '|  |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For all objects we have seen so far, it is easy to determine the effective
    type:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们迄今为止看到的所有对象，确定有效类型很容易：
- en: '|  |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.20
  id: totrans-937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点12.20
- en: '*The effective type of a variable or compound literal is the type of its declaration.*'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量的有效类型是其声明的类型*。'
- en: '|  |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Later, we will see another category of objects that are a bit more involved.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到另一类稍微复杂一些的对象。
- en: Note that this rule has no exceptions, and that we can’t change the type of
    such a variable or compound literal.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个规则没有例外，我们也不能改变这种变量或复合字面量的类型。
- en: '|  |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 12.21
  id: totrans-943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点12.21
- en: '*Variables and compound literals must be accessed through their declared type
    or through a pointer to a character type.*'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量和复合字面量必须通过其声明的类型或通过字符类型的指针来访问*。'
- en: '|  |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Also observe the asymmetry in all of this for character types. Any object can
    be seen as being composed of **`unsigned char`**, but no array of **`unsigned
    char`** s can be used through another type:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意所有这些字符类型中的不对称性。任何对象都可以被视为由 **`unsigned char`** 组成，但没有任何 **`unsigned char`**
    数组可以通过其他类型来使用：
- en: '[PRE77]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here, the access `*`p is an error, and the program state is undefined afterward.
    This is in strong contrast to our dealings with **`union`** earlier: see [section
    12.2](#ch12lev1sec2), where we actually could view a byte sequence as an array
    of **`unsigned char`** or **`unsigned`**.'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，访问 `*p` 是一个错误，之后的程序状态是未定义的。这与我们之前对 **`union`** 的处理形成鲜明对比：参见 [第12.2节](#ch12lev1sec2)，在那里我们实际上可以将字节序列视为一个
    **`unsigned char`** 或 **`unsigned`** 的数组。
- en: The reasons for such a strict rule are multiple. The very first motivation for
    introducing effective types in the C standard was to deal with aliasing, as we
    saw in [section 12.3](#ch12lev1sec3). In fact, the Aliasing Rule ([takeaway 12.11](#ch12note11))
    is derived from the Effective Type Rule ([takeaway 12.18](#ch12note18)). As long
    as there is no **`union`** involved, the compiler knows that we cannot access
    a **`double`** through a **`size_t`**`*`, and so it may *assume* that the objects
    are different.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的规则有多个原因。在 C 标准中引入有效类型的最初动机是为了处理别名，正如我们在 [第12.3节](#ch12lev1sec3) 中看到的。实际上，别名规则（[要点12.11](#ch12note11)）是从有效类型规则（[要点12.18](#ch12note18)）派生出来的。只要没有
    **`union`** 参与，编译器就知道我们不能通过 **`size_t`** 访问 **`double`**，因此它可能会 *假设* 对象是不同的。
- en: 12.7\. Alignment
  id: totrans-950
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7. 对齐
- en: 'The inverse direction of pointer conversions (from “pointer to character type”
    to “pointer to object”) is not harmless at all, and not only because of possible
    aliasing. This has to do with another property of C’s memory model: *alignment**^C*.
    Objects of most non-character types can’t start at any arbitrary byte position;
    they usually start at a *word boundary**^C*. The alignment of a type then describes
    the possible byte positions at which an object of that type can start.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 指针转换的反向方向（从“字符类型指针”到“对象指针”）根本不是无害的，不仅仅是因为可能存在别名。这与C内存模型的另一个属性有关：*对齐**^C*。大多数非字符类型对象不能从任意字节位置开始；它们通常从*字边界**^C*开始。类型的对齐描述了该类型对象可以开始的可能的字节位置。
- en: 'If we force some data to a false alignment, really bad things can happen. To
    see that, have a look at the following code:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们强制某些数据到错误的对齐，会发生真正糟糕的事情。为了看到这一点，请查看以下代码：
- en: '[PRE78]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This starts with a declaration of a **`union`** similar to what we saw earlier.
    Again, we have a data object (of type **`complex`** **`double`**`[2]` in this
    case) that we overlay with an array of **`unsigned char`**. Other than the fact
    that this part is a bit more complex, at first glance there is no major problem
    with it. But if I execute this program on my machine, I get
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从一个类似于我们之前看到的**`union`**声明开始的。再次强调，我们有一个数据对象（在这种情况下是类型为**`complex`** **`double`**`[2]`的对象），我们用**`unsigned
    char`**数组覆盖它。除了这部分稍微复杂一些之外，乍一看并没有什么大问题。但是，如果我在我的机器上执行这个程序，我会得到
- en: '`Terminal`'
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Terminal`'
- en: '[PRE79]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The program crashes with an error indicated as a *bus error**^C*, which is a
    shortcut for something like “data bus alignment error.” The real problem line
    is
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃，显示为*总线错误**^C*，这是“数据总线对齐错误”的快捷方式。真正的问题行是
- en: '`crash.c`'
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`crash.c`'
- en: '[PRE80]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'On the right, we see a pointer cast: an **`unsigned char`**`*` is converted
    to a **`complex`** **`double`**`*`. With the **`for`** loop around it, this cast
    is performed for byte offsets offset from the beginning of toocomplex. These are
    powers of `2`: `16`, `8`, `4`, `2`, and `1`. As you can see in the output, above,
    it seems that **`complex`** **`double`** still works well for alignments of half
    of its size, but then with an alignment of one fourth, the program crashes.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们看到一个指针转换：将**`unsigned char`**`*`转换为**`complex`** **`double`**`*`。通过围绕它的**`for`**循环，这个转换从toocomplex的开始字节偏移量offset执行。这些是2的幂：`16`、`8`、`4`、`2`和`1`。如上输出所示，似乎**`complex`**
    **`double`**对于其大小的一半的对齐仍然表现良好，但是当对齐为四分之一时，程序崩溃。
- en: 'Some architectures are more tolerant of misalignment than others, and we might
    have to force the system to error out on such a condition. We use the following
    function at the beginning to force crashing:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 一些架构对不匹配的容忍度比其他架构更高，我们可能需要强制系统在出现此类条件下出错。我们在开始时使用以下函数来强制崩溃：
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`crash.c`'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '`crash.c`'
- en: 'enable_alignment_check: enable alignment check for i386 processors'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 'enable_alignment_check: 为i386处理器启用对齐检查'
- en: Intel’s i386 processor family is quite tolerant in accepting misalignment of
    data. This can lead to irritating bugs when ported to other architectures that
    are not as tolerant.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔i386处理器系列在接受数据不匹配方面相当宽容。这可能导致在其他不那么宽容的架构上移植时出现令人烦恼的bug。
- en: This function enables a check for this problem also for this family or processors,
    such that you can be sure to detect this problem early.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数还启用了对该系列或处理器的此类问题的检查，这样你可以确保及早发现此问题。
- en: 'I found that code on Ygdrasil’s blog: `http://orchistro.tistory.com/206`'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Ygdrasil的博客上找到了这段代码：`http://orchistro.tistory.com/206`
- en: '[PRE81]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|  |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you are interested in portable code (and if you are still here, you probably
    are), early errors in the development phase are really helpful.^([[7](#ch12fn07)])
    So, consider crashing a feature. See the blog entry mentioned in `crash.h` for
    an interesting discussion on this topic.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对便携式代码感兴趣（而且如果你还在这里，你很可能感兴趣），在开发阶段的早期错误实际上是非常有帮助的.^([[7](#ch12fn07)]) 因此，考虑崩溃一个功能。参见`crash.h`中提到的博客条目，其中对这一主题进行了有趣的讨论。
- en: ⁷
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷
- en: ''
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the code that is used inside that function, please consult the source code
    of `crash.h` to inspect it.
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于该函数内部使用的代码，请查阅`crash.h`的源代码以进行检查。
- en: In the previous code example, we also see a new operator, **`alignof`** (or
    **`_Alignof`**, if you don’t include `stdalign.h`), that provides us with the
    alignment of a specific type. You will rarely find the occasion to use it in real
    live code.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们还看到了一个新的运算符，**`alignof`**（或者如果你没有包含`stdalign.h`，则为**`_Alignof`**），它为我们提供了特定类型的对齐。你很少会在实际代码中找到使用它的场合。
- en: '|  |'
  id: totrans-975
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdalign.h>`'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdalign.h>`'
- en: '|  |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Another keyword can be used to force allocation at a specified alignment: **`alignas`**
    (respectively, **`_Alignas`**). Its argument can be either a type or expression.
    It can be useful where you know that your platform can perform certain operations
    more efficiently if the data is aligned in a certain way.'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键字可以用来强制在指定的对齐方式下进行分配：**`alignas`**（分别，**`_Alignas`**）。它的参数可以是类型或表达式。如果你知道你的平台可以在数据以某种方式对齐的情况下更有效地执行某些操作，这可能是有用的。
- en: For example, to force alignment of a **`complex`** variable to its size and
    not half the size, as we saw earlier, you could use
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了强制将一个**`complex`**变量的对齐方式设置为与其大小一致，而不是之前看到的一半大小，你可以使用
- en: '[PRE82]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Or if you know that your platform has efficient vector instructions for **`float`**`[4]`
    arrays:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果你知道你的平台对**`float`**`[4]`数组有高效的向量指令：
- en: '[PRE83]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: These operators don’t help against the Effective Type Rule ([takeaway 12.18](#ch12note18)).
    Even with
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符不能帮助克服有效类型规则（[要点12.18](#ch12note18)）。即使有
- en: '[PRE84]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: the example at the end of [section 12.6](#ch12lev1sec6) remains invalid.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 第12.6节末尾的例子仍然无效。
- en: Summary
  id: totrans-986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'The memory and object model have several layers of abstraction: physical memory,
    virtual memory, storage instances, object representation, and binary representation.'
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存和对象模型有多个抽象层：物理内存、虚拟内存、存储实例、对象表示和二进制表示。
- en: Each object can be seen as an array of **`unsigned char`**.
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象都可以看作是一个**`unsigned char`**数组。
- en: '**`union`**s serve to overlay different object types over the same object representation.'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`union`**用于在不同的对象表示上覆盖不同的对象类型。'
- en: Memory can be aligned differently according to the need for a specific data
    type. In particular, not all arrays of **`unsigned char`** can be used to represent
    any object type.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据特定数据类型的需要，内存可以对齐不同。特别是，并不是所有**`unsigned char`**数组都可以用来表示任何对象类型。
- en: Chapter 13\. Storage
  id: totrans-991
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章\. 存储
- en: This chapter covers
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Creating objects with dynamic allocation
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分配创建对象
- en: The rules of storage and initialization
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和初始化的规则
- en: Understanding object lifetime
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解对象的生命周期
- en: Handling automatic storage
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理自动存储
- en: 'So far, most objects we have handled in our programs have been *variables*:
    that is, objects that are declared in a regular declaration with a specific type
    and an identifier that refers to the object. Sometimes they were defined at a
    different place in the code than they were declared, but even such a definition
    referred to them with a type and identifier. Another category of objects that
    we have seen less often is specified with a type but not with an identifier: *compound
    literals*, as introduced in [section 5.6.4](kindle_split_013.html#ch05lev2sec9).'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们程序中处理的大多数对象都一直是**`变量`**：也就是说，在常规声明中声明的对象，具有特定的类型和一个指向该对象的标识符。有时它们在代码中的定义位置与声明位置不同，但即使是这样的定义也使用类型和标识符来引用它们。我们较少见到的另一类对象是使用类型指定但未使用标识符指定的：*复合字面量*，如在第5.6.4节中介绍。
- en: All such objects, variables or compound literals, have a *lifetime**^C* that
    depends on the syntactical structure of the program. They have an object lifetime
    and identifier visibility that either spans the whole program execution (global
    variables, global literals, and variables that are declared with **`static`**)
    or are bound to a block of statements inside a function.^([[1](#ch13fn01)])
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对象，无论是变量还是复合字面量，都有一个**`lifetime`**^C，它取决于程序的语法结构。它们具有对象生命期和标识符可见性，要么跨越整个程序执行（全局变量、全局字面量和使用**`static`**声明的变量），要么绑定到函数内部的语句块中.^([[1](#ch13fn01)])
- en: ¹
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fact, this is a bit of a simplification; we will see the gory details shortly.
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，这有点简化；我们很快就会看到细节。
- en: 'We also have seen that for certain objects, it is important to distinguish
    different instances: when we declare a variable in a recursive function. Each
    call in a hierarchy of recursive calls has its own instance of such a variable.
    Therefore, it is convenient to distinguish another entity that is not exactly
    the same as an object, the storage instance.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，对于某些对象，区分不同的实例很重要：当我们在一个递归函数中声明一个变量时。递归调用层次结构中的每个调用都有自己的此类变量的实例。因此，区分另一个不是完全相同于对象的实体是有方便的，即存储实例。
- en: In this chapter, we will handle another mechanism to create objects, called
    *dynamic allocation* ([section 13.1](#ch13lev1sec1)). In fact, this mechanism
    creates storage instances that are only seen as byte arrays and do not have any
    interpretation as objects. They only acquire a type once we store something.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理另一种创建对象的机制，称为**动态分配**([章节 13.1](#ch13lev1sec1))。实际上，这种机制创建的存储实例仅被视为字节数组，并且没有作为对象进行任何解释。只有当我们存储某些内容时，它们才会获得类型。
- en: With this, we have an almost-complete picture of the different possibilities,
    and we can thus discuss the different rules for storage *duration*, object *lifetime*,
    and identifier *visibility* ([section 13.2](#ch13lev1sec2)); we will also take
    a full dive into the rules for initialization ([section 13.4](#ch13lev1sec4)),
    as these differ significantly for differently created objects.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们几乎完全了解了不同的可能性，因此我们可以讨论存储**持续时间**、对象**生命周期**和标识符**可见性**的不同规则([章节 13.2](#ch13lev1sec2))；我们还将深入探讨初始化的规则([章节
    13.4](#ch13lev1sec4))，因为这些规则对于不同创建的对象差异很大。
- en: Additionally, we propose two digressions. The first is a more-detailed view
    of object lifetime, which allows us to access objects at surprising points in
    the C code ([section 13.3](#ch13lev1sec3)). The second provides a glimpse into
    a realization of the memory model for a concrete architecture ([section 13.5](#ch13lev1sec5))
    and in particular how automatic storage may be handled on your particular machine.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提出两个旁白。第一个是对对象生命周期的更详细观察，这使我们能够在C代码的令人惊讶的点访问对象([章节 13.3](#ch13lev1sec3))。第二个提供了对具体架构的内存模型实现的一瞥([章节
    13.5](#ch13lev1sec5))，特别是如何在你的特定机器上处理自动存储。
- en: 13.1\. malloc and friends
  id: totrans-1006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. malloc 和相关函数
- en: For programs that have to handle growing collections of data, the types of objects
    that we have seen so far are too restrictive. To handle varying user input, web
    queries, large interaction graphs and other irregular data, big matrices, and
    audio streams, it is convenient to reclaim storage instances for objects on the
    fly and then release them once they are not needed anymore. Such a scheme is called
    *dynamic allocation**^C*, or sometimes just *allocation* for short.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 对于必须处理数据集合不断增长的程序，我们迄今为止看到的对象类型过于受限。为了处理变化的用户输入、网络查询、大型交互图和其他不规则数据、大型矩阵和音频流，在需要时即时回收对象的存储实例并在不再需要时释放它们是方便的。这种方案称为**动态分配**^C，有时简称为**分配**。
- en: '|  |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdlib.h>`'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdlib.h>`'
- en: '|  |'
  id: totrans-1010
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following set of functions, available with `stdlib.h`, has been designed
    to provide such an interface to allocated storage:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组函数，通过`stdlib.h`提供，已被设计为提供对分配存储的接口：
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE85]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|  |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The first two, **malloc** (memory allocate) and **free**, are by far the most
    prominent. As their names indicate, **malloc** creates a storage instance for
    us on the fly, and **free** then annihilates it. The three other functions are
    specialized versions of **malloc**: **calloc** (clear allocate) sets all bits
    of the new storage to `0`, **realloc** grows or shrinks storage, and **aligned_alloc**
    ensures nondefault alignment.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数，**malloc**（内存分配）和**free**，迄今为止是最突出的。正如它们的名称所表明的，**malloc**会即时为我们创建一个存储实例，而**free**则会将其销毁。另外三个函数是**malloc**的专用版本：**calloc**（清除分配）将新存储的所有位都设置为`0`，**realloc**可以扩展或缩小存储空间，而**aligned_alloc**确保非默认对齐。
- en: 'All these functions operate with **`void`**`*`: that is, with pointers for
    which no type information is known. Being able to specify such a “non-type” for
    this series of functions is probably the *raison d’être* for the whole game with
    **`void`**`*` pointers. Using that, they become universally applicable to all
    types. The following example allocates a large storage for a vector of **`double`**s,
    one element for each living person:^([[[Exs 1]](#ch13fn-ex01)])'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都使用**`void`**`*`：也就是说，对于没有已知类型信息的指针。能够为这一系列函数指定这种“非类型”可能是整个**`void`**`*`指针游戏的**目的**。使用它，它们可以普遍适用于所有类型。以下示例为**`double`**类型的向量分配大量存储空间，每个元素对应一个活着的人：^([[[Exs
    1]](#ch13fn-ex01)])
- en: ^([Exs 1])
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t try this allocation, but compute the size that would be needed on your
    platform. Is allocating such a vector feasible on your platform?
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要尝试这种分配，但计算一下在你的平台上需要的空间大小。在你的平台上分配这样一个向量是否可行？
- en: '|  |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE86]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|  |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because **malloc** knows nothing about the later use or type of the to-be-stored
    object, the size of the storage is specified in bytes. In the idiom given here,
    we have specified the type information only once, as the pointer type for largeVec.
    By using **`sizeof`** `*`largeVec in the parameter for the **malloc** call, we
    ensure that we will allocate the right number of bytes. Even if we change largeVec
    later to have type **`size_t`**`*`, the allocation will adapt.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 **malloc** 对将要存储的对象的后续使用或类型一无所知，存储的大小是以字节为单位的。在给定的惯用表达式中，我们只为 largeVec 的指针类型指定了一次类型信息。通过在
    **malloc** 调用的参数中使用 **`sizeof`** `*`largeVec，我们确保将分配正确的字节数。即使我们后来将 largeVec 的类型更改为
    **`size_t`**`*`，分配也会相应调整。
- en: 'Another idiom that we will often encounter strictly takes the size of the type
    of the object that we want to create: an array of length elements of type **`double`**:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种我们经常会遇到的惯用表达方式严格地取我们想要创建的对象的类型的大小：一个长度为元素个数的 **`double`** 类型的数组：
- en: '|  |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE87]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|  |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We already have been haunted by the introduction of casts, which are explicit
    conversions. It is important to note that the call to **malloc** stands as is;
    the conversion from **`void`**`*`, the return type of **malloc**, to the target
    type is automatic and doesn’t need any intervention.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经被引入了类型转换所困扰，这些转换是显式的。重要的是要注意，对 **malloc** 的调用保持原样；从 **`void`**`*`（**malloc**
    的返回类型）到目标类型的转换是自动的，不需要任何干预。
- en: '|  |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.1
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.1
- en: '*Don’t cast the return of* **malloc** *and friends.*'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要对* **malloc** *及其相关函数的返回值进行类型转换。*'
- en: '|  |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Not only is such a cast superfluous, but doing an explicit conversion can even
    be counterproductive when we forget to include the header file `stdlib.h`:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅这种类型转换是多余的，而且当我们忘记包含头文件 `stdlib.h` 时，进行显式转换甚至可能适得其反：
- en: '|  |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<stdlib.h>`'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`<stdlib.h>`'
- en: '|  |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE88]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '|  |'
  id: totrans-1039
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Older C compilers then suppose a return of **`int`** and trigger the wrong conversion
    from **`int`** to a pointer type. I have seen many crashes and subtle bugs triggered
    by that error, in particular in beginners’ code whose authors have been following
    bad advice.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 C 编译器会假设返回 **`int`** 并触发从 **`int`** 到指针类型的错误转换。我见过许多由这个错误引起的崩溃和微妙的错误，特别是在初学者的代码中，这些代码的作者一直遵循着不良的建议。
- en: 'In the previous code, as a next step, we initialize the storage that we just
    allocated through assignment: here, all `0.0`. It is only with these assignments
    that the individual elements of largeVec become “objects.” Such an assignment
    provides an effective type *and* a value.'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，作为下一步，我们通过赋值初始化我们刚刚分配的存储：这里，所有 `0.0`。只有这些赋值使得 largeVec 的各个元素成为“对象”。这样的赋值提供了有效的类型和值。
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.2
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.2
- en: '*Storage that is allocated through* **malloc** *is uninitialized and has no
    type.*'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过* **malloc** *分配的存储是未初始化的，没有类型。*'
- en: '|  |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.1.1\. A complete example with varying array size
  id: totrans-1046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 具有可变数组大小的完整示例
- en: 'Let us now look at an example where using a dynamic array that is allocated
    with **malloc** brings us more flexibility than a simple array variable. The following
    interface describes a circular buffer of **`double`** values called circular:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，使用通过 **malloc** 分配的动态数组比简单的数组变量提供了更多的灵活性。以下接口描述了一个名为 circular 的 **`double`**
    类型的循环缓冲区：
- en: '|  |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular: an opaque type for a circular buffer for **`double`** values'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular: 用于 **`double`** 类型的循环缓冲区的不可见类型'
- en: This data structure allows to add **`double`** values in rear and to take them
    out in front. Each such structure has a maximal amount of elements that can be
    stored in it.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据结构允许在尾部添加 **`double`** 类型的值，并在前面取出。每个这样的结构都有一个最大元素数量，可以存储在其中。
- en: '[PRE89]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_append: Append a new element with value *value* to the buffer *c*.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_append: 将具有值 *value* 的新元素追加到缓冲区 *c*。'
- en: '**Returns**: c if the new element could be appended, `0` otherwise.'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：如果新元素可以追加，则返回 c，否则返回 `0`。'
- en: '[PRE90]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '|  |'
  id: totrans-1059
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_pop: Remove the oldest element from *c* and return its value.'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_pop: 从 *c* 中移除最旧的元素并返回其值。'
- en: '**Returns**: the removed element if it exists, `0.0` otherwise.'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：如果存在，则返回移除的元素，否则返回 `0.0`。'
- en: '[PRE91]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '|  |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The idea is that, starting with `0` elements, new elements can be appended
    to the buffer or dropped from the front, as long as the number of elements that
    are stored doesn’t exceed a certain limit. The individual elements that are stored
    in the buffer can be accessed with the following function:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，从`0`个元素开始，只要存储的元素数量不超过某个限制，就可以将新元素追加到缓冲区或从前面删除。可以使用以下函数访问存储在缓冲区中的单个元素：
- en: '|  |'
  id: totrans-1067
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_element: Return a pointer to position *pos* in buffer *c*.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_element: 返回指向缓冲区*c*中位置*pos*的指针。'
- en: '**Returns**: a pointer to the *pos’* element of the buffer, `0` otherwise.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：指向缓冲区中*pos*位置的指针，否则返回`0`。'
- en: '[PRE92]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|  |'
  id: totrans-1072
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Since our type circular will need to allocate and deallocate space for the
    circular buffer, we will need to provide consistent functions for initialization
    and destruction of instances of that type. This functionality is provided by two
    pairs of functions:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的类型circular将需要为循环缓冲区分配和释放空间，因此我们需要提供初始化和销毁此类类型实例的一致函数。这种功能由两对函数提供：
- en: '|  |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_init: Initialize a circular buffer *c* with maximally *max_len* elements.'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_init: 使用最多*max_len*个元素的*max_len*初始化循环缓冲区*c*。'
- en: Only use this function on an uninitialized buffer.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在未初始化的缓冲区上使用此函数。
- en: Each buffer that is initialized with this function must be destroyed with a
    call to circular_destroy.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数初始化的每个缓冲区都必须通过调用circular_destroy销毁。
- en: '[PRE93]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '|  |'
  id: totrans-1080
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1081
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_destroy: Destroy circular buffer *c*.'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_destroy: 销毁循环缓冲区*c*。'
- en: '*c* must have been initialized with a call to circular_init'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*必须通过调用circular_init初始化'
- en: '[PRE94]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1087
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_new: Allocate and initialize a circular buffer with maximally *len*
    elements.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_new: 分配并初始化一个最多有*len*个元素的循环缓冲区。'
- en: Each buffer that is allocated with this function must be deleted with a call
    to circular_delete.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数分配的每个缓冲区都必须通过调用circular_delete删除。
- en: '[PRE95]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '|  |'
  id: totrans-1092
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_delete: Delete circular buffer *c*.'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_delete: 删除循环缓冲区*c*。'
- en: '*c* must have been allocated with a call to circular_new'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*必须通过调用circular_new分配'
- en: '[PRE96]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '|  |'
  id: totrans-1098
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first pair is to be applied to existing objects. They receive a pointer
    to such an object and ensure that space for the buffer is allocated or freed.
    The first of the second pair creates an object and initializes it; the last destroys
    that object and then deallocates the memory space.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对应用于现有对象。它们接收指向此类对象的指针并确保为缓冲区分配或释放空间。第二对中的第一个创建对象并初始化它；最后一个销毁该对象然后释放内存空间。
- en: 'If we used regular array variables, the maximum number of elements that we
    could store in a circular would be fixed once we created such an object. We want
    to be more flexible so this limit can be raised or lowered by means of the circular_resize
    function and the number of elements can be queried with circular_getlength:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用常规数组变量，一旦创建了此类对象，我们可以在循环中存储的最大元素数量将是固定的。我们希望更加灵活，因此可以通过circular_resize函数提高或降低此限制，并且可以使用circular_getlength查询元素数量：
- en: '|  |'
  id: totrans-1101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_resize: Resize to capacity *max_len*.'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_resize: 调整到容量*max_len*。'
- en: '[PRE97]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '|  |'
  id: totrans-1105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`circular.h`**'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '**`circular.h`**'
- en: 'circular_getlength: Return the number of elements stored.'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 'circular_getlength: 返回存储的元素数量。'
- en: '[PRE98]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Then, with the function circular_element, it behaves like an array of **`double`**s:
    calling it with a position within the current length, we obtain the address of
    the element that is stored in that position.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用circular_element函数，它表现得像一个**`double`**数组：在当前长度内调用它，我们获得存储在该位置的元素的地址。
- en: 'The hidden definition of the structure is as follows:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的隐藏定义如下：
- en: '**`circular.c`**'
  id: totrans-1113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE99]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The idea is that the pointer member tab will always point to an array object
    of length max_len. At a certain point in time the buffered elements will start
    at start, and the number of elements stored in the buffer is maintained in member
    len. The position inside the table tab is computed modulo max_len.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，指针成员tab将始终指向长度为max_len的数组对象。在某个时间点，缓冲区元素将从start开始，存储在缓冲区中的元素数量由成员len维护。在tab表中的位置是计算max_len的模。
- en: The following table symbolizes one instance of this circular data structure,
    with max_len=10, start`=2`, and len`=4`.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格表示这种循环数据结构的一个实例，其中max_len=10，start`=2`，len`=4`。
- en: '![](pg_210-01_alt.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_210-01_alt.jpg)'
- en: We see that the buffer contents (the four numbers `6.0`, `7.7`, `81.0`, and
    `99.0`) are placed consecutively in the array object pointed to by tab.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，缓冲区内容（四个数字`6.0`、`7.7`、`81.0`和`99.0`）连续放置在tab指向的数组对象中。
- en: The following scheme represents a circular buffer with the same four numbers,
    but the storage space for the elements wraps around.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的方案表示了一个具有相同四个数字的循环缓冲区，但元素存储空间是环绕的。
- en: '![](pg_210-02_alt.jpg)'
  id: totrans-1120
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_210-02_alt.jpg)'
- en: Initialization of such a data structure needs to call **malloc** to provide
    memory for the tab member. Other than that it is
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据结构的初始化需要调用**malloc**为tab成员提供内存。除此之外
- en: '**`circular.c`**'
  id: totrans-1122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE100]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Observe that this function always checks the pointer parameter c for validity.
    Also, it guarantees to initialize all other members to `0` by assigning compound
    literals in both branches of the conditional.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数总是检查指针参数c的有效性。此外，它通过在条件语句的两个分支中赋值复合字面量，保证初始化所有其他成员为`0`。
- en: The library function **malloc** can fail for different reasons. For example,
    the memory system might be exhausted from previous calls to it, or the reclaimed
    size for allocation might just be too large. In a general-purpose system like
    the one you are probably using for your learning experience, such a failure will
    be rare (unless voluntarily provoked), but it still is a good habit to check for
    it.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数**malloc**可能会因为不同的原因失败。例如，内存系统可能因为之前的调用而耗尽，或者分配的回收大小可能太大。在一个通用系统（你很可能正在使用这样的系统来学习）中，这样的失败是罕见的（除非是故意引起的），但检查它仍然是一个好习惯。
- en: '|  |'
  id: totrans-1126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.3
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点13.3
- en: '**malloc** *indicates failure by returning a null pointer value.*'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**malloc**通过返回一个空指针值来**指示失败**。'
- en: '|  |'
  id: totrans-1129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Destruction of such an object is even simpler: we just have to check for the
    pointer, and then we may **free** the tab member unconditionally.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的对象的销毁甚至更简单：我们只需检查指针，然后就可以无条件地**free**tab成员。
- en: '**`circular.c`**'
  id: totrans-1131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE101]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The library function **free** has the friendly property that it accepts a null
    parameter and does nothing in that case.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 库函数**free**有一个友好的特性，即它接受一个空参数，并在该情况下不执行任何操作。
- en: The implementation of some of the other functions uses an internal function
    to compute the “circular” aspect of the buffer. It is declared **`static`** so
    it is only visible for those functions and doesn’t pollute the identifier name
    space ([takeaway 9.8](kindle_split_019.html#ch09note10)).
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他函数的实现使用一个内部函数来计算缓冲区的“循环”部分。它被声明为**`static`**，因此它只对那些函数可见，不会污染标识符命名空间（[要点9.8](kindle_split_019.html#ch09note10)）。
- en: '**`circular.c`**'
  id: totrans-1135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE102]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Obtaining a pointer to an element of the buffer is now quite simple.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 获取缓冲区元素的指针现在相当简单。
- en: '**`circular.c`**'
  id: totrans-1138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE103]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'With all of that information, you should now be able to implement all but one
    of the function interfaces nicely.^([[[Exs 2]](#ch13fn-ex02)]) The one that is
    more difficult is circular_resize. It starts with some length calculations and
    then treats the cases in which the request would enlarge or shrink the table.
    Here we have the naming convention of using o (old) as the first character of
    a variable name that refers to a feature before the change, and n (new) to its
    value afterward. The end of the function then uses a compound literal to compose
    the new structure by using the values found during the case analysis:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了所有这些信息之后，你现在应该能够很好地实现除了一个之外的所有函数接口。更难的一个是circular_resize。它从一些长度计算开始，然后处理请求会扩大或缩小表的情况。在这里，我们使用命名约定，用o（旧）作为指向前变化特征的变量名的第一个字符，用n（新）表示变化后的值。函数的末尾使用复合字面量，通过在情况分析期间找到的值来组合新的结构：
- en: ^([Exs 2])
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([例 2])
- en: ''
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write implementations of the missing functions.
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写缺失函数的实现。
- en: '**circular.c**'
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**circular.c**'
- en: '[PRE104]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '**`circular.c`**'
  id: totrans-1146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE105]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let us now try to fill the gap in the previous code and look at the first case
    of enlarging an object. The essential part of this is a call to **realloc**:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试填补前面代码中的空白，并查看扩大对象的第一种情况。这其中的关键部分是对**realloc**的调用：
- en: '**`circular.c`**'
  id: totrans-1149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE106]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: For this call, **realloc** receives the pointer to the existing object and the
    new size the relocation should have. It returns either a pointer to the new object
    with the desired size or null. In the line immediately after, we check the latter
    case and terminate the function if it was not possible to relocate the object.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个调用，**realloc**接收现有对象的指针和重定位应具有的新大小。它返回指向新对象（具有所需大小）的指针或null。在下一行，我们检查后一种情况，如果无法重定位对象，则终止函数。
- en: 'The function **realloc** has interesting properties:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数**realloc**具有有趣的特性：
- en: The returned pointer may or may not be the same as the argument. It is left
    to the discretion of the runtime system to determine whether the resizing can
    be performed in place (if there is space available behind the object, for example,
    or if a new object must be provided. But, regardless of that, even if the returned
    pointer is the same, the object is considered to be a new one (with the same data).
    That means in particular that all pointers derived from the original become invalid.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的指针可能与参数相同，也可能不同。是否可以在原地执行调整（例如，如果对象后面有空间，或者如果必须提供新对象）由运行时系统决定。但无论如何，即使返回的指针相同，对象也被视为新的（具有相同的数据）。这意味着特别是所有从原始对象派生的指针都无效。
- en: If the argument pointer and the returned one are distinct (that is, the object
    has been copied), nothing has to be done (or even should be) with the previous
    pointer. The old object is taken care of.
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数指针和返回的指针不同（即对象已被复制），则不需要（甚至不应该）对之前的指针进行任何操作。旧对象将得到妥善处理。
- en: 'As far as possible, the existing content of the object is preserved:'
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地保留对象现有的内容：
- en: If the object is enlarged, the initial part of the object that corresponds to
    the previous size is left intact.
  id: totrans-1156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象扩大，对象对应于之前大小的初始部分保持不变。
- en: If the object shrank, the relocated object has a content that corresponds to
    the initial part before the call.
  id: totrans-1157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象缩小，重定位的对象内容与调用前的初始部分相对应。
- en: If `0` is returned (that is, the relocation request could not be fulfilled by
    the runtime system), the old object is unchanged. So, nothing is lost.
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回`0`（即重定位请求无法由运行时系统满足），则旧对象保持不变。因此，没有丢失任何内容。
- en: Now that we know the newly received object has the size we want, we have to
    ensure that tab still represents a circular buffer. If previously the situation
    was as in the first table, earlier (the part that corresponds to the buffer elements
    is contiguous), we have nothing to do. All data is nicely preserved.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道新接收的对象具有我们想要的大小，我们必须确保tab仍然代表一个环形缓冲区。如果之前的情况与第一个表相同，早期（对应于缓冲区元素的这部分是连续的），我们不需要做任何事情。所有数据都得到了妥善保存。
- en: 'If our circular buffer wrapped around, we have to make some adjustments:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的环形缓冲区已绕过，我们必须做一些调整：
- en: '**`circular.c`**'
  id: totrans-1161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`circular.c`**'
- en: '[PRE107]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following table illustrates the difference in the contents between before
    and after the changes for the first subcase: the lower part finds enough space
    inside the part that was added:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了第一个子案例在修改前后的内容差异：下部分在新增的部分内部找到了足够的空间：
- en: '![](pg_214-01_alt.jpg)'
  id: totrans-1164
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_214-01_alt.jpg)'
- en: 'The other case, where the lower part doesn’t fit into the newly allocated part,
    is similar. This time, the upper half of the buffer is shifted toward the end
    of the new table:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况，下部分无法适应新分配的部分，与这种情况类似。这次，缓冲区的上半部分被移向新表末尾：
- en: '![](pg_214-02_alt.jpg)'
  id: totrans-1166
  prefs: []
  type: TYPE_IMG
  zh: '![](pg_214-02_alt.jpg)'
- en: The handling of both cases shows a subtle difference, though. The first is handled
    with **memcpy**; the source and target elements of the copy operation can’t overlap,
    so using **memcpy** here is safe. For the other case, as we see in the example,
    the source and target elements may overlap, and thus the use of the less-restrictive
    **memmove** function is required.^([[[Exs 3]](#ch13fn-ex03)])
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种情况的处理方式有所不同，但都显示了细微的差别。第一种情况使用**memcpy**处理；复制操作的数据源和目标元素不能重叠，因此在这里使用**memcpy**是安全的。对于另一种情况，正如示例所示，源和目标元素可能重叠，因此需要使用更宽松的**memmove**函数。^([[[Exs
    3]](#ch13fn-ex03)])
- en: ^([Exs 3])
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-1169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Implement shrinking of the table: it is important to reorganize the table contents
    before calling **realloc**.'
  id: totrans-1170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现表的缩小：在调用**realloc**之前重新组织表内容非常重要。
- en: 13.1.2\. Ensuring consistency of dynamic allocations
  id: totrans-1171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. 确保动态分配的一致性
- en: 'As in both our code examples, calls to allocation functions such as **malloc**,
    **realloc**, and **free** should always come in pairs. This mustn’t necessarily
    be inside the same function, but in most cases simple counting of the occurrence
    of both should give the same number:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的代码示例中一样，对分配函数（如 **malloc**、**realloc** 和 **free**）的调用应该始终成对出现。这不一定是在同一个函数内部，但在大多数情况下，简单地计数两者的发生次数应该给出相同的数字：
- en: '|  |'
  id: totrans-1173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.4
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.4
- en: '*For every allocation, there must be a* **free***.*'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于每一次分配，都必须有一个* **释放**.*'
- en: '|  |'
  id: totrans-1176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If not, this could indicate a *memory leak**^C*: a loss of allocated objects.
    This could lead to resource exhaustion of your platform, showing itself in low
    performance or random crashes.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，这可能会表明 *内存泄漏**^C**：已分配对象的损失。这可能导致你的平台资源耗尽，表现为性能低下或随机崩溃。
- en: '|  |'
  id: totrans-1178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.5
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.5
- en: '*For every* **free***, there must be a* **malloc***,* **calloc***,* **aligned_alloc***,
    or* **realloc***.*'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于每一次* **释放**，都必须有一个* **malloc**、**calloc**、**aligned_alloc** 或 **realloc**.*'
- en: '|  |'
  id: totrans-1181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'But be aware that **realloc** can easily obfuscate simple counting of allocations:
    because if it is called with an existing object, it serves as deallocation (for
    the old object) and allocation (for the new one) at the same time.'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意，**realloc** 很容易模糊简单的分配计数：因为如果它用一个现有的对象被调用，它同时作为（旧对象的）释放和（新对象的）分配。
- en: The memory-allocation system is meant to be simple, and thus **free** is only
    allowed for pointers that have been allocated with **malloc** or that are null.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配系统旨在简单，因此**free** 只允许用于用 **malloc** 分配的指针或空指针。
- en: '|  |'
  id: totrans-1184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.6
  id: totrans-1185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.6
- en: '*Only call* **free** *with pointers as they are returned by* **malloc***,*
    **calloc***,* **aligned_alloc***, or* **realloc***.*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '*只使用* **free** *指针，它们是* **malloc**、**calloc**、**aligned_alloc** 或 **realloc**
    返回的。'
- en: '|  |'
  id: totrans-1187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: They *must not*
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们 *必须不*
- en: Point to an object that has been allocated by other means (that is, a variable
    or a compound literal)
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向由其他方式分配的对象（即变量或复合字面量）
- en: Have been freed yet
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还未被释放
- en: Only point to a smaller part of the allocated object.
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只指向分配对象的一个更小的部分。
- en: Otherwise, your program will crash. Seriously, this will completely corrupt
    the memory of your program execution, which is one of the worst types of crashes
    you can have. Be careful.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你的程序将会崩溃。说真的，这将完全破坏你的程序执行内存，这是你可以遇到的最糟糕的崩溃之一。请小心。
- en: 13.2\. Storage duration, lifetime, and visibility
  id: totrans-1193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 存储持续时间、生命周期和可见性
- en: We have seen in different places that visibility of an identifier and accessibility
    of the object to which it refers are not the same thing. As a simple example,
    take the variable(s) x in [listing 13.1](#ch13ex10).
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在不同的地方看到，标识符的可见性和它所引用的对象的可访问性并不是同一件事。作为一个简单的例子，考虑[列表 13.1](#ch13ex10)中的变量(s)
    x。
- en: Listing 13.1\. An example of shadowing with local variables
  id: totrans-1195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 使用局部变量的遮蔽示例
- en: '[PRE108]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here, the visibility scope of the identifier x that is declared in line 5 starts
    from that line and goes to the end of the function **main**, but with a noticeable
    interruption: from line 10 to 14, this visibility is *shadowed**^C* by another
    variable, also named x.'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第 5 行声明的标识符 x 的可见作用域从该行开始，延伸到函数 **main** 的末尾，但有一个明显的中断：从第 10 行到 14 行，这个可见性被另一个同名的变量，也命名为
    x 的变量所 *遮蔽**^C*。
- en: '|  |'
  id: totrans-1198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.7
  id: totrans-1199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.7
- en: '*Identifiers only have visibility inside their scope, starting at their declaration.*'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符只在它们的声明范围内可见，从它们的声明开始。*'
- en: '|  |'
  id: totrans-1201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.8
  id: totrans-1203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.8
- en: '*The visibility of an identifier can be shadowed by an identifier of the same
    name in a subordinate scope.*'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符的可见性可以被从属作用域中同名的标识符所遮蔽。*'
- en: '|  |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We also see that the visibility of an identifier and the usability of the object
    it represents are not the same thing. First, the **`double`** x *object* is used
    by all calls to squareIt, although the identifier x is not visible at the point
    where the function is defined. Then, on line 12, we pass the address of the **`double`**
    x variable to the function squareIt, although the identifier is shadowed there.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，标识符的可见性和它所代表的对象的可使用性并不是同一件事。首先，**`double`** x *对象* 被squareIt的所有调用使用，尽管标识符
    x 在函数定义的点不可见。然后，在第 12 行，我们传递**`double`** x 变量的地址到函数squareIt，尽管在那里标识符被遮蔽。
- en: Another example concerns declarations that are tagged with the storage class
    **`extern`**. These always designate an object of static storage duration that
    is expected to be defined at file scope;^([[2](#ch13fn02)]) see [listing 13.2](#ch13ex11).
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子涉及带有存储类别**`extern`**的声明。这些总是指定一个静态存储持续时间的对象，预期在文件作用域中定义；^([[2](#ch13fn02)])参见[列表13.2](#ch13ex11)。
- en: ²
  id: totrans-1208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In fact, such an object can be defined at file scope in another translation
    unit.
  id: totrans-1210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，这样的对象可以在另一个翻译单元的文件作用域中定义。
- en: Listing 13.2\. An example of shadowing with an `extern` variable
  id: totrans-1211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.2\. 使用`extern`变量的阴影示例
- en: '[PRE109]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This program has three declarations for variables named i, but only two definitions:
    the declaration and definition on line 6 shadows the one on line 3\. In turn,
    declaration line 8 shadows line 6, but it refers to the same object as the object
    defined on line 3.^([[[Exs 4]](#ch13fn-ex04)])'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有三个名为i的变量声明，但只有两个定义：第6行的声明和定义覆盖了第3行的声明。反过来，第8行的声明覆盖了第6行，但它引用的是第3行定义的对象。^([[[Exs
    4]](#ch13fn-ex04)])
- en: ^([Exs 4])
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 4])
- en: ''
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which value is printed by this program?
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个程序打印出哪个值？
- en: '|  |'
  id: totrans-1217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.9
  id: totrans-1218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.9
- en: '*Every definition of a variable creates a new, distinct object.*'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个变量的定义都创建了一个新的、独特的对象*。'
- en: '|  |'
  id: totrans-1220
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'So in the following, the **`char`** arrays A and B identify distinct objects,
    with distinct addresses. The expression A `==` B *must* always be false:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下面的例子中，**`char`**数组A和B标识不同的对象，具有不同的地址。表达式A `==` B**必须**始终为假：
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE110]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|  |'
  id: totrans-1224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'But how many distinct array objects are there in total? It depends. The compiler
    has a lot of choices:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 但总共有多少个不同的数组对象？这取决于。编译器有很多选择：
- en: '|  |'
  id: totrans-1226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.10
  id: totrans-1227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.10
- en: '*Read-only object literals may overlap.*'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: '*只读对象字面量可能重叠*。'
- en: '|  |'
  id: totrans-1229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the previous example, we have three string literals and two compound literals.
    These are all object literals, and they are read-only: string literals are read-only
    by definition, and the two compound literals are **`const`**-qualified. Four of
    them have exactly the same base type and content (''e''`,` ''n`'',` ''d`'',` ''\0''),
    so the four pointers c, d, f, and g may all be initialized to the same address
    of one **`char`** array. The compiler may even save more memory: this address
    may just be &`e[3]`, by using the fact that *end* appears at the end of *friend*.'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有三个字符串字面量和两个复合字面量。这些都是对象字面量，它们是只读的：字符串字面量按定义是只读的，两个复合字面量是**`const`**修饰的。其中四个具有完全相同的基类型和内容('e'`,`
    'n`',` 'd`',` '\0')，所以指针c, d, f和g都可能初始化到同一个**`char`**数组的地址。编译器甚至可能节省更多内存：这个地址可能是&`e[3]`，通过使用*end*出现在*friend*结尾的事实。
- en: 'As we have seen from these examples, the usability of an object not only is
    a lexical property of an identifier or of the position of definition (for literals),
    but also depends on the state of execution of the program. The *lifetime**^C*
    of an object has a starting point and an end point:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中我们可以看到，一个对象的可访问性不仅是一个标识符或定义位置的词法属性（对于字面量），还取决于程序的执行状态。对象的**生命周期**有一个起点和一个终点：
- en: '|  |'
  id: totrans-1232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.11
  id: totrans-1233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.11
- en: '*Objects have a lifetime outside of which they can’t be accessed.*'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象在其生命周期之外无法访问*。'
- en: '|  |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.12
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.12
- en: '*Referring to an object outside of its lifetime has undefined behavior.*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用其生命周期之外的对象具有未定义的行为*。'
- en: '|  |'
  id: totrans-1239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'How the start and end points of an object are defined depends on the tools
    we use to create it. We distinguish four different *storage durations**^C* for
    objects in C: *static**^C* when it is determined at compile time, *automatic**^C*
    when it is automatically determined at runtime, *allocated**^C*, when it is explicitly
    determined by function calls **malloc** and friends, and *thread**^C* when it
    is bound to a certain thread of execution.'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的开头和结尾点的定义取决于我们用来创建它的工具。在C语言中，我们区分四种不同的对象**存储持续时间**：**静态**^C*，当它在编译时确定；**自动**^C*，当它在运行时自动确定；**分配**^C*，当它通过函数调用**malloc**和类似函数显式确定；以及**线程**^C*，当它与某个执行线程绑定。
- en: '[Table 13.1](#ch13table01) gives an overview of the complicated relationship
    between declarations and their *storage classes*, initialization, linkage, *storage
    duration*, and lifetime. Without going into too much detail for the moment, it
    shows that the usage of keywords and the underlying terminology are quite confusing.'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '[表13.1](#ch13table01)概述了声明与其**存储类别**、初始化、链接、**存储持续时间**和生命周期之间复杂的关系。目前不深入细节，它显示关键字的使用和底层术语相当令人困惑。'
- en: Table 13.1\. *Storage classes, scope, linkage of identifiers, and storage duration
    of the associated objects* *Tentative* indicates that a definition is implied
    only if there is no other definition with an initializer. *Induced* indicates
    that the linkage is internal if another declaration with internal linkage has
    been met prior to that declaration; otherwise, it is external.
  id: totrans-1242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 13.1\. *标识符的存储类别、作用域、链接和关联对象的存储持续时间* *暂定* 表示如果没有其他带有初始化器的定义，则隐含定义。*诱导* 表示如果在该声明之前遇到了具有内部链接的另一个声明，则链接是内部的；否则，它是外部的。
- en: '| Class | Scope | Definition | Linkage | Duration | Lifetime |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 范围 | 定义 | 链接 | 持续时间 | 生命周期 |'
- en: '| Initialized | File | Yes | External | Static | Whole execution |'
  id: totrans-1244
  prefs: []
  type: TYPE_TB
  zh: '| 已初始化 | 文件 | 是 | 外部 | 静态 | 整个执行过程 |'
- en: '| **extern**, initialized | File | Yes | External | Static | Whole execution
    |'
  id: totrans-1245
  prefs: []
  type: TYPE_TB
  zh: '| **extern**，已初始化 | 文件 | 是 | 外部 | 静态 | 整个执行过程 |'
- en: '| Compound literal | File | Yes | N/A | Static | Whole execution |'
  id: totrans-1246
  prefs: []
  type: TYPE_TB
  zh: '| 复合字面量 | 文件 | 是 | N/A | 静态 | 整个执行过程 |'
- en: '| String literal | Any | Yes | N/A | Static | Whole execution |'
  id: totrans-1247
  prefs: []
  type: TYPE_TB
  zh: '| 字符串字面量 | 任何 | 是 | N/A | 静态 | 整个执行过程 |'
- en: '| **static**, initialized | Any | Yes | Internal | Static | Whole execution
    |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
  zh: '| **静态**，已初始化 | 任何 | 是 | 内部 | 静态 | 整个执行过程 |'
- en: '| Uninitialized | File | Tentative | External | Static | Whole execution |'
  id: totrans-1249
  prefs: []
  type: TYPE_TB
  zh: '| 未初始化 | 文件 | 暂定 | 外部 | 静态 | 整个执行过程 |'
- en: '| **extern**, uninitialized | Any | No | Induced | Static | Whole execution
    |'
  id: totrans-1250
  prefs: []
  type: TYPE_TB
  zh: '| **extern**，未初始化 | 任何 | 否 | 诱导 | 静态 | 整个执行过程 |'
- en: '| **static**, uninitialized | Any | Tentative | Internal | Static | Whole execution
    |'
  id: totrans-1251
  prefs: []
  type: TYPE_TB
  zh: '| **静态**，未初始化 | 任何 | 暂定 | 内部 | 静态 | 整个执行过程 |'
- en: '| **thread_local** | File | Yes | External | Thread | Whole thread |'
  id: totrans-1252
  prefs: []
  type: TYPE_TB
  zh: '| **线程局部** | 文件 | 是 | 外部 | 线程 | 整个线程 |'
- en: '| **extern** **thread_local** | Any | No | External | Thread | Whole thread
    |'
  id: totrans-1253
  prefs: []
  type: TYPE_TB
  zh: '| **extern** **线程局部** | 任何 | 否 | 外部 | 线程 | 整个线程 |'
- en: '| **static** **thread_local** | Any | Yes | internal | Thread | Whole thread
    |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
  zh: '| **静态** **线程局部** | 任何 | 是 | 内部 | 线程 | 整个线程 |'
- en: '| Compound literal |   |   | N/A |   |   |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
  zh: '| 复合字面量 |   |   | N/A |   |   |'
- en: '| Non-VLA |   |   | None |   |   |'
  id: totrans-1256
  prefs: []
  type: TYPE_TB
  zh: '| 非 VLA |   |   | 无 |   |   |'
- en: '| Non-VLA, **auto** | Block | Yes | None | Automatic | Block of definition
    |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
  zh: '| 非 VLA，**auto** | 块 | 是 | 无 | 自动 | 定义块 |'
- en: '| **register** |   |   | None |   |   |'
  id: totrans-1258
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** |   |   | 无 |   |   |'
- en: '| VLA | Block | Yes | None | Automatic | From definition to end of block |'
  id: totrans-1259
  prefs: []
  type: TYPE_TB
  zh: '| 可变长度数组 (VLA) | 块 | 是 | 无 | 自动 | 块定义到结束 |'
- en: '| Function **return** with array | Block | Yes | None | Automatic | To the
    end of expression |'
  id: totrans-1260
  prefs: []
  type: TYPE_TB
  zh: '| 函数**返回**数组 | 块 | 是 | 无 | 自动 | 表达式结束处 |'
- en: First, unlike what the name suggests, the *storage class* **`extern`** may refer
    to identifiers with external or internal *linkage*.^([[3](#ch13fn03)]) Here, in
    addition to the compiler, an identifier with linkage is usually managed by another
    external program, the *linker**^C*. Such an identifier is initialized at startup
    of the program, even before it enters **main**, and the linker ensures that. Identifiers
    that are accessed from different object files need *external* linkage so they
    all access the same object or function, and so the linker is able to establish
    the correspondence.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与名称所暗示的相反，*存储类别* **`extern`** 可能指代具有外部或内部 *链接* 的标识符.^([[3](#ch13fn03)]) 在这里，除了编译器之外，具有链接的标识符通常由另一个外部程序，即
    *链接器**^C* 管理。这样的标识符在程序启动时初始化，甚至在进入 **main** 之前，链接器确保这一点。从不同对象文件访问的标识符需要 *外部* 链接，以便它们都能访问相同的对象或函数，这样链接器就能建立对应关系。
- en: ³
  id: totrans-1262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that linkage is a property of identifiers, not of the objects they represent.
  id: totrans-1264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，链接是标识符的属性，而不是它们所代表的对象。
- en: Important identifiers with external linkage that we have seen are the functions
    of the C library. They reside in a system *library**^C*, usually called something
    like `libc.so`, and not in the object file you created. Otherwise, a global, file
    scope, object, or function that has no connection to other object files should
    have *internal* linkage. All other identifiers have *no* linkage.^([[4](#ch13fn04)])
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的重要具有外部链接的标识符是 C 库中的函数。它们位于系统 *库**^C* 中，通常称为 `libc.so`，而不是你创建的对象文件中。否则，没有与其他对象文件连接的全局、文件作用域的对象或函数应该具有
    *内部* 链接。所有其他标识符都没有 *链接*.^([[4](#ch13fn04)])
- en: ⁴
  id: totrans-1266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A better keyword for **`extern`** would perhaps be **`linkage`**.
  id: totrans-1268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 **`extern`** 关键字来说，可能更好的词是 **`linkage`**。
- en: Then, static *storage duration* is not the same as declaring a variable with
    the *storage class* **`static`**. The latter is merely enforcing that a variable
    or function has internal linkage. Such a variable may be declared in file scope
    (global) or in block scope (local). ^([[5](#ch13fn05)])You probably have not yet
    called the linker of your platform explicitly. Usually, its execution is hidden
    behind the compiler frontend that you are calling, and a dynamic linker may only
    kick in as late as program startup without being noticed.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，静态存储期并不等同于声明一个具有**`storage class`** **`static`**的变量。后者仅仅强制一个变量或函数具有内部链接。这样的变量可以声明在文件作用域（全局）或块作用域（局部）。^([[5](#ch13fn05)])你可能还没有明确调用你平台的链接器。通常，它的执行被隐藏在你调用的编译器前端后面，动态链接器可能只有在程序启动时才会被注意到，而且可能不会被察觉。
- en: ⁵
  id: totrans-1270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A better keyword for **`static`** in this context would perhaps be **`internal`**,
    with the understanding that any form of linkage implies static storage duration.
  id: totrans-1272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个上下文中，**`static`**可能是一个更好的关键字，即**`internal`**，理解任何形式的链接都意味着静态存储期。
- en: For the first three types of storage duration, we have seen a lot of examples.
    Thread storage duration (**`_Thread_local`** or **`thread_local`**) is related
    to C’s thread API, which we will see later, in [chapter 18](kindle_split_029.html#ch18).
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前三种存储期类型，我们已经看到了很多例子。线程存储期（**`_Thread_local`**或**`thread_local`**）与C的线程API相关，我们将在第18章中看到，届时我们将讨论。
- en: 'Allocated storage duration is straightforward: the lifetime of such an object
    starts from the corresponding call to **malloc**, **calloc**, **realloc**, or
    **aligned_alloc** that creates it. It ends with a call to **free** or **realloc**
    that destroys it, or, if no such call is issued, with the end of the program execution.'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的存储期是直接的：此类对象的生存期从创建它的对应调用**malloc**、**calloc**、**realloc**或**aligned_alloc**开始。它以调用**free**或**realloc**来销毁它结束，或者，如果没有发出此类调用，则以程序执行结束结束。
- en: The two other cases of storage duration need additional explanation, and so
    we will discuss them in more length next.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 存储期的另外两种情况需要额外的解释，因此我们将在下一节中更详细地讨论它们。
- en: 13.2.1\. Static storage duration
  id: totrans-1276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1\. 静态存储期
- en: 'Objects with static storage duration can be defined two ways:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 具有静态存储期的对象可以通过两种方式定义：
- en: Objects that are *defined* in file scope. Variables and compound literals can
    have that property.
  id: totrans-1278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件作用域中**定义**的对象。变量和复合字面量可以具有这种属性。
- en: Variables that are declared inside a function block and that have the storage
    class specifier **`static`**.
  id: totrans-1279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数块内部声明的变量，并且具有存储类指定符**`static`**。
- en: 'Such objects have a lifetime that is the entire program execution. Because
    they are considered alive before any application code is executed, they can only
    be initialized with expressions that are known at compile time or can be resolved
    by the system’s process startup procedure. Here’s an example:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象的生存期是整个程序执行期。因为它们在执行任何应用程序代码之前就被认为是活跃的，所以它们只能用编译时已知的表达式或可以被系统的进程启动程序解析的表达式来初始化。以下是一个例子：
- en: '|  |'
  id: totrans-1281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE111]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|  |'
  id: totrans-1283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This defines four objects of static storage duration, those identified with
    A, p, and B, and a compound literal defined in line 3\. Three of them have type
    **`double`**, and one has type **`double`**`*`.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了四个具有静态存储期的对象，即A、p和B以及第3行定义的复合字面量。其中三个具有**`double`**类型，一个具有**`double`**`*`类型。
- en: All four objects are properly initialized from the start; three of them are
    initialized explicitly, and B is initialized implicitly with `0`.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个对象都是从一开始就正确初始化的；其中三个是显式初始化的，B则是通过`0`隐式初始化。
- en: '|  |'
  id: totrans-1286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.13
  id: totrans-1287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.13
- en: '*Objects with static storage duration are always initialized.*'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有静态存储期的对象始终会被初始化。*'
- en: '|  |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The initialization of p is an example that needs a bit more magic than the compiler
    itself can offer. It uses the address of another object. Such an address can usually
    only be computed when the execution starts. This is why most C implementations
    need the concept of a linker, as we discussed earlier.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: p的初始化是一个需要比编译器本身能提供的更多魔法的例子。它使用了另一个对象的地址。这种地址通常只能在执行开始时计算。这就是为什么大多数C实现需要链接器概念，正如我们之前讨论的那样。
- en: The example of B shows that an object with a lifetime that is the entire program
    execution isn’t necessarily visible in the entire program. The **`extern`** example
    also shows that an object with static storage duration that is defined elsewhere
    can become visible inside a narrow scope.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: B的例子表明，具有整个程序执行生存期的对象不一定在整个程序中都是可见的。**`extern`**例子也表明，在别处定义的具有静态存储期的对象可以在狭窄的作用域内变得可见。
- en: 13.2.2\. Automatic storage duration
  id: totrans-1292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2\. 自动存储期
- en: 'This is the most complicated case: rules for automatic storage duration are
    implicit and therefore need the most explanation. There are several cases of objects
    that can be defined explicitly or implicitly that fall into this category:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最复杂的情况：自动存储期的规则是隐式的，因此需要最多的解释。有几个对象可以显式或隐式地定义，并属于这一类别：
- en: Any block-scope variables that are not declared **`static`**, that are declared
    as **`auto`** (the default) or **`register`**
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何未声明为**`static`**的块作用域变量，声明为**`auto`**（默认）或**`register`**
- en: Block-scope compound literals
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块作用域复合字面量
- en: Some temporary objects that are returned by function calls
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用返回的一些临时对象
- en: The simplest and most current case for the lifetime of automatic objects is
    when the object is not a variable-length array (VLA).
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 自动对象的生存期最简单和最常见的情况是当对象不是可变长度数组（VLA）。
- en: '|  |'
  id: totrans-1298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.14
  id: totrans-1299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.14
- en: '*Unless they are VLA or temporary objects, automatic objects have a lifetime
    corresponding to the execution of their block of definition.*'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非是VLA或临时对象，否则自动对象的生存期与其定义块的执行相对应。*'
- en: '|  |'
  id: totrans-1301
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That is, most local variables are created when program execution enters the
    scope in which they are defined, and they are destroyed when it leaves that scope.
    But, because of recursion, several *instances**^C* of the same object may exist
    at the same time:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 即，大多数局部变量是在程序执行进入它们定义的作用域时创建的，并在离开该作用域时被销毁。但是，由于递归，同一对象的几个*实例**^C*可能同时存在：
- en: '|  |'
  id: totrans-1303
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.15
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.15
- en: '*Each recursive call creates a new local instance of an automatic object.*'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '*每次递归调用都会创建一个自动对象的新的局部实例。*'
- en: '|  |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Objects with automatic storage duration have a big advantage for optimization:
    the compiler usually sees the full usage of such a variable and, with this information,
    is able to decide if it may alias. This is where the difference between the **`auto`**
    and **`register`** variables comes into play:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 具有自动存储期的对象在优化方面有一个很大的优势：编译器通常可以看到此类变量的全部使用情况，并且利用这些信息，能够决定它是否可能产生别名。这就是**`auto`**和**`register`**变量之间的区别所在：
- en: '|  |'
  id: totrans-1308
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.16
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.16
- en: '*The* *`&`* *operator is not allowed for variables declared with* **`register`***.*'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '*不允许对使用* **`register`** *声明的变量使用* *`&`* *运算符。*'
- en: '|  |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'With that, we can’t inadvertently take the address of a **`register`** variable
    ([takeaway 12.12](kindle_split_022.html#ch12note12)). As a simple consequence,
    we get:'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会意外地取**`register`**变量的地址（[摘要 12.12](kindle_split_022.html#ch12note12)）。作为简单后果，我们得到：
- en: '|  |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.17
  id: totrans-1314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.17
- en: '*Variables declared with* **`register`** *can’t alias.*'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **`register`** *声明的变量不能产生别名。*'
- en: '|  |'
  id: totrans-1316
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So, with **`register`** variable declarations, the compiler can be forced to
    tell us where we are taking the address of a variable, so we may identify spots
    that may have some optimization potential. This works well for all variables that
    are not arrays and that contain no arrays.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用**`register`**变量声明，编译器可以被迫告诉我们变量的地址在哪里，这样我们就可以识别可能具有某些优化潜力的地方。这对于所有不是数组且不包含数组的变量都适用。
- en: '|  |'
  id: totrans-1318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.18
  id: totrans-1319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.18
- en: '*Declare local variables that are not arrays in performance-critical code as*
    **`register`***.*'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '*在性能关键代码中将非数组局部变量声明为* **`register`***。'
- en: '|  |'
  id: totrans-1321
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Arrays play a particular role here because they decay to the address of their
    first element in almost all contexts. So, for arrays, we need to be able to take
    addresses.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在这里扮演着特殊角色，因为它们在几乎所有上下文中都会退化到其第一个元素的地址。因此，对于数组，我们需要能够取地址。
- en: '|  |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.19
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 13.19
- en: '*Arrays with storage class* **`register`** *are useless.*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有存储类* **`register`** *的数组是无用的。*'
- en: '|  |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There is another case where the presence of arrays needs special treatment.
    Some return values of functions can really be chimeras: objects with *temporary
    lifetime*. As you know now, functions normally return values and as such values
    are not addressable. But if the return type *contains* an array type, we must
    be able to take the address implicitly, so the `[]` operator is well defined.
    Therefore, the following function return is a temporary object, of which we may
    implicitly take an address by using the member designator .or`y[0]`:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种情况需要特别处理数组的存在。一些函数的返回值确实可以是混合体：具有*临时生存期*的对象。正如你所知，函数通常返回值，而这些值是不可寻址的。但是，如果返回类型*包含*数组类型，我们必须能够隐式地取其地址，因此`[]`运算符是明确定义的。因此，以下函数返回的是一个临时对象，我们可以通过使用成员指定符`.or`y[0]`来隐式地取其地址：
- en: '|  |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE112]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|  |'
  id: totrans-1330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The only reason objects with temporary lifetime exist in C is to be able to
    access members of such a function return value. Don’t use them for anything else.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中存在临时生存期的对象，唯一的原因是为了能够访问此类函数返回值的成员。不要将它们用于其他任何目的。
- en: '|  |'
  id: totrans-1332
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.20
  id: totrans-1333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 13.20
- en: '*Objects of temporary lifetime are read-only.*'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '*临时生存期的对象是只读的*。'
- en: '|  |'
  id: totrans-1335
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1336
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Takeaway 13.21
  id: totrans-1337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要点 13.21
- en: '*Temporary lifetime ends at the end of the enclosing full expression.*'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '*临时生存期在包含表达式的末尾结束*。'
- en: '|  |'
  id: totrans-1339
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That is, their life ends as soon as the evaluation of the expression in which
    they occur is terminated. For example, in the previous example, the temporary
    object ceases to exist as soon as the argument for **printf** is constructed.
    Compare this to the definition of a compound literal: a compound literal would
    live on until the enclosing scope of the **printf** terminates.'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它们的生命在它们所在的表达式的评估结束时结束。例如，在上一个示例中，临时对象在**printf**的参数构造完毕后即不再存在。将此与复合字面量的定义进行比较：复合字面量将一直存在，直到**printf**的包含范围终止。
- en: '13.3\. Digression: using objects "before” their definition'
  id: totrans-1341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3. 脱离主题：在定义之前使用对象
- en: The following chapter goes into more detail about how automatic objects spring
    to life (or not). It is a bit tough, so if you are not up to it right now, you
    might skip it and come back to it later. It will be needed in order to understand
    [section 13.5](#ch13lev1sec5) about concrete machine models, but that section
    is a digression, too. Also, it introduces the new features **`goto`** and labels,
    which we need later, in [section 14.5](kindle_split_024.html#ch14lev1sec5) for
    handling errors.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将更详细地介绍自动对象是如何产生生命（或不是）的。这有点难，所以如果你现在不想处理，你可以跳过它，稍后再回来。为了理解[第 13.5 节](#ch13lev1sec5)关于具体机器模型的内容，这是必需的，但那一节也是一个脱离主题的部分。此外，它引入了新的特性**`goto`**和标签，我们稍后在[第
    14.5 节](kindle_split_024.html#ch14lev1sec5)处理错误时需要它们。
- en: 'Let us get back to the rule for the lifetime of ordinary automatic objects
    ([takeaway 13.14](#ch13note16)). It is quite particular, if you think about it:
    the lifetime of such an object starts when its scope of definition is entered,
    not, as one would perhaps expect, later, when its definition is first encountered
    during execution.'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到普通自动对象生存期的规则（[要点 13.14](#ch13note16)）。如果你仔细想想，这个规则相当特别：此类对象的生存期从其定义范围开始，而不是像人们可能预期的那样，在其定义在执行过程中首次遇到时开始。
- en: To note the difference, let us look at [listing 13.3](#ch13ex12), which is a
    variant of an example that can be found in the C standard document.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明区别，让我们看看[列表 13.3](#ch13ex12)，这是C标准文档中可以找到的一个示例的变体。
- en: Listing 13.3\. A contrived example for the use of a compound literal
  id: totrans-1345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3. 使用复合字面量的一个人为示例
- en: '[PRE113]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We will be particularly interested in the lines printed if this function is
    called as fgot`o(2)`. On my computer, the output looks like this:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数以fgot`o(2)的形式被调用，我们将特别关注打印的行。在我的计算机上，输出看起来像这样：
- en: '`Terminal`'
  id: totrans-1348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`终端`'
- en: '[PRE114]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Admittedly, this code is a bit contrived. It uses a new construct that we haven’t
    yet seen in action, **`goto`**. As the name indicates, this is a *jump statement**^C*.
    In this case, it instructs the computer to continue execution at *label**^C* **`AGAIN`**.
    Later, we will see contexts where using **`goto`** makes a bit more sense. The
    demonstrative purpose here is just to jump over the definition of the compound
    literal.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码有点人为，它使用了我们尚未见过的构造**`goto`**。正如其名所示，这是一个*跳转语句**^C*。在这种情况下，它指示计算机在*标签**^C*
    **`AGAIN`**处继续执行。稍后，我们将看到使用**`goto`**更有意义的上下文。这里演示的目的只是跳过复合字面量的定义。
- en: So, let us look at what happens with the **printf** call during execution. For
    n `== 2`, execution meets the corresponding line three times; but because p is
    `0` initially, at the first passage, the **printf** call itself is skipped. The
    values of our three variables in that line are
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看执行期间**printf**调用发生了什么。对于n `== 2`，执行遇到相应的行三次；但由于p最初为`0`，在第一次通过时，**printf**调用本身被跳过。该行我们三个变量的值是
- en: '| j | p | q | **printf** |'
  id: totrans-1352
  prefs: []
  type: TYPE_TB
  zh: '| j | p | q | **printf** |'
- en: '| 0 | 0 | Undetermined | Skipped |'
  id: totrans-1353
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 未确定 | 跳过 |'
- en: '| 1 | Addr of literal of *j* = 0 | 0 | printed |'
  id: totrans-1354
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Addr of literal of *j* = 0 | 0 | printed |'
- en: '| 2 | Addr of literal of *j* = 1 | Addr of literal of *j* = 0 | printed |'
  id: totrans-1355
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Addr of literal of *j* = 1 | Addr of literal of *j* = 0 | printed |'
- en: Here we see that for `j==2` pointers, p and q hold addresses that are obtained
    at different iterations. So why, then, does my printout say that both addresses
    are equal? Is this just a coincidence? Or is there undefined behavior because
    I am using the compound literal lexically at a place before it is defined?
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到对于`j==2`的指针，p和q持有在不同迭代中获得的地址。那么，为什么我的打印输出会说这两个地址都相等呢？这是巧合吗？还是因为我使用复合字面量在定义之前的地方，所以这是未定义的行为？
- en: The C standard prescribes that the output shown here *must* be produced. In
    particular, for j`==2`, the values of p and q are equal and valid, and the value
    of the object they are pointing to is `1`. Or, stated another way, in this example,
    the use of `*`p is well defined, although lexically the evaluation of `*`p precedes
    the definition of the object. Also, there is exactly one such compound literal,
    and therefore the addresses are equal for `j==2`.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: C标准规定，这里显示的输出*必须*被生成。特别是，对于j`==2`，p和q的值相等且有效，它们所指向的对象的值为`1`。或者，换一种说法，在这个例子中，`*p`的使用是明确定义的，尽管在词法上`*p`的评估先于对象的定义。此外，恰好有一个这样的复合字面量，因此当j`==2`时，地址是相等的。
- en: '|  |'
  id: totrans-1358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.22
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.22
- en: '*For an object that is not a VLA, lifetime starts when the scope of the definition
    is entered, and it ends when that scope is left.*'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于不是VLA的对象，其生命周期从定义的作用域进入开始，到离开该作用域结束。*'
- en: '|  |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.23
  id: totrans-1363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.23
- en: '*Initializers of automatic variables and compound literals are evaluated each
    time the definition is met.*'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动变量和复合字面量的初始化器在每次遇到定义时都会被评估。*'
- en: '|  |'
  id: totrans-1365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this example, the compound literal is visited three times and set to the
    values `0`, `1`, and `2` in turn.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，复合字面量被访问了三次，并依次设置为`0`、`1`和`2`的值。
- en: For a VLA, the lifetime is given by a different rule.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VLA，其生命周期由不同的规则给出。
- en: '|  |'
  id: totrans-1368
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.24
  id: totrans-1369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.24
- en: '*For a VLA, lifetime starts when the definition is encountered and ends when
    the visibility scope is left.*'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于可变长度数组（VLA），其生命周期从遇到定义开始，到离开可见作用域结束。*'
- en: '|  |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'So for a VLA, our strange trick of using **`goto`** would not be valid: we
    are not allowed to use the pointer to a VLA in code that precedes the definition,
    even if we still are inside the same block. The reason for this special treatment
    of VLAs is that their size is a runtime property and therefore the space for it
    simply can’t be allocated when the block of the declaration is entered.'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于VLA，我们使用**`goto`**的奇怪技巧是不合法的：我们不允许在定义之前的代码中使用VLA的指针，即使我们仍然在同一个块内。这种特殊处理VLA的原因是它们的大小是运行时属性，因此当进入声明块时，为其分配空间是不可能的。
- en: 13.4\. Initialization
  id: totrans-1373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 初始化
- en: In [section 5.5](kindle_split_013.html#ch05lev1sec5), we discussed the importance
    of initialization. It is crucial to guarantee that a program starts in a well-defined
    state and stays so throughout execution. The storage duration of an object determines
    how it is initialized.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5.5节](kindle_split_013.html#ch05lev1sec5)中，我们讨论了初始化的重要性。确保程序从一个良好定义的状态开始，并在整个执行过程中保持这种状态是至关重要的。对象的存储持续时间决定了它是如何初始化的。
- en: '|  |'
  id: totrans-1375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.25
  id: totrans-1376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.25
- en: '*Objects of static or thread-storage duration are initialized by default.*'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态或线程存储持续期的对象默认进行初始化。*'
- en: '|  |'
  id: totrans-1378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As you probably recall, such a default initialization is the same as initializing
    all members of an object by `0`. In particular, default initialization works well
    for base types that might have a nontrivial representation for their `0` value:
    namely pointers and floating point types.'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，这种默认初始化与通过`0`初始化对象的全部成员相同。特别是，对于可能有非平凡`0`值表示的基础类型，默认初始化效果很好：即指针和浮点类型。
- en: For other objects, automatic or allocated, we must do something.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他对象，无论是自动的还是分配的，我们必须做些事情。
- en: '|  |'
  id: totrans-1381
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.26
  id: totrans-1382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 13.26
- en: '*Objects of automatic or allocated storage duration must be initialized explicitly.*'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动或分配存储期的对象必须显式初始化。*'
- en: '|  |'
  id: totrans-1384
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The simplest way to achieve initialization are initializers, which put variables
    and compound literals in a well-defined state as soon as they become visible.
    For arrays that we allocate as VLA, or through dynamic allocation, this is not
    possible, so we have to provide initialization through assignment. In principle,
    we could do this manually each time we allocate such an object, but such code
    becomes difficult to read and to maintain, because the initialization parts may
    visually separate definition and use. The easiest way to avoid this is to encapsulate
    initialization into functions:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 实现初始化的最简单方法是初始化器，它们将变量和复合字面量置于定义良好的状态，一旦它们变得可见。对于作为 VLA 或通过动态分配分配的数组，这是不可能的，因此我们必须通过赋值来提供初始化。原则上，我们可以在每次分配这样的对象时手动执行此操作，但这样的代码难以阅读和维护，因为初始化部分可能在视觉上分离定义和使用。避免这种情况的最简单方法是封装初始化到函数中：
- en: '|  |'
  id: totrans-1386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 13.27
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取代 13.27
- en: '*Systematically provide an initialization function for each of your data types.*'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统地为你的每个数据类型提供一个初始化函数。*'
- en: '|  |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Here, the emphasis is on *systematically*: you should have a consistent convention
    for how such initializing functions should work and how they should be named.
    To see that, let us go back to rat_init, the initialization function for our rat
    data type. It implements a specific API for such functions:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，重点是 *系统地*：你应该有一个一致的约定来规定这些初始化函数应该如何工作以及它们应该如何命名。为了说明这一点，让我们回到 `rat_init`，这是我们的
    rat 数据类型的初始化函数。它实现了这样的函数的特定 API：
- en: For a type toto, the initialization function is named toto_init.
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于类型 `toto`，初始化函数命名为 `toto_init`。
- en: The first argument to such a _init function is the pointer to the object that
    is to be initialized.
  id: totrans-1392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的 `_init` 函数的第一个参数是要初始化的对象的指针。
- en: If that pointer to object is null, the function does nothing.
  id: totrans-1393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该对象的指针为空，函数不执行任何操作。
- en: Other arguments can be provided to pass initial values for certain members.
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以提供其他参数来传递某些成员的初始值。
- en: The function returns the pointer to the object it received or `0` if an error
    occurred.
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回它接收到的对象的指针或 `0` 如果发生错误。
- en: 'With such properties, such a function can be used easily in an initializer
    for a pointer:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这些属性，这样的函数可以很容易地用于指针的初始化器：
- en: '[PRE115]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Observe that this has several advantages:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这有几个优点：
- en: If the call to **malloc** fails by returning `0`, the only effect is that myRat
    is initialized to `0`. Thus myRat is always in a well-defined state.
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 **malloc** 调用失败并返回 `0`，唯一的影响是 myRat 被初始化为 `0`。因此 myRat 总是处于一个定义良好的状态。
- en: If we don’t want the object to be changed afterward, we can qualify the pointer
    target as **`const`** from the start. All modification of the new object happens
    inside the initialization expression on the right side.
  id: totrans-1400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不希望对象之后被修改，我们可以从开始就将指针目标指定为 **`const`**。所有对新对象的修改都发生在右侧初始化表达式中。
- en: 'Since such initialization can then appear in many places, we can also encapsulate
    this into another function:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这样的初始化可以出现在许多地方，我们也可以将其封装到另一个函数中：
- en: '[PRE116]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The initialization using that function becomes
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该函数的初始化方式如下
- en: '[PRE117]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Macro addicts like myself can even easily define a type-generic macro that
    does such an encapsulation once and for all:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 宏爱好者像我一样甚至可以轻松定义一个类型通用的宏，它可以一次性完成这样的封装：
- en: '[PRE118]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: With this, we could have written the earlier initialization as
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以将之前的初始化写成
- en: '[PRE119]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This has the advantage of being at least as readable as the rat_new variant,
    but it avoids the additional declaration of such a function for all types that
    we define.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 这的好处是至少与 rat_new 变体一样可读，但它避免了为所有我们定义的类型额外声明这样的函数。
- en: 'Such macro definitions are frowned upon by many, so some projects probably
    will not accept this as a general strategy, but you should at least be aware that
    the possibility exists. It uses two features of macros that we have not yet encountered:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人都对这样的宏定义持批评态度，因此一些项目可能不会接受这作为一个通用的策略，但你应该至少知道这种可能性存在。它使用了我们尚未遇到的两个宏特性：
- en: 'Concatenation of tokens is achieved with the **`##`** operator. Here, T **`##`**
    _init melds the argument T and _init into one token: with rat, this produces rat_init;
    with toto, this produces toto_init.'
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌的连接是通过 **`##`** 运算符实现的。在这里，T **`##`** _init 将 T 和 _init 合并成一个令牌：使用 rat，这会产生
    rat_init；使用 toto，这会产生 toto_init。
- en: The construct `...` provides an argument list of variable length. The whole
    set of arguments that is passed after the first is accessible inside the macro
    expansion as **`__VA_ARGS__`**. That way, we can pass any number of arguments
    as required by the corresponding _init function to P99_NEW.
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造 `...` 提供了一个可变长度的参数列表。在宏展开内部，传递给第一个参数之后的整个参数集都可以通过 **`__VA_ARGS__`** 访问。这样，我们可以根据对应
    _init 函数的要求传递任意数量的参数给 P99_NEW。
- en: 'If we have to initialize arrays by means of a **`for`** loop, things get even
    uglier. Here also it is easy to encapsulate with a function:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须通过一个 **`for`** 循环来初始化数组，事情会变得更糟。在这里，也很容易通过函数来封装：
- en: '[PRE120]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'With such a function, again, initialization becomes straightforward:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的函数，初始化再次变得简单：
- en: '[PRE121]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here, encapsulation into a function is really better, since repeating the size
    may easily introduce errors:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将封装到函数中确实更好，因为重复大小很容易引入错误：
- en: '[PRE122]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '13.5\. Digression: a machine model'
  id: totrans-1419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 旁白：机器模型
- en: 'Up to now, we mostly argued about C code from within, using the internal logic
    of the language to describe what was going on. This chapter is an optional digression
    that deviates from that: it is a glimpse into the machine model of a concrete
    architecture. We will see more in detail how a simple function is translated into
    this model and, in particular, how automatic storage duration is realized. If
    you really can’t bear it yet, you may skip it for now. Otherwise, remember not
    to panic, and dive in.'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要是在内部讨论C代码，使用语言的内部逻辑来描述正在发生的事情。本章是一个可选的旁白，与之前的讨论有所不同：它是对一个具体架构的机器模型的窥视。我们将更详细地看到，一个简单的函数是如何被转换成这个模型的，特别是自动存储持续时间是如何实现的。如果你现在实在无法忍受，你可以先跳过这一部分。否则，请记住不要慌张，深入其中。
- en: Traditionally, computer architectures were described with the von Neumann model.^([[6](#ch13fn06)])
    In this model, a processing unit has a finite number of hardware *registers* that
    can hold integer values, a *main memory* that holds the program as well as data
    and that is linearly addressable, and a finite *instruction set* that describes
    the operations that can be done with these components.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，计算机架构是用冯·诺伊曼模型描述的.^([[6](#ch13fn06)]) 在这个模型中，处理单元具有有限数量的硬件 *寄存器*，可以存储整数值，一个
    *主存储器*，它存储程序以及数据，并且是线性可寻址的，以及一个有限的 *指令集*，它描述了可以使用这些组件执行的操作。
- en: ⁶
  id: totrans-1422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶
- en: ''
  id: totrans-1423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Invented around 1945 by J. Presper Eckert and John William Mauchly for the ENIAC
    project; first described by John von Neumann (1903 – 1957, also known as Neumann
    János Lajos and Johann Neumann von Margitta), one of the pioneers of modern science,
    in von Neumann [[1945](kindle_split_036.html#bib20)].
  id: totrans-1424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大约在1945年由J. Presper Eckert和John William Mauchly为ENIAC项目发明；首先由现代科学的先驱之一John von
    Neumann（1903 – 1957，也被称为Neumann János Lajos和Johann Neumann von Margitta）描述，他在von
    Neumann [[1945](kindle_split_036.html#bib20)]。
- en: 'The intermediate programming languages that are usually used to describe machine
    instructions as they are understood by your CPU are called *assembler**^C*, and
    they still pretty much build upon the von Neumann model. There is not one unique
    assembler language (like C, which is valid for all platforms) but an entire set
    of *dialects* that take different particularities into account: of the CPU, the
    compiler, or the operating system. The assembler that we use here is the one used
    by the `gcc` compiler for the `x86_64` processor architecture.^([[[Exs 5]](#ch13fn-ex05)])
    If you don’t know what that means, don’t worry; this is just an example of one
    such architecture.'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用来描述CPU理解的机器指令的中间编程语言被称为 *汇编器**^C*，它们仍然在很大程度上基于冯·诺伊曼模型。没有一种唯一的汇编器语言（如C，适用于所有平台），而是一整套
    *方言*，它们考虑了不同的特定性：CPU、编译器或操作系统。我们这里使用的汇编器是 `gcc` 编译器用于 `x86_64` 处理器架构的汇编器.^([[[Exs
    5]](#ch13fn-ex05)]) 如果你不知道这是什么意思，不要担心；这只是一个此类架构的例子。
- en: ^([Exs 5])
  id: totrans-1426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 5])
- en: ''
  id: totrans-1427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find out which compiler arguments produce assembler output for your platform.
  id: totrans-1428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查找哪些编译器参数可以为你平台的平台生成汇编输出。
- en: '[Listing 13.4](#ch13ex14) shows an assembler printout for the function fgoto
    from [listing 13.3](#ch13ex12). Such assembler code operates with *instructions**^C*
    on hardware registers and memory locations. For example, the line **`movl $`**`0,
    -16(`**`%`****`rbp`**`)` stores (*moves*) the value `0` to the location in memory
    that is `16` bytes below the one indicated by register **`%`****`rbp`**. The assembler
    program also contains *labels**^C* that identify certain points in the program.
    For example, **`fgoto`** is the *entry point**^C* of the function, and **`.L_AGAIN`**
    is the counterpart in assembler to the **`goto`** label **`AGAIN`** in C.'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 13.4](#ch13ex14) 展示了函数 fgoto 从 [清单 13.3](#ch13ex12) 的汇编打印输出。这样的汇编代码在硬件寄存器和内存位置上操作
    *指令**^C*。例如，行 **`movl $`**`0, -16(`**`%`****`rbp`**`)` 将值 `0` 存储到内存中，该内存位置位于寄存器
    **`%`****`rbp`** 指示的位置下方 `16` 个字节处。汇编程序还包含 *标签**^C*，用于标识程序中的某些点。例如，**`fgoto`**
    是函数的 *入口点**^C*，而 **`.L_AGAIN`** 是汇编中对应于 C 中的 **`goto`** 标签 **`AGAIN`** 的对应物。'
- en: As you probably have guessed, the text on the right after the **`#`** character
    are comments that try to link individual assembler instructions to their C counterparts.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，在 **`#`** 字符之后的文本是注释，试图将单个汇编指令与其 C 对应物联系起来。
- en: Listing 13.4\. An assembler version of the **`fgoto`** function
  id: totrans-1431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 13.4\. **`fgoto`** 函数的汇编版本
- en: '[PRE123]'
  id: totrans-1432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This assembler function uses hardware registers **`%eax`**, **`%ecx`**, **`%edi`**
    **`%edx`**, **`%esi`**, **`%rax`**, **`%rbp`**, **`%`****`rcx`**, **`%rdx`**,
    and **`%rsp`**. This is much more than the original von Neumann machine had, but
    the main ideas are still present: we have some general-purpose registers that
    are used to represent values of the state of a program’s execution. Two others
    have very special roles: **`%rbp`** (base pointer) and **`%rsp`** (stack pointer).'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编函数使用了硬件寄存器 **`%eax`**, **`%ecx`**, **`%edi`**, **`%edx`**, **`%esi`**, **`%rax`**,
    **`%rbp`**, **`%rcx`**, **`%rdx`** 和 **`%rsp`**。这比原始的冯·诺依曼机器要多得多，但主要思想仍然存在：我们有一些通用寄存器，用于表示程序执行状态的价值。另外两个寄存器有非常特殊的作用：**`%rbp`**（基指针）和**`%rsp`**（栈指针）。
- en: The function disposes of a reserved area in memory, often called *The Stack**^C*,
    that holds its local variables and compound literals. The “upper” end of that
    area is designated by the **`%rbp`** register, and the objects are accessed with
    negative offsets relative to that register. For example, the variable n is found
    from position `-36` before **`%rbp`** encoded as `-36(`**`%`****`rbp`**`)`. The
    following table represents the layout of this memory chunk that is reserved for
    function **`fgoto`** and the values that are stored there at three different points
    of the execution of the function.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 函数处理内存中的一个预留区域，通常称为 *栈**^C*，该区域用于存储其局部变量和复合字面量。该区域的“上部”由 **`%rbp`** 寄存器指定，对象通过相对于该寄存器的负偏移来访问。例如，变量
    n 可以从 **`%rbp`** 之前 `-36` 个位置找到，编码为 `-36(`**`%`****`rbp`**`)`。以下表格表示为函数 **`fgoto`**
    预留的内存块布局以及在该函数执行的不同点存储的值。
- en: '![](pg227_01_alt.jpg)'
  id: totrans-1435
  prefs: []
  type: TYPE_IMG
  zh: '![](pg227_01_alt.jpg)'
- en: 'This example is of particular interest for learning about automatic variables
    and how they are set up when execution enters the function. On this particular
    machine, when entering **`fgoto`**, three registers hold information for this
    call: **`%edi`** holds the function argument, n; **`%`****`rbp`** points to the
    base address of the calling function; and **`%rsp`** points to the top address
    in memory where this call to **`fgoto`** may store its data.'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子特别有趣，可以用来学习自动变量以及它们在执行进入函数时是如何设置的。在这个特定的机器上，当进入 **`fgoto`** 时，有三个寄存器持有关于这个调用的信息：**`%edi`**
    持有函数参数 n；**`%`****`rbp`** 指向调用函数的基地址；**`%rsp`** 指向内存中这个对 **`fgoto`** 的调用可能存储数据的位置顶部。
- en: Now let us consider how the above assembler code ([listing 13.4](#ch13ex14))
    sets up things. Right at the start, **`fgoto`** executes three instructions to
    set up its “world” correctly. It saves **`%rbp`** because it needs this register
    for its own purpose, it moves the value from **`%rsp`** to **`%rbp`**, and then
    it decrements **`%rsp`** by `48`. Here, `48` is the number of bytes the compiler
    has computed for all automatic objects that the **`fgoto`** needs. Because of
    this simple type of setup, the space reserved by that procedure is not initialized
    but filled with garbage. In the three following instructions, three of the automatic
    objects are then initialized (n, j, and p), but others remain uninitialized until
    later.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑上述汇编代码 ([清单 13.4](#ch13ex14)) 如何设置这些内容。一开始，**`fgoto`** 执行三条指令来正确设置其“世界”。它保存
    **`%rbp`** 因为它需要这个寄存器用于自己的目的，然后将 **`%rsp`** 的值移动到 **`%rbp`**，然后减少 **`%rsp`** 的
    `48`。在这里，`48` 是编译器为 **`fgoto`** 需要的所有自动对象计算的字节数。由于这种简单的设置类型，该过程保留的空间未初始化，而是填充了垃圾数据。在接下来的三条指令中，三个自动对象（n、j
    和 p）被初始化，但其他对象直到后来才初始化。
- en: 'After this setup, the function is ready to go. In particular, it can easily
    call another function: **`%`****`rsp`** now points to the top of a new memory
    area that a called function can use. This can be seen in the middle part, after
    the label .L_NO. This part implements the call to **printf**: it stores the four
    arguments the function is supposed to receive in registers **`%edi`**, **`%esi`**,
    **`%ecx`**, **`%`****`rdx`**, in that order; clears **`%eax`**; and then calls
    the function.'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置完成后，函数就绪可以运行。特别是，它可以轻松调用另一个函数：**`%`****`rsp`** 现在指向一个新内存区域的顶部，被调用的函数可以使用这个区域。这可以在标签
    .L_NO 的中间部分看到。这部分实现了对 **printf** 的调用：它将函数应接收的四个参数按顺序存储在寄存器 **`%edi`**、**`%esi`**、**`%ecx`**、**`%`****`rdx`**
    中；清除 **`%eax`**；然后调用该函数。
- en: To summarize, the setup of a memory area for the automatic objects (without
    VLA) of a function only needs a few instructions, regardless of how many automatic
    objects are effectively used by the function. If the function had more, the magic
    number `48` would need to be modified to the new size of the area.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，为函数的自动对象（无 VLA）设置内存区域（无需 VLA）只需要几条指令，无论函数实际使用了多少自动对象。如果函数有更多，则需要将魔法数字 `48`
    修改为新区域的大小。
- en: As a consequence of the way this is done,
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方式，产生了以下后果，
- en: Automatic objects are usually available from the start of a function or scope.
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动对象通常从函数或作用域的开始就可用。
- en: Initialization of automatic *variables* is not enforced.
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动变量的初始化不是强制的。
- en: This does a good job of mapping the rules for the lifetime and initialization
    of automatic objects in C.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地映射了 C 中自动对象的生存期和初始化规则。
- en: The earlier assembler output is only half the story, at most. It was produced
    without optimization, just to show the principle assumptions that can be made
    for such code generation. When using optimization, the as-if Rule ([takeaway 5.8](kindle_split_013.html#ch05note08))
    allows us to reorganize the code substantially. With full optimization, my compiler
    produces something like [listing 13.5](#ch13ex15).
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的汇编器输出只是故事的一半，最多。它是在没有优化的情况下产生的，只是为了展示可以为此类代码生成做出的基本假设。当使用优化时，as-if 规则 ([takeaway
    5.8](kindle_split_013.html#ch05note08)) 允许我们大幅度地重新组织代码。在完全优化的情况下，我的编译器产生的代码类似于
    [清单 13.5](#ch13ex15)。
- en: Listing 13.5\. An optimized assembler version of the **`fgoto`** function
  id: totrans-1445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 13.5\. **`fgoto`** 函数的优化汇编版本
- en: '[PRE124]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'As you can see, the compiler has completely restructured the code. This code
    just reproduces the *effects* that the original code had: its output is the same
    as before. But it doesn’t use objects in memory, doesn’t compare pointers for
    equality, and has no trace of the compound literal. For example, it doesn’t implement
    the iteration for `j=0` at all. This iteration has no effect, so it is simply
    omitted. Then, for the other iterations, it distinguishes a version with `j=1`,
    where the pointers p and q of the C program are known to be different. Then, the
    general case has to increment j and to set up the arguments for **printf** accordingly.^([[[Exs
    6]](#ch13fn-ex06)])^([[[Exs 7]](#ch13fn-ex07)])'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编译器已经完全重构了代码。这段代码只是重现了原始代码的效果：其输出与之前相同。但它不使用内存中的对象，不比较指针是否相等，并且没有复合字面量的痕迹。例如，它根本不实现
    `j=0` 的迭代。这个迭代没有效果，所以它被简单地省略了。然后，对于其他迭代，它区分了一个 `j=1` 的版本，其中 C 程序中的指针 p 和 q 被认为是不同的。然后，对于一般情况，需要增加
    j 并相应地设置 **printf** 的参数.^([[[Exs 6]](#ch13fn-ex06)])^([[[Exs 7]](#ch13fn-ex07)])
- en: ^([Exs 6])
  id: totrans-1448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 6])
- en: ''
  id: totrans-1449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the fact that p is assigned the same value over and over again, write
    a C program that gets closer to what the optimized assembler version looks like.
  id: totrans-1450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 利用p被反复赋以相同值的这一事实，编写一个C程序，使其更接近优化汇编版本的模样。
- en: ^([Exs 7])
  id: totrans-1451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 7])
- en: ''
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even the optimized version leaves room for improvement: the inner part of the
    loop can still be shortened. Write a C program that explores this potential when
    compiled with full optimization.'
  id: totrans-1453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使是优化版本也还有改进的空间：循环的内部部分仍然可以缩短。编写一个C程序，在完全优化编译时探索这种潜力。
- en: All we have seen here is code that doesn’t use VLA. These change the picture,
    because the trick that simply modifies **`%rsp`** with a constant doesn’t work
    if the needed memory is not a constant size. For a VLA, the program has to compute
    the size during execution from the actual values of the bounds of the VLA, has
    to adjust **`%rsp`** accordingly there, and then it has to undo that modification
    of **`%rsp`** once execution leaves the scope of the definition of the VLA. So
    here the value of adjustment for **`%rsp`** cannot be computed at compile time,
    but must be determined during the execution of the program.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们所看到的代码都没有使用可变长度数组（VLA）。这些代码改变了情况，因为仅仅通过常数来修改**`%rsp`**的技巧在需要的内存不是固定大小时就不起作用了。对于VLA，程序必须在执行期间从VLA边界的实际值计算大小，相应地调整**`%rsp`**，然后一旦执行离开VLA定义的作用域，就必须撤销对**`%rsp`**的修改。因此，这里**`%rsp`**调整的值不能在编译时计算，而必须在程序执行期间确定。
- en: Summary
  id: totrans-1455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Storage for a large number of objects or for objects that are large in size
    can be allocated and freed dynamically. We have to keep track of this storage
    carefully.
  id: totrans-1456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大量对象或大尺寸对象的存储可以动态分配和释放。我们必须仔细跟踪这种存储。
- en: Identifier visibility and storage duration are different things.
  id: totrans-1457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符可见性和存储持续时间是不同的事情。
- en: Initialization must be done systematically with a coherent strategy for each
    type.
  id: totrans-1458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化必须对每种类型系统地使用一致的策略。
- en: C’s allocation strategy for local variables maps well to low-level handling
    of function stacks.
  id: totrans-1459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C为局部变量分配的策略很好地映射到函数栈的低级处理。
- en: Chapter 14\. More involved processing and IO
  id: totrans-1460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章. 更复杂的处理和IO
- en: This chapter covers
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with pointers
  id: totrans-1462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针
- en: Formatting input
  id: totrans-1463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化输入
- en: Handling extended character sets
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理扩展字符集
- en: Input and output with binary streams
  id: totrans-1465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制流进行输入和输出
- en: Checking errors and cleaning up
  id: totrans-1466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查错误和清理
- en: Now that we know about pointers and how they work, we will shed new light on
    some of the C library features. Cs text processing is incomplete without using
    pointers, so we will start this chapter with an elaborated example in [section
    14.1](#ch14lev1sec1). Then we will look at functions for formatted input ([section
    14.1](#ch14lev1sec1)); these require pointers as arguments, so we had to delay
    their presentation until now. A whole new series of functions is then presented
    to handle extended character sets ([section 14.3](#ch14lev1sec3)) and binary streams
    ([section 14.4](#ch14lev1sec4)), and we round out this chapter and the entire
    level with a discussion of clean error handling ([section 14.4](#ch14lev1sec4))).
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了指针及其工作原理，我们将对C库的一些特性进行新的探讨。C的文本处理如果不使用指针就不完整，因此我们将从[第14.1节](#ch14lev1sec1)的一个详细示例开始本章。然后我们将查看格式化输入的函数([第14.1节](#ch14lev1sec1))；这些函数需要指针作为参数，因此我们不得不推迟它们的介绍直到现在。然后我们将介绍一系列新函数来处理扩展字符集([第14.3节](#ch14lev1sec3))和二进制流([第14.4节](#ch14lev1sec4))，最后我们通过讨论干净的错误处理([第14.4节](#ch14lev1sec4))来结束本章和整个级别的讨论。
- en: 14.1\. Text processing
  id: totrans-1468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1. 文本处理
- en: 'As a first example, consider the following program, which that reads a series
    of lines with numbers from **`stdin`** and writes these same numbers in a normalized
    way to **`stdout`** as comma-separated hexadecimal numbers:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，考虑以下程序，它从**`stdin`**读取一系列带有数字的行，并以逗号分隔的十六进制数的形式将这些相同的数字以规范化的方式写入**`stdout`**：
- en: '**`numberline.c`**'
  id: totrans-1470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE125]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This program splits the job in three different tasks:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将任务分为三个不同的任务：
- en: fgetline to read a line of text
  id: totrans-1473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fgetline 读取一行文本
- en: numberline to split such a line in a series of numbers of type **`size_t`**
  id: totrans-1474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: numberline 将此类行分割成一系列**`size_t`**类型的数字
- en: fprintnumbers to print them
  id: totrans-1475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fprintnumbers 来打印它们
- en: 'At the heart is the function numberline. It splits the lbuf string that it
    receives into numbers, allocates an array to store them, and also returns the
    count of these numbers through the pointer argument np if that is provided:'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 核心是numberline函数。它将接收到的lbuf字符串分割成数字，分配一个数组来存储它们，并且如果提供了指针参数np，还通过np返回这些数字的计数：
- en: '|  |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`numberline.c`**'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: 'numberline: interpret string *lbuf* as a sequence of numbers represented with
    *base*'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 'numberline: 将字符串*lbuf*解释为用*base*表示的数字序列'
- en: '**Returns**: a newly allocated array of numbers as found in *lbuf*'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：一个新分配的包含在*lbuf*中找到的数字的数组'
- en: '**Parameters**:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**:'
- en: '| lbuf | is supposed to be a string |'
  id: totrans-1482
  prefs: []
  type: TYPE_TB
  zh: '| lbuf | 应该是一个字符串 |'
- en: '| np | if non-null, the count of numbers is stored in *np |'
  id: totrans-1483
  prefs: []
  type: TYPE_TB
  zh: '| np | 如果非空，则将数字的计数存储在*np|中'
- en: '| base | value from 0 to 36, with the same interpretation as for **strtoul**
    |'
  id: totrans-1484
  prefs: []
  type: TYPE_TB
  zh: '| base | 从0到36的值，与**strtoul**相同的解释 |'
- en: '**Remarks**: The caller of this function is responsible to **free** the array
    that is returned.'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**：调用此函数的调用者负责**释放**返回的数组。'
- en: '[PRE126]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '|  |'
  id: totrans-1487
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That function itself is split into two parts, which perform quite different
    tasks. One performs the task of interpreting the line, numberline_inner. The other,
    numberline itself, is just a wrapper around the first that verifies or ensures
    the prerequisites for the first. Function numberline_inner puts the C library
    function **strtoull** in a loop that collects the numbers and returns a count
    of them.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数本身分为两部分，执行完全不同的任务。一个执行解析行的任务，即numberline_inner。另一个，numberline本身，只是第一个的包装，用于验证或确保第一个的前提条件。numberline_inner函数将C库函数**strtoull**放入一个循环中，该循环收集数字并返回它们的计数。
- en: 'Now we see the use of the second parameter of **strtoull**. Here, it is the
    address of the variable next, and next is used to keep track of the position in
    the string that ends the number. Since next is a pointer to **`char`**, the argument
    to **strtoull** is a pointer to a pointer to **`char`**:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看**strtoull**函数第二个参数的用法。在这里，它是下一个变量的地址，而next用于跟踪数字结束的字符串中的位置。由于next是一个指向**`char`**的指针，因此**strtoull**的参数是一个指向指向**`char`**的指针的指针：
- en: '**`numberline.c`**'
  id: totrans-1490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE127]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Suppose **strtoull** is called as **strtoull**("0789a"`, &`next, base`)`. According
    to the value of the parameter base, that string is interpreted differently. If,
    for example, base has the value `10`, the first non-digit is the character ''a''
    at the end:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 假设**strtoull**被调用为**strtoull**("0789a", &next, base**)。根据参数base的值，该字符串被解释为不同。例如，如果base的值为`10`，则第一个非数字字符是字符串末尾的字符'a'：
- en: '| Base | Digits | Number | *next |'
  id: totrans-1493
  prefs: []
  type: TYPE_TB
  zh: '| Base | 数字 | 数字 | *next |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1494
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 8 | 2 | 7 | ''8'' |'
  id: totrans-1495
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 | 7 | ''8'' |'
- en: '| 10 | 4 | 789 | ''a'' |'
  id: totrans-1496
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 4 | 789 | ''a'' |'
- en: '| 16 | 5 | 30874 | ''\0'' |'
  id: totrans-1497
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 5 | 30874 | ''\0'' |'
- en: '| 0 | 2 | 7 | ''8'' |'
  id: totrans-1498
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2 | 7 | ''8'' |'
- en: 'Remember the special rules for base `0`. The effective base is deduced from
    the first (or first two) characters in the string. Here, the first character is
    a ''0'', so the string is interpreted as being octal, and parsing stops at the
    first non-digit for that base: ''8''.'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 记住基数`0`的特殊规则。有效基数是从字符串中的第一个（或前两个）字符中推断出来的。在这里，第一个字符是'0'，因此字符串被解释为八进制，解析在第一个非数字字符处停止：'8'。
- en: 'There are two conditions that may end the parsing of the line that numberline_inner
    receives:'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: numberline_inner接收到的行可能有两个条件会导致解析结束：
- en: 'act points to a string termination: to a `0` character.'
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: act指向一个字符串终止符：一个`0`字符。
- en: Function **strtoull** doesn’t find a number, in which case next is set to the
    value of act.
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数**strtoull**找不到数字，在这种情况下，next被设置为act的值。
- en: These two conditions are found as the controlling expression of the **`for`**
    loop and as **`if-break`** condition inside.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个条件作为**`for`**循环的控制表达式和内部**`if-break`**条件被发现。
- en: '![](comm.jpg)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: 'Note that the C library function **strtoull** has a historical weakness: the
    first argument has type **`char const`**`*`, whereas the second has type **`char`**`**`,
    without **`const`** qualification. This is why we had to type next as **`char`**`*`
    and couldn’t use **`char const`**`*`. As a result of a call to **strtoull**, we
    could inadvertently modify a read-only string and crash the program.'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C库函数**strtoull**有一个历史性的弱点：第一个参数的类型是**`char const`**`*`，而第二个参数的类型是**`char`**`**`，没有**`const`**修饰。这就是为什么我们必须将next类型指定为**`char`**`*`，而不能使用**`char
    const`**`*`。由于调用**strtoull**，我们可能会意外地修改只读字符串并导致程序崩溃。
- en: '|  |'
  id: totrans-1506
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.1
  id: totrans-1507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.1
- en: '*The string* *`strt`**`o...`* *conversion functions are not* **`const`***-safe.*'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '*`strt`**`o...`* *字符串转换函数不是* **`const`***-安全的。'
- en: '|  |'
  id: totrans-1509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now, the function numberline itself provides the glue around numberline_inner:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，numberline 函数本身提供了围绕 numberline_inner 的粘合剂：
- en: If np is null, it is set to point to an auxiliary.
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 np 为空，则将其设置为指向一个辅助对象。
- en: The input string is checked for validity.
  id: totrans-1512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查输入字符串的有效性。
- en: An array with enough elements to store the values is allocated and tailored
    to the appropriate size, once the correct length is known.
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦知道正确的长度，就会分配一个足够存储值的数组，并调整到适当的大小。
- en: 'We use three functions from the C library: **memchr**, **malloc**, and **realloc**.
    As in previous examples, a combination of **malloc** and **realloc** ensures that
    we have an array of the necessary length:'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 C 库中的三个函数：**memchr**、**malloc** 和 **realloc**。与前面的例子一样，**malloc** 和 **realloc**
    的组合确保我们有一个必要长度的数组：
- en: '**`numberline.c`**'
  id: totrans-1515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE128]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The call to **memchr** returns the address of the first byte that has value
    `0`, if there is any, or `(`**`void`**`*``)0` if there is none. Here, this is
    just used to check that within the first size bytes there effectively is a `0`
    character. That way, it guarantees that all the string functions used underneath
    (in particular, **strtoull**) operate on a `0`-terminated string.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '**memchr** 的调用返回第一个值为 `0` 的字节的地址，如果有的话，或者如果没有，则返回 `(`**`void`**`*``)0`。在这里，这只是为了检查在第一个大小字节内实际上是否存在一个
    `0` 字符。这样，它保证了所有底层使用的字符串函数（特别是 **strtoull**）都操作在以 `0` 结尾的字符串上。'
- en: With **memchr**, we encounter another problematic interface. It returns a **`void`**`*`
    that potentially points into a read-only object.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **memchr**，我们遇到了另一个有问题的接口。它返回一个 **`void`**`*`，它可能指向一个只读对象。
- en: '![](comm.jpg)'
  id: totrans-1519
  prefs: []
  type: TYPE_IMG
  zh: '![](comm.jpg)'
- en: '|  |'
  id: totrans-1520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.2
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.2
- en: '*The* **memchr** *and* **strchr** *search functions are not* **`const`***-safe.*'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '*memchr* 和 *strchr* 搜索函数不是 **`const`***-安全的。'
- en: '|  |'
  id: totrans-1523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In contrast, functions that return an index position within the string would
    be safe.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，返回字符串中索引位置的函数将是安全的。
- en: '|  |'
  id: totrans-1525
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.3
  id: totrans-1526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.3
- en: '*The* **strspn** *and* **strcspn** *search functions are* **`const`***-safe.*'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '*strspn* 和 *strcspn* 搜索函数是 **`const`***-安全的。'
- en: '|  |'
  id: totrans-1528
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Unfortunately, they have the disadvantage that they can’t be used to check whether
    a **`char-`**array is in fact a string. So they can’t be used here.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它们有一个缺点，即不能用来检查一个 **`char-`**数组实际上是否是一个字符串。因此，它们不能在这里使用。
- en: 'Now, let us look at the second function in our example:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们示例中的第二个函数：
- en: '|  |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`numberline.c`**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: 'fgetline: read one text line of at most size`-1` bytes.'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 'fgetline: 读取最多`-1`字节大小的文本行。'
- en: The '\n' character is replaced by `0`.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `\n` 字符替换为 `0`。
- en: '**Returns:** s if an entire line was read successfully. Otherwise, `0` is returned
    and *s* contains a maximal partial line that could be read. *s* is null terminated.'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** 如果成功读取整个行，则返回`s`。否则，返回`0`，并且`s`包含可以读取的最大部分行。`*s*`以空字符结尾。'
- en: '[PRE129]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '|  |'
  id: totrans-1537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is quite similar to the C library function **fgets**. The first difference
    is the interface: the parameter order is different, and the size parameter is
    a **`size_t`** instead of an **`int`**. Like **fgets**, it returns a null pointer
    if the read from the stream failed. Thus the end-of-file condition is easily detected
    on stream.'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C 库函数 **fgets** 非常相似。第一个区别是接口：参数顺序不同，大小参数是 **`size_t`** 而不是 **`int`**。像 **fgets**
    一样，如果从流中读取失败，它返回一个空指针。因此，在流上可以轻松检测文件结束条件。
- en: 'More important is that fgetline handles another critical case more gracefully.
    It detects whether the next input line is too long or whether the last line of
    the stream ends without a ''\n'' character:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，fgetline 更优雅地处理另一个关键情况。它检测下一个输入行是否过长，或者流的最后一行是否没有以`\n`字符结束：
- en: '**`numberline.c`**'
  id: totrans-1540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE130]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The first two lines of the function guarantee that s is always null terminated:
    either by the call to **fgets**, if successful, or by enforcing it to be an empty
    string. Then, if something was read, the first ''\n'' character that can be found
    in s is replaced with `0`. If none is found, a partial line has been read. In
    that case, the caller can detect this situation and call fgetline again to attempt
    to read the rest of the line or to detect an end-of-file condition.^([[[Exs 1]](#ch14fn-ex01)])'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的前两行保证 s 总是以空字符结尾：要么是通过 **fgets** 调用成功，要么是通过强制使其成为一个空字符串。然后，如果读取了某些内容，s 中可以找到的第一个
    `\n` 字符将被替换为 `0`。如果没有找到，则读取了部分行。在这种情况下，调用者可以检测这种情况并再次调用 fgetline 来尝试读取剩余的行或检测文件结束条件.^([[[Exs
    1]](#ch14fn-ex01)])
- en: ^([Exs 1])
  id: totrans-1543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 1])
- en: ''
  id: totrans-1544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Improve the **main** of the example such that it is able to cope with arbitrarily
    long input lines.
  id: totrans-1545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改进示例的 **main** 部分，使其能够处理任意长度的输入行。
- en: In addition to **fgets**, this uses **strchr** from the C library. The lack
    of **`const`**-safeness of this function is not an issue here, since s is supposed
    to be modifiable anyway. Unfortunately, with the interfaces as they exist now,
    we always have to do this assessment ourselves.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **fgets**，这个例子还使用了 C 库中的 **strchr**。这个函数缺乏 **`const`**-安全性在这里不是问题，因为 s 应该是可修改的。不幸的是，由于现有的接口，我们总是必须自己进行这种评估。
- en: 'Since it involves a lot of detailed error handling, we will go into detail
    about the function fprintnumbers in [section 14.5](#ch14lev1sec5). For our purpose
    here, we restrict ourselves to the discussion of function sprintnumbers, which
    is a bit simpler because it only writes to a string, instead of a stream, and
    because it just assumes that the buffer buf that it receives provides enough space:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它涉及大量的详细错误处理，我们将详细介绍函数 fprintnumbers，它在 [第 14.5 节](#ch14lev1sec5) 中。对于我们的目的，我们只限于讨论函数
    sprintnumbers，它比它简单，因为它只写入字符串，而不是流，并且它只假设它接收到的缓冲区 buf 提供了足够的空间：
- en: '|  |'
  id: totrans-1548
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`numberline.c`**'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: 'sprintnumbers: print a series of numbers *nums* in *buf*, using **printf**
    format *form*, separated by *sep* characters and terminated with a newline character.'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 'sprintnumbers: 在 *buf* 中打印一系列数字 *nums*，使用 **printf** 格式 *form*，并用 *sep* 字符分隔，并以换行符结尾。'
- en: '**Returns:** the number of characters printed to *buf*.'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值：** 打印到 *buf* 中的字符数。'
- en: This supposes that *tot* and *buf* are big enough and that *form* is a format
    suitable to print **`size_t`**.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设 *tot* 和 *buf* 足够大，并且 *form* 是一个适合打印 **`size_t`** 的格式。
- en: '[PRE131]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '|  |'
  id: totrans-1554
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The function sprintnumbers uses a function of the C library that we haven’t
    met yet: **sprintf**. Its formatting capacities are the same as those of **printf**
    and **fprintf**, only it doesn’t print to a stream but rather to a **`char`**
    array:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 sprintnumbers 使用 C 库中的一个我们尚未遇到的功能：**sprintf**。它的格式化能力与 **printf** 和 **fprintf**
    相同，只是它不打印到流，而是打印到 **`char`** 数组：
- en: '**`numberline.c`**'
  id: totrans-1556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE132]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The function **sprintf** always ensures that a `0` character is placed at the
    end of the string. It also returns the length of that string, which is the number
    of characters before the `0` character that have been written. This is used in
    the example to update the pointer to the current position in the buffer. **sprintf**
    still has an important vulnerability:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 **sprintf** 总是确保在字符串末尾放置一个 `0` 字符。它还返回该字符串的长度，这是在 `0` 字符之前写入的字符数。这在示例中用于更新缓冲区当前位置的指针。**sprintf**
    仍然有一个重要的漏洞：
- en: '|  |'
  id: totrans-1559
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.4
  id: totrans-1560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.4
- en: '**sprintf** *makes no provision against buffer overflow.*'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: '**sprintf** **没有提供防止缓冲区溢出的措施**。'
- en: '|  |'
  id: totrans-1562
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'That is, if we pass an insufficient buffer as a first argument, bad things
    will happen. Here, inside sprintnumbers, much like **sprintf** itself, we *suppose*
    the buffer is large enough to hold the result. If we aren’t sure the buffer can
    hold the result, we can use the C library function **snprintf**, instead:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 即，如果我们传递一个不充足的缓冲区作为第一个参数，会发生不好的事情。在这里，在 sprintnumbers 中，就像 **sprintf** 本身一样，我们
    *假设* 缓冲区足够大，可以容纳结果。如果我们不确定缓冲区能否容纳结果，我们可以使用 C 库函数 **snprintf**，而不是：
- en: '[PRE133]'
  id: totrans-1564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This function ensures in addition that no more than n bytes are ever written
    to s. If the return value is greater than or equal to n, the string is been truncated
    to fit. In particular, if n is `0`, nothing is written into s.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还确保不会写入超过 n 个字节。如果返回值大于或等于 n，字符串将被截断以适应。特别是，如果 n 是 `0`，则不会写入 s。
- en: '|  |'
  id: totrans-1566
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.5
  id: totrans-1567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.5
- en: '*Use* **snprintf** *when formatting output of unknown length.*'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* **snprintf** **来格式化未知长度的输出。*'
- en: '|  |'
  id: totrans-1569
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In summary, **snprintf** has a lot of nice properties:'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，**snprintf** 有很多不错的特性：
- en: The buffer s will not overflow.
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区 s 不会溢出。
- en: After a successful call, s is a string.
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功调用后，s 是一个字符串。
- en: When called with n and s set to `0`, **snprintf** just returns the length of
    the string that would have been written.
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 n 和 s 设置为 `0` 时，**snprintf** 只返回将要写入的字符串的长度。
- en: 'By using that, a simple **`for`** loop to compute the length of all the numbers
    printed on one line looks like this:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用它，一个简单的 **`for`** 循环来计算一行上打印的所有数字的长度如下所示：
- en: '**`numberline.c`**'
  id: totrans-1575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE134]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: We will see later how this is used in the context of fprintnumbers.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面看到如何在 fprintnumbers 的上下文中使用它。
- en: '|  |'
  id: totrans-1578
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Text processing in strings**'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串中的文本处理**'
- en: We’ve covered quite a bit about text processing, so let’s see if we can actually
    use it.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于文本处理的内容，现在让我们看看我们是否真的能使用它。
- en: Can you search for a given word in a string?
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在字符串中搜索一个特定的单词？
- en: Can you replace a word in a string and return a copy with the new contents?
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在字符串中替换一个单词，并返回包含新内容的副本？
- en: Can you implement some regular-expression-matching functions for strings? For
    example, find a character class such as `[A-Q]` or `[^0-9]`, match with `*` (meaning
    “anything"), or match with `?` (meaning “any character").
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否为字符串实现一些正则表达式匹配函数？例如，找到一个字符类如 `[A-Q]` 或 `[^0-9]`，使用 `*`（表示“任何东西”）进行匹配，或使用
    `?`（表示“任何字符”）进行匹配。
- en: Or can you implement a regular-expression-matching function for POSIX character
    classes such as `[[:alpha:]]`, `[[:digit:]]`, and so on?
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否实现一个用于POSIX字符类（如 `[[:alpha:]]`, `[[:digit:]]` 等）的正则表达式匹配函数？
- en: Can you stitch all these functionalities together to search for a regexp in
    a string?
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否将这些功能组合起来，在字符串中搜索正则表达式？
- en: Do query-replace with regexp against a specific word?
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否使用正则表达式对特定单词进行查询替换？
- en: Extend a regexp with grouping?
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 能否扩展正则表达式以实现分组？
- en: Extend query-replace with grouping?
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 能否扩展查询替换以实现分组？
- en: '|  |'
  id: totrans-1589
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.2\. Formatted input
  id: totrans-1590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. 格式化输入
- en: 'Similar to the **printf** family of functions for formatted output, the C library
    has a series of functions for formatted input: **fscanf** for input from an arbitrary
    stream, **scanf** for **`stdin`**, and **sscanf** from a string. For example,
    the following would read a line of three **`double`** values from **`stdin`**:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于格式化输出的 **printf** 函数族类似，C库有一系列用于格式化输入的函数：**fscanf** 用于从任意流中读取，**scanf** 用于
    **`stdin`**，**sscanf** 用于字符串。例如，以下代码将从 **`stdin`** 读取一行包含三个 **`double`** 值：
- en: '[PRE135]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[Tables 14.1](#ch14table01) to [14.3](#ch14table03) give an overview of the
    format for specifiers. Unfortunately, these functions are more difficult to use
    than **printf** and also have conventions that diverge from **printf** in subtle
    ways.'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14.1](#ch14table01) 到 [14.3](#ch14table03) 提供了规范格式的概述。不幸的是，这些函数比 **printf**
    更难使用，并且它们的约定在细微之处与 **printf** 有所不同。'
- en: Table 14.1\. Format specifications for **scanf** and similar functions, with
    the general syntax **`[XX][WW][LL]SS`**
  id: totrans-1594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 14.1. **scanf** 和类似函数的格式规范，其一般语法为 **`[XX][WW][LL]SS`**
- en: '| XX | * | Assignment suppression |'
  id: totrans-1595
  prefs: []
  type: TYPE_TB
  zh: '| XX | * | 赋值抑制 |'
- en: '| WW | Field width | Maximum number of input characters |'
  id: totrans-1596
  prefs: []
  type: TYPE_TB
  zh: '| WW | 字段宽度 | 最大输入字符数 |'
- en: '| LL | Modifier | Select width of target type |'
  id: totrans-1597
  prefs: []
  type: TYPE_TB
  zh: '| LL | 修饰符 | 选择目标类型的宽度 |'
- en: '| SS | Specifier | Select conversion |'
  id: totrans-1598
  prefs: []
  type: TYPE_TB
  zh: '| SS | 规范符 | 选择转换 |'
- en: To be able to return values for all formats, the arguments are pointers to the
    type that is scanned.
  id: totrans-1599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够返回所有格式的值，参数是指向被扫描的类型指针。
- en: 'Whitespace handling is subtle and sometimes unexpected. A space character,
    '' '', in the format matches any sequence of whitespace: spaces, tabs, and newline
    characters. Such a sequence may in particular be empty or contain several newline
    characters.'
  id: totrans-1600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白处理很微妙，有时会出乎意料。在格式中，空格字符 ' ' 匹配任何空白序列：空格、制表符和换行符。这样的序列可能是空的，或者包含多个换行符。
- en: String handling is different. Because the arguments to the **scanf** functions
    are pointers anyway, the formats "%c" and "%s" both refer to an argument of type
    **`char`**`*`. Where "%c" reads a character array of fixed size (of default `1`),
    "%s" matches any sequence of non-whitespace characters and adds a terminating
    `0` character.
  id: totrans-1601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串处理不同。因为 **scanf** 函数的参数本身就是指针，所以格式 "%c" 和 "%s" 都指向一个 **`char`**`*` 类型的参数。其中
    "%c" 读取固定大小的字符数组（默认为 `1`），而 "%s" 匹配任何非空白字符序列，并添加一个终止的 `0` 字符。
- en: The specifications of types in the format have subtle differences compared to
    **printf**, in particular for floating-point types. To be consistent between the
    two, it is best to use "%lg" or similar for **`double`** and "%Lg" for **`long
    double`**, for both **printf** and **scanf**.
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式中类型的规范与 **printf** 相比有细微的差别，特别是在浮点类型方面。为了保持两者的一致性，最好对 **`double`** 使用 "%lg"
    或类似格式，对 **`long double`** 使用 "%Lg"，无论是 **printf** 还是 **scanf**。
- en: There is a rudimentary utility to recognize character classes. For example,
    a format of "%[aeiouAEIOU]" can be used to scan for the vowels in the Latin alphabet.
  id: totrans-1603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个基本的工具可以识别字符类。例如，格式 "%[aeiouAEIOU]" 可以用来扫描拉丁字母中的元音。
- en: Table 14.2\. *Format specifiers for **scanf** and similar functions* With an
    'l' modifier, specifiers for characters or sets of characters ('c', 's', '[')
    transform multibyte character sequences on input to wide-character **`wchar_t`**
    arguments; see subection 14.3.
  id: totrans-1604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.2\. *scanf和类似函数的格式说明符* 使用'l'修饰符时，字符或字符集（'c', 's', '['）的说明符将输入的多字节字符序列转换为宽字符**`wchar_t`**参数；参见14.3节。
- en: '| SS | Conversion | Pointer to | Skip space | Analogous to function |'
  id: totrans-1605
  prefs: []
  type: TYPE_TB
  zh: '| SS | 转换 | 指针到 | 跳过空格 | 类似于函数 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-1606
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| ''d'' | Decimal | Signed type | Yes | **strtol**, base 10 |'
  id: totrans-1607
  prefs: []
  type: TYPE_TB
  zh: '| ''d'' | 十进制 | 有符号类型 | 是 | **strtol**，基数10 |'
- en: '| ''i'' | Decimal, octal, or hex | Signed type | Yes | **strtol**, base 0 |'
  id: totrans-1608
  prefs: []
  type: TYPE_TB
  zh: '| ''i'' | 十进制、八进制或十六进制 | 有符号类型 | 是 | **strtol**，基数0 |'
- en: '| ''u'' | Decimal | Unsigned type | Yes | **strtoul**, base 10 |'
  id: totrans-1609
  prefs: []
  type: TYPE_TB
  zh: '| ''u'' | 十进制 | 无符号类型 | 是 | **strtoul**，基数10 |'
- en: '| ''o'' | Octal | Unsigned type | Yes | **strtoul**, base 8 |'
  id: totrans-1610
  prefs: []
  type: TYPE_TB
  zh: '| ''o'' | 八进制 | 无符号类型 | 是 | **strtoul**，基数8 |'
- en: '| ''x'' | Hexadecimal | Unsigned type | Yes | **strtoul**, base 16 |'
  id: totrans-1611
  prefs: []
  type: TYPE_TB
  zh: '| ''x'' | 十六进制 | 无符号类型 | 是 | **strtoul**，基数16 |'
- en: '| ''aefg'' | Floating point | Floating point | Yes | **strtod** |'
  id: totrans-1612
  prefs: []
  type: TYPE_TB
  zh: '| ''aefg'' | 浮点数 | 浮点数 | 是 | **strtod** |'
- en: '| ''%'' | ''%'' character | No assignment | No |   |'
  id: totrans-1613
  prefs: []
  type: TYPE_TB
  zh: '| ''%'' | ''%''字符 | 无赋值 | 否 |   |'
- en: '| ''c'' | Characters | **char** | No | **memcpy** |'
  id: totrans-1614
  prefs: []
  type: TYPE_TB
  zh: '| ''c'' | 字符 | **char** | 否 | **memcpy** |'
- en: '| ''s'' | Non-whitespace | **char** | Yes | **strcspn** with |'
  id: totrans-1615
  prefs: []
  type: TYPE_TB
  zh: '| ''s'' | 非空白字符 | **字符** | 是 | **strcspn** 与 |'
- en: '|   |   |   |   | " \f\n\r\t\v" |'
  id: totrans-1616
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   | " \f\n\r\t\v" |'
- en: '| ''['' | Scan set | String | No | **strspn** or **strcspn** |'
  id: totrans-1617
  prefs: []
  type: TYPE_TB
  zh: '| ''['' | 扫描集 | 字符串 | 否 | **strspn**或**strcspn** |'
- en: '| ''p'' | Address | **void** | Yes |   |'
  id: totrans-1618
  prefs: []
  type: TYPE_TB
  zh: '| ''p'' | 地址 | **void** | 是 |   |'
- en: '| ''n'' | Character count | Signed type | No |   |'
  id: totrans-1619
  prefs: []
  type: TYPE_TB
  zh: '| ''n'' | 字符计数 | 有符号类型 | 否 |   |'
- en: In such a character class specification, the caret `^` negates the class if
    it is found at the beginning. Thus "%[^\n]%*[\n]" scans a whole line (which must
    be nonempty) and then discards the newline character at the end of the line.
  id: totrans-1620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这样的字符类指定中，如果开头的反斜杠`^`出现在类中，它将否定该类。因此，"%[^\n]%*[\n]"扫描整个行（必须非空）然后丢弃行尾的换行符。
- en: These particularities make the **scanf** family of functions difficult to use.
    For example, our seemingly simple example has the flaw (or feature) that it is
    not restricted to read a single input line, but it would happily accept three
    **`double`** values spread over several lines.^([[[Exs 2]](#ch14fn-ex02)]) In
    most cases where you have a regular input pattern such as a series of numbers,
    they are best avoided.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性使得**scanf**函数族难以使用。例如，我们的看似简单的例子有一个缺陷（或特性），即它不仅限于读取单行输入，而且它还会愉快地接受分布在多行上的三个**`double`**值。（[[[Exs
    2]](#ch14fn-ex02)]) 在大多数有规律输入模式的情况下，例如一系列数字，最好避免使用。
- en: ^([Exs 2])
  id: totrans-1622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 2])
- en: ''
  id: totrans-1623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the format string in the example such that it only accepts three numbers
    on a single line, separated by blanks, and such that the terminating newline character
    (eventually preceded by blanks) is skipped.
  id: totrans-1624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改示例中的格式字符串，使其只接受一行上的三个数字，由空格分隔，并且跳过终止的换行符（可能前面有空白）。
- en: 14.3\. Extended character sets
  id: totrans-1625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3\. 扩展字符集
- en: 'Up to now, we have used only a limited set of characters to specify our programs
    or the contents of string literals that we printed on the console: a set consisting
    of the Latin alphabet, Arabic numerals, and some punctuation characters. This
    limitation is a historical accident that originated in the early market domination
    by the American computer industry, on one hand, and the initial need to encode
    characters with a very limited number of bits on the other.^([[1](#ch14fn01)])
    As we saw with the use of the type name **`char`** for the basic data cell, the
    concepts of a text character and an indivisible data component were not very well
    separated at the start.'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了一组有限的字符来指定我们的程序或打印在控制台上的字符串字面量的内容：一组由拉丁字母、阿拉伯数字和一些标点符号字符组成。这种限制是一个历史事件，起源于美国计算机行业在早期市场的统治地位，另一方面，以及最初需要用非常有限的位数来编码字符的需求.^([[1](#ch14fn01)])
    正如我们在使用类型名**`char`**作为基本数据单元时所见，文本字符和不可分割的数据组件的概念在开始时并没有很好地分离。
- en: ¹
  id: totrans-1627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The character encoding that is dominantly used for the basic character set
    is referred to as ASCII: *A*merican *s*tandard *c*ode for *i*nformation *i*nterchange.'
  id: totrans-1629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于基本字符集的占主导地位的字符编码被称为ASCII：*A*merican *s*tandard *c*ode for *i*nformation *i*nterchange。
- en: Table 14.3\. *Format modifiers for **scanf** and similar functions* Note that
    the significance of **`float`**`*` and **`double`**`*` arguments is different
    than for **printf** formats.
  id: totrans-1630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 14.3\. *scanf 和类似函数的格式修饰符* 注意，**`float`**`*` 和 **`double`**`*` 参数的显著性不同于 printf
    格式。
- en: '| Character | Type |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 类型 |'
- en: '| --- | --- |'
  id: totrans-1632
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| "hh" | **char** types |'
  id: totrans-1633
  prefs: []
  type: TYPE_TB
  zh: '| "hh" | **char** 类型 |'
- en: '| "h" | **short** types |'
  id: totrans-1634
  prefs: []
  type: TYPE_TB
  zh: '| "h" | **short** 类型 |'
- en: '| "" | **signed**, **unsigned**, **float**, **char** arrays and strings |'
  id: totrans-1635
  prefs: []
  type: TYPE_TB
  zh: '| "" | **signed**，**unsigned**，**float**，**char** 数组和字符串 |'
- en: '| "l" | **long** integer types, **double**, **wchar_t** characters and strings
    |'
  id: totrans-1636
  prefs: []
  type: TYPE_TB
  zh: '| "l" | **long** 整数类型，**double**，**wchar_t** 字符和字符串 |'
- en: '| "ll" | **long long** integer types |'
  id: totrans-1637
  prefs: []
  type: TYPE_TB
  zh: '| "ll" | **long long** 整数类型 |'
- en: '| "j" | **intmax_t**, **uintmax_t** |'
  id: totrans-1638
  prefs: []
  type: TYPE_TB
  zh: '| "j" | **intmax_t**, **uintmax_t** |'
- en: '| "z" | **size_t** |'
  id: totrans-1639
  prefs: []
  type: TYPE_TB
  zh: '| "z" | **size_t** |'
- en: '| "t" | **ptrdiff_t** |'
  id: totrans-1640
  prefs: []
  type: TYPE_TB
  zh: '| "t" | **ptrdiff_t** |'
- en: '| "L" | **long double** |'
  id: totrans-1641
  prefs: []
  type: TYPE_TB
  zh: '| "L" | **long double** |'
- en: Latin, from which we inherited our character set, is long dead as a spoken language.
    Its character set is not sufficient to encode the particularities of the phonetics
    of other languages. Among the European languages, English has the peculiarity
    that it encodes missing sounds with combinations of letters such as *ai*, *ou*,
    and *gh* (*fair enough*), not with diacritical marks, special characters, or ligatures
    (*fär ínó*), as do most of its cousins. So for other languages that use the Latin
    alphabet, the possibilities were already quite restricted; but for languages and
    cultures that use completely different scripts (Greek, Russian) or even completely
    different concepts (Japanese, Chinese), this restricted American character set
    was clearly not sufficient.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 拉丁语，我们从其中继承了我们的字符集，作为一种口语已经很久远了。它的字符集不足以编码其他语言的语音特性。在欧洲语言中，英语有一个特性，它用字母组合（如
    *ai*，*ou*，和 *gh* (*fair enough*））来编码缺失的音素，而不是用重音符号、特殊字符或连字符（如 *fär ínó*），就像大多数它的表亲一样。所以对于使用拉丁字母的其他语言，可能性已经相当有限；但对于使用完全不同书写系统（希腊语、俄语）或甚至完全不同概念（日语、中文）的语言和文化，这个受限的美国字符集显然是不够的。
- en: During the first years of market expansion around the world, different computer
    manufacturers, countries, and organizations provided native language support for
    their respective communities more or less randomly, and added specialized support
    for graphical characters, mathematical typesetting, musical scores, and so on
    without coordination. It was an utter chaos. As a result, interchanging textual
    information between different systems, countries, and cultures was difficult if
    not impossible in many cases; writing portable code that could be used in the
    context of different languages *and* different computing platforms resembled the
    black arts.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 在全球市场扩张的前几年，不同的计算机制造商、国家和组织为其各自的社区提供本地语言支持，或多或少是随机进行的，并且没有协调地添加了对图形字符、数学排版、乐谱等特殊支持。这完全是一团糟。因此，在不同系统、国家和文化之间交换文本信息在许多情况下是困难的，甚至是不可能的；编写可在不同语言
    *和* 不同计算平台上下文中使用的可移植代码就像黑魔法一样。
- en: 'Luckily, these years-long difficulties are now mainly mastered, and on modern
    systems we can write portable code that uses “extended” characters in a unified
    way. The following code snippet shows how this is supposed to work:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些长达数年的困难现在已经被主要克服，在现代系统中，我们可以编写使用“扩展”字符的统一方式的可移植代码。以下代码片段展示了这是如何工作的：
- en: '**`mbstrings-main.c`**'
  id: totrans-1645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings-main.c`**'
- en: '[PRE136]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'That is, near the beginning of our program, we switch to the “native” locale,
    and then we can use and output text containing *extended characters*: here, phonetics
    (so-called IPA). The output of this looks similar to'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 即，在我们的程序接近开始的地方，我们切换到“本地”区域设置，然后我们可以使用和输出包含 *扩展字符* 的文本：这里，是语音学（所谓的 IPA）。输出看起来类似于
- en: '![](241fig01_alt.jpg)'
  id: totrans-1648
  prefs: []
  type: TYPE_IMG
  zh: '![](241fig01_alt.jpg)'
- en: 'The means to achieve this are quite simple. We have some macros with magic
    string literals for vertical and horizontal bars, and top-left and top-right corners:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的手段相当简单。我们有一些宏，带有用于垂直和水平线的魔法字符串字面量，以及左上角和右上角：
- en: '**`mbstrings-main.c`**'
  id: totrans-1650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings-main.c`**'
- en: '[PRE137]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'And an ad hoc function that nicely formats an output line:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个格式化输出行的专用函数：
- en: '|  |'
  id: totrans-1653
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`mbstrings-main.c`**'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: '**`mbstrings-main.c`**'
- en: 'draw_sep: Draw multibyte strings *start* and *end* separated by a horizontal
    line.'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 'draw_sep: 使用水平线绘制由 *start* 和 *end* 分隔的多字节字符串。'
- en: '[PRE138]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '|  |'
  id: totrans-1657
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This uses a function to count the number of print characters in a multibyte
    string (mbsrlen) and our old friends **fputs** and **fputc** for textual output.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用一个函数来计算多字节字符串（mbsrlen）中的打印字符数，以及我们的老朋友 **fputs** 和 **fputc** 用于文本输出。
- en: The start of all of this with the call to **setlocale** is important. Chances
    are, otherwise you’d see garbage if you output characters from the extended set
    to your terminal. But once you have issued that call to **setlocale** and your
    system is well installed, such characters placed inside multibyte strings "fär
    ínó*`ff`*" should not work out too badly.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都是从调用**setlocale**开始的，这一点很重要。否则，如果您将扩展集中的字符输出到终端，可能会看到垃圾数据。但是一旦您调用了**setlocale**并且系统安装良好，这些字符放在多字节字符串中“fär
    ínó*`ff`*”应该不会出太大问题。
- en: A *multibyte character* is a sequence of bytes that is interpreted as representing
    a single character of the extended character set, and a *multibyte string* is
    a string that contains such multibyte characters. Luckily, these beasts are compatible
    with ordinary strings as we have handled them so far.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*多字节字符*是一系列字节，被解释为表示扩展字符集的单个字符，而一个*多字节字符串*是包含此类多字节字符的字符串。幸运的是，这些家伙与我们迄今为止处理的标准字符串兼容。
- en: '|  |'
  id: totrans-1661
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.6
  id: totrans-1662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获14.6
- en: '*Multibyte characters don’t contain null bytes.*'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '*多字节字符不包含空字节*。'
- en: '|  |'
  id: totrans-1664
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1665
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.7
  id: totrans-1666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收获14.7
- en: '*Multibyte strings are null terminated.*'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: '*多字节字符串以空字符结尾*。'
- en: '|  |'
  id: totrans-1668
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Thus, many of the standard string functions such as **strcpy** work out of
    the box for multibyte strings. They introduce one major difficulty, though: the
    fact that the number of printed characters can no longer be directly deduced from
    the number of elements of a **`char`** array or by the function **strlen**. This
    is why, in the previous code, we use the (nonstandard) function mbsrlen:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，许多标准字符串函数，如**strcpy**，对于多字节字符串来说都是现成的。尽管如此，它们也引入了一个主要困难：打印字符的数量不能再直接从**`char`**数组元素的数量或通过函数**strlen**来推断。这就是为什么在前面的代码中，我们使用了（非标准的）函数mbsrlen：
- en: '|  |'
  id: totrans-1670
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`mbstrings.h`**'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '**`mbstrings.h`**'
- en: 'mbsrlen: Interpret a mb string in *mbs* and return its length when interpreted
    as a wide character string.'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: mbsrlen：在*mbs*中解释mb字符串，并将其作为宽字符字符串返回其长度。
- en: '**Returns**: the length of the mb string or `-1` if an encoding error occured.'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：多字节字符串的长度，如果发生编码错误则返回`-1`。'
- en: This function can be integrated into a sequence of searches through a string,
    as long as a *state* argument is passed to this function that is consistent with
    the mb character starting in *mbs*. The state itself is not modified by this function.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 只要向此函数传递一个与*mbs*中mb字符起始状态一致的*状态*参数，此函数就可以集成到对字符串的一系列搜索中。该状态本身不会被此函数修改。
- en: '**Remarks**: *state* of `0` indicates that *mbs* can be scanned without considering
    any context.'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**：`0`的*状态*表示可以不考虑任何上下文扫描*mbs*。'
- en: '[PRE139]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|  |'
  id: totrans-1677
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you can see from that description, parsing multibyte strings for the individual
    multibyte characters can be a bit more complicated. In particular, generally we
    need to keep a parsing state by means of the type **`mbstate_t`** that is provided
    by the C standard in the header files `wchar.h`.^([[2](#ch14fn02)]) This header
    provides utilities for multibyte strings and characters, and also for a *wide
    character* type **`wchar_t`**. We will see that later.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从描述中可以看到，解析多字节字符串以获取单个多字节字符可能要复杂一些。特别是，我们通常需要通过C标准在头文件`wchar.h`中提供的类型**`mbstate_t`**来保持解析状态。^([[2](#ch14fn02)])
    此头文件提供了多字节字符串和字符的实用工具，以及*宽字符*类型**`wchar_t`**。我们将在后面看到这一点。
- en: ²
  id: totrans-1679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The header `uchar.h` also provides this type.
  id: totrans-1681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 头文件`uchar.h`也提供了这种类型。
- en: '|  |'
  id: totrans-1682
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<wchar.h>`'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '`<wchar.h>`'
- en: '|  |'
  id: totrans-1684
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'But first, we have to introduce another international standard: ISO 10646,
    or *Unicode [[2017](kindle_split_036.html#bib19)]*. As the naming indicates, Unicode
    ([http://www.joelonsoftware.com/articles/Unicode.html](http://www.joelonsoftware.com/articles/Unicode.html))
    attempts to provide a unified framework for character codes. It provides a huge
    table^([[3](#ch14fn03)]) of basically all character *concepts* that have been
    conceived by mankind so far. *Concept* here is really important: we have to understand
    from the print form or *glyph* of a particular character in a certain type that,
    for example, “Latin capital letter A” can appear as A, *A*, A, or `A` in the present
    text. Other such conceptual characters like the character “Greek capital letter
    Alpha” may even be printed with the same or similar glyph A.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们必须介绍另一个国际标准：ISO 10646，或称为*Unicode [[2017](kindle_split_036.html#bib19)]*。正如其命名所示，Unicode
    ([http://www.joelonsoftware.com/articles/Unicode.html](http://www.joelonsoftware.com/articles/Unicode.html))试图提供一个统一的字符码框架。它提供了一个巨大的表格^([[3](#ch14fn03)])，基本上包含了迄今为止人类所构想的所有字符*概念*。*概念*在这里非常重要：我们必须从特定类型中某个特定字符的打印形式或*符号*来理解，例如，“拉丁大写字母A”可以在这个文本中以A、*A*、A或`A`的形式出现。其他类似的概念字符，如“希腊大写字母Alpha”字符，甚至可能以相同的或相似的符号A打印。
- en: ³
  id: totrans-1686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Today, Unicode has about 110,000 code points.
  id: totrans-1688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，Unicode大约有110,000个码点。
- en: Unicode places each character concept, or *code point* in its own jargon, into
    a linguistic or technical context. In addition to the definition of the character,
    Unicode classifies it, for example, as being a capital letter, and relates it
    to other code points, such as by stating that *A* is the capitalization of *a*.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode将每个字符概念，或称为*码点*，放入其自己的语言或技术上下文中。除了字符的定义外，Unicode还对它进行分类，例如，将其归类为一个大写字母，并将其与其他码点相关联，例如，指出*A*是*a*的大写形式。
- en: 'If you need special characters for your particular language, there is a good
    chance that you have them on your keyboard and that you can enter them into multibyte
    strings for coding in C as is. That is, your system may be configured to insert
    the whole byte sequence for ä, say, directly into the text and do all the required
    magic for you. If you don’t have or want that, you can use the technique that
    we used for the macros HBAR earlier. There we used an escape sequence that was
    new in C11 ([http://dotslashzero.net/2014/05/21/the-interesting-state-of-unicode-in-c/](http://dotslashzero.net/2014/05/21/the-interesting-state-of-unicode-in-c/)):
    a backslash and a *u* followed by four hexadecimal digits encode a Unicode code
    point. For example, the code point for “latin small letter a with diaeresis” is
    228 or 0xE4. Inside a multibyte string, this then reads as "\u00E4". Since four
    hexadecimal digits can address only 65,536 code points, there is also the option
    to specify 8 hexadecimal digits, introduced with a backslash and a capital *U*,
    but you will encounter this only in very specialized contexts.'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要特定语言的特殊字符，那么您很可能在键盘上就能找到它们，并且可以将它们输入到用于C语言编码的多字节字符串中，就像这样。也就是说，您的系统可能被配置为直接将整个字节序列（例如ä）插入到文本中，并为您完成所有必要的操作。如果您没有或者不想使用这种方法，您可以使用我们之前用于宏HBAR的技术。在那里，我们使用了C11中引入的新转义序列（[http://dotslashzero.net/2014/05/21/the-interesting-state-of-unicode-in-c/](http://dotslashzero.net/2014/05/21/the-interesting-state-of-unicode-in-c/)）：一个反斜杠后跟一个*u*和四个十六进制数字来编码一个Unicode码点。例如，“拉丁小写字母a带重音符号”的码点是228或0xE4。在多字节字符串中，这读作"\u00E4"。由于四个十六进制数字只能表示65,536个码点，因此还有指定8个十六进制数字的选项，这是通过反斜杠和一个大写*U*引入的，但您只有在非常专业的环境中才会遇到这种情况。
- en: In the previous example, we encoded four graphical characters with such Unicode
    specifications, characters that most likely are not on any keyboard. There are
    several online sites that allow you to find the code point for any character you
    need.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用这样的Unicode规范编码了四个图形字符，这些字符很可能不在任何键盘上。有几个在线网站允许您查找您需要的任何字符的码点。
- en: 'If we want to do more than simple input/output with multibyte characters and
    strings, things become a bit more complicated. Simple counting of the characters
    already is not trivial: **strlen** does not give the right answer, and other string
    functions such as **strchr**, **strspn**, and **strstr** don’t work as expected.
    Fortunately, the C standard gives us a set of replacement functions, usually prefixed
    with **`wcs`** instead of str, that will work on *wide character strings*, instead.
    The mbsrlen function that we introduced earlier can be coded as'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用多字节字符和字符串进行比简单的输入/输出更复杂的操作，事情就会变得稍微复杂一些。简单的字符计数已经不再是微不足道的：**strlen**不会给出正确答案，其他字符串函数如**strchr**、**strspn**和**strstr**也不会按预期工作。幸运的是，C标准为我们提供了一组替换函数，通常以**`wcs`**而不是str作为前缀，这些函数将作用于*宽字符字符串*。我们之前介绍的mbsrlen函数可以编码为
- en: '**`mbstrings.c`**'
  id: totrans-1693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings.c`**'
- en: '[PRE140]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The core of this function is the use of the library function **mbsrtowcs**
    (“*multibyte string (mbs), restartable, to wide character string (wcs)*"), which
    constitutes one of the primitives that the C standard provides to handle multibyte
    strings:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的核心是使用库函数**mbsrtowcs**（“*多字节字符串（mbs），可重置，到宽字符字符串（wcs）*”），它构成了C标准提供的用于处理多字节字符串的原始函数之一：
- en: '[PRE141]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'So once we decrypt the abbreviation of the name, we know that this function
    is supposed to convert an mbs, src, to a wcs, dst. Here, *wide characters* (wc)
    of type **`wchar_t`** are use to encode exactly one character of the extended
    character set, and these wide characters are used to form wcs pretty much in the
    same way as **`char`** s compose ordinary strings: they are null-terminated arrays
    of such wide characters.'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们解密了名称的缩写，我们就知道这个函数应该将mbs，src，转换为wcs，dst。在这里，*宽字符*（wc）类型**`wchar_t`**用于精确编码扩展字符集中的单个字符，这些宽字符以与**`char`**组成普通字符串相同的方式形成wcs：它们是这种宽字符的空终止数组。
- en: 'The C standard doesn’t restrict the encoding used for **`wchar_t`** much, but
    any sane environment nowadays should use Unicode for its internal representations.
    You can check this with two macros as follows:'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: C标准对**`wchar_t`**使用的编码限制不多，但任何合理的环境现在都应该使用Unicode作为其内部表示。你可以使用以下两个宏来检查这一点：
- en: '**`mbstrings.h`**'
  id: totrans-1699
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings.h`**'
- en: '[PRE142]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Modern platforms typically implement **`wchar_t`** with either 16-bit or 32-bit
    integer types. Which one usually should not be of much concern to you, if you
    only use the code points that are representable with four hexadecimal digits in
    the \uXXXX notation. Those platforms that use 16-bit effectively can’t use the
    other code points in \UXXXXXXXX notation, but this shouldn’t bother you much.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 现代平台通常使用16位或32位整数类型来实现**`wchar_t`**。如果你只使用可以用四个十六进制数字表示的Unicode码点，那么通常你不必太关心这一点。那些使用16位有效编码的平台不能使用\UXXXXXXXX表示法中的其他码点，但这不应该让你感到烦恼。
- en: 'Wide characters and wide character string literals follow analogous rules to
    those we have seen for **`char`** and strings. For both, a prefix of L indicates
    a wide character or string: for example, L''ä'' and L''\u00E4'' are the same character,
    both of type **`wchar_t`**, and L"b\u00E4" is an array of three elements of type
    **`wchar_t`** that contains the wide characters L''b'', L''ä'', and `0`.'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 宽字符和宽字符字符串字面量遵循与**`char`**和字符串相同的规则。对于两者，L前缀表示宽字符或字符串：例如，L'ä'和L'\u00E4'是相同的字符，两者都是**`wchar_t`**类型，L"b\u00E4"是一个包含宽字符L'b'、L'ä'和`0`的三个元素的数组。
- en: Classification of wide characters is also done in a similar way as for simple
    **`char`**. The header `wctype.h` provides the necessary functions and macros.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 宽字符的分类也以与简单**`char`**类似的方式进行。头文件`wctype.h`提供了必要的函数和宏。
- en: '|  |'
  id: totrans-1704
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<wctype.h>`'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '`<wctype.h>`'
- en: '|  |'
  id: totrans-1706
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To come back to **mbsrtowcs**, this function *parses* the multibyte string src
    into snippets that correspond to *multibyte characters* (mbc), and assigns the
    corresponding code point to the wide characters in dst. The parameter len describes
    the maximal length that the resulting wcs may have. The parameter state points
    to a variable that stores an eventual *parsing state* of the mbs; we will discuss
    this concept briefly a bit later.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**mbsrtowcs**，这个函数*解析*多字节字符串src到对应于*多字节字符*（mbc）的片段，并将相应的码点分配给dst中的宽字符。参数len描述了结果wcs可能的最大长度。参数state指向一个变量，该变量存储mbs的潜在*解析状态*；我们将在稍后简要讨论这个概念。
- en: As you can see, the function **mbsrtowcs** has two peculiarities. First, when
    called with a null pointer for dst, it simply doesn’t store the wcs but only returns
    the size that such a wcs would have. Second, it can produce a *coding error* if
    the mbs is not encoded correctly. In that case, the function returns `(`**`size_t`**`)-1`
    and sets **`errno`** to the value **`EILSEQ`** (see `errno.h`). Part of the code
    for mbsrlen is actually a repair of that error strategy by setting **`errno`**
    to `0` again.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数 **mbsrtowcs** 有两个特殊性。首先，当使用空指针调用 dst 时，它不会存储 wcs，而只是返回这样一个 wcs 的大小。其次，如果
    mbs 没有正确编码，它可能会产生 *编码错误*。在这种情况下，函数返回 `(`**`size_t`**`)-1` 并将 **`errno`** 设置为值
    **`EILSEQ`**（见 `errno.h`）。mbsrlen 的部分代码实际上是对该错误策略的修复，通过将 **`errno`** 再次设置为 `0`。
- en: '|  |'
  id: totrans-1709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<errno.h>`'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '`<errno.h>`'
- en: '|  |'
  id: totrans-1711
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s now look at a second function that will help us handle mbs:'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看第二个函数，它将帮助我们处理 mbs：
- en: '|  |'
  id: totrans-1713
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`mbstrings.h`**'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '**`mbstrings.h`**'
- en: 'mbsrdup: Interpret a sequence of bytes in *s* as mb string and convert it to
    a wide character string.'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 'mbsrdup: 将 *s* 中的字节序列解释为 mb 字符串，并将其转换为宽字符字符串。'
- en: '**Returns**: a newly malloc’ed wide character string of the appropriate length,
    `0` if an encoding error occurred.'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：一个新分配的适当长度的宽字符字符串，如果发生编码错误则返回 `0`。'
- en: '**Remarks**: This function can be integrated into a sequence of such searches
    through a string, as long as a *state* argument is passed to this function that
    is consistent with the mb character starting in *c*. The state itself is not modified
    by this function.'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**：此函数可以通过传递到该函数的与 *c* 中 mb 字符起始一致的 *state* 参数，集成到一系列对字符串的此类搜索中。该状态本身不会被此函数修改。'
- en: '*state* of `0` indicates that *s* can be scanned without considering any context.'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 状态的 `state` 表示可以不考虑任何上下文扫描 `s`。'
- en: '[PRE143]'
  id: totrans-1719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '|  |'
  id: totrans-1720
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This function returns a freshly allocated wcs with the same contents as the
    mbs s that it receives on input. Other than for the state parameter, its implementation
    is straightforward:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个新分配的具有与输入的 mbs s 相同内容的 wcs。除了状态参数外，其实现很简单：
- en: '**`mbstrings.c`**'
  id: totrans-1722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings.c`**'
- en: '[PRE144]'
  id: totrans-1723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: After determining the length of the target string, we use **malloc** to allocate
    space and **mbsrtowcs** to copy over the data.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目标字符串的长度后，我们使用 **malloc** 分配空间，并使用 **mbsrtowcs** 复制数据。
- en: 'To have more fine-grained control over the parsing of an mbs, the standard
    provides the function **mbrtowc**:'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精细地控制 mbs 的解析，标准提供了函数 **mbrtowc**：
- en: '[PRE145]'
  id: totrans-1726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'In this interface, parameter len denotes the maximal position in s that is
    scanned for a single multibyte character. Since in general we don’t know how such
    a multibyte encoding works on the target machine, we have to do some guesswork
    that helps us determine len. To encapsulate such a heuristic, we cook up the following
    interface. It has semantics similar to **mbrtowc** but avoids the specification
    of len:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 在此接口中，参数 len 表示在 s 中扫描单个多字节字符的最大位置。由于通常我们不知道这种多字节编码在目标机器上的工作方式，我们必须做一些有助于我们确定
    len 的猜测工作。为了封装这种启发式方法，我们制定了以下接口。它的语义类似于 **mbrtowc**，但避免了 len 的指定：
- en: '|  |'
  id: totrans-1728
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`mbstrings.h`**'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '**`mbstrings.h`**'
- en: 'mbrtow: Interpret a sequence of bytes in *c* as mb character and return that
    as wide character through *C*.'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 'mbrtow: 将 *c* 中的字节序列解释为 mb 字符，并通过 *C* 返回该宽字符。'
- en: '**Returns**: the length of the mb character or `-1` if an encoding error occured.'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**：mb 字符的长度，或者在发生编码错误时返回 `-1`。'
- en: This function can be integrated into a sequence of such searches through a string,
    as long as the same *state* argument passed to all calls to this or similar functions.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以通过将相同的 *state* 参数传递给所有调用此或类似函数的调用集成到一系列对字符串的此类搜索中。
- en: '**Remarks**: *state* of `0` indicates that *c* can be scanned without considering
    any context.'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**：`0` 状态的 `state` 表示可以不考虑任何上下文扫描 `c`。'
- en: '[PRE146]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '|  |'
  id: totrans-1735
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This function returns the number of bytes that were identified for the first
    multibyte character in the string, or `-1` on error. **mbrtowc** has another possible
    return value, `-2`, for the case that len wasn’t big enough. The implementation
    uses that return value to detect such a situation and to adjust len until it fits:'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回字符串中第一个多字节字符识别的字节数，或者在出错时返回 `-1`。**mbrtowc** 还有一个可能的返回值 `-2`，用于 len 不够大的情况。实现使用该返回值来检测这种情况并调整
    len，直到它适合：
- en: '**`mbstrings.c`**'
  id: totrans-1737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings.c`**'
- en: '[PRE147]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Here, **`MB_LEN_MAX`** is a standard value that is a good upper bound for len
    in most situations.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**`MB_LEN_MAX`** 是一个标准值，在大多数情况下是 len 的良好上限。
- en: 'Let us now go to a function that uses the capacity of mbrtow to identify mbc
    and to use that to search inside a mbs:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转到使用 mbrtow 的容量来识别 mbc 并使用它来搜索 mbs 的函数：
- en: '|  |'
  id: totrans-1741
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**`mbstrings.h`**'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: '**`mbstrings.h`**'
- en: 'mbsrwc: Interpret a sequence of bytes in *s* as mb string and search for wide
    character *C*.'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: mbsrwc：将 *s* 中的字节序列解释为 mb 字符串，并搜索宽字符 *C*。
- en: '**Returns**: the *occurrence’th* position in *s* that starts a mb sequence
    corresponding to *C* or `0` if an encoding error occurred.'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：*occurrence* 次出现在 *s* 中，该位置开始一个与 *C* 对应的 mb 序列，或者在发生编码错误时返回 `0`。'
- en: If the number of occurrences is less than *occurrence* the last such position
    is returned. So in particular using **`SIZE_MAX`** (or `-1`) will always return
    the last occurrence.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现次数少于 *occurrence*，则返回最后一个此类位置。因此，特别是使用 **`SIZE_MAX`**（或 `-1`）将始终返回最后一个出现位置。
- en: '**Remarks**: This function can be integrated into a sequence of such searches
    through a string, as long as the same *state* argument passed to all calls to
    this or similar functions and as long as the continuation of the search starts
    at the position that is returned by this function.'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: '**备注**：此函数可以通过将相同的 *状态* 参数传递给对这一或类似函数的所有调用，并且只要搜索的延续从该函数返回的位置开始，就可以将其集成到一系列字符串搜索中。'
- en: '*state* of `0` indicates that *s* can be scanned without considering any context.'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态* `0` 表示在无需考虑任何上下文的情况下，可以扫描 *s*。'
- en: '[PRE148]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '|  |'
  id: totrans-1749
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**`mbstrings.c`**'
  id: totrans-1750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`mbstrings.c`**'
- en: '[PRE149]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'As we said, all of this encoding with multibyte strings and simple IO works
    fine if we have an environment that is consistent: that is, if it uses the same
    multibyte encoding within your source code as for other text files and on your
    terminal. Unfortunately, not all environments use the same encoding yet, so you
    may encounter difficulties when transferring text files (including sources) or
    executables from one environment to another. In addition to the definition of
    the big character table, Unicode also defines three encodings that are now widely
    used and that hopefully will replace all others eventually: *UTF-8*, *UTF-16*,
    and *UTF-32*, for *U*nicode *T*ransformation *F*ormat with 8-bit, 16-bit, and
    32-bit words, respectively. Since C11, the C language includes rudimentary direct
    support for these encodings without having to rely on the locale. String literals
    with these encodings can be coded as u8"text", u"text", and U"text", which have
    types **`char`**`[]`, **`char16_t`**`[]`, and **`char32_t`**`[]`, respectively.'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，如果我们有一个一致的环境，所有这些多字节字符串和简单 IO 的编码都能正常工作：也就是说，如果它使用与源代码中相同的多字节编码，用于其他文本文件和终端。不幸的是，并非所有环境都使用相同的编码，因此在将文本文件（包括源文件）或可执行文件从一个环境传输到另一个环境时，您可能会遇到困难。除了大字符表的定义外，Unicode
    还定义了三种现在广泛使用的编码，并希望最终取代所有其他编码：*UTF-8*、*UTF-16* 和 *UTF-32*，分别对应于 8 位、16 位和 32 位的
    *U*nicode *T*ransformation *F*ormat。自 C11 以来，C 语言包括对这些编码的基本直接支持，而无需依赖于区域设置。具有这些编码的字符串字面量可以编码为
    u8"text"，u"text" 和 U"text"，它们分别具有类型 **`char`**`[]`、**`char16_t`**`[]` 和 **`char32_t`**`[]`。
- en: Chances are that the multibyte encoding on a modern platform is UTF-8, and then
    you won’t need these special literals and types. They are mostly useful in a context
    where you have to ensure one of these encodings, such as in network communication.
    Life on legacy platforms might be more difficult; see [http://www.nubaria.com/en/blog/?p=289](http://www.nubaria.com/en/blog/?p=289)
    for an overview for the Windows platform.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 现代平台上的多字节编码很可能是 UTF-8，因此您不需要这些特殊字面量和类型。它们主要用于需要确保这些编码的上下文中，例如在网络通信中。在旧平台上的生活可能更困难；有关
    Windows 平台的概述，请参阅 [http://www.nubaria.com/en/blog/?p=289](http://www.nubaria.com/en/blog/?p=289)。
- en: 14.4\. Binary streams
  id: totrans-1754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4\. 二进制流
- en: 'In [section 8.3](kindle_split_016.html#ch08lev1sec3), we briefly mentioned
    that input and output to streams can also be performed in *binary* mode in contrast
    to the usual *text mode* we have used up to now. To see the difference, remember
    that text mode IO doesn’t write the bytes that we pass to **printf** or **fputs**
    one-to-one to the target file or device:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8.3 节](kindle_split_016.html#ch08lev1sec3) 中，我们简要提到了与流输入和输出也可以在 *二进制* 模式下进行，这与我们迄今为止使用的通常的
    *文本* 模式不同。要了解差异，请记住，文本模式 IO 不会将我们传递给 **printf** 或 **fputs** 的字节一对一地写入目标文件或设备：
- en: Depending on the target platform, a '\n' character can be encoded as one or
    several characters.
  id: totrans-1756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据目标平台，`\n` 字符可以编码为一个或多个字符。
- en: Spaces that precede a newline can be suppressed.
  id: totrans-1757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以抑制在换行符之前的空间。
- en: Multibyte characters can be transcribed from the execution character set (the
    program’s internal representation) to the character set of the file system underlying
    the file.
  id: totrans-1758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多字节字符可以从执行字符集（程序的内部表示）转录到文件系统字符集。
- en: Similar observations hold for reading data from text files.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从文本文件读取数据也有类似的观察。
- en: If the data that we manipulate is effectively human-readable text, all of this
    is fine; we can consider ourselves happy that the IO functions together with **setlocale**
    make this mechanism as transparent as possible. But if we are interested in reading
    or writing binary data just as it is present in some C objects, this can be quite
    a burden and lead to serious difficulties. In particular, binary data could implicitly
    map to the end-of-line convention of the file, and thus a write of such data could
    change the file’s internal structure.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们操作的数据是有效的人类可读文本，所有这些都很好；我们可以认为自己很满意，因为 IO 函数与 **setlocale** 一起使这种机制尽可能透明。但如果我们对读取或写入与某些
    C 对象中存在的二进制数据完全相同的数据感兴趣，这可能会相当麻烦，并导致严重困难。特别是，二进制数据可能会隐式映射到文件的换行符约定，因此写入此类数据可能会改变文件的内部结构。
- en: As indicated previously, streams can be opened in binary mode. For such a stream,
    all the translation between the external representation in the file and the internal
    representation is skipped, and each byte of such a stream is written or read as
    such. From the interfaces we have seen up to now, only **fgetc** and **fputc**
    can handle binary files portably. All others may rely on some form of end-of-line
    transformation.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，流可以以二进制模式打开。对于这种流，跳过了文件外部表示和内部表示之间的所有转换，并且这样的流中的每个字节都按原样写入或读取。从我们现在看到的接口来看，只有
    **fgetc** 和 **fputc** 可以便携地处理二进制文件。所有其他函数可能依赖于某种形式的换行符转换。
- en: 'To read and write binary streams more easily, the C library has some interfaces
    that are better suited:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易地读取和写入二进制流，C 库有一些更适合的接口：
- en: '[PRE150]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The use of **fread** and **fwrite** is relatively straightforward. Each stream
    has a current *file position* for reading and writing. If successful, these two
    functions read or write size`*`nmemb bytes from that position onward and then
    update the file position to the new value. The return value of both functions
    is the number of bytes that have been read or written, usually size`*`nmemb, and
    thus an error occurred if the return value is less than that.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '**fread** 和 **fwrite** 的使用相对简单。每个流都有一个用于读取和写入的当前 *文件位置*。如果成功，这两个函数将从该位置开始读取或写入
    size`*`nmemb 字节，然后更新文件位置为新值。这两个函数的返回值是已读取或写入的字节数，通常是 size`*`nmemb，因此如果返回值小于这个值，则表示发生了错误。'
- en: 'The functions **ftell** and **fseek** can be used to operate on that file position:
    **ftell** returns the position in terms of bytes from the start of the file, and
    **fseek** positions the file according to the arguments offset and whence. Here,
    whence can have one of these values: **`SEEK_SET`** refers to the start of the
    file, and **`SEEK_CUR`** to the current file position before the call.^([[4](#ch14fn04)])'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 **ftell** 和 **fseek** 可以用来操作文件位置：**ftell** 返回从文件开始到当前位置的字节数，而 **fseek** 根据偏移量和
    whence 参数定位文件。在这里，whence 可以有以下这些值：**`SEEK_SET`** 指的是文件开始，而 **`SEEK_CUR`** 指的是调用之前的当前文件位置。[^4](#ch14fn04)
- en: ⁴
  id: totrans-1766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is also **`SEEK_END`** for the end-of-file position, but it may have platform-defined
    glitches.
  id: totrans-1768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样，也有 **`SEEK_END`** 用于文件末尾位置，但它可能存在平台定义的缺陷。
- en: By means of these four functions, we may effectively move forward and backward
    in a stream that represents a file and read or write any byte of it. This can,
    for example, be used to write out a large object in its internal representation
    to a file and read it in later with a different program, without performing any
    modifications.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这四个函数，我们可以有效地在表示文件的流中前后移动，并读取或写入其任何字节。例如，这可以用来将大对象以内部表示形式写入文件，稍后用不同的程序读取，而不进行任何修改。
- en: This interface has some restrictions, though. To work portably, streams have
    to be opened in binary mode. On some platforms, IO is *always* binary, because
    there is no effective transformation to perform. So, unfortunately, a program
    that does not use binary mode may work reliably on these platforms, but then fail
    when ported to others.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个接口有一些限制。为了便携性，流必须以二进制模式打开。在某些平台上，IO 总是二进制的，因为没有有效的转换要执行。所以，不幸的是，在这些平台上不使用二进制模式的程序可能运行可靠，但一旦移植到其他平台，就会失败。
- en: '|  |'
  id: totrans-1771
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.8
  id: totrans-1772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 14.8
- en: '*Open streams on which you use* **fread** *or* **fwrite** *in binary mode.*'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '*在二进制模式下使用 *fread* 或 *fwrite* 的打开流上。*'
- en: '|  |'
  id: totrans-1774
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Since this works with internal representations of objects, it is only portable
    between platforms and program executions that use that same representation: the
    same endian-ness. Different platforms, operating systems, and even program executions
    can have different representations.'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是与对象的内部表示一起工作的，因此它只能在具有相同表示（相同的字节序）的平台和程序执行之间移植：相同的端序。不同的平台、操作系统，甚至程序执行可以有不同的表示。
- en: '|  |'
  id: totrans-1776
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.9
  id: totrans-1777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.9
- en: '*Files that are written in binary mode are not portable between platforms.*'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: '*以二进制模式写入的文件在不同平台之间不可移植。*'
- en: '|  |'
  id: totrans-1779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The use of the type **`long`** for file positions limits the size of files that
    can easily be handled with **ftell** and **fseek** to **`LONG_MAX`** bytes. On
    most modern platforms, this corresponds to 2GiB.^([[[Exs 3]](#ch14fn-ex03)])
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型 **`long`** 表示文件位置限制了可以使用 **ftell** 和 **fseek** 容易处理的文件大小，限制为 **`LONG_MAX`**
    字节。在大多数现代平台上，这相当于 2GiB.^([[[Exs 3]](#ch14fn-ex03)])
- en: ^([Exs 3])
  id: totrans-1781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([Exs 3])
- en: ''
  id: totrans-1782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a function fseekmax that uses **`intmax_t`** instead of **`long`** and
    achieves large seek values by combining calls to **fseek**.
  id: totrans-1783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个名为 fseekmax 的函数，它使用 **`intmax_t`** 而不是 **`long`**，并通过组合对 **fseek** 的调用来实现大范围的查找值。
- en: '|  |'
  id: totrans-1784
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.10
  id: totrans-1785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Takeaway 14.10
- en: '**fseek** *and* **ftell** *are not suitable for very large file offsets.*'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '**fseek** 和 **ftell** 不适合用于非常大的文件偏移量。'
- en: '|  |'
  id: totrans-1787
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.5\. Error checking and cleanup
  id: totrans-1788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5. 错误检查和清理
- en: C programs can encounter a lot of error conditions. Errors can be programming
    errors, bugs in the compiler or OS software, hardware errors, in some cases resource
    exhaustion (such as out of memory), or any malicious combination of these. For
    a program to be reliable, we have to detect such error conditions and deal with
    them gracefully.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序可能会遇到许多错误条件。错误可能是编程错误、编译器或操作系统软件中的错误、硬件错误，在某些情况下是资源耗尽（例如内存不足），或者这些错误的任何恶意组合。为了使程序可靠，我们必须检测这些错误条件并以优雅的方式处理它们。
- en: 'As a first example, take the following description of a function fprintnumbers,
    which continues the series of functions that we discussed in [section 14.1](#ch14lev1sec1):'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，考虑以下函数 fprintnumbers 的描述，它继续了我们之前在 [14.1 节](#ch14lev1sec1)中讨论的函数系列：
- en: '|  |'
  id: totrans-1791
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`numberline.c`**'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: 'fprintnumbers: print a series of numbers *nums* on *stream*, using **printf**
    format *form*, separated by *sep* characters and terminated with a newline character.'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: fprintnumbers：在 *stream* 上打印一系列数字 *nums*，使用 **printf** 格式 *form*，由 *sep* 字符分隔，并以换行符结尾。
- en: 'Returns: the number of characters printed to *stream*, or a negative error
    value on error.'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值：打印到 *stream* 的字符数，或者在出错时返回负的错误值。
- en: If *len* is `0`, an empty line is printed and `1` is returned.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *len* 是 `0`，则打印一个空行并返回 `1`。
- en: 'Possible error returns are:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的错误返回值：
- en: '**`EOF`** (which is negative) if *stream* was not ready to be written to'
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`EOF`**（这是负值）如果 *stream* 没有准备好写入'
- en: '`-`**`EOVERFLOW`** if more than **`INT_MAX`** characters would have to be written,
    including the case that *len* is greater than **`INT_MAX`**.'
  id: totrans-1798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`**`EOVERFLOW`** 如果需要写入超过 **`INT_MAX`** 个字符，包括 *len* 大于 **`INT_MAX`** 的情况。'
- en: '`-`**`EFAULT`** if *stream* or *numb* are `0`'
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`**`EFAULT`** 如果 *stream* 或 *numb* 是 `0`'
- en: '`-`**`ENOMEM`** if a memory error occurred'
  id: totrans-1800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`**`ENOMEM`** 如果发生内存错误'
- en: This function leaves **`errno`** to the same value as occurred on entry.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将 **`errno`** 留在进入时的相同值。
- en: '[PRE151]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '|  |'
  id: totrans-1803
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As you can see, this function distinguishes four different error conditions,
    which are indicated by the return of negative constant values. The macros for
    these values are generally provided by the platform in `errno.h`, and all start
    with the capital letter E. Unfortunately, the C standard imposes only **`EOF`**
    (which is negative) and **`EDOM`**, **`EILSEQ`**, and **`ERANGE`**, which are
    positive. Other values may or may not be provided. Therefore, in the initial part
    of our code, we have a sequence of preprocessor statements that give default values
    for those that are missing:'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个函数区分了四种不同的错误条件，这些条件通过返回负的常量值来指示。这些值的宏通常由平台在 `errno.h` 中提供，并且所有都以大写字母
    E 开头。不幸的是，C 标准只提供了 **`EOF`**（这是负值）和 **`EDOM`**、**`EILSEQ`** 和 **`ERANGE`**，它们是正值。其他值可能提供也可能不提供。因此，在我们代码的初始部分，有一系列预处理语句为那些缺失的值提供了默认值：
- en: '|  |'
  id: totrans-1805
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`<errno.h>`'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '`<errno.h>`'
- en: '|  |'
  id: totrans-1807
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**`numberline.c`**'
  id: totrans-1808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE152]'
  id: totrans-1809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The idea is that we want to be sure to have distinct values for all of these
    macros. Now the implementation of the function itself looks as follows:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的情况是我们想要确保所有这些宏都有不同的值。现在函数的实现本身如下所示：
- en: '**`numberline.c`**'
  id: totrans-1811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE153]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Error handling pretty much dominates the coding effort for the whole function.
    The first three lines handle errors that occur on entry to the function and reflect
    missed preconditions or, in the language of Annex K (see [section 8.1.4](kindle_split_016.html#ch08lev2sec4)),
    *runtime constraint violations**^C*.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理几乎占用了整个函数的编码工作量。前三行处理函数进入时发生的错误，并反映了遗漏的先决条件，或者在附件K的语言中（见[第8.1.4节](kindle_split_016.html#ch08lev2sec4)），*运行时约束违规*^C*。
- en: 'Dynamic runtime errors are a bit more difficult to handle. In particular, some
    functions in the C library may use the pseudo-variable **`errno`** to communicate
    an error condition. If we want to capture and repair all errors, we have to avoid
    any change to the global state of the execution, including to **`errno`**. This
    is done by saving the current value on entry to the function and restoring it
    in case of an error with a call to the small function error_cleanup:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 动态运行时错误处理稍微困难一些。特别是，C库中的某些函数可能使用伪变量**`errno`**来传达错误条件。如果我们想捕获和修复所有错误，我们必须避免对执行的全局状态的任何更改，包括对**`errno`**的更改。这是通过在函数进入时保存当前值并在出错时通过调用小的函数error_cleanup来恢复它来实现的：
- en: '**`numberline.c`**'
  id: totrans-1815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE154]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The core of the function computes the total number of bytes that should be printed
    in a **`for`** loop over the input array. In the body of the loop, **snprintf**
    with two `0` arguments is used to compute the size for each number. Then our function
    sprintnumbers from [section 14.1](#ch14lev1sec1) is used to produce a big string
    that is printed using **fputs**.
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的核心计算在输入数组上的**`for`**循环中应该打印的总字节数。在循环体中，使用带有两个`0`参数的**snprintf**来计算每个数字的大小。然后，我们使用[第14.1节](#ch14lev1sec1)中的函数sprintnumbers来生成一个长字符串，该字符串使用**fputs**打印。
- en: Observe that there is no error exit after a successful call to **malloc**. If
    an error is detected on return from the call to **fputs**, the information is
    stored in the variable tot, but the call to **free** is not skipped. So even if
    such an output error occurs, no allocated memory is left leaking. Here, taking
    care of a possible IO error was relatively simple because the call to **fputs**
    occurred close to the call to **free**.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在成功调用**malloc**后没有错误退出。如果在调用**fputs**返回时检测到错误，信息将存储在变量tot中，但不会跳过对**free**的调用。因此，即使发生此类输出错误，也不会有分配的内存泄漏。在这里，处理可能的IO错误相对简单，因为**fputs**的调用接近**free**的调用。
- en: 'The function fprintnumbers_opt requires more care:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 函数fprintnumbers_opt需要更加小心：
- en: '**`numberline.c`**'
  id: totrans-1820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**`numberline.c`**'
- en: '[PRE155]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: It tries to optimize the procedure even further by printing the numbers immediately
    instead of counting the required bytes first. This may encounter more error conditions
    as we go, and we have to take care of them by guaranteeing to issue a call to
    **free** at the end. The first such condition is that the buffer we allocated
    initially is too small. If the call to **realloc** to enlarge it fails, we have
    to retreat carefully. The same is true if we encounter the unlikely condition
    that the total length of the string exceeds **`INT_MAX`**.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图通过立即打印数字而不是先计算所需的字节数来进一步优化程序。这可能会遇到更多的错误条件，我们必须通过保证在最后发出对**free**的调用来处理它们。第一个这样的条件是我们最初分配的缓冲区太小。如果调用**realloc**来扩大它失败，我们必须谨慎撤退。同样，如果我们遇到不太可能的条件，即字符串的总长度超过**`INT_MAX`**，也是如此。
- en: 'In both cases, the function uses **`goto`**, to jump to the cleanup code that
    then calls **free**. With C, this is a well-established technique that ensures
    that the cleanup takes place and that also avoids hard-to-read nested **`if`**`-`**`else`**
    conditions. The rules for **`goto`** are relatively simple:'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，函数使用**`goto`**跳转到清理代码，然后调用**free**。在C语言中，这是一个成熟的技巧，确保清理发生，同时也避免了难以阅读的嵌套**`if`**`-`**`else`**条件。**`goto`**的规则相对简单：
- en: '|  |'
  id: totrans-1824
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.11
  id: totrans-1825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 14.11
- en: '*Labels for* **`goto`** *are visible in the entire function that contains them.*'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签* **`goto`** *在整个包含它们的函数中都是可见的*。'
- en: '|  |'
  id: totrans-1827
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1828
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.12
  id: totrans-1829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 14.12
- en: '**`goto`** *can only jump to a label inside the same function.*'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: '**`goto`** *只能跳转到同一函数内的标签*。'
- en: '|  |'
  id: totrans-1831
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1832
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Takeaway 14.13
  id: totrans-1833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要 14.13
- en: '**`goto`** *should not jump over variable initializations.*'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: '**`goto`** *不应跳过变量初始化*。'
- en: '|  |'
  id: totrans-1835
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The use of **`goto`** and similar jumps in programming languages has been subject
    to intensive debate, starting from an article by Dijkstra [[1968](kindle_split_036.html#bib3)].
    You will still find people who seriously object to code as it is given here, but
    let us try to be pragmatic about that: code with or without **`goto`** can be
    ugly and hard to follow. The main idea is to have the “normal” control flow of
    the function be mainly undisturbed and to clearly mark changes to the control
    flow that only occur under exceptional circumstances with a **`goto`** or **`return`**.
    Later, in [section 17.5](kindle_split_028.html#ch17lev1sec5), we will see another
    tool in C that allows even more drastic changes to the control flow: **setjmp**`/`**longjmp**,
    which enables us to jump to other positions on the stack of calling functions.'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言中使用**`goto`**和类似跳转的方式一直备受争议，始于迪杰斯特拉的一篇文章[[1968](kindle_split_036.html#bib3)]。你仍然会找到一些人严重反对这里给出的代码，但让我们尽量务实：带或不带**`goto`**的代码可能都很丑陋且难以理解。主要思想是让函数的“正常”控制流主要不受干扰，并且用**`goto`**或**`return`**清楚地标记仅在异常情况下发生的控制流变化。稍后，在[第
    17.5 节](kindle_split_028.html#ch17lev1sec5)中，我们将看到 C 语言中另一个允许对控制流进行更剧烈更改的工具：**setjmp**`/`**longjmp**，它使我们能够跳转到调用函数堆栈上的其他位置。
- en: '|  |'
  id: totrans-1837
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Text processing in streams**'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: '**流中的文本处理**'
- en: For text processing in streams, can you read on **`stdin`**, dump modified text
    on **`stdout`**, and report diagnostics on **`stderr`**? Count the occurrences
    of a list of words? Count the occurrences of a regexp? Replace all occurrences
    of a word with another?
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 对于流中的文本处理，你能从**`stdin`**读取，将修改后的文本输出到**`stdout`**，并在**`stderr`**上报告诊断信息？计算单词列表的出现次数？计算正则表达式的出现次数？将一个单词的所有出现替换为另一个单词？
- en: '|  |'
  id: totrans-1840
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1841
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Text processor sophistication**'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本处理器复杂性**'
- en: Can you extend your text processor ([challenge 12](kindle_split_021.html#ch11sb01))
    to use multibyte characters?
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 你能扩展你的文本处理器([挑战 12](kindle_split_021.html#ch11sb01))以使用多字节字符吗？
- en: Can you also extend it to do regular expression processing, such as searching
    for a word, running a simple query-replace of one word against another, performing
    a query-replace with a regex against a specific word, and applying regexp grouping?
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 你也能扩展它以进行正则表达式处理，例如搜索一个单词，执行一个单词对另一个单词的简单查询替换，使用正则表达式对特定单词进行查询替换，以及应用正则表达式分组？
- en: '|  |'
  id: totrans-1845
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-1846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: The C library has several interfaces for text processing, but we must be careful
    about **`const`**-qualification and buffer overflow.
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 库有多个用于文本处理的接口，但我们必须注意**`const`**-资格和缓冲区溢出。
- en: Formatted input with **scanf** (and similar) has subtle issues with pointer
    types, null termination of strings, white space, and new-line separation. If possible,
    you should use the combination of **fgets** with **strtod** or similar, more specialized,
    functions.
  id: totrans-1848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**scanf**（和类似函数）进行格式化输入时，指针类型、字符串的空终止符、空白和换行分隔等问题可能很微妙。如果可能，你应该使用**fgets**与**strtod**或类似更专业的函数的组合。
- en: Extended character sets are best handled by using multibyte strings. With some
    caution, these can be used much like ordinary strings for input and output.
  id: totrans-1849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展字符集最好通过使用多字节字符串来处理。在谨慎使用的情况下，它们可以像普通字符串一样用于输入和输出。
- en: Binary data should be written to binary files by using **fwrite** and **fread**.
    Such files are platform dependent.
  id: totrans-1850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应使用**fwrite**和**fread**将二进制数据写入二进制文件。这些文件是平台相关的。
- en: Calls to C library functions should be checked for error returns.
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 C 库函数时应该检查错误返回值。
- en: Handling error conditions can lead to complicated case analysis. It can be organized
    by a function-specific code block to which we jump with **`goto`** statements.
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误条件可能导致复杂的案例分析。可以通过特定函数的代码块来组织，我们通过**`goto`**语句跳转到该代码块。
