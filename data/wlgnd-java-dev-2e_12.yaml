- en: 9 Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 Kotlin
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why use Kotlin?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Kotlin？
- en: Convenience and conciseness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便性和简洁性
- en: Safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Java interoperability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java互操作性
- en: Kotlin is a language created by JetBrains ([https://jetbrains.com](https://jetbrains.com)),
    makers of the popular IntelliJ IDEA. Announced publicly in 2011, Kotlin aims to
    fill language gaps they felt developing in Java, without the friction they saw
    with other existing JVM languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是由JetBrains（[https://jetbrains.com](https://jetbrains.com)）创建的语言，JetBrains是流行的IntelliJ
    IDEA的制造商。2011年公开宣布，Kotlin旨在填补他们在Java开发中感到的语言空白，而没有看到其他现有JVM语言中的摩擦。
- en: Kotlin was open sourced the following year and reached 1.0—with guaranteed levels
    of support and maintenance from JetBrains—in 2016\. Since then, it has gone on
    to become the recommended language for the Android platform and has gathered a
    solid following in other JVM coding circles. The Kotlin Foundation, announced
    in 2018, brings the support of both JetBrains and Google to the language for the
    long term. Kotlin is even reaching beyond the JVM to support JavaScript and native
    backends.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin在次年开源，并在2016年达到了1.0版本——由JetBrains提供保证的支持和维护水平。从那时起，它已成为Android平台的推荐语言，并在其他JVM编码圈子中积累了坚实的支持。2018年宣布的Kotlin基金会，为语言带来了JetBrains和Google的长期支持。Kotlin甚至超越了JVM，以支持JavaScript和本地后端。
- en: 9.1 Why use Kotlin?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 为什么使用Kotlin？
- en: As alternate languages go, Kotlin provides many quality of life improvements
    over Java, while not radically changing the entire world. Its focus on convenience,
    safety, and solid interoperability has given it a great story for incremental
    usage in existing Java projects. With first-class support in IntelliJ IDEA, turning
    a file from Java to Kotlin is often just a click away.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代语言，Kotlin在Java之上提供了许多生活质量的改进，而不会彻底改变整个世界。它对便利性、安全性和良好互操作性的关注，为在现有Java项目中增量使用提供了很好的故事。在IntelliJ
    IDEA中，将文件从Java转换为Kotlin通常只需点击一下。
- en: It’s worth noting that some features originally available only in Kotlin have
    made their way back into Java. A great example of this is Kotlin script—Kotlin
    can run a source file directly, typically with the `kts` extension, without the
    developer asking to compile it. If this sounds like Java 11’s single-file feature
    that we showed off in chapter 1, you’re not wrong!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一些最初仅在Kotlin中可用的功能已经回到了Java中。一个很好的例子是Kotlin脚本——Kotlin可以直接运行源文件，通常带有`kts`扩展名，而无需开发者请求编译它。如果这听起来像我们在第1章中展示的Java
    11的单文件功能，你并没有错！
- en: Following this chapter, we will use our new familiarity with Kotlin in chapter
    11 as the main scripting language for our builds with Gradle. It will also be
    revisited in chapter 15 where we examine functional programming on the JVM, and
    in chapter 16 where Kotlin’s built-in coroutine mechanism provides a compelling
    alternative to classical multithreading in Java. Let’s start seeing what Kotlin
    can provide for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们将利用对Kotlin的新熟悉程度，在11章中将Kotlin作为构建Gradle项目的主要脚本语言。它也将在15章中再次被提及，届时我们将探讨JVM上的函数式编程，以及在16章中，Kotlin内置的协程机制为Java中的经典多线程提供了一个令人信服的替代方案。让我们开始看看Kotlin能为我们提供什么。
- en: 9.1.1 Installing
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 安装
- en: If you use IntelliJ IDEA, Kotlin is provided via a plugin. With that installed,
    you can start writing code in Kotlin straight away, just like any other supported
    language in the IDE.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用IntelliJ IDEA，Kotlin通过插件提供。安装后，你就可以开始用Kotlin编写代码了，就像在IDE中支持的其他任何语言一样。
- en: For those who are more inclined to bare-bones setups, Kotlin also provides a
    command-line compiler (`kotlinc`) (see [http://mng.bz/YGoa](http://mng.bz/YGoa))
    and interactive shell (`kotlin`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更倾向于裸机设置的人来说，Kotlin还提供了一个命令行编译器(`kotlinc`)（见[http://mng.bz/YGoa](http://mng.bz/YGoa)）和交互式外壳(`kotlin`)。
- en: Adding Kotlin to an existing project requires updating your build scripts. Chapter
    11 will get you more familiar with these systems, but for now, you can refer to
    Kotlin’s excellent documentation to get you started with either Maven ([http://mng.bz/GEYJ](http://mng.bz/GEYJ))
    or Gradle ([http://mng.bz/z4vA](http://mng.bz/z4vA)). With Kotlin ready to run,
    a good place to start exploring is in how its basic features work and improve
    on Java.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将Kotlin添加到现有项目需要更新您的构建脚本。第11章将使您更熟悉这些系统，但到目前为止，您可以参考Kotlin的优秀文档，以Maven([http://mng.bz/GEYJ](http://mng.bz/GEYJ))或Gradle([http://mng.bz/z4vA](http://mng.bz/z4vA))开始。Kotlin准备好运行后，开始探索的好地方是了解其基本功能是如何工作和改进Java的。
- en: 9.2 Convenience and conciseness
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 方便性和简洁性
- en: Java has a reputation for being verbose. Although it retains a lot of visual
    similarity with Java, Kotlin relentlessly streamlines the code you have to write.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java 以冗长著称。尽管它与 Java 保持了很多视觉上的相似性，但 Kotlin 不懈地简化了您必须编写的代码。
- en: 9.2.1 Starting with less
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 从更少开始
- en: One example of its streamlined nature is the simple character, the semicolon.
    Kotlin doesn’t require semicolons for line ending, allowing the typical newlines
    to stand in their place. Semicolons are allowed—and, in fact, required if you
    want to put multiple statements on a single line, for instance—but most often,
    they aren’t needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其简化性质的一个例子是简单的字符，分号。Kotlin 不需要分号来表示行结束，允许典型的换行符代替。分号是允许的——实际上，如果您想在单行上放置多个语句，例如，则必须使用分号——但大多数情况下并不需要。
- en: 'Kotlin took advantage of its blank slate to alter other defaults that would
    be difficult to change in Java. Although Java imports only `java.lang` by default,
    Kotlin provides the following packages everywhere:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 利用其空白状态来改变其他在 Java 中难以更改的默认设置。尽管 Java 默认只导入 `java.lang`，但 Kotlin 在任何地方都提供了以下包：
- en: '`java.lang.*`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.*`'
- en: '`kotlin.*`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.*`'
- en: '`kotlin.annotation.*`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.annotation.*`'
- en: '`kotlin.collections.*`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.collections.*`'
- en: '`kotlin.comparisons.*`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.comparisons.*`'
- en: '`kotlin.io.*`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.io.*`'
- en: '`kotlin.ranges.*`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.ranges.*`'
- en: '`kotlin.sequences.*`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.sequences.*`'
- en: '`kotlin.text.*`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.text.*`'
- en: '`kotlin.jvm.*`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kotlin.jvm.*`'
- en: It’s the rare program that doesn’t need Collections, text, or IO, so these inclusions
    save a lot of needless importing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有程序不需要集合、文本或 IO，因此这些包含节省了很多不必要的导入。
- en: A spot where Java’s verbosity often shows up is with types—and we saw in chapter
    1 how the `var` keyword cuts down on repetition of type information. Kotlin has
    had this style of type inference since the beginning, although it is far from
    the only source for the idea.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的冗长性通常在类型上体现出来——我们在第 1 章中看到 `var` 关键字如何减少类型信息的重复。Kotlin 从一开始就采用了这种类型推断的风格，尽管这并不是唯一的思想来源。
- en: 9.2.2 Variables
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 变量
- en: 'When introducing a variable, Kotlin even uses the same keyword as newer Java
    releases: `var`. It will infer from the expression on the right-hand side what
    type to use for the variable, as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当引入变量时，Kotlin 甚至使用了与较新 Java 版本相同的关键字：`var`。它将从右侧的表达式推断出变量的类型，如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ i is of type kotlin.Int.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ i 是 `kotlin.Int` 类型。
- en: ❷ s is of type kotlin.String.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ s 是 `kotlin.String` 类型。
- en: 'Unlike Java, though, in Kotlin `var` is not just a shortcut. If you want to
    explicitly call out the type of the variable, `var` remains, but the type is added
    after the variable name, as shown in the next code snippet. This is sometimes
    referred to as a *type hint* :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 不同的是，在 Kotlin 中 `var` 不仅仅是一个快捷方式。如果您想显式地指出变量的类型，`var` 仍然存在，但类型被添加到变量名称之后，如下面的代码片段所示。这有时被称为
    *类型提示*：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ This assignment will fail with a compile error, error: type mismatch: inferred
    type is String but Int was expected.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此赋值将因编译错误而失败，错误：类型不匹配：推断类型为 String 但期望 Int。
- en: 'In Kotlin, `var` has a friend in the `val` keyword. Variables declared with
    `val` are immutable and cannot be written after assignment. It’s the equivalent
    of `final var` in Java—a highly recommended default for any variable that isn’t
    expected to be reassigned. Kotlin nicely makes this safer setting just as concise
    as the mutable alternative, as illustrated here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`var` 有一个伙伴，即 `val` 关键字。使用 `val` 声明的变量是不可变的，并且在赋值后不能被写入。这相当于 Java
    中的 `final var`——对于任何不期望重新分配的变量来说，这是一个高度推荐默认设置。Kotlin 优雅地将这种更安全的设置与可变替代方案一样简洁，如下所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Reassignment is allowed to var variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许对 `var` 变量进行重新赋值。
- en: '❷ Compile error, error: val cannot be reassigned.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 编译错误，错误：`val` 不能重新赋值。
- en: '`var` and `val` are used consistently through Kotlin for variables and arguments.
    The theme of favoring immutability by default is also a key design factor in Kotlin
    that we’ll see time and again throughout the language.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`var` 和 `val` 一致地用于变量和参数。默认倾向于不可变性的主题也是 Kotlin 的一个关键设计因素，我们将在整个语言中反复看到这一点。
- en: Once we have variables it’s natural to want to compare them. Kotlin has some
    fresh help to give us on equality that’s worth knowing about.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了变量，自然就想比较它们。Kotlin 在相等性方面提供了一些新的帮助，这是值得了解的。
- en: 9.2.3 Equality
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.3 相等性
- en: 'A common mistake in many Java programs is shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Java 程序中常见的错误如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Receives a string from somewhere. Note that string literals may actually be
    interned to the same object, giving a false sense of security in the incorrect
    comparison.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从某处接收一个字符串。注意，字符串字面量实际上可能被内部化到同一个对象中，这可能会在错误的比较中产生一种错误的安全感。
- en: ❷ Not reached, even when same value but separate references are used
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 即使使用相同的值但不同的引用，也不会到达这里
- en: We quickly learn that `==` in Java compares *references*, not *values*, so this
    doesn’t do what you’d expect from many other languages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会了解到 Java 中的 `==` 比较的是 *引用*，而不是 *值*，所以这不会像许多其他语言那样做你所期望的事情。
- en: 'Kotlin eliminates this quirk and treats `==` as value equality on common types
    such as `String`. Effectively, calls to `==` are equivalent to a `null`-safe call
    to `equals`. This optimizes for the more common programming case and avoids a
    huge cause of errors in Java programming, as shown next:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 消除了这个怪癖，并将 `==` 作为 `String` 等常见类型的值相等性处理。实际上，对 `==` 的调用相当于对 `equals`
    的安全调用。这优化了更常见的编程情况，并避免了 Java 编程中一个巨大的错误原因，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Will be reached if the value of s is “A value”
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 s 的值为“一个值”，则会到达这里
- en: On rare occasions, you may still have reason to compare references. When those
    cases arise, Kotlin’s `===` (and its pair `!==`) gives you the behavior Java used
    for `==` and `!=`. Comparing variables is important, but you won’t get far without
    needing to call other code or define your own subroutines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，你可能仍然有理由比较引用。当这些情况出现时，Kotlin 的 `===`（及其配对 `!==`）提供了 Java 中 `==` 和 `!=`
    的行为。比较变量很重要，但如果你不调用其他代码或定义自己的子程序，你不会走得很远。
- en: 9.2.4 Functions
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.4 函数
- en: Sometimes when speaking, we use the terms “function” and “method” interchangeably,
    but, in fact, Java only has methods—you can’t define a reusable block of code
    outside of the context of a class. Although Kotlin supports all the object-oriented
    goodness of Java—we’ll see it in an upcoming section—it also recognizes that sometimes
    you just want a function by itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在说话时，我们会互换使用“函数”和“方法”这两个术语，但实际上，Java 只有方法——你无法在类的作用域之外定义可重用的代码块。尽管 Kotlin
    支持所有 Java 的面向对象优点——我们将在下一节中看到——但它也认识到有时你可能只需要一个单独的函数。
- en: 'Keeping to Kotlin’s principle of conciseness, a minimal function definition
    looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 Kotlin 的简洁原则，一个最小化的函数定义看起来像这样：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ fun defines a function in Kotlin. We’ll see it again when we get to defining
    methods attached to classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `fun` 在 Kotlin 中定义一个函数。当我们到达定义与类相关联的方法时，我们还会再次看到它。
- en: This looks a little different than the Java way of doing things, but it is still
    fairly recognizable. Apart from the `fun` keyword to start the declaration, the
    biggest difference is the lack of return type. In Kotlin if your function doesn’t
    return anything, rather than stating `void` explicitly, you can say nothing, and
    the return type is treated as `Unit` (Kotlin’s way of saying “no return value”).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与 Java 的做法略有不同，但仍然相当容易辨认。除了用于开始声明的 `fun` 关键字之外，最大的区别是缺少返回类型。在 Kotlin 中，如果你的函数不返回任何内容，而不是明确地声明
    `void`，你可以说 nothing，返回类型将被视为 `Unit`（Kotlin 表示“没有返回值”的方式）。
- en: 'If we do want to return a value, we must state that directly, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实想返回一个值，我们必须直接声明，如下所示：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Declares that our function returns type Boolean
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明我们的函数返回类型为 Boolean
- en: ❷ Returns our success
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回我们的成功
- en: 'Functions aren’t much use without taking arguments. Kotlin’s syntax for that
    looks much like variable declaration, shown next:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数如果没有参数就没有太大用处。Kotlin 用于此的语法与变量声明类似，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Our function now takes a single argument of type Int.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的功能现在接受一个类型为 Int 的单个参数。
- en: ❷ Arguments appear within the function like locally defined variables. Here
    we use one in Kotlin’s handy string interpolation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 参数在函数中像局部定义的变量一样出现。这里我们使用了 Kotlin 的便捷字符串插值。
- en: 'Even the simple function definition in Kotlin has a few tricks up its sleeve,
    though. Sometimes the order of arguments to a function can be unclear, particularly
    when types match between arguments, as in the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是 Kotlin 中简单的函数定义也有一些技巧。有时函数参数的顺序可能不清楚，尤其是当参数类型相同时，如下例所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we call this function, we have to remember the order of the arguments—`x`
    comes before `y`—or risk a bug. Kotlin solves this with *named arguments*, shown
    next:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们必须记住参数的顺序——`x` 在 `y` 之前——否则可能会出现错误。Kotlin 通过 *命名参数* 解决了这个问题，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Normal positional call to the function
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对函数的正常位置调用
- en: ❷ This call has the same result despite reordering because we name the arguments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尽管重新排序，但这个调用仍然有相同的结果，因为我们命名了参数。
- en: Note Named arguments can’t be used when calling Java functions or, conversely,
    when calling a Kotlin function from Java. The names of arguments aren’t preserved
    in the bytecode to allow this. Also, altering argument names can be considered
    a breaking API change in Kotlin code, where in Java, only changes to type, number,
    or ordering of arguments will cause trouble.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在调用 Java 函数或相反，从 Java 调用 Kotlin 函数时，不能使用命名参数。参数的名称在字节码中不被保留，以允许这样做。此外，更改参数名称在
    Kotlin 代码中可能被视为破坏性 API 变更，而在 Java 中，只有类型、参数数量或顺序的改变会引起问题。
- en: 'Sometimes it’s not necessary to pass all arguments to a function— reasonable
    defaults exist. In Java we accommodate this with multiple method overloads taking
    varying sets of arguments. Although this is supported in Kotlin too, we can use
    a more direct approach for default values, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时没有必要将所有参数传递给函数——存在合理的默认值。在 Java 中，我们通过具有不同参数集的多重方法重载来适应这种情况。尽管 Kotlin 也支持这一点，但我们可以使用更直接的方法来设置默认值，如下所示：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ retry in the function is false, thanks to the default value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 函数中的重试默认值为 false，这是由于默认值的原因。
- en: Instead of needing to provide two definitions of `callOtherServices`—one with
    a single argument, another with the two—we can keep all the related bits in one
    function without boilerplate.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要提供两个 `callOtherServices` 的定义——一个带有单个参数，另一个带有两个——我们可以将所有相关部分保留在一个函数中，而不需要样板代码。
- en: 'Another common case that Kotlin provides syntax for is single-line functions,
    as shown in the following code. These provide encapsulation and a name to a particular
    calculation or check. Kotlin supports this as part of its trend toward conciseness
    via an alternate declaration for such short functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了语法支持的单行函数是另一种常见情况，如下面的代码所示。这些函数提供了封装，并为特定的计算或检查提供了一个名称。Kotlin 通过为这样的短函数提供另一种声明方式，支持这一简洁趋势：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This format is shorter not only for the lack of curly braces in favor of the
    single `=` but also because of type inference. Return types may be excluded, and
    Kotlin will infer the type of the expression automatically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式不仅因为省略了花括号而更短，也因为类型推断。可以省略返回类型，Kotlin 会自动推断表达式的类型。
- en: This feature hints at a deeper part of Kotlin’s design, which is its support
    for *first-class functions*. Functions in Kotlin may be passed as arguments, stored
    in variables and properties, and returned from other functions. Although Kotlin
    isn’t considered a functional programming language, support for first-class functions
    allows Kotlin to benefit from many common patterns in functional programming.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一特性暗示了 Kotlin 设计的更深层部分，即其对 *一等函数* 的支持。Kotlin 中的函数可以作为参数传递，存储在变量和属性中，并从其他函数中返回。尽管
    Kotlin 并不被视为函数式编程语言，但对一等函数的支持使 Kotlin 能够从函数式编程的许多常见模式中受益。
- en: 'Assigning a function to a variable can take a few different forms, depending
    on the source of your function. If we’ve previously declared the function, we
    can use the `::` operator to reference it by name:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数分配给变量可以采取几种不同的形式，具体取决于函数的来源。如果我们之前已经声明了函数，我们可以使用 `::` 操作符通过名称来引用它：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Kotlin also has *lambda expression* syntax to create an anonymous function
    on the fly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还具有 *lambda 表达式* 语法，可以即时创建匿名函数：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Regardless of how it was assigned, references to functions can be invoked as
    if the variable name were the function’s own name. Alternatively, an `invoke`
    function is available, as illustrated here, if that’s clearer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何分配，函数引用可以像变量名一样调用函数本身。或者，如果这样更清晰，可以使用 `invoke` 函数，如下所示：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Runs our previously fun declared checkCondition captured in the check variable
    and prints true
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行之前在 `checkCondition` 变量中声明的 fun 声明的检查条件，并打印 true
- en: ❷ Runs our lambda to see if we’re greater than 100 and prints false
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行我们的 lambda 来查看我们是否大于 100 并打印 false
- en: We’re not limited to assigning functions to local variables. We can pass them
    to other functions as arguments like any other value. This is one of the key properties
    of languages with first-class functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于将函数分配给局部变量。我们可以像传递任何其他值一样将它们作为参数传递给其他函数。这是具有一等函数的语言的关键特性之一。
- en: 'As we’ve seen previously, Kotlin requires arguments to declare their type.
    Functions are no exception, and there’s a specific syntax for expressing the type
    of functions, shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Kotlin 要求声明参数的类型。函数也不例外，并且有特定的语法来表示函数的类型，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ callsAnother takes an argument that is a function taking an Int and returning
    nothing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `callsAnother` 函数接受一个参数，该参数是一个接受 Int 并不返回任何内容的函数。
- en: ❷ callsAnother invokes the function it is passed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ callsAnother调用它接收到的函数。
- en: ❸ We can invoke callsAnother, passing a lambda whose function type matches.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们可以调用callsAnother，传递一个与函数类型匹配的lambda。
- en: A function type is composed of two parts separated by an `->`—its list of arguments
    in `()` and the return type. The list of argument types can be empty, but the
    return type cannot be excluded. If the function you are passing doesn’t return
    anything, its type must be specified as `Unit`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型由两部分组成，由`->`分隔——它的参数列表在`()`中，以及返回类型。参数类型的列表可以是空的，但返回类型不能省略。如果你传递的函数不返回任何内容，其类型必须指定为`Unit`。
- en: Note When a lambda takes a single argument and the type can be inferred, the
    identifier `it` can be used, excluding the need both for a specific name and for
    the `->` at the start of the lambda.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当一个lambda只接受一个参数且类型可以推断时，可以使用标识符`it`，无需指定特定的名称，也不需要在lambda的开始处使用`->`。
- en: 'Function arguments must specify the types they expect callers to pass, but
    Kotlin does save some typing for the caller by applying type inference to lambdas.
    The following are all allowed forms of our earlier invocation of `callsAnother`
    with progressively less and less explicit typing:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数必须指定它们期望调用者传递的类型，但Kotlin通过将类型推断应用于lambda来为调用者节省一些打字。以下都是我们之前对`callsAnother`的调用允许的形式，类型指定越来越不明确：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The original invocation of callsAnother with our lambda types fully specified
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用完全指定的lambda类型调用callsAnother的原始调用
- en: ❷ Kotlin can infer that n must be an Int because that’s what callsAnother needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Kotlin 可以推断出n必须是Int类型，因为调用another需要的就是这个类型。
- en: ❸ The pattern of passing a single parameter to lambda is so common that Kotlin
    provides special support with an implicit it parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将单个参数传递给lambda的模式非常常见，以至于Kotlin提供了特殊的支持，即隐式的it参数。
- en: 'Kotlin has one more trick when passing lambdas as arguments. If a function
    call’s last argument is a lambda, that lambda may appear after the parentheses.
    If the only argument to a function is a lambda, you don’t even have to use parentheses
    at all! The following three calls are all identical:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 在传递lambda作为参数时还有一个技巧。如果一个函数调用的最后一个参数是一个lambda，那么这个lambda可以出现在括号之后。如果一个函数的唯一参数是一个lambda，你甚至可以完全不用括号！以下三个调用都是相同的：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ll dig into more details of functional programming with Kotlin in chapter
    15, but let’s now look at how Kotlin puts all this functional goodness to use
    in improving a point of frequent discontent in Java—Collections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第15章深入探讨Kotlin的函数式编程的更多细节，但现在让我们看看Kotlin是如何利用所有这些函数式优点来改善Java中常见的痛点——集合。
- en: 9.2.5 Collections
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.5 集合
- en: Collections are one of the most common data structures in programs. Java’s standard
    Collection library, from the earliest versions, has provided a lot of power and
    flexibility. But constraints of both the language and backward compatibility often
    end up with more verbose, ceremony-laden code, especially when compared to scripting
    languages like Python or functional languages like Haskell. Recent Java releases
    have improved the situation dramatically—see chapter 1’s coverage of Collections
    factories and appendix B for streams—but difficulties from Java’s original collection
    design remain with us today.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是程序中最常见的几种数据结构之一。Java的标准集合库，从最早的版本开始，就提供了大量的功能和灵活性。但是，语言本身的限制和向后兼容性通常会导致代码更加冗长，仪式感更强，尤其是在与Python这样的脚本语言或Haskell这样的函数式语言相比时。最近的Java版本大大改善了这种情况——参见第1章对集合工厂的介绍和附录B中的流——但Java原始集合设计中的困难仍然存在。
- en: 'Naturally, Kotlin learned from these mistakes and from day one had a seamless
    collection experience. Standard functions, shown next, have always existed in
    Kotlin for creating the most common types of Collections—a feature that arrived
    in Java only with version 9:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，Kotlin从这些错误中吸取了教训，并且从第一天起就提供了无缝的集合体验。下面展示的标准函数，在Kotlin中一直存在，用于创建最常见的集合类型——这是一个在Java中直到版本9才出现的特性：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Create lists with the inferred types kotlin.collections.List<String> and kotlin.collections.MutableList<String>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用推断的类型kotlin.collections.List<String>和kotlin.collections.MutableList<String>创建列表
- en: ❷ Create maps with the inferred types kotlin .collections.Map<String, Int> and
    kotlin.collections .MutableMap<String, Int>. Note the built-in syntax for defining
    maps with the to keyword.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用推断的类型kotlin.collections.Map<String, Int>和kotlin.collections.MutableMap<String,
    Int>创建映射。注意使用to关键字定义映射的内置语法。
- en: ❸ Create sets with the inferred types kotlin.collections.Set<String> and kotlin.collections.MutableSet<String>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建具有推断类型`kotlin.collections.Set<String>`和`kotlin.collections.MutableSet<String>`的集合
- en: The default functions return read-only copies of their Collections—a great default
    choice for performance and correctness. You have to explicitly ask for the `mutable`
    flavor to get a Collection with the interfaces for modification. Kotlin again
    aims to protect you from whole classes of bugs by nudging your code toward immutability
    as the easier, shorter option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认函数返回其集合的只读副本——这对于性能和正确性来说是一个非常好的默认选择。你必须明确要求`mutable`版本才能得到一个具有修改接口的集合。Kotlin再次旨在通过将代码推向不可变性作为更简单、更短的选择来保护你免受整个类别的错误。
- en: You may have noted that the inferred types for these Collections differ from
    the standard Java counterparts—though similarly named, they live in the `kotlin.collections`
    package. Kotlin defines its own hierarchy of collection interfaces, as shown in
    figure 9.1, but, under the covers, reuses the implementations from the JDK. This
    allows for cleaner APIs with the `kotlin.collections` interfaces, while preserving
    the ability to pass our Collections across to Java code, because the implementations
    also support the `java .util` collection interfaces.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这些集合的推断类型与标准Java对应项不同——尽管名称相似，但它们位于`kotlin.collections`包中。Kotlin定义了自己的集合接口层次结构，如图9.1所示，但在底层，它重新使用了JDK的实现。这允许使用`kotlin.collections`接口提供更干净的API，同时保留将我们的集合传递到Java代码中的能力，因为实现也支持`java.util`集合接口。
- en: '![](../Images/CH09_F02_Evans2.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH09_F02_Evans2.png)'
- en: Figure 9.1 Kotlin Collection hierarchy
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 Kotlin集合层次结构
- en: 'These Collections participate in all the standard Java interfaces and patterns.
    You can iterate over them with `for ... in` as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合参与所有标准的Java接口和模式。你可以使用`for ... in`来迭代它们，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, the `for` loop to iterate over a Collection is the only operation directly
    in the language. A lot of other work on Collections happens over and over, and
    Kotlin’s Collections have a ton of features using the first-class functions we
    saw in the previous section. These features almost always return a new Collection
    rather than mutating the Collection they are called against. You may have encountered
    this style of Collection code in Java since the release of lambdas and streams,
    which share many common ideas.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，迭代集合的`for`循环是语言中唯一的直接操作。许多其他关于集合的工作反复进行，Kotlin的集合使用我们在上一节中看到的顶级函数具有大量功能。这些功能几乎总是返回一个新的集合，而不是修改它们被调用的集合。自lambda和流发布以来，你可能在Java中遇到了这种风格的集合代码，它们共享许多共同的想法。
- en: 'Often we take a value in one Collection and transform each element to a different
    value based on some calculation. `map` does exactly this using the function we
    pass in, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 经常我们会从一个集合中取一个值，并根据某些计算将每个元素转换成不同的值。`map`函数正是使用我们传递的函数来完成这个任务，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ result contains a list of “A”, “B”, “C”.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结果包含“A”、“B”、“C”的列表。
- en: 'Another common operation is to remove certain values from a Collection before
    doing further processing. `filter` expects a lambda that returns a `Boolean`.
    This lambda is called a *predicate*, and `filter` calls the predicate repeatedly
    to decide which elements to return in a new Collection, as shown next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是在进一步处理之前从集合中移除某些值。`filter`期望一个返回`Boolean`的lambda表达式。这个lambda表达式被称为*谓词*，`filter`会重复调用谓词来决定在新的集合中返回哪些元素，如下所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ result contains a list of “a”, “c”.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 结果包含“a”、“c”的列表。
- en: 'If you care only whether a Collection fulfills certain conditions but you don’t
    need the elements, the `all`, `any`, and `none` functions are just what you need.
    These avoid copying data and will return early where possible (i.e., after the
    first `false` for `all()`), as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心一个集合是否满足某些条件，但不需要元素，那么`all`、`any`和`none`函数正是你所需要的。这些函数会避免复制数据，并在可能的情况下尽早返回（即对于`all()`在第一个`false`之后），如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ all == true
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ all == true
- en: ❷ any == false
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ any == false
- en: ❸ none == false
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ none == false
- en: 'You can build a map from a list with the functions `associateWith` and `associateBy`.
    `associateWith` expects the Collection element to be the key in the resulting
    map. `associateBy` assumes instead the Collection element is the value in the
    map. If duplicates are encountered with either of these functions, the last calculated
    value wins, as illustrated in the next code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`associateWith`和`associateBy`函数从列表构建映射。`associateWith`期望集合元素是结果映射中的键。`associateBy`假设集合元素是映射中的值。如果遇到这些函数中的任何一种重复项，则最后计算出的值获胜，如下一个代码片段所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ resultWith contains mapOf(“!” to 1, “-” to 1, “--” to 2, “---” to 3).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ resultWith包含mapOf(“!” to 1, “-” to 1, “--” to 2, “---” to 3)。
- en: ❷ resultBy contains mapOf(1 to “-”, 2 to “--”, 3 to “---”).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ resultBy包含mapOf(1 to “-”, 2 to “--”, 3 to “---”)。
- en: This just scratches the surface of the rich set of functions in Kotlin for working
    with Collections. These functions can be chained together to allow expressive,
    concise descriptions of operations over a Collection. The documentation is excellent
    with examples that walk through other topics like grouping, sorting, aggregating,
    and copying. See [https://kotlinlang.org/docs/collections-overview.html](https://kotlinlang.org/docs/collections-overview.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是Kotlin中用于处理集合的丰富函数集的冰山一角。这些函数可以连在一起，以便对集合上的操作进行表达性、简洁的描述。文档非常优秀，提供了关于分组、排序、聚合和复制的其他主题的示例。请参阅[https://kotlinlang.org/docs/collections-overview.html](https://kotlinlang.org/docs/collections-overview.html)。
- en: Kotlin’s focus on maintaining a tight flow between bits of code carries to other
    fundamental features, too. A preference for expressions over statements is another
    way Kotlin smooths the edges in your code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin在保持代码片段之间紧密流动方面的关注也体现在其他基本特性上。优先使用表达式而非语句是Kotlin使代码边缘更加平滑的另一种方式。
- en: 9.2.6 Express yourself
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.6 表达自己
- en: 'Among the first structures we encounter when learning to program is `if`. In
    Java, `if` is a statement used to control the flow of execution through your program.
    Kotlin also uses `if` for this purpose, but rather than a *statement* that is
    just executed, `if` is an *expression* that returns a value, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习编程时，我们遇到的第一个结构就是`if`。在Java中，`if`是一个用于控制程序执行流程的语句。Kotlin也用`if`来达到这个目的，但与只是执行的单个`statement`不同，`if`是一个返回值的`expression`，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The variable iffy will receive a value, depending on which branch is taken.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ iffy变量将根据选择的分支接收一个值。
- en: ❷ If checkCondition() is true, “sure” will be assigned to iffy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果checkCondition()为真，则“sure”将被赋值给iffy。
- en: ❸ If checkCondition() is false, “nope” will be assigned to iffy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果checkCondition()为假，则“nope”将被赋值给iffy。
- en: Like with any other variable assignment, Kotlin allows us to infer the type.
    In this case, the final line of each branch is accounted for in determining the
    type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他变量赋值一样，Kotlin允许我们推断类型。在这种情况下，每个分支的最后一行在确定类型时都被考虑在内。
- en: '`if` expressions are powerful enough that Kotlin actually dropped a feature
    that Java inherited from C—the ternary `condition ? "sure" : "nope"` operator.
    The ternary shortens code, but it also has a reputation for compressing to the
    point of losing readability. Although it has slightly more characters, Kotlin’s
    version is more readable in many cases, as shown in the next code sample, and
    naturally converts to a multiline `if` should the logic grow further:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`表达式足够强大，以至于Kotlin实际上放弃了一个Java从C继承来的特性——三元`condition ? "sure" : "nope"`运算符。三元运算符可以缩短代码，但它也有一个压缩到失去可读性的名声。尽管它有更多的字符，但Kotlin的版本在许多情况下更易于阅读，如下一个代码示例所示，并且当逻辑进一步增长时，自然转换为多行`if`：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In chapter 1, we discussed the introduction of *switch expressions* to Java.
    This is another case where Kotlin’s design preceded similar enhancements in Java.
    Kotlin doesn’t use the traditional C-style `switch` syntax at all but supports
    a powerful alternative with the keyword `when`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了将*switch表达式*引入Java。这是Kotlin的设计先于Java类似增强的另一个例子。Kotlin根本不使用传统的C样式`switch`语法，而是支持一个强大的替代方案，即使用关键字`when`，如下所示：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ If value x is 1, then we’ll assign “one” to w.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果值x为1，则将“one”赋值给w。
- en: ❷ If value x is 2, then we’ll assign “two” to w.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果值x为2，则将“two”赋值给w。
- en: ❸ If value x is anything else, then we’ll assign “lots” to w.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果值x是任何其他值，则将“lots”赋值给w。
- en: '`when` supports a number of other very useful forms. With the `in` keyword,
    you can check for membership in a Collection, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`支持许多其他非常有用的形式。使用`in`关键字，您可以检查集合中的成员资格，如下所示：'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Checks whether x is in each Collection—the equivalent of calling valid.contains(x)
    and invalid.contains(x)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查 x 是否在每一个集合中——相当于调用 valid.contains(x) 和 invalid.contains(x)
- en: 'Kotlin also has language-level support for numeric ranges, which plays nicely
    with `when` and `in`, too, as shown next:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还提供了对数值范围的语言级支持，这很好地与`when`和`in`一起使用，如下所示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The .. syntax defines an inclusive range, so this code is equivalent to the
    prior list-based example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `..` 语法定义了一个包含范围，因此这段代码与先前的基于列表的示例等效。
- en: 'It’s worth noting that the left-hand condition of `when` can be any valid expression
    as long the type matches what’s required. For example, function calls can be used,
    a nice trick for clarifying complex conditions, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`when`的左侧条件可以是任何有效的表达式，只要类型与所需类型匹配即可。例如，可以使用函数调用，这是一个澄清复杂条件的不错技巧，如下所示：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Because the return value from theBest is used directly, it must return an
    Int to be compared to incoming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为`theBest`的返回值被直接使用，所以它必须返回一个 Int 以与传入值进行比较。
- en: ❷ Because the return value from okValues is used with an in, it must be a Collection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为`okValues`的返回值与`in`一起使用，所以它必须是一个集合。
- en: 'A final point on `when`, if you aren’t already convinced of its superpowers,
    is safety. All of our examples provide an `else` case. Removing any of those causes
    a compilation error complaining we haven’t handled all the cases, shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`when`的最后一个要点，如果你还没有被它的超能力所说服，那就是安全性。我们所有的示例都提供了一个`else`情况。移除这些中的任何一个都会导致编译错误，抱怨我们没有处理所有的情况，如下所示：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Kotlin has one other trick for replacing a statement construct in Java with
    an expression—error handling with `try catch`, as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还有一个技巧可以用来替换 Java 中的语句结构——使用`try catch`进行错误处理，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ A function call that might fail
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可能会失败的函数调用
- en: ❷ message will be assigned “fine” if we get past the dangerous call.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果我们成功通过了危险调用，则`message`将被分配“fine”。
- en: ❸ message will be assigned “oops” if our dangerous call throws an exception.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果我们的危险调用抛出异常，则`message`将被分配“oops”。
- en: This avoids the awkward construct of declaring a variable outside the `try catch`
    which all paths inside must remember to set properly. Not only is this shorter
    to write, but it’s safer, too, because the compiler can guarantee the assignment
    is valid.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这避免了在`try catch`之外声明变量这种尴尬的结构，所有路径内部都必须记住正确设置。这不仅更易于编写，而且更安全，因为编译器可以保证赋值是有效的。
- en: Although both Kotlin and Java have adopted aspects of functional programming,
    they are at heart object-oriented languages. Next we’ll examine defining classes
    and objects in Kotlin.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 和 Java 都采用了函数式编程的一些方面，但它们本质上仍然是面向对象的语言。接下来，我们将探讨在 Kotlin 中定义类和对象。
- en: 9.3 A different view of classes and objects
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 类和对象的另一种视角
- en: Kotlin’s classes provide very similar functionality to Java, starting with the
    keyword `class`. But, just as we’ve seen elsewhere, the code is different, with
    an emphasis on conciseness and convenience.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的类提供了与 Java 非常相似的功能，从`class`关键字开始。但就像我们在其他地方看到的那样，代码是不同的，强调简洁和便利。
- en: 'For starters, Kotlin doesn’t use the `new` keyword for creating instances of
    a class. Instead, its syntax is more akin to invoking a function using the class
    name, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kotlin 不使用 `new` 关键字来创建类的实例。相反，它的语法更类似于使用类名调用函数，如下所示：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Kotlin doesn’t really have fields in the same way that Java does. Instead,
    our friends `val` and `var` show up when declaring *properties* within the class.
    These can be initialized inline in the same fashion as Java fields, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 并没有像 Java 那样真正有字段。相反，当我们声明类内的*属性*时，我们的朋友`val`和`var`就会出现。这些可以像 Java 字段一样内联初始化，如下所示：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The read-only property birthdate
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只读属性 birthdate
- en: ❷ The mutable property name
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可变属性名
- en: Note As we saw in chapter 4, fields are present at JVM level, so Kotlin’s properties
    are actually converted into field access in the bytecode. However, at the language
    level, it is better to think in terms of properties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如我们在第 4 章中看到的，字段在 JVM 层级上是存在的，所以 Kotlin 的属性实际上在字节码中转换为字段访问。然而，在语言层面上，最好从属性的角度来思考。
- en: 'A major source of boilerplate in Java classes is getter and setter methods
    for fields. Kotlin addresses this by providing accessors for properties automatically
    by default. To take it a step further, Kotlin also allows us to use those accessor
    methods as if we were accessing a field in Java, as shown next:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Java 类中的主要样板代码来源是字段的获取器和设置器方法。Kotlin 通过默认提供属性访问器来解决此问题。更进一步，Kotlin 还允许我们像访问
    Java 中的字段一样使用这些访问器方法，如下所示：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Prints Hi Name here. You were born on 1996-01-23.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此处打印“Hi Name”。你出生于 1996-01-23。
- en: ❷ var properties also get setters, which can be used with =.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 变量属性也获得设置器，可以使用 = 使用。
- en: ❸ val properties cannot be set.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ val 属性不能被设置。
- en: A big topic in class designing is visibility of state data, especially as it
    relates to *encapsulation*. Kotlin takes a slightly controversial move of defaulting
    visibility to `public`, which differs from Java’s *package-protected* default.
    Freely exposing all properties isn’t considered good practice, but Kotlin’s designers
    found that `public` had to be stated far more often in real code, so choosing
    it as the default has a major slimming effect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在类设计中，状态数据的可见性是一个大问题，尤其是与 *封装* 相关。Kotlin 采取了一个稍微有争议的举措，将默认可见性设置为 `public`，这与
    Java 的 *包保护* 默认设置不同。公开暴露所有属性并不被认为是良好的实践，但 Kotlin 的设计者发现，在实际代码中 `public` 需要被声明得更加频繁，因此将其作为默认设置具有重大简化效果。
- en: 'Kotlin supports the following four levels of visibility, most of which align
    with their Java counterparts:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持以下四个可见级别，其中大多数与它们的 Java 对应项相匹配：
- en: '*private*—Visible only within the current class or file for top-level functions'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私有*—仅对当前类或文件中的顶级函数可见'
- en: '*protected*—Visible within the class and child classes'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*受保护*—在类及其子类中可见'
- en: '*internal*—Visible to the set of code you compile together'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内部*—可见于您一起编译的代码集'
- en: '*public*—Visible to everyone'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公共*—对每个人可见'
- en: 'For example, if we wanted to make `birthdate` private, it would look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想将 `birthdate` 设置为私有，它看起来会是这样：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because Kotlin exposes only properties, not fields, to the programmer, it opens
    the possibility for *delegated properties*. When followed with the `by` keyword,
    a property can provide a custom implementation of its getting and setting behavior.
    This practice will show up in a number of advanced techniques in later chapters.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kotlin 仅向程序员公开属性，而不是字段，因此它为 *委托属性* 开辟了可能性。当跟随 `by` 关键字时，属性可以提供其获取和设置行为的自定义实现。这种做法将在后续章节的许多高级技术中体现出来。
- en: 'Several useful delegates come with the standard library. For instance, it’s
    not uncommon when debugging to want to know when a value was changed. `Delegates
    .observable` provides just such a hook, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中包含了一些有用的委托。例如，在调试时，想知道何时更改了值是很常见的。`Delegates.observable` 提供了这样的钩子，如下所示：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The value passed when calling `Delegates.observable` is treated as the initial
    value of the property. The lambda we pass to `Delegates.observable` will be invoked
    after the backing property value has been changed. A handle to the property itself,
    along with the old and new values, is passed into the lambda for us to work with.
    Here we simply print out what changed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Delegates.observable` 时传递的值被视为属性的初始值。我们传递给 `Delegates.observable` 的 lambda
    将在支持属性值更改后调用。一个属性本身的句柄，以及旧值和新值，将传递给 lambda，供我们操作。在这里，我们只是简单地打印出更改了什么。
- en: 'Like Java, Kotlin supports constructors for creating instances of our classes,
    and, in fact, Kotlin actually has a few different forms for construction. The
    first of these is declaring a *primary constructor* at the very top with your
    class name, as shown next. Kotlin uses this as an alternative location where you
    can specify your properties as well:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 类似，Kotlin 支持为我们的类创建实例的构造函数，实际上，Kotlin 在构造方面有几个不同的形式。这些中的第一个是在类名顶部声明一个
    *主构造函数*，如下所示。Kotlin 将此用作一个替代位置，您可以在此处指定您的属性：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ val and var in the primary constructor create properties so we don’t need
    to declare them later.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在主构造函数中使用的 val 和 var 创建属性，因此我们不需要稍后声明它们。
- en: ❷ Because we didn’t provide defaults, parameters must be passed at construction.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于我们没有提供默认值，参数必须在构造时传递。
- en: 'If you need visibility modifiers or annotations on a constructor, you can use
    a longer syntax using the `constructor` keyword. For instance, if we wanted to
    hide our constructor from the world, we can do it like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在构造函数上使用可见性修饰符或注解，您可以使用 `constructor` 关键字的较长语法。例如，如果我们想将我们的构造函数从世界中隐藏，我们可以这样做：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we want to run other logic during all object construction, Kotlin uses the
    `init` keyword like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在所有对象构造期间运行其他逻辑，Kotlin 使用 `init` 关键字，如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ init runs after we’ve assigned the properties from the constructor so we can
    access them in our code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `init` 在我们从构造函数分配属性之后运行，这样我们就可以在代码中访问它们。
- en: 'A class may have multiple `init` blocks, and they are run in the order in which
    they’re defined in the class, as shown here. Properties defined in the class body
    are accessible to `init` blocks only after the definition:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以有多个 `init` 块，并且它们按照在类中定义的顺序执行，如下所示。在类体中定义的属性只有在定义之后才能被 `init` 块访问：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '❶ Fails to compile with error: variable ‘nameParts’ must be initialized'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编译失败，错误：变量 `nameParts` 必须被初始化
- en: ❷ Works as expected, and prints out a list
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如预期的那样工作，并打印出一个列表
- en: 'If we need additional constructors, we define them in the class body with the
    `constructor` keyword, as follows. These are referred to as *secondary constructors*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要额外的构造函数，我们可以在类体中使用 `constructor` 关键字定义它们，如下所示。这些被称为 *二级构造函数*：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ When a class has a primary constructor, secondary constructors must call it
    (directly or through other secondary constructors) via this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当一个类有一个主构造函数时，二级构造函数必须通过 this（直接或通过其他二级构造函数）调用它。
- en: Note Many cases in Java where multiple constructor overrides exist for supplying
    defaults can be handled in Kotlin with default argument values instead.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在 Java 中，许多存在多个构造函数重写以提供默认值的情况可以用 Kotlin 的默认参数值来处理。
- en: 'Although a class with only properties can be of use, most of the time, our
    classes have other functionality, too. The next code sample uses the familiar
    function syntax we’ve already seen earlier in the chapter to add a method to the
    class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然只有属性的类可能有用，但大多数时候，我们的类还有其他功能。下面的代码示例使用我们在本章前面已经见过的熟悉函数语法向类添加一个方法：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As mentioned before, functions in Kotlin default to `public` visibility. If
    we want to hide a function, precede it with the desired access modifier like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kotlin 中的函数默认为 `public` 可见性。如果我们想隐藏一个函数，可以在它前面加上所需的访问修饰符，如下所示：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ isBirthday is available for anyone who can see the Person class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `isBirthday` 对任何可以看到 `Person` 类的人来说都是可用的。
- en: ❷ today is available only within the Person class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `today` 只在 `Person` 类内部可用。
- en: 'Another key part of object-oriented programming is *inheritance*. Kotlin doesn’t
    have the `extends` keyword but instead expresses inheritance via the familiar
    `:` syntax we’ve seen in type declarations previously and shown next:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的另一个关键部分是 *继承*。Kotlin 没有使用 `extends` 关键字，而是通过我们在类型声明中已经看到的熟悉的 `:` 语法来表示继承，如下所示：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ Parameters to the Child constructor. Note these are not marked val and var,
    so they don’t collide with the parent properties but are available as local variables
    to pass to the superclass constructor.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 子类构造函数的参数。注意这些参数没有被标记为 val 和 var，所以它们不会与父属性冲突，但可以作为局部变量传递给超类构造函数。
- en: ❷ Calling to the superclass constructor
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用超类构造函数
- en: 'Inheritance requires one other change to the `Parent` class. To encourage subclassing
    only where we intend and plan for it, Kotlin classes are *closed* by default.
    If a class may be subclassed, it must use the `open` keyword, as shown in the
    next code sample. This is the inverse of the situation in Java, where classes
    are open by default and use `final` to indicate that they may *not* be subclassed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 继承需要对 `Parent` 类进行一项其他更改。为了鼓励仅在打算和计划的地方进行子类化，Kotlin 类默认是 *关闭的*。如果一个类可以被子类化，它必须使用
    `open` 关键字，如下面的代码示例所示。这与 Java 中的情况相反，Java 中的类默认是开放的，并使用 `final` 来表示它们可能 *不能* 被子类化：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ open precedes the class keyword along with visibility modifiers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `open` 关键字及其可见性修饰符位于类关键字之前。
- en: 'The same closed-by-default principle applies to methods. The parent class must
    declare a method to be overridden `open`, and overrides must be marked with `override`
    in the child, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的默认关闭原则也适用于方法。父类必须声明一个要重写的 `open` 方法，并且重写必须在子类中用 `override` 标记，如下所示：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The Person class declares that the isBirthday function can be overridden in
    subclasses.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Person` 类声明 `isBirthday` 函数可以在子类中重写。
- en: ❷ The Child class must explicitly mark its method as an override.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 子类必须显式标记其方法为重写。
- en: ❸ Child can call the parent implementation of the isBirthday with super.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `Child` 可以使用 `super` 调用父类的 `isBirthday` 实现。
- en: 'Like Java, Kotlin allows only a single base class, but classes may inherit
    multiple interfaces, as shown in the next code. Kotlin’s interfaces allow the
    default implementations of functions, much like Java has since version 8:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 一样，Kotlin 只允许一个基类，但类可以继承多个接口，如以下代码所示。Kotlin 的接口允许函数有默认实现，就像 Java 从 8
    版本以来所做的那样：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Defines our interface with a function to return a greeting
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义我们的接口，包含一个返回问候语的函数
- en: ❷ Person declares that it implements Greetable.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Person 声明实现了 Greetable。
- en: ❸ Interface functions are open, so their implementation must specify override.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 接口函数是开放的，因此它们的实现必须指定 `override`。
- en: In typical Kotlin style, implementing an interface uses a concise form that
    looks a lot like what we already use for extending a base class—no more remembering
    whether to use `extends` or `implements` like in Java.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Kotlin 风格中，实现接口使用了一种简洁的形式，看起来与我们用来扩展基类已经很相似——不再需要记住是否像在 Java 中那样使用 `extends`
    或 `implements`。
- en: 9.3.1 Data classes
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 数据类
- en: Although these basic constructs allow us to make rich object models in Kotlin,
    sometimes you just want a container to pass data around. Kotlin provides support
    for this with *data classes*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些基本构造允许我们在 Kotlin 中创建丰富的对象模型，但有时你只是需要一个容器来传递数据。Kotlin 通过 *数据类* 提供了对这一点的支持。
- en: Note We met Java’s new `record` capability in chapter 3, and Kotlin data classes
    are very similar to Java records in some ways.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在第 3 章中遇到了 Java 的新 `record` 功能，Kotlin 数据类在某些方面与 Java 记录非常相似。
- en: Kotlin already makes the property side of this seamless, but the equality issues
    remain with standard classes—the default `equals` and `hashCode` implementations
    are based on object references, rather than the values of its properties.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 已经使属性方面变得无缝，但标准类的相等性问题仍然存在——默认的 `equals` 和 `hashCode` 实现是基于对象引用，而不是其属性的值。
- en: 'When we declare a type as a `data class`, though, Kotlin will create the equality
    functions we’d want (unless we provide an implementation ourselves explicitly),
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个类型为 `data class` 时，Kotlin 将创建我们想要的相等函数（除非我们显式地提供实现），如下所示：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ The default equals compares reference equality, so this prints false.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 默认的 equals 方法比较引用相等性，因此这里打印出 false。
- en: ❷ With Kotlin’s data class implementation, this prints true.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Kotlin 的数据类实现，这里打印出 true。
- en: Data classes must have a primary constructor with a least one `val` or `var`.
    They can’t be `open`, because it’s impossible at compile time for Kotlin to correctly
    generate the equality functions if child classes might exist for the type. Data
    classes also aren’t allowed as inner classes. Apart from these and a handful of
    more exotic constraints, though, they are normal classes on which you can implementation
    functions or interfaces to your heart’s content.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类必须有一个至少包含一个 `val` 或 `var` 的主构造函数。它们不能是 `open` 的，因为在编译时 Kotlin 无法正确生成可能存在子类的类型的相等函数。数据类也不允许作为内部类。尽管如此，除了这些和一些更特殊的约束之外，它们仍然是普通的类，你可以在上面实现任何你想要的功能或接口。
- en: A last feature that folks coming from Java might look for in classes is declaring
    a function that belongs not to instances but to the class as a whole. Kotlin chose
    not to support `static`, though—functions are either free-floating or are members
    of a type.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Java 的人可能在类中寻找的最后一个特性是声明一个属于整个类而不是实例的函数。然而，Kotlin 没有选择支持 `static`——函数要么是自由浮动的，要么是类型的成员。
- en: However, the convenience of associating functions with a class can’t be denied,
    and Kotlin provides similar functionality via its `companion object`. This syntax
    declares a singleton object that lives within the class. `object` declarations
    in Kotlin are full objects with typical properties and functions. This avoids
    weird edges that `static` methods suffer from in Java (i.e., testing difficulties),
    while retaining the convenience of keeping functionality associated with the class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将函数与类关联的便利性是无法否认的，Kotlin 通过其 `companion object` 提供了类似的功能。这种语法声明了一个在类内部存在的单例对象。Kotlin
    中的 `object` 声明是具有典型属性和函数的完整对象。这避免了 Java 中 `static` 方法所遭受的奇怪边缘问题（例如，测试困难），同时保持了将功能与类关联的便利性。
- en: 'A common use case for these functions is factory methods, where you want to
    keep the constructors of your objects private but allow controlled creation by
    more specifically named methods, as shown here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的常见用例是工厂方法，其中你希望保持对象的构造函数为私有，但允许通过更具体命名的函数进行受控的创建，如下所示：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ ShyObject declares its constructor private so no one outside the class can
    use it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ShyObject 声明其构造函数为私有，因此类外部的任何人都不可以使用它。
- en: ❷ Our factory method inside the companion object is part of the ShyObject class,
    so it can access the private constructor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们在伴随对象中的工厂方法属于 ShyObject 类的一部分，因此它可以访问私有构造函数。
- en: ❸ Outside of our class, functions on ShyObject’s companion are available directly
    via its class name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在我们的类外部，ShyObject 伴随对象上的函数可以通过其类名直接访问。
- en: As a pragmatic alternative to Java, Kotlin brings a lot of convenience and boilerplate
    reduction to the table. But it doesn’t stop there, as we’ll see in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Java 的实用替代方案，Kotlin 带来了很多便利和样板代码的减少。但不仅如此，我们将在下一节中看到。
- en: 9.4 Safety
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 安全性
- en: Kotlin is built on top of the JVM, and so it has no choice but to live within
    some design constraints that really come from the design of the virtual machine.
    For example, the JVM specification defines `null` as a value that can be assigned
    to any variable of reference type.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是建立在 JVM 之上的，因此它别无选择，只能遵守一些来自虚拟机设计的实际设计约束。例如，JVM 规范定义 `null` 为可以分配给任何引用类型变量的值。
- en: Despite these issues, the Kotlin language seeks to address some common code
    safety concerns to try to minimize the inherited pain and suffering. This manifests
    itself by elevating a number of Java code patterns to language features to make
    your code safer by default.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些问题，Kotlin 语言试图解决一些常见的代码安全性问题，以尽量减少继承的痛苦和困扰。这通过将许多 Java 代码模式提升为语言特性来实现，使代码默认更安全。
- en: 9.4.1 Null safety
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 可空性
- en: Among the most common Java exceptions is the `NullPointerException`. This happens
    when we try to access a variable or field that should have contained an object
    but instead was `null`. Nulls have been referred to by Tony Hoare, the original
    creator of the Quicksort algorithm, as his “billion dollar mistake” (see [https://qconlondon.com/london-2009/qconlondon.com/london-2009/speaker/Tony+Hoare.html](https://qconlondon.com/london-2009/qconlondon.com/london-2009/speaker/Tony+Hoare.html)),
    given his role in introducing the `null` reference in ALGOL.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的 Java 异常中，`NullPointerException` 是其中之一。这发生在我们尝试访问一个应该包含对象但实际为 `null` 的变量或字段时。Tony
    Hoare，快速排序算法的原始创造者，将 `null` 称为他的“十亿美元的错误”（参见 [https://qconlondon.com/london-2009/qconlondon.com/london-2009/speaker/Tony+Hoare.html](https://qconlondon.com/london-2009/qconlondon.com/london-2009/speaker/Tony+Hoare.html)），鉴于他在
    ALGOL 中引入 `null` 引用方面的作用。
- en: Over its history, Java has developed several different approaches to provide
    protection against `null`s. The `Optional` type lets you always have a concrete
    object, while still indicating a “missing” value without resorting to `null`.
    The `@NotNull` and `@Nullable` annotations, supported by many different validation
    and serialization frameworks, can ensure that values aren’t unexpectedly `null`
    at key points in our applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在其历史中，Java 已经发展出几种不同的方法来提供对 `null` 的保护。`Optional` 类型让你始终有一个具体对象，同时仍然表示一个“缺失”的值，而不必求助于
    `null`。`@NotNull` 和 `@Nullable` 注解，由许多不同的验证和序列化框架支持，可以在我们的应用程序的关键点上确保值不会意外地变为
    `null`。
- en: As you might expect, Kotlin has taken these common patterns and baked them right
    into the language itself. Let’s revisit our earlier example of assigning variables.
    How do they behave when combined with `null`s?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，Kotlin 已经将这些常见模式直接烘焙到语言本身中。让我们回顾一下我们之前关于赋值变量的例子。当它们与 `null` 结合时，它们是如何表现的？
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Trying to assign null to these types will fail to compile.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试将这些类型赋值为 null 将导致编译失败。
- en: 'Both assignments give a compilation error, `error: null can not be a value
    of a non-null type Int`. Although those `Int` and `String` type declarations look
    like Java’s, they, in fact, disallow `null` values.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '这两种赋值都会导致编译错误，`error: null can not be a value of a non-null type Int`。尽管那些
    `Int` 和 `String` 类型声明看起来像 Java 的，但实际上它们不允许 `null` 值。'
- en: Note Kotlin has made nullability part of its type system. The Kotlin type `String`
    is *not* actually the same as the Java type `String` that allows `null`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Kotlin 已经将可空性作为其类型系统的一部分。Kotlin 类型 `String` 实际上并不等同于允许 `null` 的 Java 类型 `String`。
- en: 'For a Kotlin variable to allow `null`, we must state it explicitly by adding
    a suffix of `?` to the type as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Kotlin 变量允许 `null`，我们必须明确声明，通过在类型后添加 `?` 后缀，如下所示：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Changing our types to Int? and String? will tell Kotlin to allow nulls.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将我们的类型更改为 Int? 和 String? 将告诉 Kotlin 允许 `null`。
- en: Note Whenever possible, declare your variables and arguments with non-null types.
    You can rest assured that Kotlin is protecting you from those `NullPointerException`
    headaches.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在可能的情况下，请使用非空类型声明变量和参数。您可以放心，Kotlin 正在保护您免受那些 `NullPointerException` 痛苦。
- en: 'We can’t always avoid `null`s, though. Perhaps we’re interacting with Java
    code, or our classes weren’t designed with `null` safety in mind. Even once we’ve
    dipped our toes into the dangers of nullability, Kotlin still does its best to
    inform us of the risks, like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们总是无法避免 `null`，但也许我们正在与 Java 代码交互，或者我们的类在设计时没有考虑到 `null` 安全性。即使我们已经涉足到可空性的危险，Kotlin
    仍然尽力通知我们风险，如下所示：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ❶ Creates a nullable variable
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个可空变量
- en: ❷ Attempts to access a property on that variable
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试访问该变量的属性
- en: 'Kotlin recognizes the dereference in calling `s.length` is potentially unsafe
    and refuses to compile with `error: only safe (?.) or non-null asserted (!!.)
    calls are allowed on a nullable receiver of type String?`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kotlin 认识到在调用 `s.length` 时解引用可能是不安全的，并拒绝编译，错误信息为 `error: only safe (?.) or
    non-null asserted (!!.) calls are allowed on a nullable receiver of type String?`。'
- en: 'The first option Kotlin suggests is to correct this to the safe operator `?.`.
    This operator examines the object its being applied to. If the object is `null`,
    it returns `null` instead of making the further function call, like so:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 建议的第一个选项是将此更正为安全操作符 `?.`。这个操作符检查其应用的对象。如果对象为 `null`，则返回 `null` 而不是进行进一步的函数调用，如下所示：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ ?. results in printing the value null.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `?.` 导致打印出 `null` 值。
- en: 'The safe operator returns early, so it works fine, even with a nested chain
    of calls. Any point along the way in our following example can safely return a
    `null` and the whole expression will just turn to `null`, as shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 安全操作符会提前返回，因此即使在嵌套调用链中也能正常工作。在我们以下示例中的任何一点都可以安全地返回 `null`，整个表达式将变为 `null`，如下所示：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ A data class that allows for an optional parent node
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个允许可选父节点的数据类
- en: ❷ Retrieves a Node from somewhere
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从某处检索一个节点
- en: ❸ Sees whether node has a great-grandparent node
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查节点是否有曾祖父母节点
- en: This may be convenient, but `?.` potentially hides data issues. If we got a
    `null` back on our previous great-grandparent check, we can’t assure which level
    of our hierarchy it came from without further inspection.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很方便，但 `?.` 可能会隐藏数据问题。如果我们之前的曾祖父母节点检查返回了 `null`，没有进一步的检查，我们无法确定它来自我们层次结构的哪个级别。
- en: 'The second option for our compilation failure, (`error: only safe (?.) or non-null
    asserted (!!.) calls are allowed on a nullable receiver of type String?`.) is
    using `!!` on the variable. This operator forces Kotlin to see whether the object
    is `null` and will raise the familiar `NullPointerException` if the value is `null`,
    as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '我们编译失败的第二种选择（`error: only safe (?.) or non-null asserted (!!.) calls are allowed
    on a nullable receiver of type String?`）是在变量上使用 `!!`。这个操作符强制 Kotlin 判断对象是否为 `null`，如果值为
    `null`，则会抛出熟悉的 `NullPointerException`，如下所示：'
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Throws a NullPointerException
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 抛出 NullPointerException
- en: 'Although it should be needed less often, we can still check whether a variable
    is `null`. In fact, Kotlin can often notice such checks and let us avoid further
    `?.` or `!!`, like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况可能需要得较少，但我们仍然可以检查变量是否为 `null`。实际上，Kotlin 通常可以注意到这样的检查，并让我们避免进一步的 `?.`
    或 `!!`，如下所示：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Checks for null in all cases
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在所有情况下检查 null
- en: ❷ Because we know that s isn’t null, it can be safely referenced.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为我们知道 s 不是 null，所以可以安全地引用。
- en: What we’ve seen here is actually a deeper feature of Kotlin called *smart casting*,
    which is worth looking at more closely in its own right.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是 Kotlin 的一个更深层功能，称为 *智能转换*，这值得更仔细地研究。
- en: 9.4.2 Smart casting
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 智能转换
- en: Although good object-oriented design tries to avoid directly checking the type
    of objects, sometimes it’s necessary. Data formats at the edges of our system
    may be loose about types (i.e., JSON) and often outside our control. At other
    times, we have plugin systems that must dynamically probe for capabilities of
    an object.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然良好的面向对象设计试图避免直接检查对象类型，但有时这是必要的。我们系统边缘的数据格式可能对类型较为宽松（即 JSON）并且通常不受我们控制。在其他时候，我们可能有插件系统，必须动态探测对象的能力。
- en: 'Kotlin embraces this need and takes it a step further in how the compiler supports
    the common patterns. To start, Kotlin uses the `is` operator to check an object’s
    type as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 接受了这种需求，并在编译器如何支持常见模式方面更进一步。首先，Kotlin 使用 `is` 操作符来检查对象类型，如下所示：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Any is the equivalent of Java’s Object type—the base type for all objects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Any` 是 Java 的 Object 类型的等价物——所有对象的基础类型。
- en: ❷ Checks whether s contains a String instance
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查 s 是否包含一个 String 实例
- en: ❸ Uses the variable s as a String. toUpperCase wouldn’t be available if the
    compiler treated it as type Any still within the branch.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用变量 s 作为 String。如果编译器将其视为类型 Any 仍然在分支中，则 toUpperCase 将不可用。
- en: If you’re familiar with Java’s `instanceof` construct, this code appears to
    miss a crucial step—we look to see whether `s` is a `String`, but then we don’t
    cast it before treating it as a `String`. Fortunately, Kotlin has us covered.
    Within the `if` block where the compiler can ensure we have a `String`, we may
    use `s` as a `String` without explicitly casting. This is known as *smart casting*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Java 的 `instanceof` 构造，这段代码似乎遗漏了一个关键步骤——我们查看 `s` 是否是 `String` 类型，但随后在将其作为
    `String` 处理之前没有进行转换。幸运的是，Kotlin 有所准备。在编译器可以确保我们有 `String` 的 `if` 块中，我们可以使用 `s`
    作为 `String` 而不进行显式转换。这被称为 *智能转换*。
- en: Note Java has a new feature called *pattern matching* that is being slowly rolled
    out as part of Project Amber. The first piece of it applies to `instanceof` and
    provides some of the same benefits as smart casting. We will discuss pattern matching
    in more detail in chapter 18.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Java 有一个名为 *模式匹配* 的新特性，作为 Amber 项目的一部分正在逐步推出。其中的一部分应用于 `instanceof` 并提供了与智能转换相同的一些好处。我们将在第
    18 章中更详细地讨论模式匹配。
- en: 'Kotlin’s smart casting functionality is allowed within an `if` conditional
    as well, as shown next:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的智能转换功能也允许在 `if` 条件语句中使用，如下所示：
- en: '[PRE58]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Kotlin can ensure the type from our check on the left-hand side of the &&
    so it can safely uppercase without casting.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Kotlin 可以确保对 && 左侧的检查类型，因此它可以安全地不进行转换而转换为大写。
- en: Constraints exist around where smart casting can kick in. In particular, it
    won’t work with `var` properties on a class. This protects us against the property
    being mutated concurrently to a different compatible subtype after the smart cast
    check has been performed but before the following block executes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 智能转换的触发条件存在限制。特别是，它不能与类上的 `var` 属性一起使用。这保护我们在智能转换检查执行后但在下一个块执行之前，属性不会并发地突变到不同的兼容子类型。
- en: 'Even if Kotlin can’t do it directly, we may still cast to the type we expect—
    it’s just a little less convenient, as shown here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Kotlin 不能直接做到这一点，我们仍然可以将类型转换为期望的类型——只是稍微不太方便，如下所示：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Assumes s is defined in a way that we can’t smart cast
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 假设 s 是以我们无法智能转换的方式定义的
- en: ❷ as casts to the expected type.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `as` 转换到期望的类型。
- en: 'When we use `as`, we’re back to the same spot as in Java when we cast. We’ll
    see `ClassCastException` if the types aren’t actually compatible. Kotlin does
    provide the following alternative if we would prefer allowing nullability into
    the picture instead of exceptions:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `as` 时，我们回到了 Java 中进行转换时的同一个位置。如果类型实际上不兼容，我们将看到 `ClassCastException`。如果宁愿允许可空性而不是异常，Kotlin
    提供以下替代方案：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ as? attempts the cast but won’t throw. Note also that the resulting type is
    String? not String.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `as?` 尝试进行转换但不会抛出异常。注意，结果类型是 String? 而不是 String。
- en: ❷ If s couldn’t be cast, the variable will be null instead.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 s 不能进行转换，则变量将为 null。
- en: A lot of Kotlin’s power comes from taking a fresh look at the common, practical
    coding that Java developers have been doing for years. One area where the language
    provides more than just polish and protection, though, is in concurrency. Kotlin
    provides a technique called coroutines, which can be thought of as an alternative
    to the classical threading approaches that are most widely used in Java.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的许多功能来自于对 Java 开发者多年来一直在做的常见、实用编码的新审视。然而，语言在并发方面提供的不只是润色和保护，还有一个领域。Kotlin
    提供了一种称为协程的技术，可以被视为 Java 中最广泛使用的经典线程方法的替代方案。
- en: 9.5 Concurrency
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 并发
- en: As we discussed in chapter 5, since its very first versions the JVM has supported
    the `Thread` class as a model of operating-system-managed threads. The thread
    model is well understood, but it comes with many problems.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 5 章中讨论的，自从 JVM 的最初版本以来，它就支持 `Thread` 类作为操作系统管理的线程模型。线程模型是众所周知的，但它带来了许多问题。
- en: Note Although threads are so deeply embedded in the Java language and ecosystem
    that it would be almost impossible to remove them, moving to a new, non-Java language
    allows us to potentially reimagine the concurrency primitives that the language
    might use.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管线程在 Java 语言和生态系统中根深蒂固，几乎不可能将其移除，但转向一种新的、非 Java 语言使我们有可能重新构想该语言可能使用的并发原语。
- en: Although Kotlin as a JVM language still exposes threads, it also introduces
    another construct called *coroutines*. At the simplest level, a coroutine can
    be thought of as a lighter-weight thread. These are implemented and scheduled
    within the runtime instead of at the operating system level, making them much
    less resource intensive. Spinning up thousands of coroutines isn’t a problem at
    all, where similar counts of threads would grind a system to a halt.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin作为JVM语言仍然暴露线程，但它也引入了另一种称为*协程*的结构。在最简单的层面上，协程可以被看作是一个更轻量级的线程。这些协程在运行时实现和调度，而不是在操作系统级别，这使得它们对资源的消耗要小得多。启动数千个协程根本不是问题，而相同数量的线程可能会使系统停止运行。
- en: Note We’ll meet Java’s take on coroutines in chapter 18 when we discuss Project
    Loom.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在第18章讨论Project Loom时遇到Java对协程的看法。
- en: 'Part of Kotlin’s support for coroutines is directly in the language (`suspend`
    functions), but to use coroutines practically requires an additional library,
    `kotlin-coroutine-core`. We’ll see a lot more about introducing these sorts of
    dependencies in chapter 11, but for now the addition would look like this in Maven:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin对协程的支持部分直接在语言中（`suspend`函数），但为了实际使用协程，还需要一个额外的库，即`kotlin-coroutine-core`。我们将在第11章中看到更多关于引入这些类型依赖的内容，但到目前为止，在Maven中的添加看起来像这样：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The equivalent in Kotlin-flavored Gradle follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin风格的Gradle中，等效的代码如下：
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In Java a thread is started by handing it an object that implements the `Runnable`
    interface. Coroutines in Kotlin also need a way to receive the code to run, but
    instead they use the language’s lambda syntax.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，线程是通过传递一个实现了`Runnable`接口的对象来启动的。Kotlin中的协程也需要一种接收要运行代码的方式，但它们使用的是语言的lambda语法。
- en: 'A coroutine is always started in a *scope*, which controls how the coroutine
    will be scheduled and run. We’ll start with the simplest option, which is `GlobalScope`,
    a scope that exists for the entire duration of your application. `GlobalScope`
    has a `launch` function we call with a lambda to get ourselves started, as shown
    next:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 协程总是在一个*作用域*中启动，它控制着协程的调度和运行方式。我们将从最简单的选项开始，即`GlobalScope`，这是一个在整个应用程序运行期间都存在的范围。`GlobalScope`有一个`launch`函数，我们通过传递一个lambda表达式来调用它以开始运行，如下所示：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ Imports for the coroutine function and object we’ll use
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入我们将使用的协程函数和对象
- en: ❷ Starts a new coroutine in the GlobalScope, which lives as long as our program
    does
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在全局作用域中启动一个新的协程，该作用域与我们的程序一样长
- en: ❸ Back outside of our coroutine, we’ll print to see that main still runs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在我们的协程外部，我们将打印出来以确认`main`仍在运行。
- en: 'When we run this example, most often you’ll simply see it output the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个示例时，大多数情况下你只会看到它输出以下内容：
- en: '[PRE64]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Why isn’t our coroutine working? We expect at some point to see `Inside` printed
    as well. Looking closer, though, we can spot the problem if we think about the
    sequence of events. `main` starts up our program. We then launch our coroutine
    to run asynchronously. Following that, we print our `Outside` message, and then
    the program is finished. When `main` is done, the program exits, regardless what
    coroutines may be waiting to run.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们的协程没有工作？我们预期在某个时刻也会看到`Inside`被打印出来。然而，如果我们仔细思考事件的顺序，我们就能发现问题。`main`启动了我们的程序。然后我们异步地启动协程。接着，我们打印出`Outside`消息，然后程序结束。当`main`完成时，程序退出，不管是否有协程正在等待运行。
- en: 'To get the result we wanted, we need to introduce a pause before the program
    finishes. This could be done with a loop or asking for user input at the console.
    We’ll just use a `Thread.sleep(1000)` to give enough time for everything to settle,
    like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到我们想要的结果，我们需要在程序结束前引入一个暂停。这可以通过循环或请求在控制台输入来实现。我们只是使用`Thread.sleep(1000)`来为所有事情足够的时间来稳定，如下所示：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Starts our coroutine again
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 再次启动我们的协程
- en: ❷ Gives the coroutine time to run
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 给协程运行留出时间
- en: Now we’ll see output with both messages, although the order is potentially nondeterministic,
    depending on how fast the coroutine starts up and what the main thread is doing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到包含两条消息的输出，尽管顺序可能是非确定性的，这取决于协程启动的速度以及主线程正在做什么。
- en: At a high level, this doesn’t look much different from using threads to get
    similar concurrent execution of code. But the underlying implementation requires
    fewer operating system resources (each coroutine doesn’t have its own execution
    stack and local storage) and allows safety for operations like cancelling a coroutine.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，这和使用线程来获得类似的并发执行代码看起来并没有太大的不同。但是，底层的实现需要更少的操作系统资源（每个协程没有自己的执行栈和本地存储），并且允许像取消协程这样的操作更安全。
- en: 'To see this in action, we can capture a handle to the coroutine with the return
    value of `launch`. This coroutine object presents a `cancel` function, which we
    can call immediately if we want, as shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个功能在实际中的表现，我们可以通过 `launch` 的返回值捕获协程的句柄。这个协程对象提供了一个 `cancel` 函数，如果我们想的话，可以立即调用，如下所示：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ❶ Captures the coroutine object returned by launch
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 捕获由 launch 返回的协程对象
- en: ❷ Inside of coroutines, we can call delay to wait a period of time.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在协程内部，我们可以调用 delay 来等待一段时间。
- en: ❸ Cancels the coroutine immediately
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 立即取消协程
- en: ❹ Wait as long as you like here—you’ll never see the coroutine output.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这里等待多长时间都可以——你永远不会看到协程的输出。
- en: This code will safely stop the coroutine and print only `Outside`. This is a
    marked contrast to the `stop()` method on `java.lang.Thread` which was deprecated
    long ago due to being hopelessly unsafe, as we discussed in chapter 5.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将安全地停止协程并只打印 `Outside`。这与我们在第 5 章讨论的 `java.lang.Thread` 上的 `stop()` 方法形成了鲜明的对比，因为
    `stop()` 方法由于安全性极差而被弃用很久。
- en: 'Why can coroutines accomplish this safely when threads can’t? The key is the
    `delay` function. Its declaration is marked with a special modifier: `suspend`.
    Kotlin knows to treat `suspend` functions as safe spots in coroutine execution
    for operations like switching to another task or looking for cancellations. This
    is known as *cooperative multitasking*, and it’s only because the code inside
    our coroutine “cooperates” in its calls to suspend functions that it can be cancelled.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么协程能够安全地完成这项工作，而线程却不能？关键在于 `delay` 函数。它的声明被标记了一个特殊的修饰符：`suspend`。Kotlin 知道将
    `suspend` 函数视为协程执行中的安全点，用于执行如切换到另一个任务或查找取消等操作。这被称为 *合作多任务处理*，而且正是因为我们协程内部的代码在其对挂起函数的调用中“合作”，它才能被取消。
- en: 'This cooperation gives benefits beyond just the ability to safely cancel. For
    example, Kotlin understands when one coroutine (parent) starts another coroutine
    (child). Cancelling the parent automatically cancels the child coroutines without
    additional management on our part, as shown next:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这种合作带来的好处远不止于能够安全取消。例如，Kotlin 理解当一个协程（父协程）启动另一个协程（子协程）时。取消父协程会自动取消子协程，而无需我们进行额外的管理，如下所示：
- en: '[PRE67]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ❶ Starts our parent coroutine as before
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述，启动我们的父协程
- en: ❷ Starts two child coroutines. coroutineScope associates those to the enclosing
    scope—in this case, our global coroutine.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动两个子协程。coroutineScope 将这些协程关联到封装作用域——在这种情况下，我们的全局协程。
- en: ❸ Starts two child coroutines. coroutineScope associates those to the enclosing
    scope—in this case, our global coroutine.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动两个子协程。coroutineScope 将这些协程关联到封装作用域——在这种情况下，我们的全局协程。
- en: ❹ Cancels the parent coroutine
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 取消父协程
- en: ❺ Again, we can wait here, but we won’t see any output.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 再次，我们可以在这里等待，但不会看到任何输出。
- en: If you’ve seen the implementation necessary in Java to accomplish this sort
    of coordination, the value Kotlin brings here is pretty apparent.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经看到了在 Java 中完成这种协调所需的实现，Kotlin 在这里带来的价值就非常明显了。
- en: Coroutines are a great example of how Kotlin uses its strength as a separate
    language with its own compiler to work with libraries to accomplish a lot of complex
    behavior cleanly. In fact, there’s enough to coroutines that we’ll be back for
    a deeper investigation in chapter 16.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是 Kotlin 如何利用其作为独立语言并拥有自己的编译器的优势，与库一起工作以干净地完成许多复杂行为的绝佳例子。事实上，关于协程的内容足够多，我们将在第
    16 章进行更深入的探讨。
- en: But no language lives in a vacuum, especially on the JVM. Kotlin has seen great
    success and uptake because of its strong focus on interoperating with the vast
    world of Java code out there.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有一种语言是孤立存在的，尤其是在 JVM 上。Kotlin 因为其强烈关注与庞大的 Java 代码世界的互操作性而取得了巨大的成功和普及。
- en: 9.6 Java interoperability
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 Java 兼容性
- en: As we learned in chapter 4, the class file is the center of the JVM’s execution
    model. It should come as no surprise that the Kotlin compiler (`kotlinc`) produces
    class files much like `javac` does for Java, as illustrated in figure 9.2.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 4 章中学到的，类文件是 JVM 执行模型的核心。Kotlin 编译器（`kotlinc`）生成类文件的方式与 `javac` 为 Java
    生成的类文件类似，如图 9.2 所示。
- en: '![](../Images/CH09_F01_Evans2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH09_F01_Evans2.png)'
- en: Figure 9.2 Kotlin and Java working side by side to generate class files
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 Kotlin 和 Java 并行工作以生成类文件
- en: Basic class definitions end up looking similar between the languages, but when
    Kotlin provides a feature that isn’t available in Java, we see more interesting
    differences in the generated class files. These are evidence of compiler fictions,
    which we discussed in chapter 8.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类定义在两种语言之间看起来相似，但当 Kotlin 提供了 Java 中不可用的功能时，我们在生成的类文件中会看到更多有趣的不同。这些都是编译器虚构的证据，我们在第
    8 章中讨论了这一点。
- en: An example is Kotlin’s top-level functions outside of classes. This isn’t even
    directly supported in the JVM class file format. Kotlin bridges this gap by generating
    a class with the `Kt` suffix, named after its compilation file. Any top-level
    functions from within that file will appear in the `Kt` class.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Kotlin 类外的顶级函数。这在 JVM 类文件格式中甚至没有直接支持。Kotlin 通过生成一个带有 `Kt` 后缀的类来弥合这个差距，该类以它的编译文件命名。该文件中的任何顶级函数都将出现在
    `Kt` 类中。
- en: Note You can alter the name of the generated class with the `@file:JvmName("AlternateClassName")`
    annotation in your `.kt` file.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以使用 `.kt` 文件中的 `@file:JvmName("AlternateClassName")` 注解更改生成的类名。
- en: 'For example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ❶ The filename by default influences the wrapping class name generated.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 默认情况下，文件名会影响生成的封装类名。
- en: ❷ Users of the function will need to import from our package as usual.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 函数的使用者需要像往常一样从我们的包中导入。
- en: 'When compiled, this will produce a class file `MainKt.class` with our function
    in it. Because Java doesn’t provide top-level functions itself, using the function
    from Java must go through that intermediate class as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，这将生成一个包含我们的函数的类文件 `MainKt.class`。因为 Java 本身不提供顶级函数，所以从 Java 使用该函数必须通过这个中间类，如下所示：
- en: '[PRE69]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ Imports the class Kotlin created to wrap the function
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Kotlin 创建的用于封装函数的类
- en: ❷ Invokes the function through Java’s static method syntax
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过 Java 的静态方法语法调用函数
- en: 'Another key convenience in Kotlin is its built-in treatment of properties.
    By using a little `val` and `var`, we never end up writing screens full of boilerplate
    getters and setters. Using Kotlin classes from Java reveals that at the lower
    level, those methods have been there all along—Kotlin just wraps them up for our
    convenience, as shown here:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的另一个关键便利之处在于其对属性的内置处理。通过使用一点 `val` 和 `var`，我们永远不会写满屏幕的样板代码 getter 和 setter。从
    Java 使用 Kotlin 类可以看出，在底层，这些方法一直都在那里——Kotlin 只是方便地封装了它们，如下所示：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ❶ Our property is var, so it is mutable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的属性是 var，所以它是可变的。
- en: ❷ The Kotlin class is still instantiated with new when used from Java.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当从 Java 使用时，Kotlin 类仍然使用 new 实例化。
- en: ❸ Accessing Person.name in Kotlin, is Person.getName() in Java.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 Kotlin 中访问 Person.name，在 Java 中是 Person.getName()。
- en: ❹ Accessing Person.name = “...” in Kotlin is Person.setName(“...”) in Java.
    Note that this accessor is available only because the Person class declares the
    name property a var, or mutable. If name was instead declared val, only the getName()
    accessor would be generated.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 Kotlin 中访问 Person.name = “...”，在 Java 中是 Person.setName(“...”)。请注意，这个访问器之所以可用，是因为
    Person 类将名称属性声明为 var，即可变的。如果名称被声明为 val，则只会生成 getName() 访问器。
- en: Note This example reveals that under the covers, Kotlin has been doing the standard
    pattern of creating a private field and wrapping access to the field. Kotlin lets
    us use the more natural property access form without the risks of exposing fields
    directly.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此示例表明，在幕后，Kotlin 一直在执行创建私有字段并封装对字段访问的标准模式。Kotlin 允许我们使用更自然的属性访问形式，而不必直接暴露字段的风险。
- en: A number of other convenient features in Kotlin don’t manifest in the resulting
    code when used from another JVM language. Named arguments are one example— Java
    just doesn’t have a way to address an argument by name, so that nicety remains
    only in Kotlin code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的一些其他便利功能在使用其他 JVM 语言时不会在生成的代码中体现出来。命名参数是一个例子——Java 没有通过名称引用参数的方法，所以这种优雅性只存在于
    Kotlin 代码中。
- en: 'At the surface level, it might seem as though default values would suffer the
    same fate—after all, calling from Java requires that you explicitly pass in all
    arguments to the function as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面层面上，默认值可能会遭受相同的命运——毕竟，从 Java 调用需要你明确传递所有参数给函数，如下所示：
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ The standard Kotlin default value for the argument words
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于参数单词的标准 Kotlin 默认值
- en: '❷ We can’t invoke with default or we get a compile error, reason: actual and
    formal argument lists differ in length.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不能使用默认值调用它，否则会得到编译错误，原因是实际参数列表和形式参数列表的长度不同。
- en: ❸ We can pass our own value.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们可以传递自己的值。
- en: 'However, an escape hatch exists, which means we don’t have to abandon Kotlin’s
    tidiness. The `@JvmOverloads` annotation tells Kotlin to explicitly generate the
    necessary variations of a function, so calling it from other JVM languages looks
    the same:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个逃生门，这意味着我们不必放弃 Kotlin 的整洁性。`@JvmOverloads` 注解告诉 Kotlin 显式生成函数所需的必要变体，因此从其他
    JVM 语言调用它看起来相同：
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ Annotates our Kotlin function and provides the default as before
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注释我们的 Kotlin 函数并提供默认值，与之前一样
- en: ❷ Works fine and prints the default “Hi there”
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行正常并打印默认的“Hi there”
- en: ❸ Works as before and prints our passed alternate greeting
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与之前一样运行，并打印我们传递的备用问候语
- en: Several other annotations allow for controlling how our Kotlin code manifests
    at the JVM level. One we’ve already seen in another context is `@JvmName`. This
    applies to functions as well as files to control the eventual naming outside Kotlin.
    `@JvmField` lets us avoid property wrappers and expose a bare field to the world
    if required.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 几个其他注释允许我们控制 Kotlin 代码在 JVM 层面的表现。我们已经在另一个上下文中看到的一个是 `@JvmName`。它适用于函数以及文件，以控制
    Kotlin 之外最终命名的命名。`@JvmField` 允许我们在需要时避免属性包装器并向世界公开裸字段。
- en: 'Last, but certainly not least, is `@JvmStatic`. As we’ve seen earlier, Kotlin
    will wrap top-level functions in specially named classes, which can be accessed
    as static methods in Java. There’s one prominent static method in all Java applications,
    even if you avoid statics otherwise: the `main` method that starts an application.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，是 `@JvmStatic`。正如我们之前所看到的，Kotlin 将顶层函数包装在特别命名的类中，这些类可以作为 Java 中的静态方法访问。在所有
    Java 应用程序中都有一个突出的静态方法，即使你避免使用静态方法：启动应用程序的 `main` 方法。
- en: 'If we wanted to create an application in Kotlin, you can define its `main`
    method with `@JvmStatic` to avoid any weird naming needs on startup like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Kotlin 中创建一个应用程序，可以使用 `@JvmStatic` 定义其 `main` 方法，以避免在启动时出现任何奇怪的命名需求，如下所示：
- en: '[PRE73]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ❶ The App class we’d specify as our main class to start up.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将指定为主类的 App 类以启动。
- en: ❷ @JvmStatic means this function will present as a static method on the containing
    class, not just on the companion.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `@JvmStatic` 表示此函数将作为包含类上的静态方法呈现，而不仅仅是伴生对象上的。
- en: 'Making a change of language on a project is usually a huge step. Kotlin eases
    this burden, though, by leaning on standard patterns for multilanguage projects
    on the JVM. Unsurprisingly, there’s additional tooling as well if you’re using
    IntelliJ IDEA. We’ll look at the standard project layout in chapter 11, but for
    now it’s enough to know that projects typically embed the languages used into
    the directory layout like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中更改语言通常是一个巨大的步骤。然而，Kotlin 通过依赖 JVM 多语言项目的标准模式来减轻这种负担。不出所料，如果你使用 IntelliJ
    IDEA，还有额外的工具。我们将在第 11 章中查看标准项目布局，但就目前而言，只需知道项目通常将使用的语言嵌入到目录布局中，如下所示：
- en: '[PRE74]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This separation makes it easy for build tools to find what they need for all
    your code to coexist.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离使得构建工具很容易找到它们需要的东西，以便所有代码可以共存。
- en: If you’re using IntelliJ IDEA, the good folks at JetBrains have taken this a
    step further. By right-clicking on a Java file, you’ll find an item convert that
    single file directly to Kotlin. Pasting Java code into a Kotlin file will also
    offer this same conversion. This makes it possible to start conversion on a system
    from whatever point makes the most sense—perhaps with tests or a module that isn’t
    deeply entangled in the remainder of an app.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 IntelliJ IDEA，JetBrains 的好人们已经将这一功能进一步扩展。通过在 Java 文件上右键单击，你会找到一个“转换”选项，可以直接将单个文件转换为
    Kotlin。将 Java 代码粘贴到 Kotlin 文件中也会提供相同的转换功能。这使得从系统中的任何合理点开始转换都成为可能——也许是从测试或与应用程序其余部分不太紧密耦合的模块开始。
- en: The IDE will walk you through additional steps as necessary, but converting
    does take a little more than just switching some source files. Your build tools
    need to know about Kotlin to compile it alongside your existing code. Also, the
    Kotlin standard library `kotlin-stdlib` needs to be included in your project as
    a dependency. We’ll see more about how to manage these sorts of dependencies in
    chapter 11.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，IDE会引导你完成额外的步骤，但转换确实需要比仅仅切换一些源文件更多的工作。你的构建工具需要知道Kotlin以便与现有代码一起编译它。此外，Kotlin标准库`kotlin-stdlib`需要作为依赖项包含到你的项目中。我们将在第11章中了解更多关于如何管理这类依赖项的内容。
- en: Note Although IntelliJ IDEA provides a Java-to-Kotlin translation, it does not
    go the other direction. Its translations may also not be the ideal way to write
    your code in Kotlin. Keep that source control handy as always when starting a
    big conversion.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管IntelliJ IDEA提供了Java到Kotlin的翻译，但它不支持反向翻译。它的翻译可能也不是用Kotlin编写代码的理想方式。在开始大规模转换时，始终要保留源代码控制。
- en: The fact that Kotlin compiles to class files and provides much of its additional
    functionality through libraries means that even including this new language in
    your project doesn’t change that you’re just running on the good old JVM.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译成类文件并提供大量附加功能通过库来实现，这意味着即使将这种新语言包含到你的项目中，也不会改变你只是在运行那个好用的旧JVM。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kotlin is a pragmatic, attractive alternative language on the JVM.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 是JVM上的一种实用且吸引人的替代语言。
- en: Kotlin draws on years of production Java use and, as a new language, made changes
    that Java can likely never duplicate due to backward compatibility.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 从多年的生产级 Java 使用经验中汲取灵感，作为一个新语言，它做出了Java可能由于向后兼容性而无法复制的改变。
- en: Kotlin prizes its conciseness. Familiar constructs in Java can almost always
    be written with less code in Kotlin.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 非常重视其简洁性。在Java中熟悉的构造在Kotlin中几乎总是可以用更少的代码来编写。
- en: Safety is key for Kotlin, with `null` safety baked directly into the language
    to reduce `NullPointerException`s in production.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Kotlin来说，安全性至关重要，它直接将`null`安全性嵌入到语言中，以减少生产中的`NullPointerException`。
- en: Coroutines provide a compelling concurrency alternative to Java’s classic threading
    model.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程提供了对Java经典线程模型的引人注目的并发替代方案。
- en: Kotlin script (`kts`) enables scripting that previously would have been the
    domain of dynamic languages or shell.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin脚本（`kts`）使得以前动态语言或shell的领域也可以进行脚本编写。
- en: Even build scripts can be written using Kotlin, as we’ll see in detail in chapter
    11 when we discuss Gradle.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是构建脚本也可以使用Kotlin编写，正如我们将在第11章详细讨论Gradle时所见。
