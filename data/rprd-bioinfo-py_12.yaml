- en: 'Chapter 11\. Finding a Protein Motif: Fetching Data and Using Regular Expressions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。查找蛋白质基序：获取数据和使用正则表达式
- en: We’ve spent quite a bit of time now looking for sequence motifs. As described
    in [the Rosalind MPRT challenge](https://oreil.ly/EAp3i), shared or conserved
    sequences in proteins imply shared functions. In this exercise, I need to identify
    protein sequences that contain the N-glycosylation motif. The input to the program
    is a list of protein IDs that will be used to download the sequences from [the
    UniProt website](https://www.uniprot.org). After demonstrating how to manually
    and programmatically download the data, I’ll show how to find the motif using
    a regular expression and by writing a manual solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们花了相当多的时间寻找序列基序。如[罗莎琳德MPRT挑战](https://oreil.ly/EAp3i)所述，蛋白质中的共享或保守序列意味着共享功能。在这个练习中，我需要识别包含N-糖基化基序的蛋白质序列。程序的输入是一个蛋白质ID列表，将用于从[UniProt网站](https://www.uniprot.org)下载序列。在演示了如何手动和编程方式下载数据之后，我将展示如何使用正则表达式和编写手动解决方案来查找这一基序。
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: How to programmatically fetch data from the internet
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从互联网上获取数据
- en: How to write a regular expression to find the N-glycosylation motif
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写正则表达式来查找N-糖基化基序
- en: How to manually find the N-glycosylation motif
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何手动查找N-糖基化基序
- en: Getting Started
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'All the code and tests for this program are located in the *11_mprt* directory.
    To begin, copy the first solution to the program `mprt.py`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这个程序的代码和测试都位于*11_mprt*目录中。要开始，请将第一个解决方案复制到程序`mprt.py`中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inspect the usage:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 检查用法：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1)'
- en: The required positional argument is a file of protein IDs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的位置参数是一个蛋白质ID文件。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2)'
- en: The optional download directory name defaults to *fasta*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的下载目录名默认为*fasta*。
- en: 'The input file will list protein IDs, one per line. The protein IDs provided
    in the Rosalind example comprise the first test input file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件将列出蛋白质ID，每行一个。在罗莎琳德示例中提供的蛋白质ID组成了第一个测试输入文件：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the program using this as the argument. The output of the program lists
    each protein ID containing the N-glycosylation motif and the locations where it
    can be found:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此参数运行程序。程序的输出列出包含N-糖基化基序及其位置的每个蛋白质ID：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After running the preceding command, you should see that the default *fasta*
    directory has been created. Inside you should find four FASTA files. All subsequent
    runs using these protein IDs will be faster as the cached data will be used unless
    you remove the download directory, for instance by running **`make clean`**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，你应该看到默认的*fasta*目录已创建。在其中你应该找到四个FASTA文件。除非你删除下载目录（例如运行**`make clean`**），否则使用这些蛋白质ID的所有后续运行都会更快，因为将使用缓存数据。
- en: 'Take a look at the first two lines of each file using the command **`head -2`**.
    The headers for some of the FASTA records are quite long so I’ve broken them here
    so they won’t wrap, but the actual headers must be on a single line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令**`head -2`**查看每个文件的前两行。某些FASTA记录的标题相当长，所以我在这里分行显示它们以防止换行，但实际的标题必须在一行内：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run **`make test`** to see the kinds of tests your program should pass. When
    you’re ready, start the program from scratch:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`make test`**查看程序应通过的测试类型。当你准备好时，从头开始运行程序：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should define a positional file argument and an optional download directory
    as the arguments to the program:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该定义一个位置文件参数和一个可选的下载目录作为程序的参数：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1)'
- en: The `file` will be a filehandle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`将是一个文件句柄。'
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2)'
- en: The `download_dir` will be a string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_dir`将是一个字符串。'
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3)'
- en: Ensure the `file` argument is a readable text file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`file`参数是一个可读的文本文件。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4)'
- en: The `download_dir` is an optional string with a reasonable default value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_dir`是一个可选的字符串，有一个合理的默认值。'
- en: 'Ensure your program can create the usage, then start by printing the protein
    IDs from the file. Each ID is terminated by a newline, so I’ll use the `str.rstrip()`
    (*right strip*) method to remove any whitespace from the right side:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的程序可以创建用法，然后开始打印文件中的蛋白质ID。每个ID以换行符结尾，所以我将使用`str.rstrip()`（*右侧去除*）方法从右侧去除任何空白：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program and make sure you see the protein IDs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，确保你看到蛋白质ID：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run **`pytest`**, you should pass the first three tests and fail the
    fourth.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行**`pytest`**，你应该通过前三个测试并失败第四个。
- en: Downloading Sequences Files on the Command Line
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载命令行上的序列文件
- en: 'The next order of business is fetching the protein sequences. The UniProt information
    for each protein is found by substituting the protein ID into the URL *http://www.uniprot.org/uniprot/{uniprot_id}*.
    I’ll change the program to print this string instead:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个工作是获取蛋白质序列。每个蛋白质的UniProt信息可以通过将蛋白质ID替换到URL *http://www.uniprot.org/uniprot/{uniprot_id}*
    中找到。我将修改程序以打印这个字符串：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should now see this output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到这个输出：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Paste the first URL into your web browser and inspect the page. There is a wealth
    of data, all in a human-readable format. Scroll down to the sequence, and you
    should see 203 amino acids. It would be awful to have to parse this page to extract
    the sequence. Luckily, I can append *.fasta* to the URL and get a FASTA file of
    the sequence.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个URL粘贴到你的Web浏览器中并检查页面。这里有大量的数据，全部以人类可读的格式展示。向下滚动到序列，你应该看到203个氨基酸。如果必须解析此页面以提取序列，那将是件糟糕的事情。幸运的是，我可以在URL末尾添加*.fasta*并获得序列的FASTA文件。
- en: 'Before I show you how to download the sequences using Python, I think you should
    know how to do this using command-line tools. From the command line, you can use
    `curl` (which you may need to install) to download the sequence. By default, this
    will print the contents of the file to `STDOUT`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示如何使用Python下载序列之前，我认为你应该知道如何使用命令行工具来做这件事。从命令行可以使用`curl`（你可能需要安装）来下载序列。默认情况下，这会将文件内容打印到`STDOUT`：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You could either redirect this to a file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其重定向到文件：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'or use the `-o|--output` option to name the output file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`-o|--output`选项来命名输出文件：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use `wget` (*web get*, which may also need to be installed) to
    download the sequence file like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`wget`（网络获取，可能需要安装）来下载序列文件，就像这样：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Whichever tool you use, you should now have a file called *A2Z669.fasta* with
    the sequence data:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种工具，现在你应该有一个名为*A2Z669.fasta*的包含序列数据的文件：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I know this is a book on Python, but it’s worth learning how to write a basic
    `bash` program. Just as some stories can be told in a haiku and others are sprawling
    novels, some tasks are easily expressed using a few shell commands and others
    require thousands of lines of code in a more complex language. Sometimes I can
    write 10 lines of `bash` to do what I need. When I hit about 30 lines of `bash`,
    I generally move to Python or Rust.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是一本关于Python的书，但学习如何编写基本的`bash`程序也是值得的。就像有些故事可以用俳句来讲述，而另一些则是庞大的小说，有些任务可以用几个shell命令轻松表达，而其他则需要更复杂语言的数千行代码。有时我可以用10行`bash`来做我需要的事情。当我达到大约30行`bash`时，我通常会转向Python或Rust。
- en: 'Here is how I could automate downloading the proteins with a `bash` script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我如何使用`bash`脚本自动下载蛋白质的方式：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1)'
- en: The shebang (`#!`) should use the `env` (environment) to find `bash`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: shebang（`#!`）应该使用`env`（环境）来找到`bash`。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2)'
- en: Check that the number of arguments (`$#`) is `1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 检查参数的数量（`$#`）是否为`1`。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3)'
- en: Print a usage statement using the program basename (`$0`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序的基本名称（`$0`）打印使用语句。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4)'
- en: Exit with a nonzero value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用非零值退出。
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5)'
- en: Define the output directory to be *fasta*. Note that in `bash` you can have
    no spaces around the `=` for variable assignment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定义输出目录为*fasta*。请注意，在`bash`中，您可以在变量分配周围没有空格。
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6)'
- en: Create the output directory if it does not exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出目录不存在，则创建它。
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7)'
- en: Read each line from the file into the `PROT_ID` variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件中的每一行读入`PROT_ID`变量中。
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8)'
- en: Print the current protein ID so the user knows something is happening.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打印当前蛋白质ID，以便用户知道正在发生某事。
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9)'
- en: Construct the URL by using variable interpolation inside double quotes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号内的变量插值构建URL。
- en: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10)'
- en: Construct the output filename by combining the output directory and the protein
    ID.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合输出目录和蛋白质ID构建输出文件名。
- en: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11)'
- en: Call `wget` with the `-q` (quiet) flag to fetch the URL into the output file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-q`（静默）标志调用`wget`，将URL获取到输出文件中。
- en: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12)'
- en: This reads each line from the first positional argument (`$1`), which is the
    input filename.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这从第一个位置参数（`$1`）读取每一行，即输入文件名。
- en: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13)'
- en: Let the user know the program has finished and where to find the output.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户知道程序已经完成，并告知输出文件的位置。
- en: 'I can run this like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以像这样运行它：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now there should be a *fasta* directory containing the four FASTA files. One
    way to write the `mprt.py` program would be to fetch all the input files first
    using something like this and then provide the FASTA files as arguments. This
    is a very common pattern in bioinformatics, and writing a shell script like this
    is a great way to document exactly how you retrieved the data for your analysis.
    Be sure you always commit programs like this to your source repository, and consider
    adding a *Makefile* target with a name like *fasta* that is flush-left followed
    by a colon and the command on the next line indented with a single tab character:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有一个*fasta*目录，其中包含四个FASTA文件。编写`mprt.py`程序的一种方法是首先使用类似于这样的东西获取所有输入文件，然后将FASTA文件作为参数提供。这在生物信息学中是非常常见的模式，编写这样的shell脚本是记录确切地如何检索数据以进行分析的绝佳方式。确保像这样的程序始终提交到您的源代码库，并考虑添加一个名称为*fasta*的*Makefile*目标，其左侧紧随着一个冒号，后面是一个单个制表符缩进的命令：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you should be able to run **`make fasta`** to automate the process of getting
    your data. By writing the program to accept the input file as an argument rather
    than hard-coding it, I can use this program and multiple *Makefile* targets to
    automate the process of downloading many different datasets. Reproducibility for
    the win.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够运行**`make fasta`**来自动化获取数据的过程。通过编写程序以接受输入文件作为参数而不是硬编码它，我可以使用此程序和多个*Makefile*目标来自动化下载许多不同的数据集的过程。复现性为胜利。
- en: Downloading Sequences Files with Python
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python下载序列文件
- en: 'I’ll translate the `bash` utility to Python now. As you can see from the preceding
    program, there are several steps involved to fetch each sequence file. I don’t
    want this to be a part of `main()` as it will clutter the program, so I’ll write
    a function for this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将把`bash`实用程序翻译成Python。正如你从前面的程序中看到的那样，获取每个序列文件涉及到几个步骤。我不希望这成为`main()`的一部分，因为它会使程序变得凌乱，所以我会为此编写一个函数：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1)'
- en: The function will accept a filehandle for the protein IDs and a download directory
    name, and will return a list of the files that were downloaded or were already
    present. Be sure to add `typing.List` to your imports.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将接受蛋白质 ID 的文件句柄和下载目录名称，并返回已下载或已存在的文件列表。务必将 `typing.List` 添加到您的导入中。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2)'
- en: For now, return an empty list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时返回一个空列表。
- en: 'I want to call it like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这样调用它：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run your program and ensure it compiles and prints nothing. Now add the following
    Python code to fetch the sequences. You’ll need to import `os`, `sys`, and [`requests`](https://oreil.ly/nYSUM),
    a library for making web requests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行您的程序，并确保它编译并且不打印任何内容。现在添加以下 Python 代码来获取序列。您需要导入 `os` 、`sys` 和 [`requests`](https://oreil.ly/nYSUM)
    ，这是用于进行网络请求的库：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1)'
- en: Create the output directory if it does not exist.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出目录不存在，则创建它。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2)'
- en: Create the directory and any needed parent directories.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，则创建目录及其所需的父目录。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3)'
- en: Initialize the return list of filenames.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化返回文件名列表。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4)'
- en: Read each protein ID from the file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取每个蛋白质 ID。
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5)'
- en: Construct the output filename by combining the output directory plus the protein
    ID.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 构造输出文件名，将输出目录与蛋白质 ID 结合起来。
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6)'
- en: Check if the file already exists.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否已存在。
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7)'
- en: Construct the URL to the FASTA file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 构造到 FASTA 文件的 URL。
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8)'
- en: Make a *GET* request for the file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 *GET* 请求获取文件。
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9)'
- en: A response code of 200 indicates success.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 200 的响应代码表示成功。
- en: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10)'
- en: Write the text of the response to the output file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应的文本写入输出文件。
- en: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11)'
- en: Print a warning to `STDERR` that the file could not be fetched.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将一条警告打印到 `STDERR` ，指出文件无法获取。
- en: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12)'
- en: Skip to the next iteration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到下一次迭代。
- en: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13)'
- en: Append the file to the return list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件追加到返回列表中。
- en: '[![14](assets/14.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14)'
- en: Return the files that now exist locally.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回现在本地存在的文件。
- en: '`os.makedirs()` is an example of a function that will throw an exception if
    it fails. This might happen due to the user having insufficient permissions to
    create a directory, or because of a disk error. What would be the point in my
    catching and handling such an error? If my program is unable to fix a problem,
    I feel it’s better to let it crash loudly, producing an error code and a stacktrace
    of what went wrong. A human would have to fix the underlying problems before the
    program could work. Catching and mishandling the exception would be far worse
    than letting the program crash.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.makedirs()`是一个示例函数，如果创建失败会抛出异常。这可能是由于用户权限不足以创建目录，或者由于磁盘错误。我捕获和处理这种错误的目的是什么？如果我的程序无法解决问题，我觉得让它大声崩溃，输出错误代码和堆栈跟踪，比捕获和处理异常要好得多。人们必须在程序能够工作之前解决潜在的问题。捕获和错误处理异常比让程序崩溃更糟糕。'
- en: 'That logic almost exactly mirrors that of the `bash` program. If you run your
    program again, there should be a *fasta* directory with the four files, and the
    program should print the names of the downloaded files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑几乎与`bash`程序完全相似。如果重新运行程序，应该会有一个*fasta*目录，其中包含四个文件，并且程序应该会打印出下载文件的名称：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Writing a Regular Expression to Find the Motif
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写正则表达式以查找基序
- en: 'The Rosalind page notes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Rosalind页面指出：
- en: 'To allow for the presence of its varying forms, a protein motif is represented
    by a shorthand as follows: `[XY]` means *either X or Y* and `{X}` means *any amino
    acid except X*. For example, the N-glycosylation motif is written as `N{P}[ST]{P}`.'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了允许其变化形式的存在，蛋白质基序以以下缩写表示：`[XY]`表示*要么是X或Y*，`{X}`表示*除了X以外的任何氨基酸*。例如，N-糖基化基序写作`N{P}[ST]{P}`。
- en: The [Prosite website](https://oreil.ly/aFwWe) is a database of protein domains,
    families, and functional sites. The [details for the N-glycosylation motif](https://oreil.ly/VrQLl)
    show a similar convention for the *consensus pattern* of `N-{P}-[ST]-{P}`. Both
    patterns are extremely close to the regular expression shown in [Figure 11-1](#fig_11.1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[Prosite网站](https://oreil.ly/aFwWe)是一个蛋白质域、家族和功能位点的数据库。[N-糖基化基序的详细信息](https://oreil.ly/VrQLl)显示了类似的*共识模式*
    `N-{P}-[ST]-{P}`。这两种模式与图 11-1中显示的正则表达式非常接近。'
- en: '![mpfb 1101](assets/mpfb_1101.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1101](assets/mpfb_1101.png)'
- en: Figure 11-1\. A regular expression for the N-glycosylation protein motif
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. N-糖基化蛋白质基序的正则表达式
- en: In this regex, the `N` indicates the literal character *N*. The `[ST]` is a
    character class representing either the character *S* or *T*. It’s the same as
    the regex `[GC]` I wrote in [Chapter 5](ch05.html#ch05) to find either *G* or
    *C*. The `[^P]` is a *negated* character class, which means it will match any
    character that is *not P*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个正则表达式中，`N`表示字面字符*N*。`[ST]`是一个字符类，表示字符*S*或*T*。它与我在[第5章](ch05.html#ch05)中写的`[GC]`正则表达式找到*G*或*C*的方式相同。`[^P]`是一个*否定*字符类，表示匹配任何不是*P*的字符。
- en: Some people (OK, mostly me) like to represent regexes using the notation of
    finite state machines (FSMs), such as the one shown in [Figure 11-2](#fig_11.2).
    Imagine the pattern entering on the left. It first needs to find the letter *N*
    to proceed to the next step. Next can be any character that is not the letter
    *P*. After that, the graph has two alternate paths through the letters *S* or
    *T*, which must be followed again by a not-*P* character. If the pattern makes
    it to the double circle, the match was successful.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人（好吧，主要是我）喜欢使用有限状态机（FSMs）的符号来表示正则表达式，例如[图 11-2](#fig_11.2)中显示的这种表示方式。想象模式从左侧输入。它首先需要找到字母*N*，才能进行下一步。接下来可以是任何不是字母*P*的字符。然后，图表有两条经过字母*S*或*T*的替代路径，之后必须再次跟随一个非*P*字符。如果模式到达双圆圈，表示匹配成功。
- en: '![mpfb 1102](assets/mpfb_1102.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1102](assets/mpfb_1102.png)'
- en: Figure 11-2\. Graphical depiction of an FSM to identify the N-glycosylation
    motif
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-2\. 识别N-糖基化基序的FSM的图形表示
- en: 'In [Chapter 8](ch08.html#ch08), I pointed out a problem when using regular
    expressions to find overlapping text. There are no instances of this in the first
    test file, but another of the datasets I used to solve the problem did have two
    overlapping motifs. Let me demonstrate in the REPL:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html#ch08)中，我指出使用正则表达式查找重叠文本时存在问题。第一个测试文件中没有这种情况，但我用来解决问题的另一个数据集确实有两个重叠的基序。让我在REPL中演示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’m using the `re.compile()` function here to force the regex engine to parse
    the pattern and create the necessary internal code to do the matching. This is
    similar to how compiled languages like C use source code that humans can edit
    and read into machine code that computers can directly execute. This transformation
    happens once when you use `re.compile()`, whereas functions like `re.search()`
    must recompile the regex on each call.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我使用`re.compile()`函数来强制正则表达式引擎解析模式并创建必要的内部代码来进行匹配。这类似于编译语言如 C 使用人类可编辑和读取的源代码转换为计算机可以直接执行的机器代码。这种转换在使用`re.compile()`时只发生一次，而像`re.search()`这样的函数必须在每次调用时重新编译正则表达式。
- en: 'Here is the relevant portion of the protein sequence for *P07204_TRBM_HUMAN*
    that has the pattern starting at both the first and second positions (see [Figure 11-3](#fig_11.3)).
    The `re.findall()` function shows that only the pattern starting at the first
    position is found:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*P07204_TRBM_HUMAN*蛋白序列的相关部分，该部分具有在第一和第二位置开始的模式（见[图 11-3](#fig_11.3)）。`re.findall()`函数显示仅找到第一个位置开始的模式：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![mpfb 1103](assets/mpfb_1103.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1103](assets/mpfb_1103.png)'
- en: Figure 11-3\. This sequence contains two copies of the motif that overlap
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-3\. 此序列包含两个重叠的模体副本
- en: 'As in [Chapter 8](ch08.html#ch08), the solution is to wrap the regex in a look-ahead
    assertion using `?=(<*pattern*>`), which itself will need to be wrapped in capturing
    parentheses:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[第 8 章](ch08.html#ch08)中一样，解决方案是将正则表达式包装在一个使用`?=(<*pattern*>`的前瞻断言中，这本身需要包装在捕获括号中：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I need to know the positions of the matches, which I can get from `re.finditer()`.
    This will return a list of `re.Match` objects, each of which has a `match.start()`
    function that will return the zero-offset index of the match’s starting position.
    I need to add 1 to report the position using 1-based counting:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要知道匹配的位置，这可以从`re.finditer()`获取。这将返回一个`re.Match`对象列表，每个对象都有一个`match.start()`函数，该函数将返回匹配起始位置的零偏移索引。我需要加
    1 以使用基于 1 的计数报告位置：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This should be enough for you to solve the rest of the problem. Keep hacking
    until you pass all the tests. Be sure to download a dataset from the Rosalind
    site and verify that your solution gives an answer that passes the test with that,
    too. See if you can also write a version that doesn’t use regular expressions.
    Go back and study the FSM model and think about how you can implement those ideas
    in Python code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足以帮助您解决剩下的问题。继续进行修改，直到通过所有测试为止。确保从 Rosalind 站点下载数据集，并验证您的解决方案是否能够通过该测试。看看是否还可以编写一个不使用正则表达式的版本。回顾一下
    FSM 模型，并思考如何在 Python 代码中实现这些想法。
- en: Solutions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: I will present two variations to solve this problem. Both use the same `get_args()`
    and `fetch_fasta()` functions shown previously. The first uses a regular expression
    to find the motif, and the second imagines how to solve the problem in a horrible,
    desolate intellectual wasteland where regular expressions don’t exist.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我将提出两种解决此问题的变体。两者都使用先前显示的相同的`get_args()`和`fetch_fasta()`函数。第一种使用正则表达式找到模体，第二种则设想在一个可怕的、荒凉的智力荒原中解决问题，在那里正则表达式不存在。
- en: 'Solution 1: Using a Regular Expression'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：使用正则表达式
- en: 'The following is my final solution using a regular expression. Be sure to import
    `re` and `Bio.SeqIO` for this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我使用正则表达式的最终解决方案。确保为此导入`re`和`Bio.SeqIO`：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1)'
- en: Fetch the sequence files for the protein IDs in the given file. Put the files
    into the indicated download directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定文件中的蛋白质ID获取序列文件。将文件放入指定的下载目录中。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2)'
- en: Compile the regex for the N-glycosylation motif.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 N-糖基化模体的正则表达式。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3)'
- en: Iterate through the files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历文件。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4)'
- en: Get the protein ID from the basename of the file minus the file extension.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件的基本名称减去文件扩展名获取蛋白质ID。
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5)'
- en: Create a lazy iterator to fetch the FASTA sequences from the file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个懒惰迭代器以从文件中获取 FASTA 序列。
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6)'
- en: Attempt to retrieve the first sequence record from the iterator.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从迭代器中检索第一个序列记录。
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7)'
- en: Coerce the sequence to a `str`, then try to find all the matches for the motif.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 强制将序列转换为 `str`，然后尝试查找文本中基序的所有匹配项。
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8)'
- en: Print the protein ID.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打印蛋白质 ID。
- en: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9)'
- en: Print all the matches, correcting to 1-based counting.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打印所有匹配项，修正为基于1的计数。
- en: 'In this solution, I used the `os.path.basename()` and `os.path.splitext()`
    functions. I often use these, so I want to make sure you understand exactly what
    they do. I first introduced the `os.path.basename()` in [Chapter 2](ch02.html#ch02).
    This function will return the filename from a path that might include directories:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，我使用了 `os.path.basename()` 和 `os.path.splitext()` 函数。我经常使用这些函数，所以我希望确保你准确理解它们的作用。我首次在
    [第2章](ch02.html#ch02) 中介绍了 `os.path.basename()` 函数。此函数将从可能包含目录的路径中返回文件名：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `os.path.splitext()` function will break a filename into the part before
    the file extension and the extension:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `os.path.splitext()` 将文件名分解为文件扩展名前部分和扩展名部分：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: File extensions can provide useful metadata about a file. For instance, your
    operating system may know to use Microsoft Excel to open files ending in *.xls*
    or *.xlsx*. There are many conventions for FASTA extensions, including *.fasta*,
    *.fa*, *.fna* (for nucleotides), and *.faa* (for amino acids). You can put whatever
    extension you like on a FASTA file or none at all, but remember that a FASTA file
    is always plain text and needs no special application to view it. Also, just because
    a file has a FASTA-like extension does not necessarily mean it’s a FASTA file.
    *Caveat emptor*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名可以提供有关文件的有用元数据。例如，您的操作系统可能知道要使用 Microsoft Excel 打开以 *.xls* 或 *.xlsx* 结尾的文件。有许多用于
    FASTA 扩展名的约定，包括 *.fasta*、*.fa*、*.fna*（用于核苷酸）和 *.faa*（用于氨基酸）。您可以为 FASTA 文件添加任何扩展名或不添加扩展名，但请记住，FASTA
    文件始终是纯文本，无需特殊应用程序即可查看。此外，仅因为文件具有类似 FASTA 的扩展名并不一定意味着它是 FASTA 文件。*买方自负*。
- en: 'In the preceding code, I don’t need the extension, so I assign it to the variable
    `_` (underscore), which is a convention indicating that I don’t intend to use
    the value. I could also use a list slice to grab the first element from the function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我不需要扩展名，所以我将其赋值给变量 `_`（下划线），这是一种表明我不打算使用该值的约定。我还可以使用列表切片从函数中获取第一个元素：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Solution 2: Writing a Manual Solution'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：编写手动解决方案
- en: 'If I were writing a program like this for production use, I would use a regular
    expression to find the motif. In this context, though, I wanted to challenge myself
    to find a manual solution. As usual, I want to write a function to encapsulate
    this idea, so I stub it out:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我为了生产使用而编写这样的程序，我将使用正则表达式来查找基序。然而，在这种情况下，我想挑战自己找到一个手动解决方案。像往常一样，我想写一个函数来封装这个想法，所以我先草拟出来：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1)'
- en: The function will take some text and return a list of integers where the motif
    can be found in the text.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将获取一些文本，并返回在文本中可以找到基序的整数列表。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2)'
- en: For now, return the empty list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回空列表。
- en: 'The biggest reason to have a function is to write a test where I encode examples
    I expect to match and fail:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有函数的最大原因是写一个测试，我会编码我期望匹配和失败的示例：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1)'
- en: Ensure the function does not do something silly like raise an exception when
    given the empty string.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保函数在给定空字符串时不会像抛出异常这样愚蠢地做某事。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2)'
- en: This should fail because it has a *P* in the second position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该失败，因为第二个位置有一个 *P*。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3)'
- en: This should fail because it has a *P* in the fourth position.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该失败，因为第四个位置有一个 *P*。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4)'
- en: This should find the motif at the beginning of the string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在字符串开头找到基序。
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5)'
- en: This should find the motif not at the beginning of the string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该找到不在字符串开头的基序。
- en: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6)'
- en: This should find overlapping motifs at the beginning of the string.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在字符串开头找到重叠的基序。
- en: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7)'
- en: This should find overlapping motifs not at the beginning of the string.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该找到不在字符串开头的重叠基序。
- en: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8)'
- en: This is a slightly more complicated pattern containing four copies of the motif.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微复杂的模式，包含四个基序的副本。
- en: 'I can add these functions to my `mprt.py` program and I can run `pytest` on
    that source code to ensure that the tests *do* fail as expected. Now I need to
    write the `find_motif()` code that will pass these tests. I decided I would again
    use k-mers, so I will bring in the `find_kmers()` function (and test it, of course,
    but I’ll omit that here) from Chapters [9](ch09.html#ch09) and [10](ch10.html#ch10):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将这些函数添加到我的 `mprt.py` 程序中，并可以在该源代码上运行 `pytest` 来确保测试*如预期般*失败。现在我需要编写 `find_motif()`
    代码来通过这些测试。我决定再次使用 k-mer，所以我将从第 [9](ch09.html#ch09) 章和第 [10](ch10.html#ch10) 章带入
    `find_kmers()` 函数（当然，我会测试它，但我会在这里省略）：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since the motif is four characters long, I can use this to find all the 4-mers
    in a sequence:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基序长度为四个字符，我可以用它来找到序列中所有的 4-mer：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I will also need their positions. The `enumerate()` function I introduced in
    [Chapter 8](ch08.html#ch08) will provide both the indexes and values of the items
    in a sequence:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要它们的位置。我在第 [8](ch08.html#ch08) 章介绍的 `enumerate()` 函数将为序列中的项提供索引和值：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I can unpack each position and k-mer while iterating like so:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在迭代时展开每个位置和 k-mer，像这样：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Take the first k-mer, *NNTS*. One way to test for this pattern is to manually
    check each index:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 取第一个 k-mer，*NNTS*。一种测试这种模式的方法是手动检查每个索引：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I know the first two k-mers should match, and this is borne out:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道前两个 k-mer 应该匹配，事实证明如此：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'While effective, this is tedious. I would like to hide this code in a function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有效，但这太繁琐了。我想把这段代码隐藏在一个函数中：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is a test I wrote for the function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为该函数编写的一个测试：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1)'
- en: If a function accepts a string parameter, I always test with an empty string.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数接受字符串参数，我总是用空字符串进行测试。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2)'
- en: The next two sequences should match.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个序列应该匹配。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3)'
- en: This sequence is too long and should be rejected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列过长，应予以拒绝。
- en: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4)'
- en: This sequence has a *P* in the second position and should be rejected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列第二个位置有一个 *P*，应予以拒绝。
- en: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5)'
- en: This sequence has a *P* in the fourth position and should be rejected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列在第四个位置有一个*P*，应该被拒绝。
- en: 'That makes the code much more readable:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更加可读：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I only want the k-mers that match. I could write this using an `if` expression
    with a guard, which I showed in Chapters [5](ch05.html#ch05) and [6](ch06.html#ch06):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想要匹配的k-mer。我可以使用带有保护的`if`表达式来编写这段代码，我在第[5章](ch05.html#ch05)和第[6章](ch06.html#ch06)中展示过：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or using the `starfilter()` function I showed in [Chapter 9](ch09.html#ch09):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用我在[第9章](ch09.html#ch09)中展示的`starfilter()`函数：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I only want the first elements from each of the tuples, so I could use a `map()`
    to select those:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想要每个元组的第一个元素，所以我可以使用`map()`来选择它们：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For what it’s worth, Haskell uses tuples extensively and includes two handy
    functions in the prelude: `fst()` to get the first element from a 2-tuple, and
    `snd()` to get the second. Be sure to import `typing.Tuple` for this code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就其价值而言，Haskell广泛使用元组，并在预设中包含两个方便的函数：`fst()`用于从2元组获取第一个元素，`snd()`用于获取第二个元素。确保为此代码导入`typing.Tuple`：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With these functions, I can eliminate the `starfilter()` like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我可以像这样消除`starfilter()`：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'But notice a very subtle bug if I try to use the `filter()`/`starmap()` technique
    I’ve shown a couple of times:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，如果我尝试使用`filter()`/`starmap()`技术，我之前展示过几次的话，会有一个非常微妙的 bug：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It only returns the second match. Why is that? It’s due to using `None` as the
    predicate to `filter()`. According to `help(filter)`, “If [the] function is `None`,
    return the items that are true.” In [Chapter 1](ch01.html#ch01), I introduced
    the ideas of truthy and falsey values. The Boolean values `True` and `False` are
    represented by the integer values `1` and `0`, respectively; hence, the actual
    number zero (either `int` or `float`) is technically `False`, which means that
    any nonzero number is not-`False` or, if you will, truthy. Python will evaluate
    many data types in a Boolean context to decide if they are truthy or falsey.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它只返回第二个匹配项。为什么？因为在`filter()`中使用`None`作为谓词。根据`help(filter)`，“如果函数为`None`，返回为`True`的项。”在[第1章](ch01.html#ch01)中，我介绍了真值和假值的概念。布尔值`True`和`False`分别由整数值`1`和`0`表示；因此，实际数字零（无论是`int`还是`float`）在技术上是`False`，这意味着任何非零数字都不是`False`，或者说是真值。Python会在布尔上下文中评估许多数据类型，以决定它们是真还是假。
- en: 'In this case, using `None` as the predicate for `filter()` causes it to remove
    the number `0`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将`None`用作`filter()`的谓词会导致它移除数字`0`：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I came to Python from Perl and JavaScript, both of which also silently coerce
    values given different contexts, so I was not so surprised by this behavior. If
    you come from a language like Java, C, or Haskell that has stricter types, this
    is probably quite troubling. I often feel that Python is a very powerful language
    if you know exactly what you’re doing at all times. This is a high bar, so it’s
    extremely important when writing Python to use types and tests liberally.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Perl和JavaScript转到Python，这两种语言在不同的上下文中也会悄悄地强制转换值，所以对这种行为并不感到惊讶。如果你来自像Java、C或Haskell这样有更严格类型的语言，这可能会令人非常困扰。我经常觉得Python是一种非常强大的语言，如果你在任何时候都确切地知道自己在做什么。这是一个很高的门槛，所以在编写Python代码时，大量使用类型和测试至关重要。
- en: 'In the end, I felt the list comprehension was the easiest to read. Here’s how
    I wrote my function to manually identify the protein motif:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我觉得列表推导式是最易读的。这是我如何编写我的函数手动识别蛋白质模体的方式：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1)'
- en: Get the positions and values of the 4-mers from the text.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本中获取4-mer的位置和值。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2)'
- en: Select those positions for the k-mers matching the motif.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 选择与模体匹配的k-mer的位置。
- en: 'Using this function is almost identical to how I used the regular expression,
    which is the point of hiding complexities behind functions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数几乎和我使用正则表达式的方式完全相同，这正是将复杂性隐藏在函数背后的关键所在：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1)'
- en: Try to find any matches to the motif.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试查找与模体匹配的任何匹配项。
- en: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2)'
- en: The matches are a list of 0-based indexes, so add 1 to each.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配结果是一个从0开始的索引列表，因此对每个索引加1。
- en: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3)'
- en: Convert the integer values to strings and join them on spaces to print.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数值转换为字符串，并在空格上连接它们以打印。
- en: Although this works and was fun (your mileage may vary) to write, I would not
    want to use or maintain this code. I hope it gives you a sense of how much work
    the regular expression is doing for us. Regexes allow me to describe *what* I
    want, not *how* to get it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做很有效且有趣（结果可能因人而异），但我不希望使用或维护这段代码。希望它能让您感受到正则表达式为我们做了多少工作。正则表达式允许我描述*我想要什么*，而不是*如何获得它*。
- en: Going Further
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解
- en: '[The Eukaryotic Linear Motifs database example](http://elm.eu.org/elms) provides
    regexes to find motifs that define functional sites in proteins. Write a program
    to search for any occurrence of any pattern in a given set of FASTA files.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[真核线性基序数据库示例](http://elm.eu.org/elms)提供了用于在蛋白质中定义功能位点的基序查找表达式。编写一个程序，在给定的一组FASTA文件中搜索任何模式的出现。'
- en: Review
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'Key points from this chapter:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要点：
- en: You can use command-line utilities like `curl` and `wget` to fetch data from
    the internet. Sometimes it makes sense to write a shell script for such tasks,
    and sometimes it’s better to encode this using a language like Python.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用命令行实用程序如`curl`和`wget`从互联网获取数据。有时编写一个Shell脚本执行此类任务是有意义的，有时使用像Python这样的语言来编码更好。
- en: A regular expression can find the N-glycosylation motif, but it’s necessary
    to wrap it in a look-ahead assertion and capturing parentheses to find overlapping
    matches.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式可以找到N-糖基化基序，但必须将其包装在前瞻断言和捕获括号中以找到重叠匹配。
- en: It’s possible to manually find the N-glycosylation motif, but it’s not easy.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动查找N-糖基化基序是可能的，但并不容易。
- en: The `os.path.splitext()` function is useful when you need to separate a filename
    from the extension.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要从扩展名中分离文件名时，`os.path.splitext()`函数非常有用。
- en: File extensions are conventions and may be unreliable.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件扩展名是约定俗成的，可能不可靠。
