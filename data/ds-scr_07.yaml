- en: Chapter 6\. Probability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。概率
- en: The laws of probability, so true in general, so fallacious in particular.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 概率定律，在一般情况下正确，在特定情况下谬误。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Edward Gibbon
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 爱德华·吉本
- en: It is hard to do data science without some sort of understanding of *probability*
    and its mathematics. As with our treatment of statistics in [Chapter 5](ch05.html#statistics),
    we’ll wave our hands a lot and elide many of the technicalities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对*概率*及其数学的某种理解，数据科学是很难做的。就像我们在[第5章](ch05.html#statistics)中处理统计学一样，我们将在很多地方简化和省略技术细节。
- en: For our purposes you should think of probability as a way of quantifying the
    uncertainty associated with *events* chosen from some *universe* of events. Rather
    than getting technical about what these terms mean, think of rolling a die. The
    universe consists of all possible outcomes. And any subset of these outcomes is
    an event; for example, “the die rolls a 1” or “the die rolls an even number.”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，你应该把概率看作是对从某个*事件宇宙*中选择的*事件*的不确定性进行量化的一种方式。与其深究这些术语的技术含义，不如想象掷骰子。事件宇宙包含所有可能的结果。而这些结果的任何子集就是一个事件；例如，“骰子掷出1”或“骰子掷出偶数”。
- en: Notationally, we write *P*(*E*) to mean “the probability of the event *E*.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号上，我们写 *P*(*E*) 来表示“事件 *E* 发生的概率”。
- en: We’ll use probability theory to build models. We’ll use probability theory to
    evaluate models. We’ll use probability theory all over the place.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用概率理论来建立模型。我们将使用概率理论来评估模型。我们将在很多地方使用概率理论。
- en: One could, were one so inclined, get really deep into the philosophy of what
    probability theory *means*. (This is best done over beers.) We won’t be doing
    that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以深入探讨概率论的哲学含义。（最好在喝啤酒时进行。）我们不会做这件事。
- en: Dependence and Independence
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖性与独立性
- en: Roughly speaking, we say that two events *E* and *F* are *dependent* if knowing
    something about whether *E* happens gives us information about whether *F* happens
    (and vice versa). Otherwise, they are *independent*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果知道 *E* 发生与否能够提供 *F* 发生与否的信息（反之亦然），我们称事件 *E* 和 *F* 是*依赖*的。否则，它们是*独立*的。
- en: For instance, if we flip a fair coin twice, knowing whether the first flip is
    heads gives us no information about whether the second flip is heads. These events
    are independent. On the other hand, knowing whether the first flip is heads certainly
    gives us information about whether both flips are tails. (If the first flip is
    heads, then definitely it’s not the case that both flips are tails.) These two
    events are dependent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们抛一枚公平的硬币两次，知道第一次抛硬币是正面并不能提供关于第二次抛硬币是否正面的信息。这两个事件是独立的。另一方面，知道第一次抛硬币是正面肯定会影响到第二次抛硬币是否都是反面。（如果第一次抛硬币是正面，那么肯定不会是两次抛硬币都是反面。）这两个事件是依赖的。
- en: 'Mathematically, we say that two events *E* and *F* are independent if the probability
    that they both happen is the product of the probabilities that each one happens:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上，我们说事件 *E* 和 *F* 是独立的，如果它们同时发生的概率等于它们各自发生的概率的乘积：
- en: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis upper P left-parenthesis
    upper F right-parenthesis" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi>
    <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis upper P left-parenthesis
    upper F right-parenthesis" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi>
    <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
- en: In the example, the probability of “first flip heads” is 1/2, and the probability
    of “both flips tails” is 1/4, but the probability of “first flip heads *and* both
    flips tails” is 0.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，“第一次抛硬币为正面”的概率是1/2，“两次抛硬币都为反面”的概率是1/4，但“第一次抛硬币为正面*且*两次抛硬币都为反面”的概率是0。
- en: Conditional Probability
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件概率
- en: 'When two events *E* and *F* are independent, then by definition we have:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个事件 *E* 和 *F* 是独立的时候，根据定义我们有：
- en: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis upper P left-parenthesis
    upper F right-parenthesis" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi>
    <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis upper P left-parenthesis
    upper F right-parenthesis" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi>
    <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
- en: 'If they are not necessarily independent (and if the probability of *F* is not
    zero), then we define the probability of *E* “conditional on *F*” as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们不一定是独立的（如果 *F* 的概率不为零），那么我们定义 *E* 在给定 *F* 的条件下的概率为：
- en: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E comma upper F right-parenthesis slash
    upper P left-parenthesis upper F right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>)</mo></mrow></math>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E comma upper F right-parenthesis slash
    upper P left-parenthesis upper F right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>)</mo></mrow></math>
- en: You should think of this as the probability that *E* happens, given that we
    know that *F* happens.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把这看作是在我们知道 *F* 发生的情况下，*E* 发生的概率。
- en: 'We often rewrite this as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将其重写为：
- en: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    upper P left-parenthesis upper F right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E comma upper F right-parenthesis
    equals upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    upper P left-parenthesis upper F right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
- en: 'When *E* and *F* are independent, you can check that this gives:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *E* 和 *F* 是独立的时候，你可以检查这是否成立：
- en: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>)</mo></mrow></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>)</mo></mrow></math>
- en: which is the mathematical way of expressing that knowing *F* occurred gives
    us no additional information about whether *E* occurred.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数学上表达，即知道 *F* 发生了并不能给我们关于 *E* 是否发生额外的信息。
- en: 'One common tricky example involves a family with two (unknown) children. If
    we assume that:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的棘手例子涉及一对（未知的）孩子的家庭。如果我们假设：
- en: Each child is equally likely to be a boy or a girl.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个孩子都同等可能是男孩或女孩。
- en: The gender of the second child is independent of the gender of the first child.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个孩子的性别与第一个孩子的性别是独立的。
- en: Then the event “no girls” has probability 1/4, the event “one girl, one boy”
    has probability 1/2, and the event “two girls” has probability 1/4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么事件“没有女孩”的概率为1/4，事件“一个女孩一个男孩”的概率为1/2，事件“两个女孩”的概率为1/4。
- en: 'Now we can ask what is the probability of the event “both children are girls”
    (*B*) conditional on the event “the older child is a girl” (*G*)? Using the definition
    of conditional probability:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以问事件“两个孩子都是女孩”(*B*)在事件“老大是女孩”(*G*)条件下的概率是多少？使用条件概率的定义：
- en: <math alttext="upper P left-parenthesis upper B vertical-bar upper G right-parenthesis
    equals upper P left-parenthesis upper B comma upper G right-parenthesis slash
    upper P left-parenthesis upper G right-parenthesis equals upper P left-parenthesis
    upper B right-parenthesis slash upper P left-parenthesis upper G right-parenthesis
    equals 1 slash 2" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>|</mo>
    <mi>G</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>,</mo> <mi>G</mi>
    <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>G</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>B</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>G</mi> <mo>)</mo>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper B vertical-bar upper G right-parenthesis
    equals upper P left-parenthesis upper B comma upper G right-parenthesis slash
    upper P left-parenthesis upper G right-parenthesis equals upper P left-parenthesis
    upper B right-parenthesis slash upper P left-parenthesis upper G right-parenthesis
    equals 1 slash 2" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>|</mo>
    <mi>G</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>,</mo> <mi>G</mi>
    <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>G</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>B</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>G</mi> <mo>)</mo>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>2</mn></mrow></math>
- en: since the event *B* and *G* (“both children are girls *and* the older child
    is a girl”) is just the event *B*. (Once you know that both children are girls,
    it’s necessarily true that the older child is a girl.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件*B*和*G*（“两个孩子都是女孩*且*老大是女孩”）就是事件*B*。（一旦知道两个孩子都是女孩，老大是女孩就是必然的。）
- en: Most likely this result accords with your intuition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这个结果符合您的直觉。
- en: We could also ask about the probability of the event “both children are girls”
    conditional on the event “at least one of the children is a girl” (*L*). Surprisingly,
    the answer is different from before!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以询问事件“两个孩子都是女孩”在事件“至少一个孩子是女孩”(*L*)条件下的概率。令人惊讶的是，答案与之前不同！
- en: 'As before, the event *B* and *L* (“both children are girls *and* at least one
    of the children is a girl”) is just the event *B*. This means we have:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，事件*B*和*L*（“两个孩子都是女孩*且*至少一个孩子是女孩”）就是事件*B*。这意味着我们有：
- en: <math alttext="upper P left-parenthesis upper B vertical-bar upper L right-parenthesis
    equals upper P left-parenthesis upper B comma upper L right-parenthesis slash
    upper P left-parenthesis upper L right-parenthesis equals upper P left-parenthesis
    upper B right-parenthesis slash upper P left-parenthesis upper L right-parenthesis
    equals 1 slash 3" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>|</mo>
    <mi>L</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>,</mo> <mi>L</mi>
    <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>L</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>B</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>L</mi> <mo>)</mo>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></math>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper B vertical-bar upper L right-parenthesis
    equals upper P left-parenthesis upper B comma upper L right-parenthesis slash
    upper P left-parenthesis upper L right-parenthesis equals upper P left-parenthesis
    upper B right-parenthesis slash upper P left-parenthesis upper L right-parenthesis
    equals 1 slash 3" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>|</mo>
    <mi>L</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>B</mi> <mo>,</mo> <mi>L</mi>
    <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>L</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi>
    <mo>(</mo> <mi>B</mi> <mo>)</mo> <mo>/</mo> <mi>P</mi> <mo>(</mo> <mi>L</mi> <mo>)</mo>
    <mo>=</mo> <mn>1</mn> <mo>/</mo> <mn>3</mn></mrow></math>
- en: How can this be the case? Well, if all you know is that at least one of the
    children is a girl, then it is twice as likely that the family has one boy and
    one girl than that it has both girls.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？嗯，如果您所知道的是至少有一个孩子是女孩，那么这个家庭有一个男孩和一个女孩的可能性是有两倍多于两个女孩的可能性的。
- en: 'We can check this by “generating” a lot of families:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过“生成”许多家庭来验证这一点：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Bayes’s Theorem
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贝叶斯定理
- en: 'One of the data scientist’s best friends is Bayes’s theorem, which is a way
    of “reversing” conditional probabilities. Let’s say we need to know the probability
    of some event *E* conditional on some other event *F* occurring. But we only have
    information about the probability of *F* conditional on *E* occurring. Using the
    definition of conditional probability twice tells us that:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家的最佳朋友之一是贝叶斯定理，这是一种“反转”条件概率的方法。假设我们需要知道某事件*E*在另一事件*F*发生条件下的概率。但我们只有关于*E*发生条件下*F*的概率信息。使用条件概率的定义两次告诉我们：
- en: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E comma upper F right-parenthesis slash
    upper P left-parenthesis upper F right-parenthesis equals upper P left-parenthesis
    upper F vertical-bar upper E right-parenthesis upper P left-parenthesis upper
    E right-parenthesis slash upper P left-parenthesis upper F right-parenthesis"
    display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo>
    <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>/</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>/</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper E comma upper F right-parenthesis slash
    upper P left-parenthesis upper F right-parenthesis equals upper P left-parenthesis
    upper F vertical-bar upper E right-parenthesis upper P left-parenthesis upper
    E right-parenthesis slash upper P left-parenthesis upper F right-parenthesis"
    display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo>
    <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>)</mo> <mo>/</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>/</mo>
    <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>)</mo></mrow></math>
- en: 'The event *F* can be split into the two mutually exclusive events “*F* and
    *E*” and “*F* and not *E*.” If we write <math><mrow><mo>¬</mo> <mi>E</mi></mrow></math>
    for “not *E*” (i.e., “*E* doesn’t happen”), then:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 事件*F*可以分为两个互斥事件：“*F*和*E*”以及“*F*和非*E*”。如果我们用<math><mrow><mo>¬</mo> <mi>E</mi></mrow></math>表示“非*E*”（即“*E*不发生”），那么：
- en: <math alttext="upper P left-parenthesis upper F right-parenthesis equals upper
    P left-parenthesis upper F comma upper E right-parenthesis plus upper P left-parenthesis
    upper F comma normal not-sign upper E right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>,</mo>
    <mi>E</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>,</mo> <mo>¬</mo>
    <mi>E</mi> <mo>)</mo></mrow></math>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper F right-parenthesis equals upper
    P left-parenthesis upper F comma upper E right-parenthesis plus upper P left-parenthesis
    upper F comma normal not-sign upper E right-parenthesis" display="block"><mrow><mi>P</mi>
    <mo>(</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>,</mo>
    <mi>E</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>,</mo> <mo>¬</mo>
    <mi>E</mi> <mo>)</mo></mrow></math>
- en: 'so that:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以：
- en: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper F vertical-bar upper E right-parenthesis
    upper P left-parenthesis upper E right-parenthesis slash left-bracket upper P
    left-parenthesis upper F vertical-bar upper E right-parenthesis upper P left-parenthesis
    upper E right-parenthesis plus upper P left-parenthesis upper F vertical-bar normal
    not-sign upper E right-parenthesis upper P left-parenthesis normal not-sign upper
    E right-parenthesis right-bracket" display="block"><mrow><mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>/</mo>
    <mo>[</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>|</mo>
    <mo>¬</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mo>¬</mo> <mi>E</mi> <mo>)</mo>
    <mo>]</mo></mrow></math>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper E vertical-bar upper F right-parenthesis
    equals upper P left-parenthesis upper F vertical-bar upper E right-parenthesis
    upper P left-parenthesis upper E right-parenthesis slash left-bracket upper P
    left-parenthesis upper F vertical-bar upper E right-parenthesis upper P left-parenthesis
    upper E right-parenthesis plus upper P left-parenthesis upper F vertical-bar normal
    not-sign upper E right-parenthesis upper P left-parenthesis normal not-sign upper
    E right-parenthesis right-bracket" display="block"><mrow><mi>P</mi> <mo>(</mo>
    <mi>E</mi> <mo>|</mo> <mi>F</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi>
    <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>/</mo>
    <mo>[</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>|</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi>
    <mo>(</mo> <mi>E</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>F</mi> <mo>|</mo>
    <mo>¬</mo> <mi>E</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mo>¬</mo> <mi>E</mi> <mo>)</mo>
    <mo>]</mo></mrow></math>
- en: which is how Bayes’s theorem is often stated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是贝叶斯定理的陈述方式。
- en: This theorem often gets used to demonstrate why data scientists are smarter
    than doctors. Imagine a certain disease that affects 1 in every 10,000 people.
    And imagine that there is a test for this disease that gives the correct result
    (“diseased” if you have the disease, “nondiseased” if you don’t) 99% of the time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定理经常被用来展示为什么数据科学家比医生更聪明。想象一种影响每10,000人中1人的特定疾病。再想象一种测试这种疾病的方法，它在99%的情况下给出正确结果（如果您有疾病则为“患病”，如果您没有则为“未患病”）。
- en: 'What does a positive test mean? Let’s use *T* for the event “your test is positive”
    and *D* for the event “you have the disease.” Then Bayes’s theorem says that the
    probability that you have the disease, conditional on testing positive, is:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正测试意味着什么？让我们用*T*表示“您的测试呈阳性”事件，*D*表示“您患有疾病”事件。那么贝叶斯定理表明，在测试呈阳性的条件下，您患有疾病的概率是：
- en: <math alttext="upper P left-parenthesis upper D vertical-bar upper T right-parenthesis
    equals upper P left-parenthesis upper T vertical-bar upper D right-parenthesis
    upper P left-parenthesis upper D right-parenthesis slash left-bracket upper P
    left-parenthesis upper T vertical-bar upper D right-parenthesis upper P left-parenthesis
    upper D right-parenthesis plus upper P left-parenthesis upper T vertical-bar normal
    not-sign upper D right-parenthesis upper P left-parenthesis normal not-sign upper
    D right-parenthesis right-bracket" display="block"><mrow><mi>P</mi> <mo>(</mo>
    <mi>D</mi> <mo>|</mo> <mi>T</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi>
    <mo>|</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>D</mi> <mo>)</mo> <mo>/</mo>
    <mo>[</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi>
    <mo>(</mo> <mi>D</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo>
    <mo>¬</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mo>¬</mo> <mi>D</mi> <mo>)</mo>
    <mo>]</mo></mrow></math>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper D vertical-bar upper T right-parenthesis
    equals upper P left-parenthesis upper T vertical-bar upper D right-parenthesis
    upper P left-parenthesis upper D right-parenthesis slash left-bracket upper P
    left-parenthesis upper T vertical-bar upper D right-parenthesis upper P left-parenthesis
    upper D right-parenthesis plus upper P left-parenthesis upper T vertical-bar normal
    not-sign upper D right-parenthesis upper P left-parenthesis normal not-sign upper
    D right-parenthesis right-bracket" display="block"><mrow><mi>P</mi> <mo>(</mo>
    <mi>D</mi> <mo>|</mo> <mi>T</mi> <mo>)</mo> <mo>=</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi>
    <mo>|</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mi>D</mi> <mo>)</mo> <mo>/</mo>
    <mo>[</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi>
    <mo>(</mo> <mi>D</mi> <mo>)</mo> <mo>+</mo> <mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo>
    <mo>¬</mo> <mi>D</mi> <mo>)</mo> <mi>P</mi> <mo>(</mo> <mo>¬</mo> <mi>D</mi> <mo>)</mo>
    <mo>]</mo></mrow></math>
- en: 'Here we know that <math><mrow><mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo> <mi>D</mi>
    <mo>)</mo></mrow></math> , the probability that someone with the disease tests
    positive, is 0.99\. *P*(*D*), the probability that any given person has the disease,
    is 1/10,000 = 0.0001\. <math><mrow><mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo>
    <mo>¬</mo> <mi>D</mi> <mo>)</mo></mrow></math> , the probability that someone
    without the disease tests positive, is 0.01\. And <math><mrow><mi>P</mi> <mo>(</mo>
    <mo>¬</mo> <mi>D</mi> <mo>)</mo></mrow></math> , the probability that any given
    person doesn’t have the disease, is 0.9999\. If you substitute these numbers into
    Bayes’s theorem, you find:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们知道，<math><mrow><mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo> <mi>D</mi> <mo>)</mo></mrow></math>，即染病者测试阳性的概率，为0.99。*P*(*D*)，即任何给定人患病的概率，为1/10,000
    = 0.0001。 <math><mrow><mi>P</mi> <mo>(</mo> <mi>T</mi> <mo>|</mo> <mo>¬</mo> <mi>D</mi>
    <mo>)</mo></mrow></math>，即没有患病者测试阳性的概率，为0.01。而 <math><mrow><mi>P</mi> <mo>(</mo>
    <mo>¬</mo> <mi>D</mi> <mo>)</mo></mrow></math>，即任何给定人没有患病的概率，为0.9999。如果你把这些数字代入贝叶斯定理，你会发现：
- en: <math alttext="upper P left-parenthesis upper D vertical-bar upper T right-parenthesis
    equals 0.98 percent-sign" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>D</mi>
    <mo>|</mo> <mi>T</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>98</mn>
    <mo>%</mo></mrow></math>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis upper D vertical-bar upper T right-parenthesis
    equals 0.98 percent-sign" display="block"><mrow><mi>P</mi> <mo>(</mo> <mi>D</mi>
    <mo>|</mo> <mi>T</mi> <mo>)</mo> <mo>=</mo> <mn>0</mn> <mo>.</mo> <mn>98</mn>
    <mo>%</mo></mrow></math>
- en: That is, less than 1% of the people who test positive actually have the disease.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，只有不到1%的阳性测试者实际上患有这种疾病。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: This assumes that people take the test more or less at random. If only people
    with certain symptoms take the test, we would instead have to condition on the
    event “positive test *and* symptoms” and the number would likely be a lot higher.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设人们更多或更少是随机参加测试的。如果只有具有某些症状的人参加测试，我们将需要在“阳性测试 *和* 症状”事件上进行条件判断，而阳性测试的人数可能会高得多。
- en: A more intuitive way to see this is to imagine a population of 1 million people.
    You’d expect 100 of them to have the disease, and 99 of those 100 to test positive.
    On the other hand, you’d expect 999,900 of them not to have the disease, and 9,999
    of those to test positive. That means you’d expect only 99 out of (99 + 9999)
    positive testers to actually have the disease.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更直观地看待这个问题的方法是想象一种100万人口的人群。你会预期其中有100人患有这种疾病，其中有99人测试结果呈阳性。另一方面，你会预期这中间有999,900人没有患有这种疾病，其中有9,999人测试结果呈阳性。这意味着你只会预期(99
    + 9999)个阳性测试者中有99人实际上患有这种疾病。
- en: Random Variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机变量
- en: A *random variable* is a variable whose possible values have an associated probability
    distribution. A very simple random variable equals 1 if a coin flip turns up heads
    and 0 if the flip turns up tails. A more complicated one might measure the number
    of heads you observe when flipping a coin 10 times or a value picked from `range(10)`
    where each number is equally likely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机变量*是具有相关概率分布的可能值的变量。一个非常简单的随机变量，如果抛硬币正面朝上则值为1，如果反面朝上则值为0。一个更复杂的随机变量可能会测量你在抛硬币10次时观察到的头像数量，或者从`range(10)`中选取的值，其中每个数字都是同样可能的。'
- en: The associated distribution gives the probabilities that the variable realizes
    each of its possible values. The coin flip variable equals 0 with probability
    0.5 and 1 with probability 0.5\. The `range(10)` variable has a distribution that
    assigns probability 0.1 to each of the numbers from 0 to 9.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的分布给出了变量实现其可能值的概率。抛硬币变量等于0的概率为0.5，等于1的概率为0.5。`range(10)`变量具有分布，将0到9中的每个数字分配概率0.1。
- en: We will sometimes talk about the *expected value* of a random variable, which
    is the average of its values weighted by their probabilities. The coin flip variable
    has an expected value of 1/2 (= 0 * 1/2 + 1 * 1/2), and the `range(10)` variable
    has an expected value of 4.5.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会谈论一个随机变量的*期望值*，这是其值按其概率加权的平均值。抛硬币变量的期望值为1/2（= 0 * 1/2 + 1 * 1/2），而`range(10)`变量的期望值为4.5。
- en: Random variables can be *conditioned* on events just as other events can. Going
    back to the two-child example from [“Conditional Probability”](#conditional_probability),
    if *X* is the random variable representing the number of girls, *X* equals 0 with
    probability 1/4, 1 with probability 1/2, and 2 with probability 1/4.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随机变量可以像其他事件一样被条件化。回到[“条件概率”](#conditional_probability)中的两个孩子示例，如果*X*是表示女孩数量的随机变量，那么*X*等于0的概率为1/4，等于1的概率为1/2，等于2的概率为1/4。
- en: We can define a new random variable *Y* that gives the number of girls conditional
    on at least one of the children being a girl. Then *Y* equals 1 with probability
    2/3 and 2 with probability 1/3\. And a variable *Z* that’s the number of girls
    conditional on the older child being a girl equals 1 with probability 1/2 and
    2 with probability 1/2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个新的随机变量*Y*，条件是至少有一个孩子是女孩。然后*Y*以2/3的概率等于1，以1/3的概率等于2。还有一个变量*Z*，条件是较大的孩子是女孩，则以1/2的概率等于1，以1/2的概率等于2。
- en: For the most part, we will be using random variables *implicitly* in what we
    do without calling special attention to them. But if you look deeply you’ll see
    them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，在我们进行的操作中，我们将隐含地使用随机变量，而不特别关注它们。但是如果你深入研究，你会发现它们。
- en: Continuous Distributions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连续分布
- en: A coin flip corresponds to a *discrete distribution*—one that associates positive
    probability with discrete outcomes. Often we’ll want to model distributions across
    a continuum of outcomes. (For our purposes, these outcomes will always be real
    numbers, although that’s not always the case in real life.) For example, the *uniform
    distribution* puts *equal weight* on all the numbers between 0 and 1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 抛硬币对应于*离散分布*——它将离散结果与正概率关联起来。通常我们希望模拟跨越连续结果的分布。（对我们而言，这些结果将始终是实数，尽管在现实生活中并非总是如此。）例如，*均匀分布*将在0到1之间所有数字上赋予*相等的权重*。
- en: Because there are infinitely many numbers between 0 and 1, this means that the
    weight it assigns to individual points must necessarily be zero. For this reason,
    we represent a continuous distribution with a *probability density function* (PDF)
    such that the probability of seeing a value in a certain interval equals the integral
    of the density function over the interval.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在0和1之间有无穷多个数，这意味着它分配给单个点的权重必然为零。因此，我们用*概率密度函数*（PDF）表示连续分布，使得在某个区间内看到一个值的概率等于该区间上密度函数的积分。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If your integral calculus is rusty, a simpler way of understanding this is that
    if a distribution has density function *f*, then the probability of seeing a value
    between *x* and *x + h* is approximately *h * f(x)* if *h* is small.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的积分微积分有点生疏，一个更简单的理解方式是，如果一个分布有密度函数*f*，那么在*x*和*x + h*之间看到一个值的概率大约是*h * f(x)*，如果*h*很小的话。
- en: 'The density function for the uniform distribution is just:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀分布的密度函数就是：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The probability that a random variable following that distribution is between
    0.2 and 0.3 is 1/10, as you’d expect. Python’s `random.random` is a (pseudo)random
    variable with a uniform density.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照该分布，随机变量落在0.2到0.3之间的概率是1/10，正如你所期望的那样。Python的`random.random`是一个均匀密度的（伪）随机变量。
- en: 'We will often be more interested in the *cumulative distribution function*
    (CDF), which gives the probability that a random variable is less than or equal
    to a certain value. It’s not hard to create the CDF for the uniform distribution
    ([Figure 6-1](#uniform_cdf)):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常更感兴趣的是*累积分布函数*（CDF），它给出随机变量小于或等于某个值的概率。对于均匀分布，创建CDF并不困难（见[图6-1](#uniform_cdf)）：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Uniform CDF.](assets/dsf2_0601.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![均匀分布的CDF。](assets/dsf2_0601.png)'
- en: Figure 6-1\. The uniform CDF
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 均匀分布的累积分布函数
- en: The Normal Distribution
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正态分布
- en: 'The normal distribution is the classic bell curve–shaped distribution and is
    completely determined by two parameters: its mean *μ* (mu) and its standard deviation
    *σ* (sigma). The mean indicates where the bell is centered, and the standard deviation
    how “wide” it is.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布是经典的钟形曲线分布，完全由两个参数确定：其均值*μ*（mu）和标准差*σ*（sigma）。均值表示钟形曲线的中心位置，标准差表示其“宽度”。
- en: 'It has the PDF:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它的PDF是：
- en: <math alttext="f left-parenthesis x vertical-bar mu comma sigma right-parenthesis
    equals StartFraction 1 Over StartRoot 2 pi EndRoot sigma EndFraction exp left-parenthesis
    minus StartFraction left-parenthesis x minus mu right-parenthesis squared Over
    2 sigma squared EndFraction right-parenthesis" display="block"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>μ</mi> <mo>,</mo> <mi>σ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac>
    <mo form="prefix">exp</mo> <mo>(</mo> <mrow><mo>-</mo> <mfrac><msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mi>μ</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac>
    <mrow><mo>)</mo></mrow></mrow></mrow></math>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f left-parenthesis x vertical-bar mu comma sigma right-parenthesis
    equals StartFraction 1 Over StartRoot 2 pi EndRoot sigma EndFraction exp left-parenthesis
    minus StartFraction left-parenthesis x minus mu right-parenthesis squared Over
    2 sigma squared EndFraction right-parenthesis" display="block"><mrow><mi>f</mi>
    <mrow><mo>(</mo> <mi>x</mi> <mo>|</mo> <mi>μ</mi> <mo>,</mo> <mi>σ</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt><mi>σ</mi></mrow></mfrac>
    <mo form="prefix">exp</mo> <mo>(</mo> <mrow><mo>-</mo> <mfrac><msup><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mi>μ</mi><mo>)</mo></mrow>
    <mn>2</mn></msup> <mrow><mn>2</mn><msup><mi>σ</mi> <mn>2</mn></msup></mrow></mfrac>
    <mrow><mo>)</mo></mrow></mrow></mrow></math>
- en: 'which we can implement as:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样实现它：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In [Figure 6-2](#various_normal_pdfs), we plot some of these PDFs to see what
    they look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-2](#various_normal_pdfs)中，我们绘制了一些这些PDF，看看它们的样子：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Various normal pdfs.](assets/dsf2_0602.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![各种正态分布的PDF。](assets/dsf2_0602.png)'
- en: Figure 6-2\. Various normal PDFs
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 各种正态分布的PDF
- en: 'When *μ* = 0 and *σ* = 1, it’s called the *standard normal distribution*. If
    *Z* is a standard normal random variable, then it turns out that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当*μ* = 0且*σ* = 1时，称为*标准正态分布*。如果*Z*是一个标准正态随机变量，则有：
- en: <math alttext="upper X equals sigma upper Z plus mu" display="block"><mrow><mi>X</mi>
    <mo>=</mo> <mi>σ</mi> <mi>Z</mi> <mo>+</mo> <mi>μ</mi></mrow></math>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper X equals sigma upper Z plus mu" display="block"><mrow><mi>X</mi>
    <mo>=</mo> <mi>σ</mi> <mi>Z</mi> <mo>+</mo> <mi>μ</mi></mrow></math>
- en: is also normal but with mean <math alttext="mu"><mi>μ</mi></math> and standard
    deviation <math alttext="sigma"><mi>σ</mi></math> . Conversely, if *X* is a normal
    random variable with mean <math alttext="mu"><mi>μ</mi></math> and standard deviation
    <math alttext="sigma"><mi>σ</mi></math> ,
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 也服从正态分布，但其均值为<math alttext="mu"><mi>μ</mi></math>，标准差为<math alttext="sigma"><mi>σ</mi></math>
    。反之，如果*X*是均值为<math alttext="mu"><mi>μ</mi></math>，标准差为<math alttext="sigma"><mi>σ</mi></math>的正态随机变量，
- en: <math alttext="upper Z equals left-parenthesis upper X minus mu right-parenthesis
    slash sigma" display="block"><mrow><mi>Z</mi> <mo>=</mo> <mo>(</mo> <mi>X</mi>
    <mo>-</mo> <mi>μ</mi> <mo>)</mo> <mo>/</mo> <mi>σ</mi></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper Z equals left-parenthesis upper X minus mu right-parenthesis
    slash sigma" display="block"><mrow><mi>Z</mi> <mo>=</mo> <mo>(</mo> <mi>X</mi>
    <mo>-</mo> <mi>μ</mi> <mo>)</mo> <mo>/</mo> <mi>σ</mi></mrow></math>
- en: is a standard normal variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个标准正态变量。
- en: 'The CDF for the normal distribution cannot be written in an “elementary” manner,
    but we can write it using Python’s `math.erf` [error function](http://en.wikipedia.org/wiki/Error_function):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布的累积分布函数不能用“基本”的方式写出，但我们可以使用Python的`math.erf` [误差函数](http://en.wikipedia.org/wiki/Error_function)来表示它：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, in [Figure 6-3](#various_normal_cdfs), we plot a few CDFs:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在[图 6-3](#various_normal_cdfs)中，我们绘制了几个累积分布函数（CDF）：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Various normal cdfs.](assets/dsf2_0603.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![各种正态分布的CDF。](assets/dsf2_0603.png)'
- en: Figure 6-3\. Various normal CDFs
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 各种正态分布的累积分布函数
- en: 'Sometimes we’ll need to invert `normal_cdf` to find the value corresponding
    to a specified probability. There’s no simple way to compute its inverse, but
    `normal_cdf` is continuous and strictly increasing, so we can use a [*binary search*](http://en.wikipedia.org/wiki/Binary_search_algorithm):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要求逆`normal_cdf`以找到对应于指定概率的值。虽然没有简单的方法来计算其逆，但`normal_cdf`是连续且严格递增的，因此我们可以使用[*二分查找*](http://en.wikipedia.org/wiki/Binary_search_algorithm)：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The function repeatedly bisects intervals until it narrows in on a *Z* that’s
    close enough to the desired probability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数重复地将区间二分，直到找到接近所需概率的*Z*。
- en: The Central Limit Theorem
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中心极限定理
- en: One reason the normal distribution is so useful is the *central limit theorem*,
    which says (in essence) that a random variable defined as the average of a large
    number of independent and identically distributed random variables is itself approximately
    normally distributed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布如此有用的一个原因是*中心极限定理*，它（本质上）表明大量独立同分布的随机变量的平均值本身近似服从正态分布。
- en: 'In particular, if <math><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo>
    <mo>...</mo> <mo>,</mo> <msub><mi>x</mi> <mi>n</mi></msub></mrow></math> are random
    variables with mean *μ* and standard deviation *σ*, and if *n* is large, then:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果<math><mrow><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <mo>...</mo>
    <mo>,</mo> <msub><mi>x</mi> <mi>n</mi></msub></mrow></math>是均值为*μ*，标准差为*σ*的随机变量，并且*n*很大，则
- en: <math display="block"><mrow><mfrac><mn>1</mn> <mi>n</mi></mfrac> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <mo>...</mo> <mo>+</mo> <msub><mi>x</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></mrow></math>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mfrac><mn>1</mn> <mi>n</mi></mfrac> <mrow><mo>(</mo>
    <msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo> <mo>...</mo> <mo>+</mo> <msub><mi>x</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></mrow></math>
- en: is approximately normally distributed with mean *μ* and standard deviation <math
    alttext="sigma slash StartRoot n EndRoot"><mrow><mi>σ</mi> <mo>/</mo> <msqrt><mi>n</mi></msqrt></mrow></math>
    . Equivalently (but often more usefully),
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上符合正态分布，均值为*μ*，标准差为<math alttext="sigma slash StartRoot n EndRoot"><mrow><mi>σ</mi>
    <mo>/</mo> <msqrt><mi>n</mi></msqrt></mrow></math> 。同样（但通常更有用），
- en: <math alttext="StartFraction left-parenthesis x 1 plus ellipsis plus x Subscript
    n Baseline right-parenthesis minus mu n Over sigma StartRoot n EndRoot EndFraction"
    display="block"><mfrac><mrow><mo>(</mo><msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo><mo>...</mo><mo>+</mo><msub><mi>x</mi>
    <mi>n</mi></msub> <mo>)</mo><mo>-</mo><mi>μ</mi><mi>n</mi></mrow> <mrow><mi>σ</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac></math>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction left-parenthesis x 1 plus ellipsis plus x Subscript
    n Baseline right-parenthesis minus mu n Over sigma StartRoot n EndRoot EndFraction"
    display="block"><mfrac><mrow><mo>(</mo><msub><mi>x</mi> <mn>1</mn></msub> <mo>+</mo><mo>...</mo><mo>+</mo><msub><mi>x</mi>
    <mi>n</mi></msub> <mo>)</mo><mo>-</mo><mi>μ</mi><mi>n</mi></mrow> <mrow><mi>σ</mi><msqrt><mi>n</mi></msqrt></mrow></mfrac></math>
- en: is approximately normally distributed with mean 0 and standard deviation 1.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上符合均值为0，标准差为1的正态分布。
- en: 'An easy way to illustrate this is by looking at *binomial* random variables,
    which have two parameters *n* and *p*. A Binomial(*n*,*p*) random variable is
    simply the sum of *n* independent Bernoulli(*p*) random variables, each of which
    equals 1 with probability *p* and 0 with probability 1 – *p*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个易于说明这一点的方法是看*二项式*随机变量，它具有两个参数*n*和*p*。一个二项式(*n*,*p*)随机变量简单地是*n*个独立的伯努利(*p*)随机变量的和，其中每个随机变量以概率*p*等于1，以概率1
    - *p*等于0：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The mean of a Bernoulli(*p*) variable is *p*, and its standard deviation is
    <math alttext="StartRoot p left-parenthesis 1 minus p right-parenthesis EndRoot"><msqrt><mrow><mi>p</mi>
    <mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow></msqrt></math> .
    The central limit theorem says that as *n* gets large, a Binomial(*n*,*p*) variable
    is approximately a normal random variable with mean <math alttext="mu equals n
    p"><mrow><mi>μ</mi> <mo>=</mo> <mi>n</mi> <mi>p</mi></mrow></math> and standard
    deviation <math alttext="sigma equals StartRoot n p left-parenthesis 1 minus p
    right-parenthesis EndRoot"><mrow><mi>σ</mi> <mo>=</mo> <msqrt><mrow><mi>n</mi>
    <mi>p</mi> <mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow></msqrt></mrow></math>
    . If we plot both, you can easily see the resemblance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 伯努利变量（Bernoulli(*p*)）的均值是 *p*，标准差是 <math alttext="StartRoot p left-parenthesis
    1 minus p right-parenthesis EndRoot"><msqrt><mrow><mi>p</mi> <mo>(</mo> <mn>1</mn>
    <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow></msqrt></math> 。 中心极限定理表明，当 *n* 变大时，二项分布（Binomial(*n*,*p*)）变量近似于均值
    <math alttext="mu equals n p"><mrow><mi>μ</mi> <mo>=</mo> <mi>n</mi> <mi>p</mi></mrow></math>
    和标准差 <math alttext="sigma equals StartRoot n p left-parenthesis 1 minus p right-parenthesis
    EndRoot"><mrow><mi>σ</mi> <mo>=</mo> <msqrt><mrow><mi>n</mi> <mi>p</mi> <mo>(</mo>
    <mn>1</mn> <mo>-</mo> <mi>p</mi> <mo>)</mo></mrow></msqrt></mrow></math> 的正态随机变量。
    如果我们同时绘制它们，你可以很容易地看到它们的相似之处：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For example, when you call `make_hist(0.75, 100, 10000)`, you get the graph
    in [Figure 6-4](#make_hist_result).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你调用 `make_hist(0.75, 100, 10000)` 时，你会得到[图 6-4](#make_hist_result)中的图表。
- en: '![The result of calling binomial_histogram.](assets/dsf2_0604.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![调用 binomial_histogram 的结果。](assets/dsf2_0604.png)'
- en: Figure 6-4\. The output from binomial_histogram
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 调用 binomial_histogram 的输出
- en: The moral of this approximation is that if you want to know the probability
    that (say) a fair coin turns up more than 60 heads in 100 flips, you can estimate
    it as the probability that a Normal(50,5) is greater than 60, which is easier
    than computing the Binomial(100,0.5) CDF. (Although in most applications you’d
    probably be using statistical software that would gladly compute whatever probabilities
    you want.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个近似的道理是，如果你想知道（比如说）在100次投掷中，一个公平硬币出现超过60次正面的概率，你可以估计为一个正态分布（Normal(50,5)）大于60的概率，这比计算二项分布（Binomial(100,0.5)）的累积分布函数要简单。
    （尽管在大多数应用中，你可能会使用愿意计算任何你想要的概率的统计软件。）
- en: For Further Exploration
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: '[scipy.stats](https://docs.scipy.org/doc/scipy/reference/stats.html) contains
    PDF and CDF functions for most of the popular probability distributions.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[scipy.stats](https://docs.scipy.org/doc/scipy/reference/stats.html) 包含大多数流行概率分布的概率密度函数（PDF）和累积分布函数（CDF）。'
- en: Remember how, at the end of [Chapter 5](ch05.html#statistics), I said that it
    would be a good idea to study a statistics textbook? It would also be a good idea
    to study a probability textbook. The best one I know that’s available online is
    [*Introduction to Probability*](http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/book.html),
    by Charles M. Grinstead and J. Laurie Snell (American Mathematical Society).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还记得在[第 5 章](ch05.html#statistics)的结尾处我说过，学习一本统计学教材是个好主意吗？学习一本概率论教材也是个好主意。我知道的最好的在线教材是
    [*Introduction to Probability*](http://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/book.html)，由
    Charles M. Grinstead 和 J. Laurie Snell（美国数学学会）编写。
