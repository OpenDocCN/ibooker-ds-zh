- en: Unit 7\. Concurrent programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元 7. 并发编程
- en: Computers are excellent at doing many things at the same time. You might want
    the computer to speed up a calculation, download many web pages simultaneously,
    or control different parts of a robot independently. This ability to deal with
    several things at once is called *concurrency*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机擅长同时做很多事情。你可能想让计算机加快计算速度，同时下载许多网页，或者独立控制机器的不同部分。这种一次处理几件事情的能力被称为 *并发*。
- en: Go has a different approach to concurrency than most other programming languages.
    Any Go code can be made concurrent by starting it in a *goroutine*. Goroutines
    use *channels* for communication and coordination, making it straightforward to
    have multiple concurrent tasks working toward the same end.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对并发的方法与其他大多数编程语言不同。任何 Go 代码都可以通过在 *goroutine* 中启动它来使其并发。Goroutines 使用 *channels*
    进行通信和协调，使得多个并发任务朝着同一目标工作变得简单直接。
- en: Lesson 30\. Goroutines and concurrency
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 30 课. Goroutines 和并发
- en: After reading [lesson 30](#ch30), you’ll be able to
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完 [第 30 课](#ch30) 后，你将能够
- en: Start a goroutine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 goroutine
- en: Use channels to communicate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道进行通信
- en: Understand channel pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解通道管道
- en: 'Look, it’s a gopher factory! All the gophers are busy building things. Well,
    almost all. Over in the corner is a sleeping gopher—or maybe he’s deep in thought.
    Here’s an important gopher: she’s giving orders to other gophers. They run around
    and do her bidding, tell others what to do, and eventually report back their findings
    to her. Some gophers are sending things from the factory. Others are receiving
    things sent from outside.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 看，这是一个地鼠工厂！所有的地鼠都在忙着建造东西。嗯，几乎都在。角落里有一个正在睡觉的地鼠——或者也许他正在深思。这里有一个重要的地鼠：她在向其他地鼠下达命令。他们四处跑来跑去，执行她的命令，告诉别人该做什么，并最终向她报告他们的发现。一些地鼠正在从工厂发送东西。其他地鼠正在接收从外面送来的东西。
- en: '![](f0253-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](f0253-01.jpg)'
- en: Until now, all the Go we’ve written has been like a single gopher in this factory,
    busy with her own tasks and not bothering with anyone else’s. Go programs are
    more often like a whole factory, with many independent tasks all doing their own
    thing, but communicating with each other towards some common goal. These *concurrent*
    tasks might include fetching data from a web server, computing millions of digits
    of pi, or controlling a robot arm.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有 Go 代码都像这个工厂里单独一只地鼠一样，忙于自己的任务，不去打扰别人。Go 程序更像是整个工厂，许多独立任务都在各自做自己的事情，但为了某个共同目标相互沟通。这些
    *并发* 任务可能包括从网络服务器获取数据、计算数百万位的 π 或控制机械臂。
- en: In Go, an independently running task is known as a *goroutine*. In this lesson,
    you’ll learn how to start as many goroutines as you like and communicate between
    them with *channels*. Goroutines are similar to *coroutines*, *fibers*, *processes*,
    or *threads* in other languages, although they’re not quite the same as any of
    those. They’re very efficient to create, and Go makes it straightforward to coordinate
    many concurrent operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，独立运行的任务被称为 *goroutine*。在本课中，你将学习如何启动任意数量的 goroutine，并通过 *channels* 之间进行通信。Goroutines
    在其他语言中类似于 *coroutines*、*fibers*、*processes* 或 *threads*，尽管它们并不完全相同。它们创建起来非常高效，Go
    使得协调许多并发操作变得简单。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Consider writing a program that performs a sequence of actions. Each action
    might take a long time and could involve waiting for something to happen before
    it’s done. It could be written as straightforward, sequential code. But what if
    you want to do two or more of those sequences at the same time?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑编写一个执行一系列操作的程序。每个操作可能需要很长时间，并且可能需要在完成之前等待某些事情发生。它可以写成简单的、顺序的代码。但如果你想在同一时间做两个或更多的这些序列呢？
- en: For example, you might want one part of your program to go through a list of
    email addresses and send an email for each one, while another task waits for incoming
    email and stores them in a database. How would you write that?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想让程序的一部分遍历电子邮件地址列表，并为每个地址发送一封电子邮件，而另一个任务则等待接收到的电子邮件并将它们存储在数据库中。你会如何编写这样的代码？
- en: In some languages, you would need to change the code quite a bit. But in Go,
    you can use exactly the same kind of code for each independent task. Goroutines
    enable you to run any number of actions at the same time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，你可能需要相当大幅度地更改代码。但在 Go 中，你可以为每个独立任务使用完全相同的代码。Goroutines 允许你同时运行任意数量的操作。
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.1\. Starting a goroutine
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.1. 启动 goroutine
- en: Starting a goroutine is as easy as calling a function. All you need is the `go`
    keyword in front of the call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个goroutine就像调用一个函数一样简单。你只需要在调用前加上`go`关键字。
- en: The goroutine in [listing 30.1](#ch30ex01) is similar to our sleepy gopher in
    the corner of the factory. He doesn’t do much, though where that `Sleep` statement
    is, he could be doing some serious thought (computation) instead. When the `main`
    function returns, all the goroutines in the program are immediately stopped, so
    we need to wait long enough to see the sleepy gopher print his “... snore ...”
    message. We’ll wait for a little bit longer than necessary just to make sure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表30.1](#ch30ex01)中的goroutine类似于工厂角落的睡眠刺猬。尽管如此，他在`Sleep`语句那里并没有做什么，他本可以做一些严肃的思考（计算）。当`main`函数返回时，程序中的所有goroutine都会立即停止，因此我们需要等待足够长的时间来看到睡眠刺猬打印他的“...打呼噜...”信息。我们将等待比必要的时间更长一点，只是为了确保。'
- en: '![](f0255-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](f0255-01.jpg)'
- en: 'Listing 30.1\. Sleepy gopher: sleepygopher.go'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.1\. 睡眠的刺猬：sleepygopher.go
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The goroutine is started.**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* goroutine启动了。**'
- en: '***2* Waiting for the gopher to snore**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待刺猬打呼噜**'
- en: '***3* When we get here, all the goroutines are stopped.**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当我们到达这里时，所有的goroutine都停止了。**'
- en: '***4* The gopher sleeps.**'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 刺猬在睡觉。**'
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.1**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查30.1**'
- en: '**[1](#ch30qa2q0a1)**'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa2q0a1)**'
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What would you use in Go if you wanted to do more than one thing at the same
    time?
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想在Go中同时做更多的事情，你会使用什么？
- en: '**[2](#ch30qa2q0a2)**'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa2q0a2)**'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What keyword is used to start a new independently running task?
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于启动一个独立运行任务的关键字是什么？
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.1 answer**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查30.1答案**'
- en: '**[1](#ch30qa1q1)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa1q1)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A goroutine.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个goroutine。
- en: '**[2](#ch30qa1q2)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa1q2)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`go`.'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`go`。'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.2\. More than one goroutine
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.2\. 多个goroutine
- en: Each time we use the `go` keyword, a new goroutine is started. All goroutines
    appear to run at the same time. They might not *technically* run at the same time,
    though, because computers only have a limited number of processing units.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用`go`关键字时，就会启动一个新的goroutine。所有goroutine看起来都是同时运行的。尽管如此，它们可能并不*技术上*同时运行，因为计算机只有有限数量的处理单元。
- en: In fact, these processors usually spend some time on one goroutine before proceeding
    to another, using a technique known as *time sharing*. Exactly how this happens
    is a dark secret known only to the Go runtime and the operating system and processor
    you’re using. It’s best always to assume that the operations in different goroutines
    may run in any order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这些处理器通常会在处理另一个goroutine之前，花费一些时间在一个goroutine上，使用一种称为*时间共享*的技术。具体是如何发生的，这是一个只有Go运行时、你使用的操作系统和处理器才知道的黑暗秘密。最好总是假设不同goroutine中的操作可能以任何顺序运行。
- en: The `main` function in [listing 30.2](#ch30ex02) starts five `sleepyGopher`
    goroutines. They all sleep for three seconds and then print the same thing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表30.2](#ch30ex02)中的`main`函数启动了五个`sleepyGopher` goroutine。它们都睡眠三秒钟，然后打印相同的内容。'
- en: 'Listing 30.2\. Five sleepy gophers: sleepygophers.go'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.2\. 五个睡眠的刺猬：sleepygophers.go
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can find out which ones finish first by passing an argument to each goroutine.
    Passing an argument to a goroutine is like passing an argument to any function:
    the value is copied and passed as a parameter.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向每个goroutine传递一个参数来找出哪些先完成。向goroutine传递参数就像向任何函数传递参数一样：值被复制并作为参数传递。
- en: When you run the next listing, you should see that even though we started all
    the goroutines in order from zero to nine, they all finished at different times.
    If you run this outside the Go playground, you’ll see a different order every
    time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行下一个列表时，你应该看到尽管我们按顺序从零到九启动了所有的goroutine，但它们都在不同的时间完成。如果你在Go沙盒外运行这个程序，你每次都会看到不同的顺序。
- en: 'Listing 30.3\. Identified gophers: identifiedgophers.go'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.3\. 确认的刺猬：identifiedgophers.go
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There’s a problem with this code. It’s waiting for four seconds when it only
    needs to wait for just over three seconds. More importantly, if the goroutines
    are doing more than just sleeping, we won’t know how long they’re going to take
    to do their work. We need some way for the code to know when all the goroutines
    have finished. Fortunately Go provides us with exactly what we need: channels.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个问题。它等待了四秒钟，而它只需要等待超过三秒钟。更重要的是，如果goroutine执行的任务不仅仅是睡眠，我们不知道它们需要多长时间来完成工作。我们需要一种方法让代码知道所有goroutine何时完成。幸运的是，Go为我们提供了我们需要的：通道。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 30.2**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查30.2**'
- en: '**[Q1:](#ch30qa4q0a1)**'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[问题1:](#ch30qa4q0a1)**'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What order do different goroutines run in?
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不同的goroutine以什么顺序运行？
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.2 answer**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查30.2答案**'
- en: '**[1:](#ch30qa3q1)**'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch30qa3q1)**'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any order.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何订单。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.3\. Channels
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.3\. 通道
- en: A channel can be used to send values safely from one goroutine to another. Think
    of a channel as one of those pneumatic tube systems in old offices that passed
    around mail. If you put an object into it, it zips to the other end of the tube
    and can be taken out by someone else.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以用来安全地从一个 goroutine 向另一个 goroutine 发送值。将通道想象成那些旧办公室中传递邮件的气动管道系统之一。如果你把它放进去，它就会飞到管道的另一端，然后可以被其他人取出。
- en: Like any other Go type, channels can be used as variables, passed to functions,
    stored in a structure, and do almost anything else you want them to do.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 Go 类型一样，通道可以用作变量，传递给函数，存储在结构体中，并且可以执行几乎任何其他您希望它们执行的操作。
- en: 'To create a channel, use `make`, the same built-in function used to make maps
    and slices. Channels have a type that’s specified when you make them. The following
    channel can only send and receive integer values:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个通道，使用 `make`，这是与创建映射和切片相同的内置函数。通道的类型在创建时指定。以下通道只能发送和接收整数值：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you have a channel, you can send values to it and receive the values sent
    to it. You send or receive values on a channel with the *left arrow* operator
    (`<-`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了通道，你就可以向它发送值并接收发送到它的值。你使用 *左箭头* 操作符 (`<-`) 在通道上发送或接收值。
- en: 'To send a value, point the arrow toward the channel expression, as if the arrow
    were telling the value on the right to flow into the channel. The send operation
    will wait until something (in another goroutine) tries to receive on the same
    channel. While it’s waiting, the sender can’t do anything else, although all other
    goroutines will continue running freely (assuming they’re not waiting on channel
    operations too). The following sends the value 99:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送一个值，将箭头指向通道表达式，就像箭头在告诉右侧的值流入通道一样。发送操作将等待直到有东西（在另一个 goroutine 中）尝试在同一个通道上接收。在等待期间，发送者不能做任何事情，尽管所有其他
    goroutine 仍然可以自由运行（假设它们没有在通道操作上等待）。以下发送了值 99：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To receive a value from a channel, the arrow points away from the channel (it’s
    to the left of the channel). In the following code, we receive a value from channel
    `c` and assign it to variable `r`. Similarly to sending on a channel, the receiver
    will wait until another goroutine tries to send on the same channel:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要从通道接收值，箭头指向通道（它在通道的左侧）。在下面的代码中，我们从通道 `c` 接收一个值并将其赋给变量 `r`。与在通道上发送类似，接收者将等待另一个
    goroutine 尝试在同一个通道上发送：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although it’s common to use a channel receive operation on its own line, that’s
    not required. The channel receive operation can be used anywhere any other expression
    can be used.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常将通道接收操作单独放在一行上，但这不是必需的。通道接收操作可以在任何可以使用其他表达式的位置使用。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The code in [listing 30.4](#ch30ex04) makes a channel and passes it to five
    sleepy gopher goroutines. Then it waits to receive five messages, one for each
    goroutine that’s been started. Each goroutine sleeps and then sends a value identifying
    itself. When execution reaches the end of the `main` function, we know for sure
    that all the gophers will have finished sleeping, and it can return without disturbing
    any gopher’s sleep. For example, say we have a program that saves the results
    of some number-crunching computation to online storage. It might save several
    things at the same time, and we don’t want to quit before all the results have
    been successfully saved.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 30.4](#ch30ex04) 中的代码创建了一个通道并将其传递给五个困倦的地鼠 goroutine。然后它等待接收五个消息，每个消息对应于已启动的每个
    goroutine。每个 goroutine 睡觉并发送一个标识自己的值。当执行到达 `main` 函数的末尾时，我们可以确信所有的地鼠都已经完成了睡眠，并且它可以返回而不会打扰到任何地鼠的睡眠。例如，假设我们有一个程序将一些数值计算的输出保存到在线存储中。它可能同时保存几个东西，我们不希望在所有结果都成功保存之前退出。'
- en: 'Listing 30.4\. Channeled sleeping gophers: simplechan.go'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.4\. 通过通道休眠的地鼠：simplechan.go
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Makes the channel to communicate over**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建通道以进行通信**'
- en: '***2* Receives a value from a channel**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从通道接收值**'
- en: '***3* Declares the channel as an argument**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将通道作为参数声明**'
- en: '***4* Sends a value back to main**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将值发送回主函数**'
- en: The square boxes in [figure 30.1](#ch30fig01) represent goroutines, and the
    circle represents a channel. A link from a goroutine to a channel is labeled with
    the name of the variable that refers to the channel; the arrow direction represents
    the way the goroutine is using the channel. When an arrow points towards a goroutine,
    the goroutine is reading from the channel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图30.1中的方框代表goroutine，圆圈代表通道。从goroutine到通道的链接用指向通道的变量的名称标记；箭头方向表示goroutine使用通道的方式。当箭头指向goroutine时，goroutine正在从通道中读取。
- en: Figure 30.1\. How the gophers look together
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图30.1\. gopher们一起的样子
- en: '![](30fig01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](30fig01.jpg)'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.3**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查30.3**'
- en: '**[1](#ch30qa6q0a1)**'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa6q0a1)**'
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What statement would you use to send the string `"hello world"` on a channel
    named `c`?
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会使用什么语句在名为`c`的通道上发送字符串`"hello world"`？
- en: '**[2](#ch30qa6q0a2)**'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa6q0a2)**'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you receive that value and assign it to a variable?
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会如何接收那个值并将其分配给一个变量？
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.3 answer**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.3答案**'
- en: '**[1](#ch30qa5q1)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa5q1)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`c <- "hello world"`'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`c <- "hello world"`'
- en: '**[2](#ch30qa5q2)**'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa5q2)**'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`v = <-c`'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`v = <-c`'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.4\. Channel surfing with select
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.4\. 使用select进行通道冲浪
- en: In the preceding example, we used a single channel to wait for many goroutines.
    That works well when all the goroutines are producing the same type of value,
    but that’s not always the case. Often we’ll want to wait for two or more different
    kinds of values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用单个通道等待多个goroutine。当所有goroutine都产生相同类型的值时，这很好，但并不总是这样。我们通常会想要等待两种或更多不同类型的值。
- en: One example of this is when we’re waiting for some values over a channel but
    we want to avoid waiting too long. Perhaps we’re a little impatient with our sleepy
    gophers, and our patience runs out after a time. Or we may want to time out a
    network request after a few seconds rather than several minutes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是我们正在等待通过通道的一些值，但我们不想等待太久。也许我们对我们的沉睡gopher有点不耐烦，经过一段时间后我们的耐心耗尽。或者我们可能想在几秒钟后超时网络请求，而不是几分钟。
- en: Fortunately, the Go standard library provides a nice function, `time.After`,
    to help. It returns a channel that receives a value after some time has passed
    (the goroutine that sends the value is part of the Go runtime).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go标准库提供了一个很好的函数，`time.After`，来帮助。它返回一个通道，在经过一段时间后接收一个值（发送值的goroutine是Go运行时的一部分）。
- en: We want to continue receiving values from the sleepy gophers until either they’ve
    all finished sleeping or our patience runs out. That means we need to wait on
    both the timer channel and the other channel at the same time. The `select` statement
    allows us to do this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望继续从沉睡的gopher那里接收值，直到他们全部完成睡眠或者我们的耐心耗尽。这意味着我们需要同时等待计时器通道和另一个通道。`select`语句允许我们这样做。
- en: The `select` statement looks like the `switch` statement covered in [lesson
    3](kindle_split_012.html#ch03). Each `case` inside a `select` holds a channel
    receive or send. `select` waits until one case is ready and then runs it and its
    associated case statement. It’s as if `select` is looking at both channels at
    once and takes action when it sees something happen on either of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句看起来像在[第3课](kindle_split_012.html#ch03)中介绍的`switch`语句。`select`语句内部的每个`case`都包含一个通道接收或发送。`select`等待直到一个案例准备好，然后运行它及其相关的case语句。就像`select`同时查看两个通道，并在它们中的任何一个发生动作时采取行动一样。'
- en: The following listing uses `time.After` to make a timeout channel and then uses
    `select` to wait for the channel from the sleepy gophers and the timeout channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表使用`time.After`创建一个超时通道，然后使用`select`等待沉睡的gopher的通道和超时通道。
- en: 'Listing 30.5\. Impatiently waiting for sleepy gophers: select1.go'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.5\. 急切等待沉睡的gopher：select1.go
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* The select statement**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* select语句**'
- en: '***2* Waits for a gopher to wake up**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待gopher醒来**'
- en: '***3* Waits for time to run out**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 等待时间耗尽**'
- en: '***4* Gives up and returns**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 放弃并返回**'
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: When there are no cases in the `select` statement, it will wait forever. That
    might be useful to stop the `main` function returning when you’ve started some
    goroutines that you want to leave running indefinitely.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当`select`语句中没有案例时，它将永远等待。这可能在你启动了一些你想无限期运行的goroutine时停止`main`函数返回时很有用。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This isn’t very interesting when all the gophers are sleeping for exactly three
    seconds, because our patience always runs out before any gophers wake up. The
    gophers in the next listing sleep for a random amount of time. When you run this,
    you’ll find that some gophers wake up in time, but others don’t.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有的gopher都恰好睡眠三秒钟时，这并不很有趣，因为我们的耐心总是在任何gopher醒来之前耗尽。在下一条列表中的gopher睡眠的时间是随机的。当你运行这个程序时，你会发现一些gopher按时醒来，但有些却没有。
- en: 'Listing 30.6\. A randomly sleeping gopher: select2.go'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.6\. 随机睡眠的gopher：select2.go
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: This pattern is useful whenever you want to limit the amount of time spent doing
    something. By putting the action inside a goroutine and sending on a channel when
    it completes, anything in Go can be timed out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在你想要限制做某事所花费的时间时非常有用。通过将操作放在goroutine中，并在完成时通过channel发送信号，Go中的任何操作都可以设置超时。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although we’ve stopped waiting for the goroutines, if we haven’t returned from
    the `main` function, they’ll still be sitting around using up memory. It’s good
    practice to tell them to finish, if possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经停止等待goroutines，但如果我们没有从`main`函数返回，它们仍然会占用内存。如果可能的话，告诉它们完成是一个好的做法。
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Nil channels do nothing**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**nil channel 无作用**'
- en: Because you need to create channels explicitly with `make`, you may wonder what
    happens if you use channel values that haven’t been “made.” As with maps, slices,
    and pointers, channels can be nil. In fact, `nil` is their default zero value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要使用`make`显式地创建channel，你可能会想知道如果你使用了尚未“创建”的channel值会发生什么。与map、slice和pointer一样，channel可以是nil。事实上，`nil`是它们的默认零值。
- en: If you try to use a nil channel, it won’t panic—instead, the operation (send
    or receive) will block forever, like a channel that nothing ever receives from
    or sends to. The exception to this is `close` (covered later in this lesson).
    If you try to close a nil channel, it will panic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用nil channel，它不会引发panic——相反，操作（发送或接收）将永远阻塞，就像一个从未接收过或发送过任何内容的channel。这个例外是`close`（在后面的课程中会介绍）。如果你尝试关闭一个nil
    channel，它将引发panic。
- en: At first glance, that may not seem very useful, but it can be surprisingly helpful.
    Consider a loop containing a `select` statement. We may not want to wait for all
    the channels mentioned in the `select` every time through the loop. For example,
    we might only try to send on a channel when we have a value ready to send. We
    can do that by using a channel variable that’s only non-nil when we want to send
    a value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，这可能似乎并不很有用，但它可以非常有帮助。考虑一个包含`select`语句的循环。我们可能不希望在循环的每次迭代中都等待`select`中提到的所有channel。例如，我们可能只在准备好发送值时尝试在channel上发送。我们可以通过使用一个只在想要发送值时才非nil的channel变量来实现这一点。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So far, all has been well. When our `main` function received on the channel,
    it found a gopher sending a value on the channel. But what would happen if we
    accidentally tried to read when there were no goroutines left to send? Or if we
    tried to send on a channel instead of receive?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利。当我们的`main`函数在channel上接收时，它发现有一个gopher在channel上发送了一个值。但如果我们不小心尝试在没有任何goroutine可以发送时读取，或者如果我们尝试在channel上发送而不是接收会发生什么呢？
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.4**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.4**'
- en: '**[1](#ch30qa8q0a1)**'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa8q0a1)**'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What kind of value does `time.After` return?
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`time.After`返回什么类型的值？'
- en: '**[2](#ch30qa8q0a2)**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa8q0a2)**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you send or receive on a nil channel?
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在一个nil channel上发送或接收会发生什么？
- en: '**[3](#ch30qa8q0a3)**'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch30qa8q0a3)**'
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does each case in a `select` statement have in it?
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`select`语句中的每个情况包含什么？'
- en: '|  |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.4 answer**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.4 答案**'
- en: '**[1](#ch30qa7q1)**'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa7q1)**'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A channel.
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个channel。
- en: '**[2](#ch30qa7q2)**'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa7q2)**'
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will block forever.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它将永远阻塞。
- en: '**[3](#ch30qa7q3)**'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch30qa7q3)**'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A channel operation.
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个channel操作。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.5\. Blocking and deadlock
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.5\. 阻塞和死锁
- en: When a goroutine is waiting to send or receive on a channel, we say that it’s
    *blocked*. This might sound the same as if we’d written some code with a loop
    that spins around forever doing nothing, and on the face of it they look exactly
    the same. But if you run an infinite loop in a program on your laptop, you may
    find that the fan starts to whir and the computer gets hot because it’s doing
    a lot of work. By contrast, a blocked goroutine takes no resources (other than
    a small amount of memory used by the goroutine itself). It’s parked itself quietly,
    waiting for whatever is blocking it to stop blocking it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个goroutine在等待发送或接收通道上的数据时，我们称它为*阻塞*。这听起来可能和我们编写了一个永远旋转什么也不做的循环代码一样，表面上它们看起来确实一样。但如果你在你的笔记本电脑上运行一个无限循环，你可能会发现风扇开始嗡嗡作响，电脑变热，因为它做了很多工作。相比之下，一个阻塞的goroutine不占用任何资源（除了goroutine本身使用的一小部分内存）。它安静地停在那里，等待阻止它的因素停止阻止。
- en: 'When one or more goroutines end up blocked for something that can never happen,
    it’s called *deadlock*, and your program will generally crash or hang up. Deadlocks
    can be caused by something as simple as this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个或多个goroutine最终因为某些永远不会发生的事情而阻塞时，我们称之为*死锁*，你的程序通常会崩溃或挂起。死锁可能由像这样简单的事情引起：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In large programs, deadlocks can involve an intricate series of dependencies
    between goroutines.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型程序中，死锁可能涉及goroutine之间复杂的一系列依赖关系。
- en: Although theoretically hard to guard against, in practice, by sticking to a
    few simple guidelines (covered soon), it’s not hard to make deadlock-free programs.
    When you *do* find a deadlock, Go can show you the state of all the goroutines,
    so it’s often easy to find out what’s going on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上难以防范，但在实践中，通过坚持一些简单的指南（很快就会介绍），制作无死锁的程序并不困难。当你*确实*发现死锁时，Go可以显示所有goroutine的状态，因此通常很容易找出发生了什么。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.5**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.5**'
- en: '**[Q1:](#ch30qa10q0a1)**'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch30qa10q0a1)**'
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does a blocked goroutine do?
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个阻塞的goroutine会做什么？
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.5 answer**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.5 答案**'
- en: '**[1:](#ch30qa9q1)**'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch30qa9q1)**'
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It does nothing at all.
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它什么也不做。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 30.6\. A gopher assembly line
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 30.6. 一个地鼠装配线
- en: So far, our gophers have been pretty sleepy. They just sleep for a while and
    then wake up and send a single value on their channel. But not all gophers in
    this factory are like that. Some are industriously working on an assembly line,
    receiving an item from a gopher earlier in the line, doing some work on it, then
    sending it on to the next gopher in the line. Although the work done by each gopher
    is simple, the assembly line can produce surprisingly sophisticated results.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的地鼠们相当懒惰。它们只是睡一会儿，然后醒来，通过它们的通道发送一个值。但这个工厂里并非所有地鼠都这样。有些地鼠在装配线上勤奋工作，从生产线上的前一个地鼠那里接收一个物品，对它进行一些处理，然后将其发送给生产线上的下一个地鼠。尽管每个地鼠完成的工作很简单，但装配线可以产生令人惊讶的复杂结果。
- en: This technique, known as a *pipeline*, is useful for processing large streams
    of data without using large quantities of memory. Although each goroutine might
    hold only a single value at a time, it may process millions of values over time.
    A pipeline is also useful because you can use it as a “thought tool” to help solve
    some kinds of problems more easily.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*流水线*，它对于在不使用大量内存的情况下处理大量数据流非常有用。尽管每个goroutine一次可能只持有单个值，但它们可能在一段时间内处理数百万个值。流水线也很有用，因为你可以将其用作“思维工具”，帮助更容易地解决某些类型的问题。
- en: We already have all the tools we need to assemble goroutines into a pipeline.
    Go values flow down the pipeline, handed from one goroutine to the next. A worker
    in the pipeline repeatedly receives a value from its *upstream* neighbor, does
    something with it, and sends the result *downstream*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了组装goroutine成流水线的所有工具。Go值沿着流水线流动，从一个goroutine传递到下一个。流水线中的工作者反复从其*上游*邻居那里接收一个值，对其进行一些处理，然后将结果发送到*下游*。
- en: Let’s build an assembly line of workers that process string values. The gopher
    at the start of the assembly line is shown in [listing 30.7](#ch30ex07)—the source
    of the stream. This gopher doesn’t read values, but only sends them. In another
    program, this might involve reading data from a file, a database, or the network,
    but here we’ll just send a few arbitrary values. To tell the downstream gophers
    that there are no more values, the source sends a *sentinel value*, the empty
    string, to indicate when it’s done.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个由工人组成的装配线，这些工人处理字符串值。装配线起点的gopher如[列表30.7](#ch30ex07)所示——流的来源。这个gopher不读取值，只发送它们。在另一个程序中，这可能涉及从文件、数据库或网络中读取数据，但在这里我们只发送一些任意值。为了告诉下游的gopher没有更多的值，源发送一个*哨兵值*，即空字符串，以表示何时完成。
- en: 'Listing 30.7\. Source gopher: pipeline1.go'
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.7\. 源gopher：pipeline1.go
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The gopher in [listing 30.8](#ch30ex08) filters out anything bad from the assembly
    line. It reads an item from its upstream channel and only sends it on the downstream
    channel if the value doesn’t have the string `"bad"` in it. When it sees the final
    empty string, the filter gopher quits, making sure to send the empty string to
    the next gopher down the line too.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表30.8](#ch30ex08)中的gopher从装配线中过滤掉任何不良内容。它从其上游通道读取一个项目，并且只有当值中没有字符串`"bad"`时，才将其发送到下游通道。当它看到最后的空字符串时，过滤gopher停止，并确保将空字符串发送到下一个gopher。'
- en: 'Listing 30.8\. Filter gopher: pipeline1.go'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.8\. 过滤gopher：pipeline1.go
- en: '[PRE11]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The gopher that sits at the end of the assembly line—the print gopher—is shown
    in [listing 30.9](#ch30ex09). This gopher doesn’t have anything downstream. In
    another program, it might save the results to a file or a database, or print a
    summary of the values it’s seen. Here the print gopher prints all the values it
    sees.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 装配线末尾的gopher——打印gopher，如[列表30.9](#ch30ex09)所示。这个gopher没有下游。在另一个程序中，它可能将结果保存到文件或数据库中，或者打印它看到的值的摘要。这里的打印gopher打印它看到的所有值。
- en: 'Listing 30.9\. Print gopher: pipeline1.go'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.9\. 打印gopher：pipeline1.go
- en: '[PRE12]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s put our gopher workers together. We’ve got three stages in the pipeline
    (source, filter, print) but only two channels. We don’t need to start a new goroutine
    for the last gopher because we want to wait for it to finish before exiting the
    whole program. When the `printGopher` function returns, we know that the two other
    goroutines have done their work, and we can return from `main`, finishing the
    whole program, as shown in the following listing and illustrated in [figure 30.2](#ch30fig02).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的gopher工人组合起来。我们在管道中有三个阶段（源、过滤、打印），但只有两个通道。我们不需要为最后一个gopher启动一个新的goroutine，因为我们想在退出整个程序之前等待它完成。当`printGopher`函数返回时，我们知道其他两个goroutine已经完成了它们的工作，然后我们可以从`main`返回，完成整个程序，如以下列表和[图30.2](#ch30fig02)所示。
- en: 'Listing 30.10\. Assembly: pipeline1.go'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表30.10\. 装配：pipeline1.go
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Figure 30.2\. Gopher pipeline
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图30.2\. Gopher管道
- en: '![](30fig02_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](30fig02_alt.jpg)'
- en: There’s an issue with the pipeline code we have so far. We’re using the empty
    string a way to signify that there aren’t any more values to process, but what
    if we want to process an empty string as if it were any other value? Instead of
    strings, we *could* send a struct value containing both the string we want and
    a Boolean field saying whether it’s the last value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '我们目前拥有的管道代码存在问题。我们使用空字符串来表示没有更多的值需要处理，但如果我们想将空字符串处理成其他任何值一样呢？我们*可以*发送一个包含我们想要的字符串和一个表示是否为最后一个值的布尔字段的struct值。 '
- en: 'But there’s a better way. Go lets us *close* a channel to signify that no more
    values will be sent, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但有更好的方法。Go允许我们*关闭*一个通道来表示不再发送任何值，如下所示：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a channel is closed, you can’t write any more values to it (you’ll get
    a panic if you try), and any read will return immediately with the zero value
    for the type (the empty string in this case).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个通道被关闭时，你不能向其中写入任何更多的值（如果你尝试这样做，你会得到一个panic），任何读取都会立即返回类型的零值（在这种情况下是空字符串）。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful! If you read from a closed channel in a loop without checking whether
    it’s closed, the loop will spin forever, burning lots of CPU time. Make sure you
    know which channels may be closed and check accordingly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！如果你在一个循环中从关闭的通道读取，而没有检查它是否已关闭，循环将永远旋转，消耗大量的CPU时间。确保你知道哪些通道可能已关闭，并相应地进行检查。
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'How do we tell whether the channel has been closed? Like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断通道是否已关闭？如下所示：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we assign the result to two variables, the second variable will tell us
    whether we’ve successfully read from the channel. It’s false when the channel
    has been closed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将结果分配给两个变量时，第二个变量会告诉我们是否已成功从通道读取。如果通道已关闭，则为 false。
- en: With these new tools, we can easily close down the whole pipeline. The following
    listing shows the source goroutine at the head of the pipeline.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新工具，我们可以轻松关闭整个管道。下一列表显示了管道头部的源 goroutine。
- en: 'Listing 30.11\. Assembly: pipeline2.go'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.11\. 汇编：pipeline2.go
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next listing shows how the filter goroutine now looks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表显示了过滤器 goroutine 现在的样子。
- en: 'Listing 30.12\. Assembly: pipeline2.go'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.12\. 汇编：pipeline2.go
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This pattern of reading from a channel until it’s closed is common enough that
    Go provides a shortcut. If we use a channel in a `range` statement, it will read
    values from the channel until the channel is closed.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从通道读取直到其关闭的模式足够常见，以至于 Go 提供了一个快捷方式。如果我们在一个 `range` 语句中使用通道，它将读取通道中的值直到通道关闭。
- en: This means our code can be rewritten more simply with a `range` loop. The following
    listing accomplishes the same thing as before.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的代码可以用 `range` 循环更简单地重写。以下列表实现了与之前相同的功能。
- en: 'Listing 30.13\. Assembly: pipeline2.go'
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.13\. 汇编：pipeline2.go
- en: '[PRE18]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final gopher on the assembly line reads all the messages and prints one
    after another, as shown in the next listing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编线上的最后一个 gopher 读取所有消息，并依次打印，如下一列表所示。
- en: 'Listing 30.14\. Assembly: pipeline2.go'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 30.14\. 汇编：pipeline2.go
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 30.6**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 30.6**'
- en: '**[1](#ch30qa12q0a1)**'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa12q0a1)**'
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What value do you see when you read from a closed channel?
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你从关闭的通道读取时，你看到了什么值？
- en: '**[2](#ch30qa12q0a2)**'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa12q0a2)**'
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you check whether a channel has been closed?
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何检查通道是否已关闭？
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 30.6 answer**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 30.6 答案**'
- en: '**[1](#ch30qa11q1)**'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch30qa11q1)**'
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The zero value for the channel’s type.
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通道类型的零值。
- en: '**[2](#ch30qa11q2)**'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch30qa11q2)**'
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Use a two-valued assignment statement:'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用双值赋值语句：
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The `go` statement starts a new goroutine, running concurrently.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go` 语句启动一个新的 goroutine，并与之并发运行。'
- en: Channels are used to send values between goroutines.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道用于在 goroutine 之间发送值。
- en: A channel is created with `make(chan string)`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `make(chan string)` 创建一个通道。
- en: The `<-` operator receives from a channel (when used before a channel value).
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<-` 操作符从通道接收值（当在通道值之前使用时）。'
- en: The `<-` operator sends to a channel (when placed between the channel value
    and the value to be sent).
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<-` 操作符将值发送到通道（当放置在通道值和要发送的值之间时）。'
- en: The `close` function closes a channel.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close` 函数关闭一个通道。'
- en: The `range` statement reads all the values from a channel until it’s closed.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range` 语句读取通道中的所有值，直到其关闭。'
- en: Let’s see if you got this...
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些...
- en: 'Experiment: remove-identical.go'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：remove-identical.go
- en: It’s boring to see the same line repeated over and over again. Write a pipeline
    element (a goroutine) that remembers the previous value and only sends the value
    to the next stage of the pipeline if it’s different from the one that came before.
    To make things a little simpler, you may assume that the first value is never
    the empty string.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 看到相同的行重复出现是令人厌烦的。编写一个管道元素（一个 goroutine），它记住前一个值，并且只有当它与之前的不同时，才将值发送到管道的下一阶段。为了使事情更简单一些，你可以假设第一个值永远不会是空字符串。
- en: 'Experiment: split-words.go'
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：split-words.go
- en: Sometimes it’s easier to operate on words than on sentences. Write a pipeline
    element that takes strings, splits them up into words (you can use the `Fields`
    function from the `strings` package), and sends all the words, one by one, to
    the next pipeline stage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候操作单词比操作句子更容易。编写一个管道元素，它接受字符串，将它们拆分成单词（你可以使用 `strings` 包中的 `Fields` 函数），并将所有单词逐个发送到下一个管道阶段。
- en: Lesson 31\. Concurrent state
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 31 课\. 并发状态
- en: After reading [lesson 31](#ch31), you’ll be able to
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完[第 31 课](#ch31)后，你将能够
- en: Keep state safe
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持状态安全
- en: Use mutexes and reply channels
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁和回复通道
- en: Employ service loops
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务循环
- en: Here we are back in the gopher factory. The busy gophers are still building
    things, but several of the production lines are running low on stock, so they
    need to order more.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们又回到了 gopher 工厂。忙碌的 gopher 们仍在建造东西，但有几条生产线库存不足，因此他们需要订购更多。
- en: Unfortunately, this is an old-fashioned factory that only has a single shared
    phone landline to the outside world. All the production lines have their own handset,
    though. A gopher picks up the phone to place an order, but as she starts speaking,
    another gopher picks up another handset and starts dialing, interfering with the
    first gopher. Then another does the same thing and they all get very confused
    and none of them manage to place any order at all. If only they could agree to
    use the phone one at time!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这是一个过时的工厂，只有一条通往外界的单一共享电话线。不过，所有生产线都有自己的听筒。一只地鼠拿起电话下单，但当她开始说话时，另一只地鼠拿起另一个听筒开始拨号，干扰了第一只地鼠。然后另一只也这样做，他们都非常困惑，没有人能成功下单。如果他们能同意一次只使用电话就好了！
- en: '*Shared values* in a Go programs are a bit like this shared phone. If two or
    more goroutines try to use a shared value at the same time, things can go wrong.
    It *might* turn out okay. Perhaps no two gophers will ever try to use the phone
    at the same time. But things can go wrong in all kinds of ways.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go程序中的*共享值*有点像这个共享电话。如果有两个或更多的goroutine试图同时使用一个共享值，事情可能会出错。*可能*会没事。也许没有两只地鼠会同时尝试使用电话。但事情可能会以各种方式出错。
- en: Perhaps two gophers talking at the same time confuse the seller at the other
    end of the line, and they end up ordering the wrong things, or the wrong quantity
    of things, or something else about the order goes wrong. There’s no way to know—all
    bets are off.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 可能两只地鼠同时说话会混淆电话另一端的卖家，他们最终订购了错误的东西，或者订购的数量错误，或者订单的其他方面出了问题。无法知道——所有赌注都取消了。
- en: That’s the problem with shared Go values. Unless we explicitly know that it’s
    okay to use the specific kind of value in question concurrently, we must assume
    that it’s not okay. This kind of situation is known as a *race condition* because
    it’s as if the goroutines are racing to use the value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是共享Go值的问题。除非我们明确知道可以使用特定类型的值进行并发，否则我们必须假设这是不允许的。这种情况被称为*竞态条件*，因为goroutines就像是在争夺使用这个值。
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: The Go compiler includes functionality that tries to find race conditions in
    your code. It’s well worth using, and it’s always worth fixing your code if it
    reports a race. See [golang.org/doc/articles/race_detector.html](http://golang.org/doc/articles/race_detector.html).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器包括尝试在您的代码中查找竞态条件的功能。这非常值得使用，如果它报告了竞态，修复代码总是值得的。请参阅[golang.org/doc/articles/race_detector.html](http://golang.org/doc/articles/race_detector.html)。
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: It’s okay if two goroutines read from the same thing at the same time, but if
    you read or write at the same time as another write, you’ll get undefined behavior.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个goroutine同时从同一事物中读取，这是可以的，但如果你在另一个写入的同时读取或写入，你会得到未定义的行为。
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Say we have a bunch of goroutines working away, crawling the web and *scraping*
    web pages. We might want to keep track of which web pages have already been visited.
    Let’s say we want to keep track of the number of web links to each page (Google
    does something similar to this in order to rank web pages in its search results).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一群goroutine在工作，爬取网页和*抓取*网页。我们可能想要跟踪哪些网页已经被访问过。让我们说我们想要跟踪每个网页的链接数量（谷歌在搜索结果中对网页进行排名时做了一些类似的事情）。
- en: It seems like we could use a map shared between the goroutines that holds the
    link count for each web page. When a goroutine processes a web page, it would
    increment the entry in the map for that page.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们可以在goroutine之间共享一个映射，它包含每个网页的链接计数。当一个goroutine处理一个网页时，它会增加该页面的映射条目。
- en: However, doing that is a mistake because all the goroutines are updating the
    map at the same time, and that produces race conditions. We need some way of getting
    around that. Enter mutexes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做是错误的，因为所有的goroutine都在同时更新映射，这会产生竞态条件。我们需要找到一种绕过它的方法。进入互斥锁。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 31.1\. Mutexes
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.1. 互斥锁
- en: Back in the gopher factory, one clever gopher has a bright idea. She puts a
    glass jar in the middle of the factory floor that holds a single metal token.
    When a gopher needs to use the phone, they take the token out of the jar and keep
    it until the phone call has finished. Then they return the token to the jar. If
    there’s no token in the jar when a gopher wants to make a call, they have to wait
    until the token is returned.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Back in the gopher factory, one clever gopher has a bright idea. She puts a
    glass jar in the middle of the factory floor that holds a single metal token.
    When a gopher needs to use the phone, they take the token out of the jar and keep
    it until the phone call has finished. Then they return the token to the jar. If
    there’s no token in the jar when a gopher wants to make a call, they have to wait
    until the token is returned.
- en: 'Note that there’s nothing that physically stops a gopher from using the phone
    without taking the token. But if they do, there may be unintended consequences
    from two gophers talking over one another on the phone. Also, consider what happens
    if the gopher with the token forgets to return it: no other gopher will be able
    to use the phone until they remember to return it.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'Note that there’s nothing that physically stops a gopher from using the phone
    without taking the token. But if they do, there may be unintended consequences
    from two gophers talking over one another on the phone. Also, consider what happens
    if the gopher with the token forgets to return it: no other gopher will be able
    to use the phone until they remember to return it.'
- en: '![](f0271-01.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](f0271-01.jpg)'
- en: In a Go program, the equivalent of that glass jar is called a *mutex*. The word
    *mutex* is short for *mutual exclusion*. Goroutines can use a mutex to exclude
    each other from doing something at the same time. The *something* in question
    is up to the programmer to decide. Like the jar in the factory, the only “mutual
    exclusion” properties of a mutex come from the fact that we’re careful to use
    it whenever we access the thing we’re guarding with it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: In a Go program, the equivalent of that glass jar is called a *mutex*. The word
    *mutex* is short for *mutual exclusion*. Goroutines can use a mutex to exclude
    each other from doing something at the same time. The *something* in question
    is up to the programmer to decide. Like the jar in the factory, the only “mutual
    exclusion” properties of a mutex come from the fact that we’re careful to use
    it whenever we access the thing we’re guarding with it.
- en: 'Mutexes have two methods: `Lock` and `Unlock`. Calling `Lock` is like taking
    the token from the jar. We put the token back in the jar by calling `Unlock`.
    If any goroutine calls `Lock` while the mutex is locked, it’ll wait until it’s
    unlocked before locking it again.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mutexes have two methods: `Lock` and `Unlock`. Calling `Lock` is like taking
    the token from the jar. We put the token back in the jar by calling `Unlock`.
    If any goroutine calls `Lock` while the mutex is locked, it’ll wait until it’s
    unlocked before locking it again.'
- en: To use the mutex properly, we need to make sure that any code accessing the
    shared values locks the mutex first, does whatever it needs to, then unlocks the
    mutex. If any code doesn’t follow this pattern, we can end up with a race condition.
    Because of this, mutexes are almost always kept internal to a package. The package
    knows what things the mutex guards, but the `Lock` and `Unlock` calls are nicely
    hidden behind methods or functions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: To use the mutex properly, we need to make sure that any code accessing the
    shared values locks the mutex first, does whatever it needs to, then unlocks the
    mutex. If any code doesn’t follow this pattern, we can end up with a race condition.
    Because of this, mutexes are almost always kept internal to a package. The package
    knows what things the mutex guards, but the `Lock` and `Unlock` calls are nicely
    hidden behind methods or functions.
- en: Unlike channels, Go mutexes aren’t built into the language itself. Rather, they’re
    available in the `sync` package. [Listing 31.1](#ch31ex01) is a complete program
    that locks and unlocks a global mutex value. We don’t need to initialize the mutex
    before using it—the zero value is an unlocked mutex.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Unlike channels, Go mutexes aren’t built into the language itself. Rather, they’re
    available in the `sync` package. [Listing 31.1](#ch31ex01) is a complete program
    that locks and unlocks a global mutex value. We don’t need to initialize the mutex
    before using it—the zero value is an unlocked mutex.
- en: The `defer` keyword introduced in [lesson 28](kindle_split_042.html#ch28) can
    help with mutexes too. Even if there are many lines of code in a function, the
    `Unlock` call stays next to the `Lock` call.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: The `defer` keyword introduced in [lesson 28](kindle_split_042.html#ch28) can
    help with mutexes too. Even if there are many lines of code in a function, the
    `Unlock` call stays next to the `Lock` call.
- en: 'Listing 31.1\. Locking and unlocking a mutex: mutex.go'
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.1\. 锁定和解锁互斥锁：mutex.go
- en: '[PRE21]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Imports the sync package**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入sync包**'
- en: '***2* Declares the mutex**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明互斥锁**'
- en: '***3* Locks the mutex**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 锁定互斥锁**'
- en: '***4* Unlocks the mutex before returning**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在返回前解锁互斥锁**'
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Note
- en: The `defer` statement is particularly useful when there are multiple return
    statements. Without `defer`, we’d need a call to `Unlock` just before every return
    statement, and it would be very easy to forget one of those.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: The `defer` statement is particularly useful when there are multiple return
    statements. Without `defer`, we’d need a call to `Unlock` just before every return
    statement, and it would be very easy to forget one of those.
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s implement a type that a web crawler can use to keep track of link counts
    to visited web pages. We’ll store a map holding the URL of the web page and guard
    it with a mutex. The `sync.Mutex` in [listing 31.2](#ch31ex02) is a member of
    a `struct` type, a very common pattern.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个类型，网络爬虫可以使用它来跟踪已访问网页的链接数量。我们将存储一个包含网页URL的映射，并用互斥锁保护它。[列表31.2](#ch31ex02)中的`sync.Mutex`是`struct`类型的一个成员，这是一个非常常见的模式。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: It’s good practice to keep a mutex definition immediately above the variables
    that it’s guarding, and include a comment so the association is clear.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将互斥锁的定义放在它所保护的变量上方，并包含注释，以便关联清晰，是一种良好的实践。
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 31.2\. Page reference map: scrape.go'
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.2\. 页面引用映射：scrape.go
- en: '[PRE22]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Declare a mutex**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个互斥锁**'
- en: '***2* Declare a map from URL (string) keys to integer values**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明一个从URL（字符串）键到整数值的映射**'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, you should assume that no method is safe to use concurrently unless it’s
    explicitly documented, as we’ve done here.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你应该假设除非明确记录，否则没有方法可以在并发中使用，就像我们在这里所做的那样。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The code in the next listing defines a `VisitLink` method to be called when
    a link has been encountered; it returns the number of times that link has been
    encountered before.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码定义了一个`VisitLink`方法，当遇到链接时调用；它返回该链接之前遇到的次数。
- en: 'Listing 31.3\. Visit link: scrape.go'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.3\. 访问链接：scrape.go
- en: '[PRE23]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Locks the mutex**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 锁定互斥锁**'
- en: '***2* Ensures that the mutex is unlocked**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保互斥锁已解锁**'
- en: '***3* Updates the map**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新映射**'
- en: The Go playground isn’t a good place to experiment with race conditions because
    it’s kept deliberately deterministic and race-free. But you can experiment by
    inserting calls to `time.Sleep` between statements.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Go playground不是实验竞态条件的好地方，因为它被故意保持确定性且无竞态。但你可以通过在语句之间插入`time.Sleep`调用来进行实验。
- en: Try modifying [listing 31.3](#ch31ex03) to use the techniques introduced at
    the beginning of [lesson 30](kindle_split_045.html#ch30) to start several goroutines
    that all call `VisitLink` with different values and experiment with inserting
    `Sleep` statements in different places. Also try deleting the `Lock` and `Unlock`
    calls to see what happens.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改[列表31.3](#ch31ex03)，使用在第30课开头介绍的技术来启动几个goroutine，它们都调用带有不同值的`VisitLink`，并尝试在不同位置插入`Sleep`语句进行实验。还尝试删除`Lock`和`Unlock`调用，看看会发生什么。
- en: With a small and well-defined piece of state to guard, a mutex is quite straightforward
    to use and is an essential tool when writing methods that you want to be usable
    from multiple goroutines at once.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一个小而定义良好的状态要保护时，互斥锁的使用相当简单，并且当编写希望从多个goroutine同时使用的方法时，它是必不可少的工具。
- en: '|  |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.1**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查31.1**'
- en: '**[1](#ch31qa2q0a1)**'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch31qa2q0a1)**'
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What might happen if two goroutines try to change the same value at the same
    time?
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个goroutine同时尝试更改相同的值，可能会发生什么？
- en: '**[2](#ch31qa2q0a2)**'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch31qa2q0a2)**'
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you try to lock the mutex again before unlocking it?
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在解锁之前再次尝试锁定互斥锁，会发生什么？
- en: '**[3](#ch31qa2q0a3)**'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch31qa2q0a3)**'
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you unlock it without locking it?
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你没有加锁就解锁会发生什么？
- en: '**[4](#ch31qa2q0a4)**'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch31qa2q0a4)**'
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is it safe to call methods on the same type from different goroutines at the
    same time?
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同时从不同的goroutine调用同一类型的函数是否安全？
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 31.1 answer**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.1 答案**'
- en: '**[1](#ch31qa1q1)**'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch31qa1q1)**'
- en: ''
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s undefined. The program may crash or anything else may happen.
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它是未定义的。程序可能会崩溃或发生其他任何事情。
- en: '**[2](#ch31qa1q2)**'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch31qa1q2)**'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will block forever.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它将永远阻塞。
- en: '**[3](#ch31qa1q3)**'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch31qa1q3)**'
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It will panic: unlock of unlocked mutex.'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它会恐慌：未加锁的互斥锁解锁。
- en: '**[4](#ch31qa1q4)**'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch31qa1q4)**'
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No, not unless specifically documented as such.
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不，除非明确记录为这样。
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 31.1.1\. Mutex pitfalls
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 31.1.1\. 互斥锁陷阱
- en: 'In [listing 31.2](#ch31ex02), when the mutex is locked, we only do a very simple
    thing: we update a map. The more we do while the lock is held, the more we need
    to be careful. If we block to wait for something when we’ve locked the mutex,
    we may be locking others out for a long time. Worse, if we somehow try to lock
    the *same* mutex, we’ll *deadlock*—the `Lock` call will block forever because
    we’re never going to give up the lock while we’re waiting to acquire it!'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表31.2](#ch31ex02)中，当互斥锁被锁定时，我们只做一件非常简单的事情：我们更新一个映射。在锁定期间我们做的越多，我们就越需要小心。如果我们锁定互斥锁等待某事，我们可能会长时间地阻止其他人。更糟糕的是，如果我们试图锁定相同的互斥锁，我们将会**死锁**——`Lock`调用将永远阻塞，因为我们永远不会在等待获取锁的同时放弃锁！
- en: 'To keep on the safe side, follow these guidelines:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，请遵循以下指南：
- en: Try to keep the code within the mutex simple.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量保持mutex中的代码简单。
- en: Only have one mutex for a given piece of shared state.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的共享状态，只有一个mutex。
- en: A mutex is good to use for simple shared state, but it’s not uncommon to want
    something more. In the gopher factory of [lesson 30](kindle_split_045.html#ch30),
    we might want gophers that act independently, responding to requests from other
    gophers but also doing their own thing over time. Unlike the gophers on the assembly
    line, gophers like this don’t respond entirely to messages from other gophers,
    but can decide to do things on their own behalf.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Mutex对于简单的共享状态来说很好用，但有时我们可能需要更多。在[第30课](kindle_split_045.html#ch30)的gopher工厂中，我们可能希望gophers能够独立行动，响应其他gophers的请求，但同时也随着时间的推移做自己的事情。与装配线上的gophers不同，这样的gophers不会完全响应其他gophers的消息，但可以决定为自己做事情。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 31.2**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 31.2**'
- en: '**[Q1:](#ch31qa4q0a1)**'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch31qa4q0a1)**'
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are two potential problems with locking a mutex?
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 锁定mutex可能存在两个潜在的问题是什么？
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 31.2 answer**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.2 答案**'
- en: '**[1:](#ch31qa3q1)**'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch31qa3q1)**'
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It might block other goroutines that are also trying to lock the mutex; it could
    lead to deadlock.
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它可能会阻塞其他也试图锁定mutex的goroutines；这可能导致死锁。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 31.2\. Long-lived workers
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.2. 长期工作者
- en: Consider the task of driving a rover around the surface of Mars. The software
    on the Curiosity Mars rover is structured as a set of independent modules that
    communicate by passing each other messages (see [mng.bz/Z7Xa](http://mng.bz/Z7Xa)),
    much like Go’s goroutines.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在火星表面驾驶探测车的任务。好奇号火星探测车上的软件被构建为一系列独立的模块，通过传递消息相互通信（见[mng.bz/Z7Xa](http://mng.bz/Z7Xa)），这与Go的goroutines非常相似。
- en: The rover’s modules are responsible for different aspects of the rover’s behavior.
    Let’s try to write some Go code that drives a (highly simplified) rover around
    a virtual Mars. Because we don’t have a real engine to drive, we’ll make do by
    updating a variable that holds the coordinates of the rover. We want the rover
    to be controllable from Earth, so it needs to be responsive to external commands.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 探测车的模块负责探测车行为的各个方面。让我们尝试编写一些Go代码，在虚拟火星上驾驶一个（高度简化的）探测车。因为我们没有真正的引擎来驾驶，我们将通过更新一个包含探测车坐标的变量来凑合。我们希望探测车可以从地球控制，因此它需要对外部命令做出响应。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code structure we’re building here can be used for any kind of long-lived
    task that does things independently, such as a website poller or a hardware device
    controller.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的代码结构可以用于任何类型的长期任务，这些任务可以独立执行，例如网站轮询器或硬件设备控制器。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To drive the rover, we’ll start a goroutine that will be responsible for controlling
    its position. The goroutine is started when the rover software starts and stays
    around until it’s shut down. Because it stays around and operates independently,
    we’ll call this goroutine a *worker*.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要驾驶探测车，我们将启动一个goroutine，该goroutine将负责控制其位置。当探测车软件启动时启动goroutine，并在关闭前保持运行。因为它持续运行并独立操作，我们将称这个goroutine为*工作者*。
- en: A worker is often written as a `for` loop containing a `select` statement. The
    loop runs for as long as the worker is alive; the `select` waits for something
    of interest to happen. In this case, the “something of interest” might be a command
    from outside. Remember, although the worker is operating independently, we still
    want to be able to control it. Or it could be a timer event telling the worker
    that it’s time to move the rover.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者通常被编写为一个包含`select`语句的`for`循环。循环在工作者存活期间运行；`select`等待发生感兴趣的事情。在这种情况下，“感兴趣的事情”可能是一个来自外部的命令。记住，尽管工作者是独立操作的，但我们仍然希望能够控制它。或者，它可能是一个定时器事件，告诉工作者是时候移动探测车了。
- en: 'Here’s a skeleton worker function that does nothing:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个什么也不做的骨架工作者函数：
- en: '[PRE24]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can start such a worker exactly as we’ve started goroutines in previous
    examples:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在之前的例子中启动goroutines一样启动这样的工作者：
- en: '[PRE25]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Event loops and goroutines**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件循环和goroutines**'
- en: Some other programming languages use an *event loop* —a central loop that waits
    for events and calls registered functions when they occur. By providing goroutines
    as a core concept, Go avoids the need for a central event loop. Any worker goroutine
    can be considered an event loop in its own right.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他编程语言使用*事件循环*——一个等待事件并当事件发生时调用注册函数的中心循环。通过提供goroutines作为核心概念，Go避免了需要中心事件循环的需求。任何工作者goroutine都可以被视为它自己的事件循环。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We want our Mars rover to update its position periodically. For this, we want
    the worker goroutine that’s driving it to wake up every so often to do the update.
    We can use `time.After` for this (discussed in [lesson 30](kindle_split_045.html#ch30)),
    which provides a channel that will receive a value after a given duration.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的火星漫游车定期更新其位置。为此，我们希望驱动它的工作goroutine每隔一段时间醒来进行更新。我们可以使用`time.After`来实现这一点（在第30课中讨论过），它提供了一个在给定持续时间后接收值的通道。
- en: The worker in [listing 31.4](#ch31ex04) prints a value every second. For the
    time being, instead of updating a position, we just increment a number. When we
    receive a timer event, we call `After` again so that the next time around the
    loop, we’ll be waiting on a fresh timer channel.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 31.4 中的工作进程每秒打印一个值。目前，我们只是增加一个数字而不是更新位置。当我们收到计时器事件时，我们再次调用`After`，这样在下一次循环中，我们将等待一个新的计时器通道。
- en: 'Listing 31.4\. Number printing worker: printworker.go'
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.4\. 数字打印工作进程：printworker.go
- en: '[PRE26]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Makes initial timer channel**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建初始计时器通道**'
- en: '***2* Waits for the timer to fire**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待计时器触发**'
- en: '***3* Prints the number**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印数字**'
- en: '***4* Makes another timer channel for another event**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为另一个事件创建另一个计时器通道**'
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We don’t need to use a `select` statement in this example. A `select` with only
    one case is the same as using the channel operation on its own. But we’re using
    `select` here because later in this lesson, we’ll change the code to wait for
    more than just a timer. Otherwise, we could avoid the `After` call entirely and
    use `time.Sleep`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不需要使用`select`语句。只有一个情况的`select`与直接使用通道操作相同。但在这里我们使用`select`，因为在接下来的课程中，我们将更改代码以等待不仅仅是计时器。否则，我们可以完全避免`After`调用并使用`time.Sleep`。
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we’ve got a worker that can act of its own accord, let’s make it a
    little more rover-like by updating a position instead of a number. Conveniently,
    Go’s `image` package provides a `Point` type that we can use to represent the
    rover’s current position and direction. A `Point` is a structure holding X and
    Y coordinates with appropriate methods. For example, the `Add` method adds one
    point to another.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以独立行动的工作进程，让我们通过更新位置而不是数字使其更像漫游车。方便的是，Go的`image`包提供了一个`Point`类型，我们可以用它来表示漫游车的当前位置和方向。`Point`是一个包含X和Y坐标以及相应方法的结构。例如，`Add`方法将一个点添加到另一个点。
- en: 'Let’s use the X axis to represent east-west and the Y axis to represent north-south.
    To use `Point`, we must first import the `image` package:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用X轴表示东西方向，用Y轴表示南北方向。要使用`Point`，我们必须首先导入`image`包：
- en: '[PRE27]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Every time we receive a value on the timer channel, we add the point representing
    the current direction to the current position, as shown in the next listing. Right
    now, the rover will always start at the same place [10, 10] and proceed East,
    but we’ll address that shortly.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们在计时器通道上接收到一个值时，我们将表示当前方向的点添加到当前位置，如下一列表所示。目前，漫游车将始终从同一位置 [10, 10] 开始并向东行进，但我们将很快解决这个问题。
- en: 'Listing 31.5\. Position updating worker: positionworker.go'
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.5\. 位置更新工作进程：positionworker.go
- en: '[PRE28]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* The current position (initially [10, 10])**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当前位置（初始为 [10, 10]）**'
- en: '***2* The current direction (initially [1, 0], traveling east)**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当前方向（初始为 [1, 0]，向东行进）**'
- en: '***3* Prints the current position**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印当前位置**'
- en: It’s not much good if a Mars rover can only move in a straight line. We’d like
    to be able to control the rover to make it go in different directions, or stop
    it, or make it go faster. We’ll need another channel we can use to send commands
    to the worker. When the worker receives a value on the command channel, it can
    act on the command. In Go, it’s usual to hide channels like this behind methods
    because channels are considered an implementation detail.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个火星漫游车只能直线行进，那就没什么用了。我们希望能够控制漫游车使其向不同方向行进，或停止它，或使其行进得更快。我们需要另一个可以用来向工作进程发送命令的通道。当工作进程在命令通道上接收到一个值时，它可以执行该命令。在Go中，通常将这样的通道隐藏在方法后面，因为通道被认为是实现细节。
- en: The `RoverDriver` type in the following listing holds the channel that we’ll
    use to send commands to the worker. We’ll use a `command` type that will hold
    the commands sent.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的`RoverDriver`类型包含我们将用于向工作进程发送命令的通道。我们将使用一个`command`类型来保存发送的命令。
- en: 'Listing 31.6\. `RoverDriver` type: rover.go'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 31.6\. `RoverDriver` 类型：rover.go
- en: '[PRE29]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can wrap the logic that creates the channel and starts the worker inside
    a `NewRoverDriver` function, shown in the next listing. We’re going to define
    a `drive` method to implement our worker logic. Although it’s a method, it will
    function the same as the `worker` functions from earlier in this chapter. As a
    method, it has access to any values in the `RoverDriver` structure.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将创建通道并启动工作者的逻辑封装在`NewRoverDriver`函数中，如下一列表所示。我们将定义一个`drive`方法来实现我们的工作者逻辑。虽然它是一个方法，但它将像本章前面提到的`worker`函数一样工作。作为一个方法，它能够访问`RoverDriver`结构中的任何值。
- en: 'Listing 31.7\. Create: rover.go'
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.7\. 创建：rover.go
- en: '[PRE30]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need to decide which commands we’d like to be able to send the rover.
    To keep things simple, let’s only allow two commands: “turn 90° left” and “turn
    90° right,” as shown in the following listing.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要决定我们想要能够发送给探测车的命令。为了保持简单，让我们只允许两个命令：“向左转90°”和“向右转90°”，如以下列表所示。
- en: 'Listing 31.8\. Command type: rover.go'
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.8\. 命令类型：rover.go
- en: '[PRE31]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A channel can be any Go type; the command type could be a struct type holding
    arbitrarily complex commands.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以是任何Go类型；命令类型可以是包含任意复杂命令的结构体类型。
- en: '|  |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we’ve defined the `RoverDriver` type and a function to create an instance
    of it, we need the `drive` method (the worker that will control the rover), which
    [listing 31.9](#ch31ex09) provides. It’s almost the the same as the position updater
    worker we saw earlier except that it waits on the command channel too. When it
    receives a command, it decides what to do by switching on the command value. To
    see what’s going on, we log changes as they happen.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`RoverDriver`类型和一个创建其实例的函数，我们需要`drive`方法（将控制探测车的工作者），如[列表31.9](#ch31ex09)提供。它与之前看到的定位更新工作者几乎相同，只是它也等待在命令通道上。当它收到命令时，它会根据命令值来决定要做什么。为了了解发生了什么，我们记录了变化。
- en: 'Listing 31.9\. `RoverDriver` worker: rover.go'
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.9\. `RoverDriver`工作者：rover.go
- en: '[PRE32]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Waits for commands on the command channel**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在命令通道上等待命令**'
- en: '***2* Turns right**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 向右转**'
- en: '***3* Turns left**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向左转**'
- en: Now we can complete the `RoverDriver` type by adding methods to control the
    rover, as shown in [listing 31.10](#ch31ex10). We’ll declare two methods, one
    for each command. Each method sends the correct command on the `commandc` channel.
    For example, if we call the `Left` method, it will send a `left` command value,
    which the worker will receive and change the direction of the worker.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过添加控制探测车的方法来完成`RoverDriver`类型的定义，如[列表31.10](#ch31ex10)所示。我们将声明两个方法，每个命令一个。每个方法都会在`commandc`通道上发送正确的命令。例如，如果我们调用`Left`方法，它将发送一个`left`命令值，工作者将接收这个值并改变工作者的方向。
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although these methods are controlling the direction of the rover, they don’t
    have direct access to the direction value, so there’s no danger that they can
    change it concurrently and risk a race condition. This means we don’t need a mutex,
    because channels allow communication with the rover’s goroutine without changing
    any of its values directly.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法正在控制探测车的方向，但它们没有直接访问方向值，因此不存在它们可以并发更改它并导致竞争条件的风险。这意味着我们不需要互斥锁，因为通道允许与探测车的goroutine通信，而不直接更改其任何值。
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Listing 31.10\. `RoverDriver` methods: rover.go'
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.10\. `RoverDriver`方法：rover.go
- en: '[PRE33]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now that we have a fully functional `RoverDriver` type, [listing 31.11](#ch31ex11)
    creates a rover and sends it some commands. It’s now free to rove!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完全功能的`RoverDriver`类型，[列表31.11](#ch31ex11)创建了一个探测车并发送了一些命令。现在它可以自由地移动了！
- en: 'Listing 31.11\. Let it go!: rover.go'
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表31.11\. 放手吧！rover.go
- en: '[PRE34]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Try experimenting with the `RoverDriver` type by using different timings and
    sending different commands to it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过使用不同的定时和发送不同的命令来实验`RoverDriver`类型。
- en: Although we’ve focused on one specific example here, this worker pattern can
    be useful in many different situations where you need to have some long-lived
    goroutine controlling something while remaining responsive to external control
    itself.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里关注了一个具体的例子，但这种工作者模式可以在许多不同的情况下很有用，在这些情况下，你需要有一些长期运行的goroutine来控制某些东西，同时保持对外部控制的响应。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 31.3**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查31.3**'
- en: '**[1](#ch31qa6q0a1)**'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch31qa6q0a1)**'
- en: ''
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is used instead of an event loop in Go?
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Go中，我们通常使用什么代替事件循环？
- en: '**[2](#ch31qa6q0a2)**'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch31qa6q0a2)**'
- en: ''
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What Go standard library package provides a `Point` data type?
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提供了`Point`数据类型的Go标准库包是什么？
- en: '**[3](#ch31qa6q0a3)**'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch31qa6q0a3)**'
- en: ''
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What Go statements might you use to implement a long-lived worker goroutine?
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会使用哪些Go语句来实现一个长期运行的worker goroutine？
- en: '**[4](#ch31qa6q0a4)**'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch31qa6q0a4)**'
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are internal details of channel use hidden?
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通道使用的内部细节是如何隐藏的？
- en: '**[5](#ch31qa6q0a5)**'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch31qa6q0a5)**'
- en: ''
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What Go values can be sent down a channel?
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以通过通道发送哪些 Go 值？
- en: '|  |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 31.3 answer**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 31.3 答案**'
- en: '**[1](#ch31qa5q1)**'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch31qa5q1)**'
- en: ''
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A loop in a goroutine.
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: goroutine 中的循环。
- en: '**[2](#ch31qa5q2)**'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch31qa5q2)**'
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `image` package.
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`image` 包。'
- en: '**[3](#ch31qa5q3)**'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch31qa5q3)**'
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `for` statement and the `select` statement.
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`for` 语句和 `select` 语句。'
- en: '**[4](#ch31qa5q4)**'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch31qa5q4)**'
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Behind method calls.
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在方法调用之后。
- en: '**[5](#ch31qa5q5)**'
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch31qa5q5)**'
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any value can be sent down a channel.
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何值都可以通过通道发送。
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Never access state from more than one goroutine at the same time unless it’s
    explicitly marked as okay to do so.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非明确标记为可以这样做，否则不要同时从多个 goroutine 访问状态。
- en: Use a mutex to make sure only one goroutine is accessing something at a time.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁确保一次只有一个 goroutine 访问某个东西。
- en: Use a mutex to guard one piece of state only.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只用一个互斥锁来保护一块状态。
- en: Do as little as possible with the mutex held.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少在互斥锁保持期间的操作。
- en: You can write a long-lived goroutine as a worker with a `select` loop.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将一个长生命周期的 goroutine 写作一个带有 `select` 循环的工作者。
- en: Hide worker details behind methods.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法后面隐藏工作者的细节。
- en: Let’s see if you got this...
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否掌握了这些...
- en: 'Experiment: positionworker.go'
  id: totrans-490
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：positionworker.go
- en: Using [listing 31.5](#ch31ex05) as a starting point, change the code so that
    the delay time gets a half a second longer with each move.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 以 [列表 31.5](#ch31ex05) 为起点，修改代码，使每次移动的延迟时间增加半秒。
- en: 'Experiment: rover.go'
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实验：rover.go
- en: Using the `RoverDriver` type as a starting point, define `Start` and `Stop`
    methods and associated commands and make the rover obey them.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `RoverDriver` 类型为起点，定义 `Start` 和 `Stop` 方法以及相关的命令，并使漫游者遵守这些命令。
- en: 'Lesson 32\. Capstone: Life on Mars'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 32 课。火星生活
- en: 32.1\. A grid to rove on
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.1. 可驾驶的网格
- en: 'Make a grid that the rover can drive around on by implementing a `MarsGrid`
    type. You’ll need to use a mutex to make it safe for use by multiple goroutines
    at once. It should look something like the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `MarsGrid` 类型来创建一个漫游者可以驾驶的网格。你需要使用互斥锁来确保它可以同时被多个 goroutine 安全使用。它看起来可能如下所示：
- en: '[PRE35]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now change the rover example from [lesson 31](kindle_split_046.html#ch31) so
    that instead of only updating its coordinates locally, the rover uses a `MarsGrid`
    object passed into the `NewRoverDriver` function. If it hits the edge of the grid
    or an obstacle, it should turn and go in another random direction.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将第 31 课的漫游者示例（[kindle_split_046.html#ch31](https://kindle_split_046.html#ch31)）修改一下，使其不再只是本地更新坐标，而是使用传递给
    `NewRoverDriver` 函数的 `MarsGrid` 对象。如果它触碰到网格的边缘或障碍物，它应该转向并朝另一个随机方向前进。
- en: '![](f0283-01_alt.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](f0283-01_alt.jpg)'
- en: Now you can start several rovers by calling `NewRoverDriver` and see them drive
    around together on the grid.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过调用 `NewRoverDriver` 来启动几个漫游者，并看到它们在网格上一起驾驶。
- en: 32.2\. Reporting discoveries
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2. 报告发现
- en: We want to find life on Mars, so we’ll send several rovers down to search for
    it, but we need to know when life is found. In every cell in the grid, assign
    some likelihood of life, a random number between 0 and 1000\. If a rover finds
    a cell with a life value above 900, it may have found life and it must send a
    radio message back to Earth.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在火星上找到生命，所以我们会派几个漫游者下去寻找，但我们需要知道何时找到生命。在网格的每个单元格中，分配一些生命可能性的概率，一个介于 0 和 1000
    之间的随机数。如果一个漫游者找到一个生命值超过 900 的单元格，它可能已经找到了生命，并且必须发送一个无线电消息回地球。
- en: Unfortunately, it’s not always possible to send a message immediately because
    the relay satellite is not always above the horizon. Implement a buffer goroutine
    that receives messages sent from the rover and buffers them into a slice until
    they can be sent back to Earth.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不总是能够立即发送消息，因为中继卫星并不总是位于地平线上。实现一个缓冲 goroutine，它接收从漫游者发送的消息，并将它们缓冲到一个切片中，直到它们可以发送回地球。
- en: Implement Earth as a goroutine that receives messages only occasionally (in
    reality for a couple of hours every day, but you might want to make the interval
    a little shorter than that). Each message should contain the coordinates of the
    cell where the life might have been found, and the life value itself.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 实现地球作为一个只偶尔接收消息的 goroutine（在现实中，每天可能只有几个小时，但你可能希望将间隔缩短一些）。每个消息应包含可能发现生命的单元格的坐标以及生命值本身。
- en: You may also want to give a name to each of your rovers and include that in
    the message so you can see which rover sent it. It’s also helpful to include the
    name in the log messages printed by the rovers so you can track the progress of
    each one.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 你也许还想给你的每个漫游者起一个名字，并在消息中包含这个名字，这样你就能知道哪个漫游者发送了它。在漫游者打印的日志消息中包含名字也很有用，这样你可以跟踪每个漫游者的进度。
- en: Set your rovers free to search and see what they come up with!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 释放你的漫游者去搜索，看看它们能找到什么！
