- en: 13 Working with sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 使用集合
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Comparing differences between sets and arrays
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较集合和数组之间的差异
- en: Creating sets in different ways
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同方式创建集合
- en: Using union and intersect operations to locate items in different types of software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并集和交集操作在不同类型的软件中定位项目
- en: Understanding tradeoffs between usings sets and search operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用集合和搜索操作之间的权衡
- en: It does not take much time to define a set and show what operations they can
    be used for. What does take time is developing an understanding or intuition about
    what sort of problems you can solve with sets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 定义集合并展示它们可以用于的操作并不需要花费太多时间。真正需要时间的是发展对使用集合可以解决何种问题的理解或直觉。
- en: Many problems related to organizing and locating data can be solved beautifully
    by utilizing sets and set operations, but that is not always apparent. In this
    chapter, I will go through what sets are as well as what you can do with them,
    and then I’ll walk you through various realistic examples showing the power of
    storing data in sets.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用集合和集合操作，可以巧妙地解决许多与组织数据定位相关的问题，但这并不总是显而易见的。在本章中，我将介绍集合是什么以及你可以用它做什么，然后我会通过展示各种现实生活中的例子来展示在集合中存储数据的力量。
- en: 13.1 What kind of problems can sets help solve?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 集合可以帮助解决哪些类型的问题？
- en: 'Lots of software requires organizing large amounts of data, including the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件需要组织大量数据，包括以下内容：
- en: Photo albums
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相册
- en: Email clients
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件客户端
- en: Bug-tracking systems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷跟踪系统
- en: Online shopping
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线购物
- en: Software-development projects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发项目
- en: Specialist software, like modeling software for geologists
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门软件，如地质学家使用的建模软件
- en: For a long time the most popular way of organizing data was via tree structures.
    To find an item you would drill down into subcategories until you found what you
    were looking for. The problem with this approach is that many items can potentially
    exist underneath multiple subcategories instead of just one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很长时间以来，组织数据最流行的方式是通过树形结构。要找到一项物品，你会钻入子类别，直到找到你想要的。这种方法的缺点是，许多物品可能存在于多个子类别下，而不仅仅是单个子类别。
- en: A webshop such as McMaster-Carr (figure 13.1), which sells a huge number of
    mechanical components, is a great example of this problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像McMaster-Carr（图13.1）这样的网店，销售大量机械部件，是这种问题的绝佳例子。
- en: '![13-01](../Images/13-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![13-01](../Images/13-01.png)'
- en: Figure 13.1 McMaster-Carr webshop showing how screws can be categorized in multiple
    ways
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 McMaster-Carr网店展示了螺丝可以以多种方式分类
- en: 'On the side of the screen you can see various categories for screws:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的侧面，你可以看到各种螺丝的分类：
- en: '*System of measurement*—Are the screw dimensions given in imperial or metric
    units?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*度量系统*——螺丝尺寸是以英制单位还是公制单位给出的？'
- en: '*Thread size*—What is the actual measurement of the threads and threads per
    inch?'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*螺纹尺寸*——螺纹的实际测量值和每英寸的螺纹数是多少？'
- en: '*Material*—Is the screw made of steel, plastic, or wood?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*材料*——螺丝是由钢、塑料还是木头制成的？'
- en: '*Length*—What is the length from under the screw head to the end of the threads?'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*长度*——从螺丝头下方到螺纹末端的长度是多少？'
- en: '*Head type*—Is it flat, rounded, or hex shaped?'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部类型*——它是平的、圆形的还是六角形的？'
- en: There are far more categories than I have shown here. The point, however, is
    that you cannot turn this into a tree hierarchy. Both a plastic screw and a steel
    screw can have a rounded head, for example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的分类远不止这些。然而，重要的是你不能将其转换成树形层次结构。例如，塑料螺丝和钢螺丝都可以有圆形的头部。
- en: Another case is photo albums. How do you organize them? You could organize pictures
    by every family member, so your wife and each child gets their own album. Or maybe
    organizing albums based on events, such as visiting Barcelona or Hawaii, makes
    more sense. Or maybe one would prefer activity-based organization such as by creating
    albums for particular types of attractions like technical museums or zoos. Organization
    is difficult, so let’s look at how sets and set operations can help you achieve
    this task.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是相册。你是如何组织它们的？你可以按家庭成员组织照片，这样你的妻子和每个孩子都有自己的相册。或者，也许根据事件组织相册，比如访问巴塞罗那或夏威夷，更有意义。或者，也许有人更喜欢基于活动的组织，比如为特定类型的景点创建相册，如技术博物馆或动物园。组织很困难，所以让我们看看集合和集合操作如何帮助你完成这项任务。
- en: 13.2 What is a set?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 什么是集合？
- en: 'A *set* is a collection type just like arrays or dictionaries. The following
    is an example of creating a set:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种集合类型，就像数组或字典一样。以下是一个创建集合的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Symbols instead of strings
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用符号代替字符串
- en: ❷ Attempted to add duplicates
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试添加重复项
- en: In the first case, a set of fruits is created, where each fruit is represented
    by a string. The second case is similar, but symbols are used instead of strings
    to represent fruits. It is a useful example, since symbols are often used in Julia
    to represent keys.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，创建了一个包含水果的集合，其中每个水果都由一个字符串表示。第二种情况类似，但使用符号而不是字符串来表示水果。这是一个有用的例子，因为符号在
    Julia 中经常用来表示键。
- en: Sets are like the keys of a dictionary; no element occurs twice. Notice in the
    last example, nodups, 3 is attempted to be added multiple times. Like a dictionary,
    the elements don’t exist in any particular order. When you iterate over a set,
    elements will appear in a specific order. However, you have no control over this
    order. If you add or remove elements the order can change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类似于字典的键；没有元素重复。注意在最后一个例子中，nodups，3 被尝试添加多次。像字典一样，元素没有特定的顺序。当您遍历一个集合时，元素将以特定的顺序出现。然而，您无法控制这个顺序。如果您添加或删除元素，顺序可能会改变。
- en: That behavior is different from, say, an array, where you have full control
    over how the addition and removal of elements affects the order of the array.
    If you add an element to an array using push!, then every element stays in the
    same position as before. Every element can be accessed with the exact same index
    as previously.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与数组不同，例如，您可以对数组中元素的增加和删除如何影响数组的顺序有完全的控制。如果您使用 push! 向数组中添加一个元素，那么每个元素都会保持原来的位置。每个元素都可以使用与之前相同的索引访问。
- en: 13.2.1 Comparing properties of sets and arrays
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 比较集合和数组的属性
- en: You can get a better sense of what a set is by comparing its properties with
    those of an array (table 13.1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较集合的属性与数组的属性（表13.1），您可以更好地理解什么是集合。
- en: Table 13.1 Differences and similarities between sets and arrays
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表13.1 集合和数组之间的差异和相似之处
- en: '| Property | Sets | Arrays |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 集合 | 数组 |'
- en: '| Duplicates allowed | No | Yes |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 允许重复 | 否 | 是 |'
- en: '| Elements ordered | No | Yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 元素有序 | 否 | 是 |'
- en: '| Random access | No | Yes |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 随机访问 | 否 | 是 |'
- en: '| Quick membership test | Yes | No |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 快速成员测试 | 是 | 否 |'
- en: '| Iterable | Yes | Yes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 可迭代 | 是 | 是 |'
- en: 'The following are two desirable properties offered by sets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 集合提供了以下两个期望的属性：
- en: Sets are guaranteed not to have any duplicate elements.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合保证不包含任何重复元素。
- en: It is very quick to check if a set contains a specific object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一个集合是否包含一个特定的对象非常快。
- en: Arrays, in contrast, don’t offer a quick way of checking whether they contain
    a specific object because determining whether an array contains an element or
    not requires looking at every element in the array. So looking for a particular
    element in an array of two million elements will, on average, take twice as long
    as looking for it in an array of one million elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，数组没有提供快速检查它们是否包含特定对象的方法，因为确定数组是否包含一个元素需要查看数组中的每个元素。所以在一个包含两百万个元素的数组中寻找特定元素，平均需要的时间是寻找一个包含一百万个元素的数组中元素的两倍。
- en: This is called a *linear* relationship. However, for a set, the number of operations
    required to locate an element does not grow with the size of the set. There is
    no linear relationship.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 *线性* 关系。然而，对于集合来说，定位一个元素所需的操作数量不会随着集合大小的增加而增加。没有线性关系。
- en: Sets can be implemented in different ways; thus, in some variants on average,
    *log(n)* checks are required to look up an element in a set of *n* elements. To
    help you better understand the benefits of using sets, let’s make some comparisons
    of sets with arrays for different types of operations sets are optimized for.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以用不同的方式实现；因此，在某些变体中，平均需要 *log(n)* 次检查才能在包含 *n* 个元素的集合中查找一个元素。为了帮助您更好地理解使用集合的好处，让我们比较一下集合与针对不同类型操作优化的数组。
- en: Searching a sorted array
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在有序数组中搜索
- en: 'In a sorted array you can perform a *binary search*. Consider the following
    sorted array of numbers for a quick idea of how that works:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在有序数组中，您可以执行 *二分搜索*。考虑以下有序数字数组，以快速了解它是如何工作的：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This sorted array has 9 numbers. Say you are looking for the number 18\. The
    number is somewhere in the range 1:9 (index range). Normally, finding the number
    would require 8 comparisons, but with binary search you begin in the middle A[5]
    == 11 and ask if 18 > 11 or if 18 < 11.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有序数组有 9 个数字。比如说您正在寻找数字 18。这个数字在 1:9（索引范围）的某个地方。通常，找到这个数字需要 8 次比较，但使用二分搜索，您从中间开始
    A[5] == 11，并询问 18 是否大于 11 或小于 11。
- en: 'Because the array is sorted, you can conclude 18 is somewhere in the upper
    half of the array or, more specifically, the index range 6:9. This search process
    is repeated by checking the middle of this range. Since there isn’t a middle in
    this range one could round down the index to A[7] == 15. You find that 18 is above
    this value. Hence in 3 comparisons, rather than 8, you can locate the answer.
    Julia has several functions for doing this type of search:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是排序的，你可以得出结论18位于数组的上半部分，或者更具体地说，索引范围6:9。这个搜索过程通过检查这个范围的中间值来重复进行。由于这个范围内没有中间值，可以将索引向下取整到A[7]
    == 15。你发现18大于这个值。因此，在3次比较中，而不是8次，你就可以找到答案。Julia有几个用于执行此类搜索的函数：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The downside of using sorted arrays is that the programmer has to make sure
    the array is sorted at all times. It makes insertions slow, as you must re-sort
    the array each time. Sets have the benefit of allowing not only fast checks on
    membership (e.g., determining whether an element is in the set) but also fast
    insertion and removal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用排序数组的一个缺点是程序员必须确保数组始终是排序的。这会使插入操作变慢，因为每次插入都必须重新排序数组。集合的好处在于不仅允许快速检查成员资格（例如，确定一个元素是否在集合中），而且也允许快速插入和删除。
- en: Performing object membership tests
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行对象成员资格测试
- en: 'You can turn the array A into a set S. Both support membership test with in
    or its Greek equivalent ∈. You can also use ⊆ or issubset to check if multiple
    elements are members:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数组A转换为集合S。它们都支持使用in或其希腊语等价物∈进行成员资格测试。你还可以使用⊆或issubset来检查多个元素是否是成员：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Arrays look similar in behavior, but these operations will happen faster on
    a set. The exception is for small collections. With few elements, no collection
    is as fast as an array. Once you go above 30-40 elements a set will start outperforming
    an unsorted array on membership tests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在行为上看起来很相似，但这些操作在集合上会更快速。例外情况是对于小集合。在元素较少的情况下，没有任何集合比数组更快。一旦超过30-40个元素，集合在成员资格测试上就会开始优于未排序的数组。
- en: However, it is still advisable to use sets for small collections if maintaining
    a unique set of elements is important and order isn’t. It helps *communicate*
    to the reader of your code how it is supposed to work. Using more sophisticated
    collection types, such as Dictionary or Set, really starts to pay off once you
    have a large number of elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果保持一组唯一的元素很重要而顺序不重要，那么仍然建议使用集合。这有助于*传达*你代码的工作方式。使用更复杂的集合类型，如Dictionary或Set，一旦你有大量元素，就会真正开始带来回报。
- en: Sets don’t allow duplicates
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不允许重复
- en: 'What happens when you attempt to create a Set with duplicates? The following
    example explores this topic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试创建一个包含重复元素的集合时会发生什么？以下示例探讨了这个问题：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Duplicates are allowed in arrays but not in sets.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许重复，但集合不允许。
- en: Random access and ordering of elements
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的随机访问和排序
- en: 'I will create a set and an array with the same elements to demonstrate how
    random access and ordering is entirely different:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个集合和一个具有相同元素的数组来演示随机访问和排序是如何完全不同的：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you use collect or foreach they will iterate over the collections. You can
    see the order is different; it is not guaranteed and can change between different
    versions of Julia:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用collect或foreach，它们将遍历集合。你可以看到顺序是不同的；它不是保证的，并且在不同版本的Julia之间可能会改变：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I am able to use brackets to access array elements by index:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用方括号通过索引访问数组元素：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But this is not possible to do with a set:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不可能用集合来完成：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With an array, push! adds each element to a predictable location:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组时，push!会将每个元素添加到可预测的位置：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However for sets, the element can end up anywhere:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于集合来说，元素可以出现在任何地方：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With an array, pop! will remove the last element added:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组时，pop!将移除最后添加的元素：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, with a Set this operation is best avoided, as you have no control
    over what element you actually end up removing:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用集合进行此操作最好避免，因为你无法控制最终移除的是哪个元素：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, it may have been more appropriate for Julia to throw an exception,
    rather than letting the user perform pop!.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Julia抛出异常可能更为合适，而不是让用户执行pop!操作。
- en: 13.3 How to use set operations
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 如何使用集合操作
- en: Set operations are used to combine sets to create new sets. However, set operations
    are not actually limited to sets. You can perform set operations between arrays
    as well. The difference is that sets are designed to support this, while arrays
    are not. Arrays only perform set operations efficiently for small collections
    of elements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作用于组合集合以创建新的集合。然而，集合操作实际上并不限于集合。你还可以在数组之间执行集合操作。区别在于集合被设计来支持这一点，而数组则不是。数组只对元素数量较少的集合执行集合操作效率较高。
- en: 'Set operations allow you to answer questions such as the following: *Give me
    the pictures of Bob when he visited Spain and Greece.* If Bob represents all images
    of your uncle Bob in your photos application, Spain is a set of all your pictures
    from Spain, and Greece is a set of all your pictures from Greece, then such a
    question can be answered with either of these two equivalent expressions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作允许你回答如下问题：*给我鲍勃访问西班牙和希腊时的照片*。如果鲍勃代表你在照片应用中叔叔鲍勃的所有图片，西班牙是一个包含你所有西班牙照片的集合，希腊是一个包含你所有希腊照片的集合，那么这样的问题可以用这两个等效表达式中的任何一个来回答：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This demonstrates the use of the union and intersect operations. These can also
    be written using the ∪ and ∩ symbols. The best way to visualize the behavior of
    the different set operations is by using Venn diagrams^([1](#pgfId-1013781)) (figure
    13.2).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了使用并集和交集操作。这些也可以使用 ∪ 和 ∩ 符号来表示。通过使用维恩图^([1](#pgfId-1013781))（图 13.2）是可视化不同集合操作行为的最有效方式。
- en: '![13-02](../Images/13-02.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![13-02](../Images/13-02.png)'
- en: Figure 13.2 Venn diagrams helping explain set operations
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 帮助解释集合操作的维恩图
- en: The two circles in each example represent the sets A and B. These are overlapping
    sets, meaning some of the elements in A also exist in B.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个例子中的两个圆圈代表集合 A 和 B。这些是重叠的集合，意味着 A 中的某些元素也存在于 B 中。
- en: The colored area shows which elements are included in the set resulting from
    the set operation. For instance, with a *set union* all the elements in A and
    B are included in the result. For *set intersection*, however, only elements shared
    between A and B are part of the result. You might recognize an analogy with the
    AND && and OR || operators used in Boolean logic. With *union* the elements must
    be in set A *or* set B. With *intersection* they must be in set A *and* set B.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 彩色区域显示了集合操作结果中包含哪些元素。例如，对于 *集合并集*，A 和 B 中的所有元素都包含在结果中。然而，对于 *集合交集*，只有 A 和 B
    共享的元素才是结果的一部分。你可能已经注意到了与布尔逻辑中使用的 AND && 和 OR || 操作符的类比。对于 *并集*，元素必须在集合 A *或* 集合
    B 中。对于 *交集*，它们必须在集合 A *和* 集合 B 中。
- en: 'With *set difference* the order is important. setdiff(A, B) returns the elements
    in A remaining after you’ve removed elements in A that also exist in B. Let’s
    look at a practical example of how this is used. Imagine having some sets of photo
    captions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *集合差分* 时，顺序很重要。setdiff(A, B) 在你从 A 中移除也存在于 B 中的元素后，返回 A 中剩余的元素。让我们看看这个实际应用的例子。想象一下有一些照片标题的集合：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So there are three people—Bob, Joe, and Eve—who have been on various vacations
    abroad, where they have taken pictures. In this example, those pictures are represented
    as their caption text.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有三个人——鲍勃、乔和伊芙——他们去过国外的各种度假胜地，在那里他们拍了照片。在这个例子中，这些照片被表示为它们的标题文本。
- en: 'In this scenario, you want to use set operations to find pictures containing
    more than one of these people. bob is a set of all pictures Bob has been in, joe
    is a set of all pictures Joe has been in, and eve is a set of all pictures Eve
    has been in. This code finds pictures in which Bob and Joe were together on vacation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你想要使用集合操作来找到包含这些人中多于一人的照片。bob 是鲍勃参与的所有照片的集合，joe 是乔参与的所有照片的集合，eve 是伊芙参与的所有照片的集合。此代码找到鲍勃和乔一起度假的照片：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Perhaps Eve broke up with Joe, so you don’t want pictures with Joe in them.
    Eve can then use setdiff to exclude Joe pictures:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也许伊芙和乔分手了，所以你不想看到有乔的照片。然后伊芙可以使用 setdiff 来排除乔的照片：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Perhaps Joe wants to find all vacations he spent together with somebody else:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也许乔想找到他和其他人一起度过的所有假期：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Sets can, of course, contain any kind of object. Let’s do some slightly less
    exciting set operations with numbers. A is a set of mostly even numbers, while
    B contains mostly odd numbers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 集合当然可以包含任何类型的对象。让我们用一些稍微不那么令人兴奋的数字集合操作来做一些事情。A 是一个主要由偶数组成的集合，而 B 包含了大部分的奇数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can get the set intersection in two different ways:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种不同的方式得到集合的交集：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also get the set union:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以得到集合的并集：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And finally, you can get the set difference of A and B:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以得到 A 和 B 的集合差分：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, order matters with set difference.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，集合差分中的顺序很重要。
- en: 13.4 How to use sets in your code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 如何在代码中使用集合
- en: The basic operations of sets are not hard to learn. It takes more time to get
    a sense of when to use sets in your code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的基本操作不难学习。学会何时在代码中使用集合需要更多的时间。
- en: Often I have been surprised by how sets can provide powerful and elegant solutions
    to difficult problems. It is very easy to forget that sets are lying in your toolbox.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常对集合如何提供强大而优雅的解决方案来解决难题感到惊讶。很容易忘记集合就在你的工具箱里。
- en: In the following sections you will look at problems that can be solved using
    sets. I will also contrast using sets with other solutions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，你将看到可以使用集合解决的问题。我还会对比使用集合与其他解决方案。
- en: I will first show how to create sets for different product categories using
    the Set constructor. Afterwards, I will demonstrate the process of finding screws
    matching different criteria by using the intersect and setdiff operations. The
    alternative solution will be based on defining a Screw composite type with different
    properties. I will show how to use the filter function to find Screw objects matching
    desired criteria.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先展示如何使用集合构造函数创建不同产品类别的集合。之后，我将通过使用交集和集合差操作来演示查找符合不同标准的螺丝的过程。替代方案将基于定义具有不同属性的螺丝复合类型。我将展示如何使用过滤器函数来查找符合所需标准的螺丝对象。
- en: 13.5 Searching for products using set operations
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 使用集合操作搜索产品
- en: When dealing with products in, say, a Web shop, you would typically use an SQL^([2](#pgfId-1014612))
    database. This process is conceptually similar to using set operations, which
    is why I will expand on the example of buying screws from an online hardware shop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理，比如说，网店中的产品时，你通常会使用SQL^([2](#pgfId-1014612))数据库。这个过程在概念上与使用集合操作相似，这就是为什么我会扩展在线五金店购买螺丝的例子。
- en: 'A screw can have different head types:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 螺丝可以有不同的头部类型：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You may want a flat screw if you want the screw flush with the surface or a
    headless one for things like set screws for axle collars. The screw can have a
    drive style, which indicates what kind of tip you need to have on your screwdriver
    to turn the screw around:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要螺丝与表面齐平或者需要一个无头的螺丝，比如用于轴套的螺丝，那么螺丝可以有一个驱动方式，这表明你需要什么样的螺丝刀尖端来转动螺丝：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Material should be obvious:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 材料应该是显而易见的：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is the list of categories. Each item in the list is actually a Set, and
    the set contains a product number uniquely identifying that screw. For practical
    reasons I will demonstrate inventing some 3-digit product numbers. The following
    example uses ranges to quickly create a large number of product numbers:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分类列表。列表中的每一项实际上是一个集合，该集合包含一个唯一标识该螺丝的产品编号。出于实际原因，我将演示如何发明一些三位数的产品编号。以下示例使用范围快速创建大量产品编号：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you look carefully at the numbers, you will see that they are overlapping.
    For example, some of the aluminum product numbers are the same as the hex product
    numbers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察数字，你会看到它们是重叠的。例如，一些铝制产品编号与六角产品编号相同。
- en: 'With these sets defined, I can ask various useful questions, such as the following:
    Which screws in your product catalog have a rounded head, are made of wood, and
    can be fastened with a torx screwdriver? Answering this requires just a simple
    set operation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些集合之后，我可以提出各种有用的问题，例如以下问题：在你的产品目录中，哪些螺丝是圆头、由木头制成，并且可以用扭矩螺丝刀拧紧？回答这个问题只需要一个简单的集合操作：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Or how about getting all steel screws that can be fastened with a Phillips screwdriver?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你想得到所有可以用菲利普螺丝刀拧紧的钢制螺丝？
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or maybe you just want to know whether T-slot screws not made of plastic exist:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可能只想知道是否存在非塑料制成的T型槽螺丝：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is one way of using sets, but you can accomplish the same with entirely
    different designs, not utilizing sets at all. Instead, you could define a screw
    as a richer data type with properties for each attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使用集合的方法，但你也可以用完全不同的设计实现相同的效果，根本不使用集合。相反，你可以定义一个螺丝为一个具有每个属性属性的更丰富的数据类型：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Instead of dealing with screws as just numbers, there is a data type with properties,
    with which you could attempt to match some given search criteria. You can see
    the various properties are represented by the custom types HeadType, DriveStyle,
    and Material. In a different example, these could be with these strings or symbols,
    but instead they are made as particular types to catch cases in which an illegal
    category is assigned to any of the attributes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅将螺丝视为数字，存在一个具有属性的 数据类型，您可以使用它来尝试匹配一些给定的搜索条件。您可以看到，各种属性由自定义类型HeadType、DriveStyle和Material表示。在不同的例子中，这些可以是这些字符串或符号，但它们被制作成特定的类型，以便在将非法类别分配给任何属性时捕获这些情况。
- en: 13.5.1 Defining and using enumerations
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.1 定义和使用枚举
- en: 'To represent different categories, you use enumerations, or enum for short.
    Enumerations exist in a number of different languages. In Julia they are a bit
    peculiar because they are defined using macros. Now restart Julia, as these variables
    are already defined; otherwise there will be complaints about variables already
    being defined:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示不同的类别，您可以使用枚举，或简称为enum。枚举存在于多种不同的语言中。在Julia中，它们有点特别，因为它们是通过宏来定义的。现在重新启动Julia，因为这些变量已经定义了；否则，会有关于变量已定义的抱怨：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The giveaway is the @ prefix. You can think of hex, slotted, and torx as instances
    of the DriveStyle type. In fact, you can use the DriveStyle constructor to create
    them:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提示是@前缀。您可以将六角、槽口和Torx视为DriveStyle类型的实例。实际上，您可以使用DriveStyle构造函数来创建它们：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, you can see the added type safety in the last example. It is not possible
    to create other values for DriveStyle than the ones specified when the enumeration
    was defined.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以在最后一个例子中看到增加的类型安全性。在定义枚举时，除了指定的值之外，无法为DriveStyle创建其他值。
- en: 13.5.2 Creating test data to perform queries on
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.2 创建测试数据以执行查询
- en: 'To demonstrate using this type to locate screws with different properties,
    you need to create some test data to operate on:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用此类型定位具有不同属性的螺丝，您需要创建一些测试数据来操作：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code creates an array of screws with product numbers in the range 100
    to 150, and you pick values for each property at random. The instances function
    returns an array of every possible value for an enumeration:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个包含螺丝产品编号在100到150范围内的数组，并且您为每个属性随机选择值。instances函数返回枚举的每个可能值的数组：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 13.5.3 Searching for screws
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.3 搜索螺丝
- en: 'The first example showed screws matching your desired criteria using set operations.
    Now you will find desired screws by searching through all the screws in an array
    and checking whether each screw matches all desired criteria. The example will
    show how to do that by specifying predicate functions. A predicate function will
    take a screw as an argument and return true or false, depending on whether the
    criteria the predicate function tests for was met. isroundwood will test whether
    the given screw has rounded heads made of wood:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子展示了使用集合操作匹配您所需标准的螺丝。现在，您将通过搜索数组中的所有螺丝并检查每个螺丝是否满足所有所需条件来找到所需的螺丝。示例将通过指定谓词函数来展示如何做到这一点。谓词函数将螺丝作为参数，并根据谓词函数测试的标准是否满足返回true或false。isroundwood将测试给定的螺丝是否具有由木材制成的圆形头部：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This predicate can then be used (function returning a Boolean value) to filter
    screws:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谓词可以用来（返回布尔值的函数）过滤螺丝：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How about finding what nonplastic T-slot screws are offered in the store?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在商店里能找到哪些非塑料T型槽螺丝呢？
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 13.5.4 Putting screw objects into sets
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.4 将螺丝对象放入集合
- en: The best solution for each case is not always easy to determine, so it is worth
    knowing about different approaches. Sometimes it makes sense to combine solutions.
    You can put these screw objects into sets as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种情况，最佳解决方案并不总是容易确定，因此了解不同的方法是有价值的。有时结合解决方案是有意义的。您也可以将这些螺丝对象放入集合中。
- en: 'You can use the filter function to produce sets, which can be reused later:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用filter函数生成集合，这些集合以后可以重复使用：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can then use these sets in set operations:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用这些集合进行集合操作：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, this solution can be further improved upon.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案还可以进一步改进。
- en: 13.5.5 Looking up screws using dictionaries
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.5 使用字典查找螺丝
- en: 'Frequently, buyers know the product number of the screw they want and want
    to lookup the screw using this number rather than a complex search critera. By
    storing screws in a dictionary, where the key is the product number, you can solve
    this use case:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，买家知道他们想要的螺丝的产品编号，并希望使用这个编号而不是复杂的搜索条件来查找螺丝。通过将螺丝存储在字典中，其中键是产品编号，你可以解决这个用例：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code change allows you to get back to the original solution where you
    use product numbers in your sets. Let’s first make some new sets based on product
    numbers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码更改允许你回到原始解决方案，其中你在集合中使用乘积数。让我们首先基于乘积数创建一些新的集合：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now you are back to the elegance of using set operations to pick desired products,
    based on product keys in sets:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你回到了使用集合操作根据集合中的产品键选择所需产品的优雅方式：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 13.6 Search in bug tracker using sets
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 使用集合在错误跟踪器中进行搜索
- en: When developing larger pieces of software, particularly in a team, companies
    will usually use some form of bug-tracking tool. Commonly, these are web applications
    that allow testers to submit descriptions of bugs. Managers or product specialists
    may then review these bugs and assign priorities and severity before the bugs
    finally get assigned to software developers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发较大的软件组件，尤其是在团队中，公司通常会使用某种形式的错误跟踪工具。通常，这些是允许测试者提交错误描述的Web应用程序。经理或产品专家随后可以审查这些错误，并在错误最终分配给软件开发者之前分配优先级和严重性。
- en: 'Some common attributes recorded for a bug include the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 记录给错误的常见属性包括以下内容：
- en: '*Project*—What software project is it part of?'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目*—这是哪个软件项目的一部分？'
- en: '*Priority*—How important is this bug to fix?'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先级*—修复这个错误有多重要？'
- en: '*Severity*—Is it a minor annoyance or a crash in critical functionality?'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严重性*—这是一个小的烦恼还是一个关键功能崩溃？'
- en: '*Component*—Is this in a user interface, client, server, or so on?'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件*—这是在用户界面、客户端、服务器等中吗？'
- en: '*Assignee*—Who is assigned to deal with the bug currently?'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*负责人*—目前谁被分配去处理这个错误？'
- en: 'Just like with products, bugs will usually be uniquely identified by a bug
    number. Thus, a very similar approach to the one described previously can be used:
    you can use bugs in dictionaries, where the keys are the bug numbers.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就像产品一样，错误通常会被一个唯一的错误编号唯一标识。因此，可以采用与之前描述的非常相似的方法：你可以在字典中使用错误，其中键是错误编号。
- en: 'I’ll demonstrate defining sets composed of different bug numbers. The following
    are some questions you can imagine being solved using sets:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示定义由不同错误编号组成的集合。以下是一些你可以想象使用集合解决的问题：
- en: What are the most critical bugs assigned to Bob in the Lunar Lander project?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在月球着陆器项目中分配给鲍勃的最关键的错误是什么？
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It may not be practical to have names for each set like this, and sets should
    be organized according to the fields in the bug tracker. The following shows using
    dictionaries to group related sets:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不实用为每个集合命名，并且集合应根据错误跟踪器中的字段进行组织。以下展示了使用字典来分组相关集合：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When doing the set operation on multiple objects, it may be more practical
    not to use the operator symbols. This is equivalent:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当对多个对象进行集合操作时，可能更实用的是不使用操作符符号。这相当于：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A manager may ask the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 经理可能会问以下问题：
- en: What top priority bugs are being handled by Bob and Eve?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃和伊芙正在处理哪些顶级优先级的错误？
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We could have looked at many more examples, but hopefully, this gives you a
    good idea of how you can use sets to simplify problems in your own applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以查看更多的例子，但希望这能给你一个很好的想法，了解你如何在自己的应用程序中使用集合来简化问题。
- en: 13.7 Relational databases and sets
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7 关系型数据库和集合
- en: If you have worked with SQL and relational databases before, then a lot of what
    you have seen in this chapter might look familiar. In the SQL database query language,
    one can perform many operations similar to set operations. What is called an *inner
    join* in the database world is equivalent to a *set intersection*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前已经使用过SQL和关系型数据库，那么你在这个章节中看到的大部分内容可能看起来很熟悉。在SQL数据库查询语言中，可以执行许多类似于集合操作的操作。在数据库世界中称为*内连接*的操作相当于*集合交集*。
- en: Relational databases are built upon a branch of mathematics called *relational
    algebra*, which covers modeling data and queries on it. In this chapter, you have
    explored set theory, which is more basic. With relational databases, you can create
    tables of data with multiple columns that have relations to other tables. The
    Julia data structure most similar to database tables is called a DataFrame^([3](#pgfId-1016470))
    and exists in the DataFrames package.^([4](#pgfId-1016498)) For in-depth coverage
    of the DataFrames package, see Bogumił Kamin´ski’s *Julia for Data Analysis* (Manning,
    2022).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库建立在一种称为**关系代数**的数学分支之上，它涵盖了数据建模及其查询。在本章中，你已经探讨了集合论，这是更基础的。使用关系数据库，你可以创建具有多个列的表格数据，这些列与其他表有关。与数据库表最相似的数据结构称为DataFrame^([3](#pgfId-1016470))，它存在于DataFrames包中.^([4](#pgfId-1016498))有关DataFrames包的深入介绍，请参阅Bogumił
    Kamin´ski的《Julia for Data Analysis》（Manning，2022年）。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Sets can help you organize data such as photo albums, defects in a bug-tracking
    tool, or items sold in a web shop.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合可以帮助你组织数据，如相册、缺陷跟踪工具中的缺陷或在线商店中销售的商品。
- en: Sets don’t have duplicates and allow very quick membership tests, unlike arrays
    of elements.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与元素数组不同，集合没有重复项，并且允许非常快速的成员测试。
- en: Elements in sets have no well-defined order, unlike arrays. Elements cannot
    be inserted at specific positions in the set.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中的元素没有明确的顺序，与数组不同。元素不能在集合中的特定位置插入。
- en: Create a set by providing an array of elements such as Set([4, 8, 10]).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供元素数组，如Set([4, 8, 10])，来创建一个集合。
- en: Combine sets using set operations such as union, intersect, and setdiff.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并集、交集和集合差等集合操作来组合集合。
- en: Check if an element x is in a set S with the in function. This can be written
    as in(x, S) or x in S.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用in函数检查元素x是否在集合S中。这可以写成in(x, S)或x in S。
- en: Create an enum type with the @enum macro. @enum Fruit apple banana creates an
    enum type Fruit with legal values apple and banana.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用@enum宏创建枚举类型。@enum Fruit apple banana创建了一个具有有效值apple和banana的枚举类型Fruit。
- en: You can achieve operations similar to set operations using filter on an array.
    However, performance will not be equally good for large datasets.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在数组上使用filter来执行类似于集合操作的操作。然而，对于大型数据集，性能可能不会同样良好。
- en: Set theory and relational algebra (used in relational databases) allow you to
    do similar operations. However, sets deal with values, while relational databases
    deal with tables and their relations.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合论和关系代数（用于关系数据库）允许你执行类似操作。然而，集合处理的是值，而关系数据库处理的是表及其关系。
- en: '* * *'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Venn diagrams are usually used to illustrate the logical relationships
    between two or more sets of items.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)维恩图通常用于说明两个或多个项目集合之间的逻辑关系。
- en: ^(2.)Structured Query Language (SQL) is a specialized language for formulating
    database queries. A query is a request for data in a database matching one or
    more criteria.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)结构化查询语言（SQL）是一种用于制定数据库查询的专用语言。查询是对数据库中符合一个或多个标准的数据请求。
- en: ^(3.)A dataframe has multiple named columns. Each column can contain different
    types of data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (3.)数据框具有多个命名列。每一列可以包含不同类型的数据。
- en: ^(4.)See [https://dataframes.juliadata.org/](https://dataframes.juliadata.org/)
    for more information on DataFrames packages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (4.)有关DataFrames包的更多信息，请参阅[https://dataframes.juliadata.org/](https://dataframes.juliadata.org/)。
