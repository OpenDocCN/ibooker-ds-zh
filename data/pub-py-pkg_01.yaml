- en: 1 The what and why of Python packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 Python包的什么和为什么
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Packaging code to make it more accessible to others
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包代码以使其更容易被他人访问
- en: Using packages to make your own projects more manageable
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包来使你的项目更易于管理
- en: Building Python packages for different platforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同平台构建Python包
- en: Imagine that you’ve written a groundbreaking piece of Python software for use
    in self-driving cars. Your latest work is going to change the world, and you want
    as many people using it as possible. You’ve convinced CarCorp to use your solution,
    and they want to retrieve the code to get started with it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你已经为自动驾驶汽车编写了一款具有突破性的Python软件。你的最新作品将改变世界，你希望尽可能多的人使用它。你已经说服CarCorp使用你的解决方案，他们希望获取代码以开始使用。
- en: When CarCorp calls to ask how to install and use your code, you go through all
    the gory details of copying each file to the right directory, making some files
    executable so they can be run as commands, and so on. Because you wrote the software,
    this is all second nature to you. To your surprise, the developers on the other
    end of the phone are a bit lost. What happened?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当CarCorp打电话询问如何安装和使用你的代码时，你详细说明了将每个文件复制到正确的目录，使一些文件可执行以便作为命令运行等等。因为你编写了软件，所以这一切对你来说都是第二本能。令你惊讶的是，电话另一端的开发者有点迷茫。发生了什么？
- en: You’ve discovered the chasm that often exists between those who create software
    and those who use it. These days, people are used to visiting the app store on
    their iPhone when they need something new. You have a bit of work to do if you
    want to improve the user experience of your software!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了那些创造软件的人和那些使用软件的人之间常常存在的鸿沟。如今，当人们需要新东西时，他们习惯于访问iPhone上的应用商店。如果你想提高你软件的用户体验，你还有一点工作要做！
- en: 'In this book, you’ll learn how distributing your Python project as an installable
    package can make it more accessible to others. You’ll also learn how to create
    a repeatable process for managing your projects, reducing the effort you’ll spend
    maintaining them, so you can focus on your real aspiration: to change the world.
    You’ll do all this by building a real project using some popular packaging tools
    and automating several aspects of the process. Although the Python community has
    developed standards for some areas of packaging, the One True Way© of doing things
    has not yet emerged. Nor may it ever do so!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何将你的Python项目作为可安装的包分发，使其更容易被他人访问。你还将学习如何为管理你的项目创建一个可重复的过程，减少你维护它们所花费的努力，这样你就可以专注于你的真正抱负：改变世界。你将通过构建一个真实的项目并使用一些流行的打包工具来自动化流程的几个方面来实现这一切。尽管Python社区已经为打包的一些领域制定了标准，但“唯一正确的方式©”尚未出现。也许它永远不会出现！
- en: Even if you’ve created or published a Python package before, you’ll find something
    in this book for you. The suggestions and tools you’ll learn in this book are
    time-tested approaches to some of the more loosely defined packaging practices.
    Python packaging has a messy history and many current alternative options, so
    in addition to seeing and using the tools available now, you’ll also learn the
    methodology behind how they work to continue adapting as the landscape matures.
    To that end, it’s important to first understand why software is packaged at all.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你之前已经创建或发布过Python包，你在这本书中也会找到适合你的内容。你将在本书中学到的建议和工具是经过时间考验的，用于一些定义较为宽松的打包实践。Python打包有着混乱的历史和许多当前的替代选项，因此，除了查看和使用现在可用的工具外，你还将学习它们背后的工作方法，以便随着环境的成熟而继续适应。为此，首先理解为什么软件需要打包是很重要的。
- en: 1.1 What is a package, anyway?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是包？
- en: To save your relationship with CarCorp, you promise to come back in a few weeks
    with an overhauled process that will help them install your software in a snap.
    You know that some of your favorite Python code, like `pandas` and `requests`,
    are available as packages online, and you want to provide the same ease of installation
    to your own consumers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了挽救与CarCorp的关系，你承诺几周后回来，带来一个彻底改进的过程，这将帮助他们轻松安装你的软件。你知道一些你最喜欢的Python代码，如`pandas`和`requests`，可以作为包在网上获得，你希望为你自己的消费者提供同样的安装便利。
- en: '*Packaging* is the act of archiving software along with metadata that describes
    those files. Developers usually create these archives, or *packages*, with the
    intent of sharing or publishing them.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*打包*是将软件及其描述这些文件的元数据存档的行为。开发者通常创建这些存档，或*包*，目的是为了共享或发布它们。'
- en: 'Important The Python ecosystem uses the word *package* for two distinct concepts.
    The Python Packaging Authority (PyPA ) differentiates the terms in the *Python
    Packaging User Guide* ([https://packaging.python.org](https://packaging.python.org))
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：Python生态系统使用“软件包”一词来表示两个不同的概念。Python打包权威机构（PyPA）在 *Python打包用户指南* ([https://packaging.python.org](https://packaging.python.org))
    中区分了这些术语，如下所示：
- en: '*Import packages* organize multiple Python modules into a directory for discovery
    purposes ([http://mng.bz/wypg](http://mng.bz/wypg)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*导入包* 将多个Python模块组织到一个目录中，用于发现目的 ([http://mng.bz/wypg](http://mng.bz/wypg))。'
- en: '*Distribution packages* archive Python projects to be published for others
    to install ([http://mng.bz/qoNz](http://mng.bz/qoNz)).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分发包* 将 Python 项目存档以供他人安装 ([http://mng.bz/qoNz](http://mng.bz/qoNz))。'
- en: Import packages aren’t always distributed in an archive, though distribution
    packages often contain one or more import packages. Distribution packages are
    the main subject of this book and will be disambiguated from import packages where
    necessary to avoid confusion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包的导入并不总是以存档的形式分发，尽管分发包通常包含一个或多个导入包。分发包是本书的主要内容，并在必要时将与导入包区分开来，以避免混淆。
- en: With a probably infinite number of ways to roll software and its metadata together,
    how do maintainers and users of that software manage expectations and reduce manual
    work? That’s where *package management systems* come in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在将软件及其元数据组合在一起可能有无限种方式的情况下，维护者和软件使用者如何管理期望并减少手动工作？这就是 *包管理系统* 发挥作用的地方。
- en: 1.1.1 Standardizing packaging for automation
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 标准化打包以实现自动化
- en: 'Package management systems, or *package managers*, standardize the archive
    and metadata format for software packages in a particular domain. Package managers
    provide tools to help consumers install dependencies at the project, programming
    language, framework, or operating system level. Most package managers ship with
    a familiar set of instructions to install, uninstall, or update packages. You
    may have used some of the following package managers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理系统，或称为 *包管理器*，为特定领域的软件包标准化存档和元数据格式。包管理器提供工具以帮助消费者在项目、编程语言、框架或操作系统级别安装依赖项。大多数包管理器都附带一套熟悉的指令来安装、卸载或更新软件包。你可能使用过以下一些包管理器：
- en: pip ([https://pip.pypa.io](https://pip.pypa.io))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pip ([https://pip.pypa.io](https://pip.pypa.io))
- en: conda ([https://docs.conda.io](https://docs.conda.io))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: conda ([https://docs.conda.io](https://docs.conda.io))
- en: Homebrew ([https://brew.sh/](https://brew.sh/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew ([https://brew.sh/](https://brew.sh/))
- en: npm ([https://www.npmjs.com/](https://www.npmjs.com/))
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm ([https://www.npmjs.com/](https://www.npmjs.com/))
- en: asdf ([https://asdf-vm.com/](https://asdf-vm.com/))
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: asdf ([https://asdf-vm.com/](https://asdf-vm.com/))
- en: The early days of package management
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理早期的日子
- en: Although developers had been packaging their code informally for some time,
    it wasn’t until package management systems became widely available in the early
    1990s that this approach took off (see Jeremy Katz, “A Brief History of Package
    Management,” *Tidelift*, [http://mng.bz/7ZG4](http://mng.bz/7ZG4)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发者们已经非正式地打包他们的代码有一段时间了，但直到20世纪90年代初包管理系统变得广泛可用，这种方法才开始流行（参见Jeremy Katz，“包管理简史”，*Tidelift*，[http://mng.bz/7ZG4](http://mng.bz/7ZG4))。
- en: The ability to declaratively define project dependencies proved a boon to developer
    productivity by abstracting away a major area of legwork in managing software
    projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明性定义项目依赖关系的能力，通过抽象出管理软件项目的主要繁琐工作，极大地提高了开发者的生产力。
- en: '*Software repositories* standardize packaging further by acting as centralized
    marketplaces to publish and host packages that others can install (see figure
    1.1). Many programming language communities provide an official or de facto standard
    repository for installing packages. PyPI ([https://pypi.org](https://pypi.org)),
    RubyGems ([https://rubygems.org/](https://rubygems.org/)), and Docker Hub ([https://hub.docker.com/](https://hub.docker.com/))
    are a few popular software repositories.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件仓库* 通过作为集中市场来发布和托管其他可以安装的软件包，进一步标准化了软件打包（见图1.1）。许多编程语言社区提供官方或事实上的标准仓库以安装软件包。PyPI
    ([https://pypi.org](https://pypi.org))、RubyGems ([https://rubygems.org/](https://rubygems.org/))
    和 Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) 是一些流行的软件仓库。'
- en: '![](../../OEBPS/Images/01-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-01.png)'
- en: Figure 1.1 Packages, package managers, and software repositories are all critical
    to sharing software.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 软件包、包管理器和软件仓库对于软件共享都是至关重要的。
- en: If you own a smartphone, tablet, or desktop computer and you’ve installed apps
    from an app store, that’s packaging at work. Packages are software bundled together
    with metadata about that software, and that’s precisely what an app is. Software
    repositories host software that people can install, and that’s what an app store
    is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有一部智能手机、平板电脑或台式电脑，并且从应用商店安装了应用，那么这就是在应用软件包。软件包是将软件与关于该软件的元数据捆绑在一起，这正是应用的本质。软件仓库托管人们可以安装的软件，这就是应用商店。
- en: So, packages are software and metadata rolled together in an agreed-upon format,
    codified in the relevant package management system. At a more granular level,
    packages also typically include a way to build the software on a user’s system,
    or they may provide several prebuilt versions of the software for a variety of
    target systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，软件包是将软件和元数据结合在一起，按照约定的格式编码在相关的包管理系统中。在更细粒度的层面上，软件包通常还包括在用户系统上构建软件的方法，或者它们可能为各种目标系统提供几个预构建的软件版本。
- en: 1.1.2 The contents of a distribution package
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 分发软件包的内容
- en: Figure 1.2 shows some of the files you might choose to put in a distribution
    package. Developers often include the source code files in a package, but they
    can also provide compiled artifacts, test data, and whatever else a consumer or
    colleague might need. By distributing a package, your consumers will have a one-stop
    shop to grab all the pieces they need to get started with your software.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 展示了一些你可能选择放入分发软件包中的文件。开发者通常在软件包中包含源代码文件，但他们也可以提供编译工件、测试数据和消费者或同事可能需要的任何其他内容。通过分发软件包，你的消费者将有一个一站式商店来获取他们开始使用你的软件所需的所有部件。
- en: '![](../../OEBPS/Images/01-02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-02.png)'
- en: Figure 1.2 A package often includes source code, a makefile for compiling the
    code, metadata about the code, and instructions for the consumer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 一个软件包通常包括源代码、编译代码的 makefile、关于代码的元数据以及给消费者的说明。
- en: Distributing noncode files is an important capability. Although the code is
    often the reason to distribute anything in the first place, many users and tools
    depend on the metadata about the code to differentiate it from other code. Developers
    usually specify the name of a software project, its creator(s), the license under
    which it can be reused, and so on in the metadata. Importantly, the metadata often
    includes the version of the archive to distinguish it from previous and future
    publications of the project.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分发非代码文件是一个重要的功能。尽管代码通常是分发任何内容的原因，但许多用户和工具依赖于关于代码的元数据来区分它与其他代码。开发者通常在元数据中指定软件项目的名称、其创建者、可以重新使用的许可协议等。重要的是，元数据通常包括存档的版本，以区分项目之前的和未来的发布。
- en: The early days of sharing software
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 软件共享的早期阶段
- en: For more than a decade after the Unix operating system first became available,
    sharing software between teams and individuals remained a largely manual process.
    Downloading source code, compiling it, and contending with the artifacts of the
    compilation were all left up to the person trying to use the code. Each step in
    this process introduced opportunities for failure due to human error and architectural
    or environmental differences between systems. Tools like Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    removed some of this variation from the process but stopped shy of package version,
    dependency, and installation management.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 操作系统首次可用后的十多年里，团队和个人之间的软件共享仍然是一个主要的手动过程。下载源代码、编译它以及处理编译的工件都留给了试图使用代码的人。这个过程的每一步都引入了由于人为错误和系统之间的架构或环境差异而失败的机会。像
    Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
    这样的工具从过程中移除了一些这种变化，但并未触及包版本、依赖和安装管理。
- en: Now that you’re familiar with what goes into a package, you’ll learn how this
    approach to sharing software solves specific problems in practice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了软件包的内容，你将了解这种软件共享方法如何在实践中解决具体问题。
- en: 1.1.3 The challenges of sharing software
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 软件共享的挑战
- en: Your call with CarCorp is growing tense, and you realize you forgot to have
    them install all your project’s dependencies first. You back up a few steps and
    navigate them through the dependency installation. Unfortunately, you forgot to
    check which version you’ve been using for one of your major dependencies, and
    the latest version doesn’t seem to work. You walk them through installing each
    previous version until you finally find one that works. Crisis narrowly averted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您与CarCorp的通话变得越来越紧张，您意识到您忘记让他们首先安装您项目的所有依赖项。您退后几步，并引导他们进行依赖项安装。不幸的是，您忘记检查您的一个主要依赖项所使用的版本，而最新版本似乎不起作用。您引导他们安装每个之前的版本，直到您最终找到一个可以工作的版本。危机险些酿成。
- en: As you develop increasingly complex systems, the effort to make sure you’ve
    installed the required version of each dependency correctly grows quickly. In
    the worst cases, you might reach a point where you need two different versions
    of the same dependency, and they can’t coexist. This is affectionally known as
    “dependency hell.” Detangling a project from this point can prove challenging.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您开发越来越复杂的系统，确保您正确安装每个依赖项所需版本的努力会迅速增加。在最坏的情况下，您可能达到需要同一依赖项的两个不同版本，它们无法共存。这被亲切地称为“依赖地狱”。从这个点开始梳理项目可能会很具挑战性。
- en: Even without running into dependency hell, without a standardized approach to
    packaging, it can be difficult to share software in a standard way so that anyone,
    anywhere knows what other dependencies they need to install for your project.
    Software communities create conventions and standards for managing packages, codifying
    those practices into the package management systems you use to get your work done.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有遇到依赖地狱，如果没有标准化的包装方法，以标准方式共享软件也可能很困难，这样任何地方的人都知道他们需要安装哪些其他依赖项来使用您的项目。软件社区为管理包创建了惯例和标准，将这些实践编纂成您用来完成工作的包管理系统中。
- en: Now that you understand why packaging is good for sharing software, read on
    to learn about some of the advantages that packaging can provide even if you aren’t
    always making your software publicly available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了为什么包装对分享软件有好处，请继续阅读，了解即使您并不总是公开分享您的软件，包装也能提供的一些优势。
- en: 1.2 How packaging helps you
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 包装如何帮助您
- en: 'If you’re new to packaging, it may seem so far like it’s mainly useful for
    sharing software with people across the globe. Although that’s certainly a good
    reason to package your code, you may also like some of the following benefits
    that packaging brings when developing software:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对包装还不太熟悉，它可能看起来主要是为了与全球各地的人分享软件而有用。尽管这当然是一个包装代码的好理由，但您可能也会喜欢以下包装在软件开发中带来的好处：
- en: Stronger cohesion and encapsulation
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更强的凝聚力和封装
- en: Clearer definition of ownership
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更清晰的归属定义
- en: Looser coupling between areas of the code
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码区域之间的耦合更松
- en: More opportunity for composition
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的组合机会
- en: The following sections cover these benefits in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将详细介绍这些好处。
- en: 1.2.1 Enforcing cohesion and encapsulation through packaging
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 通过包装实现凝聚力和封装
- en: A particular area of code should generally have one job. *Cohesion* measures
    how dutifully the code sticks to that job. The more stray functionality is floating
    around, the less cohesive the code is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的特定区域通常应该只完成一项工作。*凝聚性*衡量代码对这个工作的忠诚度。游离功能越多，代码的凝聚性就越低。
- en: You’ve probably used functions, classes, modules, and import packages to organize
    your Python code (see Dane Hillard, “The Hierarchy of Separation in Python,” *Practices
    of the Python Pro*, Manning Publications, 2020, pp. 25–39, [http://mng.bz/m2N0](http://mng.bz/m2N0)).
    These constructs each place a kind of named boundary around areas of code that
    have a particular job. When done well, naming communicates to developers what
    belongs inside the boundary and, importantly, what doesn’t.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经使用函数、类、模块和导入包来组织您的Python代码（参见Dane Hillard，“Python中的分离层次结构”，《Python专家实践》，Manning
    Publications，2020年，第25-39页，[http://mng.bz/m2N0](http://mng.bz/m2N0)）。这些构造中的每一个都在具有特定工作的代码区域周围放置了一种命名的边界。当做得好的时候，命名会向开发者传达边界内属于什么，以及，更重要的是，不属于什么。
- en: Despite best efforts, names and people are rarely perfect. If you put all your
    Python code in a single application, chances are some code will eventually seep
    into areas it doesn’t belong. Think about some of the larger projects you’ve developed.
    How many times did you create a `utils.py` or `helpers.py` module containing a
    grab bag of functionality? The boundaries you create with a function or a module
    are readily overcome. These “utility” areas of the code tend to attract new “utilities,”
    with the cohesion trending down over time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管付出了最大努力，名称和人物很少是完美的。如果你把所有的Python代码放在一个应用程序中，有些代码最终可能会渗透到它不属于的区域。想想你开发的一些大型项目。你创建了多少次包含各种功能的`utils.py`或`helpers.py`模块？你通过函数或模块创建的边界很容易被克服。这些“实用”的代码区域往往会吸引新的“实用”功能，随着时间的推移，其内聚性呈下降趋势。
- en: Imagine that your self-driving car system can use lidar ([https://oceanservice.noaa.gov/facts/lidar.xhtml](https://oceanservice.noaa.gov/facts/lidar.xhtml))
    as one type of input. CarCorp’s vehicles don’t include lidar sensors. Being the
    diligent developer you are, you create a lidar-specific part of the code base
    to separate it from other concerns. Although assessing naming and regularly refactoring
    the code base can keep cohesion higher, it’s also a maintenance burden. Distribution
    packages increase the barrier to adding code where it may not belong in the first
    place. Because updating a package necessitates going through a cycle of packaging,
    publishing, and installing the update, it prompts developers to think more deeply
    about the changes they make. You will be less likely to add code to a package
    without explicit intent that’s worth the investment of the update cycle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的自动驾驶汽车系统可以使用激光雷达([https://oceanservice.noaa.gov/facts/lidar.xhtml](https://oceanservice.noaa.gov/facts/lidar.xhtml))作为输入类型之一。CarCorp的车辆不包括激光雷达传感器。作为你勤奋的开发者，你创建了一个针对激光雷达的特定代码库部分，以将其与其他关注点分离。尽管评估命名和定期重构代码库可以提高内聚性，但这也是一种维护负担。分发包增加了将代码添加到可能一开始就不应该存在的位置的障碍。因为更新包需要经历打包、发布和安装更新的周期，这促使开发者更深入地思考他们所做的更改。你不太可能在没有明确意图的情况下向包中添加代码，这种意图值得更新周期的投资。
- en: Creating cohesion and packaging a cohesive area of code is a gateway into *encapsulation*.
    Encapsulation helps you build the right expectations with your consumers about
    how to interact with your code by defining whether and how the code’s behavior
    is exposed. Think of a project you built and shared with someone to use. Now think
    about how many times you changed your code, and how many times they had to change
    their code in turn. How frustrating was it for them? How about for you? Encapsulation
    can reduce this kind of churn by better defining the API contract that’s less
    subject to change. Figure 1.3 shows how you might create multiple packages out
    of cohesive areas of code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内聚性和包装内聚的代码区域是进入*封装*的途径。封装通过定义代码的行为是否以及如何暴露来帮助你在消费者中建立正确的期望，以便如何与你的代码交互。想想你构建并与人共享以供使用的一个项目。现在想想你修改了多少次你的代码，他们又不得不相应地修改多少次代码。这对他们来说有多令人沮丧？对你来说呢？封装可以通过更好地定义不太可能改变的API合同来减少这种类型的
    churn。图1.3展示了如何从内聚的代码区域创建多个包。
- en: '![](../../OEBPS/Images/01-03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3](../../OEBPS/Images/01-03.png)'
- en: Figure 1.3 Packaging can reduce unexpected interdependence between areas of
    code by introducing stronger boundaries.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 通过引入更强的边界，包装可以减少代码区域之间意外的相互依赖。
- en: You might’ve felt frustration in the past when you found that a piece of code
    meant only for use internal to a module was being used widely throughout the code.
    Each time you update that “internal” code, you need to update usages elsewhere.
    This high-churn environment can lead to bugs when you don’t propagate a change
    everywhere, leaving you or your team that much less productive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当你发现一些仅用于模块内部使用的代码被广泛地用于整个代码中时，你可能感到过挫败。每次你更新那“内部”代码时，你都需要在其他地方更新使用情况。这种高
    churn 的环境可能导致错误，当你没有在所有地方传播更改时，这会使你或你的团队的生产力降低。
- en: Well-encapsulated, highly cohesive code will change rarely, even when used widely.
    This kind of code is sometimes labeled “mature.” Mature code is a great candidate
    for distributing as a package because you won’t need to republish it frequently.
    You can get a start in packaging by extracting some of the more mature code from
    your code base and then use what you know about cohesion and encapsulation to
    bring less mature code up to snuff.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的封装和高度内聚的代码很少改变，即使在使用广泛的情况下。这种代码有时被标记为“成熟”。成熟的代码是作为包分发的绝佳候选者，因为你不需要频繁重新发布。你可以通过从你的代码库中提取一些更成熟的代码开始打包，然后利用你对内聚和封装的了解来提升不那么成熟的代码。
- en: 1.2.2 Promoting clear ownership of code
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 推广代码的明确所有权
- en: Teams benefit from clear ownership over areas of code. Ownership often goes
    beyond maintaining the behavior of the code itself. Teams build automation to
    streamline unit testing, deployment, integration testing, performance testing,
    and more. That’s a lot of plates to keep spinning at once. Keeping the scope of
    a bounded area of code small so that a team can own all these aspects will ensure
    the code’s longevity. Packaging is one tool for managing scope.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 团队从对代码区域的明确所有权中受益。所有权往往超出了维护代码本身行为。团队构建自动化工具以简化单元测试、部署、集成测试、性能测试等。这需要同时保持许多任务运转。将代码区域的范围保持小，以便团队能够拥有所有这些方面，将确保代码的长期性。打包是管理范围的一个工具。
- en: The encapsulation you create through packaging code enables you to develop automation
    independent of other code. As an example, automation for a code base with little
    structure may require you to write conditional logic to determine which tests
    to run based on which files changed. Alternatively, you might run all the tests
    for every change, which can be slow. Creating packages that you can test and publish
    independently of other code will result in clearer mappings from source code to
    test code to publication code (see figure 1.4).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打包代码创建的封装使你能够独立于其他代码开发自动化。例如，对于结构简单的代码库的自动化可能需要你编写条件逻辑来确定基于哪些文件更改运行哪些测试。或者，你可能为每次更改运行所有测试，这可能会很慢。创建可以独立于其他代码进行测试和发布的包，将导致从源代码到测试代码再到发布代码的更清晰的映射（见图1.4）。
- en: '![](../../OEBPS/Images/01-04.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/01-04.png)'
- en: Figure 1.4 Teams can take full ownership over individual packages, defining
    how they want to manage the development, testing, and publishing life cycle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 团队可以完全拥有单个包，定义他们想要如何管理开发、测试和发布生命周期。
- en: A clear delineation of purpose for a package makes it likelier to have a clear
    delineation of ownership. If a team isn’t sure what they’re committing to by taking
    ownership of some code, they’re going to be wary. Try providing a package with
    a clear scope, story, and operator’s manual to see how the mood shifts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包的明确目的划分使其更有可能拥有明确的所有权。如果一个团队不确定通过接管某些代码所做出的承诺是什么，他们可能会谨慎行事。尝试提供一个具有明确范围、故事和操作手册的包，看看情绪如何转变。
- en: 1.2.3 Decoupling implementation from usage
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 将实现与使用解耦
- en: You may have heard the term *loose coupling* used to describe the level of interdependence
    between areas of code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经听说过“松耦合”这个术语，用来描述代码区域之间相互依赖的程度。
- en: Definition Coupling is a measure of the interdependence between areas of code.
    Loosely coupled code provides multiple avenues of flexibility so you can implement
    and choose from a variety of execution strategies instead of being forced down
    a particular path. Two pieces of code with low coupling have little or no dependence
    on each other, and they can be changed at different rates.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 定义耦合是衡量代码区域之间相互依赖程度的指标。松耦合的代码提供了多种灵活性途径，因此你可以实施和选择多种执行策略，而不是被迫走特定的路径。两个低耦合的代码片段之间几乎或没有任何依赖，并且它们可以以不同的速度进行更改。
- en: The cohesion and encapsulation practices you read about earlier in this chapter
    are a way to reduce the likelihood of tight coupling due to poor code organization.
    Highly cohesive code will have tight coupling within itself and loose coupling
    to anything outside its boundary. Encapsulation exposes an intentional API, limiting
    any coupling to that API. Your choices about packaging and encapsulation, then,
    help you decouple your consumers from implementation details in your code. Packaging
    also makes it possible to decouple consumers from implementation through versioning,
    namespacing, and even the programming language in which software is written.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到的凝聚和封装实践是一种减少由于代码组织不良而导致紧密耦合可能性的方法。高度凝聚的代码将在其内部有紧密耦合，对外部边界之外的事物有松散耦合。封装暴露了一个有意的API，将任何耦合限制在该API上。因此，你在打包和封装方面的选择有助于你将消费者从代码的实现细节中解耦。打包还通过版本控制、命名空间以及甚至编写软件的编程语言，使得消费者可以从实现中解耦。
- en: In a big ball of mud, you’re stuck running whatever code is in each module.
    If you or someone on your team updates a module, all code using that module needs
    to accommodate the change immediately. If the update changes a call signature
    or a return value, it may have a wide blast radius. Packaging significantly reduces
    this restriction (see figure 1.5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个混乱的大球中，你只能运行每个模块中的代码。如果你或你的团队中的某个人更新了一个模块，所有使用该模块的代码都需要立即适应这个变化。如果更新改变了调用签名或返回值，它可能会产生广泛的影响。打包显著减少了这种限制（见图1.5）。
- en: '![](../../OEBPS/Images/01-05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/01-05.png)'
- en: Figure 1.5 Packaging provides flexibility so two areas of code can evolve at
    different rates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 打包提供了灵活性，使得两个代码区域可以以不同的速度发展。
- en: Imagine if each update to the `requests` package required you to react immediately
    by updating your own code. That would be a nightmare! Because packages version
    the code they contain, and because consumers can specify which version they want
    to install, a package can be updated many times without impacting consuming code.
    Developers can choose precisely when to incur the effort of updating their code
    to accommodate a change in a more recent version of the package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每次对`requests`包的更新都需要你立即反应，更新你自己的代码。那将是一场噩梦！因为包会对包含的代码进行版本控制，并且因为消费者可以指定他们想要安装的版本，所以一个包可以在不影响消费代码的情况下更新多次。开发者可以精确选择何时付出努力来更新他们的代码，以适应包较新版本的更改。
- en: Another point at which you can decouple code is *namespacing*. Namespaces attach
    values and behavior to human-readable names. When you install a package, you make
    it available at the namespace it specifies. As an example, the `requests` package
    is available in the `requests` namespace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在另一个地方解耦代码，那就是*命名空间*。命名空间将值和行为附加到可读性强的名称上。当你安装一个包时，你使它在指定的命名空间中可用。例如，`requests`包在`requests`命名空间中可用。
- en: 'Different packages can have the same namespace. This means they could conflict
    if you install more than one of them, but it also makes something interesting
    possible: this flexibility in namespaces means packages can act as full alternatives
    to one another. If a developer creates an alternative to a popular package that’s
    faster, safer, or more maintainable, you can install it in place of the original
    as long as the API is the same. As an example, the following packages all provide
    roughly equivalent MySQL ([https://www.mysql.com](https://www.mysql.com)) client
    functionality (specifically, they implement some level of compatibility with PEP
    249; [https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的包可以拥有相同的命名空间。这意味着如果你安装了多个包，它们可能会发生冲突，但这也使得可能发生一些有趣的事情：这种命名空间的灵活性意味着包可以作为彼此的完全替代品。如果一个开发者创建了一个比流行的包更快、更安全或更易于维护的替代品，只要API相同，你就可以将其安装到原始包的位置。以下包都提供了大致相当的MySQL
    ([https://www.mysql.com](https://www.mysql.com))客户端功能（具体来说，它们实现了某些级别的与PEP 249的兼容性；[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/))）：
- en: mysqlclient ([https://github.com/PyMySQL/mysqlclient](https://github.com/PyMySQL/mysqlclient))
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mysqlclient ([https://github.com/PyMySQL/mysqlclient](https://github.com/PyMySQL/mysqlclient))
- en: PyMySQL ([https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL))
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyMySQL ([https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL))
- en: mysql-python ([https://github.com/arnaudsj/mysql-python](https://github.com/arnaudsj/mysql-python))
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mysql-python ([https://github.com/arnaudsj/mysql-python](https://github.com/arnaudsj/mysql-python))
- en: oursql ([https://github.com/python-oursql/oursql](https://github.com/python-oursql/oursql))
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: oursql ([https://github.com/python-oursql/oursql](https://github.com/python-oursql/oursql))
- en: Finally, Python packaging can even decouple usage in Python from the language
    in which a package is written! Many Python packages are written in C and even
    Fortran for improved performance or integration with legacy systems. Package authors
    can provide precompiled versions of these packages alongside versions that can
    be built from source by the consumer if needed. This also makes packages more
    portable, decoupling developers somewhat from the details of the computer or server
    they’re using. You’ll learn more about packaging build targets in chapter 3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Python打包甚至可以将Python的使用与包所写的语言解耦！许多Python包是用C甚至Fortran编写的，以提高性能或与遗留系统集成。包作者可以提供这些包的预编译版本，同时提供消费者如果需要可以从源代码构建的版本。这也使得包更加便携，使开发者多少与他们在使用的计算机或服务器的细节解耦。你将在第3章中了解更多关于打包构建目标的内容。
- en: You might like to package some of your code to experiment with the freedom of
    version decoupling to see how your versioned packages evolve over time. Those
    that change quickly may point to low cohesion because the code has many reasons
    to change. On the other hand, it may indicate only that the code is still maturing.
    At the very least, these data points will be observable! You’ll learn more about
    versioning in chapter 9\.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想将一些代码打包起来，以实验版本解耦的自由，看看你的版本化包是如何随时间演变的。那些变化快的可能表明低内聚性，因为代码有很多理由需要改变。另一方面，这也可能仅仅意味着代码仍在成熟。至少，这些数据点将是可观察的！你将在第9章中了解更多关于版本化的内容。
- en: 1.2.4 Filling roles by composing small packages
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 通过组合小型包来填补角色
- en: 'The act of extracting code into multiple packages is a bit like *decomposition*.
    Successful decomposition requires a good handle on loose coupling. Decomposing
    code is an art that separates pieces of code so they can be recombined in new
    ways (for a wonderfully concise rundown of decomposition and coupling, see Josh
    Justice, “Breaking Up Is Hard to Do: How to Decompose Your Code,” *Big Nerd Ranch*,
    [http://mng.bz/5mpq](http://mng.bz/5mpq)).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '将代码提取到多个包中的行为有点像*分解*。成功的分解需要很好地掌握松散耦合。分解代码是一种艺术，它将代码片段分离出来，以便以新的方式重新组合（关于分解和耦合的精彩简洁概述，请参阅Josh
    Justice的“Breaking Up Is Hard to Do: How to Decompose Your Code”，*Big Nerd Ranch*，[http://mng.bz/5mpq](http://mng.bz/5mpq))。'
- en: By packaging smaller areas of your code, you’ll start to identify code that
    accomplishes a very specific goal that can be generalized or broadened to fulfill
    a role. As an example, you can create one-off HTTP requests using a built-in Python
    utility like `urllib.request.urlopen`. Once you’ve done this a few times, you
    can see commonalities between the use cases and generalize the concept into a
    higher-level utility. So the `requests` package isn’t built to make just one specific
    HTTP request; it fills a general role as an HTTP client. Some of your code may
    be very specific now, but as you find new areas where you need similar behavior,
    you may see an opportunity to identify the role it fills, generalize a bit, and
    create a package that can fill that role.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打包代码的较小区域，你将开始识别那些完成非常具体目标且可以概括或扩展以履行角色的代码。例如，你可以使用内置的Python实用工具如`urllib.request.urlopen`创建一次性的HTTP请求。一旦你这样做了几次，你就可以看到用例之间的共性，并将概念概括为更高层次的实用工具。所以`requests`包并不是为了只做一次特定的HTTP请求；它作为一个HTTP客户端填补了一个通用角色。你的一些代码现在可能非常具体，但随着你在需要类似行为的新领域中发现，你可能会看到识别它所填补的角色、进行一些概括并创建一个可以填补该角色的包的机会。
- en: As you work on revamping your software for CarCorp, you remember that a major
    portion of the code deals with the car’s navigation systems. You realize that
    with a bit of tweaking, the navigation code will also work for Acme Auto’s vehicles.
    This code could fill the role of communicating with vehicle navigation systems.
    Because you’ve learned that packages can depend on other packages, and because
    your navigation system code is already fairly cohesive, you commit yourself to
    creating not one but two packages before your next CarCorp meeting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为CarCorp重整软件时，你记得代码的大部分部分都处理汽车的导航系统。你意识到，通过一点调整，导航代码也可以适用于Acme Auto的车辆。这段代码可以充当与车辆导航系统通信的角色。因为你已经了解到包可以依赖于其他包，而且你的导航系统代码已经相当内聚，你决定在下次CarCorp会议之前创建两个包，而不是一个。
- en: A composition success story
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组合成功的故事
- en: You can see great examples of composition at play in packaging through Python
    frameworks like Django ([https://www.djangoproject.com](https://www.djangoproject.com)).
    Django is itself a package, and because it’s built as a plugin-based architecture,
    you can extend its functionality by installing and configuring additional packages.
    Peruse the hundreds of packages listed on Django Packages ([https://djangopackages.org](https://djangopackages.org))
    to see the kind of wide adoption the packaging approach enjoys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过像 Django 这样的 Python 框架看到在打包中发挥作用的优秀组合示例（[https://www.djangoproject.com](https://www.djangoproject.com)）。Django
    本身就是一个包，因为它构建为一个基于插件的架构，你可以通过安装和配置额外的包来扩展其功能。浏览 Django 包（[https://djangopackages.org](https://djangopackages.org)）上列出的数百个包，以了解打包方法所享有的广泛采用。
- en: Thinking about composition and decomposition highlights the fact that distribution
    packages can exist at any size, just as functions, classes, modules, and import
    packages do. Look to cohesion and decoupling as guiding lights to strike the right
    balance. One hundred distribution packages that each provide a single function
    would be a maintenance burden, and one distribution package that provides one
    hundred import packages would be about the same as having no package at all. If
    all else fails, always ask yourself, “What role do I want this code to fill?”
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到组合和分解，我们可以看到，分发包可以存在于任何大小，就像函数、类、模块和导入包一样。将内聚性和解耦性视为指导灯，以找到正确的平衡点。如果有一百个分发包，每个都提供单一功能，那么维护负担将会很重；而一个提供一百个导入包的分发包，几乎等同于没有包。如果所有其他方法都失败了，始终问问自己，“我想要这段代码扮演什么角色？”
- en: Now that you’ve learned that packaging can help you write cohesive, loosely
    coupled code with clear ownership that you can deliver to consumers in an accessible
    way, I hope you’re rolling up your sleeves to dive into the details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解到，打包可以帮助你编写具有内聚性、松散耦合且清晰所有权的代码，并以可访问的方式交付给消费者，我希望你正在卷起袖子深入细节。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Packages archive software files and metadata about the software, such as the
    name, creator, license, and version.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包存档软件文件以及关于软件的元数据，例如名称、创建者、许可证和版本。
- en: Package managers automate installing packages and managing the interdependencies
    between them.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包管理器自动化安装包以及管理它们之间的相互依赖关系。
- en: The packaging process has a number of pitfalls that can be overcome with tools
    and a repeatable process.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包过程有一些陷阱，可以通过工具和可重复的过程来克服。
- en: Software repositories host published packages for others to install.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件仓库托管发布的包，供他人安装。
- en: Packaging is a great way to separate and encapsulate code with high cohesion.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包是分离和封装具有高内聚性代码的绝佳方式。
- en: Packaging can be used as a decoupling tool to gain flexibility in developing
    and maintaining code.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包可以用作解耦工具，以在开发和维护代码中获得灵活性。
- en: Versioned packages are a great way to reduce churn across the code base for
    each individual update.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本化的包是减少每个单独更新在代码库中产生混乱的绝佳方式。
