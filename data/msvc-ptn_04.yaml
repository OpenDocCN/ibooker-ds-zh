- en: Chapter 5\. Designing business logic in a microservice architecture
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章：在微服务架构中设计业务逻辑
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: 'Applying the business logic organization patterns: Transaction script pattern
    and Domain model pattern'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用业务逻辑组织模式：事务脚本模式和领域模型模式
- en: Designing business logic with the Domain-driven design (DDD) aggregate pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用领域驱动设计（DDD）聚合模式设计业务逻辑
- en: Applying the Domain event pattern in a microservice architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微服务架构中应用领域事件模式
- en: The heart of an enterprise application is the business logic, which implements
    the business rules. Developing complex business logic is always challenging. The
    FTGO application’s business logic implements some quite complex business logic,
    especially for order management and delivery management. Mary had encouraged her
    team to apply object-oriented design principles, because in her experience this
    was the best way to implement complex business logic. Some of the business logic
    used the procedural Transcription script pattern. But the majority of the FTGO
    application’s business logic is implemented in an object-oriented domain model
    that’s mapped to the database using JPA.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用的核心是业务逻辑，它实现了业务规则。开发复杂的业务逻辑始终具有挑战性。FTGO应用的业务逻辑实现了一些相当复杂的业务逻辑，尤其是在订单管理和配送管理方面。玛丽鼓励她的团队应用面向对象设计原则，因为在她看来，这是实现复杂业务逻辑的最佳方式。一些业务逻辑使用了程序性的事务脚本模式。但FTGO应用的大多数业务逻辑都是在一个面向对象的领域模型中实现的，该模型使用JPA映射到数据库。
- en: Developing complex business logic is even more challenging in a microservice
    architecture where the business logic is spread over multiple services. You need
    to address two key challenges. First, a typical domain model is a tangled web
    of interconnected classes. Although this isn’t a problem in a monolithic application,
    in a microservice architecture, where classes are scattered around different services,
    you need to eliminate object references that would otherwise span service boundaries.
    The second challenge is designing business logic that works within the transaction
    management constraints of a microservice architecture. Your business logic can
    use ACID transactions within services, but as described in [chapter 4](kindle_split_012.xhtml#ch04),
    it must use the Saga pattern to maintain data consistency across services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务逻辑分散在多个服务中的微服务架构中，开发复杂的业务逻辑更具挑战性。你需要解决两个关键挑战。首先，典型的领域模型是一个相互连接的类错综复杂的网络。尽管在单体应用中这不是问题，但在类分散在不同服务中的微服务架构中，你需要消除跨越服务边界的对象引用。第二个挑战是在微服务架构的事务管理约束内设计业务逻辑。你的业务逻辑可以在服务内使用ACID事务，但如第4章所述，它必须使用
    Saga 模式来维护服务间数据的一致性。
- en: 'Fortunately, we can address these issues by using the Aggregate pattern from
    DDD. The Aggregate pattern structures a service’s business logic as a collection
    of aggregates. An *aggregate* is a cluster of objects that can be treated as a
    unit. There are two reasons why aggregates are useful when developing business
    logic in a microservice architecture:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用DDD中的聚合模式来解决这些问题。聚合模式将服务业务逻辑结构化为一系列聚合。一个*聚合*是一组可以作为一个单元处理的对象。在微服务架构中开发业务逻辑时，聚合之所以有用，有两个原因：
- en: Aggregates avoid any possibility of object references spanning service boundaries,
    because an inter-aggregate reference is a primary key value rather than an object
    reference.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合避免任何跨越服务边界的对象引用的可能性，因为聚合间的引用是一个主键值而不是对象引用。
- en: Because a transaction can only create or update a single aggregate, aggregates
    fit the constraints of the microservices transaction model.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为一个事务只能创建或更新一个聚合，所以聚合符合微服务事务模型的约束。
- en: As a result, an ACID transaction is guaranteed to be within a single service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ACID事务保证在单个服务内完成。
- en: 'I begin this chapter by describing the different ways of organizing business
    logic: the Transcription script pattern and the Domain model pattern. Next I introduce
    the concept of a DDD aggregate and explain why it’s a good building block for
    a service’s business logic. After that, I describe the Domain event pattern events
    and explain why it’s useful for a service to publish events. I end this chapter
    with a couple of examples of business logic from `Kitchen Service` and `Order
    Service`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我以描述组织业务逻辑的不同方式开始本章：转录脚本模式和领域模型模式。接下来，我介绍 DDD 聚合的概念，并解释为什么它是服务业务逻辑的良好构建块。之后，我描述领域事件模式事件，并解释为什么对服务发布事件是有用的。我以
    `Kitchen Service` 和 `Order Service` 的几个业务逻辑示例结束本章。
- en: Let’s now look at business logic organization patterns.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看业务逻辑组织模式。
- en: 5.1\. Business logic organization patterns
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 业务逻辑组织模式
- en: '[Figure 5.1](#ch05fig01) shows the architecture of a typical service. As described
    in [chapter 2](kindle_split_010.xhtml#ch02), the business logic is the core of
    a hexagonal architecture. Surrounding the business logic are the inbound and outbound
    adapters. An *inbound adapter* handles requests from clients and invokes the business
    logic. An *outbound adapter*, which is invoked by the business logic, invokes
    other services and applications.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.1](#ch05fig01) 展示了一个典型服务的架构。正如 [第 2 章](kindle_split_010.xhtml#ch02) 所描述的，业务逻辑是六边形架构的核心。围绕业务逻辑的是输入和输出适配器。一个
    *输入适配器* 处理来自客户端的请求并调用业务逻辑。一个 *输出适配器*，由业务逻辑调用，调用其他服务和应用程序。'
- en: Figure 5.1\. The `Order Service` has a hexagonal architecture. It consists of
    the business logic and one or more adapters that interface with external applications
    and other services.
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. `Order Service` 具有六边形架构。它由业务逻辑和一个或多个适配器组成，这些适配器与外部应用程序和其他服务进行接口。
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: 'This service consists of the business logic and the following adapters:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务由业务逻辑和以下适配器组成：
- en: '**`REST API adapter`—** An inbound adapter that implements a REST API which
    invokes the business logic'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`REST API 适配器`—** 一个实现 REST API 的输入适配器，它调用业务逻辑'
- en: '**`OrderCommandHandlers`—** An inbound adapter that consumes command messages
    from a message channel and invokes the business logic'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`OrderCommandHandlers`—** 一个从消息通道消费命令消息并调用业务逻辑的输入适配器'
- en: '**`Database Adapter`—** An outbound adapter that’s invoked by the business
    logic to access the database'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Database Adapter`—** 一个由业务逻辑调用以访问数据库的输出适配器'
- en: '**`Domain Event Publishing Adapter`—** An outbound adapter that publishes events
    to a message broker'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`领域事件发布适配器`—** 一个将事件发布到消息代理的输出适配器'
- en: 'The business logic is typically the most complex part of the service. When
    developing business logic, you should consciously organize your business logic
    in the way that’s most appropriate for your application. After all, I’m sure you’ve
    experienced the frustration of having to maintain someone else’s badly structured
    code. Most enterprise applications are written in an object-oriented language
    such as Java, so they consist of classes and methods. But using an object-oriented
    language doesn’t guarantee that the business logic has an object-oriented design.
    The key decision you must make when developing business logic is whether to use
    an object-oriented approach or a procedural approach. There are two main patterns
    for organizing business logic: the procedural Transaction script pattern, and
    the object-oriented Domain model pattern.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑通常是服务中最复杂的一部分。在开发业务逻辑时，你应该有意识地以最适合你应用程序的方式组织你的业务逻辑。毕竟，我相信你一定经历过维护他人糟糕结构化代码的挫败感。大多数企业应用程序是用面向对象的语言（如
    Java）编写的，因此它们由类和方法组成。但是，使用面向对象的语言并不能保证业务逻辑具有面向对象的设计。在开发业务逻辑时，你必须做出的关键决策是使用面向对象的方法还是过程式方法。组织业务逻辑有两种主要模式：过程式的交易脚本模式和面向对象的领域模型模式。
- en: 5.1.1\. Designing business logic using the Transaction script pattern
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 使用交易脚本模式设计业务逻辑
- en: Although I’m a strong advocate of the object-oriented approach, there are some
    situations where it is overkill, such as when you are developing simple business
    logic. In such a situation, a better approach is to write procedural code and
    use what the book *Patterns of Enterprise Application Architecture* by Martin
    Fowler (Addison-Wesley Professional, 2002) calls the Transaction script pattern.
    Rather than doing any object-oriented design, you write a method called a *transaction
    script* to handle each request from the presentation tier. As [figure 5.2](#ch05fig02)
    shows, an important characteristic of this approach is that the classes that implement
    behavior are separate from those that store state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我是面向对象方法的强烈支持者，但在某些情况下，它可能过于复杂，例如当你正在开发简单的业务逻辑时。在这种情况下，更好的方法是编写过程性代码，并使用马丁·福勒（Martin
    Fowler）在其著作《企业应用架构模式》（Patterns of Enterprise Application Architecture）中称为“事务脚本模式”的方法。而不是进行任何面向对象设计，你编写一个名为“事务脚本”的方法来处理来自表示层的每个请求。如图5.2所示，这种方法的一个重要特征是实现行为的类与存储状态的类是分开的。
- en: Figure 5.2\. Organizing business logic as transaction scripts. In a typical
    transaction script–based design, one set of classes implements behavior and another
    set stores state. The transaction scripts are organized into classes that typically
    have no state. The scripts use data classes, which typically have no behavior.
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 将业务逻辑组织成事务脚本。在典型的基于事务脚本的设计中，一组类实现行为，另一组类存储状态。事务脚本组织成通常没有状态的类。脚本使用数据类，这些数据类通常没有行为。
- en: '![](Images/05fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02.jpg)'
- en: When using the Transaction script pattern, the scripts are usually located in
    service classes, which in this example is the `OrderService` class. A service
    class has one method for each request/system operation. The method implements
    the business logic for that request. It accesses the database using data access
    objects (DAOs), such as the `OrderDao`. The data objects, which in this example
    is the `Order` class, are pure data with little or no behavior.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用事务脚本模式时，脚本通常位于服务类中，在这个例子中是`OrderService`类。服务类为每个请求/系统操作有一个方法。该方法实现该请求的业务逻辑。它使用数据访问对象（DAOs），如`OrderDao`，访问数据库。数据对象，在这个例子中是`Order`类，是纯数据，几乎没有行为。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Transaction script**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：事务脚本**'
- en: Organize the business logic as a collection of procedural transaction scripts,
    one for each type of request.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务逻辑组织成一系列过程性事务脚本，每个脚本对应一种请求类型。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This style of design is highly procedural and relies on few of the capabilities
    of object-oriented programming (OOP) languages. This what you would create if
    you were writing the application in C or another non-OOP language. Nevertheless,
    you shouldn’t be ashamed to use a procedural design when it’s appropriate. This
    approach works well for simple business logic. The drawback is that this tends
    not to be a good way to implement complex business logic.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计风格高度过程化，并且很少依赖面向对象编程（OOP）语言的能力。如果你用C或另一种非面向对象语言编写应用程序，你会创建这样的应用程序。尽管如此，当适用时，使用过程性设计并不应该感到羞耻。这种方法对于简单的业务逻辑效果很好。缺点是这通常不是实现复杂业务逻辑的好方法。
- en: 5.1.2\. Designing business logic using the Domain model pattern
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 使用领域模型模式设计业务逻辑
- en: The simplicity of the procedural approach can be quite seductive. You can write
    code without having to carefully consider how to organize the classes. The problem
    is that if your business logic becomes complex, you can end up with code that’s
    a nightmare to maintain. In fact, in the same way that a monolithic application
    has a habit of continually growing, transaction scripts have the same problem.
    Consequently, unless you’re writing an extremely simple application, you should
    resist the temptation to write procedural code and instead apply the Domain model
    pattern and develop an object-oriented design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 过程性方法的简单性可能相当诱人。你可以编写代码而无需仔细考虑如何组织类。问题是如果业务逻辑变得复杂，你可能会得到难以维护的代码。事实上，就像单体应用程序有不断增长的习性一样，事务脚本也有同样的问题。因此，除非你正在编写极其简单的应用程序，否则你应该抵制编写过程性代码的诱惑，而是应用领域模型模式并开发面向对象的设计。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Domain model**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：领域模型**'
- en: Organize the business logic as an object model consisting of classes that have
    state and behavior.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务逻辑组织成一个由具有状态和行为的类组成的对象模型。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In an object-oriented design, the business logic consists of an object model,
    a network of relatively small classes. These classes typically correspond directly
    to concepts from the problem domain. In such a design some classes have only either
    state or behavior, but many contain both, which is the hallmark of a well-designed
    class. [Figure 5.3](#ch05fig03) shows an example of the Domain model pattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的设计中，业务逻辑由一个对象模型和相对较小类的网络组成。这些类通常直接对应于问题域中的概念。在这种设计中，一些类可能只有状态或行为，但许多类同时包含两者，这是设计良好的类的标志。[图5.3](#ch05fig03)展示了领域模型模式的一个示例。
- en: Figure 5.3\. Organizing business logic as a domain model. The majority of the
    business logic consists of classes that have state and behavior.
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 将业务逻辑组织为领域模型。大部分业务逻辑由具有状态和行为的类组成。
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: As with the Transaction script pattern, an `OrderService` class has a method
    for each request/system operation. But when using the Domain model pattern, the
    service methods are usually simple. That’s because a service method almost always
    delegates to persistent domain objects, which contain the bulk of the business
    logic. A service method might, for example, load a domain object from the database
    and invoke one of its methods. In this example, the `Order` class has both state
    and behavior. Moreover, its state is private and can only be accessed indirectly
    via its methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与事务脚本模式一样，`OrderService`类为每个请求/系统操作都有一个方法。但是，当使用领域模型模式时，服务方法通常是简单的。这是因为服务方法几乎总是委托给持久化的领域对象，这些对象包含大部分业务逻辑。例如，一个服务方法可能会从数据库中加载一个领域对象并调用其方法之一。在这个例子中，`Order`类既有状态又有行为。此外，其状态是私有的，只能通过其方法间接访问。
- en: 'Using an object-oriented design has a number of benefits. First, the design
    is easy to understand and maintain. Instead of consisting of one big class that
    does everything, it consists of a number of small classes that each have a small
    number of responsibilities. In addition, classes such as `Account`, `BankingTransaction`,
    and `OverdraftPolicy` closely mirror the real world, which makes their role in
    the design easier to understand. Second, our object-oriented design is easier
    to test: each class can and should be tested independently. Finally, an object-oriented
    design is easier to extend because it can use well-known design patterns, such
    as the Strategy pattern and the Template method pattern, that define ways of extending
    a component without modifying the code.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向对象的设计有许多好处。首先，这种设计易于理解和维护。它不是由一个承担所有功能的庞大类组成，而是由许多具有少量职责的小类组成。此外，如`Account`、`BankingTransaction`和`OverdraftPolicy`之类的类紧密地反映了现实世界，这使得它们在设计中的角色更容易理解。其次，我们的面向对象设计更容易测试：每个类都可以并且应该独立测试。最后，面向对象的设计更容易扩展，因为它可以使用诸如策略模式（Strategy
    pattern）和模板方法模式（Template method pattern）之类的知名设计模式，这些模式定义了在不修改代码的情况下扩展组件的方法。
- en: The Domain model pattern works well, but there are a number of problems with
    this approach, especially in a microservice architecture. To address those problems,
    you need to use a refinement of OOD known as DDD.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型模式效果良好，但这种方法存在一些问题，尤其是在微服务架构中。为了解决这些问题，你需要使用一种称为领域驱动设计（DDD）的面向对象设计的细化。
- en: 5.1.3\. About Domain-driven design
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 关于领域驱动设计
- en: DDD, which is described in the book *Domain-Driven Design* by Eric Evans (Addison-Wesley
    Professional, 2003), is a refinement of OOD and is an approach for developing
    complex business logic. I introduced DDD in [chapter 2](kindle_split_010.xhtml#ch02)
    when discussing the usefulness of DDD subdomains when decomposing an application
    into services. When using DDD, each service has its own domain model, which avoids
    the problems of a single, application-wide domain model. Subdomains and the associated
    concept of Bounded Context are two of the strategic DDD patterns.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD），由埃里克·埃文斯（Eric Evans）在其著作《领域驱动设计》（Domain-Driven Design）中描述，是面向对象设计的细化，并且是开发复杂业务逻辑的方法。我在[第2章](kindle_split_010.xhtml#ch02)中介绍了DDD，当时讨论了在将应用程序分解为服务时DDD子域的有用性。当使用DDD时，每个服务都有自己的领域模型，这避免了单一、应用范围领域模型的问题。子域和相关概念边界上下文（Bounded
    Context）是DDD的战略模式之二。
- en: 'DDD also has some tactical patterns that are building blocks for domain models.
    Each pattern is a role that a class plays in a domain model and defines the characteristics
    of the class. The building blocks that have been widely adopted by developers
    include the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 还有一些战术模式，它们是领域模型的构建块。每个模式都是一个类在领域模型中扮演的角色，并定义了类的特征。被开发者广泛采用的构建块包括以下内容：
- en: '***Entity*—** An object that has a persistent identity. Two entities whose
    attributes have the same values are still different objects. In a Java EE application,
    classes that are persisted using JPA `@Entity` are usually DDD entities.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***实体*—** 具有持久身份的对象。具有相同属性的两个实体仍然是不同的对象。在 Java EE 应用程序中，使用 JPA `@Entity` 持久化的类通常是
    DDD 实体。'
- en: '***Value object*—** An object that is a collection of values. Two value objects
    whose attributes have the same values can be used interchangeably. An example
    of a value object is a `Money` class, which consists of a currency and an amount.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***值对象*—** 由值组成的对象。具有相同属性的两个值对象可以互换使用。一个值对象的例子是 `Money` 类，它由货币和金额组成。'
- en: '***Factory*—** An object or method that implements object creation logic that’s
    too complex to be done directly by a constructor. It can also hide the concrete
    classes that are instantiated. A factory might be implemented as a static method
    of a class.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工厂*—** 实现对象创建逻辑的对象或方法，这些逻辑过于复杂，不能直接通过构造函数完成。它还可以隐藏实例化的具体类。工厂可以作为一个类的静态方法实现。'
- en: '***Repository*—** An object that provides access to persistent entities and
    encapsulates the mechanism for accessing the database.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***仓储*—** 提供对持久化实体访问的对象，并封装了访问数据库的机制。'
- en: '***Service*—** An object that implements business logic that doesn’t belong
    in an entity or a value object.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务*—** 实现不属于实体或值对象的业务逻辑的对象。'
- en: 'These building blocks are used by many developers. Some are supported by frameworks
    such as JPA and the Spring framework. There is one more building block that has
    been generally ignored (myself included!) except by DDD purists: aggregates. As
    it turns out, aggregates are an extremely useful concept when developing microservices.
    Let’s first look at some subtle problems with classic OOD that are solved by using
    aggregates.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建块被许多开发者使用。其中一些由 JPA 和 Spring 框架等框架支持。还有一个构建块通常被忽视（包括我自己！），除了 DDD 纯粹主义者之外：聚合。实际上，聚合在开发微服务时是一个极其有用的概念。让我们首先看看经典
    OOD 中的一些微妙问题，这些问题可以通过使用聚合来解决。
- en: 5.2\. Designing a domain model using the DDD aggregate pattern
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. 使用 DDD 聚合模式设计领域模型
- en: In traditional object-oriented design, a domain model is a collection of classes
    and relationships between classes. The classes are usually organized into packages.
    For example, [figure 5.4](#ch05fig04) shows part of a domain model for the FTGO
    application. It’s a typical domain model consisting of a web of interconnected
    classes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象设计中，领域模型是一组类及其之间的关系。这些类通常被组织成包。例如，[图5.4](#ch05fig04) 展示了 FTGO 应用程序领域模型的一部分。它是一个典型的领域模型，由相互连接的类网组成。
- en: Figure 5.4\. A traditional domain model is a web of interconnected classes.
    It doesn’t explicitly specify the boundaries of business objects, such as `Consumer`
    and `Order`.
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4. 传统的领域模型是一个相互连接的类网。它没有明确指定业务对象（如 `Consumer` 和 `Order`）的边界。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig04_alt.jpg)'
- en: 'This example has several classes corresponding to business objects: `Consumer`,
    `Order`, `Restaurant`, and `Courier`. But interestingly, the explicit boundaries
    of each business object are missing from this kind of traditional domain model.
    It doesn’t specify, for example, which classes are part of the `Order` business
    object. This lack of boundaries can sometimes cause problems, especially in microservice
    architecture.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有几个与业务对象对应的类：`Consumer`、`Order`、`Restaurant` 和 `Courier`。但有趣的是，这种传统领域模型中缺少每个业务对象的明确边界。例如，它没有指定哪些类是
    `Order` 业务对象的一部分。这种边界缺失有时会导致问题，尤其是在微服务架构中。
- en: I begin this section with an example problem caused by the lack of explicit
    boundaries. Next I describe the concept of an aggregate and how it has explicit
    boundaries. After that, I describe the rules that aggregates must obey and how
    they make aggregates a good fit for the microservice architecture. I then describe
    how to carefully choose the boundaries of your aggregates and why it matters.
    Finally, I discuss how to design business logic using aggregates. Let’s first
    take a look at the problems caused by fuzzy boundaries.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我以一个由于缺乏明确边界而引起的问题为例开始本节。接下来，我描述了聚合的概念以及它具有明确的边界。然后，我描述了聚合必须遵守的规则以及它们如何使聚合适合微服务架构。然后，我描述了如何仔细选择聚合的边界以及为什么这很重要。最后，我讨论了如何使用聚合设计业务逻辑。让我们首先看看模糊边界引起的问题。
- en: 5.2.1\. The problem with fuzzy boundaries
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 模糊边界的弊端
- en: Imagine, for example, that you want to perform an operation, such as a load
    or delete, on an `Order` business object. What exactly does that mean? What is
    the scope an operation? You would certainly load or delete the `Order` object.
    But in reality there’s more to an `Order` than simply the `Order` object. There
    are also the order line items, the payment information, and so on. [Figure 5.4](#ch05fig04)
    leaves the boundaries of a domain object to the developer’s intuition.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想对一个`Order`业务对象执行一个操作，比如加载或删除。这究竟意味着什么？操作的范畴是什么？你当然会加载或删除`Order`对象。但在现实中，`Order`不仅仅是`Order`对象。还包括订单行项目、支付信息等等。[图5.4](#ch05fig04)将领域对象的边界留给了开发者的直觉。
- en: Besides a conceptual fuzziness, the lack of explicit boundaries causes problems
    when updating a business object. A typical business object has *invariants*, business
    rules that must be enforced at all times. An `Order` has a minimum order amount,
    for example. The FTGO application must ensure that any attempt to update an order
    doesn’t violate an invariant such as the minimum order amount. The challenge is
    that in order to enforce invariants, you must design your business logic carefully.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概念上的模糊性之外，缺乏明确的边界在更新业务对象时也会引起问题。一个典型的业务对象有*不变性*，这是必须始终强制执行的商务规则。例如，`Order`有一个最小订单金额。FTGO应用程序必须确保任何尝试更新订单的行为都不会违反不变性，例如最小订单金额。挑战在于，为了强制执行不变性，你必须仔细设计你的业务逻辑。
- en: For example, let’s look at how to ensure the order minimum is met when multiple
    consumers work together to create an order. Two consumers—Sam and Mary—are working
    together on an order and simultaneously decide that the order exceeds their budget.
    Sam reduces the quantity of samosas, and Mary reduces the quantity of naan bread.
    From the application’s perspective, both consumers retrieve the order and its
    line items from the database. Both consumers then update a line item to reduce
    the cost of the order. From each consumer’s perspective the order minimum is preserved.
    Here’s the sequence of database transactions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看当多个消费者共同创建一个订单时，如何确保满足订单的最小金额。两个消费者——山姆和玛丽——正在共同处理一个订单，并且同时决定订单超出了他们的预算。山姆减少了萨莫萨饼的数量，玛丽减少了印度烤饼的数量。从应用程序的角度来看，两个消费者都从数据库中检索订单及其行项目。然后，两个消费者更新一个行项目以降低订单的成本。从每个消费者的角度来看，订单的最小金额得到了保留。以下是数据库事务的顺序。
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '|   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Each consumer changes a line item using a sequence of two transactions. The
    first transaction loads the order and its line items. The UI verifies that the
    order minimum is satisfied before executing the second transaction. The second
    transaction updates the line item quantity using an optimistic offline locking
    check that verifies that the order line is unchanged since it was loaded by the
    first transaction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消费者使用一系列两个事务来更改一个行项目。第一个事务加载订单及其行项目。UI在执行第二个事务之前验证订单最小金额是否得到满足。第二个事务使用乐观离线锁定检查更新行项目数量，该检查验证订单行自第一个事务加载以来未发生变化。
- en: In this scenario, Sam reduces the order total by $X and Mary reduces it by $Y.
    As a result, the `Order` is no longer valid, even though the application verified
    that the order still satisfied the order minimum after each consumer’s update.
    As you can see, directly updating part of a business object can result in the
    violation of the business rules. DDD aggregates are intended to solve this problem.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，山姆减少了订单总额X美元，玛丽减少了Y美元。结果，`Order`不再有效，尽管应用程序在每次消费者更新后都验证了订单仍然满足订单最小金额。正如你所看到的，直接更新业务对象的一部分可能导致违反业务规则。DDD聚合旨在解决这个问题。
- en: 5.2.2\. Aggregates have explicit boundaries
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 聚合具有明确的边界
- en: An *aggregate* is a cluster of domain objects within a boundary that can be
    treated as a unit. It consists of a root entity and possibly one or more other
    entities and value objects. Many business objects are modeled as aggregates. For
    example, in [chapter 2](kindle_split_010.xhtml#ch02) we created a rough domain
    model by analyzing the nouns used in the requirements and by domain experts. Many
    of these nouns, such as `Order`, `Consumer`, and `Restaurant`, are aggregates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *聚合* 是一个边界内的领域对象簇，可以作为一个单元处理。它由一个根实体以及可能的一个或多个其他实体和值对象组成。许多业务对象被建模为聚合。例如，在[第
    2 章](kindle_split_010.xhtml#ch02)中，我们通过分析需求中使用的名词以及领域专家的分析创建了一个粗略的领域模型。其中许多名词，如`Order`、`Consumer`和`Restaurant`，都是聚合。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Aggregate**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：聚合**'
- en: Organize a domain model as a collection of aggregates, each of which is a graph
    of objects that can be treated as a unit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将领域模型组织为聚合的集合，每个聚合都是一个可以作为一个单元处理的对象图。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 5.5](#ch05fig05) shows the `Order` aggregate and its boundary. An `Order`
    aggregate consists of an `Order` entity, one or more `OrderLineItem` value objects,
    and other value objects such as a delivery `Address` and `PaymentInformation`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.5](#ch05fig05) 展示了`Order`聚合及其边界。一个`Order`聚合由一个`Order`实体、一个或多个`OrderLineItem`值对象以及其他值对象（如交付地址和支付信息）组成。'
- en: Figure 5.5\. Structuring a domain model as a set of aggregates makes the boundaries
    explicit.
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 将领域模型结构化为聚合集合使边界明确。
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: Aggregates decompose a domain model into chunks, which are individually easier
    to understand. They also clarify the scope of operations such as load, update,
    and delete. These operations act on the entire aggregate rather than on parts
    of it. An aggregate is often loaded in its entirety from the database, thereby
    avoiding any complications of lazy loading. Deleting an aggregate removes all
    of its objects from a database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合将领域模型分解成块，这些块单独更容易理解。它们还澄清了诸如加载、更新和删除等操作的范围。这些操作作用于整个聚合，而不是其部分。聚合通常从数据库中完全加载，从而避免了懒加载的任何复杂性。删除聚合会从数据库中删除其所有对象。
- en: Aggregates are consistency boundaries
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合是一致性边界
- en: Updating an entire aggregate rather than its parts solves the consistency issues,
    such as the example described earlier. Update operations are invoked on the aggregate
    root, which enforces invariants. Also, concurrency is handled by locking the aggregate
    root using, for example, a version number or a database-level lock. For example,
    instead of updating line items’ quantities directly, a client must invoke a method
    on the root of the `Order` aggregate, which enforces invariants such as the minimum
    order amount. Note, though, that this approach doesn’t require the entire aggregate
    to be updated in the database. An application might, for example, only update
    the rows corresponding to the `Order` object and the updated `OrderLineItem`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 更新整个聚合而不是其部分可以解决一致性问题，例如前面描述的例子。更新操作是在聚合根上触发的，这强制执行不变性。此外，并发通过使用版本号或数据库级别的锁等方式锁定聚合根来处理。例如，而不是直接更新行项的数量，客户端必须调用`Order`聚合根上的一个方法，该方法强制执行如最小订单金额这样的不变性。然而，请注意，这种方法不需要在数据库中更新整个聚合。例如，应用程序可能只更新与`Order`对象和更新的`OrderLineItem`对应的行。
- en: Identifying aggregates is key
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 识别聚合是关键
- en: In DDD, a key part of designing a domain model is identifying aggregates, their
    boundaries, and their roots. The details of the aggregates’ internal structure
    is secondary. The benefit of aggregates, however, goes far beyond modularizing
    a domain model. That’s because aggregates must obey certain rules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DDD 中，设计领域模型的关键部分是识别聚合、它们的边界和它们的根。聚合内部结构的细节是次要的。然而，聚合的好处远远超出了模块化领域模型。这是因为聚合必须遵守某些规则。
- en: 5.2.3\. Aggregate rules
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3\. 聚合规则
- en: DDD requires aggregates to obey a set of rules. These rules ensure that an aggregate
    is a self-contained unit that can enforce its invariants. Let’s look at each of
    the rules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DDD要求聚合遵守一组规则。这些规则确保聚合是一个自包含的单元，可以强制执行其不变性。让我们看看每条规则。
- en: 'Rule #1: Reference only the aggregate root'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '规则 #1：仅引用聚合根'
- en: The previous example illustrated the perils of updating `OrderLineItems` directly.
    The goal of the first aggregate rule is to eliminate this problem. It requires
    that the root entity be the only part of an aggregate that can be referenced by
    classes outside of the aggregate. A client can only update an aggregate by invoking
    a method on the aggregate root.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子说明了直接更新 `OrderLineItems` 的危险。第一个聚合规则的目标是消除这个问题。它要求根实体是聚合中唯一可以被聚合外部类引用的部分。客户端只能通过在聚合根上调用方法来更新聚合。
- en: A service, for example, uses a repository to load an aggregate from the database
    and obtain a reference to the aggregate root. It updates an aggregate by invoking
    a method on the aggregate root. This rule ensures that the aggregate can enforce
    its invariant.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个服务使用存储库从数据库中加载聚合并获取聚合根的引用。它通过在聚合根上调用方法来更新聚合。这个规则确保聚合可以强制执行其不变性。
- en: 'Rule #2: Inter-aggregate references must use primary keys'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规则#2：聚合之间的引用必须使用主键
- en: Another rule is that aggregates reference each other by identity (for example,
    primary key) instead of object references. For example, as [figure 5.6](#ch05fig06)
    shows, an `Order` references its `Consumer` using a `consumerId` rather than a
    reference to the `Consumer` object. Similarly, an `Order` references a `Restaurant`
    using a `restaurantId`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条规则是，聚合通过标识符（例如，主键）而不是对象引用相互引用。例如，如图5.6所示，`Order` 使用 `consumerId` 而不是 `Consumer`
    对象的引用来引用其 `Consumer`。同样，`Order` 使用 `restaurantId` 来引用 `Restaurant`。
- en: Figure 5.6\. References between aggregates are by primary key rather than by
    object reference. The `Order` aggregate has the IDs of the `Consumer` and `Restaurant`
    aggregates. Within an aggregate, objects have references to one another.
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 聚合之间的引用是通过主键而不是通过对象引用来实现的。`Order` 聚合包含 `Consumer` 和 `Restaurant` 聚合的ID。在一个聚合内部，对象之间相互引用。
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig06_alt.jpg)'
- en: This approach is quite different from traditional object modeling, which considers
    foreign keys in the domain model to be a design smell. It has a number of benefits.
    The use of identity rather than object references means that the aggregates are
    loosely coupled. It ensures that the aggregate boundaries between aggregates are
    well defined and avoids accidentally updating a different aggregate. Also, if
    an aggregate is part of another service, there isn’t a problem of object references
    that span services.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与传统对象建模有很大不同，传统对象建模认为领域模型中的外键是一个设计问题。它有许多好处。使用标识符而不是对象引用意味着聚合是松散耦合的。它确保聚合之间的边界定义良好，并避免意外更新不同的聚合。此外，如果一个聚合是另一个服务的一部分，就不会存在跨越服务的对象引用问题。
- en: This approach also simplifies persistence since the aggregate is the unit of
    storage. It makes it easier to store aggregates in a NoSQL database such as MongoDB.
    It also eliminates the need for transparent lazy loading and its associated problems.
    Scaling the database by sharding aggregates is relatively straightforward.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也简化了持久性，因为聚合是存储的单位。这使得在MongoDB等NoSQL数据库中存储聚合变得更加容易。它还消除了透明延迟加载及其相关问题的需要。通过分片聚合来扩展数据库相对简单。
- en: 'Rule #3: One transaction creates or updates one aggregate'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规则#3：一个事务创建或更新一个聚合
- en: Another rule that aggregates must obey is that a transaction can only create
    or update a single aggregate. When I first read about it many years ago, this
    rule made no sense! At the time, I was developing traditional monolithic applications
    that used an RDBMS, so transactions could update multiple aggregates. Today, this
    constraint is perfect for the microservice architecture. It ensures that a transaction
    is contained within a service. This constraint also matches the limited transaction
    model of most NoSQL databases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合必须遵守的另一条规则是，一个事务只能创建或更新单个聚合。多年前我第一次读到这条规则时，觉得它毫无意义！当时，我正在开发使用RDBMS的传统单体应用，事务可以更新多个聚合。如今，这个约束对微服务架构来说非常完美。它确保事务被包含在服务内部。这个约束也符合大多数NoSQL数据库有限的交易模型。
- en: This rule makes it more complicated to implement operations that need to create
    or update multiple aggregates. But this is exactly the problem that sagas (described
    in [chapter 4](kindle_split_012.xhtml#ch04)) are designed to solve. Each step
    of the saga creates or updates exactly one aggregate. [Figure 5.7](#ch05fig07)
    shows how this works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则使得实现需要创建或更新多个聚合的操作变得更加复杂。但这正是传奇（在第4章中描述）旨在解决的问题。传奇的每一步都恰好创建或更新一个聚合。[图5.7](#ch05fig07)显示了这是如何工作的。
- en: Figure 5.7\. A transaction can only create or update a single aggregate, so
    an application uses a saga to update multiple aggregates. Each step of the saga
    creates or updates one aggregate.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7。事务只能创建或更新单个聚合，因此应用程序使用传奇来更新多个聚合。传奇的每一步都创建或更新一个聚合。
- en: '![](Images/05fig07_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig07_alt.jpg)'
- en: In this example, the saga consists of three transactions. The first transaction
    updates aggregate `X` in service `A`. The other two transactions are both in service
    `B`. One transaction updates aggregate `X`, and the other updates aggregate `Y`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，传奇由三个事务组成。第一个事务在服务 `A` 中更新聚合 `X`。其他两个事务都在服务 `B` 中。一个事务更新聚合 `X`，另一个更新聚合
    `Y`。
- en: An alternative approach to maintaining consistency across multiple aggregates
    within a single service is to cheat and update multiple aggregates within a transaction.
    For example, service `B` could update aggregates `Y` and `Z` in a single transaction.
    This is only possible when using a database, such as an RDBMS, that supports a
    rich transaction model. If you’re using a NoSQL database that only has simple
    transactions, there’s no other option except to use sagas.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个服务内维护多个聚合的一致性的一种替代方法是采取欺骗手段，在事务中更新多个聚合。例如，服务 `B` 可以在单个事务中更新聚合 `Y` 和 `Z`。这只有在使用支持丰富事务模型的数据库，如关系数据库管理系统（RDBMS）时才可行。如果你使用的是只有简单事务的
    NoSQL 数据库，除了使用传奇（sagas）之外没有其他选择。
- en: Or is there? It turns out that aggregate boundaries are not set in stone. When
    developing a domain model, you get to choose where the boundaries lie. But like
    a 20th century colonial power drawing national boundaries, you need to be careful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者有其他选择吗？实际上，聚合边界并不是一成不变的。在开发领域模型时，你可以选择边界在哪里。但就像20世纪的殖民强国划定国家边界一样，你需要小心谨慎。
- en: 5.2.4\. Aggregate granularity
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4. 聚合粒度
- en: When developing a domain model, a key decision you must make is how large to
    make each aggregate. On one hand, aggregates should ideally be small. Because
    updates to each aggregate are serialized, more fine-grained aggregates will increase
    the number of simultaneous requests that the application can handle, improving
    scalability. It will also improve the user experience because it reduces the chance
    of two users attempting conflicting updates of the same aggregate. On the other
    hand, because an aggregate is the scope of transaction, you may need to define
    a larger aggregate in order to make a particular update atomic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发领域模型时，你必须做出的一个关键决策是每个聚合的大小。一方面，理想情况下聚合应该尽可能小。因为每个聚合的更新都是序列化的，更细粒度的聚合将增加应用程序可以处理的并发请求数量，从而提高可伸缩性。它还将改善用户体验，因为它减少了两个用户尝试对同一聚合进行冲突更新的可能性。另一方面，因为聚合是事务的范围，你可能需要定义一个更大的聚合，以便执行特定的原子更新。
- en: For example, earlier I mentioned how in the FTGO application’s domain model
    `Order` and `Consumer` are separate aggregates. An alternative design is to make
    `Order` part of the `Consumer` aggregate. [Figure 5.8](#ch05fig08) shows this
    alternative design.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我之前提到过在 FTGO 应用程序的领域模型中，“订单”和“消费者”是独立的聚合。另一种设计是将“订单”作为“消费者”聚合的一部分。图5.8显示了这种替代设计。
- en: Figure 5.8\. An alternative design defines a `Customer` aggregate that contains
    the `Customer` and `Order` classes. This design enables an application to atomically
    update a `Consumer` and one or more of its `Orders`.
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8。一种替代设计定义了一个包含“客户”类和“订单”类的“客户”聚合。这种设计使得应用程序能够原子性地更新一个“消费者”及其一个或多个“订单”。
- en: '![](Images/05fig08_alt.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig08_alt.jpg)'
- en: A benefit of this larger `Consumer` aggregate is that the application can atomically
    update a `Consumer` and one or more of its `Orders`. A drawback of this approach
    is that it reduces scalability. Transactions that update different orders for
    the same customer would be serialized. Similarly, two users would conflict if
    they attempted to edit different orders for the same customer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更大的`Consumer`聚合体的一个好处是，应用程序可以原子性地更新一个`Consumer`及其一个或多个`Orders`。这种方法的缺点是它降低了可扩展性。更新同一客户不同订单的事务将被序列化。同样，如果两个用户尝试编辑同一客户的不同的订单，他们将会发生冲突。
- en: Another drawback of this approach in a microservice architecture is that it
    is an obstacle to decomposition. The business logic for `Orders` and `Consumers`,
    for example, must be collocated in the same service, which makes the service larger.
    Because of these issues, making aggregates as fine-grained as possible is best.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，这种方法的一个缺点是它阻碍了分解。例如，`Orders`和`Consumers`的业务逻辑必须在同一服务中集中，这使得服务更大。由于这些问题，使聚合体尽可能细粒度是最好的。
- en: 5.2.5\. Designing business logic with aggregates
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5. 使用聚合体设计业务逻辑
- en: In a typical (micro)service, the bulk of the business logic consists of aggregates.
    The rest of the business logic resides in the domain services and the sagas. The
    sagas orchestrate sequences of local transactions in order to enforce data consistency.
    The services are the entry points into the business logic and are invoked by inbound
    adapters. A service uses a repository to retrieve aggregates from the database
    or save aggregates to the database. Each repository is implemented by an outbound
    adapter that accesses the database. [Figure 5.9](#ch05fig09) shows the aggregate-based
    design of the business logic for the `Order Service`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的（微）服务中，大部分业务逻辑由聚合体组成。其余的业务逻辑位于领域服务和传说中。传说通过编排一系列本地事务来强制执行数据一致性。服务是业务逻辑的入口点，并由入站适配器调用。服务使用存储库从数据库检索聚合体或将聚合体保存到数据库。每个存储库都由一个出站适配器实现，该适配器访问数据库。[图5.9](#ch05fig09)显示了基于聚合体的`Order
    Service`业务逻辑设计。
- en: Figure 5.9\. An aggregate-based design for the `Order Service` business logic
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.9. `Order Service`业务逻辑的基于聚合体的设计
- en: '![](Images/05fig09_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig09_alt.jpg)'
- en: The business logic consists of the `Order` aggregate, the `OrderService` service
    class, the `OrderRepository`, and one or more sagas. The `OrderService` invokes
    the `OrderRepository` to save and load `Orders`. For simple requests that are
    local to the service, the service updates an `Order` aggregate. If an update request
    spans multiple services, the `OrderService` will also create a saga, as described
    in [chapter 4](kindle_split_012.xhtml#ch04).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑包括`Order`聚合体、`OrderService`服务类、`OrderRepository`和一个或多个传说。`OrderService`调用`OrderRepository`来保存和加载`Orders`。对于仅限于服务本地的简单请求，服务会更新一个`Order`聚合体。如果更新请求跨越多个服务，`OrderService`还将创建一个传说，如第4章所述。
- en: 'We’ll take a look at the code—but first, let’s examine a concept that’s closely
    related to aggregates: domain events.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看代码——但首先，让我们考察一个与聚合体密切相关的概念：领域事件。
- en: 5.3\. Publishing domain events
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 发布领域事件
- en: 'Merriam-Webster ([https://www.merriam-webster.com/dictionary/event](https://www.merriam-webster.com/dictionary/event))
    lists several definitions of the word *event*, including these:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Merriam-Webster ([https://www.merriam-webster.com/dictionary/event](https://www.merriam-webster.com/dictionary/event))
    列出了“事件”这个词的几个定义，包括以下这些：
- en: Something that happens
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发生的事情
- en: A noteworthy happening
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个值得注意的事件
- en: A social occasion or activity
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个社交场合或活动
- en: An adverse or damaging medical occurrence, a heart attack or other cardiac event
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不利的或有害的医疗事件，如心脏病发作或其他心脏事件
- en: In the context of DDD, a domain event is something that has happened to an aggregate.
    It’s represented by a class in the domain model. An event usually represents a
    state change. Consider, for example, an `Order` aggregate in the FTGO application.
    Its state-changing events include `Order Created`, `Order Cancelled`, `Order Shipped`,
    and so forth. An `Order` aggregate might, if there are interested consumers, publish
    one of the events each time it undergoes a state transition.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计（DDD）的上下文中，领域事件是发生在聚合体上的事情。它在领域模型中由一个类表示。事件通常表示状态变化。例如，考虑FTGO应用程序中的`Order`聚合体。其状态变化事件包括`Order
    Created`、`Order Cancelled`、`Order Shipped`等。如果存在感兴趣的消费者，`Order`聚合体可能会在每次经历状态转换时发布其中一个事件。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Domain event**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：领域事件**'
- en: An aggregate publishes a domain event when it’s created or undergoes some other
    significant change.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当聚合创建或经历某些其他重大变化时，它会发布领域事件。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.3.1\. Why publish change events?
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 为什么发布变更事件？
- en: 'Domain events are useful because other parties—users, other applications, or
    other components within the same application—are often interested in knowing about
    an aggregate’s state changes. Here are some example scenarios:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件很有用，因为其他方——用户、其他应用程序或同一应用程序内的其他组件——通常对了解聚合的状态变化感兴趣。以下是一些示例场景：
- en: Maintaining data consistency across services using choreography-based sagas,
    described in [chapter 4](kindle_split_012.xhtml#ch04).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于编排的叙事，维护跨服务的数据一致性，如[第4章](kindle_split_012.xhtml#ch04)所述。
- en: Notifying a service that maintains a replica that the source data has changed.
    This approach is known as Command Query Responsibility Segregation (CQRS), and
    it’s described in [chapter 7](kindle_split_015.xhtml#ch07).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知维护副本的服务源数据已更改。这种方法被称为命令查询责任分离（CQRS），并在[第7章](kindle_split_015.xhtml#ch07)中描述。
- en: Notifying a different application via a registered webhook or via a message
    broker in order to trigger the next step in a business process.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注册的 webhook 或通过消息代理通知不同的应用程序，以触发业务流程的下一步。
- en: Notifying a different component of the same application in order, for example,
    to send a WebSocket message to a user’s browser or update a text database such
    as ElasticSearch.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知同一应用程序的另一个组件，例如，向用户的浏览器发送 WebSocket 消息或更新文本数据库，如 ElasticSearch。
- en: Sending notifications—text messages or emails—to users informing them that their
    order has shipped, their Rx prescription is ready for pick up, or their flight
    is delayed.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户发送通知——短信或电子邮件——告知他们的订单已发货，他们的 Rx 处方已准备好取药，或他们的航班延误。
- en: Monitoring domain events to verify that the application is behaving correctly.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控领域事件以验证应用程序是否表现正确。
- en: Analyzing events to model user behavior.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析事件以建模用户行为。
- en: The trigger for the notification in all these scenarios is the state change
    of an aggregate in an application’s database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些场景中，通知的触发器是应用程序数据库中聚合的状态变化。
- en: 5.3.2\. What is a domain event?
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 什么是领域事件？
- en: A *domain event* is a class with a name formed using a past-participle verb.
    It has properties that meaningfully convey the event. Each property is either
    a primitive value or a value object. For example, an `OrderCreated` event class
    has an `orderId` property.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *领域事件* 是一个使用过去分词动词命名的类。它具有有意义的传达事件的属性。每个属性要么是原始值，要么是值对象。例如，`OrderCreated`
    事件类有一个 `orderId` 属性。
- en: A domain event typically also has metadata, such as the event ID, and a timestamp.
    It might also have the identity of the user who made the change, because that’s
    useful for auditing. The metadata can be part of the event object, perhaps defined
    in a superclass. Alternatively, the event metadata can be in an envelope object
    that wraps the event object. The ID of the aggregate that emitted the event might
    also be part of the envelope rather than an explicit event property.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件通常也具有元数据，例如事件 ID 和时间戳。它还可能包含更改用户的身份，因为这对审计很有用。元数据可以是事件对象的一部分，也许定义在超类中。或者，事件元数据可以放在包装事件对象的信封对象中。发出事件的聚合的
    ID 也可能是信封的一部分，而不是显式的事件属性。
- en: The `OrderCreated` event is an example of a domain event. It doesn’t have any
    fields, because the Order’s ID is part of the event envelope. The following listing
    shows the `OrderCreated` event class and the `DomainEventEnvelope` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderCreated` 事件是领域事件的例子。它没有任何字段，因为订单的 ID 是事件信封的一部分。以下列表显示了 `OrderCreated`
    事件类和 `DomainEventEnvelope` 类。'
- en: Listing 5.1\. The `OrderCreated` event and the `DomainEventEnvelope` class
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. `OrderCreated` 事件和 `DomainEventEnvelope` 类
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The event’s metadata**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 事件的元数据**'
- en: The `DomainEvent` interface is a marker interface that identifies a class as
    a domain event. `OrderDomainEvent` is a marker interface for events, such as `OrderCreated`,
    which are published by the `Order` aggregate. The `DomainEventEnvelope` is a class
    that contains event metadata and the event object. It’s a generic class that’s
    parameterized by the domain event type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`DomainEvent` 接口是一个标记接口，用于标识一个类作为领域事件。`OrderDomainEvent` 是一个标记接口，用于事件，例如 `OrderCreated`，这些事件由
    `Order` 聚合发布。`DomainEventEnvelope` 是一个包含事件元数据和事件对象的类。它是一个泛型类，由领域事件类型参数化。'
- en: 5.3.3\. Event enrichment
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 事件丰富化
- en: Let’s imagine, for example, that you’re writing an event consumer that processes
    `Order` events. The `OrderCreated` event class shown previously captures the essence
    of what has happened. But your event consumer may need the order details when
    processing an `OrderCreated` event. One option is for it to retrieve that information
    from the `OrderService`. The drawback of an event consumer querying the service
    for the aggregate is that it incurs the overhead of a service request.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象你正在编写一个处理 `Order` 事件的消费者。之前显示的 `OrderCreated` 事件类捕捉了所发生事情的本质。但你的事件消费者在处理
    `OrderCreated` 事件时可能需要订单详情。一个选项是让它从 `OrderService` 中检索该信息。事件消费者查询服务以获取聚合的缺点是它会产生服务请求的开销。
- en: An alternative approach known as *event enrichment* is for events to contain
    information that consumers need. It simplifies event consumers because they no
    longer need to request that data from the service that published the event. In
    the `OrderCreated` event, the `Order` aggregate can enrich the event by including
    the order details. The following listing shows the enriched event.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种称为 *事件丰富* 的替代方法是为事件包含消费者所需的信息。这简化了事件消费者，因为他们不再需要从发布事件的服务的请求该数据。在 `OrderCreated`
    事件中，`Order` 聚合可以通过包含订单详情来丰富事件。以下列表显示了丰富的事件。
- en: Listing 5.2\. The enriched `OrderCreated` event
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 丰富的 `OrderCreated` 事件
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Data that its consumers typically need**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 消费者通常需要的数据**'
- en: Because this version of the `OrderCreated` event contains the order details,
    an event consumer, such as the `Order History Service` (discussed in [chapter
    7](kindle_split_015.xhtml#ch07)) no longer needs to fetch that data when processing
    an `OrderCreated` event.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个版本的 `OrderCreated` 事件包含了订单详情，所以事件消费者，例如 `Order History Service`（在第 7 章中讨论过），在处理
    `OrderCreated` 事件时不再需要获取这些数据。
- en: Although event enrichment simplifies consumers, the drawback is that it risks
    making the event classes less stable. An event class potentially needs to change
    whenever the requirements of its consumers change. This can reduce maintainability
    because this kind of change can impact multiple parts of the application. Satisfying
    every consumer can also be a futile effort. Fortunately, in many situations it’s
    fairly obvious which properties to include in an event.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然事件丰富简化了消费者，但其缺点是它可能会使事件类变得不稳定。事件类可能需要在消费者需求发生变化时进行更改。这可能会降低可维护性，因为这种类型的更改可能会影响应用程序的多个部分。满足每个消费者的需求也可能是一种徒劳的努力。幸运的是，在许多情况下，很明显应该将哪些属性包含在事件中。
- en: Now that we’ve covered the basics of domain events, let’s look at how to discover
    them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了领域事件的基础知识，让我们看看如何发现它们。
- en: 5.3.4\. Identifying domain events
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4\. 识别领域事件
- en: There are a few different strategies for identifying domain events. Often the
    requirements will describe scenarios where notifications are required. The requirements
    might include language such as “When X happens do Y.” For example, one requirement
    in the FTGO application is “When an Order is placed send the consumer an email.”
    A requirement for a notification suggests the existence of a domain event.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 识别领域事件有几种不同的策略。通常，需求会描述需要通知的场景。需求可能包括诸如“当 X 发生时做 Y。”之类的语言。例如，FTGO 应用中的一个需求是“当订单被下单时，向消费者发送电子邮件。”一个通知需求暗示了领域事件的存在。
- en: Another approach, which is increasing in popularity, is to use event storming.
    *Event storming* is an event-centric workshop format for understanding a complex
    domain. It involves gathering domain experts in a room, lots of sticky notes,
    and a very large surface—a whiteboard or paper roll—to stick the notes on. The
    result of event storming is an event-centric domain model consisting of aggregates
    and events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种越来越受欢迎的方法是使用事件风暴。*事件风暴* 是一种以事件为中心的工作坊格式，用于理解复杂的领域。它涉及将领域专家聚集在房间里，大量的便利贴，以及一个非常大的表面——白板或纸卷——将便利贴粘在上面。事件风暴的结果是一个以事件为中心的领域模型，由聚合和事件组成。
- en: 'Event storming consist of three main steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事件风暴包括三个主要步骤：
- en: '***Brainstorm events*—** Ask the domain experts to brainstorm the domain events.
    Domain events are represented by orange sticky notes that are laid out in a rough
    timeline on the modeling surface.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***头脑风暴事件*—** 请领域专家进行领域事件的头脑风暴。领域事件由橙色便利贴表示，这些便利贴在建模表面上以大致的时间顺序排列。'
- en: '***Identify event triggers*—** Ask the domain experts to identify the trigger
    of each event, which is one of the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***识别事件触发器*—** 请领域专家识别每个事件的触发器，这通常包括以下几种：'
- en: User actions, represented as a command using a blue sticky note
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户操作，用蓝色便利贴表示的命令
- en: External system, represented by a purple sticky note
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部系统，由紫色便利贴表示
- en: Another domain event
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个领域事件
- en: Passing of time
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间的流逝
- en: '***Identify aggregates*—** Ask the domain experts to identify the aggregate
    that consumes each command and emits the corresponding event. Aggregates are represented
    by yellow sticky notes.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***识别聚合*—** 请领域专家识别消耗每个命令并发出相应事件的聚合。聚合用黄色便利贴表示。'
- en: '[Figure 5.10](#ch05fig10) shows the result of an event-storming workshop. In
    just a couple of hours, the participants identified numerous domain events, commands,
    and aggregates. It was a good first step in the process of creating a domain model.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.10](#ch05fig10)显示了事件风暴工作坊的结果。在短短几个小时里，参与者确定了众多领域事件、命令和聚合。这是创建领域模型过程中的良好第一步。'
- en: Figure 5.10\. The result of an event-storming workshop that lasted a couple
    of hours. The sticky notes are events, which are laid out along a timeline; commands,
    which represent user actions; and aggregates, which emit events in response to
    a command.
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. 持续了几个小时的事件风暴工作坊的结果。便利贴代表事件，它们沿着时间线排列；命令，代表用户操作；以及聚合，它们在接收到命令时发出事件。
- en: '![](Images/05fig10_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig10_alt.jpg)'
- en: Event storming is a useful technique for quickly creating a domain model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 事件风暴是一种快速创建领域模型的有用技术。
- en: Now that we’ve covered the basics of domain events, let’s look at the mechanics
    of generating and publishing them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了领域事件的基础知识，让我们看看生成和发布它们的机制。
- en: 5.3.5\. Generating and publishing domain events
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5\. 生成和发布领域事件
- en: Communicating using domain events is a form of asynchronous messaging, discussed
    in [chapter 3](kindle_split_011.xhtml#ch03). But before the business logic can
    publish them to a message broker, it must first create them. Let’s look at how
    to do that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用领域事件进行通信是一种异步消息传递的形式，这在[第3章](kindle_split_011.xhtml#ch03)中讨论过。但在业务逻辑可以将它们发布到消息代理之前，它必须首先创建它们。让我们看看如何做到这一点。
- en: Generating domain events
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成领域事件
- en: Conceptually, domain events are published by aggregates. An aggregate knows
    when its state changes and hence what event to publish. An aggregate could invoke
    a messaging API directly. The drawback of this approach is that because aggregates
    can’t use dependency injection, the messaging API would need to be passed around
    as a method argument. That would intertwine infrastructure concerns and business
    logic, which is extremely undesirable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，领域事件是由聚合发布的。聚合知道其状态何时改变，因此知道要发布什么事件。聚合可以直接调用消息API。这种方法的缺点是，由于聚合不能使用依赖注入，消息API需要作为方法参数传递。这将基础设施关注点和业务逻辑交织在一起，这是极其不希望的。
- en: A better approach is to split responsibility between the aggregate and the service
    (or equivalent class) that invokes it. Services can use dependency injection to
    obtain a reference to the messaging API, easily publishing events. The aggregate
    generates the events whenever its state changes and returns them to the service.
    There are a couple of different ways an aggregate can return events back to the
    service. One option is for the return value of an aggregate method to include
    a list of events. For example, the following listing shows how a `Ticket` aggregate’s
    `accept()` method can return a `TicketAcceptedEvent` to its caller.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是让聚合和调用它的服务（或等效类）分担责任。服务可以使用依赖注入来获取消息API的引用，轻松发布事件。聚合在其状态改变时生成事件，并将它们返回给服务。聚合将事件返回给服务的方式有几种。一种选择是聚合方法的返回值包括事件列表。例如，以下列表显示了`Ticket`聚合的`accept()`方法如何向其调用者返回`TicketAcceptedEvent`。
- en: Listing 5.3\. The `Ticket` aggregate’s `accept()` method
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. `Ticket`聚合的`accept()`方法
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Updates the Ticket**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新票据**'
- en: '***2* Returns an event**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回一个事件**'
- en: The service invokes the aggregate root’s method, and then publishes the events.
    For example, the following listing shows how `KitchenService` invokes `Ticket.accept()`
    and publishes the events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 服务调用聚合根的方法，然后发布事件。例如，以下列表显示了`KitchenService`如何调用`Ticket.accept()`并发布事件。
- en: Listing 5.4\. `KitchenService` calls `Ticket.accept()`
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. `KitchenService`调用`Ticket.accept()`
- en: '[PRE7]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Publishes domain events**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 发布领域事件**'
- en: The `accept()` method first invokes the `TicketRepository` to load the `Ticket`
    from the database. It then updates the `Ticket` by calling `accept()`. `KitchenService`
    then publishes events returned by `Ticket` by calling `DomainEventPublisher.publish()`,
    described shortly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()` 方法首先调用 `TicketRepository` 从数据库中加载 `Ticket`。然后通过调用 `accept()` 更新
    `Ticket`。`KitchenService` 然后通过调用 `DomainEventPublisher.publish()` 发布 `Ticket`
    返回的事件，这将在稍后进行描述。'
- en: This approach is quite simple. Methods that would otherwise have a void return
    type now return `List<Event>`. The only potential drawback is that the return
    type of non-void methods is now more complex. They must return an object containing
    the original return value and `List<Event>`. You’ll see an example of such a method
    soon.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当简单。原本应该返回 void 类型的方法现在返回 `List<Event>`。唯一的潜在缺点是，非 void 方法的返回类型现在更复杂。它们必须返回一个包含原始返回值和
    `List<Event>` 的对象。你很快就会看到一个这样的方法的例子。
- en: Another option is for the aggregate root to accumulate events in a field. The
    service then retrieves the events and publishes them. For example, the following
    listing shows a variant of the `Ticket` class that works this way.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是聚合根在字段中累积事件。然后服务检索事件并发布它们。例如，以下列表显示了一个以这种方式工作的 `Ticket` 类的变体。
- en: Listing 5.5\. The `Ticket` extends a superclass, which records domain events
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5。`Ticket` 扩展了一个超类，该超类记录领域事件
- en: '[PRE8]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Ticket` extends `AbstractAggregateRoot`, which defines a `registerDomainEvent()`
    method that records the event. A service would call `AbstractAggregateRoot.getDomainEvents()`
    to retrieve those events.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket` 扩展了 `AbstractAggregateRoot`，它定义了一个 `registerDomainEvent()` 方法来记录事件。服务将调用
    `AbstractAggregateRoot.getDomainEvents()` 来检索这些事件。'
- en: 'My preference is for the first option: the method returning events to the service.
    But accumulating events in the aggregate root is also a viable option. In fact,
    the Spring Data Ingalls release train ([https://spring.io/blog/2017/01/30/what-s-new-in-spring-data-release-ingalls](https://spring.io/blog/2017/01/30/what-s-new-in-spring-data-release-ingalls))
    implements a mechanism that automatically publishes events to the Spring `ApplicationContext`.
    The main drawback is that to reduce code duplication, aggregate roots should extend
    a superclass such as `AbstractAggregateRoot`, which might conflict with a requirement
    to extend some other superclass. Another issue is that although it’s easy for
    the aggregate root’s methods to call `registerDomainEvent()`, methods in other
    classes in the aggregate would find it challenging. They would mostly likely need
    to somehow pass the events to the aggregate root.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我的偏好是第一种选项：将事件返回给服务的方法。但是，在聚合根中累积事件也是一个可行的选项。事实上，Spring Data Ingalls 版本列车（[https://spring.io/blog/2017/01/30/what-s-new-in-spring-data-release-ingalls](https://spring.io/blog/2017/01/30/what-s-new-in-spring-data-release-ingalls)）实现了一个机制，该机制自动将事件发布到
    Spring `ApplicationContext`。主要的缺点是，为了减少代码重复，聚合根应该扩展一个超类，如 `AbstractAggregateRoot`，这可能与扩展其他超类的要求相冲突。另一个问题是，尽管聚合根的方法调用
    `registerDomainEvent()` 很容易，但聚合中其他类的方法会发现这很具挑战性。它们很可能会需要以某种方式将事件传递给聚合根。
- en: How to reliably publish domain events?
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 如何可靠地发布领域事件？
- en: '[Chapter 3](kindle_split_011.xhtml#ch03) talks about how to reliably send messages
    as part of a local database transaction. Domain events are no different. A service
    must use transactional messaging to publish events to ensure that they’re published
    as part of the transaction that updates the aggregate in the database. The Eventuate
    Tram framework, described in [chapter 3](kindle_split_011.xhtml#ch03), implements
    such a mechanism. It insert events into an `OUTBOX` table as part of the ACID
    transaction that updates the database. After the transaction commits, the events
    that were inserted into the `OUTBOX` table are then published to the message broker.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](kindle_split_011.xhtml#ch03) 讨论了如何在本地数据库事务中可靠地发送消息。领域事件并无不同。服务必须使用事务消息来发布事件，以确保它们作为更新数据库中聚合的事务的一部分发布。在第
    3 章（kindle_split_011.xhtml#ch03）中描述的 Eventuate Tram 框架实现了这样的机制。它将事件插入到更新数据库的 ACID
    事务中的 `OUTBOX` 表中。在事务提交后，插入到 `OUTBOX` 表中的事件随后被发布到消息代理。'
- en: The `Tram` framework provides a `DomainEventPublisher` interface, shown in the
    following listing. It defines several overloaded `publish()` methods that take
    the aggregate type and ID as parameters, along with a list of domain events.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tram` 框架提供了一个 `DomainEventPublisher` 接口，如下所示。它定义了几个重载的 `publish()` 方法，这些方法接受聚合类型和
    ID 作为参数，以及一个领域事件列表。'
- en: Listing 5.6\. The Eventuate Tram framework’s `DomainEventPublisher` interface
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. Eventuate Tram 框架的 `DomainEventPublisher` 接口
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It uses the Eventuate Tram framework’s `MessageProducer` interface to publish
    those events transactionally.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 Eventuate Tram 框架的 `MessageProducer` 接口以事务方式发布这些事件。
- en: 'A service could call the `DomainEventPublisher` publisher directly. But one
    drawback of doing so is that it doesn’t ensure that a service only publishes valid
    events. `KitchenService`, for example, should only publish events that implement
    `TicketDomainEvent`, which is the marker interface for the `Ticket` aggregate’s
    events. A better option is for services to implement a subclass of `AbstractAggregateDomainEventPublisher`,
    which is shown in [listing 5.7](#ch05ex07). `AbstractAggregateDomainEventPublisher`
    is an abstract class that provides a type-safe interface for publishing domain
    events. It’s a generic class that has two type parameters, `A`, the aggregate
    type, and `E`, the marker interface type for the domain events. A service publishes
    events by calling the `publish()` method, which has two parameters: an aggregate
    of type `A` and a list of events of type `E`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以直接调用 `DomainEventPublisher` 发布者。但这样做的一个缺点是它不能确保服务只发布有效的事件。例如，`KitchenService`
    应该只发布实现 `TicketDomainEvent` 的事件，这是 `Ticket` 聚合事件的标记接口。更好的选择是服务实现 `AbstractAggregateDomainEventPublisher`
    的子类，这在 [列表 5.7](#ch05ex07) 中展示。`AbstractAggregateDomainEventPublisher` 是一个抽象类，它为发布领域事件提供了一个类型安全的接口。它是一个泛型类，有两个类型参数，`A`
    是聚合类型，`E` 是领域事件的标记接口类型。服务通过调用 `publish()` 方法发布事件，该方法有两个参数：类型为 `A` 的聚合和类型为 `E`
    的事件列表。
- en: Listing 5.7\. The abstract superclass of type-safe domain event publishers
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 类型安全领域事件发布器的抽象超类
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `publish()` method retrieves the aggregate’s ID and invokes `DomainEventPublisher.publish()`.
    The following listing shows the `TicketDomainEventPublisher`, which publishes
    domain events for the `Ticket` aggregate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish()` 方法检索聚合的 ID 并调用 `DomainEventPublisher.publish()`。以下列表展示了 `TicketDomainEventPublisher`，它为
    `Ticket` 聚合发布领域事件。'
- en: Listing 5.8\. A type-safe interface for publishing `Ticket` aggregates’ domain
    events
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. 发布 `Ticket` 聚合领域事件的类型安全接口
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This class only publishes events that are a subclass of `TicketDomainEvent`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此类只发布是 `TicketDomainEvent` 子类的事件。
- en: Now that we’ve looked at how to publish domain events, let’s see how to consume
    them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何发布领域事件，接下来让我们看看如何消费它们。
- en: 5.3.6\. Consuming domain events
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.6\. 消费领域事件
- en: Domain events are ultimately published as messages to a message broker, such
    as Apache Kafka. A consumer could use the broker’s client API directly. But it’s
    more convenient to use a higher-level API such as the Eventuate Tram framework’s
    `DomainEventDispatcher`, described in [chapter 3](kindle_split_011.xhtml#ch03).
    A `DomainEventDispatcher` dispatches domain events to the appropriate handle method.
    [Listing 5.9](#ch05ex09) shows an example event handler class. `KitchenServiceEventConsumer`
    subscribes to events published by `Restaurant Service` whenever a restaurant’s
    menu is updated. It’s responsible for keeping `Kitchen Service`’s replica of the
    data up-to-date.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件最终被发布为消息到消息代理，例如 Apache Kafka。消费者可以直接使用代理的客户端 API。但使用更高层次的 API，例如 Eventuate
    Tram 框架中的 `DomainEventDispatcher` 更为方便，这在 [第 3 章](kindle_split_011.xhtml#ch03)
    中有描述。`DomainEventDispatcher` 将领域事件分发给相应的处理方法。[列表 5.9](#ch05ex09) 展示了一个示例事件处理器类。`KitchenServiceEventConsumer`
    订阅由 `Restaurant Service` 发布的事件，每当餐厅的菜单更新时。它负责保持 `Kitchen Service` 的数据副本是最新的。
- en: Listing 5.9\. Dispatching events to event handler methods
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. 将事件分发给事件处理方法
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Maps events to event handlers**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将事件映射到事件处理器**'
- en: '***2* An event handler for the RestaurantMenuRevised event**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* RestaurantMenuRevised 事件的处理器**'
- en: The `reviseMenu()` method handles `RestaurantMenuRevised` events. It calls `restaurantService.reviseMenu()`,
    which updates the restaurant’s menu. That method returns a list of domain events,
    which are published by the event handler.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`reviseMenu()` 方法处理 `RestaurantMenuRevised` 事件。它调用 `restaurantService.reviseMenu()`，更新餐厅的菜单。该方法返回一个领域事件列表，这些事件由事件处理器发布。'
- en: Now that we’ve looked at aggregates and domain events, it’s time to consider
    some example business logic that’s implemented using aggregates.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了聚合和领域事件，是时候考虑一些使用聚合实现的示例业务逻辑了。
- en: 5.4\. Kitchen Service business logic
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 厨房服务业务逻辑
- en: The first example is `Kitchen Service`, which enables a restaurant to manage
    their orders. The two main aggregates in this service are the `Restaurant` and
    `Ticket` aggregates. The `Restaurant` aggregate knows the restaurant’s menu and
    opening hours and can validate orders. A `Ticket` represents an order that a restaurant
    must prepare for pickup by a courier. [Figure 5.11](#ch05fig11) shows these aggregates
    and other key parts of the service’s business logic, as well as the service’s
    adapters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是`Kitchen Service`，它使餐厅能够管理他们的订单。该服务中的两个主要聚合是`Restaurant`和`Ticket`聚合。`Restaurant`聚合了解餐厅的菜单和营业时间，并可以验证订单。`Ticket`代表餐厅必须为快递员准备的订单。![图5.11](#ch05fig11)显示了这些聚合以及服务业务逻辑的其他关键部分，以及服务的适配器。
- en: Figure 5.11\. The design of `Kitchen Service`
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. `Kitchen Service`的设计
- en: '![](Images/05fig11_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig11_alt.jpg)'
- en: In addition to the aggregates, the other main parts of `Kitchen Service`’s business
    logic are `KitchenService`, `TicketRepository`, and `RestaurantRepository`. `KitchenService`
    is the business logic’s entry. It defines methods for creating and updating the
    `Restaurant` and `Ticket` aggregates. `TicketRepository` and `RestaurantRepository`
    define methods for persisting `Tickets` and `Restaurants` respectively.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了聚合之外，`Kitchen Service`的业务逻辑的其他主要部分是`KitchenService`、`TicketRepository`和`RestaurantRepository`。`KitchenService`是业务逻辑的入口。它定义了创建和更新`Restaurant`和`Ticket`聚合的方法。`TicketRepository`和`RestaurantRepository`分别定义了持久化`Tickets`和`Restaurants`的方法。
- en: 'The `Kitchen Service` service has three inbound adapters:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kitchen Service` 服务有三个入站适配器：'
- en: '**`REST API`—** The REST API invoked by the user interface used by workers
    at the restaurant. It invokes `KitchenService` to create and update `Tickets`.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`REST API`—** 由餐厅工作人员使用的用户界面调用的REST API。它调用`KitchenService`来创建和更新`Tickets`。'
- en: '**`KitchenServiceCommandHandler`—** The asynchronous request/response-based
    API that’s invoked by sagas. It invokes `KitchenService` to create and update
    `Tickets`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`KitchenServiceCommandHandler`—** 由sagas调用的基于异步请求/响应的API。它调用`KitchenService`来创建和更新`Tickets`。'
- en: '**`KitchenServiceEventConsumer`—** Subscribes to events published by `Restaurant
    Service`. It invokes `KitchenService` to create and update `Restaurants`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`KitchenServiceEventConsumer`—** 订阅由`Restaurant Service`发布的事件。它调用`KitchenService`来创建和更新`Restaurants`。'
- en: 'The service also has two outbound adapters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务还有两个出站适配器：
- en: '**`DB adapter`—** Implements the `TicketRepository` and the `RestaurantRepository`
    interfaces and accesses the database.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DB adapter`—** 实现了`TicketRepository`和`RestaurantRepository`接口并访问数据库。'
- en: '**`DomainEventPublishingAdapter`—** Implements the `DomainEventPublisher` interface
    and publishes `Ticket` domain events.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DomainEventPublishingAdapter`—** 实现了`DomainEventPublisher`接口并发布`Ticket`领域事件。'
- en: Let’s take a closer look at the design of `KitchenService`, starting with the
    `Ticket` aggregate.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看`KitchenService`的设计，从`Ticket`聚合开始。
- en: 5.4.1\. The Ticket aggregate
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 票据聚合
- en: '`Ticket` is one of the aggregates of `Kitchen Service`. As described in [chapter
    2](kindle_split_010.xhtml#ch02), when talking about the concept of a Bounded Context,
    this aggregate represents the restaurant kitchen’s view of an order. It doesn’t
    contain information about the consumer, such as their identity, the delivery information,
    or payment details. It’s focused on enabling a restaurant’s kitchen to prepare
    the `Order` for pickup. Moreover, `KitchenService` doesn’t generate a unique ID
    for this aggregate. Instead, it uses the ID supplied by `OrderService`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket`是`Kitchen Service`的聚合之一。如[第2章](kindle_split_010.xhtml#ch02)中所述，当谈论边界上下文的概念时，这个聚合代表了餐厅厨房对订单的视图。它不包含有关消费者的信息，例如他们的身份、配送信息或支付详情。它专注于使餐厅的厨房能够为取货准备`Order`。此外，`KitchenService`不为这个聚合生成唯一的ID。相反，它使用`OrderService`提供的ID。'
- en: Let’s first look at the structure of this class and then we’ll examine its methods.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看这个类的结构，然后我们将检查其方法。
- en: Structure of the Ticket class
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 票据类结构
- en: The following listing shows an excerpt of the code for this class. The `Ticket`
    class is similar to a traditional domain class. The main difference is that references
    to other aggregates are by primary key.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了该类的代码摘录。`Ticket`类类似于传统的领域类。主要区别是其他聚合的引用是通过主键进行的。
- en: Listing 5.10\. Part of the `Ticket` class, which is a JPA entity
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. `Ticket`类的一部分，它是一个JPA实体
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This class is persisted with JPA and is mapped to the `TICKETS` table. The `restaurantId`
    field is a `Long` rather than an object reference to a `Restaurant`. The `readyBy`
    field stores the estimate of when the order will be ready for pickup. The `Ticket`
    class has several fields that track the history of the order, including `acceptTime`,
    `preparingTime`, and `pickupTime`. Let’s look at this class’s methods.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此类使用 JPA 持久化，并映射到 `TICKETS` 表。`restaurantId` 字段是一个 `Long` 而不是一个指向 `Restaurant`
    对象的引用。`readyBy` 字段存储订单预计可以取走的时间。`Ticket` 类有多个字段跟踪订单的历史，包括 `acceptTime`、`preparingTime`
    和 `pickupTime`。让我们看看这个类的其他方法。
- en: Behavior of the Ticket aggregate
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Ticket` 聚合的行为'
- en: 'The `Ticket` aggregate defines several methods. As you saw earlier, it has
    a static `create()` method, which is a factory method that creates a `Ticket`.
    There are also some methods that are invoked when the restaurant updates the state
    of the order:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket` 聚合定义了几个方法。正如您之前所看到的，它有一个静态的 `create()` 方法，这是一个工厂方法，用于创建一个 `Ticket`。还有一些方法在餐厅更新订单状态时会被调用：'
- en: '**`accept()`—** The restaurant has accepted the order.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`accept()`—** 餐厅已接受订单。'
- en: '**`preparing()`—** The restaurant has started preparing the order, which means
    the order can no longer be changed or cancelled.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`preparing()`—** 餐厅已经开始准备订单，这意味着订单不能再更改或取消。'
- en: '**`readyForPickup()`—** The order can now be picked up.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`readyForPickup()`—** 订单现在可以取走了。'
- en: The following listing shows some of its methods.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了其中的一些方法。
- en: Listing 5.11\. Some of the `Ticket`’s methods
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. `Ticket` 的部分方法
- en: '[PRE14]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `create()` method creates a `Ticket`. The `preparing()` method is called
    when the restaurant starts preparing the order. It changes the state of the order
    to `PREPARING`, records the time, and publishes an event. The `cancel()` method
    is called when a user attempts to cancel an order. If the cancellation is allowed,
    this method changes the state of the order and returns an event. Otherwise, it
    throws an exception. These methods are invoked in response to REST API requests
    as well as events and command messages. Let’s look at the classes that invoke
    the aggregate’s method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 方法创建一个 `Ticket`。当餐厅开始准备订单时，会调用 `preparing()` 方法。它将订单状态更改为 `PREPARING`，记录时间，并发布一个事件。当用户尝试取消订单时，会调用
    `cancel()` 方法。如果允许取消，此方法将更改订单状态并返回一个事件。否则，它抛出异常。这些方法在响应 REST API 请求以及事件和命令消息时被调用。让我们看看调用聚合方法类的示例。'
- en: The KitchenService domain service
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`KitchenService` 领域服务'
- en: '`KitchenService` is invoked by the service’s inbound adapters. It defines various
    methods for changing the state of an order, including `accept()`, `reject()`,
    `preparing()`, and others. Each method loads the specifies aggregate, calls the
    corresponding method on the aggregate root, and publishes any domain events. The
    following listing shows its `accept()` method.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`KitchenService` 由服务的入站适配器调用。它定义了各种更改订单状态的方法，包括 `accept()`、`reject()`、`preparing()`
    等。每个方法都加载指定的聚合，在聚合根上调用相应的方法，并发布任何领域事件。以下列表显示了它的 `accept()` 方法。'
- en: Listing 5.12\. The service’s `accept()` method updates `Ticket`
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 服务的 `accept()` 方法更新 `Ticket`
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Publish domain events**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 发布领域事件**'
- en: 'The `accept()` method is invoked when the restaurant accepts a new order. It
    has two parameters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当餐厅接受新订单时，会调用 `accept()` 方法。它有两个参数：
- en: '**`orderId`—** ID of the order to accept'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`orderId`—** 要接受的订单 ID'
- en: '**`readyBy`—** Estimated time when the order will be ready for pickup'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`readyBy`—** 订单预计可以取走的时间'
- en: This method retrieves the `Ticket` aggregate and calls its `accept()` method.
    It publishes any generated events.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检索 `Ticket` 聚合并调用其 `accept()` 方法。它发布任何生成的事件。
- en: Now let’s look at the class that handles asynchronous commands.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看处理异步命令的类。
- en: The KitchenServiceCommandHandler class
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`KitchenServiceCommandHandler` 类'
- en: The `KitchenServiceCommandHandler` class is an adapter that’s responsible for
    handling command messages sent by the various sagas implemented by `Order Service`.
    This class defines a handler method for each command, which invokes `KitchenService`
    to create or update a `Ticket`. The following listing shows an excerpt of this
    class.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`KitchenServiceCommandHandler` 类是一个适配器，负责处理由 `Order Service` 实现的各个 sagas 发送的命令消息。此类为每个命令定义了一个处理程序方法，调用
    `KitchenService` 创建或更新 `Ticket`。以下列表显示了此类的摘录。'
- en: Listing 5.13\. Handling command messages sent by sagas
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 处理 sagas 发送的命令消息
- en: '[PRE16]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Maps command messages to message handlers**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将命令消息映射到消息处理器**'
- en: '***2* Invokes KitchenService to create the Ticket**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 KitchenService 创建 Ticket**'
- en: '***3* Sends back a successful reply**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发送成功回复**'
- en: '***4* Sends back a failure reply**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 发送失败回复**'
- en: '***5* Confirms the order**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 确认订单**'
- en: All the command handler methods invoke `KitchenService` and reply with either
    a success or a failure reply.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令处理方法都调用 `KitchenService` 并以成功或失败回复进行回复。
- en: 'Now that you’ve seen the business logic for a relatively simple service, we’ll
    look at a more complex example: `Order Service`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了一个相对简单的服务的业务逻辑，我们将看看一个更复杂的例子：`Order Service`。
- en: 5.5\. Order Service business logic
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 订单服务业务逻辑
- en: As mentioned in earlier chapters, `Order Service` provides an API for creating,
    updating, and canceling orders. This API is primarily invoked by the consumer.
    [Figure 5.12](#ch05fig12) shows the high-level design of the service. The `Order`
    aggregate is the central aggregate of `Order Service`. But there’s also a `Restaurant`
    aggregate, which is a partial replica of data owned by `Restaurant Service`. It
    enables `Order Service` to validate and price an `Order`’s line items.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，`Order Service` 提供了一个用于创建、更新和取消订单的 API。此 API 主要由消费者调用。[图 5.12](#ch05fig12)
    展示了该服务的高级设计。`Order` 聚合是 `Order Service` 的中心聚合。但还有一个 `Restaurant` 聚合，它是 `Restaurant
    Service` 所拥有数据的部分副本。它使 `Order Service` 能够验证和定价 `Order` 的行项目。
- en: Figure 5.12\. The design of the `Order Service`. It has a REST API for managing
    orders. It exchanges messages and events with other services via several message
    channels.
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.12. `Order Service` 的设计。它有一个用于管理订单的 REST API。它通过几个消息通道与其他服务交换消息和事件。
- en: '![](Images/05fig12_alt.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig12_alt.jpg)'
- en: 'In addition to the `Order` and `Restaurant` aggregates, the business logic
    consists of `OrderService`, `OrderRepository`, `RestaurantRepository`, and various
    sagas such as the `CreateOrderSaga` described in [chapter 4](kindle_split_012.xhtml#ch04).
    `OrderService` is the primary entry point into the business logic and defines
    methods for creating and updated `Orders` and `Restaurants`. `OrderRepository`
    defines methods for persisting `Orders`, and `RestaurantRepository` has methods
    for persisting `Restaurants`. `Order Service` has several inbound adapters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Order` 和 `Restaurant` 聚合之外，业务逻辑还包括 `OrderService`、`OrderRepository`、`RestaurantRepository`
    以及各种 saga，例如在第 4 章中描述的 `CreateOrderSaga`。`OrderService` 是业务逻辑的主要入口点，并定义了创建和更新
    `Orders` 和 `Restaurants` 的方法。`OrderRepository` 定义了持久化 `Orders` 的方法，而 `RestaurantRepository`
    则有持久化 `Restaurants` 的方法。`Order Service` 有几个入站适配器：
- en: '**`REST API`—** The REST API invoked by the user interface used by consumers.
    It invokes `OrderService` to create and update `Orders`.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`REST API`—** 用户界面调用的 REST API。它调用 `OrderService` 来创建和更新 `Orders`。'
- en: '**`OrderEventConsumer`—** Subscribes to events published by `Restaurant Service`.
    It invokes `OrderService` to create and update its replica of `Restaurants`.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`OrderEventConsumer`—** 订阅由 `Restaurant Service` 发布的事件。它调用 `OrderService`
    来创建和更新其 `Restaurants` 的副本。'
- en: '**`OrderCommandHandlers`—** The asynchronous request/response-based API that’s
    invoked by sagas. It invokes `OrderService` to update `Orders`.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`OrderCommandHandlers`—** 由 sagas 调用的基于异步请求/响应的 API。它调用 `OrderService` 来更新
    `Orders`。'
- en: '**`SagaReplyAdapter`—** Subscribes to the saga reply channels and invokes the
    sagas.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`SagaReplyAdapter`—** 订阅 saga 回复通道并调用 sagas。'
- en: 'The service also has some outbound adapters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务还有一些出站适配器：
- en: '**`DB adapter`—** Implements the `OrderRepository` interface and accesses the
    `Order Service` database'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DB adapter`—** 实现 `OrderRepository` 接口并访问 `Order Service` 数据库'
- en: '**`DomainEventPublishingAdapter`—** Implements the `DomainEventPublisher` interface
    and publishes `Order` domain events'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DomainEventPublishingAdapter`—** 实现 `DomainEventPublisher` 接口并发布 `Order`
    领域事件'
- en: '**`OutboundCommandMessageAdapter`—** Implements the `CommandPublisher` interface
    and sends command messages to saga participants'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`OutboundCommandMessageAdapter`—** 实现 `CommandPublisher` 接口并向 saga 参与者发送命令消息'
- en: Let’s first take a closer look at the `Order` aggregate and then examine `OrderService`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先仔细看看 `Order` 聚合，然后再检查 `OrderService`。
- en: 5.5.1\. The Order Aggregate
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1. 订单聚合
- en: The `Order` aggregate represents an order placed by a consumer. We’ll first
    look at the structure of the `Order` aggregate and then check out its methods.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 聚合代表消费者下的一张订单。我们首先将查看 `Order` 聚合的结构，然后检查其方法。'
- en: The structure of the Order aggregate
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 订单聚合的结构
- en: '[Figure 5.13](#ch05fig13) shows the structure of the `Order` aggregate. The
    `Order` class is the root of the `Order` aggregate. The `Order` aggregate also
    consists of value objects such as `OrderLineItem`, `DeliveryInfo`, and `PaymentInfo`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.13](#ch05fig13) 展示了 `Order` 聚合的结构。`Order` 类是 `Order` 聚合的根。`Order` 聚合还包括诸如
    `OrderLineItem`、`DeliveryInfo` 和 `PaymentInfo` 这样的值对象。'
- en: Figure 5.13\. The design of the `Order` aggregate, which consists of the `Order`
    aggregate root and various value objects.
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.13\. 由 `Order` 聚合根和各种值对象组成的 `Order` 聚合的设计。
- en: '![](Images/05fig13_alt.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig13_alt.jpg)'
- en: The `Order` class has a collection of `OrderLineItems`. Because the `Order`’s
    `Consumer` and `Restaurant` are other aggregates, it references them by primary
    key value. The `Order` class has a `DeliveryInfo` class, which stores the delivery
    address and the desired delivery time, and a `PaymentInfo`, which stores the payment
    info. The following listing shows the code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 类有一个 `OrderLineItems` 集合。因为 `Order` 的 `Consumer` 和 `Restaurant` 是其他聚合，所以它通过主键值引用它们。`Order`
    类有一个 `DeliveryInfo` 类，用于存储送货地址和期望的送货时间，以及一个 `PaymentInfo`，用于存储支付信息。以下列表显示了代码。'
- en: Listing 5.14\. The `Order` class and its fields
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. `Order` 类及其字段
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class is persisted with JPA and is mapped to the `ORDERS` table. The `id`
    field is the primary key. The `version` field is used for optimistic locking.
    The state of an `Order` is represented by the `OrderState` enumeration. The `DeliveryInformation`
    and `PaymentInformation` fields are mapped using the `@Embedded` annotation and
    are stored as columns of the `ORDERS` table. The `orderLineItems` field is an
    embedded object that contains the order line items. The `Order` aggregate consists
    of more than just fields. It also implements business logic, which can be described
    by a state machine. Let’s take a look at the state machine.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用 JPA 进行持久化，并映射到 `ORDERS` 表。`id` 字段是主键。`version` 字段用于乐观锁。`Order` 的状态由 `OrderState`
    枚举表示。`DeliveryInformation` 和 `PaymentInformation` 字段使用 `@Embedded` 注解进行映射，并存储为
    `ORDERS` 表的列。`orderLineItems` 字段是一个包含订单行项的嵌入对象。`Order` 聚合不仅包含字段，还实现了业务逻辑，这可以通过状态机来描述。让我们看看状态机。
- en: The Order aggregate state machine
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Order` 聚合状态机'
- en: In order to create or update an order, `Order Service` must collaborate with
    other services using sagas. Either `OrderService` or the first step of the saga
    invokes an `Order` method that verifies that the operation can be performed and
    changes the state of the `Order` to a pending state. A *pending* state, as explained
    in [chapter 4](kindle_split_012.xhtml#ch04), is an example of a semantic lock
    countermeasure, which helps ensure that sagas are isolated from one another. Eventually,
    once the saga has invoked the participating services, it then updates the `Order`
    to reflect the outcome. For example, as described in [chapter 4](kindle_split_012.xhtml#ch04),
    the `Create Order Saga` has multiple participant services, including `Consumer
    Service`, `Accounting Service`, and `Kitchen Service`. `OrderService` first creates
    an `Order` in an `APPROVAL_PENDING` state, and then later changes its state to
    either `APPROVED` or `REJECTED`. The behavior of an `Order` can be modeled as
    the state machine shown in [figure 5.14](#ch05fig14).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建或更新订单，`Order Service` 必须与其他服务协作使用 sagas。要么 `OrderService` 或 saga 的第一步调用一个
    `Order` 方法来验证操作是否可以执行，并将 `Order` 的状态更改为待处理状态。正如 [第 4 章](kindle_split_012.xhtml#ch04)
    中解释的，*待处理* 状态是语义锁对策的一个例子，有助于确保 sagas 之间相互隔离。最终，一旦 saga 调用了参与的服务，它就会更新 `Order`
    以反映结果。例如，正如 [第 4 章](kindle_split_012.xhtml#ch04) 中描述的，`Create Order Saga` 有多个参与服务，包括
    `Consumer Service`、`Accounting Service` 和 `Kitchen Service`。`OrderService` 首先以
    `APPROVAL_PENDING` 状态创建一个 `Order`，然后稍后将其状态更改为 `APPROVED` 或 `REJECTED`。`Order`
    的行为可以建模为 [图 5.14](#ch05fig14) 中所示的状态机。
- en: Figure 5.14\. Part of the state machine model of the `Order` aggregate
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.14\. `Order` 聚合状态机模型的一部分
- en: '![](Images/05fig14_alt.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig14_alt.jpg)'
- en: Similarly, other `Order Service` operations such as `revise()` and `cancel()`
    first change the `Order` to a pending state and use a saga to verify that the
    operation can be performed. Then, once the saga has verified that the operation
    can be performed, it changes the `Order` transitions to some other state that
    reflects the successful outcome of the operation. If the verification of the operation
    fails, the `Order` reverts to the previous state. For example, the `cancel()`
    operation first transitions the `Order` to the `CANCEL_PENDING` state. If the
    order can be cancelled, the `Cancel Order Saga` changes the state of the `Order`
    to the `CANCELLED` state. Otherwise, if a `cancel()` operation is rejected because,
    for example, it’s too late to cancel the order, then the `Order` transitions back
    to the `APPROVED` state.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，其他 `Order Service` 操作，如 `revise()` 和 `cancel()`，首先将 `Order` 改为挂起状态，并使用 saga
    来验证操作是否可以执行。一旦 saga 验证操作可以执行，它将 `Order` 转换为反映操作成功结果的其他状态。如果操作验证失败，`Order` 将恢复到之前的状态。例如，`cancel()`
    操作首先将 `Order` 转换为 `CANCEL_PENDING` 状态。如果订单可以被取消，`Cancel Order Saga` 将 `Order`
    的状态改为 `CANCELLED` 状态。否则，如果由于例如取消订单太晚等原因，`cancel()` 操作被拒绝，那么 `Order` 将转换回 `APPROVED`
    状态。
- en: Let’s now look at the how the `Order` aggregate implements this state machine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `Order` 聚合是如何实现这个状态机的。
- en: The Order aggregate’s methods
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Order` 聚合的方法'
- en: The `Order` class has several groups of methods, each of which corresponds to
    a saga. In each group, one method is invoked at the start of the saga, and the
    other methods are invoked at the end. I’ll first discuss the business logic that
    creates an `Order`. After that we’ll look at how an `Order` is updated. The following
    listing shows the `Order`’s methods that are invoked during the process of creating
    an `Order`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 类有多个方法组，每个组对应一个 saga。在每个组中，一个方法在 saga 的开始时被调用，其他方法在 saga 的结束时被调用。我首先将讨论创建
    `Order` 的业务逻辑。之后，我们将看看如何更新 `Order`。以下列表显示了在创建 `Order` 的过程中被调用的 `Order` 的方法。'
- en: Listing 5.15\. The methods that are invoked during order creation
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. 订单创建过程中调用的方法
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `createOrder()` method is a static factory method that creates an Order
    and publishes an `OrderCreatedEvent`. The `OrderCreatedEvent` is enriched with
    the details of the `Order`, including the line items, the total amount, the restaurant
    ID, and the restaurant name. [Chapter 7](kindle_split_015.xhtml#ch07) discusses
    how `Order History Service` uses `Order` events, including `OrderCreatedEvent`,
    to maintain an easily queried replica of `Orders`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`createOrder()` 方法是一个静态工厂方法，用于创建一个订单并发布一个 `OrderCreatedEvent`。`OrderCreatedEvent`
    包含了订单的详细信息，包括行项目、总金额、餐厅 ID 和餐厅名称。[第 7 章](kindle_split_015.xhtml#ch07) 讨论了 `Order
    History Service` 如何使用 `Order` 事件，包括 `OrderCreatedEvent`，来维护一个易于查询的 `Orders` 复制品。'
- en: The initial state of the `Order` is `APPROVAL_PENDING`. When the `CreateOrderSaga`
    completes, it will invoke either `noteApproved()` or `noteRejected()`. The `noteApproved()`
    method is invoked when the consumer’s credit card has been successfully authorized.
    The `noteRejected()` method is called when one of the services rejects the order
    or authorization fails. As you can see, the `state` of the `Order` aggregate determines
    the behavior of most of its methods. Like the `Ticket` aggregate, it also emits
    events.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order` 的初始状态为 `APPROVAL_PENDING`。当 `CreateOrderSaga` 完成时，它将调用 `noteApproved()`
    或 `noteRejected()` 中的一个。当消费者的信用卡成功授权时，将调用 `noteApproved()` 方法。当其中一个服务拒绝订单或授权失败时，将调用
    `noteRejected()` 方法。正如你所见，`Order` 聚合的 `state` 决定了其大多数方法的行为。像 `Ticket` 聚合一样，它也会发出事件。'
- en: In addition to `createOrder()`, the `Order` class defines several update methods.
    For example, the `Revise Order Saga` revises an order by first invoking the `revise()`
    method and then, once it’s verified that the revision can be made, it invokes
    the `confirmRevised()` method. The following listing shows these methods.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `createOrder()`，`Order` 类还定义了几个更新方法。例如，`Revise Order Saga` 通过首先调用 `revise()`
    方法，然后验证修订可以执行后，再调用 `confirmRevised()` 方法来修改订单。以下列表显示了这些方法。
- en: Listing 5.16\. The `Order` method for revising an `Order`
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. 修改 `Order` 的 `Order` 方法
- en: '[PRE19]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `revise()` method is called to initiate the revision of an order. Among
    other things, it verifies that the revised order won’t violate the order minimum
    and changes the state of the order to `REVISION_PENDING`. Once `Revise Order Saga`
    has successfully updated `Kitchen Service` and `Accounting Service`, it then calls
    `confirmRevision()` to complete the revision.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`revise()`方法来启动订单的修订。除了其他事情之外，它验证修订的订单不会违反订单最低限额，并将订单的状态更改为`REVISION_PENDING`。一旦`Revise
    Order Saga`成功更新了`Kitchen Service`和`Accounting Service`，它随后调用`confirmRevision()`来完成修订。
- en: These methods are invoked by `OrderService`. Let’s take a look at that class.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法由`OrderService`调用。让我们看看那个类。
- en: 5.5.2\. The OrderService class
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. `OrderService`类
- en: The `OrderService` class defines methods for creating and updating `Orders`.
    It’s the main entry point into the business logic and is invoked by various inbound
    adapters, such as the `REST API`. Most of its methods create a saga to orchestrate
    the creation and updating of `Order` aggregates. As a result, this service is
    more complicated than the `KitchenService` class discussed earlier. The following
    listing shows an excerpt of this class. `OrderService` is injected with various
    dependencies, including `OrderRepository`, `OrderDomainEventPublisher`, and several
    saga managers. It defines several methods, including `createOrder()` and `reviseOrder()`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderService`类定义了创建和更新`Orders`的方法。它是进入业务逻辑的主要入口点，并由各种传入适配器调用，例如`REST API`。它的大多数方法创建一个传奇来编排`Order`聚合的创建和更新。因此，这个服务比之前讨论的`KitchenService`类更复杂。以下列表显示了该类的摘录。`OrderService`被注入了各种依赖项，包括`OrderRepository`、`OrderDomainEventPublisher`和几个传奇管理器。它定义了包括`createOrder()`和`reviseOrder()`在内的几个方法。'
- en: Listing 5.17\. The `OrderService` class has methods for creating and managing
    orders
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.17\. `OrderService`类具有创建和管理订单的方法
- en: '[PRE20]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Creates the Order aggregate**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建订单聚合**'
- en: '***2* Persists the Order in the database**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在数据库中持久化订单**'
- en: '***3* Publishes domain events**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发布领域事件**'
- en: '***4* Creates the Create Order Saga**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建创建订单传奇**'
- en: '***5* Retrieves the Order**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取订单**'
- en: '***6* Creates the Revise Order Saga**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 创建修订订单传奇**'
- en: The `createOrder()` method first creates and persists an `Order` aggregate.
    It then publishes the domain events emitted by the aggregate. Finally, it creates
    a `CreateOrderSaga`. The `reviseOrder()` retrieves the `Order` and then creates
    a `ReviseOrderSaga`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`createOrder()`方法首先创建和持久化`Order`聚合。然后，它发布由聚合发出的领域事件。最后，它创建一个`CreateOrderSaga`。`reviseOrder()`检索`Order`然后创建一个`ReviseOrderSaga`。'
- en: In many ways, the business logic for a microservices-based application is not
    that different from that of a monolithic application. It’s comprised of classes
    such as services, JPA-backed entities, and repositories. There are some differences,
    though. A domain model is organized as a set of DDD aggregates that impose various
    design constraints. Unlike in a traditional object model, references between classes
    in different aggregates are in terms of primary key value rather than object references.
    Also, a transaction can only create or update a single aggregate. It’s also useful
    for aggregates to publish domain events when their state changes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，基于微服务的应用程序的业务逻辑与传统单体应用程序的业务逻辑并没有太大的不同。它由服务、JPA支持的实体和存储库等类组成。尽管如此，也有一些不同之处。领域模型组织为一系列DDD聚合，这些聚合施加了各种设计约束。与传统对象模型不同，不同聚合之间类的引用是主键值而不是对象引用。此外，事务只能创建或更新单个聚合。当聚合的状态发生变化时，发布领域事件对聚合也很有用。
- en: Another major difference is that services often use sagas to maintain data consistency
    across multiple services. For example, `Kitchen Service` merely participates in
    sagas, it doesn’t initiate them. In contrast, `Order Service` relies heavily on
    sagas when creating and updating orders. That’s because `Orders` must be transactionally
    consistent with data owned by other services. As a result, most `OrderService`
    methods create a saga rather than update an `Order` directly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要区别是，服务通常使用传奇（sagas）来维护多个服务之间的数据一致性。例如，`Kitchen Service` 仅参与传奇，它不会启动它们。相比之下，`Order
    Service` 在创建和更新订单时严重依赖传奇。这是因为`Orders`必须与属于其他服务的数据进行事务一致性。因此，大多数`OrderService`方法创建一个传奇而不是直接更新`Order`。
- en: This chapter has covered how to implement business logic using a traditional
    approach to persistence. That has involved integrating messaging and event publishing
    with database transaction management. The event publishing code is intertwined
    with the business logic. The next chapter looks at event sourcing, an event-centric
    approach to writing business logic where event generation is integral to the business
    logic rather than being bolted on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用传统的持久化方法来实现业务逻辑。这包括将消息传递和事件发布与数据库事务管理集成。事件发布代码与业务逻辑交织在一起。下一章将探讨事件溯源，这是一种以事件为中心的方法来编写业务逻辑，其中事件生成是业务逻辑的组成部分，而不是附加的。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The procedural Transaction script pattern is often a good way to implement simple
    business logic. But when implementing complex business logic you should consider
    using the object-oriented Domain model pattern.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序性事务脚本模式通常是实现简单业务逻辑的好方法。但在实现复杂业务逻辑时，应考虑使用面向对象的领域模型模式。
- en: A good way to organize a service’s business logic is as a collection of DDD
    aggregates. DDD aggregates are useful because they modularize the domain model,
    eliminate the possibility of object reference between services, and ensure that
    each ACID transaction is within a service.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务业务逻辑组织为DDD聚合集合是一个好方法。DDD聚合很有用，因为它们模块化了领域模型，消除了服务之间对象引用的可能性，并确保每个ACID事务都在服务内部。
- en: An aggregate should publish domain events when it’s created or updated. Domain
    events have a wide variety of uses. [Chapter 4](kindle_split_012.xhtml#ch04) discusses
    how they can implement choreography-based sagas. And, in [chapter 7](kindle_split_015.xhtml#ch07),
    I talk about how to use domain events to update replicated data. Domain event
    subscribers can also notify users and other applications, and publish WebSocket
    messages to a user’s browser.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当聚合创建或更新时，应该发布领域事件。领域事件有广泛的应用。[第4章](kindle_split_012.xhtml#ch04)讨论了它们如何实现基于编排的叙事。在[第7章](kindle_split_015.xhtml#ch07)中，我谈论了如何使用领域事件来更新复制数据。领域事件订阅者还可以通知用户和其他应用程序，并向用户的浏览器发布WebSocket消息。
