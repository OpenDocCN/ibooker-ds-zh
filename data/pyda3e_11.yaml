- en: '8  Data Wrangling: Join, Combine, and Reshape'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 数据整理：连接、合并和重塑
- en: 原文：[https://wesmckinney.com/book/data-wrangling](https://wesmckinney.com/book/data-wrangling)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://wesmckinney.com/book/data-wrangling](https://wesmckinney.com/book/data-wrangling)
- en: '*This Open Access web version of *Python for Data Analysis 3rd Edition* is
    now available as a companion to the [print and digital editions](https://amzn.to/3DyLaJc).
    If you encounter any errata, [please report them here](https://oreilly.com/catalog/0636920519829/errata).
    Please note that some aspects of this site as produced by Quarto will differ from
    the formatting of the print and eBook versions from O’Reilly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python for Data Analysis第3版*的这个开放访问网络版本现在作为[印刷版和数字版](https://amzn.to/3DyLaJc)的伴侣提供。如果您发现任何勘误，请[在此报告](https://oreilly.com/catalog/0636920519829/errata)。请注意，由Quarto制作的本站某些方面将与O’Reilly的印刷版和电子书版本的格式不同。'
- en: If you find the online edition of the book useful, please consider [ordering
    a paper copy](https://amzn.to/3DyLaJc) or a [DRM-free eBook](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)
    to support the author. The content from this website may not be copied or reproduced.
    The code examples are MIT licensed and can be found on GitHub or Gitee.*  *In
    many applications, data may be spread across a number of files or databases, or
    be arranged in a form that is not convenient to analyze. This chapter focuses
    on tools to help combine, join, and rearrange data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现本书的在线版本有用，请考虑[订购纸质副本](https://amzn.to/3DyLaJc)或[无DRM的电子书](https://www.ebooks.com/en-us/book/210644288/python-for-data-analysis/wes-mckinney/?affId=WES398681F)以支持作者。本网站的内容不得复制或复制。代码示例采用MIT许可证，可在GitHub或Gitee上找到。*
    *在许多应用程序中，数据可能分布在许多文件或数据库中，或者以不便于分析的形式排列。本章重点介绍帮助组合、连接和重新排列数据的工具。
- en: 'First, I introduce the concept of *hierarchical indexing* in pandas, which
    is used extensively in some of these operations. I then dig into the particular
    data manipulations. You can see various applied usages of these tools in [Ch 13:
    Data Analysis Examples](#data-analysis-examples).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我介绍了pandas中*层次索引*的概念，这在某些操作中被广泛使用。然后我深入研究了特定的数据操作。您可以在[第13章：数据分析示例](#data-analysis-examples)中看到这些工具的各种应用用法。
- en: 8.1 Hierarchical Indexing
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 层次索引
- en: '*Hierarchical indexing* is an important feature of pandas that enables you
    to have multiple (two or more) index *levels* on an axis. Another way of thinking
    about it is that it provides a way for you to work with higher dimensional data
    in a lower dimensional form. Let’s start with a simple example: create a Series
    with a list of lists (or arrays) as the index:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*层次索引*是pandas的一个重要特性，它使您能够在轴上具有多个（两个或更多）索引*级别*。另一种思考方式是，它为您提供了一种以较低维度形式处理较高维度数据的方法。让我们从一个简单的示例开始：创建一个Series，其索引为列表的列表（或数组）：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What you’re seeing is a prettified view of a Series with a `MultiIndex` as
    its index. The “gaps” in the index display mean “use the label directly above”:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的是一个带有`MultiIndex`作为索引的Series的美化视图。索引显示中的“间隙”表示“使用直接上面的标签”：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With a hierarchically indexed object, so-called *partial* indexing is possible,
    enabling you to concisely select subsets of the data:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有层次索引的对象，可以进行所谓的*部分*索引，使您能够简洁地选择数据的子集：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Selection is even possible from an “inner” level. Here I select all of the
    values having the value `2` from the second index level:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以从“内部”级别进行选择。在这里，我从第二个索引级别选择所有具有值`2`的值：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hierarchical indexing plays an important role in reshaping data and in group-based
    operations like forming a pivot table. For example, you can rearrange this data
    into a DataFrame using its `unstack` method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 层次索引在重塑数据和基于组的操作（如形成数据透视表）中发挥着重要作用。例如，您可以使用其`unstack`方法将这些数据重新排列为DataFrame：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The inverse operation of `unstack` is `stack`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`unstack`的逆操作是`stack`：'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`stack` and `unstack` will be explored in more detail later in [Reshaping and
    Pivoting](#prep_reshape).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack`和`unstack`将在[重塑和透视](#prep_reshape)中更详细地探讨。'
- en: 'With a DataFrame, either axis can have a hierarchical index:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，任一轴都可以具有分层索引：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The hierarchical levels can have names (as strings or any Python objects).
    If so, these will show up in the console output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 层次级别可以有名称（作为字符串或任何Python对象）。如果有的话，这些名称将显示在控制台输出中：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These names supersede the `name` attribute, which is used only with single-level
    indexes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称取代了仅用于单级索引的`name`属性。
- en: '*Caution* *Be careful to note that the index names `"state"` and `"color"`
    are not part of the row labels (the `frame.index` values).*  *You can see how
    many levels an index has by accessing its `nlevels` attribute:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *请注意，索引名称`"state"`和`"color"`不是行标签（`frame.index`值）的一部分。* *您可以通过访问其`nlevels`属性来查看索引具有多少级别：'
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With partial column indexing you can similarly select groups of columns:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部分列索引，您也可以类似地选择列组：
- en: '[PRE9]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A `MultiIndex` can be created by itself and then reused; the columns in the
    preceding DataFrame with level names could also be created like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex`可以单独创建，然后重复使用；具有级别名称的前述DataFrame中的列也可以这样创建：'
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Reordering and Sorting Levels
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排序和排序级别
- en: 'At times you may need to rearrange the order of the levels on an axis or sort
    the data by the values in one specific level. The `swaplevel` method takes two
    level numbers or names and returns a new object with the levels interchanged (but
    the data is otherwise unaltered):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要重新排列轴上级别的顺序或按特定级别的值对数据进行排序。`swaplevel`方法接受两个级别编号或名称，并返回一个级别互换的新对象（但数据本身不变）：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`sort_index` by default sorts the data lexicographically using all the index
    levels, but you can choose to use only a single level or a subset of levels to
    sort by passing the `level` argument. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort_index`默认按所有索引级别词典顺序对数据进行排序，但您可以选择通过传递`level`参数仅使用单个级别或一组级别进行排序。例如：'
- en: '[PRE12]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Note* *Data selection performance is much better on hierarchically indexed
    objects if the index is lexicographically sorted starting with the outermost level—that
    is, the result of calling `sort_index(level=0)` or `sort_index()`.*  *### Summary
    Statistics by Level'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *如果索引按字典顺序排序，从最外层级别开始，那么在具有分层索引的对象上进行数据选择性能要好得多——也就是说，调用`sort_index(level=0)`或`sort_index()`的结果。*  *###
    按级别汇总统计'
- en: 'Many descriptive and summary statistics on DataFrame and Series have a `level`
    option in which you can specify the level you want to aggregate by on a particular
    axis. Consider the above DataFrame; we can aggregate by level on either the rows
    or columns, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame和Series上的许多描述性和汇总统计信息具有`level`选项，您可以在特定轴上指定要按级别聚合的级别。考虑上面的DataFrame；我们可以按行或列的级别进行聚合，如下所示：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will discuss `groupby` in much more detail later in [Ch 10: Data Aggregation
    and Group Operations](/book/data-aggregation).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章：数据聚合和分组操作](/book/data-aggregation)中更详细地讨论`groupby`。
- en: Indexing with a DataFrame's columns
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DataFrame的列进行索引
- en: 'It’s not unusual to want to use one or more columns from a DataFrame as the
    row index; alternatively, you may wish to move the row index into the DataFrame’s
    columns. Here’s an example DataFrame:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 希望使用一个或多个DataFrame列作为行索引并不罕见；或者，您可能希望将行索引移入DataFrame的列中。这是一个示例DataFrame：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'DataFrame’s `set_index` function will create a new DataFrame using one or more
    of its columns as the index:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame的`set_index`函数将使用一个或多个列作为索引创建一个新的DataFrame：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By default, the columns are removed from the DataFrame, though you can leave
    them in by passing `drop=False` to `set_index`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，列会从DataFrame中移除，但您可以通过向`set_index`传递`drop=False`来保留它们：
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`reset_index`, on the other hand, does the opposite of `set_index`; the hierarchical
    index levels are moved into the columns:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`reset_index`的作用与`set_index`相反；层次化索引级别被移动到列中：
- en: '[PRE17]**  **## 8.2 Combining and Merging Datasets'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]**  **## 8.2 合并和组合数据集'
- en: 'Data contained in pandas objects can be combined in a number of ways:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: pandas对象中包含的数据可以以多种方式组合：
- en: '`pandas.merge`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.merge`'
- en: Connect rows in DataFrames based on one or more keys. This will be familiar
    to users of SQL or other relational databases, as it implements database *join*
    operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基于一个或多个键连接DataFrame中的行。这将为使用SQL或其他关系数据库的用户提供熟悉的操作，因为它实现了数据库*join*操作。
- en: '`pandas.concat`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.concat`'
- en: Concatenate or "stack" objects together along an axis.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 沿轴连接或“堆叠”对象。
- en: '`combine_first`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`combine_first`'
- en: Splice together overlapping data to fill in missing values in one object with
    values from another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将重叠数据拼接在一起，用另一个对象中的值填充另一个对象中的缺失值。
- en: I will address each of these and give a number of examples. They’ll be utilized
    in examples throughout the rest of the book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐个讨论这些并给出一些示例。它们将在本书的其余部分的示例中使用。
- en: Database-Style DataFrame Joins
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库风格的DataFrame连接
- en: '*Merge* or *join* operations combine datasets by linking rows using one or
    more *keys*. These operations are particularly important in relational databases
    (e.g., SQL-based). The `pandas.merge` function in pandas is the main entry point
    for using these algorithms on your data.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*合并*或*连接*操作通过使用一个或多个*键*链接行来合并数据集。这些操作在关系数据库（例如基于SQL的数据库）中尤为重要。pandas中的`pandas.merge`函数是使用这些算法在您的数据上的主要入口点。'
- en: 'Let’s start with a simple example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here I am using pandas''s `Int64` extension type for nullable integers, discussed
    in [Ch 7.3: Extension Data Types](/book/data-cleaning#pandas-ext-types).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用pandas的`Int64`扩展类型来表示可空整数，详细讨论请参见[第7.3章：扩展数据类型](/book/data-cleaning#pandas-ext-types)。
- en: 'This is an example of a *many-to-one* join; the data in `df1` has multiple
    rows labeled `a` and `b`, whereas `df2` has only one row for each value in the
    `key` column. Calling `pandas.merge` with these objects, we obtain:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*多对一*连接的示例；`df1`中的数据有多行标记为`a`和`b`，而`df2`中的每个值在`key`列中只有一行。使用这些对象调用`pandas.merge`，我们得到：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that I didn’t specify which column to join on. If that information is
    not specified, `pandas.merge` uses the overlapping column names as the keys. It’s
    a good practice to specify explicitly, though:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我没有指定要连接的列。如果没有指定该信息，`pandas.merge`将使用重叠的列名作为键。不过，最好明确指定：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In general, the order of column output in `pandas.merge` operations is unspecified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在`pandas.merge`操作中，列的输出顺序是不确定的。
- en: 'If the column names are different in each object, you can specify them separately:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个对象中的列名不同，您可以分别指定它们：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may notice that the `"c"` and `"d"` values and associated data are missing
    from the result. By default, `pandas.merge` does an `"inner"` join; the keys in
    the result are the intersection, or the common set found in both tables. Other
    possible options are `"left"`, `"right"`, and `"outer"`. The outer join takes
    the union of the keys, combining the effect of applying both left and right joins:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到结果中缺少`"c"`和`"d"`值及其相关数据。默认情况下，`pandas.merge`执行的是`"inner"`连接；结果中的键是交集，或者是在两个表中都找到的公共集合。其他可能的选项是`"left"`、`"right"`和`"outer"`。外连接取键的并集，结合了应用左连接和右连接的效果：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In an outer join, rows from the left or right DataFrame objects that do not
    match on keys in the other DataFrame will appear with NA values in the other DataFrame's
    columns for the nonmatching rows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在外连接中，左侧或右侧DataFrame对象中与另一个DataFrame中的键不匹配的行将在另一个DataFrame的列中出现NA值。
- en: See [Table 8.1](#tbl-table_merge_how_behavior) for a summary of the options
    for `how`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[表 8.1](#tbl-table_merge_how_behavior)以获取`how`选项的摘要。
- en: 'Table 8.1: Different join types with the `how` argument'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1：使用`how`参数的不同连接类型
- en: '| Option | Behavior |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 行为 |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `how="inner"` | Use only the key combinations observed in both tables |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `how="inner"` | 仅使用在两个表中观察到的键组合 |'
- en: '| `how="left"` | Use all key combinations found in the left table |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `how="left"` | 使用在左表中找到的所有键组合 |'
- en: '| `how="right"` | Use all key combinations found in the right table |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `how="right"` | 使用在右表中找到的所有键组合 |'
- en: '| `how="outer"` | Use all key combinations observed in both tables together
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `how="outer"` | 使用两个表中观察到的所有键组合 |'
- en: '*Many-to-many* merges form the Cartesian product of the matching keys. Here’s
    an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*多对多* 合并形成匹配键的笛卡尔积。以下是一个示例：'
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since there were three `"b"` rows in the left DataFrame and two in the right
    one, there are six `"b"` rows in the result. The join method passed to the `how`
    keyword argument affects only the distinct key values appearing in the result:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于左侧DataFrame中有三行`"b"`，右侧DataFrame中有两行`"b"`，因此结果中有六行`"b"`。传递给`how`关键字参数的连接方法仅影响结果中出现的不同键值：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To merge with multiple keys, pass a list of column names:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用多个键进行合并，请传递列名列表：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To determine which key combinations will appear in the result depending on the
    choice of merge method, think of the multiple keys as forming an array of tuples
    to be used as a single join key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定根据合并方法的选择将出现在结果中的哪些键组合，请将多个键视为形成元组数组，用作单个连接键。
- en: '*Caution* *When you''re joining columns on columns, the indexes on the passed
    DataFrame objects are discarded. If you need to preserve the index values, you
    can use `reset_index` to append the index to the columns.*  *A last issue to consider
    in merge operations is the treatment of overlapping column names. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *当您在列上进行列连接时，传递的DataFrame对象的索引会被丢弃。如果需要保留索引值，可以使用`reset_index`将索引附加到列中。*
    *合并操作中要考虑的最后一个问题是处理重叠列名的方式。例如：'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'While you can address the overlap manually (see the section [Ch 7.2.4: Renaming
    Axis Indexes](/book/data-cleaning#prep_renaming) for renaming axis labels), `pandas.merge`
    has a `suffixes` option for specifying strings to append to overlapping names
    in the left and right DataFrame objects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以手动处理重叠（请参阅[Ch 7.2.4：重命名轴索引](/book/data-cleaning#prep_renaming)部分以重命名轴标签），`pandas.merge`具有一个`suffixes`选项，用于指定要附加到左侧和右侧DataFrame对象中重叠名称的字符串：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See [Table 8.2](#tbl-table_merge_function) for an argument reference on `pandas.merge`.
    The next section covers joining using the DataFrame's row index.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[pandas.merge](#tbl-table_merge_function)中的表8.2，了解有关参数的参考。下一节将介绍使用DataFrame的行索引进行连接。
- en: 'Table 8.2: `pandas.merge` function arguments'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2：`pandas.merge`函数参数
- en: '| Argument | Description |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `left` | DataFrame to be merged on the left side. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `left` | 要在左侧合并的DataFrame。 |'
- en: '| `right` | DataFrame to be merged on the right side. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `right` | 要在右侧合并的DataFrame。 |'
- en: '| `how` | Type of join to apply: one of `"inner"`, `"outer"`, `"left"`, or
    `"right"`; defaults to `"inner"`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `how` | 要应用的连接类型：`"inner"`、`"outer"`、`"left"`或`"right"`之一；默认为`"inner"`。 |'
- en: '| `on` | Column names to join on. Must be found in both DataFrame objects.
    If not specified and no other join keys given, will use the intersection of the
    column names in `left` and `right` as the join keys. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `on` | 要连接的列名。必须在两个DataFrame对象中找到。如果未指定并且没有给出其他连接键，则将使用`left`和`right`中的列名的交集作为连接键。
    |'
- en: '| `left_on` | Columns in `left` DataFrame to use as join keys. Can be a single
    column name or a list of column names. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `left_on` | 用作连接键的`left` DataFrame中的列。可以是单个列名或列名列表。 |'
- en: '| `right_on` | Analogous to `left_on` for `right` DataFrame. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `right_on` | 与`right` DataFrame的`left_on`类似。 |'
- en: '| `left_index` | Use row index in `left` as its join key (or keys, if a `MultiIndex`).
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `left_index` | 使用`left`中的行索引作为其连接键（或键，如果是`MultiIndex`）。 |'
- en: '| `right_index` | Analogous to `left_index`. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `right_index` | 与`left_index`类似。 |'
- en: '| `sort` | Sort merged data lexicographically by join keys; `False` by default.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 按连接键按字典顺序对合并数据进行排序；默认为`False`。 |'
- en: '| `suffixes` | Tuple of string values to append to column names in case of
    overlap; defaults to `("_x", "_y")` (e.g., if `"data"` in both DataFrame objects,
    would appear as `"data_x"` and `"data_y"` in result). |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `suffixes` | 字符串元组值，用于在重叠的列名后追加（默认为`("_x", "_y")`，例如，如果两个DataFrame对象中都有`"data"`，则在结果中会显示为`"data_x"`和`"data_y"`。
    |'
- en: '| `copy` | If `False`, avoid copying data into resulting data structure in
    some exceptional cases; by default always copies. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | 如果为`False`，则在某些特殊情况下避免将数据复制到结果数据结构中；默认情况下始终复制。 |'
- en: '| `validate` | Verifies if the merge is of the specified type, whether one-to-one,
    one-to-many, or many-to-many. See the docstring for full details on the options.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `validate` | 验证合并是否是指定类型，一对一、一对多或多对多。有关选项的完整详细信息，请参阅文档字符串。 |'
- en: '| `indicator` | Adds a special column `_merge` that indicates the source of
    each row; values will be `"left_only"`, `"right_only"`, or `"both"` based on the
    origin of the joined data in each row. |*  *### Merging on Index'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '| `indicator` | 添加一个特殊列`_merge`，指示每行的来源；值将根据每行中连接数据的来源为`"left_only"`、`"right_only"`或`"both"`。*  *###
    在索引上合并'
- en: 'In some cases, the merge key(s) in a DataFrame will be found in its index (row
    labels). In this case, you can pass `left_index=True` or `right_index=True` (or
    both) to indicate that the index should be used as the merge key:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，DataFrame中的合并键会在其索引（行标签）中找到。在这种情况下，您可以传递`left_index=True`或`right_index=True`（或两者都传递）来指示索引应该用作合并键：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Note* *If you look carefully here, you will see that the index values for
    `left1` have been preserved, whereas in other examples above, the indexes of the
    input DataFrame objects are dropped. Because the index of `right1` is unique,
    this "many-to-one" merge (with the default `how="inner"` method) can preserve
    the index values from `left1` that correspond to rows in the output.*  *Since
    the default merge method is to intersect the join keys, you can instead form the
    union of them with an outer join:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* *如果您仔细观察这里，您会发现`left1`的索引值已被保留，而在上面的其他示例中，输入DataFrame对象的索引已被丢弃。由于`right1`的索引是唯一的，这种“一对多”合并（使用默认的`how="inner"`方法）可以保留与输出中的行对应的`left1`的索引值。*
    *由于默认合并方法是交集连接键，您可以使用外连接来形成它们的并集：'
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With hierarchically indexed data, things are more complicated, as joining on
    index is equivalent to a multiple-key merge:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有分层索引的数据，情况会更加复杂，因为在索引上进行连接等效于多键合并：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this case, you have to indicate multiple columns to merge on as a list (note
    the handling of duplicate index values with `how="outer"`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您必须指示要合并的多个列作为列表（注意使用`how="outer"`处理重复索引值）：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the indexes of both sides of the merge is also possible:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用合并的两侧的索引也是可能的：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'DataFrame has a `join` instance method to simplify merging by index. It can
    also be used to combine many DataFrame objects having the same or similar indexes
    but nonoverlapping columns. In the prior example, we could have written:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame有一个`join`实例方法，可以简化按索引合并。它还可以用于合并许多具有相同或类似索引但列不重叠的DataFrame对象。在前面的例子中，我们可以这样写：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Compared with `pandas.merge`, DataFrame’s `join` method performs a left join
    on the join keys by default. It also supports joining the index of the passed
    DataFrame on one of the columns of the calling DataFrame:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pandas.merge`相比，DataFrame的`join`方法默认在连接键上执行左连接。它还支持将传递的DataFrame的索引与调用DataFrame的某一列进行连接：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can think of this method as joining data "into" the object whose `join`
    method was called.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此方法视为将数据“合并”到调用其`join`方法的对象中。
- en: 'Lastly, for simple index-on-index merges, you can pass a list of DataFrames
    to `join` as an alternative to using the more general `pandas.concat` function
    described in the next section:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于简单的索引对索引合并，您可以将DataFrame的列表传递给`join`，作为使用下一节中描述的更一般的`pandas.concat`函数的替代方法：
- en: '[PRE35]*  *### Concatenating Along an Axis'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]*  *### 沿轴连接'
- en: 'Another kind of data combination operation is referred to interchangeably as
    *concatenation* or *stacking*. NumPy''s `concatenate` function can do this with
    NumPy arrays:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种数据组合操作被称为*连接*或*堆叠*。NumPy的`concatenate`函数可以使用NumPy数组来执行此操作：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the context of pandas objects such as Series and DataFrame, having labeled
    axes enable you to further generalize array concatenation. In particular, you
    have a number of additional concerns:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas对象（如Series和DataFrame）的上下文中，具有标记轴使您能够进一步推广数组连接。特别是，您有许多额外的考虑：
- en: If the objects are indexed differently on the other axes, should we combine
    the distinct elements in these axes or use only the values in common?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象在其他轴上的索引不同，我们应该合并这些轴中的不同元素还是仅使用共同的值？
- en: Do the concatenated chunks of data need to be identifiable as such in the resulting
    object?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接的数据块在结果对象中需要被识别吗？
- en: Does the "concatenation axis" contain data that needs to be preserved? In many
    cases, the default integer labels in a DataFrame are best discarded during concatenation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “连接轴”中包含需要保留的数据吗？在许多情况下，DataFrame中的默认整数标签在连接时最好被丢弃。
- en: 'The `concat` function in pandas provides a consistent way to address each of
    these questions. I’ll give a number of examples to illustrate how it works. Suppose
    we have three Series with no index overlap:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: pandas中的`concat`函数提供了一种一致的方法来解决这些问题。我将给出一些示例来说明它是如何工作的。假设我们有三个没有索引重叠的Series：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Calling `pandas.concat` with these objects in a list glues together the values
    and indexes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些对象的列表调用`pandas.concat`会将值和索引粘合在一起：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By default, `pandas.concat` works along `axis="index"`, producing another Series.
    If you pass `axis="columns"`, the result will instead be a DataFrame:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pandas.concat`沿着`axis="index"`工作，产生另一个Series。如果传递`axis="columns"`，结果将是一个DataFrame：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case there is no overlap on the other axis, which as you can see is
    the union (the `"outer"` join) of the indexes. You can instead intersect them
    by passing `join="inner"`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，另一个轴上没有重叠，您可以看到这是索引的并集（“outer”连接）。您可以通过传递`join="inner"`来取交集：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this last example, the `"f"` and `"g"` labels disappeared because of the
    `join="inner"` option.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，“f”和“g”标签消失了，因为使用了`join="inner"`选项。
- en: 'A potential issue is that the concatenated pieces are not identifiable in the
    result. Suppose instead you wanted to create a hierarchical index on the concatenation
    axis. To do this, use the `keys` argument:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的问题是结果中无法识别连接的片段。假设您希望在连接轴上创建一个分层索引。为此，请使用`keys`参数：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the case of combining Series along `axis="columns"`, the `keys` become the
    DataFrame column headers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在沿`axis="columns"`组合Series的情况下，`keys`变成了DataFrame的列标题：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The same logic extends to DataFrame objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑也适用于DataFrame对象：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here the `keys` argument is used to create a hierarchical index where the first
    level can be used to identify each of the concatenated DataFrame objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`keys`参数用于创建一个分层索引，其中第一级可以用于标识每个连接的DataFrame对象。
- en: 'If you pass a dictionary of objects instead of a list, the dictionary’s keys
    will be used for the `keys` option:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您传递的是对象字典而不是列表，那么字典的键将用于`keys`选项：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are additional arguments governing how the hierarchical index is created
    (see [Table 8.3](#tbl-table_concat_function)). For example, we can name the created
    axis levels with the `names` argument:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的参数控制如何创建分层索引（参见[表 8.3](#tbl-table_concat_function)）。例如，我们可以使用`names`参数为创建的轴级别命名：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A last consideration concerns DataFrames in which the row index does not contain
    any relevant data:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个考虑因素涉及行索引不包含任何相关数据的DataFrame：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, you can pass `ignore_index=True`, which discards the indexes
    from each DataFrame and concatenates the data in the columns only, assigning a
    new default index:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以传递`ignore_index=True`，这将丢弃每个DataFrame的索引并仅连接列中的数据，分配一个新的默认索引：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[Table 8.3](#tbl-table_concat_function) describes the `pandas.concat` function
    arguments.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8.3](#tbl-table_concat_function)描述了`pandas.concat`函数的参数。'
- en: 'Table 8.3: `pandas.concat` function arguments'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3：`pandas.concat`函数参数
- en: '| Argument | Description |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `objs` | List or dictionary of pandas objects to be concatenated; this is
    the only required argument |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `objs` | 要连接的pandas对象的列表或字典；这是唯一必需的参数 |'
- en: '| `axis` | Axis to concatenate along; defaults to concatenating along rows
    (`axis="index"`) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `axis` | 要沿着连接的轴；默认为沿着行连接（`axis="index"`） |'
- en: '| `join` | Either `"inner"` or `"outer"` (`"outer"` by default); whether to
    intersect (inner) or union (outer) indexes along the other axes |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `join` | 要么是`"inner"`要么是`"outer"`（默认为`"outer"`）；是否沿着其他轴相交（inner）或联合（outer）索引
    |'
- en: '| `keys` | Values to associate with objects being concatenated, forming a hierarchical
    index along the concatenation axis; can be a list or array of arbitrary values,
    an array of tuples, or a list of arrays (if multiple-level arrays passed in `levels`)
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `keys` | 与要连接的对象关联的值，形成沿着连接轴的分层索引；可以是任意值的列表或数组，元组的数组，或数组的列表（如果在`levels`中传递了多级数组）
    |'
- en: '| `levels` | Specific indexes to use as hierarchical index level or levels
    if keys passed |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `levels` | 用作分层索引级别的特定索引，如果传递了键 |'
- en: '| `names` | Names for created hierarchical levels if `keys` and/or `levels`
    passed |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `names` | 如果传递了`keys`和/或`levels`，则为创建的分层级别命名 |'
- en: '| `verify_integrity` | Check new axis in concatenated object for duplicates
    and raise an exception if so; by default (`False`) allows duplicates |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `verify_integrity` | 检查连接对象中的新轴是否存在重复项，如果存在则引发异常；默认情况下（`False`）允许重复项 |'
- en: '| `ignore_index` | Do not preserve indexes along concatenation `axis`, instead
    produce a new `range(total_length)` index |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `ignore_index` | 不保留沿着连接`axis`的索引，而是生成一个新的`range(total_length)`索引 |'
- en: Combining Data with Overlap
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合具有重叠部分的数据
- en: 'There is another data combination situation that can’t be expressed as either
    a merge or concatenation operation. You may have two datasets with indexes that
    overlap in full or in part. As a motivating example, consider NumPy’s `where`
    function, which performs the array-oriented equivalent of an if-else expression:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种数据组合情况，既不能表示为合并操作也不能表示为连接操作。您可能有两个具有完全或部分重叠索引的数据集。作为一个激励性的例子，考虑NumPy的`where`函数，它执行数组导向的if-else表达式的等效操作：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, whenever values in `a` are null, values from `b` are selected, otherwise
    the non-null values from `a` are selected. Using `numpy.where` does not check
    whether the index labels are aligned or not (and does not even require the objects
    to be the same length), so if you want to line up values by index, use the Series
    `combine_first` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当`a`中的值为空时，将选择`b`中的值，否则将选择`a`中的非空值。使用`numpy.where`不会检查索引标签是否对齐（甚至不需要对象具有相同的长度），因此如果要按索引对齐值，请使用Series`combine_first`方法：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With DataFrames, `combine_first` does the same thing column by column, so you
    can think of it as “patching” missing data in the calling object with data from
    the object you pass:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，`combine_first`按列执行相同的操作，因此您可以将其视为使用传递的对象中的数据“修补”调用对象中的缺失数据：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output of `combine_first` with DataFrame objects will have the union of
    all the column names.**  **## 8.3 Reshaping and Pivoting
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame对象的`combine_first`的输出将具有所有列名称的并集。** **## 8.3 重塑和旋转
- en: There are a number of basic operations for rearranging tabular data. These are
    referred to as *reshape* or *pivot* operations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于重新排列表格数据的基本操作。这些操作被称为*重塑*或*旋转*操作。
- en: Reshaping with Hierarchical Indexing
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用分层索引进行重塑
- en: 'Hierarchical indexing provides a consistent way to rearrange data in a DataFrame.
    There are two primary actions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 分层索引提供了在DataFrame中重新排列数据的一致方法。有两个主要操作：
- en: '`stack`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack`'
- en: This “rotates” or pivots from the columns in the data to the rows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据中的列旋转或旋转到行。
- en: '`unstack`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`unstack`'
- en: This pivots from the rows into the columns.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从行旋转到列。
- en: 'I’ll illustrate these operations through a series of examples. Consider a small
    DataFrame with string arrays as row and column indexes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过一系列示例来说明这些操作。考虑一个具有字符串数组作为行和列索引的小DataFrame：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the `stack` method on this data pivots the columns into the rows, producing
    a Series:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些数据上使用`stack`方法将列旋转为行，生成一个Series：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'From a hierarchically indexed Series, you can rearrange the data back into
    a DataFrame with `unstack`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从具有分层索引的Series中，您可以使用`unstack`将数据重新排列回DataFrame：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By default, the innermost level is unstacked (same with `stack`). You can unstack
    a different level by passing a level number or name:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，最内层级别被取消堆叠（与`stack`相同）。您可以通过传递级别编号或名称来取消堆叠不同的级别：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Unstacking might introduce missing data if all of the values in the level aren’t
    found in each subgroup:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在每个子组中未找到级别中的所有值，则取消堆叠可能会引入缺失数据：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Stacking filters out missing data by default, so the operation is more easily
    invertible:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠默认会过滤掉缺失数据，因此该操作更容易反转：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When you unstack in a DataFrame, the level unstacked becomes the lowest level
    in the result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在DataFrame中取消堆叠时，取消堆叠的级别将成为结果中的最低级别：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As with `unstack`, when calling `stack` we can indicate the name of the axis
    to stack:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unstack`一样，调用`stack`时，我们可以指定要堆叠的轴的名称：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Pivoting “Long” to “Wide” Format
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将“长”格式旋转为“宽”格式
- en: A common way to store multiple time series in databases and CSV files is what
    is sometimes called *long* or *stacked* format. In this format, individual values
    are represented by a single row in a table rather than multiple values per row.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库和CSV文件中存储多个时间序列的常见方法有时被称为*长*或*堆叠*格式。在此格式中，单个值由表中的一行表示，而不是每行多个值。
- en: 'Let''s load some example data and do a small amount of time series wrangling
    and other data cleaning:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载一些示例数据，并进行少量时间序列整理和其他数据清理：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, I use `pandas.PeriodIndex` (which represents time intervals rather than
    points in time), discussed in more detail in [Ch 11: Time Series](/book/time-series),
    to combine the `year` and `quarter` columns to set the index to consist of `datetime`
    values at the end of each quarter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我使用`pandas.PeriodIndex`（表示时间间隔而不是时间点），在[Ch 11: Time Series](/book/time-series)中更详细地讨论，将`year`和`quarter`列组合起来，将索引设置为每个季度末的`datetime`值：'
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here I used the `pop` method on the DataFrame, which returns a column while
    deleting it from the DataFrame at the same time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在DataFrame上使用了`pop`方法，该方法返回一个列，同时从DataFrame中删除它。
- en: 'Then, I select a subset of columns and give the `columns` index the name `"item"`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我选择一部分列，并给`columns`索引命名为`"item"`：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Lastly, I reshape with `stack`, turn the new index levels into columns with
    `reset_index`, and finally give the column containing the data values the name
    `"value"`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我使用`stack`重新塑造，使用`reset_index`将新的索引级别转换为列，最后给包含数据值的列命名为“value”：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, `ldata` looks like:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ldata`看起来像这样：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this so-called *long* format for multiple time series, each row in the table
    represents a single observation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种所谓的*长*格式中，每个时间序列的每一行在表中代表一个单独的观察。
- en: 'Data is frequently stored this way in relational SQL databases, as a fixed
    schema (column names and data types) allows the number of distinct values in the
    `item` column to change as data is added to the table. In the previous example,
    `date` and `item` would usually be the primary keys (in relational database parlance),
    offering both relational integrity and easier joins. In some cases, the data may
    be more difficult to work with in this format; you might prefer to have a DataFrame
    containing one column per distinct `item` value indexed by timestamps in the `date`
    column. DataFrame’s `pivot` method performs exactly this transformation:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 数据经常以这种方式存储在关系型SQL数据库中，因为固定的模式（列名和数据类型）允许`item`列中的不同值的数量随着数据添加到表中而改变。在前面的例子中，`date`和`item`通常会成为主键（在关系数据库术语中），提供关系完整性和更容易的连接。在某些情况下，以这种格式处理数据可能更加困难；您可能更喜欢拥有一个DataFrame，其中包含一个以`date`列中的时间戳为索引的每个不同`item`值的列。DataFrame的`pivot`方法正好执行这种转换：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first two values passed are the columns to be used, respectively, as the
    row and column index, then finally an optional value column to fill the DataFrame.
    Suppose you had two value columns that you wanted to reshape simultaneously:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的前两个值分别是要使用的列，作为行和列索引，最后是一个可选的值列，用于填充DataFrame。假设您有两个值列，希望同时重塑：
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'By omitting the last argument, you obtain a DataFrame with hierarchical columns:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过省略最后一个参数，您可以获得一个具有分层列的DataFrame：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Note that `pivot` is equivalent to creating a hierarchical index using `set_index`
    followed by a call to `unstack`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pivot`等同于使用`set_index`创建一个分层索引，然后调用`unstack`：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Pivoting “Wide” to “Long” Format
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从“宽”格式到“长”格式的旋转
- en: 'An inverse operation to `pivot` for DataFrames is `pandas.melt`. Rather than
    transforming one column into many in a new DataFrame, it merges multiple columns
    into one, producing a DataFrame that is longer than the input. Let''s look at
    an example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame的`pivot`的逆操作是`pandas.melt`。与在新的DataFrame中将一个列转换为多个不同，它将多个列合并为一个，生成一个比输入更长的DataFrame。让我们看一个例子：
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `"key"` column may be a group indicator, and the other columns are data
    values. When using `pandas.melt`, we must indicate which columns (if any) are
    group indicators. Let''s use `"key"` as the only group indicator here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: “key”列可以是一个组指示器，其他列是数据值。在使用`pandas.melt`时，我们必须指示哪些列（如果有的话）是组指示器。让我们在这里只使用“key”作为唯一的组指示器：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using `pivot`, we can reshape back to the original layout:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pivot`，我们可以重新塑造回原始布局：
- en: '[PRE70]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Since the result of `pivot` creates an index from the column used as the row
    labels, we may want to use `reset_index` to move the data back into a column:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pivot`的结果从用作行标签的列创建索引，我们可能希望使用`reset_index`将数据移回到列中：
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can also specify a subset of columns to use as `value` columns:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定要用作“值”列的列的子集：
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`pandas.melt` can be used without any group identifiers, too:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.melt`也可以在没有任何组标识符的情况下使用：'
- en: '[PRE73]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 8.4 Conclusion
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 结论
- en: Now that you have some pandas basics for data import, cleaning, and reorganization
    under your belt, we are ready to move on to data visualization with matplotlib.
    We will return to explore other areas of pandas later in the book when we discuss
    more advanced analytics.*****
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了一些关于pandas的基础知识，用于数据导入、清理和重新组织，我们准备继续使用matplotlib进行数据可视化。当我们讨论更高级的分析时，我们将回到书中的其他领域来探索pandas的更多功能。*****
