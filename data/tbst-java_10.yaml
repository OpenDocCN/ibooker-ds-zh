- en: 8 Using advanced visualization tools for profiled data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 使用高级可视化工具分析剖析数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Detecting problems with connections to relational databases
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测与关系型数据库连接的问题
- en: Using call graphs to more quickly understand an app’s design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调用图更快地理解应用程序的设计
- en: Using flame graphs to more easily visualize an app’s execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用火焰图更轻松地可视化应用程序的执行
- en: Analyzing queries an app sends to a NoSQL database server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析应用程序发送到NoSQL数据库服务器的查询
- en: In this chapter, we discuss valuable techniques that can make life easier when
    investigating specific scenarios. We start the chapter by examining an approach
    for identifying connection problems between a Java app and a relational database
    server. We already discussed profiling SQL queries in chapter 7, but sometimes
    problems appear when an app establishes communication with a DBMS. Such situations
    can even lead to an app not responding at all, which makes finding the causes
    of such problems essential.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了一些有价值的技巧，这些技巧可以在调查特定场景时使生活变得更轻松。我们首先通过检查Java应用程序与关系型数据库服务器之间连接问题的方法来开始本章。我们在第7章中已经讨论了SQL查询的剖析，但有时当应用程序与DBMS建立通信时会出现问题。这种情况下，应用程序甚至可能完全无响应，因此找到这种问题的原因至关重要。
- en: In section 8.2, I’ll show you one of my favorite ways to understand the code
    behind a given execution scenario—a simple approach using call graphs, which are
    visual representations of the dependencies between an app’s objects. I find call
    graphs helpful, especially when dealing with messy code I’ve never seen before.
    And since I’m sure most developers have to deal with messy codebases at some point
    in their careers, knowing this approach will be helpful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.2节中，我将向您展示我最喜欢的理解给定执行场景背后代码的方法之一——使用调用图的一个简单方法，调用图是应用程序对象之间依赖关系的视觉表示。我发现调用图很有帮助，尤其是在处理我以前从未见过的混乱代码时。鉴于我相信大多数开发者在职业生涯的某个阶段都必须处理混乱的代码库，了解这种方法将是有帮助的。
- en: 'Chapter 7 discussed one of the most used ways to visualize an app’s execution—the
    execution stack. You learned how to generate an execution stack when sampling
    or profiling with VisualVM and how to use it to identify execution latencies.
    In section 8.3, we’ll use a different representation of the execution stack: a
    flame graph. Flame graphs are a way to visualize an app’s execution that focuses
    on both the executed code and the execution time. Viewing the same data from an
    additional perspective sometimes can help you to find what you’re searching for
    more easily. As you’ll learn in section 8.3, flame graphs offer you a different
    view of the app’s execution, which helps you to identify potential latencies and
    performance problems. In section 8.4, we’ll discuss techniques for analyzing how
    an app’s persistence layer works when it doesn’t use relational databases and
    instead uses different persistent approaches from what we call “the NoSQL family
    of technologies.”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '第7章讨论了可视化应用程序执行的最常用方法之一——执行栈。您学习了如何使用VisualVM进行采样或剖析时生成执行栈，以及如何使用它来识别执行延迟。在第8.3节中，我们将使用执行栈的不同表示：火焰图。火焰图是一种可视化应用程序执行的方法，它侧重于执行代码和执行时间。从额外的角度查看相同的数据有时可以帮助您更容易地找到您正在寻找的内容。正如您将在第8.3节中学习的，火焰图为您提供了应用程序执行的另一种视角，这有助于您识别潜在的延迟和性能问题。在第8.4节中，我们将讨论分析应用程序的持久层如何工作的技术，当它不使用关系型数据库，而是使用我们所说的“NoSQL技术家族”中的不同持久化方法时。 '
- en: For the topics we discuss in this chapter, VisualVM is not enough. VisualVM
    is an excellent free tool that I use in more than 90% of the scenarios I investigate
    with a profiler, but it has its limitations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中讨论的主题，VisualVM是不够的。VisualVM是一个出色的免费工具，我在使用剖析器调查的90%以上的场景中都使用它，但它有其局限性。
- en: To demonstrate the features we discuss in this chapter, we’ll use JProfiler
    ([http:// mng.bz/RvVn](http://mng.bz/RvVn)), a licensed profiler. JProfiler provides
    everything we discussed with VisualVM, but it also has capabilities VisualVM doesn’t
    have (for a small price). You can use the trial period the software offers to
    try profiling the examples we use in this book and form your own opinion on the
    differences between VisualVM and JProfiler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示本章中讨论的功能，我们将使用JProfiler ([http:// mng.bz/RvVn](http://mng.bz/RvVn))，这是一个授权的剖析器。JProfiler提供了我们与VisualVM讨论的所有内容，但它还具备VisualVM没有的功能（以一个小价格）。您可以使用软件提供的试用版来尝试剖析本书中使用的示例，并形成自己对VisualVM和JProfiler之间差异的看法。
- en: 8.1 Detecting problems with JDBC connections
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 检测JDBC连接的问题
- en: We discussed plenty of details about investigating problems with SQL queries
    in chapter 7\. But what about the connection an app needs with a DBMS to send
    the queries? Negligence regarding connection management can cause problems, and
    in this section, we discuss these issues and how to find their root causes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7章中讨论了使用SQL查询调查问题的许多细节。但是，一个应用与DBMS之间发送查询所需的连接是怎样的呢？忽视连接管理可能会导致问题，在本节中，我们将讨论这些问题以及如何找到它们的根本原因。
- en: Some may argue that apps use frameworks and libraries that take care of connection
    management in most cases, and thus such problems no longer occur. However, experience
    tells me that these problems still happen, mainly because developers depend on
    many things to be automatic. Sometimes we should use less common and more low-level
    implementations, instead of depending on what the framework offers, which is where
    most of these types of problems occur.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，应用使用框架和库来处理大多数情况下的连接管理，因此这类问题不再发生。然而，经验告诉我，这些问题仍然存在，主要是因为开发者依赖于许多事情自动完成。有时我们应该使用更不常见且更底层的实现，而不是依赖于框架提供的功能，大多数这类问题都发生在这里。
- en: 'Let me tell you a story of an issue I had to deal with recently. In a particular
    service (implemented with Spring), developers had to implement a less common capability:
    a way to cancel the execution of a stored procedure (a procedure running at the
    database level). The implementation wasn’t complex, but it required directly accessing
    the connection object. In most cases, it was enough to allow Spring to use the
    connection behind the scenes. Spring is a robust framework and easy to customize,
    and you can easily access the connections it manages, but does it still manage
    these connections after you access them? The answer is sometimes. And this “sometimes”
    is what made things interesting (and also more challenging).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你讲一个我最近不得不处理的问题的故事。在一个特定的服务（使用Spring实现）中，开发者必须实现一个不太常见的功能：一种取消存储过程（在数据库级别运行的过程）执行的方法。实现并不复杂，但它需要直接访问连接对象。在大多数情况下，允许Spring在幕后使用连接就足够了。Spring是一个健壮的框架，易于定制，你可以轻松访问它管理的连接，但它在你访问它们之后仍然管理这些连接吗？答案是有时。而这个“有时”就是事情变得有趣（同时也更具挑战性）的原因。
- en: The developers found that in a standard method execution where Spring manages
    the transactions, the framework also closes the connections at the end. The procedure
    was cancelled with a batching approach, which was implemented from Spring Batch.
    In such cases, the framework doesn’t close the connections; you must manage them.
    The developers used the same approach in both cases and didn’t realize that the
    connections were not correctly closed in one of the cases, which could have caused
    a big problem. Fortunately, the development error was found in time and caused
    no harm.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者发现，在Spring管理事务的标准方法执行中，框架也会在结束时关闭连接。该过程是通过Spring Batch实现的批处理方法取消的。在这种情况下，框架不会关闭连接；你必须自己管理它们。开发者在这两种情况下都使用了相同的方法，但没有意识到在其中一个情况下连接没有被正确关闭，这可能会造成大问题。幸运的是，开发错误及时发现，没有造成损害。
- en: This story shows why the technique you’ll learn in this section is still relevant.
    The name of the frameworks you use doesn’t matter, and you may never know everything
    that happens behind the scenes, so being prepared to investigate your app execution
    in any way will always be relevant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事展示了为什么本节中你将学习的技巧仍然相关。你使用的框架名称并不重要，你可能永远不知道幕后发生的一切，所以准备好以任何方式调查你的应用执行始终是相关的。
- en: 'We’ll use project da-ch8-ex1 provided with the book. This project defines a
    simple app with a huge problem: one of its methods “forgets” to close the JDBC
    connections it opens. An app creates a JDBC connection to send SQL queries to
    the DBMS. The JDBC connections must always be closed once the app no longer needs
    them. All DBMSs offer clients (i.e., apps) the ability to get a limited number
    of connections (usually a small number, such as 100). When an app opens all these
    connections but doesn’t close them, it cannot connect to the database server (figure
    8.1).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用书中提供的项目da-ch8-ex1。这个项目定义了一个简单的应用，它有一个巨大的问题：它的一个方法“忘记”关闭它打开的JDBC连接。应用创建一个JDBC连接以向DBMS发送SQL查询。一旦应用不再需要这些连接，就必须始终关闭JDBC连接。所有DBMS都向客户端（即应用）提供获取有限数量连接的能力（通常数量很少，如100）。当应用打开所有这些连接但又不关闭它们时，它就无法连接到数据库服务器（图8.1）。
- en: '![](../../OEBPS/Images/CH08_F01_Spilca3.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F01_Spilca3.png)'
- en: Figure 8.1 DBMS allows an app to open a finite and usually small number of connections.
    When the app reaches the limit of connections it can open, the DBMS doesn’t allow
    the app to open other connections. In such a case, the app may become unable to
    execute its work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 数据库管理系统允许应用打开有限且通常数量较小的连接。当应用达到可以打开的连接限制时，数据库管理系统不允许应用打开其他连接。在这种情况下，应用可能无法执行其工作。
- en: The DBMS doesn’t always offer precisely 100 connections. This number is configurable
    at the database level. When working with a database, it’s best to find (usually
    by asking the database administrator) the maximum number of connections the app
    can open.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库管理系统并不总是提供精确的100个连接。这个数字可以在数据库级别进行配置。当与数据库一起工作时，最好找到（通常通过询问数据库管理员）应用可以打开的最大连接数。
- en: NOTE To simplify our demonstration, we’ll use a persistence layer that limits
    the number of connections to 10.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了简化我们的演示，我们将使用一个持久层，该层限制连接数为10。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: Let’s start project da-ch8-ex1 and analyze the app’s behavior. This project
    defines a simple application that stores details about products in a database.
    The app exposes an endpoint at the `/products` path. By calling the endpoint,
    the app returns details based on data it stores in its database. When you call
    the endpoint the first time, the app responds almost instantaneously. But when
    you send the second request to the same endpoint, the app responds after 30 seconds
    with an error message, as shown in figure 8.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始项目da-ch8-ex1并分析应用的行为。该项目定义了一个简单的应用，该应用在数据库中存储有关产品的详细信息。应用在`/products`路径上公开一个端点。通过调用端点，应用返回基于其数据库中存储的数据的详细信息。当你第一次调用端点时，应用几乎立即响应。但是当你向同一端点发送第二个请求时，应用在30秒后响应并显示一个错误信息，如图8.2所示。
- en: '![](../../OEBPS/Images/CH08_F02_Spilca3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F02_Spilca3.png)'
- en: Figure 8.2 When calling the `/products` endpoint the first time, the app responds
    instantaneously with a list containing the word “Chocolate.” But when you try
    to call the endpoint a second time, the app appears to be stuck for about 30 seconds
    and then shows an error message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 当第一次调用`/products`端点时，应用立即响应，返回包含单词“巧克力”的列表。但是当你尝试第二次调用该端点时，应用似乎卡住了大约30秒，然后显示一个错误信息。
- en: What the app actually does is not essential for our demonstration, so I won’t
    go into details about its functionality, but imagine that a friend working on
    a separate project calls you for your help and shows such a problem. They don’t
    give you many details about how their app works (in a real-world app, it could
    be a complicated business case). Can you still help them? We start by analyzing
    the behavior they show us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用实际执行的操作对我们演示来说并不重要，所以我就不会深入讨论其功能细节了，但想象一下，一个在独立项目上工作的朋友向你求助并展示了这样的问题。他们没有提供太多关于他们的应用如何工作的细节（在现实世界的应用中，这可能是一个复杂的企业案例）。你还能帮助他们吗？我们首先分析他们向我们展示的行为。
- en: 'We want to find out what causes the problematic behavior. You access the logs
    and immediately suspect the problem is related to the JDBC connections. The exception
    message, shown in the following snippet, tells you that the app can’t make a connection,
    most likely because the DBMS doesn’t allow other connections to be opened. But
    let’s assume we cannot always rely on logs. In the end, we can’t know for certain
    that another framework or library that your app uses didn’t generate the straightforward
    exception message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要找出导致问题行为的原因。你查看日志并立即怀疑问题与JDBC连接有关。下面的代码片段中显示的异常信息告诉你，应用无法建立连接，很可能是由于数据库管理系统不允许打开其他连接。但让我们假设我们并不能总是依赖日志。最终，我们无法确定是否是应用使用的另一个框架或库生成了直接的异常信息：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The exception message
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 异常信息
- en: As I recommended in chapter 7, every profiling investigation should start with
    sampling, which gives you an overview of the execution and the details you need
    to continue your research. If you used VisualVM, the sampling result would look
    like figure 8.3.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第7章中建议的，每次性能分析调查都应该从采样开始，这为你提供了执行概述和继续研究所需的详细信息。如果你使用了VisualVM，采样结果将类似于图8.3。
- en: '![](../../OEBPS/Images/CH08_F03_Spilca3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F03_Spilca3.png)'
- en: Figure 8.3 After sampling the execution, we have more reasons to suspect something
    is wrong with establishing a connection to the DBMS. In the execution stack, we
    see that the app waited for 30 seconds to get a connection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 在采样执行后，我们有更多理由怀疑与数据库管理系统建立连接存在问题。在执行堆栈中，我们看到应用程序等待了30秒来获取连接。
- en: 'After sampling and observing the exception stack trace in the logs, we know
    our app has a problem connecting to the DBMS. But what causes this problem? It
    could be one of two things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样并观察日志中的异常堆栈跟踪后，我们知道我们的应用程序在连接到数据库管理系统时存在问题。但造成这个问题的原因可能是什么？这可能是两件事之一：
- en: The communication between the app and the DBMS fails because of some infrastructure
    or networking problems.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序与数据库管理系统之间的通信失败是由于某些基础设施或网络问题。
- en: 'The DBMS doesn’t want to provide a connection to our application:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库管理系统不愿意为我们应用程序提供连接：
- en: Because of an authentication problem
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为认证问题
- en: Because the app already consumed all the connections the DBMS can offer
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为应用程序已经消耗了数据库管理系统可以提供的所有连接
- en: Since in our case the issue always happens the second time a request is sent
    (there is a defined pattern to reproduce it), we can exclude the communication
    problem. It must be that the DMBS doesn’t provide a connection. But it can’t be
    an authentication problem since the first call worked well. It’s unlikely that
    something changed with the credentials, so the most plausible cause is that our
    app sometimes doesn’t close the connections. Now we just have to find where this
    happens. Remember that the method that encountered the problem isn’t necessarily
    the one causing it. It may be that this method is the “unlucky” one that tried
    to get a connection after someone else “ate” all the others.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的情况下，问题总是在第二次发送请求时发生（有一个定义的模式可以重现它），我们可以排除通信问题。这必须是数据库管理系统没有提供连接。但由于第一次调用工作良好，这不可能是一个认证问题。不太可能凭据发生了变化，所以最有可能的原因是我们应用程序有时没有关闭连接。现在我们只需要找到这种情况发生的地方。记住，遇到问题的方法不一定是导致问题的方法。可能这个方法是“不幸”的那个，在其他人“吃掉”所有其他连接之后尝试获取连接。
- en: But with VisualVM, you can’t explicitly investigate JDBC connections, so we
    can’t use it to identify which connection stays open. Instead, we’ll continue
    our investigation using JProfiler. Attaching JProfiler to a running Java process
    is very similar to using VisualVM. Let’s follow the approach step by step.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用VisualVM，您不能明确地调查JDBC连接，因此我们无法使用它来识别哪个连接保持打开状态。相反，我们将继续使用JProfiler进行调查。将JProfiler附加到正在运行的Java进程与使用VisualVM非常相似。让我们一步一步地遵循这种方法。
- en: First, select Start Center in the upper-left corner of JProfiler’s main window,
    as presented in figure 8.4.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在JProfiler主窗口的左上角选择“开始中心”，如图8.4所示。
- en: '![](../../OEBPS/Images/CH08_F04_Spilca3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F04_Spilca3.png)'
- en: Figure 8.4 Start a sampling or profiling session with JProfiler by selecting
    the Start Center menu in the upper-left corner of the JProfiler window.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 通过选择JProfiler窗口左上角的“开始中心”菜单，使用JProfiler开始采样或性能分析会话。
- en: A pop-up window appears (figure 8.5), and you can select Quick Attach on the
    left to get a list of all Java processes running locally. Choose the process you
    want to profile and then select Start. Just as with VisualVM, you identify the
    process by the name of the main class or the process ID (PID).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 出现一个弹出窗口（图8.5），您可以在左侧选择快速附加以获取所有本地运行的Java进程的列表。选择您想要分析的过程，然后选择开始。就像VisualVM一样，您可以通过主类的名称或进程ID（PID）来识别进程。
- en: '![](../../OEBPS/Images/CH08_F05_Spilca3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F05_Spilca3.png)'
- en: Figure 8.5 In the pop-up window, select Quick Attach and, in the list, select
    the process you want to profile. Then select the Start button to begin the profiling
    session.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 在弹出窗口中，选择快速附加，并在列表中选择您想要分析的过程。然后选择开始按钮以开始性能分析会话。
- en: JProfiler will ask you if you want to use sampling or instrumentation (instrumentation
    is the equivalent to what we called profiling with VisualVM), as shown in figure
    8.6\. We select instrumentation since we are using the profiler to get details
    about the JDBC connections and thus want to analyze the execution in more depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JProfiler会询问您是否想要使用采样或仪器（仪器相当于我们所说的使用VisualVM进行性能分析），如图8.6所示。我们选择仪器，因为我们使用性能分析器来获取JDBC连接的详细信息，因此希望更深入地分析执行过程。
- en: '![](../../OEBPS/Images/CH08_F06_Spilca3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F06_Spilca3.png)'
- en: Figure 8.6 To analyze the execution in more depth, we need to select Instrumentation,
    the equivalent to what we call profiling in VisualVM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 为了更深入地分析执行情况，我们需要选择工具，这在VisualVM中相当于我们所说的分析。
- en: Under Databases in the left menu, select JDBC. Then start the JDBC profiling
    as presented in figure 8.7.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧菜单的数据库下，选择JDBC。然后按照图8.7所示开始JDBC分析。
- en: '![](../../OEBPS/Images/CH08_F07_Spilca3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F07_Spilca3.png)'
- en: Figure 8.7 You can start JDBC profiling with JProfiler by first selecting JDBC
    in the left menu; then you begin the profiling process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 使用JProfiler开始JDBC分析，首先在左侧菜单中选择JDBC；然后开始分析过程。
- en: 'Once profiling begins, we are most interested in two tabs: Connections and
    Connection Leaks (figure 8.8). These tabs show us details about the connections
    to the DBMS the app opens, and we’ll use them to identify the problem’s root cause.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始分析，我们最感兴趣的两个标签页是连接和连接泄漏（图8.8）。这些标签页显示了应用程序打开到DBMS的连接的详细信息，我们将使用它们来识别问题的根本原因。
- en: '![](../../OEBPS/Images/CH08_F08_Spilca3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F08_Spilca3.png)'
- en: Figure 8.8 The Connections and Connection Leaks tabs show details about the
    connections the app creates, including potential problematic connections. We’ll
    use these details to understand where the problem in our app comes from.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8  连接和连接泄漏标签页显示了应用程序创建的连接的详细信息，包括潜在的问题连接。我们将使用这些详细信息来了解我们应用程序中问题的来源。
- en: Now it’s time to reproduce the problem and profile the execution. Send a request
    to the `/products` endpoint, and let’s see what happens. The Connections tab shows
    that many connections are created, as presented in figure 8.9\. Since we don’t
    know what the app does, many connections don’t necessarily mean problems. But
    we expect that the app closed these connections so that it can get other connections
    when needed. What we need to figure out is if the app closed these connections
    correctly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候重现问题并分析执行情况了。向`/products`端点发送请求，看看会发生什么。连接标签页显示，正如图8.9所示，创建了多个连接。由于我们不知道应用程序做了什么，所以许多连接并不一定意味着问题。但我们期望应用程序在需要时关闭这些连接。我们需要弄清楚的是，应用程序是否正确地关闭了这些连接。
- en: '![](../../OEBPS/Images/CH08_F09_Spilca3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F09_Spilca3.png)'
- en: Figure 8.9  The Connection Leaks tab confirms our suspicion (figure 8.10); not
    only does the app Figure 8.9 By sending a request to the `/products` endpoint,
    we see that the app creates many connections. We don’t know exactly what the app
    does, but this can be alarming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9  连接泄漏标签页证实了我们的怀疑（图8.10）；通过向`/products`端点发送请求，我们看到应用程序创建了多个连接。我们不知道应用程序具体做了什么，但这可能令人担忧。
- en: open many connections, but the connections remain unclosed long after the endpoint
    responds. This is a clear sign of a connection leak. If we didn’t explicitly start
    CPU profiling (I’ll show you in a moment how to do that), you’d only see the name
    of the thread that created the connection. Sometimes the thread’s name is enough,
    and in such a case, you wouldn’t need to start CPU profiling at all. However,
    in situations such as this one, it doesn’t tell us enough to identify the code
    that created the connection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开许多连接，但连接在端点响应后长时间未关闭。这是连接泄漏的明显迹象。如果我们没有明确启动CPU分析（我稍后会展示如何进行），你只能看到创建连接的线程名称。有时线程名称就足够了，在这种情况下，你甚至不需要启动CPU分析。然而，在这种情况下，它并不能提供足够的信息来识别创建连接的代码。
- en: '![](../../OEBPS/Images/CH08_F10_Spilca3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F10_Spilca3.png)'
- en: Figure 8.10 The Connection Leaks tab shows us the status of each connection.
    We are interested in the connections that close late or never. Here, the connections
    the app opened are still alive long after the endpoint sent a response back to
    the client, which strongly indicates a problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 连接泄漏标签页显示了每个连接的状态。我们关注的是关闭晚或从未关闭的连接。在这里，应用程序打开的连接在端点向客户端发送响应后仍然存活很长时间，这强烈表明存在问题。
- en: But that’s not enough, is it? We had suspected that something was wrong with
    the app obtaining a connection to the DBMS. Now we need to use the profiler’s
    CPU profiling capability to identify the part of the codebase that creates the
    connections and forgets to close them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够，是吗？我们怀疑应用程序获取DBMS连接时可能存在问题。现在我们需要使用分析器的CPU分析功能来识别代码库中创建连接并忘记关闭它们的部分。
- en: We still need a way to identify the code that creates the leaking connections.
    Fortunately, JProfiler can help us with this as well, but we’ll need to redo the
    exercise after also enabling CPU profiling. With CPU profiling active, JProfiler
    will display, for each leaking connection, the stack trace to the method that
    created the connection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要一种方法来识别创建泄漏连接的代码。幸运的是，JProfiler也可以帮助我们做到这一点，但我们需要在启用CPU分析后重新进行练习。在CPU分析激活时，JProfiler将为每个泄漏连接显示创建连接的方法的堆栈跟踪。
- en: Figure 8.11 shows how to enable CPU profiling and how you find the stack trace
    for each leaking connection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11展示了如何启用CPU分析以及如何找到每个泄漏连接的堆栈跟踪。
- en: '![](../../OEBPS/Images/CH08_F11_Spilca3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F11_Spilca3.png)'
- en: Figure 8.11 With CPU profiling enabled, JProfiler shows the stack trace, which
    helps you identify which part of the app’s code creates the leaking connections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 启用CPU分析后，JProfiler显示堆栈跟踪，这有助于你确定哪个应用程序代码部分创建了泄漏连接。
- en: Let’s go straight to that code in our example da-ch8-ex1\. We observe that the
    method indeed creates a connection that seems not to be closed anywhere. We found
    the root cause!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接查看我们的示例da-ch8-ex1中的代码。我们观察到该方法确实创建了一个似乎在任何地方都没有关闭的连接。我们找到了根本原因！
- en: Listing 8.1 Identifying the problem root cause
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 识别问题根本原因
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This line creates a connection that is never closed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这行代码创建了一个永远不会关闭的连接。
- en: Project da-ch8-ex2 corrects the code. By adding the connection to the `try-with-resources`
    block, the app will close the connection at the end of the `try` block when the
    connection is no longer needed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 项目da-ch8-ex2修复了代码。通过将连接添加到`try-with-resources`块中，应用程序将在`try`块结束时关闭连接，当连接不再需要时。
- en: Listing 8.2 Solving the problem by closing the connection
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 通过关闭连接解决问题
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The connection is declared in the try-with-resources block, closing the connection
    at the end of the try block.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 连接在`try-with-resources`块中声明，在`try`块结束时关闭连接。
- en: We can profile the app again after applying the correction. Now the Connection
    tab in JProfiler shows us that only one connection is created, and the Connection
    Leaks tab is empty, confirming that the problem was indeed solved (figure 8.12).
    When you test the app, you also see that you can send multiple requests to the
    `/products` endpoint.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用修正后，我们可以再次对应用程序进行分析。现在，JProfiler中的连接选项卡显示只创建了一个连接，连接泄漏选项卡为空，确认问题确实得到了解决（图8.12）。当你测试应用程序时，你也会看到你可以向`/products`端点发送多个请求。
- en: '![](../../OEBPS/Images/CH08_F12_Spilca3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F12_Spilca3.png)'
- en: Figure 8.12 After fixing the error, we use JProfiler to confirm that no more
    connections are leaking. We observe that the app opens only one connection at
    a time and correctly closes the connection when it no longer needs it. The Connection
    Leaks tab doesn’t show any other faulty connections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 修复错误后，我们使用JProfiler确认没有更多的连接泄漏。我们观察到应用程序一次只打开一个连接，并在不再需要时正确关闭连接。连接泄漏选项卡没有显示其他故障连接。
- en: Do you wonder if there is a best practice to avoid such problems in real-world
    scenarios? I recommend that developers take 10 minutes or so after each implementation
    or bug fix to test the capability they worked on with a profiler. This practice
    can help to identify latency issues caused by wrong queries or faulty connection
    management from the early phases of development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道在现实场景中避免此类问题的最佳实践是什么？我建议开发者每次实现或修复错误后花大约10分钟的时间，使用分析器测试他们所工作的功能。这种做法可以帮助在开发的早期阶段识别由错误的查询或错误连接管理引起的延迟问题。
- en: 8.2 Understanding the app’s code design using call graphs
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 使用调用图理解应用程序的代码设计
- en: 'In this section, we discuss one of my favorite techniques to understand an
    app’s class design: visualizing the execution as a call graph. This technique
    is especially helpful when dealing with messy code, an eventuality of working
    with a new app.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了我最喜欢的一种理解应用程序类设计的技术：将执行过程可视化为一个调用图。这项技术在处理混乱的代码时特别有帮助，这是与新的应用程序一起工作的一个可能结果。
- en: Thus far, we’ve used stack traces to understand execution. Execution stack traces
    are valuable tools, and we’ve already seen how many things we can do with them.
    They are helpful because of their straightforward way of representing as text,
    which allows them to be printed in logs (usually as exception stack traces). But
    from a visual point of view, they’re not great at quickly identifying the relationship
    between objects and method calls. Call graphs are a different way to represent
    the data a profiler collects and focus more on the relationships between the objects
    and method calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用堆栈跟踪来理解执行。执行堆栈跟踪是有价值的工具，我们已经看到了我们可以用它们做什么。它们之所以有用，是因为它们以直观的文本方式表示，这使得它们可以打印在日志中（通常作为异常堆栈跟踪）。但从视觉角度来看，它们在快速识别对象和方法调用之间的关系方面并不出色。调用图是表示分析器收集数据的不同方式，并且更多地关注对象和方法调用之间的关系。
- en: To demonstrate how to obtain a call graph, we’ll use example da-ch8-ex2 provided
    with the book to demonstrate how to use call graphs to quickly understand which
    objects and methods act behind an execution without analyzing the code. Of course,
    the idea isn’t to avoid the code completely; you’ll still end up digging through
    the code, but by using call graphs first, you’ll have a better picture of what
    happens up front.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何获取调用图，我们将使用书中提供的示例da-ch8-ex2来演示如何使用调用图快速了解哪些对象和方法在执行背后起作用，而无需分析代码。当然，这并不是要完全避免代码；你最终仍然需要深入代码，但通过首先使用调用图，你将有一个更好的初步了解发生了什么。
- en: We will continue to use JProfiler for our demonstration. Since call graphs are
    a way to represent CPU profiler data, we first need to start CPU profiling. Figure
    8.13 shows how to start CPU profiling, which results in a stack trace (referred
    to as a *call tree* in JProfiler). We’ll investigate what happens when calling
    the `/products` endpoint the app exposes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用JProfiler进行演示。由于调用图是表示CPU分析数据的一种方式，我们首先需要开始CPU分析。图8.13显示了如何开始CPU分析，这将导致堆栈跟踪（在JProfiler中称为*调用树*）。我们将研究调用应用程序公开的`/products`端点时会发生什么。
- en: '![](../../OEBPS/Images/CH08_F13_Spilca3.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F13_Spilca3.png)'
- en: Figure 8.13 Select Call Tree from the left-hand menu to start profiling the
    CPU (recording CPU data). Send a request to the `/products` endpoint, and the
    profiler will initially show the recorded data as a stack trace, including details
    about the number of invocations and the execution time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13从左侧菜单中选择调用树以开始分析CPU（记录CPU数据）。向`/products`端点发送请求，分析器最初将记录的数据显示为堆栈跟踪，包括调用次数和执行时间的详细信息。
- en: Right-click a line in the stack trace and select Show Call Graph to visualize
    the data collected about the execution as a call graph (figure 8.14).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击堆栈跟踪中的一行，然后选择显示调用图，以将收集的执行数据可视化为调用图（图8.14）。
- en: '![](../../OEBPS/Images/CH08_F14_Spilca3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F14_Spilca3.png)'
- en: Figure 8.14 To get a call graph representation from an execution stack trace,
    right-click a line in the stack trace and select Show Call Graph.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14要从执行堆栈跟踪中获取调用图表示，右键单击堆栈跟踪中的一行，然后选择显示调用图。
- en: JProfiler will generate a call graph representation, focusing on the method
    defined by the line you selected when generating the call graph. You’ll initially
    only know where this method is called from and what this method calls. You can
    navigate further and observe the entire call chain (figure 8.15). The call graph
    also provides details about the execution time and the number of invocations,
    but its focus is mainly on the relationship between the objects and the method
    calls.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JProfiler将生成一个调用图表示，重点关注在生成调用图时所选行的定义的方法。最初，你只知道这个方法是从哪里被调用的以及这个方法调用了什么。你可以进一步导航并观察整个调用链（图8.15）。调用图还提供了关于执行时间和调用次数的详细信息，但它的主要焦点是对象和方法调用之间的关系。
- en: '![](../../OEBPS/Images/CH08_F15_Spilca3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F15_Spilca3.png)'
- en: Figure 8.15 A call graph shows the execution, focusing mainly on the relationship
    between objects and method calls. You can linearly navigate the method execution
    chain to determine where each method is called from and what that method calls.
    The call graph also shows objects and methods that are part of the app’s codebase
    and those of libraries and frameworks the app uses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15调用图显示了执行情况，主要关注对象和方法调用之间的关系。你可以线性地导航方法执行链，以确定每个方法是从哪里被调用的以及该方法调用了什么。调用图还显示了应用程序代码库中的对象和方法，以及应用程序使用的库和框架中的对象和方法。
- en: 8.3 Using flame graphs to spot performance problems
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用火焰图查找性能问题
- en: Another way to visualize the profiled execution is using a *flame graph*. If
    call graphs focus on the relationship between objects and method calls, flame
    graphs are most helpful in identifying potential latencies. They are just a different
    way to see the same details a method execution stack provides, but, as mentioned
    in the chapter introduction, other representations of the same data may help to
    identify specific information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化已分析执行的方法是使用*火焰图*。如果调用图关注对象和方法调用之间的关系，那么火焰图在识别潜在延迟方面最有帮助。它们只是以不同的方式查看方法执行栈提供相同细节的一种方式，但正如章节引言中提到的，相同数据的其他表示可能有助于识别特定信息。
- en: We’ll continue using example da-ch8-ex2 for this demonstration. We’ll use JProfiler
    to change the execution stack representation to a flame graph and discuss the
    new representation’s advantages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用示例da-ch8-ex2进行演示。我们将使用JProfiler将执行栈表示更改为火焰图，并讨论新表示的优点。
- en: After generating a call tree, as discussed in sections 8.1 and 8.2, you can
    change it to a flame graph using the Analyze item in the top menu bar, as shown
    in figure 8.16.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.1节和第8.2节中讨论了生成调用树之后，您可以使用菜单栏上的“分析”项将其更改为火焰图，如图8.16所示。
- en: '![](../../OEBPS/Images/CH08_F16_Spilca3.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F16_Spilca3.png)'
- en: Figure 8.16 To change an execution stack (call tree) into a flame graph, select
    Analyze in the menu and then select Show Flame Graph.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 要将执行栈（调用树）更改为火焰图，请在菜单中选择“分析”，然后选择“显示火焰图”。
- en: A flame graph is a way to represent the execution tree as a stack. The fancy
    name is given because the graph usually looks like a flame. The first level of
    this stack is the first method the thread executed. Then, every level above is
    shared by the methods called by the layer below. Figure 8.17 shows you the flame
    graph created for the execution tree in figure 8.16.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图是一种将执行树表示为栈的方式。这个花哨的名字是因为这个图通常看起来像火焰。这个栈的第一层是线程执行的第一个方法。然后，每一层以上的方法都是由下面一层调用的。图8.17展示了为图8.16中的执行树创建的火焰图。
- en: '![](../../OEBPS/Images/CH08_F17_Spilca3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F17_Spilca3.png)'
- en: Figure 8.17 The flame graph is a stack representation of the execution trace.
    Each level shows the methods called by the level below. The first (bottom) level
    of the stack is the start of the thread. This way, we see the execution stack
    vertically, while the flame graph horizontally indicates the time spent by each
    level relative to the level below.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 火焰图是执行跟踪的栈表示。每一层显示的是下面一层调用的方法。栈的第一层（底部）是线程的开始。这样，我们垂直地看到执行栈，而火焰图水平地表示每一层相对于下面一层花费的时间。
- en: A method can call multiple other methods. In the flame graph, the methods that
    were called will appear on the same level. In such a case, the length of each
    is the time spent relative to the method calling it (the level below). In figure
    8.17, you can see that method `findById()` in the `ProductRepository` class and
    method `findAll()` in the `PurchaseRepository` class were both called from `getProductNamesForPurchases()`
    in the `ProductService` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以调用多个其他方法。在火焰图中，被调用的方法将出现在同一层。在这种情况下，每个方法的长度是相对于调用它的方法（下面一层）花费的时间。在图8.17中，您可以看到`ProductRepository`类中的`findById()`方法和`PurchaseRepository`类中的`findAll()`方法都是从`ProductService`类中的`getProductNamesForPurchases()`方法调用的。
- en: '![](../../OEBPS/Images/CH08_F18_Spilca3.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F18_Spilca3.png)'
- en: Figure 8.18 When multiple methods share the same level, they are all called
    by the method below them. The sum of the lengths of the representation equals
    the length of the method under them. Each method’s length is a relative representation
    of the execution time from the total. In this case, `findAll()` took much longer
    to execute than `findById()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 当多个方法共享同一层时，它们都是由下面的方法调用的。表示长度的总和等于下面方法的长度。每个方法的长度是相对于总执行时间的相对表示。在这种情况下，`findAll()`的执行时间比`findById()`长得多。
- en: In figure 8.18, we observe that `getProductNamesForPurchases()` in the `ProductService`
    class is the bottom level for both method `findById()` in the `ProductRepository`
    class and method `findAll()` in the `PurchaseRepository` class. Moreover, `findById()`
    and `findAll()` share the same layer. But notice that they don’t have the same
    length. The length is relative to the caller’s execution, so in this case, the
    execution time of `findById()` is less than the execution time of `findAll()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在图8.18中，我们观察到`ProductService`类中的`getProductNamesForPurchases()`是`ProductRepository`类中的`findById()`方法和`PurchaseRepository`类中的`findAll()`方法的底层。此外，`findById()`和`findAll()`共享相同的层。但请注意，它们的长度并不相同。长度是相对于调用者的执行而言的，因此在这种情况下，`findById()`的执行时间小于`findAll()`的执行时间。
- en: '![](../../OEBPS/Images/CH08_F19_Spilca3.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F19_Spilca3.png)'
- en: Figure 8.19 To color your flame graph and make it easier to read, add colorization
    rules using the Colorize item in the top menu. The rules define which layers in
    the flame graph should be colored and which color should be used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 为了使火焰图着色并便于阅读，请使用顶部菜单中的“着色”项添加着色规则。这些规则定义了火焰图中哪些层应该着色以及使用哪种颜色。
- en: You may have already noticed that it’s easy to get lost in this graph. And this
    is only a simple example for study purposes; in a real-world app, the flame may
    be much more complex. To mitigate this complexity, you can use JProfiler to color
    the layers based on the method, class, or package names. Figure 8.19 shows how
    to use colorization to mark specific layers in the flame graphs. You use the Colorize
    item in the top menu to add colorization rules. You can add multiple colorization
    rules to specify which layers should be colored and the color you prefer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这张图中很容易迷失方向。这只是一个用于学习目的的简单示例；在实际应用程序中，火焰图可能要复杂得多。为了减轻这种复杂性，你可以使用JProfiler根据方法、类或包名称着色层。图8.19展示了如何使用着色来标记火焰图中的特定层。你使用顶部菜单中的“着色”项添加着色规则。你可以添加多个着色规则来指定哪些层应该着色以及你喜欢的颜色。
- en: '![](../../OEBPS/Images/CH08_F20_Spilca3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F20_Spilca3.png)'
- en: Figure 8.20 Colorizing levels helps highlight specific parts of the flame that
    you want to focus on. You can use multiple colors at the same time, which can
    help you to compare execution times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 着色层级有助于突出你想要关注的火焰图的特定部分。你可以同时使用多种颜色，这有助于你比较执行时间。
- en: In figure 8.20, you can see how I highlighted the levels for the methods containing
    the word “Purchase” in their names and had them colored blue (dark gray in the
    print version of this book).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在图8.20中，你可以看到我如何突出显示名称中包含“Purchase”一词的方法的层级，并将它们着色为蓝色（本书印刷版中的深灰色）。
- en: 8.4 Analyzing queries on NoSQL databases
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 分析NoSQL数据库上的查询
- en: Applications often use relational databases, but in many cases, certain implementations
    need different persistence technologies. We call these *NoSQL technologies*, and
    apps we implement can choose from a large variety of such implementations. Some
    of the best known examples are MongoDB, Cassandra, Redis, and Neo4J. Some profilers,
    such as JProfiler, can intercept queries the app sends to a specific NoSQL server
    to work with a database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常使用关系型数据库，但在许多情况下，某些实现需要不同的持久化技术。我们称之为*NoSQL技术*，我们实现的应用程序可以从大量此类实现中选择。其中一些最著名的例子是MongoDB、Cassandra、Redis和Neo4J。一些分析器，如JProfiler，可以拦截应用程序发送到特定NoSQL服务器以与数据库交互的查询。
- en: JProfiler can intercept events sent to MongoDB and Cassandra, and these details
    may help to save time when you are investigating the behavior of an app using
    such a persistence implementation. For this reason, in this section, we’ll use
    a small app to demonstrate the use of JProfiler to observe an app’s interaction
    with a MongoDB database.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JProfiler可以拦截发送到MongoDB和Cassandra的事件，这些详细信息在调查使用此类持久化实现的应用程序行为时可能有助于节省时间。因此，在本节中，我们将使用一个小应用程序来演示如何使用JProfiler观察应用程序与MongoDB数据库的交互。
- en: 'Project da-ch8-ex3 works with MongoDB. The app implements a couple of endpoints:
    one that stores details of products in the database and another that returns a
    list of all previously added products. To make it simple, a product is only represented
    by a name and a unique ID.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 项目da-ch8-ex3与MongoDB协作。该应用程序实现了一些端点：一个用于在数据库中存储产品详情，另一个用于返回所有先前添加的产品列表。为了简化，产品仅由名称和唯一ID表示。
- en: 'To follow this section, you first need to locally install a MongoDB server
    to which project da-ch8-ex3 will connect. You can download and install MongoDB
    Community Server from the official page: [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本节，您首先需要在本地安装一个MongoDB服务器，项目da-ch8-ex3将连接到该服务器。您可以从官方网站下载并安装MongoDB Community
    Server：[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)。
- en: 'Once you have installed the server, you can start project da-ch8-ex3\. We will
    also attach JProfiler to the process. To begin monitoring MongoDB events, select
    the MongoDB section under Databases in the left menu and start recording. To observe
    how JProfiler presents the events, we will call the two endpoints the app exposes.
    You can call the two endpoints using the cURL commands (as in the following snippet)
    or a tool such as Postman:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了服务器，您就可以开始项目da-ch8-ex3。我们还将把JProfiler附加到该进程。要开始监控MongoDB事件，请在左侧菜单的“数据库”下选择MongoDB部分并开始录制。为了观察JProfiler如何呈现事件，我们将调用应用程序公开的两个端点。您可以使用cURL命令（如下面的片段所示）或Postman等工具调用这两个端点：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Adds a product named “Beer” to the database
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向数据库添加名为“Beer”的产品
- en: ❷ Gets all the products in the database
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取数据库中的所有产品
- en: Figure 8.21 shows the two events intercepted by JProfiler. The tool displays
    the stack traces (call trees) associated with each event. We get details about
    the number of invocations and the execution time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21显示了JProfiler拦截的两个事件。该工具显示与每个事件相关的堆栈跟踪（调用树）。我们可以获取关于调用次数和执行时间的详细信息。
- en: '![](../../OEBPS/Images/CH08_F21_Spilca3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F21_Spilca3.png)'
- en: 'Figure 8.21 JProfiler can intercept the operations an app applies to a NoSQL
    database. In this example, JProfiler intercepts two events: an update and a read
    on a document named “product.” This way, you can monitor the interaction between
    your app and a NoSQL database and consider the number of invocations for specific
    operations and the execution time. The profiler also gives you the complete stack
    trace for a particular operation so you can quickly find the code that caused
    a specific event.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 JProfiler可以拦截应用程序对NoSQL数据库执行的操作。在这个例子中，JProfiler拦截了两个事件：对名为“product”的文档的更新和读取。这样，您可以监控您的应用程序与NoSQL数据库之间的交互，并考虑特定操作的调用次数和执行时间。分析器还为您提供特定操作的完整堆栈跟踪，以便您可以快速找到导致特定事件的代码。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Free tools such as VisualVM offer plenty of widgets that can help with any investigation.
    But licensed tools such as JProfiler can make the investigations even more effective
    through different ways of representing the investigation data.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如VisualVM之类的免费工具提供了大量的小部件，可以帮助进行任何调查。但如JProfiler之类的授权工具可以通过不同的方式表示调查数据，使调查更加有效。
- en: Sometimes apps encounter issues when connecting to a DBMS. By using JProfiler,
    you can more easily investigate issues with a JDBC connection to a relational
    database server. You can evaluate whether connections remain open and identify
    the part of the code that “forgets” to close them.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时应用程序在连接到DBMS时会遇到问题。通过使用JProfiler，您可以更轻松地调查与关系型数据库服务器的JDBC连接问题。您可以评估连接是否保持打开状态，并识别代码中“忘记”关闭它们的部分。
- en: Call graphs are a different way to visualize the execution stack and focus mainly
    on the relationship between objects and method calls. For this reason, call graphs
    are an excellent tool you can use to more easily understand the class design behind
    the app’s execution.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用图是可视化执行堆栈的另一种方式，主要关注对象和方法调用之间的关系。因此，调用图是您可以用来更轻松地理解应用程序执行背后的类设计的优秀工具。
- en: Flame graphs offer a different perspective for visualizing profiled data. You
    can use flame graphs to more easily spot areas causing latencies in execution
    and long stack traces. You can color specific layers in a flame graph to better
    visualize the execution.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火焰图提供了可视化分析数据的另一种视角。您可以使用火焰图更容易地发现导致执行延迟和长堆栈跟踪的区域。您可以在火焰图中着色特定的层，以更好地可视化执行。
- en: Some licensed tools offer extended capabilities, such as investigating the communication
    between apps or between your app and a NoSQL database server.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些授权的工具提供扩展功能，例如调查应用程序之间的通信或您的应用程序与NoSQL数据库服务器之间的通信。
