- en: 8 Selecting channels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 选择channel
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Selecting from multiple channels
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个channel中选择
- en: Disabling select cases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用select情况
- en: Choosing between message passing and memory sharing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息传递和内存共享之间选择
- en: In the previous chapter, we used channels to implement message passing between
    two goroutines. In this chapter, we will see how to use Go’s `select` statement
    to read and write messages on multiple channels and to implement timeouts and
    non-blocking channels. We will also examine a technique for excluding channels
    that have been closed and consuming only from the remaining open channels. Finally,
    we’ll discuss memory sharing versus message passing and when we should choose
    one technique over the other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了channel在两个goroutine之间实现消息传递。在这一章中，我们将看到如何使用Go的`select`语句在多个channel上读取和写入消息，以及实现超时和非阻塞channel。我们还将检查一种排除已关闭channel并仅从剩余的开放channel中消费的技术。最后，我们将讨论内存共享与消息传递之间的区别，以及何时应该选择一种技术而不是另一种。
- en: 8.1 Combining multiple channels
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 结合多个channel
- en: How can we have one goroutine respond to messages coming from different goroutines
    over multiple channels? Go’s `select` statement lets us specify multiple channel
    operations as separate cases and then execute a case depending on which channel
    is ready.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让一个goroutine响应来自多个goroutine通过多个channel的消息？Go的`select`语句允许我们指定多个channel操作作为单独的情况，然后根据哪个channel准备好来执行一个情况。
- en: 8.1.1 Reading from multiple channels
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 从多个channel读取
- en: Let’s think of a simple scenario where a goroutine is expecting messages from
    separate channels, but we don’t know on which channel the next message will be
    received. The `select` statement lets us group read operations on multiple channels
    together, blocking the goroutine until a message arrives on any one of the channels
    (see figure 8.1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的场景，其中goroutine期望从不同的channel接收消息，但我们不知道下一个消息将在哪个channel上接收。`select`语句允许我们将多个channel上的读取操作组合在一起，阻塞goroutine直到任何一个channel上到达消息（见图8.1）。
- en: '![](../../OEBPS/Images/CH08_F01_Cutajar.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F01_Cutajar.png)'
- en: Figure 8.1 Select blocks until a channel becomes available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 Select语句会阻塞，直到某个channel可用。
- en: Once a message arrives on any of the channels, the goroutine is unblocked, and
    a code handler for that channel is run, as shown in figure 8.2\. We can then decide
    what else to do—either continue with our execution, or go back and wait for the
    next message by using the `select` statement again.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何channel上到达消息，goroutine将被解除阻塞，并运行该channel的代码处理器，如图8.2所示。然后我们可以决定接下来做什么——要么继续执行，要么再次使用`select`语句等待下一个消息。
- en: '![](../../OEBPS/Images/CH08_F02_Cutajar.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F02_Cutajar.png)'
- en: Figure 8.2 Once a channel is available, select unblocks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 一旦channel可用，select解除阻塞。
- en: Let’s now look at how this translates to code. In listing 8.1, we have a function
    that creates an anonymous goroutine that periodically sends a message on a channel.
    The period is specified by the `seconds` input variable. As we shall see later
    in this chapter, using a pattern where the function returns an output-only channel
    enables us to reuse these functions as building blocks for more complex behaviors.
    We can do this because Go channels are first-class objects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何转化为代码。在列表8.1中，我们有一个创建匿名goroutine的函数，该goroutine周期性地在channel上发送消息。周期由`seconds`输入变量指定。正如我们将在本章后面看到的那样，使用函数返回输出-only
    channel的模式使我们能够将这些函数作为构建更复杂行为的构建块重用。我们可以这样做，因为Go channels是一等对象。
- en: Listing 8.1 Function periodically outputting messages on a channel
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 函数周期性地在channel上输出消息
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creates a new channel of type string
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的字符串类型channel
- en: ❷ Creates a new, anonymous goroutine
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的匿名goroutine
- en: ❸ Sleeps for the specified period
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 睡眠指定的时间段
- en: ❹ Sends the specified message on the channel
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在channel上发送指定的消息
- en: ❺ Returns the newly created message channel
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回新创建的消息channel
- en: Definition Channels are *first-class objects**,* which means that we can store
    them as variables, pass or return them from functions, or even send them on a
    channel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Channels是**一等对象**，这意味着我们可以将它们存储为变量，从函数中传递或返回，甚至通过channel发送。
- en: We can demonstrate the `select` statement by calling the `writeEvery()` function
    (shown in the previous listing) twice. If we specify a different message and sleep
    period, we’ll end up with two channels and two goroutines sending messages at
    different times. The following listing reads from these two channels in a `select`
    statement, with each channel as a separate select case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两次调用 `writeEvery()` 函数（如前一个列表所示）来演示 `select` 语句。如果我们指定不同的消息和睡眠周期，我们将得到两个通道和两个在不同时间发送消息的
    goroutine。以下列表在 `select` 语句中读取这些通道，每个通道作为一个单独的 select 情况。
- en: Listing 8.2 Reading from multiple channels using `select`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 使用 `select` 从多个通道读取
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates a goroutine sending messages every second on channel A
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在通道 A 上创建一个每秒发送消息的 goroutine
- en: ❷ Creates a goroutine sending messages every 3 seconds on channel B
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在通道 B 上创建一个每 3 秒发送消息的 goroutine
- en: ❸ Loops forever
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 无限循环
- en: ❹ Outputs message from channel A if one is available
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果通道 A 有可用的消息，则输出该消息
- en: ❺ Outputs message from channel B if one is available
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果通道 B 有可用的消息，则输出该消息
- en: 'When we run listings 8.1 and 8.2 together, we get the `main()` goroutine looping
    and blocking each time until a message arrives from either channel. When we get
    a message, the `main()` goroutine executes the code underneath the `case` statement.
    In this example, the code just outputs the message to the console:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们同时运行列表 8.1 和 8.2 时，我们得到 `main()` goroutine 在每次收到来自任一通道的消息之前循环并阻塞。当我们收到消息时，`main()`
    goroutine 执行 `case` 语句下的代码。在这个例子中，代码只是将消息输出到控制台：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NOTE When using `select`, if multiple cases are ready, a case is chosen at random.
    Your code should not rely on the order in which the cases are specified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：当使用 `select` 时，如果多个情况都准备好了，则会随机选择一个情况。你的代码不应该依赖于情况指定的顺序。'
- en: Origins of the select statement
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 语句的起源'
- en: The UNIX operating system contains a system call named `select()` that accepts
    a set of file descriptors (such as files or network sockets) and blocks until
    one or more of the descriptors become ready for an I/O operation. The system call
    is useful when you want to monitor multiple files or sockets from a single kernel-level
    thread.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 操作系统包含一个名为 `select()` 的系统调用，它接受一组文件描述符（如文件或网络套接字），并在一个或多个描述符准备好 I/O 操作时阻塞。当您想从单个内核级线程监控多个文件或套接字时，该系统调用非常有用。
- en: Go’s `select` statement derives its name from the Newsqueak programming language’s
    `select` command. Newsqueak (not to be confused with the fictional language Newspeak
    by George Orwell) is a language that, like Go, takes its concurrency model from
    C.A.R. Hoare’s CSP formal language. Newsqueak’s `select` statement might have
    gotten its name from the select system call that was built to provide multiplexed
    I/O for the Blit graphics terminal in 1983.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `select` 语句的名字来源于 Newsqueak 编程语言的 `select` 命令。Newsqueak（不要与乔治·奥威尔虚构的语言
    Newspeak 混淆）是一种语言，就像 Go 一样，从 C.A.R. Hoare 的 CSP 形式语言中获取其并发模型。Newsqueak 的 `select`
    语句可能得名于 1983 年为 Blit 图形终端构建的多路复用 I/O 的 select 系统调用。
- en: It is unclear whether the naming of Go’s `select` statement was influenced by
    the UNIX system call; however, we can say that the UNIX `select()` system call
    is analogous to Go’s `select` statement in that it multiplexes multiple blocking
    operations into a single execution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚 Go 的 `select` 语句的命名是否受到了 UNIX 系统调用的启发；然而，我们可以说 UNIX 的 `select()` 系统调用与 Go
    的 `select` 语句类似，因为它将多个阻塞操作多路复用到单个执行中。
- en: 8.1.2 Using select for non-blocking channel operations
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 使用 `select` 进行非阻塞通道操作
- en: Another use case for `select` is when we need to use channels in a non-blocking
    manner. Recall that when we were discussing mutexes, we saw that Go provides a
    non-blocking `tryLock()` operation. This function call tries to acquire the lock,
    but if the lock is being used, it will return immediately with a `false` return
    value. Can we adopt this pattern for channel operations? For example, can we try
    to read a message from a channel? Then, if no messages are available, instead
    of blocking, can we have the current execution work on a default set of instructions
    (see figure 8.3)?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 的另一个用例是我们需要以非阻塞方式使用通道。回想一下，当我们讨论互斥锁时，我们看到 Go 提供了一个非阻塞的 `tryLock()`
    操作。这个函数调用尝试获取锁，但如果锁正在被使用，它将立即返回一个 `false` 的返回值。我们能否采用这种模式进行通道操作？例如，我们能否尝试从通道读取消息？然后，如果没有消息可用，而不是阻塞，我们能否让当前执行在默认指令集上工作（参见图
    8.3）？'
- en: '![](../../OEBPS/Images/CH08_F03_Cutajar.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F03_Cutajar.png)'
- en: Figure 8.3 The default case’s instructions are executed if no channels are available.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 当没有通道可用时，执行默认情况的指令。
- en: The `select` statement gives us the *default case* for exactly this scenario.
    The instructions under the default case will be executed if none of the other
    cases is available. This lets us try to access one or more channels, but if none
    is ready, we can do something else.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句为我们提供了恰好这种场景的*默认情况*。如果没有其他情况可用，将执行默认情况下的指令。这让我们可以尝试访问一个或多个通道，但如果没有任何通道准备好，我们可以做其他事情。'
- en: In the following listing, we have a `select` statement with a default case.
    In this listing, we are trying to read a message from a channel, but because the
    message arrives later, we get to execute the contents of the default case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们有一个带有默认情况的`select`语句。在这个列表中，我们正在尝试从通道读取消息，但由于消息到达较晚，我们执行了默认情况的代码。
- en: Listing 8.3 Non-blocking reads from a channel
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 从通道进行非阻塞读取
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Sends channel message after 3 seconds
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在3秒后发送通道消息
- en: ❷ Reads a message from the channel if there is one
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果有消息，则从通道读取消息
- en: ❸ When a message is available, terminates the execution
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当有消息可用时，终止执行
- en: ❹ When no message is available, the default case is executed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当没有消息可用时，执行默认情况。
- en: 'In the previous listing, since we have the `select` statement in a loop, the
    default case will be executed over and over again until we receive a message.
    When this happens, we print the message and return on the `main()` function, terminating
    the program. Here’s the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，由于我们在循环中有`select`语句，默认情况会反复执行，直到我们收到消息。当发生这种情况时，我们会打印消息并在`main()`函数中返回，终止程序。以下是输出：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 8.1.3 Performing concurrent computations on the default case
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 在默认情况下执行并发计算
- en: A useful scenario is to use the default select case for concurrent computations
    and then use a channel to signal when we need to stop. To illustrate this concept,
    suppose we have a sample application that will discover a forgotten password by
    brute force. To keep things simple, let’s say we have a password-protected file
    that we remember has a password of six characters or less, using only the lowercase
    letters *a* to *z* and spaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的场景是使用默认的select情况来执行并发计算，然后使用通道来表示我们需要停止。为了说明这个概念，假设我们有一个示例应用程序，它将通过暴力破解来发现遗忘的密码。为了使事情简单，让我们假设我们有一个受密码保护的文件，我们知道它的密码是六位或更少，只使用小写字母*a*到*z*和空格。
- en: The number of possible strings from "`a`" to "`zzzzzz`", including spaces, is
    27 ⁶ – 1 (387,420,488). The function in the following listing gives us a way to
    convert the integers 1 to 387,420,488 into a string. For example, calling `toBase27(1)`
    gives us "`a`", calling it with `2` gives us "`b`", `28` gives us "`aa`", and
    so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从"`a`"到"`zzzzzz`"，包括空格，可能的字符串数量是27的6次方减1（387,420,488）。下面的列表中的函数为我们提供了一种将1到387,420,488的整数转换为字符串的方法。例如，调用`toBase27(1)`会得到"`a`"，调用它时使用`2`会得到"`b`"，`28`会得到"`aa`"，依此类推。
- en: Listing 8.4 Enumerating all possible combinations of a string
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 枚举字符串的所有可能组合
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Sets the password that we need to guess
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置我们需要猜测的密码
- en: ❷ Defines all possible characters that the password is made of
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义密码可能由的所有可能字符
- en: ❸ Algorithm converts a decimal integer into a string of base 27 using the alphabet
    constant
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 算法使用字母常量将十进制整数转换为基27的字符串
- en: If we had to use a brute force approach in a sequential program, we would just
    create a loop enumerating all strings from "`a`" to "`zzzzzz`", and every time,
    we would check to see whether it matched with the variable `passwordToGuess`.
    In a real-life scenario, we wouldn’t have the value of the password; instead,
    we would try to gain access to our resource (such as a file) using each string
    enumeration as the password.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不得不在顺序程序中使用暴力方法，我们就会创建一个循环，枚举从"`a`"到"`zzzzzz`"的所有字符串，并且每次都会检查它是否与变量`passwordToGuess`匹配。在现实生活中，我们不会有密码的值；相反，我们会尝试使用每个字符串枚举作为密码来访问我们的资源（例如文件）。
- en: To find our password faster, we can divide the range of our guesses among several
    goroutines. For example, goroutine A would try guesses from string enumerations
    1 to 10 million, goroutine B would try guesses from 10 million to 20 million,
    and so on (see figure 8.4). In this way, we can have many goroutines, each working
    on a separate part of our problem space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快地找到我们的密码，我们可以将猜测的范围分配给几个goroutine。例如，goroutine A将尝试从字符串枚举1到1000万，goroutine
    B将尝试从1000万到2000万，依此类推（见图8.4）。这样，我们可以有多个goroutine，每个goroutine都在我们问题空间的不同部分工作。
- en: '![](../../OEBPS/Images/CH08_F04_Cutajar.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F04_Cutajar.png)'
- en: Figure 8.4 Dividing the work among executions and closing the channel to stop
    them
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 在执行之间分配工作并关闭通道以停止它们
- en: To avoid unnecessary computations, we want to stop the execution of each goroutine
    when any goroutine makes a correct guess. To achieve this, we can use a channel
    to notify all other goroutines when one execution discovers the password, as shown
    in figure 8.4\. Once a goroutine finds the matching password, it closes a common
    channel. This has the effect of interrupting all participating goroutines and
    stopping the processing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不必要的计算，我们希望在任何一个goroutine做出正确猜测时停止每个goroutine的执行。为了实现这一点，我们可以使用一个通道来通知所有其他goroutine当一个执行发现密码时，如图8.4所示。一旦一个goroutine找到匹配的密码，它就关闭一个公共通道。这会中断所有参与goroutine并停止处理。
- en: Note We can use the `close()` operation on a channel to act like a signal being
    broadcast to all consumers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 我们可以在通道上使用`close()`操作来向所有消费者广播信号。
- en: How can we implement the logic to stop processing in all goroutines after a
    common channel is closed? One solution is to perform the necessary computation
    in the `select` statement’s default case and then have another case waiting on
    the common channel. In our example, we can call our `toBase27()` function and
    try to guess passwords in the default case, each time guessing just one password.
    We can have the logic to stop generating and trying passwords in a separate select
    case, which will be triggered when the common channel is closed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现关闭公共通道后停止所有goroutine处理的逻辑？一个解决方案是在`select`语句的默认情况下执行必要的计算，然后有一个等待公共通道的另一个情况。在我们的例子中，我们可以调用我们的`toBase27()`函数并在默认情况下尝试猜测密码，每次只猜测一个密码。我们可以将停止生成和尝试密码的逻辑放在一个单独的`select`情况中，这将触发当公共通道关闭时。
- en: Listing 8.5 shows a function that accepts this common channel, called `stop`.
    In the function, we generate all password guesses from the given range, represented
    by the `from` and `upto` integer variables. Each time we generate the next password
    guess, we try to match it against the `passwordToGuess` constant. This simulates
    the program trying to access a resource that is password protected. Once a password
    matches, the function closes the channel, resulting in all the goroutines receiving
    a close message on their own select case and stopping their processing because
    of the `return` statement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5显示了一个接受这个公共通道，称为`stop`的函数。在函数中，我们生成给定范围的密码猜测，这些范围由`from`和`upto`整数变量表示。每次我们生成下一个密码猜测时，我们尝试将其与`passwordToGuess`常量匹配。这模拟了程序尝试访问受密码保护的资源。一旦密码匹配，函数关闭通道，导致所有goroutine在自己的`select`情况下收到关闭消息，并由于`return`语句而停止处理。
- en: Listing 8.5 Brute force password discovery goroutine
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 强制力密码发现goroutine
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Loops over all password combinations using from and upto as starting and end
    points
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用from和upto作为起始点和结束点循环遍历所有密码组合
- en: ❷ Upon receiving a message on the stop channel, outputs a message and stops
    processing
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在收到停止通道的消息后，输出一条消息并停止处理
- en: ❸ Checks whether the password matches (in a real-life system, we would try to
    access the protected resource)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查密码是否匹配（在现实生活中的系统中，我们会尝试访问受保护的资源）
- en: ❹ Sends matching password on the result channel
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在结果通道上发送匹配的密码
- en: ❺ Closes the channel so that other goroutines stop checking the password
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 关闭通道，以便其他goroutine停止检查密码
- en: We can now create several goroutines executing the previous listing. Each goroutine
    will try to find the correct password within a certain range. In the following
    listing, the `main()` function creates the necessary channels and starts all the
    goroutines with their input ranges in steps of 10 million.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建几个执行前面列表的goroutine。每个goroutine将尝试在特定范围内找到正确的密码。在下面的列表中，`main()`函数创建了必要的通道，并以每步1000万为单位启动所有goroutine。
- en: Listing 8.6 `main()` function creating several goroutines with various password
    ranges
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 `main()` 函数创建具有各种密码范围的多个goroutine
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates a common channel used in the goroutines that signals when a password
    has been found
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个在goroutine中使用，用于在找到密码时发出信号的公共通道
- en: ❷ Creates a channel that will contain the discovered password after it’s found
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个通道，在找到密码后它将包含找到的密码
- en: ❸ Creates a goroutine with input ranges [1, 10M), [10M, 20M), . . . [380M, 390M)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个输入范围为[1, 10M), [10M, 20M), ... [380M, 390M)的goroutine
- en: ❹ Waits for the password to be found
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 等待找到密码
- en: ❺ Simulates the program using the password to access the resource
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用密码模拟程序访问资源
- en: 'After starting up all the goroutines, the `main()` function waits for an output
    message on the `passwordFound` channel. Once a goroutine discovers the correct
    password, it will send the password on its `result` channel to the `main()` function.
    When we run all the listings together, we get the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动所有goroutine后，`main()`函数等待`passwordFound`通道上的输出消息。一旦某个goroutine发现正确的密码，它将向`main()`函数发送密码到其`result`通道。当我们一起运行所有列表时，我们得到以下输出：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 8.1.4 Timing out on channels
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 通道超时
- en: Another useful scenario is blocking for only a specified amount of time, waiting
    for an operation on a channel. Just like in the previous two examples, we want
    to check to see whether a message has arrived on a channel, but we want to wait
    for a few seconds to see if a message arrives, instead of unblocking immediately
    and doing something else. This is useful in many situations when channel operations
    are time sensitive. Consider, for example, a financial trading application, where
    if we don’t receive a stock price update within a time window, we need to raise
    alerts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的场景是仅阻塞指定的时间，等待通道上的操作。就像在前两个例子中一样，我们想要检查通道上是否收到了消息，但我们想等待几秒钟看看是否收到消息，而不是立即解除阻塞并做其他事情。这在许多通道操作对时间敏感的情况下很有用。例如，考虑一个金融交易应用程序，如果我们没有在时间窗口内收到股票价格更新，我们需要发出警报。
- en: We can implement this behavior by using a separate goroutine that sends a message
    on an extra channel after a specified timeout. We can then use this extra channel
    in our `select` statement, together with the other channels. This will give us
    the effect of blocking on the `select` statement until any of the channels becomes
    available or the timeout occurs (see figure 8.5).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个单独的goroutine，在指定超时后向额外的通道发送消息来实现这种行为。然后我们可以使用这个额外的通道在我们的`select`语句中，与其他通道一起使用。这将给我们阻塞在`select`语句上的效果，直到任何通道变得可用或超时发生（见图8.5）。
- en: '![](../../OEBPS/Images/CH08_F05_Cutajar.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F05_Cutajar.png)'
- en: Figure 8.5 Using a timer to send a message on a channel to implement blocking
    with a timeout
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 使用定时器在通道上发送消息以实现带超时的阻塞
- en: Thankfully, the `time.Timer` type in Go provides us with this functionality,
    and we don’t have to implement our own timer goroutine. We can create one of these
    timers by calling `time.After(duration)`. This will return a channel on which
    a message is sent after the duration time elapses. The following listing shows
    an example of how we can use this with a `select` statement to implement channel
    blocking with a timeout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go中的`time.Timer`类型为我们提供了这个功能，我们不需要实现自己的定时器goroutine。我们可以通过调用`time.After(duration)`来创建这样的定时器。这将返回一个在持续时间过后发送消息的通道。以下列表展示了我们如何使用`select`语句与这个通道结合来实现带超时的通道阻塞。
- en: Listing 8.7 Blocking with a timeout
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 带超时的阻塞
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Sends the message “Hello” on the returned channel after the specified number
    of seconds
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在指定秒数后，在返回的通道上发送“Hello”消息
- en: ❷ Reads the timeout value from the program argument
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从程序参数中读取超时值
- en: ❸ Starts a goroutine that sends a message on the returned channel after 3 seconds
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动一个goroutine，在3秒后向返回的通道发送消息
- en: ❹ Reads a message from the messages channel if there is one
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果有消息，则从`messages`通道读取消息
- en: ❺ Creates a channel and timer, receiving a message after the specified duration
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个通道和定时器，在指定持续时间后接收消息
- en: 'Listing 8.7 accepts a timeout value as a program argument. We use this timeout
    to wait for a message to arrive on the `messages` channel, which arrives after
    3 seconds. Here’s the output of this program when we specify a timeout of less
    than 3 seconds:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7接受一个超时值作为程序参数。我们使用这个超时来等待`messages`通道上的消息到达，该消息在3秒后到达。以下是当我们指定小于3秒的超时时，这个程序的输出：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we specify a timeout greater than 3 seconds, the message arrives, as expected:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定大于3秒的超时时，消息如预期那样到达：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we use the `time.After(duration)` call, the returned channel will receive
    a message containing the time when the message was sent. In listing 8.7, we are
    simply outputting it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`time.After(duration)`调用时，返回的通道将接收到一个包含消息发送时间的消息。在列表8.7中，我们只是简单地输出了它。
- en: 8.1.5 Writing to channels with select
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.5 使用select向通道写入
- en: We can also use the `select` statement when we need to write messages to channels,
    not just when we are reading messages from channels. `Select` statements can combine
    read or write blocking channel operations together, selecting the case that unblocks
    first. As in the previous scenarios, we can use `select` to implement non-blocking
    channel sending or sending on a channel with a timeout. Let’s demonstrate a scenario
    that combines writing and reading from channels in a single `select` statement.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在需要向通道写入消息时使用`select`语句，而不仅仅是当我们从通道读取消息时。`Select`语句可以组合读取或写入阻塞通道操作，选择首先解锁的情况。与先前的场景一样，我们可以使用`select`来实现非阻塞通道发送或带有超时的通道发送。让我们演示一个在单个`select`语句中结合写入和读取通道的场景。
- en: Imagine we have to come up with 100 random prime numbers. In real life, we could
    pick a random number from a bag with a large set of numbers and then keep that
    number only if it is prime (see figure 8.6).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须生成100个随机质数。在现实生活中，我们可以从一个包含大量数字的袋子中随机抽取一个数字，然后只有当它是质数时才保留该数字（见图8.6）。
- en: '![](../../OEBPS/Images/CH08_F06_Cutajar.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F06_Cutajar.png)'
- en: Figure 8.6 Filtering primes from random numbers
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 从随机数中过滤质数
- en: 'In programming, we can have a primes filter that, given a stream of random
    numbers, picks out any prime number it finds and outputs it on another stream.
    In listing 8.8, the `primesOnly()` function does exactly this: it accepts a channel
    with input numbers and filters for prime numbers. The primes are output on the
    returned channel.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们可以有一个质数过滤器，给定一个随机数流，从中挑选出任何找到的质数，并将其输出到另一个流。在列表8.8中，`primesOnly()`函数正是这样做的：它接受一个包含输入数字的通道，并过滤出质数。质数输出在返回的通道上。
- en: To prove that a number, *C*, is non-prime, we just need to find a prime number
    in the range from 2 to the square root of *C* that is a factor of *C*. A *factor*
    is a number that divides another number, leaving no remainder. If no such factor
    exists, then *C* is prime. To keep our `primesOnly()` function implementation
    simple, we’ll check every integer in this range instead of checking every prime.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明一个数，*C*，是非质数，我们只需要在2到*C*的平方根范围内找到一个质数，它是*C*的因子。一个*因子*是除另一个数时没有余数的数。如果不存在这样的因子，那么*C*就是质数。为了使我们的`primesOnly()`函数实现简单，我们将检查这个范围内的每一个整数，而不是检查每一个质数。
- en: Listing 8.8 Goroutine filtering for prime numbers
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 质数Goroutine过滤
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Accepts numbers in the inputs channel and returns a channel containing only
    prime numbers
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接受输入通道中的数字并返回只包含质数的通道
- en: ❷ Creates an anonymous goroutine that will filter for prime numbers only
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个只过滤质数的匿名goroutine
- en: ❸ Checks to ensure c is not 1, since 1 is not a prime
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查以确保c不是1，因为1不是质数
- en: ❹ Checks to see if c has a factor in the range from 2 to the square root of
    c
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查c在2到c的平方根范围内是否有因子
- en: ❺ If c is prime, outputs c on the results channel
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果c是质数，则在结果通道上输出c
- en: 'Notice that in listing 8.8, our goroutine outputs a subset of the numbers it
    receives on the input channel. Often, the goroutine receives a non-prime number
    that is thrown away, meaning no number is output. How can we feed in a stream
    of random numbers while reading the primes returned on another channel in one
    goroutine? The answer is to use a `select` statement to both feed in the random
    numbers and read the primes. This is shown in the following listing, where the
    `main()` goroutine uses two select cases: one feeds the random numbers and another
    reads the primes.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表8.8中，我们的goroutine输出它在输入通道上接收到的数字的一个子集。通常，goroutine会接收到一个非质数，然后被丢弃，这意味着没有数字被输出。我们如何在单个goroutine中同时读取另一个通道上返回的质数并输入一个随机数流？答案是使用`select`语句来同时输入随机数和读取质数。这在下述列表中显示，其中`main()`
    goroutine使用了两个`select`情况：一个用于输入随机数，另一个用于读取质数。
- en: Listing 8.9 Feeding random numbers and collecting 100 primes
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 输入随机数并收集100个质数
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Repeats until we collect 100 prime numbers
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重复直到我们收集到100个质数
- en: ❷ Feeds a random number between 1 and 1 billion onto the input isPrimeChannel
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将1亿之间的随机数输入到isPrimeChannel输入通道
- en: ❸ Reads an output prime number
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 读取输出质数
- en: 'In listing 8.9, we continue executing until we collect 100 prime numbers. After
    running this, we get the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.9中，我们继续执行，直到收集到100个质数。运行此代码后，我们得到以下输出：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 8.1.6 Disabling select cases with nil channels
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.6 使用nil通道禁用select情况
- en: In Go, we can assign `nil` values to channels. This has the effect of blocking
    the channel from sending or receiving anything, as demonstrated in the following
    listing. The `main()` goroutine tries to send a string on a nil channel, and the
    operation blocks, stopping any further statements from executing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们可以将`nil`值赋给通道。这会阻止通道发送或接收任何内容，如下面的列表所示。`main()` goroutine尝试在一个nil通道上发送一个字符串，操作会阻塞，阻止任何进一步语句的执行。
- en: Listing 8.10 Blocking on a nil channel
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 在nil通道上阻塞
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Creates a nil channel
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个nil通道
- en: ❷ Blocks execution as it tries to send message on the nil channel
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试在nil通道上发送消息时阻塞执行
- en: 'When we run listing 8.10, the `Println()` command never gets executed because
    the execution blocks on the message sending. Go has deadlock detection, so when
    Go notices that the program is stuck with no hope of recovering, it gives us the
    following message:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行列表8.10时，`Println()`命令永远不会被执行，因为执行在消息发送上阻塞。Go有死锁检测，所以当Go注意到程序陷入僵局且没有恢复的希望时，它会给我们以下信息：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same logic applies to `select` statements. Trying to send to or receive
    from a nil channel on a `select` statement has the same effect of blocking the
    case using that channel (see figure 8.7).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑也适用于`select`语句。在`select`语句中尝试向nil通道发送或从nil通道接收会导致使用该通道的case阻塞（见图8.7）。
- en: '![](../../OEBPS/Images/CH08_F07_Cutajar.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F07_Cutajar.png)'
- en: Figure 8.7 Blocking on nil channels
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 在nil通道上阻塞
- en: Using `select` with just one nil channel is not that useful, but we can use
    the pattern of assigning `nil` to a channel to disable a case in a `select` statement.
    Consider a scenario where we are consuming messages from two separate goroutines
    on two separate channels, and the goroutines close their channels at different
    times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用只有一个nil通道的`select`并不那么有用，但我们可以使用将`nil`赋给通道的模式来在`select`语句中禁用一个case。考虑一个场景，我们正在从两个不同的goroutine和两个不同的通道中消费消息，这些goroutine在不同的时间关闭它们的通道。
- en: For example, we might be developing accounting software that receives sales
    and expense amounts from various sources. At the close of business, we want to
    output the total profit or loss for that day. We can model this by having a goroutine
    outputting sales details on one channel and another goroutine doing the same on
    another channel for expenses. We can then collate the two sources in another goroutine,
    and once both channels are closed, output the end-of-day balance to the user (see
    figure 8.8).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能正在开发会计软件，该软件从各种来源接收销售和费用金额。在业务结束时，我们希望输出当天的总利润或亏损。我们可以通过让一个goroutine在一个通道上输出销售详情，另一个goroutine在另一个通道上输出费用详情来模拟这种情况。然后我们可以在另一个goroutine中汇总这两个来源，一旦两个通道都关闭，就可以将日终余额输出给用户（见图8.8）。
- en: '![](../../OEBPS/Images/CH08_F08_Cutajar.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F08_Cutajar.png)'
- en: Figure 8.8 An accounting application reading sales and expenses from two sources
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 一个从两个来源读取销售和费用的会计应用程序
- en: Listing 8.11 simulates our expense and sales application. The `generateAmounts()`
    function will create `n` random transaction amounts and send them on an output
    channel. We can then call this function twice, once for sales and again for expenses,
    and our main goroutine can combine both channels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11模拟我们的费用和销售应用程序。`generateAmounts()`函数将创建n个随机交易金额并将它们发送到输出通道。然后我们可以调用这个函数两次，一次用于销售，再次用于费用，我们的主goroutine可以合并这两个通道。
- en: There is a small sleep inside the loop so that we can interleave both the sales
    and expense goroutines.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中有一个小的睡眠，这样我们就可以交错销售和费用goroutine。
- en: Listing 8.11 A `generateAmounts()` function generating sales and expenses
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 生成销售和费用的`generateAmounts()`函数
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Creates an output channel
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个输出通道
- en: ❷ Closes the output channel when we’re done
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 完成后关闭输出通道
- en: ❸ Writes n random amounts in the range of [1, 100] to the output channel every
    100 ms
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每100毫秒将n个随机金额写入[1, 100]范围内的输出通道
- en: ❹ Returns the output channel
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回输出通道
- en: If we were to use a normal `select` statement to consume from both the sales
    and expense goroutines, with one of the goroutines closing its channel earlier
    than the other, we would end up always executing on the closed channel case. Every
    time we consume from a closed channel, it will return the default data type without
    blocking. This also applies to select cases. In our simple accounting application,
    if we used a `select` statement to consume from both sources, we would end up
    needlessly looping on the closed channel select case, receiving `0` every time
    (see figure 8.9).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用正常的`select`语句从销售和费用goroutine中消费，其中一个goroutine比另一个goroutine先关闭其通道，我们最终总是在关闭通道的case上执行。每次我们从关闭的通道中消费时，它都会返回默认数据类型而不会阻塞。这也适用于select
    cases。在我们的简单会计应用程序中，如果我们使用`select`语句从两个来源中消费，我们最终会在关闭通道的select case上无谓地循环，每次都接收到`0`（见图8.9）。
- en: WARNING When we use a select case on a closed channel, that case will always
    execute.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：当我们在一个关闭的通道上使用select case时，该case将始终执行。
- en: '![](../../OEBPS/Images/CH08_F09_Cutajar.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F09_Cutajar.png)'
- en: Figure 8.9 Using a select case with a closed channel will result in that select
    case always executing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 使用带有关闭通道的select case将导致该select case始终执行。
- en: One solution to this problem is to have both the sales and expense goroutines
    output onto the same channel and then close the channel only when both goroutines
    are done. However, this might not always be an option, since it requires us to
    change the goroutine function’s signature so we can pass the same output channel
    to both sources. Sometimes, such as when using third-party libraries, changing
    the function’s signature is not possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是将销售和费用goroutine的输出都发送到同一个通道，然后在两个goroutine都完成后关闭通道。然而，这不一定总是可行的，因为这需要我们更改goroutine函数的签名，以便我们可以将相同的输出通道传递给两个来源。有时，例如在使用第三方库时，更改函数的签名是不可能的。
- en: 'Another solution would be to change the channel into a nil channel whenever
    it is closed. Reading from a channel always returns two values: the message and
    a flag telling us if the channel is still open. We can read the flag, and if the
    flag indicates that the channel has been closed, we can set the channel reference
    to `nil` (see figure 8.10).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是在通道关闭时将其更改为`nil`通道。从通道读取总是返回两个值：消息和一个标志告诉我们通道是否仍然开放。我们可以读取标志，如果标志指示通道已关闭，我们可以将通道引用设置为`nil`（见图8.10）。
- en: '![](../../OEBPS/Images/CH08_F10_Cutajar.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F10_Cutajar.png)'
- en: Figure 8.10 Assigning a nil channel when the channel is closed to disable the
    select case
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 当通道关闭时分配一个nil通道以禁用select case
- en: Assigning a `nil` value to the channel variable after the receiver detects that
    the channel has been closed has the effect of disabling that `case` statement.
    This allows the receiving goroutine to read from the remaining open channels.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器检测到通道已关闭后，将通道变量赋值为`nil`，这将禁用该`case`语句。这允许接收goroutine从剩余的开放通道中读取。
- en: Listing 8.12 shows how we can use this nil channel pattern for our accounting
    application. In the `main()` goroutine, we initialize the sales and expense sources,
    and then we use a `select` statement to consume from both. If either of the channels
    returns a flag indicating that the channel has been closed, we set the channel
    to `nil` to disable the select case. We continue selecting from the channels for
    as long as there is one non-nil channel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12展示了我们如何在我们的会计应用程序中使用这种`nil`通道模式。在`main()` goroutine中，我们初始化销售和费用来源，然后使用`select`语句从两者中消费。如果任一通道返回一个标志表示通道已关闭，我们将通道设置为`nil`以禁用select
    case。只要有一个非空通道，我们就继续从通道中选择。
- en: Listing 8.12 A `main()` goroutine using the nil select pattern
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 使用`nil` select模式的`main()` goroutine
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Generates 50 amounts on the sales channel
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在销售通道上生成50个金额
- en: ❷ Generates 40 amounts on the expenses channel
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在费用通道上生成40个金额
- en: ❸ Continues to loop while there is a non-nil channel
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当存在非空通道时继续循环
- en: ❹ Consumes the next amount and channel open flag from the sales channel\
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从销售通道中消费下一个金额和通道开放标志
- en: ❺ Adds the sales amount to the total end-of-day balance
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将销售金额添加到每日结束时的总余额中
- en: ❻ If the channel has been closed, marks the channel as nil, disabling this select
    case
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果通道已关闭，将通道标记为`nil`，禁用此select case
- en: ❼ Consumes the next amount and channel open flag from the expenses channel
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从费用通道中消费下一个金额和通道开放标志
- en: ❽ Subtracts the expense amount from the total end-of-day balance
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从每日结束时的总余额中减去费用金额
- en: ❾ If the channel has been closed, marks the channel as nil, disabling this select
    case
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果通道已被关闭，则将通道标记为 nil，禁用此 `select` 情况
- en: 'In listing 8.12, once both channels are closed and set to nil, we exit the
    `select` loop and output the end-of-day balance. Running listings 8.11 and 8.12
    together, we get the sales and expense amounts interleaved until we have consumed
    all the expenses and the channel has been closed. At this point, the `select`
    statement drains the sales channel and then exits the loop, printing the total
    balance:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.12 中，一旦两个通道都已关闭并设置为 nil，我们就退出 `select` 循环并输出日终余额。将列表 8.11 和 8.12 一起运行，我们得到销售和费用金额交替出现，直到我们消耗完所有费用并且通道已关闭。在此阶段，`select`
    语句清空销售通道，然后退出循环，打印总余额：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: NOTE This pattern of merging channel data into one stream is referred to as
    a *fan-in* pattern. Using the `select` statement to merge different sources only
    works when we have a fixed number of sources. In the next chapter, we will see
    a fan-in pattern that merges a dynamic number of sources.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：将通道数据合并到一个流中的这种模式被称为 *扇入* 模式。使用 `select` 语句合并不同的来源仅在我们有固定数量的来源时才有效。在下一章中，我们将看到一种扇入模式，该模式可以合并动态数量的来源。
- en: 8.2 Choosing between message passing and memory sharing
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 在消息传递和内存共享之间进行选择
- en: We can decide whether to use memory sharing or message passing for our concurrent
    applications depending on the type of solution we are trying to implement. In
    this section, we will examine the factors and implications that we should keep
    in mind when deciding which of the two approaches to use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据我们试图实现的解决方案类型来决定是否使用内存共享或消息传递来构建我们的并发应用程序。在本节中，我们将检查我们在决定使用两种方法中的哪一种时应考虑的因素和影响。
- en: 8.2.1 Balancing code simplicity
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 平衡代码的简洁性
- en: Producing simple, readable, and easy-to-maintain software code is ever more
    important with today’s complex business requirements and large development teams.
    Concurrent programming using message passing tends to produce code containing
    well-defined modules, each module running its own concurrent execution that passes
    messages to other executions. This makes code simpler and easier to understand.
    In addition, having clear input and output channels to the concurrent executions
    means that our program data flow is easier to grasp and, if needed, modify.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今复杂的企业需求和大型开发团队中，生产简单、可读且易于维护的软件代码变得越来越重要。使用消息传递进行并发编程往往会产生包含定义良好的模块的代码，每个模块运行自己的并发执行，并将消息传递给其他执行。这使得代码更简单，更容易理解。此外，具有清晰的输入和输出通道到并发执行意味着我们的程序数据流更容易掌握，如果需要，也更容易修改。
- en: In contrast, memory sharing means that we need to use a more primitive way of
    managing concurrency. Just like reading a low-level language, code that uses concurrency
    primitives (such as mutexes and semaphores) tends to be harder to follow. The
    code is usually more verbose and is littered with protected critical sections.
    Unlike message passing, it’s harder to determine how data flows through the application
    (see figure 8.11).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，内存共享意味着我们需要使用更原始的方式来管理并发。就像阅读低级语言一样，使用并发原语（如互斥锁和信号量）的代码往往更难跟踪。代码通常更冗长，并充满了受保护的临界区。与消息传递不同，确定数据如何通过应用程序流动更困难（参见图
    8.11）。
- en: '![](../../OEBPS/Images/CH08_F11_Cutajar.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F11_Cutajar.png)'
- en: Figure 8.11 Achieving the right balance between code simplicity and performance
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 在代码简洁性和性能之间取得正确的平衡
- en: 8.2.2 Designing tightly versus loosely coupled systems
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 设计紧密耦合与松散耦合的系统
- en: The terms *tightly* and *loosely* coupled software refer to how dependent different
    modules are on each other. *Tightly* coupled software means that when we change
    one component, it will have a ripple effect on many other parts of the software,
    which usually require changes as well. In loosely coupled software, components
    tend to have clear boundaries and few dependencies on other modules. In *loosely*
    coupled software, introducing a change in one component requires few or no changes
    in others (see figure 8.12). Loosely coupling is usually a software design goal
    and a desirable code property. It means that our software is easier to test and
    more maintainable, requiring less work whenever we introduce a new feature.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*紧密*耦合和*松散*耦合软件指的是不同模块之间相互依赖的程度。*紧密*耦合软件意味着当我们更改一个组件时，它将对软件的许多其他部分产生连锁反应，通常这些部分也需要进行更改。在松散耦合软件中，组件往往具有清晰的边界，对其他模块的依赖性很少。在*松散*耦合软件中，对某个组件的更改只需要对其他组件进行少量或没有更改（见图8.12）。松散耦合通常是软件设计目标和一个理想的代码属性。这意味着我们的软件更容易测试和更易于维护，在引入新功能时所需的工作量更少。
- en: '![](../../OEBPS/Images/CH08_F12_Cutajar.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH08_F12_Cutajar.png)'
- en: Figure 8.12 The difference between tight and loose code coupling
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 紧密耦合和松散代码耦合的区别
- en: Concurrent programming using memory sharing typically produces more tightly
    coupled software. The inter-thread communication uses a common block of memory,
    and the boundaries of each execution are not clearly defined. Any execution can
    read and write to the same location. Writing loosely coupled software while using
    memory sharing is more difficult than when using message passing because changing
    the way we update the shared memory from one execution will have a significant
    effect on the rest of the application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存共享进行并发编程通常会产生更紧密耦合的软件。线程间的通信使用一个共同的内存块，每个执行的边界并不明确。任何执行都可以读取和写入同一位置。在使用内存共享的同时编写松散耦合的软件比使用消息传递更困难，因为更改一个执行更新共享内存的方式将对整个应用程序产生重大影响。
- en: In contrast, with message passing, executions can have clearly defined input
    and output contracts, which means we know exactly how a change in one execution
    will affect another. For example, we can easily change the inside logic of a goroutine
    if the input and output contracts through our channels are maintained. This allows
    us to build loosely coupled systems more easily, and refactoring the logic in
    one module does not have a large ripple effect on the rest of the application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用消息传递，执行可以具有明确定义的输入和输出契约，这意味着我们知道一个执行中的更改将如何影响另一个执行。例如，如果我们通过通道维护输入和输出契约，我们可以轻松地更改goroutine的内部逻辑。这使我们更容易构建松散耦合的系统，并且在一个模块中重构逻辑不会对应用程序的其他部分产生大的连锁反应。
- en: NOTE This is not to say that all code that uses message passing is loosely coupled.
    Nor is all software that uses memory sharing tightly coupled. It is just easier
    to come up with a loosely coupled design using message passing because we can
    define simple boundaries for each concurrent execution with clear input and output
    channels.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这并不是说所有使用消息传递的代码都是松散耦合的。也不是所有使用内存共享的软件都是紧密耦合的。只是使用消息传递来设计松散耦合的方案更容易，因为我们可以为每个并发执行定义简单的边界，并具有清晰的输入和输出通道。
- en: 8.2.3 Optimizing memory consumption
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 优化内存消耗
- en: With message passing, each goroutine has its own isolated state stored in memory.
    When we pass messages from one goroutine to another, each organizes the data in
    its memory to compute its task. Often, there is some replication of the same data
    across multiple goroutines.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息传递时，每个goroutine都有其自己的隔离状态，存储在内存中。当我们从一个goroutine向另一个goroutine传递消息时，每个goroutine都会在其内存中组织数据以计算其任务。通常，在多个goroutine之间会有相同数据的复制。
- en: For example, consider the letter-frequency application we implemented in chapter
    3\. In our implementation, we used a Go slice shared among our goroutines. The
    program downloaded web pages using concurrent goroutines and used this shared
    slice to store the number of times that each letter in the English alphabet appeared
    in the downloaded document (see the left side of figure 8.13). We could change
    the program to use message passing by having each goroutine build a local instance
    of a slice with the frequencies encountered while downloading its web page. After
    counting the letter frequencies, each goroutine would send a message on an output
    channel with the slice containing the results. In our `main()` function, we could
    then collect the results and merge them (see the right side of figure 8.13).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在第3章中实现的字母频率应用。在我们的实现中，我们使用了在goroutines之间共享的Go切片。程序使用并发goroutines下载网页，并使用这个共享切片来存储下载文档中每个英文字母出现的次数（见图8.13的左侧）。我们可以将程序修改为使用消息传递，让每个goroutine在下载其网页时构建一个包含遇到频率的本地切片实例。在计算字母频率后，每个goroutine会在输出通道上发送一个包含结果的切片消息。然后，在我们的`main()`函数中，我们可以收集这些结果并将它们合并（见图8.13的右侧）。
- en: '![](../../OEBPS/Images/CH08_F13_Cutajar.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F13_Cutajar.png)'
- en: Figure 8.13 Message passing can result in more memory consumption.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 消息传递可能导致内存消耗增加。
- en: Listing 8.13 shows how we could implement a goroutine that downloads a web document
    and counts the occurrences of each letter in the alphabet. It has its own local
    slice data structure instead of a shared one.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13显示了如何实现一个goroutine，该goroutine下载网页并计算字母表中每个字母的出现次数。它有自己的本地切片数据结构，而不是共享的。
- en: Once it’s done, it sends the results to its output channel.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，它将结果发送到其输出通道。
- en: Listing 8.13 Letter-frequency function using message passing (imports omitted)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 使用消息传递的字母频率函数（省略了导入）
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Creates output channel of type int slice
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含int切片类型的输出通道
- en: ❷ Creates a local frequency slice
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个本地频率切片
- en: ❸ Updates each character count in the local frequency slice
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新本地频率切片中的每个字符计数
- en: ❹ Once it’s finished, the frequency slice is sent over the channel.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一旦完成，频率切片将通过通道发送。
- en: We can now add a `main()` function that starts a goroutine for each web page
    and waits for messages from each output channel. Once we start receiving messages
    containing the slices, we can merge them into a final slice. The following listing
    shows how we can do this, summing each slice into the `totalFrequencies` slice.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个`main()`函数，为每个网页启动一个goroutine，并等待每个输出通道的消息。一旦我们开始接收包含切片的消息，我们就可以将它们合并到一个最终的切片中。下面的列表显示了我们可以如何做到这一点，将每个切片累加到`totalFrequencies`切片中。
- en: Listing 8.14 Main function for the message-passing letter-frequency program
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.14 消息传递字母频率程序的主函数
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Creates a slice to contain all output channels
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个包含所有输出通道的切片
- en: ❷ Creates a slice to store the frequency for each letter in the English alphabet
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个切片来存储英文字母的频率
- en: ❸ Creates a goroutine for each web page and stores the output channel in the
    results slice
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每个网页创建一个goroutine并将输出通道存储在结果切片中
- en: ❹ Iterates over each output channel
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历每个输出通道
- en: ❺ Receives a message from each output channel containing the frequencies for
    one web page
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从每个输出通道接收包含一个网页频率的消息
- en: ❻ Adds the frequency counts to the total frequencies for each letter
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将频率计数添加到每个字母的总频率中
- en: In converting our program to use message passing, we have avoided using mutexes
    to control access to shared memory since each goroutine is now only working on
    its own data. However, in doing so, we have increased the memory use since we
    have allocated a slice for each web page. For this simple application, the memory
    increase is minimal because we’re only using a small slice of size 26\. For applications
    that pass structures containing larger amounts of data, we might be better off
    using memory sharing to reduce memory consumption.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的程序转换为使用消息传递时，我们避免了使用互斥锁来控制对共享内存的访问，因为每个goroutine现在只在自己的数据上工作。然而，这样做增加了内存使用，因为我们为每个网页分配了一个切片。对于这个简单的应用，内存增加是微不足道的，因为我们只使用了一个大小为26的小切片。对于传递包含大量数据的结构的应用，我们可能更倾向于使用内存共享来减少内存消耗。
- en: 8.2.4 Communicating efficiently
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 高效通信
- en: Message passing will degrade the performance of our application if we are spending
    too much time passing messages around. Since we pass copies of messages from one
    goroutine to another, we suffer the performance penalty of spending time copying
    the data in the message. This extra performance cost is noticeable if the messages
    are large or numerous.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在传递消息上花费太多时间，消息传递将降低我们应用程序的性能。由于我们从goroutine到goroutine传递消息的副本，我们承受了复制消息中数据的时间性能损失。如果消息很大或数量很多，这种额外的性能成本是明显的。
- en: One scenario is when the message size is too large. Consider, for example, an
    image or video processing application applying various filters on the images concurrently.
    Copying huge blocks of memory containing images or videos just to pass them on
    channels might greatly reduce our performance. If the amount of data shared is
    large and we have performance constraints, we might be better off using memory
    sharing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一种情况是当消息大小太大时。例如，考虑一个图像或视频处理应用程序，它对图像进行并发处理，应用各种过滤器。仅仅为了通过通道传递，就复制包含图像或视频的大量内存块，可能会大大降低我们的性能。如果共享的数据量很大，并且我们有性能限制，我们可能更倾向于使用内存共享。
- en: The other scenario is when our executions are very chatty—when concurrent executions
    need to send many messages to each other. For example, we can imagine a weather
    forecasting application that uses concurrent programming to speed up its weather
    calculations. Figure 8.14 shows how we could split the weather forecasting area
    into a grid and distribute the computational work of forecasting the weather for
    each grid square to a separate goroutine.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是我们的执行非常频繁——当并发执行需要相互发送大量消息时。例如，我们可以想象一个使用并发编程来加速其天气预报的天气预报应用程序。图8.14显示了我们可以如何将天气预报区域分割成网格，并将预测每个网格方块天气的计算工作分配给单独的goroutine。
- en: '![](../../OEBPS/Images/CH08_F14_Cutajar.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH08_F14_Cutajar.png)'
- en: Figure 8.14 Using concurrent executions to speed up weather forecasting
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 使用并发执行加速天气预报
- en: 'To calculate the weather forecast in each grid square, a goroutine might need
    information from calculations in all the other grids. Each goroutine might need
    to send and receive partial calculation results from all the other goroutines,
    and this process might have to be repeated multiple times until the forecasting
    calculations converge. Our made-up algorithm, running in each goroutine, might
    look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算每个网格方块中的天气预报，goroutine可能需要从所有其他网格的计算中获取信息。每个goroutine可能需要从所有其他goroutine发送和接收部分计算结果，这个过程可能需要重复多次，直到预测计算收敛。我们编写的算法，在每个goroutine中运行，可能看起来像这样：
- en: Calculate partial results for the goroutine’s grid square.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为goroutine的网格方块计算部分结果。
- en: Send partial results to all other goroutines, each working on its own grid square.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将部分结果发送给所有其他goroutine，每个goroutine都在其自己的网格方块上工作。
- en: Receive partial results from every other goroutine, and include them in the
    next calculation.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个其他goroutine接收部分结果，并将它们包含在下一个计算中。
- en: Repeat from `1` until the calculation is fully complete.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`1`开始重复，直到计算完全完成。
- en: Using message passing for such a scenario would mean that we would be sending
    a huge number of messages on every iteration. Every goroutine would have to send
    its partial results to all other goroutines and then receive the other grid results
    from every goroutine. In this scenario, our application would end up spending
    a lot of time and memory to copy and pass the values around.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用消息传递意味着我们会在每次迭代中发送大量的消息。每个goroutine都必须将其部分结果发送给所有其他goroutine，然后从每个goroutine接收其他网格的结果。在这种情况下，我们的应用程序最终会花费大量时间和内存来复制和传递值。
- en: In such scenarios, we are likely better off using memory sharing. For example,
    we could allocate a shared two-dimensional array space and let the goroutines
    read each other’s grid results, using the appropriate synchronization tools, such
    as readers–writer locks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能更倾向于使用内存共享。例如，我们可以分配一个共享的二维数组空间，并让goroutines读取彼此的网格结果，使用适当的同步工具，如读者-写者锁。
- en: 8.3 Exercises
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 练习
- en: NOTE Visit [http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)
    to see all the code solutions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：访问[http://github.com/cutajarj/ConcurrentProgrammingWithGo](http://github.com/cutajarj/ConcurrentProgrammingWithGo)以查看所有代码解决方案。
- en: In listing 8.15, we have two goroutines. The `generateTemp()` function simulates
    reading and sending the temperature on a channel every 200 ms. The `outputTemp()`
    function simply outputs a message found on a channel every 2 seconds. Can you
    write a `main()` function, using a `select` statement, that reads messages coming
    from the `generateTemp()` goroutine and sends only the latest temperature to the
    `outputTemp()` channel? Since the `generateTemp()` function outputs values faster
    than the `outputTemp()` function, you’ll need to discard some values so that only
    the most up-to-date temperature is displayed.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表8.15中，我们有两个goroutine。`generateTemp()`函数模拟每200毫秒在通道上读取和发送温度。`outputTemp()`函数简单地每2秒在通道上输出一条消息。你能写一个`main()`函数，使用`select`语句读取来自`generateTemp()`
    goroutine的消息，并将最新的温度发送到`outputTemp()`通道吗？由于`generateTemp()`函数输出值的速度比`outputTemp()`函数快，你需要丢弃一些值，以确保只显示最新的温度。
- en: Listing 8.15 Latest temperature exercise
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.15 最新温度练习
- en: '[PRE22]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In listing 8.16, we have a goroutine in the `generateNumbers()` function that
    outputs random numbers. Can you write a `main()` function using a `select` statement
    that continuously consumes from the output channel, printing the output on the
    console until 5 seconds have elapsed from the start of the program? After 5 seconds,
    the function should stop consuming from the output channel, and the program should
    terminate.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表8.16中，`generateNumbers()`函数中有一个goroutine输出随机数。你能写一个使用`select`语句的`main()`函数，持续从输出通道中消费，直到程序开始后的5秒内打印到控制台上的输出吗？5秒后，函数应停止从输出通道中消费，程序应终止。
- en: Listing 8.16 Stop-reading-after-5-seconds exercise
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.16 停止读取5秒练习
- en: '[PRE23]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Consider listing 8.17 containing the `player()` function. This function creates
    a goroutine simulating a player in a game moving along a two-dimensional plane.
    The goroutine returns the movements at random times by writing `UP`, `DOWN`, `LEFT`,
    or `RIGHT` on an output channel. Create a `main()` function that creates four
    player goroutines and outputs on the console all movements from the four players.
    The `main()` function should terminate only when there is one player left in the
    game. Here is an example of what the output should look like:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑包含`player()`函数的列表8.17。此函数创建一个goroutine模拟在二维平面上移动的游戏玩家。goroutine通过在输出通道上写入`UP`、`DOWN`、`LEFT`或`RIGHT`在随机时间返回移动。创建一个`main()`函数，创建四个玩家goroutine，并在控制台上输出四个玩家的所有移动。`main()`函数应在游戏中只剩下一个玩家时终止。以下是一个输出示例：
- en: '[PRE24]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 8.17 Simulating game players
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.17 模拟游戏玩家
- en: '[PRE25]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: When multiple channel operations are combined using the `select` statement,
    the operation that is unblocked first gets executed.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`select`语句组合多个通道操作时，首先解除阻塞的操作将被执行。
- en: We can have non-blocking behavior on a blocking channel by using the default
    case on the `select` statement.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在`select`语句中使用默认情况，在阻塞通道上实现非阻塞行为。
- en: Combining a send or receive channel operation with a `Timer` channel on a `select`
    statement results in blocking on a channel up to the specified timeout.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`select`语句中将发送或接收通道操作与`Timer`通道结合会导致在指定超时时间内阻塞通道。
- en: The `select` statement can be used not just for receiving messages but also
    for sending.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`语句不仅可以用于接收消息，还可以用于发送。'
- en: Trying to send to or receive from a nil channel results in blocking the execution.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试向或从nil通道发送或接收消息会导致执行阻塞。
- en: Select cases can be disabled when we use nil channels.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用nil通道时，可以禁用`select`情况。
- en: Message passing produces simpler code that is easier to understand.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递产生更简单、更容易理解的代码。
- en: Tightly coupled code results in applications in which it is difficult to add
    new features.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密耦合的代码会导致难以添加新功能的应用程序。
- en: Code written in a loosely coupled way is easier to maintain.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以松散耦合方式编写的代码更容易维护。
- en: Loosely coupled software with message passing tends to be simpler and more readable
    than using memory sharing.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息传递的松散耦合软件通常比使用内存共享更简单、更易读。
- en: Concurrent applications using message passing might consume more memory because
    each execution has its own isolated state instead of a shared one.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息传递的并发应用程序可能会消耗更多内存，因为每个执行都有自己的独立状态，而不是共享状态。
- en: Concurrent applications requiring the exchange of large chunks of data might
    be better off using memory sharing because copying this data for message passing
    may greatly degrade performance.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要交换大量数据的同时运行的应用程序可能更适合使用内存共享，因为为消息传递而复制这些数据可能会极大地降低性能。
- en: Memory sharing is more suited for applications that would exchange a huge number
    of messages if they were to use message passing.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存共享更适合那些如果使用消息传递将会交换大量消息的应用程序。
