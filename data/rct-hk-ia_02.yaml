- en: 1 React is evolving
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 React 正在不断发展
- en: '*React* is a JavaScript library for building beautiful user interfaces. The
    React team wants the developer experience to be as great as possible so that developers
    are inspired and enabled to create delightful, productive user experiences. *React
    Hooks in Action with Suspense and Concurrent Mode* is your guide to some of the
    latest additions to the library, additions that can simplify your code, improve
    code reuse, and help make your applications slicker and more responsive, leading
    to happier developers and happier users.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*React* 是一个用于构建美观用户界面的 JavaScript 库。React 团队希望开发者的体验尽可能出色，以便开发者能够受到启发并能够创建令人愉悦、高效的用户体验。"React
    Hooks in Action with Suspense and Concurrent Mode" 是您了解库中最新添加功能的指南，这些功能可以简化您的代码，提高代码重用性，并帮助使您的应用程序更加流畅和响应迅速，从而让开发者和用户都更加满意。'
- en: This chapter gives a brief overview of React and its new features to whet your
    appetite for the details that follow later in the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了 React 及其新功能，以激发您对书中后续详细内容的兴趣。
- en: 1.1 What is React?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是 React？
- en: Say you are creating a user interface (UI) for the web, the desktop, for a smartphone,
    or even for a virtual reality (VR) experience. You want your page or app to display
    a variety of data that changes over time, like authenticated user info, filterable
    product lists, data visualization, or customer details. You expect the user to
    interact with the app, choosing filters and data sets and customers to view, filling
    in form fields, or even exploring a VR space! Or maybe your app will consume data
    from a network or from the internet, like social media updates, stock tickers,
    or product availability. React is here to help.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在创建一个用于网页、桌面、智能手机或甚至虚拟现实（VR）体验的用户界面（UI）。您希望您的页面或应用能够显示随时间变化的各种数据，如认证用户信息、可筛选的产品列表、数据可视化或客户详情。您期望用户与该应用交互，选择过滤器、数据集和客户进行查看，填写表单字段，甚至探索
    VR 空间！或者，也许您的应用将从网络或互联网中获取数据，如社交媒体更新、股票行情或产品可用性。React 正在这里帮助。
- en: React makes it easy to build user interface *components* that are composable
    and reusable and that react to changes in data and to user interactions. A page
    from a social media site includes buttons, posts, comments, images, and video,
    among many other interface components. React helps update the interface as the
    user scrolls down the page, opens up posts, adds comments, or transitions to other
    views. Some components on the page might have repeated *subcomponents*, page elements
    with the same structure but different content. And those subcomponents could be
    made up of components too! There are image thumbnails, repeated buttons, clickable
    text, and icons aplenty. Taken as a whole, the page has hundreds of such elements.
    But by breaking such rich interfaces into reusable components, development teams
    can more easily focus on specific areas of functionality and put the components
    to use on multiple pages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: React 使得构建可组合、可重用且对数据变化和用户交互做出反应的用户界面组件变得简单。社交媒体网站的一页可能包括按钮、帖子、评论、图片和视频等众多界面组件。React
    帮助更新界面，当用户滚动页面、打开帖子、添加评论或切换到其他视图时。页面上的某些组件可能有重复的 *子组件*，即具有相同结构但内容不同的页面元素。而这些子组件也可以由组件组成！这里有图片缩略图、重复的按钮、可点击文本和图标。整体来看，页面有数百个这样的元素。但通过将这些丰富的界面分解为可重用组件，开发团队能够更容易地专注于特定功能区域，并将组件用于多个页面。
- en: Making it easy to define and reuse components, and compose them into complex
    but understandable and usable interfaces is one of React’s core purposes. Other
    frontend libraries are out there (like AngularJS, Vue.js, and Ember.js), but this
    is a React book, so we concentrate on how React approaches components, data flow,
    and code reuse.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使定义和重用组件，并将它们组合成复杂但易于理解和使用的界面变得简单，这是 React 的核心目的之一。其他前端库也存在（如 AngularJS、Vue.js
    和 Ember.js），但这是一本关于 React 的书，所以我们专注于 React 如何处理组件、数据流和代码重用。
- en: 'Over the next few sections, we take a high-level look at how React helps developers
    build such apps, highlighting five of its key features:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将从高层次的角度了解 React 如何帮助开发者构建这样的应用程序，突出其五个关键特性：
- en: Building UI from reusable, composable components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从可重用、可组合的组件构建用户界面
- en: Describing UI by using JSX—a blend of HTML-style templating and JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSX 描述 UI——HTML 风格的模板与 JavaScript 的结合
- en: Making the most of JavaScript without introducing too many idiomatic constraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不引入太多惯用约束的情况下充分利用 JavaScript
- en: Intelligently synchronizing state and UI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能同步状态和 UI
- en: Helping manage the fetching of code, assets, and data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助管理代码、资源和数据的获取
- en: 1.1.1 Building a UI from components
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 从组件构建UI
- en: Social media sites show rich, hierarchical, multilayered user interfaces that
    React can help you design and code. But for now, let’s start with something a
    bit simpler to get a feel for the features of React.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 社交媒体网站展示了丰富的、分层的、多层次的用户界面，React可以帮助你设计和编码。但就目前而言，让我们从一个稍微简单一些的例子开始，以了解React的功能。
- en: Say you want to build a quiz app to help learners test themselves on facts they’ve
    been studying. Your component should be able to show and hide questions, and show
    and hide answers. One question-and-answer pair might look something like figure
    1.1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想构建一个测验应用来帮助学习者测试他们所学习的事实。你的组件应该能够显示和隐藏问题，以及显示和隐藏答案。一个问题及答案对可能看起来像图1.1。
- en: '![](../Images/1-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/1-1.png)'
- en: Figure 1.1 Part of a quiz app showing a question and an answer
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 显示问题及答案的测验应用的一部分
- en: 'You could create a component for the question section and a component for the
    answer section. But the structure of the two components is the same: each has
    a title, some text to show and hide, and a button to do the showing and hiding.
    React makes it easy to define a single component, say a `TextToggle` component,
    that you can use for both the question and the answer. You pass the title and
    text and whether the text should be shown to each of your `TextToggle` components.
    You pass the values as properties (or props), something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为问题部分创建一个组件，为答案部分创建另一个组件。但这两个组件的结构是相同的：每个组件都有一个标题，一些显示和隐藏的文本，以及一个用于显示和隐藏的按钮。React使得定义一个单一的组件变得容易，比如一个`TextToggle`组件，你可以用它来处理问题和答案。你将标题、文本以及是否显示文本传递给每个`TextToggle`组件。你将这些值作为属性（或props）传递，类似于这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Wait! What now? Is that HTML? XML? JavaScript? Well, programming with React
    is programming in JavaScript. But React provides an HTML-like syntax for describing
    your UI called JSX. Before running your app, the JSX needs to be preprocessed
    to convert it into the actual JavaScript that creates the elements of your user
    interface. At first it seems a bit strange, mixing HTML with your JavaScript,
    but it turns out the convenience is a big plus. And once your code finally runs
    in the browser (or other environment), it really is just JavaScript. A package
    called *Babel* is almost always used to compile the code you write into the code
    that will run. You can find out more about Babel at [https://babeljs.io](https://babeljs.io/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！现在是什么？这是HTML？XML？JavaScript？嗯，用React编程就是用JavaScript编程。但React提供了一个类似于HTML的语法来描述你的UI，称为JSX。在运行你的应用之前，JSX需要预处理以将其转换为创建用户界面元素的实际JavaScript。一开始这似乎有点奇怪，将HTML与JavaScript混合，但事实证明这种便利性是一个很大的优点。一旦你的代码最终在浏览器（或其他环境）中运行，它实际上就是JavaScript。一个名为*Babel*的包几乎总是用来将你编写的代码编译成将要运行的代码。你可以在[https://babeljs.io](https://babeljs.io/)了解更多关于Babel的信息。
- en: This chapter offers only a high-level overview of React, so we won’t explore
    JSX any further here. It’s worth mentioning up front, though, because it’s a widely
    used part of React development. In fact, in my opinion, React’s JavaScriptiness
    is one of its appeals—*although other opinions are available*—and, for the most
    part, it doesn’t introduce many constraints. While best practices have emerged
    and continue to do so, being a good JavaScript programmer and being a good React
    programmer are very similar skills.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅提供了一个React的高级概述，因此我们在这里不会进一步探讨JSX。不过，提前提一下是值得的，因为它是React开发中广泛使用的一部分。实际上，在我看来，React的JavaScript特性是其吸引力之一——尽管其他观点也是可用的——而且，在大多数情况下，它并没有引入很多限制。尽管最佳实践已经出现并且仍在继续出现，但成为一名优秀的JavaScript程序员和成为一名优秀的React程序员是非常相似的技术。
- en: So, say you’ve created the `TextToggle` component; what’s next? With React,
    you can define new components made up of existing components. You can encapsulate
    the question card, showing the question and the answer, as its own `QuestionCard`
    component. And if you want to show multiple questions at once, your `Quiz` component
    UI could be made up of multiple `QuestionCard` components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了`TextToggle`组件；接下来是什么？使用React，你可以定义由现有组件组成的新组件。你可以将问题卡（显示问题和答案）封装成自己的`QuestionCard`组件。如果你想同时显示多个问题，你的`Quiz`组件UI可以由多个`QuestionCard`组件组成。
- en: Figure 1.2 shows two `QuestionCard` components making up a `Quiz` component.
    The `Quiz` component is a container for the `QuestionCard`s and has no visible
    presence apart from the cards it contains.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 显示了由两个 `QuestionCard` 组件组成的 `Quiz` 组件。`Quiz` 组件是 `QuestionCard` 的容器，除了包含的卡片外，没有可见的存在。
- en: '![](../Images/1-2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-2.png)'
- en: Figure 1.2 `Quiz` component showing two `QuestionCard` components
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 显示两个 `QuestionCard` 组件的 `Quiz` 组件
- en: So, the `Quiz` component is made up of `QuestionCard` components, and they,
    in turn, are made up of `TextToggle` components, which are made up of standard
    HTML elements—an `h2`, a `p`, and a `button`, for example. Ultimately, the `Quiz`
    component comprises all native UI elements. Figure 1.3 shows the simple hierarchy
    for your `Quiz` component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Quiz` 组件由 `QuestionCard` 组件组成，而它们又由 `TextToggle` 组件组成，这些组件由标准的 HTML 元素组成——例如
    `h2`、`p` 和 `button`。最终，`Quiz` 组件包含所有原生 UI 元素。图 1.3 显示了您的 `Quiz` 组件的简单层次结构。
- en: '![](../Images/1-3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-3.png)'
- en: Figure 1.3 `Quiz` component hierarchy
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 `Quiz` 组件层次结构
- en: React makes this component creation and composition much easier. And once you’ve
    crafted your components, you can reuse them and share them easily, too. Imagine
    a learning resource site with different pages for different topics. On each page,
    you could include your `Quiz` component, just passing it the quiz data for that
    topic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: React 使这种组件创建和组合变得容易得多。一旦您制作了组件，您就可以轻松地重用和共享它们。想象一个学习资源网站，它为不同的主题提供不同的页面。在每一页上，您都可以包含您的
    `Quiz` 组件，只需传递该主题的测验数据即可。
- en: Many React components are available to download in package management repositories
    like npm. There’s no need to re-create common use cases, simple or complex, when
    well-used, well-tested examples of drop-down menus, date pickers, rich text editors,
    and probably quiz templates, also, are ready and waiting to be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 React 组件可以在 npm 等包管理存储库中下载。当有现成的、经过良好使用和测试的示例，如下拉菜单、日期选择器、富文本编辑器和可能还有测验模板时，无需重新创建常见用例，无论是简单还是复杂。
- en: React also provides mechanisms and patterns for passing your app’s data to the
    components that need them. In fact, that synchronization, of state and UI, goes
    to the heart of what React is and what it does.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: React 还提供了机制和模式，用于将您的应用程序数据传递给需要它们的组件。实际上，这种状态和 UI 的同步是 React 的核心所在，也是它所做的事情。
- en: 1.1.2 Synchronizing state and UI
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 同步状态和 UI
- en: React keeps an app’s user interface synchronized with its data. The data held
    in your app at any moment is called the app’s *state* and might include, for example,
    current posts, details about the logged-in user, whether comments are shown or
    hidden, or the content of a text input field. If new data arrives over the network
    or a user updates a value via a button or text input, React works out what changes
    need to be made to the display and efficiently updates it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: React 保持应用程序的用户界面与其数据同步。在任何时刻存储在您应用程序中的数据被称为应用程序的 *状态*，可能包括，例如，当前帖子、登录用户的详细信息、是否显示或隐藏评论，或文本输入字段的内
    容。如果通过网络到达新的数据或用户通过按钮或文本输入更新值，React 会计算出需要对显示进行哪些更改，并高效地更新它。
- en: React intelligently schedules the order and timing of the updates to optimize
    the perceived performance of your app and improve the user experience. Figure
    1.4 represents this idea, that React responds to a change in a component’s state
    by re-rendering the user interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: React 智能地安排更新顺序和时机，以优化应用程序的感知性能并提高用户体验。图 1.4 代表了这个想法，即 React 通过重新渲染用户界面来响应用件状态的变化。
- en: '![](../Images/1-4.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-4.png)'
- en: Figure 1.4 When a value in a component’s state changes, React re-renders the
    user interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 当组件的状态中的值发生变化时，React 会重新渲染用户界面。
- en: But updating state and re-rendering is not a one-off task. A visitor using your
    app is likely to cause a multitude of state changes, and React will need to repeatedly
    ask your components for the latest UI that represents those latest state values.
    It’s your components’ job to convert their state and props (the properties passed
    to them) into a description of their user interface. React then takes those UI
    descriptions and schedules updates to the browser’s Document Object Model (DOM)
    where necessary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但更新状态和重新渲染不是一个一次性任务。使用您应用程序的访客可能会引起大量的状态变化，React 将需要反复询问您的组件以获取表示最新状态值的最新 UI。您的组件的职责是将它们的状
    态和属性（传递给它们的属性）转换为它们用户界面的描述。然后 React 会根据需要将这些 UI 描述安排到浏览器文档对象模型 (DOM) 中进行更新。
- en: Cycle diagrams
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 循环图
- en: To represent the ongoing cycle of state changes and UI updates, this book uses
    circular cycle diagrams to illustrate the interactions between your components
    and React. Figure 1.5 is a simple example, showing how React calls your component
    code when the component first appears and when a user updates a value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示状态变化和UI更新的持续周期，本书使用圆形周期图来展示您的组件与React之间的交互。图1.5是一个简单的例子，展示了组件首次出现时以及用户更新值时React如何调用您的组件代码。
- en: '![](../Images/1-5.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-5.png)'
- en: Figure 1.5 React calls and re-calls your component to generate a description
    of its UI using the latest state.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 React调用并重新调用您的组件以使用最新的状态生成其UI的描述。
- en: The cycle diagrams are accompanied by tables, like table 1.1, describing the
    diagrams’ steps in more detail. The diagram and table pair don’t necessarily cover
    everything that is happening but pull out the key steps to help you understand
    the similarities and differences related to the way components work in different
    scenarios.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 周期图旁边附有表格，如表1.1，更详细地描述了图的步骤。图和表的配对不一定涵盖所有发生的事情，但提取了关键步骤，以帮助您理解与组件在不同场景下工作相关的相似之处和不同之处。
- en: For example, this section’s figure doesn’t show *how* the event handler works
    with React to update the state; that detail is added in later diagrams when introducing
    the relevant React Hooks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，本节中的图示没有显示事件处理程序如何与React一起更新状态；这个细节将在介绍相关React Hooks的后续图中添加。
- en: Table 1.1 Some key steps when React calls and re-calls a function component
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 当React调用并重新调用函数组件时的关键步骤
- en: '| Step | What happens? | Discussion |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 发生了什么？ | 讨论 |'
- en: '| 1 | React calls the component. | To generate the UI for the page, React traverses
    the tree of components, calling each one. React will pass each component any props
    set as attributes in the JSX. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | React调用组件。 | 为了生成页面的UI，React遍历组件树，调用每个组件。React将传递给每个组件任何在JSX中设置的属性作为props。
    |'
- en: '| 2 | The component specifies an event handler. | The event handler may listen
    for user clicks, timers firing, or resources loading, for example. The handler
    will change the state when it runs later. React will hook up the handler to the
    DOM when it updates the DOM in step 4. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 组件指定了一个事件处理程序。 | 事件处理程序可能监听用户点击、计时器触发或资源加载等。处理程序将在稍后运行时更改状态。React将在步骤4更新DOM时将处理程序连接到DOM。
    |'
- en: '| 3 | The component returns its UI. | The component uses the current state
    value to generate its user interface and returns it, finishing its work. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 组件返回其用户界面。 | 组件使用当前状态值来生成其用户界面并将其返回，完成其工作。 |'
- en: '| 4 | React updates the DOM. | React compares the description of the UI the
    component returns with the current description of the app’s UI. It efficiently
    makes any necessary changes to the DOM and sets up or updates event handlers as
    necessary. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 4 | React更新DOM。 | React将组件返回的UI描述与当前的应用程序UI描述进行比较。它高效地做出任何必要的DOM更改，并根据需要设置或更新事件处理程序。
    |'
- en: '| 5 | The event handler fires. | An event fires, and the handler runs. The
    handler changes the state. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 事件处理程序被触发。 | 发生了一个事件，并且处理程序运行。处理程序更改了状态。 |'
- en: '| 6 | React calls the component. | React knows the state value has changed
    so must recalculate the UI. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 6 | React调用组件。 | React知道状态值已更改，因此必须重新计算UI。 |'
- en: '| 7 | The component specifies an event handler. | This is a new version of
    the handler and may use the newly updated state value. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 组件指定了一个事件处理程序。 | 这是一个新版本的处理程序，可能使用新更新的状态值。 |'
- en: '| 8 | The component returns its UI. | The component uses the current state
    value to generate its user interface and returns it, finishing its work. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 组件返回其用户界面。 | 组件使用当前状态值来生成其用户界面并将其返回，完成其工作。 |'
- en: '| 9 | React updates the DOM. | React compares the description of the UI the
    component returns with the previous description of the app’s UI. It efficiently
    makes any necessary changes to the DOM and sets up or updates event handlers as
    necessary. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 9 | React更新DOM。 | React将组件返回的UI描述与应用程序UI的先前描述进行比较。它高效地做出任何必要的DOM更改，并根据需要设置或更新事件处理程序。
    |'
- en: The illustrations also use consistent icons to represent key objects and actions
    discussed in the surrounding text, such as components, state values, event handlers,
    and UI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插图还使用一致的图标来表示周围文本中讨论的关键对象和动作，例如组件、状态值、事件处理程序和用户界面。
- en: State in the quiz app
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 问答应用中的状态
- en: Social media pages, like the one discussed at the start of the chapter, usually
    require a lot of state, with new posts being loaded and users liking posts, adding
    comments, and interacting with components in a variety of ways. Some of that state,
    like the current user, may be shared across many components, whereas other state,
    like a comment, may be local to a post.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 社交媒体页面，如本章开头讨论的那样，通常需要大量的状态，包括加载新帖子、用户点赞帖子、添加评论以及以各种方式与组件交互。其中一些状态，如当前用户，可能被许多组件共享，而其他状态，如评论，可能仅限于帖子本身。
- en: In the Quiz app, you have a question-and-answer component, a `QuestionCard`,
    shown again in figure 1.6\. Users can show and hide each question and answer and
    move to the next available question.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quiz 应用中，你有一个问答组件，即 `QuestionCard`，如图 1.6 所示。用户可以显示和隐藏每个问题和答案，并移动到下一个可用的问题。
- en: '![](../Images/1-6.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-6.png)'
- en: Figure 1.6 The question-and-answer component with the answer hidden
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 答案隐藏的问答组件
- en: 'The `QuestionCard` component state includes the information needed to display
    the current question and answer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestionCard` 组件的状态包括显示当前问题和答案所需的信息：'
- en: The question number
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题编号
- en: The number of questions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题的数量
- en: The question text
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题文本
- en: The answer text
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案文本
- en: Whether the question is hidden or shown
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是隐藏还是显示
- en: Whether the answer is hidden or shown
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案是否隐藏或显示
- en: Clicking the answer’s Show button changes the state of the component. Maybe
    an `isAnswerShown` variable switches from `false` to `true`. React will notice
    that the state has changed, will update the displayed component to show the answer
    text, and toggle the button’s text from Show to Hide (figure 1.7).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 点击答案的显示按钮会改变组件的状态。可能一个 `isAnswerShown` 变量从 `false` 切换到 `true`。React 会注意到状态已更改，将更新显示的组件以显示答案文本，并将按钮的文本从显示切换到隐藏（图
    1.7）。
- en: '![](../Images/1-7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-7.png)'
- en: Figure 1.7 The question-and-answer component with the answer shown
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 显示答案的问答组件
- en: Clicking the Next button changes the question number. It will switch from question
    1 to question 2, as shown in figure 1.8\. If the questions and answers for the
    whole quiz are in memory, React can update the display straightaway. If they need
    to be loaded from a file or service, React can wait while the data is being fetched
    before updating the UI or, if the network is slow, show a loading indicator like
    a spinner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮会改变问题编号。它将从问题 1 切换到问题 2，如图 1.8 所示。如果整个测验的问题和答案都在内存中，React 可以立即更新显示。如果它们需要从文件或服务中加载，React
    可以在更新 UI 之前等待数据被检索，或者在网络较慢时显示一个加载指示器，如旋转器。
- en: '![](../Images/1-8.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-8.png)'
- en: Figure 1.8 The question-and-answer component showing the second question. The
    answer has been hidden.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 显示第二个问题的问答组件。答案已被隐藏。
- en: The simple Quiz app example doesn’t need much state to perform its duties. Most
    real-world apps are more complicated. Deciding where state should live—whether
    a component should manage its own state, whether some components should share
    state, and whether some state should be globally shared—is an important part of
    building apps. React provides mechanisms for all three scenarios, and published
    packages, like Redux, MobX, React Query, and Apollo Client, for example, offer
    approaches to manage state via a data store outside your components.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 Quiz 应用示例不需要太多状态来执行其任务。大多数现实世界的应用更为复杂。决定状态应该放在哪里——是否一个组件应该管理自己的状态，是否某些组件应该共享状态，以及是否某些状态应该全局共享——是构建应用的重要部分。React
    为这三种场景提供了机制，例如，像 Redux、MobX、React Query 和 Apollo Client 这样的发布包，提供了通过组件外的数据存储管理状态的方法。
- en: 'In the past, whether or not your component managed some of its own state determined
    the method of component creation you would use; React provides two main methods:
    function components and class components, as discussed in the next section.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，组件是否管理自己的状态决定了你会使用哪种组件创建方法；React 提供了两种主要方法：函数组件和类组件，如下一节所述。
- en: 1.1.3 Understanding component types
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 理解组件类型
- en: 'To define a component, React lets you use two JavaScript structures: a function
    or a class. Before React Hooks, you would use a function when the component didn’t
    need any local state (you would pass it all its data via props):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个组件，React 允许你使用两种 JavaScript 结构：一个函数或一个类。在 React Hooks 之前，当组件不需要任何本地状态时（你会通过
    props 传递给它所有数据）：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You would use a class when the component needed to manage its own state, perform
    side effects (like loading its data or getting hands-on with the DOM), or directly
    respond to events:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件需要管理自己的状态、执行副作用（如加载数据或与DOM交互）或直接响应事件时，你会使用类：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Class components set up their state in a constructor function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类组件在其构造函数中设置其状态。
- en: ❷ Class components can include methods for various stages in their life cycle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 类组件可以包括其生命周期各个阶段的函数。
- en: ❸ Class components have a render method that returns their UI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 类组件有一个返回其UI的`render`方法。
- en: 'The addition of React Hooks means you can now use function components to manage
    state and side effects:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks的添加意味着你现在可以使用函数组件来管理状态和副作用：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Use hooks to manage state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用钩子来管理状态。
- en: ❷ Use hooks to manage side effects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用钩子来管理副作用。
- en: ❸ Return UI directly from the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 直接从函数中返回UI。
- en: The React team recommends the use of functions for components in new projects
    (although there is no plan to remove class components, so no need for big rewrites
    of existing projects). Table 1.2 lists the component types and their descriptions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: React团队建议在新项目中使用函数组件（尽管没有计划移除类组件，因此无需对现有项目进行大规模重写）。表1.2列出了组件类型及其描述。
- en: Table 1.2 Component types and their descriptions *(continued)*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 组件类型及其描述 *(继续)*
- en: '| Component type | Description |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 组件类型 | 描述 |'
- en: '| Stateless function component | A JavaScript function that is passed properties
    and returns UI |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 无状态函数组件 | 一个接收属性并返回UI的JavaScript函数 |'
- en: '| Function component | A JavaScript function that is passed properties and
    uses hooks to manage state and perform side effects, as well as returning UI |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 函数组件 | 一个接收属性并使用钩子来管理状态和执行副作用的JavaScript函数，同时返回UI |'
- en: '| Class component | A JavaScript class that includes a render method that returns
    UI. It may also set up state in its constructor function and manage state and
    perform side effects in its life-cycle methods. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 类组件 | 包含一个返回UI的`render`方法的JavaScript类。它也可能在其构造函数中设置状态，并在其生命周期方法中管理状态和执行副作用。
    |'
- en: Function components are just JavaScript functions that return a description
    of their user interface. When writing components, developers usually use JSX to
    specify the UI. The UI might depend on properties passed to the function. With
    stateless function components, that’s where the story ends; they turn properties
    into UI. More generally, function components can now include state and work with
    side effects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组件只是返回其用户界面描述的JavaScript函数。在编写组件时，开发者通常使用JSX来指定UI。UI可能取决于传递给函数的属性。对于无状态函数组件，故事就到这里结束了；它们将属性转换为UI。更普遍地说，函数组件现在可以包含状态并处理副作用。
- en: Class components are built using the JavaScript class syntax, extending from
    a `React.Component` or `React.PureComponent` base class. They have a constructor
    function, where state can be initialized, and methods that React calls as part
    of the component life cycle; for instance, when the DOM has been updated with
    the latest component UI or when the properties passed to the component change.
    They also have a `render` method that returns a description of the component’s
    UI. Class components were the way to create stateful components that could cause
    side effects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件是使用JavaScript类语法构建的，从`React.Component`或`React.PureComponent`基类扩展而来。它们有一个构造函数，可以在其中初始化状态，并且React会在组件生命周期中调用它们的方法；例如，当DOM使用最新的组件UI更新时或当传递给组件的属性更改时。它们还有一个`render`方法，返回组件UI的描述。类组件是创建可以引起副作用的具有状态组件的方法。
- en: We’ll see in section 1.3 how function components with hooks provide a better
    way of creating stateful components and managing side effects than classes. First,
    let’s take a more general look at what’s new in React and how the new features
    make working with React even better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第1.3节中看到，具有钩子的函数组件在创建有状态组件和管理副作用方面比类组件提供了一种更好的方法。首先，让我们更广泛地了解一下React的新特性以及这些新特性如何使使用React变得更加出色。
- en: Component side effects
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 组件副作用
- en: React components generally transform state into UI. When component code performs
    actions outside this main focus—perhaps fetching data like blog posts or stock
    prices from the network, setting up a subscription to an online service, or directly
    interacting with the DOM to focus form fields or measure element dimensions—we
    describe those actions as component *side effects*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件通常将状态转换为 UI。当组件代码执行与此主要焦点无关的操作时——例如从网络获取数据（如博客文章或股票价格）、设置对在线服务的订阅或直接与
    DOM 交互以聚焦表单字段或测量元素尺寸——我们把这些操作描述为组件的 *副作用*。
- en: We want our app and its components to behave predictably, so should make sure
    any necessary side effects are deliberate and visible. As you’ll see in chapter
    4, React provides the `useEffect` hook to help us set up and manage side effects
    in our functional components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序及其组件的行为可预测，因此应确保任何必要的副作用都是故意的且可见的。正如你在第 4 章中将要看到的，React 提供了 `useEffect`
    hook 来帮助我们设置和管理函数组件中的副作用。
- en: 1.2 What’s new in React?
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 React 的新特性有哪些？
- en: 'React 16 included a rewrite of core functionality that has paved the way for
    a steady rollout of new library features and approaches. We’ll explore several
    of the newest additions in the chapters that follow. The new features include
    the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: React 16 包含了对核心功能的重写，这为稳定推出新的库功能和方法的实施铺平了道路。在接下来的章节中，我们将探讨其中的一些最新增补。新功能包括以下内容：
- en: Stateful function components (`useState`, `useReducer`)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带状态的函数组件（`useState`、`useReducer`）
- en: Context API (`useContext`)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文 API (`useContext`)
- en: Cleaner side-effect management (`useEffect`)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更干净的副作用管理（`useEffect`）
- en: Simple but powerful code reuse patterns (custom hooks)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单但强大的代码重用模式（自定义 hooks）
- en: Code splitting (`lazy`)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码拆分（`lazy`）
- en: Faster initial loading and intelligent rendering (Concurrent Mode—experimental)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的初始加载和智能渲染（并发模式—实验性）
- en: Better feedback for loading states (`Suspense`, `useTransition`)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的加载状态反馈（`Suspense`，`useTransition`）
- en: Powerful debugging, inspection, and profiling (Development Tools and Profiler)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的调试、检查和性能分析（开发工具和性能分析器）
- en: Targeted error handling (error boundaries)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标化错误处理（错误边界）
- en: 'The words starting with use—`useState`, `useReducer`, `useContext`, `useEffect`,
    and `useTransition`—are examples of *React Hooks*. They are functions that you
    can call from React function components and that hook into key React functionality:
    state, life cycle, and context. React Hooks let you add state to function components,
    cleanly encapsulate side effects, and reuse code across your project. By using
    hooks, you do away with the need for classes, reducing and consolidating your
    code in an elegant way. Section 1.3 discusses React components and hooks in a
    little more detail.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以 use 开头的单词—`useState`、`useReducer`、`useContext`、`useEffect` 和 `useTransition`—是
    *React Hooks* 的例子。它们是你可以从 React 函数组件中调用的函数，并且可以钩入关键的 React 功能：状态、生命周期和上下文。React
    Hooks 允许你在函数组件中添加状态，干净地封装副作用，并在你的项目中重用代码。通过使用 hooks，你可以摆脱对类的需求，以优雅的方式减少和整合你的代码。第
    1.3 节将更详细地讨论 React 组件和 hooks。
- en: Concurrent Mode and Suspense provide the means to be more deliberate about when
    code, data, and assets are loaded and to wrangle loading states and fallback content
    like spinners in a coordinated manner. The aim is to improve the user experience
    as applications load and states change and to improve the developer experience,
    making it easier to hook into these new behaviors. React can pause the rendering
    of expensive but nonurgent components and switch to urgent tasks, like reacting
    to user interactions, to keep your application responsive and to smooth the perceived
    path for user productivity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式和 `Suspense` 提供了更细致地控制代码、数据和资产加载的手段，以及以协调的方式处理加载状态和回退内容（如加载指示器）。目标是提高应用程序加载和状态变化时的用户体验，并改善开发者体验，使开发者更容易接入这些新行为。React
    可以暂停渲染昂贵但非紧急的组件，转而执行紧急任务，如响应用户交互，以保持应用程序的响应性，并平滑用户生产力的感知路径。
- en: The React documentation at [https://reactjs.org](https://reactjs.org) is a great
    resource, providing clear, well-structured explanations of the philosophy, API,
    and recommended use of the library, as well as blog posts from the team and links
    to live code examples, conference talks on the new features, and other React-related
    resources. While this book will concentrate on hooks, Suspense, and Concurrent
    Mode, do check out the official docs to find out more about the other additions
    to React. In particular, take a look at the blog post on React 17 ([https://reactjs.org/blog/2020/10/20/react-v17.html](https://reactjs.org/blog/2020/10/20/react-v17.html)).
    The next major version of React was released in October 2020 but contains no new
    developer-facing features. Instead, it includes changes to make it easier to gradually
    upgrade React apps as well as further experimental development of Concurrent Mode
    and its APIs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactjs.org](https://reactjs.org) 上的 React 文档是一个极好的资源，提供了对哲学、API 和库推荐使用的清晰、结构化的解释，以及团队博客文章、指向实时代码示例、关于新特性的会议演讲和其他与
    React 相关的资源链接。虽然这本书将专注于 hooks、Suspense 和并发模式，但请务必查看官方文档，以了解更多关于 React 其他新增功能的信息。特别是，请查看关于
    React 17 的博客文章([https://reactjs.org/blog/2020/10/20/react-v17.html](https://reactjs.org/blog/2020/10/20/react-v17.html))。React
    的下一个主要版本于 2020 年 10 月发布，但没有包含面向开发者的新功能。相反，它包括了一些更改，使得逐步升级 React 应用程序变得更加容易，以及并发模式和其
    API 的进一步实验性开发。'
- en: 1.3 React Hooks can add state to function components
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 React Hooks 可以给函数组件添加状态
- en: As discussed in section 1.1.2, one of React’s core strengths is how it synchronizes
    application and component state with the UI. As the state changes, based on user
    interactions or data updates from the system or network, React intelligently and
    efficiently works out what changes should be made to the DOM in a browser or to
    the UI, more generally, in other environments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如 1.1.2 节所述，React 的核心优势之一是它如何同步应用程序和组件状态与 UI。随着状态的变化，基于用户交互或来自系统或网络的数据更新，React
    会智能且高效地计算出在浏览器中的 DOM 或更广泛环境中的 UI 应该进行哪些更改。
- en: The state could be local to a component, raised to a component higher in the
    tree, and shared among siblings via properties, or global and accessed via React’s
    Context 4 and return a new component that wraps the passed-in component but that
    has extra functionality). For a component to have state, it used to be that you’d
    use a class component with the JavaScript class extending from `React.Component`.
    Now, with React Hooks, you can add state to function components.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 状态可以是组件本地的，提升到树中的更高组件，通过属性在兄弟组件间共享，或者全局的，并通过 React 的 Context 4 访问，并返回一个包装了传入组件的新组件，但具有额外的功能）。为了使组件具有状态，过去通常使用一个从
    `React.Component` 扩展的 JavaScript 类组件。现在，有了 React Hooks，你可以在函数组件中添加状态。
- en: '1.3.1 Stateful function components: Less code, better organization'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 带状态的函数组件：更少的代码，更好的组织
- en: Compared to classes, function components with hooks encourage cleaner, leaner
    code that can be easily tested, maintained, and reused. The *function component*
    is a JavaScript function that returns a description of its user interface. That
    UI depends on properties passed in and state managed or accessed by the component.
    Figure 1.9 shows a diagram representing a function component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与类相比，使用 hooks 的函数组件鼓励编写更干净、更精简的代码，这种代码易于测试、维护和重用。*函数组件* 是一个返回其用户界面描述的 JavaScript
    函数。该 UI 依赖于传入的属性以及组件管理或访问的状态。图 1.9 展示了一个表示函数组件的图表。
- en: '![](../Images/1-9.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-9.png)'
- en: Figure 1.9 A `Quiz` function component with state and encapsulated code for
    loading data and managing a subscription to a service
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 一个具有状态和封装了加载数据以及管理服务订阅的 `Quiz` 功能组件
- en: 'The figure shows a `Quiz` component that performs a couple of side effects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了执行了几个副作用的 `Quiz` 组件：
- en: It loads its own question data—both initial data and new questions when the
    user chooses a new question set.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它加载自己的问题数据——包括初始数据和当用户选择新的问题集时的新问题。
- en: It subscribes to a user service—the service provides updates about other quiz
    users currently online so the user can join a team or challenge a rival.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它订阅用户服务——该服务提供有关当前在线的其他 quiz 用户的更新，以便用户可以加入团队或挑战对手。
- en: In JavaScript, functions can contain other functions, so the component can contain
    event handlers that react to user interactions with the UI, for example, to show,
    hide, or submit answers, or to move to the next question. Within the component,
    you can easily encapsulate side effects, like fetching the question data or subscribing
    to the user service. You can also include cleanup code for those side effects
    to cancel any unfinished data fetching and unsubscribe from the user service.
    Using hooks, those features can even be extracted into their own functions outside
    the component, ready for reuse or sharing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数可以包含其他函数，因此组件可以包含响应用户与UI交互的事件处理器，例如显示、隐藏或提交答案，或移动到下一个问题。在组件内部，你可以轻松封装副作用，如获取问题数据或订阅用户服务。你还可以包括清理代码以取消任何未完成的数据获取并从用户服务取消订阅。使用钩子，这些功能甚至可以提取到组件外部的函数中，以便重用或共享。
- en: 'Here are some of the results of using the new function component approach rather
    than the older class-based approach:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用新的函数组件方法而不是旧的基于类的方法的某些结果：
- en: Less code
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码更少
- en: Better code organization with related code kept together along with any cleanup
    code
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织更好，相关代码与任何清理代码一起保持在一起
- en: Extraction of features to external functions that can be reused and shared
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能提取到外部函数中，以便重用和共享
- en: More easily testable components
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易测试的组件
- en: No need to call `super``()`in a class constructor
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类构造函数中不需要调用`super()`函数
- en: No need to work with `this` and bind handlers
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要与`this`和绑定处理器一起工作
- en: Simpler life-cycle model
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的生命周期模型
- en: Local state in scope for handlers, side effect functions, and the returned UI
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器、副作用函数和返回的UI作用域内的本地状态
- en: All of the items in this list facilitate writing code that’s easier to understand
    and so easier to work with and maintain. That’s not to say nuances might not trip
    up developers working with the new approaches for the first time, but I’ll highlight
    those nuances as we delve more deeply into each concept and their connections
    throughout this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的所有项目都有助于编写更易于理解的代码，因此更容易使用和维护。这并不是说细微差别可能不会让第一次使用新方法的开发者感到困惑，但当我们深入探讨每个概念及其在本书中各部分之间的联系时，我会突出这些细微差别。
- en: '*React Hooks in Action* outlines the functional approach to component building,
    rather than using classes. But it’s sometimes worth comparing the new methods
    with the old to motivate adoption and because it’s interesting (and, in the case
    of hooks, a little cool!) to see the differences. If you’re new to React and have
    never seen the code for class components, don’t worry. Rest assured that the function
    components we’ll be using for the rest of the book are the preferred approach
    going forward. The following discussion should still give you an idea of how this
    new approach simplifies and organizes the code needed to create React components.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 《*React Hooks in Action*》概述了组件构建的函数式方法，而不是使用类。但有时将新方法与旧方法进行比较是有意义的，以激发采用并因为看到差异很有趣（在钩子的情况下，这有点酷！）。如果你是React的新手，从未见过类组件的代码，请不要担心。请放心，本书余下的部分我们将使用函数组件作为首选方法。以下讨论应该仍然能让你了解这种新方法如何简化并组织创建React组件所需的代码。
- en: 'The title of this section is “Stateful function components: Less code, better
    organization.” Better than what? Well, with class components, state was set up
    in the constructor function, event handlers were bound to `this`, and side-effect
    code was split across multiple life-cycle methods (`componentDidMount`, `componentWillUnmount`,
    `componentWillUpdate`, and so on). It was common for code relating to different
    effects and features to sit side-by-side in a life-cycle method. You can see in
    figure 1.10 how the `Quiz` class component code for loading question data and
    subscribing to the user service is split across methods and how some methods include
    a mix of code for the two tasks.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题是“有状态的函数组件：更少的代码，更好的组织。”比什么更好？嗯，使用类组件时，状态是在构造函数中设置的，事件处理器绑定到`this`，副作用代码分散在多个生命周期方法（`componentDidMount`、`componentWillUnmount`、`componentWillUpdate`等）中。在生命周期方法中，与不同效果和功能相关的代码通常并排放置。你可以在图1.10中看到`Quiz`类组件代码如何跨方法分割，以及某些方法如何包含两个任务的代码混合。
- en: '![](../Images/1-10.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图1-10](../Images/1-10.png)'
- en: Figure 1.10 A class component with code spread across life-cycle methods, and
    a function component with the same functionality but with less, better organized
    code
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 一个代码分布在生命周期方法中的类组件，以及具有相同功能但代码更少、更有组织的函数组件
- en: Function components with hooks no longer need all the life-cycle methods because
    effects can be encapsulated into hooks. The change leads to neater, better organized
    code, as seen in the `Quiz` function component in figure 1.10\. The code has been
    much more sensibly organized with the two side effects separated and their code
    consolidated in one place for each effect. The improved organization makes it
    easier to find the code for a particular effect, see how a component works, and
    maintain it in the future. In fact, keeping a feature or effect’s code in one
    place makes it much easier to extract into an external function of its own, and
    that’s what we’ll discuss next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 带有钩子的函数组件不再需要所有生命周期方法，因为效果可以被封装到钩子中。这种变化导致了更整洁、更有组织的代码，如图 1.10 中的 `Quiz` 函数组件所示。代码已经被更合理地组织，两个副作用被分开，并且每个效果的相关代码都集中在一个地方。这种改进的组织使得查找特定效果代码、了解组件的工作方式以及未来维护它变得更加容易。实际上，将功能或效果的代码放在一个地方使得将其提取为外部函数变得更加容易，这正是我们接下来要讨论的。
- en: '1.3.2 Custom hooks: Easier code reuse'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 自定义钩子：更简单的代码重用
- en: Function components with hooks encourage you to keep related side-effect logic
    in one place. If the side effect is a feature that many components will need,
    you can take the organization a step further and extract the code into its own
    external function; you can create what is called a *custom hook*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 带有钩子的函数组件鼓励你将相关的副作用逻辑放在一个地方。如果副作用是许多组件都需要的功能，你可以进一步组织代码，将其提取到自己的外部函数中；你可以创建所谓的
    *自定义钩子*。
- en: Figure 1.11 shows how the question loading and user service subscription tasks
    for the `Quiz` function component could be moved into their own custom hooks.
    Any state that is used solely for those tasks can be moved into the corresponding
    hook.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 展示了如何将 `Quiz` 功能组件的题目加载和用户服务订阅任务移动到它们自己的自定义钩子中。任何仅用于这些任务的任何状态都可以移动到相应的钩子中。
- en: '![](../Images/1-11.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-11.png)'
- en: Figure 1.11 The code for fetching question data and for subscribing to a user
    service can be extracted into custom hooks. The accompanying state can also be
    managed by the hooks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 获取问题数据和订阅用户服务的代码可以提取到自定义钩子中。相关的状态也可以由钩子管理。
- en: 'There’s no magic here; it’s just how functions usually work in JavaScript:
    the function is extracted from the component and then called from the component.
    Once you have a custom hook, you aren’t restricted to calling it from your original
    component. You can use it across many components, share it with your team, or
    publish it for others to use.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有魔法；这只是函数在 JavaScript 中通常工作的方式：函数从组件中提取出来，然后从组件中调用。一旦你有了自定义钩子，你就不再局限于从原始组件中调用它。你可以在许多组件中使用它，与你的团队共享，或者发布供他人使用。
- en: Figure 1.12 shows the new super-slim `Quiz` function component using the `useUsers`
    custom hook and the `useFetch` custom hook to carry out the user service subscription
    and question-fetching tasks that, previously, it carried out on its own. But now
    a second component, `Chat`, makes use of the `useUsers` custom hook too. Hooks
    make this kind of feature sharing much easier in React; custom hooks can be imported
    and used wherever they are needed in your portfolio of applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 展示了使用 `useUsers` 自定义钩子和 `useFetch` 自定义钩子实现的新超级瘦 `Quiz` 功能组件，它执行了之前由自身独立完成的用户服务订阅和问题获取任务。但现在，第二个组件
    `Chat` 也开始使用 `useUsers` 自定义钩子。钩子在 React 中使得这种功能共享变得更加容易；自定义钩子可以在你的应用程序组合中任何需要的地方导入和使用。
- en: '![](../Images/1-12.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-12.png)'
- en: Figure 1.12 You can extract code into custom hooks for reuse and sharing. The
    `Quiz` component calls both the `useUsers` and `useFetch` hooks. The `Chat` component
    calls the `useUsers` hook.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 你可以将代码提取到自定义钩子中以实现重用和共享。`Quiz` 组件调用 `useUsers` 和 `useFetch` 钩子。`Chat`
    组件调用 `useUsers` 钩子。
- en: Each custom hook can maintain its own state, whatever it needs to perform its
    duties. And because hooks are just functions, if components need access to any
    of the hook’s state, the hook can include the state in its return value. For example,
    a custom hook that fetches user info for a specified ID could store the fetched
    user data locally but return it to any components that call the hook. Each hook
    call encapsulates its own state, just like any other function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个自定义钩子都可以维护自己的状态，无论它需要执行什么任务。由于钩子只是函数，如果组件需要访问钩子的任何状态，钩子可以将状态包含在其返回值中。例如，一个用于为指定ID获取用户信息的自定义钩子可以本地存储获取到的用户数据，但将其返回给调用钩子的任何组件。每个钩子调用都封装了自己的状态，就像任何其他函数一样。
- en: To get a sense of the variety of common tasks that programmers have easily abstracted
    into custom hooks, take a look at the useHooks website at [https://usehooks .com](https://usehooks.com)
    (figure 1.13).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解程序员如何轻松地将常见任务抽象为自定义钩子的多样性，请查看[https://usehooks.com](https://usehooks.com)网站（图1.13）。
- en: '![](../Images/1-13.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-13.png)'
- en: Figure 1.13 The useHooks website has many examples of custom hooks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 useHooks网站有许多自定义钩子的示例。
- en: 'It showcases easy-to-use recipes, including these:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了易于使用的配方，包括以下内容：
- en: '`useRouter`—Wraps the new hooks made available by React Router'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRouter`—包装React Router提供的新的钩子'
- en: '`useAuth`—Enables any component to get the current auth state and re-render
    if it changes'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useAuth`—允许任何组件获取当前的认证状态，并在状态改变时重新渲染'
- en: '`useEventListener`—Abstracts the process of adding and removing event listeners
    to components'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEventListener`—抽象了向组件添加和删除事件监听器的过程'
- en: '`useMedia`—Makes it easy to use media queries in your component logic'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMedia`—使在组件逻辑中使用媒体查询变得容易'
- en: It’s well worth researching on sites like useHooks or in package repositories
    like npm whether hooks exist that fit your use cases before rolling your own.
    If you already use libraries or frameworks for common scenarios like data fetching
    or state management, check the latest versions to see if they’ve introduced hooks
    to make working with them easier. We’ll take a look at a few such packages in
    the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己实现钩子之前，在useHooks或npm等包仓库网站上研究是否存在适合您用例的钩子是非常值得的。如果您已经使用了用于常见场景（如数据获取或状态管理）的库或框架，请检查最新版本，看看它们是否引入了钩子以简化使用。我们将在下一节中查看一些这样的包。
- en: 1.3.3 Third-party hooks provide ready-made, well-tested functionality
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.3 第三方钩子提供现成的、经过良好测试的功能
- en: Sharing functionality across components is not new; it’s been an essential part
    of React development for some time. Hooks offer a much cleaner way of sharing
    code and hooking into functionality than the older methods of higher-order components
    and render props, which often lead to highly nested code (“wrapper hell”) and
    false code hierarchies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件之间共享功能并非新事物；它已经是一段时间内React开发的一个基本组成部分。钩子提供了一种比旧方法（如高阶组件和渲染属性）更干净的方式来共享代码和连接到功能，后者往往导致高度嵌套的代码（“包装地狱”）和虚假的代码层次结构。
- en: 'Third-party libraries that work with React have been quick to release new versions
    that make the most of hooks’ simpler API and more direct methods of integration.
    We take a very brief look at three examples in this section:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与React一起工作的第三方库迅速发布了新版本，充分利用了钩子更简单的API和更直接的集成方法。我们将在本节中简要介绍三个示例：
- en: React Router for page navigation
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router 用于页面导航
- en: Redux as an application data store
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 作为应用程序数据存储
- en: React Spring for animation
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Spring 用于动画
- en: React Router
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: React Router
- en: '*React Router* provides components to help developers manage navigation between
    pages in their apps. Its custom hooks make it easy to access common objects involved
    in navigation: `useHistory`, `useLocation`, `useParams`, and `useRouteMatch`.
    For example, `useParams` gives access to any parameters matched in a page’s URL:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*React Router* 提供了组件，帮助开发者管理他们应用中页面之间的导航。它的自定义钩子使得访问导航中涉及的常见对象变得容易：`useHistory`、`useLocation`、`useParams`
    和 `useRouteMatch`。例如，`useParams` 允许访问页面URL中匹配的任何参数：'
- en: '[PRE4]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Redux
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Redux
- en: 'For some applications, a separate store for state might be appropriate. Redux
    is a popular library for creating such stores and it is often combined with React
    via the React Redux library. Since version 7.1, React Redux offers hooks to make
    interacting with the store easier: `useSelector`, `useDispatch`, and `useStore`.
    For example, `useDispatch` lets you dispatch an action to update the state in
    the store. Say you have an application to build question sets for quizzes and
    you want to add a question:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，可能需要一个单独的状态存储。Redux 是创建此类存储的流行库，通常与 React Redux 库结合使用。自 7.1 版本以来，React
    Redux 提供了钩子，使与存储的交互更加容易：`useSelector`、`useDispatch` 和 `useStore`。例如，`useDispatch`
    允许你向存储发送一个动作来更新状态。假设你有一个用于构建测验问题集的应用程序，并且你想添加一个问题：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new custom hooks remove some of the boilerplate code that was associated
    with connecting a React application to a Redux store. React also has a built-in
    hook, `useReducer`, which might provide a simpler model for dispatching actions
    to update state and remove the perceived need for Redux in some cases.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新的自定义钩子消除了与将 React 应用程序连接到 Redux 存储相关的部分样板代码。React 还有一个内置的钩子 `useReducer`，它可能提供了一个更简单的模型来分发动作以更新状态，并在某些情况下消除对
    Redux 的感知需求。
- en: React Spring
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: React Spring
- en: 'React Spring is a Spring-based animation library that currently provides five
    hooks to access its functionality: `useSpring`, `useSprings`, `useTrail`, `useTransition`,
    and `useChain`. For example, to animate between two values, you can opt for `useSpring`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: React Spring 是一个基于 Spring 的动画库，目前提供了五个钩子来访问其功能：`useSpring`、`useSprings`、`useTrail`、`useTransition`
    和 `useChain`。例如，要在这两个值之间进行动画，你可以选择 `useSpring`：
- en: '[PRE6]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: React Hooks have made it easier for library authors to provide developers with
    simpler APIs that don’t clutter their code with potentially deeply nested false
    component hierarchies. Similarly, a couple of other new React features, Concurrent
    Mode and Suspense, enable library authors and app developers to better manage
    asynchronous processes within their code and provide smoother, more responsive
    user experiences.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: React Hooks 使得库作者能够为开发者提供更简单的 API，这些 API 不会在他们的代码中引入可能深度嵌套的虚假组件层次结构。同样，React
    的其他几个新特性，如并发模式和 Suspense，使库作者和应用程序开发者能够更好地管理代码中的异步过程，并提供更平滑、更响应式的用户体验。
- en: 1.4 Better UX with Concurrent Mode and Suspense
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 并发模式和 Suspense 提供更好的用户体验
- en: We want to develop great experiences for our users that help them interact with
    our applications smoothly and enjoyably. That might mean them getting a job done
    in a productivity app, connecting with friends on a social platform, or capturing
    a crystal in a game. Whatever their goal, the interfaces we design and code should
    be a means to an end rather than a stumbling block. But our apps may need to load
    a lot of code, fetch a lot of data, and try to manipulate the data to provide
    the information the user needs, even as they switch quickly from view to view,
    scrolling and clicking and tapping as they go.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为用户提供出色的体验，帮助他们顺畅愉快地与我们的应用程序互动。这可能意味着他们在生产力应用程序中完成工作，在社交平台上与朋友联系，或者在游戏中捕捉到一个晶体。无论他们的目标是什么，我们设计和编写的界面应该是达到目的的手段，而不是障碍。但是，我们的应用程序可能需要加载大量代码，获取大量数据，并尝试操纵数据以提供用户所需的信息，即使他们在快速切换视图时也是如此，滚动、点击和触摸。
- en: A large part of the motivation for the rewrites of React for versions 16 and
    17 was to build the architecture to cope with the multiple demands put upon a
    user interface as it loads and manipulates data while users continue interacting
    with the application. Concurrent Mode is a core piece of that new architecture,
    and `Suspense` components fit the new mode naturally. But what problems do they
    solve?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: React 在 16 和 17 版本中的重写大部分动机是为了构建一个架构，以应对用户界面在加载和处理数据时面临的多种需求，同时用户继续与应用程序交互。并发模式是这一新架构的核心部分，`Suspense`
    组件自然地适应了这种新模式。但它们解决了哪些问题？
- en: Say you have an app that shows products in a long list and has a text box that
    users type in to filter the list. Your app updates the list as the user types.
    Each keystroke triggers the code to filter the list anew, requiring React to draw
    the updated list components to the screen. The expensive filtering process and
    recalculation and updating of the UI hogs the processing time, reducing the responsiveness
    of the text box. The experience for the user is one of a lagging, slow text box
    that doesn’t show text as the user types. Figure 1.14, while obviously not being
    a perfect representation of how a browser might schedule code to run, does illustrate
    the point that long-running operations can slow updates to the screen, causing
    a poorer experience for users.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个应用程序，它在一个长列表中显示产品，并有一个文本框，用户可以在其中输入以过滤列表。当用户输入时，应用程序会更新列表。每个按键都会触发代码重新过滤列表，需要
    React 将更新的列表组件绘制到屏幕上。昂贵的过滤过程、重新计算和更新 UI 占用了处理时间，降低了文本框的响应性。用户的体验就像是一个滞后、缓慢的文本框，不会显示用户输入的文字。图
    1.14，虽然显然不是浏览器可能调度代码运行的完美表示，但它说明了长时间运行的操作可能会减慢屏幕更新，从而使用户体验变差。
- en: '![](../Images/1-14.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-14.png)'
- en: Figure 1.14 Without Concurrent Mode, interactions like keystrokes are blocked
    by long-running updates.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 没有并发模式时，像按键这样的交互会被长时间运行的更新所阻塞。
- en: Wouldn’t it be great if the app could prioritize the text box updates and keep
    the user experience smooth, pausing and restarting the filtering duties around
    the typing? Say hello to Concurrent Mode!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序能够优先处理文本框更新并保持用户体验平滑，暂停和重新启动围绕输入的过滤任务，那岂不是很好？欢迎来到并发模式！
- en: 1.4.1 Concurrent Mode
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 并发模式
- en: With *Concurrent Mode*, React can schedule tasks in a more granular way, pausing
    its work building elements, checking for differences, and updating the DOM for
    previous state changes to make sure it responds to user interactions, for example.
    In the preceding filtering app example, React can pause rendering of the filtered
    list to make sure the text that the user is typing appears in the text box.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *并发模式* 下，React 可以以更细粒度的方式调度任务，暂停构建元素、检查差异和更新前一个状态的 DOM，以确保它能够响应用户交互，例如。在前面的过滤应用程序示例中，React
    可以暂停渲染过滤列表，以确保用户输入的文字出现在文本框中。
- en: So how does Concurrent Mode enable this magic? The new React architecture breaks
    its tasks into smaller units of work, providing regular points for the browser
    or operating system to inform the application that a user is trying to interact
    with it. React’s scheduler can then decide what jobs to do based on the priority
    of each. Reconciling and committing changes to one part of the component tree
    can be paused or abandoned to make sure components with higher priority are updated
    first, as illustrated in figure 1.15.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那么并发模式是如何实现这种魔法的呢？新的 React 架构将任务分解成更小的单元工作，为浏览器或操作系统提供常规的点，以便通知应用程序用户正在尝试与之交互。React
    的调度器可以根据每个任务的优先级来决定执行哪些任务。对组件树的一部分进行协调和提交更改可以暂停或放弃，以确保优先级更高的组件首先更新，如图 1.15 所示。
- en: '![](../Images/1-15.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-15.png)'
- en: Figure 1.15 In Concurrent Mode, React can pause longer-running updates to quickly
    react to user interactions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 在并发模式下，React 可以暂停较长时间运行的更新，以便快速响应用户交互。
- en: It’s not just user interactions that can benefit from this intelligent scheduling;
    responses to incoming data, lazily loaded components or media, or other asynchronous
    processes can also enjoy a smoother user-interface upgrade. React can continue
    to display a fully interactive existing UI (rather than a spinner) while it renders
    the UI for updated state in memory, switching to the new UI when enough of it
    is ready. Concurrent Mode enables a couple of new hooks, `useTransition` and `useDeferredValue`,
    that improve the user experience, smoothing the change from one view to another
    or one state to another. It also goes hand in hand with `Suspense`, both a component
    for rendering fallback content and a mechanism for specifying that a component
    is waiting for something, like loading data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅用户交互可以从这种智能调度中受益；对传入数据的响应、懒加载的组件或媒体，或其他异步过程也可以享受到更平滑的用户界面升级。React 可以在内存中渲染更新状态的
    UI 时继续显示一个完全交互的现有 UI（而不是旋转器），当足够多的 UI 准备就绪时，切换到新的 UI。并发模式启用了一组新的钩子，`useTransition`
    和 `useDeferredValue`，这些钩子可以改善用户体验，平滑从一个视图到另一个视图或从一个状态到另一个状态的转换。它还与 `Suspense`
    一起使用，`Suspense` 既是渲染回退内容的组件，也是指定组件正在等待某些内容（如加载数据）的机制。
- en: 1.4.2 Suspense
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 悬疑
- en: As you have seen, React applications are built from components in a hierarchical
    tree. To display the current state of your app onscreen (using the DOM, for instance),
    React traverses your components and creates *element trees*, descriptions of the
    intended UI, in memory. It compares the latest tree with the previous one and
    intelligently decides what DOM updates need to be made to realize the intended
    UI. Concurrent mode lets React pause processing of parts of the element tree,
    either to work on higher-priority tasks or because the current component isn’t
    ready to be processed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，React应用程序是由组件按层次结构构建的。为了在屏幕上显示您应用程序的当前状态（例如使用DOM），React遍历您的组件并在内存中创建*元素树*，即预期UI的描述。它将最新的树与之前的树进行比较，并智能地决定需要做出哪些DOM更新来实现预期的UI。并发模式允许React暂停处理元素树的一部分，要么是为了处理更高优先级任务，要么是因为当前组件尚未准备好被处理。
- en: Components built to work with `Suspense` can now *suspend* if they are not ready
    to return their UI (remember, components are either functions or have a render
    method and convert properties and state into UI). They might be waiting for component
    code or assets or data to load and just don’t yet have the information they need
    to fully describe their UI. React can pause processing of a suspended component
    and carry on traversing the element tree. But how does that look on the screen?
    Will there be a hole in your user interface?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 建造用来与`Suspense`一起工作的组件现在可以*挂起*，如果它们还没有准备好返回它们的UI（记住，组件要么是函数，要么有渲染方法，并将属性和状态转换为UI）。它们可能正在等待组件代码、资源或数据加载，但还没有它们需要完全描述UI所需的信息。React可以暂停挂起组件的处理，并继续遍历元素树。但在屏幕上看起来会怎样？你的用户界面会出现漏洞吗？
- en: 'In addition to specifying a mechanism for components to suspend, React provides
    a `Suspense` component that you can use to plug holes that suspended components
    have left in your user interface. Wrap sections of your UI in `Suspense` components
    and use their `fallback` properties to let React know what content to show if
    one or more of the wrapped components suspends:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为组件指定挂起机制外，React还提供了一个`Suspense`组件，您可以使用它来填补挂起组件在您的用户界面中留下的空缺。将您的UI部分包裹在`Suspense`组件中，并使用它们的`fallback`属性让React知道如果被包裹的组件之一挂起，应该显示什么内容：
- en: '[PRE7]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Suspense` allows the developer to deliberately manage loading states for multiple
    components, either showing fallbacks for individual components, groups of components,
    or the app as a whole. It provides a mechanism for library authors to update their
    APIs to work with the `Suspense` component, so their asynchronous features can
    make full use of the loading state management that `Suspense` provides.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Suspense`允许开发者故意管理多个组件的加载状态，无论是为单个组件、组件组还是整个应用程序显示回退内容。它为库作者提供了一个机制来更新他们的API以与`Suspense`组件一起工作，这样他们的异步功能就可以充分利用`Suspense`提供的加载状态管理。'
- en: 1.5 React’s new publication channels
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 React的新发布渠道
- en: 'To enable application developers and library authors to make the most of stable
    features in production but still prepare for upcoming features, the React team
    has started publishing code in separate channels:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序开发者和库作者能够充分利用生产中的稳定功能，同时为即将到来的功能做准备，React团队已经开始在单独的渠道发布代码：
- en: '*Latest*—Stable semver release'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最新版*—稳定的semver发布'
- en: '*Next*—Tracks the master branch of React development'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下一个*—追踪React开发的master分支'
- en: '*Experimental*—Includes experimental APIs and features'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实验性*—包括实验性API和功能'
- en: For production, developers should stick with the Latest release; it’s the one
    you get when installing React from npm (or another package manager). Much of Concurrent
    Mode and Suspense for data fetching are on the experimental channel at the time
    of writing. They are in the pipeline, but changes to the API may occur. The React
    and Relay (for data fetching) teams have been using many of the experimental features
    on the new Facebook website for some time. Such active use enables them to develop
    a strong understanding of the new approaches in context and at scale. By opening
    up the discussion of new features early and making them available in an experimental
    channel, the React team enables library authors to test integrations and new APIs,
    and application developers to start adapting to new mindsets and nuances.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，开发者应该坚持使用最新版本；这是当你从npm（或其他包管理器）安装React时获得的那一个。在撰写本文时，大部分并发模式和用于数据获取的Suspense都处于实验频道。它们正在开发中，但API的变化可能会发生。React和Relay（用于数据获取）团队已经在新Facebook网站上使用了许多实验性功能一段时间了。这种积极的使用使它们能够对新的方法在具体环境和规模上进行深入理解。通过尽早开放对新功能的讨论并在实验频道提供这些功能，React团队使得库作者能够测试集成和新API，以及应用开发者开始适应新的思维方式和细微差别。
- en: 1.6 Whom is this book for?
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 这本书是为谁而写的？
- en: This book is for experienced JavaScript developers who want to learn about the
    latest features in React. It focuses on React Hooks, Concurrent Mode, and Suspense,
    using plenty of code examples to get you up to speed and ready to use these features
    in your own projects (although not necessarily in production yet for those features
    currently in React’s Experimental channel). In addition to providing simple, practical
    examples, the book spends a little time probing a bit deeper into the reasoning
    behind some of the features and the nuances that developers would do well to be
    aware of.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是为想要了解React最新特性的经验丰富的JavaScript开发者而写的。它专注于React Hooks、并发模式和Suspense，使用大量的代码示例来帮助你快速掌握这些特性，并准备好在自己的项目中使用它们（尽管目前这些特性可能还无法在生产环境中使用）。除了提供简单实用的示例外，本书还会花一些时间深入探讨一些特性的背后的推理以及开发者应该注意的细微差别。
- en: This is not an introduction to React as a whole and won’t cover the React ecosystem,
    build tools, styling, or testing in any detail. The reader should have a knowledge
    of basic React concepts and be able to create, build, and run a React application.
    The book will occasionally use class component examples as comparisons to the
    new function component approach but will not focus on teaching the class-based
    approach, higher-order components, or render props in any depth. (Don’t worry
    if you don’t know all those terms; you don’t need to know about them to learn
    the new concepts.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书并不是对React整体介绍的入门书籍，也不会详细涵盖React生态系统、构建工具、样式或测试。读者应该对React的基本概念有所了解，并且能够创建、构建和运行一个React应用程序。本书偶尔会使用类组件示例来与新的函数组件方法进行比较，但不会深入教授基于类的编程方法、高阶组件或渲染属性。（如果你不熟悉所有这些术语，不用担心；你不需要了解它们来学习新概念。）
- en: Readers should be comfortable with some of the more recent JavaScript syntax
    additions, like `const` and `let`, object and array destructuring, default parameters,
    the spread operator and array methods like `map`, `filter`, and `reduce`. Some
    of the comparisons with class components will obviously be using JavaScript’s
    class syntax, so familiarity with that would be useful but is not essential.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该熟悉一些较新的JavaScript语法添加，如`const`和`let`，对象和数组解构，默认参数，扩展运算符以及数组方法如`map`、`filter`和`reduce`。一些与类组件的比较显然会使用JavaScript的类语法，因此熟悉这一点会有所帮助，但不是必需的。
- en: 1.7 Getting started
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 开始学习
- en: The code examples for the book’s main example, a bookings app, are on GitHub
    at [https://github.com/jrlarsen/react-hooks-in-action](https://github.com/jrlarsen/react-hooks-in-action)
    and are downloadable from the book’s page at the Manning website ([www.manning.com/books/react-hooks-in-action](http://www.manning.com/books/react-hooks-in-action)).
    Each step in the example apps development is on a separate Git branch, and the
    book’s code listings include the name of the relevant branch. Smaller, standalone
    React examples are hosted on CodeSandbox ([https://codesandbox.io](https://codesandbox.io)),
    and a few simple vanilla JavaScript examples are on JS Bin ([https://jsbin.com](https://jsbin.com)).
    Links to sandboxes and bins will accompany the book’s listings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 书中主要示例，一个预订应用，的代码示例在GitHub上，网址为[https://github.com/jrlarsen/react-hooks-in-action](https://github.com/jrlarsen/react-hooks-in-action)，并且可以从Manning网站的书页上下载（[www.manning.com/books/react-hooks-in-action](http://www.manning.com/books/react-hooks-in-action)）。示例应用开发的每个步骤都在单独的Git分支上，书中的代码列表包括了相关分支的名称。更小的、独立的React示例托管在CodeSandbox上（[https://codesandbox.io](https://codesandbox.io)），以及一些简单的纯JavaScript示例在JS
    Bin上（[https://jsbin.com](https://jsbin.com)）。与沙盒和Bin相关的链接将伴随书中的列表。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Use React to create reusable components that make up an app by turning state
    into UI.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React创建可重用的组件，通过将状态转换为UI来构建应用。
- en: Use JSX and props to describe the UI in an HTML-like syntax.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSX和props以类似HTML的语法描述UI。
- en: Create function components that collocate related code and functionality.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数组件，将相关的代码和功能集中在一起。
- en: Use React Hooks to encapsulate and share functionality for components, performing
    side effects, and hooking into moments in the component’s life cycle.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用React Hooks来封装和共享组件的功能，执行副作用，以及钩入组件的生命周期中的时刻。
- en: Create your own custom hooks and use those provided by third-party libraries.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的自定义钩子，并使用第三方库提供的钩子。
- en: Use `Suspense` components to provide fallbacks for components that take time
    to return their UI.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件为需要时间返回其UI的组件提供后备。
- en: Explore the experimental Concurrent Mode to work with multiple versions of the
    UI in memory, making it easier to transition smoothly from one interface to another
    in response to changes in state.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索实验性的并发模式，以在内存中处理多个版本的UI，使得在状态变化时从一个界面平滑过渡到另一个界面变得更加容易。
- en: 'Be aware of React’s three publication channels: Latest, Next, and Experimental.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意React的三个发布渠道：最新版、下个版本和实验版。
- en: Check out the React docs on [https://reactjs.org](https://reactjs.org).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅React官方文档，网址为[https://reactjs.org](https://reactjs.org)。
