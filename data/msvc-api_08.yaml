- en: 6 Building REST APIs with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用 Python 构建 REST API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding URL query parameters to an endpoint using FastAPI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FastAPI 向端点添加 URL 查询参数
- en: Disallowing the presence of unknown properties in a payload using pydantic and
    marshmallow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pydantic 和 marshmallow 禁止在有效负载中出现未知属性
- en: Implementing a REST API using flask-smorest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 flask-smorest 实施 REST API
- en: Defining validation schemas and URL query parameters using marshmallow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 marshmallow 定义验证模式和 URL 查询参数
- en: In previous chapters, you learned to design and document REST APIs. In this
    chapter, you’ll learn to implement REST APIs by working on two examples from the
    CoffeeMesh platform, the on-demand coffee delivery application that we introduced
    in chapter 1\. We’ll build the APIs for the orders service and for the kitchen
    service. The orders service is the main gateway to CoffeeMesh for customers of
    the platform. Through it they can place orders, pay for those orders, update them,
    and keep track of them. The kitchen service takes care of scheduling orders for
    production in the CoffeeMesh factories and keeps track of their progress. We’ll
    learn best practices for implementing REST APIs as we work through these examples.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何设计和记录 REST API。在本章中，你将学习通过在 CoffeeMesh 平台的两个示例上工作来实施 REST API，这是我们在第
    1 章中介绍的需求咖啡配送应用程序。我们将构建订单服务和厨房服务的 API。订单服务是 CoffeeMesh 平台客户的主要入口。通过它，他们可以下单、支付订单、更新订单并跟踪订单。厨房服务负责在
    CoffeeMesh 工厂安排订单的生产并跟踪其进度。我们将通过这些示例学习实施 REST API 的最佳实践。
- en: In chapter 2, we implemented part of the orders API. In the first sections of
    this chapter, we pick up the orders API where we left it in chapter 2 and implement
    its remaining features using FastAPI, a highly performant API framework for Python
    and a popular choice for building REST APIs. We’ll learn how to add URL query
    parameters to our endpoints using FastAPI. As we saw in chapter 2, FastAPI uses
    pydantic for data validation, and in this chapter we’ll use pydantic to forbid
    unknown fields in a payload. We’ll learn about the tolerant reader pattern and
    balance its benefits against the risk of API integration failures due to errors
    such as typos.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们实现了订单 API 的一部分。在本章的前几节中，我们将在第 2 章中留下的订单 API 上继续工作，并使用 FastAPI（一个针对
    Python 的高性能 API 框架，也是构建 REST API 的热门选择）实现其剩余功能。我们将学习如何使用 FastAPI 向我们的端点添加 URL
    查询参数。正如我们在第 2 章中看到的，FastAPI 使用 pydantic 进行数据验证，在本章中我们将使用 pydantic 禁止有效负载中的未知字段。我们将了解容错读取模式，并权衡其好处与由于错误（如拼写错误）导致的
    API 集成失败的风险。
- en: After completing the implementation of the orders API, we’ll implement the API
    for the kitchen service. The kitchen service schedules orders for production in
    the factory and keeps track of their progress. We’ll implement the kitchen API
    using flask-smorest, a popular API framework built on top of Flask and marshmallow.
    We’ll learn to implement our APIs following Flask application patterns, and we’ll
    define validation schemas using marshmallow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成订单 API 的实施后，我们将实施厨房服务的 API。厨房服务在工厂安排订单的生产并跟踪其进度。我们将使用 flask-smorest 实施厨房
    API，这是一个基于 Flask 和 marshmallow 的流行 API 框架。我们将学习按照 Flask 应用程序模式实施我们的 API，并使用 marshmallow
    定义验证模式。
- en: 'By the end of this chapter, you’ll know how to implement REST APIs using FastAPI
    and Flask, two of the most popular libraries in the Python ecosystem. You’ll see
    how the principles for implementing REST APIs transcend the implementation details
    of each framework and can be applied regardless of the technology that you use.
    The code for this chapter is available under folder ch06 in the repository provided
    with this book. Folder ch06 contains two subfolders: one for the orders API (ch06/orders)
    and one for the kitchen API (ch06/kitchen). With that said, and without further
    ado, let’s get cracking!'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用 FastAPI 和 Flask（Python 生态系统中最受欢迎的库之一）实施 REST API。你将看到实施 REST
    API 的原则如何超越每个框架的实现细节，并且可以应用于你使用的任何技术。本章的代码可在本书提供的存储库中的 ch06 文件夹下找到。ch06 文件夹包含两个子文件夹：一个用于订单
    API（ch06/orders）和一个用于厨房 API（ch06/kitchen）。话虽如此，我们就不多说了，让我们开始吧！
- en: 6.1 Overview of the orders API
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 订单 API 概述
- en: In this section, we recap the minimal implementation of the orders API that
    we undertook in chapter 2\. You can find the full specification of the orders
    API under ch06/ orders/oas.yaml in the GitHub repository for this book. Before
    we jump directly into the implementation, let’s briefly analyze the specification
    and see what’s left to implement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了我们在第二章中进行的订单API的最小实现。您可以在本书的GitHub仓库中ch06/orders/oas.yaml下找到订单API的完整规范。在我们直接进入实现之前，让我们简要分析一下规范，看看还剩下哪些要实现的内容。
- en: In chapter 2, we implemented the API endpoints of the orders API, and we created
    pydantic schemas to validate request and response payloads. We intentionally skipped
    implementing the business layer of the application, as that’s a complex task that
    we’ll tackle in chapter 7.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们实现了订单API的API端点，并创建了pydantic架构来验证请求和响应负载。我们故意跳过了实现应用程序的业务层，因为这是一个复杂任务，我们将在第七章中解决。
- en: 'As a reminder, the endpoints exposed by the orders API are the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，订单API公开的端点如下：
- en: '`/orders`—Allows us to retrieve lists (GET) of orders and to place orders (POST)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders`—允许我们检索订单列表（GET）以及放置订单（POST）'
- en: '`/orders/{order_id}`—Allows us to retrieve the details of a specific order
    (GET), to update an order (PUT), and to delete an order (DELETE)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}`—允许我们检索特定订单的详细信息（GET）、更新订单（PUT）以及删除订单（DELETE）'
- en: '`/orders/{order_id}/cancel`—Allows us to cancel an order (POST)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}/cancel`—允许我们取消订单（POST）'
- en: '`/orders/{order_id}/pay`—Allows us to pay for an order (POST)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/orders/{order_id}/pay`—允许我们为订单付款（POST）'
- en: POST `/orders` and PUT `/orders/{order_id}` require request payloads that define
    the properties of an order, and in chapter 2 we implemented schemas for those
    payloads. What’s missing from the implementation is the URL query parameters for
    the GET `/orders` endpoint. Also, the pydantic schemas we implemented in chapter
    2 don’t invalidate payloads with illegal properties in the payloads. As we’ll
    see in section 6.3, this is fine in some situations, but it may lead to integration
    issues in other cases, and you’ll learn to configure the schemas to invalidate
    payloads with illegal properties.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: POST `/orders` 和 PUT `/orders/{order_id}` 需要包含请求负载，以定义订单的属性，在第二章中我们已经实现了这些负载的架构。在实现中缺少的是GET
    `/orders` 端点的URL查询参数。此外，我们在第二章中实现的pydantic架构不会使包含非法属性的负载无效。正如我们将在6.3节中看到的，在某些情况下这是可以的，但在其他情况下可能会导致集成问题，您将学习如何配置架构以使包含非法属性的负载无效。
- en: 'If you want to follow along with the examples in this chapter, create a folder
    called ch06 and copy into it the code from ch02 as ch06/orders. Remember to install
    the dependencies and activate the virtual environment:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟随本章的示例，请创建一个名为ch06的文件夹，并将ch02中的代码复制到ch06/orders中。请记住安装依赖项并激活虚拟环境：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can start the web server by running the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来启动Web服务器：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: FastAPI + uvicorn refresher We implement the orders API using the FastAPI framework,
    a popular Python framework for building REST APIs. FastAPI is built on top of
    Starlette, an asynchronous web server implementation. To execute our FastAPI application,
    we use Uvicorn, another asynchronous server implementation that efficiently handles
    incoming requests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI + uvicorn 快速回顾 我们使用FastAPI框架实现订单API，这是一个用于构建REST API的流行Python框架。FastAPI建立在Starlette之上，这是一个异步Web服务器实现。为了执行我们的FastAPI应用程序，我们使用Uvicorn，这是另一个异步服务器实现，它有效地处理传入的请求。
- en: The `--reload` flag makes Uvicorn watch for changes on your files so that any
    time you make an update, the application is reloaded. This saves you the time
    of having to restart the server every time you make changes to the code. With
    this covered, let’s complete the implementation of the orders API!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reload`标志使Uvicorn监视您的文件上的更改，这样每次您进行更新时，应用程序都会重新加载。这为您节省了每次更改代码时都需要重新启动服务器的时间。在这一点上，让我们完成订单API的实现！'
- en: 6.2 URL query parameters for the orders API
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 订单API的URL查询参数
- en: In this section, we enhance the GET `/orders` endpoint of the orders API by
    adding URL query parameters. We also implement validation schemas for the parameters.
    In chapter 4, we learned that URL query parameters allow us to filter the results
    of a GET endpoint. In chapter 5, we established that the GET `/orders` endpoint
    accepts URL query parameters to filter orders by cancellation and also to limit
    the list of orders returned by the endpoint.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过添加URL查询参数来增强订单API的GET `/orders`端点。我们还实现了参数的验证模式。在第4章中，我们了解到URL查询参数允许我们过滤GET端点的结果。在第5章中，我们确定GET
    `/orders`端点接受URL查询参数以通过取消来过滤订单，并且还可以限制端点返回的订单列表。
- en: Listing 6.1 Specification for the GET `/orders` URL query parameters
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 GET `/orders` URL查询参数的规范
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to implement two URL query parameters: `cancelled` (Boolean) and `limit`
    (integer). Neither are required, so users must be able to call the GET `/orders`
    endpoint without specifying them. Let’s see how we do that.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现两个URL查询参数：`cancelled`（布尔值）和`limit`（整数）。这两个参数都不是必需的，因此用户必须能够在不指定它们的情况下调用GET
    `/orders`端点。让我们看看我们如何做到这一点。
- en: Implementing URL query parameters for an endpoint is easy with FastAPI. All
    we need to do is include them in the endpoint’s function signature and use type
    hints to add validation rules for them. Since the query parameters are optional,
    we’ll mark them as such using the `Optional` type, and we’ll set their default
    values to `None`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FastAPI实现端点的URL查询参数非常简单。我们只需要在端点的函数签名中包含它们，并使用类型提示为它们添加验证规则。由于查询参数是可选的，我们将使用`Optional`类型将它们标记为可选，并将它们的默认值设置为`None`。
- en: Listing 6.2 Implementation of URL query parameters for GET `/orders`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 GET `/orders`端点URL查询参数的实现
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① We include URL query parameters in the function signature.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们在函数签名中包含URL查询参数。
- en: Now that we have query parameters available in the GET `/orders` endpoint, how
    should we handle them within the function? Since the query parameters are optional,
    we’ll first check whether they’ve been set. We can do that by checking whether
    their values are something other than `None`. Listing 6.3 shows how we can handle
    URL query parameters within the function body of the GET `/orders` endpoint. Study
    figure 6.1 to understand the decision flow for filtering the list of orders based
    on the query parameters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在GET `/orders`端点中有了查询参数，我们如何在函数内部处理它们呢？由于查询参数是可选的，我们首先检查它们是否已设置。我们可以通过检查它们的值是否不是`None`来实现这一点。列表6.3显示了如何在GET
    `/orders`端点的函数体内部处理URL查询参数。研究图6.1以了解基于查询参数过滤订单列表的决策流程。
- en: Listing 6.3 Implementation of URL query parameters for GET `/orders`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 GET `/orders`端点URL查询参数的实现
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① If the parameters haven’t been set, we return immediately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果参数尚未设置，我们立即返回。
- en: ② If any of the parameters has been set, we filter list into a query_set.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果任何参数已设置，我们将列表过滤到`query_set`中。
- en: ③ We check whether cancelled is set.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们检查`cancelled`是否已设置。
- en: ④ If limit is set and its value is lower than the length of query_set, we return
    a subset of query_set.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果设置了`limit`并且其值小于`query_set`的长度，我们返回`query_set`的子集。
- en: '![](../Images/06-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-01.png)'
- en: Figure 6.1 Decision flow for filtering orders based on query parameters. If
    the `cancelled` parameter is set to `True` or `False`, we use it to filter the
    list of orders. After this step, we check whether the `limit` parameter is set.
    If `limit` is set, we only return the corresponding number of orders from the
    list.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 基于查询参数过滤订单的决策流程。如果`cancelled`参数设置为`True`或`False`，我们使用它来过滤订单列表。在此步骤之后，我们检查`limit`参数是否已设置。如果设置了`limit`，我们只从列表中返回相应数量的订单。
- en: Now that we know how to add URL query parameters to our endpoints, let’s see
    how we enhance our validation schemas.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何将URL查询参数添加到我们的端点中，让我们看看我们如何增强我们的验证模式。
- en: 6.3 Validating payloads with unknown fields
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 验证具有未知字段的负载
- en: Until now, our pydantic models have been tolerant with the request payloads.
    If an API client sends a payload with fields that haven’t been declared in our
    schemas, the payload will be accepted. As you’ll see in this section, this may
    be convenient in some cases but misleading or dangerous in other contexts. To
    avoid integration errors, in this section, we learn how to configure pydantic
    to forbid the presence of unknown fields. Unknown fields are fields that haven’t
    been defined in a schema.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 Pydantic 模型对请求负载一直持宽容态度。如果一个 API 客户端发送的负载包含在我们模式中未声明的字段，该负载将被接受。正如您在本节中将会看到的，在某些情况下这可能很方便，但在其他上下文中可能会产生误导或危险。为了避免集成错误，在本节中，我们将学习如何配置
    Pydantic 以禁止未知字段的的存在。未知字段是指那些在模式中未定义的字段。
- en: pydantic refresher As we saw in chapter 2, FastAPI uses pydantic to define validation
    models for our APIs. Pydantic is a popular data validation library for Python
    with a modern interface that allows you to define data validation rules using
    type hints.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 快速回顾正如我们在第 2 章中看到的，FastAPI 使用 Pydantic 来定义我们 API 的验证模型。Pydantic 是一个流行的
    Python 数据验证库，它具有现代接口，允许您使用类型提示来定义数据验证规则。
- en: In chapter 2, we implemented the schema definitions of the orders API following
    the tolerant reader pattern ([https://martinfowler.com/bliki/TolerantReader.html](https://martinfowler.com/bliki/TolerantReader.html)),
    which follows Postel’s law that recommends to be conservative in what you do and
    be liberal in what you accept from others.[¹](#pgfId-1080830)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们按照宽容读取器模式实现了订单 API 的模式定义（[https://martinfowler.com/bliki/TolerantReader.html](https://martinfowler.com/bliki/TolerantReader.html)），该模式遵循
    Postel 的法律，建议在您所做的事情上要保守，在您从他人那里接受的事情上要宽容。[¹](#pgfId-1080830)
- en: 'In the field of web APIs, this means that we must strictly validate the payloads
    we send to the client, while allowing for unknown fields in the payloads we receive
    from API clients. JSON Schema follows this pattern by default, and unless explicitly
    declared, a JSON Schema object accepts any kind of property. To disallow undeclared
    properties using JSON Schema, we set `additionalProperties` to `false`. If we
    use model composition, a better strategy is setting `unevaluatedProperties` to
    `false`, since `additionalProperties` causes conflicts between different models.[²](#pgfId-1080834)
    OpenAPI 3.1 allows us to use both `additionalProperties` and `unevaluatedProperties`,
    but OpenAPI 3.0 only accepts `additionalProperties`. Since we’re documenting our
    APIs using OpenAPI 3.0.3, we’ll ban undeclared properties using `additionalProperties`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络 API 领域，这意味着我们必须严格验证发送给客户端的负载，同时允许接收来自 API 客户端的负载中的未知字段。JSON Schema 默认遵循此模式，除非明确声明，否则
    JSON Schema 对象接受任何类型的属性。要使用 JSON Schema 禁止未声明的属性，我们将 `additionalProperties` 设置为
    `false`。如果我们使用模型组合，一个更好的策略是将 `unevaluatedProperties` 设置为 `false`，因为 `additionalProperties`
    会导致不同模型之间的冲突。[²](#pgfId-1080834) OpenAPI 3.1 允许我们使用 `additionalProperties` 和 `unevaluatedProperties`，但
    OpenAPI 3.0 只接受 `additionalProperties`。由于我们使用 OpenAPI 3.0.3 来记录我们的 API，我们将使用 `additionalProperties`
    来禁止未声明的属性：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Check out the orders API specification under ch06/orders/oas.yaml in the GitHub
    repository for this book to see additional examples of `additionalProperties`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多关于 `additionalProperties` 的示例，请查看本书 GitHub 仓库中 ch06/orders/oas.yaml 下的订单
    API 规范。
- en: The tolerant reader pattern is useful when an API is not fully consolidated
    or is likely to change frequently and when we want to be able to make changes
    to it without breaking integrations with existing clients. However, in other cases,
    like we saw in chapter 2 (section 2.5), the tolerant reader pattern can introduce
    new bugs or lead to unexpected integration issues.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 宽容读取器模式在 API 未经充分整合或可能频繁更改，并且我们希望能够在不破坏现有客户端集成的情况下对其进行更改时很有用。然而，在其他情况下，例如我们在第
    2 章中看到的（第 2.5 节），宽容读取器模式可能会引入新的错误或导致意外的集成问题。
- en: 'For example, `OrderItemSchema` has three properties: `product`, `size`, and
    `quantity`. `product` and `size` are required properties, but `quantity` is optional,
    and if missing, the server assigns to it the default value of `1`. In some scenarios,
    this can lead to confusing situations. Imagine a client sends a payload with a
    typo in the representation of the `quantity` property, for example with the following
    payload:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`OrderItemSchema` 有三个属性：`product`、`size` 和 `quantity`。`product` 和 `size`
    是必需属性，但 `quantity` 是可选的，如果缺失，服务器将其分配为默认值 `1`。在某些场景中，这可能会导致令人困惑的情况。想象一下，一个客户端发送了一个包含
    `quantity` 属性表示错误的负载，例如以下负载：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the tolerant reader implementation, we ignore the field `quantit` from
    the payload, and we assume that the `quantity` property is missing and set its
    value to the default of `1`. This situation can be confusing for the client, who
    intended to set a different value for `quantity`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容错读取器实现，我们忽略来自负载的字段 `quantit`，并假设 `quantity` 属性缺失，将其值设置为默认的 `1`。这种情况可能会让客户端感到困惑，因为客户端原本打算为
    `quantity` 设置不同的值。
- en: The API client should’ve tested their code! You can argue that the client should’ve
    tested their code and verified that it works properly before calling the server.
    And you’re right. But in real life, code often goes untested, or is not properly
    tested, and a little bit of extra validation in the server will help in those
    situations. If we check the payload for the presence of illegal properties, this
    error will be caught and reported to the client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: API 客户端应该测试他们的代码！你可以争辩说客户端应该测试他们的代码，并在调用服务器之前验证它是否正常工作。你是对的。但在现实生活中，代码往往未经测试，或者测试不充分，服务器上的一点额外验证将有助于这些情况。如果我们检查负载是否存在非法属性，这个错误将被捕获并向客户端报告。
- en: How can we accomplish this using pydantic? To disallow unknown attributes, we
    need to define a `Config` class within our models and set the `extra` property
    to `forbid`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用 pydantic 实现这一点？为了禁止未知属性，我们需要在我们的模型中定义一个 `Config` 类，并将 `extra` 属性设置为 `forbid`。
- en: Listing 6.4 Disallowing additional properties in models
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 在模型中禁止额外的属性
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① We use Config to ban properties that haven’t been defined in the schema.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用 Config 禁止在模式中未定义的属性。
- en: 'Let’s test this new functionality. Run the following command to start the server:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个新功能。运行以下命令以启动服务器：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we saw in chapter 2, FastAPI generates a Swagger UI from the code, which
    we can use to test the endpoints. We’ll use this UI to test our new validation
    rules with the following payload:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中看到的，FastAPI 从代码中生成 Swagger UI，我们可以使用它来测试端点。我们将使用此 UI 使用以下负载测试我们的新验证规则：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: DEFINITION A *Swagger UI* is a popular style for representing interactive visualizations
    of REST APIs. They provide a user-friendly interface that helps us understand
    the API implementation. Another popular UI for REST interfaces is Redoc ([https://github.com/Redocly/redoc](https://github.com/Redocly/redoc)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *Swagger UI* 是表示 REST API 交互式可视化的流行样式。它们提供了一个用户友好的界面，帮助我们理解 API 实现。另一个流行的
    REST 接口 UI 是 Redoc ([https://github.com/Redocly/redoc](https://github.com/Redocly/redoc))。
- en: To get to the Swagger UI, visit http://127.0.0.1:8000/docs and follow the steps
    in figure 6.2 to learn how to execute a test against the POST `/orders` endpoint.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 Swagger UI，请访问 http://127.0.0.1:8000/docs 并按照图 6.2 中的步骤操作，学习如何对 POST `/orders`
    端点执行测试。
- en: '![](../Images/06-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-02.png)'
- en: 'Figure 6.2 Testing the API with the Swagger UI: to test an endpoint, click
    the endpoint itself, then click the Try it Out button, then click the Execute
    button.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 使用 Swagger UI 测试 API：要测试端点，点击端点本身，然后点击“尝试一下”按钮，然后点击“执行”按钮。
- en: 'After running this test, you’ll see that now FastAPI invalidates this payload
    and returns a helpful 422 response with the following message: “extra fields not
    permitted.”'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试后，您会看到现在 FastAPI 会验证此负载，并返回一个包含以下信息的有用 422 响应：“不允许额外的字段。”
- en: 6.4 Overriding FastAPI’s dynamically generated specification
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 覆盖 FastAPI 的动态生成规范
- en: So far, we’ve relied on FastAPI’s dynamically generated API specification to
    test, visualize, and document the orders API. The dynamically generated specification
    is great to understand how we’ve implemented the API. However, our code can contain
    implementation errors, and those errors can translate to inaccurate documentation.
    Additionally, API development frameworks have limitations when it comes to generating
    API documentation, and they typically lack support for certain features of OpenAPI.
    For example, a common missing feature is documenting OpenAPI links, which we’ll
    add to our API specification in chapter 12.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖 FastAPI 动态生成的 API 规范来测试、可视化和记录订单 API。动态生成的规范有助于我们理解 API 的实现方式。然而，我们的代码可能包含实现错误，这些错误可能导致文档不准确。此外，API
    开发框架在生成 API 文档方面存在局限性，并且通常缺乏对 OpenAPI 某些特性的支持。例如，一个常见的缺失特性是记录 OpenAPI 链接，我们将在第
    12 章中将其添加到我们的 API 规范中。
- en: To understand how the API is supposed to work, we need to look at our API design
    document, which lives under orders/oas.yaml, and therefore is the specification
    we want to show when we deploy the API. In this section, you’ll learn to override
    FastAPI’s dynamically generated API specification with our API design document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解API应该如何工作，我们需要查看我们的API设计文档，它位于orders/oas.yaml下，因此是我们部署API时想要展示的规范。在本节中，你将学习如何使用我们的API设计文档覆盖FastAPI动态生成的API规范。
- en: 'To load the API specification document, we need PyYAML, which you can install
    with the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载API规范文档，我们需要PyYAML，你可以使用以下命令安装：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the orders/app.py file, we load the API specification, and we overwrite our
    application’s object `openapi` property.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在orders/app.py文件中，我们加载API规范，并覆盖我们应用程序的对象`openapi`属性。
- en: Listing 6.5 Overriding FastAPI’s dynamically generated API specification
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 覆盖FastAPI动态生成的API规范
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① We load the API specification using PyYAML.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用PyYAML加载API规范。
- en: ② We override FastAPI’s openapi property so that it returns our API specification.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们覆盖FastAPI的openapi属性，使其返回我们的API规范。
- en: 'To be able to test the API using the Swagger UI, we need to add the localhost
    URL to the API specification. Open the orders/oas.yaml file and add the localhost
    address to the `servers` section of the specification:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用Swagger UI测试API，我们需要将localhost URL添加到API规范中。打开orders/oas.yaml文件，并将localhost地址添加到规范的`servers`部分：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, FastAPI serves the Swagger UI under the /docs URL, and the OpenAPI
    specification under /openapi.json. That’s great when we only have one API, but
    CoffeeMesh has multiple microservice APIs; therefore, we need multiple paths to
    access each API’s documentation. We’ll serve the orders API’s Swagger UI under
    /docs/orders, and its OpenAPI specification under /openapi/orders.json. We can
    override those paths directly in FastAPI’s application object initializer:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FastAPI在/docs URL下提供Swagger UI，在/openapi.json下提供OpenAPI规范。当我们只有一个API时，这很好，但CoffeeMesh有多个微服务API；因此，我们需要多个路径来访问每个API的文档。我们将为orders
    API的Swagger UI提供/docs/orders，以及其OpenAPI规范提供/openapi/orders.json。我们可以在FastAPI的应用程序对象初始化器中直接覆盖这些路径：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This concludes our journey through building the orders API with FastAPI. It’s
    now time to move on to building the API for the kitchen service, for which we’ll
    use a new stack: Flask + marshmallow. Let’s get on with it!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们使用FastAPI构建订单API之旅的结束。现在是时候继续构建厨房服务的API了，我们将使用一个新的堆栈：Flask + marshmallow。让我们开始吧！
- en: 6.5 Overview of the kitchen API
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 厨房API概述
- en: In this section, we analyze the implementation requirements for the kitchen
    API. As you can see in figure 6.3, the kitchen service manages the production
    of customer orders. Customers interface with the kitchen service through the orders
    service when they place an order or check its status. CoffeeMesh staff can also
    use the kitchen service to check how many orders are scheduled and to manage them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了厨房API的实现需求。如图6.3所示，厨房服务管理客户订单的生产。当客户下单或检查订单状态时，他们通过订单服务与厨房服务接口。CoffeeMesh的员工也可以使用厨房服务来检查已安排的订单数量并管理它们。
- en: '![](../Images/06-03.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-03.png)'
- en: Figure 6.3 The kitchen service schedules orders for production, and it tracks
    their progress. CoffeeMesh staff members use the kitchen service to manage scheduled
    orders.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 厨房服务安排生产订单，并跟踪它们的进度。CoffeeMesh的员工使用厨房服务来管理已安排的订单。
- en: 'The specification for the kitchen API is provided under ch06/kitchen/oas.yaml
    in the repository provided with this book. The kitchen API contains four URL paths
    (see figure 6.4 for additional clarification):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 厨房API的规范位于本书提供的存储库中的ch06/kitchen/oas.yaml文件下。厨房API包含四个URL路径（参见图6.4以获取更多说明）：
- en: '`/kitchen/schedules`—Allows us to schedule an order for production in the kitchen
    (POST) and to retrieve a list of orders scheduled for production (GET)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kitchen/schedules`—允许我们在厨房中安排生产订单（POST）并检索已安排生产订单的列表（GET）'
- en: '`/kitchen/schedules/{schedule_id}`—Allows us to retrieve the details of a scheduled
    order (GET), to update its details (PUT), and to delete it from our records (DELETE)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kitchen/schedules/{schedule_id}`—允许我们检索已安排订单的详细信息（GET），更新其详细信息（PUT），并从我们的记录中删除它（DELETE）'
- en: '`/kitchen/schedules/{schedule_id}/status`—Allows us to read the status of an
    order scheduled for production'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kitchen/schedules/{schedule_id}/status`—允许我们读取已安排生产订单的状态'
- en: '`/kitchen/schedules/{schedule_id}/cancel`—Allows us to cancel a scheduled order'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kitchen/schedules/{schedule_id}/cancel`—允许我们取消一个已计划的订单'
- en: '![](../Images/06-04.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-04.png)'
- en: 'Figure 6.4 The kitchen API has four URL paths: `/kitchen/schedules` exposes
    a GET and a POST endpoint; `/kitchen/schedules/{schedule_id}` exposes PUT, GET,
    and DELETE endpoints; `/kitchen/schedules/{schedule_id}/cancel` exposes a POST
    endpoint; and `/kitchen/schedules/{schedule_id}/status` exposes a GET endpoint.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 厨房API有四个URL路径：`/kitchen/schedules`公开一个GET和一个POST端点；`/kitchen/schedules/{schedule_id}`公开PUT、GET和DELETE端点；`/kitchen/schedules/{schedule_id}/cancel`公开一个POST端点；而`/kitchen/schedules/{schedule_id}/status`公开一个GET端点。
- en: 'The kitchen API contains three schemas: `OrderItemSchema`, `ScheduleOrderSchema`,
    and `GetScheduledOrderSchema`. The `ScheduleOrderSchema` represents the payload
    required to schedule an order for production, while the `GetScheduledOrderSchema`
    represents the details of an order that has been scheduled. Just like in the orders
    API, `OrderItemSchema` represents the details of each item in an order.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 厨房API包含三个模式：`OrderItemSchema`、`ScheduleOrderSchema`和`GetScheduledOrderSchema`。`ScheduleOrderSchema`表示为生产调度订单所需的负载，而`GetScheduledOrderSchema`表示已调度的订单的详细信息。就像在订单API中一样，`OrderItemSchema`表示订单中每个项目的详细信息。
- en: Just as we did in chapter 2, we’ll keep the implementation simple and focus
    only on the API layer. We’ll mock the business layer with an in-memory representation
    of the schedules managed by the service. In chapter 7, we’ll learn service implementation
    patterns that will help us implement the business layer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第2章中所做的那样，我们将保持实现简单，仅关注API层。我们将使用服务管理的调度内存表示来模拟业务层。在第7章中，我们将学习服务实现模式，这将帮助我们实现业务层。
- en: 6.6 Introducing flask-smorest
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 介绍 flask-smorest
- en: 'This section introduces the framework we’ll use to build the kitchen API: flask-smorest
    ([https://github.com/marshmallow-code/flask-smorest](https://github.com/marshmallow-code/flask-smorest)).
    Flask-smorest is a REST API framework built on top of Flask and marshmallow. Flask
    is a popular framework for building web applications, while marshmallow is a popular
    data validation library that handles the conversion of complex data structures
    to and from native Python objects. Flask-smorest builds on top of both frameworks,
    which means we implement our API schemas using marshmallow, and we implement our
    API endpoints following the patterns of a typical Flask application, as illustrated
    in figure 6.5\. As you’ll see, the principles and patterns we used when we built
    the orders API with FastAPI can be applied regardless of the framework, and we’ll
    use the same approach to build the kitchen API with flask-smorest.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了我们将用于构建厨房API的框架：flask-smorest ([https://github.com/marshmallow-code/flask-smorest](https://github.com/marshmallow-code/flask-smorest))。Flask-smorest是在Flask和marshmallow之上构建的REST
    API框架。Flask是构建Web应用的流行框架，而marshmallow是一个流行的数据验证库，用于处理复杂数据结构到和从原生Python对象的转换。Flask-smorest建立在两个框架之上，这意味着我们使用marshmallow实现我们的API模式，我们按照典型Flask应用程序的模式实现我们的API端点，如图6.5所示。正如您将看到的，我们在使用FastAPI构建订单API时使用的原则和模式可以应用于任何框架，我们将使用相同的方法使用flask-smorest构建厨房API。
- en: '![](../Images/06-05.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-05.png)'
- en: Figure 6.5 Architecture of an application built with flask-smorest. Flask-smorest
    implements a typical Flask blueprint, which allows us to build and configure our
    API endpoints just as we would in a standard Flask application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 使用flask-smorest构建的应用程序架构。Flask-smorest实现了一个典型的Flask蓝图，这允许我们像在标准Flask应用程序中一样构建和配置我们的API端点。
- en: 'Building APIs with flask-smorest offers an experience similar to building them
    with FastAPI, with only two major differences:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用flask-smorest构建API提供与使用FastAPI构建类似的经验，只有两个主要区别：
- en: '*FastAPI uses pydantic for data validation, while flask-smorest uses marshmallow*.
    This means that with FastAPI we use native Python-type hints to create data validation
    rules, while in marshmallow we use field classes.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI使用pydantic进行数据验证，而flask-smorest使用marshmallow*。这意味着在FastAPI中，我们使用原生Python类型提示来创建数据验证规则，而在marshmallow中，我们使用字段类。'
- en: '*Flask allows us to implement API endpoints with class-based views*. This means
    that we can use a class to represent a URL path and implement its HTTP methods
    as methods of the class. Class-based views help you write more structured code
    and encapsulate the specific behavior of each URL path within the class. In contrast,
    FastAPI allows you only to define endpoints using functions. Notice that Starlette
    allows you to implement class-based routes, so this limitation of FastAPI may
    go away in the future.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Flask允许我们使用基于类的视图实现API端点*。这意味着我们可以使用一个类来表示一个URL路径，并实现其HTTP方法作为类的成员方法。基于类的视图帮助你编写更结构化的代码，并将每个URL路径的特定行为封装在类中。相比之下，FastAPI只允许你使用函数定义端点。请注意，Starlette允许你实现基于类的路由，因此FastAPI的这种限制可能在将来消失。'
- en: With this covered, let’s kick off the implementation of the kitchen API!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们开始厨房API的实现！
- en: 6.7 Initializing the web application for the API
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 初始化API的Web应用程序
- en: In this section, we set up the environment to start working on the kitchen API.
    We’ll also create the entry point for the application and add basic configuration
    for the web server. In doing so, you’ll learn how to set up a project with flask-smorest
    and how to inject configuration objects into your Flask applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设置环境以开始对厨房API进行工作。我们还将创建应用程序的入口点并添加对Web服务器的基本配置。这样做，你将学习如何使用flask-smorest设置项目以及如何将配置对象注入到Flask应用程序中。
- en: 'Flask-smorest is built on top of the Flask framework, so we’ll lay out our
    web application following the patterns of a typical Flask application. Create
    a folder called ch06/kitchen for the kitchen API implementation. Within that folder,
    copy the kitchen API specification, which is available under ch06/kitchen/oas.yaml
    in this book’s GitHub repository. oas.yaml contains the API specification for
    the kitchen API. Use the `cd` command to navigate into the ch06/kitchen folder,
    and run the following commands to install the dependencies that we’ll need to
    proceed with the implementation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-smorest建立在Flask框架之上，因此我们将按照典型Flask应用程序的模式来布局我们的Web应用程序。为厨房API实现创建一个名为ch06/kitchen的文件夹。在该文件夹中，复制本书GitHub仓库中ch06/kitchen/oas.yaml下的厨房API规范。oas.yaml包含厨房API的规范。使用`cd`命令导航到ch06/kitchen文件夹，并运行以下命令来安装我们进行实现所需的依赖项：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: NOTE If you want to ensure that you’re installing the same version of the dependencies
    that I used when writing this chapter, copy the ch06/kitchen/ Pipfile and the
    ch06/kitchen/Pipfile.lock files from the GitHub repository onto your local machine,
    and run `pipenv` `install`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你想确保安装的依赖项与我编写本章时使用的版本相同，请从GitHub仓库复制ch06/kitchen/ Pipfile和ch06/kitchen/Pipfile.lock文件到你的本地机器上，并运行`pipenv`
    `install`。
- en: 'Also, run the following command to activate the environment:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，运行以下命令以激活环境：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have the libraries we need, let’s create a file called kitchen/app.py.
    This file will contain an instance of the `Flask` application object, which represents
    our web server. We’ll also create an instance of flask-smorest’s `Api` object,
    which will represent our API.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的库，让我们创建一个名为kitchen/app.py的文件。这个文件将包含一个`Flask`应用程序对象的实例，它代表我们的Web服务器。我们还将创建一个flask-smorest的`Api`对象的实例，它将代表我们的API。
- en: Listing 6.6 Initialization of the `Flask` application object and the `Api` object
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 初始化`Flask`应用程序对象和`Api`对象
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① We create an instance of the Flask application object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建了一个Flask应用程序对象的实例。
- en: ② We create an instance of flask-smorest’s Api object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们创建了一个flask-smorest的Api对象的实例。
- en: Flask-smorest requires some configuration parameters to work. For example, we
    need to specify the version of OpenAPI we are using, the title of our API, and
    the version of our API. We pass this configuration through the `Flask` application
    object. Flask offers different strategies for injecting configuration, but the
    most convenient method is loading configuration from a class. Let’s create a file
    called kitchen/config.py for our configuration parameters. Within this file we
    create a `BaseConfig` class, which contains generic configuration for the API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-smorest需要一些配置参数才能工作。例如，我们需要指定我们使用的OpenAPI版本、我们API的标题以及我们API的版本。我们通过`Flask`应用程序对象传递此配置。Flask提供了不同的注入配置策略，但最方便的方法是从类中加载配置。让我们创建一个名为kitchen/config.py的文件来存储我们的配置参数。在这个文件中，我们创建一个`BaseConfig`类，它包含API的通用配置。
- en: Listing 6.7 Configuration for the orders API
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 orders API的配置
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① The title of our API
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们API的标题
- en: ② The version of our API
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们API的版本
- en: ③ The version of OpenAPI we are using
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用的OpenAPI版本
- en: ④ Path to the dynamically generated specification in JSON
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 动态生成的JSON规范路径
- en: ⑤ URL path prefix for the OpenAPI specification file
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ OpenAPI规范文件URL路径的前缀
- en: ⑥ Path to the Redoc UI of our API
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们API的Redoc UI路径
- en: ⑦ Path to a script to be used to render the Redoc UI
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 用于渲染Redoc UI的脚本路径
- en: ⑧ Path to the Swagger UI of our API
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们API的Swagger UI路径
- en: ⑨ Path to a script to be used to render the Swagger UI
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 用于渲染Swagger UI的脚本路径
- en: Now that the configuration is ready, we can pass it to the `Flask` application
    object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置已经就绪，我们可以将其传递给`Flask`应用程序对象。
- en: Listing 6.8 Loading configuration
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 加载配置
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① We import the BaseConfig class we defined earlier.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入我们之前定义的BaseConfig类。
- en: ② We use the from_object method to load configuration from a class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用from_object方法从类中加载配置。
- en: With the entry point for our application ready and configured, let’s move on
    to implementing the endpoints for the kitchen API!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序入口点和配置就绪并配置好后，让我们继续实现厨房API的端点！
- en: 6.8 Implementing the API endpoints
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 实现API端点
- en: 'This section explains how we implement the endpoints of the kitchen API using
    flask-smorest. Since flask-smorest is built on top of Flask, we build the endpoints
    for our API exactly as we’d do any other Flask application. In Flask, we register
    our endpoints using Flask’s `route` decorator:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了我们如何使用flask-smorest实现厨房API的端点。由于flask-smorest建立在Flask之上，因此我们为我们的API构建端点的方式与构建任何其他Flask应用程序的方式完全相同。在Flask中，我们使用Flask的`route`装饰器注册我们的端点：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using the `route` decorator works for simple cases, but for more complex application
    patterns, we use Flask blueprints. Flask blueprints allow you to provide specific
    configuration for a group of URLs. To implement the kitchen API endpoints, we’ll
    use the flask-smorest’s `Blueprint` class. Flask-smorest’s `Blueprint` is a subclass
    of Flask’s `Blueprint`, so it provides the functionality that comes with Flask
    blueprints, enhances it with additional functionality and configuration that generates
    API documentation, and supplies payload validation models, among other things.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`route`装饰器适用于简单情况，但对于更复杂的应用程序模式，我们使用Flask blueprints。Flask blueprints允许你为一组URL提供特定的配置。为了实现厨房API端点，我们将使用flask-smorest的`Blueprint`类。Flask-smorest的`Blueprint`是Flask的`Blueprint`的子类，因此它提供了Flask
    blueprints的功能，并增强了额外的功能和配置，用于生成API文档，并提供负载验证模型等。
- en: We can use `Blueprint`’s `route` decorators to create an endpoint or URL path.
    As you can see from figure 6.6, functions are convenient for URL paths that only
    expose one HTTP method. When a URL exposes multiple HTTP methods, it’s more convenient
    to use class-based routes, which we implement using Flask’s `MethodView` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Blueprint`的`route`装饰器创建端点或URL路径。正如你在图6.6中看到的，对于只暴露一个HTTP方法的URL路径，函数是方便的。当一个URL暴露多个HTTP方法时，使用基于类的路由会更方便，我们使用Flask的`MethodView`类来实现这些路由。
- en: '![](../Images/06-06.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图6-6](../Images/06-06.png)'
- en: Figure 6.6 When a URL path exposes more than one HTTP method, it’s more convenient
    to implement it as a class-based view, where the class methods implement each
    of the HTTP methods exposed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 当一个URL路径暴露多个HTTP方法时，将其实现为一个基于类的视图会更方便，其中类方法实现了暴露的每个HTTP方法。
- en: As you can see in figure 6.7, using `MethodView`, we represent a URL path as
    a class, and we implement the HTTP methods it exposes as methods of the class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图6.7中看到的，使用`MethodView`，我们将URL路径表示为一个类，并将它暴露的HTTP方法实现为类的成员方法。
- en: '![](../Images/06-07.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图6-7](../Images/06-07.png)'
- en: Figure 6.7 When a URL path exposes only one HTTP method, it’s more convenient
    to implement it as a function-based view.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 当一个URL路径只暴露一个HTTP方法时，将其实现为一个基于函数的视图会更方便。
- en: 'For example, if we have a URL path `/kitchen` that exposes GET and POST endpoints,
    we can implement the following class-based view:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个暴露GET和POST端点的URL路径`/kitchen`，我们可以实现以下基于类的视图：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6.9 illustrates how we implement the endpoints for the kitchen API
    using class-based views and function-based views. The content in listing 6.9 goes
    into the kitchen/api/api.py file. First, we create an instance of flask-smorest’s
    `Blueprint`. The `Blueprint` object allows us to register our endpoints and add
    data validation to them. To instantiate `Blueprint`, we must pass two required
    positional arguments: the name of the `Blueprint` itself and the name of the module
    where the `Blueprint`’s routes are implemented. In this case, we pass the module’s
    name using the `__name__` attribute, which resolves to the name of the file.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 展示了如何使用基于类的视图和基于函数的视图实现厨房 API 的端点。列表 6.9 中的内容放入 kitchen/api/api.py 文件中。首先，我们创建
    flask-smorest 的 `Blueprint` 的一个实例。`Blueprint` 对象允许我们注册我们的端点并为它们添加数据验证。要实例化 `Blueprint`，我们必须传递两个必需的位置参数：`Blueprint`
    本身的名称以及实现 `Blueprint` 路由的模块的名称。在这种情况下，我们使用 `__name__` 属性传递模块的名称，它解析为文件的名称。
- en: Once the `Blueprint` is instantiated, we register our URL paths with it using
    the `route()` decorator. We use class-based routes for the `/kitchen/schedules`
    and the `/kitchen/schedules/{schedule_id}` paths since they expose more than one
    HTTP method, and we use function-based routes for the `/kitchen/schedules/{schedule_`
    `id}/cancel` and /`kitchen/schedules/{schedule_id}/status` paths because they
    only expose one HTTP method. We return a mock schedule object in each endpoint
    for illustration purposes, and we’ll change that into a dynamic in-memory collection
    of schedules in section 6.12\. The return value of each function is a tuple, where
    the first element is the payload and the second is the status code of the response.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `Blueprint` 被实例化，我们就使用 `route()` 装饰器将我们的 URL 路径注册到它。对于 `/kitchen/schedules`
    和 `/kitchen/schedules/{schedule_id}` 路径，我们使用基于类的路由，因为它们暴露了多个 HTTP 方法，而对于 `/kitchen/schedules/{schedule_id}/cancel`
    和 `/kitchen/schedules/{schedule_id}/status` 路径，我们使用基于函数的路由，因为它们只暴露一个 HTTP 方法。为了说明目的，我们每个端点都返回一个模拟的调度对象，我们将在第
    6.12 节中将它更改为动态的内存中的调度集合。每个函数的返回值是一个元组，其中第一个元素是有效载荷，第二个是响应的状态码。
- en: Listing 6.9 Implementation of the endpoints of the orders API
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 订单 API 端点的实现
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① We create an instance of flask-smorest’s Blueprint class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建 flask-smorest 的 Blueprint 类的一个实例。
- en: ② We declare a hardcoded list of schedules.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们声明一个硬编码的调度列表。
- en: ③ We use the Blueprint’s route() decorator to register a class or a function
    as a URL path.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用 Blueprint 的 route() 装饰器来注册一个类或函数作为 URL 路径。
- en: ④ We implement the /kitchen/schedules URL path as a class-based view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将 `/kitchen/schedules` URL 路径实现为一个基于类的视图。
- en: ⑤ Every method view in a class-based view is named after the HTTP method it
    implements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 在基于类的视图中，每个方法视图的名称都与其实现的 HTTP 方法相对应。
- en: ⑥ We return both the payload and the status code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们返回有效载荷和状态码。
- en: ⑦ We define URL parameters within angle brackets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们在尖括号内定义 URL 参数。
- en: ⑧ We include the URL path parameter in the function signature.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们在函数签名中包含 URL 路径参数。
- en: ⑨ We implement the /kitchen/schedules/<schedule_id>/cancel URL path as a function-based
    view.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 我们将 `/kitchen/schedules/<schedule_id>/cancel` URL 路径实现为一个基于函数的视图。
- en: Now that we have created the blueprint, we can register it with our API object
    in the kitchen/app.py file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了蓝图，我们可以在 kitchen/app.py 文件中将它注册到我们的 API 对象。
- en: Listing 6.10 Registering the blueprint with the API object
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 将蓝图注册到 API 对象
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① We import the blueprint we defined earlier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入之前定义的蓝图。
- en: ② We register the blueprint with the kitchen API object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将蓝图注册到厨房 API 对象。
- en: 'Using the `cd` command, navigate to the ch06/kitchen directory and run the
    application with the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cd` 命令导航到 ch06/kitchen 目录，并使用以下命令运行应用程序：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like in Uvicorn, the `--reload` flag runs the server with a watcher over
    your files so that the server restarts when you make changes to the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Uvicorn 中一样，`--reload` 标志会在你的文件上运行一个监视器，以便当你修改代码时服务器会重新启动。
- en: If you visit the http://127.0.0.1:5000/docs URL, you’ll see an interactive Swagger
    UI dynamically generated from the endpoints we implemented earlier. You can also
    see the OpenAPI specification dynamically generated by flask-smorest under http://127.0.0.1:5000/openapi.json.
    At this stage in our implementation, it’s not possible to interact with the endpoints
    through the Swagger UI. Since we don’t yet have marshmallow models, flask-smorest
    doesn’t know how to serialize data and therefore doesn’t return payloads. However,
    it’s still possible to call the API using cURL and inspect the responses. If you
    run `curl` `http://127.0.0.1:5000/kitchen/schedules`, you’ll get the mock object
    we defined in the kitchen/api/api.py module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问http://127.0.0.1:5000/docs URL，您将看到由我们之前实现的端点动态生成的交互式Swagger UI。您还可以看到由flask-smorest在http://127.0.0.1:5000/openapi.json下动态生成的OpenAPI规范。在我们当前的实施阶段，通过Swagger
    UI与端点交互是不可能的。由于我们还没有marshmallow模型，flask-smorest不知道如何序列化数据，因此不返回负载。然而，仍然可以通过cURL调用API并检查响应。如果您运行`curl
    http://127.0.0.1:5000/kitchen/schedules`，您将得到我们在厨房/api/api.py模块中定义的模拟对象。
- en: Things are looking good, and it’s time to spice up the implementation by adding
    marshmallow models. Move on to the next section to learn how to do that!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很顺利，现在是时候通过添加marshmallow模型来丰富实现。继续阅读下一节，了解如何做到这一点！
- en: 6.9 Implementing payload validation models with marshmallow
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 使用marshmallow实现负载验证模型
- en: Flask-smorest uses marshmallow models to validate request and response payloads.
    In this section, we learn to work marshmallow models by implementing the schemas
    of the kitchen API. The marshmallow models will help flask-smorest validate our
    payloads and serialize our data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-smorest使用marshmallow模型来验证请求和响应负载。在本节中，我们通过实现厨房API的架构来学习如何使用marshmallow模型。marshmallow模型将帮助flask-smorest验证我们的负载并序列化我们的数据。
- en: 'As you can see in the kitchen API specification under ch06/kitchen/oas.yaml
    in this book’s GitHub repository, the kitchen API contains three schemas: `ScheduleOrderSchema`
    schema, which contains the details needed to schedule an order; `GetScheduledOrderSchema`,
    which represents the details of a scheduled order; and `OrderItemSchema`, which
    represents a collection of items in an order. Listing 6.11 shows how to implement
    these schemas as marshmallow models under kitchen/api/ schemas.py.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以在本书GitHub仓库的ch06/kitchen/oas.yaml文件下的厨房API规范中看到的那样，厨房API包含三个架构：`ScheduleOrderSchema`架构，其中包含安排订单所需的详细信息；`GetScheduledOrderSchema`，它表示已安排订单的详细信息；以及`OrderItemSchema`，它表示订单中的项目集合。列表6.11展示了如何在厨房/api/schemas.py下实现这些架构作为marshmallow模型。
- en: To create marshmallow models, we create subclasses of marshmallow’s `Schema`
    class. We define the models’ properties with the help of marshmallow’s field classes,
    such as `String` and `Integer`. Marshmallow uses these property definitions to
    validate a payload against a model. To customize the behavior of marshmallow’s
    models, we use the `Meta` class to set the `unknown` attribute to `EXCLUDE`, which
    instructs marshmallow to invalidate the payload with unknown properties.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建marshmallow模型，我们创建marshmallow的`Schema`类的子类。我们使用marshmallow的字段类，如`String`和`Integer`，来定义模型的属性。Marshmallow使用这些属性定义来验证负载与模型的一致性。为了自定义marshmallow模型的行为，我们使用`Meta`类将`unknown`属性设置为`EXCLUDE`，这指示marshmallow无效化具有未知属性的负载。
- en: Listing 6.11 Schema definitions for the orders API
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 订单API的架构定义
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① We use the Meta class to ban unknown properties.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们使用Meta类来禁止未知属性。
- en: ② We use class inheritance to reuse the definitions of an existing schema.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用类继承来重用现有架构的定义。
- en: Now that our validation models are ready, we can link them with our views. Listing
    6.12 shows how we use the models to add validation for request and response payloads
    on our endpoints. To add request payload validation to a view, we use the blueprint’s
    `arguments()` decorator in combination with a marshmallow model. For response
    payloads, we use the blueprint’s `response()` decorator in combination with a
    marshmallow model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了验证模型，我们可以将它们与我们的视图链接起来。列表6.12展示了我们如何使用这些模型在我们的端点上添加请求和响应负载的验证。要向视图添加请求负载验证，我们使用蓝图中的`arguments()`装饰器与marshmallow模型结合使用。对于响应负载，我们使用蓝图中的`response()`装饰器与marshmallow模型结合使用。
- en: By decorating our methods and functions with the blueprint’s `response()` decorator,
    we no longer need to return a tuple of payload plus a status code. Flask-smorest
    takes care of adding the status code for us. By default, flask-smorest adds a
    200 status code to our responses. If we want to customize that, we simply need
    to specify the desired status code using the `status_code` parameter in the decorator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用蓝图中的`response()`装饰器装饰我们的方法和函数，我们不再需要返回负载加状态码的元组。Flask-smorest会为我们处理添加状态码。默认情况下，flask-smorest将200状态码添加到我们的响应中。如果我们想自定义它，我们只需在装饰器中指定所需的`status_code`参数。
- en: While the blueprint’s `arguments()` decorator validates and deserializes a request
    payload, the blueprint’s `response()` decorator doesn’t perform validation and
    only serializes the payload. We’ll discuss this feature in more detail in section
    6.11, and we’ll see how we can ensure that data is validated before being serialized.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当蓝图中的`arguments()`装饰器验证和反序列化请求负载时，蓝图中的`response()`装饰器不执行验证，仅序列化负载。我们将在6.11节中更详细地讨论此功能，并了解我们如何确保在序列化之前验证数据。
- en: Listing 6.12 Adding validation to the API endpoints
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12 向API端点添加验证
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① We import our marshmallow models.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入我们的Marshmallow模型。
- en: ② We use the blueprint’s response() decorator to register a marshmallow model
    for the response payload.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用蓝图中的`response()`装饰器来注册用于响应负载的Marshmallow模型。
- en: ③ We use the blueprint’s arguments() decorator to register a marshmallow model
    for the request payload.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们使用蓝图中的`arguments()`装饰器来注册用于请求负载的Marshmallow模型。
- en: ④ We set the status_code parameter to the desired status code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将`status_code`参数设置为所需的状态码。
- en: To see the effects of the new changes in the implementation, visit http://127.0.0.1:5000/docs
    URL again. If you’re running the server with the `--reload` flag, the changes
    will be automatically reloaded. Otherwise, stop the server and run it again. As
    you can see in figure 6.8, flask-smorest now recognizes the validation schemas
    that need to be used in the API, and therefore they’re represented in the Swagger
    UI. If you play around with the UI now, for example by hitting the GET `/kitchen/schedules`
    endpoint, you’ll be able to see the response payloads.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实现中新的更改的效果，请再次访问http://127.0.0.1:5000/docs URL。如果您使用`--reload`标志运行服务器，更改将自动重新加载。否则，停止服务器并重新运行。如图6.8所示，flask-smorest现在识别API中需要使用的验证模式，因此它们在Swagger
    UI中表示。如果您现在尝试操作UI，例如通过调用GET `/kitchen/schedules`端点，您将能够看到响应负载。
- en: '![](../Images/06-08.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06-08.png)'
- en: Figure 6.8 The Swagger UI shows the schema for the request for the POST `/kitchen/schedules`
    endpoint’s payload and provides an example of it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 Swagger UI显示了POST `/kitchen/schedules`端点请求负载的模式，并提供了示例。
- en: The API is looking good, and we are nearly finished with the implementation.
    The next step is adding URL query parameters to the GET `/kitchen/schedules` endpoint.
    Move on to the next section to learn how to do that!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: API看起来不错，我们几乎完成了实现。下一步是向GET `/kitchen/schedules`端点添加URL查询参数。继续下一节，了解如何做到这一点！
- en: 6.10 Validating URL query parameters
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10 验证URL查询参数
- en: 'In this section, we learn how to add URL query parameters to the GET /`kitchen/`
    `schedules` endpoint. As shown in listing 6.13, the GET `/kitchen/schedules` endpoint
    accepts three URL query parameters:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习如何向GET /`kitchen/` `schedules`端点添加URL查询参数。如图表6.13所示，GET `/kitchen/schedules`端点接受三个URL查询参数：
- en: '`progress` *(Boolean)*—Indicates whether an order is in progress.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`progress` *(布尔值)*—指示订单是否正在进行中。'
- en: '`limit` *(integer)*—Limits the number of results returned by the endpoint.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit` *(整数)*—限制端点返回的结果数量。'
- en: '`since` *(date-time)*—Filters results by the time when the orders were scheduled.
    A date in date-time format is an ISO date with the following structure: `YYYY-MM-DDTHH:mm:ssZ`.
    An example of this date format is 2021-08-31T01:01:01Z. For more information on
    this format, see [https://tools.ietf.org/html/rfc3339 #section-5.6](https://tools.ietf.org/html/rfc3339#section-5.6).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`since` *(日期时间)*—通过订单计划的时间过滤结果。日期时间格式的日期是ISO日期，具有以下结构：`YYYY-MM-DDTHH:mm:ssZ`。此日期格式的一个示例是2021-08-31T01:01:01Z。有关此格式的更多信息，请参阅[https://tools.ietf.org/html/rfc3339
    #section-5.6](https://tools.ietf.org/html/rfc3339#section-5.6)。'
- en: Listing 6.13 Specification for the GET `/kitchen/schedules` URL query parameters
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 GET `/kitchen/schedules` URL查询参数规范
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How do we implement URL query parameters in flask-smorest? To begin, we need
    to create a new marshmallow model to represent them. We define the URL query parameters
    for the kitchen API using marshmallow. You can add the model for the URL query
    parameters to kitchen/api/schemas.py with the other marshmallow models.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 flask-smorest 中实现 URL 查询参数？首先，我们需要创建一个新的 marshmallow 模型来表示它们。我们使用 marshmallow
    定义厨房 API 的 URL 查询参数。您可以将 URL 查询参数的模型添加到 kitchen/api/schemas.py 中，与其他 marshmallow
    模型一起。
- en: Listing 6.14 URL query parameters in marshmallow
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 marshmallow 中的 URL 查询参数
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① We define the fields of the URL query parameters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们定义 URL 查询参数的字段。
- en: We register the schema for URL query parameters using the blueprint’s `arguments()`
    decorator. We specify that the properties defined in the schema are expected in
    the URL, so we set the `location` parameter to `query`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用蓝图中的 `arguments()` 装饰器注册 URL 查询参数的方案。我们指定方案中定义的属性预期在 URL 中，因此我们将 `location`
    参数设置为 `query`。
- en: Listing 6.15 Adding URL query parameters to GET `/kitchen/schedules`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 向 GET `/kitchen/schedules` 添加 URL 查询参数
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① We import the marshmallow model for URL query parameters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 URL 查询参数的 marshmallow 模型。
- en: ② We register the model using the arguments() decorator and set the location
    parameter to query.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 arguments() 装饰器注册模型，并将位置参数设置为查询。
- en: ③ We capture URL query parameter in the function signature.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们在函数签名中捕获 URL 查询参数。
- en: If you reload the Swagger UI, you’ll see that the GET `/kitchen/schedules` endpoint
    now accepts three optional URL query parameters (shown in figure 6.9). We should
    pass these parameters to our business layer, which will use them to filter the
    list of results. URL query parameters come in the form of a dictionary. If the
    user didn’t set any query parameters, the dictionary will be empty and therefore
    and evaluate to `False`. Since URL query parameters are optional, we check for
    their presence by using the dictionary’s `get()` method. Since `get()` returns
    `None` when a parameter isn’t set, we know that a parameter is set when its value
    isn’t `None`. We won’t be implementing the business layer until chapter 7, but
    we can use query parameters to filter our in-memory list of schedules.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新加载 Swagger UI，你会看到 GET `/kitchen/schedules` 端点现在接受三个可选的 URL 查询参数（如图 6.9
    所示）。我们应该将这些参数传递给我们的业务层，它将使用它们来过滤结果列表。URL 查询参数以字典的形式出现。如果用户没有设置任何查询参数，则字典将为空，因此评估为
    `False`。由于 URL 查询参数是可选的，我们通过使用字典的 `get()` 方法来检查它们的存在。由于 `get()` 在参数未设置时返回 `None`，我们知道当参数的值不是
    `None` 时，参数已被设置。我们将在第 7 章实现业务层，但我们可以使用查询参数来过滤我们的内存中的调度列表。
- en: '![](../Images/06-09.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06-09.png)'
- en: Figure 6.9 The Swagger UI shows the URL query parameters of the GET `/kitchen/schedules`
    endpoint, and it offers form fields that we can fill in to experiment with different
    values.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 Swagger UI 显示了 GET `/kitchen/schedules` 端点的 URL 查询参数，并提供表单字段，我们可以填写以尝试不同的值。
- en: Listing 6.16 Use filters in GET `/kitchen/schedules`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 在 GET `/kitchen/schedules` 中使用过滤器
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① If no parameter is set, we return the full list of schedules.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果没有设置任何参数，我们返回完整的调度列表。
- en: ② If the user set any URL query parameters, we use them to filter the list of
    schedules.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果用户设置了任何 URL 查询参数，我们使用它们来过滤调度列表。
- en: ③ We check for the presence of each URL query parameter by using the dictionary’s
    get() method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们通过使用字典的 get() 方法检查每个 URL 查询参数的存在。
- en: ④ If limit is set and its value is lower than the length of query_set, we return
    a subset of query_set.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果设置了 limit 并且其值小于 query_set 的长度，我们返回 query_set 的子集。
- en: ⑤ We return the filtered list of schedules.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们返回过滤后的调度列表。
- en: Now that we know how to handle URL query parameters with flask-smorest, there’s
    one more topic we need to cover, and that is data validation before serialization.
    Move on to the next section to learn more about this!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 flask-smorest 处理 URL 查询参数，还有一个主题需要讨论，那就是在序列化之前的数据验证。继续到下一节了解更多关于这个主题的信息！
- en: 6.11 Validating data before serializing the response
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.11 在序列化响应之前验证数据
- en: Now that we have schemas to validate our request payloads and we have hooked
    them up with our routes, we have to ensure that our response payloads are also
    validated. In this section, we learn how to use marshmallow models to validate
    data. We’ll use this functionality to validate our response payloads, but you
    could use the same approach to validate any kind of data, such as configuration
    objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于验证请求负载的模式，并且我们已经将它们与我们的路由连接起来，我们必须确保我们的响应负载也被验证。在本节中，我们将学习如何使用marshmallow模型来验证数据。我们将使用此功能来验证我们的响应负载，但你也可以使用相同的方法来验证任何类型的数据，例如配置对象。
- en: '![](../Images/06-10.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06-10.png)'
- en: Figure 6.10 Workflow of a data payload with the flask-smorest framework. Response
    payloads are supposed to come from a “trusted zone,” and therefore are not validated
    before marshalling.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10展示了使用flask-smorest框架的数据负载的工作流程。响应负载应该来自“可信区域”，因此在序列化之前不进行验证。
- en: When we send a payload in a response, flask-smorest serializes the payload using
    marshmallow. However, as shown in figure 6.10, it doesn’t validate if it’s correctly
    formed.[³](#pgfId-1081568) As you can see in figure 6.11, in contrast to marshmallow,
    FastAPI does validate our data before it’s serialized for a response.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在响应中发送负载时，flask-smorest使用marshmallow序列化负载。然而，如图6.10所示，它不会验证其是否正确形成。[³](#pgfId-1081568)正如你在图6.11中看到的，与marshmallow不同，FastAPI在序列化响应之前会验证我们的数据。
- en: '![](../Images/06-11.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06-11.png)'
- en: Figure 6.11 Workflow of a data payload with the FastAPI framework. Before marshalling
    a response, FastAPI validates that the payload conforms to the specified schema.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11展示了使用FastAPI框架的数据负载的工作流程。在序列化响应之前，FastAPI会验证负载是否符合指定的模式。
- en: 'The fact that marshmallow doesn’t perform validation before serialization is
    not necessarily undesirable. In fact, it can be argued that it’s a desirable behavior,
    as it decouples the task of serializing from the task of validating the payload.
    There are two rationales to justify why marshmallow doesn’t perform validation
    before serialization ([http://mng.bz/9Vwx](http://mng.bz/9Vwx)):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: marshmallow在序列化之前不执行验证的事实并不一定是不受欢迎的。事实上，可以认为这是一种期望的行为，因为它将序列化任务与验证负载的任务解耦。有两个理由可以证明为什么marshmallow在序列化之前不执行验证([http://mng.bz/9Vwx](http://mng.bz/9Vwx))：
- en: It improves performance, since validation is slow.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提高了性能，因为验证是缓慢的。
- en: Data coming from the server is supposed to be trusted and therefore shouldn’t
    require validation.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器来的数据应该被信任，因此不需要进行验证。
- en: The reasons the maintainers of marshmallow use to justify this design decision
    are fair. However, if you’ve worked with APIs, and websites in general, long enough,
    you know there’s generally very little to be trusted, even from within your own
    system.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: marshmallow维护者用来证明这一设计决策的理由是合理的。然而，如果你在API和网站方面工作的时间足够长，你就会知道，通常情况下，即使是来自你自己的系统，也很少有什么可以信任的。
- en: zero-trust approach for robust apis API integrations fail due to the server
    sending the wrong payload as much as they fail due to the client sending malformed
    payloads to the server. Whenever possible, it’s good practice to take a zero-trust
    approach to our systems design and validate all data, regardless of its origin.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 零信任方法对于健壮的API集成至关重要，API集成失败的原因既可能是服务器发送了错误的负载，也可能是客户端向服务器发送了格式不正确的负载。在可能的情况下，采取零信任方法来设计我们的系统，并验证所有数据，无论其来源如何。
- en: The data that we send from the kitchen API comes from a database. In chapter
    7, we’ll learn patterns and techniques to ensure that our database contains the
    right data in the right format. However, and even under the strictest access security
    measures, there’s always a chance that malformed data ends up in the database.
    As unlikely as this is, we don’t want to ruin the user experience if that happens,
    and validating our data before serializing helps us with that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从厨房API发送的数据来自数据库。在第7章中，我们将学习模式和技巧来确保我们的数据库包含正确格式的数据。然而，即使在最严格的安全措施下，总有可能出现格式不正确的数据进入数据库。尽管这种情况不太可能发生，但我们不希望在这种情况下破坏用户体验，在序列化之前验证我们的数据可以帮助我们做到这一点。
- en: 'Thankfully, it’s easy to validate data using marshmallow. We simply need to
    get an instance of the schema we want to validate against and use its `validate()`
    method to pass in the data we need to validate. `validate()` doesn’t raise an
    exception if it finds errors. Instead, it returns a dictionary with the errors,
    or an empty dictionary if no errors are found. To get a feeling for how this works,
    open a Python shell by typing `python` in the terminal, and run the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用 marshmallow 验证数据非常简单。我们只需获取我们想要验证的模式的实例，并使用其 `validate()` 方法传递我们需要验证的数据。如果
    `validate()` 函数发现错误，它不会抛出异常。相反，它返回一个包含错误的字典，如果没有错误则返回一个空字典。为了了解这是如何工作的，请在终端中输入
    `python` 打开 Python 壳，并运行以下代码：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After importing the schema on line 1, in line 2 we pass a malformed representation
    of a schedule containing only the `id` field, and in line 3 marshmallow helpfully
    reports that the `order`, `scheduled`, and `status` fields are missing, and that
    the `id` field is not a valid UUID. We can use this information to raise a helpful
    error message in the server, as shown in listing 6.17\. We validate schedules
    in the GET `/kitchen/schedules` method view before building and returning the
    query set, and we iterate the list of schedules to validate one at a time. Before
    validation, we make a deep copy of the schedule so that we can transform its `datetime`
    object into an ISO date string, since that’s the format expected by the validation
    method. If we get a validation error, we raise marshmallow’s `ValidationError`
    exception, which automatically formats the error message into an appropriate HTTP
    response.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 行导入模式后，在第 2 行我们传递一个包含仅 `id` 字段的无效日程表示，在第 3 行 marshmallow 有助于报告 `order`、`scheduled`
    和 `status` 字段缺失，以及 `id` 字段不是一个有效的 UUID。我们可以使用这些信息在服务器上抛出一个有用的错误消息，如列表 6.17 所示。我们在构建和返回查询集之前在
    GET `/kitchen/schedules` 方法视图中验证日程，并逐个迭代日程列表进行验证。在验证之前，我们创建日程的深拷贝，这样我们就可以将其 `datetime`
    对象转换为 ISO 日期字符串，因为这是验证方法期望的格式。如果我们得到验证错误，我们将抛出 marshmallow 的 `ValidationError`
    异常，该异常会自动将错误消息格式化为适当的 HTTP 响应。
- en: Listing 6.17 Validating data before serialization
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 在序列化前验证数据
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① We import the ValidationError class from marshmallow.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们从 marshmallow 导入 ValidationError 类。
- en: ② We capture validation errors in the errors variable.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将验证错误捕获在 errors 变量中。
- en: ③ If validate() finds errors, we raise a ValidationError exception.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果 validate() 函数发现错误，我们将抛出 ValidationError 异常。
- en: Please be aware that there are known issues with validation in marshmallow,
    especially when your models contain complex configurations for determining which
    fields should be serialized and which fields shouldn’t (see [https://github.com/marshmallow-code/marshmallow/issues/682](https://github.com/marshmallow-code/marshmallow/issues/682)
    for additional information). Also, take into account that validation is known
    to be a slow process, so if you are handling large payloads, you may want to use
    a different tool to validate your data, validate only a subset of your data, or
    skip validation altogether. However, whenever possible, you’re better off performing
    validation on your data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，marshmallow 中存在已知的验证问题，尤其是在你的模型包含用于确定哪些字段应该序列化以及哪些字段不应该序列化的复杂配置时（有关更多信息，请参阅
    [https://github.com/marshmallow-code/marshmallow/issues/682](https://github.com/marshmallow-code/marshmallow/issues/682)）。此外，请注意，验证是一个已知的过程，速度较慢，因此如果你正在处理大量有效负载，你可能想使用不同的工具来验证你的数据，只验证数据的一部分，或者完全跳过验证。然而，只要可能，你最好对你的数据进行验证。
- en: This concludes the implementation of the functionality of the kitchen API. However,
    the API is still returning the same mock schedule across all endpoints. Before
    concluding this chapter, let’s add a minimal implementation of an in-memory list
    of schedules so that we can make our API dynamic. This will allow us to verify
    that all endpoints are functioning as intended.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着厨房 API 功能实现的完成。然而，API 仍然在所有端点返回相同的模拟日程安排。在结束这一章之前，让我们添加一个内存中的日程列表的最小实现，这样我们就可以使我们的
    API 动态化。这将允许我们验证所有端点是否按预期工作。
- en: 6.12 Implementing an in-memory list of schedules
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.12 实现内存中的日程列表
- en: In this section, we implement a simple in-memory representation of schedules
    so that we can obtain dynamic results from the API. By the end of this section,
    we’ll be able to schedule orders, update them, and cancel them through the API.
    Because the schedules are managed as an in-memory list, any time the server is
    restarted, we’ll lose information from our previous session. In the next chapter,
    we’ll address this problem by adding a persistence layer to our service.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了一个简单的日程表内存表示，以便我们可以从API中获得动态结果。在本节结束时，我们将能够通过API安排订单、更新它们以及取消它们。因为日程表被管理为一个内存列表，所以每次服务器重启时，我们都会丢失之前会话的信息。在下一章中，我们将通过向我们的服务添加持久化层来解决这个问题。
- en: Our in-memory collection of schedules will be represented by a Python list,
    and we’ll simply add and remove elements from it in the API layer. Listing 6.18
    shows the changes that we need to make to kitchen/api/api.py to make this possible.
    We initialize an empty list and assign it to a variable named `schedules`. We
    also refactor our data validation code into an independent function named `validate_schedule()`
    so that we can reuse it in other view methods or functions. When a schedule payload
    arrives in the `KitchenSchedules`’ `post()` method, we set the server-side attributes,
    such as the ID, the scheduled time, and the status. In the singleton endpoints,
    we look for the requested schedule by iterating the list of schedules and checking
    their IDs. If the requested schedule isn’t found, we return a 404 response.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内存中的日程表集合将由一个Python列表表示，我们将在API层中简单地添加和删除元素。列表6.18显示了我们需要对`kitchen/api/api.py`进行的更改，以实现这一点。我们初始化一个空列表并将其分配给名为`schedules`的变量。我们还重构了我们的数据验证代码到一个名为`validate_schedule()`的独立函数中，这样我们就可以在其他视图方法或函数中重用它。当`KitchenSchedules`的`post()`方法接收到日程表有效载荷时，我们设置服务器端属性，如ID、预定时间和状态。在单例端点中，我们通过遍历日程表列表并检查它们的ID来查找请求的日程表。如果找不到请求的日程表，我们返回一个404响应。
- en: Listing 6.18 In-memory implementation of schedules
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.18：日程表的内存实现
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① We initialize schedules as an empty list.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们将日程表初始化为一个空列表。
- en: ② We refactor our data validation code into a function.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们将数据验证代码重构为一个函数。
- en: ③ We set the server-side attributes of a schedule, such as the ID.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们设置日程表的服务器端属性，如ID。
- en: ④ If a schedule isn’t found, we return a 404 response.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果找不到日程表，我们返回一个404响应。
- en: ⑤ When a user updates a schedule, we update the schedule’s properties with the
    contents of the payload.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 当用户更新日程表时，我们使用有效载荷的内容更新日程表属性。
- en: ⑥ We remove the schedule from the list and return an empty response.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们从列表中删除日程表并返回一个空响应。
- en: ⑦ We set the status of the schedule to cancelled.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们将日程表的状态设置为已取消。
- en: If you reload the Swagger UI and test the endpoints, you’ll see you’re now able
    to add schedules, update them, cancel them, list and filter them, get their details,
    and delete them. In the next section, you’ll learn to override flask-smorest’s
    dynamically generated API specification to make sure we serve our API design instead
    of our implementation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新加载Swagger UI并测试端点，你会看到你现在能够添加日程表、更新它们、取消它们、列出和过滤它们、获取它们的详细信息以及删除它们。在下一节中，你将学习如何覆盖flask-smorest动态生成的API规范，以确保我们提供我们的API设计而不是实现。
- en: 6.13 Overriding flask-smorest’s dynamically generated API specification
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.13 覆盖flask-smorest动态生成的API规范
- en: 'As we learned in section 6.4, API specifications dynamically generated from
    code are good for testing and visualizing our implementation, but to publish our
    API, we want to make sure we serve our API design document. To do that, we’ll
    override flask-smorest’s dynamically generated API documentation. First, we need
    to install PyYAML, which we’ll use to load the API design document:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在6.4节中学到的，从代码动态生成的API规范对于测试和可视化我们的实现是有好处的，但为了发布我们的API，我们想确保我们提供的是我们的API设计文档。为此，我们将覆盖flask-smorest动态生成的API文档。首先，我们需要安装PyYAML，我们将使用它来加载API设计文档：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We override the API object’s `spec` property with a custom `APISpec` object.
    We also override `APISpec`’s `to_dict()` method so that it returns our API design
    document.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义的`APISpec`对象覆盖API对象的`spec`属性。我们还覆盖了`APISpec`的`to_dict()`方法，以便它返回我们的API设计文档。
- en: Listing 6.19 Overriding flask-smorest’s dynamically generated API specification
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.19：覆盖flask-smorest动态生成的API规范
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This concludes our journey through implementing REST APIs using Python. In the
    next chapter, we’ll learn patterns to implement the rest of the service following
    best practices and useful design patterns. Things are spicing up!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们使用 Python 实现 REST API 的旅程的结束。在下一章中，我们将学习如何遵循最佳实践和有用的设计模式来实施服务的其余部分。事情变得越来越有趣了！
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can build REST APIs in Python using frameworks like FastAPI and flask-smorest,
    which have great ecosystems of tools and libraries that make it easier to build
    APIs.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 FastAPI 和 flask-smorest 等框架在 Python 中构建 REST API，这些框架拥有强大的工具和库生态系统，使构建
    API 更加容易。
- en: FastAPI is a modern API framework that makes it easier to build highly performant
    and robust REST APIs. FastAPI is built on top of Starlette and pydantic. Starlette
    is a highly performant asynchronous server framework, and pydantic is a data validation
    library that uses type hints to create validation rules.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 是一个现代 API 框架，它使构建高性能和健壮的 REST API 更加容易。FastAPI 是建立在 Starlette 和 pydantic
    之上的。Starlette 是一个高性能的异步服务器框架，而 pydantic 是一个使用类型提示来创建验证规则的数据验证库。
- en: Flask-smorest is built on top of Flask and works as a Flask blueprint. Flask
    is one of Python’s most popular frameworks, and by using flask-smorest you can
    leverage its rich ecosystem of libraries to make it easier to build APIs.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-smorest 是建立在 Flask 之上的，并作为一个 Flask 蓝图工作。Flask 是 Python 最受欢迎的框架之一，通过使用
    flask-smorest，你可以利用其丰富的库生态系统，使构建 API 更加容易。
- en: FastAPI uses pydantic for data validation. Pydantic is a modern framework that
    uses type hints to define validation rules, which results in cleaner and easy-to-read
    code. By default, FastAPI validates both request and response payloads.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI 使用 pydantic 进行数据验证。Pydantic 是一个现代框架，它使用类型提示来定义验证规则，这导致代码更加清晰和易于阅读。默认情况下，FastAPI
    验证请求和响应负载。
- en: Flask-smorest uses marshmallow for data validation. Marshmallow is a battle-tested
    framework that uses class fields to define validation rules. By default, flask-smorest
    doesn’t validate response payloads, but you can validate responses by using marshmallow
    models’ `validate()` method.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask-smorest 使用 marshmallow 进行数据验证。Marshmallow 是一个经过实战考验的框架，它使用类字段来定义验证规则。默认情况下，flask-smorest
    不验证响应负载，但你可以通过使用 marshmallow 模型的 `validate()` 方法来验证响应。
- en: With flask-smorest, you can use Flask’s `MethodView` to create class-based views
    that represent URL paths. In a class-based view, you implement HTTP methods as
    methods of the class, such as `get()` and `post()`.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 flask-smorest，你可以使用 Flask 的 `MethodView` 来创建表示 URL 路径的基于类的视图。在基于类的视图中，你将
    HTTP 方法实现为类的成员方法，例如 `get()` 和 `post()`。
- en: The tolerant reader pattern follows Postel’s law, which recommends being tolerant
    with errors in HTTP requests and validating response payloads. When designing
    your APIs, you must balance the benefits of the tolerant reader pattern with risk
    of integration failure due to bugs like typos.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容忍的读取模式遵循波斯尔的法则，该法则建议对 HTTP 请求中的错误保持容忍，并验证响应负载。在设计你的 API 时，你必须平衡容忍的读取模式的好处与由于错误（如拼写错误）导致的集成失败的风险。
- en: '* * *'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ Jon Postel, Ed., “Transmission Control Protocol,” RFC 761, p. 13, [https://tools.ietf.org/html/rfc761](https://tools.ietf.org/html/rfc761).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 约翰·波斯尔，编辑，“传输控制协议”，RFC 761，第 13 页，[https://tools.ietf.org/html/rfc761](https://tools.ietf.org/html/rfc761)。
- en: '² To understand why `additionalProperties` doesn’t work when using model composition,
    see the excellent discussion about this topic in JSON Schema’s GitHub repository:
    [https://github.com/json-schema-org/json-schema-spec/issues/556](https://github.com/json-schema-org/json-schema-spec/issues/556).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ² 要了解为什么在使用模型组合时 `additionalProperties` 不起作用，请参阅 JSON Schema 的 GitHub 存储库中关于此主题的优秀讨论：[https://github.com/json-schema-org/json-schema-spec/issues/556](https://github.com/json-schema-org/json-schema-spec/issues/556)。
- en: '³ Before version 3.0.0, marshmallow used to perform validation before serialization
    (see the change log: [https://github.com/marshmallow-code/marshmallow/blob/dev/CHANGELOG.rst#300-2019-08-18](https://github.com/marshmallow-code/marshmallow/blob/dev/CHANGELOG.rst#300-2019-08-18)).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 在 3.0.0 版本之前，marshmallow 会在序列化之前执行验证（参见变更日志：[https://github.com/marshmallow-code/marshmallow/blob/dev/CHANGELOG.rst#300-2019-08-18](https://github.com/marshmallow-code/marshmallow/blob/dev/CHANGELOG.rst#300-2019-08-18)）。
