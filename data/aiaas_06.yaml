- en: 4 Building and securing a web application the serverless way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 以无服务器方式构建和保障Web应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating a serverless to-do list
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建无服务器待办事项列表
- en: Using DynamoDB, a serverless database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DynamoDB，一个无服务器数据库
- en: Implementing login the serverless way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以无服务器方式实现登录
- en: 'In this chapter we will build upon the lessons of chapters 2 and 3 to build
    our second, more capable serverless AI system. Most programming texts use the
    canonical to-do list application as a teaching example. This book is no different
    in that regard. However, this is certainly not your grandparents'' to-do list:
    this is the to-do list on steroids! The to-do list application that we will build
    in this chapter will start out simple enough as a familiar CRUD (Create, Read,
    Update, Delete ) type application utilizing a cloud native database. After securing
    the application with a login and logout screen, we will add natural language speech
    interfaces to record and transcribe text, and to have the system tell us our daily
    schedule from our to-do list. Finally, we will add a conversational interface
    to the system, allowing us to interact entirely through natural speech and not
    the keyboard.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将基于第2章和第3章的教训，构建我们的第二个、更强大的无服务器AI系统。大多数编程教材都使用标准的待办事项列表应用作为教学示例。在这方面，本书也不例外。然而，这绝对不是你祖父母的待办事项列表：这是强化版的待办事项列表！在本章中，我们将构建的待办事项列表应用将从一个足够简单的CRUD（创建、读取、更新、删除）类型的应用程序开始，利用云原生数据库。在通过登录和注销屏幕保护应用程序后，我们将添加自然语言语音接口来记录和转录文本，并让系统从我们的待办事项列表中告诉我们日常日程。最后，我们将向系统中添加对话接口，使我们能够完全通过自然语音而不是键盘进行交互。
- en: In this chapter we will build the serverless to-do list. We will add the AI
    features in chapter 5, and as we will see, these can be built very rapidly by
    harnessing cloud AI services to do the heavy lifting.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建无服务器待办事项列表。我们将在第5章中添加AI功能，正如我们将看到的，这些功能可以通过利用云AI服务来完成快速构建。
- en: 4.1 The to-do list
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 待办事项列表
- en: Our next-generation to-do list will consume a number of AI services. As before,
    this will follow our canonical architectural pattern for serverless AI systems
    that we developed in chapter 1 and used in chapters 2 and 3\. The finished product
    is shown in figure 4.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一代待办事项列表将消耗多个AI服务。与之前一样，这将遵循我们在第1章中开发的、在第2章和第3章中使用的标准无服务器AI系统架构模式。最终产品如图4.1所示。
- en: '![](../Images/CH04_F01_Elger.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F01_Elger.png)'
- en: Figure 4.1 The end goal
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 最终目标
- en: In this image, the user is midway through creating a new to-do item through
    a conversation with our to-do chatbot.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中，用户正在通过与我们待办事项聊天机器人的对话创建一个新的待办事项，正处于中途。
- en: 4.2 Architecture
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 架构
- en: Before we get into assembling the system, let’s look at the architecture and
    take a moment to understand how it maps back to our canonical serverless AI architecture
    that we developed in chapter 1\. Figure 4.2 depicts the overall structure of the
    system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始组装系统之前，让我们看看架构，并花点时间理解它如何映射回我们在第1章中开发的标准无服务器AI架构。图4.2描述了系统的整体结构。
- en: 'The system architecture shows a clear separation between services. Every service
    has a single responsibility with a well-defined interface:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构显示了服务之间的清晰分离。每个服务都有一个单一的责任和定义良好的接口：
- en: '*Web application* --Static content for the client application is served from
    an S3 bucket. An API Gateway provides an API that triggers event handlers in our
    synchronous and asynchronous services. Our web application client uses the AWS
    Amplify client SDK to handle the complexity of authentication.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Web应用程序* --客户端应用程序的静态内容从S3存储桶中提供。API网关提供了一个API，该API触发我们的同步和异步服务中的事件处理器。我们的Web应用程序客户端使用AWS
    Amplify客户端SDK来处理认证的复杂性。'
- en: '*Synchronous and asynchronous services* --These custom services are AWS Lambda
    functions that handle our API requests and perform the main business logic of
    our application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步和异步服务* --这些自定义服务是AWS Lambda函数，它们处理我们的API请求并执行应用程序的主要业务逻辑。'
- en: '![](../Images/CH04_F02_Elger.png)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](../Images/CH04_F02_Elger.png)'
- en: Figure 4.2 System architecture. The system is composed of custom services and
    managed services. Using many managed services provided by AWS allows us to quickly
    build and deploy scalable, production-grade applications.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.2 系统架构。系统由自定义服务和托管服务组成。使用AWS提供的许多托管服务，我们可以快速构建和部署可扩展的生产级应用程序。
- en: '*Communication fabric* --AWS Route53 is used for DNS configuration so our services
    can be accessed using a custom domain name.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信架构* --AWS Route53用于DNS配置，因此我们的服务可以通过自定义域名访问。'
- en: '*Utility services* --AWS Cognito is used for authentication and authorization.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用服务* --AWS Cognito用于身份验证和授权。'
- en: '*AI services* --We use three managed AWS AI services: Transcribe, Polly, and
    Lex.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AI服务* --我们使用三个托管的AWS AI服务：Transcribe、Polly和Lex。'
- en: '*Data services* --DynamoDB is used as a powerful and scalable database. S3
    is used for file storage.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据服务* --使用DynamoDB作为强大且可扩展的数据库。S3用于文件存储。'
- en: As we work through the system, we will describe each section in more detail
    and explain how it is built and deployed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理系统时，我们将更详细地描述每个部分，并解释它是如何构建和部署的。
- en: 4.2.1 Web application
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 网络应用
- en: The structure of the application is shown in figure 4.3 with the *web application*
    section highlighted.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的结构如图4.3所示，其中突出显示了*网络应用*部分。
- en: '![](../Images/CH04_F03_Elger.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F03_Elger.png)'
- en: Figure 4.3 Web application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 网络应用
- en: The structure shown will be familiar from our system in chapters 2 and 3\. The
    front end of the system is a single-page application comprising HTML, CSS, and
    JavaScript to render the UI, deployed into an S3 bucket. We will repeat this image
    throughout the chapter, highlighting the relevant section as we build the complete
    application. As before, we are using API Gateway to provide a route into the services.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的结构与我们第2章和第3章中的系统相似。系统的前端是一个单页应用程序，由HTML、CSS和JavaScript组成，用于渲染UI，部署到S3存储桶中。我们将在本章中重复使用此图像，在构建完整应用程序时突出相关部分。与之前一样，我们使用API
    Gateway提供对服务的路由。
- en: For our to-do application, we are using an additional library on the front end;
    AWS Amplify. Amplify is a JavaScript client library that provides secure access
    to nominated AWS services. In our case we are using it to provide a client interface
    to Cognito for login and logout, and also to access speech-to-text data stored
    in S3\.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的待办事项应用程序，我们在前端使用了一个额外的库；AWS Amplify。Amplify是一个JavaScript客户端库，它提供了对指定AWS服务的安全访问。在我们的案例中，我们使用它来提供Cognito的客户端接口以进行登录和注销，并且还可以访问存储在S3中的语音转文本数据。
- en: 4.2.2 Synchronous services
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 同步服务
- en: Figure 4.4 shows our application architecture again, this time with the *synchronous
    services* section highlighted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4再次显示了我们的应用程序架构，这次突出显示了*同步服务*部分。
- en: '![](../Images/CH04_F04_Elger.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F04_Elger.png)'
- en: Figure 4.4 Synchronous services
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 同步服务
- en: 'There is one main synchronous service shown. This is the `to-do` service, which
    exposes routes for a simple CRUD interface as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了一个主要同步服务。这是`to-do`服务，它提供了以下简单的CRUD接口：
- en: '`POST /todo/`-- Create a new item.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /todo/`--创建一个新的项目。'
- en: '`GET /todo/{id}`--Read a specific item.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /todo/{id}`--读取一个特定的项目。'
- en: '`PUT /todo/{id}`--Update item.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /todo/{id}`--更新项目。'
- en: '`DELETE /todo/{id}`--Delete an item.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /todo/{id}`--删除一个项目。'
- en: '`GET /todo`--List all items.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /todo`--列出所有项目。'
- en: 4.2.3 Asynchronous services
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 异步服务
- en: The asynchronous services section of our application architecture is highlighted
    in figure 4.5.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序架构的异步服务部分在图4.5中突出显示。
- en: '![](../Images/CH04_F05_Elger.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F05_Elger.png)'
- en: Figure 4.5 Asynchronous services
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 异步服务
- en: There are two asynchronous services which are concerned with speech-to-text
    and text-to-speech translation. These services are as follows.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种异步服务，分别涉及语音转文本和文本转语音翻译。这些服务如下。
- en: Note service
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意服务
- en: 'Provides an interface to convert a voice recorded note into text:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个将录音笔记转换为文本的接口：
- en: '`POST /note`--Kick off a new asynchronous note transcription job.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /note`--启动一个新的异步笔记转录作业。'
- en: '`GET /note/{id}`--Poll for information on the asynchronous transcription.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /note/{id}`--轮询获取有关异步转录的信息。'
- en: Schedule service
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调度服务
- en: 'Provides an interface to create a schedule and then convert it into a voice
    recording:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个创建计划并将其转换为语音录音的接口：
- en: '`POST /schedule`--Start a new asynchronous schedule job.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /schedule`--启动一个新的异步调度作业。'
- en: '`GET /schedule/{id}`--Poll for information on the schedule.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /schedule/{id}`--轮询获取有关计划的信息。'
- en: 4.2.4 Communication fabric
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 通信架构
- en: We have chosen to build our to-do list using a poll-based mechanism for simplicity,
    and have opted not to use any queue. We are primarily using HTTP and DNS as our
    communication fabric technologies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用基于轮询的机制来构建待办事项列表以保持简单，并且选择不使用任何队列。我们主要使用HTTP和DNS作为我们的通信架构技术。
- en: 4.2.5 Utility services
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 实用服务
- en: We are using Amazon Cognito as a mechanism for user login and authentication.
    User management is a “solved problem” and one that we don’t want to build ourselves
    for each platform that we develop. For this system we use Cognito to do the heavy
    lifting for us.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Amazon Cognito 作为用户登录和身份验证的机制。用户管理是一个“已解决的问题”，我们不想为每个我们开发的平台都自己构建。对于这个系统，我们使用
    Cognito 来为我们做繁重的工作。
- en: 4.2.6 AI services
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 AI 服务
- en: The next highlighted sections of our architecture, shown in figure 4.6, cover
    the AI and data storage services we use in this system
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构中下一个突出的部分，如图 4.6 所示，涵盖了我们在本系统中使用的 AI 和数据存储服务。
- en: '![](../Images/CH04_F06_Elger.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F06_Elger.png)'
- en: Figure 4.6 AI and data services
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 AI 和数据服务
- en: 'This image shows that we are using several AI services:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示我们正在使用几个 AI 服务：
- en: '*Transcribe* is used to provide speech-to-text conversion and reads its input
    from S3.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Transcribe* 用于提供语音到文本转换，并从 S3 读取其输入。'
- en: '*Polly* converts text into speech and writes its output audio files to S3.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Polly* 将文本转换为语音，并将其输出音频文件写入 S3。'
- en: '*Lex* is used to create interactive chatbots. We will use the Lex Web UI system
    to plug directly into our front-end application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Lex* 用于创建交互式聊天机器人。我们将使用 Lex Web UI 系统直接集成到我们的前端应用中。'
- en: 4.2.7 Data services
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.7 数据服务
- en: In the data services tier, we are using the Simple Storage Service (S3) and
    DynamoDB. DynamoDB is a highly scalable cloud native NoSQL database, and we are
    using it to store our to-do items.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据服务层，我们使用简单存储服务（S3）和 DynamoDB。DynamoDB 是一个高度可扩展的云原生 NoSQL 数据库，我们使用它来存储我们的待办事项。
- en: 4.2.8 Development support and operational support
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.8 开发支持和运营支持
- en: As before, we are using the Serverless Framework as our main development support
    system. All logging data is collected using CloudWatch.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们使用 Serverless Framework 作为我们的主要开发支持系统。所有日志数据都使用 CloudWatch 收集。
- en: 4.3 Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 准备工作
- en: 'Now that we have seen the end goal, let’s dive in and put the system together.
    As a prerequisite for this chapter, you will need to have the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了最终目标，让我们深入其中，将系统组合起来。作为本章的先决条件，您需要具备以下条件：
- en: AWS account
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 账户
- en: AWS command line installed and configured
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 命令行已安装并配置
- en: Node.js installed
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 已安装
- en: Serverless Framework installed
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serverless Framework 已安装
- en: Instructions on how to set up Node.js and the Serverless Framework are provided
    in chapters 2 and 3\. Setup instructions for AWS are provided in appendix A. If
    you haven’t done so already, you will need to follow these instructions before
    proceeding with the code in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置 Node.js 和 Serverless Framework 的说明在第 2 和第 3 章中提供。AWS 的设置说明在附录 A 中提供。如果您尚未这样做，您需要在继续本章的代码之前遵循这些说明。
- en: Warning Using AWS costs money! Please ensure that any cloud infrastructure is
    destroyed once you are finished with it. We will provide tear down instructions
    at the end of each chapter to help with this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：使用 AWS 需要付费！请确保您完成使用后，任何云基础设施都被销毁。我们将在每个章节的末尾提供拆解说明，以帮助您完成这项工作。
- en: 4.3.1 Getting the code
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 获取代码
- en: 'The source code for this chapter is available in the repository [https://github.com/fourTheorem/ai-as-a-service](https://github.com/fourTheorem/ai-as-a-service)
    in the `code/chapter4` directory. If you haven’t done so already, you can go ahead
    and clone the repository:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/fourTheorem/ai-as-a-service](https://github.com/fourTheorem/ai-as-a-service)仓库的`code/chapter4`目录中找到。如果您尚未这样做，您可以继续克隆该仓库：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for this system is broken down into a number of simple steps, as we
    will be building the system up piece by piece. In this chapter we build the basic
    application and then add the AI features in chapter 5\. If you look in the `chapter4`
    and `chapter5` directories, you will find the following breakdown:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的代码被分解为多个简单步骤，因为我们将会逐步构建系统。在本章中，我们构建基本应用，然后在第 5 章中添加 AI 功能。如果您查看`chapter4`和`chapter5`目录，您将找到以下分解：
- en: '`chapter4/step-1-basic-todo`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter4/step-1-basic-todo`'
- en: '`chapter4/step-2-cognito-login`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter4/step-2-cognito-login`'
- en: '`chapter5/step-3-note-service`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter5/step-3-note-service`'
- en: '`chapter5/step-4-schedule-service`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter5/step-4-schedule-service`'
- en: '`chapter5/step-5-chat-interface`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter5/step-5-chat-interface`'
- en: We will be working through these directories in order. Each logical step will
    add additional functionality to our to-do list application. Let’s get going with
    the first step, our basic to-do application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按顺序处理这些目录。每个逻辑步骤都将为我们的待办事项应用添加额外的功能。让我们从第一步开始，我们的基本待办事项应用。
- en: '4.4 Step 1: The basic application'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 步骤 1：基本应用
- en: Our basic to-do application should feel fairly familiar to most programmers,
    who will at some time or another have encountered the canonical to-do application.
    Figure 4.7 depicts the application running after deployment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本待办事项应用程序对大多数程序员来说应该相当熟悉，他们可能在某个时候遇到过标准的待办事项应用程序。图 4.7 展示了部署后的应用程序运行情况。
- en: '![](../Images/CH04_F07_Elger.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F07_Elger.png)'
- en: Figure 4.7 Basic to-do list
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 基本待办事项列表
- en: The complete application shows a list of to-dos, along with a form for adding
    a new to-do.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序显示了一个待办事项列表，以及一个用于添加新待办事项的表单。
- en: Why another to-do application?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么还需要另一个待办事项应用程序？
- en: 'In putting the content for this book together, we did indeed question if the
    world needed yet another to-do application. However on reflection we decided that
    it would be valuable for the following reasons:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在整理本书的内容时，我们确实质疑过世界是否还需要另一个待办事项应用程序。然而，经过反思，我们决定以下原因将是有价值的：
- en: A to-do application needs to cover all of the basic CRUD operations.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项应用程序需要涵盖所有基本的 CRUD 操作。
- en: It is a familiar starting point for most programmers.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这对大多数程序员来说是一个熟悉的起点。
- en: Most to-do applications stop at the CRUD part; our aim is to explore how to
    secure and then expand the application with AI services.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数待办事项应用程序都停留在 CRUD 部分；我们的目标是探索如何通过 AI 服务来保护和扩展应用程序。
- en: At this starting point, the system is composed of a small set of components,
    as illustrated in figure 4.8.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个起点，系统由一组小的组件组成，如图 4.8 所示。
- en: '![](../Images/CH04_F08_Elger.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F08_Elger.png)'
- en: Figure 4.8 Step 1 architecture
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 步骤 1 架构
- en: As you can see, our system is fairly simple at this point. It uses a single
    API Gateway deployment, some simple Lambda functions, a DynamoDB table, and some
    front end code served out of S3\. The source code for this first step is in the
    directory `chapter4/step-1-basic-todo` and has the structure shown in the next
    listing, which lists only the key files for the sake of clarity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的系统目前相当简单。它使用单个 API Gateway 部署、一些简单的 Lambda 函数、一个 DynamoDB 表，以及从 S3 提供的前端代码。这个第一步的源代码在
    `chapter4/step-1-basic-todo` 目录中，下一列表中只列出了关键文件，以保持清晰。
- en: Listing 4.1 Code structure
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 代码结构
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s look at each of these components in turn.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些组件。
- en: 4.4.1 Resources
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 资源
- en: As with our previous application, we define a set of global cloud resources
    in our `resources` directory. It is important to note that we only configure global
    resources here. Configuration for cloud resources that are specific to an individual
    service should be kept with that service. For example, the to-do service “owns”
    the to-do DynamoDB table; therefore this resource is configured as part of the
    `to-do` service definition.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的应用程序一样，我们在 `resources` 目录中定义了一组全局云资源。需要注意的是，我们在这里只配置全局资源。针对特定服务的云资源配置应与该服务一起保留。例如，待办事项服务“拥有”待办事项
    DynamoDB 表；因此，此资源被配置为 `to-do` 服务定义的一部分。
- en: Tip As a rule of thumb, keep service-specific resource definitions with the
    service code. Only globally accessed resources should be configured outside of
    a service directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：作为一般规则，将特定服务的资源定义与服务代码一起保留。只有全局访问的资源才应在服务目录之外进行配置。
- en: 'Our `serverless.yml` file for resources defines an S3 bucket for the front
    end, sets permissions, and enables CORS. After working through chapters 2 and
    3, the format and structure of this `serverless.yml` should be very familiar,
    so we won’t cover it here, except to note that we are using a new plugin in this
    configuration: `serverless-dotenv-plugin`. This reads in environment variables
    from a `.env` file, which contains system-specific variables such as our bucket
    name. We will edit this file later in this section when we deploy the system.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为资源定义的 `serverless.yml` 文件定义了一个用于前端的前端 S3 存储桶，设置了权限，并启用了 CORS。在完成第 2 章和第 3
    章的学习后，这个 `serverless.yml` 的格式和结构应该非常熟悉，所以我们在这里不会详细说明，只是指出，在这个配置中我们使用了一个新的插件：`serverless-dotenv-plugin`。这个插件从
    `.env` 文件中读取环境变量，该文件包含系统特定的变量，如我们的存储桶名称。我们将在本节稍后部署系统时编辑此文件。
- en: CORS
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CORS
- en: '*CORS* stands for *cross-origin resource sharing*. It is a security mechanism
    that allows a web page to request resources from a different domain than the one
    from which the original web page was loaded. Using CORS, a web server may selectively
    allow or deny requests from different originating domains. A full explanation
    of CORS can be found here: [https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*CORS*代表*跨源资源共享*。这是一种安全机制，允许网页从与原始网页加载的域不同的域请求资源。使用CORS，Web服务器可以选择性地允许或拒绝来自不同源域的请求。有关CORS的完整解释，请参阅此处：[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)。'
- en: In our system the only shared resource is the data bucket. This will be used
    by services in later sections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统中，唯一的共享资源是数据存储桶。这将在后续部分的服务中使用。
- en: 4.4.2 To-do service
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 待办服务
- en: For the first step, we have implemented only the basic to-do CRUD service and
    a minimal front end. The to-do service uses DynamoDB, Amazon’s cloud-native NoSQL
    database. Figure 4.9 illustrates the individual routes that make up the to-do
    service, each of which performs a corresponding read or write operation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一步，我们只实现了基本的待办CRUD服务和最小的前端。待办服务使用DynamoDB，亚马逊的云原生NoSQL数据库。图4.9说明了构成待办服务的各个路由，每个路由都执行相应的读取或写入操作。
- en: '![](../Images/CH04_F09_Elger.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F09_Elger.png)'
- en: Figure 4.9 To-do service
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9待办服务
- en: 'The expanded section of the image shows the POST, PUT, and DELETE routes for
    adding, updating, and deleting to-do records. There are two GET routes shown:
    one for retrieving all to-dos, and one for retrieving a single to-do using its
    ID.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的展开部分显示了添加、更新和删除待办记录的POST、PUT和DELETE路由。显示了两个GET路由：一个用于检索所有待办事项，另一个用于使用其ID检索单个待办事项。
- en: CRUD
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD
- en: 'If you’re not familiar with the term, *CRUD* stands for *Create, Read, Update,
    Delete*. Sometimes you will hear the term “CRUD-based application.” This term
    just means an application that performs these standard operations on some data
    store. Typically CRUD applications are implemented using a RESTful HTTP interface.
    This means that the following HTTP verb and routes are used:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个术语不熟悉，*CRUD*代表*创建、读取、更新、删除*。有时你会听到“基于CRUD的应用程序”这个术语。这个术语只是意味着一个在某个数据存储上执行这些标准操作的应用程序。通常，CRUD应用程序使用RESTful
    HTTP接口实现。这意味着以下HTTP动词和路由被使用：
- en: '`POST /widget`--Post data to create and store a new widget.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /widget`--发布数据以创建和存储新的小部件。'
- en: '`GET /widget/{id}`--Read back the data for widget with the supplied ID.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /widget/{id}`--读取具有提供ID的小部件的数据。'
- en: '`PUT /widget/{id}`--Update the widget with the supplied ID.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /widget/{id}`--更新具有提供ID的小部件。'
- en: '`DELETE /widget/{id}`--Delete the widget with the supplied ID.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /widget/{id}`--删除具有提供ID的小部件。'
- en: '`GET /widget`--Get a list of all widgets.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /widget`--获取所有小部件的列表。'
- en: The main section of the `serverless.yml` file, shown in the following listing,
    configures the AWS provider and defines the API Gateway routes and their associated
    Lambda function event handlers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`serverless.yml`文件的主要部分配置了AWS提供者并定义了API网关路由及其相关的Lambda函数事件处理程序。
- en: Listing 4.2 `serverless.yml` configuration for the to-do service
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2为待办服务配置的`serverless.yml`
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Define environment variable for DynamoDB
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为DynamoDB定义环境变量
- en: ❷ IAM access role for Lambda functions to access DynamoDB
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为Lambda函数访问DynamoDB的IAM访问角色
- en: ❸ CRUD routes and handlers
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ CRUD路由和处理程序
- en: ❹ Include resources
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含资源
- en: Though this configuration file is a little larger than our previous examples,
    the structure is very much the same as for the `ui-service` in chapters 2 and
    3, in that we
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个配置文件比我们之前的示例要大一些，但其结构与第2章和第3章中的`ui-service`非常相似，即我们
- en: Configure access to DynamoDB for our handler functions
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的处理程序函数配置对DynamoDB的访问
- en: Define routes and handler functions
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义路由和处理程序函数
- en: 'We use an environment definition in the provider section to supply our handler
    code with the DynamoDB table name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提供者部分使用环境定义来为我们的处理程序代码提供DynamoDB表名：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is important because we do not want to hard-code the table name into our
    handler functions, as this would be a violation of the DRY principle.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们不希望将表名硬编码到我们的处理程序函数中，因为这会违反DRY原则。
- en: Tip *DRY* stands for “don’t repeat yourself.” In the context of a software system,
    it means that we should strive to only have a single definition or source of truth
    for each piece of information in a system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 *DRY* 代表“不要重复自己”。在软件系统的上下文中，这意味着我们应该努力只为系统中的每条信息保留一个定义或真相来源。
- en: 'To make the serverless definition more manageable, we have chosen to place
    our DynamoDB table definition in a separate file and include it in our main `serverless.yml`
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使无服务器定义更易于管理，我们选择将我们的 DynamoDB 表定义放在单独的文件中，并将其包含在我们的主 `serverless.yml` 文件中：
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This can help to keep our configurations shorter and more readable. We will
    be using this pattern throughout the remaining chapters. Our included file, shown
    in the next listing, configures DynamoDB resources for the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以帮助我们使配置更短、更易读。我们将在剩余的章节中一直使用这种模式。我们包含的文件，如下一列表所示，为系统配置了 DynamoDB 资源。
- en: Listing 4.3 Serverless DynamoDB configuration
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 无服务器 DynamoDB 配置
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We specify that the table should not be deleted when the CloudFormation stack
    is removed. This can help to avoid accidental data loss. The CloudFormation stack
    is the set of resources created or updated when we run serverless deploy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们指定，当删除 CloudFormation 堆栈时，不应删除表格。这有助于避免意外数据丢失。CloudFormation 堆栈是我们运行无服务器部署时创建或更新的资源集。
- en: ❷ For this table, we specify one key attribute, an ID of type S (string). This
    attribute is a partition key, so values must be unique.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于这个表格，我们指定了一个键属性，一个类型为 S（字符串）的 ID。这个属性是一个分区键，因此值必须是唯一的。
- en: ❸ The capacity units for throughput are set to the lowest possible values. This
    will restrict the number of reads and writes that can occur but, for this application,
    will ensure costs are kept to a minimum.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置吞吐量的容量单位为最低可能值。这将限制可以发生的读取和写入次数，但对于这个应用程序，将确保成本保持在最低。
- en: This is a very simple configuration, defining a single `id` key on the DynamoDB
    table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的配置，在 DynamoDB 表上定义了一个单一的 `id` 键。
- en: If we now look at the handler code for the `to-do` service, it should become
    clear how the system uses DynamoDB to store data. The code is in the file `handler.js`,
    shown in the following listing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看 `to-do` 服务的处理程序代码，应该会清楚系统是如何使用 DynamoDB 存储数据的。代码在文件 `handler.js` 中，如下所示列表。
- en: Listing 4.4 Requires and creates handler for to-do service
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 需求和创建待办服务处理程序
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Require AWS SDK
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需求 AWS SDK
- en: ❷ Create DynamoDB client
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 DynamoDB 客户端
- en: ❸ Use table name environment variable
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用表名环境变量
- en: ❹ Respond boilerplate
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 响应样板
- en: ❺ Create handler
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建处理程序
- en: ❻ Create to-do in database
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在数据库中创建待办事项
- en: The handler implementation should also feel familiar if you worked through chapters
    2 and 3\. The pattern here is to include the AWS SDK and then create an interface
    into the specific service that we want to access, in this case DynamoDB. The rest
    of the code then uses this resource to perform operations against the service
    and returns a result to the caller of the service. In listing 4.4, we have shown
    the `create` endpoint. This maps to our `POST /to-do` route. Clients of this code
    will include to-do information in the `POST` request as JSON-formatted data. In
    this case, the JSON used is of the form shown in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第 2 章和第 3 章中工作过，处理程序的实现应该也很熟悉。这里的模式是包含 AWS SDK 并创建一个接口，以便访问我们想要访问的特定服务，在这种情况下是
    DynamoDB。其余的代码然后使用这个资源对服务执行操作，并将结果返回给服务的调用者。在列表 4.4 中，我们展示了 `create` 端点。这映射到我们的
    `POST /to-do` 路由。此代码的客户端将在 `POST` 请求中包含待办信息，格式为 JSON 数据。在这种情况下，使用的 JSON 格式如以下列表所示。
- en: Listing 4.5 Example JSON content for the to-do `POST`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 待办 `POST` 的示例 JSON 内容
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The create method adds in a `timestamp` and an `id` field before writing the
    to-do to the database. The rest of the methods in `handler.js` implement the other
    CRUD operations against the database.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法在将待办事项写入数据库之前添加了一个 `timestamp` 字段和一个 `id` 字段。`handler.js` 中的其他方法实现了对数据库的其他
    CRUD 操作。'
- en: 4.4.3 Front end
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 前端
- en: Our front-end application for this first step is also fairly straightforward,
    and is illustrated in figure 4.10.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个第一步的前端应用程序也很简单，如图 4.10 所示。
- en: The front-end application is built and stored in S3\. When a browser loads the
    `index.html` page, the code and other assets, such as stylesheets and images,
    are also loaded. Internally the front-end application is built using JQuery. As
    this application will do a little more than the example in chapters 2 and 3, we
    have introduced some structure into the code, which is illustrated in figure 4.10
    and will be described shortly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序在S3上构建和存储。当浏览器加载 `index.html` 页面时，代码和其他资源，如样式表和图像，也会被加载。内部前端应用程序使用JQuery构建。由于这个应用程序将比第2章和第3章中的示例做得更多，我们在代码中引入了一些结构，如图4.10所示，稍后将进行描述。
- en: The code is in the `frontend` directory and has the structure shown in the next
    listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于 `frontend` 目录中，结构如下所示列表。
- en: Listing 4.6 Front-end directory structure
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 前端目录结构
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The root page for the application is `src/index.html`, shown in the following
    listing. This provides some of the initial DOM (Document Object Model) structure
    and loads in the main application code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的根页面是 `src/index.html`，如下所示列表。这提供了一些初始的DOM（文档对象模型）结构和加载主要应用程序代码。
- en: '![](../Images/CH04_F10_Elger.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F10_Elger.png)'
- en: Figure 4.10 Front end
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 前端
- en: Listing 4.7 `index.html`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 `index.html`
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Load application code
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载应用程序代码
- en: ❷ Navigation bar code omitted
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导航栏代码省略
- en: ❸ Main application content area
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 主要应用程序内容区域
- en: 'The main code for the application lives in the `src` directory. This is composed
    of the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主要代码位于 `src` 目录中。它由以下内容组成：
- en: index.js--Application entry point
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: index.js--应用程序入口点
- en: todo.js--To-do “model” and “controller” code
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: todo.js--待办事项“模型”和“控制器”代码
- en: todo-view.js--To-do DOM manipulation
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: todo-view.js--待办事项DOM操作
- en: templates.js--Common rendering templates
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: templates.js--通用渲染模板
- en: Our `index.js` file, shown in the next listing, simply loads in the required
    resources.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示列表的 `index.js` 文件，简单地加载了所需资源。
- en: Listing 4.8 `index.js`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 `index.js`
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Load jquery and styles
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载jQuery和样式
- en: ❷ Load to-do code
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载待办事项代码
- en: ❸ Activate to-do once page has loaded
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 页面加载后激活待办事项
- en: The main work is carried out in our to-do module, shown in the following listing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工作在我们下面的待办事项模块中完成。
- en: Listing 4.9 `todo.js`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 `todo.js`
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Import to-do view
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入待办事项视图
- en: ❷ Export activate function
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出激活函数
- en: ❸ Create to-do
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建待办事项
- en: ❹ List to-dos
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 列出待办事项
- en: ❺ Call list on load
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 加载时调用列表
- en: We have omitted some of the code from listing 4.9 for clarity. Most readers
    will be familiar with the Model View Controller (MVC) pattern. Our to-do module
    can be thought of as acting as the model and controller for to-dos in our front-end
    application, with our view functionality handled in `todo-view.js`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们省略了列表4.9中的一些代码。大多数读者都会熟悉模型视图控制器（MVC）模式。我们的待办事项模块可以被视为在前端应用程序中充当待办事项的模型和控制器，而视图功能由
    `todo-view.js` 处理。
- en: 'We are building a URL for the to-do API using an environment variable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用环境变量构建待办事项API的URL：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will set the `CHAPTER4_DOMAIN` variable later in this section when we deploy
    the front end.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节稍后部署前端时设置 `CHAPTER4_DOMAIN` 变量。
- en: Why no framework?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有使用框架？
- en: Readers who are familiar with front-end development may be wondering why we
    aren’t using some kind of front-end framework such as React, Vue, or Angular.
    The answer is that although we understand that there are a number of popular frameworks
    available, they take time to learn. Our aim in this book is to teach AI as a Service
    and not front-end frameworks, so we have opted to use a lowest common denominator
    approach of JQuery combined with Webpack. In this way we hope to reduce the cognitive
    learning load.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉前端开发的读者可能会想知道为什么我们不使用某种前端框架，如React、Vue或Angular。答案是，尽管我们了解有许多流行的框架可用，但它们需要时间来学习。本书的目标是教授AI即服务而不是前端框架，因此我们选择使用JQuery结合Webpack的最低共同分母方法。这样我们希望减少认知学习负担。
- en: Our display functionality is handled in `todo-view.js` and `templates.js`. We
    leave it as a exercise for the reader to look through these files, which are essentially
    doing some very simple DOM manipulation to render the to-do list.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理功能由 `todo-view.js` 和 `templates.js` 处理。我们将其留作练习，让读者查看这些文件，这些文件本质上执行了一些非常简单的DOM操作来渲染待办事项列表。
- en: 'In the root of our `frontend` directory we have three control files: `package.json`,
    `webpack.config.js`, and `serverless.yml`. These files allow us to install and
    manage JavaScript dependencies, build a version of the front end for deployment,
    and create the S3 bucket to deploy the build to.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `frontend` 目录根目录中，我们有三个控制文件：`package.json`、`webpack.config.js` 和 `serverless.yml`。这些文件允许我们安装和管理
    JavaScript 依赖项，构建用于部署的前端版本，并创建用于部署构建的 S3 存储桶。
- en: The `serverless.yml` for the front end is very similar to that in our resources
    directory, so we won’t cover it in detail here. It simply defines an S3 bucket
    with the appropriate permissions to serve up our front end publicly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前端 `serverless.yml` 与我们资源目录中的类似，所以我们在这里不会详细说明。它只是定义了一个具有适当权限的 S3 存储桶，以公开提供我们的前端。
- en: We covered the structure of `package.json` in chapters 2 and 3, so this should
    be familiar. We should note that `webpack` itself is managed as a development
    dependency in `package.json`. We also define a build task under the scripts block,
    which runs `webpack` in order to build the application for deployment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 2 章和第 3 章中介绍了 `package.json` 的结构，所以这部分应该是熟悉的。我们应该注意，`webpack` 本身在 `package.json`
    中被管理为一个开发依赖项。我们还在脚本块下定义了一个构建任务，该任务运行 `webpack` 以构建用于部署的应用程序。
- en: Webpack
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack
- en: 'Webpack is a static module bundler for modern JavaScript applications. Webpack
    processes JavaScript, CSS, and other source files to create a compact output JavaScript
    file that can be included in a web application. Webpack works by building a dependency
    graph rather than working on a file-by-file basis. This has several benefits:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 是现代 JavaScript 应用程序的静态模块打包器。Webpack 处理 JavaScript、CSS 以及其他源文件，以创建一个紧凑的输出
    JavaScript 文件，该文件可以包含在 Web 应用程序中。Webpack 通过构建依赖图而不是逐文件工作来实现这一点。这有几个好处：
- en: The dependency graph means that only the resources we need are included in the
    output.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖图意味着只有我们需要的资源被包含在输出中。
- en: The resultant output is much more efficient, as only a single minified JavaScript
    file is downloaded by the web application.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果输出更加高效，因为网络应用程序只下载一个压缩后的 JavaScript 文件。
- en: Our workflow is now clean and efficient, as we can use the `npm` module system
    for dependency management.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的流程现在干净且高效，因为我们可以使用 `npm` 模块系统进行依赖管理。
- en: Webpack will also manage other static assets such as CSS, images, and so on
    as part of the dependency graph.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 还会管理其他静态资源，如 CSS、图像等，作为依赖图的一部分。
- en: 'Full documentation on Webpack is available here: [https://webpack.js.org/](https://webpack.js.org/).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的完整文档可在此处查看：[https://webpack.js.org/](https://webpack.js.org/).
- en: Our `webpack` configuration is listed in the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `webpack` 配置如下所示。
- en: Listing 4.10 `webpack.config.js`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 `webpack.config.js`
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Define dependency graph entry point
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义依赖图入口点
- en: ❷ Enable source maps for debugging
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启用源映射以进行调试
- en: ❸ Define output map
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义输出映射
- en: ❹ Development mode
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 开发模式
- en: ❺ CSS and image modules
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ CSS 和图像模块
- en: ❻ .env file plugin
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ .env 文件插件
- en: Our webpack configuration will build all dependencies from `src/index.js` into
    the `dist` folder for us. This includes all of our source code and related modules,
    including JQuery. We can then simply deploy the `dist` directory to S3 to have
    a functional application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 webpack 配置将把 `src/index.js` 中的所有依赖项构建到 `dist` 文件夹中。这包括我们所有的源代码和相关模块，包括 JQuery。然后我们可以简单地部署
    `dist` 目录到 S3，以拥有一个功能性的应用程序。
- en: In a similar manner to the `serverless-dotenv-plugin`, we use the `dotenv-webpack`
    plugin here. This allows us to use a single environment configuration file across
    all code areas, helping to keep our system DRY.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `serverless-dotenv-plugin` 类似，我们在这里使用 `dotenv-webpack` 插件。这允许我们在所有代码区域使用单个环境配置文件，有助于保持我们的系统
    DRY（Don't Repeat Yourself）。
- en: 4.4.4 Deploying step 1
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 部署步骤 1
- en: Now that we understand the to-do system, let’s go ahead and deploy it to AWS.
    If you haven’t already set up an account, you will need to go to appendix A to
    get set up.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了待办事项系统，让我们继续将其部署到 AWS。如果您还没有设置账户，您需要查看附录 A 来进行设置。
- en: Set environment variables
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: You may recall from reviewing the code that the front-end project created an
    S3 bucket to hold our web application and that it used an environment variable,
    `CHAPTER4_BUCKET`. You will need to decide on a name for your bucket that is globally
    unique. Remember also that we are using a custom domain for our to-do API through
    the environment variable `CHAPTER4_DOMAIN`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在审查代码时，前端项目创建了一个S3存储桶来存放我们的Web应用程序，并且它使用了一个环境变量`CHAPTER4_BUCKET`。你需要为你的存储桶选择一个全局唯一的名称。记住，我们通过环境变量`CHAPTER4_DOMAIN`使用了一个自定义域名来为待办事项API。
- en: 'Following the setup in appendix A, you should have the following environment
    variables defined in your shell:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录A的设置之后，你应该在你的shell中定义以下环境变量：
- en: '`AWS_ACCOUNT_ID`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_ACCOUNT_ID`'
- en: '`AWS_DEFAULT_REGION`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_DEFAULT_REGION`'
- en: '`AWS_ACCESS_KEY_ID`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_ACCESS_KEY_ID`'
- en: '`AWS_SECRET_ACCESS_KEY`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWS_SECRET_ACCESS_KEY`'
- en: These are global variables and that you should keep in just one place on your
    system. To deploy our to-do application, we need to provide the system-specific
    variables. To do this, we will use a `.env` file. Using any text editor, create
    a file called `.env` and place it in the `chapter4/step1-basic-todo` directory.
    The file should contain the contents shown in the following listing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是全局变量，你应该在系统的一个地方保持它们。为了部署我们的待办应用程序，我们需要提供系统特定的变量。为此，我们将使用一个`.env`文件。使用任何文本编辑器创建一个名为`.env`的文件，并将其放置在`chapter4/step1-basic-todo`目录中。该文件应包含以下列表中的内容。
- en: Listing 4.11 Environment variables for step 1
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 步骤1的环境变量
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ We specify the region eu-west-1 for all examples.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们指定所有示例的区域为eu-west-1。
- en: ❷ Specify the globally unique bucket names you have chosen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定你选择的全球唯一存储桶名称。
- en: ❸ The value for CHAPTER4_DOMAIN can be exactly as used for our chapter 2 and
    3 deployment, and should refer to a domain created with AWS Route53.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `CHAPTER4_DOMAIN`的值可以与第2章和第3章部署中使用的值完全相同，并且应引用使用AWS Route53创建的域名。
- en: Substitute your chosen names for `CHAPTER4_BUCKET`, `CHAPTER4_DATA_BUCKET`,
    and `CHAPTER4_DOMAIN`. Refer back to chapters 2 and 3 for full instructions on
    setting up a domain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 用你选择的名称替换`CHAPTER4_BUCKET`、`CHAPTER4_DATA_BUCKET`和`CHAPTER4_DOMAIN`。请参考第2章和第3章，以获取设置域的完整说明。
- en: Deploy resources
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署资源
- en: First, we will deploy our resources project. To do this, `cd` into the `resources`
    directory and run
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将部署我们的资源项目。为此，进入`resources`目录并运行：
- en: '[PRE15]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will create our S3 data bucket for later use. We can confirm creation of
    the bucket by using the AWS web console.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的S3数据存储桶，供以后使用。我们可以通过使用AWS Web控制台来确认存储桶的创建。
- en: Deploy todo-service
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署待办服务
- en: Next we will deploy the to-do service. `cd` into the `todo-service` directory
    and install dependencies by running
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将部署待办服务。进入`todo-service`目录，通过运行以下命令安装依赖项：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before deploying, we will need to create a custom domain for our application.
    Our configuration for this in `serverless.yml` is shown in the next listing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前，我们需要为我们的应用程序创建一个自定义域名。在`serverless.yml`中的配置如下所示。
- en: Listing 4.12 Custom domain configuration in `serverless.yml`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 `serverless.yml`中的自定义域名配置
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ This defines the parent domain.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这定义了父域名。
- en: ❷ The subdomain is composed of the prefix chapter4api and the parent domain.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 子域名由前缀chapter4api和父域名组成。
- en: ❸ A wildcard certificate is specified.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定了一个通配符证书。
- en: Our domain name for this section will be composed of our setting for `CHAPTER4_DOMAIN`
    and with a subdomain of `chapter4api`. That is, if we were using `example.com`
    for our variable `CHAPTER4_DOMAIN`, then the full custom domain for this chapter
    would be `chapter4api.example.com`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个部分的域名将由`CHAPTER4_DOMAIN`的设置和一个子域名`chapter4api`组成。也就是说，如果我们使用`example.com`作为变量`CHAPTER4_DOMAIN`的值，那么这一章的完整自定义域名将是`chapter4api.example.com`。
- en: Let’s go ahead and create this domain
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建这个域名
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now deploy our to-do API by running
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过运行以下命令来部署我们的待办事项API：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deploy the front end
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署前端
- en: Finally, in this section, we need to deploy our front end. First, to install
    dependencies, `cd` into the `frontend` directory and run
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这一节中，我们需要部署我们的前端。首先，为了安装依赖项，进入`frontend`目录并运行：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next we need to create the bucket for our application by running
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过运行以下命令创建我们的应用程序的存储桶：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now build the front end with Webpack through our `npm` scripts section:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过我们的`npm`脚本部分使用Webpack构建前端：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will create a file `main.js` in our `dist` directory, along with an `assets`
    directory containing some additional images. To deploy the front end we will use
    the AWS command line as we did in chapters 2 and 3:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的`dist`目录中创建一个名为`main.js`的文件，以及一个包含一些额外图像的`assets`目录。为了部署前端，我们将使用AWS命令行，就像我们在第2章和第3章中所做的那样：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will push the contents of the `dist` directory into our chapter 4 bucket
    that we just created. Note that we need to `source` the contents of our environment
    file into the shell to provide the `CHAPTER4_BUCKET` environment variable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`dist`目录的内容推送到我们刚刚创建的第4章存储桶。请注意，我们需要将环境文件的内容`source`到shell中，以提供`CHAPTER4_BUCKET`环境变量。
- en: Test it
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试它
- en: If all of the preceding steps went well, we should now have a fully functioning
    system deployed to AWS. To test this out, open this URL in a browser
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有前面的步骤都进行顺利，我们现在应该已经将一个完全功能性的系统部署到了AWS。为了测试这一点，请在浏览器中打开此URL
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: replacing `<CHAPTER4_BUCKET>` with your specific bucket name. You should be
    able to create and update to-do items through the front end in your browser.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<CHAPTER4_BUCKET>`替换为你的特定存储桶名称。你应该能够通过浏览器中的前端创建和更新待办事项。
- en: Why serve from the bucket?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么从存储桶提供服务？
- en: Some readers may be wondering why are we serving up content directly from the
    S3 bucket. Why are we not using a CDN such as CloudFront? The answer is that for
    a teaching system like this, CloudFront is overkill. We agree that for a full
    production system, the S3 bucket should be used as the origin server for a CDN;
    however, in development mode, CDN caching and updating will just get in the way.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能会想知道为什么我们要直接从S3存储桶提供内容。我们为什么不使用像CloudFront这样的CDN？答案是，对于这样一个教学系统，CloudFront是过度的。我们同意，对于一个完整的生产系统，S3存储桶应该用作CDN的源服务器；然而，在开发模式下，CDN缓存和更新只会碍手碍脚。
- en: We now have a working to-do system. There’s just one minor problem. The system
    is publicly accessible, meaning that any random person on the internet can read
    and modify my to-do list. This is clearly not a desirable characteristic for our
    system, so we’d better address it quickly. Thankfully, we can use a cloud native
    service to handle the work here for us. In the next section we will secure our
    to-do list with Cognito.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个工作的待办事项系统。只有一个小问题。系统是公开可访问的，这意味着任何互联网上的随机人员都可以读取和修改我的待办事项列表。这显然不是我们系统所期望的特性，所以我们最好迅速解决这个问题。幸运的是，我们可以使用一个云原生服务来为我们处理这项工作。在下一节中，我们将使用Cognito来保护我们的待办事项列表。
- en: '4.5 Step 2: Securing with Cognito'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 步骤2：使用Cognito进行安全保护
- en: User management is one of those deceptively simple problems, in that it seems
    like it should be easy, but usually turns out to be really hard! Many programmers
    have suffered long into the night rolling their own user authentication and management
    systems under the naive assumption that “it can’t be that hard.”
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 用户管理是那些看似简单的问题之一，因为它看起来应该很容易，但通常结果却非常困难！许多程序员在天真地认为“这不可能那么难”的假设下，长时间熬夜自己编写用户身份验证和管理系统。
- en: Fortunately, user login and management is a solved problem, so we never have
    to write this type of code again. We can just use a cloud native service to do
    the work for us. There are several options available, but for this system we will
    be using AWS Cognito. Cognito provides a full authentication service for us, including
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，用户登录和管理是一个已解决的问题，所以我们再也不需要编写这类代码了。我们可以直接使用云原生服务来为我们完成这项工作。有几种选项可供选择，但对我们这个系统来说，我们将使用AWS
    Cognito。Cognito为我们提供了一个完整的身份验证服务，包括
- en: Password complexity policy
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码复杂性策略
- en: Integration with web and mobile applications
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Web和移动应用程序的集成
- en: Multiple login strategies
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种登录策略
- en: User management
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理
- en: Password complexity rules
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码复杂性规则
- en: Single sign on
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点登录
- en: Social login via Facebook, Google, Amazon, and so on
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Facebook、Google、Amazon等社交登录
- en: Security best practices and defense for the latest known security vulnerabilities
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全最佳实践和针对最新已知安全漏洞的防御
- en: This is an awful lot of functionality for a small development effort. So, let’s
    apply Cognito to our to-do system and secure it from the bad guys!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一个小型的开发工作来说功能非常强大。所以，让我们将Cognito应用到我们的待办事项系统中，并保护它免受坏人的侵害！
- en: Figure 4.11 illustrates the system with Cognito authentication added.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11展示了添加了Cognito身份验证的系统。
- en: '![](../Images/CH04_F11_Elger.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH04_F11_Elger.png)'
- en: Figure 4.11 Step 2 architecture
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 步骤2架构
- en: We have added the AWS Amplify library to the front end. Amplify is a JavaScript
    library that provides authenticated access to various AWS services. For now, we
    will be using it just for authentication and access control. The token provided
    on successful login is passed to API calls to the API Gateway which, in turn,
    are handled by the AWS Lambda handler functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 AWS Amplify 库添加到前端。Amplify 是一个提供对各种 AWS 服务进行认证访问的 JavaScript 库。目前，我们只会用它来进行认证和访问控制。在成功登录后提供的令牌将被传递到
    API Gateway 的 API 调用中，这些调用反过来由 AWS Lambda 处理函数处理。
- en: AWS Amplify
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Amplify
- en: Amplify started life as a JavaScript library providing client-side access to
    AWS APIs. The library supports desktop browsers, as well as iOS and Android devices.
    A recent addition to the library is the Amplify CLI, which aims to provide a tool
    chain similar to the Serverless Framework that we have been using. At the time
    of writing, the Amplify tool chain is less mature than the Serverless Framework
    and lacks the plugin ecosystem support. However, this is definitely one to watch.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Amplify 最初是一个提供客户端访问 AWS API 的 JavaScript 库。该库支持桌面浏览器，以及 iOS 和 Android 设备。库的最新增补是
    Amplify CLI，旨在提供类似于我们一直在使用的 Serverless Framework 的工具链。在撰写本文时，Amplify 工具链不如 Serverless
    Framework 成熟，并且缺乏插件生态系统支持。然而，这绝对是一个值得关注的项目。
- en: 'Full documentation on Amplify can be found here: [https://aws-amplify.github.io/docs/js/start](https://aws-amplify.github.io/docs/js/start).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Amplify 的完整文档可以在以下链接找到：[https://aws-amplify.github.io/docs/js/start](https://aws-amplify.github.io/docs/js/start)。
- en: As illustrated in figure 4.11, we hand off the job of login to Cognito. Once
    a user has authenticated, they are allocated a session token, which is managed
    by the Amplify library. We then add an authentication step into our API Gateway
    setup, requiring that the user supply a valid JSON Web Token (JWT) before we allow
    the request to proceed. Any requests without a valid web token are rejected at
    this layer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.11 所示，我们将登录任务委托给 Cognito。一旦用户认证成功，就会分配一个会话令牌，由 Amplify 库管理。然后我们在 API Gateway
    设置中添加一个认证步骤，要求用户在请求继续之前提供有效的 JSON Web Token (JWT)。任何没有有效网络令牌的请求都会在这一层被拒绝。
- en: JSON Web Tokens
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: 'JSON Web Token (JWT) is an (RFC 7519) standard defining a method for securely
    transmitting claims as a JSON object. A JWT is comprised of three parts:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Web Token (JWT) 是一个定义了安全传输声明的方法的 (RFC 7519) 标准，它将声明作为 JSON 对象进行传输。JWT 由三个部分组成：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: header--Identifies the hash algorithm used by the token.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: header--标识令牌使用的哈希算法。
- en: payload--Contains a set of claims. A typical claim would be a user ID.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: payload--包含一组声明。一个典型的声明可能是用户 ID。
- en: signature--Is a one-way hash of the header, payload, and a secret using the
    algorithm defined in the header.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: signature--是 header、payload 和一个秘密使用 header 中定义的算法进行单向哈希的结果。
- en: Typically a JWT will be issued by an authentication server on login and then
    used by a client to securely access resources. JWTs are typically short-lived
    and expire after a predefined time, forcing the client to periodically re-authenticate
    to generate a fresh token.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JWT 会在登录时由认证服务器颁发，然后由客户端用于安全地访问资源。JWT 通常具有较短的生存期，并在预定义的时间后过期，迫使客户端定期重新认证以生成新的令牌。
- en: 'Detailed information on JWTs can be found here: [https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JWT 的详细信息可以在以下链接找到：[https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token)。
- en: 4.5.1 Getting the code
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 获取代码
- en: The code for this step is in the directory `chapter4/step-2-cognito-login` and
    contains the code from step 1 along with the updates for Cognito. We will walk
    through the updates in turn first, and then deploy the changes to secure our system.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤的代码在目录 `chapter4/step-2-cognito-login` 中，包含了步骤 1 的代码以及 Cognito 的更新。我们将依次介绍这些更新，然后部署更改以保护我们的系统。
- en: 4.5.2 User service
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 用户服务
- en: 'First up, there is a new service directory, `user-service`. This folder just
    contains the Serverless configuration for Cognito. There are three files:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个新的服务目录，`user-service`。这个文件夹只包含 Cognito 的无服务器配置。这里有三个文件：
- en: identity-pool.yml
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: identity-pool.yml
- en: user-pool.yml
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: user-pool.yml
- en: serverless.yml
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: serverless.yml
- en: Our `serverless.yml` is short and you should be familiar with most of the boilerplate
    entries at this point. It imports the other two files, which contain Cognito resources.
    `user-pool.yml`, shown in the next listing, configures our Cognito user pool.
    A user pool is exactly what it sounds like, a pool of users.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`serverless.yml`很短，此时你应该熟悉大多数模板条目。它导入其他两个文件，这些文件包含Cognito资源。下一个列表中的`user-pool.yml`配置了我们的Cognito用户池。用户池正是其名称所暗示的，即用户池。
- en: Listing 4.13 Cognito user-pool configuration
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 Cognito用户池配置
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ User pool
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户池
- en: ❷ Client integration
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 客户端集成
- en: Cognito provides a huge range of options. We are going to keep things simple
    and configure it just for email and password login. The code in listing 4.13 creates
    a user pool and also a user-pool client. A user pool client provides an integration
    bridge between a user pool and external applications. Cognito supports multiple
    user-pool clients against a single user pool.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Cognito提供了大量的选项。我们将保持简单，仅为其配置电子邮件和密码登录。列表4.13中的代码创建了一个用户池和一个用户池客户端。用户池客户端提供了一个用户池和外部应用程序之间的集成桥梁。Cognito支持单个用户池针对多个用户池客户端。
- en: To use Cognito for authorized access to AWS resources, we are going to also
    need an identity pool. This is configured in `identity-pool.yml`, shown in the
    next listing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Cognito授权访问AWS资源，我们还需要一个身份池。这已在`identity-pool.yml`中配置，如下所示。
- en: Listing 4.14 Cognito identity-pool configuration
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 Cognito身份池配置
- en: '[PRE27]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Define identity pool
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义身份池
- en: ❷ Connect to user pool
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 连接到用户池
- en: ❸ Attach policy to identity pool
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将策略附加到身份池
- en: In listing 4.14, we connected the identity pool to our user pool and also to
    a role, `CognitoAuthRole`. The role is also defined in `identity-pool.yml`. The
    key part to understand about this role is contained in the policy statement, shown
    in the next listing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.14中，我们将身份池连接到了我们的用户池，还连接到了一个角色，`CognitoAuthRole`。该角色也在`identity-pool.yml`中定义。关于这个角色的关键部分包含在下一个列表中的策略声明中。
- en: Listing 4.15 Identity-pool policy statements
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 身份池策略声明
- en: '[PRE28]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The policy grants all actions for Cognito, S3, Transcribe, Polly, and Lex.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 策略授予Cognito、S3、Transcribe、Polly和Lex的所有操作。
- en: ❷ The policy grants access to invoke our API Gateway routes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 策略授予调用我们的API网关路由的访问权限。
- en: This policy will be associated with all authenticated users and says that users
    with this role can
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略将与所有经过身份验证的用户相关联，并表示具有此角色的用户可以
- en: Access S3
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问S3
- en: Call the Transcribe service
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用Transcribe服务
- en: Call the Polly service
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用Polly服务
- en: Use the Lex service
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lex服务
- en: Execute API Gateway functions
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行API网关功能
- en: Access to any other services will be denied for this role.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此角色，将拒绝访问任何其他服务。
- en: Timeout!
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超时！
- en: OK, if you think all of this talk of user pools and identity pools is a little
    confusing, we agree! It can be overwhelming at first, so let’s take some time
    to explain. The key concept to understand is the difference between authentication
    and authorization.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你觉得所有关于用户池和身份池的讨论有点令人困惑，我们同意！一开始可能会感到有些压倒性，所以让我们花点时间来解释。要理解的关键概念是身份验证和授权之间的区别。
- en: '*Authentication* is the “who.” In other words, can I prove that I am who I
    say I am? Usually this is done by proving that I know a secret piece of information--a
    password. A user pool deals with authentication.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*是“谁”。换句话说，我能证明我就是我所说的那个人吗？通常这是通过证明我知道一个秘密信息片段——密码来完成的。用户池处理身份验证。'
- en: '*Authorization* is the “what.” Given that I have proved who I am, what resources
    am I allowed to access? Typically this is achieved through some type of permissions
    model. For example, in a file system there are user- and group-level access controls
    that implement a basic permissions model. The AWS policy that we just created
    is a permissions model for our logged-in user. An identity pool deals with authorization.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权*是“什么”。鉴于我已经证明了我的身份，我允许访问哪些资源？通常这通过某种类型的权限模型来实现。例如，在文件系统中，有用户和组级别的访问控制，实现了基本的权限模型。我们刚刚创建的AWS策略是我们登录用户的权限模型。身份池处理授权。'
- en: Identity pools are also referred to as *federated identities*. This is because
    an identity pool can have multiple sources of identity. This is illustrated in
    figure 4.12.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 身份池也被称为*联合身份*。这是因为身份池可以有多个身份来源。这如图4.12所示。
- en: '![](../Images/CH04_F12_Elger.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F12_Elger.png)'
- en: Figure 4.12 User and identity pools
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 用户和身份池
- en: As illustrated, a user pool can be thought of as one source of validated identities.
    Other sources include Facebook, Google, Twitter, and so on. An identity pool can
    be configured to use multiple sources of identity. For each validated identity,
    the identity pool allows us to configure a policy for authorized access to our
    AWS resources.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，用户池可以被视为一个验证身份的来源。其他来源包括 Facebook、Google、Twitter 等。可以配置身份池以使用多个身份来源。对于每个验证过的身份，身份池允许我们为授权访问我们的
    AWS 资源配置策略。
- en: For this system, we will just use a Cognito user pool as our source of authenticated
    users; we won’t enable social logins.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个系统，我们将仅使用 Cognito 用户池作为我们的认证用户来源；我们不会启用社交登录。
- en: 4.5.3 To-do service
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 To-do 服务
- en: Now that we have a source of authenticated users, we need to update our service
    to ensure that we have locked it down against unauthorized access. This is very
    simple to implement, and requires a small update to our `serverless.yml` for our
    to-do service, shown in the following listing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了认证用户的来源，我们需要更新我们的服务以确保我们已将其锁定以防止未经授权的访问。这很容易实现，并且需要对我们的 to-do 服务 `serverless.yml`
    进行少量更新，如下列表所示。
- en: Listing 4.16 Changes to to-do `serverless.yml`
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 对 `serverless.yml` 的更改
- en: '[PRE29]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Include user pool ARN
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含用户池 ARN
- en: ❷ Declare authorizer
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明授权者
- en: We simply declare an authorizer against each endpoint that we wish to secure.
    We will also need to update our environment to include the user pool identifier
    `CHAPTER4_POOL_ARN`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需为希望保护的每个端点声明一个授权者。我们还需要更新我们的环境以包括用户池标识符 `CHAPTER4_POOL_ARN`。
- en: 4.5.4 Front-end service
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 前端服务
- en: The final set of changes to our front end provides login, logout, and token
    management. We have added AWS Amplify to our front-end `package.json` as a dependency.
    Amplify requires that we supply it with some configuration parameters. This is
    done in `index.js`, shown in the next listing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对前端所做的最后一系列更改提供了登录、注销和令牌管理功能。我们已将 AWS Amplify 添加到前端 `package.json` 中作为依赖项。Amplify
    需要我们提供一些配置参数。这通过 `index.js` 完成，如下列表所示。
- en: Listing 4.17 Amplify configuration in `index.js`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 `index.js` 中的 Amplify 配置
- en: '[PRE30]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Configure OAuth flow.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 配置 OAuth 流程。
- en: ❷ Configure Amplify.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 配置 Amplify。
- en: Our configuration is broken into two separate parts. First, we configure OAuth
    by providing a domain name and redirect URLs. These must match our Cognito configuration,
    which we will set up shortly when we deploy these changes. Second, we configure
    Amplify with our pool identifiers; we will grab these IDs during deployment and
    adjust our environment file accordingly in the next section.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置分为两个独立的部分。首先，我们通过提供域名和重定向 URL 来配置 OAuth。这些必须与我们的 Cognito 配置匹配，我们将在部署这些更改时设置。其次，我们使用我们的池标识符配置
    Amplify；我们将在部署期间获取这些 ID，并在下一节中相应地调整我们的环境文件。
- en: The login implementation is handled by `auth.js` and `auth-view.js`. The code
    for `auth.js` is shown in the following listing.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 登录实现由 `auth.js` 和 `auth-view.js` 处理。以下列表显示了 `auth.js` 的代码。
- en: Listing 4.18 `auth.js`
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 `auth.js`
- en: '[PRE31]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Redirect to Cognito login page
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重定向到 Cognito 登录页面
- en: ❷ Check if logged in
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否已登录
- en: ❸ Render logout link
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染注销链接
- en: ❹ Else render login link
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则渲染登录链接
- en: '`auth.js` hands off most of the work to Amplify. In the `activate` function,
    it checks to see if the user is already logged in, and then calls the view to
    render either a login or logout link. It also provides a login handler that redirects
    to the Cognito login page.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.js` 将大部分工作委托给 Amplify。在 `activate` 函数中，它检查用户是否已经登录，然后调用视图来渲染登录或注销链接。它还提供了一个登录处理程序，该处理程序将重定向到
    Cognito 登录页面。'
- en: Finally, in the front end, we need to update our calls to the to-do API to include
    our authorization token; otherwise, we will be denied access. This is shown in
    listing 4.19.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在前端，我们需要更新我们对 to-do API 的调用，包括我们的授权令牌；否则，我们将被拒绝访问。这显示在列表 4.19 中。
- en: Listing 4.19 Updated `create` method
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.19 更新的 `create` 方法
- en: '[PRE32]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Get the session.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取会话。
- en: ❷ Supply JWT through an Authorization header
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过授权头提供 JWT
- en: We have updated each of the functions in `to-do.js` to include an `Authorization`
    header, which is used to pass the JWT obtained from Cognito to our API.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更新 `to-do.js` 中的每个函数，以包含一个 `Authorization` 头，该头用于将 Cognito 获取的 JWT 传递到我们的
    API。
- en: 4.5.5 Deploying step 2
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.5 部署步骤 2
- en: Now that we understand Cognito, let’s get the changes deployed and our application
    secured.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Cognito，让我们部署更改并确保我们的应用程序安全。
- en: Deploying Cognito pools
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署 Cognito 池
- en: First, `cd` into `step-2-cognito-login/user-service` and deploy the pools by
    running
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入 `step-2-cognito-login/user-service` 目录，通过运行以下命令部署池：
- en: '[PRE33]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will create a user and identity pool. We will need to supply some additional
    configuration through the AWS console. Open up a browser, log in to the AWS console,
    and go to the Cognito section. Select the option to Manage User Pools and select
    the pool `chapter4usersdevuserpool`. We need to provide a domain name to our user
    pool. Select the Domain Name option from the App Integration section, and provide
    a new domain name as illustrated in figure 4.13.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个用户和身份池。我们还需要通过 AWS 控制台提供一些额外的配置。打开浏览器，登录到 AWS 控制台，并转到 Cognito 部分。选择管理用户池选项，并选择池
    `chapter4usersdevuserpool`。我们需要为我们用户提供一个域名。从应用集成部分选择域名选项，并提供一个新域名，如图 4.13 所示。
- en: '![](../Images/CH04_F13_Elger.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F13_Elger.png)'
- en: Figure 4.13 User and identity pools
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 用户和身份池
- en: For our user pool, we have used the domain name `chapter4devfth`. You can use
    any unique domain name that is available.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用户池，我们使用了域名 `chapter4devfth`。您可以使用任何可用的唯一域名。
- en: Next we need to configure our OAuth flows. Select the option App Client Settings
    and provide settings as illustrated in figure 4.14.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的 OAuth 流。选择应用客户端设置选项，并按图 4.14 所示提供设置。
- en: '![](../Images/CH04_F14_Elger.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F14_Elger.png)'
- en: Figure 4.14 OAuth flow configuration
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 OAuth 流配置
- en: 'For the login and logout callback URLs, you should provide the URL to your
    front-end bucket using the custom domain that we created in step 1\. These should
    be provided in this form: [https://s3-eu-west-1.amazonaws.com/<YOUR BUCKET NAME>/index.html](https://s3-eu-west-1.amazonaws.com/<YOUR%20BUCKET%20NAME%3E/index.html).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于登录和注销回调 URL，您应该使用我们在步骤 1 中创建的定制域名提供您的前端存储桶的 URL。这些应该以以下形式提供：[https://s3-eu-west-1.amazonaws.com/<YOUR
    BUCKET NAME>/index.html](https://s3-eu-west-1.amazonaws.com/<YOUR%20BUCKET%20NAME%3E/index.html)。
- en: OAuth
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth
- en: OAuth is a standard protocol for authentication and authorization which is widely
    implemented. A full discussion of the OAuth 2.0 protocol would require an entire
    book of its own. In fact, we would refer readers who are interested in this to
    the Manning publication, *OAuth 2 in Action*, by Justin Richer and Antonio Sanso
    ([https://www.manning.com/books/oauth-2-in-action](https://www.manning.com/books/oauth-2-in-action)).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一种广泛实施的认证和授权标准协议。对 OAuth 2.0 协议的全面讨论需要一本完整的书籍。实际上，我们会将对此感兴趣的读者推荐到曼宁出版社出版的由
    Justin Richer 和 Antonio Sanso 编写的 *OAuth 2 in Action* 一书（[https://www.manning.com/books/oauth-2-in-action](https://www.manning.com/books/oauth-2-in-action)）。
- en: 'More details on the OAuth 2.0 protocol can be found here: [https://oauth.net/2/](https://oauth.net/2/).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OAuth 2.0 协议的更多详细信息，请参阅此处：[https://oauth.net/2/](https://oauth.net/2/)。
- en: Finally, for the user pool we will need to create an account to log in with.
    To do this, select Users and Groups and click on the Create User button. Here,
    you can use your email address as the username and pick a temporary password.
    Enter your email address in the email field too. There is no need to enter a phone
    number, so deselect Mark Phone Number as Verified. The default selection for all
    other fields can be kept.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于用户池，我们需要创建一个账户来登录。为此，选择用户和组，然后点击创建用户按钮。在这里，您可以使用您的电子邮件地址作为用户名，并选择一个临时密码。在电子邮件字段中也输入您的电子邮件地址。不需要输入电话号码，因此取消选中“标记电话号码为已验证”。所有其他字段的默认选择可以保持不变。
- en: Updating the environment
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新环境变量
- en: Now that we have configured our pools, we need to update our `.env` file. `cd`
    into the `chapter4/step-2-cognito-login` directory and edit the file `.env` to
    match the following listing.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的池，我们需要更新我们的 `.env` 文件。进入 `chapter4/step-2-cognito-login` 目录并编辑文件
    `.env` 以匹配以下列表。
- en: Listing 4.20 Updated `.env` file
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.20 更新的 `.env` 文件
- en: '[PRE34]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ The first block of environment variables is retained from listing 4.11.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 环境变量的第一块保留自列表 4.11。
- en: ❷ The new environment variables reference the AWS Cognito resources we have
    created.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新的环境变量引用了我们创建的 AWS Cognito 资源。
- en: You can find these IDs in the Cognito section of the AWS Management Console.
    The user-pool ID is located in the user-pool view, shown in figure 4.15.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 AWS 管理控制台的 Cognito 部分找到这些 ID。用户池 ID 位于用户池视图中，如图 4.15 所示。
- en: '![](../Images/CH04_F15_Elger.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F15_Elger.png)'
- en: Figure 4.15 User pool ID and ARN
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 用户池 ID 和 ARN
- en: The client ID can be located in the *App client settings* section of the Cognito
    user-pools view. This is shown in figure 4.16.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 ID 可以在 Cognito 用户池视图的 *应用客户端设置* 部分找到。这如图 4.16 所示。
- en: '![](../Images/CH04_F16_Elger.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F16_Elger.png)'
- en: Figure 4.16 Pool client ID
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 池客户端ID
- en: The identity-pool ID can be located in the *Federated Identities* view. Simply
    select the identity pool that has been created and select Edit Identity Pool at
    the top right. The edit view is shown in figure 4.17\. From here, you can view
    and copy the identity-pool ID.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 身份池ID可以在“联合身份”视图中找到。只需选择已创建的身份池，然后在右上角选择编辑身份池。编辑视图如图4.17所示。从这里，您可以查看并复制身份池ID。
- en: '![](../Images/CH04_F17_Elger.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH04_F17_Elger.png)'
- en: Figure 4.17 Identity-pool ID
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 身份池ID
- en: Note that you may see a warning stating that no unauthenticated role has been
    specified. This can be ignored, as all users must be authenticated for our application.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能会看到一个警告，表明没有指定未认证的角色。这可以忽略，因为所有用户都必须对我们的应用程序进行认证。
- en: Once you have located the required values in the AWS Console, populate the `.env`
    file with the relevant values.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在AWS控制台中找到了所需值，请使用相关值填充`.env`文件。
- en: Updating the to-do API
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新待办事项API
- en: Now that we have updated our environment, we can deploy the changes to our to-do
    service. `cd` into the `step-2-cognito-login/todo-service` directory and run
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了我们的环境，我们可以将更改部署到我们的待办事项服务。请进入`step-2-cognito-login/todo-service`目录并运行
- en: '[PRE35]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will push a new version of the API, which will include our Cognito authorizer.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这将推送API的新版本，其中包括我们的Cognito授权器。
- en: Updating the front end
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新前端
- en: Now that our API is safely secured, we need to update our front end to allow
    access. To do this, `cd` into the `step-2-cognito-login/frontend` directory and
    run
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安全地保护了我们的API，我们需要更新我们的前端以允许访问。为此，请进入`step-2-cognito-login/frontend`目录并运行
- en: '[PRE36]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will build a new version of our application, including the authentication
    code, and deploy it to our bucket. If you point a browser at our application,
    you should see a blank page and a Login link at the top of the page. Click this
    link to bring up a Cognito login dialog. Once logged in, the application should
    function as before.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建我们应用程序的新版本，包括认证代码，并将其部署到我们的存储桶。如果您将浏览器指向我们的应用程序，您应该看到一个空白页面和页面顶部的登录链接。点击此链接将弹出Cognito登录对话框。一旦登录，应用程序应该像以前一样运行。
- en: 'Though it takes a little effort to set up Cognito, the benefits far outweigh
    the costs. Let’s review what you get with this service:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置Cognito需要一点努力，但带来的好处远远超过了成本。让我们回顾一下您使用此服务可以获得的内容：
- en: User registration
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册
- en: Secure JWT login
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全JWT登录
- en: Integration into the AWS IAM security model
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成到AWS IAM安全模型中
- en: Password reset
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码重置
- en: Federated identities both enterprise and social (such as Facebook, Google, Twitter...)
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联邦身份，包括企业和社交（如Facebook、Google、Twitter...）
- en: Password policy control
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码策略控制
- en: Those of you who have had to deal with these issues before will appreciate the
    large overhead that can come with implementing these features, even when using
    a third-party library. The key reason for using Cognito is that the responsibility
    for much of the work of keeping user accounts secure can be offloaded onto this
    service. Of course, we still have to be mindful of the security of our applications;
    however, it is comforting to know that the Cognito service is being actively managed
    and updated for us.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 那些之前必须处理这些问题的用户将欣赏到实现这些功能所带来的大量开销，即使使用第三方库也是如此。使用Cognito的关键原因是将保持用户账户安全的大部分工作责任转移到这个服务上。当然，我们仍然必须注意我们应用程序的安全性；然而，知道Cognito服务正在为我们积极管理和更新，这让人感到安慰。
- en: We covered a lot of ground to get our secured serverless application up and
    running. The important point to note about this is that we were able to rapidly
    deploy our application in a secure manner with very little work. In the next chapter
    we will add some AI services to our to-do list.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的安全无服务器应用程序上线，我们覆盖了很多内容。关于这一点，重要的是我们能够以非常少的努力快速以安全的方式部署我们的应用程序。在下一章中，我们将向我们的待办事项列表添加一些AI服务。
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An end-to-end serverless platform, from client to database, can be defined in
    code and deployed using the Serverless Framework.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端到数据库的端到端无服务器平台可以在代码中定义并使用Serverless Framework进行部署。
- en: A DynamoDB table can be created as part of the resources section of the `serverless.yml`
    file.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在`serverless.yml`文件的资源部分创建DynamoDB表。
- en: The AWS SDK is used in our Lambda functions to pass data from events to our
    database read and write invocations.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Lambda函数中使用AWS SDK将数据从事件传递到我们的数据库读/写调用。
- en: Authentication and authorization are configured with AWS Cognito. We configure
    a user pool, identity pool, and custom domain along with a policy to protect specific
    resources.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权使用 AWS Cognito 进行配置。我们配置了一个用户池、身份池和自定义域名，以及一个策略来保护特定资源。
- en: AWS Amplify is used with Cognito to create a login interface with Cognito. Amplify
    is an easy-to-use client SDK from AWS that integrates with Cognito to enable powerful
    security features.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Amplify 与 Cognito 结合使用，以创建一个带有 Cognito 的登录界面。Amplify 是 AWS 提供的一个易于使用的客户端
    SDK，它集成了 Cognito 以启用强大的安全功能。
- en: API Gateway CRUD routes can be created to trigger Lambda functions. API Gateway
    routes are created through the events we define in the `serverless.yml`, linked
    to the associated Lambda function or *handler*.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以创建 API Gateway CRUD 路由来触发 Lambda 函数。API Gateway 路由是通过我们在 `serverless.yml`
    中定义的事件创建的，与相关的 Lambda 函数或 *handler* 相关联。
- en: Warning Chapter 5 continues to build on this system and we provide instructions
    on how to remove the deployed resources at the end of chapter 5\. If you are not
    planning on working on chapter 5 for some time, please ensure that you fully remove
    all cloud resources deployed in this chapter in order to avoid additional charges!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：第五章将继续构建此系统，并在第五章末尾提供如何移除已部署资源的说明。如果您暂时不打算处理第五章，请确保您完全移除本章中部署的所有云资源，以避免产生额外费用！
