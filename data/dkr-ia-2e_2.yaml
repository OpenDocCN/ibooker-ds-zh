- en: Part 2\. Packaging software for distribution
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二部分\. 打包软件以进行分发
- en: Inevitably, a Docker user will need to create an image. Sometimes the software
    you need is not packaged in an image. Other times you will need a feature that
    has not been enabled in an available image. The four chapters in this part will
    help you understand how to originate, customize, and specialize the images you
    intend to deploy or share using Docker.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不可避免地，Docker用户将需要创建一个镜像。有时您需要的软件没有打包在镜像中。有时您可能需要一个在可用镜像中尚未启用的功能。本部分的四章将帮助您了解如何创建、定制和专门化您打算使用Docker部署或共享的镜像。
- en: Chapter 7\. Packaging software in images
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第7章\. 在镜像中打包软件
- en: This chapter covers
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Manual image construction and practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动镜像构建和实践
- en: Images from a packaging perspective
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从打包的角度看镜像
- en: Working with flat images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与平面镜像一起工作
- en: Image versioning best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像版本控制最佳实践
- en: The goal of this chapter is to help you understand the concerns of image design,
    learn the tools for building images, and discover advanced image patterns. You
    will accomplish these things by working through a thorough real-world example.
    Before getting started, you should have a firm grasp on the concepts in [part
    1](index_split_023.html#filepos151791) of this book.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章的目标是帮助您了解镜像设计的相关问题，学习构建镜像的工具，并发现高级镜像模式。您将通过一个详尽的现实世界示例来完成这些任务。在开始之前，您应该对本书中第一部分（index_split_023.html#filepos151791）中的概念有牢固的掌握。
- en: You can create a Docker image by either modifying an existing image inside a
    container or defining and executing a build script called a Dockerfile. This chapter
    focuses on the process of manually changing an image, the fundamental mechanics
    of image manipulation, and the artifacts that are produced. Dockerfiles and build
    automation are covered in [chapter 8](index_split_069.html#filepos755104).
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过修改容器内现有的镜像或定义并执行一个名为Dockerfile的构建脚本来创建一个Docker镜像。本章重点介绍手动更改镜像的过程、镜像操作的基本原理以及产生的工件。Dockerfile和构建自动化将在第8章（index_split_069.html#filepos755104）中介绍。
- en: 7.1\. BUILDING DOCKER IMAGES FROM A CONTAINER
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1\. 从容器构建Docker镜像
- en: It’s easy to get started building images if you’re already familiar with using
    containers. Remember, a union filesystem (UFS) mount provides a container’s filesystem.
    Any changes that you make to the filesystem inside a container will be written
    as new layers owned by the container that created them.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您已经熟悉使用容器，那么开始构建镜像会很容易。记住，联合文件系统（UFS）挂载提供了一个容器的文件系统。您对容器内文件系统所做的任何更改都将作为新层写入，这些层由创建它们的容器拥有。
- en: Before you work with real software, the next section details the typical workflow
    with a “Hello, World” example.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您开始处理真实软件之前，下一节将详细说明使用“Hello, World”示例的典型工作流程。
- en: 7.1.1\. Packaging “Hello, World”
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.1\. 打包“Hello, World”
- en: The basic workflow for building an image from a container includes three steps.
    First, you create a container from an existing image. You choose the image based
    on what you want to be included with the new finished image and the tools you
    need to make the changes.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从容器构建镜像的基本工作流程包括三个步骤。首先，您从现有镜像创建一个容器。您根据希望包含在新完成的镜像中的内容以及您需要用于更改的工具来选择镜像。
- en: The second step is to modify the filesystem of the container. These changes
    will be written to a new layer of the container’s union filesystem. We’ll revisit
    the relationship between images, layers, and repositories later in this chapter.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二步是修改容器的文件系统。这些更改将被写入容器联合文件系统的新层。我们将在本章后面重新探讨镜像、层和仓库之间的关系。
- en: Once the changes have been made, the last step is to commit those changes. Then
    you’ll be able to create new containers from the resulting image. [Figure 7.1](#filepos671609)
    illustrates this workflow.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦进行了更改，最后一步就是提交这些更改。然后您将能够从生成的镜像创建新的容器。[图7.1](#filepos671609)展示了这个工作流程。
- en: Figure 7.1\. Building an image from a container
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.1\. 从容器构建镜像
- en: '![](images/00036.jpg)'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00036.jpg)'
- en: 'With these steps in mind, work through the following commands to create a new
    image named `hw_image`:'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在考虑这些步骤的基础上，执行以下命令以创建一个名为`hw_image`的新镜像：
- en: '`docker container run --name hw_container \     ubuntu:latest \     touch /HelloWorld`
    `1` `docker container commit hw_container hw_image` `2` `docker container rm -vf
    hw_container` `3` `docker container run --rm \     hw_image \     ls -l /HelloWorld`
    `4`'
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name hw_container \ ubuntu:latest \ touch /HelloWorld`
    `1` `docker container commit hw_container hw_image` `2` `docker container rm -vf
    hw_container` `3` `docker container run --rm \ hw_image \ ls -l /HelloWorld` `4`'
- en: 1 Modifies file in container
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 修改容器中的文件
- en: 2 Commits change to new image
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将更改提交到新镜像
- en: 3 Removes changed container
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 删除已更改的容器
- en: 4 Examines file in new container
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 检查新容器中的文件
- en: If that seems stunningly simple, you should know that it does become a bit more
    nuanced as the images you produce become more sophisticated, but the basic steps
    will always be the same. Now that you have an idea of the workflow, you should
    try to build a new image with real software. In this case, you’ll be packaging
    a program called Git.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这看起来非常简单，你应该知道，随着你生成的镜像变得更加复杂，这个过程确实会变得稍微复杂一些，但基本步骤始终是相同的。现在你已经对工作流程有了概念，你应该尝试使用真实软件构建一个新的镜像。在这种情况下，你将打包一个名为
    Git 的程序。
- en: 7.1.2\. Preparing packaging for Git
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.2. 准备Git打包
- en: Git is a popular, distributed version-control tool. Whole books have been written
    about the topic. If you’re unfamiliar with it, we recommend that you spend some
    time learning how to use Git. At the moment, though, you need to know only that
    it’s a program you’re going to install onto an Ubuntu image.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Git是一个流行的分布式版本控制工具。关于这个主题已经写了很多本书。如果你不熟悉它，我们建议你花些时间学习如何使用 Git。不过，目前你只需要知道它是一个你将要安装到Ubuntu镜像中的程序。
- en: 'To get started building your own image, the first thing you’ll need is a container
    created from an appropriate base image:'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要开始构建你自己的镜像，你需要首先从一个合适的基镜像创建一个容器：
- en: '`docker container run -it --name image-dev ubuntu:latest /bin/bash`'
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -it --name image-dev ubuntu:latest /bin/bash`'
- en: 'This will start a new container running the bash shell. From this prompt, you
    can issue commands to customize your container. Ubuntu ships with a Linux tool
    for software installation called `apt-get`. This will come in handy for acquiring
    the software that you want to package in a Docker image. You should now have an
    interactive shell running with your container. Next, you need to install Git in
    the container. Do that by running the following commands:'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将启动一个新的容器，运行 bash shell。从这个提示符开始，你可以发出命令来自定义你的容器。Ubuntu 随带了一个名为 `apt-get` 的
    Linux 工具，用于软件安装。这对于获取你想要打包到 Docker 镜像中的软件非常有用。现在你应该有一个交互式 shell 在你的容器中运行。接下来，你需要在这个容器中安装
    Git。通过运行以下命令来完成：
- en: '`apt-get update apt-get -y install git`'
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`apt-get update apt-get -y install git`'
- en: 'This will tell APT to download and install Git and all its dependencies on
    the container’s filesystem. When it’s finished, you can test the installation
    by running the `git` program:'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将告诉 APT 在容器的文件系统中下载并安装 Git 及其所有依赖项。完成后，你可以通过运行 `git` 程序来测试安装：
- en: '`git version # Output something like: # git version 2.7.4`'
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`git version # 输出类似：# git version 2.7.4`'
- en: Package tools like `apt-get` make installing and uninstalling software easier
    than if you had to do everything by hand. But they provide no isolation to that
    software, and dependency conflicts often occur. You can be sure that other software
    you install outside this container won’t impact the version of Git you have installed
    in this container.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含 `apt-get` 这样的包管理工具使得安装和卸载软件比手动操作要容易得多。但它们并没有为该软件提供隔离，并且依赖冲突经常发生。你可以确信，在这个容器外部安装的其他软件不会影响你在容器内安装的
    Git 版本。
- en: 'Now that Git has been installed on your Ubuntu container, you can simply exit
    the container:'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在Git已经安装在你的Ubuntu容器中，你可以简单地退出容器：
- en: '`exit`'
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exit`'
- en: The container should be stopped but still present on your computer. Git has
    been installed in a new layer on top of the `ubuntu:latest` image. If you were
    to walk away from this example right now and return a few days later, how would
    you know exactly what changes were made? When you’re packaging software, it’s
    often useful to review the list of files that have been modified in a container,
    and Docker has a command for that.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器应该已经停止，但仍然存在于你的电脑上。Git 已经在 `ubuntu:latest` 镜像的新层上安装。如果你现在离开这个例子，几天后再回来，你将如何知道确切发生了哪些更改？在打包软件时，审查容器中修改的文件列表通常非常有用，而Docker有一个用于此的命令。
- en: 7.1.3\. Reviewing filesystem changes
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.3. 审查文件系统更改
- en: 'Docker has a command that shows you all the filesystem changes that have been
    made inside a container. These changes include added, changed, or deleted files
    and directories. To review the changes that you made when you used APT to install
    Git, run the `diff` subcommand:'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker有一个命令可以显示容器内部所做的所有文件系统更改。这些更改包括添加、更改或删除的文件和目录。要审查你使用 APT 安装 Git 时所做的更改，请运行
    `diff` 子命令：
- en: '`docker container diff image-dev` `1`'
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container diff image-dev` `1`'
- en: 1 Outputs a LONG list of file changes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输出文件更改的长列表
- en: 'Lines that start with an `A` are files that were added. Those starting with
    a `C` were changed. Finally, those with a `D` were deleted. Installing Git with
    APT in this way made several changes. For that reason, it might be better to see
    this at work with a few specific examples:'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以 `A` 开头的行表示添加了文件。以 `C` 开头的表示文件已更改。最后，以 `D` 开头的表示文件被删除。以这种方式使用 APT 安装 Git 导致了多项更改。因此，最好通过一些具体的例子来观察其工作情况：
- en: '`docker container run --name tweak-a busybox:latest touch /HelloWorld` `1`
    `docker container diff tweak-a # Output: #    A /HelloWorld  docker container
    run --name tweak-d busybox:latest rm /bin/vi` `2` `docker container diff tweak-d
    # Output: #    C /bin #    D /bin/vi  docker container run --name tweak-c busybox:latest
    touch /bin/vi` `3` `docker container diff tweak-c # Output: #    C /bin #    C
    /bin/busybox`'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name tweak-a busybox:latest touch /HelloWorld` `1`
    `docker container diff tweak-a # Output: #    A /HelloWorld` `2` `docker container
    run --name tweak-d busybox:latest rm /bin/vi` `3` `docker container diff tweak-d
    # Output: #    C /bin #    D /bin/vi` `4` `docker container run --name tweak-c
    busybox:latest touch /bin/vi` `5` `docker container diff tweak-c # Output: #   
    C /bin #    C /bin/busybox`'
- en: 1 Adds new file to busybox
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 向 busybox 添加新文件
- en: 2 Removes existing file from busybox
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 从 busybox 中删除现有文件
- en: 3 Changes existing file in busybox
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 在 busybox 中现有文件更改
- en: 'Always remember to clean up your workspace, like this:'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总是记得清理您的 workspace，如下所示：
- en: '`docker container rm -vf tweak-a docker container rm -vf tweak-d docker container
    rm -vf tweak-c`'
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container rm -vf tweak-a docker container rm -vf tweak-d docker container
    rm -vf tweak-c`'
- en: Now that you’ve seen the changes you’ve made to the filesystem, you’re ready
    to commit the changes to a new image. As with most other things, this involves
    a single command that does several things.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，您已经看到了对文件系统所做的更改，您准备将这些更改提交到一个新镜像中。与其他大多数事情一样，这涉及一个执行多项操作的单一命令。
- en: 7.1.4\. Committing a new image
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.4. 提交新镜像
- en: 'You use the `docker container commit` command to create an image from a modified
    container. It’s a best practice to use the `-a` flag that signs the image with
    an author string. You should also always use the `-m` flag, which sets a commit
    message. Create and sign a new image that you’ll name `ubuntu-git` from the `image-dev`
    container where you installed Git:'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用 `docker container commit` 命令从一个修改过的容器创建一个镜像。使用 `-a` 标志为镜像签名一个作者字符串是一个最佳实践。您还应该始终使用
    `-m` 标志，它设置了一个提交信息。从您安装 Git 的 `image-dev` 容器创建并签名一个名为 `ubuntu-git` 的新镜像：
- en: '`docker container commit -a "@dockerinaction" -m "Added git" \   image-dev
    ubuntu-git # Outputs a new unique image identifier like: # bbf1d5d430cdf541a72ad74dfa54f6faec41d2c1e4200778e9d4302035e5d143`'
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container commit -a "@dockerinaction" -m "Added git" \ image-dev ubuntu-git
    # 输出新的唯一镜像标识符，例如：# bbf1d5d430cdf541a72ad74dfa54f6faec41d2c1e4200778e9d4302035e5d143`'
- en: 'Once you’ve committed the image, it should show up in the list of images installed
    on your computer. Running `docker images` should include a line like this:'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦您提交了镜像，它应该出现在您计算机上安装的镜像列表中。运行 `docker images` 应该包括如下一行：
- en: '`REPOSITORY    TAG      IMAGE ID      CREATED        VIRTUAL SIZE ubuntu-git   
    latest   bbf1d5d430cd  5 seconds ago  248 MB`'
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`REPOSITORY    TAG      IMAGE ID      CREATED        VIRTUAL SIZE ubuntu-git   
    latest   bbf1d5d430cd  5 seconds ago  248 MB`'
- en: 'Make sure it works by testing Git in a container created from that image:'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保它正常工作，通过从该镜像创建的容器测试 Git：
- en: '`docker container run --rm ubuntu-git git version`'
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm ubuntu-git git version`'
- en: 'Now you’ve created a new image based on an Ubuntu image and installed Git.
    That’s a great start, but what do you think will happen if you omit the command
    override? Try it to find out:'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，您已经基于 Ubuntu 镜像创建了一个新镜像并安装了 Git。这是一个很好的开始，但您认为如果您省略了命令覆盖会发生什么？试一试来找出答案：
- en: '`docker container run --rm ubuntu-git`'
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm ubuntu-git`'
- en: Nothing appears to happen when you run that command. That’s because the command
    you started the original container with was committed with the new image. The
    command you used to start the container that the image was created by was `/bin/bash`.
    When you create a container from this image by using the default command, it will
    start a shell and immediately exit. That’s not a terribly useful default command.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您运行该命令时，似乎没有任何反应。这是因为您启动原始容器时使用的命令已经与新镜像一起提交。您用于启动创建该镜像的容器的命令是 `/bin/bash`。当您使用默认命令从这个镜像创建容器时，它将启动一个
    shell 并立即退出。这不是一个非常有用的默认命令。
- en: I doubt that any users of an image named `ubuntu-git` would expect that they’d
    need to manually invoke Git each time. It would be better to set an entrypoint
    on the image to `git`. An entrypoint is the program that will be executed when
    the container starts. If the entrypoint isn’t set, the default command will be
    executed directly. If the entrypoint is set, the default command and its arguments
    will be passed to the entrypoint as arguments.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我怀疑任何名为`ubuntu-git`的镜像的用户都不会期望每次都需要手动调用Git。最好在镜像上设置入口点为`git`。入口点是容器启动时将执行的程序。如果没有设置入口点，将直接执行默认命令。如果设置了入口点，默认命令及其参数将作为参数传递给入口点。
- en: 'To set the entrypoint, you need to create a new container with the `--entrypoint`
    flag set and create a new image from that container:'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要设置入口点，你需要创建一个新的容器，并设置`--entrypoint`标志，然后从该容器创建一个新的镜像：
- en: '`docker container run --name cmd-git --entrypoint git ubuntu-git` `1` `docker
    container commit -m "Set CMD git" \     -a "@dockerinaction" cmd-git ubuntu-git`
    `2` `docker container rm -vf cmd-git` `3` `docker container run --name cmd-git
    ubuntu-git version` `4`'
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name cmd-git --entrypoint git ubuntu-git` `1` `docker
    container commit -m "Set CMD git" \   -a "@dockerinaction" cmd-git ubuntu-git`
    `2` `docker container rm -vf cmd-git` `3` `docker container run --name cmd-git
    ubuntu-git version` `4`'
- en: 1 Shows standard git help and exit
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 显示标准git帮助并退出
- en: 2 Commits new image to same name
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将新镜像提交到相同名称
- en: 3 Cleanup
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 清理
- en: 4 Test
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 测试
- en: Now that the entrypoint has been set to `git`, users no longer need to type
    the command at the end. This might seem like a marginal savings with this example,
    but many tools that people use are not as succinct. Setting the entrypoint is
    just one thing you can do to make images easier for people to use and integrate
    into their projects.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在入口点已设置为`git`，用户不再需要输入命令。在这个例子中，这可能看起来节省不大，但许多人使用的工具并不那么简洁。设置入口点只是你可以做的使镜像更容易被用户使用并集成到他们的项目中的一件事。
- en: 7.1.5\. Configuring image attributes
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.5\. 配置镜像属性
- en: 'When you use `docker container commit`, you commit a new layer to an image.
    The filesystem snapshot isn’t the only thing included with this commit. Each layer
    also includes metadata describing the execution context. Of the parameters that
    can be set when a container is created, all the following will carry forward with
    an image created from the container:'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你使用`docker container commit`时，你将一个新的层提交到镜像中。文件系统快照并不是这个提交中唯一包含的东西。每一层还包括描述执行上下文的元数据。在创建容器时可以设置的参数中，以下所有参数都将随从容器创建的镜像一起传递：
- en: All environment variables
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有环境变量
- en: The working directory
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作目录
- en: The set of exposed ports
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露的端口集合
- en: All volume definitions
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有卷定义
- en: The container entrypoint
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器入口点
- en: Command and arguments
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令和参数
- en: 'If these values weren’t specifically set for the container, the values will
    be inherited from the original image. [Part 1](index_split_023.html#filepos151791)
    of this book covers each of these, so we won’t reintroduce them here. But it may
    be valuable to examine two detailed examples. First, consider a container that
    introduces two environment variable specializations:'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这些值没有为容器特别设置，它们将继承自原始镜像。[第1部分](index_split_023.html#filepos151791)的这本书涵盖了这些内容，所以我们在这里不会重新介绍它们。但是，检查两个详细示例可能很有价值。首先，考虑一个引入两个环境变量特殊化的容器：
- en: '`docker container run --name rich-image-example \     -e ENV_EXAMPLE1=Rich
    -e ENV_EXAMPLE2=Example \` `1` `busybox:latest  docker container commit rich-image-example
    rie` `2` `docker container run --rm rie \     /bin/sh -c "echo \$ENV_EXAMPLE1
    \$ENV_EXAMPLE2"` `3`'
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name rich-image-example \   -e ENV_EXAMPLE1=Rich -e
    ENV_EXAMPLE2=Example \` `1` `busybox:latest  docker container commit rich-image-example
    rie` `2` `docker container run --rm rie \   /bin/sh -c "echo \$ENV_EXAMPLE1 \$ENV_EXAMPLE2"`
    `3`'
- en: 1 Creates environment variable specialization
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建环境变量专业化
- en: 2 Commits image
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 提交镜像
- en: '3 Outputs: Rich Example'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 输出：丰富示例
- en: 'Next, consider a container that introduces an entrypoint and command specialization
    as a new layer on top of the previous example:'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，考虑一个在前面示例之上引入入口点和命令特殊化的容器：
- en: '`docker container run --name rich-image-example-2 \     --entrypoint "/bin/sh"
    \` `1` `rie \     -c "echo \$ENV_EXAMPLE1 \$ENV_EXAMPLE2"` `2` `docker container
    commit rich-image-example-2 rie` `3` `docker container run --rm rie` `4`'
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name rich-image-example-2 \   --entrypoint "/bin/sh"
    \` `1` `rie \   -c "echo \$ENV_EXAMPLE1 \$ENV_EXAMPLE2"` `2` `docker container
    commit rich-image-example-2 rie` `3` `docker container run --rm rie` `4`'
- en: 1 Sets default entrypoint
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置默认入口点
- en: 2 Sets default command
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 设置默认命令
- en: 3 Commits image
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 提交镜像
- en: 4 Different command with same output
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 使用相同输出的不同命令
- en: This example builds two additional layers on top of BusyBox. In neither case
    are files changed, but the behavior changes because the context metadata has been
    altered. These changes include two new environment variables in the first new
    layer. Those environment variables are clearly inherited by the second new layer,
    which sets the entrypoint and default command to display their values. The last
    command uses the final image without specifying any alternative behavior, but
    it’s clear that the previous defined behavior has been inherited.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此示例在 BusyBox 上构建了两个额外的层。在两种情况下都没有更改文件，但由于上下文元数据已更改，行为发生了变化。这些更改包括在第一个新层中添加两个新的环境变量。这些环境变量显然被第二个新层继承，该层设置入口点和默认命令以显示它们的值。最后一个命令使用最终镜像而不指定任何替代行为，但很明显，之前定义的行为已被继承。
- en: Now that you understand how to modify an image, take the time to dive deeper
    into the mechanics of images and layers. Doing so will help you produce high-quality
    images in real-world situations.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何修改镜像，花些时间深入了解镜像和层的机制。这样做将帮助你在实际情况下制作高质量的镜像。
- en: 7.2\. GOING DEEP ON DOCKER IMAGES AND LAYERS
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2\. 深入了解 Docker 镜像和层
- en: By this point in the chapter, you’ve built a few images. In those examples,
    you started by creating a container from an image such as `ubuntu:latest` or `busybox:latest`.
    Then you made changes to the filesystem or context within that container. Finally,
    everything seemed to just work when you used the `docker container commit` command
    to create a new image. Understanding how the container’s filesystem works and
    what the `docker container commit` command actually does will help you become
    a better image author. This section dives into that subject and demonstrates the
    impact to authors.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到此为止，你已经构建了一些镜像。在这些示例中，你首先从一个镜像（如 `ubuntu:latest` 或 `busybox:latest`）创建了一个容器。然后你在该容器内对文件系统或上下文进行了更改。最后，当你使用
    `docker container commit` 命令创建新镜像时，一切似乎都正常工作。了解容器文件系统的工作原理以及 `docker container
    commit` 命令实际上做什么将帮助你成为一个更好的镜像作者。本节深入探讨这个主题，并展示了它对作者的影响。
- en: 7.2.1\. Exploring union filesystems
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.1\. 探索联合文件系统
- en: 'Understanding the details of union filesystems is important for image authors
    for two reasons:'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于镜像作者来说，理解联合文件系统的细节非常重要，原因有两个：
- en: Authors need to know the impact that adding, changing, and deleting files have
    on resulting images.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者需要了解添加、更改和删除文件对结果镜像的影响。
- en: Authors need have a solid understanding of the relationship between layers and
    how layers relate to images, repositories, and tags.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者需要有一个坚实的理解，了解层与层之间的关系，以及层如何与镜像、存储库和标签相关联。
- en: 'Start by considering a simple example. Suppose you want to make a single change
    to an existing image. In this case, the image is `ubuntu:latest`, and you want
    to add a file named mychange to the root directory. You should use the following
    command to do this:'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，考虑一个简单的例子。假设你想要对现有的镜像进行单个更改。在这种情况下，镜像为 `ubuntu:latest`，你想要在根目录中添加一个名为 mychange
    的文件。你应该使用以下命令来完成此操作：
- en: '`docker container run --name mod_ubuntu ubuntu:latest touch /mychange`'
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name mod_ubuntu ubuntu:latest touch /mychange`'
- en: The resulting container (named `mod_ubuntu`) will be stopped but will have written
    that single change to its filesystem. As discussed in [chapters 3](index_split_032.html#filepos303917)
    and [4](index_split_037.html#filepos379268), the root filesystem is provided by
    the image that the container was started from. That filesystem is implemented
    with a union filesystem.
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成的容器（命名为 `mod_ubuntu`）将被停止，但会将其文件系统中的单个更改写入。如第 [3](index_split_032.html#filepos303917)
    章和 [4](index_split_037.html#filepos379268) 章所述，根文件系统由启动容器的镜像提供。该文件系统使用联合文件系统实现。
- en: A union filesystem is made up of layers. Each time a change is made to a union
    filesystem, that change is recorded on a new layer on top of all of the others.
    The union of all of those layers, or top-down view, is what the container (and
    user) sees when accessing the filesystem. [Figure 7.2](#filepos702111) illustrates
    the two perspectives for this example.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 联合文件系统由层组成。每次对联合文件系统进行更改时，该更改都会记录在所有其他层之上的新层上。所有这些层的联合，或从上到下的视图，是容器（和用户）在访问文件系统时看到的。图
    [7.2](#filepos702111) 说明了此例的两个视角。
- en: Figure 7.2\. A simple file write example on a union filesystem from two perspectives
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 [7.2]\. 从两个视角看联合文件系统上的简单文件写入示例
- en: '![](images/00037.jpg)'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00037.jpg)'
- en: When you read a file from a union filesystem, that file will be read from the
    topmost layer where it exists. If a file was not created or changed on the top
    layer, the read will fall through the layers until it reaches a layer where that
    file does exist. This is illustrated in [figure 7.3](#filepos702967).
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您从联合文件系统读取文件时，该文件将从它存在的最顶层读取。如果一个文件在顶层没有被创建或更改，读取将穿过层直到它到达存在该文件的层。这如图[图7.3](#filepos702967)所示。
- en: Figure 7.3\. Reading files that are located on different layers
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.3\. 读取位于不同层的文件
- en: '![](images/00077.jpg)'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00077.jpg)'
- en: All this layer functionality is hidden by the union filesystem. No special actions
    need to be taken by the software running in a container to take advantage of these
    features. Understanding layers where files were added covers one of three types
    of filesystem writes. The other two are deletions and file changes.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有这些层功能都被联合文件系统隐藏。在容器中运行的软件无需采取特殊操作即可利用这些功能。理解文件添加的层涵盖了三种类型的文件系统写入之一。其他两种是删除和文件更改。
- en: 'Like additions, both file changes and deletions work by modifying the top layer.
    When a file is deleted, a delete record is written to the top layer, which hides
    any versions of that file on lower layers. When a file is changed, that change
    is written to the top layer, which again hides any versions of that file on lower
    layers. The changes made to the filesystem of a container are listed with the
    `docker container diff` command you used earlier in the chapter:'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与添加一样，文件更改和删除都是通过修改顶层来实现的。当文件被删除时，会在顶层写入删除记录，这会隐藏该文件在底层版本。当文件被更改时，更改会被写入顶层，这同样会隐藏该文件在底层版本。容器文件系统所做的更改可以通过您在章节中使用的
    `docker container diff` 命令列出：
- en: '`docker container diff mod_ubuntu`'
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container diff mod_ubuntu`'
- en: 'This command will produce the output:'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将生成以下输出：
- en: '`A /mychange`'
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`A /mychange`'
- en: 'The `A` in this case indicates that the file was added. Run the next two commands
    to see how a file deletion is recorded:'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，`A` 表示文件被添加。运行以下两个命令以查看文件删除是如何记录的：
- en: '`docker container run --name mod_busybox_delete busybox:latest rm /etc/passwd
    docker container diff mod_busybox_delete`'
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name mod_busybox_delete busybox:latest rm /etc/passwd
    docker container diff mod_busybox_delete`'
- en: 'This time, the output will have two rows:'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这次，输出将包含两行：
- en: '`C /etc D /etc/passwd`'
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`C /etc D /etc/passwd`'
- en: 'The `D` indicates a deletion, but this time the parent folder of the file is
    also included. The `C` indicates that it was changed. The next two commands demonstrate
    a file change:'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`D` 表示删除，但这次还包括文件的父文件夹。`C` 表示它已被更改。以下两个命令演示了文件更改：'
- en: '`docker container run --name mod_busybox_change busybox:latest touch \     
    /etc/passwd docker container diff mod_busybox_change`'
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name mod_busybox_change busybox:latest touch \ /etc/passwd
    docker container diff mod_busybox_change`'
- en: 'The `diff` subcommand will show two changes:'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`diff` 子命令将显示两个更改：'
- en: '`C /etc C /etc/passwd`'
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`C /etc C /etc/passwd`'
- en: Again, the `C` indicates a change, and the two items are the file and the folder
    where it’s located. If a file nested five levels deep were changed, there would
    be a line for each level of the tree.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次强调，`C` 表示一个变化，这两个项目是文件及其所在文件夹。如果嵌套五层深度的文件被更改，则树中的每一层都会有一行。
- en: Changes to filesystem attributes such as file ownership and permissions are
    recorded in the same way as changes to files. Be careful when modifying filesystem
    attributes on large numbers of files, as those files will likely be copied into
    the layer performing the change. File-change mechanics are the most important
    thing to understand about union filesystems, and we will examine that a little
    deeper next.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文件系统属性（如文件所有权和权限）的更改与文件更改的记录方式相同。在大量文件上修改文件系统属性时要小心，因为这些文件可能会被复制到执行更改的层。理解层文件添加是了解联合文件系统最重要的内容之一，我们将在下一部分稍作深入探讨。
- en: Most union filesystems use something called copy-on-write, which is easier to
    understand if you think of it as copy-on-change. When a file in a read-only layer
    (not the top layer) is modified, the whole file is first copied from the read-only
    layer into the writable layer before the change is made. This has a negative impact
    on runtime performance and image size. [Section 7.2.3](#filepos720190) covers
    the way this should influence your image design.
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数联合文件系统使用一种称为写时复制（copy-on-write）的技术，如果你将其视为更改时复制，则更容易理解。当一个只读层（非顶层）中的文件被修改时，在做出更改之前，整个文件首先从只读层复制到可写层。这会对运行时性能和镜像大小产生负面影响。[第7.2.3节](#filepos720190)介绍了这种影响应该如何影响你的镜像设计。
- en: Take a moment to solidify your understanding of the system by examining how
    the more comprehensive set of scenarios is illustrated in [figure 7.4](#filepos709327).
    In this illustration, files are added, changed, deleted, and added again over
    a range of three layers.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请花一点时间，通过检查[图7.4](#filepos709327)中更全面的场景集来巩固你对系统的理解。在这个示例中，文件被添加、更改、删除，并在三个层次范围内再次添加。
- en: Figure 7.4\. Various file addition, change, and deletion combinations over a
    three-layered image
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.4. 在三层镜像上的各种文件添加、更改和删除组合
- en: '![](images/00045.jpg)'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00045.jpg)'
- en: Knowing how filesystem changes are recorded, you can begin to understand what
    happens when you use the `docker container commit` command to create a new image.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 了解文件系统更改是如何记录的，你就可以开始理解当你使用`docker container commit`命令创建新镜像时会发生什么。
- en: 7.2.2\. Reintroducing images, layers, repositories, and tags
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.2. 重新介绍镜像、层、仓库和标签
- en: You’ve created an image by using the `docker container commit` command, and
    you understand that it commits the top-layer changes to an image. But we’ve yet
    to define commit.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你通过使用`docker container commit`命令创建了一个镜像，并且你理解它将顶层更改提交到镜像中。但我们还没有定义提交。
- en: Remember, a union filesystem is made up of a stack of layers, and new layers
    are added to the top of the stack. Those layers are stored separately as collections
    of the changes made in that layer and metadata for that layer. When you commit
    a container’s changes to its filesystem, you’re saving a copy of that top layer
    in an identifiable way.
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，联合文件系统由一系列层组成，新层被添加到堆栈的顶部。这些层作为该层更改的集合及其元数据单独存储。当你将容器对文件系统的更改提交时，你以可识别的方式保存了该顶层的一个副本。
- en: When you commit the layer, a new ID is generated for it, and copies of all the
    file changes are saved. Exactly how this happens depends on the storage engine
    that’s being used on your system. It’s less important for you to understand the
    details than it is for you to understand the general approach. The metadata for
    a layer includes that generated identifier, the identifier of the layer below
    it (parent), and the execution context of the container that the layer was created
    from. Layer identities and metadata form the graph that Docker and the UFS use
    to construct images.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你提交一个层时，为其生成一个新的ID，并保存所有文件更改的副本。了解这一过程的具体细节不如了解一般方法重要。层的元数据包括生成的标识符、其下层的标识符（父层）以及从该层创建的容器的执行上下文。层标识符和元数据构成了Docker和UFS用来构建镜像的图。
- en: An image is the stack of layers that you get by starting with a given top layer
    and then following all the links defined by the parent ID in each layer’s metadata,
    as shown in [figure 7.5](#filepos712275).
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像是通过从给定的顶层开始，然后遵循每个层元数据中定义的父ID的所有链接得到的层堆栈。如图[图7.5](#filepos712275)所示。
- en: Figure 7.5\. An image is the collection of layers produced by traversing the
    parent graph from a top layer.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.5. 镜像是通过从顶层遍历父图产生的层集合。
- en: '![](images/00059.jpg)'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00059.jpg)'
- en: 'Images are stacks of layers constructed by traversing the layer dependency
    graph from a starting layer. The layer that the traversal starts from is the top
    of the stack. This means that a layer’s ID is also the ID of the image that it
    and its dependencies form. Take a moment to see this in action by committing the
    `mod_ubuntu` container you created earlier:'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像是通过遍历从起始层开始的层依赖图构建的层堆栈。遍历开始的层是堆栈的顶部。这意味着层的ID也是它及其依赖项形成的镜像的ID。花点时间看看你之前创建的`mod_ubuntu`容器提交时的实际效果：
- en: '`docker container commit mod_ubuntu`'
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container commit mod_ubuntu`'
- en: 'That `commit` subcommand will generate output that includes a new image ID
    like this:'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该`commit`子命令将生成包含类似以下新镜像ID的输出：
- en: '`6528255cda2f9774a11a6b82be46c86a66b5feff913f5bb3e09536a54b08234d`'
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`6528255cda2f9774a11a6b82be46c86a66b5feff913f5bb3e09536a54b08234d`'
- en: You can create a new container from this image by using the image ID as it’s
    presented to you. Like containers, layer IDs are large hexadecimal numbers that
    can be difficult for a person to work with directly. For that reason, Docker provides
    repositories.
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用显示给您的镜像ID创建一个新的容器。与容器一样，层ID是难以直接处理的大十六进制数字。因此，Docker提供了仓库。
- en: 'In [chapter 3](index_split_032.html#filepos303917), a repository is roughly
    defined as a named bucket of images. More specifically, repositories are location/name
    pairs that point to a set of specific layer identifiers. Each repository contains
    at least one tag that points to a specific layer identifier and thus the image
    definition. Let’s revisit the example used in [chapter 3](index_split_032.html#filepos303917):'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[第3章](index_split_032.html#filepos303917)中，仓库被粗略地定义为图像的命名桶。更具体地说，仓库是位置/名称对，指向一组特定的层标识符。每个仓库至少包含一个指向特定层标识符的标签，从而定义了镜像。让我们回顾一下[第3章](index_split_032.html#filepos303917)中使用的示例：
- en: '![](images/00039.jpg)'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00039.jpg)'
- en: 'This repository is located in the Docker Hub registry, but we have used the
    fully qualified registry hostname, `docker.io`. It’s named for the user (`dockerinaction`)
    and a unique short name (`ch3_hello_registry`). If you pull this repository without
    specifying a tag, Docker will try to pull an image tagged with `latest`. You can
    pull all tagged images in a repository by adding the `--all-tags` option to your
    pull command. In this example, there’s only one tag: `latest`. That tag points
    to a layer with the short form ID `4203899414c0`, as illustrated in [figure 7.6](#filepos716824).'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个仓库位于Docker Hub注册表中，但我们使用了完全限定的注册表主机名`docker.io`。它以用户名（`dockerinaction`）和一个独特的简短名称（`ch3_hello_registry`）命名。如果您不指定标签而拉取此仓库，Docker将尝试拉取标记为`latest`的镜像。您可以通过在拉取命令中添加`--all-tags`选项来拉取仓库中的所有标记镜像。在这个例子中，只有一个标签：`latest`。该标签指向具有短形式ID
    `4203899414c0`的层，如图7.6所示。
- en: Figure 7.6\. A visual representation of repositories
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.6\. 仓库的视觉表示
- en: '![](images/00010.jpg)'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00010.jpg)'
- en: 'Repositories and tags are created with the `docker tag`, `docker container
    commit`, or `docker build` commands. Revisit the `mod_ubuntu` container again
    and put it into a repository with a tag:'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`docker tag`、`docker container commit`或`docker build`命令创建仓库和标签。再次查看`mod_ubuntu`容器，并将其与标签一起放入仓库中：
- en: '`docker container commit mod_ubuntu myuser/myfirstrepo:mytag # Outputs: # 82ec7d2c57952bf57ab1ffdf40d5374c4c68228e3e923633734e68a11f9a2b59`'
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container commit mod_ubuntu myuser/myfirstrepo:mytag # 输出：# 82ec7d2c57952bf57ab1ffdf40d5374c4c68228e3e923633734e68a11f9a2b59`'
- en: 'The generated ID that’s displayed will be different because another copy of
    the layer was created. With this new friendly name, creating containers from your
    images requires little effort. If you want to copy an image, you need only to
    create a new tag or repository from the existing one. You can do that with the
    `docker tag` command. Every repository contains a `latest` tag by default. That
    will be used if the tag is omitted, as in the previous command:'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显示的ID将不同，因为创建了层的另一个副本。使用这个新的友好名称，从您的镜像创建容器需要很少的努力。如果您想复制一个镜像，您只需从现有的镜像创建一个新的标签或仓库。您可以使用`docker
    tag`命令做到这一点。每个仓库默认都包含一个`latest`标签。如果省略了标签，将使用该标签，如前一个命令所示：
- en: '`docker tag myuser/myfirstrepo:mytag myuser/mod_ubuntu`'
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker tag myuser/myfirstrepo:mytag myuser/mod_ubuntu`'
- en: By this point, you should have a strong understanding of basic UFS fundamentals
    as well as how Docker creates and manages layers, images, and repositories. With
    these in mind, let’s consider how they might impact image design.
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对基本的UFS基础知识和Docker如何创建和管理层、镜像和仓库有了深刻的理解。考虑到这些，让我们考虑它们可能对镜像设计产生的影响。
- en: All layers below the writable layer created for a container are immutable, meaning
    they can never be modified. This property makes it possible to share access to
    images instead of creating independent copies for every container. It also makes
    individual layers highly reusable. The other side of this property is that any
    time you make changes to an image, you need to add a new layer, and old layers
    are never removed. Knowing that images will inevitably need to change, you need
    to be aware of any image limitations and keep in mind how changes impact image
    size.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为容器创建的可写层下面的所有层都是不可变的，这意味着它们永远不能被修改。这个特性使得可以共享对镜像的访问，而不是为每个容器创建独立的副本。这也使得单个层非常易于重用。这个特性的另一方面是，每次你对镜像进行更改时，都需要添加一个新的层，而旧的层永远不会被删除。既然知道镜像不可避免地需要更改，就需要了解任何镜像的限制，并记住更改如何影响镜像大小。
- en: 7.2.3\. Managing image size and layer limits
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.3. 管理镜像大小和层限制
- en: 'If images evolved in the same way that most people manage their filesystems,
    Docker images would quickly become unusable. For example, suppose you want to
    make a different version of the `ubuntu-git` image you created earlier in this
    chapter. It may seem natural to modify that `ubuntu-git` image. Before you do,
    create a new tag for your `ubuntu-git` image. You’ll be reassigning the latest
    tag:'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果镜像像大多数人管理文件系统一样发展，Docker 镜像很快就会变得不可用。例如，假设你想要制作本章前面创建的 `ubuntu-git` 镜像的不同版本。修改那个
    `ubuntu-git` 镜像可能看起来很自然。在你这样做之前，为你的 `ubuntu-git` 镜像创建一个新的标签。你将重新分配最新标签：
- en: '`docker image tag ubuntu-git:latest ubuntu-git:2.7` `1`'
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image tag ubuntu-git:latest ubuntu-git:2.7` `1`'
- en: '1 Creates new tag: 2.7'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建新标签：2.7
- en: 'The first thing you’ll do in building your new image is remove the version
    of Git you installed:'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建新镜像时，你首先会移除你安装的 Git 版本：
- en: '`docker container run --name image-dev2 \         --entrypoint /bin/bash \`
    `1` `ubuntu-git:latest -c "apt-get remove -y git"` `2` `docker container commit
    image-dev2 ubuntu-git:removed` `3` `docker image tag ubuntu-git:removed ubuntu-git:latest`
    `4` `docker image ls` `5`'
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name image-dev2 \   --entrypoint /bin/bash \` `1` `ubuntu-git:latest
    -c "apt-get remove -y git"` `2` `docker container commit image-dev2 ubuntu-git:removed`
    `3` `docker image tag ubuntu-git:removed ubuntu-git:latest` `4` `docker image
    ls` `5`'
- en: 1 Executes bash command
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 执行 bash 命令
- en: 2 Removes Git
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 移除 Git
- en: 3 Commits image
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 提交镜像
- en: 4 Reassigns latest tag
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 重新分配最新标签
- en: 5 Examines image sizes
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 检查镜像大小
- en: 'The image list and sizes reported will look something like the following:'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 报告的镜像列表和大小看起来可能如下所示：
- en: '`REPOSITORY   TAG        IMAGE ID        CREATED           VIRTUAL SIZE ubuntu-git  
    latest     826c66145a59    10 seconds ago    226.6 MB ubuntu-git   removed   
    826c66145a59    10 seconds ago    226.6 MB ubuntu-git   2.7        3e356394c14e   
    41 hours ago      226 MB ...`'
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`REPOSITORY   TAG        IMAGE ID        CREATED           VIRTUAL SIZE ubuntu-git  
    latest     826c66145a59    10 seconds ago    226.6 MB ubuntu-git   removed   
    826c66145a59    10 seconds ago    226.6 MB ubuntu-git   2.7        3e356394c14e   
    41 hours ago      226 MB ...`'
- en: Notice that even though you removed Git, the image actually increased in size.
    Although you could examine the specific changes with `docker container diff`,
    you should be quick to realize that the reason for the increase has to do with
    the union filesystem.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，即使你移除了 Git，镜像的实际大小实际上增加了。虽然你可以使用 `docker container diff` 来检查具体的变化，但你应该迅速意识到增加的原因与联合文件系统有关。
- en: Remember, UFS will mark a file as deleted by actually adding a file to the top
    layer. The original file and any copies that existed in other layers will still
    be present in the image. It’s important to minimize image size for the sake of
    the people and systems that will be consuming your images. If you can avoid causing
    long download times and significant disk usage with smart image creation, your
    consumers will benefit. In the early days of Docker, image authors sometimes minimized
    the number of layers in an image because of the limits of image storage drivers.
    Modern Docker image storage drivers do not have image layer limits that normal
    users will encounter, so design for other attributes such as size and cacheability.
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，UFS 会通过实际上向顶层添加文件来标记文件为已删除。原始文件和存在于其他层的任何副本仍然存在于镜像中。为了使将消费你的镜像的人和系统受益，最小化镜像大小是很重要的。如果你可以通过智能创建镜像来避免造成长时间的下载时间和显著的磁盘使用，你的消费者将受益。在
    Docker 的早期阶段，镜像作者有时会最小化镜像中的层数，因为镜像存储驱动程序的限制。现代 Docker 镜像存储驱动程序没有普通用户会遇到的镜像层限制，因此设计时考虑其他属性，如大小和缓存性。
- en: 'You can examine all the layers in an image by using the `docker image history`
    command. It will display the following:'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以使用`docker image history`命令检查镜像中的所有层。它将显示以下内容：
- en: Abbreviated layer ID
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的层ID
- en: Age of the layer
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层的年龄
- en: Initial command of the creating container
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建容器的初始命令
- en: Total file size of that layer
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那一层的总文件大小
- en: 'By examining the history of the `ubuntu-git:removed` image, you can see that
    three layers have already been added on the top of the original `ubuntu:latest`
    image:'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过检查`ubuntu-git:removed`镜像的历史，你可以看到已经在原始`ubuntu:latest`镜像的顶部添加了三个层：
- en: '`docker image history ubuntu-git:removed`'
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image history ubuntu-git:removed`'
- en: 'Outputs are something like this:'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出类似于以下内容：
- en: '`IMAGE          CREATED          CREATED BY                    SIZE 826c66145a59  
    24 minutes ago   /bin/bash -c apt-get remove   662 kB 3e356394c14e   42 hours
    ago     git                           0 B bbf1d5d430cd   42 hours ago     /bin/bash                    
    37.68 MB b39b81afc8ca   3 months ago     /bin/sh -c #(nop) CMD [/bin   0 B 615c102e2290  
    3 months ago     /bin/sh -c sed -i ''s/^#\s*\   1.895 kB 837339b91538   3 months
    ago     /bin/sh -c echo ''#!/bin/sh''   194.5 kB 53f858aaaf03   3 months ago    
    /bin/sh -c #(nop) ADD file:   188.1 MB 511136ea3c5a   22 months ago                                 
    0 B`'
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`IMAGE          CREATED          CREATED BY                    SIZE 826c66145a59  
    24分钟前   /bin/bash -c apt-get remove   662 kB 3e356394c14e   42小时前     git                          
    0 B bbf1d5d430cd   42小时前     /bin/bash                     37.68 MB b39b81afc8ca  
    3个月前     /bin/sh -c #(nop) CMD [/bin   0 B 615c102e2290   3个月前     /bin/sh -c
    sed -i ''s/^#\s*\   1.895 kB 837339b91538   3个月前     /bin/sh -c echo ''#!/bin/sh''  
    194.5 kB 53f858aaaf03   3个月前     /bin/sh -c #(nop) ADD file:   188.1 MB 511136ea3c5a  
    22个月前                                  0 B`'
- en: You can flatten images by saving the image to a TAR file with `docker image
    save`, and then importing the contents of that filesystem back into Docker with
    `docker image import`. But that’s a bad idea, because you lose the original image’s
    metadata, its change history, and any savings customers might get when they download
    images with the same lower levels. The smarter thing to do in this case is to
    create a branch.
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以通过使用`docker image save`将镜像保存为TAR文件来扁平化镜像，然后使用`docker image import`将那个文件系统的内容导入Docker。但这不是一个好主意，因为你将丢失原始镜像的元数据、变更历史以及当客户下载具有相同底层版本的镜像时可能获得的任何节省。在这种情况下，更明智的做法是创建一个分支。
- en: Instead of fighting the layer system, you can solve both the size and layer
    growth problems by using the layer system to create branches. The layer system
    makes it trivial to go back in the history of an image and make a new branch.
    You are potentially creating a new branch every time you create a container from
    the same image.
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是与层系统作斗争，你可以通过使用层系统创建分支来解决大小和层增长问题。层系统使得回溯镜像的历史并创建新的分支变得非常简单。每次从相同的镜像创建容器时，你都有可能创建一个新的分支。
- en: In reconsidering your strategy for your new `ubuntu-git` image, you should simply
    start from `ubuntu:latest` again. With a fresh container from `ubuntu:latest`,
    you could install whatever version of Git you want. The result would be that both
    the original `ubuntu-git` image you created and the new one would share the same
    parent, and the new image wouldn’t have any of the baggage of unrelated changes.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在重新考虑你的新`ubuntu-git`镜像策略时，你应该简单地再次从`ubuntu:latest`开始。使用从`ubuntu:latest`的新鲜容器，你可以安装你想要的任何版本的Git。结果是，你创建的原始`ubuntu-git`镜像和新的镜像将共享相同的父镜像，并且新的镜像不会携带任何无关变更的负担。
- en: Branching increases the likelihood that you’ll need to repeat steps that were
    accomplished in peer branches. Doing that work by hand is prone to error. Automating
    image builds with Dockerfiles is a better idea.
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分支增加了你需要重复在同级分支中完成步骤的可能性。手动完成这项工作容易出错。使用Dockerfile自动化镜像构建是一个更好的主意。
- en: Occasionally, the need arises to build a full image from scratch. Docker provides
    special handling for the `scratch` image that tells the build process to make
    the next command the first layer of the resulting image. This practice can be
    beneficial if your goal is to keep images small and if you’re working with technologies
    that have few dependencies such as the Go or Rust programming languages. Other
    times, you may want to flatten an image to trim an image’s history. In either
    case, you need a way to import and export full filesystems.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时需要从头开始构建一个完整的镜像。Docker为`scratch`镜像提供了特殊的处理，这告诉构建过程将下一个命令作为结果的第一个层。如果你的目标是保持镜像小，并且你正在使用依赖项很少的技术，如Go或Rust编程语言，这种做法可能是有益的。在其他时候，你可能想将镜像扁平化以修剪镜像的历史。在两种情况下，你需要一种导入和导出完整文件系统的方法。
- en: 7.3\. EXPORTING AND IMPORTING FLAT FILESYSTEMS
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.3\. 导出和导入扁平文件系统
- en: On some occasions, it’s advantageous to build images by working with the files
    destined for an image outside the context of the union filesystem or a container.
    To fill this need, Docker provides two commands for exporting and importing archives
    of files.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在某些情况下，通过在联合文件系统或容器上下文之外处理用于镜像的文件来构建镜像是有利的。为了满足这一需求，Docker提供了两个命令用于导出和导入文件的归档。
- en: The `docker container export` command will stream the full contents of the flattened
    union filesystem to stdout or an output file as a tarball. The result is a tarball
    that contains all the files from the container perspective. This can be useful
    if you need to use the filesystem that was shipped with an image outside the context
    of a container. You can use the `docker cp` command for this purpose, but if you
    need several files, exporting the full filesystem may be more direct.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container export`命令会将扁平化联合文件系统的全部内容以tar包的形式输出到stdout或输出文件。结果是包含容器视角下所有文件的tar包。如果你需要在容器上下文之外使用与镜像一起提供的文件系统，这可能很有用。你可以使用`docker
    cp`命令来做到这一点，但如果需要多个文件，导出整个文件系统可能更直接。'
- en: 'Create a new container and use the `export` subcommand to get a flattened copy
    of its filesystem:'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个新的容器并使用`export`子命令来获取其文件系统的扁平化副本：
- en: '`docker container create --name export-test \    dockerinaction/ch7_packed:latest
    ./echo For Export` `1` `docker container export --output contents.tar export-test  docker
    container rm export-test  tar -tf contents.tar` `2`'
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container create --name export-test \  '
- en: 1 Exports filesystem contents
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 导出文件系统内容
- en: 2 Shows archive contents
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 显示归档内容
- en: 'This will produce a file in the current directory named contents.tar. That
    file should contain two files from the `ch7_packed` image: message.txt and folder/message.txt.
    At this point, you could extract, examine, or change those files to whatever end.
    The archive will also contain some zero-byte files related to devices and files
    that Docker manages for every container such as /etc/resolv.conf. You can ignore
    these. If you had omitted the `--output` (or `-o` for short), then the contents
    of the filesystem would be streamed in tarball format to stdout. Streaming the
    contents to stdout makes the `export` command useful for chaining with other shell
    programs that work with tarballs.'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将在当前目录中生成一个名为contents.tar的文件。该文件应包含来自`ch7_packed`镜像的两个文件：message.txt和folder/message.txt。在此阶段，你可以提取、检查或更改这些文件以实现任何目的。归档还将包含一些与设备相关的零字节文件以及Docker为每个容器管理的文件，如/etc/resolv.conf。你可以忽略这些文件。如果你省略了`--output`（或简写为`-o`），那么文件系统的内容将以tar包格式流式传输到stdout。将内容流式传输到stdout使得`export`命令可以与其他处理tar包的shell程序链式使用。
- en: The `docker import` command will stream the content of a tarball into a new
    image. The `import` command recognizes several compressed and uncompressed forms
    of tarballs. An optional Dockerfile instruction can also be applied during filesystem
    import. Importing filesystems is a simple way to get a complete minimum set of
    files into an image.
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker import`命令会将tar包的内容流式传输到一个新镜像中。`import`命令识别几种压缩和非压缩的tar包形式。在文件系统导入期间还可以应用可选的Dockerfile指令。导入文件系统是获取完整最小文件集到镜像的简单方法。'
- en: 'To see how useful this is, consider a statically linked Go version of “Hello,
    World.” Create an empty folder and copy the following code into a new file named
    helloworld.go:'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了了解这有多有用，考虑一个静态链接的“Hello, World.” Go版本。创建一个空文件夹并将以下代码复制到一个名为helloworld.go的新文件中：
- en: '`package main import "fmt" func main() {         fmt.Println("hello, world!")
    }`'
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`package main import "fmt" func main() {         fmt.Println("hello, world!")
    }`'
- en: 'You may not have Go installed on your computer, but that’s no problem for a
    Docker user. By running the next command, Docker will pull an image containing
    the Go compiler, compile and statically link the code (which means it can run
    all by itself), and place that program back into your folder:'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能没有在电脑上安装Go，但对于Docker用户来说这并不是问题。通过运行下一个命令，Docker将拉取包含Go编译器的镜像，编译并静态链接代码（这意味着它可以独立运行），并将该程序放回你的文件夹中：
- en: '`docker container run --rm -v "$(pwd)":/usr/src/hello \     -w /usr/src/hello
    golang:1.9 go build -v`'
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -v "$(pwd)":/usr/src/hello \  '
- en: 'If everything works correctly, you should have an executable program (binary
    file) in the same folder, named hello. Statically linked programs have no external
    file dependencies at runtime. That means this statically linked version of “Hello,
    World” can run in a container with no other files. The next step is to put that
    program in a tarball:'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该在同一文件夹中有一个可执行的程序（二进制文件），命名为hello。静态链接的程序在运行时没有外部文件依赖。这意味着这个静态链接版本的“Hello,
    World”可以在没有其他文件的容器中运行。下一步是将这个程序放入一个tar包中：
- en: '`tar -cf static_hello.tar hello`'
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`tar -cf static_hello.tar hello`'
- en: 'Now that the program has been packaged in a tarball, you can import it by using
    the `docker import` command:'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在程序已经被打包成tar包，你可以使用`docker import`命令来导入它：
- en: '`docker import -c "ENTRYPOINT [\"/hello\"]"` `-` `\     dockerinaction/ch7_static
    < static_hello.tar` `1`'
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker import -c "ENTRYPOINT [\"/hello\"]"` `-` `\ dockerinaction/ch7_static
    < static_hello.tar` `1`'
- en: 1 Tar file streamed via UNIX pipe
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 通过UNIX管道流式传输的tar文件
- en: In this command, you use the `-c` flag to specify a Dockerfile command. The
    command you use sets the entrypoint for the new image. The exact syntax of the
    Dockerfile command is covered in [chapter 8](index_split_069.html#filepos755104).
    The more interesting argument on this command is the hyphen (`-`)at the end of
    the first line. This hyphen indicates that the contents of the tarball will be
    streamed through stdin. You can specify a URL at this position if you’re fetching
    the file from a remote web server instead of from your local filesystem.
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个命令中，你使用`-c`标志来指定Dockerfile命令。你使用的命令设置了新镜像的入口点。Dockerfile命令的确切语法在[第8章](index_split_069.html#filepos755104)中有介绍。这个命令中更有趣的参数是第一行末尾的连字符（`-`）。这个连字符表示tar包的内容将通过stdin流式传输。如果你是从远程Web服务器而不是本地文件系统获取文件，你可以在这个位置指定一个URL。
- en: 'You tagged the resulting image as the `dockerinaction/ch7_static` repository.
    Take a moment to explore the results:'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你将生成的镜像标记为`dockerinaction/ch7_static`仓库。花点时间探索一下结果：
- en: '`docker container run dockerinaction/ch7_static` `1` `docker history dockerinaction/ch7_static`'
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run dockerinaction/ch7_static` `1` `docker history dockerinaction/ch7_static`'
- en: '1 Outputs: hello, world!'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输出：hello, world!
- en: 'You’ll notice that the history for this image has only a single entry (and
    layer):'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你会注意到这个镜像的历史记录只有一个条目（和层）：
- en: '`IMAGE           CREATED         CREATED BY     SIZE edafbd4a0ac5    11 minutes
    ago                 1.824 MB`'
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`IMAGE           CREATED         CREATED BY     SIZE edafbd4a0ac5    11 minutes
    ago                 1.824 MB`'
- en: In this case, the image you produced was small for two reasons. First, the program
    you produced was only just over 1.8 MB, and you included no operating system files
    or support programs. This is a minimalistic image. Second, there’s only one layer.
    There are no deleted or unused files carried with the image in lower layers. The
    downside to using single-layer (or flat) images is that your system won’t benefit
    from layer reuse. That might not be a problem if all your images are small enough.
    But the overhead may be significant if you use larger stacks or languages that
    don’t offer static linking.
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，你生成的镜像很小有两个原因。首先，你生成的程序只有1.8 MB多一点，你没有包含操作系统文件或支持程序。这是一个极简主义镜像。其次，只有一个层。在底层没有携带被删除或未使用的文件。使用单层（或扁平）镜像的缺点是，你的系统不会从层重用中受益。如果你的所有镜像都足够小，这可能不是问题。但如果你使用较大的堆栈或不支持静态链接的语言，开销可能会很大。
- en: There are trade-offs to every image design decision, including whether or not
    to use flat images. Regardless of the mechanism you use to build images, your
    users need a consistent and predictable way to identify different versions.
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个镜像设计决策都有权衡，包括是否使用扁平镜像。无论你使用什么机制来构建镜像，你的用户都需要一个一致且可预测的方式来识别不同的版本。
- en: 7.4\. VERSIONING BEST PRACTICES
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.4. 版本控制最佳实践
- en: Pragmatic versioning practices help users make the best use of images. The goal
    of an effective versioning scheme is to communicate clearly and provide flexibility
    to image users.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实用版本控制实践有助于用户充分利用镜像。有效版本控制方案的目标是清晰沟通并提供灵活性给镜像用户。
- en: It’s generally insufficient to build or maintain only a single version of your
    software unless it’s your first. If you’re releasing the first version of your
    software, you should be mindful of your users’ adoption experience from the beginning.
    Versions are important because they identify contracts your adopters depend on.
    Unexpected software changes cause problems for adopters, and versions are one
    of the primary ways to signal software changes.
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非是第一个版本，否则仅构建或维护单个版本的软件通常是不够的。如果你正在发布软件的第一个版本，你应该从一开始就关注用户的采用体验。版本很重要，因为它们标识了采用者所依赖的合同。意外的软件更改会给采用者带来问题，版本是表示软件更改的主要方式之一。
- en: With Docker, the key to maintaining multiple versions of the same software is
    proper repository tagging. The understanding that every repository contains multiple
    tags and that multiple tags can reference the same image is at the core of a pragmatic
    tagging scheme.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Docker，维护同一软件的多个版本的关键在于适当的仓库标签。理解每个仓库包含多个标签，并且多个标签可以引用相同的镜像，这是实用标签方案的核心。
- en: The `docker image tag` command is unlike the other two commands that can be
    used to create tags. It’s the only one that’s applied to existing images. To understand
    how to use tags and how they impact the user adoption experience, consider the
    two tagging schemes for a repository shown in [figure 7.7](#filepos745532).
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image tag`命令与其他两个可以用来创建标签的命令不同。它是唯一应用于现有镜像的命令。为了了解如何使用标签以及它们如何影响用户采用体验，请考虑[图7.7](#filepos745532)中显示的仓库的两个标签方案。'
- en: Figure 7.7\. Two tagging schemes (left and right) for the same repository with
    three images. Dotted lines represent old relationships between a tag and an image.
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.7\. 同一仓库中三个镜像的两个标签方案（左侧和右侧）。虚线表示标签和镜像之间的旧关系。
- en: '![](images/00005.jpg)'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00005.jpg)'
- en: There are two problems with the tagging scheme on the left side of [figure 7.7](#filepos745532).
    First, it provides poor adoption flexibility. A user can choose to declare a dependency
    on `1.9` or `latest`. When a user adopts version 1.9 and that implementation is
    actually 1.9.1, they may develop dependencies on behavior defined by that build
    version. Without a way to explicitly depend on that build version, they will experience
    pain when 1.9 is updated to point to 1.9.2\.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图7.7](#filepos745532)左侧的标签方案有两个问题。首先，它提供了较差的采用灵活性。用户可以选择声明对`1.9`或`latest`的依赖。当用户采用1.9版本而实际实现是1.9.1时，他们可能会对该构建版本定义的行为产生依赖。如果没有明确依赖该构建版本的方法，当1.9更新到指向1.9.2时，他们将会遇到痛苦。'
- en: The best way to eliminate this problem is to define and tag versions at a level
    where users can depend on consistent contracts. This is not advocating a three-tiered
    versioning system. It means only that the smallest unit of the versioning system
    you use captures the smallest unit of contract iteration. By providing multiple
    tags at this level, you can let users decide how much version drift they want
    to accept.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消除这个问题的最佳方法是定义和标记版本，让用户可以依赖一致的合同。这并不是提倡三层版本控制系统。这意味着你使用的版本系统中的最小单位只捕获合同迭代的最低单位。通过在这个级别提供多个标签，你可以让用户决定他们愿意接受多少版本漂移。
- en: Consider the right side of [figure 7.7](#filepos745532). A user who adopts version
    1 will always use the highest minor and build version under that major version.
    Adopting 1.9 will always use the highest build version for that minor version.
    Adopters who need to carefully migrate between versions of their dependencies
    can do so with control and at times of their choosing.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑[图7.7](#filepos745532)的右侧。采用版本1的用户将始终使用该主版本下的最高次小版本和构建版本。采用1.9将始终使用该次小版本的最高构建版本。需要仔细在不同版本的依赖项之间迁移的采用者可以在控制和选择的时间进行迁移。
- en: The second problem is related to the `latest` tag. On the left, `latest` currently
    points to an image that’s not otherwise tagged, so an adopter has no way of knowing
    what version of the software that is. In this case, it’s referring to a release
    candidate for the next major version of the software. An unsuspecting user may
    adopt the `latest` tag with the impression that it’s referring to the latest build
    of an otherwise tagged version.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个问题与`latest`标签相关。在左侧，`latest`当前指向一个未做其他标签的镜像，因此采用者无法知道这是哪个版本的软件。在这种情况下，它指的是软件下一个主要版本的候选发布版。一个未察觉的用户可能会采用`latest`标签，以为它指的是已标记版本的最新构建版本。
- en: The `latest` tag has other problems. It’s adopted more frequently than it should
    be. This happens because it’s the default tag. The impact is that a responsible
    repository maintainer should always make sure that its repository’s `latest` refers
    to the latest stable build of its software instead of the true latest.
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`latest` 标签存在其他问题。它被采用得比应有的频率更高。这是因为它是默认标签。影响是，有责任的仓库维护者应始终确保其仓库的 `latest`
    指向其软件的最新稳定构建，而不是真正的最新版本。'
- en: The last thing to keep in mind is that in the context of containers, you’re
    versioning not only your software but also a snapshot of all of your software’s
    packaged dependencies. For example, if you package software with a particular
    distribution of Linux, such as Debian, then those additional packages become part
    of your image’s interface contract. Your users will build tooling around your
    images and in some cases may come to depend on the presence of a particular shell
    or script in your image. If you suddenly rebase your software on something like
    CentOS but leave your software otherwise unchanged, your users will experience
    pain.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后要记住的是，在容器上下文中，你不仅对软件进行版本控制，还对软件所有打包依赖项的快照进行版本控制。例如，如果你使用特定的 Linux 发行版（如 Debian）打包软件，那么这些额外的包将成为你镜像接口合同的一部分。你的用户将围绕你的镜像构建工具，在某些情况下可能会依赖你镜像中存在特定的
    shell 或脚本。如果你突然将你的软件基于类似 CentOS 这样的平台，但其他方面软件保持不变，你的用户将感到痛苦。
- en: When software dependencies change, or the software needs to be distributed on
    top of multiple bases, then those dependencies should be included with your tagging
    scheme.
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当软件依赖项发生变化，或者软件需要基于多个基础进行分发时，这些依赖项应包含在你的标签方案中。
- en: 'The Docker official repositories are ideal examples to follow. Consider this
    abbreviated tag list for the official `golang` repository, where each row represents
    a distinct image:'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 官方仓库是理想的参考例子。考虑以下官方 `golang` 仓库的简略标签列表，其中每一行代表一个不同的镜像：
- en: '`1.9,             1.9-stretch, 1.9.6 1.9-alpine 1,               1.10,       
    1.10.2,          latest,    stretch 1.10-alpine,     alpine`'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1.9,             1.9-stretch, 1.9.6 1.9-alpine 1,               1.10,       
    1.10.2,          latest,    stretch 1.10-alpine,     alpine`'
- en: Users can determine that the latest version of Golang 1, 1.x, and 1.10 all currently
    point to version 1.10.2\. A Golang user can select a tag that meets their needs
    for tracking changes in Golang or the base operating system. If an adopter needs
    the latest image built on the `debian:stretch` platform, they can use the `stretch`
    tag. This scheme puts the control and responsibility for upgrades in the hands
    of your adopters.
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户可以确定 Golang 1、1.x 和 1.10 的最新版本目前都指向 1.10.2 版本。Golang 用户可以选择一个标签来跟踪 Golang
    或基础操作系统的更改。如果采用者需要基于 `debian:stretch` 平台构建的最新镜像，他们可以使用 `stretch` 标签。这种方案将升级的控制和责任交到采用者手中。
- en: SUMMARY
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This is the first chapter to cover the creation of Docker images, tag management,
    and other distribution concerns such as image size. Learning this material will
    help you build images and become a better consumer of images. The following are
    the key points in the chapter:'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是第一章节，涵盖了 Docker 镜像的创建、标签管理以及其他如镜像大小等分发问题。学习这些材料将帮助你构建镜像，并成为更好的镜像消费者。本章的关键点如下：
- en: New images are created when changes to a container are committed using the `docker
    container commit` command.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `docker container commit` 命令提交容器更改时，将创建新的镜像。
- en: When a container is committed, the configuration it was started with will be
    encoded into the configuration for the resulting image.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当容器被提交时，启动时使用的配置将被编码到生成的镜像的配置中。
- en: An image is a stack of layers that’s identified by its top layer.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像是一系列层，由其顶层来标识。
- en: An image’s size on disk is the sum of the sizes of its component layers.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像在磁盘上的大小是其组件层大小的总和。
- en: Images can be exported to and imported from a flat tarball representation by
    using the `docker container export` and `docker image import` commands.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `docker container export` 和 `docker image import` 命令将镜像导出为 flat tarball
    表示形式，并从中导入。
- en: The `docker image tag` command can be used to assign several tags to a single
    repository.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `docker image tag` 命令为单个仓库分配多个标签。
- en: Repository maintainers should keep pragmatic tags to ease user adoption and
    migration control.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库维护者应保持实用的标签，以简化用户的采用和迁移控制。
- en: Tag your latest stable build with the `latest` tag.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `latest` 标签标记最新的稳定构建。
- en: Provide fine-grained and overlapping tags so that adopters have control of the
    scope of their dependency version creep.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供细粒度和重叠的标签，以便采用者可以控制其依赖项版本爬升的范围。
- en: Chapter 8\. Building images automatically with Dockerfiles
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第8章\. 使用Dockerfile自动构建镜像
- en: This chapter covers
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Automated image packaging with Dockerfiles
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile进行自动化的镜像打包
- en: Metadata and filesystem instructions
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据和文件系统指令
- en: Creating maintainable image builds with arguments and multiple stages
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数和多个阶段创建可维护的镜像构建
- en: Packaging for multiprocess and durable containers
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多进程和耐用容器的包装
- en: Reducing the image attack surface and building trust
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少镜像攻击面和建立信任
- en: A Dockerfile is a text file that contains instructions for building an image.
    The Docker image builder executes the Dockerfile from top to bottom, and the instructions
    can configure or change anything about an image. Building images from Dockerfiles
    makes tasks like adding files to a container from your computer simple one-line
    instructions. Dockerfiles are the most common way to describe how to build a Docker
    image.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile是一个包含构建镜像指令的文本文件。Docker镜像构建器从上到下执行Dockerfile，指令可以配置或更改关于镜像的任何内容。从Dockerfile构建镜像使得像将文件添加到来自你电脑的容器这样的任务变得简单的一行指令。Dockerfile是描述如何构建Docker镜像最常见的方式。
- en: This chapter covers the basics of working with Dockerfile builds and the best
    reasons to use them, a lean overview of the instructions, and how to add future
    build behavior. We’ll get started with a familiar example that shows how to automate
    the process of building images with code instead of creating them manually. Once
    an image’s build is defined in code, it is simple to track changes in version
    control, share with team members, optimize, and secure.
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖了使用Dockerfile构建的基础知识以及使用它们的最佳理由，对指令的简洁概述以及如何添加未来的构建行为。我们将从一个熟悉的例子开始，展示如何通过代码自动化构建镜像的过程，而不是手动创建它们。一旦在代码中定义了镜像的构建，跟踪版本控制中的更改、与团队成员共享、优化和确保安全性都变得简单。
- en: 8.1\. PACKAGING GIT WITH A DOCKERFILE
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.1\. 使用Dockerfile打包GIT
- en: Let’s start by revisiting the Git example image we built by hand in [chapter
    7](index_split_063.html#filepos667222). You should recognize many of the details
    and advantages of working with a Dockerfile as we translate the image build process
    from manual operations to code.
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们从回顾我们在[第7章](index_split_063.html#filepos667222)中手动构建的Git示例镜像开始。在翻译镜像构建过程从手动操作到代码的过程中，你应该能识别出许多与使用Dockerfile工作的细节和优势。
- en: 'First, create a new directory, and from that directory create a new file with
    your favorite text editor. Name the new file Dockerfile. Write the following five
    lines and then save the file:'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，创建一个新的目录，然后从该目录使用你喜欢的文本编辑器创建一个新文件。将新文件命名为Dockerfile。写下以下五行，然后保存文件：
- en: '`# An example Dockerfile for installing Git on Ubuntu FROM ubuntu:latest LABEL
    maintainer="dia@allingeek.com" RUN apt-get update && apt-get install -y git ENTRYPOINT
    ["git"]`'
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 安装Git到Ubuntu的示例Dockerfile FROM ubuntu:latest LABEL maintainer="dia@allingeek.com"
    RUN apt-get update && apt-get install -y git ENTRYPOINT ["git"]`'
- en: 'Before dissecting this example, build a new image from it with the `docker
    image build` command from the same directory containing the Dockerfile and tag
    the image with `auto`:'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在剖析此示例之前，使用包含Dockerfile的同一目录中的`docker image build`命令从它构建一个新的镜像，并用`auto`标记该镜像：
- en: '`docker image build --tag ubuntu-git:auto .`'
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build --tag ubuntu-git:auto .`'
- en: 'This outputs several lines about steps and output from `apt-get`, and will
    finally display a message like this:'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这将输出关于`apt-get`步骤和输出的多行信息，最终会显示如下信息：
- en: '`Successfully built cc63aeb7a5a2 Successfully tagged ubuntu-git:auto`'
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Successfully built cc63aeb7a5a2 Successfully tagged ubuntu-git:auto`'
- en: 'Running this command starts the build process. When it’s completed, you should
    have a brand-new image that you can test. View the list of all your `ubuntu-git`
    images and test the newest one with this command:'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行此命令将启动构建过程。完成后，你应该有一个全新的镜像可以进行测试。使用以下命令查看所有`ubuntu-git`镜像的列表，并测试最新版本：
- en: '`docker image ls`'
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image ls`'
- en: 'The new build tagged `auto` should now appear in the list:'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新的标记为`auto`的构建现在应该出现在列表中：
- en: '`REPOSITORY   TAG        IMAGE ID        CREATED             VIRTUAL SIZE ubuntu-git  
    auto       cc63aeb7a5a2     2 minutes ago      219MB ubuntu-git   latest     826c66145a59   
    10 minutes ago      249MB ubuntu-git   removed    826c66145a59    10 minutes ago     
    249MB ubuntu-git   1.9        3e356394c14e    41 hours ago        249MB ...`'
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`REPOSITORY   TAG        IMAGE ID        CREATED             VIRTUAL SIZE ubuntu-git  
    auto       cc63aeb7a5a2     2 minutes ago      219MB ubuntu-git   latest     826c66145a59   
    10 minutes ago      249MB ubuntu-git   removed    826c66145a59    10 minutes ago     
    249MB ubuntu-git   1.9        3e356394c14e    41 hours ago        249MB ...`'
- en: 'Now you can run a Git command using the new image:'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，您可以使用新的镜像运行 Git 命令：
- en: '`docker container run --rm ubuntu-git:auto`'
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm ubuntu-git:auto`'
- en: 'These commands demonstrate that the image you built with the Dockerfile works
    and is functionally equivalent to the one you built by hand. Examine what you
    did to accomplish this:'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些命令演示了您使用 Dockerfile 构建的镜像可以正常工作，并且功能上与您手动构建的镜像等效。检查您做了什么来实现这一点：
- en: 'First, you created a Dockerfile with four instructions:'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，您创建了一个包含四个指令的 Dockerfile：
- en: '`FROM ubuntu:latest`—  Tells Docker to start from the latest Ubuntu image just
    as you did when creating the image manually.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM ubuntu:latest`—  告诉 Docker 从最新的 Ubuntu 镜像开始，就像您手动创建镜像时那样。'
- en: '`LABEL maintainer`—  Sets the maintainer name and email for the image. Providing
    this information helps people know whom to contact if there’s a problem with the
    image. This was accomplished earlier when you invoked `commit`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL maintainer`—  设置镜像的维护者姓名和电子邮件。提供此信息有助于人们知道在镜像出现问题时联系谁。这在前面的 `commit`
    调用中已经完成。'
- en: '`RUN apt-get update && apt-get install -y git`—  Tells the builder to run the
    provided commands to install Git.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN apt-get update && apt-get install -y git`—  告诉构建器运行提供的命令来安装 Git。'
- en: '`ENTRYPOINT ["git"]`—  Sets the entrypoint for the image to `git`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["git"]`—  将镜像的入口点设置为 `git`。'
- en: Dockerfiles, like most scripts, can include comments. Any line beginning with
    a `#` will be ignored by the builder. It’s important for Dockerfiles of any complexity
    to be well-documented. In addition to improving Dockerfile maintainability, comments
    help people audit images that they’re considering for adoption and spread best
    practices.
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile，像大多数脚本一样，可以包含注释。任何以 `#` 开头的行都将被构建器忽略。对于任何复杂性的 Dockerfile 来说，良好的文档记录非常重要。除了提高
    Dockerfile 的可维护性外，注释还有助于人们审计他们考虑采用的镜像，并传播最佳实践。
- en: The only special rule about Dockerfiles is that the first instruction must be
    `FROM`. If you’re starting from an empty image and your software has no dependencies,
    or you’ll provide all the dependencies, then you can start from a special empty
    repository named `scratch`.
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于 Dockerfile 的唯一特殊规则是第一条指令必须是 `FROM`。如果您从一个空镜像开始，并且您的软件没有依赖项，或者您将提供所有依赖项，那么您可以从一个名为
    `scratch` 的特殊空仓库开始。
- en: After you saved the Dockerfile, you started the build process by invoking the
    `docker image build` command. The command had one flag set and one argument. The
    `--tag` flag (or `-t` for short) specifies the full repository designation that
    you want to use for the resulting image. In this case, you used `ubuntu-git:auto`.
    The argument that you included at the end was a single period. That argument told
    the builder the location of the Dockerfile. The period told it to look for the
    file in the current directory.
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在保存了 Dockerfile 之后，您通过调用 `docker image build` 命令开始了构建过程。该命令设置了一个标志和一个参数。`--tag`
    标志（或简写为 `-t`）指定了您希望用于结果镜像的完整仓库标识。在这种情况下，您使用了 `ubuntu-git:auto`。您在末尾包含的参数是一个单独的点。该参数告诉构建器
    Dockerfile 的位置。点号告诉它在该当前目录中查找文件。
- en: The `docker image build` command has another flag, `--file` (or `-f` for short),
    that lets you set the name of the Dockerfile. `Dockerfile` is the default, but
    with this flag you could tell the builder to look for a file named BuildScript
    or release-image.df. This flag sets only the name of the file, not the location.
    That must always be specified in the location argument.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build` 命令还有一个标志，`--file`（或简写为 `-f`），允许您设置 Dockerfile 的名称。`Dockerfile`
    是默认值，但使用此标志，您可以告诉构建器查找名为 BuildScript 或 release-image.df 的文件。此标志仅设置文件的名称，而不是位置。这必须在位置参数中始终指定。'
- en: The builder works by automating the same tasks that you’d use to create images
    by hand. Each instruction triggers the creation of a new container with the specified
    modification. After the modification has been made, the builder commits the layer
    and moves on to the next instruction and container created from the fresh layer.
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建器通过自动化您手动创建镜像时使用的相同任务来工作。每条指令都会触发创建一个新的容器，并应用指定的修改。修改完成后，构建器提交该层，然后继续执行下一条指令和由新层创建的下一个容器。
- en: 'The builder validated that the image specified by the `FROM` instruction was
    installed as the first step of the build. If it were not, Docker would have automatically
    tried to pull the image. Take a look at the output from the `build` command that
    you ran:'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建器验证了 `FROM` 指令指定的镜像是否作为构建的第一步安装。如果没有安装，Docker 会自动尝试拉取该镜像。查看您运行的 `build` 命令的输出：
- en: '`Sending build context to Docker daemon  2.048kB Step 1/4 : FROM ubuntu:latest
    ---> 452a96d81c30`'
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`将构建上下文发送到 Docker 守护进程  2.048kB 步骤 1/4 : FROM ubuntu:latest ---> 452a96d81c30`'
- en: You can see that in this case the base image specified by the `FROM` instruction
    is `ubuntu:latest`, which should have already been installed on your machine.
    The abbreviated image ID of the base image is included in the output.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以看到，在这种情况下，`FROM` 指令指定的基本镜像为 `ubuntu:latest`，这应该已经安装在了您的机器上。基本镜像的缩写 ID 包含在输出中。
- en: 'The next instruction sets the maintainer information on the image. This creates
    a new container and then commits the resulting layer. You can see the result of
    this operation in the output for step 1:'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下一条指令设置了镜像的维护者信息。这会创建一个新的容器，然后提交生成的层。您可以在步骤 1 的输出中看到此操作的成果：
- en: '`Step 2/4 : LABEL maintainer="dia@allingeek.com" ---> Running in 11140b391074
    Removing intermediate container 11140b391074`'
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`步骤 2/4 : 标签维护者="dia@allingeek.com" ---> 在 11140b391074 中运行 移除中间容器 11140b391074`'
- en: The output includes the ID of the container that was created and the ID of the
    committed layer. That layer will be used as the top of the image for the next
    instruction, `RUN`. The `RUN` instruction executes the program with the arguments
    you specify on top of a new image layer. Then Docker commits the filesystem changes
    to the layer so they are available for the next Dockerfile instruction. In this
    case, the output for the `RUN` instruction was clouded with all the output for
    the command `apt-get update && apt-get install -y git`. Installing software packages
    is one of the most common use cases for the `RUN` instruction. You should explicitly
    install each software package needed by your container to ensure that it is available
    when needed.
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出包括创建的容器 ID 和提交的层 ID。该层将作为下一个指令 `RUN` 的镜像顶层。`RUN` 指令在新的镜像层上执行您指定的程序，然后 Docker
    将文件系统更改提交到该层，以便它们对下一个 Dockerfile 指令可用。在这种情况下，`RUN` 指令的输出被 `apt-get update && apt-get
    install -y git` 命令的所有输出所覆盖。安装软件包是 `RUN` 指令最常见的使用场景之一。您应该明确安装容器需要的每个软件包，以确保在需要时可用。
- en: 'If you’re not interested in reams of build process output, you can invoke the
    `docker image build` command with the `--quiet` or `-q` flag. Running in quiet
    mode will suppress all output from the build process and management of intermediate
    containers. The only output of the build process in quiet mode is the resulting
    image ID, which looks like this:'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您对大量的构建过程输出不感兴趣，可以使用带有 `--quiet` 或 `-q` 标志的 `docker image build` 命令。在静默模式下运行将抑制构建过程和管理中间容器的所有输出。静默模式下的构建过程唯一输出是生成的镜像
    ID，如下所示：
- en: '`sha256:e397ecfd576c83a1e49875477dcac50071e1c71f76f1d0c8d371ac74d97bbc90`'
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`sha256:e397ecfd576c83a1e49875477dcac50071e1c71f76f1d0c8d371ac74d97bbc90`'
- en: 'Although this third step to install Git usually takes much longer to complete,
    you can see the instruction and input as well as the ID of the container where
    the command was run and the ID of the resulting layer. Finally, the `ENTRYPOINT`
    instruction performs all the same steps, and the output is similarly unsurprising:'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然安装 Git 的这一步通常需要更长的时间才能完成，但您可以看到指令和输入，以及运行命令的容器 ID 和生成层的 ID。最后，`ENTRYPOINT`
    指令执行所有相同的步骤，输出同样不出所料：
- en: '`Step 4/4 : ENTRYPOINT ["git"] ---> Running in 6151803c388a Removing intermediate
    container 6151803c388a ---> e397ecfd576c Successfully built e397ecfd576c Successfully
    tagged ubuntu-git:auto`'
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`步骤 4/4 : ENTRYPOINT ["git"] ---> 在 6151803c388a 中运行 移除中间容器 6151803c388a --->
    e397ecfd576c 成功构建 e397ecfd576c 成功标记 ubuntu-git:auto`'
- en: A new layer is being added to the resulting image after each step in the build.
    Although this means you could potentially branch on any of these steps, the more
    important implication is that the builder can aggressively cache the results of
    each step. If a problem with the build script occurs after several other steps,
    the builder can restart from the same position after the problem has been fixed.
    You can see this in action by breaking your Dockerfile.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建的每一步之后，都会向生成的镜像中添加一个新的层。虽然这意味着您可以在这些步骤中的任何一步进行分支，但更重要的是，构建者可以积极缓存每一步的结果。如果在其他几个步骤之后构建脚本出现问题，构建者可以在问题解决后从相同的位置重新启动。您可以通过破坏Dockerfile来看到这一过程。
- en: 'Add this line to the end of your Dockerfile:'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将此行添加到您的Dockerfile末尾：
- en: '`RUN This will not work`'
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`RUN 这将不会工作`'
- en: 'Then run the build again:'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后再次运行构建：
- en: '`docker image build --tag ubuntu-git:auto .`'
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build --tag ubuntu-git:auto .`'
- en: 'The output will show which steps the builder was able to skip in favor of cached
    results:'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出将显示构建者能够跳过哪些步骤以使用缓存结果：
- en: '`Sending build context to Docker daemon  2.048kB Step 1/5 : FROM ubuntu:latest
    ---> 452a96d81c30 Step 2/5 : LABEL maintainer="dia@allingeek.com" ---> Using cache`
    `1` `---> 83da14c85b5a Step 3/5 : RUN apt-get update && apt-get install -y git
    ---> Using cache` `1` `---> 795a6e5d560d Step 4/5 : ENTRYPOINT ["git"] ---> Using
    cache` `1` `---> 89da8ffa57c7 Step 5/5 : RUN This will not work ---> Running in
    2104ec7bc170 /bin/sh: 1: This: not found The command ''/bin/sh -c This will not
    work'' returned a non-zero code: 127`'
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Sending build context to Docker daemon  2.048kB Step 1/5 : FROM ubuntu:latest
    ---> 452a96d81c30 Step 2/5 : LABEL maintainer="dia@allingeek.com" ---> 使用缓存` `1`
    `---> 83da14c85b5a Step 3/5 : RUN apt-get update && apt-get install -y git --->
    使用缓存` `1` `---> 795a6e5d560d Step 4/5 : ENTRYPOINT ["git"] ---> 使用缓存` `1` `--->
    89da8ffa57c7 Step 5/5 : RUN 这将不会工作 ---> 在 2104ec7bc170 /bin/sh: 1: This: not found
    命令 ''/bin/sh -c 这将不会工作'' 返回了非零代码：127`'
- en: 1 Note use of cache.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1. 注意缓存的使用。
- en: Steps 1 through 4 were skipped because they were already built during your last
    build. Step 5 failed because there’s no program with the name `This` in the container.
    The container output was valuable in this case because the error message informs
    you about the specific problem with the Dockerfile. If you fix the problem, the
    same steps will be skipped again, and the build will succeed, resulting in output
    like `Successfully built d7a8ee0cebd4`.
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤1至4被跳过，因为它们在您上一次构建时已经构建完成。步骤5失败，因为容器中没有名为`This`的程序。在这种情况下，容器输出是有价值的，因为错误消息会告知您Dockerfile的具体问题。如果您修复了问题，相同的步骤将再次被跳过，构建将成功，输出类似于`Successfully
    built d7a8ee0cebd4`。
- en: The use of caching during the build can save time if the build includes downloading
    material, compiling programs, or anything else that is time-intensive. If you
    need a full rebuild, you can use the `--no-cache` flag on `docker image build`
    to disable the use of the cache. Make sure you’re disabling the cache only when
    required because it will place much more strain on upstream source systems and
    image-building systems.
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建过程中使用缓存可以在构建包括下载材料、编译程序或其他耗时操作时节省时间。如果您需要进行完整重建，您可以在`docker image build`中使用`--no-cache`标志来禁用缓存的使用。请确保仅在需要时禁用缓存，因为它会给上游源系统和镜像构建系统带来更大的压力。
- en: This short example uses 4 of the 18 Dockerfile instructions. The example is
    limited in that all the files added to the image were downloaded from the network;
    the example modifies the environment in a limited way and provides a general tool.
    The next example, which has a more specific purpose and local code, provides a
    more complete Dockerfile primer.
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个简短的例子使用了18个Dockerfile指令中的4个。这个例子有限制，因为添加到镜像中的所有文件都是从网络上下载的；这个例子以有限的方式修改了环境并提供了一般工具。下一个例子，它具有更具体的目的和本地代码，提供了一个更完整的Dockerfile入门。
- en: 8.2\. A DOCKERFILE PRIMER
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2. DOCKERFILE 入门
- en: Dockerfiles are expressive and easy to understand because of their terse syntax
    that allows for comments. You can keep track of changes to Dockerfiles with any
    version-control system. Maintaining multiple versions of an image is as simple
    as maintaining multiple Dockerfiles. The Dockerfile build process itself uses
    extensive caching to aid rapid development and iteration. The builds are traceable
    and reproducible. They integrate easily with existing build systems and many continuous
    integration tools. With all these reasons to prefer Dockerfile builds to handmade
    images, it’s important to learn how to write them.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile由于其简洁的语法和允许注释而易于表达和理解。您可以使用任何版本控制系统跟踪Dockerfile的更改。维护多个镜像版本就像维护多个Dockerfile一样简单。Dockerfile构建过程本身使用广泛的缓存来帮助快速开发和迭代。构建是可追踪和可重复的。它们可以轻松地与现有的构建系统集成，并与许多持续集成工具集成。鉴于有这么多理由更喜欢Dockerfile构建而不是手动制作的镜像，学习如何编写它们是非常重要的。
- en: The examples in this section cover the core Dockerfile instructions used in
    most images. The following sections show how to create downstream behavior and
    more maintainable Dockerfiles. Every instruction is covered here at an introductory
    level. For deep coverage of each instruction, the best reference will always be
    the Docker documentation online at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    The Docker builder reference also provides examples of good Dockerfiles and a
    best practices guide.
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节中的示例涵盖了大多数镜像中使用的核心Dockerfile指令。以下部分展示了如何创建下游行为和更易于维护的Dockerfile。这里对每个指令都进行了入门级别的介绍。对于每个指令的深入覆盖，最佳参考始终是网上Docker文档[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。Docker构建器参考还提供了良好的Dockerfile示例和最佳实践指南。
- en: 8.2.1\. Metadata instructions
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2.1. 元数据指令
- en: The first example builds a base image and two other images with distinct versions
    of the mailer program you used in [chapter 2](index_split_024.html#filepos153412).
    The purpose of the program is to listen for messages on a TCP port and then send
    those messages to their intended recipients. The first version of the mailer will
    listen for messages but only log those messages. The second will send the message
    as an `HTTP POST` to the defined URL.
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个示例构建了一个基础镜像和两个使用[第2章](index_split_024.html#filepos153412)中使用的不同版本的mailer程序的镜像。该程序的目的是在TCP端口上监听消息，然后将这些消息发送给预期的接收者。mailer的第一个版本将监听消息，但只记录这些消息。第二个版本将消息作为`HTTP
    POST`发送到定义的URL。
- en: One of the best reasons to use Dockerfile builds is that they simplify copying
    files from your computer into an image. But it’s not always appropriate for certain
    files to be copied to images. The first thing to do when starting a new project
    is to define which files should never be copied into any images. You can do this
    in a file called .dockerignore. In this example, you’ll create three Dockerfiles,
    and none needs to be copied into the resulting images.
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建的最佳理由之一是它们简化了从您的计算机到镜像中复制文件的过程。但并不是所有文件都适合复制到镜像中。开始一个新项目时首先要做的是定义哪些文件永远不应该被复制到任何镜像中。您可以在名为.dockerignore的文件中完成这项工作。在这个例子中，您将创建三个Dockerfile，并且都不需要复制到生成的镜像中。
- en: 'Use your favorite text editor to create a new file named .dockerignore and
    copy in the following lines:'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器创建一个名为.dockerignore的新文件，并复制以下行：
- en: '`.dockerignore mailer-base.df mailer-logging.df mailer-live.df`'
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`.dockerignore mailer-base.df mailer-logging.df mailer-live.df`'
- en: Save and close the file when you’re finished. This will prevent the .dockerignore
    file, or files named mailer-base.df, mailer-logging.df, or mailer-live.df, from
    ever being copied into an image during a build. With that bit of accounting finished,
    you can begin working on the base image.
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完成后保存并关闭文件。这将防止.dockerignore文件，或名为mailer-base.df、mailer-logging.df或mailer-live.df的文件在构建过程中被复制到镜像中。完成这部分会计工作后，你就可以开始对基础镜像进行工作了。
- en: 'Building a base image helps create common layers. Each version of the mailer
    will be built on top of an image called `mailer-base`. When you create a Dockerfile,
    you need to keep in mind that each Dockerfile instruction will result in a new
    layer being created. Instructions should be combined whenever possible because
    the builder won’t perform any optimization. Putting this in practice, create a
    new file named mailer-base.df and add the following lines:'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建基础镜像有助于创建公共层。每个邮件器的版本都将建立在名为`mailer-base`的镜像之上。当你创建Dockerfile时，需要记住每个Dockerfile指令都将导致创建一个新的层。尽可能地将指令组合在一起，因为构建器不会执行任何优化。将以下内容放入实践中，创建一个名为mailer-base.df的新文件，并添加以下行：
- en: '`FROM debian:buster-20190910 LABEL maintainer="dia@allingeek.com" RUN groupadd
    -r -g 2200 example && \     useradd -rM -g example -u 2200 example ENV APPROOT="/app"
    \     APP="mailer.sh" \     VERSION="0.6" LABEL base.name="Mailer Archetype" \
          base.version="${VERSION}" WORKDIR $APPROOT ADD . $APPROOT ENTRYPOINT ["/app/mailer.sh"]`
    `1` `EXPOSE 33333 # Do not set the default user in the base otherwise # implementations
    will not be able to update the image # USER example:example`'
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM debian:buster-20190910 LABEL maintainer="dia@allingeek.com" RUN groupadd
    -r -g 2200 example && \ useradd -rM -g example -u 2200 example ENV APPROOT="/app"
    \ APP="mailer.sh" \ VERSION="0.6" LABEL base.name="Mailer Archetype" \ base.version="${VERSION}"
    WORKDIR $APPROOT ADD . $APPROOT ENTRYPOINT ["/app/mailer.sh"]` `1` `EXPOSE 33333
    # Do not set the default user in the base otherwise # implementations will not
    be able to update the image # USER example:example`'
- en: 1 This file does not exist yet.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此文件尚不存在。
- en: 'Put it all together by running the `docker image build` command from the directory
    where the mailer-base file is located. The `-f` flag tells the builder which filename
    to use as input:'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过在mailer-base文件所在的目录中运行`docker image build`命令来将所有内容组合在一起。`-f`标志告诉构建器使用哪个文件名作为输入：
- en: '`docker image build -t dockerinaction/mailer-base:0.6 -f mailer-base.df .`'
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/mailer-base:0.6 -f mailer-base.df .`'
- en: '|    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Naming Dockerfiles
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile的命名
- en: The default and most common name for a Dockerfile is Dockerfile. However, Dockerfiles
    can be named anything because they are simple text files and the build command
    accepts any filename you tell it. Some people name their Dockerfiles with an extension
    such as .df so that they can easily define builds for multiple images in a single
    project directory (for example, app-build.df, app-runtime.df, and app-debug-tools.df).
    A file extension also makes it easy to activate Dockerfile support in editors.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile的默认和最常见名称是Dockerfile。然而，Dockerfile可以命名为任何东西，因为它们是简单的文本文件，并且构建命令接受你告诉它的任何文件名。有些人使用扩展名（如.df）来命名他们的Dockerfile，这样他们就可以在单个项目目录中轻松定义多个镜像的构建（例如，app-build.df、app-runtime.df和app-debug-tools.df）。文件扩展名还使得在编辑器中激活Dockerfile支持变得容易。
- en: '|    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'Five new instructions are introduced in this Dockerfile. The first new instruction
    is `ENV`. `ENV` sets environment variables for an image, similar to the `--env`
    flag on `docker container run` or `docker container create`. In this case, a single
    `ENV` instruction is used to set three distinct environment variables. That could
    have been accomplished with three subsequent `ENV` instructions, though doing
    so would result in the creation of three layers. You can keep instructions easy
    to read by using a backslash to escape the newline character (just as in shell
    scripting):'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个Dockerfile中引入了五个新指令。第一个新指令是`ENV`。`ENV`用于为镜像设置环境变量，类似于`docker container run`或`docker
    container create`上的`--env`标志。在这种情况下，使用单个`ENV`指令设置了三个不同的环境变量。虽然也可以用三个随后的`ENV`指令来完成，但这样做会导致创建三个层。你可以通过使用反斜杠来转义换行符（就像在shell脚本中一样）来保持指令易于阅读：
- en: '`Step 4/9 : ENV APPROOT="/app"     APP="mailer.sh"     VERSION="0.6" ---> Running
    in c525f774240f Removing intermediate container c525f774240f`'
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Step 4/9 : ENV APPROOT="/app"     APP="mailer.sh"     VERSION="0.6" ---> Running
    in c525f774240f Removing intermediate container c525f774240f`'
- en: 'Environment variables declared in the Dockerfile are made available to the
    resulting image but can be used in other Dockerfile instructions as substitutions.
    In this Dockerfile, the environment variable `VERSION` was used as a substitution
    in the next new instruction, `LABEL`:'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Dockerfile中声明的环境变量将对生成的镜像可用，但可以在其他Dockerfile指令中使用作为替换。在这个Dockerfile中，环境变量`VERSION`被用作下一个新指令`LABEL`的替换：
- en: '`Step 5/9 : LABEL base.name="Mailer Archetype"       base.version="${VERSION}"
    ---> Running in 33d8f4d45042 Removing intermediate container 33d8f4d45042 --->
    20441d0f588e`'
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Step 5/9 : LABEL base.name="Mailer Archetype"       base.version="${VERSION}"
    ---> Running in 33d8f4d45042 Removing intermediate container 33d8f4d45042 --->
    20441d0f588e`'
- en: The `LABEL` instruction is used to define key/value pairs that are recorded
    as additional metadata for an image or container. This mirrors the `--label` flag
    on `docker run` and `docker create`. Like the `ENV` instruction before it, multiple
    labels can and should be set with a single instruction. In this case, the value
    of the `VERSION` environment variable was substituted for the value of the `base.version`
    label. By using an environment variable in this way, the value of `VERSION` will
    be available to processes running inside a container as well as recorded to an
    appropriate label. This increases maintainability of the Dockerfile because it’s
    more difficult to make inconsistent changes when the valueis set in a single location.
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`LABEL` 指令用于定义作为镜像或容器的附加元数据记录的键/值对。这反映了 `docker run` 和 `docker create` 中的 `--label`
    标志。像之前的 `ENV` 指令一样，可以使用单个指令设置多个标签。在这种情况下，`VERSION` 环境变量的值被替换为 `base.version` 标签的值。通过这种方式使用环境变量，`VERSION`
    的值将可供容器内运行的过程使用，并记录到适当的标签中。这增加了 Dockerfile 的可维护性，因为当值在单一位置设置时，做出不一致的更改会更困难。'
- en: '|    |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Organizing metadata with labels
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用标签组织元数据
- en: Docker Inc. recommends recording metadata with labels to help organize images,
    networks, containers, and other objects. Each label key should be prefixed with
    the reverse DNS notation of a domain that is controlled or collaborating with
    the author, such as `com.<your company>.some-label`. Labels are flexible, extensible,
    and lightweight, but the lack of structure makes leveraging the information difficult.
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker Inc. 建议使用标签记录元数据以帮助组织镜像、网络、容器和其他对象。每个标签键应该以受作者控制或合作的域的反向DNS表示法作为前缀，例如
    `com.<你的公司>.some-label`。标签是灵活的、可扩展的且轻量级，但缺乏结构使得利用信息变得困难。
- en: The Label Schema project ([http://label-schema.org/](http://label-schema.org/))
    is a community effort to standardize label names and promote compatible tooling.
    The schema covers many important attributes of an image such as build date, name,
    and description. For example, when using the label schema namespace, the key for
    the build date is named `org.label-schema.build-date` and should have a value
    in RFC 3339 format such as `2018-07-12T16:20:50.52Z`.
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标签模式项目 ([http://label-schema.org/](http://label-schema.org/)) 是一个社区努力，旨在标准化标签名称并推广兼容的工具。该模式涵盖了镜像的许多重要属性，如构建日期、名称和描述。例如，当使用标签模式命名空间时，构建日期的键命名为
    `org.label-schema.build-date`，并且应该具有 RFC 3339 格式的值，例如 `2018-07-12T16:20:50.52Z`。
- en: '|    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'The next two instructions are `WORKDIR` and `EXPOSE`. These are similar in
    operation to their corresponding flags on the `docker run` and `docker create`
    commands. An environment variable was substituted for the argument to the `WORKDIR`
    command:'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下两条指令是 `WORKDIR` 和 `EXPOSE`。这些指令在操作上与 `docker run` 和 `docker create` 命令中的相应标志类似。`WORKDIR`
    指令的参数被一个环境变量所替代：
- en: '`Step 6/9 : WORKDIR $APPROOT Removing intermediate container c2cb1fc7bf4f --->
    cb7953a10e42`'
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`步骤 6/9 : WORKDIR $APPROOT 移除中间容器 c2cb1fc7bf4f ---> cb7953a10e42`'
- en: 'The result of the `WORKDIR` instruction will be an image with the default working
    directory set to `/app`. Setting `WORKDIR` to a location that doesn’t exist will
    create that location just as it would with the command-line option. Last, the
    `EXPOSE` command creates a layer that opens TCP port 33333:'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`WORKDIR` 指令的结果将是一个默认工作目录设置为 `/app` 的镜像。将 `WORKDIR` 设置为不存在的位置将创建该位置，就像使用命令行选项一样。最后，`EXPOSE`
    命令创建一个打开 TCP 端口 33333 的层：'
- en: '`Step 9/9 : EXPOSE 33333 ---> Running in cfb2afea5ada  Removing intermediate
    container cfb2afea5ada ---> 38a4767b8df4`'
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`步骤 9/9 : EXPOSE 33333 ---> 在 cfb2afea5ada 容器中运行  移除中间容器 cfb2afea5ada --->
    38a4767b8df4`'
- en: The parts of this Dockerfile that you should recognize are the `FROM`, `LABEL`,
    and `ENTRYPOINT` instructions. In brief, the `FROM` instruction sets the layer
    stack to start from the `debian:buster-20190910` image. Any new layers built will
    be placed on top of that image. The `LABEL` instruction adds key/value pairs to
    the image’s metadata. The `ENTRYPOINT` instruction sets the executable to run
    at container startup. Here, it’s setting the instruction to `exec ./mailer.sh`
    and using the shell form of the instruction.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你应该能识别出这个 Dockerfile 中的 `FROM`、`LABEL` 和 `ENTRYPOINT` 指令。简要来说，`FROM` 指令设置层堆栈从
    `debian:buster-20190910` 镜像开始。任何新构建的层都将放置在这个镜像之上。`LABEL` 指令向镜像的元数据添加键/值对。`ENTRYPOINT`
    指令设置容器启动时运行的可执行文件。在这里，它将指令设置为 `exec ./mailer.sh` 并使用指令的 shell 形式。
- en: 'The `ENTRYPOINT` instruction has two forms: the shell form and an exec form.
    The shell form looks like a shell command with whitespace-delimited arguments.
    The exec form is a string array in which the first value is the command to execute
    and the remaining values are arguments. A command specified using the shell form
    would be executed as an argument to the default shell. Specifically, the command
    used in this Dockerfile will be executed as `/bin/sh –c ''exec ./mailer.sh''`
    at runtime. Most importantly, if the shell form is used for `ENTRYPOINT`, all
    other arguments provided by the `CMD` instruction or at runtime as extra arguments
    to `docker container run` will be ignored. This makes the shell form of `ENTRYPOINT`
    less flexible.'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令有两种形式：shell形式和exec形式。shell形式看起来像带有空格分隔的参数的shell命令。exec形式是一个字符串数组，其中第一个值是要执行的命令，其余值是参数。使用shell形式指定的命令将作为默认shell的参数执行。具体来说，在这个Dockerfile中使用的命令将在运行时作为`/bin/sh
    –c ''exec ./mailer.sh''`执行。最重要的是，如果使用shell形式为`ENTRYPOINT`，则将忽略`CMD`指令提供的所有其他参数或作为`docker
    container run`的额外参数在运行时提供的参数。这使得shell形式的`ENTRYPOINT`灵活性较低。'
- en: 'You can see from the build output that the `ENV` and `LABEL` instructions each
    resulted in a single step and layer. But the output doesn’t show that the environment
    variable values were substituted correctly. To verify that, you’ll need to inspect
    the image:'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以从构建输出中看到，`ENV`和`LABEL`指令每个都只产生了一步和一层。但输出并没有显示环境变量值被正确替换。为了验证这一点，你需要检查镜像：
- en: '`docker inspect dockerinaction/mailer-base:0.6`'
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker inspect dockerinaction/mailer-base:0.6`'
- en: '|    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the `docker inspect` command can be used to view the metadata of either
    a container or an image. In this case, you used it to inspect an image.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，`docker inspect`命令可以用来查看容器或镜像的元数据。在这种情况下，你用它来检查了一个镜像。
- en: '|    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'The relevant lines are these:'
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相关的行如下：
- en: '`"Env": [     "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
        "APPROOT=/app",     "APP=mailer.sh",     "VERSION=0.6" ], ... "Labels": {
        "base.name": "Mailer Archetype",     "base.version": "0.6",     "maintainer":
    "dia@allingeek.com" }, ... "WorkingDir": "/app"`'
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"Env": [ "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
    "APPROOT=/app", "APP=mailer.sh", "VERSION=0.6" ], ... "Labels": { "base.name":
    "Mailer Archetype", "base.version": "0.6", "maintainer": "dia@allingeek.com" },
    ... "WorkingDir": "/app"`'
- en: The metadata makes it clear that the environment variable substitution works.
    You can use this form of substitution in the `ENV`, `ADD`, `COPY`, `LABEL`, `WORKDIR`,
    `VOLUME`, `EXPOSE`, and `USER` instructions.
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 元数据清楚地表明环境变量替换是有效的。你可以在`ENV`、`ADD`、`COPY`、`LABEL`、`WORKDIR`、`VOLUME`、`EXPOSE`和`USER`指令中使用这种替换形式。
- en: The last commented line is a metadata instruction, `USER`. It sets the user
    and group for all further build steps and containers created from the image. In
    this case, setting it in a base image would prevent any downstream Dockerfiles
    from installing software. That would mean that those Dockerfiles would need to
    flip the default back and forth for permission. Doing so would create at least
    two additional layers. The better approach would be to set up the user and group
    accounts in the base image and let the implementations set the default user when
    they’ve finished building.
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一条注释行是一个元数据指令`USER`。它为所有后续的构建步骤和从镜像创建的容器设置了用户和组。在这种情况下，在基础镜像中设置它将防止任何下游的Dockerfile安装软件。这意味着那些Dockerfile将需要在权限之间来回切换默认设置。这样做至少会创建两个额外的层。更好的方法是，在基础镜像中设置用户和组账户，然后让实现者在构建完成后设置默认用户。
- en: The most curious thing about this Dockerfile is that the `ENTRYPOINT` is set
    to a file that doesn’t exist. The entrypoint will fail when you try to run a container
    from this base image. But now that the entrypoint is set in the base image, that’s
    one less layer that will need to be duplicated for specific implementations of
    the mailer. The next two Dockerfiles build different mailer.sh implementations.
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个Dockerfile最奇特的地方在于`ENTRYPOINT`被设置为一个不存在的文件。当你尝试从这个基础镜像运行容器时，entrypoint将会失败。但现在entrypoint已经在基础镜像中设置，这意味着对于特定邮件发送器的实现，将少一个需要复制的层。接下来的两个Dockerfile构建了不同的`mailer.sh`实现。
- en: 8.2.2\. Filesystem instructions
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2.2\. 文件系统指令
- en: 'Images that include custom functionality will need to modify the filesystem.
    A Dockerfile defines three instructions that modify the filesystem: `COPY`, `VOLUME`,
    and `ADD`. The Dockerfile for the first implementation should be placed in a file
    named mailer-logging.df:'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含自定义功能的镜像需要修改文件系统。Dockerfile 定义了三个修改文件系统的指令：`COPY`、`VOLUME` 和 `ADD`。第一个实现的
    Dockerfile 应该放置在一个名为 mailer-logging.df 的文件中：
- en: '`FROM dockerinaction/mailer-base:0.6 RUN apt-get update && \     apt-get install
    -y netcat COPY ["./log-impl", "${APPROOT}"] RUN chmod a+x ${APPROOT}/${APP} &&
    \     chown example:example /var/log USER example:example VOLUME ["/var/log"]
    CMD ["/var/log/mailer.log"]`'
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM dockerinaction/mailer-base:0.6 RUN apt-get update && \     apt-get install
    -y netcat COPY ["./log-impl", "${APPROOT}"] RUN chmod a+x ${APPROOT}/${APP} &&
    \     chown example:example /var/log USER example:example VOLUME ["/var/log"]
    CMD ["/var/log/mailer.log"]`'
- en: 'In this Dockerfile, you use the image generated from mailer-base as the starting
    point. The three new instructions are `COPY`, `VOLUME`, and `CMD`. The `COPY`
    instruction will copy files from the filesystem where the image is being built,
    into the build container. The `COPY` instruction takes at least two arguments.
    The last argument is the destination, and all other arguments are source files.
    This instruction has only one unexpected feature: any files copied will be copied
    with file ownership set to root. This is the case regardless of how the default
    user is set before the `COPY` instruction. It’s better to delay any `RUN` instructions
    to change file ownership until all the files that you need to update have been
    copied into the image.'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个 Dockerfile 中，你使用由 mailer-base 生成的镜像作为起点。三条新指令是 `COPY`、`VOLUME` 和 `CMD`。`COPY`
    指令将从镜像构建的文件系统中的文件复制到构建容器中。`COPY` 指令至少需要两个参数。最后一个参数是目标，所有其他参数都是源文件。这个指令只有一个意外的特性：任何复制的文件都将设置文件所有者为
    root。这无论在 `COPY` 指令之前默认用户是如何设置的都适用。最好是将更改文件所有权的 `RUN` 指令推迟到所有需要更新的文件都已复制到镜像中。
- en: The `COPY` instruction, just like `ENTRYPOINT` and other instructions, will
    honor both shell style and exec style arguments. But if any of the arguments contains
    whitespace, you need to use the exec form.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`COPY` 指令，就像 `ENTRYPOINT` 和其他指令一样，将尊重 shell 风格和 exec 风格的参数。但如果任何参数包含空格，你需要使用
    exec 形式。'
- en: '|    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using the exec (or string array) form wherever possible is the best practice.
    At a minimum, a Dockerfile should be consistent and avoid mixing styles. This
    will make your Dockerfiles more readable and ensure that instructions behave as
    you’d expect without detailed understanding of their nuances.
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在可能的情况下尽可能使用 exec（或字符串数组）形式是最佳实践。至少，Dockerfile 应该保持一致，避免混合风格。这将使你的 Dockerfile
    更易于阅读，并确保指令的行为符合你的预期，而无需深入了解它们的细微差别。
- en: '|    |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'The second new instruction is `VOLUME`. This behaves exactly as you’d expect
    if you understand what the `--volume` flag does on a call to `docker run` or `docker
    create`. Each value in the string array argument will be created as a new volume
    definition in the resulting layer. Defining volumes at image build time is more
    limiting than at runtime. You have no way to specify a bind-mount volume or read-only
    volume at image build time. The `VOLUME` instruction will do only two things:
    create the defined location in the image filesystem and then add a volume definition
    to the image metadata.'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二条新指令是 `VOLUME`。如果你理解了在调用 `docker run` 或 `docker create` 时 `--volume` 标志的作用，那么它的行为将完全符合你的预期。字符串数组参数中的每个值都将作为新卷定义创建在结果层中。在镜像构建时定义卷比在运行时更有限制。你在镜像构建时无法指定绑定挂载卷或只读卷。`VOLUME`
    指令只会做两件事：在镜像文件系统中创建定义的位置，然后将卷定义添加到镜像元数据中。
- en: The last instruction in this Dockerfile is `CMD`. `CMD` is closely related to
    the `ENTRYPOINT` instruction, as shown in [figure 8.1](#filepos818318) They both
    take either shell or exec forms and are both used to start a process within a
    container. But a few important differences exist.
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个 Dockerfile 中的最后一条指令是 `CMD`。`CMD` 与 `ENTRYPOINT` 指令密切相关，如图 8.1 所示。它们都采用 shell
    或 exec 形式，并且都用于在容器内启动进程。但存在一些重要差异。
- en: Figure 8.1\. Relationship between `ENTRYPOINT` and `CMD`
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 8.1\. `ENTRYPOINT` 和 `CMD` 之间的关系
- en: '![](images/00066.jpg)'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00066.jpg)'
- en: The `CMD` command represents an argument list for the entrypoint. The default
    entrypoint for a container is `/bin/sh`. If no entrypoint is set for a container,
    the values are passed, because the command will be wrapped by the default entrypoint.
    But if the entrypoint is set and is declared using the exec form, you use `CMD`
    to set default arguments. The base for this Dockerfile defines the `ENTRYPOINT`
    as the mailer command. This Dockerfile injects an implementation of mailer.sh
    and defines a default argument. The argument used is the location that should
    be used for the log file.
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CMD`命令表示入口点的参数列表。容器的默认入口点是`/bin/sh`。如果容器没有设置入口点，则传递值，因为命令将被默认入口点包装。但是，如果设置了入口点并且使用exec形式声明，您将使用`CMD`来设置默认参数。此Dockerfile将`ENTRYPOINT`定义为邮件器命令。此Dockerfile注入了mailer.sh的实现并定义了一个默认参数。使用的参数是用于日志文件的应使用位置。'
- en: 'Before building the image, you need to create the logging version of the mailer
    program. Create a directory at `./log-impl`. Inside that directory, create a file
    named mailer.sh and copy the following script into the file:'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建镜像之前，您需要创建邮件程序的日志版本。在`./log-impl`目录中创建一个目录。在该目录内，创建一个名为mailer.sh的文件，并将以下脚本复制到该文件中：
- en: '`#!/bin/sh printf "Logging Mailer has started.\n" while true do     MESSAGE=$(nc
    -l -p 33333)     printf "[Message]: %s\n" "$MESSAGE" > $1     sleep 1 done`'
  id: totrans-345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`#!/bin/sh printf "Logging Mailer has started.\n" while true do     MESSAGE=$(nc
    -l -p 33333)     printf "[Message]: %s\n" "$MESSAGE" > $1     sleep 1 done`'
- en: 'The structural specifics of this script are unimportant. All you need to know
    is that this script will start a mailer daemon on port 33333 and write each message
    that it receives to the file specified in the first argument to the program. Use
    the following command to build the `mailer-logging` image from the directory containing
    mailer-logging.df:'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此脚本的详细结构并不重要。您需要知道的是，此脚本将在33333端口启动邮件器守护程序，并将它接收到的每条消息写入程序的第一个参数指定的文件中。使用以下命令从包含mailer-logging.df的目录构建`mailer-logging`镜像：
- en: '`docker image build -t dockerinaction/mailer-logging -f mailer-logging.df .`'
  id: totrans-347
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/mailer-logging -f mailer-logging.df .`'
- en: 'The results of this image build should be anticlimactic. Go ahead and start
    up a named container from this new image:'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此镜像构建的结果可能不会太引人注目。现在，从新镜像启动一个命名容器：
- en: '`docker run -d --name logging-mailer dockerinaction/mailer-logging`'
  id: totrans-349
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name logging-mailer dockerinaction/mailer-logging`'
- en: The logging mailer should now be built and running. Containers that link to
    this implementation will have their messages logged to /var/log/mailer.log. That’s
    not very interesting or useful in a real-world situation, but it might be handy
    for testing. An implementation that sends email would be better for operational
    monitoring.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 日志邮件器现在应该构建并运行。链接到此实现的容器将它们的消息记录到`/var/log/mailer.log`。这在现实世界的场景中可能不太有趣或有用，但它可能对测试很有帮助。一个发送电子邮件的实现将更适合操作监控。
- en: 'The next implementation example uses the Simple Email Service provided by Amazon
    Web Services to send email. Get started with another Dockerfile. Name this file
    mailer-live.df:'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下一个实现示例使用亚马逊网络服务提供的简单电子邮件服务发送电子邮件。从另一个Dockerfile开始。将此文件命名为mailer-live.df：
- en: '`FROM dockerinaction/mailer-base:0.6 ADD ["./live-impl", "${APPROOT}"] RUN
    apt-get update && \     apt-get install -y curl netcat python && \     curl "https://bootstrap.pypa.io/get-pip.py"
    -o "get-pip.py" && \     python get-pip.py && \     pip install awscli && \    
    rm get-pip.py && \     chmod a+x "${APPROOT}/${APP}" USER example:example CMD
    ["mailer@dockerinaction.com", "pager@dockerinaction.com"]`'
  id: totrans-352
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM dockerinaction/mailer-base:0.6 ADD ["./live-impl", "${APPROOT}"] RUN
    apt-get update && \     apt-get install -y curl netcat python && \     curl "https://bootstrap.pypa.io/get-pip.py"
    -o "get-pip.py" && \     python get-pip.py && \     pip install awscli && \    
    rm get-pip.py && \     chmod a+x "${APPROOT}/${APP}" USER example:example CMD
    ["mailer@dockerinaction.com", "pager@dockerinaction.com"]`'
- en: This Dockerfile includes one new instruction, `ADD`. The `ADD` instruction operates
    similarly to the `COPY` instruction with two important differences. The `ADD`
    instruction will
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此Dockerfile包含一个新指令`ADD`。`ADD`指令与`COPY`指令类似，但有两个重要区别。`ADD`指令将
- en: Fetch remote source files if a URL is specified
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了URL，则获取远程源文件
- en: Extract the files of any source determined to be an archive file
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取任何确定为存档文件的源文件
- en: The auto-extraction of archive files is the more useful of the two. Using the
    remote fetch feature of the `ADD` instruction isn’t good practice; although the
    feature is convenient, it provides no mechanism for cleaning up unused files and
    results in additional layers. Instead, you should use a chained `RUN` instruction,
    like the third instruction of mailer-live.df.
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这两个功能中，自动提取归档文件更有用。使用 `ADD` 指令的远程获取功能不是好的实践；尽管这个功能很方便，但它没有提供清理未使用文件和导致额外层的机制。相反，你应该使用链式
    `RUN` 指令，就像 mailer-live.df 的第三条指令一样。
- en: The other instruction to note in this Dockerfile is `CMD`, where two arguments
    are passed. Here you’re specifying the From and To fields on any emails that are
    sent. This differs from mailer-logging.df, which specifies only one argument.
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个 Dockerfile 中需要注意的另一个指令是 `CMD`，其中传递了两个参数。在这里，你指定了任何发送的电子邮件的“发件人”和“收件人”字段。这与
    mailer-logging.df 不同，后者只指定了一个参数。
- en: 'Next, create a new subdirectory named live-impl under the location containing
    mailer-live.df. Add the following script to a file in that directory named mailer.sh:'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，在包含 mailer-live.df 的位置下创建一个名为 live-impl 的新子目录。将以下脚本添加到该目录下名为 mailer.sh 的文件中：
- en: '`#!/bin/sh printf "Live Mailer has started.\n" while true do   MESSAGE=$(nc
    -l -p 33333)   aws ses send-email --from $1 \     --destination {\"ToAddresses\":[\"$2\"]}
    \      --message "{\"Subject\":{\"Data\":\"Mailer Alert\"},\                 \"Body\":{\"Text\":{\"Data\":\"${MESSAGE}\"}}}"
      sleep 1 done`'
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`#!/bin/sh printf "Live Mailer has started.\n" while true do MESSAGE=$(nc -l
    -p 33333) aws ses send-email --from $1 --destination "{\"ToAddresses\":[\"$2\"]}
    --message \"{\\\"Subject\\\":{\\\"Data\\\":\\\"Mailer Alert\\\"},\\\"Body\\\":{\\\"Text\\\":{\\\"Data\\\":\\\"${MESSAGE}\"}}}\"
    sleep 1 done`'
- en: 'The key takeaway from this script is that, like the other mailer implementation,
    it will wait for connections on port 33333, take action on any received messages,
    and then sleep for a moment before waiting for another message. This time, though,
    the script will send an email using the Simple Email Service command-line tool.
    Build and start a container with these two commands:'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从这个脚本中可以得出的关键教训是，就像其他邮件实现一样，它将在端口 33333 上等待连接，对收到的任何消息采取行动，然后在等待下一个消息之前暂停一下。不过，这次脚本将使用简单电子邮件服务的命令行工具发送电子邮件。使用以下两个命令构建并启动容器：
- en: '`docker image build -t dockerinaction/mailer-live -f mailer-live.df . docker
    run -d --name live-mailer dockerinaction/mailer-live`'
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/mailer-live -f mailer-live.df . docker
    run -d --name live-mailer dockerinaction/mailer-live`'
- en: If you link a watcher to these, you’ll find that the logging mailer works as
    advertised. But the live mailer seems to be having difficulty connecting to the
    Simple Email Service to send the message. With a bit of investigation, you’ll
    eventually realize that the container is misconfigured. The `aws` program requires
    certain environment variables to be set.
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你将这些与监视器链接起来，你会发现日志邮件器按预期工作。但实时邮件器似乎在连接到简单电子邮件服务以发送消息时遇到了困难。经过一点调查，你最终会意识到容器配置错误。`aws`
    程序需要设置某些环境变量。
- en: You need to set `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_DEFAULT
    _REGION` in order to get this example working. These environment variables define
    the AWS cloud credentials and location to use for this example. Discovering execution
    preconditions one by one as programs need them can be frustrating for users. [Section
    8.5.1](index_split_074.html#filepos860796) details an image design pattern that
    reduces this friction and helps adopters.
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使这个示例工作，你需要设置 `AWS_ACCESS_KEY_ID`、`AWS_SECRET_ACCESS_KEY` 和 `AWS_DEFAULT_REGION`。这些环境变量定义了用于此示例的
    AWS 云凭证和位置。随着程序需要时逐个发现执行先决条件可能会让用户感到沮丧。[第 8.5.1 节](index_split_074.html#filepos860796)详细介绍了减少这种摩擦并帮助采用者的镜像设计模式。
- en: Before you get to design patterns, you need to learn about the final Dockerfile
    instruction. Remember, not all images contain applications. Some are built as
    platforms for downstream images. Those cases specifically benefit from the ability
    to inject downstream build-time behavior.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在学习设计模式之前，你需要了解 Dockerfile 的最后一条指令。记住，并非所有镜像都包含应用程序。有些镜像被构建为下游镜像的平台。这些情况特别受益于注入下游构建时行为的能力。
- en: 8.3\. INJECTING DOWNSTREAM BUILD-TIME BEHAVIOR
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3. 注入下游构建时行为
- en: 'A Dockerfile instruction that is important for authors of base images is `ONBUILD`.
    The `ONBUILD` instruction defines other instructions to execute if the resulting
    image is used as a base for another build. For example, you could use `ONBUILD`
    instructions to compile a program that’s provided by a downstream layer. The upstream
    Dockerfile copies the contents of the build directory into a known location and
    then compiles the code at that location. The upstream Dockerfile would use a set
    of instructions like this:'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于基础镜像的作者来说，一个重要的Dockerfile指令是`ONBUILD`。`ONBUILD`指令定义了当生成的镜像用作另一个构建的基础时将执行的其它指令。例如，你可以使用`ONBUILD`指令来编译由下游层提供的程序。上游Dockerfile将构建目录的内容复制到已知位置，然后在该位置编译代码。上游Dockerfile将使用类似以下的指令集：
- en: '`ONBUILD COPY [".", "/var/myapp"] ONBUILD RUN go build /var/myapp`'
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ONBUILD COPY [".", "/var/myapp"] ONBUILD RUN go build /var/myapp`'
- en: 'The instructions following `ONBUILD` aren’t executed when their containing
    Dockerfile is built. Instead, those instructions are recorded in the resulting
    image’s metadata under `ContainerConfig.OnBuild`. The previous instructions would
    result in the following metadata inclusions:'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建包含`ONBUILD`指令的Dockerfile时，这些指令不会被执行。相反，这些指令会被记录在生成的镜像的元数据中，位于`ContainerConfig.OnBuild`下。之前的指令将导致以下元数据包含：
- en: '`... "ContainerConfig": { ...     "OnBuild": [          "COPY [\".\", \"/var/myapp\"]",
            "RUN go build /var/myapp"     ],     ...`'
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`... "ContainerConfig": { ...   "OnBuild": [   "COPY [\".\", \"/var/myapp\"]",  
    "RUN go build /var/myapp"   ],   ...`'
- en: This metadata is carried forward until the resulting image is used as the base
    for another Dockerfile build. When a downstream Dockerfile uses the upstream image
    (the one with the `ONBUILD` instructions) in a `FROM` instruction, those `ONBUILD`
    instructions are executed after the `FROM` instruction and before the next instruction
    in a Dockerfile.
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此元数据将一直保留，直到生成的镜像被用作另一个Dockerfile构建的基础。当下游Dockerfile在`FROM`指令中使用带有`ONBUILD`指令的上游镜像时，这些`ONBUILD`指令将在`FROM`指令之后和Dockerfile中的下一个指令之前执行。
- en: 'Consider the following example to see exactly when `ONBUILD` steps are injected
    into a build. You need to create two Dockerfiles and execute two build commands
    to get the full experience. First, create an upstream Dockerfile that defines
    the `ONBUILD` instructions. Name the file base.df and add the following instructions:'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑以下示例以了解`ONBUILD`步骤何时被注入到构建中。你需要创建两个Dockerfile并执行两个构建命令以获得完整的体验。首先，创建一个上游Dockerfile，该Dockerfile定义了`ONBUILD`指令。将文件命名为base.df，并添加以下指令：
- en: '`FROM busybox:latest WORKDIR /app RUN touch /app/base-evidence ONBUILD RUN
    ls -al /app`'
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM busybox:latest WORKDIR /app RUN touch /app/base-evidence ONBUILD RUN
    ls -al /app`'
- en: You can see that the image resulting from building base.df will add an empty
    file named base-evidence to the /app directory. The `ONBUILD` instruction will
    list the contents of the /app directory at build time, so it’s important that
    you not run the build in quiet mode if you want to see exactly when changes are
    made to the filesystem.
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以看到，从构建base.df生成的镜像将在/app目录中添加一个名为base-evidence的空文件。`ONBUILD`指令将在构建时列出/app目录的内容，因此如果你想要确切地看到文件系统何时发生变化，请不要以静默模式运行构建。
- en: 'Next, create the downstream Dockerfile. When this is built, you will be able
    to see exactly when the changes are made to the resulting image. Name the file
    downstream.df and include the following contents:'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，创建下游Dockerfile。当它被构建时，你将能够看到对生成的镜像所做的更改。将文件命名为downstream.df，并包含以下内容：
- en: '`FROM dockerinaction/ch8_onbuild RUN touch downstream-evidence RUN ls -al .`'
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM dockerinaction/ch8_onbuild RUN touch downstream-evidence RUN ls -al .`'
- en: This Dockerfile will use an image named `dockerinaction/ch8_onbuild` as a base,
    so that’s the repository name you’ll want to use when you build the base. Then
    you can see that the downstream build will create a second file and then list
    the contents of /app again.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此Dockerfile将使用名为`dockerinaction/ch8_onbuild`的镜像作为基础，因此当你构建基础镜像时，你需要使用该仓库名称。然后你可以看到下游构建将创建第二个文件，并再次列出/app目录的内容。
- en: 'With these two files in place, you’re ready to start building. Run the following
    to create the upstream image:'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这两个文件就绪后，你就可以开始构建了。运行以下命令以创建上游镜像：
- en: '`docker image build -t dockerinaction/ch8_onbuild -f base.df .`'
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch8_onbuild -f base.df .`'
- en: 'The output of the build should look like this:'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建输出的结果应该如下所示：
- en: '`Sending build context to Docker daemon  3.072kB Step 1/4 : FROM busybox:latest
    ---> 6ad733544a63 Step 2/4 : WORKDIR /app Removing intermediate container dfc7a2022b01
    ---> 9bc8aeafdec1  Step 3/4 : RUN touch /app/base-evidence ---> Running in d20474e07e45
    Removing intermediate container d20474e07e45 ---> 5d4ca3516e28 Step 4/4 : ONBUILD
    RUN ls -al /app ---> Running in fce3732daa59 Removing intermediate container fce3732daa59
    ---> 6ff141f94502 Successfully built 6ff141f94502 Successfully tagged dockerinaction/ch8_onbuild:latest`'
  id: totrans-380
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`将构建上下文发送到Docker守护进程  3.072kB 步骤 1/4 : FROM busybox:latest ---> 6ad733544a63
    步骤 2/4 : WORKDIR /app 移除中间容器 dfc7a2022b01 ---> 9bc8aeafdec1 步骤 3/4 : RUN touch
    /app/base-evidence ---> 在 d20474e07e45 中运行 移除中间容器 d20474e07e45 ---> 5d4ca3516e28
    步骤 4/4 : ONBUILD RUN ls -al /app ---> 在 fce3732daa59 中运行 移除中间容器 fce3732daa59 --->
    6ff141f94502 构建成功 6ff141f94502 成功标记 dockerinaction/ch8_onbuild:latest`'
- en: 'Then build the downstream image with this command:'
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后使用以下命令构建下游镜像：
- en: '`docker image build -t dockerinaction/ch8_onbuild_down -f downstream.df .`'
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch8_onbuild_down -f downstream.df .`'
- en: 'The results clearly show when the `ONBUILD` instruction (from the base image)
    is executed:'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果清楚地显示了当执行来自基础镜像的`ONBUILD`指令时：
- en: '`Sending build context to Docker daemon  3.072kB Step 1/3 : FROM dockerinaction/ch8_onbuild
    # Executing 1 build trigger ---> Running in 591f13f7a0e7 total 8 drwxr-xr-x   
    1 root     root          4096 Jun 18 03:12 . drwxr-xr-x    1 root     root         
    4096 Jun 18 03:13 .. -rw-r--r--    1 root     root             0 Jun 18 03:12
    base-evidence Removing intermediate container 591f13f7a0e7 ---> 5b434b4be9d8 Step
    2/3 : RUN touch downstream-evidence ---> Running in a42c0044d14d Removing intermediate
    container a42c0044d14d ---> e48a5ea7b66f Step 3/3 : RUN ls -al . ---> Running
    in 7fc9c2d3b3a2 total 8 drwxr-xr-x    1 root     root          4096 Jun 18 03:13
    . drwxr-xr-x    1 root     root          4096 Jun 18 03:13 .. -rw-r--r--    1
    root     root             0 Jun 18 03:12 base-evidence -rw-r--r--    1 root    
    root             0 Jun 18 03:13 downstream-evidence Removing intermediate container
    7fc9c2d3b3a2 ---> 46955a546cd3 Successfully built 46955a546cd3 Successfully tagged
    dockerinaction/ch8_onbuild_down:latest`'
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`将构建上下文发送到Docker守护进程  3.072kB 步骤 1/3 : FROM dockerinaction/ch8_onbuild # 执行
    1 个构建触发器 ---> 在 591f13f7a0e7 中运行 总计 8 drwxr-xr-x    1 root     root          4096
    Jun 18 03:12 . drwxr-xr-x    1 root     root          4096 Jun 18 03:13 .. -rw-r--r--   
    1 root     root             0 Jun 18 03:12 base-evidence 移除中间容器 591f13f7a0e7 --->
    5b434b4be9d8 步骤 2/3 : RUN touch downstream-evidence ---> 在 a42c0044d14d 中运行 移除中间容器
    a42c0044d14d ---> e48a5ea7b66f 步骤 3/3 : RUN ls -al . ---> 在 7fc9c2d3b3a2 中运行 总计
    8 drwxr-xr-x    1 root     root          4096 Jun 18 03:13 . drwxr-xr-x    1 root    
    root          4096 Jun 18 03:13 .. -rw-r--r--    1 root     root             0
    Jun 18 03:12 base-evidence -rw-r--r--    1 root     root             0 Jun 18
    03:13 downstream-evidence 移除中间容器 7fc9c2d3b3a2 ---> 46955a546cd3 构建成功 46955a546cd3
    成功标记 dockerinaction/ch8_onbuild_down:latest`'
- en: You can see the builder registering the `ONBUILD` instruction with the container
    metadata in step 4 of the base build. Later, the output of the downstream image
    build shows which triggers (`ONBUILD` instructions) it has inherited from the
    base image. The builder discovers and processes the trigger immediately after
    step 0, the `FROM` instruction. The output then includes the result of the `RUN`
    instruction specified by the trigger. The output shows that only evidence of the
    base build is present. Later, when the builder moves on to instructions from the
    downstream Dockerfile, it lists the contents of the /app directory again. The
    evidence of both changes is listed.
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在基础构建的第4步中看到构建器将`ONBUILD`指令与容器元数据注册。稍后，下游镜像构建的输出显示了它从基础镜像继承的触发器（`ONBUILD`指令）。构建器在步骤0（`FROM`指令）之后立即发现并处理触发器。输出包括触发器指定的`RUN`指令的结果。输出显示只有基础构建的证据存在。稍后，当构建器继续执行来自下游Dockerfile的指令时，它再次列出/app目录的内容。两个更改的证据都被列出。
- en: 'That example is more illustrative than it is useful. You should consider browsing
    Docker Hub and looking for images tagged with `onbuild` suffixes to get an idea
    about how this is used in the wild. Here are a couple of our favorites:'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那个例子比它有用得多。你应该考虑浏览Docker Hub，寻找带有`onbuild`后缀的镜像，以了解它在现实世界中的使用情况。以下是我们最喜欢的几个：
- en: '[https://hub.docker.com/r/_/python/](https://hub.docker.com/r/_/python/)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/r/_/python/](https://hub.docker.com/r/_/python/)'
- en: '[https://hub.docker.com/r/_/node/](https://hub.docker.com/r/_/node/)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/r/_/node/](https://hub.docker.com/r/_/node/)'
- en: 8.4\. CREATING MAINTAINABLE DOCKERFILES
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.4. 创建可维护的Dockerfile
- en: Dockerfile has features that make maintaining closely related images easier.
    These features help authors share metadata and data between images at build time.
    Let’s work through a couple of Dockerfile implementations and use these features
    to make them more concise and maintainable.
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile具有使维护紧密相关的镜像更简单的功能。这些功能帮助作者在构建时在镜像之间共享元数据和数据。让我们通过几个Dockerfile实现来工作，并使用这些功能使它们更简洁、更易于维护。
- en: As you were writing the mailer application’s Dockerfiles, you may have noticed
    a few repeated bits that need to change for every update. The `VERSION` variable
    is the best example of repetition. The version metadata goes into the image tag,
    environment variable, and label metadata. There’s another issue, too. Build systems
    often derive version metadata from the application’s version-control system. We
    would prefer not to hardcode it in our Dockerfiles or scripts.
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您编写邮件应用程序的Dockerfile时，您可能已经注意到一些需要每次更新时都更改的重复部分。`VERSION`变量是重复的最佳例子。版本元数据进入镜像标签、环境变量和标签元数据。还有一个问题。构建系统通常从应用程序的版本控制系统中提取版本元数据。我们宁愿不在我们的Dockerfile或脚本中硬编码它。
- en: The Dockerfile’s `ARG` instruction provides a solution to these problems. `ARG`
    defines a variable that users can provide to Docker when building an image. Docker
    interpolates the argument value into the Dockerfile, allowing creation of parametrized
    Dockerfiles. You provide build arguments to the `docker image build` command by
    using one or more `--build-arg <varname>=<value>` options.
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile的`ARG`指令提供了解决这些问题的方案。`ARG`定义了一个变量，用户可以在构建镜像时提供给Docker。Docker将参数值插入到Dockerfile中，允许创建参数化的Dockerfile。您可以通过使用一个或多个`--build-arg
    <varname>=<value>`选项来向`docker image build`命令提供构建参数。
- en: 'Let’s introduce the `ARG VERSION` instruction into mailer-base.df on line 2:'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们在mailer-base.df的第2行引入`ARG VERSION`指令：
- en: '`FROM debian:buster-20190910 ARG VERSION=unknown` `1` `LABEL maintainer="dia@allingeek.com"
    RUN groupadd -r -g 2200 example && \     useradd -rM -g example -u 2200 example
    ENV APPROOT="/app" \     APP="mailer.sh" \     VERSION="${VERSION}" LABEL base.name="Mailer
    Archetype" \       base.version="${VERSION}" WORKDIR $APPROOT ADD . $APPROOT ENTRYPOINT
    ["/app/mailer.sh"] EXPOSE 33333`'
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM debian:buster-20190910 ARG VERSION=unknown` `1` `LABEL maintainer="dia@allingeek.com"
    RUN groupadd -r -g 2200 example && \     useradd -rM -g example -u 2200 example
    ENV APPROOT="/app" \     APP="mailer.sh" \     VERSION="${VERSION}" LABEL base.name="Mailer
    Archetype" \       base.version="${VERSION}" WORKDIR $APPROOT ADD . $APPROOT ENTRYPOINT
    ["/app/mailer.sh"] EXPOSE 33333`'
- en: 1 Defines the VERSION build arg with default value “unknown”
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 定义了具有默认值“unknown”的VERSION构建参数
- en: 'Now the version can be defined once as a shell variable and passed on the command
    line as both the image tag and a build argument for use within the image:'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在可以将版本定义一次作为shell变量，并通过命令行作为镜像标签和构建参数传递，以便在镜像内部使用：
- en: '`version=0.6; docker image build -t dockerinaction/mailer-base:${version} \
        -f mailer-base.df \     --build-arg VERSION=${version} \     .`'
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`version=0.6; docker image build -t dockerinaction/mailer-base:${version} \
        -f mailer-base.df \     --build-arg VERSION=${version} \     .`'
- en: 'Let’s use `docker image inspect` to verify that the `VERSION` was substituted
    all the way down to the `base.version` label:'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们使用`docker image inspect`来验证`VERSION`是否被替换到了`base.version`标签中：
- en: '`docker image inspect --format ''{{ json .Config.Labels }}'' \     dockerinaction/mailer-base:0.6`'
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image inspect --format ''{{ json .Config.Labels }}'' \     dockerinaction/mailer-base:0.6`'
- en: 'The `inspect` command should produce JSON output that looks like this:'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`inspect`命令应该产生类似以下的JSON输出：'
- en: '`{   "base.name": "Mailer Archetype",   "base.version": "0.6",   "maintainer":
    "dia@allingeek.com" }`'
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`{   "base.name": "Mailer Archetype",   "base.version": "0.6",   "maintainer":
    "dia@allingeek.com" }`'
- en: If you had not specified `VERSION` as a build argument, the default value of
    `unknown` would be used and a warning printed during the build process.
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您没有指定`VERSION`作为构建参数，则将使用默认值`unknown`并在构建过程中打印警告。
- en: Let’s turn our attention to multistage builds, which can help manage important
    concerns by distinguishing between phases of an image build. Multistage builds
    can help solve a few common problems. The primary uses are reusing parts of another
    image, separating the build of an application from the build of an application
    runtime image, and enhancing an application’s runtime image with specialized test
    or debug tools. The example that follows demonstrates reusing parts of another
    image as well as separating an application’s build and runtime concerns. First,
    let’s learn about Dockerfile’s multistage feature.
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们把注意力转向多阶段构建，它可以通过区分镜像构建的不同阶段来管理重要的问题。多阶段构建可以帮助解决一些常见问题。主要用途包括重用另一个镜像的部分、将应用程序的构建与应用程序运行时镜像的构建分离，以及通过专门的测试或调试工具增强应用程序的运行时镜像。下面的例子展示了如何重用另一个镜像的部分以及分离应用程序的构建和运行时问题。首先，让我们了解Dockerfile的多阶段功能。
- en: A multistage Dockerfile is a Dockerfile that has multiple `FROM` instructions.
    Each `FROM` instruction marks a new build stage whose final layer may be referenced
    in a downstream stage. The build stage is named by appending `AS <name>` to the
    `FROM` instruction, where `name` is an identifier you specify, such as `builder`.
    The name can be used in subsequent `FROM` and `COPY --from=<name|index>` instructions,
    providing a convenient way to identify the source layer for files brought into
    the image build. When you build a Dockerfile with multiple stages, the build process
    still produces a single Docker image. The image is produced from the final stage
    executed in the Dockerfile.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多阶段Dockerfile是一个包含多个`FROM`指令的Dockerfile。每个`FROM`指令标记一个新的构建阶段，其最终层可以在下游阶段中引用。通过在`FROM`指令后附加`AS
    <name>`来命名构建阶段，其中`name`是你指定的标识符，例如`builder`。该名称可以在后续的`FROM`和`COPY --from=<name|index>`指令中使用，为将文件带入镜像构建的源层提供了一个方便的标识方式。当你使用多个阶段构建Dockerfile时，构建过程仍然会产生一个单一的Docker镜像。该镜像是由Dockerfile中执行的最终阶段产生的。
- en: Let’s demonstrate the use of multistage builds with an example that uses two
    stages and a bit of composition; see [figure 8.2](#filepos850024). An easy way
    to follow along with this example is to clone the Git repository at `git@github.com:dockerinaction/ch8_multi_stage_build.git`.
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们通过一个使用两个阶段和一些组合的例子来演示多阶段构建的使用；参见[图8.2](#filepos850024)。跟随这个例子的一种简单方法是克隆位于`git@github.com:dockerinaction/ch8_multi_stage_build.git`的Git仓库。
- en: Figure 8.2\. Multistage Docker builds
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图8.2. 多阶段Docker构建
- en: '![](images/00021.jpg)'
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00021.jpg)'
- en: 'This Dockerfile defines two stages: `builder` and `runtime`. The `builder`
    stage gathers dependencies and builds the example program. The `runtime` stage
    copies the certificate authority (CA) and program files into the runtime image
    for execution. The source of the `http-client`.df Dockerfile is as follows:'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此Dockerfile定义了两个阶段：`builder`和`runtime`。`builder`阶段收集依赖并构建示例程序。`runtime`阶段将证书授权（CA）和程序文件复制到运行时镜像中以执行。`http-client`.df
    Dockerfile的来源如下：
- en: '`################################################# # Define a Builder stage
    and build app inside it FROM golang:1-alpine as builder  # Install CA Certificates
    RUN apk update && apk add ca-certificates  # Copy source into Builder ENV HTTP_CLIENT_SRC=$GOPATH/src/dia/http-client/
    COPY . $HTTP_CLIENT_SRC WORKDIR $HTTP_CLIENT_SRC  # Build HTTP Client RUN CGO_ENABLED=0
    GOOS=linux GOARCH=amd64 \     go build -v -o /go/bin/http-client  #################################################
    # Define a stage to build a runtime image. FROM scratch as runtime ENV PATH="/bin"
    # Copy CA certificates and application binary from builder stage COPY --from=builder
    \     /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt COPY
    --from=builder /go/bin/http-client /http-client ENTRYPOINT ["/http-client"]`'
  id: totrans-409
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`################################################# # 定义一个Builder阶段并在其中构建应用
    FROM golang:1-alpine as builder  # 安装CA证书 RUN apk update && apk add ca-certificates  #
    将源代码复制到Builder ENV HTTP_CLIENT_SRC=$GOPATH/src/dia/http-client/ COPY . $HTTP_CLIENT_SRC
    WORKDIR $HTTP_CLIENT_SRC  # 构建HTTP客户端 RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64
    \    go build -v -o /go/bin/http-client  #################################################
    # 定义一个构建运行时镜像的阶段 FROM scratch as runtime ENV PATH="/bin" # 从builder阶段复制CA证书和应用程序二进制文件
    COPY --from=builder \    /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt
    COPY --from=builder /go/bin/http-client /http-client ENTRYPOINT ["/http-client"]`'
- en: Let’s examine the image build in detail. The `FROM golang:1-alpine as builder`
    instruction declares that the first stage will be based on Golang’s alpine image
    variation and aliased to `builder` for easy referencing by later stages. First,
    `builder` installs certificate authority files used to establish Transport Layer
    Security (TLS) connections supporting HTTPS. These CA files aren’t used in this
    stage, but will be stored for composition by the runtime image. Next, the `builder`
    stage copies the `http-client` source code into the container and builds the `http-client`
    Golang program into a static binary. The `http-client` program is stored in the
    `builder` container at /go/bin/http-client.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们详细检查镜像构建过程。`FROM golang:1-alpine as builder` 指令声明第一个阶段将基于 Golang 的 alpine
    镜像变体，并别名为 `builder` 以便于后续阶段的引用。首先，`builder` 安装用于建立支持 HTTPS 的传输层安全 (TLS) 连接的证书颁发机构文件。这些
    CA 文件在本阶段未使用，但将被存储以供运行时镜像组合使用。接下来，`builder` 阶段将 `http-client` 源代码复制到容器中，并将 `http-client`
    Golang 程序构建为静态二进制文件。`http-client` 程序存储在 `builder` 容器的 `/go/bin/http-client` 目录下。
- en: 'The `http-client` program is simple. It makes an HTTP request to retrieve its
    own source code from GitHub:'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`http-client` 程序很简单。它通过 GitHub 发起 HTTP 请求以检索其自身的源代码：'
- en: '`package main  import (     "net/http" ) import "io/ioutil" import "fmt"  func
    main() {     url := "https://raw.githubusercontent.com/" +         "dockerinaction/ch8_multi_stage_build/master/http-client.go"
        resp, err := http.Get(url)      if err != nil {             panic(err)    
    }     defer resp.Body.Close()     body, err := ioutil.ReadAll(resp.Body)     fmt.Println("response:\n",
    string(body)) }`'
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`package main  import (     "net/http" ) import "io/ioutil" import "fmt"  func
    main() {     url := "https://raw.githubusercontent.com/" +         "dockerinaction/ch8_multi_stage_build/master/http-client.go"
        resp, err := http.Get(url)      if err != nil {             panic(err)    
    }     defer resp.Body.Close()     body, err := ioutil.ReadAll(resp.Body)     fmt.Println("response:\n",
    string(body)) }`'
- en: 'The `runtime` stage is based on `scratch`. When you build an image `FROM scratch`,
    the filesystem begins empty and the image will contain only what is `COPY`’d there.
    Notice that the `http.Get` statement retrieves the file by using the HTTPS protocol.
    This means the program will need a set of valid TLS certificate authorities. CA
    authorities are available from the `builder` stage because you installed them
    previously. The `runtime` stage copies both the ca-certificates.crt and `http-client`
    files from the `builder` stage into the `runtime` stage with the following:'
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runtime` 阶段基于 `scratch`。当你构建一个 `FROM scratch` 的镜像时，文件系统开始时是空的，镜像将只包含被 `COPY`
    到那里的内容。请注意，`http.Get` 语句通过 HTTPS 协议检索文件。这意味着程序需要一个有效的 TLS 证书颁发机构集合。CA 颁发机构从 `builder`
    阶段提供，因为你之前已经安装了它们。`runtime` 阶段使用以下命令将 `ca-certificates.crt` 和 `http-client` 文件从
    `builder` 阶段复制到 `runtime` 阶段：'
- en: '`COPY --from=builder \     /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt
    COPY --from=builder /go/bin/http-client /http-client`'
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`COPY --from=builder \ /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt
    COPY --from=builder /go/bin/http-client /http-client`'
- en: 'The `runtime` stage finishes by setting the `ENTRYPOINT` of the image to `/http-client`,
    which will be invoked when the container starts. The final image will contain
    just two files. You can build the image with a command like this:'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`runtime` 阶段通过将镜像的 `ENTRYPOINT` 设置为 `/http-client` 来结束，当容器启动时将调用该命令。最终的镜像将只包含两个文件。你可以使用如下命令构建镜像：'
- en: '`docker build -t dockerinaction/http-client -f http-client.df .`'
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker build -t dockerinaction/http-client -f http-client.df .`'
- en: 'The image can be executed as follows:'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以按照以下方式执行镜像：
- en: '`docker container run --rm -it dockerinaction/http-client:latest`'
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it dockerinaction/http-client:latest`'
- en: When the `http-client` image runs successfully, it will output the http-client.go
    source code listed previously. To recap, the http-client.df Dockerfile uses a
    `builder` stage to retrieve runtime dependencies and build the `http-client` program.
    The `runtime` stage then copies `http-client` and its dependencies from the `builder`
    stage onto the minimal `scratch` base and configures it for execution. The resulting
    image contains only what is needed to run the program and is just over 6 MB in
    size. In the next section, we’ll work through a different style of application
    delivery using defensive startup scripts.
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 `http-client` 镜像成功运行时，它将输出之前列出的 http-client.go 源代码。总结一下，http-client.df Dockerfile
    使用 `builder` 阶段来检索运行时依赖项并构建 `http-client` 程序。然后，`runtime` 阶段将 `http-client` 和其依赖项从
    `builder` 阶段复制到最小的 `scratch` 基础镜像上，并为其执行进行配置。生成的镜像只包含运行程序所需的内容，大小仅为 6 MB 多一点。在下一节中，我们将通过使用防御性启动脚本的不同风格来处理应用程序交付。
- en: 8.5\. USING STARTUP SCRIPTS AND MULTIPROCESS CONTAINERS
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.5. 使用启动脚本和多进程容器
- en: Whatever tooling you choose to use, you’ll always need to consider a few image
    design aspects. You’ll need to ask yourself whether the software running in your
    container requires any startup assistance, supervision, monitoring, or coordination
    with other in-container processes. If so, you’ll need to include a startup script
    or initialization program with the image and install it as the entrypoint.
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你选择使用什么工具，你都需要考虑一些图像设计方面。你需要问自己，运行在你容器中的软件是否需要任何启动辅助、监督、监控或与其他容器内进程的协调。如果是这样，你需要在镜像中包含一个启动脚本或初始化程序，并将其安装为入口点。
- en: 8.5.1\. Environmental preconditions validation
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.5.1. 环境预条件验证
- en: Failure modes are difficult to communicate and can catch someone off guard if
    they occur at arbitrary times. If container configuration problems always cause
    failures at startup time for an image, users can be confident that a started container
    will keep running.
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 失败模式难以沟通，如果它们在任意时间发生，可能会让人措手不及。如果容器配置问题总是导致镜像在启动时失败，用户可以确信启动的容器将保持运行。
- en: In software design, failing fast and precondition validation are best practices.
    It makes sense that the same should hold true for image design. The preconditions
    that should be evaluated are assumptions about the context.
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在软件设计中，快速失败和预条件验证是最佳实践。对于图像设计来说，同样适用这一原则。应该评估的预条件是关于上下文的假设。
- en: Docker containers have no control over the environment where they’re created.
    They do, however, have control of their own execution. An image author can solidify
    the user experience of their image by introducing environment and dependency validation
    prior to execution of the main task. A container user will be better informed
    about the requirements of an image if containers built from that image fail fast
    and display descriptive error messages.
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker容器无法控制其创建的环境。然而，它们对自己的执行有控制权。镜像作者可以通过在执行主要任务之前引入环境和依赖项验证来巩固其镜像的用户体验。如果从该镜像构建的容器快速失败并显示描述性错误消息，容器用户将更好地了解镜像的要求。
- en: For example, WordPress requires certain environment variables to be set or container
    links to be defined. Without that context, WordPress would be unable to connect
    to the database where the blog data is stored. It would make no sense to start
    WordPress in a container without access to the data it’s supposed to serve. WordPress
    images use a script as the container entrypoint. That script validates that the
    container context is set in a way that’s compatible with the contained version
    of WordPress. If any required condition is unmet (a link is undefined or a variable
    is unset), the script will exit before starting WordPress, and the container will
    stop unexpectedly.
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，WordPress需要设置某些环境变量或定义容器链接。没有这个上下文，WordPress将无法连接到存储博客数据的数据库。在没有访问它应该提供的数据的情况下启动WordPress在容器中是没有意义的。WordPress镜像使用脚本作为容器入口点。该脚本验证容器上下文是否以与包含的WordPress版本兼容的方式设置。如果任何必需条件未满足（链接未定义或变量未设置），脚本将在启动WordPress之前退出，容器将意外停止。
- en: 'Validating the preconditions for a program startup is generally use-case specific.
    If you’re packaging software into an image, you’ll usually need to write a script
    or carefully configure the tool used to start the program yourself. The startup
    process should validate as much of the assumed context as possible. This should
    include the following:'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 验证程序启动的预条件通常是特定于用例的。如果你正在将软件打包到镜像中，你通常需要自己编写脚本或仔细配置用于启动程序的工具。启动过程应尽可能验证假设的上下文。这应包括以下内容：
- en: Presumed links (and aliases)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设链接（以及别名）
- en: Environment variables
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Secrets
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Network access
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络访问
- en: Network port availability
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络端口可用性
- en: Root filesystem mount parameters (read-write or read-only)
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统挂载参数（读写或只读）
- en: Volumes
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷
- en: Current user
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前用户
- en: You can use whichever scripting or programming language you want to accomplish
    this task. In the spirit of building minimal images, it’s a good idea to use a
    language or scripting tool that’s already included with the image. Most base images
    ship with a shell such as /bin/sh or /bin/bash. Shell scripts are the most common
    because shell programs are commonly available and they easily adapt to program
    and environment-specific requirements. When building an image from `scratch` for
    a single binary such as the `http-client` example from [section 8.4](index_split_073.html#filepos840807),
    the program is responsible for validating its own preconditions, as no other programs
    will exist in the container.
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用任何您想要的脚本或编程语言来完成此任务。在构建最小化镜像的精神下，使用已包含在镜像中的语言或脚本工具是个好主意。大多数基础镜像都附带了一个 shell，如
    /bin/sh 或 /bin/bash。Shell 脚本是最常见的，因为 shell 程序通常可用，并且它们可以轻松适应特定程序和环境的要求。当从 `scratch`
    构建一个用于单个二进制文件的镜像，例如来自 [第 8.4 节](index_split_073.html#filepos840807) 的 `http-client`
    示例时，程序负责验证其自身的先决条件，因为没有其他程序将存在于容器中。
- en: 'Consider the following shell script that might accompany a program that depends
    on a web server. At container startup, this script enforces that either another
    container has been linked to the web alias and has exposed port 80, or the `WEB_HOST`
    environment variable has been defined:'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑以下可能伴随依赖 web 服务器的程序的 shell 脚本。在容器启动时，此脚本强制执行以下条件：另一个容器已链接到 web 别名并暴露了端口 80，或者已定义
    `WEB_HOST` 环境变量：
- en: '`#!/bin/bash set -e  if [ -n "$WEB_PORT_80_TCP" ]; then   if [ -z "$WEB_HOST"
    ]; then     WEB_HOST=''web''   else     echo >&2 ''[WARN]: Linked container, "web"
    overridden by $WEB_HOST.''     echo >&2 "===> Connecting to WEB_HOST ($WEB_HOST)"
      fi fi  if [ -z "$WEB_HOST" ]; then   echo >&2 ''[ERROR]: specify container to
    link; "web" or WEB_HOST env var''   exit 1 fi exec "$@" # run the default command`'
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`#!/bin/bash set -e  if [ -n "$WEB_PORT_80_TCP" ]; then   if [ -z "$WEB_HOST"
    ]; then     WEB_HOST=''web''   else     echo >&2 ''[WARN]: Linked container, "web"
    overridden by $WEB_HOST.''     echo >&2 "===> Connecting to WEB_HOST ($WEB_HOST)"
      fi fi  if [ -z "$WEB_HOST" ]; then   echo >&2 ''[ERROR]: specify container to
    link; "web" or WEB_HOST env var''   exit 1 fi exec "$@" # run the default command`'
- en: If you’re unfamiliar with shell scripting, this is an appropriate time to learn
    it. The topic is approachable, and several excellent resources are available for
    self-directed learning. This specific script uses a pattern in which both an environment
    variable and a container link are tested. If the environment variable is set,
    the container link will be ignored. Finally, the default command is executed.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您不熟悉 shell 脚本，现在是学习它的时候了。这个主题是可接近的，并且有几种优秀的资源可供自学。这个特定的脚本使用了一种模式，其中同时测试了环境变量和容器链接。如果环境变量已设置，则忽略容器链接。最后，执行默认命令。
- en: Images that use a startup script to validate configuration should fail fast
    if someone uses them incorrectly, but those same containers may fail later for
    other reasons. You can combine startup scripts with container restart policies
    to make reliable containers. But container restart policies are not perfect solutions.
    Containers that have failed and are waiting to be restarted aren’t running. This
    means that an operator won’t be able to execute another process within a container
    that’s in the middle of a backoff window. The solution to this problem involves
    making sure the container never stops.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用启动脚本验证配置的镜像如果被错误使用，应快速失败，但相同的容器可能因其他原因稍后失败。您可以将启动脚本与容器重启策略结合使用，以创建可靠的容器。但容器重启策略并不是完美的解决方案。已失败并等待重启的容器没有运行。这意味着操作员无法在处于回退窗口中的容器内执行另一个进程。解决这个问题需要确保容器永远不会停止。
- en: 8.5.2\. Initialization processes
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.5.2\. 初始化进程
- en: UNIX-based computers usually start an initialization (init) process first. That
    init process is responsible for starting all the other system services, keeping
    them running, and shutting them down. It’s often appropriate to use an init-style
    system to launch, manage, restart, and shut down container processes with a similar
    tool.
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基于 UNIX 的计算机通常首先启动初始化（init）进程。该 init 进程负责启动所有其他系统服务，保持它们运行，并关闭它们。使用类似工具启动、管理、重启和关闭容器进程的
    init 风格系统通常是合适的。
- en: Init processes typically use a file or set of files to describe the ideal state
    of the initialized system. These files describe what programs to start, when to
    start them, and what actions to take when they stop. Using an init process is
    the best way to launch multiple programs, clean up orphaned processes, monitor
    processes, and automatically restart any failed processes.
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化进程通常使用一个或一组文件来描述初始化系统的理想状态。这些文件描述了要启动哪些程序，何时启动它们，以及停止时采取哪些行动。使用初始化进程是启动多个程序、清理孤儿进程、监控进程和自动重启任何失败进程的最佳方式。
- en: If you decide to adopt this pattern, you should use the init process as the
    entrypoint of your application-oriented Docker container. Depending on the init
    program you use, you may need to prepare the environment beforehand with a startup
    script.
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你决定采用这种模式，你应该使用初始化进程作为你应用程序容器入口点。根据你使用的初始化程序，你可能需要使用启动脚本事先准备环境。
- en: For example, the runit program doesn’t pass environment variables to the programs
    it launches. If your service uses a startup script to validate the environment,
    it won’t have access to the environment variables it needs. The best way to fix
    that problem might be to use a startup script for the runit program. That script
    might write the environment variables to a file so the startup script for your
    application can access them.
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，runit 程序不会将环境变量传递给它启动的程序。如果你的服务使用启动脚本来验证环境，它将无法访问所需的变量。解决这个问题最好的方法可能是为 runit
    程序使用一个启动脚本。这个脚本可能将环境变量写入一个文件，以便你的应用程序的启动脚本可以访问它们。
- en: Several open source init programs exist. Full-featured Linux distributions ship
    with heavyweight and full-featured init systems such as SysV, Upstart, and systemd.
    Linux Docker images such as Ubuntu, Debian, and CentOS typically have their init
    programs installed but nonfunctioning out of the box. These can be complex to
    configure and may have hard dependencies on resources that require root access.
    For that reason, the community has tended toward the use of lighter-weight init
    programs.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 存在着几个开源的初始化程序。功能齐全的 Linux 发行版通常带有重量级和功能齐全的初始化系统，如 SysV、Upstart 和 systemd。Ubuntu、Debian
    和 CentOS 等典型的 Linux Docker 镜像通常已经安装了初始化程序，但默认情况下可能无法正常工作。这些配置可能很复杂，并且可能对需要 root
    访问的资源有硬依赖。因此，社区倾向于使用更轻量级的初始化程序。
- en: 'Popular options include runit, tini, BusyBox init, Supervisord, and DAEMON
    Tools. These all attempt to solve similar problems, but each has its benefits
    and costs. Using an init process is a best practice for application containers,
    but there’s no perfect init program for every use case. When evaluating any init
    program for use in a container, consider these factors:'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 流行选项包括 runit、tini、BusyBox init、Supervisord 和 DAEMON Tools。这些都试图解决类似的问题，但每个都有其优势和成本。使用初始化进程是应用程序容器的最佳实践，但并不是每个用例都有一个完美的初始化程序。在评估任何用于容器的初始化程序时，考虑以下因素：
- en: Additional dependencies the program brings into the image
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序带入镜像的额外依赖
- en: File sizes
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小
- en: How the program passes signals to its child processes (or if it does at all)
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序如何传递信号给其子进程（或者是否传递）
- en: Required user access
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的用户访问权限
- en: Monitoring and restart functionality (backoff-on-restart features are a bonus)
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和重启功能（重启时的回退特性是额外的优势）
- en: Zombie process cleanup features
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 僵尸进程清理功能
- en: 'Init processes are so important that Docker provides an `--init` option to
    run an init process inside the container to manage the program being executed.
    The `--init` option can be used to add an init process to an existing image. For
    example, you can run Netcat using the `alpine:3.6` image and manage it with an
    init process:'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化进程非常重要，以至于 Docker 提供了一个 `--init` 选项，在容器内运行一个初始化进程来管理正在执行的程序。可以使用 `--init`
    选项向现有镜像添加一个初始化进程。例如，你可以使用 `alpine:3.6` 镜像运行 Netcat，并用初始化进程来管理它：
- en: '`docker container run -it --init alpine:3.6 nc -l -p 3000`'
  id: totrans-455
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -it --init alpine:3.6 nc -l -p 3000`'
- en: If you inspect the host’s processes with `ps -ef`, you will see Docker ran `/dev/init
    -- nc -l -p 3000` inside the container instead of just `nc`. Docker uses the `tini`
    program as an init process by default, though you may specify another init process
    instead.
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你使用 `ps -ef` 检查主机的进程，你将看到 Docker 在容器内运行了 `/dev/init -- nc -l -p 3000` 而不是仅仅
    `nc`。默认情况下，Docker 使用 `tini` 程序作为初始化进程，尽管你也可以指定另一个初始化进程。
- en: Whichever init program you decide on, make sure your image uses it to boost
    adopter confidence in containers created from your image. If the container needs
    to fail fast to communicate a configuration problem, make sure the init program
    won’t hide that failure. Now that you have a solid foundation for running and
    signaling processes inside containers, let’s see how to communicate the health
    of containerized processes to collaborators.
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你决定使用哪个init程序，都要确保你的镜像使用它来提高从你的镜像创建的容器用户的信心。如果容器需要快速失败以传达配置问题，请确保init程序不会隐藏该失败。现在你已经为在容器内运行和信号进程打下了坚实的基础，让我们看看如何将容器化进程的健康状态传达给协作者。
- en: 8.5.3\. The purpose and use of health checks
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.5.3. 健康检查的目的和使用
- en: Health checks are used to determine whether the application running inside the
    container is ready and able to perform its function. Engineers define application-specific
    health checks for containers to detect conditions when the application is running,
    but is stuck or has broken dependencies.
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 健康检查用于确定容器内运行的应用程序是否已准备好并能够执行其功能。工程师为容器定义特定于应用程序的健康检查，以检测应用程序运行时但卡住或具有损坏依赖项的情况。
- en: 'Docker runs a single command inside the container to determine whether the
    application is healthy. There are two ways to specify the health check command:'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker在容器内运行单个命令以确定应用程序是否健康。有两种方式可以指定健康检查命令：
- en: Use a `HEALTHCHECK` instruction when defining the image
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义镜像时使用`HEALTHCHECK`指令
- en: On the command-line when running a container
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行中运行容器时
- en: 'This Dockerfile defines a health check for the NGINX web server:'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个Dockerfile定义了NGINX网络服务器的健康检查：
- en: '`FROM nginx:1.13-alpine  HEALTHCHECK --interval=5s --retries=2 \   CMD nc -vz
    -w 2 localhost 80 || exit 1`'
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM nginx:1.13-alpine  HEALTHCHECK --interval=5s --retries=2 \   CMD nc -vz
    -w 2 localhost 80 || exit 1`'
- en: 'The health check command should be reliable, lightweight, and not interfere
    with the operation of the main application because it will be executed frequently.
    The command’s exit status will be used to determine the container’s health. Docker
    has defined the following exit statuses:'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 健康检查命令应该是可靠的、轻量级的，并且不会干扰主应用程序的操作，因为它将被频繁执行。命令的退出状态将用于确定容器的健康状态。Docker定义了以下退出状态：
- en: '0: success—  The container is healthy and ready for use.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: 成功 - 容器健康且可供使用。'
- en: '1: unhealthy—  The container is not working correctly.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: 不健康 - 容器工作不正确。'
- en: '2: reserved—  Do not use this exit code.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: 保留 -  不要使用此退出代码。'
- en: Most programs in the UNIX world exit with a 0 status when things went as expected,
    and a nonzero status otherwise. The `|| exit 1` is a bit of shell trickery that
    means or exit 1. This means whenever `nc` exits with any nonzero status, `nc`’s
    status will be converted to 1 so that Docker knows the container is unhealthy.
    Conversion of nonzero exit statuses to 1 is a common pattern because Docker does
    not define the behavior of all nonzero health check statuses, only 1 and 2\. As
    of this writing, use of an exit code whose behavior is not defined will result
    in an unhealthy status.
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在UNIX世界中的大多数程序在预期顺利进行时退出状态为0，否则为非零状态。`|| exit 1`是一种shell技巧，意味着或退出1。这意味着每当`nc`以任何非零状态退出时，`nc`的状态将被转换为1，这样Docker就知道容器不健康。将非零退出状态转换为1是一种常见模式，因为Docker没有定义所有非零健康检查状态的行为，只有1和2。截至本文撰写时，使用未定义行为的退出代码将导致不健康状态。
- en: 'Let’s build and run the NGINX example:'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们构建并运行NGINX示例：
- en: '`docker image build -t dockerinaction/healthcheck . docker container run --name
    healthcheck_ex -d dockerinaction/healthcheck`'
  id: totrans-471
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/healthcheck . docker container run --name
    healthcheck_ex -d dockerinaction/healthcheck`'
- en: 'Now that a container with a health check is running, you can inspect the container’s
    health status with `docker ps`. When a health check is defined, the `docker p`s
    command reports the container’s current health status in the STATUS column. Docker
    `ps` output can be a bit unwieldy, so you will use a custom format that prints
    the container name, image name, and status in a table:'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在运行了一个带有健康检查的容器，你可以使用`docker ps`来检查容器的健康状态。当定义了健康检查时，`docker ps`命令会在状态列中报告容器的当前健康状态。Docker
    `ps`的输出可能有点难以处理，所以你会使用一个自定义格式，该格式以表格形式打印容器名称、镜像名称和状态：
- en: '`docker ps --format ''table {{.Names}}\t{{.Image}}\t{{.Status}}'' NAMES              
    IMAGE                        STATUS healthcheck_ex      dockerinaction/healthcheck  
    Up 3 minutes (healthy)`'
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker ps --format ''table {{.Names}}\t{{.Image}}\t{{.Status}}'' NAMES              
    IMAGE                        STATUS healthcheck_ex      dockerinaction/healthcheck  
    Up 3 minutes (healthy)`'
- en: By default, the health check command will be run every 30 seconds, and three
    failed checks are required before transitioning the container’s `health_status`
    to `unhealthy`. The health check interval and number of consecutive failures before
    reporting a container as unhealthy can be adjusted in the `HEALTHCHECK` instruction
    or when running the container.
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，健康检查命令将每 30 秒运行一次，并且需要三次失败检查才能将容器的 `health_status` 转换为 `unhealthy`。健康检查间隔和报告容器为不健康之前所需的连续失败次数可以在
    `HEALTHCHECK` 指令或运行容器时进行调整。
- en: 'The health check facility also supports options for the following:'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 健康检查功能还支持以下选项：
- en: Time-out—  A time-out for the health check command to run and exit.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时— 健康检查命令运行和退出的超时时间。
- en: Start period—  A grace period at the start of a container to not count health
    check failures toward the health status; once the health check command returns
    `healthy`, the container is considered started, and subsequent failures count
    toward the health status.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动期间— 容器启动初期的宽限期，在此期间不计入健康检查失败对健康状态的影响；一旦健康检查命令返回 `healthy`，则认为容器已启动，后续的失败将计入健康状态。
- en: Image authors should define a useful health check in images where possible.
    Usually this means exercising the application in some way or checking an internal
    application health status indicator such as a `/health` endpoint on a web server.
    However, sometimes it is impractical to define a `HEALTHCHECK` instruction because
    not enough is known about how the image will run ahead of time. To address this
    problem, Docker provides the `--health-cmd` to define a health check when running
    a container.
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像作者应在可能的情况下在镜像中定义有用的健康检查。通常这意味着以某种方式锻炼应用程序或检查内部应用程序健康状态指示器，例如在 Web 服务器上的 `/health`
    端点。然而，有时定义 `HEALTHCHECK` 指令是不切实际的，因为事先对镜像如何运行了解不足。为了解决这个问题，Docker 提供了 `--health-cmd`
    来在运行容器时定义健康检查。
- en: 'Let’s take the previous `HEALTHCHECK` example and specify the health check
    when running the container instead:'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以前面的 `HEALTHCHECK` 示例为例，在运行容器时指定健康检查：
- en: '`docker container run --name=healthcheck_ex -d \   --health-cmd=''nc -vz -w
    2 localhost 80 || exit 1'' \   nginx:1.13-alpine`'
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --name=healthcheck_ex -d \ --health-cmd=''nc -vz -w 2
    localhost 80 || exit 1'' \ nginx:1.13-alpine`'
- en: Defining a health check at runtime overrides the health check defined in the
    image if one exists. This is useful for integrating a third-party image because
    you can account for requirements specific to your environment.
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行时定义健康检查会覆盖镜像中定义的健康检查（如果存在）。这对于集成第三方镜像很有用，因为你可以考虑特定于你的环境的要求。
- en: These are the tools at your disposal to build images that result in durable
    containers. Durability is not security, and although adopters of your durable
    images might trust that they will keep running as long as they can, they shouldn’t
    trust your images until they’ve been hardened.
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是你可用的工具，用于构建结果为持久容器的镜像。持久性不是安全性，尽管你的持久镜像的采用者可能相信它们会尽可能长时间地运行，但他们不应该信任你的镜像，直到它们被加固。
- en: 8.6\. BUILDING HARDENED APPLICATION IMAGES
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.6\. 构建加固的应用程序镜像
- en: As an image author, it’s difficult to anticipate all the scenarios where your
    work will be used. For that reason, harden the images you produce whenever possible.
    Hardening an image is the process of shaping it in a way that will reduce the
    attack surface inside any Docker containers based on it.
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为镜像作者，很难预测你的作品将在哪些场景中使用。因此，尽可能加固你生产的镜像。加固镜像的过程是以一种方式塑造它，从而减少基于它的任何 Docker 容器内的攻击面。
- en: A general strategy for hardening an application image is to minimize the software
    included with it. Naturally, including fewer components reduces the number of
    potential vulnerabilities. Further, building minimal images keeps image download
    times short and helps adopters deploy and build containers more rapidly.
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加固应用程序镜像的一般策略是尽量减少其中包含的软件。自然地，包含更少的组件可以减少潜在漏洞的数量。此外，构建最小化镜像可以缩短镜像下载时间，并有助于采用者更快地部署和构建容器。
- en: You can do three things to harden an image beyond that general strategy. First,
    you can enforce that your images are built from a specific image. Second, you
    can make sure that regardless of how containers are built from your image, they
    will have a sensible default user. Last, you should eliminate a common path for
    root user escalation from programs with `setuid` or `setgid` attributes set.
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了上述一般策略之外，您还可以采取三项措施来加固镜像。首先，您可以强制要求您的镜像从特定的镜像构建。其次，您要确保无论容器如何从您的镜像构建，它们都将有一个合理的默认用户。最后，您应该消除从具有
    `setuid` 或 `setgid` 属性的程序中提升 root 用户权限的常见路径。
- en: 8.6.1\. Content-addressable image identifiers
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.6.1\. 内容寻址镜像标识符
- en: The image identifiers discussed so far in this book are all designed to allow
    an author to update images in a transparent way to adopters. An image author chooses
    what image their work will be built on top of, but that layer of transparency
    makes it difficult to trust that the base hasn’t changed since it was vetted for
    security problems. Since Docker 1.6, the image identifier has included an optional
    digest component.
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书迄今为止讨论的镜像标识符都是设计用来允许作者以透明的方式更新镜像供使用者使用。镜像作者选择他们的工作将建立在哪个镜像之上，但这一透明层使得很难相信基础镜像自经过安全审查以来没有发生变化。自
    Docker 1.6 版本以来，镜像标识符已包含一个可选的摘要组件。
- en: An image ID that includes the digest component is called a content-addressable
    image identifier (CAIID). This refers to a specific layer containing specific
    content, instead of simply referring to a particular and potentially changing
    layer.
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含摘要组件的镜像 ID 被称为内容寻址镜像标识符（CAIID）。这指的是包含特定内容的特定层，而不是简单地指代一个可能变化的特定层。
- en: Now image authors can enforce a build from a specific and unchanging starting
    point as long as that image is in a version 2 repository. Append an `@` symbol
    followed by the digest in place of the standard tag position.
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，只要该镜像位于版本 2 仓库中，镜像作者就可以强制从特定的、不变的起始点进行构建。在标准标签位置处用 `@` 符号后跟摘要替换。
- en: 'Use `docker image pull` and observe the line labeled `Digest` in the output
    to discover the digest of an image from a remote repository. Once you have the
    digest, you can use it as the identifier to `FROM` instructions in a Dockerfile.
    For example, consider the following, which uses a specific snapshot of `debian:stable`
    as a base:'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `docker image pull` 并观察输出中标记为 `Digest` 的行，以发现远程仓库中镜像的摘要。一旦您有了摘要，您就可以将其用作
    Dockerfile 中 `FROM` 指令的标识符。例如，考虑以下使用 `debian:stable` 的特定快照作为基础的示例：
- en: '`docker pull debian:stable stable: Pulling from library/debian 31c6765cabf1:
    Pull complete Digest: sha256:6aedee3ef827...  # Dockerfile: FROM debian@sha256:6aedee3ef827...
    ...`'
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker pull debian:stable stable: Pulling from library/debian 31c6765cabf1:
    Pull complete Digest: sha256:6aedee3ef827...  # Dockerfile: FROM debian@sha256:6aedee3ef827...
    ...`'
- en: Regardless of when or how many times the Dockerfile is used to build an image,
    each build will use the content identified with that CAIID as its base image.
    This is particularly useful for incorporating known updates to a base into your
    images and identifying the exact build of the software running on your computer.
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论何时何地使用 Dockerfile 构建镜像，每次构建都将使用与该 CAIID 相关的内容作为其基础镜像。这对于将已知更新合并到镜像中以及识别运行在您计算机上的软件的确切构建版本非常有用。
- en: Although this doesn’t directly limit the attack surface of your images, using
    CAIIDs will prevent it from changing without your knowledge. The next two practices
    do address the attack surface of an image.
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这并不直接限制您镜像的攻击面，但使用 CAIIDs 将防止它在您不知情的情况下发生变化。接下来的两个实践确实解决了镜像的攻击面问题。
- en: 8.6.2\. User permissions
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.6.2\. 用户权限
- en: The known container breakout tactics all rely on having system administrator
    privileges inside the container. [Chapter 6](index_split_053.html#filepos544857)
    covers the tools used to harden containers. That chapter includes a deep dive
    into user management and a discussion of the USR Linux namespace. This section
    covers standard practices for establishing reasonable user defaults for images.
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已知的容器突破策略都依赖于容器内部具有系统管理员权限。[第 6 章](index_split_053.html#filepos544857) 讨论了用于加固容器的工具。该章节深入探讨了用户管理和
    USR Linux 命名空间讨论。本节涵盖了为镜像建立合理的默认用户的标准做法。
- en: First, please understand that a Docker user can always override image defaults
    when creating a container. For that reason, there’s no way for an image to prevent
    containers from running as the root user. The best things an image author can
    do are to create other nonroot users and establish a nonroot default user and
    group.
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，请理解，当创建容器时，Docker用户可以始终覆盖镜像的默认设置。因此，镜像无法阻止容器以root用户身份运行。镜像作者能做的最好的事情是创建其他非root用户，并建立非root默认用户和组。
- en: Dockerfile includes a `USER` instruction that sets the user and group in the
    same way you would with the `docker container run` or `docker container create`
    command. The instruction itself was covered in the Dockerfile primer. This section
    is about considerations and best practices.
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile包含一个`USER`指令，它以与`docker container run`或`docker container create`命令相同的方式设置用户和组。该指令本身已在Dockerfile入门部分中介绍。本节是关于考虑事项和最佳实践。
- en: The best practice and general guidance is to drop privileges as soon as possible.
    You can do this with the `USER` instruction before any containers are ever created
    or with a startup script that’s run at container boot time. The challenge for
    an image author is to determine the earliest appropriate time.
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最佳实践和一般指导原则是尽可能早地放弃权限。您可以在创建任何容器之前使用`USER`指令，或者使用在容器启动时运行的启动脚本。对于镜像作者来说，挑战在于确定最早合适的时机。
- en: 'If you drop privileges too early, the active user may not have permission to
    complete the instructions in a Dockerfile. For example, this Dockerfile won’t
    build correctly:'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您过早地放弃权限，活动用户可能没有权限完成Dockerfile中的指令。例如，这个Dockerfile将无法正确构建：
- en: '`FROM busybox:latest USER 1000:1000 RUN touch /bin/busybox`'
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM busybox:latest USER 1000:1000 RUN touch /bin/busybox`'
- en: 'Building that Dockerfile would result in step 2 failing with a message like
    `touch: /bin/busybox: Permission denied`. File access is obviously impacted by
    user changes. In this case, UID 1000 doesn’t have permission to change the ownership
    of the file /bin/busybox. That file is currently owned by root. Reversing the
    second and third lines would fix the build.'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '构建该Dockerfile会导致步骤2失败，并显示类似`touch: /bin/busybox: Permission denied`的消息。文件访问显然会受到用户更改的影响。在这种情况下，UID
    1000没有权限更改文件/bin/busybox的所有权。该文件目前属于root。将第二行和第三行颠倒可以修复构建。'
- en: 'The second timing consideration is the permissions and capabilities needed
    at runtime. If the image starts a process that requires administrative access
    at runtime, it would make no sense to drop user access to a non-root user before
    that point. For example, any process that needs access to the system port range
    (1–1024) will need to be started by a user with administrative (at the very least
    CAP_NET _ADMIN) privileges. Consider what happens when you try to bind to port
    80 as a nonroot user with Netcat. Place the following Dockerfile in a file named
    UserPermissionDenied.df:'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个时间考虑因素是运行时所需的权限和能力。如果镜像启动一个在运行时需要管理员访问权限的进程，那么在这一点之前将用户访问权限降级到非root用户就没有意义了。例如，任何需要访问系统端口范围（1-1024）的进程都需要由具有管理员（至少CAP_NET_ADMIN）权限的用户启动。考虑一下，当您尝试以非root用户身份使用Netcat绑定端口80时会发生什么。将以下Dockerfile放在一个名为UserPermissionDenied.df的文件中：
- en: '`FROM busybox:1.29 USER 1000:1000 ENTRYPOINT ["nc"] CMD ["-l", "-p", "80",
    "0.0.0.0"]`'
  id: totrans-504
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM busybox:1.29 USER 1000:1000 ENTRYPOINT ["nc"] CMD ["-l", "-p", "80",
    "0.0.0.0"]`'
- en: 'Build the Dockerfile and run the resulting image in a container. In this case,
    the user (UID 1000) will lack the required privileges, and the command will fail:'
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建Dockerfile并在容器中运行生成的镜像。在这种情况下，用户（UID 1000）将缺少所需的权限，命令将失败：
- en: '`docker image build \     -t dockerinaction/ch8_perm_denied \     -f UserPermissionDenied.df
    \     . docker container run dockerinaction/ch8_perm_denied`'
  id: totrans-506
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build \    -t dockerinaction/ch8_perm_denied \    -f UserPermissionDenied.df
    \    . docker container run dockerinaction/ch8_perm_denied`'
- en: 'The container should print an error message:'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器应打印错误消息：
- en: '`nc: bind: Permission denied`'
  id: totrans-508
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`nc: bind: Permission denied`'
- en: In cases like these, you may see no benefit in changing the default user. Instead,
    any startup scripts that you build should take on the responsibility of dropping
    permissions as soon as possible. The last question is, which user should be dropped
    into?
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这些情况下，您可能看不到更改默认用户的好处。相反，您构建的任何启动脚本都应该承担尽快放弃权限的责任。最后一个问题是，应该将哪个用户降级？
- en: In the default Docker configuration, containers use the same Linux USR namespace
    as the host. This means that UID 1000 in the container is UID 1000 on the host
    machine. All other aspects apart from the UID and GID are segregated, just as
    they would be between computers. For example, UID 1000 on your laptop might be
    your username, but the username associated with UID 1000 inside a BusyBox container
    could be `default`, `busyuser`, or whatever the BusyBox image maintainer finds
    convenient. When the Docker `userns-remap` feature described in [chapter 6](index_split_053.html#filepos544857)
    is enabled, UIDs in the container are mapped to unprivileged UIDs on the host.
    USR namespace remapping provides full UID and GID segregation, even for root.
    But can you depend on `userns-remap` being in effect?
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在默认的Docker配置中，容器使用与主机相同的Linux USR命名空间。这意味着容器中的UID 1000在主机机器上是UID 1000。除了UID和GID之外的所有方面都是隔离的，就像它们在计算机之间一样。例如，你笔记本电脑上的UID
    1000可能是你的用户名，但与BusyBox容器内的UID 1000关联的用户名可能是`default`、`busyuser`或BusyBox镜像维护者认为方便的任何名称。当Docker
    `userns-remap`功能（如第6章中所述）启用时，容器中的UID映射到主机上的非特权UID。USR命名空间重映射提供了完整的UID和GID隔离，即使是对于root用户。但你能否依赖`userns-remap`功能生效？
- en: 'Image authors often do not know the Docker daemon configuration where their
    images will run. Even if Docker adopted USR namespace remapping in a default configuration,
    it will be difficult for image authors to know which UID/GID is appropriate to
    use. The only thing we can be sure of is that it’s inappropriate to use common
    or system-level UID/GIDs when doing so can be avoided. With that in mind, using
    raw UID/GID numbers is still burdensome. Doing so makes scripts and Dockerfiles
    less readable. For that reason, it’s typical for image authors to include `RUN`
    instructions that create users and groups used by the image. The following is
    the second instruction in a PostgreSQL Dockerfile:'
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像作者通常不知道他们的图像将在哪里运行的Docker守护进程配置。即使Docker在默认配置中采用了USR命名空间重映射，图像作者也很难知道应该使用哪个UID/GID。我们可以确定的是，当可以避免时，使用常见的或系统级别的UID/GID是不合适的。考虑到这一点，使用原始的UID/GID数字仍然很麻烦。这样做使得脚本和Dockerfile的可读性降低。因此，图像作者通常包括创建图像使用的用户和组的`RUN`指令。以下是在PostgreSQL
    Dockerfile中的第二个指令：
- en: '`# add our user and group first to make sure their IDs get assigned # consistently,
    regardless of whatever dependencies get added RUN groupadd -r postgres && useradd
    -r -g postgres postgres`'
  id: totrans-512
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 首先添加我们的用户和组，以确保它们的ID能够一致地分配，无论添加了什么依赖 # RUN groupadd -r postgres && useradd
    -r -g postgres postgres`'
- en: This instruction simply creates a `postgres` user and group with automatically
    assigned UID and GID. The instruction is placed early in the Dockerfile so that
    it will always be cached between rebuilds, and the IDs remain consistent regardless
    of other users that are added as part of the build. This user and group could
    then be used in a `USER` instruction. That would make for a safer default. But
    PostgreSQL containers require elevated privileges during startup. Instead, this
    particular image uses a `su` or `sudo`-like program called `gosu` to start the
    PostgreSQL process as the `postgres` user. Doing so makes sure that the process
    runs without administrative access in the container.
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个指令只是创建了一个具有自动分配的UID和GID的`postgres`用户和组。这个指令放在Dockerfile的早期，以确保它在重建之间始终被缓存，并且ID保持一致，无论在构建过程中添加了其他用户。然后，这个用户和组可以在`USER`指令中使用。这将提供一个更安全的默认设置。但PostgreSQL容器在启动时需要提升权限。因此，这个特定的镜像使用了一个类似于`su`或`sudo`的程序`gosu`来以`postgres`用户启动PostgreSQL进程。这样做确保了进程在容器中运行时没有管理员访问权限。
- en: User permissions are one of the more nuanced aspects of building Docker images.
    The general rule you should follow is that if the image you’re building is designed
    to run specific application code, the default execution should drop user permissions
    as soon as possible.
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户权限是构建Docker镜像时更为微妙的方面之一。你应该遵循的一般规则是，如果你构建的镜像旨在运行特定的应用程序代码，默认执行应该尽快降低用户权限。
- en: A properly functioning system should be reasonably secure with reasonable defaults
    in place. Remember, though, an application or arbitrary code is rarely perfect
    and could be intentionally malicious. For that reason, you should take additional
    steps to reduce the attack surface of your images.
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个正常工作的系统应该有合理的默认设置，从而在合理的安全水平上运行。记住，尽管如此，应用程序或任意代码很少是完美的，可能是故意恶意的。因此，你应该采取额外的步骤来减少图像的攻击面。
- en: 8.6.3\. SUID and SGID permissions
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.6.3. SUID和SGID权限
- en: 'The last hardening action to cover is the mitigation of `setuid` (SUID) or
    `setgid` (SGID) permissions. The well-known filesystem permissions (read, write,
    execute) are only a portion of the set defined by Linux. In addition to those,
    two are of particular interest: SUID and SGID.'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后要覆盖的加固操作是缓解`setuid`（SUID）或`setgid`（SGID）权限。众所周知的文件系统权限（读取、写入、执行）只是Linux定义的集合中的一部分。除了这些之外，还有两个特别引人关注：SUID和SGID。
- en: 'These two are similar in nature. An executable file with the SUID bit set will
    always execute as its owner. Consider a program like /usr/bin/passwd, which is
    owned by the root user and has the SUID permission set. If a nonroot user such
    as `bob` executes `passwd`, he will execute that program as the root user. You
    can see this in action by building an image from the following Dockerfile:'
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这两个在本质上相似。设置了SUID位的可执行文件将始终以所有者的身份执行。考虑一个像/usr/bin/passwd这样的程序，它属于root用户，并设置了SUID权限。如果一个非root用户如`bob`执行`passwd`，他将作为root用户执行该程序。你可以通过从以下Dockerfile构建镜像来看到这一点：
- en: '`FROM ubuntu:latest # Set the SUID bit on whoami RUN chmod u+s /usr/bin/whoami
    # Create an example user and set it as the default RUN adduser --system --no-create-home
    --disabled-password --disabled-login \     --shell /bin/sh example USER example
    # Set the default to compare the container user and # the effective user for whoami
    CMD  printf "Container running as:          %s\n" $(id -u -n) && \      printf
    "Effectively running whoami as: %s\n" $(whoami)`'
  id: totrans-519
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM ubuntu:latest # Set the SUID bit on whoami RUN chmod u+s /usr/bin/whoami
    # Create an example user and set it as the default RUN adduser --system --no-create-home
    --disabled-password --disabled-login \   --shell /bin/sh example USER example
    # Set the default to compare the container user and # the effective user for whoami
    CMD printf "Container running as:          %s\n" $(id -u -n) && \   printf "Effectively
    running whoami as: %s\n" $(whoami)`'
- en: 'Once you’ve created the Dockerfile, you need to build an image and run the
    default command in a container:'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦创建了Dockerfile，就需要构建一个镜像并在容器中运行默认命令：
- en: '`docker image build -t dockerinaction/ch8_whoami . docker run dockerinaction/ch8_whoami`'
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch8_whoami . docker run dockerinaction/ch8_whoami`'
- en: 'Doing so prints results like these to the terminal:'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样做将在终端打印出如下结果：
- en: '`Container running as:          example Effectively running whoami as: root`'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Container running as:          example Effectively running whoami as: root`'
- en: The output of the default command shows that even though you’ve executed the
    `whoami` command as the example user, it’s running from the context of the root
    user. The SGID works similarly. The difference is that the execution will be from
    the owning group’s context, not the owning user.
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认命令的输出显示，尽管你以示例用户执行了`whoami`命令，但它是在root用户的上下文中运行的。SGID的工作方式类似。区别在于执行将是从所有者组的上下文中进行的，而不是所有者用户。
- en: 'Running a quick search on your base image will give you an idea of how many
    and which files have these permissions:'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的基础镜像上快速搜索将给你一个关于有多少文件以及哪些文件具有这些权限的概念：
- en: '`docker run --rm debian:stretch find / -perm /u=s -type f`'
  id: totrans-526
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm debian:stretch find / -perm /u=s -type f`'
- en: 'It will display a list like this:'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它将显示如下列表：
- en: '`/bin/umount /bin/ping /bin/su /bin/mount /usr/bin/chfn /usr/bin/passwd /usr/bin/newgrp
    /usr/bin/gpasswd /usr/bin/chsh`'
  id: totrans-528
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`/bin/umount /bin/ping /bin/su /bin/mount /usr/bin/chfn /usr/bin/passwd /usr/bin/newgrp
    /usr/bin/gpasswd /usr/bin/chsh`'
- en: 'This command will find all of the SGID files:'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将找到所有SGID文件：
- en: '`docker container run --rm debian:stretch find / -perm /g=s -type f`'
  id: totrans-530
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm debian:stretch find / -perm /g=s -type f`'
- en: 'The resulting list is much shorter:'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果列表要短得多：
- en: '`/sbin/unix_chkpwd /usr/bin/chage /usr/bin/expiry /usr/bin/wall`'
  id: totrans-532
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`/sbin/unix_chkpwd /usr/bin/chage /usr/bin/expiry /usr/bin/wall`'
- en: Each of the listed files in this particular image has the SUID or SGID permission,
    and a bug in any of them could be used to compromise the root account inside a
    container. The good news is that files that have either of these permissions set
    are typically useful during image builds but rarely required for application use
    cases. If your image is going to be running software that’s arbitrary or externally
    sourced, it’s a best practice to mitigate this risk of escalation.
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个特定图像中列出的每个文件都具有SUID或SGID权限，其中任何一个文件中的漏洞都可能被用来在容器内危害root账户。好消息是，具有这些权限之一的文件通常在镜像构建期间很有用，但在应用程序用例中很少需要。如果你的镜像将要运行任意或外部来源的软件，那么减轻这种提升风险的最好做法是。
- en: 'Fix this problem and either delete all these files or unset their SUID and
    SGID permissions. Taking either action would reduce the image’s attack surface.
    The following Dockerfile instruction will unset the SUID and GUID permissions
    on all files currently in the image:'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决这个问题，要么删除所有这些文件，要么取消它们的 SUID 和 SGID 权限。采取任何一种行动都会减少镜像的攻击面。以下 Dockerfile 指令将取消当前镜像中所有文件的
    SUID 和 GUID 权限：
- en: '`RUN for i in $(find / -type f \( -perm /u=s -o -perm /g=s \)); \     do chmod
    ug-s $i; done`'
  id: totrans-535
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`RUN for i in $(find / -type f \( -perm /u=s -o -perm /g=s \)); \ do chmod
    ug-s $i; done`'
- en: Hardening images will help users build hardened containers. Although it’s true
    that no hardening measures will protect users from intentionally building weak
    containers, those measures will help the more unsuspecting and most common type
    of user.
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加固镜像将帮助用户构建加固的容器。虽然确实没有任何加固措施可以保护用户免受故意构建弱容器的侵害，但这些措施将帮助那些不太警觉的、最常见的用户。
- en: SUMMARY
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Most Docker images are built automatically from Dockerfiles. This chapter covers
    the build automation provided by Docker and Dockerfile best practices. Before
    moving on, make sure that you’ve understood these key points:'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数 Docker 镜像都是自动从 Dockerfile 构建的。本章涵盖了 Docker 提供的构建自动化以及 Dockerfile 最佳实践。在继续之前，请确保你已经理解了这些关键点：
- en: Docker provides an automated image builder that reads instructions from Dockerfiles.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 提供了一个自动化的镜像构建器，该构建器从 Dockerfile 中读取指令。
- en: Each Dockerfile instruction results in the creation of a single image layer.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 Dockerfile 指令都会创建一个单独的镜像层。
- en: Merge instructions to minimize the size of images and layer count when possible.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并指令以在可能的情况下最小化镜像大小和层计数。
- en: Dockerfiles include instructions to set image metadata including the default
    user, exposed ports, default command, and entrypoint.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile 包含设置镜像元数据的指令，包括默认用户、暴露的端口、默认命令和入口点。
- en: Other Dockerfile instructions copy files from the local filesystem or a remote
    location into the produced images.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 Dockerfile 指令会从本地文件系统或远程位置复制文件到生成的镜像中。
- en: Downstream builds inherit build triggers that are set with `ONBUILD` instructions
    in an upstream Dockerfile.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下游构建继承了在父级 Dockerfile 中使用 `ONBUILD` 指令设置的构建触发器。
- en: Dockerfile maintenance can be improved with multistage builds and the `ARG`
    instruction.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过多阶段构建和 `ARG` 指令来改进 Dockerfile 的维护。
- en: Startup scripts should be used to validate the execution context of a container
    before launching the primary application.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动主应用程序之前，应使用启动脚本验证容器的执行上下文。
- en: A valid execution context should have appropriate environment variables set,
    network dependencies available, and an appropriate user configuration.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的执行上下文应该设置适当的环境变量，提供网络依赖，并配置适当的用户。
- en: Init programs can be used to launch multiple processes, monitor those processes,
    reap orphaned child processes, and forward signals to child processes.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化程序可以用来启动多个进程，监控这些进程，回收孤儿子进程，并将信号传递给子进程。
- en: Images should be hardened by building from content-addressable image identifiers,
    creating a nonroot default user, and disabling or removing any executable with
    SUID or SGID permissions.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该通过构建来自内容可寻址的镜像标识符、创建非 root 默认用户以及禁用或删除具有 SUID 或 SGID 权限的任何可执行文件来加固镜像。
- en: Chapter 9\. Public and private software distribution
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第9章：公共和私有软件分发
- en: This chapter covers
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Choosing a project distribution method
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择项目分发方法
- en: Using hosted infrastructure
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托管基础设施
- en: Running and using your own registry
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和使用自己的注册表
- en: Understanding manual image distribution workflows
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解手动镜像分发工作流程
- en: Distributing image sources
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发镜像源
- en: You have your own images of software you’ve written, customized, or just pulled
    from the internet. But what good is an image if nobody can install it? Docker
    is different from other container management tools because it provides image distribution
    features.
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你拥有自己编写的、定制的，或者从互联网上拉取的软件镜像。但如果没有人在安装它，这样的镜像又有什么用呢？Docker 与其他容器管理工具不同，因为它提供了镜像分发功能。
- en: There are several ways to get your images out to the world. This chapter explores
    those distribution paradigms and provides a framework for making or choosing one
    or more for your own projects.
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有几种方法可以将你的镜像分发到全世界。本章探讨了这些分发范式，并为创建或选择一个或多个用于你自己的项目提供了一个框架。
- en: Hosted registries offer both public and private repositories with automated
    build tools. By contrast, running a private registry lets you hide and customize
    your image distribution infrastructure. Heavier customization of a distribution
    workflow might require you to abandon the Docker image distribution facilities
    and build your own. Some systems might abandon the image as the distribution unit
    altogether and distribute the source files for images instead. This chapter will
    teach you how to select and use a method for distributing your images to the world
    or just at work.
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 托管注册表提供公共和私有存储库以及自动构建工具。相比之下，运行私有注册表允许您隐藏和定制您的图像分发基础设施。更重的定制分发工作流程可能需要您放弃 Docker
    图像分发设施并构建自己的。某些系统可能完全放弃图像作为分发单元，转而分发图像的源文件。本章将教会您如何选择和使用一种方法来分发您的图像到全世界或仅在工作场所。
- en: 9.1\. CHOOSING A DISTRIBUTION METHOD
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1\. 选择分发方法
- en: The most difficult thing about choosing a distribution method is choosing the
    appropriate method for your situation. To help with this problem, each method
    presented in this chapter is examined on the same set of selection criteria.
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择分发方法最困难的事情是选择适合您情况的方法。为了帮助解决这个问题，本章中提出的每种方法都将在同一组选择标准下进行审查。
- en: The first thing to recognize about distributing software with Docker is that
    there’s no universal solution. Distribution requirements vary for many reasons,
    and several methods are available. Every method has Docker tools at its core,
    so it’s always possible to migrate from one to another with minimal effort. The
    best way to start is by examining the full spectrum of options at a high level.
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于使用 Docker 分发软件的第一件事是要认识到没有通用的解决方案。由于许多原因，分发需求各不相同，因此有多种方法可供选择。每种方法都以 Docker
    工具为核心，因此总是可以以最小的努力从一种迁移到另一种。
- en: 9.1.1\. A distribution spectrum
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.1\. 分发范围
- en: The image distribution spectrum offers many methods with differing levels of
    flexibility and complexity. The methods that provide the most flexibility can
    be the most complicated to use, whereas those that are the simplest to use are
    generally the most restrictive. [Figure 9.1](#filepos914552) shows the full spectrum.
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像分发范围提供了许多具有不同灵活性和复杂性的方法。提供最大灵活性的方法可能最复杂，而那些最简单的方法通常最有限制。[图 9.1](#filepos914552)
    展示了完整的范围。
- en: Figure 9.1\. The image distribution spectrum
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 9.1\. 图像分发范围
- en: '![](images/00075.jpg)'
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00075.jpg)'
- en: The methods included in the spectrum range from hosted registries such as Docker
    Hub to totally custom distribution architectures or source-distribution methods.
    We cover some of these subjects in more detail than others. We also place particular
    focus on private registries because they provide the most balance between the
    two concerns.
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 范围内的方法从托管注册表，如 Docker Hub，到完全定制的分发架构或源分发方法。我们比其他一些主题更详细地介绍了这些内容。我们还特别关注私有注册表，因为它们在两个关注点之间提供了最平衡的解决方案。
- en: Having a spectrum of choices illustrates your range of options, but you need
    a consistent set of selection criteria in order to determine which you should
    use.
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有一系列选择可以说明你的选项范围，但你需要一个一致的筛选标准来确定应该使用哪一个。
- en: 9.1.2\. Selection criteria
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.2\. 选择标准
- en: Choosing the best distribution method for your needs may seem daunting with
    this many options. In situations like these, you should take the time to understand
    the options, identify criteria for making a selection, and avoid the urge to make
    a quick decision or settle.
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这么多选项中，选择最适合您需求的最优分发方法可能会显得有些令人畏惧。在这种情况下，您应该花时间了解这些选项，确定选择标准，并避免急于做出决定或妥协。
- en: 'The following identified selection criteria are based on differences across
    the spectrum and on common business concerns. When making a decision, consider
    how important each of these is in your situation:'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下确定的选择标准基于范围之间的差异和常见的商业关注点。在做出决定时，请考虑这些因素在您的情况中有多重要：
- en: Cost
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本
- en: Visibility
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视性
- en: Transport speed or bandwidth overhead
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输速度或带宽开销
- en: Longevity control
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长期控制
- en: Availability control
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性控制
- en: Access control
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Artifact integrity
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艺术品完整性
- en: Artifact confidentiality
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 艺术品机密性
- en: Requisite expertise
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需的专业知识
- en: How each distribution method stacks up against these criteria is covered in
    the relevant sections over the rest of this chapter.
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每种分发方法如何与这些标准相匹配将在本章其余部分的相关部分中介绍。
- en: Cost
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 成本
- en: Cost is the most obvious criterion, and the distribution spectrum ranges in
    cost from free to very expensive, and “it’s complicated.” Lower cost is generally
    better, but cost is typically the most flexible criterion. For example, most people
    will trade cost for artifact confidentiality if the situation calls for it.
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 成本是显而易见的标准，成本分布范围从免费到非常昂贵，且“情况复杂。”通常情况下，低成本更好，但成本通常是灵活性最高的标准。例如，如果情况需要，大多数人会为了工件机密性而牺牲成本。
- en: Visibility
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可见性
- en: Visibility is the next most obvious criterion for a distribution method. Secret
    projects or internal tools should be difficult if not impossible for unauthorized
    people to discover. In another case, public works or open source projects should
    be as visible as possible to promote adoption.
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可见性是分发方法下一个最明显的标准。机密项目或内部工具应该对未经授权的人难以发现，甚至不可能发现。在另一种情况下，公共作品或开源项目应该尽可能可见，以促进采用。
- en: Transportation
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传输
- en: Transportation speed and bandwidth overhead are the next most flexible criteria.
    File sizes and image installation speed will vary between methods that leverage
    image layers, concurrent downloads, and prebuilt images and those that use flat
    image files or rely on deployment-time image builds. High transportation speeds
    or low installation latency is critical for systems that use just-in-time deployment
    to service synchronous requests. The opposite is true in development environments
    or asynchronous processing systems.
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传输速度和带宽开销是下一个最灵活的标准。文件大小和图像安装速度将在利用图像层、并发下载和预构建图像的方法与使用平面图像文件或依赖于部署时图像构建的方法之间有所不同。对于仅使用即时部署来服务同步请求的系统，高传输速度或低安装延迟至关重要。在开发环境或异步处理系统中，情况则相反。
- en: Longevity
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 长期性
- en: Longevity control is a business concern more than a technical concern. Hosted
    distribution methods are subject to other people’s or companies’ business concerns.
    An executive faced with the option of using a hosted registry might ask, “What
    happens if they go out of business or pivot away from repository hosting?” The
    question reduces to, “Will the business needs of the third party change before
    ours?” If this is a concern for you, longevity control is important. Docker makes
    it simple to switch between methods, and other criteria such as requisite expertise
    or cost may trump this concern. For those reasons, longevity control is another
    of the more flexible criteria.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 长期控制更多地是商业问题而非技术问题。托管分发方法易受其他人或公司的商业问题的影响。一位面临使用托管注册表选择的执行者可能会问：“如果他们停止营业或转向远离存储库托管，会发生什么？”这个问题归结为：“第三方的商业需求在我们之前改变吗？”如果这是您的担忧，那么长期控制就很重要。Docker使得在方法之间切换变得简单，其他标准如所需的专业技能或成本可能会超过这一担忧。因此，长期控制是更灵活的标准之一。
- en: Availability
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可用性
- en: Availability control is the ability to control the resolution of availability
    issues with your repositories. Hosted solutions provide no availability control.
    Businesses typically provide a service-level agreement (SLA) on availability if
    you’re a paying customer, but there’s nothing you can do to directly resolve an
    issue. On the other end of the spectrum, private registries or custom solutions
    put both the control and responsibility in your hands.
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可用性控制是指控制您存储库中可用性问题解决的能力。托管解决方案不提供可用性控制。如果您是付费客户，企业通常会提供关于可用性的服务级别协议（SLA），但您无法直接解决问题。在光谱的另一端，私有注册表或定制解决方案将控制和责任都掌握在您的手中。
- en: Access control
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 访问控制
- en: Access control protects your images from modification or access by unauthorized
    parties. Varying degrees of access control are available. Some systems provide
    only access control of modifications to a specific repository, whereas others
    provide course control of entire registries. Still other systems may include pay
    walls or digital rights management controls. Projects typically have specific
    access-control needs dictated by the product or business. This makes access-control
    requirements one of the least flexible and most important to consider.
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 访问控制可以保护您的图像免受未经授权的修改或访问。可用的访问控制程度各不相同。一些系统仅提供对特定存储库修改的访问控制，而其他系统则提供对整个注册表的课程控制。还有其他系统可能包括付费墙或数字版权管理控制。项目通常具有由产品或业务需求决定的具体访问控制需求。这使得访问控制需求成为最不灵活且最重要的考虑因素之一。
- en: Integrity
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完整性
- en: Artifact integrity and confidentiality both fall in the less-flexible and more-technical
    end of the spectrum. Artifact integrity is trustworthiness and consistency of
    your files and images. Violations of integrity may include man-in-the-middle attacks,
    in which an attacker intercepts your image downloads and replaces the content
    with their own. They might also include malicious or hacked registries that lie
    about the payloads they return.
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文物完整性和保密性都位于范围中不太灵活且更技术性的末端。文物的完整性是指你的文件和镜像的可靠性和一致性。完整性违规可能包括中间人攻击，其中攻击者拦截你的镜像下载并用自己的内容替换。也可能包括恶意或被黑客攻击的注册表，它们对其返回的有效载荷撒谎。
- en: Confidentiality
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保密性
- en: Artifact confidentiality is a common requirement for companies developing trade
    secrets or proprietary software. For example, if you use Docker to distribute
    cryptographic material, confidentiality will be a major concern. Artifact integrity
    and confidentiality features vary across the spectrum. Overall, the out-of-the-box
    distribution security features won’t provide the tightest confidentiality or integrity.
    If that’s one of your needs, an information security professional will need to
    implement and review a solution.
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文物保密性是开发商业机密或专有软件的公司的一个常见要求。例如，如果你使用Docker来分发加密材料，保密性将是一个主要关注点。文物的完整性和保密性功能在整个范围内各不相同。总的来说，开箱即用的分发安全功能不会提供最紧密的保密性或完整性。如果这是你的需求之一，那么信息安全专业人员将需要实施并审查解决方案。
- en: Expertise
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 专业知识
- en: The last thing to consider when choosing a distribution method is the level
    of expertise required. Using hosted methods can be simple and requires little
    more than a mechanical understanding of the tools. Building custom image or image
    source-distribution pipelines requires expertise with a suite of related technologies.
    If you don’t have that expertise or don’t have access to someone who does, using
    more complicated solutions will be a challenge. In that case, you may be able
    to reconcile the gap at additional cost.
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择分发方法时需要考虑的最后一点是所需的专家水平。使用托管方法可能很简单，只需要对工具的机械理解。构建自定义镜像或镜像源分发管道需要一套相关技术的专业知识。如果你没有这种专业知识，或者无法访问拥有这种专业知识的人，使用更复杂的解决方案将是一个挑战。在这种情况下，你可能需要额外付费来弥合差距。
- en: With this strong set of selection criteria, you can begin learning about and
    evaluating various distribution methods. The following sections evaluate these
    methods against the criteria by using ratings of Worst, Bad, Good, Better, and
    Best. The best place to start is on the far left of the spectrum with hosted registries.
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个强大的选择标准集下，你可以开始了解和评估各种分发方法。以下各节将使用最差、差、好、较好和最好等评级对这些方法进行评估。最佳起点是光谱的最左侧，即托管注册表。
- en: 9.2\. PUBLISHING WITH HOSTED REGISTRIES
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2\. 通过托管注册表发布
- en: As a reminder, Docker registries are services that make repositories accessible
    to Docker pull commands. A registry hosts repositories. The simplest way to distribute
    your images is by using hosted registries.
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为提醒，Docker注册表是使仓库可供Docker拉取命令访问的服务。注册表托管仓库。分发你的镜像最简单的方法是使用托管注册表。
- en: A hosted registry is a Docker registry service that’s owned and operated by
    a third-party vendor. Docker Hub, Quay.io, and Google Container Registry are all
    examples of hosted registry providers. By default, Docker publishes to Docker
    Hub. Docker Hub and most other hosted registries provide both public and private
    registries, as shown in [figure 9.2](#filepos926454).
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 托管注册表是由第三方供应商拥有和运营的Docker注册表服务。Docker Hub、Quay.io和Google Container Registry都是托管注册表提供商的例子。默认情况下，Docker发布到Docker
    Hub。Docker Hub和大多数其他托管注册表都提供公共和私有注册表，如图9.2所示。[#filepos926454](#filepos926454)
- en: Figure 9.2\. The simplest side of the distribution spectrum and the topic of
    this section
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.2\. 分发光谱最简单的一侧和本节的主题
- en: '![](images/00033.jpg)'
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00033.jpg)'
- en: The example images used in this book are distributed with public repositories
    hosted on Docker Hub and Quay.io. By the end of this section, you’ll understand
    how to publish your own images by using hosted registries and how hosted registries
    measure up to the selection criteria.
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书使用的示例镜像通过Docker Hub和Quay.io上的公共仓库进行分发。在本节结束时，你将了解如何使用托管注册表发布自己的镜像，以及托管注册表如何满足选择标准。
- en: '9.2.1\. Publishing with public repositories: “Hello World!” via Docker Hub'
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.1\. 通过公共仓库发布：“Hello World!” via Docker Hub
- en: The simplest way to get started with public repositories on hosted registries
    is to push a repository that you own to Docker Hub. To do so, all you need is
    a Docker Hub account and an image to publish. If you haven’t done so already,
    sign up for a Docker Hub account now.
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在托管注册库上开始使用公共仓库的最简单方法是推送您拥有的仓库到 Docker Hub。为此，您需要一个 Docker Hub 账户和一个要发布的镜像。如果您还没有这样做，现在就注册一个
    Docker Hub 账户。
- en: 'Once you have your account, you need to create an image to publish. Create
    a new Dockerfile named HelloWorld.df and add the following instructions:'
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦您有了账户，您就需要创建一个要发布的镜像。创建一个名为 HelloWorld.df 的新 Dockerfile 并添加以下指令：
- en: '`FROM busybox:latest` `1` `CMD echo ''Hello World!''`'
  id: totrans-610
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM busybox:latest` `1` `CMD echo ''Hello World!''`'
- en: 1 From HelloWorld.df
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 从 HelloWorld.df
- en: '[Chapter 8](index_split_069.html#filepos755104) covers Dockerfile instructions.
    As a reminder, the `FROM` instruction tells the Docker image builder which existing
    image to start the new image from. The `CMD` instruction sets the default command
    for the new image. Containers created from this image will display `Hello World!`
    and exit. Build your new image with the following command:'
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[第8章](index_split_069.html#filepos755104) 讲解了 Dockerfile 指令。作为提醒，`FROM` 指令告诉
    Docker 镜像构建器从哪个现有镜像开始构建新镜像。`CMD` 指令设置新镜像的默认命令。从这个镜像创建的容器将显示 `Hello World!` 并退出。使用以下命令构建您的新镜像：'
- en: '`docker image build \     -t <insert Docker Hub username>/hello-dockerfile
    \` `1` `-f HelloWorld.df \     .`'
  id: totrans-613
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build \ -t <insert Docker Hub username>/hello-dockerfile \ 1
    -f HelloWorld.df \ .`'
- en: 1 Insert your username.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输入您的用户名。
- en: Be sure to substitute your Docker Hub username in that command. Authorization
    to access and modify repositories is based on the username portion of the repository
    name on Docker Hub. If you create a repository with a username other than your
    own, you won’t be able to publish it.
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请确保在命令中替换您的 Docker Hub 用户名。访问和修改仓库的授权基于 Docker Hub 上仓库名称的用户名部分。如果您使用不同于您自己的用户名创建仓库，您将无法发布它。
- en: 'Publishing images on Docker Hub with the `docker` command-line tool requires
    that you establish an authenticated session with that client. You can do that
    with the `login` command:'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `docker` 命令行工具在 Docker Hub 上发布镜像需要您与该客户端建立认证会话。您可以使用 `login` 命令来完成此操作：
- en: '`docker login`'
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker login`'
- en: This command will prompt you for your username, email address, and password.
    Each of those can be passed to the command as arguments using the `--username`,
    `--email`, and `--password` flags. When you log in, the `docker` client maintains
    a map of your credentials for the different registries that you authenticate with
    in a file. It will specifically store your username and an authentication token,
    not your password.
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将提示您输入用户名、电子邮件地址和密码。您可以使用 `--username`、`--email` 和 `--password` 标志将这些信息作为参数传递给命令。当您登录时，`docker`
    客户端会在一个文件中维护您对不同注册库的认证凭据映射。它将特别存储您的用户名和认证令牌，而不是您的密码。
- en: 'You will be able to push your repository to the hosted registry after you’ve
    logged in. Use the `docker push` command to do so:'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 登录后，您将能够将您的仓库推送到托管注册库。使用 `docker push` 命令来完成此操作：
- en: '`docker image push <insert Docker Hub username>/hello-dockerfile` `1`'
  id: totrans-620
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image push <insert Docker Hub username>/hello-dockerfile` `1`'
- en: 1 Insert your username.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输入您的用户名。
- en: 'Running that command should create output like the following:'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行该命令应生成如下输出：
- en: '`The push refers to a repository [dockerinaction/hello-dockerfile] (len: 1)
    7f6d4eb1f937: Image already exists 8c2e06607696: Image successfully pushed 6ce2e90b0bc7:
    Image successfully pushed cf2616975b4a: Image successfully pushed Digest:   sha256:ef18de4b0ddf9ebd1cf5805fae1743181cbf3642f942cae8de7c5d4e375b1f20`'
  id: totrans-623
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`将镜像推送到 [dockerinaction/hello-dockerfile] (len: 1) 7f6d4eb1f937: 镜像已存在 8c2e06607696:
    镜像成功推送 6ce2e90b0bc7: 镜像成功推送 cf2616975b4a: 镜像成功推送 Digest: sha256:ef18de4b0ddf9ebd1cf5805fae1743181cbf3642f942cae8de7c5d4e375b1f20`'
- en: The command output includes upload statuses and the resulting repository content
    digest. The push operation will create the repository on the remote registry,
    upload each of the new layers, and then create the appropriate tags.
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令输出包括上传状态和结果仓库内容摘要。推送操作将在远程注册库上创建仓库，上传每个新层，然后创建适当的标签。
- en: 'Your public repository will be available to the world as soon as the push operation
    is completed. Verify that this is the case by searching for your username and
    your new repository. For example, use the following command to find the example
    owned by the `dockerinaction` user:'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的公共仓库在推送操作完成后将向全世界开放。通过搜索您的用户名和您的新仓库来验证这一点。例如，使用以下命令查找`dockerinaction`用户拥有的示例：
- en: '`docker search dockerinaction`'
  id: totrans-626
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker search dockerinaction`'
- en: Replace the `dockerinaction` username with your own to find your new repository
    on Docker Hub. You can also log in to the Docker Hub website and view your repositories
    to find and modify your new repository.
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将`dockerinaction`用户名替换为您的用户名，以在Docker Hub上找到您的新仓库。您也可以登录到Docker Hub网站，查看您的仓库以找到并修改您的新仓库。
- en: Having distributed your first image with Docker Hub, you should consider how
    this method measures up to the selection criteria; see [table 9.1](#filepos935667).
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Docker Hub分发您的第一个镜像后，您应该考虑这种方法与选择标准相比如何；参见[表9.1](#filepos935667)。
- en: Table 9.1\. Performance of public hosted repositories
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.1\. 公共主办仓库的性能
- en: '|'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准
- en: '|'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-633
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-635
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注
- en: '|'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Best                | Public repositories on hosted
    registries are almost always free. That price is difficult to beat. These are
    especially helpful                   when you’re getting started with Docker or
    publishing open source software.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '| 成本              | 最佳   | 主办注册表上的公共仓库几乎总是免费的。这个价格很难被击败。当您刚开始使用Docker或发布开源软件时，这些特别有帮助。'
- en: '|'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Visibility   | Best   | Hosted registries are well-known hubs for software
    distribution. A public repository on a hosted registry is an obvious distribution
                      choice if you want your project to be well-known and visible
    to the public.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可见性   | 最佳   | 主办注册表是软件分发的知名中心。如果您希望您的项目广为人知并对公众可见，那么主办注册表上的公共仓库是一个明显的分发选择。'
- en: '|'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Better                | Hosted registries
    such as Docker Hub are layer-aware and will work with Docker clients to transfer
    only the layers that the                   client doesn’t already have. Further,
    pull operations that require multiple repositories to be transferred will perform
    those'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小                      | 更好                      | 主办注册表，如Docker Hub，是层感知的，并且将与Docker客户端一起工作，仅传输客户端尚未拥有的层。此外，需要传输多个仓库的拉取操作将执行这些并行传输。'
- en: transfers in parallel. For those reasons, distributing an image from a hosted
    repository is fast, and the payloads are minimal.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 并行传输。因此，从主办仓库分发镜像速度快，负载最小。
- en: '|'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Good   | You have no longevity control over hosted
    registries. But registries will all conform to the Docker registry API, and migrating
                      from one host to another should be a low-cost exercise.   |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 长期控制   | 良好   | 您无法控制主办注册表的长久性。但所有注册表都将符合Docker注册表API，从一台主机迁移到另一台主机应该是一个低成本的操作。  
    |'
- en: '| Availability control                | Worst                | You have no
    availability control over hosted registries.             |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| 可用性控制                      | 最差   | 您无法控制主办注册表的可访问性。           |'
- en: '| Access control   | Better   | Public repositories are open to the public
    for read access. Write access is still controlled by whatever mechanisms the host
                      has put in place. Write access to public repositories on Docker
    Hub is controlled in two ways. First, repositories owned by'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '| 访问控制   | 更好   | 公共仓库对公众开放，允许读取访问。写入访问仍然由主机设置的任何机制控制。Docker Hub上的公共仓库的写入访问通过两种方式控制。首先，由个人拥有的仓库只能由该个人账户写入。'
- en: an individual may be written to only by that individual account. Second, repositories
    owned by organizations may be written
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 只有该个人账户可以写入。其次，组织拥有的仓库可能只能由该组织中的任何用户写入。
- en: to by any user who is part of that organization.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 可以由该组织中的任何用户写入。
- en: '|'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Artifact integrity                | Best                | The current version
    of the Docker registry API, V2, provides content-addressable images. The V2 API
    lets you request an image                   with a specific cryptographic signature.
    The Docker client will validate the integrity of the returned image by recalculating'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '| 艺术品完整性              | 最佳   | Docker注册表API的当前版本，V2，提供了内容可寻址的镜像。V2 API允许您请求具有特定加密签名的镜像。Docker客户端将通过重新计算返回镜像的完整性来验证返回镜像的完整性。'
- en: the signature and comparing it to the one requested. Old versions of Docker
    that are unaware of the V2 registry API don’t
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 签名并将其与请求的签名进行比较。不了解 V2 注册表 API 的旧版 Docker 不
- en: support this feature and use V1 instead. In those cases, and for other cases
    where signatures are unknown, a high degree of
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此功能并使用 V1。在这些情况下，以及其他签名未知的情况下，对主机提供的授权和静态安全功能的高度信任被投入其中。
- en: trust is put into the authorization and at-rest security features provided by
    the host.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 将信任置于由主机提供的授权和静态安全功能。
- en: '|'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Confidentiality   | Worst   | Hosted registries and public repositories are
    never appropriate for storing and distributing cleartext secrets or sensitive
                      code. Remember, secrets include passwords, API keys, certificates,
    and more. Anyone can access these secrets.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '| 机密性              | 最差              | 托管注册表和公共仓库从不适合存储和分发明文密钥或敏感代码。记住，密钥包括密码、API
    密钥、证书等等。任何人都可以访问这些密钥。'
- en: '|'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Requisite experience                | Best                | Using public
    repositories on hosted registries requires only that you be minimally familiar
    with Docker and capable of setting                   up an account through a website.
    This solution is within reach for any Docker user.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '| 必需经验              | 最佳              | 在托管注册表上使用公共仓库只需要您对 Docker 有基本的了解，并且能够通过网站设置账户。这个解决方案对任何
    Docker 用户来说都触手可及。'
- en: '|'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Public repositories on hosted registries are the best choice for owners of open
    source projects or people who are just getting started with Docker. People should
    still be skeptical of software that they download and run from the internet, so
    public repositories that don’t expose their sources can be difficult for some
    users to trust. Hosted (trusted) builds solve this problem to a certain extent.
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 托管注册表上的公共仓库是开源项目所有者或刚开始使用 Docker 的人的最佳选择。人们仍然应该对从互联网下载并运行的软件持怀疑态度，因此不公开源代码的公共仓库可能对某些用户来说难以信任。托管（受信任）构建在一定程度上解决了这个问题。
- en: 9.2.2\. Private hosted repositories
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.2. 私有托管仓库
- en: Private repositories are similar to public repositories from an operational
    and product perspective. Most registry providers offer both options, and any differences
    in provisioning through their websites will be minimal. Because the Docker registry
    API makes no distinction between the two types of repositories, registry providers
    that offer both generally require you to provision private registries through
    their website, app, or API.
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从操作和产品角度来看，私有仓库与公共仓库相似。大多数注册表提供商都提供这两种选项，并且通过他们的网站进行配置的差异将是微小的。因为 Docker 注册表
    API 对这两种类型的仓库没有区别，所以提供这两种选项的注册表提供商通常要求您通过他们的网站、应用程序或 API 配置私有注册表。
- en: The tools for working with private repositories are identical to those for working
    with public repositories, with one exception. Before you can use `docker image
    pull` or `docker container run` to install an image from a private repository,
    you need to authenticate with the registry where the repository is hosted. To
    do so, you use the `docker login` command just as you would if you were using
    `docker image push` to upload an image.
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与私有仓库一起工作的工具与用于公共仓库的工具相同，只有一个例外。在您可以使用 `docker image pull` 或 `docker container
    run` 从私有仓库安装镜像之前，您需要验证存储该仓库的注册表。为此，您使用 `docker login` 命令，就像您使用 `docker image push`
    上传镜像一样。
- en: 'The following commands prompt you to authenticate with the registries provided
    by Docker Hub and Quay.io. After creating accounts and authenticating, you’ll
    have full access to your public and private repositories on all three registries.
    The `login` subcommand takes an optional server argument:'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下命令会提示您使用 Docker Hub 和 Quay.io 提供的注册表进行验证。在创建账户并验证后，您将能够访问所有三个注册表上的公共和私有仓库。`login`
    子命令接受一个可选的服务器参数：
- en: '`docker login # Username: dockerinaction # Password: # Email: book@dockerinaction.com
    # WARNING: login credentials saved in /Users/xxx/.dockercfg. # Login Succeeded  docker
    login quay.io # Username: dockerinaction # Password: # Email: book@dockerinaction.com
    # WARNING: login credentials saved in /Users/xxx/.dockercfg. # Login Succeeded`'
  id: totrans-664
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker login # 用户名: dockerinaction # 密码: # 邮箱: book@dockerinaction.com # 警告：登录凭证已保存在
    /Users/xxx/.dockercfg 中。 # 登录成功 docker login quay.io # 用户名: dockerinaction # 密码:
    # 邮箱: book@dockerinaction.com # 警告：登录凭证已保存在 /Users/xxx/.dockercfg 中。 # 登录成功`'
- en: Before you decide that private hosted repositories are the distribution solution
    for you, consider how they might fulfill your selection criteria; see [table 9.2](#filepos952815).
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您决定私有托管存储库是您的分发解决方案之前，请考虑它们如何满足您的选择标准；参见[表9.2](#filepos952815)。
- en: Table 9.2\. Performance of private hosted repositories
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.2\. 私有托管存储库的性能
- en: '|'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-668
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准
- en: '|'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-670
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-672
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注
- en: '|'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Good                | The cost of private repositories
    typically scales with the number of repositories that you need. Plans usually
    range from                   a few dollars per month for 5 repositories, to around
    $50 for 50 repositories. Price pressure of storage and monthly virtual'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '| 成本                  | 良好              | 私有存储库的成本通常与您需要的存储库数量成比例。计划通常从                        
    每月几美元的5个存储库，到50个存储库的约50美元不等。存储和每月虚拟'
- en: server hosting is a driving factor here. Users or organizations that require
    more than 50 repositories may find it more appropriate
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器托管是这里的一个驱动因素。需要超过50个存储库的用户或组织可能会发现自行运行私有注册表更为合适。
- en: to run their own private registry.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 运行他们自己的私有注册表。
- en: '|'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Visibility   | Best   | Private repositories are by definition private. These
    are typically excluded from indexes and should require authentication                  
    before a registry acknowledges the repository’s existence. They are great tools
    for organizations that don’t want to incur'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可见性                  | 最佳              | 私有存储库按定义是私有的。这些通常被排除在索引之外，并且在注册表确认存储库的存在之前通常需要身份验证                        
    。它们是组织不希望承担'
- en: the overhead associated with running their own registry or for small private
    projects. Private repositories are poor candidates
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行自己的注册表或小型私有项目相关的开销。私有存储库不是长期控制的良好候选者
- en: for publicizing availability of commercial software or distributing open source
    images.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 用于宣传商业软件的可用性或分发开源镜像。
- en: '|'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Better                | Any hosted
    registry such as Docker Hub will minimize the bandwidth used to transfer an image
    and enable clients to transfer                   an image’s layers in parallel.
    Ignoring potential latency introduced by transferring files over the internet,
    hosted registries'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小              | 较好              | 任何托管注册表，如Docker Hub，都将最小化传输镜像所使用的带宽，并允许客户端并行传输                        
    镜像层。忽略通过互联网传输文件可能引入的潜在延迟，托管注册表'
- en: should always perform well against other nonregistry solutions.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 应始终与其他非注册表解决方案表现良好。
- en: '|'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Good   | You have no longevity control over hosted
    registries. But registries will all conform to the Docker registry API, and migrating
                      from one host to another should be a low-cost exercise.   |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| 长期控制              | 良好              | 您无法控制托管注册表的长久性。但所有注册表都将符合Docker注册表API，并且从一个主机迁移到另一个主机应该是一项低成本的操作。  
    |'
- en: '| Availability control                | Worst/OK                | No hosted
    registry provides any availability control. Unlike using public repositories,
    however, using private repositories                   will make you a paying customer.
    Paying customers may have stronger SLA guarantees or access to support personnel.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可用性控制              | 最差/良好              | 没有托管注册表提供任何可用性控制。然而，与使用公共存储库不同，使用私有存储库                
    将使您成为付费客户。付费客户可能享有更强的服务等级协议保证或访问支持人员的权限。'
- en: '|'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Access control   | Better   | Both read and write access to private repositories
    is restricted to users with authorization.   |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| 访问控制              | 较好              | 对私有存储库的读取和写入访问权限仅限于授权用户。   |'
- en: '| Artifact integrity                | Best                | It’s reasonable
    to expect all hosted registries to support the V2 registry API and content-addressable
    images.             |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| 艺术品完整性              | 最佳              | 有理由期望所有托管注册表都支持V2注册表API和内容寻址镜像。          
    |'
- en: '| Confidentiality   | Worst   | Despite the privacy provided by these repositories,
    they are never suitable for storing cleartext secrets or trade-secret                  
    code. Although the registries require user authentication and authorization to
    requested resources, these mechanisms have'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '| 隐私                  | 最差              | 尽管这些存储库提供了隐私保护，但它们从不适合存储明文密钥或商业机密                        
    代码。尽管注册表要求用户对请求的资源进行身份验证和授权，但这些机制存在'
- en: several potential problems. The provider may use weak credential storage, have
    weak or lost certificates, or leave your artifacts
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 几个潜在问题。提供商可能使用弱凭证存储，拥有弱或丢失的证书，或者留下您的艺术品
- en: unencrypted at rest. Finally, your secret material should not be accessible
    to employees of the registry provider.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 静止状态下未加密。最后，你的机密材料不应被注册表提供商的员工访问。
- en: '|'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Requisite experience                | Best                | As with public
    repositories, using private repositories on hosted registries requires only that
    you be minimally familiar                   with Docker and capable of setting
    up an account through a website. This solution is within reach for any Docker
    user.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '| 必需的经验                      | 最佳                      | 与公共仓库一样，在托管注册表中使用私有仓库只需要你至少熟悉Docker，并能够通过网站设置账户。这种解决方案对任何Docker用户来说都触手可及。'
- en: '|'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Individuals and small teams will find the most utility in private hosted repositories.
    Their low cost and basic authorization features are friendly to low-budget projects
    or private projects with minimal security requirements. Large companies or projects
    that need a higher degree of secrecy and have a suitable budget may find their
    needs better met by running their own private registry.
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 个人和小型团队会发现私有托管仓库最有用。它们低成本和基本授权功能对低成本项目或对安全性要求最低的私有项目来说非常友好。需要更高保密度且预算合适的的大型公司或项目可能会发现运行自己的私有注册表更能满足他们的需求。
- en: 9.3\. INTRODUCING PRIVATE REGISTRIES
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3\. 介绍私有注册表
- en: When you have a hard requirement on availability control, longevity control,
    or secrecy, then running a private registry may be your best option. In doing
    so, you gain control without sacrificing interoperability with Docker pull and
    push mechanisms or adding to the learning curve for your environment. People can
    interact with a private registry exactly as they would with a hosted registry.
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你对可用性控制、长期控制或保密性有严格要求时，运行私有注册表可能是你的最佳选择。这样做，你可以在不牺牲与Docker拉取和推送机制互操作性或增加你环境的学习曲线的情况下获得控制权。人们可以像与托管注册表交互一样与私有注册表交互。
- en: Many free and commercially supported software packages are available for running
    a Docker image registry. If your organization has a commercial artifact repository
    for operating system or application software packages, it probably supports the
    Docker image registry API. A simple option for running a nonproduction image registry
    is to use Docker’s registry software. The Docker registry, called Distribution,
    is open source software and distributed under the Apache 2 license. The availability
    of this software and permissive license keep the engineering cost of running your
    own registry low. [Figure 9.3](#filepos968511) illustrates that private registries
    fall in the middle of the distribution spectrum.
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有许多免费和商业支持的软件包可用于运行Docker镜像注册表。如果你的组织有一个用于操作系统或应用程序软件包的商业工件仓库，它可能支持Docker镜像注册表API。运行非生产环境镜像注册表的一个简单选项是使用Docker的注册表软件。Docker注册表，称为Distribution，是开源软件，在Apache
    2许可证下分发。该软件的可用性和宽松的许可证使运行自己的注册表的工程成本保持较低。[图9.3](#filepos968511)说明了私有注册表位于分发谱的中间。
- en: Figure 9.3\. Private registries in the image distribution spectrum
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.3\. 图像分发谱中的私有仓库
- en: '![](images/00063.jpg)'
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00063.jpg)'
- en: 'Running a private registry is a great distribution method if you have special
    infrastructure use cases like the following:'
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行私有仓库是一个很好的分发方法，如果你有如下特殊的基础设施使用案例：
- en: Regional image caches
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域图像缓存
- en: Team-specific image distribution for locality or visibility
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定团队的图像分发以实现本地化或可见性
- en: Environment or deployment stage-specific image pools
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定环境或部署阶段的图像池
- en: Corporate processes for approving images
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审批图像的内部流程
- en: Longevity control of external images
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部图像的长期控制
- en: Before deciding that this is the best choice for you, consider the costs detailed
    in the selection criteria, shown in [table 9.3](#filepos970142).
  id: totrans-708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在决定这是否是你最佳选择之前，考虑选择标准中详细列出的成本，如[表9.3](#filepos970142)所示。
- en: Table 9.3\. Performance of private registries
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.3\. 私有注册表的性能
- en: '|'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-711
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准
- en: '|'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注
- en: '|'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Good                | At a minimum, a private registry
    adds to hardware overhead (virtual or otherwise), support expense, and risk of
    failure. But                   the community has already invested the bulk of
    the engineering effort required to deploy a private registry by building the'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '| 成本              | 良好              | 至少，私有注册表会增加硬件开销（虚拟或其他），支持费用和失败风险。但社区已经通过构建'
- en: open source software. Cost will scale on different dimensions than hosted registries.
    Whereas the cost of hosted repositories
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件。成本将在不同的维度上扩展。与托管注册表的成本不同，
- en: scales with raw repository count, the cost of private registries scales with
    transaction rates and storage usage. If you build
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 随着原始存储库数量的增加而增加，私有注册表的成本随着交易率和存储使用量的增加而增加。如果您构建
- en: a system with high transaction rates, you’ll need to scale up the number of
    registry hosts so that you can handle the demand.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在高交易率系统中，您需要增加注册表主机的数量，以便能够处理需求。
- en: Likewise, registries that serve a certain number of small images will have lower
    storage costs than those serving the same
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为一定数量的小型图像提供服务的注册表将比为相同
- en: number of large images.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 大型图像的系统具有更低的存储成本。
- en: '|'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Visibility   | Good   | Private registries are as visible as you decide to
    make them. But even a registry that you own and open up to the world will                  
    be less visible than advertised popular registries such as Docker Hub.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可见性                      | 良好                      | 私有注册表的可视性取决于您的决定。但即使是您拥有并向世界开放的注册表，其可见性也会低于Docker
    Hub等流行的注册表。'
- en: '|'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Best                | Latency of operations
    between any client and any registry will vary based on network performance between
    those two nodes and                   load on the registry. Private registries
    may be faster or slower than hosted registries because of these variables. Most
    people'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小                      | 最佳                      | 任何客户端与任何注册表之间的操作延迟将根据这两个节点之间的网络性能和注册表的负载而变化。由于这些变量，私有注册表可能比托管注册表更快或更慢。大多数人'
- en: operating large-scale deployments or internal infrastructure will find private
    registries appealing. Private registries eliminate
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型部署或内部基础设施中运营的人会发现私有注册表很有吸引力。私有注册表消除了
- en: a dependency on the internet or inter-datacenter networking and will improve
    latency proportionate to the external network
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于互联网或数据中心之间的网络，并将提高与外部网络的
- en: constraint. Because this solution uses a Docker registry, it shares the same
    parallelism gains as hosted registry solutions.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 约束。因为这个解决方案使用了Docker注册表，所以它共享了托管注册表解决方案相同的并行性收益。
- en: '|'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Best   | You have full control over solution longevity
    as the registry owner.   |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| 长期控制                      | 最佳                      | 作为注册表所有者，您完全控制着解决方案的长期性。   |'
- en: '| Availability control                | Best                | You have full
    control over availability as the registry owner.             |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| 可用性控制                      | 最佳                      | 作为注册表所有者，您完全控制着可用性。  
    |'
- en: '| Access control   | Good   | The registry software doesn’t include any authentication
    or authorization features out of the box. But implementing those                  
    features can be achieved with a minimal engineering exercise.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '| 访问控制                      | 良好                      | 注册表软件默认不包含任何身份验证或授权功能。但实现这些功能可以通过最小的工程练习来完成。'
- en: '|'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Artifact integrity                | Best                | Version 2 of the
    registry API supports content-addressable images, and the open source software
    supports a pluggable storage                   backend. For additional integrity
    protections, you can force the use of TLS over the network and use backend storage
    with'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '| 文件完整性                      | 最佳                      | 注册表API的版本2支持基于内容的图像，开源软件支持可插拔的存储后端。为了提供额外的完整性保护，您可以强制在网络中使用TLS，并使用带有'
- en: encryption at rest.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 静态加密。
- en: '|'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Confidentiality   | Good   | Private registries are the first solution on
    the spectrum appropriate for storage of trade secrets or secret material. You
                      control the authentication and authorization mechanisms. You
    also control the network and in-transit security mechanisms.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '| 保密性                      | 良好                      | 私有注册表是光谱上第一个适合存储商业机密或机密材料的解决方案。您控制着身份验证和授权机制。您还控制着网络和传输中的安全机制。'
- en: Most importantly, you control the at-rest storage. It’s in your power to ensure
    that the system is configured in such a way
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，您控制着静态存储。您有权力确保系统以这种方式配置
- en: that your secrets stay secret.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 保证您的机密信息保持机密。
- en: '|'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Requisite experience                | Good                | Getting started
    and running a local registry requires only basic Docker experience. But running
    and maintaining a highly available                   production private registry
    requires experience with several technologies. The specific set depends on what
    features you want'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '| 必要经验                      | 良好                      | 开始运行本地仓库只需要基本的Docker经验。但是，运行和维护一个高度可用的生产私有仓库需要具备多种技术的经验。具体取决于你想要'
- en: to take advantage of. Generally, you’ll want to be familiar with NGINX to build
    a proxy, LDAP or Kerberos to provide authentication,
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 可以利用的。通常，你将需要熟悉NGINX来构建代理，LDAP或Kerberos来提供身份验证，
- en: and Redis for caching. Many commercial product solutions are available for running
    a private Docker registry, ranging from
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 以及Redis用于缓存。许多商业产品解决方案可用于运行私有Docker仓库，范围从
- en: traditional artifact repositories such as Artifactory and Nexus to software
    delivery systems like GitLab.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的工件仓库，如Artifactory和Nexus，到软件交付系统，如GitLab。
- en: '|'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The biggest trade-off when going from hosted registries to private registries
    is gaining flexibility and control while requiring greater depth and breadth of
    engineering experience to build and maintain the solution. Docker image registries
    often consume large amounts of storage, so be sure to account for that in your
    analysis. The remainder of this section covers what you need in order to implement
    all but the most complicated registry deployment designs and highlights opportunities
    for customization in your environment.
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从托管仓库迁移到私有仓库时最大的权衡是在获得灵活性和控制的同时，需要更大的工程经验深度和广度来构建和维护解决方案。Docker镜像仓库通常消耗大量存储空间，因此在分析时务必考虑这一点。本节剩余部分涵盖了实现除最复杂仓库部署设计之外所需的内容，并突出了在您环境中定制的机遇。
- en: 9.3.1\. Using the registry image
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.1\. 使用仓库镜像
- en: 'Whatever your reasons for doing so, getting started with the Docker registry
    software is easy. The Distribution software is available on Docker Hub in a repository
    named `registry`. Starting a local registry in a container can be done with a
    single command:'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你这样做的原因是什么，开始使用Docker仓库软件都很简单。分发软件可在Docker Hub上的名为`registry`的仓库中找到。在容器中启动本地仓库可以通过单个命令完成：
- en: '`docker run -d -p 5000:5000 \         -v "$(pwd)"/data:/tmp/registry-dev \
            --restart=always --name local-registry registry:2`'
  id: totrans-750
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d -p 5000:5000 \  '
- en: The image that’s distributed through Docker Hub is configured for insecure access
    from the machine running a client’s Docker daemon. When you’ve started the registry,
    you can use it like any other registry with `docker pull`, `run`, `tag`, and `push`
    commands. In this case, the registry location is `localhost:5000`. The architecture
    of your system should now match that described in [figure 9.4](#filepos987367).
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过Docker Hub分发到机器上的镜像配置为从运行客户端Docker守护进程的机器进行不安全访问。当你启动了仓库后，你可以像使用其他任何仓库一样使用`docker
    pull`、`run`、`tag`和`push`命令。在这种情况下，仓库位置是`localhost:5000`。现在，你的系统架构应该与[图9.4](#filepos987367)中描述的相匹配。
- en: Figure 9.4\. Interactions between the Docker client, daemon, local registry
    container, and local storage
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.4\. Docker客户端、守护进程、本地仓库容器和本地存储之间的交互
- en: '![](images/00081.jpg)'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00081.jpg)'
- en: 'Companies that want tight version control on their external image dependencies
    will pull images from external sources such as Docker Hub and copy them into their
    own registry. You might do this to ensure that an important image does not change
    or disappear unexpectedly when the author updates or removes the source image.
    To get an idea of what it’s like working with your registry, consider a workflow
    for copying images from Docker Hub into your new registry:'
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想要在他们的外部镜像依赖项上实施严格版本控制的公司将从外部源（如Docker Hub）拉取镜像并将它们复制到自己的仓库中。你可能这样做是为了确保在作者更新或删除源镜像时，重要的镜像不会意外更改或消失。为了了解在你的仓库中工作的感觉，考虑以下从Docker
    Hub复制镜像到新仓库的工作流程：
- en: '`docker image pull dockerinaction/ch9_registry_bound` `1` `docker image ls
    -f "label=dia_excercise=ch9_registry_bound"` `2` `docker image tag dockerinaction/ch9_registry_bound
    \     localhost:5000/dockerinaction/ch9_registry_bound  docker image push localhost:5000/dockerinaction/ch9_registry_bound`
    `3`'
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image pull dockerinaction/ch9_registry_bound` `1` `docker image ls
    -f "label=dia_excercise=ch9_registry_bound"` `2` `docker image tag dockerinaction/ch9_registry_bound
    \  '
- en: 1 Pulls demo image from Docker Hub
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 从Docker Hub拉取演示镜像
- en: 2 Verifies image is discoverable with label filter
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 使用标签过滤器验证镜像可被发现
- en: 3 Pushes demo image into registry
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 将演示镜像推送到注册表
- en: In running these four commands, you copy an example repository from Docker Hub
    into your local repository. If you execute these commands from the same location
    from which you started the registry, you’ll find that the newly created data subdirectory
    contains new registry data.
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行这四个命令时，您将从Docker Hub复制一个示例仓库到您的本地仓库。如果您从启动注册表的位置执行这些命令，您会发现新创建的数据子目录包含新的注册表数据。
- en: 9.3.2\. Consuming images from your registry
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.2. 从您的注册表中消费镜像
- en: The tight integration you get with the Docker ecosystem can make it feel like
    you’re working with software that’s already installed on your computer. When internet
    latency has been eliminated, such as when you’re working with a local registry,
    it can feel even less like you’re working with distributed components. For that
    reason, the exercise of pushing data into a local repository isn’t very exciting
    on its own.
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与Docker生态系统紧密集成可以使您感觉您正在使用已经安装在您计算机上的软件。当消除互联网延迟，例如您在与本地注册表一起工作时，这种感觉甚至更少像您正在使用分布式组件。因此，将数据推送到本地仓库的练习本身并不那么令人兴奋。
- en: 'The next set of commands should impress on you that you’re working with a real
    registry. These commands will remove the example repositories from the local cache
    for your Docker daemon, demonstrate that they’re gone, and then reinstall them
    from your personal registry:'
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下一个命令集应该让您印象深刻，您正在使用一个真实的注册表。这些命令将从您的Docker守护进程的本地缓存中删除示例仓库，证明它们已消失，然后从您的个人注册表重新安装它们：
- en: '`docker image rm \     dockerinaction/ch9_registry_bound \     localhost:5000/dockerinaction/ch9_registry_bound`
    `1` `docker image ls -f "label=dia_excercise=ch9_registry_bound"  docker image
    pull localhost:5000/dockerinaction/ch9_registry_bound` `2` `docker image ls -f
    "label=dia_excercise=ch9_registry_bound"` `3` `docker container rm -vf local-registry`
    `4`'
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image rm \ dockerinaction/ch9_registry_bound \ localhost:5000/dockerinaction/ch9_registry_bound`
    `1` `docker image ls -f "label=dia_excercise=ch9_registry_bound"` `2` `docker
    image ls -f "label=dia_excercise=ch9_registry_bound"` `3` `docker container rm
    -vf local-registry` `4`'
- en: 1 Removes tagged reference
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 删除标记引用
- en: 2 Pulls from registry again
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 再次从注册表拉取
- en: 3 Demonstrates that image is back
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 验证镜像已返回
- en: 4 Cleans up local registry
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 清理本地注册表
- en: You can work with this registry locally as much as you want, but the insecure
    default configuration will prevent remote Docker clients from using your registry
    (unless they specifically allow insecure access). This is one of the few issues
    that you’ll need to address before deploying a registry in a production environment.
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以尽可能多地在本地上使用此注册表，但默认的不安全配置将阻止远程Docker客户端使用您的注册表（除非它们明确允许不安全访问）。这是在部署生产环境中的注册表之前需要解决的一些问题之一。
- en: This is the most flexible distribution method that involves Docker registries.
    If you need greater control over transport, storage, and artifact management,
    you should consider working directly with images in a manual distribution system.
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是涉及Docker注册表的最灵活的分发方法。如果您需要更多控制运输、存储和工件管理，您应该考虑在手动分发系统中直接与镜像一起工作。
- en: 9.4\. MANUAL IMAGE PUBLISHING AND DISTRIBUTION
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.4. 手动镜像发布和分发
- en: Images are files, and you can distribute them as you would any other file. It’s
    common to see software available for download on websites, File Transport Protocol
    (FTP) servers, corporate storage networks, or via peer-to-peer networks. You could
    use any of these distribution channels for image distribution. You can even use
    email or a USB drive in cases where you know your image recipients. Manual image
    distribution methods provide the ultimate in flexibility, enabling varied use
    cases such as distributing images to many people at an event simultaneously or
    to a secure air-gapped network.
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像是文件，您可以像分发其他任何文件一样分发它们。在网站上下载软件、文件传输协议（FTP）服务器、企业存储网络或通过对等网络分发软件是很常见的。您可以使用这些任何一种分发渠道进行镜像分发。如果您知道您的镜像接收者，您甚至可以使用电子邮件或USB驱动器。手动镜像分发方法提供了最大的灵活性，使得各种用例成为可能，例如在活动中同时向许多人分发镜像或向安全的断网网络分发。
- en: When you work with images as files, you use Docker only to manage local images
    and create files. All other concerns are left for you to implement. That void
    of functionality makes manual image publishing and distribution the second-most
    flexible but complicated distribution method. This section covers custom image
    distribution infrastructure, shown on the spectrum in [figure 9.5](#filepos995787).
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您将镜像作为文件处理时，您只需使用Docker来管理本地镜像和创建文件。所有其他问题都留给了您来实现。这种功能空白使得手动镜像发布和分发成为第二灵活但最复杂的一种分发方法。本节涵盖了自定义镜像分发基础设施，如图9.5所示。
- en: Figure 9.5\. Docker image distribution over custom infrastructure
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.5\. 在自定义基础设施上进行的Docker镜像分发
- en: '![](images/00028.jpg)'
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00028.jpg)'
- en: We’ve already covered all the methods for working with images as files. [Chapter
    3](index_split_032.html#filepos303917) covers loading images into Docker and saving
    images to your hard drive. [Chapter 7](index_split_063.html#filepos667222) covers
    exporting and importing full filesystems as flattened images. These techniques
    are the foundation for building distribution workflows like the one shown in [figure
    9.6](#filepos996931).
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有以文件形式处理镜像的方法。[第3章](index_split_032.html#filepos303917)涵盖了将镜像加载到Docker和将镜像保存到您的硬盘上。[第7章](index_split_063.html#filepos667222)涵盖了将完整文件系统作为扁平化镜像导出和导入。这些技术是构建如图9.6所示的分发工作流程的基础。
- en: Figure 9.6\. A typical manual distribution workflow with producer, transport,
    and consumers
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.6\. 典型的手动分发工作流程，包括生产者、运输和消费者
- en: '![](images/00082.jpg)'
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00082.jpg)'
- en: This workflow is a generalization of how you’d use Docker to create an image
    and prepare it for distribution. You should be familiar with using `docker image
    build` to create an image, and `docker image save` or `docker container export`
    to create an image file. You can perform each of these operations with a single
    command.
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此工作流程是对您如何使用Docker创建镜像并为其分发做准备的一般化。您应该熟悉使用`docker image build`来创建镜像，以及使用`docker
    image save`或`docker container export`来创建镜像文件。您可以使用单个命令执行这些操作中的每一个。
- en: You can use any file transport after you have an image in file form. One custom
    component not shown in [figure 9.6](#filepos996931) is the mechanism that uploads
    an image to the transport. That mechanism may be a folder that is watched by a
    file-sharing tool such as Dropbox. It could also be a piece of custom code that
    runs periodically, or in response to a new file, and uses FTP or HTTP to push
    the file to a remote server. Whatever the mechanism, this general component will
    require some effort to integrate.
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在您拥有镜像文件后，可以使用任何文件传输方式。在图9.6中未显示的一个自定义组件是将镜像上传到传输机制的机制。这种机制可能是一个由Dropbox等文件共享工具监视的文件夹。它也可能是一段定期运行或响应新文件的定制代码，并使用FTP或HTTP将文件推送到远程服务器。无论机制如何，这个通用组件都需要一些努力来集成。
- en: The figure also shows how a client would ingest the image and use it to build
    a container after the image has been distributed. Clients require a process or
    mechanism to learn where the image is located and then acquire the image from
    the remote source. Once clients have the image file, they can use the `docker
    image load` or `import` commands to complete the transfer.
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该图还展示了客户端如何在镜像分发后摄取镜像并使用它来构建容器。客户端需要一个进程或机制来学习镜像的位置，然后从远程源获取镜像。一旦客户端拥有镜像文件，他们可以使用`docker
    image load`或`import`命令来完成传输。
- en: Manual image distribution methods are difficult to measure against the selection
    criteria without knowing the specifics of the distribution problem. Using a non-Docker
    distribution channel gives you full control, making it possible to handle unusual
    requirements. It will be up to you to determine how your options measure against
    the selection criteria. [Table 9.4](#filepos1000136) explores how manual image
    distribution methods rate against the selection criteria.
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在不知道具体分发问题的情况下，手动镜像分发方法很难与选择标准进行衡量。使用非Docker分发渠道可以给您完全的控制权，使其能够处理不寻常的需求。您将需要确定您的选项如何与选择标准相匹配。[表9.4](#filepos1000136)探讨了手动镜像分发方法如何与选择标准相匹配。
- en: Table 9.4\. Performance of custom image distribution infrastructure
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.4\. 自定义镜像分发基础设施的性能
- en: '|'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准
- en: '|'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-787
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意事项
- en: '|'
  id: totrans-789
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Good                | Distribution costs are driven
    by bandwidth, storage, and hardware needs. Hosted distribution solutions such
    as cloud storage                   will bundle these costs and generally scale
    down price per unit as your usage increases. But hosted solutions bundle in the'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '| 成本   | 好   | 分发成本由带宽、存储和硬件需求驱动。托管分发解决方案，如云存储，将捆绑这些成本，并且通常随着使用量的增加而降低每单位的价格。但托管解决方案捆绑了'
- en: cost of personnel and several other benefits that you may not need, driving
    up the price compared to a mechanism that you
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 成本，包括人员成本以及您可能不需要的几个其他好处，这会使价格与您
- en: own.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: own.
- en: '|'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Visibility   | Bad   | Most manual distribution methods are special and will
    take more effort to advertise and use than public or private registries.                  
    Examples might include using popular websites or other well-known file distribution
    hubs.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可见性   | 差   | 大多数手动分发方法都是特殊的，与公共或私有注册相比，它们需要更多的努力来宣传和使用。示例可能包括使用流行的网站或其他知名的文件分发中心。'
- en: '|'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Good                | Whereas transport
    speed depends on the transport, file sizes are dependent on your choice of using
    layered images or flattened                   images. Remember, layered images
    maintain the history of the image, container-creation metadata, and old files
    that might'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小   | 好   | 虽然传输速度取决于传输方式，但文件大小取决于您选择使用分层图像或扁平图像。记住，分层图像保留了图像的历史、容器创建元数据和可能'
- en: have been deleted or overridden. Flattened images contain only the current set
    of files on the filesystem.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: have been deleted or overridden. Flattened images contain only the current set
    of files on the filesystem.
- en: '|'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Bad   | Using proprietary protocols, tools, or other
    technology that is neither open nor under your control will impact longevity                  
    control. For example, distributing image files with a hosted file-sharing service
    such as Dropbox will give you no longevity'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '| 长期控制   | 差   | 使用既不开放也不在您控制之下的专有协议、工具或其他技术将影响长期控制。例如，使用像Dropbox这样的托管文件共享服务分发图像文件将不会为您提供任何长期'
- en: control. On the other hand, swapping USB drives with your friend will last as
    long as the two of you decide to use USB drives.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 控制权。另一方面，与您的朋友交换USB驱动器将持续到你们两人决定使用USB驱动器为止。
- en: '|'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Availability control                | Best                | If availability
    control is an important factor for your case, you can use a transport mechanism
    that you own.             |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| 可用性控制   | 最佳   | 如果可用性控制对您的案例很重要，您可以使用您拥有的传输机制。    |'
- en: '| Access control   | Bad   | You could use a transport with the access control
    features you need or use file encryption. If you built a system that encrypted
                      your image files with a specific key, you could be sure that
    only a person or people with the correct key could access the'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '| 访问控制   | 差   | 您可以使用具有所需访问控制功能的传输或使用文件加密。如果您构建了一个使用特定密钥加密图像文件的系统，您可以确信只有拥有正确密钥的人或人们才能访问'
- en: image.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: image.
- en: '|'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Artifact integrity                | Bad                | Integrity validation
    is a more expensive feature to implement for broad distribution. At a minimum,
    you’d need a trusted communication                   channel for advertising cryptographic
    file signatures and creating archives that maintain image and layer signatures
    by using'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '| 文件完整性   | 差   | 完整性验证是实现广泛分布的更昂贵的功能之一。至少，您需要一个可信的通信通道来宣传加密文件签名并创建通过使用'
- en: docker image save and load.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: docker image save and load.
- en: '|'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Confidentiality   | Good   | You can implement content secrecy with cheap
    encryption tools. If you need meta-secrecy (where the exchange itself is secret)
                      as well as content secrecy, then you should avoid hosted tools
    and make sure that the transport you use provides secrecy (HTTPS,'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '| 机密性   | 好   | 您可以使用廉价的加密工具实现内容保密。如果您还需要元保密（即交换本身是保密的）以及内容保密，那么您应该避免使用托管工具，并确保您使用的传输方式提供保密（HTTPS，'
- en: SFTP, SSH, or offline).
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: SFTP、SSH或离线）。
- en: '|'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Requisite experience                | Good                | Hosted tools
    will typically be designed for ease of use and require a lesser degree of experience
    to integrate with your workflow.                   But you can as easily use simple
    tools that you own in most cases.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '| 必要经验                      | 良好              | 托管工具通常设计用于易于使用，并且与您的流程集成需要较低的经验水平。                        
    但在大多数情况下，您也可以轻松使用您拥有的简单工具。'
- en: '|'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: All the same criteria apply to manual distribution, but it’s difficult to discuss
    them without the context of a specific transportation method.
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有相同的标准适用于手动分发，但如果没有具体的运输方法背景，很难讨论它们。
- en: 9.4.1\. A sample distribution infrastructure using FTP
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.4.1\. 使用FTP的一个示例分发基础设施
- en: Building a fully functioning example will help you understand exactly what goes
    into a manual distribution infrastructure. This section will help you build an
    infrastructure with the File Transfer Protocol.
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建一个完全功能性的示例将帮助您了解手动分发基础设施中包含的内容。本节将帮助您使用文件传输协议构建基础设施。
- en: FTP is less popular than it used to be. The protocol provides no secrecy and
    requires credentials to be transmitted over the wire for authentication. But the
    software is freely available, and clients have been written for most platforms.
    That makes FTP a great tool for building your own distribution infrastructure.
    [Figure 9.7](#filepos1014967) illustrates what you’ll build.
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FTP不如以前受欢迎。该协议不提供保密性，并且需要通过有线传输凭据进行身份验证。但是，软件是免费提供的，并且为大多数平台编写了客户端。这使得FTP成为构建自己的分发基础设施的绝佳工具。[图9.7](#filepos1014967)展示了您将构建的内容。
- en: Figure 9.7\. An FTP publishing infrastructure
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.7\. 一个FTP发布基础设施
- en: '![](images/00069.jpg)'
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00069.jpg)'
- en: The example in this section uses two existing images. The first, `dockerinaction/ch9
    _ftpd`, is a specialization of the `centos:6` image; `vsftpd` (an FTP daemon)
    has been installed and configured for anonymous write access. The second image,
    `dockerinaction/ch9_ftp_client`, is a specialization of a popular minimal Alpine
    Linux image. An FTP client named `LFTP` has been installed and set as the entrypoint
    for the image.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节中的示例使用两个现有镜像。第一个，`dockerinaction/ch9_ftpd`，是`centos:6`镜像的专门化；已安装并配置了`vsftpd`（一个FTP守护进程）以允许匿名写入访问。第二个镜像，`dockerinaction/ch9_ftp_client`，是一个流行的最小化Alpine
    Linux镜像的专门化。已安装了一个名为`LFTP`的FTP客户端，并将其设置为镜像的入口点。
- en: 'To prepare for the experiment, pull a known image from Docker Hub that you
    want to distribute. In the example, the `registry:2` image is used:'
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了准备实验，从Docker Hub拉取您想要分发的已知镜像。在示例中，使用的是`registry:2`镜像：
- en: '`docker image pull registry:2`'
  id: totrans-822
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image pull registry:2`'
- en: 'Once you have an image to distribute, you can begin. The first step is building
    your image distribution infrastructure. In this case, that means running an FTP
    server, which you will do on a dedicated network:'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦您有了要分发的镜像，您就可以开始了。第一步是构建您的镜像分发基础设施。在这种情况下，这意味着运行一个FTP服务器，您将在专用网络上执行此操作：
- en: '`docker network create ch9_ftp docker container run -d --name ftp-server --network=ch9_ftp
    -p 21:21 \     dockerinaction/ch9_ftpd`'
  id: totrans-824
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker network create ch9_ftp docker container run -d --name ftp-server --network=ch9_ftp
    -p 21:21 \ dockerinaction/ch9_ftpd`'
- en: This command starts an FTP server that accepts FTP connections on TCP port 21
    (the default port). Don’t use this image in any production capacity. The server
    is configured to allow anonymous connections write access under the pub/incoming
    folder. Your distribution infrastructure will use that folder as an image distribution
    point.
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令启动一个FTP服务器，该服务器在TCP端口21（默认端口）上接受FTP连接。不要在生产环境中使用此镜像。服务器配置为允许在pub/incoming文件夹下匿名连接写入访问。您的分发基础设施将使用该文件夹作为镜像分发点。
- en: 'Next, export an image to the file format. You can use the following command
    to do so:'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，将镜像导出为文件格式。您可以使用以下命令来完成此操作：
- en: '`docker image save -o ./registry.2.tar registry:2`'
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image save -o ./registry.2.tar registry:2`'
- en: Running this command exports the `registry:2` image as a structured image file
    in your current directory. The file retains all the metadata and history associated
    with the image. At this point, you could inject all sorts of phases, such as checksum
    generation or file encryption. This infrastructure has no such requirements, and
    you should move along to distribution.
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行此命令会将`registry:2`镜像作为结构化镜像文件导出到您的当前目录。该文件保留了与镜像相关的所有元数据和历史记录。在此阶段，您可以注入各种阶段，例如生成校验和或文件加密。此基础设施没有此类要求，您应该继续进行分发。
- en: 'The `dockerinaction/ch9_ftp_client` image has an FTP client installed and can
    be used to upload your new image file to your FTP server. Remember, you started
    the FTP server in a container named `ftp-server`. The `ftp-server` container is
    attached to a user-defined bridge network (see [chapter 5](index_split_046.html#filepos458921))
    named `ch9_ftp`, and other containers attached to the `ch9_ftp` network will be
    able to connect to `ftp-server`. Let’s upload the registry image archive with
    an FTP client:'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`dockerinaction/ch9_ftp_client` 镜像中安装了FTP客户端，可以用来将您的新镜像文件上传到FTP服务器。记住，您是在名为
    `ftp-server` 的容器中启动FTP服务器的。`ftp-server` 容器连接到一个用户定义的桥接网络（见[第5章](index_split_046.html#filepos458921)），名为
    `ch9_ftp`，并且连接到 `ch9_ftp` 网络的其他容器将能够连接到 `ftp-server`。让我们使用FTP客户端上传注册表镜像存档：'
- en: '`docker container run --rm -it --network ch9_ftp \     -v "$(pwd)":/data \
        dockerinaction/ch9_ftp_client \     -e ''cd pub/incoming; put registry.2.tar;
    exit'' ftp-server`'
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it --network ch9_ftp \   -v "$(pwd)":/data \   dockerinaction/ch9_ftp_client
    \   -e ''cd pub/incoming; put registry.2.tar; exit'' ftp-server`'
- en: 'This command creates a container with a volume bound to your local directory
    and joined to the `ch9_ftp` network where the FTP server container is listening.
    The command uses LFTP to upload a file named registry.2.tar to the server located
    at `ftp_server`. You can verify that you uploaded the image by listing the contents
    of the FTP server’s folder:'
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令创建了一个与您的本地目录绑定并连接到FTP服务器容器正在监听的 `ch9_ftp` 网络的容器。该命令使用LFTP上传一个名为 registry.2.tar
    的文件到位于 `ftp_server` 的服务器。您可以通过列出FTP服务器文件夹的内容来验证您已上传了镜像：
- en: '`docker run --rm -it --network ch9_ftp \     -v "$(pwd)":/data \     dockerinaction/ch9_ftp_client
    \     -e "cd pub/incoming; ls; exit" ftp-server`'
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm -it --network ch9_ftp \   -v "$(pwd)":/data \   dockerinaction/ch9_ftp_client
    \   -e "cd pub/incoming; ls; exit" ftp-server`'
- en: The registry image is now available for download to any FTP client that knows
    about the server and can access it over the network. But that file may never be
    overridden in the current FTP server configuration. You’d need to come up with
    your own versioning scheme if you were going to use a similar tool in production.
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注册表镜像现在可供任何了解服务器并能通过网络访问它的FTP客户端下载。但在当前的FTP服务器配置中，该文件可能永远不会被覆盖。如果您打算在生产中使用类似的工具，您需要制定自己的版本控制方案。
- en: Advertising the availability of the image in this scenario requires clients
    to periodically poll the server by using the last command you ran to list files.
    Alternatively, you could build a website or send an email notifying clients about
    the image, but that all happens outside the standard FTP transfer workflow.
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在此场景下，广告图像的可用性需要客户端通过使用您运行的最后一个命令来列出文件，定期轮询服务器。或者，您也可以构建一个网站或发送电子邮件通知客户端关于图像的信息，但所有这些都在标准的FTP传输工作流程之外发生。
- en: Before moving on to evaluating this distribution method against the selection
    criteria, consume the registry image from your FTP server to get an idea of how
    clients would need to integrate.
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在评估此分发方法是否符合选择标准之前，从您的FTP服务器消耗注册表镜像，以了解客户端需要如何集成。
- en: 'First, eliminate the registry image from your local image cache and the file
    from your local directory:'
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，从您的本地镜像缓存和本地目录中删除注册表镜像和文件：
- en: '`rm registry.2.tar docker image rm registry:2` `1` `docker image ls registry`
    `2`'
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`rm registry.2.tar docker image rm registry:2` `1` `docker image ls registry`
    `2`'
- en: 1 Need to remove any registry containers first
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 需要先移除任何注册表容器
- en: 2 Confirms the registry image has been removed
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 确认注册表镜像已被移除
- en: 'Then download the image file from your FTP server by using the FTP client:'
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后使用FTP客户端从您的FTP服务器下载镜像文件：
- en: '`docker container run --rm -it --network ch9_ftp \     -v "$(pwd)":/data \
        dockerinaction/ch9_ftp_client \     -e ''cd pub/incoming; get registry.2.tar;
    exit'' ftp-server`'
  id: totrans-841
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it --network ch9_ftp \   -v "$(pwd)":/data \   dockerinaction/ch9_ftp_client
    \   -e ''cd pub/incoming; get registry.2.tar; exit'' ftp-server`'
- en: 'At this point, you should once again have the registry.2.tar file in your local
    directory. You can reload that image into your local cache with the `docker load`
    command:'
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到此为止，您应该再次在本地目录中拥有 registry.2.tar 文件。您可以使用 `docker load` 命令将该镜像重新加载到本地缓存中：
- en: '`docker image load -i registry.2.tar`'
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image load -i registry.2.tar`'
- en: You can confirm that the image has been loaded from the archive by listing images
    for the registry repository again with `docker image ls registry`.
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过再次使用 `docker image ls registry` 列出注册表存储库的镜像来确认镜像已从存档中加载。
- en: This is a minimal example of how a manual image-publishing and distribution
    infrastructure might be built. With a bit of extension, you could build a production-quality,
    FTP-based distribution hub. In its current configuration, this example matches
    against the selection criteria, as shown in [table 9.5](#filepos1026068).
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个手动图像发布和分发基础设施可能构建的最小示例。通过一点扩展，您可以构建一个基于FTP的生产质量分发中心。在其当前配置下，此示例符合所示的选择标准[表9.5](#filepos1026068)。
- en: Table 9.5\. Performance of a sample FTP-based distribution infrastructure
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.5. 基于FTP的样本分发基础设施的性能
- en: '|'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准化
- en: '|'
  id: totrans-849
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-851
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注
- en: '|'
  id: totrans-853
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Good                | This is a low-cost transport.
    All the related software is free. Bandwidth and storage costs should scale linearly
    with the                   number of images hosted and the number of clients.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '| 成本              | 良好              | 这是一个低成本传输。所有相关软件都是免费的。带宽和存储成本应与托管图像的数量和客户端数量的线性比例增长。                        
    |'
- en: '|'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Visibility   | Worst   | The FTP server is running in an unadvertised location
    with a non-standard integration workflow. The visibility of this configuration
                      is very low.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可视性   | 最差   | FTP服务器在一个未宣传的位置运行，具有非标准的集成工作流程。此配置的可视性非常低。                        
    |'
- en: '|'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Bad                | In this example,
    all the transport happens between containers on the same computer, so all the
    commands finish quickly. If                   a client connects to your FTP service
    over the network, speeds are directly impacted by your upload speeds. This distribution'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小              | 差              | 在这个示例中，所有传输都在同一台计算机上的容器之间进行，因此所有命令都很快完成。如果                        
    客户端通过网络连接到您的FTP服务，速度将直接受到您的上传速度的影响。这种分发'
- en: method will download redundant artifacts and won’t download components of the
    image in parallel. Overall, this method isn’t
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 方法将下载冗余的艺术品，并且不会并行下载图像的组件。总体而言，这种方法并不
- en: bandwidth-efficient.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽高效。
- en: '|'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Best   | You can use the FTP server created for this
    example as long as you want.   |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
  zh: '| 长期控制   | 最佳   | 您可以使用为这个示例创建的FTP服务器，只要您想。   |'
- en: '| Availability control                | Best                | You have full
    availability control of the FTP server. If it becomes unavailable, you’re the
    only person who can restore service.             |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '| 可用性控制                      | 最佳                      | 您对FTP服务器拥有完全的可用性控制。如果它变得不可用，您是唯一能够恢复服务的人。                  
    |'
- en: '| Access control   | Worst   | This configuration provides no access control.   |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '| 访问控制   | 最差   | 此配置不提供任何访问控制。   |'
- en: '| Artifact integrity                | Worst                | The network transportation
    layer does provide file integrity between endpoints. But it’s susceptible to interception
    attacks,                   and no integrity protections exist between file creation
    and upload or between download and import.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '| 艺术品完整性                      | 最差                      | 网络传输层确实在端点之间提供了文件完整性。但它容易受到拦截攻击，                        
    并且在文件创建和上传之间或下载和导入之间不存在完整性保护。'
- en: '|'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Confidentiality   | Worst   | This configuration provides no secrecy.   |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '| 机密性   | 最差   | 此配置不提供任何保密性。   |'
- en: '| Requisite experience                | Good                | All requisite
    experience for implementing this solution has been provided here. If you’re interested
    in extending the example                   for production, you need to familiarize
    yourself with vsftpd configuration options and SFTP.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '| 必要经验                      | 良好                      | 实施此解决方案所需的全部经验都已在此提供。如果您有兴趣将示例                        
    扩展到生产环境，您需要熟悉vsftpd配置选项和SFTP。'
- en: '|'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In short, there’s almost no real scenario where this transport configuration
    is appropriate. But it helps illustrate the different concerns and basic workflows
    that you can create when you work with image as files. Try to imagine how replacing
    FTP with `scp` or `rsync` tooling using the SSH protocol would improve the system’s
    performance for artifact integrity and secrecy. The final image distribution method
    we will consider distributes image sources and is both more flexible and potentially
    complicated.
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简而言之，几乎没有任何实际场景适合这种传输配置。但它有助于说明当您将图像作为文件工作时可以创建的不同关注点和基本工作流程。试着想象一下，用`scp`或`rsync`工具替换FTP，并使用SSH协议，将如何提高系统在艺术品完整性和保密性方面的性能。我们将考虑的最后一种图像分发方法既更灵活，也可能更复杂。
- en: 9.5\. IMAGE SOURCE-DISTRIBUTION WORKFLOWS
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.5. 图像源-分发工作流程
- en: When you distribute image sources instead of images, you cut out all the Docker
    distribution workflow and rely solely on the Docker image builder. As with manual
    image publishing and distribution, source-distribution workflows should be evaluated
    against the selection criteria in the context of a particular implementation.
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您分发图像源而不是图像时，您将省去所有的Docker分发工作流程，并完全依赖Docker镜像构建器。与手动图像发布和分发一样，源分发工作流程应针对特定实现的上下文中的选择标准进行评估。
- en: Using a hosted source control system such as Git on GitHub will have very different
    traits from using a file backup tool such as `rsync`. In a way, source-distribution
    workflows have a superset of the concerns of manual image publishing and distribution
    workflows. You’ll have to build your workflow, but without the help of the `docker
    save`, `load`, `export`, or `import` commands. Producers need to determine how
    they will package their sources, and consumers need to understand how those sources
    are packaged as well as how to build an image from them. That expanded interface
    makes source-distribution workflows the most flexible and potentially complicated
    distribution method. [Figure 9.8](#filepos1041132) shows image source distribution
    on the most complicated end of the spectrum.
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用GitHub上的Git等托管源代码控制系统与使用`rsync`等文件备份工具非常不同。从某种意义上说，源分发工作流程包含了手动图像发布和分发工作流程的所有关注点。您将不得不构建自己的工作流程，但无需`docker
    save`、`load`、`export`或`import`命令的帮助。生产者需要确定他们将如何打包他们的源，消费者也需要了解这些源是如何打包的，以及如何从它们构建镜像。这种扩展的接口使得源分发工作流程成为最灵活且可能最复杂的一种分发方法。[图9.8](#filepos1041132)展示了在复杂度光谱的最复杂端上的图像源分发。
- en: Figure 9.8\. Using existing infrastructure to distribute image sources
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图9.8\. 利用现有基础设施分发图像源
- en: '![](images/00078.jpg)'
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00078.jpg)'
- en: Image source distribution is one of the most common methods, despite having
    the most potential for complication. Popular version-control software handles
    many of the complications of source distribution’s expanded interface.
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像源分发是最常见的方法之一，尽管它具有最大的复杂性潜力。流行的版本控制软件处理了源分发扩展接口的许多复杂性。
- en: 9.5.1\. Distributing a project with Dockerfile on GitHub
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.5.1\. 在GitHub上使用Dockerfile分发项目
- en: When you use Dockerfile and GitHub to distribute image sources, image consumers
    clone your GitHub repository directly and use `docker image build` to build your
    image locally. With source distribution, publishers don’t need an account on Docker
    Hub or another Docker registry to publish an image.
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您使用Dockerfile和GitHub分发图像源时，图像消费者会直接克隆您的GitHub仓库，并使用`docker image build`在本地构建您的镜像。在源分发中，发布者不需要在Docker
    Hub或另一个Docker注册表中拥有账户来发布镜像。
- en: 'Supposing a producer has an existing project, Dockerfile, and GitHub repository,
    their distribution workflow will look like this:'
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设生产者有一个现有的项目、Dockerfile和GitHub仓库，他们的分发工作流程将如下所示：
- en: '`git init git config --global user.email "you@example.com" git config --global
    user.name "Your Name" git add Dockerfile # git add *whatever other files you need
    for the image* git commit -m "first commit" git remote add origin https://github.com/<your
    username>/<your repo>.git git push -u origin master`'
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`git init git config --global user.email "you@example.com" git config --global
    user.name "Your Name" git add Dockerfile # git add * whatever other files you
    need for the image* git commit -m "first commit" git remote add origin https://github.com/<your
    username>/<your repo>.git git push -u origin master`'
- en: 'Meanwhile, a consumer would use a general command set that looks like this:'
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同时，消费者会使用一个类似以下的通用命令集：
- en: '`git clone https://github.com/<your username>/<your repo>.git cd <your-repo>
    docker image build -t <your username>/<your repo>. .`'
  id: totrans-882
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/<your username>/<your repo>.git cd <your-repo>
    docker image build -t <your username>/<your repo>. .`'
- en: These are all steps that a regular Git or GitHub user is familiar with, as shown
    in [table 9.6](#filepos1044086).
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些都是普通Git或GitHub用户熟悉的步骤，如[表9.6](#filepos1044086)所示。
- en: Table 9.6\. Performance of image source distribution via GitHub
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表9.6\. 通过GitHub进行图像源分发的性能
- en: '|'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Criteria
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标准
- en: '|'
  id: totrans-887
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Rating
  id: totrans-888
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评分
- en: '|'
  id: totrans-889
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Notes
  id: totrans-890
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注
- en: '|'
  id: totrans-891
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cost                | Best                | There’s no cost if you’re using
    a public GitHub repository.             |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '| 成本              | 最佳              | 如果您使用的是公共GitHub仓库，则没有成本。           |'
- en: '| Visibility   | Best   | GitHub is a highly visible location for open source
    tools. It provides excellent social and search components, making project                  
    discovery simple.'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '| 可见性   | 最佳   | GitHub是开源工具的高可见位置。它提供了优秀的社会和搜索组件，使得项目发现变得简单。'
- en: '|'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Transport speed/size                | Good                | By distributing
    image sources, you can leverage other registries for base layers. Doing so will
    reduce the transportation                   and storage burden. GitHub also provides
    a content delivery network (CDN). That CDN is used to make sure clients around
    the'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传输速度/大小              | 良好              | 通过分发镜像源，你可以利用其他注册表进行基础层的分发。这样做将减少传输和存储负担。GitHub
    还提供了内容分发网络（CDN）。该 CDN 用于确保全球各地的客户端'
- en: world can access projects on GitHub with low network latency.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地都可以以低网络延迟访问 GitHub 上的项目。
- en: '|'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Longevity control   | Bad   | Although Git is a popular tool and should be
    around for a while, you forgo any longevity control by integrating with GitHub
                      or other hosted version-control providers.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '| 长期控制   | 差   | 虽然 Git 是一个流行的工具，并且可能会存在一段时间，但通过集成 GitHub 或其他托管版本控制提供商，你放弃了任何长期控制。'
- en: '|'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Availability control                | Worst                | Relying on GitHub
    or other hosted version-control providers eliminates any availability control.
                |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '| 可用性控制              | 最差              | 依赖于 GitHub 或其他托管版本控制提供商消除了任何可用性控制。  
    |'
- en: '| Access control   | Good   | GitHub or other hosted version-control providers
    do provide access control-tools for private repositories.   |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '| 访问控制   | 良好   | GitHub 或其他托管版本控制提供商确实为私有仓库提供了访问控制工具。   |'
- en: '| Artifact integrity                | Good                | This solution provides
    no integrity for the images produced as part of the build process, or of the sources
    after they have                   been cloned to the client machine. But integrity
    is the whole point of version-control systems. Any integrity problems should'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '| 艺术品完整性              | 良好              | 此解决方案不提供构建过程中产生的镜像或克隆到客户端机器后的源代码的完整性。但完整性是版本控制系统的主要目的。任何完整性问题都应该'
- en: be apparent and easily recoverable through standard Git processes.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标准的 Git 流程，可以明显且容易地恢复。
- en: '|'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Confidentiality   | Worst   | Public projects provide no source secrecy.   |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '| 机密性   | 最差   | 公共项目不提供源代码保密性。   |'
- en: '| Requisite Experience                | Good                | Image producers
    and consumers need to be familiar with Dockerfile, the Docker builder, and the
    Git tooling.             |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| 必要经验   | 良好   | 镜像生产者和消费者需要熟悉 Dockerfile、Docker 构建器和 Git 工具。   |'
- en: Image source distribution is divorced from all Docker distribution tools. By
    relying only on the image builder, you’re free to adopt any distribution toolset
    available. If you’re locked into a particular toolset for distribution or source
    control, this may be the only option that meets your criteria.
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像源分发与所有 Docker 分发工具分离。通过仅依赖镜像构建器，你可以自由地采用任何可用的分发工具集。如果你被锁定在特定的工具集用于分发或源代码控制，这可能就是唯一符合你标准的选项。
- en: SUMMARY
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covers various software distribution mechanisms and the value
    contributed by Docker in each. A reader that has recently implemented a distribution
    channel, or is currently doing so, might take away additional insights into their
    solution. Others will learn more about available choices. In either case, it is
    important to make sure that you have gained the following insights before moving
    on:'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖了各种软件分发机制以及 Docker 在每个机制中的价值。对于最近实施或正在实施分发渠道的读者，可能会从他们的解决方案中获得额外的见解。其他人将了解更多关于可用的选择。在任何情况下，确保在继续之前你已经获得了以下见解是很重要的：
- en: Having a spectrum of choices illustrates your range of options.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一系列的选择可以展示你的选项范围。
- en: You should use a consistent set of selection criteria in order to evaluate your
    distribution options and determine which method you should use.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用一套一致的选择标准来评估你的分发选项，并确定你应该使用哪种方法。
- en: Hosted public repositories provide excellent project visibility, are free, and
    require little experience to adopt.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管公共仓库提供了优秀的项目可见性，免费，并且采用起来经验要求不高。
- en: Consumers will have a higher degree of trust in images generated by automated
    builds because a trusted third party builds them.
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于由受信任的第三方构建，消费者将更加信任由自动化构建生成的镜像。
- en: Hosted private repositories are cost-effective for small teams and provide satisfactory
    access control.
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管私有仓库对于小型团队来说是经济高效的，并且提供了令人满意的访问控制。
- en: Running your own registry enables you to build infrastructure suitable for special
    use cases without abandoning the Docker distribution facilities.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行自己的注册表使您能够构建适合特殊用例的基础设施，而无需放弃Docker分发设施。
- en: Distributing images as files can be accomplished with any file-sharing system.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何文件共享系统都可以分发图像作为文件。
- en: Image source distribution is flexible but only as complicated as you make it.
    Using popular source-distribution tools and patterns will keep things simple.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像源分发是灵活的，但复杂程度仅取决于您如何设置。使用流行的源分发工具和模式将使事情保持简单。
- en: Chapter 10\. Image pipelines
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第10章\. 图像管道
- en: This chapter covers
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The goals of Docker image pipelines
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker图像管道的目标
- en: Patterns for building images and using metadata to help consumers use your image
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建图像和使用元数据帮助消费者使用您的图像的图案
- en: Common approaches for testing that images are configured correctly and secure
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试图像是否正确配置和安全的常见方法
- en: Patterns for tagging images so they can be identified and delivered to consumers
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图像打标签的图案，以便它们可以被识别并交付给消费者
- en: Patterns for publishing images to runtime environments and registries
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像发布到运行时环境和注册表的图案
- en: In [chapter 8](index_split_069.html#filepos755104), you learned how to build
    Docker images automatically by using Dockerfiles and the `docker build` command.
    However, building the image is merely one critical step in a longer process for
    delivering functioning and trustworthy images. Image publishers should perform
    tests to verify that the image works under the expected operating conditions.
    Confidence in the correctness of the image artifact grows as it passes those tests.
    Next, it can finally be tagged and published to a registry for consumption. Consumers
    can deploy these images with confidence, knowing that many important requirements
    have already been verified.
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[第8章](index_split_069.html#filepos755104)中，您学习了如何通过使用Dockerfile和`docker build`命令自动构建Docker镜像。然而，构建图像仅仅是交付功能性和可信图像的更长过程中的一个关键步骤。图像发布者应执行测试以验证图像在预期的操作条件下是否正常工作。随着通过这些测试，对图像工件正确性的信心逐渐增强。接下来，它最终可以被标记并发布到注册表以供消费。消费者可以自信地部署这些图像，因为他们知道许多重要要求已经得到验证。
- en: These steps—preparing image material, building an image, testing, and finally
    publishing images to registries—are together called an image build pipeline. Pipelines
    help software authors quickly publish updates and efficiently deliver new features
    and fixes to consumers.
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些步骤——准备图像材料、构建图像、测试，最后将图像发布到注册表——统称为图像构建管道。管道帮助软件作者快速发布更新，并有效地将新功能和修复传递给消费者。
- en: 10.1\. GOALS OF AN IMAGE BUILD PIPELINE
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.1\. 图像构建管道的目标
- en: In this context, pipelines automate the process for building, testing, and publishing
    artifacts so they can be deployed to a runtime environment. [Figure 10.1](#filepos1062023)
    illustrates the high-level process for building software or other artifacts in
    a pipeline. This process should be familiar to anyone using continuous integration
    (CI) practices and is not specific to Docker images.
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个背景下，管道自动化了构建、测试和发布工件的过程，以便它们可以被部署到运行时环境。图10.1 [图10.1](#filepos1062023) 展示了在管道中构建软件或其他工件的高级过程。这个过程对于使用持续集成（CI）实践的人来说应该是熟悉的，并且并不特定于Docker镜像。
- en: Figure 10.1\. Generic artifact build pipeline
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.1\. 通用工件构建管道
- en: '![](images/00023.jpg)'
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00023.jpg)'
- en: People often automate build pipelines with continuous integration systems such
    as Jenkins, Travis CI, or Drone. Regardless of the specific pipeline-modeling
    technology, the goal of a build pipeline is to apply a consistent set of rigorous
    practices in creating deployable artifacts from source definitions. Differences
    between the specific tools employed in a pipeline are simply an implementation
    detail. A CI process for a Docker image is similar to other software artifacts
    and looks like [figure 10.2](#filepos1063054).
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 人们经常使用Jenkins、Travis CI或Drone等持续集成系统来自动化构建管道。无论具体的管道建模技术如何，构建管道的目标都是从源定义中创建可部署工件时应用一套一致且严格的实践。管道中使用的特定工具之间的差异仅仅是实现细节。Docker镜像的CI过程与其他软件工件类似，看起来像[图10.2](#filepos1063054)。
- en: Figure 10.2\. A Docker image build pipeline
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.2\. Docker图像构建管道
- en: '![](images/00031.jpg)'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00031.jpg)'
- en: 'When building a Docker image, this process includes the following steps:'
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当构建Docker镜像时，这个过程包括以下步骤：
- en: Check out a clean copy of the source code defining the image and build scripts
    so the origin and process used to build the image is known.
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出定义图像和构建脚本的源代码的干净副本，以便了解构建图像的来源和过程。
- en: 2 Retrieve or generate artifacts that will be included in the image, such as
    the application package and runtime libraries.
  id: totrans-936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 检索或生成将包含在镜像中的工件，例如应用程序包和运行时库。
- en: Build the image by using a Dockerfile.
  id: totrans-937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建镜像。
- en: Verify that the image is structured and functions as intended.
  id: totrans-938
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证镜像的结构和功能是否符合预期。
- en: (Optional) Verify that the image does not contain known vulnerabilities.
  id: totrans-939
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (可选) 验证镜像不包含已知漏洞。
- en: Tag the image so that it can be consumed easily.
  id: totrans-940
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为镜像打标签，以便它可以轻松被消费。
- en: Publish the image to a registry or another distribution channel.
  id: totrans-941
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像发布到注册表或其他分发渠道。
- en: Application artifacts are the runtime scripts, binaries (.exe, .tgz, .zip),
    and configuration files produced by software authors. This image build process
    assumes the application artifacts have already been built, tested, and published
    to an artifact repository for inclusion in an image. The application artifact
    may be built inside a container, and this is how many modern CI systems operate.
    The exercises in this chapter will show how to build applications by using containers
    and how to package those application artifacts into a Docker image that runs the
    application. We will implement the build process by using a small and common set
    of tools available in UNIX-like environments. This pipeline’s concepts and basic
    commands should be easily transferrable into your organization’s own tooling.
  id: totrans-942
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序工件是软件作者生成的运行时脚本、二进制文件 (.exe, .tgz, .zip) 和配置文件。此镜像构建过程假定应用程序工件已经构建、测试并发布到工件存储库，以便包含在镜像中。应用程序工件可以在容器内构建，这正是许多现代CI系统的工作方式。本章的练习将展示如何使用容器构建应用程序，以及如何将这些应用程序工件打包到运行应用程序的Docker镜像中。我们将通过使用UNIX-like环境中可用的小型且常见的工具集来实现构建过程。此管道的概念和基本命令应很容易转移到您组织的工具中。
- en: 10.2\. PATTERNS FOR BUILDING IMAGES
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2\. 构建镜像的模式
- en: 'Several patterns exist for building applications and images using containers.
    We will discuss three of the most popular patterns here:'
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 存在多种使用容器构建应用程序和镜像的模式。在这里，我们将讨论三种最受欢迎的模式：
- en: All-in-One—  You use an all-in-one image to build and run the application.
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全功能——您使用全功能镜像来构建和运行应用程序。
- en: Build Plus Runtime—  You use a build image with a separate, slimmer runtime
    image to build a containerized application.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建加运行时——您使用一个带有单独、更精简的运行时镜像的构建镜像来构建容器化应用程序。
- en: Build Plus Multiple Runtimes—  You use a slim runtime image with variations
    for debugging and other supplemental use cases in a multi-stage build.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建加多个运行时——您在多阶段构建中使用具有用于调试和其他补充用例的变体的精简运行时镜像。
- en: Figure 10.3\. Image build pattern maturity
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.3\. 镜像构建模式成熟度
- en: '![](images/00056.jpg)'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00056.jpg)'
- en: Multiple build patterns have evolved to produce images appropriate for particular
    consumption use cases. In this context, maturity refers to the design and process
    used to build the image, not the organization applying the pattern. When an image
    will be used for internal experimentation or as a portable development environment,
    the All-in-One pattern might be most appropriate. By contrast, when distributing
    a server that will be licensed and supported commercially, the Build Plus Runtime
    pattern will probably be most appropriate. A single software publishing organization
    will often use multiple patterns for building images that they use and distribute.
    Apply and modify the patterns described here to solve your own image build and
    delivery problems.
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多种构建模式已经演变，以产生适合特定消费用例的镜像。在此上下文中，“成熟度”指的是构建镜像的设计和过程，而不是应用该模式的组织。当镜像将用于内部实验或作为便携式开发环境时，全功能模式可能最为合适。相比之下，当分发将获得商业许可和支持的服务器时，构建加运行时模式可能最为合适。单个软件发布组织通常会使用多种模式来构建他们使用和分发的镜像。应用并修改此处描述的模式来解决您自己的镜像构建和交付问题。
- en: 10.2.1\. All-in-one images
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2.1\. 全功能镜像
- en: All-in-one images include all the tools required to build and run an application.
    These tools might include software development kits (SDKs), package managers,
    shared libraries, language-specific build tooling, or other binary tools. This
    type of image will also commonly include default application runtime configuration.
    All-in-one images are the simplest way to get started containerizing an application.
    They are especially useful when containerizing a development environment or “legacy”
    application that has many dependencies.
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一体化镜像包括构建和运行应用程序所需的所有工具。这些工具可能包括软件开发工具包（SDKs）、包管理器、共享库、特定语言的构建工具或其他二进制工具。此类镜像通常还会包含默认的应用程序运行时配置。一体化镜像是开始容器化应用程序的最简单方法。当容器化具有许多依赖项的开发环境或“遗留”应用程序时，它们特别有用。
- en: 'Let’s use the All-in-One pattern to build a simple Java web server using the
    popular Spring Boot framework. Here is an all-in-one Dockerfile that builds the
    application into an image along with the build tools:'
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们使用一体化模式，使用流行的Spring Boot框架构建一个简单的Java网络服务器。以下是一个一体化Dockerfile，它将应用程序构建到镜像中，并包含构建工具：
- en: '`FROM maven:3.6-jdk-11  ENV WORKDIR=/project RUN mkdir -p ${WORKDIR} COPY .
    ${WORKDIR} WORKDIR ${WORKDIR} RUN mvn -f pom.xml clean verify RUN cp ${WORKDIR}/target/ch10-0.1.0.jar
    /app.jar  ENTRYPOINT ["java","-jar","/app.jar"]`'
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM maven:3.6-jdk-11  ENV WORKDIR=/project RUN mkdir -p ${WORKDIR} COPY .
    ${WORKDIR} WORKDIR ${WORKDIR} RUN mvn -f pom.xml clean verify RUN cp ${WORKDIR}/target/ch10-0.1.0.jar
    /app.jar  ENTRYPOINT ["java","-jar","/app.jar"]`'
- en: 'Clone the [https://github.com/dockerinaction/ch10_patterns-for-building-images.git](https://github.com/dockerinaction/ch10_patterns-for-building-images.git)
    repo and build the project as follows:'
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 克隆[https://github.com/dockerinaction/ch10_patterns-for-building-images.git](https://github.com/dockerinaction/ch10_patterns-for-building-images.git)仓库，并按以下方式构建项目：
- en: '`docker image build -t dockerinaction/ch10:all-in-one \     --file all-in-one.df
    .`'
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch10:all-in-one \    --file all-in-one.df
    .`'
- en: In this Dockerfile, the source image is the community Maven 3.6 image, which
    also includes OpenJDK 11\. The Dockerfile builds a simple Java web server, and
    the application artifact is added to the image. The image definition finishes
    with an `ENTRYPOINT` that runs the service by invoking `java` with the application
    artifact built in the image. This is about the simplest thing that could possibly
    work and a great approach for demonstrating, “Look, we can containerize our application!”
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个Dockerfile中，源镜像是社区Maven 3.6镜像，它还包括OpenJDK 11。Dockerfile构建了一个简单的Java网络服务器，并将应用程序工件添加到镜像中。镜像定义以一个`ENTRYPOINT`结束，通过在镜像中构建的应用程序工件调用`java`来运行服务。这是可能的最简单的事情，也是展示“看，我们可以容器化我们的应用程序！”的一个很好的方法。
- en: All-in-one images have downsides. Because they contain more tools than are necessary
    to run the application, attackers have more options to exploit an application,
    and images may need to update more frequently to accommodate change from a broad
    set of development and operational requirements. In addition, all-in-one images
    will be large, often 500 MB or more. The `maven:3.6-jdk-11` base image used in
    the example is 614 MB to start with, and the final image is 708 MB. Large images
    put more stress on image distribution mechanisms, though this problem is relatively
    innocuous until you get to large-scale or very frequent releases.
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一体化镜像有其缺点。因为它们包含运行应用程序所需工具之外的工具，攻击者有更多选择来利用应用程序，并且镜像可能需要更频繁地更新以适应广泛的开发和运营需求。此外，一体化镜像通常很大，通常为500
    MB或更多。示例中使用的`maven:3.6-jdk-11`基础镜像起始大小为614 MB，最终镜像大小为708 MB。大镜像对镜像分发机制施加了更多压力，尽管这个问题在达到大规模或非常频繁的发布之前相对无害。
- en: This approach is good for creating a portable application image or development
    environment with little effort. The next pattern will show how to improve many
    characteristics of the runtime image by separating application build and runtime
    concerns.
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法适用于创建便携式应用程序镜像或开发环境，而无需付出太多努力。下一个模式将展示如何通过分离应用程序构建和运行时关注点来改进运行时镜像的许多特性。
- en: 10.2.2\. Separate build and runtime images
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2.2. 分离构建和运行时镜像
- en: The All-in-One pattern can be improved by creating separate build and runtime
    images. Specifically, in this approach, all of the application build and test
    tooling will be included in one image, and the other will contain only what the
    application requires at runtime.
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过创建单独的构建和运行时镜像，可以改进一体化模式。具体来说，在这种方法中，所有应用程序构建和测试工具都将包含在一个镜像中，另一个镜像将只包含应用程序在运行时所需的内容。
- en: 'You can build the application with a Maven container:'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用Maven容器构建应用程序：
- en: '`docker container run -it --rm \   -v "$(pwd)":/project/ \   -w /project/ \
      maven:3.6-jdk-11 \   mvn clean verify`'
  id: totrans-963
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -it --rm \    -v "$(pwd)":/project/ \    -w /project/
    \    maven:3.6-jdk-11 \    mvn clean verify`'
- en: 'Maven compiles and packages the application artifact into the project’s `target`
    directory:'
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Maven将应用程序工件编译并打包到项目的`target`目录中：
- en: '`$ ls -la target/ch10-0.1.0.jar -rw-r--r--  1 user  group  16142344 Jul  2
    15:17 target/ch10-0.1.0.jar`'
  id: totrans-965
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ ls -la target/ch10-0.1.0.jar -rw-r--r-- 1 user group 16142344 Jul 2 15:17
    target/ch10-0.1.0.jar`'
- en: 'In this approach, the application is built using a container created from the
    public Maven image. The application artifact is output to the host filesystem
    via the volume mount instead of storing it in the build image as in the All-in-One
    pattern. The runtime image is created using a simple Dockerfile that `COPY`s the
    application artifact into an image based on OpenJDK 10:'
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种方法中，应用程序使用从公共Maven镜像创建的容器构建。应用程序工件通过卷挂载输出到主机文件系统，而不是像在全部包含模式中那样存储在构建图像中。运行时图像使用一个简单的Dockerfile创建，该Dockerfile将应用程序工件`COPY`到基于OpenJDK
    10的图像中：
- en: '`FROM openjdk:11-jdk-slim  COPY target/ch10-0.1.0.jar /app.jar  ENTRYPOINT
    ["java","-jar","/app.jar"]`'
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM openjdk:11-jdk-slim COPY target/ch10-0.1.0.jar /app.jar ENTRYPOINT ["java","-jar","/app.jar"]`'
- en: 'Build the runtime image:'
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建运行时图像：
- en: '`docker image build -t dockerinaction/ch10:simple-runtime \     --file simple-runtime.df
    .`'
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch10:simple-runtime \    --file simple-runtime.df
    .`'
- en: 'Now run the web server image:'
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在运行Web服务器镜像：
- en: '`docker container run --rm -it -p 8080:8080 dockerinaction/ch10:simple-runtime`'
  id: totrans-971
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it -p 8080:8080 dockerinaction/ch10:simple-runtime`'
- en: The application runs just as it did in the previous all-in-one example. With
    this approach, the build-specific tools such as Maven and intermediate artifacts
    are no longer included in the runtime image. The runtime image is now much smaller
    (401 MB versus 708 MB!) and has a smaller attack surface.
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序运行得就像在先前的全部包含示例中一样。采用这种方法，构建特定的工具如Maven和中间件件不再包含在运行时图像中。运行时图像现在要小得多（401
    MB与708 MB相比！）并且攻击面更小。
- en: This pattern is now supported and encouraged by many CI tools. The support usually
    comes in the ability to specify a Docker image to use as a hygienic execution
    environment for a step or the ability to run containerized build agents and assign
    steps to them.
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种模式现在得到了许多持续集成工具的支持和鼓励。支持通常体现在能够指定一个Docker镜像作为步骤的卫生执行环境，或者能够运行容器化构建代理并将步骤分配给它们。
- en: 10.2.3\. Variations of runtime image via multi-stage builds
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2.3. 通过多阶段构建的运行时图像变体
- en: As your build and operational experience matures, you may find it useful to
    create small variations of an application image to support use cases such as debugging,
    specialized testing, or profiling. These use cases often require adding specialized
    tools or changing the application’s image. Multi-stage builds can be used to keep
    the specialized image synchronized with the application image and avoid duplication
    of image definitions. In this section, we will focus on the Build Plus Multiple
    Runtimes pattern of creating specialized images by using the multi-stage features
    of the `FROM` instruction introduced in [chapter 8](index_split_069.html#filepos755104).
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随着你的构建和运营经验的成熟，你可能发现创建应用程序图像的小变体来支持调试、专用测试或性能分析等用例是有用的。这些用例通常需要添加专用工具或更改应用程序的图像。多阶段构建可以用来保持专用图像与应用程序图像同步，避免图像定义的重复。在本节中，我们将重点关注通过使用第8章中引入的`FROM`指令的多阶段功能来创建专用图像的“构建加多个运行时”模式。
- en: Let’s build a debug variation of our `app-image` based on our application image.
    The hierarchy will look like [figure 10.4](#filepos1078424).
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们基于我们的应用程序图像构建一个`app-image`的调试变体。层次结构将看起来像[图10.4](#filepos1078424)。
- en: Figure 10.4\. Image hierarchy for multi-stage build example
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.4. 多阶段构建示例的图像层次结构
- en: '![](images/00076.jpg)'
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00076.jpg)'
- en: 'The multi-stage-runtime.df in the chapter’s example repository implements this
    hierarchy:'
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章示例仓库中的multi-stage-runtime.df实现了这个层次结构：
- en: '`# The app-image build target defines the application image FROM openjdk:11-jdk-slim
    as app-image` `1` `ARG BUILD_ID=unknown ARG BUILD_DATE=unknown ARG VCS_REF=unknown  LABEL
    org.label-schema.version="${BUILD_ID}" \       org.label-schema.build-date="${BUILD_DATE}"
    \       org.label-schema.vcs-ref="${VCS_REF}" \        org.label-schema.name="ch10"
    \       org.label-schema.schema-version="1.0rc1"  COPY multi-stage-runtime.df
    /Dockerfile  COPY target/ch10-0.1.0.jar /app.jar  ENTRYPOINT ["java","-jar","/app.jar"]  FROM
    app-image as app-image-debug` `2` `#COPY needed debugging tools into image ENTRYPOINT
    ["sh"]  FROM app-image as default` `3`'
  id: totrans-980
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# app-image 构建目标定义了应用程序镜像 FROM openjdk:11-jdk-slim as app-image` `1` `ARG
    BUILD_ID=unknown ARG BUILD_DATE=unknown ARG VCS_REF=unknown  LABEL org.label-schema.version="${BUILD_ID}"
    \    org.label-schema.build-date="${BUILD_DATE}" \    org.label-schema.vcs-ref="${VCS_REF}"
    \    org.label-schema.name="ch10" \    org.label-schema.schema-version="1.0rc1"  COPY
    multi-stage-runtime.df /Dockerfile  COPY target/ch10-0.1.0.jar /app.jar  ENTRYPOINT
    ["java","-jar","/app.jar"]  FROM app-image as app-image-debug` `2` `# 将所需的调试工具复制到镜像中
    ENTRYPOINT ["sh"]  FROM app-image as default` `3`'
- en: 1 app-image build stage starts from openjdk.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 app-image 构建阶段从 openjdk 开始。
- en: 2 app-image-debug stage inherits and adds to the app-image.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 app-image-debug 阶段继承并添加到 app-image。
- en: 3 default stage ensures app-image is produced by default.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 默认阶段确保默认生成 app-image。
- en: The build stage of the main application image is declared as starting from `openjdk:11-jdk-slim`
    and named `app-image:`
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 主应用程序图像的构建阶段声明为从 `openjdk:11-jdk-slim` 开始，并命名为 `app-image:`
- en: '`# The app-image build target defines the application image FROM openjdk:11-jdk-slim
    as app-image …`'
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# app-image 构建目标定义了应用程序镜像 FROM openjdk:11-jdk-slim as app-image …`'
- en: Naming a build stage serves two important purposes. First, the stage name enables
    other build stages within the Dockerfile to use another stage easily. Second,
    build processes can build a stage by specifying that name as a build target. Build
    stage names are localized to the context of a Dockerfile and do not affect image
    tagging.
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名构建阶段有两个重要的目的。首先，阶段名称使 Dockerfile 中的其他构建阶段可以轻松使用另一个阶段。其次，可以通过指定该名称作为构建目标来构建阶段。构建阶段名称仅限于
    Dockerfile 的上下文，不会影响镜像标记。
- en: 'Let’s define a variation of the application image by adding a build stage to
    the Dockerfile that supports debugging:'
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们通过在 Dockerfile 中添加一个支持调试的构建阶段来定义应用程序图像的一个变体：
- en: '`FROM app-image as app-image-debug` `1` `#COPY needed debugging tools into
    image ENTRYPOINT ["sh"]`'
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM app-image as app-image-debug` `1` `# 将所需的调试工具复制到镜像中 ENTRYPOINT ["sh"]`'
- en: 1 Uses app-image as the base for the debug image
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用 app-image 作为调试镜像的基础
- en: The debug application image definition specifies `app-image` as its base image
    and demonstrates making minor changes. In this case, the only change is to reconfigure
    the image’s entrypoint to be a shell instead of running the application. The debug
    image is otherwise identical to the main application image.
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调试应用程序图像定义指定 `app-image` 作为其基础镜像，并展示了进行少量更改。在这种情况下，唯一的更改是将镜像的入口点重新配置为 shell
    而不是运行应用程序。调试镜像在其他方面与主应用程序镜像相同。
- en: 'The `docker image build` command produces a single image regardless of how
    many stages are defined in the Dockerfile. You can use the build command’s `--target`
    option to select the stage to build the image. When you define multiple build
    stages in a Dockerfile, it is best to be explicit about what image you want to
    build. To build the debug image, invoke `docker build` and target the `app-image-debug`
    stage:'
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build` 命令无论 Dockerfile 中定义了多少阶段，都只生成一个镜像。您可以使用构建命令的 `--target`
    选项来选择构建镜像的阶段。当您在 Dockerfile 中定义多个构建阶段时，最好明确您想要构建的镜像。要构建调试镜像，请调用 `docker build`
    并指定 `app-image-debug` 阶段：'
- en: '`docker image build -t dockerinaction/ch10:multi-stage-runtime-debug \    
    -f multi-stage-runtime.df \     --target=app-image-debug .`'
  id: totrans-992
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image build -t dockerinaction/ch10:multi-stage-runtime-debug \    -f
    multi-stage-runtime.df \    --target=app-image-debug .`'
- en: The build process will execute the `app-image-debug` stage as well as the `app-image`
    stage it depends on to produce the debug image.
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建过程将执行 `app-image-debug` 阶段以及它所依赖的 `app-image` 阶段以生成调试镜像。
- en: 'Note that when you build an image from a Dockerfile that defines multiple stages
    and do not specify a build target, Docker will build an image from the last stage
    defined in the Dockerfile. You can build an image for the main build stage defined
    in your Dockerfile by adding a trivial build stage at the end of the Dockerfile:'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，当您从定义了多个阶段的 Dockerfile 构建镜像且未指定构建目标时，Docker 将从 Dockerfile 中定义的最后一个阶段构建镜像。您可以通过在
    Dockerfile 的末尾添加一个微不足道的构建阶段来构建 Dockerfile 中定义的主构建阶段的镜像：
- en: '`# Ensure app-image is the default image built with this Dockerfile FROM app-image
    as default`'
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 确保app-image是使用此Dockerfile构建的默认镜像 FROM app-image as default`'
- en: This `FROM` statement defines a new build stage named `default` that is based
    on `app-image`. The `default` stage makes no additions to the last layer produced
    by `app-image` and is thus identical.
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个`FROM`语句定义了一个名为`default`的新构建阶段，它基于`app-image`。`default`阶段不对`app-image`产生的最后一层添加任何内容，因此是相同的。
- en: Now that we have covered several patterns for producing an image or family of
    closely related images, let’s discuss what metadata we should capture along with
    our images to facilitate delivery and operational processes.
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了几种生成镜像或一系列密切相关镜像的模式，让我们来讨论我们应该捕获哪些元数据与我们的镜像一起，以方便交付和操作流程。
- en: 10.3\. RECORD METADATA AT IMAGE BUILD TIME
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3\. 在镜像构建时记录元数据
- en: 'As described in [chapter 8](index_split_069.html#filepos755104), images can
    be annotated with metadata that is useful to consumers and operators via the `LABEL`
    instruction. You should use labels to capture at least the following data in your
    images:'
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如[第8章](index_split_069.html#filepos755104)所述，可以通过`LABEL`指令对镜像进行标注，以便消费者和操作员使用。你应该使用标签来捕获你的镜像中至少以下数据：
- en: Application name
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序名称
- en: Application version
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序版本
- en: Build date and time
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建日期和时间
- en: Version-control commit identifier
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制系统提交标识符
- en: In addition to image labels, consider adding the Dockerfile used to build the
    image and software package manifests to the image filesystem.
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了镜像标签外，还应考虑将用于构建镜像的Dockerfile和软件包清单添加到镜像文件系统中。
- en: All this information is highly valuable when orchestrating deployments and debugging
    problems. Orchestrators can provide traceability by logging metadata to audit
    logs. Deployment tools can visualize the composition of a service deployment using
    the build time or version-control system (VCS) commit identifier. Including the
    source Dockerfile in the image can be a quick reference for people debugging a
    problem to navigate within a container. Orchestrators and security tools may find
    other metadata describing the image’s architectural role or security profile useful
    in deciding where the container should run or what it is permitted to do.
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有这些信息在编排部署和调试问题时非常有价值。编排器可以通过将元数据记录到审计日志中提供可追溯性。部署工具可以使用构建时间或版本控制系统（VCS）提交标识符来可视化服务部署的组成。在镜像中包含源Dockerfile可以作为快速参考，帮助调试问题的人导航容器内部。编排器和安全工具可能会发现其他描述镜像架构角色或安全配置的元数据在决定容器应该在哪里运行或允许做什么时很有用。
- en: 'The Docker community Label Schema project has defined commonly used labels
    at [http://label-schema.org/](http://label-schema.org/). Representing the recommended
    metadata by using the label schema and build arguments in Dockerfile looks like
    the following:'
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker社区标签模式项目在[http://label-schema.org/](http://label-schema.org/)中定义了常用标签。使用标签模式和Dockerfile中的构建参数表示推荐元数据如下所示：
- en: '`FROM openjdk:11-jdk-slim  ARG BUILD_ID=unknown ARG BUILD_DATE=unknown ARG
    VCS_REF=unknown  LABEL org.label-schema.version="${BUILD_ID}" \       org.label-schema.build-date="${BUILD_DATE}"
    \       org.label-schema.vcs-ref="${VCS_REF}" \       org.label-schema.name="ch10"
    \       org.label-schema.schema-version="1.0rc1"  COPY multi-stage-runtime.df
    /Dockerfile  COPY target/ch10-0.1.0.jar /app.jar` `ENTRYPOINT ["java","-jar","/app.jar"]`'
  id: totrans-1007
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FROM openjdk:11-jdk-slim  ARG BUILD_ID=unknown ARG BUILD_DATE=unknown ARG
    VCS_REF=unknown  LABEL org.label-schema.version="${BUILD_ID}" \ org.label-schema.build-date="${BUILD_DATE}"
    \ org.label-schema.vcs-ref="${VCS_REF}" \ org.label-schema.name="ch10" \ org.label-schema.schema-version="1.0rc1"  COPY
    multi-stage-runtime.df /Dockerfile  COPY target/ch10-0.1.0.jar /app.jar` `ENTRYPOINT
    ["java","-jar","/app.jar"]`'
- en: 'Our build process is more complicated now that we have more steps: gather metadata,
    build application artifacts, build image. Let’s orchestrate the build process
    with a time-tested build tool, `make`.'
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们现在有更多步骤：收集元数据、构建应用程序工件、构建镜像，我们的构建过程现在更加复杂。让我们使用经过时间考验的构建工具`make`来编排构建过程。
- en: 10.3.1\. Orchestrating the build with make
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.1\. 使用make编排构建
- en: '`make`, a widely available tool used to build programs, understands dependencies
    between the steps of a build process. Build process authors describe each step
    in a Makefile that `make` interprets and executes to complete the build. The `make`
    tool provides a flexible shell-like execution environment, so you can implement
    virtually any kind of build step.'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make`是一个广泛使用的构建程序的工具，它理解构建过程中步骤之间的依赖关系。构建过程作者在`make`解释和执行以完成构建的Makefile中描述每个步骤。`make`工具提供了一个灵活的shell-like执行环境，因此你可以实现几乎任何类型的构建步骤。'
- en: 'The primary advantage of `make` over a standard shell script is that users
    declare dependencies between steps rather than directly implementing the flow
    of control between steps. These steps are called rules, and each rule is identified
    by a target name. Here is the general form of a `make` rule:'
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make` 与标准 shell 脚本相比的主要优势是用户声明步骤之间的依赖关系，而不是直接在步骤之间实现控制流的流动。这些步骤被称为规则，每个规则都通过一个目标名称来标识。以下是
    `make` 规则的一般形式：'
- en: '`target … : prerequisites …` `12` `recipe command 1` `3` `recipe command 2
            …`'
  id: totrans-1012
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`target … : prerequisites …` `12` `recipe command 1` `3` `recipe command 2  
    …`'
- en: 1 target identifies the rule with a logical name or filename produced by the
    rule.
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个目标通过一个逻辑名称或规则生成的文件名来标识规则。
- en: 2 prerequisites is an optional list of targets to build before this target.
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 先决条件是构建此目标之前可选的目标列表。
- en: 3 The recipe section contains the list of commands used to build the target.
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 脚本部分包含用于构建目标的命令列表。
- en: When you run the `make` command, it constructs a dependency graph from the prerequisites
    declared for each rule. The command uses this graph to calculate the sequence
    of steps to build a specified target. `make` has many features and quirks that
    we will not describe here, but you can read more about it at [https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/).
    One item of note is that `make` is famous for its sensitivity to whitespace characters,
    particularly tabs for indentation and spaces around variable declarations. You
    will probably find it easiest to use the Makefile provided in this chapter’s source
    repository ([https://github.com/dockerinaction/ch10_patterns-for-building-images.git](https://github.com/dockerinaction/ch10_patterns-for-building-images.git))
    instead of typing them in yourself. With our `make` primer complete, let’s return
    to building our Docker images.
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行 `make` 命令时，它会根据每个规则声明的先决条件构建一个依赖图。该命令使用此图来计算构建指定目标所需的步骤顺序。`make` 有许多特性和怪癖，我们在此不一一描述，但你可以阅读更多关于它的信息，请参阅[https://www.gnu.org/software/make/manual/](https://www.gnu.org/software/make/manual/)。值得注意的是，`make`
    以其对空白字符的敏感性而闻名，尤其是缩进时使用的制表符以及变量声明周围的空格。你可能发现使用本章源代码库中提供的 Makefile（[https://github.com/dockerinaction/ch10_patterns-for-building-images.git](https://github.com/dockerinaction/ch10_patterns-for-building-images.git)）而不是自己输入它们要容易得多。随着我们的
    `make` 入门课程完成，让我们回到构建我们的 Docker 镜像。
- en: '|    |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Building on Windows
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Windows 上构建
- en: If you are using Windows, you will probably find that `make` and several other
    commands used in this example are not available in your environment. The easiest
    solution will probably be to use a Linux virtual machine either locally or in
    the cloud. If you plan to develop software by using Docker on Windows, you should
    also investigate using the Windows Subsystem for Linux (WSL or WSL2) with Docker
    for Windows.
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在使用 Windows，你可能会发现 `make` 以及在此示例中使用的其他几个命令在你的环境中不可用。最简单的解决方案可能是使用本地或云中的
    Linux 虚拟机。如果你计划在 Windows 上使用 Docker 开发软件，你也应该调查使用 Windows Subsystem for Linux（WSL
    或 WSL2）与 Docker for Windows。
- en: '|    |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'Here is a Makefile that will gather metadata, and then build, test, and tag
    the application artifact and images:'
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里是一个 Makefile，它将收集元数据，然后构建、测试和标记应用程序工件和镜像：
- en: '`# if BUILD_ID is unset, compute metadata that will be used in builds ifeq
    ($(strip $(BUILD_ID)),)     VCS_REF := $(shell git rev-parse --short HEAD)    
    BUILD_TIME_EPOCH := $(shell date +"%s")     BUILD_TIME_RFC_3339 := \            
    $(shell date -u -r $(BUILD_TIME_EPOCH) ''+%Y-%m-%dT%I:%M:%SZ'')     BUILD_TIME_UTC
    := \             $(shell date -u -r $(BUILD_TIME_EPOCH) +''%Y%m%d-%H%M%S'')    
    BUILD_ID := $(BUILD_TIME_UTC)-$(VCS_REF) endif  ifeq ($(strip $(TAG)),)     TAG
    := unknown endif  .PHONY: clean clean:     @echo "Cleaning"     rm -rf target  .PHONY:
    metadata metadata:     @echo "Gathering Metadata"     @echo BUILD_TIME_EPOCH IS
    $(BUILD_TIME_EPOCH)     @echo BUILD_TIME_RFC_3339 IS $(BUILD_TIME_RFC_3339)    
    @echo BUILD_TIME_UTC IS $(BUILD_TIME_UTC)     @echo BUILD_ID IS $(BUILD_ID)  target/ch10-0.1.0.jar:
        @echo "Building App Artifacts"     docker run -it --rm  -v "$(shell pwd)":/project/
    -w /project/ \     maven:3.6-jdk-11 \     mvn clean verify  .PHONY: app-artifacts
    app-artifacts: target/ch10-0.1.0.jar  .PHONY: lint-dockerfile lint-dockerfile:
        @set -e     @echo "Linting Dockerfile"     docker container run --rm -i hadolint/hadolint:v1.15.0
    < \             multi-stage-runtime.df  .PHONY: app-image app-image: app-artifacts
    metadata lint-dockerfile` `1` `@echo "Building App Image"     docker image build
    -t dockerinaction/ch10:$(BUILD_ID) \     -f multi-stage-runtime.df \     --build-arg
    BUILD_ID=''$(BUILD_ID)'' \     --build-arg BUILD_DATE=''$(BUILD_TIME_RFC_3339)''
    \     --build-arg VCS_REF=''$(VCS_REF)'' \     .     @echo "Built App Image. BUILD_ID:
    $(BUILD_ID)"  .PHONY: app-image-debug app-image-debug: app-image     @echo "Building
    Debug App Image"     docker image build -t dockerinaction/ch10:$(BUILD_ID)-debug
    \     -f multi-stage-runtime.df \     --target=app-image-debug \     --build-arg
    BUILD_ID=''$(BUILD_ID)'' \     --build-arg BUILD_DATE=''$(BUILD_TIME_RFC_3339)''
    \     --build-arg VCS_REF=''$(VCS_REF)'' \     .     @echo "Built Debug App Image.
    BUILD_ID: $(BUILD_ID)"  .PHONY: image-tests image-tests:     @echo "Testing image
    structure"     docker container run --rm -it \     -v /var/run/docker.sock:/var/run/docker.sock
    \     -v $(shell pwd)/structure-tests.yaml:/structure-tests.yaml \     gcr.io/gcp-runtimes/container-structure-test:v1.6.0
    test \     --image dockerinaction/ch10:$(BUILD_ID) \     --config /structure-tests.yaml  .PHONY:
    inspect-image-labels inspect-image-labels:     docker image inspect --format ''{{
    json .Config.Labels }}'' \             dockerinaction/ch10:$(BUILD_ID) | jq  .PHONY:
    tag tag:     @echo "Tagging Image"     docker image tag dockerinaction/ch10:$(BUILD_ID)\
                dockerinaction/ch10:$(TAG)  .PHONY: all all: app-artifacts app-image
    image-tests` `2`'
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 如果 BUILD_ID 未设置，计算在构建中使用的元数据 ifeq ($(strip $(BUILD_ID)),)   VCS_REF := $(shell
    git rev-parse --short HEAD)   BUILD_TIME_EPOCH := $(shell date +"%s")   BUILD_TIME_RFC_3339
    :=   $(shell date -u -r $(BUILD_TIME_EPOCH) ''+%Y-%m-%dT%I:%M:%SZ'')   BUILD_TIME_UTC
    :=   $(shell date -u -r $(BUILD_TIME_EPOCH) +''%Y%m%d-%H%M%S'')   BUILD_ID :=
    $(BUILD_TIME_UTC)-$(VCS_REF) endif ifeq ($(strip $(TAG)),)   TAG := unknown endif
    .PHONY: clean clean:   @echo "Cleaning"   rm -rf target .PHONY: metadata metadata:  
    @echo "Gathering Metadata"   @echo BUILD_TIME_EPOCH IS $(BUILD_TIME_EPOCH)   @echo
    BUILD_TIME_RFC_3339 IS $(BUILD_TIME_RFC_3339)   @echo BUILD_TIME_UTC IS $(BUILD_TIME_UTC)  
    @echo BUILD_ID IS $(BUILD_ID) target/ch10-0.1.0.jar:   @echo "Building App Artifacts"  
    docker run -it --rm  -v "$(shell pwd)":/project/ -w /project/   maven:3.6-jdk-11  
    mvn clean verify .PHONY: app-artifacts app-artifacts: target/ch10-0.1.0.jar .PHONY:
    lint-dockerfile lint-dockerfile:   @set -e   @echo "Linting Dockerfile"   docker
    container run --rm -i hadolint/hadolint:v1.15.0 <   multi-stage-runtime.df .PHONY:
    app-image app-image: app-artifacts metadata lint-dockerfile   `1`   @echo "Building
    App Image"   docker image build -t dockerinaction/ch10:$(BUILD_ID)   -f multi-stage-runtime.df  
    --build-arg BUILD_ID=''$(BUILD_ID)''   --build-arg BUILD_DATE=''$(BUILD_TIME_RFC_3339)''  
    --build-arg VCS_REF=''$(VCS_REF)''   .   @echo "Built App Image. BUILD_ID: $(BUILD_ID)"
    .PHONY: app-image-debug app-image-debug: app-image   @echo "Building Debug App
    Image"   docker image build -t dockerinaction/ch10:$(BUILD_ID)-debug   -f multi-stage-runtime.df  
    --target=app-image-debug   --build-arg BUILD_ID=''$(BUILD_ID)''   --build-arg
    BUILD_DATE=''$(BUILD_TIME_RFC_3339)''   --build-arg VCS_REF=''$(VCS_REF)''   .  
    @echo "Built Debug App Image. BUILD_ID: $(BUILD_ID)" .PHONY: image-tests image-tests:  
    @echo "Testing image structure"   docker container run --rm -it   -v /var/run/docker.sock:/var/run/docker.sock  
    -v $(shell pwd)/structure-tests.yaml:/structure-tests.yaml   gcr.io/gcp-runtimes/container-structure-test:v1.6.0
    test   --image dockerinaction/ch10:$(BUILD_ID)   --config /structure-tests.yaml
    .PHONY: inspect-image-labels inspect-image-labels:   docker image inspect --format
    ''{{ json .Config.Labels }}''   dockerinaction/ch10:$(BUILD_ID) | jq .PHONY: tag
    tag:   @echo "Tagging Image"   docker image tag dockerinaction/ch10:$(BUILD_ID)  
    dockerinaction/ch10:$(TAG) .PHONY: all all: app-artifacts app-image image-tests  
    `2`'
- en: 1 The app-image target requires building the app-artifacts, metadata, and linting
    target.
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 app-image 目标需要构建 app-artifacts、metadata 和 linting 目标。
- en: 2 You can build everything with “make all”.
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 您可以使用“make all”构建所有内容。
- en: 'This Makefile defines a target for each build step we have discussed: gathering
    metadata, building the application, and building, testing, and tagging the image.
    Targets such as `app-image` have dependencies on other targets to ensure that
    steps execute in the right order. Because build metadata is essential for all
    steps, it is generated automatically unless a `BUILD_ID` is provided. The Makefile
    implements an image pipeline that you can run locally or use within a continuous
    integration or continuous delivery (CD) system. You can build the application
    artifacts and image by making the `app-image` target:'
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此 Makefile 为我们讨论的每个构建步骤定义了一个目标：收集元数据、构建应用程序以及构建、测试和标记镜像。例如 `app-image` 这样的目标依赖于其他目标以确保步骤按正确的顺序执行。因为构建元数据对于所有步骤都是必不可少的，所以它会被自动生成，除非提供了
    `BUILD_ID`。Makefile 实现了一个可以在本地运行或用于持续集成或持续交付（CD）系统的镜像管道。您可以通过制作 `app-image` 目标来构建应用程序工件和镜像：
- en: '`make app-image`'
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make app-image`'
- en: 'Making the application artifacts will produce a lot of output as dependencies
    are retrieved and then code compiled. However, the application build should indicate
    success with a message like this:'
  id: totrans-1027
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 制作应用程序工件将产生大量输出，因为会检索依赖项然后编译代码。然而，应用程序构建应该通过类似以下的消息表示成功：
- en: '`[INFO] ------------------------------------------------------------------
    [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------`'
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[INFO] ------------------------------------------------------------------
    [INFO] 构建成功 [INFO] ------------------------------------------------------------------`'
- en: 'Immediately following that, you should see a `Gathering Metadata` message followed
    by metadata for this build:'
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 紧接着，您应该看到一条 `Gathering Metadata` 消息，然后是此构建的元数据：
- en: '`BUILD_TIME_EPOCH IS 1562106748 BUILD_TIME_RFC_3339 IS 2019-07-02T10:32:28Z
    BUILD_TIME_UTC IS 20190702-223228 BUILD_ID IS 20190702-223228-ade3d65`'
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`BUILD_TIME_EPOCH IS 1562106748 BUILD_TIME_RFC_3339 IS 2019-07-02T10:32:28Z
    BUILD_TIME_UTC IS 20190702-223228 BUILD_ID IS 20190702-223228-ade3d65`'
- en: 'The next step in the build process is the first quality-assurance step for
    our image. You should see a message like this:'
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建过程中的下一步是对于我们镜像的第一个质量保证步骤。您应该看到类似以下的消息：
- en: '`Linting Dockerfile docker container run --rm -i hadolint/hadolint:v1.15.0
    < multi-stage-      runtime.df`'
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Linting Dockerfile docker container run --rm -i hadolint/hadolint:v1.15.0
    < multi-stage-    runtime.df`'
- en: Before building the image, the Dockerfile is analyzed by a linting tool named
    `hadolint` ([https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint)).
    The linter checks Dockerfiles to verify that they follow best practices and identify
    common mistakes. As with other quality-assurance practices, you may choose to
    stop the image build pipeline when a linter reports a problem. Hadolint is one
    of several linters available for Dockerfiles. Because it parses the Dockerfile
    into an abstract syntax tree, it’s able to perform deeper and more complex analysis
    than approaches based on regular expressions. Hadolint identifies incorrectly
    specified or deprecated Dockerfile instructions, omitting a tag in the `FROM`
    image instruction, common mistakes when using `apt`, `apk`, `pip`, and `npm` package
    managers, and other commands specified in `RUN` instructions.
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建镜像之前，Dockerfile 会通过名为 `hadolint` 的 linting 工具进行分析（[https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint)）。该检查器会验证
    Dockerfile 是否遵循最佳实践并识别常见错误。与其他质量保证实践一样，当检查器报告问题时，您可以选择停止镜像构建流程。Hadolint 是可用于 Dockerfile
    的几个检查器之一。因为它将 Dockerfile 解析为抽象语法树，所以它能够执行比基于正则表达式的方法更深入和更复杂的分析。Hadolint 识别错误指定的或已弃用的
    Dockerfile 指令、在 `FROM` 镜像指令中省略标签、使用 `apt`、`apk`、`pip` 和 `npm` 包管理器时的常见错误，以及其他在
    `RUN` 指令中指定的命令。
- en: 'Once the Dockerfile has been linted, the `app-image` target executes and builds
    the application image. The `docker image build` command should indicate success
    with output similar to the following:'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦 Dockerfile 经过 linting，`app-image` 目标就会执行并构建应用镜像。`docker image build` 命令应该显示类似以下的成功输出：
- en: '`Successfully built 79b61fb87b96 Successfully tagged dockerinaction/ch10:20190702-223619-ade3d65
    Built App Image. BUILD_ID: 20190702-223619-ade3d65`'
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`成功构建 79b61fb87b96 成功标记 dockerinaction/ch10:20190702-223619-ade3d65 构建应用镜像。BUILD_ID:
    20190702-223619-ade3d65`'
- en: In this build process, each application image is tagged with a `BUILD_ID` computed
    from the time of the build and the current Git commit hash. The fresh Docker image
    is tagged with the repository and `BUILD_ID`, `20190702-223619-ade3d65` in this
    case. The `20190702-223619-ade3d65` tag now identifies Docker image ID `79b61fb87b96`
    in the `dockerinaction/ch10` image repository. This style of `BUILD_ID` identifies
    the image with a high degree of precision in both wall clock time and version
    history. Capturing the time of an image build is an important practice because
    people understand time well, and many image builds will perform software package
    manager updates or other operations that may not produce the same result from
    build to build. Including the version control ID, `7c5fd3d`, provides a convenient
    pointer back to the original source material used to build the image.
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个构建过程中，每个应用程序镜像都会被标记上一个由构建时间和当前Git提交哈希计算出的`BUILD_ID`。在这个例子中，新的Docker镜像被标记为仓库和`BUILD_ID`，即`20190702-223619-ade3d65`。这个`20190702-223619-ade3d65`标签现在标识了`dockerinaction/ch10`镜像仓库中的Docker镜像ID
    `79b61fb87b96`。这种`BUILD_ID`风格在墙钟时间和版本历史中都能以高精度标识镜像。捕获镜像构建的时间是一个重要的实践，因为人们很好地理解了时间，许多镜像构建将执行软件包管理器更新或其他可能不会产生相同结果的操作。包括版本控制ID，`7c5fd3d`，提供了一个方便的指针，可以追溯到构建镜像所使用的原始源材料。
- en: 'The steps that follow will make use of the `BUILD_ID`. You can make the `BUILD_ID`
    easily accessible by copying it from the last line of the `app-image` build step
    output in your terminal and exporting it as a variable in your shell:'
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面的步骤将使用`BUILD_ID`。您可以通过从终端中`app-image`构建步骤输出的最后一行复制它，并在shell中将它作为变量导出，使`BUILD_ID`易于访问：
- en: '`export BUILD_ID=20190702-223619-ade3d65`'
  id: totrans-1038
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`export BUILD_ID=20190702-223619-ade3d65`'
- en: 'You can inspect the metadata that was added to the image by inspecting the
    labels via this command:'
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过检查以下命令来检查添加到镜像中的元数据：
- en: '`make inspect-image-labels BUILD_ID=20190702-223619-ade3d65`'
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make inspect-image-labels BUILD_ID=20190702-223619-ade3d65`'
- en: 'Or you can use the following if you exported the `BUILD_ID` tag:'
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 或者，如果您导出了`BUILD_ID`标签，可以使用以下命令：
- en: '`make inspect-image-labels BUILD_ID=$BUILD_ID`'
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make inspect-image-labels BUILD_ID=$BUILD_ID`'
- en: 'This command uses `docker image inspect` to show the image’s labels:'
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个命令使用`docker image inspect`来显示镜像的标签：
- en: '`{   "org.label-schema.build-date": "2019-07-02T10:36:19Z",   "org.label-schema.name":
    "ch10",   "org.label-schema.schema-version": "1.0rc1",   "org.label-schema.vcs-ref":
    "ade3d65",   "org.label-schema.version": "20190702-223619-ade3d65" }`'
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`{   "org.label-schema.build-date": "2019-07-02T10:36:19Z",   "org.label-schema.name":
    "ch10",   "org.label-schema.schema-version": "1.0rc1",   "org.label-schema.vcs-ref":
    "ade3d65",   "org.label-schema.version": "20190702-223619-ade3d65" }`'
- en: The application image is now ready for further testing and tagging prior to
    release. The image has a unique `BUILD_ID` tag that will conveniently identify
    the image through the rest of the delivery process. In the next section, we will
    examine ways to test that an image has been constructed correctly and is ready
    for deployment.
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序镜像现在已准备好进行进一步的测试和标记，以便发布。该镜像有一个独特的`BUILD_ID`标签，将方便地标识整个交付过程中的镜像。在下一节中，我们将探讨测试镜像是否正确构建并准备好部署的方法。
- en: 10.4\. TESTING IMAGES IN A BUILD PIPELINE
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.4. 在构建管道中测试镜像
- en: Image publishers can use several techniques in their build pipelines to build
    confidence in the produced artifacts. The Dockerfile linting step described in
    the previous section is one quality-assurance technique, but we can go further.
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像发布者可以在他们的构建管道中使用多种技术来构建对产生的工件有信心。上一节中描述的Dockerfile linting步骤是一个质量保证技术，但我们还可以更进一步。
- en: One of the principal advantages of the Docker image format is that image metadata
    and the filesystem can be easily analyzed by tools. For example, the image can
    be tested to verify it contains files required by the application, those files
    have appropriate permissions, and by executing key programs to verify that they
    run correctly. Docker images can be inspected to verify that traceability and
    deployment metadata has been added. Security-conscious users can scan the image
    for vulnerabilities. Publishers can stop the image delivery process if any of
    these steps fail, and together these steps raise the quality of published images
    significantly.
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker镜像格式的其中一个主要优势是，镜像元数据和文件系统可以很容易地被工具分析。例如，可以通过测试镜像来验证它是否包含应用程序所需的文件，这些文件具有适当的权限，以及通过执行关键程序来验证它们是否能够正确运行。可以通过检查Docker镜像来验证是否已添加可追溯性和部署元数据。对安全性有意识的用户可以扫描镜像以查找漏洞。如果这些步骤中的任何一个失败，发布者可以停止镜像交付过程，这些步骤共同显著提高了发布镜像的质量。
- en: 'One popular tool for verifying the construction of a Docker image is the Container
    Structure Test tool (CST) from Google ([https://github.com/GoogleContainerTools/container-structure-test](https://github.com/GoogleContainerTools/container-structure-test)).
    With this tool, authors can verify that an image (or image tarball) contains files
    with desired file permissions and ownership, commands execute with expected output,
    and the image contains particular metadata such as a label or command. Many of
    these inspections could be done by a traditional system configuration inspection
    tool such as Chef Inspec or Serverspec. However, CST’s approach is more appropriate
    for containers, as the tool operates on arbitrary images without requiring any
    tooling or libraries to be included inside the image. Let’s verify that the application
    artifact has the proper permissions and that the proper version of Java is installed
    by executing CST with the following configuration:'
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 验证Docker镜像构建的一个流行工具是来自Google的容器结构测试工具（CST）([https://github.com/GoogleContainerTools/container-structure-test](https://github.com/GoogleContainerTools/container-structure-test))。使用此工具，作者可以验证镜像（或镜像tar包）是否包含具有所需文件权限和所有权的文件，命令执行时产生预期的输出，以及镜像包含特定的元数据，如标签或命令。许多这些检查可以通过传统的系统配置检查工具，如Chef
    Inspec或Serverspec来完成。然而，CST的方法更适合容器，因为该工具在任意镜像上操作，无需在镜像内包含任何工具或库。让我们通过以下配置执行CST来验证应用程序工件具有适当的权限，并且已安装正确的Java版本：
- en: '`schemaVersion: "2.0.0"  # Verify the expected version of Java is available
    and executable commandTests:   - name: "java version"     command: "java"    
    args: ["-version"]     exitCode: 0     # OpenJDK java -version stderr will include
    a line like:     # OpenJDK Runtime Environment 18.9 (build 11.0.3+7)     expectedError:
    ["OpenJDK Runtime Environment.*build 11\\..*"]   # Verify the application archive
    is readable and owned by root fileExistenceTests: - name: ''application archive''
      path: ''/app.jar''   shouldExist: true   permissions: ''-rw-r--r--''   uid:
    0   gid: 0`'
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`schemaVersion: "2.0.0"  # 验证期望的Java版本是否可用并可执行命令测试：    - name: "java version"      command:
    "java"      args: ["-version"]      exitCode: 0      # OpenJDK java -version stderr将包含类似以下内容的行：      #
    OpenJDK Runtime Environment 18.9 (build 11.0.3+7)      expectedError: ["OpenJDK
    Runtime Environment.*build 11\\..*"]   # 验证应用程序归档是否可读且由root拥有文件存在性测试：    - name:
    ''application archive''      path: ''/app.jar''      shouldExist: true      permissions:
    ''-rw-r--r--''      uid: 0      gid: 0`'
- en: First, this configuration tells CST to invoke Java and output the version information.
    The OpenJDK Java runtime prints its version information to stderr, so CST is configured
    to match that string against the `OpenJDK Runtime Environment.*build 11\..*` regular
    expression. If you needed to ensure that the application runs against a specific
    version of Java, the regex could be made more specific and the base image updated
    to match.
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，此配置告诉CST调用Java并输出版本信息。OpenJDK Java运行时将版本信息打印到stderr，因此CST被配置为将该字符串与`OpenJDK
    Runtime Environment.*build 11\..*`正则表达式匹配。如果您需要确保应用程序针对特定的Java版本运行，则可以将正则表达式制作得更具体，并将基础镜像更新以匹配。
- en: 'Second, CST will verify that the application archive is at /app.jar, owned
    by root, and readable by everyone. Verifying file ownership and permissions might
    seem basic but helps prevent problems with bugs that are “invisible” because programs
    aren’t executable, readable, or in the executable `PATH`. Execute the image tests
    against the image you built earlier with the following command:'
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其次，CST 将验证应用程序归档位于 /app.jar，由 root 拥有，并且对所有用户可读。验证文件所有权和权限可能看似基本，但有助于防止由于程序不可执行、不可读或不在可执行
    `PATH` 中而导致的“隐形”问题。使用以下命令对您之前构建的镜像执行图像测试：
- en: '`make image-tests BUILD_ID=$BUILD_ID`'
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make image-tests BUILD_ID=$BUILD_ID`'
- en: 'This command should produce a successful result:'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令应产生成功的结果：
- en: '`Testing image structure docker container run --rm -it \     -v /var/run/docker.sock:/var/run/docker.sock
    \     -v /Users/dia/structure-tests.yaml:/structure-tests.yaml \     gcr.io/gcp-runtimes/container-structure-test:v1.6.0
    test \     --image dockerinaction/ch10:20181230-181226-61ceb6d \     --config
    /structure-tests.yaml  ============================================= ====== Test
    file: structure-tests.yaml ====== =============================================  INFO:
    stderr: openjdk version "11.0.3" 2019-04-16 OpenJDK Runtime Environment 18.9 (build
    11.0.3+7) OpenJDK 64-Bit Server VM 18.9 (build 11.0.3+7, mixed mode)  === RUN:
    Command Test: java version --- PASS stderr: openjdk version "11.0.3" 2019-04-16
    OpenJDK Runtime Environment 18.9 (build 11.0.3+7) OpenJDK 64-Bit Server VM 18.9
    (build 11.0.3+7, mixed mode) INFO: File Existence Test: application archive ===
    RUN: File Existence Test: application archive --- PASS  =============================================
    ================== RESULTS ================== =============================================
    Passes:      2 Failures:    0 Total tests: 2  PASS`'
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Testing image structure docker container run --rm -it \   '
- en: Many image authors want to scan images for vulnerabilities prior to publishing
    them and halt the delivery process when a significant vulnerability exists. We
    will give a quick overview of how these systems work and how they are typically
    integrated into an image build pipeline. Several image vulnerability scanning
    solutions are available from both commercial and community sources.
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 许多镜像作者希望在发布镜像之前扫描其漏洞，并在存在重大漏洞时停止交付过程。我们将简要概述这些系统的工作原理以及它们通常如何集成到镜像构建管道中。从商业和社区来源都有可用的几个镜像漏洞扫描解决方案。
- en: In general, image vulnerability scanning solutions rely on a lightweight scanning
    client program that runs in the image build pipeline. The scanning client examines
    the contents of the image and compares the software package metadata and file-system
    contents to vulnerability data retrieved from a centralized vulnerability database
    or API. Most of these scanning systems require registration with the vendor to
    use the service, so we will not integrate any of the tools into this image build
    workflow. After choosing an image-scanning tool, it should be easy to add another
    target to the build process.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，镜像漏洞扫描解决方案依赖于在镜像构建管道中运行的轻量级扫描客户端程序。扫描客户端检查镜像内容，并将软件包元数据和文件系统内容与从集中式漏洞数据库或
    API 获取的漏洞数据进行比较。大多数这些扫描系统需要向供应商注册才能使用该服务，因此我们不会将任何工具集成到这个镜像构建工作流程中。在选择了一个图像扫描工具之后，应该很容易将其添加到构建过程中。
- en: '|    |'
  id: totrans-1058
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Features of a general vulnerability scanning and remediation workflow
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一般漏洞扫描和修复工作流程的特点
- en: Using a scanner to identify vulnerabilities in a single image is the first and
    most critical step in publishing images without vulnerabilities. The leading container
    security systems cover a wider set of scanning and remediation use cases than
    discussed in the image build pipeline example.
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用扫描仪识别单个镜像中的漏洞是发布无漏洞镜像的第一步，也是最重要的一步。领先的容器安全系统覆盖的扫描和修复用例范围比在镜像构建管道示例中讨论的更广。
- en: These systems incorporate vulnerability feeds with low false-positive rates,
    integrate with the organization’s Docker registries to identify issues in images
    that have already been published or were built by an external source, and notify
    maintainers of the base image or layer with a vulnerability to speed remediation.
    When evaluating container security systems, pay special attention to these features
    and the way each solution will integrate with your delivery and operational processes.
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些系统集成了低误报率的漏洞信息源，与组织的Docker注册库集成以识别已发布或由外部来源构建的镜像中的问题，并通知具有漏洞的基础镜像或层的维护者以加快修复。在评估容器安全系统时，请特别注意这些功能和每种解决方案将如何与您的交付和运营流程集成。
- en: '|    |'
  id: totrans-1062
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 10.5\. PATTERNS FOR TAGGING IMAGES
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.5. 标签镜像的模式
- en: 'Once an image has been tested and is deemed ready for deployment in the next
    stage of delivery, the image should be tagged so that it is easy for consumers
    to find and use it. Several schemes for tagging images exist, and some are better
    for certain consumption patterns than others. The most important image-tagging
    features to understand are as follows:'
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦镜像经过测试并被认为在交付的下一阶段部署就绪，应该对其进行标记，以便消费者容易找到和使用它。存在几种标记镜像的方案，其中一些方案对于某些消费模式来说比其他方案更好。理解最重要的图像标记功能如下：
- en: Tags are human-readable strings that point to a particular content-addressable
    image ID.
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签是可读的字符串，指向特定的内容可寻址的镜像ID。
- en: Multiple tags may point to a single image ID.
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个标签可能指向单个镜像ID。
- en: Tags are mutable and may be moved between images in a repository or removed
    entirely.
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签是可变的，可以在存储库中的镜像之间移动，或者完全删除。
- en: You can use all of these features to construct a scheme that works for an organization,
    but there is not a single scheme in use or only a single way to do it. Certain
    tagging schemes will work well for certain consumption patterns and not others.
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用所有这些功能构建适用于组织的方案，但并没有一个通用的方案在所有情况下都适用，或者只有一个方法可以做到。某些标记方案对于某些消费模式可能效果很好，而对于其他模式则不然。
- en: 10.5.1\. Background
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.5.1. 背景
- en: Docker image tags are mutable. An image repository owner can remove a tag from
    an image ID or move it from one ID to another. Image tag mutation is commonly
    used to identify the latest image in a series. The `latest` tag is used extensively
    within the Docker community to identify the most recent build of an image repository.
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker镜像标签是可变的。镜像存储库所有者可以从镜像ID中删除标签或将它从一个ID移动到另一个ID。图像标签的变异通常用于标识一系列中的最新图像。`latest`标签在Docker社区中被广泛使用，以标识图像存储库中最新的构建。
- en: However, the `latest` tag causes a lot of confusion because there is no real
    agreement on what it means. Depending on the image repository or organization,
    any of the following are valid answers to “What does the `latest` tag identify?”
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，`latest`标签引起了很多混淆，因为对其含义没有真正的共识。根据图像存储库或组织，以下任何一项都是对“`latest`标签标识什么？”的有效回答：
- en: The most recent image built by the CI system, regardless of source control branch
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI系统构建的最新镜像，无论来源控制分支
- en: The most recent image built by the CI system, from the main release branch
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI系统构建的最新镜像，来自主发布分支
- en: The most recent image built from the stable release branch that has passed all
    the author’s tests
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从稳定发布分支构建的最新镜像，该镜像已通过所有作者的测试
- en: The most recent image built from an active development branch that has passed
    all the author’s tests
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从活跃的开发分支构建的最新镜像，该镜像已通过所有作者的测试
- en: Nothing! Because the author has never pushed an image tagged `latest` or has
    not done so recently
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有东西！因为作者从未推送过标记为`latest`的镜像，或者最近没有推送过
- en: Even trying to define `latest` prompts many questions. When adopting an image
    release tagging scheme, be sure to specify what the tag does and does not mean
    in your own context. Because tags can be mutated, you will also need to decide
    if and when consumers should pull images to receive updates to an image tag that
    already exists on the machine.
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使尝试定义`latest`也会引发许多问题。在采用镜像发布标签方案时，务必明确在您的特定环境中该标签的含义和含义之外的内容。因为标签可能会被修改，您还需要决定消费者是否以及何时应该拉取镜像以接收机器上已存在的镜像标签的更新。
- en: 'Common tagging and deployment schemes include the following:'
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 常见的标记和部署方案包括以下内容：
- en: Continuous delivery with unique tags—  Pipelines promote a single image with
    a unique tag through delivery stages.
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用唯一标签的持续交付——管道通过交付阶段提升具有唯一标签的单个镜像。
- en: Continuous delivery with environment-specific artifacts—  Pipelines produce
    environment-specific artifacts and promote them through development, stage, and
    production.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境特定工件进行持续交付— 管道产生环境特定工件，并通过开发、测试和生产阶段进行提升。
- en: Semantic versioning—  Tag and publish images with a `Major.Minor.Patch` scheme
    that communicates the level of change in a release.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义版本控制— 使用`Major.Minor.Patch`方案标记和发布镜像，以传达发布中变化的级别。
- en: 10.5.2\. Continuous delivery with unique tags
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.5.2\. 使用唯一标记的持续交付
- en: The Unique Tags scheme, illustrated in [figure 10.5](#filepos1133631), is a
    common and simple way to support continuous delivery of an application. In this
    scheme, the image is built and deployed into an environment by using the unique
    `BUILD_ID` tag. When people or automation decide that this version of the application
    is ready for promotion to the next environment, they run a deployment to that
    environment with the unique tag.
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如[图10.5](#filepos1133631)所示，唯一标记方案是一种常见且简单的方法来支持应用的持续交付。在这个方案中，使用唯一的`BUILD_ID`标记构建和部署镜像到环境中。当人们或自动化系统决定这个版本的应用已经准备好升级到下一个环境时，他们会使用带有唯一标记的部署到该环境。
- en: Figure 10.5\. Continuous delivery with unique tags
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.5\. 使用唯一标记的持续交付
- en: '![](images/00032.jpg)'
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00032.jpg)'
- en: This scheme is simple to implement and supports continuous delivery of applications
    that use a linear release model without branching. The main disadvantage of this
    scheme is that people must deal with precise build identifiers instead of being
    able to use a `latest` or a `dev` tag. Because an image may be tagged multiple
    times, many teams apply and publish additional tags such as `latest` to provide
    a convenient way to consume the most recent image.
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方案易于实施，并支持使用线性发布模型且无分支的应用的持续交付。这种方案的主要缺点是人们必须处理精确的构建标识符，而不是能够使用`latest`或`dev`标记。因为一个镜像可能被标记多次，许多团队会应用和发布额外的标记，如`latest`，以提供一个方便的方式来消费最新的镜像。
- en: 10.5.3\. Configuration image per deployment stage
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.5.3\. 部署阶段的配置镜像
- en: Some organizations package software releases into a distinct artifact for each
    stage of deployment. These packages are then deployed to dedicated internal environments
    for integration testing and have names such as `dev` and `stage`. Once the software
    has been tested in internal environments, the production package is deployed to
    the production environment. We could create a Docker image for each environment.
    Each image would include both the application artifact and environment-specific
    configuration. However, this is an antipattern because the main deployment artifact
    is built multiple times and is usually not tested prior to production.
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些组织将软件发布版本打包成每个部署阶段的独立工件。然后，这些包被部署到专门的内部环境进行集成测试，名称如`dev`和`stage`。一旦软件在内部环境中经过测试，生产包就会被部署到生产环境。我们可以为每个环境创建一个Docker镜像。每个镜像都会包含应用工件和环境特定配置。然而，这并不是一个好的做法，因为主要的部署工件被构建多次，通常在生产之前没有经过测试。
- en: 'A better way to support deployment to multiple environments is to create two
    kinds of images:'
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 支持部署到多个环境的一个更好的方法是创建两种类型的镜像：
- en: A generic, environment-agnostic application image
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通用的、与环境无关的应用镜像
- en: A set of environment-specific configuration images, with each image containing
    the environment-specific configuration files for that environment
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组环境特定配置镜像，每个镜像包含该环境的特定配置文件
- en: Figure 10.6\. Configuration image per environment
  id: totrans-1092
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.6\. 每个环境的配置镜像
- en: '![](images/00067.jpg)'
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00067.jpg)'
- en: The generic application and environment-specific configuration images should
    be built at the same time and tagged with the same `BUILD_ID`. The deployment
    process identifies the software and configuration for deployment by using the
    `BUILD_ID` as described in the continuous delivery case. At deployment time, two
    containers are created. First, a configuration container is created from the environment-specific
    configuration image. Second, the application container is created from the generic
    application image, and that container mounts the config container’s filesystem
    as a volume.
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通用应用和环境特定配置镜像应同时构建，并使用相同的`BUILD_ID`进行标记。部署过程通过使用如持续交付案例中所述的`BUILD_ID`来识别部署的软件和配置。在部署时，会创建两个容器。首先，从环境特定配置镜像创建一个配置容器。其次，从通用应用镜像创建应用容器，并将配置容器的文件系统作为卷挂载。
- en: Consuming environment-specific files from a config container’s filesystem is
    a popular application orchestration pattern and a variation of 12-factor application
    principles ([https://12factor.net/](https://12factor.net/)). In [chapter 12](index_split_098.html#filepos1254019),
    you will see how Docker supports environment-specific configuration of services
    as a first-class feature of orchestration without using a secondary image.
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从配置容器的文件系统中消费特定环境的文件是一种流行的应用程序编排模式，也是12因子应用程序原则的变体([https://12factor.net/](https://12factor.net/))。在第12章([index_split_098.html#filepos1254019])中，你将看到Docker如何作为编排的第一级功能支持服务的特定环境配置，而不使用辅助图像。
- en: This approach enables software authors and operators to support environment-specific
    variation while maintaining traceability back to the originating sources and preserving
    a simple deployment workflow.
  id: totrans-1096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法使软件作者和操作员能够在保持对原始来源的可追溯性的同时，支持特定环境的差异，并保持简单的部署工作流程。
- en: 10.5.4\. Semantic versioning
  id: totrans-1097
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.5.4\. 语义版本控制
- en: 'Semantic versioning ([https://semver.org/](https://semver.org/)) is a popular
    approach to versioning artifacts with a version number of the form `Major.Minor.Patch`.
    The semantic versioning specification defines that as software changes, authors
    should increment the following:'
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 语义版本控制([https://semver.org/](https://semver.org/))是一种流行的以`主.次.修订`形式的版本号对工件进行版本控制的方法。语义版本控制规范定义了，随着软件的变化，作者应增加以下内容：
- en: Major version when making incompatible API changes
  id: totrans-1099
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作不兼容API更改时的主版本
- en: Minor version when adding functionality in a backward-compatible manner
  id: totrans-1100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向后兼容的方式中添加功能时的次版本
- en: Patch version when making backward-compatible bug fixes
  id: totrans-1101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作向后兼容的bug修复时的修订版本
- en: Semantic versioning helps both publishers and consumers manage expectations
    for the kind of changes a consumer is getting when updating an image dependency.
    Authors who publish images to a large number of consumers or who must maintain
    several release streams for a long time often find semantic versioning or a similar
    scheme attractive. Semantic versioning is a good choice for images that many people
    depend on as a base operating system, language runtime, or database.
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 语义版本控制帮助发布者和消费者管理对更新图像依赖项时获得的变化的期望。向大量消费者发布图像或必须长期维护多个发布流的人经常发现语义版本控制或类似方案很有吸引力。对于许多人依赖作为基础操作系统、语言运行时或数据库的图像，语义版本控制是一个不错的选择。
- en: Figure 10.7\. Tag and publish image release with semantic versioning
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.7\. 使用语义版本控制标记和发布图像发布
- en: '![](images/00003.jpg)'
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00003.jpg)'
- en: 'Suppose that after testing your image in `dev` and `stage` that you want to
    release your recent build of the example app as version 1.0.0 to your customers.
    You can use `BUILD_ID` to identify the image and tag it with 1.0.0:'
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你在`dev`和`stage`测试了你的镜像后，想要将示例应用的最新构建版本作为版本1.0.0发布给你的客户。你可以使用`BUILD_ID`来标识镜像，并用1.0.0进行标记：
- en: '`make tag BUILD_ID=$BUILD_ID TAG=1.0.0`'
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`make tag BUILD_ID=$BUILD_ID TAG=1.0.0`'
- en: Tagging the image as version `1.0.0` signals that you are ready to maintain
    backward compatibility in the operation of the software. Now that you have tagged
    the image, you can push it to a registry for distribution. You may even choose
    to publish to multiple registries. Use multiple registries to keep images intended
    for internal use private and publish only official releases to the public registry
    for consumption by customers.
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将图像标记为版本 `1.0.0` 表示你已准备好在软件操作中维护向后兼容性。现在你已经标记了图像，你可以将其推送到注册表进行分发。你甚至可以选择将图像发布到多个注册表。使用多个注册表来保持内部使用图像的私密性，并将仅官方发布版发布到公共注册表以供客户消费。
- en: No matter what the scheme for identifying an image to promote, once the decision
    to promote the image is made, a promotion pipeline should resolve semantic tags
    (`latest`, `dev`, `7`) to a unique tag or content-addressable identifier and deploy
    that image. This ensures that if the tag being promoted is moved to another image
    in the meantime, the image that people decided to promote is deployed instead
    of merely whatever image the tag is associated with at the time of deployment.
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论识别图像以推广的方案是什么，一旦做出推广图像的决定，推广管道应将语义标签（`latest`、`dev`、`7`）解析为唯一的标签或内容可寻址标识符，并部署该图像。这确保了如果在推广的标签被移动到另一个图像的同时，部署的将是人们决定推广的图像，而不是仅仅在部署时与标签关联的任何图像。
- en: SUMMARY
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered common goals, patterns, and techniques used to build and
    publish applications in Docker images. The options described in this chapter illustrate
    the range of options available when creating image delivery processes. With this
    foundation, you should be able to navigate, select, and customize options that
    are appropriate for delivering your own applications as Docker images. The key
    points to understand from this chapter are:'
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖了在Docker镜像中构建和发布应用程序时使用的常见目标、模式和技巧。本章中描述的选项展示了在创建镜像交付流程时可选范围。有了这个基础，你应该能够导航、选择和定制适合将您自己的应用程序作为Docker镜像交付的选项。本章需要理解的关键点包括：
- en: Pipelines for building images have the same structure and goals for ensuring
    quality of Docker images as other software and infrastructure build pipelines.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像的管道具有与其他软件和基础设施构建管道相同的结构和目标，以确保Docker镜像的质量。
- en: Tools for detecting bugs, security problems, and other image construction problems
    exist and can easily be incorporated into image build pipelines.
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在用于检测错误、安全问题和其他镜像构建问题的工具，并且可以轻松地将其集成到镜像构建管道中。
- en: Codify the image build process by using a build tool such as make and use that
    process in local development and CI/CD processes.
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用如make之类的构建工具来规范镜像构建过程，并在本地开发和CI/CD流程中使用该过程。
- en: Several patterns exist for organizing Docker image definitions. These patterns
    provide trade-offs in managing application build and deployment concerns, such
    as attack surface and image size versus sophistication.
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在几种组织Docker镜像定义的模式。这些模式在管理应用程序构建和部署关注点（如攻击面和镜像大小与复杂性）方面提供了权衡。
- en: Information about the source and build process of an image should be recorded
    as image metadata to support traceability, debugging, and orchestration activities
    when deploying images.
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像的源和构建过程的信息应记录为镜像元数据，以支持部署镜像时的可追溯性、调试和编排活动。
- en: Docker image tags provide a foundation for delivering software to consumers
    by using styles ranging from continuous delivery in a private service deployment
    to publishing long-lived releases via semantic versioning to the public.
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像标签为通过使用从私有服务部署中的持续交付到通过语义版本发布长期版本到公共领域的各种风格，向消费者交付软件提供了一个基础。
