- en: 2 What to test and when?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 应该测试什么以及何时测试？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The different types of tests and when to use them
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的测试及其使用时机
- en: Writing your first automated tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个自动化测试
- en: How to balance coupling, maintenance, and cost
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何平衡耦合、维护和成本
- en: In the previous chapter, to facilitate explaining what tests are and their benefits,
    I put all the different types of tests in a single, big conceptual box. I showed
    tests that dealt with databases, tests that directly called one function, and
    tests that called multiple functions. In this chapter, I’ll take tests out of
    that box and put them into separate shelves, each one containing tests of a different
    kind.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，为了便于解释测试是什么以及它们的益处，我将所有不同类型的测试放入一个单一的大概念框中。我展示了处理数据库的测试、直接调用一个函数的测试以及调用多个函数的测试。在本章中，我将测试从那个框中取出，并将它们放入单独的架子，每个架子都包含不同类型的测试。
- en: It’s essential to understand how tests fit into different categories because
    **different types of tests serve different purposes**. When building a car, for
    example, it’s crucial to test the engine and the ignition system individually,
    but it’s also vital to ensure they work together. If not, both the engine and
    the ignition system are useless. It’s equally as important to test whether people
    can drive the car once all parts are in place, or else nobody will go anywhere.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理解测试如何适应不同的类别是至关重要的，因为**不同类型的测试服务于不同的目的**。例如，在制造汽车时，单独测试发动机和点火系统是至关重要的，但同样重要的是确保它们能协同工作。如果不这样，发动机和点火系统都将毫无用处。当所有部件都到位后，测试人们是否能够驾驶汽车同样重要，否则没有人会去任何地方。
- en: When we build software, we want to have similar guarantees. We want to ensure
    our functions work in isolation as well as in integration. And, when we put all
    of these functions together in an application, we want to ensure customers can
    use it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建软件时，我们希望有类似的保证。我们希望确保我们的函数在独立以及集成状态下都能正常工作。而且，当我们把这些函数全部整合到一个应用程序中时，我们希望确保客户能够使用它。
- en: These different types of tests serve different purposes, run at different frequencies,
    and take different amounts of time to complete. Some are more suited to guide
    you through the development phase, whereas others can make it easier to test a
    feature only after it’s complete. Some tests interface directly with your code,
    and others interact with your application through a graphical interface, as an
    end user would do. It’s *your* job to decide which of these tests to use and when.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同类型的测试服务于不同的目的，运行频率不同，完成所需时间也不同。有些更适合指导你通过开发阶段，而有些则可以在功能完成后更容易地进行测试。有些测试直接与你的代码接口，而有些则通过图形界面与你的应用程序交互，就像最终用户一样。决定使用哪种测试以及何时使用是**你的**职责。
- en: I’ll teach you about these different types of tests by writing examples for
    small functions and applications. Throughout the chapter, I’ll avoid being overprescriptive.
    Instead, I will focus on the outcomes and drawbacks of each kind of test so that
    you can make your own decisions. I want to empower you to decide which types of
    tests will benefit your project the most throughout the different phases of its
    development and give you a sense of how to incorporate different types of tests
    into your workflow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过为小型函数和应用程序编写示例来教你这些不同类型的测试。在整个章节中，我将避免过度规定。相反，我将专注于每种测试的结果和缺点，以便你可以做出自己的决定。我希望赋予你权力，在项目开发的各个阶段决定哪种类型的测试将对你最有益，并给你一种如何将不同类型的测试融入工作流程的感觉。
- en: Learning about these different labels is helpful because they help you decide
    what your tests *should* and should *not* cover in each situation. In reality,
    these definitions are a bit blurry. You will rarely find yourself proactively
    labeling different types of tests, but knowing that labels exist and having good
    examples for each of them is invaluable for creating strong quality guarantees
    and for unambiguous communication with colleagues.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些不同的标签是有帮助的，因为它们帮助你决定在每种情况下你的测试应该覆盖什么以及不应该覆盖什么。在现实中，这些定义有些模糊。你很少会主动地为不同类型的测试贴上标签，但知道标签的存在并为每个标签提供良好的示例对于创建强大的质量保证和与同事进行明确沟通是无价的。
- en: 2.1 The testing pyramid
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 测试金字塔
- en: 'Louis’s bakery is committed to producing the highest quality pastries East
    London has ever tasted. Louis and his team meticulously inspect every ingredient
    to guarantee it’s fresh and new. The same happens to all the parts of his cheesecakes.
    From the crust to the batter, each step in the recipe goes through rigorous quality
    control to scrutinize its texture and consistency. For every cheesecake made,
    Louis makes sure also to bake a “proof”: a small separate piece for him to savor—a
    sweet reward and the ultimate proof that Louis’s cheesecakes are undeniably delectable.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯的面包店致力于生产东伦敦有史以来最好的糕点。路易斯和他的团队仔细检查每一个成分，以确保它们新鲜且质量上乘。他的奶酪蛋糕的所有部分也是如此。从外壳到面糊，食谱中的每一步都要经过严格的质量控制，以检查其质地和一致性。对于每个制作的奶酪蛋糕，路易斯还确保烤一个“样品”：一小块单独的蛋糕供他品尝——这是一种甜蜜的奖励，也是路易斯的奶酪蛋糕无疑是美味无比的最终证明。
- en: When you keep your desserts up to such high standards, you don’t want your software
    to fall behind. For that, there’s a lot we can learn from the way Louis ensures
    his baked goods are the best in town.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保持你的甜点达到如此高的标准时，你不想你的软件落后。为此，我们可以从路易斯确保他的烘焙食品是镇上最好的方式中学到很多东西。
- en: In the same way that low-quality ingredients ruin a cake, poorly written functions
    ruin a piece of software. If your functions don’t work, then your whole application
    won’t. Testing these tiny pieces of software is the first step in achieving high-quality
    digital products.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像低质量的成分会毁掉一块蛋糕一样，编写不良的函数会毁掉一个软件组件。如果你的函数不起作用，那么你的整个应用程序也不会。测试这些微小的软件组件是实现高质量数字产品的第一步。
- en: The next step is to ensure that all the intermediary products of this process
    are as high quality as its parts. When combining those functions into larger components,
    like when combining ingredients to make dough, you must ensure that the blend
    is as good as its individual items.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保这个过程中的所有中间产品都与其各个部分一样高质量。当将这些函数组合成更大的组件时，就像将成分混合成面团一样，你必须确保混合物与其单个项目一样好。
- en: Finally, just as Louis tastes his cakes as his customers would, we must also
    try our software as our users would. If all of its modules work, but the application
    itself doesn’t, it’s a useless product.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像路易斯像他的顾客一样品尝蛋糕一样，我们也必须像我们的用户一样尝试我们的软件。如果所有模块都工作正常，但应用程序本身不工作，那么它就是一个无用的产品。
- en: Test individual ingredients.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试单个成分。
- en: Test the combination of the primary ingredients into intermediary products.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试主要成分组合成中间产品。
- en: Test the final product.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试最终产品。
- en: Mike Cohn’s testing pyramid (figure 2.1)—the metaphor whose name designates
    this section—comes from this idea that different parts of your software must be
    tested in diverse ways and with varying regularity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克·科恩的测试金字塔（图2.1）——这个隐喻的名字指定了这个部分——来源于这样一个想法，即你的软件的不同部分必须以不同的方式和不同的频率进行测试。
- en: '![](../Images/CH02_F01_DaCosta.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F01_DaCosta.png)'
- en: Figure 2.1 Mike Cohn’s test pyramid
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 迈克·科恩的测试金字塔
- en: 'It divides tests into the following three categories:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它将测试分为以下三个类别：
- en: UI tests
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI测试
- en: Service tests
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务测试
- en: Unit tests
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: The higher the tests are in the pyramid, the less frequently they run and the
    more value they provide. Tests in the top are few, and tests in the bottom are
    numerous.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔中，测试的层级越高，它们运行的频率越低，提供的价值越大。顶部的测试很少，底部的测试很多。
- en: 'Unit tests attest to the quality of the most atomic unit in your software:
    your functions. Service tests ensure these functions work in integration as a
    service. UI tests verify your work from a user’s perspective by interacting with
    your software through the user interface it provides.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试证明了你的软件中最原子单位的品质：你的函数。服务测试确保这些函数作为服务整合时能正常工作。UI测试通过用户界面与你的软件交互，从用户的角度验证你的工作。
- en: The size of the pyramid’s layers indicates how many tests of that kind we should
    write. Their placement in the pyramid suggests how strong the guarantees those
    tests provide are. The higher up a test fits into the pyramid, the more valuable
    it is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔各层的尺寸表示我们应该编写多少种此类测试。它们在金字塔中的位置暗示了这些测试提供的保证有多强。测试在金字塔中的位置越高，它的价值就越大。
- en: 'Back to our baking analogy: unit tests are analogous to inspecting individual
    ingredients. It’s a reasonably quick and cheap task that can be done multiple
    times quite early in the overall process, but it provides little value when compared
    to further quality control steps. Unit tests fit into the bottom part of the pyramid
    because we have many of them, but their quality assurance guarantees aren’t as
    strict as the other tests’.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的烘焙类比：单元测试类似于检查单个原料。这是一个相对快速且便宜的任务，可以在整体过程的早期多次进行，但与进一步的质量控制步骤相比，它提供的价值很小。单元测试位于金字塔的底部，因为我们有很多这样的测试，但它们的质量保证并不像其他测试那样严格。
- en: Service tests are analogous to inspecting the intermediary products of the recipe.
    In comparison to the inspection of individual ingredients, these tests are reasonably
    more complex and can be done only in the later phases of the overall process.
    Nonetheless, they provide more compelling evidence that a heavenly cheesecake
    is about to materialize. They fit into the middle of the pyramid because you should
    have fewer service tests than unit tests and because they provide stronger quality
    guarantees.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 服务测试类似于检查食谱的中间产品。与检查单个原料相比，这些测试相对更复杂，只能在整体过程的后期阶段进行。尽管如此，它们提供了更有力的证据，表明即将出现一个美味的芝士蛋糕。它们适合位于金字塔的中间部分，因为你应该有比单元测试更少的服务测试，并且因为它们提供了更强的质量保证。
- en: UI tests are analogous to tasting your cheesecake once it’s done. They tell
    you whether the final product matches your expectations. To perform these tests,
    you must have gone through the entire recipe and have a finished product. They
    go into the top of the pyramid because these test should be the most sporadic
    and are the ones that provide the most stringent guarantees.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试类似于完成芝士蛋糕后品尝它。它们告诉你最终产品是否符合你的预期。要执行这些测试，你必须已经完成了整个食谱，并且有一个成品。它们位于金字塔的顶部，因为这些测试应该是最不规律的，并且是提供最严格保证的测试。
- en: Each one of the pyramid’s testing layers builds on top of the one underneath.
    All of them help us assert the quality of the final product, but at different
    stages of the process. Without fresh ingredients, for example, you can’t have
    a luxurious batter. Furthermore, without a luxurious batter, you can’t have a
    sublime cheesecake.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的每一层测试都是建立在下一层之上的。它们都帮助我们断言最终产品的质量，但在不同的过程阶段。例如，如果没有新鲜的原料，你就无法做出豪华的面糊。此外，没有豪华的面糊，你就无法做出美味的芝士蛋糕。
- en: Warning This terminology is not used consistently throughout the industry. You
    may see people referring to these same categories with different names. The separation
    between these categories is blurry, just as it is to differentiate one kind of
    test from another when we see the source code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这个术语在整个行业中并不一致使用。你可能会看到人们用不同的名字来指代这些相同的类别。这些类别之间的界限模糊，就像我们在看到源代码时区分不同类型的测试一样。
- en: Mike’s pyramid is, in general, an excellent mental framework. Separating tests
    into different categories is instrumental in determining how many of each type
    we should write and how often they should run. But I find it problematic to divide
    tests by their target, be it a function, service, or interface.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克的金字塔在一般情况下是一个优秀的心智框架。将测试分为不同的类别对于确定我们应该编写多少每种类型的测试以及它们应该多久运行一次非常有帮助。但我发现按目标划分测试是有问题的，无论是功能、服务还是接口。
- en: If, for example, you are writing tests that target a web application, should
    all of its tests be considered UI tests? Even though you are testing the client
    itself, you may have separate tests for individual functions and other tests that
    actually interact with the GUI. If your product is a RESTful API and you test
    it by sending it HTTP requests, is this a service test or a UI test? Even though
    you are testing a service, the HTTP API is the interface provided to your users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在编写针对Web应用的测试，是否应该将其所有测试都视为UI测试？尽管你在测试客户端本身，但你可能需要对单个功能进行单独的测试，以及与GUI实际交互的其他测试。如果你的产品是一个RESTful
    API，并且你通过发送HTTP请求来测试它，这是服务测试还是UI测试？尽管你在测试一个服务，但HTTP API是提供给用户的一个接口。
- en: Instead of dividing tests by their targets, I suggest that we separate tests
    by how broad their scope is. The larger the portion of your software a test makes
    up, the higher it will be placed in the pyramid.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与其按测试的目标来划分测试，我建议我们根据测试的范围广度来区分测试。测试覆盖你软件的比重越大，它在金字塔中的位置就越高。
- en: 'This revised pyramid (shown in figure 2.2) divides tests into three categories,
    too, but labels them differently and used the level of isolation of each test
    as the main criterion for its division. The new labels are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修订后的金字塔（如图2.2所示）也将测试分为三个类别，但标签不同，并使用每个测试的隔离级别作为其划分的主要标准。新的标签如下：
- en: End-to-end tests
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Integration tests
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Unit tests
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: '![](../Images/CH02_F02_DaCosta.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F02_DaCosta.png)'
- en: Figure 2.2 A revised version of the original test pyramid
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 原始测试金字塔的修订版
- en: 'Unit tests are the same as in Mike’s original pyramid. They validate the most
    atomic building blocks of your software: its functions. The tests that directly
    interact with individual functions in chapter 1 fit into this category. The scope
    of these tests is the smallest possible, and they assert only the quality of individual
    functions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与迈克原始的金字塔相同。它们验证软件的最基本的构建块：其函数。与第1章中单个函数直接交互的测试属于这一类别。这些测试的范围是最小的，并且只断言单个函数的质量。
- en: Integration tests validate how the different pieces of your software work together.
    Tests that call a function and check whether it has updated items in a database
    are in this category. An example of an integration test is the test in chapter
    1 that ensures that only available items can be added to the cart. The scope of
    these tests is broader than the scope of unit tests but smaller than the scope
    of end-to-end tests. They assert the quality of the intermediary steps of the
    process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试验证软件的不同部分如何协同工作。调用函数并检查数据库中是否有更新项的测试属于这一类别。第1章中的集成测试示例确保只能将可用的项目添加到购物车中。这些测试的范围比单元测试的范围更广，但比端到端测试的范围小。它们断言过程中间步骤的质量。
- en: End-to-end tests validate your application from a user’s perspective, treating
    your software as much as a black box as possible. A test that controls a web browser
    and interacts with your application by clicking buttons and verifying labels is
    in this category. End-to-end tests correspond to tasting a sample of your cheesecake.
    Their scope is the entire application and its features.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试从用户的角度验证您的应用程序，尽可能将您的软件视为黑盒。控制网络浏览器并通过点击按钮和验证标签与您的应用程序交互的测试属于这一类别。端到端测试相当于品尝一块奶酪蛋糕的样品。其范围是整个应用程序及其功能。
- en: As in the real world, tests don’t necessarily need to be in one category or
    the other. Many times they will fit between groups, and that’s fine. These categories
    don’t exist for us to write labels on top of each of our tests. They exist to
    guide us toward better and more reliable software, indicating which tests we should
    write, when, and how much. For a detailed comparison between the different aspects
    of each type of test, see table 2.1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与现实世界一样，测试不一定需要属于某一类别或另一类别。很多时候，它们会介于各组之间，这是可以的。这些类别并不是为了我们在每个测试上方写标签而存在的。它们存在是为了指导我们编写更好、更可靠的软件，指示我们应该编写哪些测试，何时编写，以及编写多少。有关不同类型测试不同方面的详细比较，请参阅表2.1。
- en: Table 2.1 Characteristics of each kind of test
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 各类测试的特点
- en: '|  | Unit tests | Integration tests | End-to-end tests |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|  | 单元测试 | 集成测试 | 端到端测试 |'
- en: '| **Target** | Individual functions | Observable behavior and the integration
    among multiple functions | User-facing functionality |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **目标** | 单个函数 | 可观察行为和多个函数之间的集成 | 面向用户的功能 |'
- en: '| **Quantity** | Numerous—several tests per function | Somewhat frequent—many
    tests per observable behavior | Sparse—a few tests per feature |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **数量** | 许多——每个函数几个测试 | 比较频繁——每个可观察行为几个测试 | 稀疏——每个功能几个测试 |'
- en: '| **Speed** | Very quick—usually a few milliseconds | Average—usually up to
    very few seconds | Slow—usually up to many seconds or, in more complex cases,
    minutes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **速度** | 非常快——通常几毫秒 | 平均——通常几秒以内 | 慢——通常几秒或更复杂的情况下几分钟 |'
- en: '| **Execution frequency** | Numerous times during the development of a function
    | Regularly during the development of a feature | When features are complete |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **执行频率** | 在函数开发过程中多次执行 | 在功能开发过程中定期执行 | 功能完成时 |'
- en: '| **Feedback level** | Specific problematic input and output for individual
    functions | Problematic behavior | Incorrect functionality |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **反馈级别** | 单个函数的具体问题输入和输出 | 问题行为 | 错误的功能 |'
- en: '| **Costs** | Cheap—usually small, quick to update, run, and understand | Moderate—medium-sized,
    reasonably fast to execute | Expensive—take a long time to run, and tend to be
    more flaky and convoluted |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 便宜——通常规模小，更新、运行和理解速度快 | 中等——中等规模，执行速度合理 | 贵——运行时间长，往往更易出错且复杂 |'
- en: '| **Knowledge of the application** | Coupled—require direct access to the code
    itself; address its functions | Address functionality, but also through direct
    access to the code; require access to components like databases, the network,
    or filesystems | As unaware of the code as possible; interact with the application
    through the interface given to its users |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **对应用程序的了解** | 互连——需要直接访问代码本身；处理其功能 | 处理功能，但也通过直接访问代码；需要访问数据库、网络或文件系统等组件
    | 尽可能不了解代码；通过用户界面与应用程序交互 |'
- en: '| **Main goals** | Provide quick feedback during development time, aid refactoring,
    prevent regressions, and document the code’s APIs by providing usage examples
    | Guarantee adequate usage of third-party libraries, and check whether the unit
    under test performs the necessary side effects, such as logging or interacting
    with separate services | Guarantee the application works for its end users |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **主要目标** | 在开发期间提供快速反馈，帮助重构，防止回归，并通过提供使用示例来记录代码的API | 保证第三方库得到充分使用，并检查被测试的单元是否执行了必要的副作用，例如记录或与独立服务交互
    | 保证应用程序对最终用户有效 |'
- en: Using this new taxonomy, let’s think about how we’d classify specific examples
    of tests and where they’d fit in our revised test pyramid.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的分类法，让我们思考如何将特定的测试示例进行分类，以及它们将如何融入我们修订后的测试金字塔中。
- en: If your end product is a RESTful API, tests that send requests to it are one
    kind of end-to-end test. If you build a web application that talks to this API,
    then tests that open a web browser and interact with it from a user’s perspective
    are also end-to-end tests, but they should be placed even higher in the pyramid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的最终产品是一个RESTful API，向其发送请求的测试就是一种端到端测试。如果你构建了一个与该API通信的Web应用程序，那么从用户角度打开网页并与它交互的测试也是端到端测试，但它们应该放在金字塔的更高位置。
- en: Tests for your React components fit somewhere between the integration and unit
    layers. You may be testing UI, but you are orienting your development process
    by interacting with individual parts of your application in integration with React’s
    API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的React组件的测试位于集成和单元层之间。你可能正在测试UI，但你通过与React API集成，通过与应用程序的单个部分交互来引导你的开发过程。
- en: NOTE Remember not to be too concerned about fitting tests into one category
    or another. The pyramid exists as a mental framework for you to think about the
    different types of guarantees you want to create around your software. Because
    every piece software is different, some pyramids may have a narrower base or a
    wider top than others, but, as a general rule, you should strive to keep the pyramid’s
    shape.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住不要过于担心测试是否适合某一类别。金字塔作为一个思维框架，帮助你思考围绕软件想要创建的不同类型的保证。因为每个软件都是不同的，某些金字塔可能底部较窄或顶部较宽，但作为一般规则，你应该努力保持金字塔的形状。
- en: 2.2 Unit tests
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 单元测试
- en: 'In the same way that you can’t bake tasty desserts without fresh ingredients,
    you can’t write great software without well-written functions. Unit tests help
    you ensure that the smallest units of your software, your functions, behave as
    you expect them to. In this section, you’ll write your first automated test: a
    unit test.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像没有新鲜原料就无法制作美味的甜点一样，没有编写良好的函数就无法编写优秀的软件。单元测试帮助你确保软件的最小单元，即你的函数，按照你的预期行为。在本节中，你将编写你的第一个自动化测试：单元测试。
- en: To visualize precisely what these tests cover, assume that the bakery’s online
    store, whose components are shown in figure 2.3, consists of a React client and
    a Node.js backend that talks to a database and an email service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确地可视化这些测试覆盖的范围，假设面包店的在线商店（其组件如图2.3所示）由一个React客户端和一个与数据库和电子邮件服务通信的Node.js后端组成。
- en: '![](../Images/CH02_F03_DaCosta.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F03_DaCosta.png)'
- en: Figure 2.3 The bakery’s website infrastructure
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 面包店的网站基础设施
- en: The tests you will write cover a small portion of this application. They will
    deal only with individual functions within your server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的测试将覆盖这个应用程序的一小部分。它们将仅处理你服务器内的单个函数。
- en: Unit tests are at the bottom of the pyramid, so their scope, shown in figure
    2.4, is small. As we move up, you will see that the surface covered by tests will
    increase.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试位于金字塔的底部，因此它们的范围，如图 2.4 所示，很小。随着我们向上移动，你会看到测试覆盖的表面会增大。
- en: '![](../Images/CH02_F04_DaCosta.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 单元测试的范围](../Images/CH02_F04_DaCosta.png)'
- en: Figure 2.4 Unit tests’ scope
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 单元测试的范围
- en: Start by writing the function shown in listing 2.1 that will be the target of
    your test. Create a file called `Cart.js`, and write a class `Cart` that has an
    `addToCart` function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写列表 2.1 中所示的函数，这将作为你的测试目标。创建一个名为 `Cart.js` 的文件，并编写一个具有 `addToCart` 函数的 `Cart`
    类。
- en: Unit under test Most of the literature related to testing refers to the target
    of your tests as the *unit under test*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试 大多数与测试相关的文献将你的测试目标称为 *单元测试对象*。
- en: NOTE All of the code in this book is also available on GitHub at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本书中的所有代码也都在 GitHub 上提供，地址为 [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)。
- en: Listing 2.1 Cart.js
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 Cart.js
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now think about how you’d go about testing the `addToCart` function. One of
    the ways would be to integrate it into a real application and use it, but then
    we’d run into problems involving time, repeatability, and costs, as we mentioned
    in chapter 1.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何测试 `addToCart` 函数。一种方法是将它集成到实际应用程序中并使用它，但这样我们会遇到我们在第 1 章中提到的涉及时间、可重复性和成本的问题。
- en: Having to write an entire application before you can test your code requires
    too much code to be written before knowing whether it works. Additionally, if
    it doesn’t work, it will be challenging to spot bugs. A quicker way would be to
    write code that imports your `Cart`, uses its `addToCart` function, and validates
    the result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够测试你的代码之前，必须编写整个应用程序，这需要编写太多的代码，在知道它是否工作之前。此外，如果它不起作用，将很难找到错误。一种更快的方法是编写代码，导入你的
    `Cart`，使用其 `addToCart` 函数，并验证结果。
- en: Go on and write a `Cart.test.js` file that imports your `Cart`, uses its `addToCart`
    function, and checks whether a cart has the items you expected, as shown in listing
    2.2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编写一个 `Cart.test.js` 文件，导入你的 `Cart`，使用其 `addToCart` 函数，并检查购物车中是否有你预期的商品，如列表
    2.2 所示。
- en: Listing 2.2 Cart.test.js
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 Cart.test.js
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ If both checks have succeeded, prints a success message to the console
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果两个检查都成功，将在控制台打印成功信息
- en: ❷ If any of the tests failed, prints error messages
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果任何测试失败，将打印错误信息
- en: ❸ Creates a comma-separated list of the actual items in the cart to display
    in the test’s error message
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在测试的错误信息中创建一个以逗号分隔的实际商品列表以显示
- en: When you execute this file using `node` `Cart.test.js`, it will tell you whether
    your code can successfully add cheesecake to the cart—instant and precise feedback.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `node` 执行此文件 `Cart.test.js` 时，它会告诉你代码是否能够成功将芝士蛋糕添加到购物车中——即时且精确的反馈。
- en: Congratulations! You have just written your first test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经编写了你的第一个测试。
- en: A test sets up a scenario, executes the target code, and verifies whether the
    output matches what you expected. Because tests tend to follow this same formula,
    you can use tools to abstract away the testing specific concerns of your code.
    One of these concerns, for example, is comparing whether the actual output matches
    the expected output.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置一个场景，执行目标代码，并验证输出是否与预期相符。因为测试往往遵循这个相同的公式，所以你可以使用工具来抽象出代码的测试特定关注点。例如，这些关注点之一就是比较实际输出是否与预期输出匹配。
- en: Node.js itself ships with a built-in module, called `assert`, to do those checks,
    which, in the context of tests, we call *assertions*. It contains functions to
    compare objects and throw errors with meaningful messages if the actual output
    doesn’t match what you expected.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 本身带有一个内置模块，称为 `assert`，用于执行这些检查，在测试的上下文中，我们称之为 *断言*。它包含比较对象和如果实际输出与预期不符则抛出带有有意义信息的错误的功能。
- en: NOTE You can find the documentation for Node.js’s built-in `assert` library
    at [https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在 [https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html)
    找到 Node.js 内置 `assert` 库的文档。
- en: Use `assert`’s `deepStrictEqual` function to compare the actual output with
    the expected output and therefore shorten your test, as shown next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assert` 的 `deepStrictEqual` 函数来比较实际输出与预期输出，从而缩短测试，如下所示。
- en: Listing 2.3 Cart.test.js
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 Cart.test.js
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Compares the first and second arguments, and throws an insightful error if
    their values are different
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 比较第一个和第二个参数，如果它们的值不同，则抛出一个有洞察力的错误
- en: Using an assertion library enables you to get rid of the convoluted logic to
    determine whether objects are equal. It also generates meaningful output, so you
    don’t have to manipulate strings yourself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用断言库可以使你摆脱确定对象是否相等的复杂逻辑。它还会生成有意义的输出，因此你不必自己操作字符串。
- en: Try adding a new item to the array passed as the second argument to `assert
    .deepStrictEqual` so that you can see the kind of output it produces when an assertion
    fails.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试向作为`assert.deepStrictEqual`第二个参数传递的数组中添加一个新项目，以便你可以看到断言失败时它产生的输出类型。
- en: Now suppose you implement a `removeFromCart` function, as shown here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你实现了一个`removeFromCart`函数，如下所示。
- en: Listing 2.4 Cart.js
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 Cart.js
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How would you test it? Probably, you’d write something like the following code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何测试它？可能，你会写一些像以下这样的代码。
- en: Listing 2.5 Cart.test.js
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 Cart.test.js
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Adds an item to the cart
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向购物车添加项目
- en: ❷ Removes the recently added item
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 移除最近添加的项目
- en: ❸ Checks whether the cart’s items property is an empty array
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查购物车的项目属性是否为空数组
- en: 'First, your test sets up a scenario by adding a cheesecake to the cart. Then
    it calls the function you want to test (in this case, `removeFromCart`). Finally,
    it checks whether the content of the cart matches what you expected it to be.
    Again, the same formula: setup, execution, and verification. This sequence is
    also known as the three As pattern: *arrange, act, assert*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的测试通过向购物车添加芝士蛋糕来设置一个场景。然后它调用你想要测试的函数（在这种情况下，`removeFromCart`）。最后，它检查购物车的内容是否与你预期的相符。再次，同样的公式：设置、执行和验证。这个序列也被称为三个A模式：*安排（arrange）、行动（act）、断言（assert）*。
- en: Now that you have multiple tests, think about how you’d add them to your `Cart.test.js`.
    If you paste your new test right after the old one, it won’t run if the first
    test fails. You will also have to be careful to give variables in both tests different
    names. But, most importantly, it would become harder to read and interpret the
    output of each test. To be honest, it would be a bit of a mess.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有多个测试，考虑一下你如何将它们添加到你的`Cart.test.js`中。如果你直接在旧测试之后粘贴你的新测试，如果第一个测试失败，它将不会运行。你还将必须小心地为两个测试中的变量赋予不同的名称。但最重要的是，它将变得难以阅读和解释每个测试的输出。说实话，这会变得有些混乱。
- en: Test runners can solve this problem. They enable you to organize and run multiple
    tests in a comprehensive manner, providing meaningful and easily readable results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器可以解决这个问题。它们使你能够以综合的方式组织和运行多个测试，提供有意义的且易于阅读的结果。
- en: At the present moment, the most popular testing tool in the JavaScript ecosystem
    is called Jest. It is the main tool I’ll use throughout this book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在JavaScript生态系统中最受欢迎的测试工具被称为Jest。它是我在这本书中会使用的主要工具。
- en: Jest is a testing framework created at Facebook. It focuses on simplicity and,
    therefore, ships with everything you need to start writing tests straightaway.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是由Facebook创建的测试框架。它专注于简洁性，因此它包含了你开始编写测试所需的一切。
- en: Let’s install Jest so that we can write unit tests more concisely. Go ahead
    and install it globally with the command `npm install -g jest`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Jest，这样我们就可以更简洁地编写单元测试。使用命令`npm install -g jest`全局安装它。
- en: Without a configuration file, `jest.config.js`, or a `package.json` file, Jest
    will not run, so remember to add a `package.json` file to the folder that contains
    your code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有配置文件`jest.config.js`或`package.json`文件，Jest将不会运行，所以请记住将`package.json`文件添加到包含你的代码的文件夹中。
- en: TIP You can quickly add a default `package.json` file to a folder by running
    `npm init -y`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以通过运行`npm init -y`快速向文件夹添加默认的`package.json`文件。
- en: Now, instead of manually running your test file with Node.js, you will use Jest
    and tell it to load and execute tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将不再手动使用Node.js运行测试文件，而是使用Jest并告诉它加载和执行测试。
- en: NOTE By default, Jest loads all files ending in `.test.js`, `.spec.js`, or tests
    inside folders named `tests`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：默认情况下，Jest加载所有以`.test.js`、`.spec.js`结尾的文件，或者名为`tests`的文件夹内的测试。
- en: Prepare your tests for Jest to run by wrapping them into the `test` function
    that Jest adds to the global scope. You can use this function to organize multiple
    tests within a single file and indicate what should run. It takes the test’s name
    as its first argument and a callback function containing the actual test as the
    second argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它们封装到 Jest 添加到全局作用域的 `test` 函数中，为 Jest 运行测试准备你的测试。你可以使用此函数在单个文件中组织多个测试，并指示应该运行什么。它将测试的名称作为第一个参数，将包含实际测试的回调函数作为第二个参数。
- en: Once you have wrapped the previous tests into Jest’s `test` function, your `Cart.test.js`
    file should look like this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将之前的测试封装到 Jest 的 `test` 函数中，你的 `Cart.test.js` 文件应该看起来像这样。
- en: Listing 2.6 Cart.test.js
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 Cart.test.js
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Encapsulates the first test into a different namespace, isolating its variables
    and producing more readable output
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将第一个测试封装到不同的命名空间中，隔离其变量并生成更易读的输出
- en: '❷ Arrange: creates an empty cart'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安排：创建一个空购物车
- en: '❸ Act: exercises the addToCart function'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行：执行 `addToCart` 函数
- en: '❹ Assert: checks whether cart contains the newly added item'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：检查购物车是否包含新添加的项目
- en: ❺ Encapsulates the second test into a different namespace
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将第二个测试封装到不同的命名空间中
- en: '❻ Arrange: creates an empty cart, and adds an item to it'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 安排：创建一个空购物车，并向其中添加一个项目
- en: '❼ Act: exercises the removeFromCart function'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 执行：执行 `removeFromCart` 函数
- en: '❽ Assert: checks whether the cart is empty'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言：检查购物车是否为空
- en: Notice how you eliminated the previous `if` statements used to determine how
    to generate output by delegating that task to Jest. Whenever a test fails, Jest
    will provide you with a precise diff so that you can see how the actual output
    was different from what you expected. To see how much better Jest’s feedback is,
    try changing one of the assertions so that it fails.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你是如何通过委托该任务给 Jest 来消除之前用于确定如何生成输出的 `if` 语句的。每当测试失败时，Jest 都会提供精确的差异，以便你可以看到实际输出与预期输出有何不同。为了了解
    Jest 的反馈有多好，尝试更改一个断言使其失败。
- en: 'Finally, to avoid using anything but Jest for your tests, replace the `assert`
    library with Jest’s own alternative: `expect`. The `expect` module is just like
    Node.js’s `assert` module, but it’s tailored for Jest and helps it provide feedback
    that’s even more helpful.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了避免在测试中使用除 Jest 之外的其他任何东西，将 `assert` 库替换为 Jest 自带的替代品：`expect`。`expect`
    模块就像 Node.js 的 `assert` 模块一样，但它针对 Jest 进行了定制，有助于它提供更加有用的反馈。
- en: Like the `test` function, `expect` is available in the global scope when running
    tests within Jest. The `expect` function takes as an argument the actual subject
    of the assertion and returns an object that provides different *matcher* functions.
    These functions verify whether the actual value matches your expectations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `test` 函数一样，在 Jest 中运行测试时，`expect` 函数在全局范围内可用。`expect` 函数接受断言的实际主题作为参数，并返回一个对象，该对象提供了不同的
    *匹配器* 函数。这些函数验证实际值是否与你的期望相符。
- en: Jest’s equivalent to `deepStrictEqual` is `toEqual`. Replacing your first test’s
    `deepStrictEqual` with `toEqual` should lead you to code that looks similar to
    the following listing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 的 `deepStrictEqual` 等价于 `toEqual`。将第一个测试的 `deepStrictEqual` 替换为 `toEqual`
    应该会使你的代码看起来类似于以下列表。
- en: Listing 2.7 Cart.test.js
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 Cart.test.js
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Compares the value of the assertion’s target—the argument provided to expect—to
    the value of the argument passed to toEqual
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 比较 expect 的目标值（提供给 expect 的参数）与传递给 toEqual 的参数值
- en: Try eliminating the necessity to import Node.js’s `assert` library by replacing
    `deepStrictEqual` in the second test, too.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过在第二个测试中也替换 `deepStrictEqual` 来消除导入 Node.js 的 `assert` 库的必要性。
- en: Important There’s a difference between “strict” equality checks and “deep” equality
    checks. *Deep equality* verifies whether two different objects have equal values.
    *Strict equality* verifies whether two references point to the same object. In
    Jest, you perform deep equality checks using `toEqual`, and strict equality checks
    using `toBe`. Read Jest’s documentation for the `toEqual` matcher to learn more
    about how it works. It’s available at [https://jestjs.io/docs/en/expect#toequalvalue](https://jestjs.io/docs/en/expect#toequalvalue).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在“严格”相等检查和“深度”相等检查之间存在差异。“深度相等”验证两个不同的对象是否具有相等的值。“严格相等”验证两个引用是否指向同一个对象。在
    Jest 中，你使用 `toEqual` 执行深度相等检查，使用 `toBe` 执行严格相等检查。阅读 Jest 的文档了解 `toEqual` 匹配器的更多信息。它可在
    [https://jestjs.io/docs/en/expect#toequalvalue](https://jestjs.io/docs/en/expect#toequalvalue)
    找到。
- en: Up to now, you have been using a global installation of Jest to run your tests,
    which is *not* a good idea. If you are using an assertion that is available only
    in the latest version of Jest and one of your coworkers’ global installation is
    older than yours, tests may fail if the assertion’s behavior changed from one
    version to another.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直使用 Jest 的全局安装来运行你的测试，这并不是一个好主意。如果你使用的是仅在 Jest 最新版本中可用的断言，而你的某个同事的全局安装版本比你的旧，如果断言的行为从一个版本到另一个版本发生了变化，测试可能会失败。
- en: You want tests to fail only when there’s something wrong with your application,
    not when people are running different versions of a test framework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望测试只在应用程序出现问题时失败，而不是当人们运行不同版本的测试框架时。
- en: Solve this problem by running `npm install jest --save-dev` to install Jest
    as a `devDependency`. It should be a `devDependency` because it doesn’t need to
    be available when you ship your application. It needs to be available in developers’
    machines only so that they can execute tests after they download the project and
    run `npm install`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm install jest --save-dev` 来安装 Jest 作为 `devDependency` 解决这个问题。它应该是一个
    `devDependency`，因为它在你发布应用程序时不需要可用。它只需要在开发者的机器上可用，这样他们才能在下载项目并运行 `npm install`
    后执行测试。
- en: Once you run that command, you will see that your `package.json` file now lists
    a specific version of Jest within its `devDependencies`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行那个命令后，你会看到你的 `package.json` 文件现在列出了其 `devDependencies` 中的 Jest 的特定版本。
- en: NOTE Did you notice that the version of Jest within your `package.json` has
    `^` in front of it? That `^` indicates that when running `npm` `install`, NPM
    will install the latest `major` version of Jest. In other words, the leftmost
    version number will *not* change.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你注意到你的 `package.json` 中的 Jest 版本前面有一个 `^` 吗？这个 `^` 表示当运行 `npm install` 时，NPM
    将安装 Jest 的最新 `major` 版本。换句话说，最左边的版本号将不会改变。
- en: In theory, when following semantic versioning practices, any nonmajor upgrades
    should be backward-compatible, but, in reality, they are not always. To force
    NPM to install an exact version of Jest when running `npm` `install`, remove the
    `^`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，在遵循语义版本化实践的情况下，任何非主要升级都应该向后兼容，但现实中它们并不总是这样。要强制 NPM 在运行 `npm install` 时安装
    Jest 的确切版本，请删除 `^`。
- en: I highly recommend readers read more about what semantic versioning is and how
    it works. The website [https://semver.org](https://semver.org) is an excellent
    resource for that.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议读者了解更多关于语义版本化是什么以及它是如何工作的信息。[https://semver.org](https://semver.org) 是一个关于这个主题的优秀资源。
- en: Your project’s dependencies, including Jest, are available within the `node_modules`
    folder. You can run the specific version of Jest specified in your `package.json`
    by running its built version located in `node_modules/.bin/jest`. Go ahead and
    execute that file. You will see that it produces the same output as before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目依赖项，包括 Jest，都在 `node_modules` 文件夹中。你可以通过运行位于 `node_modules/.bin/jest` 的构建版本来运行你在
    `package.json` 中指定的 Jest 的特定版本。现在执行那个文件。你会看到它产生了与之前相同的输出。
- en: It’s still cumbersome to type the full path to your project’s Jest installation
    every time we want to run tests, though. To avoid that, edit your `package.json`
    file, and create a `test` script that executes the project’s Jest installation
    whenever you run the `npm test` command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，每次我们想要运行测试时，仍然需要输入项目 Jest 安装的完整路径，这仍然很麻烦。为了避免这种情况，编辑你的 `package.json` 文件，并创建一个
    `test` 脚本，这样每次运行 `npm test` 命令时都会执行项目的 Jest 安装。
- en: Add a `test` property under `scripts` in your `package.json`, and specify that
    it should run the `jest` command, as shown next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `package.json` 中的 `scripts` 下添加一个 `test` 属性，并指定它应该运行 `jest` 命令，如下所示。
- en: Listing 2.8 package.json
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.8 package.json
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Runs the project’s jest executable when running npm test
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当运行 npm test 时，会运行项目的 jest 可执行文件
- en: After creating this NPM script, whenever someone wants to execute your project’s
    tests, they can run `npm test`. They don’t need to know which tool you are using
    or worry about any other options they may need to pass to it. Whatever the command
    within the `package.jsontest` script is, it will run.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这个 NPM 脚本后，每当有人想要执行你的项目测试时，他们可以运行 `npm test`。他们不需要知道你使用的是哪个工具，也不必担心他们可能需要传递给它的任何其他选项。`package.json`
    中的 `test` 脚本内的任何命令都会运行。
- en: NOTE When you run a command defined in your `package.json` scripts, it spawns
    a new shell environment, which has `./node_modules/.bin` added to its `PATH` environment
    variable. Because of this `PATH`, you don’t need to prefix commands with `./node_modules/.bin`.
    By default, any installed libraries you have will be preferred.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你运行在 `package.json` 脚本中定义的命令时，它会启动一个新的 shell 环境，该环境将 `./node_modules/.bin`
    添加到其 `PATH` 环境变量中。因为这个 `PATH`，你不需要在命令前加上 `./node_modules/.bin` 前缀。默认情况下，你安装的任何库都将被优先考虑。
- en: As an exercise, I recommend adding more functions that manipulate items in the
    cart and writing tests for them using other Jest matchers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我建议添加更多操作购物车中项目的函数，并使用其他 Jest 匹配器为它们编写测试。
- en: Once you have added more tests, try refactoring the `Cart` class so that its
    methods don’t mutate the array referenced by a cart’s `items` property, and see
    if the tests still pass.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了更多的测试，尝试重构 `Cart` 类，使其方法不会修改由购物车的 `items` 属性引用的数组，并查看测试是否仍然通过。
- en: When refactoring, you want to ensure that you can shape your code differently
    while maintaining the same functionality. Therefore, having rigorous unit tests
    is a fantastic way to obtain quick and precise feedback during the process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构时，你想要确保你可以在保持相同功能的同时以不同的方式塑造你的代码。因此，拥有严格的单元测试是在重构过程中获得快速和精确反馈的绝佳方式。
- en: Unit tests help you iterate confidently, by providing quick feedback as you
    write code, as we will see in detail when we talk about test-driven development
    in chapter 9\. Because unit tests’ scope is limited to a function, their feedback
    is narrow and precise. They can immediately tell which function is failing. Strict
    feedback like this makes it faster to write and fix your code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通过在编写代码时提供快速反馈，帮助你自信地迭代，正如我们在第 9 章详细讨论测试驱动开发时将看到的。因为单元测试的范围仅限于一个函数，它们的反馈是狭窄且精确的。它们可以立即告诉哪个函数失败了。这样的严格反馈使得编写和修复代码更快。
- en: These tests are inexpensive and quick to write, but they cover only a small
    part of your application, and the guarantees they provide are weaker. Just because
    functions work in isolation for a few cases doesn’t mean your whole software application
    works, too. To get the most out of these narrow and inexpensive tests, you should
    write many of them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试成本低廉且易于编写，但它们只覆盖了你应用程序的一小部分，它们提供的保证较弱。仅仅因为函数在几个独立情况下工作良好，并不意味着你的整个软件应用程序也能工作。为了最大限度地利用这些狭窄且成本低的测试，你应该编写很多这样的测试。
- en: Considering that unit tests are numerous and inexpensive, and run quickly and
    frequently, we place these tests at the bottom of the testing pyramid, as figure
    2.5 shows. They’re the foundation other tests will build upon.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到单元测试数量众多且成本低廉，运行速度快且频繁，我们将这些测试放在测试金字塔的底部，如图 2.5 所示。它们是其他测试建立的基础。
- en: '![](../Images/CH02_F05_DaCosta.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F05_DaCosta.png)'
- en: Figure 2.5 Unit tests’ placement in the testing pyramid
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 测试金字塔中单元测试的位置
- en: 2.3 Integration tests
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 集成测试
- en: When looking at the application’s infrastructure diagram, you will see that
    the scope of integration tests, which is shown in figure 2.6, is broader than
    the scope of unit tests. They check how your functions interact and how your software
    integrates with third parties.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看应用程序的基础架构图时，你会看到集成测试的范围，如图 2.6 所示，比单元测试的范围更广。它们检查你的函数如何交互以及你的软件如何与第三方集成。
- en: '![](../Images/CH02_F06_DaCosta.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F06_DaCosta.png)'
- en: Figure 2.6 Integration tests’ scope
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 集成测试的范围
- en: Integration tests help you ensure that the different parts of your software
    can work together. For example, they help you validate whether your software communicates
    appropriately with third-party RESTful APIs, or whether it can manipulate items
    in a database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试帮助你确保你的软件的不同部分可以协同工作。例如，它们帮助你验证你的软件是否适当地与第三方 RESTful API 通信，或者它是否可以操作数据库中的项目。
- en: 'Let’s start by creating one of the most classic examples of an integration
    test: a test that talks to a database. For the examples in this section, I’ll
    use the `knex` and `sqlite3` packages. Knex is a query builder that can act on
    top of `sqlite3`. Knex will make it easier for you to interface with a `sqlite3`
    database. Because these two packages need to be available when the application
    runs, you must install them as dependencies instead of dev dependencies. Go ahead
    and do that by running `npm` `install` `--save knex` `sqlite3`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建最经典的集成测试示例之一开始：一个与数据库通信的测试。在本节的示例中，我将使用 `knex` 和 `sqlite3` 包。Knex 是一个查询构建器，可以在
    `sqlite3` 之上操作。Knex 将使您更容易与 `sqlite3` 数据库接口。因为这两个包需要在应用程序运行时可用，所以您必须将它们作为依赖项而不是开发依赖项安装。请运行
    `npm install --save knex sqlite3` 来完成此操作。
- en: NOTE By default, NPM will save those packages and automatically add them as
    dependencies. You can make this explicit by appending the `--save` option to the
    `install` command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：默认情况下，NPM 将保存这些包并自动将它们添加为依赖项。您可以通过在 `install` 命令后附加 `--save` 选项来使此操作明确。
- en: Put your database’s configuration in a file named `knexfile.js` in the root
    of your project. It should have the following content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的数据库配置放在项目根目录下名为 `knexfile.js` 的文件中。它应该包含以下内容。
- en: Listing 2.9 knexfile.js
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 knexfile.js
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Uses sqlite3 as the database client
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 sqlite3 作为数据库客户端
- en: ❷ Specifies the file in which the database will store its data
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定数据库将存储其数据文件的文件
- en: ❸ Uses NULL instead of DEFAULT for undefined keys
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 NULL 而不是 DEFAULT 为未定义的键
- en: Instead of just using a class `Cart`, as you’ve done in the previous chapter,
    this time you’ll create a table containing a cart’s `id` and its owner’s name.
    Then, you’ll create a separate table to store the items in each cart.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在上一章中使用的 `Cart` 类不同，这次您将创建一个包含购物车 `id` 和其所有者名称的表。然后，您将创建一个单独的表来存储每个购物车中的项目。
- en: NOTE Because this book is about tests and not about databases, I’ve opted for
    the most straightforward possible database design. To learn more about database
    systems, I’d highly recommend *Fundamentals of Database Systems*, written by Ramez
    Elmasri and Shamkant B. Navathe (Pearson, 2016).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：因为这本书是关于测试而不是数据库，所以我选择了最简单的数据库设计。要了解更多关于数据库系统，我强烈推荐由 Ramez Elmasri 和 Shamkant
    B. Navathe 编写的《数据库系统基础》（Pearson，2016）。
- en: When using Knex, you define the structure of your tables through `migrations`.
    Knex uses a database table to keep track of the migrations that have already run
    and the new ones. It uses those records to guarantee that your database always
    has a current schema.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Knex 时，您通过 `migrations` 定义您表的结构。Knex 使用一个数据库表来跟踪已运行的迁移和新迁移。它使用这些记录来确保您的数据库始终具有当前的模式。
- en: Create an empty migration using your project’s installation of Knex by running
    `./node_modules/.bin/knex` `migrate:make` `--env` `development` `create_carts`.
    This command creates a file whose name starts with the current time and ends with
    `create_carts.js` in the `migrations` directory. Use the code below to create
    the `carts` and `cart_items` tables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `./node_modules/.bin/knex migrate:make --env development create_carts`
    创建一个空迁移，使用您的项目安装的 Knex。此命令将在 `migrations` 目录中创建一个以当前时间开始并以 `create_carts.js` 结尾的文件。使用以下代码创建
    `carts` 和 `cart_items` 表。
- en: Listing 2.10 CURRENTTIMESTAMP_create_carts.js
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 CURRENTTIMESTAMP_create_carts.js
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ The exported up function migrates the database to the next state.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导出的 up 函数将数据库迁移到下一个状态。
- en: ❷ Creates a table for the application’s carts containing a username column and
    an id column that autoincrements
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为应用程序的购物车创建一个包含用户名列和自动递增的 id 列的表
- en: ❸ Creates a carts_items table that will keep track of the items in each cart
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个用于跟踪每个购物车中项目的 carts_items 表
- en: ❹ Creates a cartId column that references a cart’s id in the carts table
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个引用 carts 表中购物车 id 的 cartId 列
- en: ❺ The exported down function migrates the database to the previous state, deleting
    the carts and carts_items tables.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 导出的 down 函数将数据库迁移到之前的状态，删除购物车和 carts_items 表。
- en: To execute all the migrations in the `migrations` folder, run `./node_modules/.bin/knex
    migrate:latest`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 `migrations` 文件夹中的所有迁移，请运行 `./node_modules/.bin/knex migrate:latest`。
- en: Now you can finally create a module with methods to add items to your SQLite
    database, as shown next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您最终可以创建一个模块，其中包含向您的 SQLite 数据库添加项的方法，如下所示。
- en: Listing 2.11 dbConnection.js
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 dbConnection.js
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Sets up a connection pool for the development database
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为开发数据库设置连接池
- en: ❷ Tears down the connection pool
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断开连接池
- en: Listing 2.12 cart.js
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 cart.js
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Inserts a row in the carts table
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在购物车表中插入一行
- en: ❷ Inserts a row in the carts_items table referencing the cartId passed
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在`carts_items`表中插入一行，引用传递的cartId
- en: Try to import the `createCart` and `addItem` function in another file and use
    them to add items to your local `sqlite` database. Don’t forget to use `closeConnection`
    to disconnect from the database once you’re done; otherwise, your program will
    never terminate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在另一个文件中导入`createCart`和`addItem`函数，并使用它们向你的本地`sqlite`数据库添加项目。完成操作后，别忘了使用`closeConnection`断开与数据库的连接；否则，你的程序将永远不会终止。
- en: To test the functions in the `cart.js` module, you can follow a pattern similar
    to the one we used in chapter 1\. First, you set up a scenario. Then you call
    the function you want to test. And, finally, you check whether it produced the
    desired results.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`cart.js`模块中的功能，你可以遵循与我们在第1章中使用类似的模式。首先，你设置一个场景。然后调用你想要测试的函数。最后，检查它是否产生了预期的结果。
- en: After installing Jest as a `devDependency`, write a test for `createCart`. It
    should ensure that the database is clean, create a cart, and then check if the
    database contains the cart you’ve just created.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Jest作为`devDependency`安装后，为`createCart`编写一个测试。它应该确保数据库是干净的，创建一个购物车，然后检查数据库是否包含你刚刚创建的购物车。
- en: Listing 2.13 cart.test.js
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 cart.test.js
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Deletes every row in the carts table
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除购物车表中的每一行
- en: ❷ Selects value in the username column for all the items in the carts table
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择购物车表中所有项目的用户名列的值
- en: ❸ Tears down the connection pool
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断开连接池
- en: This time, you have asynchronous functions that you need to wait for by using
    `await`. Having to use `await` will cause you to make the function passed to Jest’s
    `test` an `async` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你有异步函数需要通过使用`await`来等待。需要使用`await`将导致你将传递给Jest的`test`函数的函数变为`async`函数。
- en: Whenever a test returns a promise—as `async` functions do—it will wait for the
    promise to resolve before marking the test as finished. If the returned promise
    is rejected, the test fails automatically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每当测试返回一个promise——就像`async`函数做的那样——它将等待promise解决，然后再将测试标记为完成。如果返回的promise被拒绝，测试将自动失败。
- en: An alternative to returning a promise is to use the `done` callback provided
    by Jest. When calling `done`, the test will be finished, as shown here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 返回promise的另一种选择是使用Jest提供的`done`回调。当调用`done`时，测试将完成，如下所示。
- en: Listing 2.14 cart.test.js
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 cart.test.js
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Deletes every row in the carts table, and returns a promise on which you’ll
    explicitly chain other actions
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除购物车表中的每一行，并返回一个你将显式链式其他操作的promise
- en: ❷ Tears down the connection pool
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断开连接池
- en: ❸ Finishes the test
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 完成测试
- en: I think it’s way uglier, but it works, too.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这看起来更丑，但它也能工作。
- en: Warning Be careful when adding the `done` parameter to your test functions.
    If you forget to call it, your tests will fail due to a timeout. Calling `done`
    with a truthy argument will also cause your test to fail. Even if you return a
    promise from a test that takes `done` as an argument, your test will terminate
    only when `done` is invoked.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在将`done`参数添加到测试函数时要小心。如果你忘记调用它，你的测试会因为超时而失败。使用真值参数调用`done`也会导致你的测试失败。即使你从接受`done`作为参数的测试中返回一个promise，你的测试也只有在`done`被调用时才会终止。
- en: Add tests for the `addItem` function now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为`addItem`函数添加测试。
- en: Listing 2.15 cart.test.js
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 cart.test.js
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Selects all the rows in the carts table whose username column matches the
    username used for the test
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 选择购物车表中用户名列与测试中使用的用户名匹配的所有行
- en: If you execute both tests, you will run into an error. The error says that the
    second test was “unable to acquire a connection” to the database. It happens because,
    once the first test finishes, it closes the connection pool by calling `closeConnection`.
    To avoid this error, we must ensure that `closeConnection` is called only *after*
    all tests have run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这两个测试，你会遇到一个错误。错误说第二个测试“无法获取数据库连接”。这是因为一旦第一个测试完成，它就会通过调用`closeConnection`关闭连接池。为了避免这种错误，我们必须确保仅在所有测试运行之后才调用`closeConnection`。
- en: Because it’s quite common to perform this sort of cleanup operation once tests
    run, Jest has hooks called `afterEach` and `afterAll`. These hooks are available
    on the global scope. They take, as arguments, functions to execute either after
    each test or after all tests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在测试运行后执行此类清理操作相当常见，Jest提供了名为`afterEach`和`afterAll`的钩子。这些钩子在全局范围内可用。它们接受作为参数的函数，这些函数将在每个测试之后或所有测试之后执行。
- en: Let’s add an `afterAll` hook to close the connection pool only after all tests
    have run and remove the invocation of `closeConnection` from within the test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在所有测试运行完毕后添加一个`afterAll`钩子来关闭连接池，并从测试内部移除对`closeConnection`的调用。
- en: Listing 2.16 cart.test.js
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 cart.test.js
- en: '[PRE15]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Tears down the connection pool once all tests have finished, returning a promise
    so that Jest knows when the hook is done
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在所有测试完成后拆毁连接池，返回一个promise以便Jest知道钩子何时完成
- en: Jest also provides `beforeAll` and `beforeEach` hooks, shown in listing 2.17\.
    Because both of your tests need to clean the database before they run, you can
    encapsulate that behavior into a `beforeEach` hook. If you do this, there’s no
    need to repeat those `truncate` statements on every test.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Jest还提供了`beforeAll`和`beforeEach`钩子，如列表2.17所示。因为你的所有测试在运行之前都需要清理数据库，所以你可以将这种行为封装到`beforeEach`钩子中。如果你这样做，就无需在每个测试中重复那些`truncate`语句。
- en: Listing 2.17 cart.test.js
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 cart.test.js
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Clears the carts and carts_items tables before each test
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前清除carts和carts_items表
- en: These tests help ensure that *your* code works and that the APIs you’re using
    behave as you expect. If you had any incorrect queries, but they were still valid
    SQL queries, these tests would catch it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试有助于确保*你的*代码能够正常工作，以及你使用的API表现如你所预期。如果你有任何错误的查询，但它们仍然是有效的SQL查询，这些测试会捕捉到它们。
- en: Like the term “unit testing,” “integration testing” means different things to
    different people. As I’ve mentioned before, I recommend you not get too hung up
    on labels. Instead, think of how big the scope of your test is. The larger its
    scope, the higher it fits in the pyramid. Whether you call it an “integration”
    test or an “end-to-end” test doesn’t matter *that* much. The important thing is
    to remember that the bigger the test’s scope, the stronger the quality guarantee
    it provides, but the longer it takes to run and the less of it you need.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“单元测试”这个术语一样，“集成测试”对不同的人来说意味着不同的事情。正如我之前提到的，我建议你不要过于纠结于标签。相反，考虑你的测试范围有多大。范围越大，它在金字塔中的位置就越高。无论你称之为“集成”测试还是“端到端”测试，其实并没有那么重要。重要的是要记住，测试的范围越大，它提供的质量保证就越强，但运行时间就越长，需要的数量就越少。
- en: Considering the characteristics of unit tests, they’d go in the middle of the
    pyramid, as shown in figure 2.7.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到单元测试的特点，它们应该位于金字塔的中间，如图2.7所示。
- en: '![](../Images/CH02_F07_DaCosta.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 DaCosta](../Images/CH02_F07_DaCosta.png)'
- en: Figure 2.7 Integration tests’ placement in the testing pyramid
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 测试金字塔中集成测试的位置
- en: You should write integration tests whenever it’s fundamental to ensure that
    multiple parts of your program can work together or that they integrate correctly
    with third-party software.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当确保你的程序中的多个部分能够协同工作或正确集成第三方软件是基本要求时，你应该编写集成测试。
- en: If you are using a library like React, for example, your software must integrate
    appropriately with it. The way React behaves is essential to how your application
    does, so you must test your code in integration with React. The same is valid
    for interacting with a database or with a computer’s filesystem. You rely on how
    those external pieces of software work, and, therefore, it’s wise to check if
    you’re using them correctly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用像React这样的库，你的软件必须适当地与之集成。React的行为对于你的应用程序来说至关重要，因此你必须与React一起测试你的代码。同样的原则也适用于与数据库或计算机文件系统的交互。你依赖于这些外部软件的工作方式，因此检查你是否正确使用它们是明智的。
- en: This kind of test provides substantial value because it helps you verify whether
    *your* code does what you expect and whether the libraries you use do, too. Nonetheless,
    it’s important to highlight that the goal of an integration test is *not* to test
    any third-party pieces of software themselves. The purpose of an integration test
    is to check whether *you* are interacting with them correctly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试提供了很大的价值，因为它帮助你验证*你的*代码是否按预期工作，以及你使用的库是否也是如此。尽管如此，重要的是要强调，集成测试的目标*不是*测试任何第三方软件本身。集成测试的目的是检查*你*是否正确地与之交互。
- en: If you are using a library to make HTTP requests, for example, you should *not*
    write tests for that library’s `get` or `post` methods. You should write tests
    to see if *your* software uses those methods correctly. Testing the request library
    is their author’s responsibility, not yours. And, if their authors didn’t write
    tests, it’s probably better to reconsider its adoption.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个库来发送HTTP请求，例如，你不应该为该库的`get`或`post`方法编写测试。你应该编写测试来查看你的软件是否正确地使用了这些方法。测试请求库是作者的责任，而不是你的。而且，如果他们的作者没有编写测试，那么重新考虑其采用可能更好。
- en: Isolating your code in unit tests can be great for writing quick and simple
    tests, but unit tests can’t guarantee that you are using other pieces of software
    as you’re supposed to.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中将你的代码隔离出来可以非常有利于编写快速简单的测试，但单元测试不能保证你像预期的那样使用其他软件组件。
- en: We will talk more about the trade-offs between more isolated versus more integrated
    tests in chapter 3\.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第3章中更多地讨论更隔离的测试与更集成测试之间的权衡。
- en: 2.4 End-to-end tests
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 端到端测试
- en: End-to-end tests are the most coarse tests. These tests validate your application
    by interacting with it as your users would.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是最粗粒度的测试。这些测试通过以用户的方式与应用程序交互来验证你的应用程序。
- en: They don’t use your software’s code directly as unit tests do. Instead, end-to-end
    tests interface with it from an external perspective. If it’s possible to use
    a button or access a page instead of calling a function or checking the database,
    they’ll do it. By taking this highly decoupled approach, they end up covering
    a large surface of the application, as shown in figure 2.8\. They rely on the
    client side working as well as all the pieces of software in the backend.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不会像单元测试那样直接使用你的软件代码。相反，端到端测试从外部角度与之交互。如果可能使用按钮或访问页面而不是调用函数或检查数据库，他们会这样做。通过采取这种高度解耦的方法，他们最终覆盖了应用程序的大部分区域，如图2.8所示。他们依赖于客户端的正常工作以及后端所有软件组件的正常工作。
- en: '![](../Images/CH02_F08_DaCosta.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F08_DaCosta.png)'
- en: Figure 2.8 End-to-end tests’ scope
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 端到端测试的范围
- en: An end-to-end test to validate whether it’s possible to add an item to the cart
    wouldn’t directly call the `addToCart` function. Instead, it would open your web
    application, click the buttons with “Add to Cart” written on them, and then check
    the cart’s content by accessing the page that lists its items. A test like this
    goes at the very top of the testing pyramid.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证是否可以添加商品到购物车的端到端测试不会直接调用`addToCart`函数。相反，它会打开你的Web应用程序，点击上面写着“添加到购物车”的按钮，然后通过访问列出其商品的页面来检查购物车的内容。这样的测试在测试金字塔的顶部。
- en: Even the REST API for this application can have its own end-to-end tests. An
    end-to-end test for your store’s backend would send an HTTP request to add items
    to the cart and then another to get its contents. This test, however, fits below
    the previous one in the testing pyramid because it covers *only* the API. Testing
    an application using its GUI has a broader scope because it comprises both the
    GUI and the API to which it sends requests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是此应用程序的REST API也可以有自己的端到端测试。对你的商店后端进行的端到端测试会发送一个HTTP请求来添加商品到购物车，然后发送另一个请求来获取其内容。然而，这个测试在测试金字塔中位于上一个测试之下，因为它只覆盖了*仅*API。使用其GUI测试应用程序的范围更广，因为它包括GUI以及它发送请求的API。
- en: Again, I’d like to reinforce that labeling tests as end-to-end, integration,
    or unit tests is not our primary goal. The testing pyramid serves to orient us
    on the role, value, and frequency of tests. What the placement of end-to-end tests
    in the pyramid (figure 2.9) tells us about this type of tests is that they’re
    very valuable and that you need a smaller quantity of them. Just a few can already
    cover large parts of your application. In contrast, unit tests focus on a single
    function and, therefore, need to be more frequent.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，将测试标记为端到端、集成或单元测试不是我们的主要目标。测试金字塔旨在帮助我们了解测试的角色、价值和频率。端到端测试在金字塔（图2.9）中的位置告诉我们，这类测试非常有价值，并且你需要较少的数量。只需几个就可以覆盖你应用程序的大部分区域。相比之下，单元测试关注单个函数，因此需要更频繁地进行。
- en: '![](../Images/CH02_F09_DaCosta.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F09_DaCosta.png)'
- en: Figure 2.9 End-to-end tests’ placement in the testing pyramid
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 端到端测试在测试金字塔中的位置
- en: End-to-end tests avoid using any private parts of your application, so they
    resemble your users’ behavior very closely. The more your tests resemble a user
    interacting with your application, the more confidence they give you. Because
    end-to-end automated tests most closely simulate real use-case scenarios, they
    provide the most value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试避免使用应用程序的任何私有部分，因此它们非常接近用户的操作。你的测试越接近用户与你的应用程序交互，它们给你的信心就越大。因为端到端自动化测试最接近模拟真实用例场景，所以它们提供了最大的价值。
- en: NOTE In testing lingo, tests that don’t know about an application’s internals
    are called *black box* tests. Tests that do are called *white box* tests.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 在测试术语中，不了解应用程序内部结构的测试被称为*黑盒测试*。了解应用程序内部结构的测试被称为*白盒测试*。'
- en: Tests don’t necessarily need to fit entirely in one category or another. The
    less they rely on an application’s implementation details, the more “black box”
    they are. The opposite is valid for more “white box” tests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不一定完全属于一个或另一个类别。它们越少依赖于应用程序的实现细节，它们就越像是“黑盒”。相反，对于更“白盒”的测试，情况也是如此。
- en: These tests also tend to take more time to run and, therefore, run less frequently.
    Differently from unit tests, it’s not feasible to run end-to-end tests whenever
    you save a file. End-to-end tests are more suited for a later stage of the development
    process. They can help you by thoroughly checking whether your application’s features
    will work for your customers before allowing developers to merge pull requests
    or perform deployments, for example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试通常需要更多的时间来运行，因此运行频率较低。与单元测试不同，每次保存文件时运行端到端测试是不可行的。端到端测试更适合开发过程的后期阶段。它们可以通过彻底检查应用程序的功能是否适用于客户，在允许开发者合并拉取请求或执行部署之前提供帮助。
- en: 2.4.1 Testing HTTP APIs
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 测试HTTP API
- en: Because tests for RESTful APIs require only a client capable of performing HTTP
    requests and inspecting responses, we can write them within Jest. In these examples,
    you will use `isomorphic-fetch` to perform HTTP requests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对RESTful API的测试只需要一个能够执行HTTP请求并检查响应的客户端，我们可以在Jest中编写它们。在这些示例中，你将使用`isomorphic-fetch`来执行HTTP请求。
- en: These tests will cover the entire backend of your application, as well as the
    HTTP API it exposes, as shown in figure 2.10.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试将涵盖应用程序的整个后端，以及它暴露的HTTP API，如图2.10所示。
- en: '![](../Images/CH02_F10_DaCosta.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F10_DaCosta.png)'
- en: Figure 2.10 The scope of tests that address your backend through its HTTP API
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 通过HTTP API解决后端问题的测试范围
- en: You need Jest and `isomorphic-fetch` only for your tests, not for your application’s
    runtime, so install them as dev dependencies.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要Jest和`isomorphic-fetch`来编写测试，而不是应用程序的运行时，所以将它们作为开发依赖项安装。
- en: 'The web framework you are going to use to build your API is Koa. It is simple,
    effective, and small. It’s ideal for what we want to do in this book: focus on
    tests. Because Koa doesn’t ship with a router, you will also need to install `koa-router`
    to map different requests to different actions.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要使用的构建API的Web框架是Koa。它简单、有效且小巧。它非常适合我们在本书中想要做的事情：专注于测试。因为Koa没有自带路由器，所以你还需要安装`koa-router`来将不同的请求映射到不同的操作。
- en: 'Our server will have two routes: one to add items to the cart and one to remove
    items from it. To add items to a cart, clients must send requests containing an
    array of items in its body to `POST /carts/:username/items/:item`. To retrieve
    the cart’s content, they must send a request to `GET /carts/:username/items`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将有两个路由：一个用于向购物车添加项目，另一个用于从购物车中移除项目。要向购物车添加项目，客户端必须向`POST /carts/:username/items/:item`发送包含项目数组的请求体。要检索购物车的商品内容，他们必须向`GET
    /carts/:username/items`发送请求。
- en: To make this test as simple as possible, avoid touching the database for now.
    Focus on writing tests, and keep the state of the users’ carts in memory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个测试尽可能简单，目前请避免接触数据库。专注于编写测试，并保持用户购物车状态在内存中。
- en: The following code will start a server on port `3000`. This server can add and
    retrieve a cart’s items.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在端口`3000`上启动一个服务器。这个服务器可以添加和检索购物车的商品。
- en: Listing 2.18 server.js
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.18 server.js
- en: '[PRE17]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The Map that stores the application’s state
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储应用程序状态的Map
- en: ❷ Handles requests to GET /carts/:username/items, listing the items in a user’s
    cart
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理对GET /carts/:username/items的请求，列出用户的购物车中的商品
- en: ❸ If the cart has been found, the application responds with a 200 status and
    the cart found. Otherwise, it responds with a 404 status.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果购物车已被找到，应用程序将返回200状态码和找到的购物车。否则，它将返回404状态码。
- en: ❹ Handles requests to POST /carts/:username/items/:item, adding items to a user’s
    cart
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 处理向 POST /carts/:username/items/:item 发送的请求，向用户的购物车添加项目
- en: ❺ Responds with the cart’s new content
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回购物车的新内容
- en: ❻ Attaches the routes to the Koa instance
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将路由附加到 Koa 实例
- en: ❼ Binds the server to port 3000
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将服务器绑定到端口 3000
- en: NOTE I have chosen Koa and `koa-router` because they are popular and have intuitive
    APIs. If you are not familiar with Koa or `koa-router`, you can find documentation
    at [https://koajs.com](https://koajs.com) and [https://github.com/ZijianHe/koa-router](https://github.com/ZijianHe/koa-router).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我选择了 Koa 和 `koa-router`，因为它们很受欢迎，并且 API 直观。如果你不熟悉 Koa 或 `koa-router`，你可以在
    [https://koajs.com](https://koajs.com) 和 [https://github.com/ZijianHe/koa-router](https://github.com/ZijianHe/koa-router)
    找到文档。
- en: If you feel more comfortable with another framework, like Express or NestJS,
    don’t hesitate to use it. End-to-end tests shouldn’t care about how you implement
    a server as long as your implementation provides the same output given the same
    requests.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更熟悉其他框架，如 Express 或 NestJS，请不要犹豫，使用它。端到端测试不应该关心你如何实现服务器，只要你的实现对于相同的请求提供相同的输出即可。
- en: End-to-end tests care only about your application from a user’s point of view.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试只关心从用户的角度来看你的应用程序。
- en: Now, write a test that uses HTTP requests to add items to a cart and check the
    cart’s contents.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写一个使用 HTTP 请求添加项目到购物车并检查购物车内容的测试。
- en: 'Even though you are making HTTP requests instead of calling functions, the
    general formula for your tests should be the same: *arrange*, *act*, *assert*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你正在发送 HTTP 请求而不是调用函数，你的测试的一般公式应该是相同的：*arrange*，*act*，*assert*。
- en: To make it easier to perform requests, you can add the following helper functions
    to your tests.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易执行请求，你可以在测试中添加以下辅助函数。
- en: Listing 2.19 server.test.js
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 server.test.js
- en: '[PRE18]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Sends POST requests to the route that adds items to a user’s cart
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 向添加用户购物车项目的路由发送 POST 请求
- en: ❷ Sends GET requests to the route that lists the contents of a user’s carts
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向列出用户购物车内容的路由发送 GET 请求
- en: After adding these helper functions, you can go ahead and use them in the test
    itself, making it shorter than it would be otherwise.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些辅助函数之后，你就可以在测试本身中使用它们，使测试比其他方式更短。
- en: Listing 2.20 server.test.js
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.20 server.test.js
- en: '[PRE19]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Lists the items in a user’s cart
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出用户的购物车中的项目
- en: ❷ Checks whether the response’s status is 404
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查响应的状态是否为 404
- en: ❸ Sends a request to add an item to a user’s cart
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向用户购物车添加项目的请求
- en: ❹ Checks whether the server responded with the cart’s new contents
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查服务器是否响应了购物车的新内容
- en: ❺ Sends another request to list the items in the user’s cart
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 再次发送请求以列出用户的购物车中的项目
- en: ❻ Checks whether the server’s response includes the item you’ve added
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查服务器的响应是否包含你添加的项目
- en: Run this test, and see what happens. You will notice that the test passes but
    Jest doesn’t exit. To detect what caused this, you can use Jest’s `detectOpenHandles`
    option. When running Jest with this flag, it will tell you what prevented your
    tests from exiting.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试，看看会发生什么。你会注意到测试通过了，但 Jest 没有退出。为了检测导致这种情况的原因，你可以使用 Jest 的 `detectOpenHandles`
    选项。当使用此标志运行 Jest 时，它会告诉你什么阻止了你的测试退出。
- en: NOTE If you are using an NPM script to run Jest, as we’ve done before, add `--`
    to it and then all the options you want to pass to the script. To pass `--detectOpenHandles`
    to Jest through your NPM script, for example, you need to run `npm test -- --detectOpenHandles`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你使用 NPM 脚本来运行 Jest，就像我们之前做的那样，请向其中添加 `--` 并然后添加你想要传递给脚本的选项。例如，要将 `--detectOpenHandles`
    传递给 Jest，你需要运行 `npm test -- --detectOpenHandles`。
- en: When you use this option, Jest will warn you that the problem comes from `app
    .listen`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用此选项时，Jest 会警告你说问题来自 `app .listen`。
- en: '[PRE20]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have started your server before your tests run, but you didn’t stop it when
    they finished!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你在测试运行之前启动了服务器，但在测试完成后没有停止它！
- en: To avoid tests that never exit, Jest allows you to use the `forceExit` option.
    If you add that to the NPM script that runs Jest, as shown next, you can guarantee
    that the tests will **always** exit when running `npm test`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免测试永远不退出，Jest 允许你使用 `forceExit` 选项。如果你将此选项添加到运行 Jest 的 NPM 脚本中，如以下所示，你可以确保在运行
    `npm test` 时测试将**总是**退出。
- en: Listing 2.21 package.json
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.21 package.json
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Runs the project’s jest executable, including the forceExit option
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行项目的 jest 可执行文件，包括 forceExit 选项
- en: A more elegant way to avoid tests hanging is to stop your server after they
    finish. Koa allows you to close your server by calling its `close` method. Adding
    an `afterAll` hook that invokes `app.close` should be enough to make your tests
    exit graciously.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 避免测试挂起的一个更优雅的方法是在它们完成后停止服务器。Koa 允许你通过调用其 `close` 方法来关闭你的服务器。添加一个调用 `app.close`
    的 `afterAll` 钩子应该足以使你的测试优雅地退出。
- en: Listing 2.22 server.test.js
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.22 server.test.js
- en: '[PRE22]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Stops the server after all tests finish
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有测试完成后停止服务器
- en: If you clean up your open handles, you won’t need to use the `forceExit` option.
    Avoiding this option is wiser because it allows you to ensure that the application
    is not holding any external resources, such as a database connection.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你清理了你的打开句柄，你就不需要使用 `forceExit` 选项。避免这个选项更明智，因为它允许你确保应用程序没有持有任何外部资源，例如数据库连接。
- en: As an exercise, add a route to remove items from the cart, and then write a
    test for it. Don’t forget that because your server keeps its state in memory,
    you must clean it up before each test. If you need assistance to figure out how
    to do that, have a look at the repository with the book’s examples at [https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)
    to find the complete solution.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，添加一个从购物车中删除项目的路由，然后为它编写一个测试。别忘了，因为你的服务器将状态保存在内存中，你必须在每次测试之前清理它。如果你需要帮助来弄清楚如何做到这一点，请查看包含本书示例的存储库[https://github.com/lucasfcosta/testing-javascript-applications](https://github.com/lucasfcosta/testing-javascript-applications)，以找到完整的解决方案。
- en: Writing tests for an HTTP API is excellent for ensuring that services follow
    the established “contracts.” When multiple teams have to develop different services,
    these services must have well-defined communication standards, which you can enforce
    through tests. Tests will help prevent services from not being able to talk to
    each other.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为 HTTP API 编写测试是确保服务遵循既定“契约”的绝佳方法。当多个团队必须开发不同的服务时，这些服务必须具有明确定义的通信标准，你可以通过测试来强制执行这些标准。测试将帮助防止服务之间无法通信。
- en: The scope of tests for HTTP APIs is broad, but it is still narrower than the
    scope of tests that target GUIs. Tests that comprise GUIs examine the entire application,
    whereas tests for HTTP APIs only probe its backend. Because of this difference
    in scope, we will subdivide the area for end-to-end tests in the testing pyramid
    and place HTTP API tests below GUI tests, as you can see in figure 2.11\.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP API 测试的范围很广，但仍然比针对 GUI 的测试范围窄。包含 GUI 的测试检查整个应用程序，而 HTTP API 的测试仅探测其后端。由于这种范围上的差异，我们将测试金字塔中的端到端测试区域细分，并将
    HTTP API 测试放在 GUI 测试之下，如图 2.11 所示。
- en: '![](../Images/CH02_F11_DaCosta.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F11_DaCosta.png)'
- en: Figure 2.11 HTTP APIs tests’ placement in the testing pyramid
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 HTTP API 测试在测试金字塔中的位置
- en: 2.4.2 Testing GUIs
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 测试 GUI
- en: GUI tests cover your entire application. They will use its client to interact
    with your backend, therefore, touching every single piece of your stack, as figure
    2.12 illustrates.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 测试覆盖你的整个应用程序。它们将使用其客户端与后端交互，因此会触及你的堆栈的每一块，如图 2.12 所示。
- en: '![](../Images/CH02_F12_DaCosta.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH02_F12_DaCosta.png)'
- en: Figure 2.12 GUI tests’ scope
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 GUI 测试的范围
- en: Writing end-to-end tests for GUIs involves particular requirements and, therefore,
    requires special tools.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 GUI 的端到端测试涉及特定的要求，因此需要特殊的工具。
- en: Tools for end-to-end testing GUIs need to be capable of interacting with a web
    page’s elements, like buttons and forms. Because of these demands, they need to
    be able to control a real browser. Otherwise, the tests will not simulate the
    user’s actions precisely.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 用于端到端测试 GUI 的工具需要能够与网页元素（如按钮和表单）交互。由于这些要求，它们需要能够控制真实浏览器。否则，测试将无法精确地模拟用户的行为。
- en: At the moment, the most popular tools for UI testing are Cypress, TestCafe,
    and Selenium. It’s possible to use these tools to make a browser interact with
    your application by using JavaScript to control them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，最流行的 UI 测试工具是 Cypress、TestCafe 和 Selenium。你可以使用这些工具通过 JavaScript 控制它们，使浏览器与你的应用程序交互。
- en: The overall structure of UI tests is similar to the types of tests we have already
    seen. UI tests still require you to set up a scenario, perform actions, and then
    do assertions. The main difference between UI tests and other types of tests is
    that instead of merely calling functions or performing requests, your actions
    happen through the browser and assertions depend on a web page’s content.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: UI测试的整体结构与我们已经看到的测试类型相似。UI测试仍然需要你设置场景、执行操作，然后进行断言。UI测试与其他类型测试的主要区别在于，你的操作不是仅仅调用函数或执行请求，而是通过浏览器进行，断言依赖于网页的内容。
- en: Even though the general three As pattern for tests applies to UI tests, the
    very process of setting up an environment for tests to run tends to be more complicated,
    especially if you need to spin up an entire application and all of its separate
    services. Instead of dealing with a single piece of software, you may be dealing
    with many.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试的三个A模式（即自动化、敏捷和适应性）适用于UI测试，但设置测试运行环境的整个过程往往更为复杂，尤其是当你需要启动整个应用程序及其所有独立服务时。你可能需要处理的不仅仅是单一软件，而是多个。
- en: GUI tests also bring to light many new concerns, mostly related to the irregularity
    of how a real browser behaves. Waiting for pages to load, for text to render,
    for elements to be ready for interaction, or for a web page to perform HTTP requests
    and update itself are examples of actions that are usually troublesome. They tend
    to be unpredictable, and different machines can take different times to complete
    them.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: GUI测试也揭示了众多新的关注点，大多与真实浏览器行为的非规律性有关。等待页面加载、文本渲染、元素准备交互，或网页执行HTTP请求并更新自身，都是通常令人头疼的操作。它们往往不可预测，不同的机器完成这些操作所需的时间可能不同。
- en: Because these tests cover all parts of your application, they have the highest
    place in the testing pyramid, as shown in figure 2.13\. They take the longest
    to run, but they also provide the strongest possible guarantees.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试覆盖了应用程序的所有部分，它们在测试金字塔中占据最高的位置，如图2.13所示。它们运行时间最长，但同时也提供了最强有力的保证。
- en: '![](../Images/CH02_F13_DaCosta.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH02_F13_DaCosta.png)'
- en: Figure 2.13 GUI tests’ placement in the testing pyramid
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 GUI测试在测试金字塔中的位置
- en: Because end-to-end testing UIs is significantly different from all other types
    of tests, it has its own unique chapter. In chapter 10, we will compare various
    tools, present best practices, and tackle the different problems that emerge with
    this new kind of test.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于端到端测试UI与所有其他类型的测试显著不同，因此它有自己的独特章节。在第10章中，我们将比较各种工具，介绍最佳实践，并解决这种新型测试出现的问题。
- en: 2.4.3 Acceptance tests and end-to-end tests are not the same
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 验收测试和端到端测试并不相同
- en: People frequently conflate acceptance tests with end-to-end tests. Acceptance
    testing is a practice that aims to validate whether your application works from
    a business perspective. It verifies whether your software is *acceptable* for
    the end users the business wants to target.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常将验收测试与端到端测试混淆。验收测试是一种旨在从业务角度验证应用程序是否工作的实践。它验证软件是否对业务想要针对的最终用户来说是*可接受的*。
- en: End-to-end tests are a type of test that verifies your application as a whole,
    from an engineering perspective. It focuses on *correctness* rather than functionality.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是一种从工程角度验证整个应用程序的测试类型。它关注的是*正确性*而不是功能。
- en: Some overlap occurs between the two concepts because acceptance tests focus
    on *functional* requirements—on what an application *can do—*which is something
    that can be done through end-to-end tests.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于验收测试关注的是*功能性*需求——即应用程序*能做什么*——而这正是可以通过端到端测试来完成的，因此这两个概念之间可能存在一些重叠。
- en: Not all end-to-end tests are acceptance tests, and not all acceptance tests
    are end-to-end tests. You *can* perform acceptance tests through end-to-end tests—and
    many times you probably will.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有端到端测试都是验收测试，也并非所有验收测试都是端到端测试。你可以通过端到端测试来执行验收测试——而且很多时候你可能会这么做。
- en: End-to-end tests are excellent for this kind of verification because they can
    cover aspects that simple unit tests won’t, such as what a web page looks like
    or how long it takes for an application to respond to specific actions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试非常适合这种验证，因为它们可以覆盖简单单元测试无法覆盖的方面，例如网页的外观或应用程序对特定操作的响应时间。
- en: As I have previously mentioned, because end-to-end tests most closely resemble
    user behavior, they provide stronger guarantees when it comes to acceptance tests.
    Nonetheless, it’s also possible to perform acceptance testing using unit or integration
    tests. When testing whether the emails sent to users contain the desired content,
    for example, you might want to write a unit test to check the generated text.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，由于端到端测试最接近用户行为，因此在验收测试方面提供了更强的保证。尽管如此，也可以使用单元测试或集成测试进行验收测试。例如，在测试发送给用户的电子邮件是否包含所需内容时，你可能想编写一个单元测试来检查生成的文本。
- en: 2.5 Exploratory testing and the value of QA
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 探索性测试和QA的价值
- en: When you don’t have Silicon Valley-types of budgets—like Louis—you need to find
    cheaper ways of testing your software. Not everyone can afford an entire department
    filled with QA analysts and testers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有像路易斯那样的硅谷式预算时——你需要找到更便宜的方式来测试你的软件。并不是每个人都能负担得起一个充满质量分析师和测试员的整个部门。
- en: With the rise of automated tests, the demand for manual QA has been decreasing
    dramatically. This isn’t because having a specialized QA team is not useful, but
    because some of their tasks, when automated, can be cheaper, quicker, and more
    precise.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 随着自动化测试的兴起，手动QA的需求急剧下降。这并不是因为拥有一个专业的QA团队没有用，而是因为其中一些任务在自动化后可以更便宜、更快、更精确。
- en: Up until now, you haven’t felt the need to have a QA specialist. Every day,
    you are learning how to write better tests, which helps you ensure that your software
    works without the need for much human intervention.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有感觉到需要有一个质量分析师。每天，你都在学习如何编写更好的测试，这有助于你确保软件在没有太多人为干预的情况下运行。
- en: So far, your colleagues may have been reliable enough to test their own work.
    In the vast majority of cases, your deployments might not have introduced any
    critical failures. And, let’s be honest, it’s not a tragedy if someone can’t order
    their cake soon enough. The median cost of failure is low. Defects are definitely
    harmful to the business, but, considering that critical failures rarely happen
    because of your rigorous automated tests, the benefits of hiring someone to do
    manual testing don’t outweigh its costs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的同事可能已经足够可靠，可以测试他们自己的工作。在绝大多数情况下，你的部署可能没有引入任何关键故障。而且，让我们说实话，如果某人不能及时订购蛋糕，这并不是一场悲剧。失败的中位成本很低。缺陷肯定对业务有害，但考虑到关键故障很少是由于你严格的自动化测试造成的，因此雇佣人员进行手动测试的好处并不超过其成本。
- en: Besides the fact that the cost of failure doesn’t justify the cost of hiring
    a QA analyst, introducing one could increase the time it takes to ship changes.
    Machines provide feedback way quicker than a person would and with less communication
    overhead.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了失败的成本不足以证明雇佣一个质量分析师的合理性之外，引入一个质量分析师可能会增加发布更改所需的时间。机器的反馈速度远快于人类，并且通信开销更少。
- en: But all business evolve, especially when their owners pour so much of their
    hearts—and sugar—into them. The cost of failure for Louis’s business could dramatically
    increase if he decides to bake wedding cakes, for example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有业务都在不断发展，尤其是当所有者将如此多的心——和糖——投入其中时。如果路易斯决定烘焙婚礼蛋糕，例如，他业务的失败成本可能会大幅增加。
- en: Wedding cakes are one of the most expensive pieces of carbohydrates someone
    will ever buy in their lives. It’s challenging to pick one, and it’s even more
    stressful to worry about it until it arrives on the very day of your wedding.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 婚礼蛋糕是人们一生中购买的最昂贵的碳水化合物之一。挑选一个很具挑战性，而且直到婚礼当天它到达时，担心它更是压力重重。
- en: To increase the likelihood of customers placing an order, Louis also wants to
    provide them with various customization features. These features can be as complex
    as uploading a model that can be 3-D printed and placed on top of the cake—the
    future is here.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加客户下单的可能性，路易斯还希望为他们提供各种定制功能。这些功能可能复杂到可以上传一个可以3D打印并放置在蛋糕顶部的模型——未来已经到来。
- en: Now Louis has an extraordinarily complex and mission-critical feature that will
    represent a large chunk of the business’s revenue. These two factors drive up
    the necessity for a QA specialist, and now its cost is justified. In the future,
    the more features like this you have to ship, the more evident this need will
    become.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，路易斯有一个极其复杂且至关重要的功能，它将代表业务收入的大部分。这两个因素推动了质量分析师的必要性，现在其成本是合理的。在未来，你不得不发布的类似功能越多，这种需求就越明显。
- en: Sophisticated features usually have many edge cases, and the requirements for
    them to be well received by users are stricter. We are not only concerned about
    whether users can shape their cakes in any form, but we are also concerned whether
    it’s easy enough for them to do that. What matters is not only whether features
    work but also whether they fulfill our customers’ needs and whether they are delightful
    to use. This kind of acceptance testing is—at least for now—almost impossible
    for a machine to do.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的功能通常有很多边缘情况，它们被用户接受的要求也更严格。我们不仅关心用户是否能够以任何形式塑造他们的蛋糕，还关心他们是否足够容易地做到这一点。重要的是不仅功能是否工作，而且它们是否满足我们的客户需求，以及它们是否易于使用。这种验收测试——至少到目前为止——几乎是不可能由机器完成的。
- en: 'So far, our comparison between QA professionals and machines has been pretty
    unfair. We have been comparing what computers are good at with what humans are
    the worst at: performing repetitive tasks quickly and flawlessly. A comparison
    that would be more favorable to users is in regard to creative tasks and empathy.
    Only humans can think of the multiple curious ways someone would find to use a
    feature. Only people can place themselves in someone else’s shoes and think about
    how pleasing a piece of software is.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对QA专业人员和机器的比较相当不公平。我们一直在比较计算机擅长的事情和人类最不擅长的事情：快速且完美地执行重复性任务。对用户更有利的比较是在创造性任务和同理心方面。只有人类能够想到多种好奇的方式来使用一个功能。只有人们能够站在他人的立场上思考，考虑软件是否令人愉悦。
- en: Even tests need to be written by someone. A machine can execute a test only
    after it’s taught how to do so. Once you have discovered a bug that prevents someone
    from adding cheesecakes to their carts if they’re also ordering macaroons, you
    can write a test to avoid this specific bug from happening again. The problem
    is that until you have considered the possibility of that ever happening, there
    will be no tests for it. You can only add tests that prevent bugs from happening
    again—regression tests—if you have seen them happening in the first place.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 即使测试也需要有人来编写。机器只有在被教会如何执行测试之后才能执行测试。一旦你发现了一个阻止某人将奶酪蛋糕添加到购物车中的错误，因为你也在订购马卡龙，你就可以编写一个测试来避免这个特定的错误再次发生。问题是，直到你考虑过这种情况可能发生，否则不会有针对它的测试。只有在你最初看到它们发生的情况下，你才能添加防止错误再次发生的测试——回归测试。
- en: A programmer’s tests usually ensure that the software will behave when someone
    orders a cake. A QA’s tests often ensure that the software will behave when someone
    orders –91344794 cakes. This willingness to test curious scenarios is the other
    advantage of hiring QA professionals. They are excellent resources for exploratory
    testing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的测试通常确保当有人订购蛋糕时，软件将如何表现。质量保证团队的测试通常确保当有人订购-91344794个蛋糕时，软件将如何表现。这种愿意测试好奇场景的意愿是雇佣QA专业人员的另一个优势。他们是探索性测试的优秀资源。
- en: Exploratory testing is useful because it can cover cases that programmers didn’t
    think of. Once a QA catches a new bug, they can report it to the development team,
    which will fix it and add a test to ensure it won’t happen again.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性测试是有用的，因为它可以覆盖程序员没有考虑到的案例。一旦质量保证团队发现新的错误，他们可以向开发团队报告，开发团队将修复它并添加一个测试来确保它不会再次发生。
- en: Competent QA professionals act collaboratively with development teams. They
    help developers improve automated tests by providing feedback on the bugs that
    the QA team has found.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 能干的QA专业人员与开发团队协作。他们通过提供关于质量保证团队发现的错误的反馈，帮助开发者改进自动测试。
- en: The best way to prevent bugs from happening is to write automated tests that
    try to reproduce them. In fact, preventing *specific* bugs is all that automated
    testing can do. Automated tests can’t determine whether a piece of software works
    because they can’t test all possible inputs and outputs. Software becomes safer
    when QA teams help developers expand that universe of inputs and outputs that
    may be problematic.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 预防错误发生的最佳方式是编写自动测试，尝试重现它们。实际上，预防**特定**错误正是自动测试所能做到的全部。自动测试无法确定软件是否工作，因为它们无法测试所有可能的输入和输出。当质量保证团队帮助开发者扩展可能存在问题的输入和输出范围时，软件变得更加安全。
- en: On the other hand, the way developers help QA teams perform better work is by
    writing rigorous automated tests. The more that software can do on its own, the
    more time it saves the QA team to do tasks that only people can do, like exploratory
    testing.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，开发者通过编写严格的自动测试来帮助质量保证团队更好地工作。软件能够自动完成的工作越多，它就能为质量保证团队节省更多时间，让他们去做只有人类才能完成的任务，比如探索性测试。
- en: The biggest concern you should have when hiring QA people is whether it will
    create an adversarial relationship between them and the software development team.
    That’s the most counterproductive thing that can happen.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当雇佣QA人员时，你应该最关心的是它是否会在这两者之间产生对抗关系。这是最无效的事情之一。
- en: If QA teams see developers as adversaries, they will consider all fixes as an
    utmost priority, rather than communicating with developers and coming to an agreement
    about what’s better for the business. If a small defective animation hinders a
    release with a crucial new feature, for example, the company will miss out on
    revenue. This intransigence increases frustration and stress among teams and makes
    release cycles longer.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果QA团队将开发者视为对手，他们将会把所有修复都视为最高优先级，而不是与开发者沟通并就什么对业务更有利达成一致。例如，如果一个小缺陷的动画阻碍了一个包含关键新功能的发布，公司就会错过收入。这种固执会增加团队之间的挫败感和压力，并使发布周期更长。
- en: When developers have an adversarial attitude toward QA, they will be dismissive
    of problems. They will not test their code thoroughly before putting it into the
    hands of QA professionals, because, ultimately, they think that quality is a responsibility
    exclusive to the QA team and not to the business. They see their success as shipping
    features as quickly as they can, so they delegate all the testing to others. This
    carelessness leads to untestable software and, ultimately, to more bugs being
    shipped.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者对QA持有对抗态度时，他们会忽视问题。他们不会在将代码交给QA专业人士之前彻底测试他们的代码，因为最终他们认为质量是QA团队独有的责任，而不是企业的责任。他们认为他们的成功是尽可能快地发布功能，因此他们将所有测试委托给他人。这种粗心大意导致无法测试的软件，并最终导致更多错误被发布。
- en: NOTE Some people will argue that there should never be QA teams in Agile. Whenever
    I hear binary arguments like this, I tend to be sceptical. Every project is distinct
    and, therefore, has different constraints and requirements for success. I believe
    in an Agile approach to QA. I’d advocate for integrating QA in the development
    process. Instead of having QA run a big batch of tests before a major release,
    companies should integrate QA into the process of the delivery of individual tasks.
    Such an approach tightens the feedback loop and still ensures a satisfactory level
    of correctness and usability.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有些人会争论在敏捷开发中永远不应该有QA团队。每当听到这种二分法论点时，我往往持怀疑态度。每个项目都是独特的，因此，对成功的约束和要求也不同。我相信敏捷的QA方法。我主张将QA整合到开发过程中。公司不应该在重大发布前运行一大批测试，而应该将QA整合到交付单个任务的过程中。这种方法缩短了反馈循环，同时仍然确保了令人满意的正确性和可用性水平。
- en: 2.6 Tests, cost, and revenue
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 测试、成本和收入
- en: 'Hey, let me tell you a secret: Louis doesn’t care whether you write tests.
    As long as you can produce working software in less time, you might as well use
    ancient wizardry. In business, there’s only two things that matter: increasing
    revenue and diminishing costs.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，让我告诉你一个秘密：路易斯并不在乎你是否编写测试。只要你能在更短的时间内生产出可工作的软件，你不妨使用古老的巫术。在商业中，只有两件事是重要的：增加收入和降低成本。
- en: Businesses care about beautiful code because it helps programmers make fewer
    mistakes and produce code in a swift and predictable pace. Well-organized code
    is easier to understand and has fewer places for bugs to hide. It decreases frustration
    and makes programmers’ jobs more stimulating. In turn, the dynamic and satisfying
    environment keeps them motivated and makes them stay at the company longer. Beautiful
    code is not a goal—it is a means to an end.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 企业关心漂亮的代码，因为它有助于程序员减少错误，并以快速和可预测的速度生产代码。组织良好的代码更容易理解，并且有更少的地方让错误隐藏。它减少了挫败感，使程序员的工作更加刺激。反过来，动态和令人满意的环境使他们保持动力，并使他们更长时间地留在公司。漂亮的代码不是目标——它是达到目标的手段。
- en: Counterintuitively, producing bug-free software is also not a goal. Imagine
    you add a bug that causes customers to get a free macaroon for every 10 cheesecakes
    they buy. If that bug drives up profits, you might as well keep it. When a bug
    becomes a feature, you won’t fix it just for the sake of complying with the original
    spec. We fix bugs because, in the vast majority of cases, they decrease revenue
    and increase costs.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 反直觉的是，生产无缺陷的软件也不是目标。想象一下，你添加了一个错误，导致顾客每买10个芝士蛋糕就能免费得到一个马卡龙。如果这个错误提高了利润，你不妨保留它。当一个错误变成一个功能时，你不会仅仅为了遵守原始规范而修复它。我们修复错误，因为在绝大多数情况下，它们会减少收入并增加成本。
- en: Even writing code is not your job. Your job is to help the company increase
    its revenue and diminish its costs. The less code you write, the better, because
    less code is cheaper to maintain. Implementing a new feature in 10 lines of code
    costs way less than doing it in a thousand. Your business doesn’t thrive when
    you write elegant solutions to problems. It thrives when features are quick and
    easy to implement and, therefore, cost less money and deliver more value.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 即使编写代码也不是你的工作。你的工作是帮助公司增加收入并减少成本。你编写的代码越少，越好，因为代码越少，维护成本越低。用10行代码实现新功能的花费远低于用一千行代码实现。当你写出解决问题的优雅解决方案时，你的业务并不会繁荣。当功能快速且易于实现，因此成本更低，并能带来更多价值时，你的业务才会繁荣。
- en: TIP Patrick McKenzie wrote a brillant blog post about the intersection between
    the economics of businesses and software engineering. It’s a classic that I highly
    recommend and can be found at [https://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer](https://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 帕特里克·麦肯齐（Patrick McKenzie）撰写了一篇关于商业经济学与软件工程交叉领域的精彩博客文章。这是一篇经典之作，我强烈推荐，可在[https://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer](https://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer)找到。
- en: In the first chapter, we talked about how tests can help businesses generate
    revenue with fewer costs. But how can we structure tests themselves to be as cost
    efficient as possible?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了测试如何帮助企业在较低的成本下创造收入。但我们可以如何构建测试本身，使其尽可能具有成本效益？
- en: The first step toward cost-efficient tests is to keep in mind that **you pay
    for tests that you have to maintain**. When Louis asks you for a change, he doesn’t
    care that you spent only five minutes to change the application but two hours
    to update its tests. All that matters to the business is that it took you more
    than two hours to deliver the change. It’s insignificant whether you had to spend
    time updating the application’s code or its tests. Tests are code, too. Maintaining
    a hundred lines of code costs the same as maintaining a hundred lines of tests.
    Poorly written code is expensive because it takes a lot of time to change, and
    the same is valid for poorly written tests.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 向成本效益测试迈出的第一步是牢记**你必须维护的测试你才需要付费**。当路易斯（Louis）要求你进行更改时，他并不关心你只花了五分钟来更改应用程序，却花了两个小时来更新其测试。对业务来说，重要的是你花了超过两个小时来交付更改。你更新应用程序代码或测试所需的时间长短无关紧要。测试也是代码。维护一百行代码的成本与维护一百行测试的成本相同。编写糟糕的代码很昂贵，因为它需要花费大量时间来更改，同样，编写糟糕的测试也是如此。
- en: The next step to cut the cost of your tests is to reduce duplication in them.
    When you notice repetitive patterns, don’t be afraid to create abstractions. Creating
    separate utility functions makes tests shorter and faster to write. Using abstractions
    decreases costs and incentivizes developers to write tests more frequently. In
    the chapter about end-to-end tests, for example, we wrote helpers to make it easier
    to perform HTTP requests. Those helpers saved us from having to rewrite the whole
    fetching logic repeatedly. Let’s revisit that example to talk about good and bad
    patterns.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 减少测试成本的下一步是减少其中的重复。当你注意到重复的模式时，不要害怕创建抽象。创建单独的实用函数可以使测试更短，编写更快。使用抽象可以降低成本，并激励开发者更频繁地编写测试。例如，在关于端到端测试的章节中，我们编写了辅助函数，以便更容易执行HTTP请求。这些辅助函数使我们免于反复重写整个获取逻辑。让我们回顾一下这个例子，来谈谈好的和坏的模式。
- en: Consider the two samples below.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个示例。
- en: Listing 2.23 badly_written.test.js
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.23 badly_written.test.js
- en: '[PRE23]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 2.24 well_written.test.js
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.24 well_written.test.js
- en: '[PRE24]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Think about which of them is harder to read, and why.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 想想哪一个更难阅读，以及为什么。
- en: I find the first sample way harder to read. The logic necessary to handle promises
    and send requests muddles the intent of each test. This complexity makes it more
    challenging to understand what the test does and, therefore, makes changes take
    longer, too. In the second test, we have encapsulated the logic for getting and
    adding cart items into separate functions. This abstraction makes it easier to
    understand each of the steps in the test. The sooner we grasp what a test does,
    the sooner we can change it and the less it costs.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现第一个示例更难阅读。处理承诺和发送请求所需的逻辑混淆了每个测试的意图。这种复杂性使得理解测试做什么变得更加困难，因此，更改也花费了更长的时间。在第二个测试中，我们将获取和添加购物车项的逻辑封装到单独的函数中。这种抽象使得理解测试中的每个步骤更容易。我们越快理解测试做什么，就越快能够更改它，成本也就越低。
- en: If you had to change the URL of your server’s endpoints, think about which one
    of these samples would be easier to update.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须更改服务器端点的URL，考虑一下这些样本中哪一个更容易更新。
- en: Updating the second code sample is way easier because you don’t have to rewrite
    the URLs used in each test. By updating those functions, you’d fix all the tests
    that use them. A single change can impact multiple tests and, therefore, decrease
    their maintenance costs. When it comes to removing duplication, the same principles
    you apply to your code apply to your tests.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 更新第二个代码样本要容易得多，因为你不需要重写每个测试中使用的URL。通过更新这些函数，你会修复所有使用它们的测试。一次更改可以影响多个测试，因此可以降低它们的维护成本。当涉及到消除重复时，应用于你的代码的原则也适用于你的测试。
- en: Now consider that you have to add more tests. With which of these samples would
    that task be harder?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑你必须添加更多测试的情况。使用这些样本中的哪一个，这项任务会更困难？
- en: If you proceed to repeat yourself, adding tests to the first sample is definitely
    going to take longer because you’d have to copy and tweak the extensive logic
    from the previous test. Your test suite would become verbose and, therefore, harder
    to debug. In contrast, the second sample facilitates writing new tests because
    each request takes a single line and is easily understandable. In the second sample,
    you also don’t have to worry about managing a complex chain of nested promises.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续重复，将测试添加到第一个样本肯定需要更长的时间，因为你必须复制并调整上一个测试中的大量逻辑。你的测试套件将变得冗长，因此更难调试。相比之下，第二个样本便于编写新的测试，因为每个请求只需一行，并且易于理解。在第二个样本中，你也不必担心管理复杂的嵌套承诺链。
- en: Besides keeping tests readable and avoiding duplication, another crucial attitude
    to decrease tests’ costs is to make them loosely coupled. Your tests should assert
    what your code does, not *how* it does it. Ideally, you should have to change
    them only when your application presents behavior that’s different from what the
    test expected.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保持测试可读性和避免重复之外，降低测试成本的关键态度之一是使它们松散耦合。你的测试应该断言你的代码做什么，而不是*如何*做。理想情况下，你只有在应用程序表现出与测试预期不同的行为时才需要更改它们。
- en: Take into account the function below.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数。
- en: Listing 2.25 pow.js
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.25 pow.js
- en: '[PRE25]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function calculates powers using recursion. A good test for this function
    would provide it with a few inputs and check whether it produces the correct output.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用递归计算幂。对这个函数的一个良好测试应该提供给它一些输入并检查它是否产生正确的输出。
- en: Listing 2.26 pow.test.js
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.26 pow.test.js
- en: '[PRE26]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This test doesn’t make any assumptions about *how* the `pow` function works.
    If you refactor the `pow` function, it should still pass.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试对`pow`函数的工作方式没有任何假设。如果你重构了`pow`函数，它仍然应该通过。
- en: Refactor the `pow` function so that it uses a loop instead, and rerun your tests.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 重构`pow`函数，使其使用循环，然后重新运行你的测试。
- en: Listing 2.27 pow.js
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.27 pow.js
- en: '[PRE27]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because the function is still correct, the test passes. This test was cost-efficient
    because it was written once but was able to validate your function multiple times.
    If your tests check irrelevant implementation details, you will need to update
    them whenever you update a function, even if it still works. **You want tests
    to fail only when a function’s observable behavior changes**.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数仍然正确，测试通过了。这个测试是成本效益的，因为它只写了一次，但能够多次验证你的函数。如果你的测试检查了无关的实现细节，那么每次你更新一个函数时，即使它仍然工作，你也必须更新它们。**你希望测试只在函数的可观察行为发生变化时失败**。
- en: There are, however, exceptions to this rule. Sometimes you will have to deal
    with side effects or call third-party APIs. If these implementation details are
    critical to what your software does, then it’s advisable to test them. Let’s use
    the following function as an example.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规则有例外。有时你必须处理副作用或调用第三方API。如果这些实现细节对你的软件功能至关重要，那么测试它们是明智的。让我们使用以下函数作为例子。
- en: Listing 2.28 cartController.js
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.28 cartController.js
- en: '[PRE28]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Logs an error
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 记录一个错误
- en: In this function, you want to ensure you will log any errors that customers
    may experience when adding items to their carts.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你想要确保记录任何客户在将项目添加到购物车时可能遇到的错误。
- en: If logging errors is critical for debugging your application, you should enforce
    it with tests. You should have tests that verify whether `addToCart` calls the
    `loggingService` when an error happens. In this case, examining that implementation
    detail is important because you want to enforce it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为记录错误对于调试你的应用程序至关重要，你应该通过测试来强制执行它。你应该有测试来验证当发生错误时`addToCart`是否调用`loggingService`。在这种情况下，检查这个实现细节很重要，因为你想要强制执行它。
- en: I like to think of tests as guarantees. Whenever I want to confirm that my application
    behaves in a certain way, I will write a test for it. If you require a function
    to be implemented in a particular manner, you can encode that demand into an automated
    test.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把测试看作是保证。每当我想要确认我的应用程序以某种方式行为时，我都会为它编写一个测试。如果你要求一个函数以特定方式实现，你可以将这个要求编码到自动化测试中。
- en: Don’t worry about whether you are checking implementation details. Worry about
    whether you are checking *relevant* behavior.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心你是否在检查实现细节。担心你是否在检查*相关*的行为。
- en: An alternative to asserting on whether `loggingService` is called is to check
    the log file to which it writes. But that approach also has downsides. If you
    decide to change how you implement `loggingService` so that it logs to a different
    file, the test for `addItemToCart`—and probably many others that rely on this
    same behavior—will fail, too, as shown in figure 2.14.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在断言`loggingService`是否被调用方面的一个替代方案是检查它写入的日志文件。但这种方法也有缺点。如果你决定更改`loggingService`的实现方式，使其将日志记录到不同的文件，那么`addItemToCart`的测试——以及可能依赖于这种相同行为的许多其他测试——也会失败，如图2.14所示。
- en: '![](../Images/CH02_F14_DaCosta.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14](../Images/CH02_F14_DaCosta.png)'
- en: Figure 2.14 When you have multiple tests checking whether `loggingService` writes
    to the correct file, all of them will fail when you change `loggingService`. Because
    you have more tests to update, the cost of changing `loggingServices` increases.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 当你有多个测试检查`loggingService`是否写入正确的文件时，当你更改`loggingService`时，所有这些测试都会失败。因为你需要更新的测试更多，所以更改`loggingServices`的成本会增加。
- en: By asserting that `addToCart` calls `loggingService—`an implementation detail—you
    avoid unrelated tests failing when `loggingService` changes, as shown in figure
    2.15\. If you have rigorous tests for `loggingService`, they will be the only
    ones to break when you change the file to which `loggingService` writes. Fewer
    breaking tests mean you have fewer tests to update and, therefore, fewer costs
    to maintain them.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过断言`addToCart`调用`loggingService`（一个实现细节），你可以在`loggingService`更改时避免无关的测试失败，如图2.15所示。如果你对`loggingService`有严格的测试，那么当你更改`loggingService`写入的文件时，它们将是唯一会中断的测试。更少的破坏性测试意味着你需要更新的测试更少，因此维护它们的成本也更低。
- en: '![](../Images/CH02_F15_DaCosta.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15](../Images/CH02_F15_DaCosta.png)'
- en: 'Figure 2.15 If you change the file to which `loggingService` writes, its tests
    will be the only ones to fail. The `addItemToCart` tests will continue to pass
    because they are doing what you expect: using the logging service. By structuring
    your tests in this way, you have fewer tests to update and more precise feedback
    about what piece of your software doesn’t comply with the tests.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 如果你更改`loggingService`写入的文件，它的测试将是唯一会失败的。`addItemToCart`测试将继续通过，因为它们正在做你期望的事情：使用日志服务。通过以这种方式构建你的测试，你将需要更新的测试更少，并且关于你的软件中哪些部分不符合测试的反馈将更加精确。
- en: NOTE We will talk about how to write tests that inspect a function’s calls when
    we talk about mocks, stubs, and spies in chapter 3\. For now, the most important
    thing is to understand why you’d want to do that.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当我们谈到第3章中的模拟、存根和间谍时，我们将讨论如何编写检查函数调用的测试。目前，最重要的是理解你为什么要这样做。
- en: When you create tests that complement each other, you create what I call a *transitive
    guarantee*. If, for example, you have tests to ensure that function `a` works,
    then you will be fine by just checking if function `a` is called by other functions,
    instead of rechecking its behavior on every test.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建相互补充的测试时，你创造了我认为的*传递性保证*。例如，如果你有确保函数`a`工作的测试，那么只需检查其他函数是否调用了函数`a`，而不是在每次测试中都重新检查其行为，你就可以做得很好。
- en: Transitive guarantees are a great way to decrease the cost of your tests. They
    work in the same way as abstractions—they decrease coupling. Instead of all tests
    repetitively checking the same behavior, they delegate that responsibility to
    another test. Transitive guarantees are encapsulation at the testing level.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 传递性保证是降低测试成本的好方法。它们与抽象一样工作——它们减少了耦合。不是所有测试都重复检查相同的行为，而是将这项责任委托给另一个测试。传递性保证是测试层面的封装。
- en: If you must assert on a function’s implementation detail, it’s advisable to
    create a transitive guarantee so that you can encapsulate that check into a separate
    test. Even though this separation distances tests from reality and, therefore,
    decreases its value, it can considerably reduce its maintenance cost.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须断言一个函数的实现细节，建议创建一个传递性保证，这样你就可以将这个检查封装到单独的测试中。尽管这种分离使测试远离现实，从而降低了其价值，但它可以显著降低其维护成本。
- en: It’s your job to balance the maintenance cost of tests versus the value they
    provide. Rigorous tests can provide excellent fine-grained feedback, but if they’re
    too coupled, they’ll be expensive to maintain. On the other hand, tests that never
    break don’t produce information. Achieving a balance between maintainability and
    rigorous quality control is what turns a good tester into an excellent one.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是平衡测试的维护成本与它们提供的价值。严格的测试可以提供优秀的细粒度反馈，但如果它们耦合度过高，维护成本会很高。另一方面，从不失败的测试不会产生信息。在可维护性和严格的质量控制之间取得平衡，是使一个好的测试员成为优秀测试员的关键。
- en: TIP One of the most heated debates when it comes to testing is whether people
    should create a test for every single line of code they write.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在测试方面，最热烈的辩论之一是人们是否应该为每行代码创建一个测试。
- en: As I have mentioned many times in this book, I don’t like absolute thinking.
    The word *always* is hazardous, and so is the word *never*. What I’d say is that
    the longer the period your code is going to survive, the more critical it is to
    write tests.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在这本书中多次提到的，我不喜欢绝对化的思考。单词“总是”（always）是危险的，单词“从不”（never）也是如此。我想说的是，你的代码将要存活的时间越长，编写测试就越重要。
- en: The value a test produces depends on how often it runs. If a test saves you
    five minutes of manual testing, by the time you’ve run it for the 15th time, you’ll
    have saved an hour.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 测试产生的价值取决于它运行的频率。如果一个测试为你节省了五分钟的手动测试时间，那么当你运行了第15次时，你就节省了一个小时。
- en: If you are in a hackathon, for example, you probably shouldn’t add too many
    tests (if any). In hackathons, the code you write will usually be gone sooner
    than the coffee and pizzas provided by the host. Therefore, it will not have enough
    opportunities to deliver value.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在黑客马拉松中，你可能不应该添加太多测试（如果有的话）。在黑客马拉松中，你写的代码通常会比主办方提供的咖啡和披萨先消失。因此，它将没有足够的机会提供价值。
- en: Another case when you should probably avoid writing tests is if you’re exploring
    a particular API or just experimenting with possibilities. In that case, it’s
    perhaps wiser to play around first and write tests only once you’re confident
    of what you want to do.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能应该避免编写测试的另一个情况是，如果你正在探索特定的API或只是尝试可能性。在这种情况下，先玩一玩，只有在你对想要做的事情有信心之后才编写测试可能更明智。
- en: When deciding whether you should write tests, consider that the longer a specific
    piece of code will survive, the more critical it is to add tests for it.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定你是否应该编写测试时，考虑一下，一段特定的代码将存活的时间越长，添加测试就越重要。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'All tests follow a similar formula: they set up a scenario, trigger an action,
    and check the results produced. This pattern is easy to remember by using the
    three As mnemonic: arrange, act, and assert.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有测试都遵循一个类似的公式：它们设置一个场景，触发一个动作，并检查产生的结果。通过使用三个A的助记符：安排（arrange）、行动（act）和断言（assert），这个模式很容易记住。
- en: Test runners are tools we use to write tests. They provide helpful and concise
    ways for you to organize tests and obtain readable and meaningful output from
    them. Some test runners, like Jest, also ship with assertion libraries, which
    help us compare the actual output of an action with what was expected.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试运行器是我们用来编写测试的工具。它们为你提供了组织和从测试中获得可读性和有意义输出的便捷方式。一些测试运行器，如Jest，还附带断言库，这有助于我们比较动作的实际输出与预期输出。
- en: To facilitate the setup and teardown process of tests, Jest provides you with
    hooks that can run at different stages of the testing process. You can use `beforeEach`
    to run a function before *each* test, `beforeAll` to run it once before *all*
    tests, `afterEach` to run it after *each* test, and `afterAll` to run it once
    after *all* tests.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便测试的设置和拆卸过程，Jest为你提供了可以在测试过程的各个阶段运行的钩子。你可以使用`beforeEach`在每次测试之前运行一个函数，使用`beforeAll`在所有测试之前运行一次，使用`afterEach`在每次测试之后运行，使用`afterAll`在所有测试之后运行一次。
- en: The testing pyramid is a visual metaphor that helps us separate types into different
    categories based on how often they should run, how many of them should exist,
    how big their scope is, and how strong the quality guarantees they produce are.
    As we ascend the pyramid, tests get scarcer, more valuable, cover a broader scope,
    and run less frequently.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔是一个视觉隐喻，帮助我们根据它们应该运行的频率、应该存在的数量、它们的范围大小以及它们产生的质量保证强度，将测试类型分为不同的类别。随着我们攀登金字塔，测试变得越来越稀缺，价值更高，覆盖范围更广，运行频率更低。
- en: Unit tests are designed to run against functions. They are essential to assert
    the quality of your software at the most granular level possible, providing quick
    and precise feedback. These tests import your functions, feed them input, and
    check the output against what you expected.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是为了针对函数而设计的。它们对于在尽可能细粒度的层面上断言软件质量至关重要，提供快速而精确的反馈。这些测试导入你的函数，提供输入，并检查输出是否符合预期。
- en: Integration tests are written to ensure that different parts of an application
    can work together. They verify whether you are using third-party libraries appropriately,
    such as database adapters. These tests act through your own software, but they
    may need access to external components, like a database or the filesystem, to
    set up a scenario and to check whether your application produced the desired result.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试是为了确保应用程序的不同部分可以协同工作。它们验证你是否适当地使用了第三方库，例如数据库适配器。这些测试通过你的软件进行操作，但可能需要访问外部组件，如数据库或文件系统，以设置场景并检查你的应用程序是否产生了预期的结果。
- en: 'End-to-end tests run against all layers of a program. Instead of directly calling
    functions, they interact with your application as a user would: by using a browser
    or sending HTTP requests, for example. They consider the application to be a “black
    box.” These tests produce the strongest quality guarantees since they most closely
    resemble real use-case scenarios.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试针对程序的所有层运行。它们不是直接调用函数，而是像用户一样与你的应用程序交互：例如，通过使用浏览器或发送HTTP请求。它们将应用程序视为一个“黑盒”。这些测试由于最接近真实用例场景，因此提供了最强的质量保证。
- en: Acceptance tests are different from end-to-end tests. Acceptance tests focus
    on validating whether your applications fulfill functional requirements. These
    tests verify whether your user is acceptable from a business perspective, taking
    into account your target users. On the other hand, end-to-end tests focus on validating
    whether your application is **correct** from an engineering perspective. End-to-end
    tests can serve as acceptance tests, but not all acceptance tests need to be end-to-end
    tests.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试与端到端测试不同。接受测试侧重于验证你的应用程序是否满足功能需求。这些测试从业务角度验证你的用户是否可接受，考虑到你的目标用户。另一方面，端到端测试侧重于从工程角度验证你的应用程序是否**正确**。端到端测试可以作为接受测试，但并非所有接受测试都需要是端到端测试。
- en: Automated tests can’t fully replace quality assurance professionals. Automated
    tests complement the work of QA analysts by freeing them to do tasks that only
    humans can do, such as exploratory testing or providing detailed user-centric
    feedback.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试不能完全取代质量保证专业人员。自动化测试通过让QA分析师有更多时间从事只有人类才能完成的任务，如探索性测试或提供以用户为中心的详细反馈，来补充QA分析师的工作。
- en: QA and development teams **must** work collaboratively instead of seeing each
    other as adversaries. Developers should write rigorous automated tests to shorten
    the feedback loop and support QA’s validation tasks. QA professionals should communicate
    with engineering and product teams to define priorities and should provide detailed
    feedback on how to improve the product instead of setting the bar to an unreachable
    level.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量保证（QA）和开发团队**必须**协作工作，而不是将对方视为对手。开发者应该编写严格的自动化测试来缩短反馈循环并支持QA的验证任务。QA专业人员应与工程和产品团队沟通，以确定优先级，并提供有关如何改进产品的详细反馈，而不是将标准定得无法触及。
- en: Tests, just like code, have maintenance costs associated to them. The more often
    you have to update tests, the more expensive they are. You can reduce tests’ costs
    by keeping code readable, avoiding duplication, decreasing coupling between tests
    and application code, and separating your verifications into multiple tests to
    create transitive guarantees.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试，就像代码一样，与它们相关的维护成本。你不得不更频繁地更新测试，它们就越昂贵。你可以通过保持代码可读性、避免重复、减少测试与应用程序代码之间的耦合，以及将验证分离到多个测试中以创建传递性保证，来降低测试的成本。
