- en: Chapter 5\. Data handling with lists
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 使用列表处理数据
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Classifying data structures in functional programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数式编程中分类数据结构
- en: Using the ubiquitous singly linked list
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无处不在的单链表
- en: Understanding the importance of immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不可变性的重要性
- en: Handling lists with recursion and functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归和函数处理列表
- en: Data structures are among the most important concepts in programming, as well
    as in everyday life. The world as we see it is itself a huge data structure composed
    of simpler data structures, which are in turn composed of simpler structures.
    Each time we try to model something, be it objects or facts, we end up with data
    structures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是编程以及日常生活中最重要的概念之一。我们所看到的世界本身就是一个巨大的数据结构，由更简单的数据结构组成，而这些更简单的结构又由更简单的结构组成。每次我们尝试对某个事物进行建模，无论是对象还是事实，最终都会得到数据结构。
- en: There are many types of data structures. In computing, data structures are generally
    represented as a whole by the term *collections*. A collection is a group of data
    items that have some relation to each other. In the simplest form, this relation
    is the fact that they belong to the same group.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多类型的数据结构。在计算机科学中，数据结构通常由术语*集合*整体表示。集合是一组数据项，它们彼此之间有一定的关系。在最简单的形式中，这种关系是它们属于同一个组。
- en: 5.1\. How to classify data collections
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 如何分类数据集合
- en: 'Data collections can be classified from many different points of view. You
    can classify data collections as linear, associative, and graph:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集合可以从许多不同的角度进行分类。您可以将数据集合分类为线性、关联和图：
- en: Linear collections are collections in which elements are related along a single
    dimension. In such a collection, each element has a relation to the next element.
    The most common example of a linear collection is the list.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性集合是元素沿着单一维度相关联的集合。在这样的集合中，每个元素都与下一个元素有关联。线性集合中最常见的例子是列表。
- en: Associative collections are collections that can be viewed as a function. Given
    an object `o`, a function `f(o)` will return `true` or `false` according to whether
    this object belongs to the collection or not. Unlike in linear collections, there’s
    no relation between the elements of the collection. These collections aren’t ordered,
    although it is possible to define an order on the elements. The most common examples
    of associative collections are the set and the associative array (which is also
    called a map or dictionary). We’ll study a functional implementation of maps in
    [chapter 11](kindle_split_018.xhtml#ch11).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联集合是可以被视为函数的集合。给定一个对象`o`，函数`f(o)`将根据该对象是否属于集合返回`true`或`false`。与线性集合不同，集合中的元素之间没有关系。这些集合是无序的，尽管可以在元素上定义一个顺序。关联集合中最常见的例子是集合和关联数组（也称为映射或字典）。我们将在第11章（[chapter
    11](kindle_split_018.xhtml#ch11)）中研究映射的函数式实现。
- en: Graphs are collections in which each element is in relationships with multiple
    other elements. A particular example is the tree, and more specifically the binary
    tree, where each element is related to two other elements. You’ll learn more about
    trees from a functional perspective in [chapter 10](kindle_split_017.xhtml#ch10).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图是每个元素都与多个其他元素相关联的集合。一个特定的例子是树，更具体地说，是二叉树，其中每个元素都与另外两个元素相关联。您将在第10章（[chapter
    10](kindle_split_017.xhtml#ch10)）中从函数式角度了解更多关于树的内容。
- en: 5.1.1\. Different types of lists
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 列表的类型
- en: In this chapter, we’ll focus on the most common type of linear collections,
    the list. The list is the most used data structure in functional programming,
    so it’s generally used to teach functional programming concepts. Be aware, however,
    that what you’ll learn in this chapter is not specific to lists but is shared
    by many other data structures (which may not be collections).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注最常见的线性集合类型，即列表。列表是函数式编程中最常用的数据结构，因此通常用于教授函数式编程概念。然而，请注意，本章所学的知识并不仅限于列表，而是与其他许多数据结构（可能不是集合）共享的。
- en: 'Lists can be further classified based on several different aspects, including
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以根据几个不同的方面进一步分类，包括以下内容：
- en: '***Access—*** Some lists will be accessed from one end only, and others will
    be accessed from both ends. Some will be written from one end and read from the
    other end. Finally, some lists may allow access to any element using its position
    in the list; the position of an element is also called its *index*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***访问—*** 一些列表只能从一端访问，而其他列表可以从两端访问。一些可以从一端写入并从另一端读取。最后，一些列表可能允许通过其在列表中的位置访问任何元素；元素的位置也称为其*索引*。'
- en: '***Type of ordering—*** In some lists, the elements will be read in the same
    order in which they were inserted. This kind of structure is said to be FIFO (first
    in, first out). In others, the order of retrieval will be the inverse of the order
    of insertion (LIFO, or last in, first out). Finally, some lists will allow you
    to retrieve the elements in a completely different order.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***排序类型—*** 在某些列表中，元素将以它们被插入的相同顺序被读取。这种结构被称为FIFO（先进先出）。在其他列表中，检索顺序将是插入顺序的逆序（LIFO，或后进先出）。最后，一些列表将允许你以完全不同的顺序检索元素。'
- en: '***Implementation—*** Access type and ordering are concepts strongly related
    to the implementation you choose for the list. If you choose to represent the
    list by linking each element to the next, you’ll get a completely different result,
    from the access point of view, than from an implementation based on an indexed
    array. Or if you choose to link each element to the next as well as to the previous
    element, you’ll get a list that can be accessed from both ends.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***实现—*** 访问类型和排序是与你为列表选择的实现方式紧密相关的概念。如果你选择通过将每个元素链接到下一个元素来表示列表，那么从访问的角度来看，你将得到与基于索引数组实现完全不同的结果。或者，如果你选择将每个元素同时链接到下一个元素和前一个元素，你将得到可以从两端访问的列表。'
- en: '[Figure 5.1](#ch05fig01) shows different types of lists offering different
    kinds of access. Note that this figure shows the principle behind each type of
    list, but not the way the lists are implemented.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01)展示了提供不同类型访问的不同类型的列表。请注意，这个图显示了每种类型列表背后的原理，但没有显示列表的实现方式。'
- en: Figure 5.1\. Different types of lists offer different types of access to their
    elements.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 不同类型的列表为它们的元素提供不同类型的访问。
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: 5.1.2\. Relative expected list performance
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 相对预期列表性能
- en: 'One very important criterion when choosing a type of list is the expected performance
    for various kinds of operations. Performance is often expressed in Big O notation.
    This notation is mainly used in mathematics, but when used in computing, it indicates
    the way the complexity of an algorithm changes when responding to a change of
    input size. When used to characterize the performance of list operations, this
    notation shows how the performance varies as a function of the length of the list.
    For example, consider the following performances:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择列表类型时，一个非常重要的标准是各种操作预期的性能。性能通常用大O符号表示。这种符号主要用在数学中，但用在计算机科学中，它表示算法的复杂度随输入大小变化的方式。当用来描述列表操作的性能时，这种符号显示了性能如何随列表长度的变化而变化。例如，考虑以下性能：
- en: O(1)—This means that the time needed for an operation will be constant. (You
    may think of it as meaning that the time for one element will be multiplied by
    1 for *n* elements.)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(1)—这意味着操作所需的时间将是常数。（你可以将其视为一个元素的时间乘以1，对于*n*个元素。）
- en: O(log(*n*))—This means that the time for an operation on *n* elements will be
    the time for one element multiplied by log(*n*).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(log(*n*))—这意味着*n*个元素上的操作时间将是一个元素的时间乘以log(*n*)。
- en: O(*n*)—The time for *n* elements will be the time for one element multiplied
    by *n*.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(*n*)—*n*个元素的时间将是单个元素的时间乘以*n*。
- en: O(*n*²)—The time for *n* elements will be the time for one element multiplied
    by *n*².
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(*n*²)—*n*个元素的时间将是单个元素的时间乘以*n*²。
- en: It would be ideal to create a data structure with O(1) performance for all types
    of operations. Unfortunately, this has not been found possible yet. Each type
    of list offers different performance for different operations. Indexed lists offer
    O(1) performance for data retrieval and near to O(1) for insertion. The singly
    linked list offers O(1) performance for insertion and retrieval on one end, and
    O(*n*) for the other end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个对所有类型操作都具有O(1)性能的数据结构将是理想的。不幸的是，这至今尚未实现。每种类型的列表为不同的操作提供不同的性能。索引列表为数据检索提供O(1)性能，对于插入接近O(1)。单链表在一端提供O(1)的插入和检索性能，而在另一端提供O(*n*)。
- en: Choosing the best structure is a compromise. Most often, you’ll seek O(1) performance
    for the most frequent operations, and you’ll have to accept O(log(*n*)) or even
    O(*n*) for some operations that don’t occur very often.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '选择最佳结构是一种折衷。大多数情况下，你将寻求对最频繁操作 O(1) 的性能，而对于不常发生的某些操作，你必须接受 O(log(*n*)) 或甚至 O(*n*)。 '
- en: Be aware that this way of measuring performance has a real meaning for structures
    that can be scaled infinitely. This is not the case for the data structures we
    manipulate, because your structures are limited in size by the available memory.
    A structure with O(*n*) access time might always be faster than another one with
    O(1) due to this size limit. If the time for one element is much smaller for the
    first structure, its memory limitation may prevent the second from showing its
    benefits. It’s often better to have O(*n*) performance with an access time of
    1 nanosecond to one element than O(1) with an access time of 1 millisecond. (The
    latter will be faster than the former only for sizes over 1,000,000 elements.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种衡量性能的方式对于可以无限扩展的结构具有实际意义。然而，对于我们所操作的数据结构来说并非如此，因为你的结构大小受可用内存的限制。一个具有 O(*n*)
    访问时间的结构可能总是比另一个具有 O(1) 访问时间的结构更快，这是由于这种大小限制。如果第一个结构中一个元素的时间远小于第二个结构，其内存限制可能会阻止第二个结构显示出其优势。通常，拥有
    O(*n*) 性能且对单个元素的访问时间为 1 纳秒，比 O(1) 性能且访问时间为 1 毫秒要好。（后者只有在元素数量超过 1,000,000 时才会比前者快。）
- en: 5.1.3\. Trading time against memory space, and time against complexity
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3. 交易时间与内存空间，以及时间与复杂度
- en: You just saw that choosing an implementation for a data structure is generally
    a question of trading time against time. You’ll choose an implementation that’s
    faster on some operations, but slower on others, based on which operations are
    the most frequent. But there are other trading decisions to make.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到，为数据结构选择实现通常是一个权衡时间的问题。你将选择在特定操作上更快，但在其他操作上较慢的实现，这取决于哪些操作是最频繁的。但还有其他需要做出的权衡决策。
- en: Imagine you want a structure from which elements can be retrieved in sorted
    order, the smallest first. You might choose to sort the elements on insertion,
    or you might prefer to store them as they arrive and search for the smallest on
    retrieval only. One important criterion for making the decision would be whether
    the retrieved element is systematically removed from the structure. If not, it
    might be accessed several times without removal, so it would probably be better
    to sort the elements at insertion time, in order to avoid sorting them several
    times on retrieval. This use case corresponds to what’s called a *priority queue*,
    in which you’re waiting for a given element. You might test the queue many times
    until the expected element is returned. Such a use case requires that elements
    be sorted at insertion time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个结构，可以从其中按顺序检索元素，从小到大。你可能选择在插入时对元素进行排序，或者你可能更喜欢按到达顺序存储它们，并在检索时仅搜索最小的元素。做出决策的一个重要标准将是检索的元素是否系统性地从结构中移除。如果不是，它可能被多次访问而不被移除，因此可能最好在插入时对元素进行排序，以避免在检索时多次排序。这种情况对应于所谓的
    *优先队列*，其中你正在等待一个特定的元素。你可能需要多次测试队列，直到返回预期的元素。这种用例要求在插入时对元素进行排序。
- en: But what if you want to access elements by several different sort orders? For
    example, you might want to access elements in the same order they were inserted,
    or in reverse order. The result might correspond to the doubly linked list of
    [figure 5.1](#ch05fig01). It seems that in such a case, elements should be sorted
    at retrieval time. You might favor one order, leading to O(1) access time from
    one end and O(*n*) from the other end, or you might invent a different structure,
    perhaps giving O(log(*n*)) access time from both ends. Another solution would
    be to store two lists, one in insertion order and one in reverse order. This way,
    you’d have a slower insertion time, but O(1) retrieval from both ends. One drawback
    is that this approach would probably use more memory. Thus you can see that choosing
    the right structure might also be a question of trading time against memory space.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想要通过几种不同的排序顺序来访问元素怎么办？例如，你可能希望以它们被插入的相同顺序或相反顺序来访问元素。结果可能与[图5.1](#ch05fig01)的双向链表相对应。在这种情况下，元素应该在检索时进行排序。你可能倾向于选择一个顺序，从而从一端提供O(1)的访问时间，而从另一端提供O(*n*)的访问时间，或者你可能发明一个不同的结构，可能从两端提供O(log(*n*))的访问时间。另一个解决方案是存储两个列表，一个按插入顺序，一个按相反顺序。这样，你会有更慢的插入时间，但两端都有O(1)的检索时间。一个缺点是，这种方法可能会使用更多的内存。因此，你可以看到，选择正确的结构也可能是一个权衡时间与内存空间的问题。
- en: But you might also invent some structure minimizing both insertion time and
    retrieval time from both ends. These types of structures have already been invented,
    and you’d only have to implement them, but such structures are much more complex
    than the simplest ones, so you’d be trading time against complexity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你也可能发明一些结构，最小化从两端插入和检索的时间。这些类型的结构已经被发明出来，你只需要实现它们，但这样的结构比最简单的结构要复杂得多，所以你会牺牲时间来换取复杂性。
- en: 5.1.4\. In-place mutation
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4\. 原地突变
- en: Most data structures change over time because elements are inserted and removed.
    Basically, there are two ways to handle such operations. The first one is *update
    in place*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据结构会随着时间的推移而改变，因为元素会被插入和删除。基本上，处理这类操作有两种方式。第一种是*原地更新*。
- en: Update in place consists of changing the elements of the data structure by mutating
    the structure itself. It would have been considered a good idea when all programs
    were single threaded, although it wasn’t. It’s much worse now that all programs
    are multithreaded. This doesn’t only concern replacing elements. It’s the same
    for adding or removing, sorting, and all operations that mutate the structure.
    If programs are allowed to mutate data structures, these structures simply can’t
    be shared without sophisticated protections that are rarely done right the first
    time, leading to deadlock, livelock, thread starving, stale data, and all those
    sorts of troubles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 原地更新包括通过修改数据结构本身来更改数据结构的元素。当所有程序都是单线程的时候，这曾经被认为是一个好主意，尽管实际上并不是。现在所有程序都是多线程的，这更糟糕。这不仅关系到替换元素，对于添加或删除、排序以及所有修改结构的操作也是如此。如果程序被允许修改数据结构，那么这些结构在缺乏复杂且很少第一次就做对的保护措施的情况下是无法共享的，从而导致死锁、活锁、线程饥饿、过时数据以及所有这些麻烦。
- en: So what’s the solution? Simply use immutable data structures. Many imperative
    programmers are shocked when they first read this. How can you do useful things
    with data structures if you can’t mutate them? After all, you often start with
    empty structures and want to add data to them. How can you possibly do this if
    they’re immutable?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？简单来说，就是使用不可变数据结构。许多命令式程序员在第一次读到这一点时都会感到震惊。如果你不能修改数据结构，你如何用它们做有用的事情呢？毕竟，你通常从一个空的结构开始，并希望向其中添加数据。如果它们是不可变的，你如何可能做到这一点呢？
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Update in place**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**原地更新**'
- en: 'In a 1981 article titled “The transaction concept: virtues and limitations,”
    Jim Gray wrote this:^([[a](#ch05fn01)])'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在1981年一篇题为“事务概念：优点和局限性”的文章中，Jim Gray写道：^([[a](#ch05fn01)])
- en: ^a
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Jim Gray, “The transaction concept: virtues and limitations” (Tandem Computers,
    Technical Report 81.3, June 1981), [http://www.hpl.hp.com/techreports/tandem/TR-81.3.pdf](http://www.hpl.hp.com/techreports/tandem/TR-81.3.pdf).'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jim Gray，“事务概念：优点和局限性”（Tandem Computers，技术报告81.3，1981年6月），[http://www.hpl.hp.com/techreports/tandem/TR-81.3.pdf](http://www.hpl.hp.com/techreports/tandem/TR-81.3.pdf).
- en: 'Update in place: a poison apple?'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原地更新：一个毒苹果？
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When bookkeeping was done with clay tablets or paper and ink, accountants developed
    some clear rules about good accounting practices. One of the cardinal rules is
    double-entry bookkeeping so that calculations are self checking, thereby making
    them fail-fast. A second rule is that one never alters the books; if an error
    is made, it is annotated and a new compensating entry is made in the books. The
    books are thus a complete history of the transactions of the business...
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用粘土板或纸张和墨水进行账目管理时，会计师们制定了一些关于良好会计实践的明确规则。其中一条基本规则是复式记账，这样计算可以自我校验，从而实现快速失败。第二条规则是永远不更改账簿；如果出错，则进行标注并在账簿中做出新的补偿性记录。因此，账簿是商业交易完整的历史记录...
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Update-in-place strikes many systems designers as a cardinal sin: it violates
    traditional accounting practices which have been observed for hundreds of years.'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在地更新（Update-in-place）在很多系统设计师看来是一种严重的罪行：它违反了数百年来一直观察到的传统会计实践。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The answer is simple. As with double-entry accounting, instead of changing what
    existed previously, you create new data to represent the new state. Instead of
    adding an element to an existing list, you create a new list with the added element.
    The main benefit is that if another thread was manipulating the list at insertion
    time, it’s not affected by the change because it doesn’t see it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单。与复式记账一样，而不是改变之前存在的内容，你创建新的数据来表示新的状态。而不是向现有列表中添加一个元素，你创建一个新的列表，包含这个添加的元素。主要好处是，如果另一个线程在插入时正在操作列表，它不会受到变化的影响，因为它看不到这个变化。
- en: 'Generally, this conception immediately raises two protests:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种观念会立即引起两个抗议：
- en: If the other thread doesn’t see the change, it’s manipulating stale data.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其他线程没有看到这个变化，它正在操作过时的数据。
- en: Making a new copy of the list with the added element is a time- and memory-consuming
    process, so immutable data structures lead to very poor performance.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用添加的元素创建新的列表副本是一个耗时且消耗内存的过程，因此不可变数据结构会导致非常差的性能。
- en: Both arguments are fallacious. The thread manipulating the “stale data” is in
    fact manipulating the data as it was when it started reading it. If inserting
    an element occurs after the manipulation is finished, there’s no concurrency problem.
    But if the insertion occurs while the manipulation is going on, what would occur
    with a mutable data structure? Either it wouldn’t be protected against concurrent
    access, and the data might be corrupted or the result false (or both), or some
    protection mechanism would lock the data, delaying the insertion until after the
    manipulation by the first thread is completed. In the second case, the end result
    would be exactly the same as with an immutable structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个论点都是错误的。操作“过时数据”的线程实际上是在操作它开始读取时的数据。如果插入元素发生在操作完成后，就不会出现并发问题。但如果插入操作在操作进行时发生，可变数据结构会发生什么？要么它不会保护并发访问，数据可能会被破坏或结果错误（或两者兼而有之），或者某种保护机制会锁定数据，直到第一个线程的操作完成后才进行插入。在后一种情况下，最终结果将与不可变结构完全相同。
- en: 5.1.5\. Persistent data structures
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.5\. 持久数据结构
- en: As you saw in the previous section, making a copy (sometimes called a *defensive
    copy*) of the data structure before inserting an element is often considered a
    time-consuming operation that leads to poor performance. This isn’t the case if
    you use data sharing, which is possible because immutable data structures are
    persistent. [Figure 5.2](#ch05fig02) shows how elements could be removed and added
    to create a new, immutable, singly linked list with optimal performance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一节中看到的，在插入元素之前对数据结构进行复制（有时称为*防御性复制*）通常被认为是一种耗时且性能较差的操作。如果你使用数据共享，情况并非如此，因为不可变数据结构是持久的。[图
    5.2](#ch05fig02) 展示了如何移除和添加元素以创建一个新的、不可变的、单链表，并具有最佳性能。
- en: Figure 5.2\. Removing and adding elements without mutation or copying
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 不进行变异或复制地移除和添加元素
- en: '![](Images/05fig02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02.jpg)'
- en: As you can see, no copying occurs at all. The result is that such a list might
    be more performant for removing and inserting elements than a mutable list. So
    functional data structures (immutable and persistent) are not always slower than
    mutable ones. They’re often even faster (although they might be slower on some
    operations). In any case, they’re much safer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，根本不会发生任何复制。结果是，这种列表在移除和插入元素方面可能比可变列表更高效。因此，函数式数据结构（不可变和持久）并不总是比可变结构慢。它们通常甚至更快（尽管在某些操作上可能较慢）。无论如何，它们的安全性要高得多。
- en: 5.2\. An immutable, persistent, singly linked list implementation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 一个不可变、持久的单链表实现
- en: 'The structure of the singly linked list shown in [figures 5.1](#ch05fig01)
    and [5.2](#ch05fig02) is theoretical. The list can’t be implemented that way,
    because elements can’t be linked to one another. They’d have to be special elements
    to allow linking, and you want your lists to be able to store any elements. The
    solution is to devise a recursive list structure composed of the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.1](#ch05fig01) 和 [5.2](#ch05fig02) 中所示的单链表结构是理论上的。列表不能以这种方式实现，因为元素不能相互链接。它们必须是特殊的元素以允许链接，而您希望您的列表能够存储任何元素。解决方案是设计一个由以下组成的递归列表结构：'
- en: An element that will be the first element of the list, also called the *head*.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将成为列表第一个元素的元素，也称为 *头*。
- en: The rest of the list, which is a list by itself and is called the *tail*.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的其余部分，它本身也是一个列表，称为 *尾*。
- en: 'Note that you already encountered a generic element that’s composed of two
    elements of different types: the `Tuple`. A singly linked list of elements of
    type `A` is in fact a `Tuple<A, List<A>>`. You could then define a list as'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您已经遇到了一个由两种不同类型的元素组成的泛型元素：`Tuple`。类型为 `A` 的元素的单链表实际上是一个 `Tuple<A, List<A>>`。然后您可以定义列表为
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But as I explained in [chapter 4](kindle_split_011.xhtml#ch04), you need a terminal
    case, as you do in every recursive definition. By convention, this terminal case
    is called `Nil` and corresponds to the empty list. And because `Nil` has no head
    nor tail, it’s not a `Tuple`. Your new definition of a list is either
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我在 [第 4 章](kindle_split_011.xhtml#ch04) 中解释的，您需要一个终止情况，就像在每一个递归定义中一样。按照惯例，这个终止情况被称为
    `Nil`，对应于空列表。由于 `Nil` 没有头和尾，它不是一个 `Tuple`。您的新列表定义可以是
- en: An empty list (`Nil`)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表 (`Nil`)
- en: A tuple of an element and a list
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个元素和列表的元组
- en: 'Instead of using a `Tuple` with properties `_1` and `_2`, you’ll create a specific
    `List` class with two properties: `head` and `tail`. This will simplify the handling
    of the `Nil` case. [Figure 5.3](#ch05fig03) shows the structure of your list implementation.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用具有 `_1` 和 `_2` 属性的 `Tuple`，您将创建一个具有两个属性（`head` 和 `tail`）的特定 `List` 类。这将简化对
    `Nil` 情况的处理。[图 5.3](#ch05fig03) 展示了您的列表实现的结构。
- en: Figure 5.3\. The representation of the singly linked list implementation
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 单链表实现的表示
- en: '![](Images/05fig03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03.jpg)'
- en: '[Listing 5.1](#ch05ex01) shows the basic implementation of this list.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.1](#ch05ex01) 展示了该列表的基本实现。'
- en: Listing 5.1\. Singly linked lists
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. 单链表
- en: '![](Images/ch05ex01-0.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch05ex01-0.jpg)'
- en: '![](Images/ch05ex01-1.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch05ex01-1.jpg)'
- en: 'The list class is implemented as an abstract class. The `List` class contains
    two private static subclasses to represent the two possible forms a `List` can
    take: `Nil` for an empty list, and `Cons` for a non-empty one.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表类被实现为一个抽象类。`List` 类包含两个私有静态子类来表示 `List` 可能采取的两种形式：`Nil` 用于空列表，`Cons` 用于非空列表。
- en: 'The `List` class defines three abstract methods: `head()`, which will return
    the first element of the list; `tail()`, which will return the rest of the list
    (without the first element); and `isEmpty(),` which will return `true` if the
    list is empty and `false` otherwise. The `List` class is parameterized with type
    parameter `A`, which represents the type of the list elements.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 类定义了三个抽象方法：`head()`，它将返回列表的第一个元素；`tail()`，它将返回列表的其余部分（不包括第一个元素）；以及 `isEmpty()`，如果列表为空则返回
    `true`，否则返回 `false`。`List` 类使用类型参数 `A` 进行参数化，它表示列表元素的类型。'
- en: 'Subclasses have been made private, so you construct lists through calls to
    the static factory methods. These methods can be statically imported:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 子类已被设置为私有，因此您通过调用静态工厂方法来构建列表。这些方法可以静态导入：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They can then be used without referencing the enclosing class, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们可以不引用封装的类而使用，如下所示：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the empty list has no type parameter. In other words, it’s a raw type
    that can be used to represent an empty list of elements of any types. As such,
    creating or using an empty list will generate a warning by the compiler. The advantage
    is that you can use a singleton for the empty list. Another solution would have
    been to use a parameterized empty list, but this would have caused much trouble.
    You’d have had to create a different empty list for each type parameter. To solve
    this problem, you use a singleton empty list with no parameter type. This generates
    a compiler warning. In order to restrict this warning to the `List` class and
    not let it leak to the `List` users, you don’t give direct access to the singleton.
    That’s why there’s a (parameterized) static method to access the singleton, and
    a `@SuppressWarnings("rawtypes")` on the `NIL` property, as well as a `@SuppressWarnings("unchecked")`
    on the `list()` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，空列表没有类型参数。换句话说，它是一个原始类型，可以用来表示任何类型的空元素列表。因此，创建或使用空列表将生成编译器警告。优点是你可以使用一个单例来表示空列表。另一个解决方案是使用参数化的空列表，但这会带来很多麻烦。你将不得不为每个类型参数创建一个不同的空列表。为了解决这个问题，你使用一个没有参数类型的单例空列表。这会生成编译器警告。为了将这个警告限制在
    `List` 类中，而不是让它泄露到 `List` 用户那里，你不直接提供对单例的访问。这就是为什么有一个（参数化的）静态方法来访问单例，以及 `@SuppressWarnings("rawtypes")`
    在 `NIL` 属性上，以及 `@SuppressWarnings("unchecked")` 在 `list()` 方法上。
- en: 'Note that the `list(A ... a)` method is annotated with `@SafeVarargs` to indicate
    that the method doesn’t do anything that could lead to heap pollution. This method
    uses an imperative implementation based on a `for` loop. This isn’t very “functional,”
    but it’s a trade-off for simplicity and performance. If you insist on implementing
    it in a functional way, you can do so. All you need is a function taking an array
    as its argument and returning its last element, and another one to return the
    array without its last element. Here’s one possible solution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`list(A ... a)` 方法被注解为 `@SafeVarargs`，以表明该方法不会执行可能导致堆污染的操作。此方法使用基于 `for`
    循环的命令式实现。这并不非常“函数式”，但这是简单性和性能之间的权衡。如果你坚持要以函数式方式实现它，你也可以做到。你所需要的是一个接受数组作为参数并返回其最后一个元素的函数，以及另一个返回没有最后一个元素的数组的函数。这里有一个可能的解决方案：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Be sure, however, not to use this implementation, because it’s 10,000 times
    slower than the imperative one. This is a good example of when not to be blindly
    functional. The imperative version has a functional interface, and this is what
    you need. Note that recursion isn’t the problem. Recursion using `TailCall` is
    nearly as fast as iteration. The problem here is the `copyOfRange` method, which
    is very slow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，务必不要使用这个实现，因为它比命令式实现慢 10,000 倍。这是一个很好的例子，说明何时不要盲目地追求函数式。命令式版本有一个函数式接口，这正是你所需要的。注意，递归并不是问题。使用
    `TailCall` 的递归几乎和迭代一样快。这里的问题是 `copyOfRange` 方法，它非常慢。
- en: 5.3\. Data sharing in list operations
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 列表操作中的数据共享
- en: One of the huge benefits of immutable persistent data structures like the singly
    linked list is the performance boost provided by data sharing. You can already
    see that accessing the first element of the list is immediate. It’s just a matter
    of calling the `head()` method, which is a simple accessor for the `head` property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表等不可变持久数据结构的一个巨大好处是数据共享带来的性能提升。你已经在列表的第一个元素访问上是即时的。这只是一个调用 `head()` 方法的简单操作，它是对
    `head` 属性的简单访问器。
- en: Removing the first element is equally fast. Just call the `tail()` method, which
    will return the `tail` property. Now let’s see how to get a new list with an additional
    element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 移除第一个元素同样快速。只需调用 `tail()` 方法，它将返回 `tail` 属性。现在让我们看看如何获取一个包含额外元素的新列表。
- en: Exercise 5.1
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.1
- en: Implement the instance functional method `cons`, adding an element at the beginning
    of a list. (Remember *cons* stands for *construct*.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 实现实例函数式方法 `cons`，在列表的开始处添加一个元素。（记住 *cons* 代表 *construct*。）
- en: Solution 5.1
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.1
- en: 'This instance method has the same implementation for the `Nil` and `Cons` subclasses:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例方法对 `Nil` 和 `Cons` 子类有相同的实现：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise 5.2
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.2
- en: Implement `setHead`, an instance method for replacing the first element of a
    `List` with a new value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `setHead`，这是一个实例方法，用于用新值替换 `List` 的第一个元素。
- en: Solution 5.2
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.2
- en: 'You might think of implementing a static method for this, but you’d have to
    test for an empty list:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑实现一个静态方法来处理这个问题，但你将不得不测试空列表：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This makes little sense. As a general rule, if you find yourself forced to use
    an `if ... else` structure, you’re probably on the wrong path. Think of how you’d
    implement instance methods calling this static one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎没有什么意义。一般来说，如果你发现自己被迫使用 `if ... else` 结构，你可能走错了路。想想你将如何实现调用此静态方法的实例方法。
- en: 'A much better solution is to add an abstract method to the `List` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是在 `List` 类中添加一个抽象方法：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implementation in the `Nil` subclass is straightforward. Just throw an exception,
    because trying to access the head of an empty list is considered a bug:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Nil` 子类中的实现很简单。只需抛出一个异常，因为尝试访问空列表的头部被认为是错误：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Cons` implementation corresponds to the `else` clause of the static method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cons` 实现对应于静态方法的 `else` 子句：'
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And if you need a static method, it can simply call the instance implementation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个静态方法，它可以直接调用实例实现：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Exercise 5.3
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.3
- en: Write a `toString` method to display the content of a list. An empty list will
    be displayed as `"[NIL]"`, and a list containing the integers from 1 to 3 will
    be displayed as `"[1, 2, 3, NIL]"`. For a list of arbitrary objects, the `toString`
    method will be called to display each object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `toString` 方法来显示列表的内容。空列表将显示为 `"[NIL]"`，包含从 1 到 3 的整数的列表将显示为 `"[1, 2, 3,
    NIL]"`。对于任意对象的列表，将调用 `toString` 方法来显示每个对象。
- en: Solution 5.3
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.3
- en: 'The `Nil` implementation is very simple:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil` 实现非常简单：'
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `cons` method is recursive and uses a `StringBuilder` as the accumulator.
    Note that the `StringBuilder`, although it’s a mutable object, has a functional-friendly
    `append` method, because it returns the mutated `StringBuilder` instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`cons` 方法是递归的，并使用 `StringBuilder` 作为累加器。请注意，尽管 `StringBuilder` 是一个可变对象，但它有一个功能友好的
    `append` 方法，因为它返回被修改的 `StringBuilder` 实例。'
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have problems remembering how the `TailCall` class is used to make recursion
    work from the heap rather than from the stack, please refer to [chapter 4](kindle_split_011.xhtml#ch04).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不住如何使用 `TailCall` 类从堆而不是从栈中使递归工作，请参阅[第 4 章](kindle_split_011.xhtml#ch04)。
- en: 5.3.1\. More list operations
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 更多列表操作
- en: You can rely on data sharing to implement various other operations in a very
    efficient way—often more efficiently than what can be done with mutable lists.
    In the rest of this section, you’ll add functionality to the linked list based
    on data sharing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以依赖数据共享以非常高效的方式实现各种其他操作——通常比使用可变列表更高效。在本节的其余部分，你将基于数据共享向链表添加功能。
- en: Exercise 5.4
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.4
- en: The `tail` method, although it doesn’t mutate the list in any way, has the same
    effect as removing the first element. Write a more general method, `drop`, that
    removes the first `n` elements from a list. Of course, this method won’t remove
    the element, but will return a new list corresponding to the intended result.
    This “new” list won’t be anything new, because data sharing will be used, so nothing
    will be created. [Figure 5.4](#ch05fig04) shows how you should proceed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 方法虽然不会以任何方式修改列表，但其效果与删除第一个元素相同。编写一个更通用的方法 `drop`，从列表中删除前 `n` 个元素。当然，这个方法不会删除元素，但会返回一个对应于预期结果的新列表。这个“新”列表实际上不会是新创建的，因为将使用数据共享，所以不会创建任何内容。[图
    5.4](#ch05fig04) 展示了你应该如何进行。'
- en: Figure 5.4\. Dropping the *n* first elements of a list while not mutating or
    creating anything.
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4. 在不修改或创建任何内容的情况下删除列表的前 *n* 个元素。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: The signature of the method will be
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的签名将是
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Hint
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You should use recursion to implement the `drop` method. And don’t forget to
    consider every special case, such as an empty list, or `n` being higher than the
    list length.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用递归来实现 `drop` 方法。并且不要忘记考虑每个特殊情况，例如空列表，或者 `n` 大于列表长度。
- en: Solution 5.4
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.4
- en: 'Here, you have the choice to implement a static method or instance methods.
    Instance methods are needed if you want to use object notation, which is much
    easier to read. For example, if you want to drop two elements of a list of integers
    and then replace the first element of the result with `0`, you could use static
    methods:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有选择实现静态方法或实例方法。如果你想要使用对象表示法，实例方法就是必需的，因为这种表示法更容易阅读。例如，如果你想删除整数列表中的两个元素，然后将结果列表的第一个元素替换为
    `0`，你可以使用静态方法：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each time you add a method to the process, the method name is added to the left,
    and the additional arguments, besides the list itself, are added to the right,
    as shown in [figure 5.5](#ch05fig05).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你向过程添加一个方法时，方法名被添加到左侧，而除了列表本身之外的其他参数被添加到右侧，如图[图5.5](#ch05fig05)所示。
- en: Figure 5.5\. Without object notation, composed functions may be difficult to
    read. Using object notation results in much more readable code.
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5。没有对象表示法，组合函数可能难以阅读。使用对象表示法可以使代码更易于阅读。
- en: '![](Images/05fig05.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05.jpg)'
- en: 'Using object notation makes the code much easier to read:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象表示法使代码更容易阅读：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementation of the `drop` method in the `Nil` class simply returns `this`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil`类中`drop`方法的实现简单地返回`this`：'
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `Cons` class, you use a private helper method to implement recursion
    in the same way you learned in [chapter 4](kindle_split_011.xhtml#ch04). This
    code assumes that the methods `TailCall.ret` and `TailCall.sus` are imported statically:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cons`类中，你使用一个私有辅助方法以与你在[第4章](kindle_split_011.xhtml#ch04)中学到的方式相同来实现递归。此代码假定方法`TailCall.ret`和`TailCall.sus`已静态导入：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that you have to test for an empty list parameter. This wouldn’t be necessary
    if the `drop` method were recursive. But only the `drop_` helper method is recursive,
    and this method isn’t defined for `Nil`. Forgetting to test for the empty list
    would result in an exception being thrown while calling `list.tail()`. Of course,
    you’d need a better way to handle this case. After all, dropping four elements
    of a list of three makes little sense. You could throw an exception, but it would
    be better to use more-functional techniques that you’ll learn in the next chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须测试空列表参数。如果`drop`方法是递归的，这就不必要了。但只有`drop_`辅助方法是递归的，而这个方法没有为`Nil`定义。忘记测试空列表会导致在调用`list.tail()`时抛出异常。当然，你需要一种更好的方法来处理这种情况。毕竟，从包含三个元素的列表中删除四个元素几乎没有意义。你可以抛出异常，但使用你将在下一章中学习的更函数式的技术会更好。
- en: Exercise 5.5
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习5.5
- en: 'Implement a `dropWhile` method to remove elements from the head of the `List`
    as long as a condition holds true. Here’s the signature to add to the `List` abstract
    class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`dropWhile`方法，从`List`的头部删除元素，直到条件为真。以下是添加到`List`抽象类中的签名：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Solution 5.5
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案5.5
- en: 'We won’t look at the `Nil` implementation because it will only return `this`.
    The implementation for the `Cons` class is recursive:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会查看`Nil`的实现，因为它只会返回`this`。`Cons`类的实现是递归的：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that when calling `dropWhile` on an empty list, you may face a problem.
    The following code, for example, won’t compile:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在空列表上调用`dropWhile`时，你可能会遇到问题。例如，以下代码将无法编译：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The reason for this is that Java is unable to infer the type of the list from
    the function you pass to the `dropWhile` method. Let’s say you’re dealing with
    a list of integers. You can then use either this solution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是Java无法从传递给`dropWhile`方法的函数中推断出列表的类型。假设你正在处理一个整数列表。然后你可以使用以下解决方案：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'or this one:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这个：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Concatenating lists
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表连接
- en: A very common operation on lists consists of “adding” one list to another to
    form a new list that contains all elements of both original lists. It would be
    nice to be able to simply link both lists, but this isn’t possible. The solution
    is to add all elements of one list to the other list. But elements can only be
    added to the front (head) of the list, so if you want to concatenate `list1` to
    `list2`, you must start by adding the last element of `list1` to the front of
    `list2`, as indicated in [figure 5.6](#ch05fig06).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上非常常见的操作是将一个列表“添加”到另一个列表中，以形成一个包含两个原始列表所有元素的新列表。能够简单地链接两个列表将很方便，但这是不可能的。解决方案是将一个列表的所有元素添加到另一个列表中。但元素只能添加到列表的前端（头部），因此如果你想将`list1`连接到`list2`，你必须首先将`list1`的最后一个元素添加到`list2`的前端，如图[图5.6](#ch05fig06)所示。
- en: Figure 5.6\. Sharing data by concatenation. You can see that both lists are
    preserved and that `list2` is shared by the resulting list. But you can also see
    that you can’t proceed exactly as is indicated in the figure, because you’d have
    to access the last element of `list1` first, which isn’t possible due to the structure
    of the list.
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6。通过连接共享数据。你可以看到两个列表都被保留，并且`list2`被结果列表共享。但你也看到，你不能像图中所示那样直接进行，因为你必须首先访问`list1`的最后一个元素，这是由于列表的结构而不可能的。
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig06_alt.jpg)'
- en: 'One way to proceed is to first reverse `list1`, producing a new list, and then
    add each element to `list2`, this time starting from the head of the reversed
    list. But you haven’t yet defined a reverse method. Can you still define `concat`?
    Yes you can. Just consider how you could define this method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一种进行的方法是首先反转`list1`，生成一个新的列表，然后从反转列表的头部开始将每个元素添加到`list2`中。但你还没有定义一个反转方法。你还能定义`concat`吗？是的，你可以。只需考虑你如何定义这个方法：
- en: If `list1` is empty, return `list2`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`list1`为空，则返回`list2`。
- en: Else return the addition of the first element (`list1.head`) of `list1` to the
    concatenation of the rest of `list1` (`list1.tail`) to `list2`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回`list1`的第一个元素（`list1.head`）与`list1`的其余部分（`list1.tail`）连接到`list2`的结果。
- en: 'This recursive definition can be translated into code as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种递归定义可以转换为以下代码：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The beauty of this solution (for some readers) is that you don’t need a figure
    to expose how it works, because it isn’t “working.” It’s just a mathematical definition
    translated into code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案（对于一些读者来说）的美丽之处在于，你不需要一个图来展示它是如何工作的，因为它并不是“工作”。它只是一个数学定义转换成代码。
- en: The main drawback of this definition (for other readers) is that, for the same
    reason, you can’t easily represent it in a figure. This may sound like humor,
    but it’s not. Both solutions represent exactly the same “operation,” but one represents
    the process (from which you can see the result) and the other expresses the result
    directly. Whichever is better is a matter of choice. But functional programming
    most often involves thinking in terms of what the intended result is, rather than
    how to obtain it. Functional code is a direct translation of the definition into
    code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义（对于其他读者来说）的主要缺点是，由于同样的原因，你无法轻易地用图表示它。这听起来可能像幽默，但不是。这两种解决方案代表的是完全相同的“操作”，但一个表示过程（从中你可以看到结果），而另一个直接表达结果。哪种更好取决于选择。但函数式编程通常涉及思考预期的结果，而不是如何获得它。函数式代码是定义直接转换成代码。
- en: Obviously, this code will overflow the stack if `list1` is too long, although
    you’ll never have a stack problem with the length of `list2`. The consequence
    is that you won’t have to worry if you’re careful to only add small lists to the
    front end of lists of any length.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果`list1`太长，这段代码将导致栈溢出，尽管你永远不会遇到`list2`长度的栈问题。结果是，如果你小心只将小列表添加到任何长度的列表的前端，你不必担心。
- en: 'An important point to note is that what you’re actually doing is adding elements
    of the first list, in reverse order, to the front of the second list. This is
    obviously different from the common sense understanding of concatenation: adding
    the second list to the tail of the first one. This is definitely not how it works
    with the singly linked list.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是，你实际上所做的操作是将第一个列表的元素以相反的顺序添加到第二个列表的前面。这显然与我们对连接的常识理解不同：将第二个列表添加到第一个列表的尾部。这绝对不是单链表的工作方式。
- en: If you need to concatenate lists of arbitrary length, you can just apply what
    you learned in [chapter 4](kindle_split_011.xhtml#ch04) to make the `concat` method
    stack-safe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要连接任意长度的列表，你只需应用你在[第4章](kindle_split_011.xhtml#ch04)中学到的知识，使`concat`方法栈安全。
- en: If you ponder what you’ve done, you might guess that there’s much room left
    for abstraction here. What if the `concat` method were only a specific application
    of a much more general operation? Maybe you could abstract this operation, make
    it stack-safe, and then reuse it to implement many other operations? Wait and
    see!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考你所做的事情，你可能会猜测这里还有很大的抽象空间。如果`concat`方法只是更通用操作的一个特定应用呢？也许你可以抽象这个操作，使其栈安全，然后重用它来实现许多其他操作？等等，看看会发生什么！
- en: You may have noticed that the complexity of this operation (and hence the time
    it’ll take to be executed by Java) is proportional to the length of the first
    list. In other words, if you concatenate `list1` and `list2`, of length `n1` and
    `n2`, the complexity is O(*n*1), which means it’s independent of `n2`. In other
    words, depending on `n2`, this operation may be more efficient than concatenating
    two mutable lists in imperative Java.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这个操作的复杂度（以及Java执行它所需的时间）与第一个列表的长度成正比。换句话说，如果你连接长度为`n1`的`list1`和长度为`n2`的`list2`，其复杂度为O(*n*1)，这意味着它与`n2`无关。换句话说，根据`n2`的不同，这个操作可能比在命令式Java中连接两个可变列表更高效。
- en: Dropping from the end of the list
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从列表末尾删除
- en: It’s sometimes necessary to remove elements from the end of a list. Although
    the singly linked list is not the ideal data structure for this kind of operation,
    you must still be able to implement it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要从列表的末尾移除元素。尽管单链表不是这种操作的理想数据结构，但你必须仍然能够实现它。
- en: Exercise 5.6
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.6
- en: 'Write a method to remove the last element from a list. This method should return
    the resulting list. Implement it as an instance method with the following signature:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个方法来从列表中移除最后一个元素。此方法应返回结果列表。将其实现为以下签名的实例方法：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Hint
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: There might be a way to express this function in terms of another one, and one
    we’ve already spoken about. Maybe now would be the right time to create this helper
    function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种方法可以用另一个我们已经讨论过的函数来表示这个函数。也许现在是创建这个辅助函数的正确时机。
- en: Solution 5.6
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 5.6
- en: 'To remove the last element, you have to traverse the list (from front to back)
    and build up the new list (from back to front, because the “last” element in a
    list must be `Nil`). This is a consequence of the way lists are created with `Cons`
    objects. This results in a list with the elements in reverse order, so the resulting
    list must be reversed. That means you only have to implement a `reverse` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除最后一个元素，你必须遍历列表（从前往后）并构建新的列表（从后往前，因为列表中的“最后一个”元素必须是 `Nil`）。这是使用 `Cons` 对象创建列表的方式的结果。这导致了一个元素顺序相反的列表，所以结果列表必须反转。这意味着你只需要实现一个
    `reverse` 方法：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the reverse method, you can implement `init` very easily:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反转方法，你可以非常容易地实现 `init`：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, these are the implementations for the `Cons` class. In the `Nil`
    class, the `reverse` method returns `this`, and the `init` method throws an exception.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些都是 `Cons` 类的实现。在 `Nil` 类中，`reverse` 方法返回 `this`，而 `init` 方法抛出异常。
- en: 5.4\. Using recursion to fold lists with higher-order functions
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 使用递归和高级函数折叠列表
- en: In [chapter 3](kindle_split_010.xhtml#ch03), you learned how to fold lists,
    and folding applies to immutable lists as well. But with mutable lists, you had
    the choice to implement these operations through iteration or recursively. In
    [chapter 3](kindle_split_010.xhtml#ch03), you implemented folds iteratively because
    you were using mutable lists, where adding and removing elements was done in place
    by nonfunctional methods. The `add` method returned nothing, and the `remove`
    method returned only the removed element, while modifying the list argument. Because
    immutable lists are recursive data structures, you can very easily use recursion
    to implement folding operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_010.xhtml#ch03) 中，你学习了如何折叠列表，折叠也适用于不可变列表。但是，对于可变列表，你可以选择通过迭代或递归来实现这些操作。在
    [第 3 章](kindle_split_010.xhtml#ch03) 中，你通过迭代实现了折叠，因为你使用了可变列表，其中通过非函数式方法在原地添加和移除元素。`add`
    方法不返回任何内容，而 `remove` 方法只返回被移除的元素，同时修改列表参数。因为不可变列表是递归数据结构，你可以非常容易地使用递归来实现折叠操作。
- en: Let’s consider common folding operations on lists of numbers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑数字列表的常见折叠操作。
- en: Exercise 5.7
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.7
- en: Write a functional method to compute the sum of all elements of a list of integers
    using simple stack-based recursion.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数式方法来计算包含整数的列表中所有元素之和，使用简单的基于栈的递归。
- en: Solution 5.7
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 5.7
- en: The recursive definition of the sum of all elements of a list is
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中所有元素之和的递归定义是
- en: 'For an empty list: 0'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于空列表：0
- en: 'For a non-empty list: head plus the sum of the tail'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非空列表：头部加上尾部之和
- en: 'This translates nearly word-for-word into Java code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎可以逐字逐句翻译成 Java 代码：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Don’t forget that this implementation will overflow the stack for long lists,
    so don’t use this kind of code in production.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，对于长列表，这种实现将导致栈溢出，所以不要在生产环境中使用这种代码。
- en: Exercise 5.8
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.8
- en: Write a functional method to compute the product of all elements of a list of
    doubles using simple stack-based recursion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数式方法来计算包含双精度浮点数的列表中所有元素之积，使用简单的基于栈的递归。
- en: Solution 5.8
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解答 5.8
- en: The recursive definition of the product of all elements of a non-empty list
    is
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 非空列表中所有元素之积的递归定义是
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But what should it return for an empty list? Of course, if you remember your
    math courses, you’ll know the answer. If you don’t, you may find the answer in
    the requirement for a non-empty list shown in solution 5.7.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于空列表，它应该返回什么？当然，如果你还记得你的数学课程，你会知道答案。如果你不记得，你可以在解答 5.7 中显示的非空列表的要求中找到答案。
- en: 'Consider what will happen when you’ve applied the recursive formula to all
    elements. You’ll end up with a result that will have to be multiplied by the product
    of all elements of an empty list. Because you want to eventually get this result,
    you have no choice but to say that the product of all elements of an empty list
    is 1\. This is the same situation as with the sum example, when you use 0 as the
    sum of all elements of an empty list. The identity element, or neutral element,
    for the sum operation is 0, and the identity or neutral element for the product
    is 1\. So your `product` method could be written as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当你将递归公式应用于所有元素时会发生什么。你最终会得到一个结果，这个结果必须乘以空列表所有元素的总乘积。因为你最终想要得到这个结果，你别无选择，只能认为空列表所有元素的总乘积是
    1。这与使用 0 作为空列表所有元素的总和的情况相同。求和操作的恒等元素或中性元素是 0，而乘法的恒等或中性元素是 1。所以你的 `product` 方法可以写成以下形式：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that the product operation is different from the sum operation in one
    important way. It has an *absorbing element*, which is an element that satisfies
    the following condition:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，乘法操作在一点上与求和操作不同。它有一个 *吸收元素*，它满足以下条件：
- en: '*a × absorbing element = absorbing element × a = absorbing element*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*a × 吸收元素 = 吸收元素 × a = 吸收元素*'
- en: 'The absorbing element for multiplication is 0\. By analogy, the absorbing element
    of any operation (if it exists) is also called the *zero element*. The existence
    of a zero element allows you to escape the computation, also called *short circuiting*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法的吸收元素是 0。类似地，任何操作（如果存在）的吸收元素也被称为 *零元素*。零元素的存在允许你避免计算，也称为 *短路*：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But forget about this optimized version and look at the definitions for `sum`
    and `product`. Can you detect a pattern that could be abstracted? Let’s look at
    them side by side (after having changed the parameter name):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但先忘记这个优化版本，看看 `sum` 和 `product` 的定义。你能发现可以抽象的模式吗？让我们将它们并排放置（在更改参数名称之后）：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now let’s remove the differences and replace them with a common notation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们消除差异，用共同的符号替换它们：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The two operations are nearly the same. If you can find a way to abstract the
    common parts, you’ll just have to provide the variable information (`Type`, `operation`,
    `identity`, and `operator`) to implement both operations without repeating yourself.
    This common operation is what we call a *fold*, which you studied in [chapter
    3](kindle_split_010.xhtml#ch03). In that chapter, you learned that there are two
    kinds of folds—right fold and left fold—as well as a relation between these two
    operations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作几乎相同。如果你能找到一种方法来抽象共同的部分，你只需提供变量信息（`Type`、`operation`、`identity` 和 `operator`）就可以实现这两个操作，而无需重复。这种共同的操作就是我们所说的
    *折叠*，你在[第 3 章](kindle_split_010.xhtml#ch03) 中学习过。在第 3 章中，你了解到有两种折叠——右折叠和左折叠，以及这两种操作之间的关系。
- en: '[Listing 5.2](#ch05ex02) shows the common parts of the sum and product operations
    abstracted into a method called `foldRight`, taking as its parameters the list
    to fold, an identity element, and a higher-order function representing the operation
    used to fold the list. The identity element is obviously the identity for the
    given operation, and the function is in curried form. (See [chapter 2](kindle_split_009.xhtml#ch02)
    if you don’t remember what this means.) This function represents the operator
    portion of your code.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.2](#ch05ex02) 展示了求和和乘法操作中抽象出来的一个名为 `foldRight` 的方法，它接受折叠的列表、一个恒等元素以及一个表示折叠列表所使用的操作的更高阶函数作为参数。恒等元素显然是给定操作的恒等元素，而函数是柯里化形式。（如果你不记得这是什么意思，请参阅[第
    2 章](kindle_split_009.xhtml#ch02)。）这个函数代表了代码的运算符部分。'
- en: Listing 5.2\. Implementing `foldRight` and using it for `sum` and `product`
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 实现 `foldRight` 并使用它进行 `sum` 和 `product`
- en: '![](Images/142fig01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/142fig01.jpg)'
- en: Note that the `Type` variable part has been replaced with two types here, `A`
    and `B`. This is because the result of folding isn’t always of the same type as
    the elements of the list. Here, it’s abstracted a bit more than is needed for
    the sum and product operations, but this will be useful soon.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Type` 变量部分在这里被替换成了两种类型，`A` 和 `B`。这是因为折叠的结果并不总是与列表的元素具有相同的类型。在这里，它比求和和乘法操作所需的抽象程度更高，但很快就会派上用场。
- en: The `operation` variable part is, of course, the names of the two methods.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`operation` 变量部分当然是两个方法的名字。'
- en: 'The fold operation isn’t specific to arithmetic computations. You can use a
    fold to transform a list of characters into a string. In such a case, `A` and
    `B` are two different types: `Char` and `String`. But you can also use a fold
    to transform a list of strings into a single string. Can you see now how you could
    implement `concat`?'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠操作并不仅限于算术计算。你可以使用折叠将字符列表转换为字符串。在这种情况下，`A`和`B`是两种不同的类型：`Char`和`String`。但你也可以使用折叠将字符串列表转换为单个字符串。你现在能看出如何实现`concat`吗？
- en: By the way, `foldRight` is very similar to the singly linked list itself. If
    you think of the list 1, 2, 3 as
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`foldRight`与单链表本身非常相似。如果你把列表1, 2, 3想象成
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'you can see immediately that it’s very similar to a right fold:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看出它与右折叠非常相似：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But perhaps you’ve already realized that `Nil` is the identity for adding elements
    to lists. This make sense: if you want to transform a list of characters into
    a string, you have to start with an empty list. (By the way, `Nil` is also the
    identity for list concatenation, although you could do without it, provided the
    list of lists to be concatenated isn’t empty. In such a case, it’s called a *reduce*
    rather than a *fold*. But this is possible only because the result is of the same
    type as the elements.)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你已经意识到`Nil`是向列表添加元素的恒等元素。这很有道理：如果你想将字符列表转换为字符串，你必须从一个空列表开始。（顺便说一句，`Nil`也是列表连接的恒等元素，尽管在没有空列表的情况下你也可以做到这一点。在这种情况下，它被称为*reduce*而不是*fold*。但这只因为结果是元素类型的相同。）
- en: 'This can be put in practice by passing `Nil` and `cons` to `foldRight` as the
    identity and the function that are used to fold:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将`Nil`和`cons`传递给`foldRight`作为折叠的恒等元素和函数来实现：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This simply produces a new list with the same elements in the same order, as
    you can see by running the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地产生一个新的列表，其元素顺序与原列表相同，正如你可以通过运行以下代码看到的那样：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code produces the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生以下输出：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s a trace of what’s happening at each step:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每一步发生情况的跟踪：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exercise 5.9
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.9
- en: Write a method to compute the length of a list. This method will use the `foldRight`
    method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算列表长度的方法。这个方法将使用`foldRight`方法。
- en: Solution 5.9
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.9
- en: The `Nil` implementation is obvious and returns 0\. The `Cons` implementation
    may be written as
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil`的实现很明显，返回0。`Cons`的实现可以写成'
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that this implementation, beside being stack-based recursive, has very
    poor performance. Even if transformed to heap-based, it’s still O(*n*), meaning
    the time needed to return the length is proportional to the length of the list.
    In following chapters, you’ll see how to get the length of a linked list in constant
    time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个实现，除了基于栈的递归之外，性能非常差。即使转换为基于堆的，它仍然是O(*n*)，这意味着返回长度所需的时间与列表的长度成正比。在接下来的章节中，你将看到如何以常数时间获取链表的长度。
- en: Exercise 5.10
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.10
- en: The `foldRight` method uses recursion, but it’s not tail recursive, so it will
    rapidly overflow the stack. How rapidly depends on several factors, the most important
    of which is the size of the stack. In Java, the size of the stack is configurable
    through the `-Xss` command-line parameter, but the major drawback is that the
    same size is used for all threads. Using a bigger stack would be a waste of memory
    for most threads.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldRight`方法使用递归，但它不是尾递归，所以它会迅速溢出栈。溢出的速度取决于几个因素，其中最重要的是栈的大小。在Java中，栈的大小可以通过`-Xss`命令行参数进行配置，但主要的缺点是所有线程使用相同的大小。对于大多数线程来说，使用更大的栈将是内存的浪费。'
- en: 'Instead of using `foldRight`, create a `foldLeft` method that’s tail recursive
    and can be made stack-safe. Here’s its signature:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 代替使用`foldRight`，创建一个尾递归的`foldLeft`方法，并且可以使其栈安全。这是它的签名：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hint
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you don’t remember the difference between `foldLeft` and `foldRight`, refer
    to [section 3.3.5](kindle_split_010.xhtml#ch03lev2sec15).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不起`foldLeft`和`foldRight`之间的区别，请参阅[第3.3.5节](kindle_split_010.xhtml#ch03lev2sec15)。
- en: Solution 5.10
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.10
- en: 'The `Nil` implementation will obviously return `identity`. For the `Cons` implementation,
    start with defining a front-end method `foldLeft` calling a stack-based tail recursive
    helper method `foldLeft_` with an accumulator `acc` initialized to `identity`
    and a reference to `this`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil`的实现显然会返回`identity`。对于`Cons`的实现，首先定义一个前端方法`foldLeft`，它调用基于栈的尾递归辅助方法`foldLeft_`，累加器`acc`初始化为`identity`，并引用`this`：'
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then make the following changes so you can use the `TailCall` interface you
    defined in [chapter 4](kindle_split_011.xhtml#ch04) (the `ret` and `sus` methods
    are imported statically):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行以下更改，以便你可以使用你在第4章[中定义的`TailCall`接口](kindle_split_011.xhtml#ch04)（`ret`和`sus`方法被静态导入）：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Exercise 5.11
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习5.11
- en: Use your new `foldLeft` method to create new stack-safe versions of `sum`, `product`,
    and `length`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的新`foldLeft`方法创建新的栈安全版本的`sum`、`product`和`length`。
- en: Solution 5.11
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案5.11
- en: 'This is the `sumViaFoldLeft` method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`sumViaFoldLeft`方法：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `productViaFoldLeft` method is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`productViaFoldLeft`方法如下：'
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here’s the `lengthViaFoldLeft` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`lengthViaFoldLeft`方法：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that once again, the second parameter of method `length` (representing
    each element of the list on each recursive call of the method) is ignored. This
    method is as inefficient as the previous one and shouldn’t be used in production
    code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，再次提醒，方法`length`的第二个参数（代表方法每次递归调用中的列表元素）被忽略。此方法与上一个方法一样低效，不应该在生产代码中使用。
- en: Exercise 5.12
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习5.12
- en: Use `foldLeft` to write a static functional method for reversing a list.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldLeft`编写一个静态函数方法来反转列表。
- en: Solution 5.12
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案5.12
- en: 'Reversing a list via a left fold is very simple, starting from an empty list
    as the accumulator and `cons`-ing each element of the first list to this accumulator:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过左折叠反转列表非常简单，从空列表作为累加器开始，并将第一个列表的每个元素`cons`到这个累加器中：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example uses a method reference instead of a lambda, as explained in [chapter
    2](kindle_split_009.xhtml#ch02). If you prefer to use a lambda, it’s equivalent
    to the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用方法引用而不是lambda，如第2章[所述](kindle_split_009.xhtml#ch02)。如果你更喜欢使用lambda，它等同于以下内容：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exercise 5.13 (hard)
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习5.13（困难）
- en: Write `foldRight` in terms of `foldLeft`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用`foldLeft`来表示`foldRight`。
- en: Solution 5.13
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案5.13
- en: 'This implementation can be useful for getting a stack-safe version of `foldRight`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现对于获取`foldRight`的栈安全版本可能很有用：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that you can also define `foldLeft` in terms of `foldRight`, although
    this is much less useful:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以用`foldRight`来定义`foldLeft`，尽管这不太有用：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, note that the `foldLeft` method you use is an instance method of `List`.
    In contrast, `foldRight` is a static method. (We’ll define an instance `foldRight`
    method soon.)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，你使用的`foldLeft`方法是`List`的实例方法。相比之下，`foldRight`是静态方法。（我们很快将定义一个实例`foldRight`方法。）
- en: 5.4.1\. Heap-based recursive version of foldRight
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. `foldRight`的基于堆的递归版本
- en: As I said, the recursive `foldRight` implementation is only for demonstrating
    these concepts, because it’s stack-based and thus shouldn’t be used in production
    code. Also note that this is a static implementation. An instance implementation
    would be much easier to use, allowing you to chain method calls with the object
    notation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，递归的`foldRight`实现只是为了演示这些概念，因为它基于栈，因此不应该在生产代码中使用。此外，请注意这是一个静态实现。实例实现会更容易使用，允许你使用对象表示法链式调用方法调用。
- en: Exercise 5.14
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习5.14
- en: Use what you learned in [chapter 4](kindle_split_011.xhtml#ch04) to write a
    heap-based recursive instance version of the `foldRight` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在第4章[中学习的](kindle_split_011.xhtml#ch04)知识，编写一个基于堆的递归实例版本的`foldRight`方法。
- en: Hint
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The method can be defined in the parent `List` class. Write a tail recursive
    stack-based version of the `foldRight` method (using a helper method). Then change
    the helper method to a heap-based recursive implementation using the `TailCall`
    interface you developed in [chapter 4](kindle_split_011.xhtml#ch04).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以在父`List`类中定义。编写一个基于栈的尾递归版本的`foldRight`方法（使用辅助方法）。然后，将辅助方法更改为使用你在第4章[中开发的`TailCall`接口](kindle_split_011.xhtml#ch04)的基于堆的递归实现。
- en: Solution 5.14
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案5.14
- en: First, let’s write the stack-based tail recursive helper method. All you have
    to do is write a helper method that takes an accumulator as an additional parameter.
    The accumulator has the same type as the function return type, and its initial
    value is equal to the `identity` element (which, by the way, is used twice).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写基于栈的尾递归辅助方法。你只需要编写一个辅助方法，该方法接受一个累加器作为额外的参数。累加器的类型与函数返回类型相同，其初始值等于`identity`元素（顺便说一下，这个元素被使用了两次）。
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then write the main method that calls this helper method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编写调用此辅助方法的主方法：
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now change both methods to use `TailCall` heap-based recursion:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这两个方法都改为使用`TailCall`堆递归：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, you should also write the `Nil` implementation, which is really simple.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也应该编写`Nil`实现，这实际上非常简单。
- en: 'You can make this much shorter by reusing your implementation of `foldRightVia-FoldLeft`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过重用你的`foldRightVia-FoldLeft`实现来使这个方法更短：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exercise 5.15
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.15
- en: Implement `concat` in terms of either `foldLeft` or `foldRight`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldLeft`或`foldRight`来实现`concat`。
- en: Solution 5.15
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.15
- en: 'The `concat` method can be implemented easily using a right fold:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过右折叠轻松实现`concat`方法：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Another solution is to use a left fold. In this case, the implementation will
    be the same as `reverseViaFoldLeft` applied to the reversed first list, using
    the second list as the accumulator:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是使用左折叠。在这种情况下，实现方式将与`reverseViaFoldLeft`应用于反转后的第一个列表相同，使用第二个列表作为累加器：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This implementation (based on `foldLeft`) may seem less efficient because it
    must first reverse the first list. In fact, it’s not, because your implementation
    of `foldRight` is based on folding left the reversed list. (If this isn’t clear,
    refer to the implementations of `reverse` [exercise 5.6], `foldLeft` [exercise
    5.10], and `foldRight` [[listing 5.2](#ch05ex02)].)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现（基于`foldLeft`）可能看起来效率较低，因为它必须首先反转第一个列表。实际上，它并不低效，因为你的`foldRight`实现是基于反转列表的左折叠。（如果这还不清楚，请参考`reverse`
    [练习 5.6]、`foldLeft` [练习 5.10]和`foldRight` [[清单 5.2](#ch05ex02)]的实现。）
- en: Exercise 5.16
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.16
- en: Write a method for flattening a list of lists into a list containing all elements
    of each contained list.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个将列表中的列表展平为包含每个包含列表所有元素的列表的方法。
- en: Hint
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: This operation consists of a series of concatenations. In other words, it’s
    similar to adding all elements of a list of integers, although integers are replaced
    with lists, and addition is replaced with concatenation. Other than this, it’s
    exactly the same as the `sum` method.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作由一系列连接组成。换句话说，它与将整数列表的所有元素相加类似，尽管整数被列表所替代，加法被连接所替代。除此之外，它与`sum`方法完全相同。
- en: Solution 5.16
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.16
- en: 'In this solution, you can use a method reference instead of a lambda to represent
    the second part of the function: `x` -> `x::concat` is equivalent to `x` -> `y`
    -> `x.concat(y)`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解决方案中，你可以使用方法引用而不是lambda来表示函数的第二部分：`x` -> `x::concat` 等价于 `x` -> `y` -> `x.concat(y)`。
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 5.4.2\. Mapping and filtering lists
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 列表的映射和过滤
- en: You can define many useful abstractions for working on lists. One abstraction
    consists of changing all the elements of a list by applying a common function
    to them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为处理列表定义许多有用的抽象。一个抽象是通过应用一个共同函数来更改列表的所有元素。
- en: Exercise 5.17
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.17
- en: Write a functional method that takes a list of integers and multiplies each
    of them by 3.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数式方法，它接受一个整数列表并乘以每个元素的3倍。
- en: Hint
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Try using the methods you’ve defined up to now. Don’t use recursion explicitly.
    The goal is to abstract stack-safe recursion once and for all so you can put it
    to work without having to reimplement it each time.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你到目前为止定义的方法。不要显式使用递归。目标是最终抽象堆安全递归，这样你就可以使用它而无需每次都重新实现它。
- en: Solution 5.17
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.17
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Exercise 5.18
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.18
- en: Write a function that turns each value in a `List<Double>` into a `String`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，将`List<Double>`中的每个值转换为`String`。
- en: Solution 5.18
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.18
- en: 'This operation can be seen as concatenating an empty list of the expected type
    (`List<String>`) with the original list, with each element being transformed before
    being `cons`-ed to the accumulator. As a result, the implementation is very similar
    to what you did in the `concat` method:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作可以看作是将一个空列表（`List<String>`类型）与原始列表连接起来，每个元素在`cons`到累加器之前都会被转换。因此，实现方式与你之前在`concat`方法中做的是非常相似的：
- en: '![](Images/148fig01_alt.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/148fig01_alt.jpg)'
- en: Exercise 5.19
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.19
- en: 'Write a general functional method `map` that allows you to modify each element
    of a list by applying a specified function to it. This time, make it an instance
    method of `List`. Add the following declaration in the `List` class:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个通用的函数式方法`map`，允许你通过将指定的函数应用于它来修改列表中的每个元素。这次，将其作为`List`的实例方法。在`List`类中添加以下声明：
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Hint
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Use the stack-safe instance version of the `foldRight` method.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`foldRight`方法的堆安全实例版本。
- en: Solution 5.19
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.19
- en: 'The `map` method may be implemented in the parent `List` class:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法可以在父`List`类中实现：'
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Exercise 5.20
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.20
- en: 'Write a `filter` method that removes from a list the elements that don’t satisfy
    a given predicate. Once again, implement this as an instance method with the following
    signature:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`filter`方法，从列表中移除不满足给定谓词的元素。再次，将其实现为一个具有以下签名的实例方法：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Solution 5.20
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.20
- en: Here’s an implementation in the parent `List` class, using `foldRight`. Don’t
    forget to use the stack-safe version of this method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在父`List`类中使用`foldRight`的一个实现，不要忘记使用这个方法的栈安全版本。
- en: '[PRE60]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Exercise 5.21
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.21
- en: Write a `flatMap` method that applies to each element of `List<A>` a function
    from `A` to `List<B>`, and returns a `List<B>`. Its signature will be
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`flatMap`方法，它将一个从`A`到`List<B>`的函数应用于`List<A>`的每个元素，并返回一个`List<B>`。它的签名将是
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: For example, `List.list(1,2,3).flatMap(i -> List.list(i, -i))` should return
    `list(1,-1,2,-2,3,-3)`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`List.list(1,2,3).flatMap(i -> List.list(i, -i))`应该返回`list(1,-1,2,-2,3,-3)`。
- en: Solution 5.21
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.21
- en: 'Once again, it can be implemented in the parent `List` class, using `foldRight`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这可以在父`List`类中实现，使用`foldRight`：
- en: '[PRE62]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Exercise 5.22
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 5.22
- en: Create a new version of `filter` based on `flatMap`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`flatMap`创建一个新的`filter`版本。
- en: Solution 5.22
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 5.22
- en: 'Here’s a static implementation:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个静态实现：
- en: '[PRE63]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that there’s a strong relation between `map`, `flatten,` and `flatMap`.
    If you map a function returning a list to a list, you get a list of lists. You
    can then apply `flatten` to get a single list containing all the elements of the
    enclosed lists. You’d get exactly the same result by directly applying `flatMap`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`map`、`flatten`和`flatMap`之间存在紧密的联系。如果你将返回列表的函数映射到列表上，你会得到一个列表的列表。然后你可以应用`flatten`来得到一个包含所有嵌套列表元素的单一列表。直接应用`flatMap`也会得到相同的结果。
- en: 'One consequence of this relation is that you can redefine `flatten` in terms
    of `flatMap`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系的一个后果是，你可以用`flatMap`来重新定义`flatten`：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This isn’t surprising, because the call to `concat` has been abstracted into
    `flatMap`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人惊讶，因为对`concat`的调用已经被抽象为`flatMap`。
- en: 5.5\. Summary
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5. 总结
- en: Data structures are among the most important concepts in programming.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构是编程中最重要概念之一。
- en: The singly linked list is the most often used data structure in functional programming.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单链表是函数式编程中最常用的数据结构。
- en: Using immutable and persistent lists brings thread-safety.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变和持久列表可以带来线程安全性。
- en: Using data sharing allows for very high performance for most operations, although
    not for all.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据共享可以使大多数操作具有非常高的性能，尽管不是所有操作。
- en: You can create other data structures to get good performance for specific use
    cases.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建其他数据结构以获得特定用例的良好性能。
- en: You can fold lists by recursively applying functions.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过递归应用函数来折叠列表。
- en: You can use heap-based recursion to fold lists without the risk of overflowing
    the stack.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用基于堆的递归折叠列表，而不会出现栈溢出的风险。
- en: Once you’ve defined `foldRight` and `foldLeft`, you shouldn’t need to use recursion
    again to handle lists. `foldRight` and `foldLeft` abstract recursion for you.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你定义了`foldRight`和`foldLeft`，你就不再需要使用递归来处理列表。`foldRight`和`foldLeft`为你抽象了递归。
