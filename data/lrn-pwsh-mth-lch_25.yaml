- en: 25 Debugging techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 25 调试技术
- en: In the previous chapter, we talked about how to handle bad situations (errors
    and exceptions) but specifically the bad situations that you were expecting. There’s
    another type of bad situation that can happen as your scripts become more and
    more complex. These situations, that we’ve alluded to already, are called *bugs*.
    These are the side effects of a long night scripting, or lack of coffee in the
    morning. In other words, they’re the side effects of us being human. We all make
    mistakes, and this chapter will be focused on some techniques on how to find and
    squash the bugs in your scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何处理不良情况（错误和异常），但特别是你预料到的不良情况。随着你的脚本变得越来越复杂，还可能发生另一种不良情况。我们已经提到过这些情况，它们被称为*错误*。这些是长时间编写脚本或早上咖啡不足的副作用。换句话说，它们是我们作为人类的副作用。我们都会犯错误，而本章将专注于一些查找和消除脚本中错误的技术。
- en: NOTE We’ll be diving into some of the features that the PowerShell extension
    for Visual Studio Code has to offer, so if you need a refresher on how to get
    set up, be sure to go back to chapter 2 and follow the steps there.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将深入探讨PowerShell扩展为Visual Studio Code提供的某些功能，所以如果你需要复习如何设置，请确保回到第2章并遵循那里的步骤。
- en: 25.1 Output everything
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.1 输出一切
- en: Without diving too deep into Azure Pipelines concepts, the script in listing
    25.1 will get details about published artifacts we care about and download them
    to the Temp drive. If you’ve never heard the term *artifact* before, it’s basically
    a file that has been published somewhere other tools can download it. Additionally,
    you’ll notice some environment variables in the script (prefixed with `$env:`).
    This is because the script was written to be run inside of Azure Pipelines where
    these artifacts exist.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨Azure Pipelines的概念，列表25.1中的脚本将获取我们关心的已发布工件的相关详细信息，并将它们下载到Temp驱动器。如果你以前从未听说过*工件*这个术语，它基本上是一个在其他工具可以下载的地方发布的文件。此外，你还会在脚本中注意到一些环境变量（以`$env:`开头）。这是因为脚本是为在存在这些工件的地方运行的Azure
    Pipelines而编写的。
- en: Let’s start with something familiar from chapter 17 where we talked about the
    different output streams. The different streams are tools in your toolbox for
    understanding what your code is doing and when it’s doing it. Thoughtful placing
    of `Write-*` statements can make it easy to find the bug in your scripts and get
    you back on track. We won’t cover this topic too much since we already dedicated
    chapter 17 to input and output, but the following listing provides an example
    of when something like `Write-Debug` would come in handy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第17章中熟悉的内容开始，在第17章中我们讨论了不同的输出流。不同的流是你的工具箱中的工具，用于理解你的代码在做什么以及何时在做这件事。仔细放置`Write-*`语句可以使你轻松找到脚本中的错误并回到正轨。我们不会过多地涉及这个主题，因为我们已经将第17章专门用于输入和输出，但以下列表提供了一个示例，说明何时像`Write-Debug`这样的功能会派上用场。
- en: Listing 25.1 A piece of VS Code’s publishing script modified for learning purposes
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表25.1：为学习目的修改的VS Code发布脚本的一部分
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let’s say you run this script and it doesn’t work the way you are expecting
    it to work. One of the simplest ways to debug a script is to run the script, asking
    it to show the debug stream. Let’s do a comparison.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你运行这个脚本，但它没有按照你预期的那样工作。调试脚本的最简单方法之一是运行脚本，要求它显示调试流。让我们进行比较。
- en: Running the script normally produces
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正常运行脚本会产生
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is not very informative. However, all we have to do is set our debug preference
    to `Continue`, and we can see the contents of the debug stream:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很有信息量。然而，我们只需要将我们的调试首选项设置为`Continue`，我们就可以看到调试流的全部内容：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is more useful information. It ran for Windows and Linux . . . but wait,
    wasn’t it supposed to also run for macOS?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有用的信息。它在Windows和Linux上运行……但是等等，它不是也应该在macOS上运行吗？
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do you see the bug? I’ll wait a second. Got it? A few years ago, Apple changed
    the name of their operating system from OSX to macOS, and it looks like the script
    wasn’t completely updated properly because it’s still referencing `VSCODE_BUILD_STAGE_OSX`
    instead of `VSCODE_BUILD_STAGE_MACOS`. That first debug statement says that it’s
    running only Windows and Linux, so that’s our hint that something is wrong around
    there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到错误了吗？我会等一会儿。明白了吗？几年前，苹果公司将他们的操作系统名称从OSX更改为macOS，看起来脚本并没有完全正确更新，因为它仍然引用`VSCODE_BUILD_STAGE_OSX`而不是`VSCODE_BUILD_STAGE_MACOS`。第一个调试语句表明它只运行Windows和Linux，所以这是我们的线索，表明那里可能有问题。
- en: Debugging like this is often used in an environment that can’t be made interactive.
    Azure Pipelines and GitHub Actions are great examples of environments like this
    where you don’t have the ability to remote into the container or VM that your
    script is running in, so your only debugging option is to leverage PowerShell’s
    streams to give you as much information as possible. This type of debugging is
    also useful if you have the ability to run scripts on your local machine or in
    a container/VM that you have access to, but there are complementary solutions
    as well that we’ll get into now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调试方式常用于无法进行交互的环境。Azure Pipelines 和 GitHub Actions 是这种环境的绝佳例子，你无法远程连接到你的脚本正在运行的容器或
    VM，因此你唯一的调试选项是利用 PowerShell 的流来尽可能多地提供信息。如果你有在本地机器或你能够访问的容器/VM 上运行脚本的能力，这种类型的调试也很有用，但这里也有互补的解决方案，我们现在将探讨。
- en: 25.2 One line at a time
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.2 逐行运行
- en: Debugging using PowerShell’s streams is “debugging the past,” as you are looking
    at what has already happened. Debugging this way is useful but can be tedious
    because you have to wait to see what shows up in these streams before you take
    action. If you don’t have enough information in the debug stream, you have to
    make a change to add more information to the debug stream, which requires you
    to run your script over and over again. If you’re trying to debug an issue that
    happens only 30 minutes into your script running, that means any change you make
    (even if it’s just to get more information) will take 30 minutes to verify. Thankfully,
    the PowerShell team has several ways to cut down on the time spent debugging.
    The first of these tactics is what we like to call *F8 debugging* or *line-by-line
    debugging*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 的流进行调试被称为“调试过去”，因为你正在查看已经发生的事情。这种方式的调试很有用，但可能会很繁琐，因为你必须等待看到这些流中显示的内容，然后才能采取行动。如果你在调试流中没有足够的信息，你必须进行更改以添加更多信息到调试流中，这需要你反复运行你的脚本。如果你正在尝试调试脚本运行
    30 分钟后发生的问题，这意味着你做的任何更改（即使只是获取更多信息）也需要 30 分钟来验证。幸运的是，PowerShell 团队有几种方法可以减少调试所需的时间。这些策略中的第一个就是我们喜欢称之为
    *F8 调试* 或 *逐行调试*。
- en: 'The premise is simple. Let’s take a large script and run it line by line in
    our console. It sounds like it could be tedious to copy and paste each line, but
    the PowerShell extension for VS Code streamlines this experience. Let’s start
    with a basic script to demonstrate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前提很简单。让我们拿一个大的脚本，并在我们的控制台中逐行运行它。听起来可能很麻烦，需要复制粘贴每一行，但 VS Code 的 PowerShell 扩展简化了这一过程。让我们从一个基本的脚本开始，以演示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Go ahead and create a test.ps1 file with the code above, and open it in VS Code.
    Next, click on the first line (the `Write-Host`) so that the cursor is on line
    1 (figure 25.1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 test.ps1 的文件，并将上面的代码放入其中，然后在 VS Code 中打开它。接下来，点击第一行（`Write-Host`），使光标位于第
    1 行（图 25.1）。
- en: '![](Images/CH25_F01_Plunk.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH25_F01_Plunk.png)'
- en: Figure 25.1 Visual Studio Code with our script. The Run and Run Selection buttons
    in the top-right corner are highlighted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25.1 Visual Studio Code 与我们的脚本。右上角的“运行”和“运行选择”按钮被突出显示。
- en: We highlight two buttons in the screen’s top-right corner. If you hover over
    these, they say Run and Run Selection (F8), respectively. The Run button will
    run your entire script, but we’ll come back to why that button is special. For
    now, let’s focus on the other one. In fact, with the cursor on line 1, let’s click
    the Run Selection (F8) button and see what happens. The PowerShell extension will
    take the current line your cursor is on and run that snippet in the PowerShell
    *I*ntegrated Console in figure 25.2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在屏幕右上角突出显示了两个按钮。如果你将鼠标悬停在这些按钮上，它们分别显示为“运行”和“运行选择（F8）”。运行按钮将运行你的整个脚本，但我们会回来解释为什么这个按钮是特殊的。现在，让我们专注于另一个按钮。实际上，当光标位于第
    1 行时，让我们点击“运行选择（F8）”按钮，看看会发生什么。PowerShell 扩展将取当前光标所在的行，并在图 25.2 中的 PowerShell
    *集成控制台* 中运行该片段。
- en: '![](Images/CH25_F02_Plunk.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH25_F02_Plunk.png)'
- en: Figure 25.2 Visual Studio Code with our script. It runs only what is highlighted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25.2 Visual Studio Code 与我们的脚本。它只运行高亮显示的部分。
- en: The Run Selection button will run any snippet that you have selected, as shown
    in figure 25.2, or it will run the current line if you have nothing selected.
    Select some of the lines and click the Run Selection button. You’ll notice that
    it will run exactly what you’ve selected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “运行选择”按钮将运行你选择的任何片段，如图 25.2 所示，或者如果你没有选择任何内容，它将运行当前行。选择一些行并点击“运行选择”按钮。你会注意到它将运行你选择的
    exactly 内容。
- en: 'Try it now If you haven’t done so yet, run the last two lines (either by selecting
    both of them or one at a time), and you’ll see something similar to the following
    output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。如果你还没有这样做，运行最后两行（可以通过选择它们或逐行选择），你将看到以下类似输出：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is where it gets interesting. Click inside of the PowerShell Integrated
    Console, and then run `$processName` in it. You’ll see that the value we set in
    our script has persisted inside of the PowerShell Integrated Console. This means
    that we can run a script line by line and see the entire state of the script as
    it’s happening, giving us more visibility into exactly what our script is doing.
    This means that we can debug our script faster because we are able to get an overview
    of what’s happening and when it’s happening *as it’s happening*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里开始变得有趣。在 PowerShell 集成控制台中点击，然后运行 `$processName`。你会看到我们在脚本中设置的值已经在 PowerShell
    集成控制台中持续存在。这意味着我们可以逐行运行脚本并看到脚本在执行过程中的整个状态，这让我们能够更清楚地了解脚本正在做什么。这意味着我们可以更快地调试脚本，因为我们能够实时获得正在发生的事情及其发生时间的概览。
- en: Note We call this *F8 debugging* because Run Selection is bound to the F8 key
    in VS Code, so you can just press F8 instead of having to click the button in
    the top right.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们称之为“F8 调试”，因为“运行选择”在 VS Code 中绑定到 F8 键，所以你只需按 F8 而不必点击右上角的按钮。
- en: You were able to see the value of the variable `$processName` in your console,
    but you can take this a step further and set the value to something else whenever
    you’d like. For example, set `$processName` to `code*` in your console (figure
    25.3), and then use Run Selection to run line 3 (the `Get-Process`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你能够在你的控制台中看到变量 `$processName` 的值，但你可以更进一步，在你想要的时候将其值设置为其他内容。例如，在你的控制台中（图 25.3）将
    `$processName` 设置为 `code*`，然后使用“运行选择”来运行第 3 行（`Get-Process`）。
- en: '![](Images/CH25_F03_Plunk.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH25_F03_Plunk.png)'
- en: Figure 25.3 Setting `$processName` to `code*` and then running line 3 of the
    script
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 25.3 将 `$processName` 设置为 `code*` 并运行脚本的第 3 行
- en: 'Notice that the output is no longer the result of `pwsh` but instead is the
    result of `code*`. This blurs the line between the script in your editor and your
    console, which can be very useful when you want to see if your script handles
    different inputs correctly. With that said, keep track of any changes you make
    because you don’t want a manually set variable to cause other issues in your script.
    If your PowerShell Integrated Console is ever in a bad state and you want to restart
    it, open the Command Palette using Ctrl+Shift+P on Windows or Linux or Cmd+Shift+P
    on macOS and type `PowerShell: Restart Current Session` and run that. This will
    give you a clean slate (a fresh PowerShell instance) that you can use.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，输出不再是 `pwsh` 的结果，而是 `code*` 的结果。这模糊了编辑器中的脚本和你的控制台之间的界限，这在你想检查脚本是否正确处理不同的输入时非常有用。话虽如此，请记录你做的任何更改，因为你不希望手动设置的变量在脚本中引起其他问题。如果你的
    PowerShell 集成控制台处于不良状态并且你想重新启动它，请使用 Windows 或 Linux 上的 Ctrl+Shift+P 或 macOS 上的
    Cmd+Shift+P 打开命令面板，并输入 `PowerShell: Restart Current Session` 并运行它。这将为你提供一个全新的起点（一个新的
    PowerShell 实例），你可以使用它。'
- en: 'The preceding example is simple, and the strategy itself is simple. Here’s
    the usual workflow that we use:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例很简单，策略本身也很简单。这是我们通常使用的常规工作流程：
- en: If your script has parameters, set the values to those in the PowerShell Integrated
    Console ahead of time to simulate running the script with those parameter values.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的脚本有参数，请提前在 PowerShell 集成控制台中设置这些值以模拟使用这些参数值运行脚本。
- en: Select the first line or part of your script that you are fairly certain doesn’t
    have the issue in it; then press F8.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你相当确定其中没有问题的第一行或脚本的一部分；然后按 F8。
- en: Dig around. Run the important variables in the console to see what their values
    are. You can also run functions in the console that you use to see what they return.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挖掘一下。在控制台中运行重要变量以查看它们的值。你还可以在控制台中运行你使用的函数，以查看它们返回的内容。
- en: Select the next line and press F8\. Repeat 3 or go to 5.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一行并按 F8。重复 3 次或转到 5。
- en: Found what looks off? Make the change to the script you think needs to be made
    and go back to number 1.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到看起来不对的地方了吗？对你认为需要修改的脚本进行更改，然后回到步骤 1。
- en: By adopting this strategy, you will gain confidence in debugging your PowerShell
    scripts and those of others as well (as we talked about in chapter 23). This is
    a necessary skill in any workplace because when push comes to shove, you will
    have scripts break and you will have to roll up your sleeves and fix them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种策略，你将对自己的PowerShell脚本以及他人的脚本进行调试时获得信心（正如我们在第23章中讨论的）。在任何工作场所，这都是一项必要的技能，因为当事情变得棘手时，你将会有脚本崩溃，你必须卷起袖子来修复它们。
- en: 25.3 Hey, script, stop right there . . . with breakpoints
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.3 嘿，脚本，就在这里停下来……使用断点
- en: F8 debugging is sufficient for debugging scripts interactively, and you could
    stop here in this chapter and do well for yourself. **B**ut we want to really
    prepare you for what you might see in the real world. To do that, we want to talk
    about a third type of debugging, which we call *breakpoint debugging*. Breakpoint
    debugging is popularized by our friends, the software developers/engineers. They
    have been using this type of debugging for many years, and the PowerShell team
    made it possible to use breakpoint debugging in PowerShell—which is a unique feature
    for a shell to have (Bash, cmd, Zsh, etc., don’t have breakpoint debugging capabilities).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: F8调试足以进行脚本的交互式调试，你可以在本章到此为止，做得很好。**但是**，我们真的想为你准备你可能会在现实世界中看到的内容。为了做到这一点，我们想谈谈第三种调试类型，我们称之为*断点调试*。断点调试是由我们的朋友，软件开发者/工程师推广的。他们已经使用这种类型的调试很多年了，PowerShell团队使得在PowerShell中使用断点调试成为可能——这对于一个shell来说是一个独特的功能（Bash、cmd、Zsh等都没有断点调试功能）。
- en: 'So what’s it all about? Well, at a high level, the way breakpoint debugging
    works is you’ll run your script “with debugging” (VS Code jargon); this tells
    VS Code which lines in your script you want to stop at for further inspection
    (these stopping points are called *breakpoints*). We want to be clear: you were
    already doing this in the previous section with F8 debugging, where you ran a
    selection up to the part you want to investigate, only this time it’s even more
    integrated into VS Code. Okay, let’s look at how to set breakpoints and how it
    works in VS Code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切都是关于什么呢？好吧，从高层次来看，断点调试的工作原理是这样的：你将以“调试”模式运行你的脚本（VS Code术语）；这告诉VS Code你想要在脚本中的哪些行停下来进行进一步检查（这些停止点被称为*断点*）。我们想明确指出：在上一节中，你已经通过F8调试做过这件事了，当时你运行了一个选择，直到你想要调查的部分，但这次它甚至更深入地集成到了VS
    Code中。好的，让我们看看如何在VS Code中设置断点以及它是如何工作的。
- en: As shown in figure 25.4, when you put your cursor over a line number (let’s
    do line number 3), a faded red dot appears in the “gutter” of VS Code (it’s always
    between the line numbers and the activity bar on the left). If you click on that
    red dot, it becomes solid and no longer disappears when you hover away from it.
    Congratulations, you’ve just set your very first breakpoint! Let’s put that breakpoint
    to the test. Remember the Run button that is next to the Run Selection button?
    Well, that button runs your script “with debugging,” which means breakpoints will
    be stopped at if they are set. Let’s try it. Click the Run button in the top right,
    or press the F5 key, which is bound to Run.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如图25.4所示，当你将光标放在行号上（让我们以行号3为例），在VS Code的“页边空白”中会出现一个淡红色的点（它总是在行号和左侧的活动栏之间）。如果你点击那个红色点，它就会变成实心，并且当你将鼠标移开时不会再消失。恭喜你，你刚刚设置了你的第一个断点！让我们来测试一下这个断点。还记得旁边的运行按钮吗？那个按钮以“调试”模式运行你的脚本，这意味着如果设置了断点，它们将会停止。让我们试试。点击右上角的运行按钮，或者按F5键，它被绑定到运行。
- en: '![](Images/CH25_F04_Plunk.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH25_F04_Plunk.png)'
- en: Figure 25.4 Place a breakpoint by clicking on the faded red dot next to the
    line number.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.4 通过点击行号旁边的淡红色点来放置断点。
- en: Figure 25.5 gives an overview of what you see when you start debugging a script.
    At the top of the screen, you see a set of buttons that control how you would
    like to proceed in the debugging process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.5概述了当你开始调试脚本时你会看到的内容。在屏幕顶部，你会看到一组按钮，这些按钮控制你在调试过程中的下一步操作。
- en: '![](Images/CH25_F05_Plunk.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH25_F05_Plunk.png)'
- en: Figure 25.5 When your script stops at a breakpoint, VS Code displays useful
    information for debugging your script. This includes indicating where you’ve stopped
    in your script, a list of all your breakpoints, a list of variables that are currently
    set, and more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.5 当你的脚本在断点处停止时，VS Code会显示用于调试脚本的有用信息。这包括指示你在脚本中的停止位置，所有断点的列表，当前设置的变量的列表等等。
- en: 'Here’s what each of those buttons does:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个按钮的功能：
- en: '| ![](Images/icon_Resume.png)     | *Resume*—Hits “play” on the script to continue
    running the script |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ![](Images/icon_Resume.png)     | *继续*—点击脚本上的“播放”按钮以继续运行脚本 |'
- en: '| ![](Images/icon_Stepover.png)     | *Step over*—Runs the current highlighted
    line and stops on the line right after |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ![](Images/icon_Stepover.png)     | *单步执行*—运行当前高亮的行并在下一行停止 |'
- en: '| ![](Images/icon_Restart.png)     | *Restart*—Stops running the script and
    starts it over again from the beginning |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ![](Images/icon_Restart.png)     | *重启*—停止运行脚本并从开始处重新开始 |'
- en: '| ![](Images/icon_Stop.png)     | *Stop*—Stops running the script and exits
    the debug experience |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ![](Images/icon_Stop.png)     | *停止*—停止运行脚本并退出调试体验 |'
- en: Don’t worry about the buttons ![](Images/icon_Arrows.png) for now. They are
    part of the concept of the call stack, which is a bit more advanced than where
    we want to take this book. This also means that we will not cover the Call Stack
    view. We also will not be covering the Watch view, because it’s not necessary
    to learn (and frankly we rarely use the feature), so we’ll leave it as an exercise
    for you to research if you like.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不用担心 ![](Images/icon_Arrows.png) 按钮。它们是调用栈概念的一部分，这比我们在这本书中想要达到的层次要高一些。这也意味着我们不会介绍调用栈视图。我们也不会介绍监视视图，因为它不是学习（坦白说我们很少使用这个功能）所必需的，所以我们将它留给你作为研究练习。
- en: Try it NOW This is a perfect opportunity for you to play around with all the
    different UI elements we’ve called out so far. Run (with debugging) a simple script
    that sets some variables and runs a few simple cmdlets like `Get-Process` or `Get-ChildItem`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试吧！这是一个让你尝试我们之前提到的所有不同 UI 元素的绝佳机会。运行（带有调试）一个简单的脚本，设置一些变量并运行几个简单的 cmdlets，如
    `Get-Process` 或 `Get-ChildItem`。
- en: Going forward in this book, continue to leverage F8 and breakpoint debugging
    so you can improve your skills. We promise you it’s like riding a bike. Once you
    get the hang of it, you’ll keep that knowledge with you forever. Your ability
    to find problems in your scripts and ability to iterate on a script will be a
    lot better than someone without this foundational knowledge.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书接下来的内容中，继续利用 F8 和断点调试来提高你的技能。我们保证这就像骑自行车一样。一旦你掌握了技巧，你将永远记住这些知识。你发现脚本中问题的能力以及迭代脚本的能力将比没有这种基础知识的人要好得多。
- en: 25.4 Lab
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.4 实验室
- en: Practice makes perfect when it comes to debugging. There are two parts of the
    lab for this chapter. Go back to the script you looked at in chapter 22’s lab.
    Modify it and add better logging so that you can more easily understand what the
    script is doing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 调试方面，熟能生巧。本章的实验室有两个部分。回到你在第 22 章实验室中查看的脚本。对其进行修改并添加更好的日志记录，这样你可以更容易地理解脚本在做什么。
- en: Make sure that you add logging that shows on the screen only when you want to
    see debug logging but otherwise does not pollute the screen if don’t want to see
    debug logging. Revisit every script you’ve written in this book so far. Try debugging
    using
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你添加的日志只在你想要看到调试日志时显示在屏幕上，否则如果不想看到调试日志，则不会污染屏幕。回顾你在本书中迄今为止编写的每一个脚本。尝试使用
- en: F8 debugging
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F8 调试
- en: Breakpoint debugging
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断点调试
