- en: 11 K-means clustering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 K-means聚类
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Developing a K-means clustering algorithm
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发K-means聚类算法
- en: Computing and visualizing optimal cluster counts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算和可视化最佳聚类数量
- en: Understanding standard deviations and computing z-scores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解标准差和计算z分数
- en: Creating Cleveland dot plots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建克利夫兰点图
- en: Our primary purpose in this chapter is to demonstrate how to develop a K-means
    clustering algorithm. K-means clustering is a popular unsupervised learning method
    and multivariate analysis technique that enables purposeful and made-to-order
    strategies around smart clusters, or groups, cut from the data. Unsupervised learning
    is a learning method where the goal is to find patterns, structures, or relationships
    in data using only input variables and therefore no target, or output, data. By
    contrast, supervised learning methods use both input and output variables, usually
    to make predictions. In the former, you have no idea what you might be looking
    for; in the latter, you’ve already figured that out. Multivariate analysis refers
    to statistical techniques and methods used to analyze and understand relationships
    among two or more variables simultaneously.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是演示如何开发K-means聚类算法。K-means聚类是一种流行的无监督学习方法，也是多变量分析技术，它允许围绕从数据中切割出的智能聚类或群体制定有目的的定制策略。无监督学习是一种学习方法，其目标是仅使用输入变量（因此没有目标或输出数据）在数据中找到模式、结构或关系。相比之下，监督学习方法使用输入和输出变量，通常用于做出预测。在前者中，你不知道你可能会寻找什么；在后者中，你已经弄清楚了。多变量分析是指用于同时分析和理解两个或更多变量之间关系的统计技术和方法。
- en: The most obvious application for K-means clustering—maybe even the most proven—is
    customer segmentation. K-means is used to segment customers based on, for example,
    prior purchases; demographic variables such as age, gender, and home address;
    and other attributes. Companies with this sort of insight can then develop different
    marketing strategies for different clusters of customers, which in turn can drive
    sales and bump customer satisfaction scores.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: K-means聚类的最明显应用——也许是最被证实的应用——是客户细分。K-means用于根据例如以前的购买、人口统计变量（如年龄、性别和家庭地址）和其他属性来细分客户。具有这种洞察力的公司可以为不同的客户群体开发不同的营销策略，这反过来可以推动销售并提高客户满意度评分。
- en: The most significant differentiator in K-means clustering from hierarchical
    clustering is that K-means requires a predetermined number of clusters, denoted
    as *K*, to run. It’s perfectly acceptable to experiment with different cluster
    counts or even run the algorithm on a fixed number of clusters. However, there
    are methods to determine an optimal number of clusters based on differentiation
    in the data. We’ll demonstrate two of those methods, and then we’ll run the K-means
    algorithm and analyze the results. We’ll even experiment with incrementally different
    values for *K* and evaluate the sequential changes in the results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: K-means聚类与层次聚类的最显著区别在于，K-means需要预先确定聚类数量，用 *K* 表示，才能运行。尝试不同的聚类数量，甚至在一个固定的聚类数量上运行算法都是完全可以接受的。然而，有一些方法可以根据数据中的差异来确定最佳聚类数量。我们将演示其中两种方法，然后运行K-means算法并分析结果。我们甚至将尝试不同的
    *K* 值，并评估结果的变化。
- en: Before that, we’ll get you grounded by introducing a discussion on standard
    deviations and z-scores (K-means clusters are visualized in a two-dimensional
    plane where the raw data has been standardized) and then by plotting a pair of
    unlike numeric variables that have been converted to like scales.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们将通过介绍标准差和z分数（K-means聚类在二维平面上可视化，其中原始数据已被标准化）以及绘制一对不同数值变量（已转换为相同尺度）来为您打下基础。
- en: Whereas in chapter 10 we examined the relationship between team payrolls and
    regular season wins, postseason appearances, and league championships at an aggregate
    level, in this chapter, we’ll be concentrating on payrolls and wins down to the
    team level. First, we’ll load the same set of packages we loaded near the beginning
    of the prior chapter, plus one new package for our K-means clustering.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，我们考察了球队工资与常规赛胜利、季后赛出场和联赛冠军之间的关系，是在一个综合水平上的。而在本章中，我们将专注于球队层面的工资和胜利。首先，我们将加载与上一章开头相同的一组包，再加上一个用于K-means聚类的包。
- en: 11.1 Loading packages
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 加载包
- en: 'Our one new package is `factoextra`, which is a popular package for extracting
    and plotting the results of multivariate data analyses, including K-means clustering.
    We’ll call one function from `factoextra` to compute and visualize optimal cluster
    counts and then a second function to plot our clusters. Otherwise, our first order
    of business is to make four successive calls to the `library()` function to load
    `factoextra` plus three other packages you’re already familiar with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一个新包是`factoextra`，这是一个流行的包，用于提取和绘制多变量数据分析的结果，包括K-means聚类。我们将调用`factoextra`中的一个函数来计算和可视化最佳聚类数量，然后调用第二个函数来绘制我们的聚类。否则，我们的首要任务是连续调用四次`library()`函数来加载`factoextra`以及您已经熟悉的三个其他包：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we’ll import and take a glance at our data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入并浏览我们的数据。
- en: 11.2 Importing data
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 导入数据
- en: 'In the previous chapter, we worked briefly with a data set called cap and then
    quite extensively with another data set called salaries. In this chapter, we’ll
    work exclusively with salaries. Our second order of business is to therefore call
    the `readr read_csv()` function to (again) import the salaries data set:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要地处理了一个名为cap的数据集，然后相当深入地处理了另一个名为salaries的数据集。在本章中，我们将仅使用salaries数据集。因此，我们的第二项任务是调用`readr
    read_csv()`函数（再次）导入薪资数据集：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are a few reminders about the salaries data set:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于薪资数据集，这里有一些提醒：
- en: The data set contains 30 rows—one row for every NBA team. Some teams relocated
    between the 2000 and 2017 seasons (which is the time horizon of our data) and
    changed their name as a result. The Supersonics moved from Seattle to Oklahoma
    City and are now the Oklahoma City Thunder; the Nets moved from New Jersey to
    Brooklyn and are now known as the Brooklyn Nets rather than the New Jersey Nets.
    But the data is nevertheless consigned to one observation per team; the salaries
    data set contains current team names only.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集包含30行——每行代表一个NBA球队。一些球队在2000年至2017年赛季之间（这是我们的数据的时间范围）搬迁并因此更改了名称。超音速队从西雅图搬到俄克拉荷马城，现在是俄克拉荷马城雷霆队；篮网队从新泽西搬到布鲁克林，现在被称为布鲁克林篮网而不是新泽西篮网。但数据仍然只对应每个球队的一个观测值；薪资数据集只包含当前球队名称。
- en: 'There are 73 columns. Other than the variable `Team`, salaries is more or less
    divided into four 18-column sections, where each column represents an NBA season
    between 2000 and 2017: real salaries (numeric), inflation-adjusted salaries (numeric),
    regular season wins (numeric), and season-ending disposition (categorical). In
    this chapter, we’ll concern ourselves only with adjusted salaries (these are player
    salaries that, when summed for every factor in the variable `Team` and grouped
    by season, equal a team’s payroll) and regular season wins.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集包含73列。除了变量`Team`外，薪资数据大致分为四个18列的部分，每个部分代表2000年至2017年间的NBA赛季：实际薪资（数值）、通货膨胀调整后的薪资（数值）、常规赛胜利（数值）和赛季结束状态（分类）。在本章中，我们将只关注调整后的薪资（这些是当按`Team`变量中的每个因素求和并按赛季分组时，等于一支球队的工资总额的球员薪资）和常规赛胜利。
- en: Because the Charlotte Hornets and New Orleans Pelicans, unlike the other NBA
    teams, played in just 16 and 15 seasons, respectively, between 2000 and 2017,
    we’re obligated to wrangle the salaries data set and make other adjustments that
    would otherwise be unnecessary. You’ll see these momentarily.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于夏洛特黄蜂队和新奥尔良鹈鹕队与NBA的其他球队不同，在2000年至2017年之间分别只打了16个和15个赛季，因此我们被迫整理薪资数据集并进行其他调整，否则这些调整是不必要的。您将很快看到这些调整。
- en: 'In the following code, we pipe the salaries data set to a pair of `dplyr` functions—first
    to the `select()` function to subset salaries on the variables `Team`, `sa2017`
    (equal to 2017 adjusted salaries), and `w2017` (equal to 2017 regular season wins);
    and second, to the `glimpse()` function, which returns a transposed view of our
    salaries subset:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将薪资数据集通过两个`dplyr`函数进行管道处理——首先是通过`select()`函数来选择变量`Team`、`sa2017`（等于2017年的调整后薪资）和`w2017`（等于2017年的常规赛胜利）；其次是通过`glimpse()`函数，它返回薪资子集的转置视图：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before we wrangle and analyze our data, it’s important to get grounded in standard
    deviations and z-scores first.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始整理和分析数据之前，首先了解标准差和z分数是很重要的。
- en: 11.3 A primer on standard deviations and z-scores
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 标准差和z分数的基础知识
- en: Understanding the basics of standard deviations and z-scores will serve us well
    in this chapter and beyond. Back in chapter 2, we mentioned that when data is
    normally distributed, approximately 68% of it would be within one standard deviation
    from the mean, plus or minus; 95% would be within two standard deviations from
    the mean; and all but a few outliers would be within three standard deviations
    from the mean. In chapter 7, we conducted Cohen’s d effect size tests, which measure
    the difference in two means from a pooled standard deviation. So we’ve at least
    had some prior exposure to standard deviations, but let’s go a little deeper.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解标准差和 z 分数的基本知识将在这个章节以及更远的地方对我们大有裨益。在第二章中，我们提到，当数据呈正态分布时，大约 68% 的数据将位于均值的一个标准差范围内，正负；95%
    将位于均值的两个标准差范围内；除了少数异常值外，所有数据都将位于均值的三个标准差范围内。在第七章中，我们进行了 Cohen 的 d 效应大小测试，它通过合并标准差来衡量两个均值之间的差异。因此，我们至少对标准差有一些先前的了解，但让我们更深入地探讨一下。
- en: Standard deviation is a statistical measure that quantifies the amount of variability,
    or dispersion, in a numeric vector. A low standard deviation indicates that the
    data is closely gathered around the mean; a high standard deviation, on the other
    hand, indicates that the data, or much of it, is spread out. A z-score is a statistical
    measure that represents the number of standard deviations a single data point
    is from the mean of its distribution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是一种统计量，它量化了数值向量中的变异量或分散度。低标准差表明数据紧密围绕均值聚集；另一方面，高标准差表明数据，或大部分数据，分布较广。z 分数是一种统计量，它表示单个数据点与其分布均值的距离标准差数。
- en: 'Let’s create a small data frame to demonstrate. We first make two calls to
    the base R `c()` function to create a pair of numeric vectors, `var1` and `var2`,
    that each contain five values. Then, we pass `var1` and `var2` to the base R `data.frame()`
    function to create a data frame called df—simple and straightforward:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小型数据框来演示。我们首先调用基础 R 的 `c()` 函数两次，创建包含五个值的两个数值向量 `var1` 和 `var2`。然后，我们将
    `var1` 和 `var2` 传递给基础 R 的 `data.frame()` 函数，创建一个名为 df 的数据框——简单直接：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But computing the standard deviation by hand or by using a spreadsheet application
    such as Microsoft Excel or Google Sheets actually requires six steps. Let’s use
    `var1` as an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过手工计算或使用 Microsoft Excel 或 Google Sheets 等电子表格应用程序来计算标准差实际上需要六个步骤。让我们以 `var1`
    为例：
- en: Find the mean by adding the values in `var1` and dividing the sum by the number
    of observations. This equals 6.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `var1` 中的值相加并除以观测值的数量来找到均值。这等于 6。
- en: Find each value’s deviation from the mean by subtracting the mean from each
    value. For the first value in `var1`, the deviation equals 2 - 6, or -4.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从每个值中减去均值来找到每个值与均值的偏差。对于 `var1` 中的第一个值，偏差等于 2 - 6，或 -4。
- en: Square each deviation from the mean by itself so that, for instance, -4 becomes
    16.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个偏差从均值平方，例如，-4 变为 16。
- en: Find the sum of squares by adding the squared deviations. This equals 40.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将平方偏差相加来找到平方和。这等于 40。
- en: Find the variance, which equals the sum of squares divided by *n* - 1, where
    *n* equals the number of observations. This equals 40 ÷ 4, or 10.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算方差，它等于平方和除以 *n* - 1，其中 *n* 等于观测值的数量。这等于 40 ÷ 4，或 10。
- en: Take the square root of the variance to get the standard deviation. This equals
    3.16.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算方差，取平方根得到标准差。这等于 3.16。
- en: 'Fortunately, we can instead just pass `var1` and `var2` to the base R `sd()`
    function to get the standard deviations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们只需将 `var1` 和 `var2` 传递给基础 R 的 `sd()` 函数，即可得到标准差：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both vectors have the same means, but the standard deviation for `var2` is almost
    double the standard deviation for `var1`. In other words, the mean can be indicative
    of a sample or population if and when the standard deviation is low, but when
    the standard deviation is high, the mean can actually be misleading.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量具有相同的均值，但 `var2` 的标准差几乎是 `var1` 的两倍。换句话说，当标准差较低时，均值可以指示样本或总体，但当标准差较高时，均值实际上可能是误导性的。
- en: 'Let’s now compute the z-score for each value in both `var1` and `var2`. To
    get the z-score for any data point, we subtract the mean from the value and divide
    the difference by the standard deviation. In R, we simply pass `df` to the `dplyr
    mutate()` function to create a pair of new variables, `zvar1` and `zvar2`, and
    append them to our data frame:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来计算`var1`和`var2`中每个值的z分数。要得到任何数据点的z分数，我们从值中减去平均值，然后将差值除以标准差。在R中，我们只需将`df`传递给`dplyr
    mutate()`函数，以创建一对新的变量`zvar1`和`zvar2`，并将它们附加到我们的数据框中：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The middle value in `var1`, for example, equals the `var1` mean, so it therefore
    has a z-score equal to 0; the middle value in `var2` has a z-score equal to -0.53,
    which means it’s approximately half a standard deviation below the `var2` mean.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`var1`中的中间值等于`var1`的平均值，因此它的z分数等于0；`var2`中的中间值z分数等于-0.53，这意味着它大约低于`var2`平均值的半个标准差。
- en: Standard deviations and z-scores provide context that we can’t always get from
    the raw data. The Boston Celtics spent just over $1.5 billion (B) in player salaries
    between the 2000 and 2017 seasons. That’s a tremendous amount of money—or is it?
    When we then compute the z-score, we get 0.21; in other words, Boston’s total
    spent on player salaries between 2000 and 2017 was just 0.21 standard deviations
    above the league mean—that is, barely average.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差和z分数提供了我们从原始数据中无法总是获得的信息。波士顿凯尔特人在2000年至2017年赛季期间仅花费了超过15亿美元（B）的球员工资。这是一笔巨大的金额——或者不是吗？当我们计算z分数时，我们得到0.21；换句话说，波士顿在2000年至2017年期间在球员工资上的总支出仅比联盟平均水平高出0.21个标准差——也就是说，几乎就是平均水平。
- en: Standard deviations are also key for performing unbiased multivariate analysis.
    When evaluating the association between a pair of numeric variables that are on
    very different scales—such as team payrolls and regular season wins—it’s absolutely
    essential to put both variables on the same scale before completing your analysis
    to avoid getting results that are weighted toward one variable at the expense
    of the other. We do that by standardizing the data and computing z-scores. That
    is just what we’ll be doing in the first half of our analysis and again when we
    compute our K-means clusters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差对于进行无偏的多变量分析也非常关键。当评估一对数值变量之间的关联，而这些变量处于非常不同的尺度上——例如球队工资和常规赛胜利——在完成分析之前将两个变量放在同一尺度上绝对至关重要，以避免得到偏向于一个变量而牺牲另一个变量的结果。我们通过标准化数据和计算z分数来实现这一点。这正是我们分析的前半部分将要做的，再次计算我们的K-means聚类时也是如此。
- en: 11.4 Analysis
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 分析
- en: We established in chapter 10 that a positive correlation exists between team
    payrolls and regular season wins, at least between the 2000 and 2017 NBA seasons;
    in fact, the correlation incrementally increased—not linearly, but it nevertheless
    increased overall—from 2006 through 2017\. Furthermore, we ran a correlation test
    that returned a p-value below the 5% threshold, thereby indicating that the association
    between team payrolls and regular season wins is, in fact, statistically significant.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第10章中已经确定，球队工资和常规赛胜利之间存在正相关关系，至少在2000年至2017年的NBA赛季之间是这样的；事实上，这种相关性是逐渐增加的——不是线性的，但总体上还是在增加——从2006年到2017年。此外，我们还进行了一次相关性测试，其p值低于5%的阈值，因此表明球队工资和常规赛胜利之间的关联实际上在统计学上是显著的。
- en: Our purpose here is to further interrogate the salaries data set and twice visualize,
    down to the team level, the relationship between payrolls and wins. We’ll first
    demonstrate how to create what is called a `ggplot2` Cleveland dot plot, where
    payrolls and wins are displayed by dots on the same standardized scale. Then,
    we’ll show you how to create a `ggplot2` horizontal bar chart, sorted by payroll
    amounts per regular season win, where the data is in its raw format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目的是进一步调查工资数据集，并两次可视化，直到球队层面，工资和胜利之间的关系。我们首先将展示如何创建所谓的`ggplot2`克利夫兰点图，其中工资和胜利通过点在同一标准化尺度上显示。然后，我们将向您展示如何创建`ggplot2`水平条形图，按常规赛每场胜利的工资金额排序，其中数据以原始格式呈现。
- en: As you might suspect by now, our data must first be wrangled some to support
    our ongoing analysis. We’ll take care of those needs next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能猜到的，我们的数据必须首先进行一些整理，以支持我们正在进行的分析。我们将在下一部分处理这些需求。
- en: 11.4.1 Wrangling data
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 数据整理
- en: As previously mentioned, the NBA was a 29-team league between 2000 and 2004
    and then a 30-team league every season thereafter; minor adjustments are therefore
    required to offset missing or Not Available (NA) values in our data and to ensure
    we return fair and accurate results. Furthermore, the raw data by itself is insufficient
    for the analysis we have in mind, so we have no choice but to transform and augment
    salaries in ways that weren’t needed in the prior chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，NBA在2000年至2004年之间是一个29支球队的联赛，此后每个赛季都是30支球队；因此，需要对数据进行一些小的调整，以抵消缺失或不可用（NA）值，并确保我们返回公平和准确的结果。此外，原始数据本身不足以进行我们心中的分析，所以我们别无选择，只能以先前章节中不需要的方式转换和增强薪资。
- en: 'The Charlotte Hornets and New Orleans Pelicans are the two teams in the salaries
    data set with missing data because neither team was around every year between
    2000 and 2004\. As such, we’re about to create three mostly similar data sets
    subset from salaries: one fixed for the Hornets, another fixed for the Pelicans,
    and a third fixed for the remaining 28 teams. At the end, we’ll combine these
    into one data set for plotting and analysis.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 夏洛特黄蜂队和新奥尔良鹈鹕队是薪资数据集中有两个缺失数据的球队，因为这两个球队在2000年至2004年之间并不是每年都存在。因此，我们即将创建三个主要相似的数据集子集从薪资：一个固定用于黄蜂队，另一个固定用于鹈鹕队，第三个固定用于剩余的28支球队。最后，我们将这些合并成一个数据集用于绘图和分析。
- en: We’ll start with the Hornets, who were active during 16 of the 18 NBA seasons
    in our data set. We therefore call the `dplyr filter()` function to subset the
    salaries data set where the variable `Team` equals Charlotte Hornets, thereby
    creating a new object called cha.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从黄蜂队开始，它在我们的数据集中活跃在18个NBA赛季中的16个赛季。因此，我们调用 `dplyr filter()` 函数来对薪资数据集进行子集化，其中变量
    `Team` 等于夏洛特黄蜂队，从而创建一个名为 cha 的新对象。
- en: 'However, before moving forward with that and other data wrangling operations,
    let’s disable scientific notation by passing the `scipen = 999` argument to the
    base R `options()` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续进行这些和其他数据处理操作之前，让我们通过将 `scipen = 999` 参数传递给基础R的 `options()` 函数来禁用科学记数法：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Later on, we’ll actually re-enable scientific notation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将实际上重新启用科学记数法：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then call the `dplyr select()` function to reduce the cha data set so that
    it only includes the 33 columns, or variables, we absolutely need going forward—these
    being `Team`, the 16 *adjusted* salary variables, and the 16 regular season wins
    variables. We’re purposely excluding the 2003 and 2004 seasons and the NAs in
    our data:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `dplyr select()` 函数来减少 cha 数据集，使其仅包括我们绝对需要的33列或变量——这些是 `Team`、16个 *调整后*
    薪资变量和16个常规赛胜利变量。我们故意排除了2003年和2004个赛季以及数据中的NA值：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we call the `mutate()` function to create four derived variables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `mutate()` 函数来创建四个派生变量：
- en: The first variable, `sumSalaries`, equals the sum of the adjusted salary variables
    in positions 2 through 17.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个变量 `sumSalaries` 等于第2至17个位置调整后薪资变量的总和。
- en: The second variable, `sumWins`, equals the sum of the regular season wins variables
    in positions 18 through 33.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个变量 `sumWins` 等于第18至33个位置常规赛胜利变量的总和。
- en: The third variable, `efficiency`, equals the sum of variables 2 through 17 divided
    by the sum of variables 18 through 33\. We’re therefore summing the adjusted salary
    for 16 seasons and dividing it by the number of regular season wins the Hornets
    had over those same 16 seasons.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个变量 `efficiency` 等于变量2至17的总和除以变量18至33的总和。因此，我们正在对16个赛季的调整后薪资进行求和，然后除以黄蜂队在相同16个赛季中的常规赛胜利次数。
- en: The fourth and final variable, `meanWins`, equals the sum of variables 18 through
    33 divided by 16 seasons, rounded to the nearest whole number. It’s therefore
    computing and returning the average number of Charlotte Hornets wins per regular
    season.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个也是最后一个变量 `meanWins` 等于变量18至33的总和除以16个赛季，四舍五入到最接近的整数。因此，它正在计算并返回每个常规赛黄蜂队胜利的平均数。
- en: 'Following are a few notes about the following chunk of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对以下代码块的一些说明：
- en: The `rowSums()` function is a built-in R function that sums numeric variables
    by row in a data set (the cha data set contains just one row of data). There is
    also a base R `colSums()` function that does the same for columns.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowSums()` 函数是R的一个内置函数，它按行在数据集中对数值变量进行求和（cha数据集只包含一行数据）。还有一个基础R的 `colSums()`
    函数，它对列执行相同的操作。'
- en: Square brackets are used for indexing a vector, matrix, array, list, or data
    frame; they are sometimes referred to as extraction operators when they are specifically
    used to extract a subset of elements from the same.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号用于索引向量、矩阵、数组、列表或数据框；当它们专门用于从同一数据集中提取元素子集时，有时被称为提取运算符。
- en: 'The dots (`.`) are used as substitutes for cha, so they represent pointers
    to the cha data set:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点 (`.`) 用作 cha 的替代，因此它们代表 cha 数据集的指针：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we pipe the cha data set to the `dplyr select()` function and create
    a new object, cha_final, which contains only the variable `Team` plus the four
    derived variables we just created:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 cha 数据集通过管道传递给 `dplyr select()` 函数，创建一个新的对象 cha_final，它只包含变量 `Team` 以及我们刚刚创建的四个派生变量：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We then repeat this exercise two times, once for the New Orleans Pelicans and
    again for the remainder of the NBA, creating two new data sets, nop_final and
    league_final, in the process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重复这个练习两次，一次用于新奥尔良鹈鹕队，再次用于 NBA 的其余部分，在这个过程中创建了两个新的数据集，nop_final 和 league_final。
- en: 'The league_final data set should include records for every NBA team *except*
    the Charlotte Hornets and New Orleans Pelicans. We therefore call the logical
    operator not equal to (`!=`) to pull every record in the salaries data set where
    the variable `Team` doesn’t equal Charlotte Hornets or New Orleans Pelicans:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: league_final 数据集应包括每个 NBA 球队的记录，*除了*夏洛特黄蜂队和新奥尔良鹈鹕队。因此，我们调用逻辑运算符不等于 (`!=`) 来提取薪资数据集中变量
    `Team` 不等于夏洛特黄蜂队或新奥尔良鹈鹕队的每个记录：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then call the built-in `rbind()` function to combine the cha_final, nop_final,
    and league_final data sets by rows into a single object called final. The `head()`
    function returns the first six observations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用内置的 `rbind()` 函数，通过行将 cha_final、nop_final 和 league_final 数据集组合成一个名为 final
    的单一对象。`head()` 函数返回前六个观测值：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have our data consolidated into a single object, we’ll call the
    `mutate()` function twice to create a pair of additional derived variables that
    both require computations within numeric vectors. The variable `zSalaries` equals
    the z-score, sometimes called a standard score, for the variable `sumSalaries`.
    Once more, the z-score represents the number of standard deviations a data point
    is above or below the distribution mean; it’s computed by subtracting the distribution
    mean from the raw data and dividing the difference by the standard deviation.
    *If* the variable `sumSalaries` were normally distributed, we could expect approximately
    20 NBA teams, or two-thirds of the league, to be within one standard deviation
    of the mean and maybe all but one or two teams to be within two standard deviations
    of the mean. The variable `zWins` equals the z-score for the variable `sumWins`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据合并到一个单一的对象中，我们将调用 `mutate()` 函数两次来创建一对额外的派生变量，这两个变量都需要在数值向量中进行计算。变量
    `zSalaries` 等于变量 `sumSalaries` 的 z 分数，有时也称为标准分数。z 分数表示数据点高于或低于分布平均值的多少个标准差；它是通过从原始数据中减去分布平均值并除以标准差来计算的。*如果*变量
    `sumSalaries` 是正态分布的，我们可以预计大约 20 支 NBA 球队，即三分之二的联赛，将位于平均值的一个标准差内，也许除了一个或两个球队外，所有球队都位于两个标准差内。变量
    `zWins` 等于变量 `sumWins` 的 z 分数。
- en: 'Subsequent calls to the `head``()` and `tail()` functions return the first
    three and last three observations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 后续对 `head()` 和 `tail()` 函数的调用返回前三个和最后三个观测值：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take the Utah Jazz, as just one example. (By the way, the Utah Jazz once played
    their home games in New Orleans; when they moved to Salt Lake City, they decided
    to keep their name as the Jazz, which is what most NBA teams do when relocating.)
    Utah spent just over $1.3 B in player salaries between 2000 and 2017\. They won
    786 regular season games over those 18 seasons, an average of 44 wins per season.
    Therefore, they spent about $1.7 M in player salaries for every regular season
    win. Their total spend in salaries was 0.71 standard deviations below the league
    mean, and their regular season wins were 0.62 standard deviations above the mean.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以犹他爵士队为例。顺便说一下，犹他爵士队曾经在新奥尔良进行主场比赛；当他们搬到盐湖城时，他们决定保留他们的名字“爵士”，这是大多数 NBA 球队在搬迁时所做的。犹他爵士队在
    2000 年至 2017 年间在球员薪资上花费了超过 13 亿美元。在这 18 个赛季中，他们赢得了 786 场常规赛，平均每个赛季 44 场胜利。因此，他们为每场常规赛胜利花费了大约
    170 万美元的球员薪资。他们在薪资上的总支出比联赛平均值低 0.71 个标准差，他们的常规赛胜利比平均值高 0.62 个标准差。
- en: 11.4.2 Evaluating payrolls and wins
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 评估薪资和胜利
- en: 'We plan to evaluate team payrolls and regular season wins between the 2000
    and 2017 NBA seasons by creating a Cleveland dot plot and then a horizontal bar
    chart. Our analysis will set us up well for what comes next: K-means clustering.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划通过创建克利夫兰点图和水平条形图来评估2000年至2017年NBA赛季之间的球队工资和常规赛胜利。我们的分析将为我们下一步做好准备：K-means聚类。
- en: Cleveland dot plot
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 克利夫兰点图
- en: 'Our first visualization, a `ggplot2` Cleveland dot plot, displays the difference
    between our standardized variables for all 30 NBA teams; in other words, it shows
    how close or how distant investments are to returns (see figure 11.1). One of
    the goals of this book is to introduce visualizations, mostly through the `ggplot2`
    graphics package, that might be outside the mainstream, discuss when they should
    best be presented, and demonstrate how to create them. A Cleveland dot plot, designed
    by prominent statistician and data visualization expert William S. Cleveland,
    is the next visualization in line, as described here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一幅可视化，一个`ggplot2`克利夫兰点图，显示了所有30支NBA球队标准化变量之间的差异；换句话说，它显示了投资与回报之间的接近程度或距离（见图11.1）。本书的一个目标是通过`ggplot2`图形包介绍一些可能不在主流之外的可视化，讨论它们何时最好展示，并演示如何创建它们。由著名统计学家和数据可视化专家威廉·S·克利夫兰设计的克利夫兰点图是下一个可视化，如下所述：
- en: The NBA’s 30 teams are sorted in alphabetical order along the x-axis. The labels
    are angled at 45 degrees and aligned horizontally just beneath the plot.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NBA的30支球队按字母顺序排列在x轴上。标签以45度角倾斜，并水平对齐在图表下方。
- en: Our y-axis measure is standard deviations, or z-scores.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的y轴度量是标准差，或z分数。
- en: The `geom_segment()` function draws 30 lines perpendicular to the x-axis, each
    of which connects a pair of points, or dots, created by two calls to the `geom_point()`
    function, starting where y equals `zSalaries` and ending where y equals `zWins`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_segment()`函数绘制了30条垂直于x轴的线，每条线连接由两个`geom_point()`函数调用创建的一对点或点，从y等于`zSalaries`开始，到y等于`zWins`结束。'
- en: The points representing the variable `zSalaries` are drawn in a dark hue, whereas
    the points representing the variable `zWins` are drawn in a light hue. All points
    are increased in size by a factor of three times the `ggplot2` default.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表变量`zSalaries`的点以深色调绘制，而代表变量`zWins`的点以浅色调绘制。所有点的大小都增加了`ggplot2`默认值的3倍。
- en: The `\n` in the caption acts as a carriage return. By default, captions are
    placed in the lower-right area and are right-justified.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题中的 `\n` 作为一个换行符。默认情况下，标题放置在右下角，并且是右对齐的。
- en: '![CH11_F01_Sutton](../../OEBPS/Images/CH11_F01_Sutton.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F01_Sutton](../../OEBPS/Images/CH11_F01_Sutton.png)'
- en: Figure 11.1 A comparison of inflation-adjusted payrolls and regular season wins
    after both variables have been standardized
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 在标准化两个变量后，比较通货膨胀调整后的工资和常规赛胜利
- en: 'Following is the code chunk for our Cleveland dot plot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们克利夫兰点图的代码块：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Clearly, we could not have drawn a Cleveland dot plot without first standardizing
    very different measures. The length of the stems indicates how well or not so
    well player salaries align with wins; this is the first clue toward correctly
    interpreting our plot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果没有首先对非常不同的度量进行标准化，我们就无法绘制克利夫兰点图。茎的长度表示球员薪资与胜利之间的匹配程度如何；这是正确解读我们图表的第一个线索。
- en: The second clue is then understanding the *direction* in which each stem was
    drawn; as a reminder, the stems are drawn *from* `zSalaries` *to* `zWins`. Therefore,
    when the stems are ascendant, it means returns in the form of regular season wins
    exceed a team’s investment in player salaries. When the stems are instead descendant,
    it means, of course, just the opposite.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线索是理解每个茎的绘制方向；提醒一下，茎是从`zSalaries`绘制到`zWins`的。因此，当茎是上升的，这意味着常规赛胜利的回报超过了球队在球员薪资上的投资。当茎相反地下降时，当然意味着正好相反。
- en: 'As it turns out, 17 teams earned returns on their respective investments, but
    13 did not. These totals are computed easily enough by piping the final data set
    to the `dplyr tally()` function twice, once to return the number of NBA teams
    where `zWins` is greater than `zSalaries` and again where `zWins` is less than
    `zSalaries`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，17支球队从各自的投资中获得了回报，但13支球队没有。这些总数很容易通过将最终数据集两次传递到`dplyr tally()`函数来计算，一次是返回`zWins`大于`zSalaries`的NBA球队数量，再次是`zWins`小于`zSalaries`。
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the `dplyr filter``()` function is called to subset the final data set
    on the 17 observations where `zWins` is greater than `zSalaries` and the `dplyr
    summarize()` function is called to then compute the mean and median differences
    between `zWins` and `zSalaries`, we see that the average difference equals 0.68
    standard deviations, and the median difference equals 0.44 standard deviations:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`dplyr filter()`函数对最终数据集进行子集化，以17个观察值中`zWins`大于`zSalaries`的情况，以及调用`dplyr
    summarize()`函数来计算`zWins`和`zSalaries`之间的均值和中位数差异时，我们看到平均差异等于0.68个标准差，而中位数差异等于0.44个标准差：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The mean is greater than the median because of teams such as the Houston Rockets,
    Utah Jazz, and especially the San Antonio Spurs; San Antonio’s investment in player
    salaries between 2000 and 2017 roughly equaled the league average, but their total
    regular season win count was more than three standard deviations above the average.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值大于中位数，这是因为像休斯顿火箭队、犹他爵士队以及尤其是圣安东尼奥马刺队这样的队伍；在2000年至2017年期间，圣安东尼奥在球员薪资上的投资大致等于联盟平均水平，但他们的常规赛总胜场数比平均水平高出三个标准差以上。
- en: 'When we flip the variables `zWins` and `zSalaries`, we see that the mean and
    median are almost one half of one standard deviation apart, with the mean being
    greater than the median:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们翻转变量`zWins`和`zSalaries`时，我们看到均值和中位数几乎相差半个标准差，均值大于中位数：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is true because of the Brooklyn Nets to some extent and the New York Knicks
    to a very large extent. The Knicks are the diametric opposite of the Spurs—their
    year-over-year payroll was more than three standard deviations above the NBA average,
    and their total number of regular season wins was about one standard deviation
    below the mean.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一定程度上也适用于布鲁克林篮网队，而在很大程度上适用于纽约尼克斯队。尼克斯队与马刺队正好相反——他们的年度工资总额比NBA平均水平高出三个标准差以上，而他们的常规赛总胜场数比平均值低大约一个标准差。
- en: Otherwise, just by reviewing our plot, we can see investments and returns are
    very well aligned—where the absolute difference between the variables `zWins`
    and `zSalaries` is less than 0.5 standard deviations—for approximately half the
    NBA. Minus the obvious outliers (the Spurs and the Knicks), our conclusions from
    chapter 10 would no doubt have been even more definite.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，仅通过查看我们的图表，我们可以看到投资和回报非常一致——变量`zWins`和`zSalaries`之间的绝对差异小于0.5个标准差，对于大约一半的NBA球队来说。除去明显的异常值（马刺队和尼克斯队），我们第10章的结论无疑会更加明确。
- en: Horizontal bar chart
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 水平条形图
- en: 'In our second look, total salaries divided by wins is visualized in a `ggplot2`
    horizontal bar chart where efficiency, equal to dollars spent on player salaries
    for every regular season win between 2000 and 2017, drops from top to bottom (see
    figure 11.2):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二次审视中，总薪资除以胜场数在`ggplot2`水平条形图中可视化，效率，即2000年至2017年每场常规赛投入球员薪资的效率，从上到下递减（见图11.2）：
- en: The `reorder``()` and `coord_flip()` functions more or less work in tandem here.
    If our intent was to instead create a *vertical* bar chart, our results would
    be sorted, left to right, as the variable efficiency decreased, but by flipping
    our plot to a horizontal layout, we get lower (and better) efficiency numbers
    on top and higher (and worse) efficiency numbers on the bottom. Note that the
    x- and y-axes are part of the plot; as such, they also flip.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reorder()`和`coord_flip()`函数在这里几乎是协同工作的。如果我们原本的意图是创建一个*垂直*条形图，我们的结果将按照效率变量从左到右递减的顺序排序，但通过将我们的图表翻转成水平布局，我们得到顶部（较低且较好）的效率数值和底部（较高且较差）的效率数值。注意，x轴和y轴是图表的一部分；因此，它们也会翻转。'
- en: The `scale_y_continuous()` function plus the `label_dollar``()` and `cut_short_
    scale()` functions from the `scales` package transform our y-axis labels from
    seven-digit numerals to $1M, $2M, and $3M.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_y_continuous()`函数加上`scales`包中的`label_dollar()`和`cut_short_scale()`函数将我们的y轴标签从七位数转换为$1M、$2M和$3M。'
- en: The `geom_text()` function affixes values from the variable `meanWins` as labels
    beside the bars; these can be adjusted vertically or horizontally with the `vjust`
    and `hjust` arguments, respectively. In addition, we’ve added a caption as another
    argument to the `labs()` function to note that these figures represent the average
    count of regular season wins for each team.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_text()`函数将变量`meanWins`的值附加到条形旁作为标签；这些标签可以通过`vjust`和`hjust`参数分别垂直或水平调整。此外，我们还在`labs()`函数中添加了一个标题作为另一个参数，以指出这些数字代表每个球队常规赛平均胜场数的计数。'
- en: '![CH11_F02_Sutton](../../OEBPS/Images/CH11_F02_Sutton.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F02_Sutton](../../OEBPS/Images/CH11_F02_Sutton.png)'
- en: Figure 11.2 Spend on player salaries for every regular season win between 2000
    and 2017, sorted from top to bottom between most efficient to least efficient
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：2000年至2017年间，每场常规赛胜利的球员薪资支出，从最高效到最低效进行排序
- en: 'Now, here’s the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是代码：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From our sorted bar chart, we can glean the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的排序条形图中，我们可以得出以下结论：
- en: The San Antonio Spurs averaged significantly more regular season wins per year
    than every other team and paid out less than $1.5 M in player salaries for every
    win. By the way, the Spurs won four league titles between 2003 and 2014.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣安东尼奥马刺平均每赛季的常规赛胜利数显著高于其他任何球队，并且每场胜利的球员薪资支出不到150万美元。顺便说一句，马刺在2003年至2014年期间赢得了四次联赛冠军。
- en: The New York Knicks, on the other hand, paid more than twice what the Spurs
    paid in player salaries for every regular season win and averaged only 35 wins
    per season in the process. The Knicks haven’t won an NBA title since 1973.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，纽约尼克斯为每场常规赛胜利支付的球员薪资是圣安东尼奥马刺的两倍多，但平均每赛季只赢得35场比赛。尼克斯自1973年以来就没有赢得过NBA冠军。
- en: Once more, minus these two rather obvious outliers in our data, our chapter
    10 conclusions around payrolls and wins would certainly be even more convincing.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，除去我们数据中的这两个相当明显的异常值，我们关于薪资和胜利的第10章结论将更加令人信服。
- en: In between the Spurs and Knicks, we don’t see too much variance in efficiency
    or average wins per season.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在圣安东尼奥马刺和纽约尼克斯之间，我们在效率和平均每赛季胜利数上并没有看到太大的差异。
- en: However, teams in the top half of our plot, for the most part, averaged more
    regular season wins than the teams in the bottom half. Only 4 of the 15 teams
    in the top half averaged fewer than 40 wins per season, and only 3 teams in the
    bottom half averaged at least 40 wins per season.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，在我们的图表上半部分的球队，大部分情况下，平均每赛季的常规赛胜利数比下半部分的球队多。上半部分的15支球队中只有4支每赛季平均胜场数少于40场，下半部分的球队中只有3支每赛季平均胜场数至少为40场。
- en: No question, payrolls influence wins, but when you see results like these, you
    also have to figure that other factors, such as competent management (or incompetent
    management) and maybe luck (good or bad), are also relevant.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，薪资会影响胜利，但当你看到这样的结果时，你也必须考虑到其他因素，例如合格的管理（或不合格的管理）以及可能的好运（或坏运），这些也是相关的。
- en: Next, we’ll divide the NBA’s 30 teams into like and unlike clusters based on
    team payrolls and regular season wins.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据球队的薪资和常规赛胜利数将NBA的30支球队划分为类似和不同的聚类。
- en: 11.5 K-means clustering
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 K均值聚类
- en: 'K-means clustering is a popular unsupervised learning algorithm used for data
    segmentation. Here are the basics:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: K均值聚类是一种流行的无监督学习算法，用于数据分段。以下是基本原理：
- en: The goal is to partition an entire data set into distinct and therefore nonoverlapping
    clusters, where every data point is assigned to a cluster with the nearest mean,
    or centroid. The number of clusters is equal to *K*. It thus aims to minimize
    intra-cluster variance and maximize inter-cluster variance.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标是将整个数据集划分为不同的且因此非重叠的聚类，其中每个数据点都被分配到具有最近平均值的聚类中，即质心。聚类的数量等于*K*。因此，它的目标是使簇内方差最小化，使簇间方差最大化。
- en: The K-means algorithm operates iteratively by randomly initializing *K* centroids
    and then alternating between two steps—(1) assigning or reassigning each data
    point to the nearest centroid and (2) recalculating the centroids as the mean
    of all the data points assigned and then reassigned to them—until convergence.
    Convergence occurs when the centroids become fixed or a predefined maximum number
    of iterations is reached. There’s no hard requirement to set a maximum number
    of iterations, but it’s a good practice nonetheless.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K均值算法通过迭代方式运行，随机初始化*K*个质心，然后交替进行两个步骤——(1)将每个数据点分配或重新分配到最近的质心，以及(2)重新计算质心，作为所有分配和重新分配给它们的点的平均值——直到收敛。收敛发生在质心变得固定或达到预定义的最大迭代次数时。虽然不是强制要求设置最大迭代次数，但这是一个良好的实践。
- en: Like hierarchical clustering, the distance between data points and centroids
    is typically computed by applying the Euclidean distance metric, which measures
    the straight-line distance between a pair of data points in a two-dimensional
    space (see chapter 3 for details).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与层次聚类类似，数据点和质心之间的距离通常是通过应用欧几里得距离度量来计算的，它衡量的是二维空间中一对数据点之间的直线距离（详细信息请参阅第3章）。
- en: Unlike hierarchical clustering, the number of clusters, or *K*, must be determined
    in advance. Choosing *K* isn’t always straightforward. If you’re in charge of
    a marketing team at a department store, for instance, and you only have enough
    resources to develop and maintain two advertising campaigns, there’s only one
    choice for *K*. Likewise, if you’re running a debt collection agency and decide
    up front that anything more than three strategies for three delinquent customer
    segmentations is untenable, then *K* can’t exceed three. But if *K* can be almost
    any reasonable and logical number, there are several ways to go about calculating
    how many clusters *might* be optimal. We’ll demonstrate two of those methods.
    On the whole, too few clusters might oversimplify the data and not add much value,
    but too many clusters may lead to overfitting.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与层次聚类不同，簇的数量，或 *K*，必须提前确定。选择 *K* 并非总是直截了当。例如，如果你是一家百货公司的营销团队负责人，而且你只有足够的资源来开发和维护两个广告活动，那么对于
    *K* 来说只有一个选择。同样，如果你在一家债务收集机构工作，并且一开始就决定超过三个策略来处理三个违约客户细分是不可行的，那么 *K* 不能超过三个。但如果
    *K* 可以是几乎任何合理和逻辑的数字，那么有几种方法可以用来计算可能最优的簇数量。我们将演示其中两种方法。总的来说，簇太少可能会过度简化数据，不会增加太多价值，但簇太多可能会导致过度拟合。
- en: The K-means algorithm is fast, simple, and scalable—and with plenty of use cases.
    A police department could associate categories of criminal offenses (violent crime,
    property crime, white-collar crime, organized crime, and consensual or victimless
    crime) with geospatial points, identify any patterns, and deploy police accordingly;
    a department store could profile its customers using demographic attributes and
    purchasing history to develop tailored marketing strategies; a debt collection
    agency could segment its customers around their outstanding balance and credit
    history to implement made-to-order collections strategies; or a clerk at the National
    Archives could use K-means for document classification using tags, topics, and
    content.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K-means 算法快速、简单且可扩展，并且有大量的应用场景。警察局可以将犯罪行为类别（暴力犯罪、财产犯罪、白领犯罪、有组织犯罪和同意或无受害者犯罪）与地理空间点关联起来，识别任何模式，并据此部署警力；百货公司可以利用人口统计属性和购买历史来分析其客户，以制定定制化的营销策略；债务收集机构可以根据客户的未偿还余额和信用历史来细分客户，以实施定制化的收集策略；或者国家档案馆的职员可以使用
    K-means 算法，通过标签、主题和内容对文档进行分类。
- en: But it’s generally understood that K-means returns best results when the variables
    in play are normally distributed. NBA payrolls and regular season wins aren’t
    normally distributed, however, so we’ll test that and show that later.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，通常认为 K-means 在变量呈正态分布时返回最佳结果。然而，NBA 的薪资和常规赛胜利并不呈正态分布，所以我们将测试这一点，并在稍后展示。
- en: Our results will be plotted in a single visualization with team payrolls as
    our x-axis variable and regular season wins as our y-axis variable. The K-means
    algorithm automatically converts raw numbers into z-scores. You’ll see that the
    results tie back extremely well to our Cleveland dot plot, except for the fact
    that all 30 NBA teams have been assigned to one cluster or another. But first,
    we have some further data wrangling to take care of.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果将被绘制在一个单一的可视化中，以球队薪资作为 x 轴变量，常规赛胜利作为 y 轴变量。K-means 算法自动将原始数字转换为 z 分数。你会看到结果与我们的克利夫兰点图非常吻合，除了所有
    30 支 NBA 球队都被分配到一个或另一个簇中。但首先，我们还有一些进一步的数据处理要处理。
- en: 11.5.1 More data wrangling
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 更多数据处理
- en: 'Back to the Charlotte Hornets. We start by piping the cha data set we created
    earlier to the `dplyr mutate()` function twice to create a pair of derived variables.
    The first of these is called `salarytotal`, which is merely the sum of Charlotte’s
    *adjusted* salaries between 2000 and 2002 and between 2005 and 2017 from columns
    2 through 17\. The second derived variable is called `wintotal`, which is the
    sum of Charlotte’s regular season win totals in columns 18 through 33\. The results
    are cast to a new object called cha_kmeans:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回到夏洛特黄蜂队。我们首先将之前创建的 cha 数据集通过 `dplyr mutate()` 函数处理两次，以创建一对派生变量。第一个派生变量被称为 `salarytotal`，它仅仅是夏洛特队
    2000 年至 2002 年和 2005 年至 2017 年间调整后的工资总和，从第 2 列到第 17 列。第二个派生变量被称为 `wintotal`，它是夏洛特队常规赛胜利总数的总和，从第
    18 列到第 33 列。结果被转换到一个新的对象 cha_kmeans 中：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To even up the Charlotte Hornets with NBA teams that played every season between
    2000 and 2017, we bump the derived variables `salarytotal` and `wintotal` by 11%
    (the Hornets “missed” two seasons, or approximately 11% of the 18 NBA seasons
    contained in the salaries data set). This is by no means an exact science, but
    it will lead to more reasonable and even more accurate results than doing nothing;
    take a second look at our Cleveland dot plot, where we left the Hornets and the
    Pelicans as they were. Because `wintotal` should not contain any fractional or
    decimal part, we call the base R `round()` function to round the `wintotal` result
    to the nearest whole number:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使夏洛特黄蜂队与在2000年至2017年之间每个赛季都参加的NBA球队保持一致，我们将派生的变量`salarytotal`和`wintotal`增加11%（黄蜂队“错过了”两个赛季，即大约11%的包含在薪资数据集中的18个NBA赛季）。这绝对不是一门精确的科学，但它将比什么都不做产生更合理、更准确的结果；再次看看我们的克利夫兰点图，我们在那里保留了黄蜂队和鹈鹕队。由于`wintotal`不应包含任何分数或小数部分，我们调用基础R的`round()`函数将`wintotal`结果四舍五入到最接近的整数：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then reduce the dimension of cha_kmeans by calling the `select()` function
    to only include the three variables we absolutely need to enable our forthcoming
    K-means clustering algorithm—`Team`, `salarytotal`, and `wintotal`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`select()`函数来降低`cha_kmeans`的维度，只包括我们绝对需要的三个变量，以启用我们即将到来的K-means聚类算法——`Team`、`salarytotal`和`wintotal`：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then repeat this exact same exercise two times, first for the New Orleans
    Pelicans and then for the remaining NBA teams. Because the Pelicans “missed” three
    seasons, we increase their `salarytotal` and `wintotal` sums by 17%. As a result,
    we have two new data objects, nop_kmeans and league_kmeans:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重复这个完全相同的练习两次，首先针对新奥尔良鹈鹕队，然后针对剩余的NBA球队。由于鹈鹕队“错过了”三个赛季，我们将它们的`salarytotal`和`wintotal`总和增加了17%。因此，我们有了两个新的数据对象，`nop_kmeans`和`league_kmeans`：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the chunk of code that follows, we first call the base R `rbind()` function
    to merge the cha_kmeans, nop_kmeans, and league_kmeans data sets into a single
    object called final_kmeans. Then, we call the `select()` function to subset final_kmeans
    on the variables `salarytotal` and `wintotal`, thereby removing the variable `Team`.
    Immediately thereafter, we call the base R `trunc()` function to essentially convert
    the variable `wintotal` from a float to an integer. Finally, we call the `print()`
    function to return the entire final_kmeans data set:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们首先调用基础R的`rbind()`函数，将`cha_kmeans`、`nop_kmeans`和`league_kmeans`数据集合并成一个名为`final_kmeans`的单个对象。然后，我们调用`select()`函数对`final_kmeans`进行子集化，基于变量`salarytotal`和`wintotal`，从而删除`Team`变量。紧接着，我们调用基础R的`trunc()`函数，将变量`wintotal`从浮点数转换为整数。最后，我们调用`print()`函数来返回整个`final_kmeans`数据集：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our final data wrangling operation is a call to the base R `rownames()` function
    to overwrite the numeric row names in the final_kmeans data set with three-letter
    abbreviations representing all 30 NBA teams. Our data is sorted with Charlotte
    (CHA) and New Orleans (NOP) at the top and then alphabetically by the remaining
    28 teams. Our results will, of course, be much easier to interpret if they contain
    team abbreviations rather than numerals:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的数据处理操作是调用基础R的`rownames()`函数，将`final_kmeans`数据集中的数字行名替换为表示所有30支NBA球队的三个字母缩写。我们的数据按夏洛特（CHA）和纽奥尔良（NOP）排在最前面，然后按剩余的28支球队进行字母排序。当然，如果结果包含球队缩写而不是数字，那么它们将更容易解释：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, let’s move on to our analysis.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行我们的分析。
- en: 11.5.2 K-means clustering
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 K-means聚类
- en: A K-means algorithm, as opposed to the hierarchical clustering algorithm we
    created back in chapter 3, first requires that we specify the number of clusters
    to generate. It’s not uncommon to randomly specify a cluster count, designated
    by *K*, or experiment with different cluster counts; however, we’ll demonstrate
    a pair of methods to generate optimal cluster counts and then make a decision
    on *K* subsequent to completing both methods.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在第3章中创建的层次聚类算法不同，K-means算法首先要求我们指定要生成的聚类数量。随机指定一个聚类数量，称为*K*，或者尝试不同的聚类数量并不罕见；然而，我们将演示两种生成最佳聚类数量的方法，并在完成这两种方法之后决定*K*：
- en: Calculating optimal cluster counts
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 计算最佳聚类数量
- en: The first method is frequently referred to as the elbow method or, more technically,
    the within sum of squares method. We draw a type of line chart called a scree
    plot, which displays the number of clusters along the x-axis and the within-cluster
    sum of squares (aka the within-cluster variance) along the y-axis. It computes
    and recomputes the sum of squares of the distances separating every data point
    and their assigned clusters, minimizing the sum with each iteration by increasing
    the number of clusters. The variance usually decreases at a decreasing rate until
    diminishing returns set in, which is where additional increases in *K* fail to
    further decrease the within-cluster variance. That’s typically where the plot
    bends—the elbow point—and we should accept that as an optimal number of clusters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法通常被称为肘部方法，或者更技术性地，称为簇内平方和法。我们绘制一种称为碎石图的线形图，它在 x 轴上显示簇数，在 y 轴上显示簇内平方和（也称为簇内方差）。它计算并重新计算每个数据点与其分配的簇之间的距离平方和，通过增加簇数来最小化每次迭代的和。方差通常以递减的速度下降，直到出现递减回报，这时增加
    *K* 的额外增加无法进一步降低簇内方差。通常，这就是图表弯曲的地方——肘部点——我们应该接受这个作为最优簇数。
- en: However, the elbow method is more subjective than objective; unfortunately,
    scree plots don’t always display a definitive elbow point. In fact, the elbow
    point and where we see diminishing returns for *K* might not be the same. That’s
    where the second method, known as the average silhouette method, comes in. It
    starts by computing a silhouette coefficient, or some number between -1 and +1,
    for every data point, based on the dissimilarity between a data point and other
    data points within the same cluster as well as the average dissimilarity between
    a data point and every data point in the nearest cluster. The silhouette coefficient
    is computed by taking the difference between those dissimilarities and dividing
    it by the maximum between the two. The clustering configuration stops when most
    data points have high, or at least positive, silhouette coefficients; conversely,
    low silhouette coefficients suggest too-low or too-high cluster counts, thereby
    triggering additional iterations. We get a plot that displays the number of clusters
    along the x-axis and the silhouette coefficients along the y-axis. It also reveals
    a *precise* optimal value for *K*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，肘部方法比客观方法更为主观；不幸的是，碎石图并不总是显示一个明确的肘部点。事实上，肘部点和我们观察到对于 *K* 的递减回报可能并不相同。这就是第二种方法，被称为平均轮廓方法，发挥作用的地方。它首先计算每个数据点的轮廓系数，这是一个介于
    -1 和 +1 之间的数字，基于数据点与其所在簇内其他数据点的相似度，以及数据点与最近簇中每个数据点的平均相似度。轮廓系数是通过取这些相似度的差值，并将其除以这两个数中的最大值来计算的。当大多数数据点具有高，或者至少是正的轮廓系数时，聚类配置停止；相反，低轮廓系数表明簇计数过低或过高，从而触发额外的迭代。我们得到一个显示
    x 轴上的簇数和 y 轴上的轮廓系数的图。它还揭示了 *K* 的一个 *精确* 的最优值。
- en: 'In the next code chunk, we twice call on the `fviz_nbclust()` function from
    the `factoextra` package to compute and visualize optimal cluster counts, first
    using the within-cluster sum of squares method and then the silhouette method.
    The `fviz_nbclust()` function takes the following three arguments: the data source,
    the clustering algorithm (it doesn’t necessarily have to be K-means), and the
    method, which are all pretty simple. In fact, the `fviz_nbclust()` function automatically
    inserts labels for both plots and defaults the y-axis tick marks for the second
    plot based on our preference for full digit numerals versus scientific notation.
    Because the sum of squares values are very large numbers, we first re-enable scientific
    notation by passing the `scipen` `=` `000` argument to the `options()` function
    and then make our successive calls to `fviz_nbclust()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码块中，我们两次调用 `factoextra` 包中的 `fviz_nbclust()` 函数来计算和可视化最优簇计数，首先使用簇内平方和法，然后使用轮廓法。`fviz_nbclust()`
    函数接受以下三个参数：数据源、聚类算法（它不一定是 K-means）和方法，这些都是相当简单的。事实上，`fviz_nbclust()` 函数自动为两个图插入标签，并将第二个图的
    y 轴刻度默认设置为基于我们偏好全数字数值而不是科学记数法。由于平方和值是很大的数字，我们首先通过将 `scipen` 参数设置为 `000` 重新启用科学记数法，然后连续调用
    `fviz_nbclust()`：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `patchwork` package works just as well with these plots as it does with
    `ggplot2` visualizations. Therefore, we call the `plot_layout()` function to group
    these two plots into a single graphical object, displaying plot `p3` on top of
    `p4` (see figure 11.3):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`patchwork`包与这些图表的配合效果与`ggplot2`可视化一样好。因此，我们调用`plot_layout()`函数将这两个图表组合成一个单一的图形对象，将图表`p3`显示在`p4`之上（见图11.3）：'
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![CH11_F03_Sutton](../../OEBPS/Images/CH11_F03_Sutton.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F03_Sutton](../../OEBPS/Images/CH11_F03_Sutton.png)'
- en: Figure 11.3 Two solutions on optimal cluster counts visualized, where the plot
    on the top is a scree plot that represents the within-cluster sum of squares method,
    and the plot on the bottom represents the silhouette method
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3展示了两种关于最优聚类数量的解决方案，其中顶部的图表是碎石图，代表簇内平方和法，底部的图表代表轮廓法
- en: While the silhouette method (bottom of figure 11.3) returns a definite, or unambiguous,
    optimal cluster count, the within-cluster sum of squares method (scree plot at
    top of figure 11.3) returns an optimal number of clusters that is open to interpretation.
    On one hand, the sharpest drop in the sum of squares is between one and two clusters,
    thereby suggesting two clusters would be optimal; on the other hand, the plot
    bends, and the slope approaches 0 between five and six clusters, alternatively
    suggesting—more convincingly—that six clusters would instead be best.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当轮廓法（图11.3底部）返回一个明确的、或无歧义的、最优聚类数量时，簇内平方和法（图11.3顶部的碎石图）返回的聚类数量则开放于解释。一方面，平方和的最陡下降出现在一和两个聚类之间，因此表明两个聚类将是最佳选择；另一方面，图表弯曲，五和六个聚类之间的斜率接近0，这更有说服力地表明六个聚类可能才是最佳选择。
- en: Running the algorithm
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行算法
- en: 'We’re going to split the difference and proceed with four clusters, also taking
    into account the fact that small cluster counts sometimes run the risk of oversimplifying
    the data. We then call the `kmeans()` function, which is part of base R, to construct
    our four clusters and group the NBA’s 30 teams based on the final_kmeans variables
    `salarytotal` and `wintotal`. The `kmeans()` function *requires* just two arguments:
    the data set (final_kmeans) and the number of desired clusters (4), otherwise
    known as *K.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将折中处理，并继续使用四个聚类，同时考虑到小聚类数量有时会存在过度简化的风险。然后我们调用`kmeans()`函数，这是R基础包的一部分，来构建我们的四个聚类，并根据最终`kmeans`变量`salarytotal`和`wintotal`将NBA的30支球队分组。`kmeans()`函数*需要*两个参数：数据集（final_kmeans）和期望的聚类数量（4），也称为*K*。
- en: 'We’ll additionally pass two *optional* arguments to the `kmeans()` function:
    `iter.max` and `nstart`. The `iter.max` argument represents the number of times
    the algorithm should run before returning any results. Bear in mind that the `kmeans()`
    function churns through several iterative steps, if allowed, and returns a configuration
    where the total sum of squares between the data and its respective centroid—that
    is, the center position of a cluster—is minimized. The optimal configuration may
    very well be obtained after just one run, or it may not—relegating the algorithm
    to one run may leave more optimal configurations on the table. Therefore, it’s
    best to enable more than one iteration, which is the default; here, we’re telling
    R to iterate through the algorithm 25 times.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向`kmeans()`函数传递两个*可选*参数：`iter.max`和`nstart`。`iter.max`参数表示算法在返回任何结果之前应该运行的次数。请记住，如果允许，`kmeans()`函数会经历几个迭代步骤，并返回一个配置，其中数据与各自质心的总平方和最小化——即聚类的中心位置。最佳配置可能在仅运行一次后就能获得，也可能不会——仅运行一次算法可能会留下更多最佳配置。因此，最好启用多次迭代，这是默认设置；在这里，我们告诉R迭代算法25次。
- en: 'The `nstart` argument represents the number of random data sets used to initialize
    the algorithm. We’ve specified four clusters and set the `nstart` argument to
    equal `25`. Consequently, R will extract four sets of data, one per cluster, 25
    times every time the algorithm is set to run. The `print()` function returns the
    results:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`nstart`参数表示用于初始化算法的随机数据集的数量。我们指定了四个聚类，并将`nstart`参数设置为`25`。因此，每次算法运行时，R将提取四组数据，每组一个聚类，总共25次。`print()`函数返回结果：'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This gives us the following information:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下信息：
- en: The number of teams assigned to each cluster (1, 15, 11, 3).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给每个聚类的球队数量（1，15，11，3）。
- en: The `salarytotal` and `wintotal` means for each cluster, which also represent
    the centroids for every cluster. The returned data is sorted in ascending order
    by the variable `wintotal`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个聚类的`salarytotal`和`wintotal`均值，这些也代表了每个聚类的中心点。返回的数据按`wintotal`变量升序排序。
- en: The cluster assignments for every team, where each cluster is identified by
    a number between 1 and 4\. Every NBA team has been assigned to a cluster.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个球队的聚类分配，其中每个聚类由1到4之间的数字标识。每个NBA球队都被分配到一个聚类中。
- en: 'We then visualize these results with a `ggplot2` look and feel by calling the
    `fviz_ cluster()` function from the `factoextra` package (see figure 11.4). A
    legend is automatically added to the right of the plot unless otherwise specified
    (we’ve decided to not include a legend). We also have the option of adding our
    own title and subtitle, x-axis and y-axis labels, and changing the font to bold:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`factoextra`包中的`fviz_cluster()`函数，以`ggplot2`的外观和感觉可视化这些结果（见图11.4）。除非另有说明，否则图例会自动添加到图的右侧（我们决定不包含图例）。我们还可以选择添加自己的标题和副标题、x轴和y轴标签，以及将字体改为粗体：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![CH11_F04_Sutton](../../OEBPS/Images/CH11_F04_Sutton.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F04_Sutton](../../OEBPS/Images/CH11_F04_Sutton.png)'
- en: Figure 11.4 The visualization of our K-means cluster where K equals 4\. The
    clusters are based on a combination of team payrolls and regular season wins,
    where each variable has been standardized.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 我们K-means聚类的可视化，其中K等于4。聚类基于球队工资和常规赛胜利次数的组合，其中每个变量都已标准化。
- en: 'The labels along the x- and y-axes represent the number of standard deviations
    from the distribution means (you can cross-check these with our Cleveland dot
    plot). Here’s what we can glean from our K-means algorithm and the visualization
    of the same:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: x轴和y轴上的标签表示分布均值的标准差数（你可以通过我们的克利夫兰点图进行交叉验证）。以下是我们从K-means算法及其可视化中可以得出的结论：
- en: The San Antonio Spurs (SAS), which, in our estimation, were the NBA’s most efficient
    team between 2000 and 2017, had a regular season win count more than three standard
    deviations *above* the league average and a total payroll that was actually *below*
    average. Yet they’re clustered with the Nets and not with the Lakers or Mavericks.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣安东尼奥马刺队（SAS），据我们估计，在2000年至2017年期间是NBA最有效的球队，其常规赛胜利次数比联赛平均水平高出三个标准差以上，而其实际总工资却低于平均水平。然而，他们与篮网队而不是湖人队或小牛队聚集在一起。
- en: The New York Knicks (NYK) are in a “cluster” all by themselves because their
    regular season win count was more than one standard deviation *below* the league
    average while their payroll was more than three standard deviations *above* it.
    You might think the Nets should be aligned with the Knicks, not San Antonio.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纽约尼克斯队（NYK）独自在一个“聚类”中，因为他们的常规赛胜利次数比联赛平均水平低一个标准差以上，而他们的工资却比平均水平高三个标准差以上。你可能认为篮网队应该与尼克斯队对齐，而不是与圣安东尼奥队。
- en: The Boston Celtics (BOS), Miami Heat (MIA), Los Angeles Lakers (LAL), and Dallas
    Mavericks (DAL) were more or less *equally* above the league averages in wins
    *and* payrolls. These four teams won a combined 10 NBA championships between 2000
    and 2013.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波士顿凯尔特人队（BOS）、迈阿密热火队（MIA）、洛杉矶湖人队（LAL）和达拉斯小牛队（DAL）在胜利次数和工资方面与联赛平均水平大致相等。这四支球队在2000年至2013年之间共赢得了10个NBA总冠军。
- en: Teams that averaged the fewest number of regular season wins between the 2000
    and 2017 seasons—the Charlotte Hornets (CHA), Minnesota Timberwolves (MIN), Washington
    Wizards (WAS), Philadelphia 76ers (PHI), Brooklyn Nets (BKN), and Milwaukee Bucks
    (MIL)—by and large had payrolls, plus or minus, very close to the league average
    while, of course, their regular season win counts were at or even beyond one standard
    deviation below the league mean.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在2000年至2017赛季期间常规赛胜利次数最少的球队——夏洛特黄蜂队（CHA）、明尼苏达森林狼队（MIN）、华盛顿奇才队（WAS）、费城76人队（PHI）、布鲁克林篮网队（BKN）和密尔沃基雄鹿队（MIL）——总的来说，他们的工资与联赛平均水平非常接近，当然，他们的常规赛胜利次数在联赛平均水平或以下一个标准差。
- en: Our clusters run more vertically than they do horizontally; that is, it more
    or less appears that a line in the sand, so to speak, has been drawn where the
    variable `Team Payrolls` equals one standard deviation above the mean.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据聚类在垂直方向上比在水平方向上更密集；也就是说，可以说在变量“球队工资”等于均值以上一个标准差的地方画了一条线。
- en: 'Bear in mind that neither `salarytotal` nor `wintotal` are normally distributed.
    The K-means algorithm works *best*—it still otherwise works—when the plotted variables
    are evenly distributed around their means. A Shapiro-Wilk test returns a p-value
    that tells us whether or not a numeric variable is normally distributed. Our null
    hypothesis is a normal distribution; we would therefore reject that hypothesis
    if Shapiro-Wilk returned a p-value below 5%. That being said, we pass the variables
    `salarytotal` and `wintotal` to the base R `shapiro.test()` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`salarytotal` 和 `wintotal` 都不是正态分布的。当绘制的变量均匀地分布在它们的平均数周围时，K-means 算法工作得最好——它仍然可以正常工作。Shapiro-Wilk
    测试返回一个 p 值，告诉我们一个数值变量是否服从正态分布。我们的零假设是正态分布；因此，如果 Shapiro-Wilk 返回的 p 值低于 5%，我们会拒绝该假设。话虽如此，我们将变量
    `salarytotal` 和 `wintotal` 传递给基础 R 的 `shapiro.test()` 函数：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both tests returned p-values below the 5% threshold for significance; so we
    would reject the null hypothesis twice and conclude that both variables aren’t
    normally distributed. This might help explain the anomalies in the results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 两次测试的 p 值都低于 5% 的显著性阈值；因此我们会两次拒绝零假设，并得出结论，这两个变量都不服从正态分布。这或许可以解释结果中的异常。
- en: Experimenting with other values for K
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试其他 *K* 值的实验
- en: Rather than finishing with just a single K-means algorithm where *K* equals
    4, let’s next iterate our code and test where *K* equals 2 through 7\. Our results—just
    the results, no code—are displayed over the next few pages (see figures 11.5a
    through 11.5c).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅以一个 *K* 等于 4 的 K-means 算法结束，接下来让我们迭代我们的代码并测试 *K* 从 2 到 7 的情况。我们的结果——仅仅是结果，没有代码——将在接下来的几页中展示（见图
    11.5a 至 11.5c）。
- en: '![CH11_F05a_Sutton](../../OEBPS/Images/CH11_F05a_Sutton.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F05a_Sutton](../../OEBPS/Images/CH11_F05a_Sutton.png)'
- en: Figure 11.5a K-means clusters where the number of clusters, otherwise known
    as *K*, starts at 2 and completes at 7
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5a 当聚类数量，即 *K*，从 2 开始到 7 结束时的 K-means 聚类
- en: '![CH11_F05b_Sutton](../../OEBPS/Images/CH11_F05b_Sutton.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F05b_Sutton](../../OEBPS/Images/CH11_F05b_Sutton.png)'
- en: Figure 11.5b K-means clusters where the number of clusters, otherwise known
    as *K*, starts at 2 and completes at 7
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5b 当聚类数量，即 *K*，从 2 开始到 7 结束时的 K-means 聚类
- en: '![CH11_F05c_Sutton](../../OEBPS/Images/CH11_F05c_Sutton.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F05c_Sutton](../../OEBPS/Images/CH11_F05c_Sutton.png)'
- en: Figure 11.5c K-means clusters where the number of clusters, otherwise known
    as *K*, starts at 2 and completes at 7
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5c 当聚类数量，即 *K*，从 2 开始到 7 结束时的 K-means 聚类
- en: 'In the results, note the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，请注意以下几点：
- en: Where *K* equals 2, K-means throws every data point where payroll is less than
    one standard deviation above the NBA mean into one cluster and every data point
    where payroll is more than one standard deviation greater than the league mean
    into the other cluster.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 2 时，K-means 将工资总额低于 NBA 平均数一个标准差以下的所有数据点投入一个聚类，而工资总额高于联盟平均数一个标准差以上的所有数据点投入另一个聚类。
- en: Where *K* equals 3, the largest of the two previous clusters is split into two
    groups. In the new cluster, every data point has a `salarytotal` z-score below
    the mean and a `wintotal` z-score less than one standard deviation above the league
    average.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 3 时，之前两个较大的聚类中的最大一个被分为两组。在新聚类中，每个数据点的 `salarytotal` z 分数都低于平均数，而 `wintotal`
    z 分数低于联盟平均数一个标准差。
- en: Where *K* equals 4, the algorithm has merely thrown the New York Knicks into
    its own group.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 4 时，算法仅仅将纽约尼克斯队放入了自己的一个组中。
- en: Where *K* equals 5, the previous two clusters plotted where payroll is less
    than one standard deviation above the mean are divided into three clusters. Every
    data point within those three clusters has a `wintotal` z-score less than one
    standard deviation above the mean.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 5 时，之前绘制的工资总额低于平均数一个标准差以下的两个聚类被划分为三个聚类。这三个聚类中的每一个数据点的 `wintotal` z
    分数都低于平均数一个标准差。
- en: Where *K* equals 6, the Los Angeles Lakers (LAL) are separated from the Dallas
    Mavericks (DAL) and Portland Trailblazers (POR) and cast into a cluster with a
    pair of teams that have payrolls less than one standard deviation above the mean.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 6 时，洛杉矶湖人队（LAL）与达拉斯小牛队（DAL）和波特兰开拓者队（POR）分开，并被放入一个包含两支工资总额低于平均数一个标准差以下的球队的聚类中。
- en: Where *K* equals 7, the Charlotte Hornets, with a payroll greater than one standard
    deviation below the league mean and a regular season win count also greater than
    one standard deviation below the mean, are thrown into their own group. Overall,
    the K-means algorithm, when instructed to iteratively add one new cluster, did
    so by splitting the data mostly by payroll rather than by wins.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 *K* 等于 7 时，夏洛特黄蜂队，其工资水平低于联赛平均值的超过一个标准差，常规赛胜利次数也低于平均值超过一个标准差，被放入他们自己的组中。总的来说，K-means
    算法在指令迭代添加一个新簇时，主要通过工资而不是胜利次数来分割数据。
- en: A K-means algorithm can absolutely include more than just two attributes; however,
    you can only visualize two variables at a time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: K-means 算法绝对可以包括不止两个属性；然而，你一次只能可视化两个变量。
- en: In the following chapter, we’ll further explore player salaries by measuring
    the amount of inequality there is at the team level and associating those results
    with wins and losses.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步通过衡量团队层面的不平等程度来探索球员工资，并将这些结果与胜利和失败相关联。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Regardless of your use case and what kind of data you’re working with—customers,
    criminal offenses, documents, whatever—you, too, can create a K-means algorithm
    by following these exact steps.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你的用例是什么，无论你处理的是什么类型的数据——客户、犯罪行为、文件，无论什么——你都可以通过遵循这些确切步骤来创建一个 K-means 算法。
- en: We demonstrated how to first generate an optimal count of clusters, based on
    differentiation in the data, by introducing a pair of methods called within- cluster
    sum of squares and average silhouette. The former is the most popular of the two
    methods, but the latter doesn’t leave any room for interpretation. Both are equally
    acceptable.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过引入一对称为簇内平方和与平均轮廓的方法，展示了如何首先根据数据中的差异生成最佳簇数量。前者是这两种方法中最受欢迎的，但后者没有留下任何解释的空间。两者都是可以接受的。
- en: The upside to K-means is that it’s fast, easy, and can scale to large data sets;
    the downside is that it works best when the variables in play are normally distributed
    around their respective means—and that’s not the case with the pair of variables
    we worked with here.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K-means 的优点是它速度快、容易使用，并且可以扩展到大型数据集；缺点是它最好在变量围绕其各自均值呈正态分布时工作——而我们处理的这对变量并不符合这种情况。
- en: Our breakdown of standard deviations and z-scores was meant to prepare you for
    the subsequent analysis to come. Once more, standard deviation is a quantitative
    measure of variability, or dispersion, in a numeric vector; a z-score is a measure
    that equals the number of standard deviations that any data point within a numeric
    vector is above or below the mean of its distribution.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对标准差和 z 分数的分析旨在为你准备随后的分析。再次强调，标准差是数值向量的变异性的定量度量，或称为分散度；z 分数是一个度量，等于任何数值向量中的数据点相对于其分布均值的上方或下方标准差的数目。
- en: We’ve previously stated that R is a best-in-class programming language for data
    visualization (among other things). One of the reasons for that is the breadth
    of plots that can be created, especially with the `ggplot2` graphics package.
    We’ve demonstrated in prior chapters how to develop plots outside the mainstream,
    such as Sankey diagrams and lollipop charts. Here, we showed how to create a Cleveland
    dot plot that not only has a slick look and feel but also lots of easy-to-interpret
    information.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前已经指出，R 是数据可视化（以及其他方面）中的最佳编程语言。其中一个原因是它可以创建的图表范围广泛，尤其是在 `ggplot2` 图形包的帮助下。我们在前面的章节中展示了如何开发主流之外的图表，例如桑基图和棒棒糖图。在这里，我们展示了如何创建克利夫兰点图，它不仅外观和感觉都很流畅，而且包含大量易于理解的信息。
- en: As for our results, payrolls and wins are aligned fairly well to very well across
    almost half the teams in the league.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至于我们的结果，工资和胜利在联赛中几乎一半的球队中相当好地或非常好地一致。
- en: We discovered further evidence to support our conclusions from chapter 10 that
    payrolls have a significant influence on regular season wins.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现了进一步的支持我们第 10 章结论的证据，即工资对常规赛胜利有显著影响。
- en: The clusters produced from our K-means algorithm are interesting and surprising.
    The “best” teams with the smartest front offices—the Lakers, Mavericks, Spurs,
    Rockets, Celtics, Heat, and Jazz—are scattered across three of our four clusters.
    You can also consider the Spurs and Nets in the same cluster or Utah mixed with
    the Hornets.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们 K-means 算法产生的簇既有趣又令人惊讶。“最佳”球队，拥有最聪明的球团——湖人队、小牛队、马刺队、火箭队、凯尔特人队、热火队和爵士队——散布在我们四个簇中的三个中。你也可以考虑将马刺队和篮网队放在同一个簇中，或者犹他队与黄蜂队混合。
- en: However, the New York Knicks are in their own cluster (at least when *K* equals
    4), which makes perfect sense.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，纽约尼克斯队处于他们自己的集群（至少当 *K* 等于 4 时是这样），这完全说得通。
