- en: Part 1\. Core concepts on the console
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：控制台上的核心概念
- en: '*Get Programming with JavaScript* starts by introducing the key concepts you
    use in every program. The ideas presented form the foundation for all the subsequent
    code you write. The discussion starts gently and takes its time, with plenty of
    examples. There is an overarching theme of organization, which runs throughout
    the book; you see how to store and retrieve values with variables, group values
    with objects and arrays, and group instructions with functions.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*用 JavaScript 开始编程* 从介绍你在每个程序中使用的核心概念开始。所提出的思想构成了你随后编写所有代码的基础。讨论从轻松开始，并逐步深入，提供了大量的示例。贯穿全书的主旨是组织，你将了解如何使用变量存储和检索值，如何使用对象和数组分组值，以及如何使用函数分组指令。'
- en: By the end of [part 1](#part01), you’ll have built a working version of an adventure
    game called *The Crypt*. Players will be able to explore a map of locations and
    move from room to room and tomb to tomb, collecting treasure. [Chapter 1](kindle_split_009.html#ch01)
    sets the scene, introducing programming, JavaScript, and JS Bin, the online code
    environment in which your adventures take place. Let the games begin!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到 [第一部分](#part01) 结束时，你将构建一个名为 *The Crypt* 的冒险游戏的可用版本。玩家将能够探索地点图，从房间移动到房间，从墓穴移动到墓穴，收集宝藏。[第一章](kindle_split_009.html#ch01)
    设置了场景，介绍了编程、JavaScript 和 JS Bin，这是你的冒险发生的在线代码环境。游戏开始吧！
- en: Chapter 1\. Programming, JavaScript, and JS Bin
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：编程、JavaScript 和 JS Bin
- en: '***This chapter covers***'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程
- en: JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: JS Bin
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS Bin
- en: 'Our ongoing example: *The Crypt*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们持续的示例：*The Crypt*
- en: '*Get Programming with JavaScript* is a practical introduction to programming.
    Through hands-on code samples coupled with carefully paced explanations, supporting
    video tutorials, and a variety of examples, this book will help you build knowledge
    and skills and get you on your way to coding expertise.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*用 JavaScript 开始编程* 是对编程的实用介绍。通过动手代码示例、精心安排的解释、支持的视频教程和各种各样的示例，这本书将帮助你建立知识和技能，并让你踏上成为编码专家的道路。'
- en: This chapter sets the scene with a brief overview of programming and programming
    with JavaScript and then an introduction to JS Bin, the online programming sandbox
    you’ll be making full use of while you learn. Finally, you’ll meet *The Crypt*,
    our ongoing context for the concepts covered in the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先简要概述了编程以及使用 JavaScript 进行编程，然后介绍了 JS Bin，这是你在学习过程中将充分利用的在线编程沙盒。最后，你将遇到 *The
    Crypt*，这是我们书中涵盖概念的不断发展的背景。
- en: 1.1\. Programming
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 编程
- en: Programming is about giving the computer a series of instructions in a format
    it understands. Programs are everywhere, running Mars rovers, the Large Hadron
    Collider, engine management systems, financial markets, drones, phones, tablets,
    TVs, and medical equipment. The power and versatility of programs are astonishing.
    Programs can be a few lines long or millions of lines long, with complex solutions
    built from simple building blocks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是向计算机提供一系列它理解的指令格式。程序无处不在，运行火星探测器、大型强子对撞机、引擎管理系统、金融市场、无人机、手机、平板电脑、电视和医疗设备。程序的力量和多功能性令人惊叹。程序可以只有几行长，也可以有几百万行长，由简单的构建块构建出复杂的解决方案。
- en: 'Deep down in a computer’s electronics is a land of binary, counters, registers,
    busses, and memory allocation. There are low-level programming languages that
    let us work in that land, known as machine code and assembly language. Luckily
    for us, high-level languages have been created that are much easier to read, follow,
    and use. We can write code that’s almost understandable by anyone; here’s some
    pretend code (pseudocode) that’s close to what high-level languages allow:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的电子深处是一个由二进制、计数器、寄存器、总线以及内存分配组成的世界。存在低级编程语言，让我们能够在那个世界中工作，被称为机器代码和汇编语言。幸运的是，我们已经创造了高级语言，它们更容易阅读、理解和使用。我们可以编写几乎任何人都能理解的代码；以下是一些接近高级语言允许的伪代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Different languages set out how you might write such code; some use more symbols
    than others, some more natural words. Here’s how it might look in JavaScript:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言规定了编写此类代码的方式；一些使用比其他更多的符号，一些使用更自然的单词。以下是它在 JavaScript 中的可能样子：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parentheses and curly braces and semicolons are all part of the language’s
    *syntax*, its rules for setting out the code so it can be understood by the computer.
    The code you write will be automatically translated into low-level code for the
    computer to execute.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 括号、花括号和分号都是语言*语法*的一部分，是设置代码的规则，以便计算机可以理解。你编写的代码将被自动翻译成计算机执行的底层代码。
- en: In the previous JavaScript snippet is the instruction `loadNewLevel();`, to
    load a new level in the game, presumably. Somewhere else in the program will be
    more code with instructions outlining, step-by-step, how to load a new level.
    Part of the art of programming is breaking larger programs into smaller pieces
    that perform specific jobs. The smaller pieces are then combined to fulfill the
    purpose of the main program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的JavaScript代码片段中是`loadNewLevel();`指令，用于加载游戏的新关卡，可能是在程序的某个地方。程序的其他部分将包含更多代码，详细说明了如何逐步加载新关卡。编程的艺术之一是将较大的程序分解成执行特定任务的较小部分。然后将这些小部分组合起来，以实现主程序的目的。
- en: There are many, many programming languages. Some you may have heard of are Java,
    C, PHP, Python, and Swift. Let’s take a look at why you might choose JavaScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多许多编程语言。你可能听说过的有Java、C、PHP、Python和Swift。让我们看看为什么你可能会选择JavaScript。
- en: 1.2\. JavaScript
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. JavaScript
- en: JavaScript is an incredibly popular programming language, mostly seen in web
    browsers but gaining popularity in other contexts. On web pages it adds interactivity,
    from simple animation effects to form validation to full-blown single-page applications.
    Servers—programs that make files, web pages, and other resources available on
    the internet—are now written using JavaScript with Node.js. Other programs can
    be scripted with JavaScript, like Photoshop and Minecraft, and some databases
    store JavaScript and let you query data with JavaScript. And as more and more
    network-enabled objects are added to the Internet of Things, JavaScript is becoming
    more popular for programming sensors, robots, drones, and Arduino-style electronics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种极其流行的编程语言，主要在网页浏览器中使用，但在其他环境中也越来越受欢迎。在网页上，它增加了交互性，从简单的动画效果到表单验证，再到完整的单页应用程序。现在，使用Node.js编写的服务器——使文件、网页和其他资源在互联网上可用的程序——现在正使用JavaScript编写。其他程序也可以用JavaScript编写，如Photoshop和Minecraft，一些数据库存储JavaScript，并允许你用JavaScript查询数据。随着越来越多的网络化对象被添加到物联网中，JavaScript在编程传感器、机器人、无人机和Arduino风格的电子设备方面变得越来越受欢迎。
- en: Learning to program gives you a great skill that’s versatile, useful, stimulating,
    creative, fun, rewarding, and in demand. Learning to program with JavaScript puts
    one of the world’s most widely used languages at your fingertips, letting you
    develop applications for all manner of uses, devices, platforms, and OSes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编程赋予你一项伟大的技能，它灵活、有用、刺激、富有创造力、有趣、有回报，并且需求量大。用JavaScript学习编程让你能够接触到世界上使用最广泛的语言之一，让你能够开发各种用途、设备、平台和操作系统上的应用程序。
- en: 1.3\. Learning by doing and thinking
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 通过做和思考学习
- en: Learning follows thinking. The philosophy of *Get Programming with JavaScript*
    is that by experimenting with programs in an online sandbox, finding out firsthand
    what works and what doesn’t, and by attempting challenges, you’ll have to think
    carefully about the concepts in each chapter. That thinking will lead to understanding
    and learning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 学习跟随思考。*《用JavaScript编程入门》*的哲学是，通过在线沙盒中实验程序，亲自找出哪些可行哪些不可行，并通过尝试挑战，你将不得不仔细思考每一章的概念。这种思考将导致理解和学习。
- en: The sandbox lets you run programs and get instant feedback. Sometimes the feedback
    will be unexpected and force you to question what you thought you knew. Some ideas
    may click into place quickly whereas others could take longer; careful consideration
    and further experimentation may be needed. Curiosity, commitment, and resilience
    are key attitudes when learning anything, and they’ll certainly help you to be
    a better programmer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒让你可以运行程序并获得即时反馈。有时反馈会出乎意料，迫使你质疑你所认为的已知信息。一些想法可能很快就会变得清晰，而其他想法可能需要更长的时间；仔细考虑和进一步的实验可能是必要的。好奇心、承诺和韧性是学习任何事物时的关键态度，它们当然会帮助你成为一个更好的程序员。
- en: That’s not to say learning to program will be a chore! Far from it. Even after
    more than 30 years of programming, I still find the transformation of code into
    a useful and/or fun application to be almost magical. That lines of simple statements,
    when combined, can accomplish such a variety of outcomes is astonishing. And seeing
    others use something you’ve created to be more productive or more organized or
    just to have more fun is a privilege and a pleasure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着学习编程会是一件苦差事！恰恰相反。即使在我编程超过30年后，我仍然发现将代码转化为有用且/或有趣的应用几乎是一种魔法。简单语句的行当组合在一起，能够实现如此多样的结果，这令人惊讶。看到别人使用你创造的东西变得更加高效、更有条理，或者只是更有乐趣，这是一种特权，也是一种快乐。
- en: So be prepared for an adventure of discovery, and don’t be disheartened if you
    find some concepts tricky at first. Take your time, do the exercises, and don’t
    forget the resources on the *Get Programming with JavaScript* website; it has
    links to listings, solutions, videos, and further reading at [www.room51.co.uk/books/getProgramming/index.html](http://www.room51.co.uk/books/getProgramming/index.html).
    Learning to program is worth the effort.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请做好探索发现的准备，如果你一开始发现某些概念难以理解，不要气馁。花时间做练习，不要忘记 *《用 JavaScript 编程入门》* 网站上的资源；它提供了链接到列表、解决方案、视频和进一步阅读的内容，网址为
    [www.room51.co.uk/books/getProgramming/index.html](http://www.room51.co.uk/books/getProgramming/index.html)。学习编程是值得努力的。
- en: 1.4\. JS Bin
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. JS Bin
- en: JavaScript is most commonly run by a web browser. The browser loads a web page
    from a server, and that page may include JavaScript code or a link to code the
    browser then fetches. The browser steps through the code, executing the instructions.
    For [part 1](kindle_split_008.html#part01) of *Get Programming with JavaScript*,
    you avoid the extra considerations of writing and loading web pages and linking
    to code files. You keep your focus on the JavaScript language itself. To do that,
    you make use of JS Bin, a free online service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 最常见的是由网页浏览器运行。浏览器从服务器加载网页，该网页可能包含 JavaScript 代码或指向代码的链接，然后浏览器获取该代码。浏览器逐行执行代码，执行指令。在
    *《用 JavaScript 编程入门》* 的第 [1 部分](kindle_split_008.html#part01) 中，你避免了编写和加载网页以及链接到代码文件的额外考虑。你将注意力集中在
    JavaScript 语言本身上。要做到这一点，你可以使用 JS Bin，这是一个免费的在线服务。
- en: JS Bin is an online sandbox for developing and sharing web pages and JavaScript
    programs. All of the code listings in this book are available on JS Bin ([www.jsbin.com](http://www.jsbin.com))
    to give you hands-on practice with the code and to let you experiment and learn.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 是一个在线沙盒，用于开发和共享网页和 JavaScript 程序。本书中的所有代码列表都可在 JS Bin 上找到 ([www.jsbin.com](http://www.jsbin.com))，以便你亲自动手实践代码，并让你进行实验和学习。
- en: When you first visit the site, you’ll see a header section with a picture of
    Dave the BinBot and some helpful links to get you started, as shown in [figure
    1.1](#ch01fig01). Feel free to explore, but don’t be put off by any complicated
    information you might find. Once you’ve finished exploring, close the header by
    clicking the X to the left of Dave. (You can close any welcome messages or other
    messages that JS Bin sometimes shows as well.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次访问该网站时，你会看到一个包含 Dave the BinBot 图片和一些帮助你入门的有用链接的标题部分，如图 [图 1.1](#ch01fig01)
    所示。请随意探索，但不要因为可能遇到的任何复杂信息而气馁。探索完毕后，通过点击 Dave 左侧的 X 关闭标题。（你还可以关闭 JS Bin 有时显示的任何欢迎信息或其他信息。）
- en: Figure 1.1\. JS Bin showing the HTML, CSS, Output, and Info panels
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1. JS Bin 显示 HTML、CSS、输出和信息面板
- en: '![](01fig01_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片 01fig01_alt.jpg](01fig01_alt.jpg)'
- en: 1.4.1\. JS Bin panels
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1. JS Bin 面板
- en: 'JS Bin is a tool for developing web pages and applications. In addition to
    the Info panel at the top, it has five panels available for display: HTML, CSS,
    JavaScript, Console, and Output. Clicking a panel’s name on the JS Bin toolbar
    toggles the panel on or off. In [part 1](kindle_split_008.html#part01) you work
    with just the JavaScript and Console panels, [part 2](kindle_split_019.html#part02)
    will use the HTML panel, and [part 3](kindle_split_026.html#part03) will add the
    CSS and Output panels. You’ll be using only the JavaScript and Console panels
    to begin with, so toggle those two panels on and the others off; see [figure 1.2](#ch01fig02).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 是一个用于开发网页和应用程序的工具。除了顶部的信息面板外，它还有五个可显示的面板：HTML、CSS、JavaScript、控制台和输出。点击
    JS Bin 工具栏上的面板名称可以切换面板的开启或关闭。在第 [1 部分](kindle_split_008.html#part01) 中，你将只使用 JavaScript
    和控制台面板，第 [2 部分](kindle_split_019.html#part02) 将使用 HTML 面板，第 [3 部分](kindle_split_026.html#part03)
    将添加 CSS 和输出面板。你一开始将只使用 JavaScript 和控制台面板，所以请切换这两个面板开启，其他面板关闭；参见 [图 1.2](#ch01fig02)。
- en: Figure 1.2\. JS Bin showing the JavaScript and Console panels.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.2. JS Bin 显示 JavaScript 和控制台面板。
- en: '![](01fig02_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig02_alt.jpg)'
- en: HTML
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTML
- en: HTML is used to structure the content of web pages. Text, images, video, and
    forms are examples of content.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HTML用于结构化网页的内容。文本、图像、视频和表单是内容的例子。
- en: CSS
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CSS
- en: Cascading Style Sheets let you specify how your content should be presented.
    You can define background color, font details, margins, sizes, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 层叠样式表（Cascading Style Sheets）允许您指定内容应该如何呈现。您可以定义背景颜色、字体细节、边距、大小等。
- en: JavaScript
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript
- en: JavaScript lets you add behavior and interactivity to your web pages. Or you
    can use it to write programs not in the context of a web page.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许您向网页添加行为和交互性。或者，您也可以在网页上下文中之外编写程序。
- en: Console
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制台
- en: The console can be used by a program to display information for users and developers.
    Warnings and errors about a program may be shown here. The console is interactive;
    you can type into it to find out about the state of a program. It’s not normally
    used in finished applications, but you’ll make good use of it as a quick and simple
    way of interacting with your programs as you learn.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台可以被程序用来向用户和开发者显示信息。程序中的警告和错误可能会在这里显示。控制台是交互式的；您可以在其中输入以了解程序的状态。它通常不在完成的应用程序中使用，但在学习过程中，您会很好地利用它作为一种快速简单的方式与您的程序交互。
- en: Output
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: The Output panel shows a preview of the web page defined in the HTML, CSS, and
    JavaScript panels. It shows what a visitor to a page would normally see in a browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出面板显示了在HTML、CSS和JavaScript面板中定义的网页预览。它显示了访问者通常在浏览器中看到的页面内容。
- en: 1.4.2\. Following the code listings on JS Bin
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 跟随JS Bin上的代码列表
- en: 'You’ll write programs by adding lines of code to the JavaScript panel on JS
    Bin. The programs will start simply and slowly increase in complexity as you cover
    more features of the language. For most of the code listings in [part 1](kindle_split_008.html#part01)
    of the book, you can test the code on JS Bin by following these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过在JS Bin的JavaScript面板中添加代码行来编写程序。随着您覆盖更多语言的功能，程序将从简单开始，逐渐增加复杂性。对于书中[第1部分](kindle_split_008.html#part01)中的大多数代码列表，您可以通过以下步骤在JS
    Bin上测试代码：
- en: '**1**.  Select New on the File menu on JS Bin.'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  在JS Bin的文件菜单上选择新建。'
- en: '**2**.  Toggle the panels so that the JavaScript and Console panels are visible.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  切换面板，使JavaScript和Console面板可见。'
- en: '**3**.  Enter code in the JavaScript panel.'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  在JavaScript面板中输入代码。'
- en: '**4**.  Click Run.'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  点击运行。'
- en: '**5**.  Check the result on the Console panel.'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  在控制台面板上检查结果。'
- en: '[Figure 1.3](#ch01fig03) shows the steps on a screenshot from JS Bin.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.3](#ch01fig03)显示了JS Bin截图中的步骤。'
- en: Figure 1.3\. The steps for running JavaScript on JS Bin
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 在JS Bin上运行JavaScript的步骤
- en: '![](01fig03_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig03_alt.jpg)'
- en: Most of the listings in the book also have a link to the same code on JS Bin.
    The listings on JS Bin include extra information and exercises related to the
    code, discussed further in [sections 1.4.4](#ch01lev2sec4) and [1.4.5](#ch01lev2sec5).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的大多数列表也都有一个链接，指向JS Bin上的相同代码。JS Bin上的列表包括与代码相关的额外信息和练习，这些将在[1.4.4](#ch01lev2sec4)和[1.4.5](#ch01lev2sec5)节中进一步讨论。
- en: 1.4.3\. Logging to the console
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3\. 将日志记录到控制台
- en: 'At various points you want programs to output information by displaying it
    on the Console panel. To display information on the console, use the `console.log`
    command. Running the program in this listing displays the following on the console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的点上，您希望程序通过在控制台面板上显示信息来输出信息。要在控制台上显示信息，请使用`console.log`命令。运行此列表中的程序将在控制台上显示以下内容：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 1.1\. Using `console.log` to display information ([http://jsbin.com/mujepu/edit?js,console](http://jsbin.com/mujepu/edit?js,console))
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1\. 使用`console.log`显示信息 ([http://jsbin.com/mujepu/edit?js,console](http://jsbin.com/mujepu/edit?js,console))
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You place the message to be displayed between quotation marks, within the parentheses.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要在显示的消息之间放置引号内的括号。
- en: Notice that the listing title contains a JS Bin link. Click the link to see
    the live code on JS Bin. To execute the code in the JavaScript panel, click the
    Run button at the top of the Console panel. You’ll see your message, “Hello World!”,
    appear on the console.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意列表标题中包含一个JS Bin链接。点击链接查看JS Bin上的实时代码。要执行JavaScript面板中的代码，请点击控制台面板顶部的运行按钮。您将在控制台上看到消息“Hello
    World!”。
- en: Try clicking Run a few more times. Every time it’s clicked, your code is executed
    and “Hello World!” is logged to the console. You can click Clear to clear all
    the messages from the console.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击运行几次。每次点击都会执行代码，并将“Hello World!”记录到控制台。您可以通过点击清除来清除控制台中的所有消息。
- en: When following links to code on JS Bin, the program may run automatically. You
    can switch off auto-run in your preferences on JS Bin if you sign up for an account.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 JS Bin 上跟踪代码链接时，程序可能会自动运行。如果您注册了账户，您可以在 JS Bin 的偏好设置中关闭自动运行。
- en: 1.4.4\. Code comments
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.4\. 代码注释
- en: 'Along with the code statements, the JS Bin listings for this book include *comments*,
    text that’s not part of the program but is useful for explaining what the code
    does. Here’s the first block comment from [listing 1.1](#ch01ex01) on JS Bin:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代码语句外，此书的 JS Bin 列表还包括*注释*，这些注释不是程序的一部分，但对解释代码的功能很有用。以下是 JS Bin 上[列表 1.1](#ch01ex01)的第一个代码块注释：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As well as block comments, which can span multiple lines, you’ll sometimes
    see single-line comments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以跨越多行的代码块注释外，您有时还会看到单行注释：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On JS Bin, the comments are usually shown in green. Programmers add comments
    to their code if they feel it needs some explanation to be understood by other
    programmers. When a program is executed, the computer ignores the comments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS Bin 上，注释通常以绿色显示。程序员如果觉得代码需要一些解释以便其他程序员理解，就会在代码中添加注释。当程序执行时，计算机将忽略注释。
- en: 1.4.5\. Further Adventures
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.5\. 进一步冒险
- en: Most code listings for *Get Programming with JavaScript* on JS Bin come with
    a small set of exercises, called *Further Adventures*, included as comments after
    the code. Some are easy, some are repetitive, and some are challenging. The best
    way to learn programming is to program, so I urge you to jump in and try the challenges.
    You can get help on the Manning Forums, and solutions to many of the tasks are
    given on the book’s websites at [www.manning.com/books/get-programming-with-javascript](http://www.manning.com/books/get-programming-with-javascript)
    and [www.room51.co.uk/books/getProgramming/index.html](http://www.room51.co.uk/books/getProgramming/index.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS Bin 上，*用 JavaScript 编程入门*的大多数代码列表都附带一组小练习，称为*进一步冒险*，作为代码后的注释。有些很简单，有些是重复的，有些是具有挑战性的。学习编程的最佳方式是编程，所以我敦促您跳进来尝试挑战。您可以在
    Manning 论坛上获得帮助，许多任务的解决方案在书籍的网站上提供，网址为 [www.manning.com/books/get-programming-with-javascript](http://www.manning.com/books/get-programming-with-javascript)
    和 [www.room51.co.uk/books/getProgramming/index.html](http://www.room51.co.uk/books/getProgramming/index.html)。
- en: 1.4.6\. Error messages
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.6\. 错误信息
- en: As you add code to the JavaScript panel, JS Bin is continuously checking for
    errors. You’ll see a red error section appear at the bottom of the JavaScript
    panel. Don’t worry about it until you’ve finished adding a line of code. If the
    error section is still there, click it to see the error messages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向 JavaScript 面板添加代码时，JS Bin 会持续检查错误。您会在 JavaScript 面板的底部看到红色错误区域。不要担心，直到您完成添加一行代码。如果错误区域仍然存在，点击它以查看错误信息。
- en: For example, try deleting the semicolon from the end of the line of code in
    [listing 1.1](#ch01ex01). [Figure 1.4](#ch01fig04) shows the error that JS Bin
    displays in response to the deleted semicolon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试从[列表 1.1](#ch01ex01)的代码行末尾删除分号。[图 1.4](#ch01fig04)显示了 JS Bin 对删除的分号所显示的错误。
- en: Figure 1.4\. The JS Bin error section (closed and then open)
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. JS Bin 错误区域（先关闭后打开）
- en: '![](01fig04_alt.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig04_alt.jpg)'
- en: The semicolon signals the end of a line of code. Each line of code, ending with
    a semicolon, is called a *statement*. If you stop typing but the line does not
    end with a semicolon, JS Bin will complain. The program may still run, and JavaScript
    will try to insert semicolons where it thinks they should go, but it’s much better
    practice to put the semicolons in yourself; the errors in JS Bin are encouraging
    good practice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分号表示代码行的结束。每行以分号结束的代码称为*语句*。如果您停止输入但行末没有分号，JS Bin 将会抱怨。程序可能仍然会运行，JavaScript
    会尝试在它认为应该放置分号的地方插入分号，但最好还是自己放置分号；JS Bin 中的错误信息鼓励良好的实践。
- en: JS Bin does its best to give error messages that help you fix any problems.
    Delete more characters, one by one, from the end of your line of code and watch
    as the error messages update.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin 尽力提供有助于您解决问题的错误信息。逐个从代码行的末尾删除更多字符，并观察错误信息如何更新。
- en: 1.4.7\. Line numbers
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.7\. 行号
- en: The error message in [figure 1.4](#ch01fig04) told you the line number where
    the error occurred. You had only one line of code, so the error was on line 1\.
    Programs can get quite long, so it’s helpful to have line numbers you can see.
    You don’t add line numbers by hand; your text editor, in this case JS Bin, does
    that automatically. They’re not part of the program; they help you while writing
    and testing the code. [Figure 1.5](#ch01fig05) shows a longer program with a couple
    of errors. Don’t worry about understanding the code for now, but see if you can
    spot the errors reported by JS Bin in the figure. Without the line numbers it
    would be much harder, especially if the program were longer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.4](#ch01fig04) 中的错误信息告诉了你错误发生的行号。你只有一行代码，所以错误在第一行。程序可以相当长，所以看到行号是有帮助的。你不需要手动添加行号；在这个例子中，JS
    Bin 文本编辑器会自动为你添加。它们不是程序的一部分；它们在编写和测试代码时帮助你。[图 1.5](#ch01fig05) 显示了一个较长的程序，其中包含几个错误。现在不必担心理解代码，但看看你是否能找到
    JS Bin 在图中报告的错误。如果没有行号，这将困难得多，尤其是如果程序更长的话。'
- en: Figure 1.5\. Line numbers are helpful when finding errors.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. 行号在查找错误时很有帮助。
- en: '![](01fig05_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.5](01fig05_alt.jpg)'
- en: To toggle the display of line numbers on JS Bin, double-click the word *JavaScript*
    at the top left of the JavaScript panel (see [figure 1.5](#ch01fig05)). A menu
    will open and close as you double-click, but the line numbers should switch from
    hidden to visible (or vice versa) as well. You can also switch on line numbers
    in your JS Bin profile, if you’ve registered.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 JS Bin 中切换行号的显示，请双击 JavaScript 面板左上角的“JavaScript”一词（见图 1.5。[图 1.5](#ch01fig05)）。当你双击时，菜单会打开和关闭，但行号应该从隐藏切换到可见（或反之亦然）。如果你已经注册，你还可以在
    JS Bin 个人资料中开启行号。
- en: 1.4.8\. Get an account
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.8\. 获取账户
- en: It’s worth signing up for a free account on JS Bin. Your work will be saved
    and you’ll be able to set a lot more preferences. As you start to write your own
    programs, it’s a great place to try out your ideas and get immediate previews
    and feedback.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS Bin 上注册一个免费账户是值得的。你的工作将被保存，你将能够设置更多的偏好设置。当你开始编写自己的程序时，这是一个尝试你的想法并获得即时预览和反馈的好地方。
- en: 1.5\. The Crypt—our running example
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 密室——我们的运行示例
- en: Throughout the book, you’re developing a text-based adventure game called *The
    Crypt*. Players will be able to explore locations on a map, moving from place
    to place, picking up items to help them solve challenges and get past obstacles.
    The last section of each chapter will use what you covered in the chapter to develop
    the game further. You’re able to see how the programming concepts help you build
    the pieces that are then combined to produce a large program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你正在开发一个名为 *The Crypt* 的基于文本的冒险游戏。玩家将能够在一个地图上探索位置，从一个地方移动到另一个地方，捡起帮助解决挑战和克服障碍的物品。每一章的最后部分将使用你在该章中学到的内容来进一步开发游戏。你将能够看到编程概念是如何帮助你构建最终组合成大型程序的各个部分的。
- en: 1.5.1\. Playing The Crypt
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1\. 玩 The Crypt
- en: The game will display a description of a player’s current location along with
    any items that are found there and any exits, as shown in [figure 1.6](#ch01fig06).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将显示玩家当前位置描述，以及在那里找到的任何物品和出口，如图 1.6 所示。[图 1.6](#ch01fig06)。
- en: Figure 1.6\. Playing *The Crypt*
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. 玩 *The Crypt*
- en: '![](01fig06_alt.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1.6](01fig06_alt.jpg)'
- en: Players can type in commands to move from place to place, pick up items they
    discover, and use the items to overcome challenges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以输入命令来从一个地方移动到另一个地方，捡起他们发现的物品，并使用这些物品来克服挑战。
- en: You need to write code for all of the different elements within the game. But
    don’t worry—you take it step by step, and I’ll introduce what you need to know
    as you progress. You can play the game on JS Bin at [http://output.jsbin.com/yapiyic](http://output.jsbin.com/yapiyic).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为游戏中的所有不同元素编写代码。但别担心——你一步一步来，随着你的进步，我会介绍你需要知道的内容。你可以在 JS Bin 上玩这个游戏，[http://output.jsbin.com/yapiyic](http://output.jsbin.com/yapiyic)。
- en: 1.5.2\. Steps for building The Crypt
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2\. 构建 The Crypt 的步骤
- en: In [part 1](kindle_split_008.html#part01), while learning some of the core concepts
    in JavaScript, you write code to represent the players and the places in the game
    and to let players move from place to place and pick up items they find. [Figure
    1.7](#ch01fig07) shows the components that you’ll create for Players, Places,
    Maps, and the Game as a whole. Don’t worry about all of the terms in the figure—you’ll
    cover them in detail as you progress through the book. A similar figure will be
    used in each chapter to highlight the ideas being discussed in the context of
    the whole game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第一部分](kindle_split_008.html#part01) 中，当你学习 JavaScript 的核心概念时，你编写代码来表示游戏中的玩家和地点，并让玩家从一个地方移动到另一个地方，捡起他们找到的物品。[图
    1.7](#ch01fig07) 展示了你将创建的用于玩家、地点、地图和整个游戏的组件。不要担心图中所有的术语——随着你阅读本书的进展，你将详细地了解它们。每个章节都将使用类似的图表来突出整个游戏背景下的讨论内容。
- en: Figure 1.7\. Game elements in *The Crypt* for [part 1](kindle_split_008.html#part01)
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.7\. 《密室》第一部分 [part 1](kindle_split_008.html#part01) 中的游戏元素
- en: '![](01fig07_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig07_alt.jpg)'
- en: Both [parts 1](kindle_split_008.html#part01) and [2](kindle_split_019.html#part02)
    will use the console on JS Bin to display game information and to accept input
    from users. [Table 1.1](#ch01table01) shows how the game elements correspond to
    the JavaScript being covered in [part 1](kindle_split_008.html#part01).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 [部分 1](kindle_split_008.html#part01) 和 [2](kindle_split_019.html#part02)
    都将使用 JS Bin 上的控制台来显示游戏信息和接受用户的输入。[表 1.1](#ch01table01) 展示了游戏元素如何对应于 [第一部分](kindle_split_008.html#part01)
    中涵盖的 JavaScript。
- en: Table 1.1\. Game elements and JavaScript in [part 1](kindle_split_008.html#part01)
    of *The Crypt*
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1\. 《密室》第一部分 [part 1](kindle_split_008.html#part01) 中的游戏元素和 JavaScript
- en: '| Game element | Task | JavaScript | Chapter |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 游戏元素 | 任务 | JavaScript | 章节 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Players | Deciding on the information we need to know about each player |
    Variables | [Chapter 2](kindle_split_010.html#ch02) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 玩家 | 决定我们需要了解的每个玩家的信息 | 变量 | [第二章](kindle_split_010.html#ch02) |'
- en: '|   | Collecting player information in one place | Objects | [Chapter 3](kindle_split_011.html#ch03)
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   | 在一个地方收集玩家信息 | 对象 | [第三章](kindle_split_011.html#ch03) |'
- en: '|   | Displaying information about players on the console | Functions | [Chapters
    4](kindle_split_012.html#ch04)–[7](kindle_split_015.html#ch07) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   | 在控制台上显示有关玩家的信息 | 函数 | [第 4 章](kindle_split_012.html#ch04)–[第 7 章](kindle_split_015.html#ch07)
    |'
- en: '|   | Creating a list of items collected by each player | Arrays | [Chapter
    8](kindle_split_016.html#ch08) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|   | 创建每个玩家收集到的物品列表 | 数组 | [第八章](kindle_split_016.html#ch08) |'
- en: '|   | Organizing player creation code | Constructors | [Chapter 9](kindle_split_017.html#ch09)
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|   | 组织玩家创建代码 | 构造函数 | [第九章](kindle_split_017.html#ch09) |'
- en: '| Places | Creating lots of places to explore, all with a similar structure
    | Constructors | [Chapter 9](kindle_split_017.html#ch09) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 创建许多可供探索的地方，它们具有相似的结构 | 构造函数 | [第九章](kindle_split_017.html#ch09) |'
- en: '|   | Joining places with exits | Square bracket notation | [Chapter 10](kindle_split_018.html#ch10)
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|   | 使用方括号表示法将地方连接起来 | 方括号表示法 | [第十章](kindle_split_018.html#ch10) |'
- en: '| Game | Adding simple functions for movement, collecting items, and displaying
    information | Square bracket notation | [Chapter 10](kindle_split_018.html#ch10)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 游戏 | 添加简单的移动、收集物品和显示信息的函数 | 方括号表示法 | [第十章](kindle_split_018.html#ch10) |'
- en: '| Maps | Joining places with exits | Square bracket notation | [Chapter 10](kindle_split_018.html#ch10)
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 地图 | 将有出口的地方连接起来 | 方括号表示法 | [第十章](kindle_split_018.html#ch10) |'
- en: '[Part 2](kindle_split_019.html#part02) adds challenges for players, blocking
    exits until the players use appropriate items to solve the puzzles. The programming
    focus is more about organizing your code, hiding how it works, checking user input,
    and building modules that you can reuse and swap to make the project more flexible.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](kindle_split_019.html#part02) 为玩家增加了挑战，阻止他们离开，直到玩家使用适当的物品来解决谜题。编程的重点更多地在于组织你的代码，隐藏其工作原理，检查用户输入，以及构建可以重用和交换的模块，使项目更加灵活。'
- en: '[Figure 1.8](#ch01fig08) shows how the game is split into modules for map data,
    constructors that you use to create players and places, views for displaying information
    on the console, and a controller for running the game and linking all of the pieces.
    Again, the figures are presented here to give a sense of what to expect and how
    the full game is made up of smaller building blocks—you’re not expected to understand
    all of the terms at this point. You are allowed to be curious and excited! Each
    building block will be fully explained over the next 400 pages; take your time
    to explore the concepts and play with the code.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.8](#ch01fig08)展示了游戏如何分为地图数据模块、用于创建玩家和地点的构造函数、用于在控制台上显示信息的视图以及用于运行游戏和连接所有部件的控制器。再次强调，这里展示的图表是为了给你一个预期的感觉以及完整游戏由更小的构建块组成——在这个阶段，你不需要理解所有术语。你可以保持好奇和兴奋！每个构建块将在接下来的400页中完全解释；花时间探索概念并玩转代码。'
- en: Figure 1.8\. Game elements in *The Crypt* for [part 2](kindle_split_019.html#part02)
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.8\. *《密码学》*中[第二部分](kindle_split_019.html#part02)的游戏元素
- en: '![](01fig08_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig08_alt](01fig08_alt.jpg)'
- en: '[Part 3](kindle_split_026.html#part03) updates the display to use HTML templates,
    modifies the game to load data while it’s running, filling the templates with
    player and place information, and introduces text boxes and buttons so that players
    can enter commands via a web page ([figure 1.9](#ch01fig09)).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三部分](kindle_split_026.html#part03)更新了显示以使用HTML模板，修改了游戏在运行时加载数据，用玩家和地点信息填充模板，并引入了文本框和按钮，以便玩家可以通过网页输入命令（[图1.9](#ch01fig09)）。'
- en: Figure 1.9\. Game elements in *The Crypt* for [part 3](kindle_split_026.html#part03)
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9\. *《密码学》*中[第三部分](kindle_split_026.html#part03)的游戏元素
- en: '![](01fig09_alt.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig09_alt](01fig09_alt.jpg)'
- en: Part 4, available online, shows how game data can be stored on a server using
    Node.js.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分可在网上找到，展示了如何使用Node.js在服务器上存储游戏数据。
- en: 1.6\. Further examples and practice
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 更多示例和实践
- en: Although *The Crypt* is our ongoing context for learning JavaScript, each chapter
    includes other examples to show you concepts at work in a variety of situations.
    Some of the smaller examples will also be developed as you progress, letting you
    see how the new concepts help to improve the examples. In particular, you’ll look
    at a quiz app, a fitness-tracking app, a movie ratings web page, and a news headlines
    page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*《密码学》*是我们学习JavaScript的持续背景，但每一章都包含其他示例，以展示在多种情况下概念的应用。一些较小的示例也会随着你的进步而发展，让你看到新概念如何帮助改进示例。特别是，你将查看一个测验应用、一个健身追踪应用、一个电影评分网页和一个新闻头条页面。
- en: 1.7\. Browser support
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7\. 浏览器支持
- en: Browsers are evolving all of the time. Some of the JavaScript listings in *Get
    Programming with JavaScript* may not work in older browsers (Internet Explorer
    8 and earlier, for example). The discussions on the book’s website will provide
    alternative methods to get code working for browsers that aren’t happy with the
    main methods shown in the listings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器一直在进化。*《用JavaScript编程入门》*中的一些JavaScript代码示例可能在较旧的浏览器中（例如Internet Explorer
    8及以下版本）无法工作。书籍网站上的讨论将提供替代方法，以便在主要方法在代码示例中显示不满意的浏览器上运行代码。
- en: 1.8\. Summary
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.8\. 摘要
- en: Programs are sets of instructions for computers to follow.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序是一系列计算机需要遵循的指令。
- en: High-level languages let us write instructions that are easier to read and understand.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级语言让我们能够编写更容易阅读和理解的指令。
- en: JavaScript is one of the most widely used programming languages in the world.
    Associated most strongly with adding interactivity to web pages, it’s also used
    in server-side programming, as a scripting language for applications, and as a
    way of programming robots and other devices.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是世界上使用最广泛的编程语言之一。它最强烈地与为网页添加交互性相关联，但也用于服务器端编程、作为应用程序的脚本语言，以及编程机器人和其他设备的方式。
- en: Learning follows from thinking. So, get involved in the practical examples in
    the book and be curious, committed, and resilient.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习源于思考。因此，参与书中的实际示例，保持好奇、投入和坚韧。
- en: JS Bin, an online code sandbox, will help you to focus on the JavaScript and
    give quick feedback as you experiment and practice.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JS Bin，一个在线代码沙盒，将帮助你专注于JavaScript，并在你实验和实践时提供快速反馈。
- en: Our main running example is *The Crypt*. It gives you a context for learning
    programming concepts and for building a relatively complicated program from simple
    elements.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的主要运行示例是*《密码学》*。它为你提供了一个学习编程概念和从简单元素构建相对复杂程序的环境。
- en: Further examples will help you to gain depth through breadth and to appreciate
    how the concepts you learn are applied in a wider variety of situations.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步的例子将帮助你通过广度来加深理解，并欣赏你学到的概念是如何在更广泛的各种情况下应用的。
- en: 'Chapter 2\. Variables: storing data in your program'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章. 变量：在程序中存储数据
- en: '***This chapter covers***'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Storing and using information with variables
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量存储和使用信息
- en: Declaring variables
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量
- en: Assigning values to variables
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给变量赋值
- en: Displaying variable values on the console
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台上显示变量值
- en: '*Get Programming with JavaScript* has been written as a gentle introduction
    to programming. This chapter, then, is a gentle introduction to a gentle introduction.
    As far as adventures go, you hardly leave the house. You can think of it as the
    packing stage for your journey, vitally important—you don’t want to get to the
    airport without your passport or to the Oscars without your selfie stick—but not
    the main event.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 《用JavaScript编程入门》被编写成对编程的温和介绍。因此，本章是对温和介绍的温和介绍。就冒险而言，你几乎不出门。你可以把它看作是旅程的打包阶段，至关重要——你不想在没有护照的情况下到达机场，或者在没有自拍杆的情况下到达奥斯卡——但这不是主要事件。
- en: Almost without exception, programs store, manipulate, and display data. Whether
    you’re writing a system for blogging, analyzing engine performance, predicting
    the weather, or sending a probe to land on a comet in 10 years’ time, you need
    to consider the data you’ll use and what kinds of values that data might take.
    To work with data in your programs, you use variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有例外，程序都会存储、操作和显示数据。无论你是编写一个博客系统、分析引擎性能、预测天气，还是发送探测器在10年后登陆彗星，你都需要考虑你将使用的数据以及这些数据可能采取的值。为了在程序中处理数据，你使用变量。
- en: 2.1\. What is a variable?
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 什么是变量？
- en: A *variable* is a named value in your program. Whenever you use the name in
    the program, it’s replaced with the value. You could create a variable called
    `score` and give it the value `100`. Then, if you tell the computer to “display
    the score,” it will display `100`. Now, variables can change, hence the name,
    so later in the program, maybe in response to some action a player takes, you
    can update the score. If you add `50` to `score` and tell the computer to “display
    the score,” it will now display `150`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *变量* 是程序中的一个命名值。每次你在程序中使用这个名称时，它就会被相应的值所替换。你可以创建一个名为 `score` 的变量，并给它赋值为 `100`。然后，如果你告诉计算机“显示分数”，它就会显示
    `100`。现在，变量可以改变，因此得名，所以程序中稍后，比如响应玩家采取的一些动作，你可以更新分数。如果你将 `50` 加到 `score` 上，并告诉计算机“显示分数”，现在它会显示
    `150`。
- en: So how can you use JavaScript to make this magic happen?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你如何使用 JavaScript 来实现这个魔法呢？
- en: 2.2\. Declaring variables and assigning values
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 声明变量和赋值
- en: 'Letting the computer know about information you’d like to store requires two
    steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让计算机知道你想要存储的信息需要两个步骤：
- en: '**1**.  You need to *set a name* you can use to refer to your data in the program,
    like *score* or *playerName* or *taxRate*.'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 你需要 *设置一个名称* 来在程序中引用你的数据，比如 *score* 或 *playerName* 或 *taxRate*。'
- en: '**2**.  You need to *link the name with the value* you want to store: something
    like *set score equal to 100* or *make ‘George’ the playerName* or *let the tax
    rate be 12%*.'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 你需要 *将名称与要存储的值相链接*：比如 *将分数设置为100* 或 *让‘George’成为playerName* 或 *让税率是12%*。'
- en: In [section 2.2.3](#ch02lev2sec3), you’ll see how both steps, giving a variable
    a name and giving it a value, can be completed in a single JavaScript statement.
    For now, you take things slowly and use a separate statement for each step.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [2.2.3节](#ch02lev2sec3) 中，你将看到如何在一个 JavaScript 语句中完成这两个步骤，即给变量命名和赋值。现在，你慢慢来，为每个步骤使用单独的语句。
- en: 2.2.1\. Declaring variables
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 声明变量
- en: You’ve been dreaming of making it big with your design for the next mobile app
    craze, *The Fruitinator!* Players are sent back in time to splat fruit with their
    *Smoothie 9mm*, racking up record scores as they go. Your program needs to track
    those scores. That means setting up a variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直梦想着通过你为下一个移动应用热潮 *The Fruitinator!* 的设计而一举成名，玩家被送回过去用他们的 *Smoothie 9mm* 拍打水果，在前进的过程中累积创纪录的分数。你的程序需要跟踪这些分数。这意味着设置一个变量。
- en: Registering a name to represent a value is called *variable declaration*. You
    declare a variable by using the `var` keyword. The following listing shows the
    code statement needed to declare a variable called `score`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用名称表示值的过程称为 *变量声明*。你通过使用 `var` 关键字来声明变量。以下列表显示了声明名为 `score` 的变量的所需代码语句。
- en: Listing 2.1\. Declaring a variable ([http://jsbin.com/potazo/edit?js,console](http://jsbin.com/potazo/edit?js,console))
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 声明一个变量 ([http://jsbin.com/potazo/edit?js,console](http://jsbin.com/potazo/edit?js,console))
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `var` keyword tells the computer to take the next word in the statement
    and turn it into a variable. [Figure 2.1](#ch02fig01) annotates the code statement
    from [listing 2.1](#ch02ex01).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字告诉计算机将语句中的下一个单词转换为一个变量。[图 2.1](#ch02fig01) 注释了 [列表 2.1](#ch02ex01)
    中的代码语句。'
- en: Figure 2.1\. Declaring a variable
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 声明一个变量
- en: '![](02fig01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片 02fig01](02fig01.jpg)'
- en: That’s it! You’ve declared a variable called `score` ready for some splatted
    fruit action. It’s the very first line of a fruit-based system that might just
    destroy humanity. Let’s start scoring points.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那就这样！你已经声明了一个名为 `score` 的变量，准备进行一些散裂水果的动作。这是基于水果的系统中的第一行代码，可能正是毁灭人类的开始。让我们开始计分吧。
- en: 2.2.2\. Assigning values to variables
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 给变量赋值
- en: Your program now knows about the variable `score`. But how do you assign it
    a value? You use the humble equals symbol, `=`. (Actually, in JavaScript, it’s
    not so humble. It turns up all over the place, performing a number of important
    jobs. A smooth operator.) [Figure 2.2](#ch02fig02) illustrates the equals symbol
    at work, with [listing 2.2](#ch02ex02) showing its use in context.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序现在知道了变量 `score`。但你是如何给它赋值的呢？你使用谦逊的等号 `=`。实际上，在 JavaScript 中，它并不那么谦逊。它无处不在，执行着许多重要的任务。（一个平滑的操作员。）[图
    2.2](#ch02fig02) 展示了等号在工作中的样子，[列表 2.2](#ch02ex02) 展示了它在上下文中的使用。
- en: Figure 2.2\. Assigning a value to a variable
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. 给变量赋值
- en: '![](02fig02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片 02fig02](02fig02.jpg)'
- en: Listing 2.2\. Assigning a value to a variable ([http://jsbin.com/yuvoju/edit?js,console](http://jsbin.com/yuvoju/edit?js,console))
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 给变量赋值 ([http://jsbin.com/yuvoju/edit?js,console](http://jsbin.com/yuvoju/edit?js,console))
- en: '![](018fig01_alt.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片 018fig01_alt](018fig01_alt.jpg)'
- en: You assign the variable `score` the value `100`. In general, you assign the
    value on the right of the equals sign to the variable on the left of the equals
    sign ([figure 2.3](#ch02fig03)). When you use the equals sign to assign a value,
    JavaScript gives it a special name, the *assignment operator*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你将变量 `score` 赋值为 `100`。一般来说，你将等号右边的值赋给等号左边的变量 ([图 2.3](#ch02fig03))。当你使用等号赋值时，JavaScript
    给它一个特殊名称，即 *赋值运算符*。
- en: Figure 2.3\. The equals sign is called the assignment operator.
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 等号被称为赋值运算符。
- en: '![](02fig03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片 02fig03](02fig03.jpg)'
- en: 'You have declared a variable and assigned it a value. It’s time to display
    it on the console. The output of the following listing should look something like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经声明了一个变量并给它赋了值。现在是时候在控制台上显示它了。以下列表的输出应该看起来像这样：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 2.3\. Using a variable ([http://jsbin.com/huvime/edit?js,console](http://jsbin.com/huvime/edit?js,console))
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 使用变量 ([http://jsbin.com/huvime/edit?js,console](http://jsbin.com/huvime/edit?js,console))
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `console.log` function, introduced in [chapter 1](kindle_split_009.html#ch01),
    you tell the computer to display the value of the `score` variable, whatever it
    happens to be. You’ve just assigned it a value of `100`, so that value appears
    on the console.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在 [第 1 章](kindle_split_009.html#ch01) 中介绍的 `console.log` 函数，你告诉计算机显示 `score`
    变量的值，无论它此时是什么。你刚刚给它赋值为 `100`，所以这个值出现在控制台上。
- en: 'Why didn’t you just print out `100` directly, using `console.log(100)`? Well,
    the values of variables usually change during the course of a program. By using
    a variable rather than a *literal* value, your programs can use current values,
    whatever they happen to be at the time. The next listing displays the value of
    `score` on the console, changes the value, and displays the new value, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用 `console.log(100)` 打印出 `100` 呢？嗯，变量的值通常在程序执行过程中会改变。通过使用变量而不是 *字面量*
    值，你的程序可以使用当前值，无论它们在此时是什么。下一个列表显示了 `score` 的值在控制台上的显示，改变了值，并显示了新的值，如下所示：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 2.4\. Variables vary ([http://jsbin.com/jasafa/edit?js,console](http://jsbin.com/jasafa/edit?js,console))
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 变量变化 ([http://jsbin.com/jasafa/edit?js,console](http://jsbin.com/jasafa/edit?js,console))
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You used the same instruction, `console.log(score)`, twice but the program printed
    two different values on the console. Your instruction used the variable `score`.
    Because its value had changed, so did the output.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了相同的指令 `console.log(score)` 两次，但程序在控制台上打印了两个不同的值。你的指令使用了变量 `score`。因为它的值已经改变，所以输出也改变了。
- en: 'You assigned the `score` variable numbers, `100` and then `150`, as values.
    Text is easy too; just wrap the text you want to assign in quotation marks. The
    next listing displays two messages on the console:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你为`score`变量分配了数字，`100`然后是`150`，作为值。文本也很简单；只需将你想分配的文本用引号括起来。下面的列表显示了控制台上的两条消息：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 2.5\. Assigning text to variables ([http://jsbin.com/hobiqo/edit?js,console](http://jsbin.com/hobiqo/edit?js,console))
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. 将文本分配给变量 ([http://jsbin.com/hobiqo/edit?js,console](http://jsbin.com/hobiqo/edit?js,console))
- en: '![](019fig01_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](019fig01_alt.jpg)'
- en: Programmers call sections of text *strings* because they’re strings, or sequences,
    of characters. As you saw in [listing 2.5](#ch02ex05), to denote a string you
    place the text inside quotation marks. The marks can be double, `"Hello World!"`,
    or single, `'Congratulations!'`, as long as they match. Without the quotation
    marks, JavaScript would try to interpret the text as instructions or variables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员称文本的部分为*字符串*，因为它们是字符的字符串，或序列。正如你在[列表2.5](#ch02ex05)中看到的，为了表示字符串，你将文本放在引号内。引号可以是双引号，`"Hello
    World!"`，或者单引号，`'Congratulations!'`，只要它们匹配即可。如果没有引号，JavaScript会尝试将文本解释为指令或变量。
- en: 2.2.3\. One-step declaration and assignment
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 单步声明和赋值
- en: You’ve seen how to declare variables and then assign them values in two steps.
    It’s also possible to declare a variable and assign it a value in a single statement,
    as illustrated in [figure 2.4](#ch02fig04).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何分两步声明变量并分配它们值。也可以在单个语句中声明变量并给它赋值，如图2.4所示。
- en: Figure 2.4\. You declare a variable and assign it a value in a single statement.
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 你在单个语句中声明变量并给它赋值。
- en: '![](02fig04.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig04.jpg)'
- en: '[Listings 2.6](#ch02ex06) and [2.7](#ch02ex07) achieve exactly the same outcome,
    declaring variables and assigning them values before displaying the following
    message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.6](#ch02ex06)和[2.7](#ch02ex07)实现了完全相同的结果，在显示以下消息之前声明变量并分配它们值：'
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 2.6\. Declaring and assigning in two steps ([http://jsbin.com/vegoja/edit?js,console](http://jsbin.com/vegoja/edit?js,console))
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. 分两步声明和分配 ([http://jsbin.com/vegoja/edit?js,console](http://jsbin.com/vegoja/edit?js,console))
- en: '![](020fig01_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](020fig01_alt.jpg)'
- en: Listing 2.7\. Declaring and assigning in one step ([http://jsbin.com/dorane/edit?js,console](http://jsbin.com/dorane/edit?js,console))
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 单步声明和分配 ([http://jsbin.com/dorane/edit?js,console](http://jsbin.com/dorane/edit?js,console))
- en: '![](020fig02_alt.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](020fig02_alt.jpg)'
- en: In [listing 2.7](#ch02ex07), you assign the value on the right side of each
    equals symbol to the newly declared variable on the left. In both programs, you
    create the message displayed on the console by joining pieces of text using the
    addition symbol, `+`. Joining pieces of text is called *string concatenation*
    and `+` is the *string concatenation operator*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表2.7](#ch02ex07)中，你将等号右侧的值分配给左侧新声明的变量。在这两个程序中，你通过使用加号`+`将文本片段连接起来来创建控制台上显示的消息。连接文本片段称为*字符串连接*，`+`是*字符串连接运算符*。
- en: If you know the value of a variable at the time you declare it, then this single-step
    approach can be a neat way of assigning the value to the variable. Sometimes,
    the value won’t be known at the time of declaration; maybe some calculations need
    to be performed, user input is required, or you’re waiting for a network response.
    In that case, declaration and assignment would be separate. It’s common for programmers
    to declare their variables at the top of a program, even if they won’t assign
    them values until later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明变量时知道它的值，那么这种单步方法可以是一种将值分配给变量的整洁方式。有时，在声明时可能不知道值；可能需要进行一些计算，需要用户输入，或者你正在等待网络响应。在这种情况下，声明和分配将是分开的。程序员通常会在程序顶部声明变量，即使他们不会在稍后分配值。
- en: 2.2.4\. Using a variable in its own assignment
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 在自己的赋值中使用变量
- en: When you assign a value to a variable, JavaScript evaluates the *expression*
    to the right of the assignment operator and assigns the result to the variable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给变量赋值时，JavaScript会评估赋值运算符右侧的表达式，并将结果分配给变量。
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: JavaScript evaluates the expression, `100 + 50`, and assigns the result, `150`,
    to the variable `score`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript评估表达式`100 + 50`，并将结果`150`分配给变量`score`。
- en: 'The values in the expression probably won’t be hard-coded literals like `100`
    and `50`; they’re more likely to be variables. Here’s an example, using the variables
    `callOut-Charge`, `costPerHour`, and `numberOfHours`, to calculate the total cost
    when hiring a plumber to do some work:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的值可能不会是硬编码的数字，如`100`和`50`；它们更有可能是变量。以下是一个例子，使用变量`callOut-Charge`、`costPerHour`和`numberOfHours`来计算雇佣水管工做工作的总费用：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `*` symbol is used for multiplication; it is the *multiplication operator*.
    You can also use `–` for subtraction and `/` for division.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`符号用于乘法；它是*乘法运算符*。你也可以使用`–`进行减法，`/`进行除法。'
- en: Because JavaScript evaluates the expression on the right first, before assigning
    its value to the variable on the left, you can even use the current value of a
    variable to set its new value. Say a player in your app sensation *The Fruitinator!*
    has just splatted a strawberry; that’s 50 points! The player needs an update.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript首先评估右侧的表达式，然后再将其值赋给左侧的变量，因此你甚至可以使用变量的当前值来设置其新值。比如说，在你的应用程序的感官游戏*水果机*中，一个玩家刚刚打翻了草莓；那值50分！玩家需要更新分数。
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 2.5](#ch02fig05) shows a statement using the current score when assigning
    the updated score, and [listing 2.8](#ch02ex08) is your score-updating program.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.5](#ch02fig05)展示了在赋值更新分数时使用当前分数的语句，[代码列表2.8](#ch02ex08)是你的更新分数的程序。'
- en: Figure 2.5\. Updating a variable with the result of a calculation involving
    itself
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 使用涉及自身计算结果的变量更新
- en: '![](02fig05.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig05.jpg)'
- en: Listing 2.8\. Using a variable’s current value to set its new value ([http://jsbin.com/kijuce/edit?js,console](http://jsbin.com/kijuce/edit?js,console))
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 使用变量的当前值来设置其新值 ([http://jsbin.com/kijuce/edit?js,console](http://jsbin.com/kijuce/edit?js,console))
- en: '![](021fig01_alt.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](021fig01_alt.jpg)'
- en: In the code, you evaluate the expression, `score + 50`, using the current value
    of `score`, `100`, to give the result `150`. This value, `150`, is then assigned
    to `score`. Next up for *The Fruitinator!* ... kumquats. Worth a cool 100 points!
    Kumquats are tricky. Never trust a kumquat.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你使用`score + 50`的表达式，利用`score`的当前值`100`来得到结果`150`。这个值`150`随后被赋值给`score`。接下来是*水果机*...金桔。价值100分！金桔很棘手。永远不要相信金桔。
- en: 2.3\. Choosing good variable names
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 选择好的变量名
- en: In all the code listings so far, there was nothing forcing you to give the variables
    the names you did. You tried to choose names that would help anyone reading the
    code understand the purpose of the variables. You almost have a free choice but
    must be careful not to tread on JavaScript’s toes; there are names that JavaScript
    has set aside for its own use and further rules governing valid variable names.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的所有代码示例中，没有任何强制要求你必须使用你给变量取的名字。你试图选择那些能帮助阅读代码的人理解变量用途的名字。你几乎有完全的自由选择，但必须小心不要触及JavaScript的底线；JavaScript为自身用途预留了一些名字，并且还有一些关于有效变量名的规则。
- en: 2.3.1\. Keywords and reserved words
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 关键词和保留字
- en: JavaScript has a set of *keywords*, like `var` and `function`, that are part
    of the language itself and govern the actions and properties available in every
    program. It also sets aside some *reserved words* that may turn up as keywords
    in the language in the future. You can’t use those keywords or reserved words
    as variable names. Other examples of keywords are `if`, `switch`, `do`, and `yield`,
    and a full list can be found on the Mozilla Developer Network ([http://mng.bz/28d9](http://mng.bz/28d9)).
    But don’t take my word for it. Head over to JS Bin and try using one of those
    words as a variable name, as shown in [figure 2.6](#ch02fig06).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一组*关键词*，如`var`和`function`，它们是语言本身的一部分，并控制着每个程序中的动作和属性。它还预留了一些*保留字*，这些字可能在未来的语言中作为关键词出现。你不能将这些关键词或保留字用作变量名。其他关键词的例子有`if`、`switch`、`do`和`yield`，完整的列表可以在Mozilla开发者网络([http://mng.bz/28d9](http://mng.bz/28d9))上找到。但不要仅凭我的话，去JS
    Bin试一试将这些词作为变量名使用，如图2.6所示。
- en: Figure 2.6\. JavaScript has some words that can’t be used as variable names.
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. JavaScript有一些不能用作变量名的词。
- en: '![](02fig06_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig06_alt.jpg)'
- en: You don’t have to learn the lists of keywords and reserved words; you’ll pick
    up most of them as you do more programming, and they usually throw errors when
    you try to use them. But do bear them in mind if your program isn’t working and
    you’re not sure why.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要学习关键词和保留字的列表；随着你编程经验的积累，你会自然而然地掌握大部分，而且当你尝试使用它们时，通常会出现错误。但如果你发现程序运行不正常，而你又不确定原因时，请记住它们。
- en: 2.3.2\. Rules for naming variables
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 变量命名规则
- en: So now that keywords and reserved words are out, is everything else in? Not
    quite—there are a few further rules. Variable names can start with any letter,
    a dollar sign, `$`, or an underscore, `_`. Subsequent characters can be any of
    those or numbers. Spaces are not allowed. [Listing 2.9](#ch02ex09) includes one
    block of valid names and one block of invalid names. If you visit the code on
    JS Bin, you’ll see it reports a long list of errors. Take a look and try to make
    sense of them, but don’t worry if you don’t understand them all; the listing includes
    invalid names on purpose and JavaScript isn’t happy about it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 既然关键字和保留字已经排除在外，那么其他所有内容都包含在内了吗？并不完全是这样——还有一些额外的规则。变量名可以以任何字母、美元符号`$`或下划线`_`开头。后续字符可以是这些字符中的任何一个或数字。不允许有空格。[列表2.9](#ch02ex09)包括一个有效名称块和一个无效名称块。如果你访问JS
    Bin上的代码，你会看到它报告了一个长长的错误列表。看看并尝试理解它们，但如果你不完全理解它们，不要担心；列表中故意包含了无效名称，因为JavaScript对此并不高兴。
- en: Listing 2.9\. Valid and invalid variable names ([http://jsbin.com/biqawu/edit?js,console](http://jsbin.com/biqawu/edit?js,console))
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9. 有效和无效变量名 ([http://jsbin.com/biqawu/edit?js,console](http://jsbin.com/biqawu/edit?js,console))
- en: '![](023fig01.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](023fig01.jpg)'
- en: JavaScript is case sensitive. Changing the case of characters in a variable
    name will give a different variable. `score`, `Score`, and `SCORE` are three different
    names. These differences can be hard to spot, so it’s worth trying to be consistent,
    as discussed in the next section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是区分大小写的。变量名中字符的大小写变化将产生不同的变量。`score`、`Score`和`SCORE`是三个不同的名称。这些差异可能很难发现，所以像下一节讨论的那样，保持一致性是值得的。
- en: 2.3.3\. camelCase
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3. 骆驼命名法
- en: You may have noticed the capitalization of letters in the variable names you’ve
    been using. Where names like `costPerHour`, `playerName`, and `selfieStickActivated`
    are made up of multiple words joined together, the first word is lowercase and
    the following words start with an uppercase character. This is called *camel casing*
    and is an extremely widespread convention that can help to make the names more
    readable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了你使用的变量名中的字母大小写。在像`costPerHour`、`playerName`和`selfieStickActivated`这样的变量名中，由多个单词组成，第一个单词是小写，后面的单词以大写字母开头。这被称为*骆驼命名法*，这是一种极其普遍的约定，可以帮助使名称更易读。
- en: Some programmers choose to separate words within variable names with underscores
    instead, like `cost_per_hour`, `player_name`, and `selfie_stick_activated`. How
    you name variables is up to you; it’s part of your programming *style*. I’ll be
    sticking with camel case throughout *Get Programming with JavaScript*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员选择使用下划线而不是空格来分隔变量名中的单词，例如`cost_per_hour`、`player_name`和`selfie_stick_activated`。你如何命名变量取决于你；这是你编程风格的一部分。在《用JavaScript编程入门》中，我将坚持使用骆驼命名法。
- en: 2.3.4\. Use descriptive variable names
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4. 使用描述性变量名
- en: Try to give your variables names that describe what they’re for or what they
    do. You’re free to choose the names but `costPerHour` is much easier to understand
    than `cph`. Other programmers may need to read and update your code in the future,
    and you’ll thank yourself when you return to it at some point down the line. As
    your programs grow and involve more and more variables, objects, and functions,
    good variable names can really help you follow the flow of the program and understand
    its purpose. So keep those variable names simple, direct, and descriptive.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试给你的变量命名，使其能够描述它们的作用或功能。你可以自由选择名称，但`costPerHour`比`cph`更容易理解。其他程序员可能需要在将来阅读和更新你的代码，当你某一天再次回到它时，你会感谢自己。随着你的程序不断增长，涉及越来越多的变量、对象和函数，好的变量名真的可以帮助你跟随程序的流程并理解其目的。因此，请保持变量名简单、直接且具有描述性。
- en: You’ve seen what variables are for, how to declare and assign them, and what
    makes for a good name. But how do you know what variables you need in a program?
    Analyzing the problem you’re trying to solve and planning out a solution that
    fits your users is an important part of program design. In the next section, you
    take a little time to consider the information you need to represent the players
    in your ongoing example, *The Crypt*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了变量的用途，如何声明和分配它们，以及什么是一个好的名称。但你知道在程序中需要哪些变量吗？分析你试图解决的问题并规划一个适合你用户的解决方案是程序设计的重要部分。在下一节中，你将花点时间考虑你正在进行的示例“密室”中需要表示玩家的信息。
- en: 2.4\. The Crypt—player variables
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 密室—玩家变量
- en: 'As discussed in [chapter 1](kindle_split_009.html#ch01), *The Crypt* includes
    a number of elements: players, places, game, maps, and challenges. You need to
    consider the properties of all of those elements as you design and build the game.
    For now, you focus on the players, as shown in [figure 2.7](#ch02fig07).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章[讨论](kindle_split_009.html#ch01)的，*The Crypt* 包含了许多元素：玩家、地点、游戏、地图和挑战。在设计构建游戏时，你需要考虑所有这些元素的性质。现在，你专注于玩家，如图2.7[所示](#ch02fig07)。
- en: Figure 2.7\. Elements in *The Crypt*
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 《The Crypt》中的元素
- en: '![](02fig07_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig07_alt.jpg)'
- en: As players move from place to place, what does the program need to know to create
    fun and challenging adventures? You may want to keep track of names, health, items
    carried, or location. Or maybe hairiness of feet or color of lightsaber. Some
    of that information may stay the same during a game and some may change.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家从一个地方移动到另一个地方时，程序需要知道什么来创建有趣和具有挑战性的冒险？你可能需要记录名字、健康、携带的物品或位置。或者可能是脚的毛茸茸程度或光剑的颜色。一些信息在游戏过程中可能保持不变，而一些信息可能会改变。
- en: Part of the art of programming is *abstraction*, knowing what information to
    include and what to leave out. It might be that just how hairy a player’s feet
    are has a role to play in the game, but it’s likely to be more than you need to
    know. You should think carefully about what data you’ll use as the player completes
    their quest.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 编程艺术的一部分是*抽象*，知道要包含哪些信息以及要排除哪些信息。可能只是玩家脚毛的多少在游戏中扮演了一定的角色，但很可能这比你需要知道的多。你应该仔细思考玩家完成他们的任务时将使用哪些数据。
- en: '[Table 2.1](#ch02table01) shows some possible properties that you may want
    to include when representing each player in your program.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.1](#ch02table01) 展示了一些你可能希望在程序中表示每个玩家时包含的属性。'
- en: Table 2.1\. Possible player properties
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. 可能的玩家属性
- en: '| Property | What’s it for? | Example values |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 它是用来做什么的？ | 示例值 |'
- en: '| --- | --- | --- |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Name | Used when displaying player information and when interacting with
    other players. | "Kandra", "Dax" |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 用于显示玩家信息和与其他玩家互动时。 | "Kandra"、"Dax" |'
- en: '| Health | Decreased by monsters and poison. Increased by food and potions.
    | 68 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 健康 | 由怪物和毒药减少。由食物和药水增加。 | 68 |'
- en: '| Place | Where is the player on the map? | "The Old Library" |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 玩家在地图上的位置？ | "老图书馆" |'
- en: '| Hairiness of feet | A measure of how well the player copes in cold conditions,
    without boots. | 94 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 脚的毛茸茸程度 | 衡量玩家在没有靴子的情况下在寒冷条件下的应对能力。 | 94 |'
- en: '| Items | Keeping track of the items a player has picked up. | "A rusty key",
    "A purple potion", "Cheese" |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 物品 | 跟踪玩家捡起的物品。 | "一把生锈的钥匙"、"一瓶紫色药水"、"奶酪" |'
- en: 'You may well need other properties, and you can add and remove properties if
    necessary. Declaring player properties could go something like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要其他属性，并且如果需要，你可以添加和删除属性。声明玩家属性可能如下所示：
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Part of a programmer’s expertise is being able to model situations and predict
    which variables will be needed to complete a program. The more you get right ahead
    of time, the less chance there’ll be a need for a big rewrite of your program—nobody
    wants that. Just as you don’t want to realize you’ve forgotten your passport at
    the airport, you don’t want to find you’ve overlooked a crucial part of a program
    when you’ve written lots of code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的专业技能之一是能够模拟情况并预测完成程序所需的变量。提前做对的事情越多，程序需要大改动的可能性就越小——没有人希望这样。就像你不想在机场意识到自己忘了护照一样，你也不想在你编写了大量代码后发现遗漏了程序的关键部分。
- en: 2.5\. Summary
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 概述
- en: Variables let you store data for your program to use while it’s running.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量允许你在程序运行时存储数据供程序使用。
- en: 'Declare a variable by following the `var` keyword with a name:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在`var`关键字后跟一个名称来声明变量：
- en: '[PRE17]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Choose simple, descriptive names for your variables, avoiding JavaScript’s keywords
    and reserved words.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的变量选择简单、描述性的名称，避免使用JavaScript的关键词和保留字。
- en: 'Assign values to variables with the assignment operator, the equals symbol
    `=`:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用赋值运算符，即等号`=`来给变量赋值：
- en: '[PRE18]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You assign the value on the right of the equals sign to the variable on the
    left.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将等号右侧的值赋给等号左侧的变量。
- en: 'Use variables in expressions:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表达式中使用变量：
- en: '[PRE19]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As part of the planning for your programs, consider what variables you’ll need
    and what kinds of data they’ll hold.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为你程序规划的一部分，考虑你需要哪些变量以及它们将持有哪些类型的数据。
- en: 'Chapter 3\. Objects: grouping your data'
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章\. 对象：分组你的数据
- en: '***This chapter covers***'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Organizing information with JavaScript objects
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript对象组织信息
- en: Creating objects
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象
- en: Adding properties to objects
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向对象添加属性
- en: Accessing properties using dot notation
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点符号访问属性
- en: Examples of objects
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的示例
- en: In [chapter 2](kindle_split_010.html#ch02) you saw how to declare variables
    and assign them values, and you considered the variables you could use to model
    a player in *The Crypt*. As your programs grow, so does the number of variables
    you use; you need ways to organize all this data, to make your programs easier
    to understand and easier to update and add to in the future.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_010.html#ch02)中，你学习了如何声明变量并分配值，并考虑了可以用来模拟《The Crypt》中的玩家的变量。随着你的程序增长，你使用的变量数量也在增加；你需要方法来组织所有这些数据，以便使你的程序更容易理解，并更容易在未来进行更新和添加。
- en: Sometimes it makes sense to group items and see them as a whole. Consider a
    first-aid kit; we happily treat it as a single item—“Have you packed the first-aid
    kit?” “Pass the first-aid kit.” “We need the first-aid kit, *now*!”—but will quickly
    switch focus to its contents when the need arises—“Pass the antiseptic and the
    bandages from the first-aid kit, please.” A number of items is neatly encapsulated
    by a single object.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将项目分组并作为一个整体来看是有意义的。考虑一个急救包；我们很高兴地将其视为一个单独的项目——“你打包了急救包吗？”“递给我急救包。”“我们急需急救包，*现在*！”——但当需要时，会迅速将注意力转向其内容——“请从急救包中递给我消毒剂和绷带。”许多项目被一个单一的对象整洁地封装起来。
- en: This chapter introduces JavaScript objects, a simple and efficient way to collect
    variables together so that you can pass them around as a group rather than individually.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了JavaScript对象，这是一种简单高效的方法，可以将变量组合在一起，以便你可以将它们作为一个组而不是单个变量传递。
- en: 3.1\. A need for organization
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 组织的需求
- en: 'Your library of adventure stories is growing, and you decide to write a program
    to keep track of your precious collection. The following listing shows variables
    you use to generate this test output on the console:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你的冒险故事图书馆正在增长，你决定编写一个程序来跟踪你宝贵的收藏。以下列表显示了你在控制台上生成此测试输出的变量：
- en: '[PRE20]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 3.1\. Using variables to represent a book ([http://jsbin.com/fucuxah/edit?js,console](http://jsbin.com/fucuxah/edit?js,console))
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 使用变量表示书籍 ([http://jsbin.com/fucuxah/edit?js,console](http://jsbin.com/fucuxah/edit?js,console))
- en: '![](028fig01_alt.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig01_alt.jpg)'
- en: First, you declare two variables, `bookTitle` and `bookAuthor`, using the `var`
    keyword. You’re going to use those two names to store and access values in the
    program. You then assign strings (text) to your freshly created variables. You
    wrap the strings in quotation marks so JavaScript doesn’t try to interpret them
    as keywords or variable names. Finally, you log a message to the console. You
    build the message by using the concatenation operator (the `+` symbol) to join
    three strings.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`var`关键字声明两个变量，`bookTitle`和`bookAuthor`。你将使用这两个名称在程序中存储和访问值。然后，将字符串（文本）分配给你的新创建的变量。你用引号包裹字符串，这样JavaScript就不会尝试将它们解释为关键字或变量名。最后，你将一条消息记录到控制台。你通过使用连接运算符（`+`符号）将三个字符串连接起来构建这条消息。
- en: 'It may be early days but you certainly have more than one book. How can you
    cope with the variables needed as you buy more? You could have a different prefix
    for each book. The next listing ups the number of books to three, printing these
    messages to the console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能还处于早期阶段，但你肯定不止有一本书。当你购买更多书籍时，如何应对所需的变量？你可以为每本书使用不同的前缀。接下来的列表将书籍数量增加到三本，并将这些消息打印到控制台：
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 3.2\. Using prefixes to tell book variables apart ([http://jsbin.com/qowagi/edit?js,console](http://jsbin.com/qowagi/edit?js,console))
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 使用前缀区分书籍变量 ([http://jsbin.com/qowagi/edit?js,console](http://jsbin.com/qowagi/edit?js,console))
- en: '![](028fig02_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](028fig02_alt.jpg)'
- en: This works up to a point. But as the number of books and the number of facts
    about each book increase, the number of variables is harder to manage. It would
    be helpful to be able to group all of the information about a book together, using
    a single variable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上是可行的。但随着书籍数量和每本书的事实增加，变量的数量就难以管理了。能够将一本书的所有信息组合在一起，使用单个变量来访问，将会很有帮助。
- en: 3.2\. Creating objects
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 创建对象
- en: In the same way as it is easier to ask for a first-aid kit rather than for the
    scissors, antiseptic, bandages, and sticking plasters separately, it can be easier
    to ask for `book1` rather than `book1Title`, `book1Author`, `book1ISBN`, and so
    on separately. JavaScript provides us with the ability to create *objects* to
    group variables. Very specific notation, or *syntax*, is used to define a new
    object. Let’s look at a full example and then break it down into stages.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就像请求急救包比单独请求剪刀、消毒剂、绷带和创可贴更容易一样，请求`book1`比单独请求`book1Title`、`book1Author`、`book1ISBN`等更容易。JavaScript为我们提供了创建*对象*来分组变量的能力。定义一个新对象时，使用非常具体的*语法*。让我们来看一个完整的例子，然后再将其分解成几个阶段。
- en: '[Listing 3.3](#ch03ex03) shows how to create a book as an object rather than
    as separate variables. [Figure 3.1](#ch03fig01) shows the output on JS Bin when
    you log the `book` object to the console.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.3](#ch03ex03)展示了如何创建一本书作为对象而不是作为单独的变量。[图3.1](#ch03fig01)展示了当你将`book`对象记录到控制台时在JS
    Bin上的输出。'
- en: Figure 3.1\. You log an object to the console on JS Bin.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1。你在JS Bin的控制台上记录一个对象。
- en: '![](03fig01_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![03fig01_alt.jpg](03fig01_alt.jpg)'
- en: Listing 3.3\. A book as an object ([http://jsbin.com/ruruko/edit?js,console](http://jsbin.com/ruruko/edit?js,console))
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3。一本书作为一个对象([http://jsbin.com/ruruko/edit?js,console](http://jsbin.com/ruruko/edit?js,console))
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you run [listing 3.3](#ch03ex03) on JS Bin, the console displays all the
    properties of your new `book` object, as well as telling you it’s an object. Notice
    that it displays the properties in alphabetical order. The object itself doesn’t
    order the properties; JS Bin has chosen an ordering purely for display.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JS Bin上运行[列表3.3](#ch03ex03)时，控制台会显示你新创建的`book`对象的所有属性，并告诉你它是一个对象。注意，它以字母顺序显示属性。对象本身并不对属性进行排序；JS
    Bin纯粹是为了显示而选择了排序方式。
- en: Let’s break down the object creation to get a clearer idea of what’s going on
    and what all the different bits of notation represent.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解对象创建过程，以更清楚地了解正在发生什么以及所有不同的符号表示什么。
- en: 3.2.1\. Creating an empty object
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1. 创建一个空对象
- en: In [chapter 2](kindle_split_010.html#ch02) you saw that variables can be declared
    but not assigned a value until later in a program. You might have to wait for
    some user input or a response from a server or a reading from a sensor before
    you know the value you want to assign to the variable. In the same way, you can
    create an object with no properties, knowing that properties will be added at
    some point in the future.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_010.html#ch02)中，你看到变量可以被声明，但不能在程序稍后分配值。你可能必须等待一些用户输入或服务器的响应，或者从传感器读取，才能知道要分配给变量的值。同样，你可以创建一个没有任何属性的空对象，知道将来会在某个时候添加属性。
- en: To create an object, use curly braces, as in the following listing.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象，使用大括号，如下面的列表所示。
- en: Listing 3.4\. Creating an empty object ([http://jsbin.com/kaqatu/edit?js,console](http://jsbin.com/kaqatu/edit?js,console))
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4。创建一个空对象([http://jsbin.com/kaqatu/edit?js,console](http://jsbin.com/kaqatu/edit?js,console))
- en: '![](030fig01.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![030fig01.jpg](030fig01.jpg)'
- en: You create an empty object, one with no properties, and assign it to the variable
    `book`. It’s not much use without any properties, and you’ll see how to add new
    properties to an existing object in [section 3.4](#ch03lev1sec4). But how would
    you create your book object with properties in place?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个空对象，一个没有任何属性的空对象，并将其分配给变量`book`。没有属性就没有什么用处，你将在[3.4节](#ch03lev1sec4)中看到如何向现有对象添加新属性。但你是如何创建具有现有属性的图书对象的？
- en: 3.2.2\. Properties as key-value pairs
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2. 属性作为键值对
- en: 'The book in [listing 3.3](#ch03ex03) includes three properties: its title,
    its author, and its year of publication. The values of those properties are `"The
    Hobbit"`, `"J. R. R. Tolkien"`, and `1937`. In a JavaScript object, the names
    of the properties are called *keys*. For `book` the keys are `title`, `author`,
    and `published`. When creating an object, you add a property by including its
    key and value, separated by a colon, between the curly braces. [Figure 3.2](#ch03fig02)
    shows a property definition.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3.3](#ch03ex03)中的书中包含三个属性：它的标题、它的作者和它的出版年份。这些属性的值是`"The Hobbit"`、`"J. R.
    R. Tolkien"`和`1937`。在JavaScript对象中，属性的名称被称为*键*。对于`book`，键是`title`、`author`和`published`。在创建对象时，你通过在大括号内包含键和值（由冒号分隔）来添加属性。[图3.2](#ch03fig02)显示了属性定义。
- en: Figure 3.2\. Set properties by using key-value pairs.
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2。使用键值对设置属性。
- en: '![](03fig02.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![03fig02.jpg](03fig02.jpg)'
- en: Another name for a key-value pair is a name-value pair, but we’ll stick with
    keys and values in this book.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对的另一个名称是名称-值对，但在这本书中我们将坚持使用键和值。
- en: In the next listing you create an object with a single property.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你创建一个只有一个属性的对象。
- en: Listing 3.5\. An object with a single property ([http://jsbin.com/robupi/edit?js,console](http://jsbin.com/robupi/edit?js,console))
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. 具有一个属性的对象 ([http://jsbin.com/robupi/edit?js,console](http://jsbin.com/robupi/edit?js,console))
- en: '[PRE23]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You declare a variable and then create an object and assign it to the variable.
    The object has a single property. The key of the property is `title` and its value
    is `"The` `Hob``bit"`. We usually simply say that the `title` property of `book`
    is `"The Hobbit"`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个变量，然后创建一个对象并将其赋值给该变量。该对象有一个属性。属性的键是 `title`，其值是 `"The` `Hob``bit"`。我们通常简单地说，`book`
    的 `title` 属性是 `"The Hobbit"`。
- en: Property values aren’t restricted to number and string literals, like `50` or
    `"The` `Hob``bit"`. You can also use previously declared variables as values.
    The following listing assigns the name of a book to a variable and then uses that
    variable as the value of an object’s property.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值不仅限于数字和字符串字面量，如 `50` 或 `"The` `Hob``bit"`。你还可以使用之前声明的变量作为值。以下列表将一本书的名称赋给一个变量，然后使用该变量作为对象属性的值。
- en: Listing 3.6\. Using a variable as a property value ([http://jsbin.com/bafige/edit?js,console](http://jsbin.com/bafige/edit?js,console))
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.6\. 使用变量作为属性值 ([http://jsbin.com/bafige/edit?js,console](http://jsbin.com/bafige/edit?js,console))
- en: '![](031fig01_alt.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](031fig01_alt.jpg)'
- en: Having an object with a single property is a little extravagant; you might as
    well stick with a variable. Let’s see how to create an object with more than one
    property.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个只有一个属性的对象有点奢侈；你不妨继续使用变量。让我们看看如何创建具有多个属性的对象。
- en: When you need multiple properties, commas separate the key-value pairs. [Figure
    3.3](#ch03fig03) shows two properties as part of an object definition, and [listing
    3.7](#ch03ex07) creates two objects, each with two properties.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要多个属性时，用逗号分隔键值对。[图3.3](#ch03fig03) 展示了对象定义中的两个属性，而[列表3.7](#ch03ex07) 创建了两个对象，每个对象都有两个属性。
- en: Figure 3.3\. An object definition with two properties
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 具有两个属性的对象定义
- en: '![](03fig03_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig03_alt.jpg)'
- en: Listing 3.7\. Objects with multiple properties ([http://jsbin.com/bawiqev/edit?js,console](http://jsbin.com/bawiqev/edit?js,console))
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. 具有多个属性的对象 ([http://jsbin.com/bawiqev/edit?js,console](http://jsbin.com/bawiqev/edit?js,console))
- en: '![](032fig01_alt.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](032fig01_alt.jpg)'
- en: Now that you’ve created an object, you need to be able to access its properties.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个对象，你需要能够访问它的属性。
- en: 3.3\. Accessing object properties
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 访问对象属性
- en: 'We’re comfortable with the concept of a first-aid kit as a single object we
    can pass around from person to person and take from place to place. It’s only
    when we need to use the kit that we consider what’s inside: antiseptic, scissors,
    bandages, and so on.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对急救包作为一个可以传递给每个人、从地方到地方携带的单个对象的概念感到舒适。只有当我们需要使用急救包时，我们才会考虑里面的内容：消毒剂、剪刀、绷带等等。
- en: For JavaScript objects, to access the values of an object’s properties you can
    use *dot notation*. Join the name of the variable to the name of the property,
    its key, with a period or dot. For a first-aid kit as an object you might use
    `kit.antiseptic` or `kit.scissors` or `kit.bandages`. And for books, to access
    the `author` property of the object assigned to the variable called `book`, you
    write `book.author` ([figure 3.4](#ch03fig04)).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript对象，要访问对象属性的值，你可以使用 *点符号*。将变量的名称与属性的名称、其键，用点或句号连接起来。对于一个急救包作为对象，你可能使用
    `kit.antiseptic` 或 `kit.scissors` 或 `kit.bandages`。对于书籍，要访问名为 `book` 的变量所赋的对象的
    `author` 属性，你写 `book.author` ([图3.4](#ch03fig04))。
- en: Figure 3.4\. Accessing object properties using dot notation
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.4\. 使用点符号访问对象属性
- en: '![](03fig04.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig04.jpg)'
- en: 'In the next listing, you print the `title` and `author` properties of the `book`
    object to the console to give the following output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你将 `book` 对象的 `title` 和 `author` 属性打印到控制台，以给出以下输出：
- en: '[PRE24]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 3.8\. Using dot notation to access property values ([http://jsbin.com/funiyu/edit?js,console](http://jsbin.com/funiyu/edit?js,console))
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. 使用点符号访问属性值 ([http://jsbin.com/funiyu/edit?js,console](http://jsbin.com/funiyu/edit?js,console))
- en: '![](032fig02_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](032fig02_alt.jpg)'
- en: You line up the colons in the object properties in [listing 3.8](#ch03ex08)
    to aid readability. Although JavaScript will ignore the extra spaces, indenting
    blocks of code and lining up values can make your programs easier to read and
    follow, especially as they grow in size. And the easier your code is to read,
    the easier it is to maintain and update, both for you and for other programmers.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[代码清单3.8](#ch03ex08)中将对象属性中的冒号对齐，以帮助提高可读性。尽管JavaScript会忽略额外的空格，但缩进代码块并对齐值可以使你的程序更容易阅读和跟踪，尤其是随着程序规模的增大。代码越容易阅读，就越容易维护和更新，无论是对你还是对其他程序员来说。
- en: Replacing a bunch of separate variables with a single object helps you manage
    the complexity of your programs. You can think more clearly about how programs
    work when details are hidden until you need them. You consider a book a single
    entity in your program until you need to access the book’s title or author or
    publication date. It may seem that replacing three variables with one variable
    and three properties isn’t an improvement, but when you start to use objects with
    functions in [chapter 7](kindle_split_015.html#ch07) and arrays in [chapter 8](kindle_split_016.html#ch08),
    their economy and clarity will be more obvious.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个单独的变量替换为一个单一的对象有助于你管理程序的复杂性。当细节隐藏直到你需要它们时，你可以更清晰地思考程序的工作方式。你将一本书视为程序中的单个实体，直到你需要访问书的标题、作者或出版日期。可能看起来用单个变量和三个属性替换三个变量并没有改进，但当你开始在[第7章](kindle_split_015.html#ch07)中使用具有函数的对象和在[第8章](kindle_split_016.html#ch08)中使用数组时，它们的效率和清晰度将更加明显。
- en: 'You use property values just like variables. The code in the following listing
    concatenates each book’s title with the string `" by "` and its author to give
    this output:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用属性值就像使用变量一样。以下代码清单中的代码将每本书的标题与字符串`" by "`及其作者连接起来，以生成以下输出：
- en: '[PRE25]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 3.9\. Concatenating string properties ([http://jsbin.com/yoweti/edit?js,console](http://jsbin.com/yoweti/edit?js,console))
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单3.9\. 连接字符串属性 ([http://jsbin.com/yoweti/edit?js,console](http://jsbin.com/yoweti/edit?js,console))
- en: '[PRE26]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 3.4\. Updating object properties
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 更新对象属性
- en: In a quiz app, players attempt questions one after another. The number of questions
    attempted, number of questions correct, and score will change over time. You can
    create a player object with initial values set and then update them whenever a
    question is attempted. Use dot notation to change a property that already exists
    or to add a new property to an object, as in the following listing.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在测验应用中，玩家一个接一个地尝试问题。尝试的问题数量、正确的问题数量和分数会随着时间的推移而变化。你可以创建一个具有初始值的玩家对象，并在尝试问题时随时更新它们。使用点符号来更改已存在的属性或向对象添加新属性，如下面的代码清单所示。
- en: Listing 3.10\. Using dot notation to update a property ([http://jsbin.com/mulimi/edit?js,console](http://jsbin.com/mulimi/edit?js,console))
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单3.10\. 使用点符号更新属性 ([http://jsbin.com/mulimi/edit?js,console](http://jsbin.com/mulimi/edit?js,console))
- en: '![](034fig01.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](034fig01.jpg)'
- en: Your code in [listing 3.10](#ch03ex10) sets the `attempted` and `correct` properties
    to an initial value when the object is created but then updates them to a new
    value. It uses the assignment operator, `=`, to assign the value, `1`, on the
    right of the operator, to the property, `player1.attempted`, on its left. You
    set the `attempted` and `correct` properties and then immediately update them;
    in the actual quiz app, the change would be in response to the player answering
    a question.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在[代码清单3.10](#ch03ex10)中，你的代码在创建对象时将`attempted`和`correct`属性设置为初始值，但随后将它们更新为新的值。它使用赋值运算符`=`将运算符右侧的值`1`赋给左侧的属性`player1.attempted`。你设置了`attempted`和`correct`属性，然后立即更新它们；在实际的测验应用中，这种变化将是对玩家回答问题的响应。
- en: You can add new properties to an object after creating it. In [listing 3.10](#ch03ex10),
    you assign the value `50` to the `score` property of the `player1` object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象后，你可以向其中添加新的属性。在[代码清单3.10](#ch03ex10)中，你将值`50`赋给`player1`对象的`score`属性。
- en: '[PRE27]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You didn’t set the `score` property when creating the object; assigning a value
    automatically creates the property if it does not yet exist.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象时，你没有设置`score`属性；如果该属性尚不存在，自动赋值会创建该属性。
- en: 'Just like using variables, you can use properties in a calculation and assign
    the result back to the property. The next listing shows code updating a player’s
    properties:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用变量一样，你可以在计算中使用属性并将结果赋回属性。下一个代码清单显示了更新玩家属性的代码：
- en: '[PRE28]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 3.11\. Using a property in a calculation ([http://jsbin.com/cuboko/edit?js,console](http://jsbin.com/cuboko/edit?js,console))
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. 在计算中使用属性 ([http://jsbin.com/cuboko/edit?js,console](http://jsbin.com/cuboko/edit?js,console))
- en: '![](034fig02_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](034fig02_alt.jpg)'
- en: When you update the `score` property (in bold in the listing), JavaScript evaluates
    the right side of the assignment first. Because `player1.score` is `0`, the expression
    becomes `0 + 50`, which is `50`. JavaScript then assigns that value to the left
    side, that is, back to the `score` property. So, you update `player1.score` from
    `0` to `50`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新 `score` 属性（列表中加粗），JavaScript 首先评估赋值右侧的表达式。因为 `player1.score` 是 `0`，表达式变为
    `0 + 50`，结果是 `50`。然后 JavaScript 将该值赋给左侧，即回到 `score` 属性。所以，你将 `player1.score` 从
    `0` 更新到 `50`。
- en: 3.5\. Further examples
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 进一步示例
- en: Although developing *The Crypt* program gives you an ongoing context for introducing
    and discussing new concepts, a broader range of examples will help to deepen your
    understanding of the different ideas presented. You can also revisit some of these
    examples throughout the book to apply fresh techniques as you master them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *The Crypt* 程序的开发为你提供了一个持续引入和讨论新概念的背景，但更广泛的示例将有助于加深你对所提出不同想法的理解。你还可以在整本书中回顾一些这些示例，随着你掌握这些技术，应用新的技巧。
- en: The examples all use curly braces to create an object and then assign the object
    to a variable created with the `var` keyword, in a single step.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都使用花括号创建一个对象，然后通过使用 `var` 关键字创建的变量将对象赋值，这是一个步骤。
- en: 3.5.1\. Writing a blog
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. 编写博客
- en: A blog is made up of blog posts. It would be good to have more information about
    each author, to be able to tag posts with keywords, and to add comments to each
    post. For now, here’s a minimal object to represent a single post.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客由博客文章组成。了解每个作者的更多信息，能够用关键词标记文章，并为每篇文章添加评论，将是有益的。现在，这里有一个表示单个文章的最小对象。
- en: Listing 3.12\. A blog post ([http://jsbin.com/jiculu/edit?js,console](http://jsbin.com/jiculu/edit?js,console))
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 一篇博客文章 ([http://jsbin.com/jiculu/edit?js,console](http://jsbin.com/jiculu/edit?js,console))
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 3.5.2\. Creating a calendar
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 创建日历
- en: Calendar events clearly involve dates. JavaScript does have a `Date` object,
    but you won’t be using it in the book. The next listing represents dates as strings
    in a specific format.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 日历事件显然涉及日期。JavaScript 确实有一个 `Date` 对象，但你在这本书中不会使用它。下一个列表展示了以特定格式表示日期的字符串。
- en: Listing 3.13\. A calendar event ([http://jsbin.com/viroho/edit?js,console](http://jsbin.com/viroho/edit?js,console))
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13\. 日历事件 ([http://jsbin.com/viroho/edit?js,console](http://jsbin.com/viroho/edit?js,console))
- en: '![](035fig01_alt.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图片](035fig01_alt.jpg)'
- en: Notice how to cope with the apostrophe in the `notes` property. A backslash
    character before the apostrophe stops JavaScript from seeing it as the end of
    the string. The backslash is called an escape character and won’t be shown.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何在 `notes` 属性中处理撇号。在撇号前的反斜杠阻止 JavaScript 将其视为字符串的结尾。这个反斜杠被称为转义字符，不会显示出来。
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use the escape character to display double quotes when a string is already wrapped
    in double quotes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转义字符来显示字符串已用双引号包裹时的双引号。
- en: '[PRE31]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: JavaScript also uses the backslash escape character to specify special characters
    like tabs and new lines. You’ll see it in action throughout the book.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也使用反斜杠转义字符来指定特殊字符，如制表符和换行符。你将在整本书中看到它的实际应用。
- en: A calendar contains lots of event objects. In [chapter 9](kindle_split_017.html#ch09),
    you’ll see how to streamline the process of creating objects that all have a similar
    structure when you investigate constructor functions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 日历包含许多事件对象。在第 9 章 [kindle_split_017.html#ch09] 中，你将看到如何通过研究构造函数来简化创建具有相似结构对象的流程。
- en: 3.5.3\. What’s the weather like?
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3\. 天气如何？
- en: Online weather information services provide weather data you can use in your
    programs. The data is often formatted using JSON (JavaScript Object Notation—see
    [chapter 20](kindle_split_030.html#ch20)) that’s very similar to the objects you’ve
    been learning about in this chapter. The data can be quite detailed with many
    properties. The next listing shows a cut-down version of location data supplied
    by one of these services.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在线天气信息服务提供你可以用于程序中的天气数据。数据通常使用 JSON（JavaScript 对象表示法——见第 20 章 [kindle_split_030.html#ch20]）格式化，这与你在本章学习过的对象非常相似。数据可以非常详细，具有许多属性。下一个列表展示了这些服务之一提供的位置数据的简化版本。
- en: Listing 3.14\. Location for a weather app ([http://jsbin.com/diguhe/edit?js,console](http://jsbin.com/diguhe/edit?js,console))
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.14\. 天气应用的定位 ([http://jsbin.com/diguhe/edit?js,console](http://jsbin.com/diguhe/edit?js,console))
- en: '[PRE32]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The property keys are within double quotation marks. JavaScript is happy for
    you to wrap keys, the property names, in quotation marks, single or double, although
    you haven’t been doing that in the examples so far. In fact, quotation marks are
    required if the property name doesn’t satisfy the rules for valid variable names
    discussed in [chapter 2](kindle_split_010.html#ch02). You’ll take a more detailed
    look at working with such property names in [chapter 10](kindle_split_018.html#ch10).
    The JSON specification, which sets out how programs should transmit JavaScript
    object data as text across the internet, requires all keys to be in double quotation
    marks. Because it’s sometimes required, many programmers recommend that property
    names always be placed within quotation marks to avoid inconsistency and potential
    errors.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 属性键位于双引号内。JavaScript 允许你将键，即属性名，用引号括起来，无论是单引号还是双引号，尽管到目前为止你在示例中还没有这样做。实际上，如果属性名不满足[第2章](kindle_split_010.html#ch02)中讨论的有效变量名规则，则必须使用引号。你将在[第10章](kindle_split_018.html#ch10)中更详细地了解如何处理此类属性名。JSON规范，它规定了程序应该如何将JavaScript对象数据作为文本在互联网上传输，要求所有键都必须使用双引号。由于有时这是必需的，许多程序员建议始终将属性名放在引号内，以避免不一致和潜在的错误。
- en: This example also lines up the colons in the key-value pairs. Do you think that
    helps? Compare it to the other examples in this section. Are they easy to read
    and follow? You don’t have to rigidly stick to one style or the other, although
    it’s quite common for programmers to adopt particular stylistic habits over time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还使键值对中的冒号对齐。你认为这有帮助吗？将其与该节中的其他示例进行比较。它们是否易于阅读和跟随？你不必严格坚持一种风格或另一种风格，尽管程序员随着时间的推移采用特定的风格习惯是很常见的。
- en: 3.5.4\. The testing effect
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.4\. 测试效应
- en: A great way to learn is to test yourself often. A quiz app could represent its
    questions and answers as properties of objects like the one in the next listing.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一种很好的学习方法就是经常自我测试。一个测验应用可以将其问题和答案表示为类似下一个列表中的对象属性。
- en: Listing 3.15\. A question and answer for a quiz app ([http://jsbin.com/damoto/edit?js,console](http://jsbin.com/damoto/edit?js,console))
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.15\. 测验应用的问题和答案([http://jsbin.com/damoto/edit?js,console](http://jsbin.com/damoto/edit?js,console))
- en: '[PRE33]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A quiz app is likely to include a small set of question types. [Listing 3.15](#ch03ex15)
    is an example of a multiple-choice question type. Each type of question would
    have a fixed form of presentation. Templates are a great way of presenting copies
    of similarly structured data, and we’ll look at them in more detail in [chapter
    19](kindle_split_029.html#ch19).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 测验应用可能包含一小套问题类型。[列表3.15](#ch03ex15)是多项选择题类型的一个示例。每种问题类型都会有固定的展示形式。模板是展示类似结构数据的副本的好方法，我们将在[第19章](kindle_split_029.html#ch19)中更详细地探讨它们。
- en: 3.5.5\. Create your own
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.5\. 创建你自己的
- en: Think of some programs you’d like to create. What kinds of objects could you
    design to represent entities in the program? Head to JS Bin and have a go at building
    objects and displaying properties on the console. Maybe share your creations or
    ask any questions they inspire over on the *Get Programming with JavaScript* forum
    at [https://forums.manning.com/forums/get-programming-with-javascript](https://forums.manning.com/forums/get-programming-with-javascript).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你想要创建的程序。你可以设计哪些对象来表示程序中的实体？前往JS Bin，尝试构建对象并在控制台显示属性。也许你可以分享你的创作或在该论坛上提出由它们激发的任何问题，该论坛位于[https://forums.manning.com/forums/get-programming-with-javascript](https://forums.manning.com/forums/get-programming-with-javascript)。
- en: 3.6\. The Crypt—a player object
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 密码学——玩家对象
- en: You’ll now apply your knowledge of JavaScript objects to *The Crypt*. [Figure
    3.5](#ch03fig05) shows where the focus of this section, a player object, fits
    into the overall structure of our ongoing game example.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将应用你对JavaScript对象的了解来应用到《密码学》中。[图3.5](#ch03fig05)显示了本节重点，即玩家对象，在我们正在进行的游戏示例的整体结构中的位置。
- en: Figure 3.5\. Elements in *The Crypt*
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 《密码学》中的元素
- en: '![](03fig05_alt.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: 'In [chapter 2](kindle_split_010.html#ch02), you considered the kind of information
    you need to store for players in *The Crypt*. For a single player, you start off
    with variables like these:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_010.html#ch02)中，你考虑了在《密码学》中为玩家存储的信息类型。对于单个玩家，你开始时可以使用这些变量：
- en: '[PRE34]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You then need to replicate those variables for each player in the game, maybe
    by using variable prefixes like `player1Name`, `player2Name`, and so on.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要为游戏中的每个玩家复制这些变量，可能通过使用变量前缀如`player1Name`、`player2Name`等。
- en: 'Clearly, it’s much neater to use JavaScript objects as a way of grouping all
    of the information about a single player. [Listing 3.16](#ch03ex16) shows how
    you can represent a player as an object and display some of their properties on
    the console. The output is as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用JavaScript对象作为组织单个玩家所有信息的手段要整洁得多。[列表3.16](#ch03ex16)展示了如何将玩家表示为一个对象，并在控制台上显示一些属性。输出如下：
- en: '[PRE35]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Listing 3.16\. A player object ([http://jsbin.com/qelene/edit?js,console](http://jsbin.com/qelene/edit?js,console))
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.16\. 玩家对象([http://jsbin.com/qelene/edit?js,console](http://jsbin.com/qelene/edit?js,console))
- en: '[PRE36]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last four lines of the listing are just for displaying player information.
    Having to repeat those lines of code every time you want to display a player’s
    information seems a little tedious. It would be great to be able to write the
    lines of code once and then call them up on demand.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后四行只是为了显示玩家信息。每次你想显示玩家信息时都要重复这些代码行似乎有点繁琐。如果能写一次代码，然后按需调用它们，那就太好了。
- en: You’re in luck! JavaScript lets you define *functions* to execute blocks of
    code whenever you need them. Functions are very powerful and will help streamline
    the display of player properties and the creation of multiple player objects.
    You’ll take a really detailed look at functions over the next four chapters.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你很幸运！JavaScript允许你定义*函数*，以便在需要时执行代码块。函数非常强大，将有助于简化玩家属性显示和多个玩家对象的创建。在接下来的四章中，你将深入了解函数。
- en: 3.7\. Summary
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. 概述
- en: Group related variables as properties of an object.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相关的变量作为对象的属性分组。
- en: 'Define objects as collections of comma-separated properties between curly braces:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用花括号定义对象，属性之间用逗号分隔：
- en: '[PRE37]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For each property use a key-value pair, with key and value separated by a colon:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个属性，使用键值对，键和值之间用冒号分隔：
- en: '[PRE38]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Access property values by using dot notation. If the object is assigned to
    a variable, join the property name to the variable name with a dot:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点符号访问属性值。如果对象被分配给一个变量，则使用点将属性名与变量名连接起来：
- en: '[PRE39]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use properties in expressions just as you would variables:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表达式中使用属性，就像使用变量一样：
- en: '[PRE40]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Assign values to properties using the assignment operator, `=`:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用赋值运算符`=`为属性赋值：
- en: '[PRE41]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add new properties to existing objects whenever you want:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要时随时向现有对象添加新属性：
- en: '[PRE42]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Chapter 4\. Functions: code on demand'
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 函数：按需执行代码
- en: '***This chapter covers***'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Organizing instructions with functions
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数组织指令
- en: Defining a function—specifying code to be executed on demand
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数——指定按需执行的代码
- en: Calling a function—executing code on demand
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数——按需执行代码
- en: Reducing repetition in code
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码中的重复
- en: Making programs easier to read and update
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使程序更容易阅读和更新
- en: One of the main themes of *Get Programming with JavaScript* is managing complexity
    through good organization. In [chapter 2](kindle_split_010.html#ch02), you stored
    information in variables and saw how choosing good names for those variables helps
    you understand their purpose in a program. In [chapter 3](kindle_split_011.html#ch03),
    you grouped variables as properties of objects. You can focus on objects as a
    whole or drill down into the details when needed. In this chapter you take a look
    at another important method for organizing code and avoiding repetition, the function.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 《用JavaScript编程入门》的主要主题之一是通过良好的组织来管理复杂性。在第2章中，你将信息存储在变量中，并看到为这些变量选择好名字如何帮助你理解它们在程序中的作用。在第3章中，你将变量作为对象的属性分组。你可以专注于整个对象，或者当需要时深入细节。在本章中，你将了解另一种重要的组织代码和避免重复的方法，即函数。
- en: 4.1\. Noticing repetition
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 注意重复
- en: As the programs you write become longer and more complex, you find yourself
    repeating similar sections of code with only slight differences. Common tasks,
    like displaying text, animating an image, or saving to a database, may need to
    be performed often. You need to notice these recurring bits of code; they’re prime
    function fodder.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你编写的程序变得越来越长和复杂，你会发现自己在重复类似的代码块，只有细微的差异。常见的任务，如显示文本、动画图像或保存到数据库，可能需要经常执行。你需要注意到这些重复的代码片段；它们是函数的理想选择。
- en: A *function* is a way of writing code once but using it many times. [Section
    4.2](#ch04lev1sec2) looks at how to create functions. This section explores a
    couple of examples of JavaScript repeated.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是一种编写一次代码但多次使用的方法。[第4.2节](#ch04lev1sec2)探讨了如何创建函数。本节探讨了JavaScript重复的一些示例。'
- en: 4.1.1\. Displaying object properties as text
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 以文本形式显示对象属性
- en: Programs use objects and variables to store all kinds of information—profiles,
    posts, documents, and photos—you name it and someone has stored it on a computer
    somewhere. A common task is to display that information to the user. Say you have
    some objects representing movies and need to display the information about each
    movie on the console. The kind of output expected is shown in [figure 4.1](#ch04fig01).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用对象和变量来存储各种信息——个人资料、帖子、文档和照片——你叫什么，就有人在某处将其存储在计算机上。一个常见的任务是将这些信息显示给用户。比如说，你有一些代表电影的对象，需要将每部电影的详细信息显示在控制台上。预期的输出类型如图
    4.1 所示。
- en: Figure 4.1\. Movie information shown on the console in JS Bin
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 在 JS Bin 控制台上显示的电影信息
- en: '![](04fig01_alt.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01_alt.jpg)'
- en: As you can see in the following listing, the code required to create the output
    in [figure 4.1](#ch04fig01) includes five calls to `console.log`. And that’s just
    for one movie.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在下面的列表中可以看到的，创建图 4.1 中输出所需的代码包括对 `console.log` 的五次调用。而这只是针对一部电影。
- en: Listing 4.1\. Displaying an object’s properties on the console ([http://jsbin.com/besudi/edit?js,console](http://jsbin.com/besudi/edit?js,console))
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 在控制台上显示对象的属性 ([http://jsbin.com/besudi/edit?js,console](http://jsbin.com/besudi/edit?js,console))
- en: '![](041fig01_alt.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](041fig01_alt.jpg)'
- en: If you have to write those five lines of code every time you want to display
    movie information and for every movie, that’s going to get pretty repetitive.
    And if you then decide to change the information displayed, you’ll have to go
    through all the places where it appears in the code and make sure it’s changed
    consistently.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你每次想要显示电影信息，并且对于每部电影，都必须编写这五行代码，那么这将会变得相当重复。而且，如果你决定更改显示的信息，你将不得不遍历代码中所有出现的地方，并确保它们被一致地更改。
- en: The next listing shows the code repeated for three different movies.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了为三部不同电影重复的代码。
- en: Listing 4.2\. Displaying information from similar objects ([http://jsbin.com/gewegi/edit?js,console](http://jsbin.com/gewegi/edit?js,console))
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 显示类似对象的信息 ([http://jsbin.com/gewegi/edit?js,console](http://jsbin.com/gewegi/edit?js,console))
- en: '[PRE43]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There could be many more than three movies and a number of places where the
    information needs to be displayed. If you later need to change the word *information*
    to *info*, you’ll have to make sure you find all the places it’s used.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有超过三部电影，以及需要显示信息的地方。如果你后来需要将单词 *information* 更改为 *info*，你必须确保找到所有使用它的地方。
- en: The three blocks of five statements are almost identical. All that varies is
    which movie’s properties are being displayed. It would be great to be able to
    define one block of statements and ask JavaScript to use that block whenever needed.
    That’s what functions are for!
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 三个包含五个语句的代码块几乎完全相同。唯一不同的是显示的是哪部电影属性。如果能定义一个语句块，并让 JavaScript 在需要时使用该块，那就太好了。这正是函数的作用！
- en: The next section has one more example of repetitive code. (Don’t worry, we’ll
    get to functions before the examples get too repetitive!)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分有一个更多重复代码的例子。（别担心，在例子变得过于重复之前，我们会接触到函数！）
- en: 4.1.2\. Adding tax and displaying a summary
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 添加税费并显示摘要
- en: A simple task like adding tax to a price is the kind of thing that happens again
    and again. You calculate the tax and add it to the price to give a total cost.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 像给价格加税这样的简单任务会反复发生。你计算税费并将其加到价格上，以得到总成本。
- en: '[PRE44]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following listing shows a program to add tax for three different transactions.
    The two operators, `*` and `/`, perform multiplication and division, respectively.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个为三个不同交易添加税费的程序。两个运算符 `*` 和 `/` 分别执行乘法和除法。
- en: Listing 4.3\. Adding tax to find the total cost ([http://jsbin.com/kawocu/edit?js,console](http://jsbin.com/kawocu/edit?js,console))
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 添加税费以找到总成本 ([http://jsbin.com/kawocu/edit?js,console](http://jsbin.com/kawocu/edit?js,console))
- en: '![](ch04ex03-0.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex03-0.jpg)'
- en: '![](ch04ex03-1.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex03-1.jpg)'
- en: Wow! That’s a riot of repetition. As well as the blocks of `console.log` lines,
    you repeat the structure of the calculations. It’s essentially the same code every
    time you want to perform the calculation. Rest assured, you’ll learn a much better
    way to write this program. Enter the function!
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这真是重复得令人发狂。除了 `console.log` 的代码块外，你还在重复计算的结构。每次你想执行计算时，本质上都是相同的代码。放心，你将学会一种更好的编写此程序的方法。进入函数的世界吧！
- en: 4.2\. Defining and calling functions
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 定义和调用函数
- en: Just as an object is a collection of properties, a function is a collection
    of statements or instructions. Functions help you avoid repetition and make your
    code more organized and easier to update and maintain. Well-named functions should
    also make your programs easier to follow. If you find your functions are used
    a lot in a program and would be useful in other programs too, you can create libraries
    of helpful functions to include in other projects.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 正如对象是一系列属性的集合一样，函数是一系列语句或指令的集合。函数帮助你避免重复，使你的代码更加组织化，更容易更新和维护。命名良好的函数也应该使你的程序更容易理解。如果你发现你的函数在程序中被大量使用，并且在其他程序中也有用，你可以创建包含在其他项目中的有用函数库。
- en: 'In the previous section you saw two examples of programs where blocks of code
    with the same structure were repeated. To reduce the code bloat you want to replace
    those blocks with something like the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了两个程序的例子，其中具有相同结构的代码块被重复使用。为了减少代码膨胀，你想要用类似以下内容替换那些代码块：
- en: '[PRE45]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The two functions, `showMovieInfo` and `showCostBreakdown`, should produce the
    same output as the code blocks in [listings 4.2](#ch04ex02) and [4.3](#ch04ex03),
    and you should be able to use them again and again, whenever you want. Let’s see
    how such code-on-demand magic is conjured.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数，`showMovieInfo`和`showCostBreakdown`，应该产生与[列表 4.2](#ch04ex02)和[4.3](#ch04ex03)中的代码块相同的输出，你应该能够反复使用它们。让我们看看这种按需代码魔法的实现方式。
- en: 4.2.1\. Defining new functions
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 定义新函数
- en: 'Define a function by using the following pieces, as shown in [figure 4.2](#ch04fig02):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下部分定义函数，如图 4.2 所示：
- en: Figure 4.2\. The pieces of a function definition
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 函数定义的各个部分
- en: '![](04fig02_alt.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig02_alt.jpg)'
- en: The `function` keyword
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`关键字'
- en: Parentheses, `()`
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号，`()`
- en: A code block between curly braces, `{}`
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号之间的代码块，`{}`
- en: The code block contains the list of instructions you’d like to execute whenever
    you use the function. The list of instructions is also called the *function body*.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块包含了你每次使用函数时想要执行的指令列表。这个指令列表也被称为*函数体*。
- en: 'It’s common to see function definitions set out like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的各个部分通常是这样安排的：
- en: '[PRE46]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once you’ve defined a function, you can assign it to a variable, just like any
    value. The next listing defines a function to display “Hello World!” on the console
    and assigns the function to the variable `sayHello`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了一个函数，你可以像任何值一样将其赋值给变量。接下来的列表定义了一个函数，用于在控制台显示“Hello World!”，并将该函数赋值给变量`sayHello`。
- en: Listing 4.4\. A simple function definition and assignment ([http://jsbin.com/tehixo/edit?js,console](http://jsbin.com/tehixo/edit?js,console))
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 一个简单的函数定义和赋值（[http://jsbin.com/tehixo/edit?js,console](http://jsbin.com/tehixo/edit?js,console)）
- en: '![](044fig01_alt.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](044fig01_alt.jpg)'
- en: 'It’s easy to see the different pieces that make up the function definition
    in [listing 4.4](#ch04ex04): the `function` keyword, the empty parentheses, and
    the code block for the function body. The function body has only a single statement,
    `console.log(`“`Hello World!`”`);`. At this point, you have only *defined* the
    function, ready for use later. The code in the function body won’t be executed
    until you run the function—you’ll see how to do that in [section 4.2.3](#ch04lev2sec5).'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 4.4](#ch04ex04)中很容易看到组成函数定义的不同部分：`function`关键字、空括号和函数体的代码块。函数体只有一个语句，`console.log(`“`Hello
    World!`”`);`。到目前为止，你只*定义*了函数，准备以后使用。函数体内的代码在运行函数之前不会执行——你将在[4.2.3 节](#ch04lev2sec5)中看到如何执行它。
- en: The following listing shows a couple more examples of defining functions and
    then assigning them to variables.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了更多定义函数并将它们赋值给变量的例子。
- en: Listing 4.5\. Two more function definitions and assignments ([http://jsbin.com/xezani/edit?js,console](http://jsbin.com/xezani/edit?js,console))
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 两个额外的函数定义和赋值（[http://jsbin.com/xezani/edit?js,console](http://jsbin.com/xezani/edit?js,console)）
- en: '![](045fig01_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](045fig01_alt.jpg)'
- en: 4.2.2\. Function expressions and function declarations
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 函数表达式和函数声明
- en: In the previous examples you’ve been using *function expressions* to define
    functions and assign them to variables with the assignment operator.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，你一直使用*函数表达式*来定义函数并将它们通过赋值操作符赋值给变量。
- en: '[PRE47]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can also use an alternative syntax, called a *function declaration*. Rather
    than defining the function and then assigning it to a variable, you can declare
    a name for the function as part of the definition.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一种称为*函数声明*的替代语法。而不是先定义函数然后将其赋值给变量，你可以在定义函数时作为定义的一部分声明函数的名称。
- en: '[PRE48]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can treat the two ways of defining functions as equivalent; there are some
    subtle differences but we won’t go into them here. *Get Programming with JavaScript*
    uses function expressions throughout [parts 1](kindle_split_008.html#part01) and
    [2](kindle_split_019.html#part02) to highlight the similarities between creating
    and assigning different values, including objects, functions, and arrays.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将定义函数的两种方式视为等效；有一些细微的差别，但在这里我们不会深入探讨。*用 JavaScript 编程入门* 在 [第 1 部分](kindle_split_008.html#part01)
    和 [第 2 部分](kindle_split_019.html#part02) 中始终使用函数表达式，以突出创建和分配不同值之间的相似性，包括对象、函数和数组。
- en: '[PRE49]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Don’t worry about the function declaration syntax for now or even about the
    difference between declarations and expressions. You’ll be much more comfortable
    with functions when you meet the declaration syntax again in [part 3](kindle_split_026.html#part03).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心函数声明语法，甚至不必担心声明和表达式之间的区别。当你再次在 [第 3 部分](kindle_split_026.html#part03)
    遇到声明语法时，你会对函数有更多的了解。
- en: Just defining the functions isn’t enough to make “Hello World!” appear on the
    console, calculate the total, or display the menu. You need a way to tell the
    function to execute its list of instructions.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 仅定义函数不足以在控制台显示“Hello World!”，计算总和或显示菜单。你需要一种方法告诉函数执行其指令列表。
- en: 4.2.3\. Using functions
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3\. 使用函数
- en: Once you’ve assigned a function to a variable, whenever you want to execute
    the statements in the function body, you write the variable name followed by parentheses,
    `()`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将一个函数赋值给一个变量，每次你想执行函数体内的语句时，你只需写出变量名后跟括号，`()`。
- en: '[PRE50]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Other names for running the function are *calling* the function or *invoking*
    the function.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的其他名称是 *调用* 函数或 *调用* 函数。
- en: 'In [listing 4.6](#ch04ex06), you call the `sayHello` function three times.
    It displays the string `"Hello World!"` three times, like this:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.6](#ch04ex06) 中，你调用了 `sayHello` 函数三次。它显示了字符串 `"Hello World!"` 三次，如下所示：
- en: '[PRE51]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Listing 4.6\. Calling the sayHello function three times ([http://jsbin.com/vozuxa/edit?js,console](http://jsbin.com/vozuxa/edit?js,console))
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6\. 调用 sayHello 函数三次 ([http://jsbin.com/vozuxa/edit?js,console](http://jsbin.com/vozuxa/edit?js,console))
- en: '![](046fig01_alt.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](046fig01_alt.jpg)'
- en: 'The next listing uses the `findTotal` function to update the `result` variable.
    It then displays the whole calculation on the console:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表使用 `findTotal` 函数更新 `result` 变量。然后它在控制台上显示整个计算：
- en: '[PRE52]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Listing 4.7\. Using the findTotal function to display a calculation ([http://jsbin.com/hefuwa/edit?js,console](http://jsbin.com/hefuwa/edit?js,console))
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 使用 findTotal 函数显示计算 ([http://jsbin.com/hefuwa/edit?js,console](http://jsbin.com/hefuwa/edit?js,console))
- en: '[PRE53]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Listing 4.8](#ch04ex08) calls the `displayMenu` function to, well, display
    a menu. (These functions do exactly what they say on the tin!)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.8](#ch04ex08) 调用了 `displayMenu` 函数来，嗯，显示菜单。（这些函数确实做了它们所说的！）'
- en: '[PRE54]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Listing 4.8\. Displaying a menu ([http://jsbin.com/cujozo/edit?js,console](http://jsbin.com/cujozo/edit?js,console))
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 显示菜单 ([http://jsbin.com/cujozo/edit?js,console](http://jsbin.com/cujozo/edit?js,console))
- en: '[PRE55]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It may seem strange to use empty parentheses as the notation for calling a function.
    But, as you’ll see in [chapter 5](kindle_split_013.html#ch05), they’re not always
    empty ... *[cue mysterious music]*.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空括号作为调用函数的符号可能看起来有些奇怪。但，正如你将在 [第 5 章](kindle_split_013.html#ch05) 中看到的，它们并不总是空的
    ... *[神秘音乐提示]*。
- en: '|  |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: For those who like their terminology, the parentheses, `()`, added to the end
    of a variable when calling a function are called the *function invocation operator*
    or the *function call operator*.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些喜欢术语的人来说，当调用函数时添加到变量末尾的括号，`()`，被称为 *函数调用操作符* 或 *函数调用操作符*。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2.4\. Functions step by step
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4\. 逐步使用函数
- en: '[Table 4.1](#ch04table01) summarizes the steps used to define and call a function.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4.1](#ch04table01) 总结了定义和调用函数所使用的步骤。'
- en: Table 4.1\. Steps used to define and call a function
  id: totrans-485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. 定义和调用函数所使用的步骤
- en: '| Action | Code | Comments |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | 代码 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Declare a variable | var sayHello; | Sets aside the name for your use in
    the program. |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 声明一个变量 | var sayHello; | 为你在程序中使用保留名称。 |'
- en: '| Define a function | function () { console.log("Hello World!");'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '| 定义一个函数 | function () { console.log("Hello World!");'
- en: '} | The code in the function body is not executed at this point. |'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '} | 函数体内的代码在此点不会执行。 |'
- en: '| Assign to a variable | sayHello = function () { console.log("Hello World!");'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '| 赋值给变量 | sayHello = function () { console.log("Hello World!");'
- en: '}; | Assigning the function to a variable gives you a label you can use to
    call the function. |'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '}; | 将函数赋值给变量为你提供了一个可以用来调用函数的标签。|'
- en: '| Call the function | sayHello(); | The code in the function body is executed.
    |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 调用函数 | sayHello(); | 函数体内的代码将被执行。 |'
- en: '| Call the function again and again as needed | sayHello(); sayHello();'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '| 需要时重复调用函数 | sayHello(); sayHello();'
- en: sayHello(); | The code in the function body is executed every time the function
    is called. |
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: sayHello(); | 每次调用函数时，函数体内的代码都会被执行。|
- en: The second row in the table, Define a function, doesn’t usually occur on its
    own; you’re much more likely to define a function and assign it to a variable,
    as seen on the third row, Assign to a variable. (You’ll see in later chapters
    that you can assign function definitions as elements in arrays [lists] and pass
    them to and from other functions—they’re not always assigned to variables.)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的第二行，定义一个函数，通常不会单独出现；你更有可能定义一个函数并将其赋值给变量，就像第三行中看到的，赋值给变量。 (你将在后面的章节中看到，你可以将函数定义作为数组（列表）的元素赋值，并将它们传递给其他函数——它们并不总是赋值给变量。)
- en: 4.3\. Reducing repetition
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 减少重复
- en: In [listings 4.2](#ch04ex02) and [4.3](#ch04ex03) you saw the repeated blocks
    of code needed when you didn’t have functions at your disposal. It’s time to rein
    in those runaways, cut back those fast-growing weeds, put the kids on a diet,
    cap the spending—you get the picture; let’s reduce the repetition!
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.2](#ch04ex02) 和 [4.3](#ch04ex03) 中，你看到了在没有函数可用时所需的重复代码块。现在是时候控制这些失控的代码，修剪那些快速生长的杂草，让孩子们节食，限制开支——你明白我的意思；让我们减少重复！
- en: 4.3.1\. A function for displaying object properties as text
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 用于将对象属性显示为文本的函数
- en: Returning to the code from [listing 4.2](#ch04ex02), you streamline the display
    of movie information. Write the movie display code once, in a function, and simply
    call the function whenever it’s needed.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 [列表 4.2](#ch04ex02) 中的代码，你简化了电影信息的显示。将电影显示代码一次性写在函数中，并在需要时简单地调用该函数。
- en: Listing 4.9\. Using a function to display object properties ([http://jsbin.com/toqopo/edit?js,console](http://jsbin.com/toqopo/edit?js,console))
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 使用函数显示对象属性 ([http://jsbin.com/toqopo/edit?js,console](http://jsbin.com/toqopo/edit?js,console))
- en: '[PRE56]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The code assigns the new function to the `showMovieInfo` variable. Call the
    function by writing the variable name followed by parentheses, `showMovieInfo()`,
    as shown in the next listing. You should end up with the following output on the
    console, matching the aim seen way back in [figure 4.1](#ch04fig01).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将新函数赋值给 `showMovieInfo` 变量。通过编写变量名后跟括号，即 `showMovieInfo()` 来调用函数，如下一列表所示。你应在控制台上得到以下输出，与之前在
    [图 4.1](#ch04fig01) 中看到的预期目标相匹配。
- en: '[PRE57]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Listing 4.10\. Calling the showMovieInfo function ([http://jsbin.com/menebu/edit?js,console](http://jsbin.com/menebu/edit?js,console))
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 调用 showMovieInfo 函数 ([http://jsbin.com/menebu/edit?js,console](http://jsbin.com/menebu/edit?js,console))
- en: '![](049fig01_alt.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig01_alt.jpg)'
- en: With the `movie` variable, used by the `showMovieInfo` function, you can switch
    which movie’s information the function will use. [Listing 4.11](#ch04ex11) shows
    how to switch between movies. Information for three different movies is printed
    to the console.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `movie` 变量，该变量由 `showMovieInfo` 函数使用，你可以切换函数将使用哪部电影的信息。[列表 4.11](#ch04ex11)
    展示了如何在电影之间切换。三个不同电影的信息被打印到控制台上。
- en: '[PRE58]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Listing 4.11\. Using the same function with multiple objects ([http://jsbin.com/mavutu/edit?js,console](http://jsbin.com/mavutu/edit?js,console))
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 使用相同函数处理多个对象 ([http://jsbin.com/mavutu/edit?js,console](http://jsbin.com/mavutu/edit?js,console))
- en: '![](ch04ex11-0.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex11-0.jpg)'
- en: '![](ch04ex11-1.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex11-1.jpg)'
- en: 4.3.2\. Functions for adding tax and displaying a summary
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 添加税费和显示摘要的函数
- en: '[Listing 4.12](#ch04ex12) shows a function to add tax for sales and display
    a summary of each transaction. Most of the code that you need to repeat is in
    the two functions, `calculateTax` and `displaySale`. You call them for each sale
    object in turn. The output is shown here.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.12](#ch04ex12) 展示了一个用于为销售添加税费并显示每笔交易摘要的函数。你需要重复的大部分代码都在两个函数 `calculateTax`
    和 `displaySale` 中，你依次为每笔销售对象调用它们。输出结果如下所示。'
- en: '[PRE59]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As with all of the listings on JS Bin, there are “[Further Adventures](kindle_split_009.html#ch01lev2sec5)”
    below the program that suggest ways of exploring the code and building your understanding.
    In this case, one challenge is to reduce the repetition of the function calls;
    `calculateTax` and `display``Sale` are always called together. Although it’s good
    to have two different functions—they do different jobs—can you avoid having to
    call them both for each sale object? If you’re connected, click the link above
    [listing 4.12](#ch04ex12) to head to JS Bin now and embrace the adventure. If
    you’re reading a print copy of the book, away from technology, it’s paper and
    pencil for you! Solutions to most problems are on the *Get Programming with JavaScript*
    website at [www.room51.co.uk/books/getProgramming/listings.html](http://www.room51.co.uk/books/getProgramming/listings.html).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JS Bin 上的所有列表一样，在程序下方有 “[进一步冒险](kindle_split_009.html#ch01lev2sec5)” 的建议，这些建议可以帮助你探索代码并加深理解。在这种情况下，一个挑战是减少函数调用的重复；`calculateTax`
    和 `displaySale` 总是同时被调用。虽然有两个不同的函数——它们做不同的事情——但你能避免每次为每个 sale 对象都调用它们吗？如果你已经连接，点击上面的链接
    [列表 4.12](#ch04ex12) 现在前往 JS Bin 并开始冒险。如果你在远离技术的印刷版书籍中阅读，那么对你来说就是纸和笔！大多数问题的解决方案都可以在
    *Get Programming with JavaScript* 网站上找到，网址为 [www.room51.co.uk/books/getProgramming/listings.html](http://www.room51.co.uk/books/getProgramming/listings.html)。
- en: Listing 4.12\. Using functions to add and display tax ([http://jsbin.com/raqiri/edit?js,console](http://jsbin.com/raqiri/edit?js,console))
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 使用函数添加和显示税 ([http://jsbin.com/raqiri/edit?js,console](http://jsbin.com/raqiri/edit?js,console))
- en: '![](ch04ex12-0.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex12-0.jpg)'
- en: '![](ch04ex12-1.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex12-1.jpg)'
- en: The two functions use the `sale` variable in their definitions, accessing properties
    on the object, `sale.price`, `sale.taxRate`, and so on. The code in the function
    bodies won’t run until the program calls the two functions, by which time the
    program will have assigned one of the sale objects to the `sale` variable.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在其定义中使用了 `sale` 变量，访问对象上的属性，如 `sale.price`、`sale.taxRate` 等。函数体内的代码在程序调用这两个函数之前不会运行，到那时程序将已将一个
    sale 对象分配给 `sale` 变量。
- en: The function names `calculateTax` and `displaySale` help to make the program
    in [listing 4.12](#ch04ex12) easier to follow and understand. [Section 4.4](#ch04lev1sec4)
    investigates these ideas in more detail.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名 `calculateTax` 和 `displaySale` 有助于使 [列表 4.12](#ch04ex12) 中的程序更易于遵循和理解。[第
    4.4 节](#ch04lev1sec4) 更详细地探讨了这些想法。
- en: 4.4\. Making code easier to read and update
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 使代码更易于阅读和更新
- en: As your programs get longer and more complicated, you manage that complexity
    by breaking them into well-named objects and functions. Anyone reading your code
    can follow its flow and understand the purpose of the pieces and of the whole.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的程序变得越来越长和复杂，你通过将它们分解成命名良好的对象和函数来管理这种复杂性。任何阅读你的代码的人都可以跟随其流程并理解各个部分以及整体的目的。
- en: Take a look at the following code snippet; you should get a sense of what’s
    happening even if you don’t know the details of how the functions work.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段；即使你不了解函数如何工作的细节，你也应该能感受到正在发生的事情。
- en: '[PRE60]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Each function should have a single, clear purpose. If you need to investigate
    what a function does, you should be able to find it defined in one place. Let’s
    look at an example of updating a function.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都应该有一个单一、明确的目的。如果你需要调查一个函数的功能，你应该能够在一个地方找到它的定义。让我们看看更新一个函数的例子。
- en: 4.4.1\. Updating the showMovieInfo function
  id: totrans-526
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 更新 showMovieInfo 函数
- en: In [listing 4.11](#ch04ex11), you created a `showMovieInfo` function to display
    information about a movie object. It was great to be able to encapsulate the blocks
    of display code into a single function. But having the information for multiple
    movies squashed together on the console makes it hard to pick out individual facts
    about particular movies. It would be useful to add blank lines, making it easier
    to see each movie.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.11](#ch04ex11) 中，你创建了一个 `showMovieInfo` 函数来显示电影对象的信息。能够将显示代码块封装到一个函数中是非常棒的。但是，当多个电影的信息挤在一起在控制台上时，很难挑选出特定电影的个别事实。添加空白行将有助于更清楚地看到每个电影。
- en: '[PRE61]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because you have all of the display code inside your `showMovieInfo` function,
    you can head right there and add an extra call to `console.log` to create the
    blank line, as shown in the next listing. Your organization is already paying
    off!
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的显示代码都在 `showMovieInfo` 函数内部，你可以直接去那里添加一个额外的 `console.log` 调用来创建空白行，如下一个列表所示。你的组织工作已经开始显现成效了！
- en: Listing 4.13\. Updating your display function to add a blank line ([http://jsbin.com/cijini/edit?js,console](http://jsbin.com/cijini/edit?js,console))
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 更新你的显示函数以添加空白行 ([http://jsbin.com/cijini/edit?js,console](http://jsbin.com/cijini/edit?js,console))
- en: '![](053fig01_alt.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![图片](053fig01_alt.jpg)'
- en: So close! Because the JS Bin console wraps strings in speech marks, you don’t
    quite get your blank lines. You get empty quotation marks instead. But if you
    check the browser’s own console (see the online guide at [www.room51.co.uk/guides/browser-consoles.html](http://www.room51.co.uk/guides/browser-consoles.html)),
    you should see the blank lines expected, as shown in [figure 4.3](#ch04fig03).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 所以很接近！因为 JS Bin 控制台将字符串包裹在引号中，所以你并没有得到空白行。你得到的是空引号。但是如果你检查浏览器的自己的控制台（见在线指南[www.room51.co.uk/guides/browser-consoles.html](http://www.room51.co.uk/guides/browser-consoles.html)），你应该看到预期的空白行，如图
    4.3 所示。
- en: Figure 4.3\. JS Bin displays empty strings in quotation marks but the Safari
    browser doesn’t.
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. JS Bin 在引号中显示空字符串，但 Safari 浏览器不这样做。
- en: '![](04fig03_alt.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig03_alt.jpg)'
- en: If this example were part of a larger (maybe much larger) program and you didn’t
    have the player display logic safely nestled in a single function, you’d have
    to inspect all the code to find the lines where changes should be made. Text editors
    and development environments should have tools to help, but they’re not foolproof
    and your program could end up with coy corners of uncorrected code. You try it
    out and, to begin with, everything seems fine. Then later there’s running and,
    um, screaming. Avoid the nightmare—use functions.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子是更大（可能更大）程序的一部分，而你没有将玩家显示逻辑安全地封装在单个函数中，你就必须检查所有代码以找到应该进行更改的行。文本编辑器和开发环境应该有工具来帮助，但它们并不是万无一失的，你的程序可能会出现未修正的代码的隐蔽角落。你尝试一下，一开始，一切似乎都很好。然后后来有运行和，嗯，尖叫。避免噩梦——使用函数。
- en: 4.5\. The Crypt—displaying player information
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. The Crypt——显示玩家信息
- en: You’ll now apply your knowledge of JavaScript functions to *The Crypt*. [Figure
    4.4](#ch04fig04) shows where the focus of this section, showing player information
    by using functions, fits into the overall structure of our ongoing game example.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用你对 JavaScript 函数的知识到*The Crypt*。图 4.4 显示了本节重点，通过使用函数显示玩家信息，如何融入我们正在进行的游戏示例的整体结构。
- en: Figure 4.4\. Elements of *The Crypt*
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. *The Crypt* 的元素
- en: '![](04fig04_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig04_alt.jpg)'
- en: 'In [chapter 3](kindle_split_011.html#ch03) you saw how to group information
    about a player into a single JavaScript object. You create the object using curly
    braces and set the properties using key-value pairs, like this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](kindle_split_011.html#ch03)中，你看到了如何将有关玩家的信息组合成一个单一的 JavaScript 对象。你使用花括号创建对象，并使用键值对设置属性，如下所示：
- en: '[PRE62]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Once you assign the new object to the `player` variable, you can get the property
    values by using dot notation. Displaying information about the player involves
    logging properties to the console.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将新对象分配给`player`变量，你就可以通过点符号来获取属性值。显示玩家信息涉及到将属性记录到控制台。
- en: '[PRE63]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the game, you may have to display player info a number of times and for a
    number of players. You should use your new knowledge of functions to make the
    display of information more efficient; make it *code on demand*—code you can execute
    by calling a function.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你可能需要多次显示玩家信息，并且针对多个玩家。你应该使用你对函数的新知识来使信息显示更高效；使其*按需编码*——可以通过调用函数来执行的代码。
- en: 4.5.1\. A function to display player information
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1\. 显示玩家信息的函数
- en: 'The `showMovieInfo` function from [listing 4.13](#ch04ex13) looks like exactly
    the kind of function you need. Whereas `showMovieInfo` displays information about
    movies, [listing 4.14](#ch04ex14) shows a `showPlayerInfo` function doing a very
    similar job for players, producing the following output:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 来自列表 4.13([#ch04ex13](#ch04ex13))的`showMovieInfo`函数看起来正是你需要的那种函数。而`showMovieInfo`显示有关电影的信息，[列表
    4.14](#ch04ex14)显示了执行类似任务的`showPlayerInfo`函数，产生以下输出：
- en: '[PRE64]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Listing 4.14\. A function to display player information ([http://jsbin.com/mafade/edit?js,console](http://jsbin.com/mafade/edit?js,console))
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 显示玩家信息的函数 ([http://jsbin.com/mafade/edit?js,console](http://jsbin.com/mafade/edit?js,console))
- en: '![](ch04ex14-0.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex14-0.jpg)'
- en: '![](ch04ex14-1.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex14-1.jpg)'
- en: Excellent! That does the job. A single call to a function now displays player
    information. It’s a shame you have to keep assigning different players to the
    `player` variable to make it work; it would be better if you could somehow say
    to the function, “Show info for player1” or “Show info for player2.” Well, passing
    information to and from functions will be investigated in detail over the next
    three chapters. Flexibility, reusability, efficiency, here we come!
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这完成了任务。现在只需调用一次函数就能显示玩家信息。遗憾的是，你必须不断将不同的玩家分配给`player`变量才能使其工作；如果能以某种方式告诉函数“显示player1的信息”或“显示player2的信息”会更好。好吧，在接下来的三章中，我们将详细探讨如何在函数之间传递信息。灵活性、可重用性、效率，我们来了！
- en: 4.6\. Summary
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 概述
- en: A function is a block of code that you write once but use many times. It should
    have a clear, single purpose.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是一段你只编写一次但多次使用的代码块。它应该有一个清晰、单一的目的。
- en: 'You *define* a function by using the function keyword, parentheses, and a function
    body in a code block between curly braces:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用函数关键字、括号和花括号中的函数体来定义一个函数：
- en: '[PRE65]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You *assign* the function to a variable with the equals symbol, `=` , also
    known as the assignment operator:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用等号`=`将函数分配给一个变量，这也就是所谓的赋值运算符：
- en: '[PRE66]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once a function is assigned to a variable, you *call* or *invoke* the function
    by adding parentheses to the end of the variable name:'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦将函数分配给变量，你就可以通过在变量名末尾添加括号来调用或调用该函数：
- en: '[PRE67]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Be on the lookout for repetition; sections of code with the same structure and
    only slight changes in values or variables used. Move repeated code into a function.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意重复；具有相同结构且仅在使用值或变量上略有变化的代码段。将重复的代码移动到函数中。
- en: Give functions clear names that communicate their purpose. Use the functions
    to organize your code, making your programs easier to follow and maintain.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给函数起一个清晰的名字，以传达其目的。使用函数来组织你的代码，使你的程序更容易遵循和维护。
- en: 'Chapter 5\. Arguments: passing data to functions'
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 参数：向函数传递数据
- en: '***This chapter covers***'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章内容涵盖***'
- en: Defining functions with parameters, ready to accept data
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数定义函数，准备接受数据
- en: Calling functions, passing in data with arguments
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数，通过参数传递数据
- en: Functions are an essential means of organization; you write them once and use
    them many times. But so far, your functions have been tied to the values of variables
    around them. It’s time to set your functions free, letting them name their own
    variables and passing them the data they need.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是组织代码的一种基本手段；你只需编写一次，然后多次使用。但到目前为止，你的函数都绑定在周围的变量值上。是时候让你的函数自由了，让它们命名自己的变量，并将它们需要的数据传递给它们。
- en: 5.1\. Function reuse and versatility
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 函数重用和多功能性
- en: The functions you’ve used up to now have relied on variables declared and assigned
    values elsewhere in the program. In the following listing, the `showMessage` function
    relies on a variable called `message`, declared outside the function definition.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止使用的函数都依赖于在程序其他地方声明的并赋予值的变量。在下面的列表中，`showMessage`函数依赖于一个名为`message`的变量，该变量在函数定义外部声明。
- en: Listing 5.1\. Relying on a variable outside the function ([http://jsbin.com/taqusi/edit?js,console](http://jsbin.com/taqusi/edit?js,console))
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 依赖于函数外部的变量([http://jsbin.com/taqusi/edit?js,console](http://jsbin.com/taqusi/edit?js,console))
- en: '![](058fig01_alt.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![图片](058fig01_alt.jpg)'
- en: 'In the `showMessage` function definition, you use a variable called `message`.
    The `message` variable has to exist for the function to do its job. If you change
    the name of the variable, the function breaks. If `message` is renamed `msg`,
    as shown in the next listing, and the program is run on JS Bin, you should get
    an error something like this: “Reference error: Can’t find variable: message.”
    (Different browsers may give slightly different error messages.)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在`showMessage`函数定义中，你使用了一个名为`message`的变量。`message`变量必须存在，函数才能执行其任务。如果你更改变量的名称，函数就会出错。如果`message`被重命名为`msg`，如下一列表所示，并在JS
    Bin上运行程序，你应该得到一个类似这样的错误：“引用错误：找不到变量：message。”（不同的浏览器可能会给出略有不同的错误信息。）
- en: Listing 5.2\. Breaking a function by changing a variable name ([http://jsbin.com/yaresa/edit?js,console](http://jsbin.com/yaresa/edit?js,console))
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2\. 通过更改变量名来分解函数([http://jsbin.com/yaresa/edit?js,console](http://jsbin.com/yaresa/edit?js,console))
- en: '![](058fig02_alt.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](058fig02_alt.jpg)'
- en: The instructions in the function body *can* use variables defined elsewhere
    in your program but that couples the function with the external variable; a better
    practice is to pass the information a function needs to the function when it’s
    called. This helps avoid the variables a function needs being misnamed, missing,
    deleted, or changed by other parts of your program and makes it easier to follow
    the flow of the program and spot mistakes if they occur.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体内的指令可以使用你在程序其他地方定义的变量，但这会将函数与外部变量耦合；更好的做法是在调用函数时将函数所需的信息传递给函数。这有助于避免函数所需的变量被误命名、遗漏、删除或被程序的其他部分更改，并使跟踪程序流程和发现错误变得更加容易。
- en: We don’t want arrogant Rock God functions demanding particular variables in
    their dressing rooms before they’ll perform; we want easy-going functions that
    are reliable and happy to strut their stuff wherever they are in the world. By
    decoupling functions from variables, you make the functions more portable; the
    function definitions can be moved to other parts of your program or be reused
    in other programs or code libraries, without causing havoc and throwing errors.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望傲慢的摇滚之神函数在表演前在他们的化妆室里要求特定的变量；我们希望随和的函数，它们可靠且愿意在世界任何地方展示自己的才华。通过将函数与变量解耦，你使函数更易于携带；函数定义可以被移动到程序的其他部分，或者在其他程序或代码库中重用，而不会造成混乱和引发错误。
- en: So, how is this decoupling achieved?
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这种解耦是如何实现的呢？
- en: 5.2\. Passing information to functions
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 将信息传递给函数
- en: 'Passing information to functions is achieved in two stages: when you define
    the function and when you call the function:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 向函数传递信息分为两个阶段：当你定义函数时和当你调用函数时：
- en: '**1**.  When you *define* the function, you set up variable names, called *parameters*,
    ready for when you call the function.'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 当你*定义*函数时，你设置变量名称，称为*参数*，以便在调用函数时使用。'
- en: '**2**.  When you *call* the function, you include data to assign to the variables
    you named in step 1.'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 当你*调用*函数时，你包括数据以分配给你在步骤1中命名的变量。'
- en: You’ll look at a number of examples over the course of this chapter (and there
    are plenty more throughout the rest of the book), but there’s nothing like practice
    to make permanent. The *Further Adventures* section for each code listing on JS
    Bin should get you started.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将看到许多示例（书中其余部分还有很多），但没有什么比实践更能使知识变得牢固。JS Bin上每个代码列表的*进一步冒险*部分应该能帮助你开始。
- en: 5.2.1\. Passing one argument to a function
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1\. 向函数传递一个参数
- en: 'It’s time to make use of those empty parentheses in your function definitions!
    To pass information to functions when you call them, include it between the parentheses,
    like this:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在你的函数定义中使用那些空括号了！当你调用函数时传递信息，就像这样放在括号之间：
- en: '[PRE68]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You pass each of the four functions some information for their code to use.
    Each value included in the parentheses is called an *argument*. Each of the four
    functions shown here includes a single argument. The arguments are “It’s full
    of stars!”, “Kandra”, “The Hobbit”, and 12.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你为每个四个函数传递了一些信息供其代码使用。括号中包含的每个值都称为*参数*。这里显示的四个函数都包含一个参数。这些参数是“它充满了星星！”，“Kandra”，“霍比特人”，和12。
- en: To use the information in the parentheses, you need to make the functions ready
    to accept it. You add a *parameter* when you define the function. The parameter
    shows that the function expects you to give it some information when you call
    it, as shown in [figure 5.1](#ch05fig01).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用括号中的信息，你需要使函数准备好接受它。你定义函数时添加一个*参数*。参数表明函数期望你在调用它时提供一些信息，如图[5.1](#ch05fig01)所示。
- en: Figure 5.1\. Including a parameter in the parentheses when defining a function
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 在定义函数时在括号中包含参数
- en: '![](05fig01.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig01.jpg)'
- en: 'For the four functions in the previous example, the function definitions could
    be something like this:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的四个函数，函数定义可能如下所示：
- en: '[PRE69]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Each function definition includes a parameter, shown in bold. The parameter
    is a variable that you can use only inside the function body.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数定义都包含一个参数，用粗体显示。该参数是一个只能在函数体内使用的变量。
- en: 'Let’s update the `showMessage` function from [listing 5.1](#ch05ex01) to accept
    a message, rather than relying on an external variable. When defining the function,
    include a `message` parameter. The `message` parameter is available as a variable
    in the function body. Now when you call the function, you pass the message to
    display in parentheses, `showMessage("It''s full of stars!")`. The function adds
    extra text and displays the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 [列表 5.1](#ch05ex01) 中的 `showMessage` 函数，使其接受一个消息，而不是依赖于外部变量。在定义函数时，包括一个
    `message` 参数。`message` 参数作为变量在函数体内可用。现在当你调用函数时，你将要在括号中传递的消息传递给函数，即 `showMessage("It's
    full of stars!")`。函数添加额外的文本并显示以下内容：
- en: '[PRE70]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Listing 5.3\. Passing information to a function ([http://jsbin.com/xucemu/edit?js,console](http://jsbin.com/xucemu/edit?js,console))
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 将信息传递给函数 ([http://jsbin.com/xucemu/edit?js,console](http://jsbin.com/xucemu/edit?js,console))
- en: '![](060fig01_alt.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](060fig01_alt.jpg)'
- en: 'When you call the `showMessage` function at the end of [listing 5.3](#ch05ex03),
    you include the string “It’s full of stars!” in the parentheses. A value included
    in the function call parentheses like this is called an *argument*. The program
    assigns the argument to the variable named `message`. The function then uses the
    `message` variable to generate the string that’s logged to the console, `"The
    message is: It''s full of stars!"`'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '当你在 [列表 5.3](#ch05ex03) 的末尾调用 `showMessage` 函数时，你将字符串 “It’s full of stars!”
    包含在括号中。像这样包含在函数调用括号中的值称为 *参数*。程序将参数分配给名为 `message` 的变量。然后函数使用 `message` 变量生成记录到控制台的字符串，即
    `"The message is: It''s full of stars!"`'
- en: '[Table 5.1](#ch05table01) lists the steps involved in declaring a function
    with parameters and then calling it with different arguments.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5.1](#ch05table01) 列出了声明带参数的函数以及用不同参数调用它的步骤。'
- en: Table 5.1\. Steps used to define and call a function, passing it data
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 定义和调用函数以及传递数据的步骤
- en: '| Action | Code | Comments |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 代码 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Declare a variable | var showMessage; | Sets aside the name for use in the
    program. |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| 声明一个变量 | var showMessage; | 为程序中的使用预留名称。|'
- en: '| Define a function with a parameter | function (message) {'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '| 带参数定义函数 | function (message) {'
- en: '} | Sets aside a variable name, message, for use in the function body. |'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '} | 预留变量名，message，用于函数体内。|'
- en: '| Use the parameter | function (message) { console.log(message);'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '| 使用参数 | function (message) { console.log(message);'
- en: '} | The parameter is available as a variable within the function body. |'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '} | 该参数作为变量在函数体内可用。|'
- en: '| Assign the function to a variable | showMessage = function (message) { console.log(message);'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '| 将函数赋值给变量 | showMessage = function (message) { console.log(message); |'
- en: '}; | Assigning the function to a variable gives you a label you can use to
    call the function. |'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '}; | 将函数赋值给变量为你提供了一个可以用来调用函数的标签。|'
- en: '| Call the function with an argument | showMessage("It''s full of stars!");
    | The code in the function body is executed with the argument in parentheses assigned
    to message. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 使用参数调用函数 | showMessage("It''s full of stars!"); | 函数体内的代码使用括号中分配给 `message`
    的参数执行。|'
- en: '| Call the function again and again with different arguments | showMessage("It''s
    full of stars!"); showMessage("Yippee!");'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '| 重复使用不同参数调用函数 | showMessage("It''s full of stars!"); showMessage("Yippee!");
    |'
- en: showMessage("Cowabunga!"); | Every time you call the function, the argument
    is assigned to the message parameter. |
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: showMessage("Cowabunga!"); | 每次调用函数时，参数都被分配给 `message` 参数。|
- en: You can call the `showMessage` function with any text you choose. The text is
    assigned to the `message` variable and used as part of the full message logged
    to the console.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你选择的任何文本调用 `showMessage` 函数。文本被分配给 `message` 变量，并用作记录到控制台的全消息的一部分。
- en: 'In [listing 5.4](#ch05ex04) you call the `showMessage` function with three
    different arguments, leading to three different messages on the console:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.4](#ch05ex04) 中，你使用三个不同的参数调用 `showMessage` 函数，导致控制台上有三条不同的消息：
- en: '[PRE71]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Listing 5.4\. Calling the same function with different arguments ([http://jsbin.com/zavavo/edit?js,console](http://jsbin.com/zavavo/edit?js,console))
  id: totrans-614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 使用不同参数调用相同函数 ([http://jsbin.com/zavavo/edit?js,console](http://jsbin.com/zavavo/edit?js,console))
- en: '![](061fig01_alt.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![](061fig01_alt.jpg)'
- en: Because you declared the name of the parameter along with the function definition,
    the `showMessage` function no longer relies on variable names from elsewhere,
    making it less brittle. Decoupling complete.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在函数定义中声明了参数名称，`showMessage` 函数不再依赖于其他地方的变量名称，这使得它更不易损坏。解耦完成。
- en: '[Listing 5.5](#ch05ex05) shows the definition of a square function, including
    a `numberToSquare` parameter. The function squares the number you pass to it as
    an argument. You call the function four times to give the following output:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.5](#ch05ex05) 显示了平方函数的定义，包括一个 `numberToSquare` 参数。该函数将你传递给它的数字作为参数进行平方。你调用该函数四次，得到以下输出：'
- en: '[PRE72]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Listing 5.5\. Using the square function ([http://jsbin.com/vequpi/edit?js,console](http://jsbin.com/vequpi/edit?js,console))
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 使用平方函数 ([http://jsbin.com/vequpi/edit?js,console](http://jsbin.com/vequpi/edit?js,console))
- en: '![](062fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](062fig01_alt.jpg)'
- en: '|  |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Parameters vs. arguments**'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数与参数**'
- en: You knew those parentheses would come in handy!
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道那些括号会派上用场！
- en: The names you include in the parentheses *when defining the function* are available
    as variables in the function body. They’re called *parameters* and show that you
    expect information to be included when the function is called.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 当你 *定义函数* 时括号中包含的名称在函数体中作为变量可用。它们被称为 *参数*，表明你期望在调用函数时包含信息。
- en: '[PRE73]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The values you include in the parentheses *when calling the function* are assigned
    to the parameter variables to be used in the function body. These values are called
    *arguments*.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当你 *调用函数* 时括号中包含的值被分配给参数变量，用于函数体中。这些值被称为 *参数*。
- en: '[PRE74]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Don’t worry too much about the terminology; it can take a little while to get
    used to. After you’ve created and used a few functions, you’ll pick up an intuitive
    sense of what’s going on even if you mix up the terms *parameter* and *argument*
    from time to time.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心术语；适应这些术语可能需要一点时间。在你创建和使用了一些函数之后，即使偶尔混淆了术语 *参数* 和 *参数*，你也会对正在发生的事情有一个直观的感觉。
- en: '|  |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2.2\. Passing multiple arguments to a function
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 向函数传递多个参数
- en: You can define functions with as many parameters as they need to complete their
    work. Simply separate the parameters with commas in the parentheses of the definition
    ([figure 5.2](#ch05fig02)).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义完成工作所需的任何参数的函数。只需在定义的括号中用逗号分隔参数即可（[图 5.2](#ch05fig02)）。
- en: Figure 5.2\. Including multiple parameters in a function definition
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 在函数定义中包含多个参数
- en: '![](05fig02_alt.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02_alt.jpg)'
- en: Suppose you want a function to add two numbers together. If you have two pairs
    of numbers, 30 and 23, and 2.8 and -5, the correct output would be
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个函数将两个数字相加。如果你有两对数字，30 和 23，以及 2.8 和 -5，正确的输出应该是
- en: '[PRE75]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How do you do this?
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么做这个？
- en: Listing 5.6\. A function with two arguments ([http://jsbin.com/siyelu/edit?js,console](http://jsbin.com/siyelu/edit?js,console))
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 具有两个参数的函数 ([http://jsbin.com/siyelu/edit?js,console](http://jsbin.com/siyelu/edit?js,console))
- en: '![](063fig01_alt.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![](063fig01_alt.jpg)'
- en: When you call the `showSum` function, the program automatically assigns the
    two arguments you provide to the two parameters in the definition, `number1` and
    `number2`. For the first call to `showSum` in [listing 5.6](#ch05ex06), it’s as
    if the function body becomes
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `showSum` 函数时，程序会自动将你提供的两个参数分配给定义中的两个参数，`number1` 和 `number2`。在 [列表 5.6](#ch05ex06)
    中的第一次调用 `showSum` 时，就像函数体变成了
- en: '[PRE76]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can define a function with as many parameters as you want. As the number
    of parameters increases, it becomes more likely for people (including you!) to
    make mistakes when using your function; they might miss an argument or put the
    arguments in the wrong order when calling the function. A neat way to overcome
    the problem is to pass an object to the function. The function definition needs
    only a single parameter and the function body can access whichever properties
    it needs. You’ll take a look at using objects with functions in [chapter 7](kindle_split_015.html#ch07).
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义具有所需数量的参数的函数。随着参数数量的增加，人们（包括你！）在使用你的函数时犯错误的可能性也更大；他们可能在调用函数时遗漏参数或参数顺序错误。克服这个问题的巧妙方法是将对象传递给函数。函数定义只需要一个参数，函数体可以访问它需要的任何属性。你将在第
    7 章（kindle_split_015.html#ch07）中了解如何使用对象与函数。
- en: 5.3\. The Crypt—displaying player information
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 密室—显示玩家信息
- en: You’ll now apply your knowledge of JavaScript function arguments to *The Crypt*.
    [Figure 5.3](#ch05fig03) shows where the focus of this section, showing player
    information by using functions with arguments, fits into the overall structure
    of our ongoing game example.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用你对 JavaScript 函数参数的知识到 *密室* 中。[图 5.3](#ch05fig03) 显示了本节重点，通过使用带参数的函数显示玩家信息，如何融入我们正在进行的游戏示例的整体结构。
- en: Figure 5.3\. Elements of *The Crypt*
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.3\. 密室元素
- en: '![](05fig03_alt.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig03_alt.jpg)'
- en: In [chapter 4](kindle_split_012.html#ch04), you wrote a `showPlayerInfo` function
    as code on demand. You could display player information on the console whenever
    you wanted, just by calling the function. Unfortunately, it relied on a `player`
    variable being set elsewhere in the code. Let’s update the `showPlayerInfo` function,
    setting parameters so you can pass it the information it needs directly.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_012.html#ch04)中，您编写了一个`showPlayerInfo`函数作为代码按需。您可以在需要时随时在控制台上显示玩家信息，只需调用该函数即可。不幸的是，它依赖于代码其他地方设置的`player`变量。让我们更新`showPlayerInfo`函数，设置参数以便您可以直接传递所需的信息。
- en: 'In order to display information about each player, you break the job into subtasks
    and create functions for each piece of information. You then show information
    about a player like this:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示每个玩家的信息，您将任务分解为子任务，并为每条信息创建函数。然后您可以这样显示玩家的信息：
- en: '[PRE77]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Each function has a specific job to do. If you want to display all of the information
    at once, you wrap the individual functions inside one master function and pass
    it all the information it needs:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有特定的任务要做。如果您想一次性显示所有信息，您可以将单个函数包装在一个主函数中，并传递给它所需的所有信息：
- en: '[PRE78]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Over the next few sections, you define the four functions and see them working
    with player objects. The first three functions are very similar; pay attention
    to what changes and what stays the same. Notice how you use parameters when defining
    the functions and how you use arguments when calling them.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您定义了四个函数，并看到它们与玩家对象一起工作。前三个函数非常相似；注意哪些发生了变化，哪些保持不变。注意您在定义函数时如何使用参数，以及调用它们时如何使用参数。
- en: 5.3.1\. Displaying players’ names
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. 显示玩家的名字
- en: 'Your first function’s job is to display the player’s name. That’s it. No bells
    or whistles. The next listing shows the `showPlayerName` function definition and
    calls the function with two different names to produce the following output:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个函数的任务是显示玩家的名字。仅此而已。没有铃声或哨声。下一个列表显示了`showPlayerName`函数的定义，并使用两个不同的名字调用该函数以产生以下输出：
- en: '[PRE79]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Listing 5.7\. Displaying a player’s name ([http://jsbin.com/yubahi/edit?js,console](http://jsbin.com/yubahi/edit?js,console))
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 显示玩家的名字 ([http://jsbin.com/yubahi/edit?js,console](http://jsbin.com/yubahi/edit?js,console))
- en: '![](065fig01_alt.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![](065fig01_alt.jpg)'
- en: In the actual *The Crypt* program, you’re not likely to call the `showPlayerName`
    function with literal values like `"Kandra"` and `"Dax"`. You’re much more likely
    to use variables. In particular, JavaScript objects will represent players. The
    next listing updates the code to use a couple of player objects instead.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的*The Crypt*程序中，您不太可能使用像`"Kandra"`和`"Dax"`这样的字面值调用`showPlayerName`函数。您更有可能使用变量。特别是，JavaScript对象将代表玩家。下一个列表更新了代码以使用几个玩家对象。
- en: Listing 5.8\. Displaying a player’s name via an object property ([http://jsbin.com/juhewi/edit?js,console](http://jsbin.com/juhewi/edit?js,console))
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 通过对象属性显示玩家的名字 ([http://jsbin.com/juhewi/edit?js,console](http://jsbin.com/juhewi/edit?js,console))
- en: '![](065fig02_alt.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![](065fig02_alt.jpg)'
- en: That’s names covered. Next up, health.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 名字部分就到这里。接下来是健康状态。
- en: 5.3.2\. Displaying players’ health
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. 显示玩家的健康状态
- en: 'The `showPlayerHealth` function definition in the following listing includes
    two parameters, `playerName` and `playerHealth`, to produce output like this:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的`showPlayerHealth`函数定义包含了两个参数，`playerName`和`playerHealth`，以产生如下输出：
- en: '[PRE80]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Listing 5.9\. Displaying a player’s health ([http://jsbin.com/nomija/edit?js,console](http://jsbin.com/nomija/edit?js,console))
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 显示玩家的健康状态 ([http://jsbin.com/nomija/edit?js,console](http://jsbin.com/nomija/edit?js,console))
- en: '![](066fig01_alt.jpg)'
  id: totrans-665
  prefs: []
  type: TYPE_IMG
  zh: '![](066fig01_alt.jpg)'
- en: The call to `showPlayerHealth` in [listing 5.9](#ch05ex09) used the literal
    values `"Kandra"` and `50`. In the final program, each player’s information is
    assigned to the properties of a player object. Your calls to `showPlayerHealth`
    are much more likely to use those properties than hard-coded values. The next
    listing updates the code to include player objects.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表5.9](#ch05ex09)中调用`showPlayerHealth`时使用了字面值`"Kandra"`和`50`。在最终程序中，每个玩家的信息都分配给了玩家对象的属性。您调用`showPlayerHealth`时更有可能使用这些属性而不是硬编码的值。下一个列表更新了代码以包含玩家对象。
- en: Listing 5.10\. Displaying a player’s health via object properties ([http://jsbin.com/zufoxi/edit?js,console](http://jsbin.com/zufoxi/edit?js,console))
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. 通过对象属性显示玩家的健康状态 ([http://jsbin.com/zufoxi/edit?js,console](http://jsbin.com/zufoxi/edit?js,console))
- en: '![](066fig02_alt.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![](066fig02_alt.jpg)'
- en: 'Name: check. Health: check. That just leaves location.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名：检查。健康：检查。这样就只剩下位置了。
- en: 5.3.3\. Displaying players’ locations
  id: totrans-670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3\. 显示玩家的位置
- en: 'The `showPlayerPlace` function definition in the following listing also includes
    two parameters, this time `playerName` and `playerPlace`, and produces output
    like this:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中定义的 `showPlayerPlace` 函数也包含两个参数，这次是 `playerName` 和 `playerPlace`，并且会输出如下内容：
- en: '[PRE81]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Listing 5.11\. Displaying a player’s location ([http://jsbin.com/yifahe/edit?js,console](http://jsbin.com/yifahe/edit?js,console))
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 显示玩家的位置 ([http://jsbin.com/yifahe/edit?js,console](http://jsbin.com/yifahe/edit?js,console))
- en: '[PRE82]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Once again, switching from the hard-coded literal values in [listing 5.11](#ch05ex11)
    to object properties gives you an updated version in the next listing.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，从 [列表 5.11](#ch05ex11) 中的硬编码字面值切换到对象属性，在下一个列表中给出了更新版本。
- en: Listing 5.12\. Displaying a player’s location via object properties ([http://jsbin.com/mejuki/edit?js,console](http://jsbin.com/mejuki/edit?js,console))
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.12\. 通过对象属性显示玩家的位置 ([http://jsbin.com/mejuki/edit?js,console](http://jsbin.com/mejuki/edit?js,console))
- en: '[PRE83]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You have the three functions you need to show individual pieces of information
    about players. Now it’s time to use the functions together.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有了显示玩家个别信息的三个函数。现在，是时候将它们组合在一起使用了。
- en: 5.3.4\. Putting it all together—displaying players’ information
  id: totrans-679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4\. 整合所有内容——显示玩家的信息
- en: 'The `showPlayerInfo` function uses your three individual functions—`showPlayerName`,
    `showPlayerHealth`, and `showPlayerPlace`—and adds a touch of formatting to produce
    a display of each player’s properties. The output for one player looks like this:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`showPlayerInfo` 函数使用您的三个单独的函数——`showPlayerName`、`showPlayerHealth` 和 `showPlayerPlace`——并添加了一些格式化，以显示每个玩家的属性。一个玩家的输出看起来像这样：'
- en: '[PRE84]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The next listing leaves out the three component functions to focus on the new
    function. They’re included on JS Bin.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表省略了三个组件函数，以专注于新的函数。它们包含在 JS Bin 中。
- en: Listing 5.13\. Displaying a player’s information ([http://jsbin.com/likafe/edit?js,console](http://jsbin.com/likafe/edit?js,console))
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 显示玩家的信息 ([http://jsbin.com/likafe/edit?js,console](http://jsbin.com/likafe/edit?js,console))
- en: '[PRE85]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You call the `showPlayerInfo` function with three arguments each time. It, in
    turn, passes the required arguments on to the `showPlayerName`, `showPlayerHealth`,
    and `showPlayerPlace` functions.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 您每次调用 `showPlayerInfo` 函数时都使用三个参数。它反过来将所需的参数传递给 `showPlayerName`、`showPlayerHealth`
    和 `showPlayerPlace` 函数。
- en: You end with all the pieces put together in a single listing, shown next. It
    includes each variable declaration and assignment as a single step and uses player
    object properties, like `player1.name`, rather than literal values, like `"Kandra"`,
    when calling `showPlayerInfo`.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将所有部分组合成一个单独的列表，如下所示。它将每个变量声明和赋值作为一个单独的步骤，并在调用 `showPlayerInfo` 时使用玩家对象的属性，如
    `player1.name`，而不是像 `"Kandra"` 这样的字面值。
- en: Listing 5.14\. Displaying a player’s information using properties ([http://jsbin.com/loteti/edit?js,console](http://jsbin.com/loteti/edit?js,console))
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 使用属性显示玩家的信息 ([http://jsbin.com/loteti/edit?js,console](http://jsbin.com/loteti/edit?js,console))
- en: '[PRE86]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 5.4\. Summary
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 概述
- en: 'Define a function with named *parameters* to show that you expect to pass data
    to the function when you call it. Commas separate the parameters inside the parentheses
    of the definition:'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个带有命名 *参数* 的函数，以表明您在调用函数时预期传递数据。定义中的参数由逗号分隔：
- en: '[PRE87]'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Use the parameters inside the function body as if they are variables.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数体内使用参数，就像它们是变量一样。
- en: 'Call the function with *arguments*. When you run the program, the arguments
    are automatically assigned to the parameters for use in the function body:'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *参数* 调用函数。当您运行程序时，参数会自动分配给参数以在函数体内使用：
- en: '[PRE88]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Chapter 6\. Return values: getting data from functions'
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第六章\. 返回值：从函数获取数据
- en: '***This chapter covers***'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Returning information from functions
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数返回信息
- en: The `return` keyword
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 关键字'
- en: Experimenting at the console prompt
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台提示符中进行实验
- en: In [chapter 4](kindle_split_012.html#ch04) you discovered how functions can
    increase your efficiency by allowing you to write code once but use it many times.
    In [chapter 5](kindle_split_013.html#ch05), you made functions much more flexible
    by passing them information with each call; a function can act in different ways
    and produce different outputs depending on the arguments you give it. In this
    chapter you give functions the chance to talk back by returning the results of
    their work. You also call functions directly at the console prompt to investigate
    the values they return.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_012.html#ch04)中，你发现了函数如何通过一次编写多次使用来提高你的效率。在[第5章](kindle_split_013.html#ch05)中，你通过在每次调用时传递信息使函数变得更加灵活；一个函数可以根据你给出的参数以不同的方式行事并产生不同的输出。在本章中，你给函数机会通过返回它们工作的结果来“回应”。你还可以在控制台提示符中直接调用函数来调查它们返回的值。
- en: 6.1\. Returning data from functions
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 从函数返回数据
- en: It’s often useful to have a function do some work for you and give you back
    the result of that work. You can then use the result however you want. In [listing
    5.6](kindle_split_013.html#ch05ex06) you saw a `showSum` function that displays
    the sum of two numbers on the console. It may be better to have an `add` function
    that simply adds the numbers and returns the result. Whereas `showSum` always
    displays the result on the console, with `add` you can display the result the
    function returns if you choose, use it in further calculations, send it across
    a network, or save it to a database.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，让函数为你做一些工作并返回该工作的结果是非常有用的。然后你可以根据需要使用该结果。在[列表5.6](kindle_split_013.html#ch05ex06)中，你看到了一个`showSum`函数，它在控制台上显示两个数的和。可能有一个`add`函数，它只是将数字相加并返回结果会更好。与`showSum`总是显示结果在控制台上不同，使用`add`，你可以选择显示函数返回的结果，将其用于进一步的计算，通过网络发送，或将其保存到数据库中。
- en: 6.1.1\. The return value replaces the function call
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 返回值替换函数调用
- en: 'Most of the functions you’ve written so far have executed code for you on demand
    and then logged something to the console. They’ve helped you to break up programs
    into understandable chunks. By assigning the functions to well-named variables,
    you’ve made the programs easier to follow. For an example of well-named variables,
    here’s a snippet of code for displaying player information in *The Crypt*:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止编写的许多函数都是根据需求执行代码并在控制台上记录一些内容。它们帮助你将程序分解成可理解的块。通过将函数分配给有良好命名的变量，你使程序更容易理解。以下是一个显示*The
    Crypt*中玩家信息的代码片段的示例：
- en: '[PRE89]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Even if you don’t know how the functions perform their jobs, their names give
    you a good idea of the intentions of the code.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道函数是如何执行它们的任务的，它们的名称也能给你一个很好的关于代码意图的印象。
- en: 'Functions can also return information: the result of a calculation, a constructed
    piece of text, or data from a database. You can assign the returned value to a
    variable or use it as an argument with other functions. The following examples
    show, in bold, calls to the four functions `add`, `getPlayerPlace`, `findPlanetPosition`,
    and `getMessage`:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还可以返回信息：计算的结果、构造的文本片段或数据库中的数据。你可以将返回的值分配给变量或将其用作其他函数的参数。以下示例以加粗的形式显示了调用四个函数`add`、`getPlayerPlace`、`findPlanetPosition`和`getMessage`：
- en: '[PRE90]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Each function returns a value and the returned value replaces the function call.
    Assuming the functions return the following values in bold, the previous four
    statements become
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都返回一个值，返回的值替换了函数调用。假设函数返回以下加粗的值，前面的四个语句变为
- en: '[PRE91]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[Figure 6.1](#ch06fig01) shows what happens when you call the `add` function.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#ch06fig01)展示了调用`add`函数时发生的情况。'
- en: Figure 6.1\. You call the `add` function and it returns the value `73`.
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 你调用`add`函数，它返回值`73`。
- en: '![](06fig01.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01.jpg)'
- en: To return a value from a function, use the `return` keyword.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 要从函数返回一个值，请使用`return`关键字。
- en: 6.1.2\. The return keyword
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. `return`关键字
- en: Return a value from a function by using the `return` keyword. Whatever follows
    `return` in a statement is the value that replaces the function call.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`return`关键字从函数返回一个值。语句中`return`之后的任何内容都是替换函数调用的值。
- en: '[Listing 6.1](#ch06ex01) shows the definition of a `getMessage` function. It
    includes a *return statement*, a statement that starts with the `return` keyword:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.1](#ch06ex01)展示了`getMessage`函数的定义。它包括一个*返回语句*，一个以`return`关键字开始的语句：'
- en: '[PRE92]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The function returns the string `"I'm going on an adventure!"` because the string
    follows the `return` keyword. The program assigns the string to the `response`
    variable and logs it to the console to show
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回字符串 `"I'm going on an adventure!"`，因为字符串跟在 `return` 关键字后面。程序将字符串赋给 `response`
    变量并将其记录到控制台以显示
- en: '[PRE93]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Listing 6.1\. Returning a value from a function ([http://jsbin.com/yucate/edit?js,console](http://jsbin.com/yucate/edit?js,console))
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1。从函数返回值 ([http://jsbin.com/yucate/edit?js,console](http://jsbin.com/yucate/edit?js,console))
- en: '![](072fig01_alt.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![072fig01_alt.jpg](072fig01_alt.jpg)'
- en: The `getMessage` function always returns the same value. It’s common to determine
    the return value by using information you pass in as arguments when you call the
    function.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`getMessage` 函数总是返回相同的值。通常，通过在调用函数时传递的参数信息来确定返回值。'
- en: 6.1.3\. Using arguments to determine the return value
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3。使用参数确定返回值
- en: In [chapter 5](kindle_split_013.html#ch05), you passed information into a function
    by including parameters in the function definition and arguments in the function
    call. You can use that information in the function body to determine the value
    the function returns and so call the function again and again with different arguments
    to produce different return values.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第5章](kindle_split_013.html#ch05) 中，你通过在函数定义中包含参数和在函数调用中包含参数将信息传递给函数。你可以在函数体中使用这些信息来确定函数返回的值，因此你可以用不同的参数多次调用函数以产生不同的返回值。
- en: The following listing shows a `getHelloTo` function that returns a string including
    a name passed in as an argument. The program assigns the return value to a variable
    and logs it to the console.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个 `getHelloTo` 函数，该函数返回一个包含作为参数传递的名称的字符串。程序将返回值赋给一个变量并将其记录到控制台。
- en: '[PRE94]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Listing 6.2\. Using an argument to determine the return value ([http://jsbin.com/nijijo/edit?js,console](http://jsbin.com/nijijo/edit?js,console))
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2。使用参数确定返回值 ([http://jsbin.com/nijijo/edit?js,console](http://jsbin.com/nijijo/edit?js,console))
- en: '![](072fig02_alt.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![072fig02_alt.jpg](072fig02_alt.jpg)'
- en: 'In [listing 6.2](#ch06ex02), you assign the return value to a variable, `fullMessage`,
    and log it to the console. The variable is redundant; you could just log the return
    value directly, as shown in the next listing, in which you call the `getHelloTo`
    function twice to give the following output:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表6.2](#ch06ex02) 中，你将返回值赋给变量 `fullMessage` 并将其记录到控制台。这个变量是多余的；你可以直接记录返回值，如下一个列表所示，其中你两次调用
    `getHelloTo` 函数以产生以下输出：
- en: '[PRE95]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Listing 6.3\. Using the return value as an argument ([http://jsbin.com/yapic/edit?js,console](http://jsbin.com/yapic/edit?js,console))
  id: totrans-732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3。使用返回值作为参数 ([http://jsbin.com/yapic/edit?js,console](http://jsbin.com/yapic/edit?js,console))
- en: '![](073fig01_alt.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![073fig01_alt.jpg](073fig01_alt.jpg)'
- en: 'Functions can return any type of value: strings, numbers, objects, and even
    other functions. Let’s look at an example that returns a number.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回任何类型的值：字符串、数字、对象，甚至其他函数。让我们看看一个返回数字的例子。
- en: '[Figure 6.2](#ch06fig02) shows a call to the `add` function, `add(50, 23`).
    The figure shows how the arguments passed to `add` are used to calculate the return
    value.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.2](#ch06fig02) 展示了对 `add` 函数的调用，`add(50, 23)`。图中显示了传递给 `add` 的参数是如何用于计算返回值的。'
- en: Figure 6.2\. The `add` function calculates the return value.
  id: totrans-736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2。`add` 函数计算返回值。
- en: '![](06fig02_alt.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![06fig02_alt.jpg](06fig02_alt.jpg)'
- en: The next listing shows the code to make the `add` function do its thing. Notice,
    in particular, the `return` keyword.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了使 `add` 函数执行其操作的代码。特别是要注意 `return` 关键字。
- en: Listing 6.4\. Returning the sum of two numbers ([http://jsbin.com/haqapu/edit?js,console](http://jsbin.com/haqapu/edit?js,console))
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4。返回两个数字的和 ([http://jsbin.com/haqapu/edit?js,console](http://jsbin.com/haqapu/edit?js,console))
- en: '![](074fig01_alt.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![074fig01_alt.jpg](074fig01_alt.jpg)'
- en: '`add(50, 23)` calls the `add` function, assigning `50` to `number1` and `23`
    to `number2`. The value of `number1` is then added to the value of `number2` and
    the result assigned to the `total` variable. The `return` keyword then ends the
    function and replaces the call to the function with the value of `total`.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(50, 23)` 调用 `add` 函数，将 `50` 赋值给 `number1`，将 `23` 赋值给 `number2`。然后 `number1`
    的值与 `number2` 的值相加，并将结果赋给 `total` 变量。然后 `return` 关键字结束函数，并用 `total` 的值替换函数调用。'
- en: '[PRE96]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: becomes
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE97]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: because `add(50, 23)` returns `73`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `add(50, 23)` 返回 `73`。
- en: Remember, the assignment operator, `=`, works by assigning the value on its
    right to the variable on its left. If a function call is on its right, then it
    assigns the function’s return value.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，赋值运算符 `=` 通过将其右侧的值赋给左侧的变量来工作。如果右侧是函数调用，那么它将函数的返回值赋给变量。
- en: The `total` variable in the `add` function in [listing 6.4](#ch06ex04) isn’t
    really needed; it’s assigned a value and then immediately returned. You could
    have returned the result of the calculation directly, as the `totalCost` function
    does in [listing 6.5](#ch06ex05). Given the call-out charge and hourly rate charged
    by a plumber, `totalCost` calculates the total cost for a certain number of hours
    of work. So, say the call-out charge is $30 and the plumber charges $40 per hour,
    what is the total cost for three hours of work? `totalCost(30, 40, 3)` should
    return the result `$150`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 6.4](#ch06ex04) 中的 `add` 函数的 `total` 变量实际上并不需要；它被分配了一个值，然后立即返回。你可以直接返回计算结果，就像
    [列表 6.5](#ch06ex05) 中的 `totalCost` 函数那样。考虑到管道工的调用费用和每小时收费，`totalCost` 计算了一定小时数的总费用。所以，假设调用费用是
    30 美元，管道工每小时收费 40 美元，那么三小时工作的总费用是多少？`totalCost(30, 40, 3)` 应该返回结果 `$150`。
- en: Listing 6.5\. A function with three arguments ([http://jsbin.com/jedigi/edit?js,console](http://jsbin.com/jedigi/edit?js,console))
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 一个有三个参数的函数 ([http://jsbin.com/jedigi/edit?js,console](http://jsbin.com/jedigi/edit?js,console))
- en: '![](074fig02_alt.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![](074fig02_alt.jpg)'
- en: 'When you call the `totalCost` function, it evaluates the calculation to the
    right of the `return` keyword and returns the value. It follows the usual rules
    of arithmetic: it performs the multiplication first and then the addition: 30
    + 40 * 3 = 30 + 120 = 150.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `totalCost` 函数时，它会评估 `return` 关键字右侧的计算并返回值。它遵循通常的算术规则：它首先执行乘法，然后执行加法：30
    + 40 * 3 = 30 + 120 = 150。
- en: 6.2\. Experimenting at the console prompt
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 在控制台提示符中进行实验
- en: Programmers don’t generally use the console in production, that is, in published
    programs and websites. They use it in development, when designing and writing
    programs. It provides a convenient way for programmers (that’s you) to log values
    and errors and investigate the state of their programs while they’re running.
    That interactivity, the chance to get immediate feedback, makes the console really
    useful for learning—particularly for learning through experimentation. It’s time
    to go on an adventure of discovery with the functions you’ve seen so far in this
    chapter.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常不会在生产环境中使用控制台，即在发布的程序和网站上。他们在开发时使用它，当设计和编写程序时。它为程序员（也就是你）提供了一个方便的方式来记录值和错误，并在程序运行时调查程序的状态。这种交互性，获得即时反馈的机会，使得控制台对于学习非常有用——尤其是通过实验学习。现在是时候带着你在本章中看到的函数去进行一次发现之旅了。
- en: 6.2.1\. Calling functions
  id: totrans-753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 调用函数
- en: The next listing includes four functions from earlier listings. If you run the
    program, it won’t produce any output on the console; it doesn’t include any calls
    to `console.log`.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表包括之前列表中的四个函数。如果你运行程序，它不会在控制台产生任何输出；它不包含任何对 `console.log` 的调用。
- en: Listing 6.6\. A collection of functions that return values ([http://jsbin.com/lijufo/edit?js,console](http://jsbin.com/lijufo/edit?js,console))
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 一组返回值的函数 ([http://jsbin.com/lijufo/edit?js,console](http://jsbin.com/lijufo/edit?js,console))
- en: '[PRE98]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Running the program assigns the four functions to the four variables declared
    at the top of the program. You can then access the variables from the console
    prompt. You can call the functions assigned to the variables to investigate their
    return values.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序会将四个函数分配给程序顶部声明的四个变量。然后你可以从控制台提示符访问这些变量。你可以调用分配给变量的函数来调查它们的返回值。
- en: Follow the link to the listing on JS Bin and make sure you run the program.
    At the console prompt type
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 JS Bin 上的列表链接，确保运行程序。在控制台提示符中输入
- en: '[PRE99]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'and press Enter. The `getMessage` function runs and displays its return value:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按 Enter。`getMessage` 函数运行并显示其返回值：
- en: '[PRE100]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: At the prompt, press the up arrow on your keyboard. It should bring up the last
    line you typed. (You can navigate through your previous entries at the console
    with the up and down arrows.) Press Enter to resubmit a command. The `getMessage`
    function always returns the same string. If you look at its function body, you
    can see it returns a string literal, a hard-coded value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符下，按键盘上的上箭头键。它应该会显示你最后输入的行。（你可以使用上下箭头在控制台导航到之前的输入。）按 Enter 键重新提交命令。`getMessage`
    函数总是返回相同的字符串。如果你查看其函数体，你可以看到它返回一个字符串字面量，一个硬编码的值。
- en: '[PRE101]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The next function in the program, `getHelloTo`, includes a `name` parameter
    in its definition. The `name` parameter allows the return value to vary in response
    to the argument you pass to the function when you call it.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的下一个函数 `getHelloTo` 在其定义中包含一个 `name` 参数。`name` 参数允许返回值根据你调用函数时传递的参数而变化。
- en: '[PRE102]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Have a go at calling the function at the console with different arguments each
    time:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在控制台使用不同的参数每次调用该函数：
- en: '[PRE103]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: You can immediately see how changing the argument affects the return value.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即看到改变参数如何影响返回值。
- en: 6.2.2\. Declaring new variables
  id: totrans-769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 声明新变量
- en: As well as giving you access to variables declared in your programs, the console
    allows you to declare new variables and assign them values.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让你访问程序中声明的变量外，控制台还允许你声明新变量并为其赋值。
- en: Carrying straight on from the previous section, at the console type
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从上一节继续，在控制台输入
- en: '[PRE104]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: and press Enter. The console displays the value of your previous entry. Because
    you didn’t assign a value to the `friend` variable, `undefined` is logged to the
    console.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 并按Enter键。控制台会显示你之前输入的值。因为你没有为`friend`变量赋值，所以`undefined`被记录到控制台。
- en: '[PRE105]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Give it a value. Type
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 给它一个值。输入
- en: '[PRE106]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: and press Enter. The console displays the new value.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 并按Enter键。控制台会显示新的值。
- en: '[PRE107]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Finally, use your new `friend` variable as an argument for the `getHelloTo`
    function.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用你新的`friend`变量作为`getHelloTo`函数的参数。
- en: '[PRE108]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Have a play with the `add` and `totalCost` functions, passing them different
    arguments and checking the return values displayed on the console, for example:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`add`和`totalCost`函数，传递不同的参数，并检查控制台上显示的返回值，例如：
- en: '[PRE109]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The console is more than a place to log messages from your programs. You can
    really dig into your programs and check that they behave as expected. Don’t wait
    for permission; jump in and test all the listings.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台不仅仅是一个记录程序消息的地方。你真的可以深入到你的程序中，检查它们是否按预期行为。不要等待许可；跳进去测试所有的列表。
- en: Now let’s use your new knowledge of return values to improve how *The Crypt*
    displays player information.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用你对返回值的新知识来改进《The Crypt》显示玩家信息的方式。
- en: 6.3\. The Crypt—building player information strings
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 《The Crypt》——构建玩家信息字符串
- en: '[Figure 6.3](#ch06fig03) shows where the focus of this section, showing player
    information by using return values, fits into the overall structure of our ongoing
    game example.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.3](#ch06fig03)显示了本节重点，即通过返回值显示玩家信息，在我们正在进行的游戏示例的整体结构中的位置。'
- en: Figure 6.3\. Elements of *The Crypt*
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 《The Crypt》的元素
- en: '![](06fig03_alt.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig03_alt.jpg)'
- en: In [chapter 5](kindle_split_013.html#ch05), you divided the work of displaying
    player information among a number of functions, with each function having a specific
    job to do.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_013.html#ch05)中，你将显示玩家信息的任务分配给多个函数，每个函数都有特定的任务要做。
- en: '[PRE110]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The functions each logged a string of information to the console. But what if
    you don’t want the information on the console? You might want to send it in an
    email, serve it as a response to a web request, or append it to an existing element
    on a web page. It would be more flexible if the functions built the information
    strings and returned them for the program to use as required.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都会在控制台记录一条信息字符串。但如果你不想在控制台上显示信息呢？你可能想通过电子邮件发送它，作为对网络请求的响应，或者将其附加到网页上的现有元素。如果函数构建信息字符串并按需返回它们，将更加灵活。
- en: 6.3.1\. Building strings for a player’s name, health, and location
  id: totrans-792
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 为玩家姓名、健康和位置构建字符串
- en: 'You pass your new functions the information they need as arguments and they
    return a string containing that information. The kind of return values you expect
    are shown here:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要的信息作为参数传递给你的新函数，它们会返回包含该信息的字符串。你期望的返回值类型如下所示：
- en: '[PRE111]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: First up is `getPlayerName`. At the moment it just returns the name it’s given,
    which seems like a waste of time. But defining a function allows you to make all
    the player information accessible in the same way; getting the name is similar
    to getting the health or the location. It also makes it easier to update the code
    later if you decide to change how the name is displayed. The following listing
    shows the `getPlayerName` function definition and an example call to it, producing
    the output
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`getPlayerName`。目前它只返回给定的名称，这似乎是浪费时间。但定义一个函数允许你以相同的方式访问所有玩家信息；获取名称类似于获取健康或位置。这也使得在以后更新代码时，如果你决定更改名称的显示方式，更容易一些。以下列表显示了`getPlayerName`函数的定义和对其的一个示例调用，产生以下输出
- en: '[PRE112]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Listing 6.7\. Getting a string for a player’s name ([http://jsbin.com/hijeli/edit?js,console](http://jsbin.com/hijeli/edit?js,console))
  id: totrans-797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 获取玩家姓名的字符串([http://jsbin.com/hijeli/edit?js,console](http://jsbin.com/hijeli/edit?js,console))
- en: '[PRE113]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The next two functions, `getPlayerHealth` and `getPlayerPlace`, are very similar,
    both building a simple string from the information passed in. The next listing
    includes the definitions of both functions along with some usage examples, producing
    the following on the console:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数`getPlayerHealth`和`getPlayerPlace`非常相似，都是根据传入的信息构建简单的字符串。下一个列表包括这两个函数的定义和一些使用示例，在控制台上生成以下内容：
- en: '[PRE114]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Listing 6.8\. Getting strings for a player’s health and location ([http://jsbin.com/pemore/edit?js,console](http://jsbin.com/pemore/edit?js,console))
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. 获取玩家健康和位置信息的字符串 ([http://jsbin.com/pemore/edit?js,console](http://jsbin.com/pemore/edit?js,console))
- en: '[PRE115]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Calling the three functions from one main `getPlayerInfo` function will give
    you the display string you want. The next section shows how the pieces are assembled.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个主`getPlayerInfo`函数中调用三个函数将给出你想要的显示字符串。下一节将展示这些组件是如何组装的。
- en: 6.3.2\. A function for player information—putting the pieces together
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 玩家信息函数——组装组件
- en: 'With the pieces in place you can now build the main function to produce a string
    of information about a player. You want the output to look something like this:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有组件就绪后，你现在可以构建主函数来生成关于玩家的信息字符串。你希望输出看起来像这样：
- en: '[PRE116]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: To construct the lines of characters separating the player information, you
    make use of a `getBorder` function that returns a line of asterisk symbols. The
    listing that follows shows the `getPlayerInfo` definition. It includes calls to
    other functions not shown in the printed listing but included in the JS Bin version.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建分隔玩家信息的字符行，你使用一个返回由星号符号组成的行的`getBorder`函数。接下来的列表显示了`getPlayerInfo`的定义。它包括对未在打印列表中显示但包含在JS
    Bin版本中的其他函数的调用。
- en: Listing 6.9\. Getting a string for a player’s information ([http://jsbin.com/javuxe/edit?js,console](http://jsbin.com/javuxe/edit?js,console))
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.9\. 获取玩家信息的字符串 ([http://jsbin.com/javuxe/edit?js,console](http://jsbin.com/javuxe/edit?js,console))
- en: '![](079fig01_alt.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
  zh: '![](079fig01_alt.jpg)'
- en: The `getPlayerInfo` function builds up the player information string piece by
    piece, appending the strings returned by the functions called to the `playerInfo`
    variable. The extra string, `\n`, appended at each stage is a new-line character;
    text following the new-line character will appear on a new line on the console.
    You use the `+=` operator to append a string to the end of an existing string.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlayerInfo`函数逐步构建玩家信息字符串，将调用函数返回的字符串附加到`playerInfo`变量上。在每个阶段附加的额外字符串`\n`是一个换行符；换行符后面的文本将在控制台上显示在新的一行。你使用`+=`运算符将字符串附加到现有字符串的末尾。'
- en: 'The final example for this chapter gathers all of the code into a single listing,
    [listing 6.10](#ch06ex10), along with two player objects used to test the `getPlayerInfo`
    function. It also uses a different separator character in the `getBorder` function,
    producing output for both players like this:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例将所有代码汇集到一个列表中，[列表6.10](#ch06ex10)，以及用于测试`getPlayerInfo`函数的两个玩家对象。它还在`getBorder`函数中使用不同的分隔符字符，为两个玩家生成如下输出：
- en: '[PRE117]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Listing 6.10\. Displaying player information using objects ([http://jsbin.com/puteki/edit?js,console](http://jsbin.com/puteki/edit?js,console))
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.10\. 使用对象显示玩家信息 ([http://jsbin.com/puteki/edit?js,console](http://jsbin.com/puteki/edit?js,console))
- en: '![](ch06ex10-0.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex10-0.jpg)'
- en: '![](ch06ex10-1.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex10-1.jpg)'
- en: You’ve successfully switched from functions that always print the output on
    the console to ones that return player information as strings. You then choose
    what to do with the strings.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功地将函数从总是打印输出到控制台切换到返回玩家信息的字符串。然后你选择如何处理这些字符串。
- en: Having to pass individual bits of information about the players to the functions
    is a bit of a drag. The different functions require different bits of info and
    you have to make sure to put the arguments in the right order. It would be easier
    if you could just pass the whole player object as an argument and let the functions
    access whichever properties they need. In [chapter 7](kindle_split_015.html#ch07)
    you’ll see how useful it is to use JavaScript objects both as arguments and as
    return values.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 将关于玩家的单个信息位传递给函数有点麻烦。不同的函数需要不同的信息位，你必须确保将参数按照正确的顺序放置。如果能直接将整个玩家对象作为参数传递，并让函数访问它们需要的任何属性，那就简单多了。在[第7章](kindle_split_015.html#ch07)中，你会看到使用JavaScript对象作为参数和返回值是多么有用。
- en: 6.4\. Summary
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 概述
- en: 'Pass information out of functions by using the `return` keyword:'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`return`关键字从函数中传递信息：
- en: '[PRE118]'
  id: totrans-820
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Use a function call as a value to assign to a variable or use as an argument.
    The value the function returns replaces the function call:'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数调用作为值分配给变量或用作参数。函数返回的值替换了函数调用：
- en: '[PRE119]'
  id: totrans-822
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Include parameters in the function definition and use the arguments passed
    in to the function to determine the value returned:'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数定义中包含参数，并使用传递给函数的参数来确定返回的值：
- en: '[PRE120]'
  id: totrans-824
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Use the console to explore and test programs.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制台来探索和测试程序。
- en: Call functions at the console prompt and see their return values displayed.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台提示符中调用函数，并查看它们的返回值显示。
- en: Declare variables at the console, assign them values, and use them as arguments
    for functions.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台声明变量，分配值，并将它们用作函数的参数。
- en: 'Chapter 7\. Object arguments: functions working with objects'
  id: totrans-828
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。对象参数：与对象一起工作的函数
- en: '***This chapter covers***'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Using objects as arguments
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象作为参数
- en: Accessing object properties from within a function
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部访问对象属性
- en: Adding new object properties from within a function
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部添加新的对象属性
- en: Returning objects from functions
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中返回对象
- en: Setting functions as properties of objects
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数设置为对象的属性
- en: This is the last of the run of four chapters introducing functions. By now,
    you know about using functions to execute code on demand and passing information
    to and from functions using parameters, arguments, and the `return` keyword. You’ve
    also seen how to use objects to collect values together as named properties. Well,
    it’s time to combine functions and objects to turbocharge productivity, efficiency,
    and readability.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 这是介绍函数的四个章节中的最后一个。到现在为止，你已经了解了如何使用函数按需执行代码，以及如何通过参数、参数和`return`关键字在函数之间传递信息。你也看到了如何使用对象将值收集在一起作为命名属性。那么，现在是时候将函数和对象结合起来，以提升生产力、效率和可读性了。
- en: 'Remember the first-aid kit from [chapter 3](kindle_split_011.html#ch03)? We
    consider the kit to be a single object that we can pass around, pack in a rucksack,
    and speak about. Such encapsulation, or chunking, where we treat a collection
    as singular, is an important part of how we as humans cope with complex information,
    both in language and in memory. When the need arises, we can consider the elements
    that make up the kit: antiseptic, plasters, bandages, and so on.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 记得第3章中的急救包吗？我们将这个包视为一个可以传递、打包在背包中并讨论的单个对象。这种封装，或者说将集合视为单一实体，是我们作为人类处理复杂信息的重要部分，无论是在语言还是在记忆中。当需要时，我们可以考虑构成这个包的元素：消毒剂、敷料、绷带等等。
- en: You use the same concept of encapsulation throughout this chapter as you pass
    objects to and from functions as arguments and return values.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用相同的封装概念，将对象作为参数传递给函数并作为返回值返回。
- en: 7.1\. Using objects as arguments
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 使用对象作为参数
- en: Being able to pass an object to a function is really useful, especially if the
    function needs to access lots of the object’s properties. You need only a single
    parameter in the function definition and you don’t need a long list of arguments
    when calling the function. `showPlayerInfo(player1)` is neater, more easily understood,
    and less prone to error than `showPlayerInfo(player1.name, player1.location, player1.health)`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将对象传递给函数非常有用，特别是如果函数需要访问大量的对象属性。你只需要在函数定义中一个参数，调用函数时不需要一个长的参数列表。"showPlayerInfo(player1)"比"showPlayerInfo(player1.name,
    player1.location, player1.health)"更整洁、更容易理解，且更不容易出错。
- en: You can pass the same information to the function but wrapped into a single
    object rather than as separate values ([figure 7.1](#ch07fig01)).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将相同的信息传递给函数，但将其封装在一个单独的对象中，而不是作为单独的值（[图7.1](#ch07fig01)）。
- en: Figure 7.1\. A single object as an argument is neater than multiple arguments.
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 将单个对象作为参数比多个参数更整洁。
- en: '![](07fig01_alt.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig01_alt.jpg)'
- en: 7.1.1\. Accessing properties of an object argument
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 访问对象参数的属性
- en: Inspired by the space adventures of New Horizons, Curiosity, Rosetta, and Philae,
    you decide to write a quick app for displaying information about the solar system.
    One feature of the app is to display information about planets.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 受到新地平线号、好奇号、罗塞塔号和菲莱号的太空探险的启发，你决定编写一个快速的应用程序来显示有关太阳系的信息。该应用程序的一个功能是显示有关行星的信息。
- en: 'Your first listing shows the `getPlanetInfo` function with a `planet` parameter.
    When you call the function using a `planet` object as an argument, the function
    body returns a string built using some of the planet’s properties. The code produces
    the following output:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个列表显示了具有 `planet` 参数的 `getPlanetInfo` 函数。当你使用 `planet` 对象作为参数调用该函数时，函数体返回一个使用行星的一些属性构建的字符串。该代码产生以下输出：
- en: '[PRE121]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Listing 7.1\. Passing a function an object as an argument ([http://jsbin.com/tafopo/edit?js,console](http://jsbin.com/tafopo/edit?js,console))
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 将对象作为参数传递给函数 ([http://jsbin.com/tafopo/edit?js,console](http://jsbin.com/tafopo/edit?js,console))
- en: '![](084fig01_alt.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![](084fig01_alt.jpg)'
- en: Passing an object to a function as a single argument is neat and tidy. There’s
    no need to make sure you’ve included all the required arguments in the right order—a
    single argument does the job.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象作为单个参数传递给函数既整洁又方便。无需确保你已按正确顺序包含所有必需的参数——单个参数就能完成工作。
- en: Once you’ve passed an object to a function, JavaScript automatically assigns
    it to the parameter included in the function’s definition.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将一个对象传递给一个函数，JavaScript 会自动将其分配给函数定义中包含的参数。
- en: You access the properties of the object through the parameter, as shown in [figure
    7.2](#ch07fig02). The function has full control of the object via the parameter;
    it can even add new properties.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过参数访问对象的属性，如图 [7.2](#ch07fig02) 所示。函数通过参数完全控制对象；它甚至可以添加新属性。
- en: Figure 7.2\. Object properties can be accessed inside the function body.
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 在函数体内可以访问对象属性。
- en: '![](07fig02_alt.jpg)'
  id: totrans-853
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: 7.1.2\. Adding properties to an object argument
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 向对象参数添加属性
- en: When you pass an object to a function as an argument, the code in the function
    body has access to the object’s properties. It can read them, change them, and
    delete them and can add new properties too.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个对象作为参数传递给一个函数时，函数体内的代码可以访问该对象的所有属性。它可以读取它们、更改它们、删除它们，也可以添加新的属性。
- en: '[Listing 7.2](#ch07ex02) shows two functions with `planet` parameters. When
    you pass a planet object, encapsulating a name and a radius, to the `calculateSizes`
    function, the function adds two new properties, `area` and `volume`, to the object
    ([figure 7.3](#ch07fig03)).'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.2](#ch07ex02) 显示了具有 `planet` 参数的两个函数。当你将包含名称和半径的行星对象传递给 `calculateSizes`
    函数时，该函数向对象添加两个新属性，`area` 和 `volume`（[图 7.3](#ch07fig03)）。'
- en: Figure 7.3\. The `calculateSizes` function adds new properties to the `planet`
    object.
  id: totrans-857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. `calculateSizes` 函数向 `planet` 对象添加新属性。
- en: '![](07fig03_alt.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig03_alt.jpg)'
- en: 'The `displaySizes` function uses the two new properties to print information
    about the planet on the console:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`displaySizes` 函数使用这两个新属性在控制台上打印有关行星的信息：'
- en: '[PRE122]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Listing 7.2\. A function that adds properties to an object ([http://jsbin.com/qevodu/edit?js,console](http://jsbin.com/qevodu/edit?js,console))
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 向对象添加属性的函数 ([http://jsbin.com/qevodu/edit?js,console](http://jsbin.com/qevodu/edit?js,console))
- en: '![](086fig01_alt.jpg)'
  id: totrans-862
  prefs: []
  type: TYPE_IMG
  zh: '![](086fig01_alt.jpg)'
- en: 'You create the `planet` object and assign it to the `planet1` variable:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建 `planet` 对象并将其分配给 `planet1` 变量：
- en: '[PRE123]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'When you call the `calculateSizes` function, you pass `planet1` to it as an
    argument:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `calculateSizes` 函数时，你将其参数 `planet1` 传递给它：
- en: '[PRE124]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'JavaScript assigns the object referred to by `planet1` to the `planet` parameter
    for use within the function. The function uses the `planet` parameter to add two
    new properties to the object, `planet.area` and `planet.volume`. By the time you
    call the `displaySizes` function, the object has the two new properties needed
    to display all the required information:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将 `planet1` 指向的对象分配给 `planet` 参数，以便在函数内部使用。函数使用 `planet` 参数向对象添加两个新属性，`planet.area`
    和 `planet.volume`。当你调用 `displaySizes` 函数时，对象已经有了显示所有所需信息所需的两个新属性：
- en: '[PRE125]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: As well as passing objects *to* functions, you can return objects *from* functions.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将对象传递给函数外，你还可以从函数返回对象。
- en: 7.2\. Returning objects from functions
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 从函数中返回对象
- en: Just as passing objects to functions as arguments is an efficient way of moving
    information to where it’s needed, so is using objects as return values. Functions
    can either manipulate objects that you pass to them and then return them, or they
    can return brand-new objects that they create in the function body.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将对象作为参数传递给函数是一种高效地将信息移动到所需位置的方法一样，使用对象作为返回值也是如此。函数可以操作你传递给它们的对象，然后返回它们，或者它们可以返回在函数体内创建的新对象。
- en: 'This section explores two examples: the first uses a number of parameters to
    build a new planet object and the second uses two object parameters to create
    a point in 2D space.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了两个示例：第一个使用多个参数来构建一个新的行星对象，第二个使用两个对象参数在 2D 空间中创建一个点。
- en: 7.2.1\. Building planets—an object creation function
  id: totrans-873
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 构建行星——对象创建函数
- en: 'Back with your solar system app, you decide to streamline the creation of planets.
    You write a function to which you pass the key facts, and it returns a `planet`
    object with properties set accordingly. Your `buildPlanet` function lets you create
    planets like this:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的太阳系应用程序中，你决定简化行星的创建。你编写了一个函数，将关键事实传递给它，然后它返回一个相应设置属性的 `planet` 对象。你的 `buildPlanet`
    函数让你可以创建像这样的行星：
- en: '[PRE126]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[Figure 7.4](#ch07fig04) shows how JavaScript assigns the arguments to parameters
    when you call `buildPlanet`. You use the parameters to create a new object.'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.4](#ch07fig04) 展示了当你调用 `buildPlanet` 时 JavaScript 如何将参数分配给参数。你使用这些参数来创建一个新对象。'
- en: Figure 7.4\. JavaScript assigns the arguments to parameters when you call `buildPlanet`.
    The function uses the parameters to create an object.
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 当你调用 `buildPlanet` 时，JavaScript 将参数分配给参数。该函数使用这些参数来创建一个对象。
- en: '![](07fig04_alt.jpg)'
  id: totrans-878
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: '[Listing 7.3](#ch07ex03) shows the definition of the `buildPlanet` function.
    It also has a `getPlanetInfo` function that it uses to get planet information
    for display. Once displayed, the information looks like this:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.3](#ch07ex03) 展示了 `buildPlanet` 函数的定义。它还有一个 `getPlanetInfo` 函数，它使用该函数来获取用于显示的行星信息。一旦显示，信息看起来像这样：'
- en: '[PRE127]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Notice here how the planet names are in uppercase. The `getPlanetInfo` function
    makes use of a built-in JavaScript function, `toUpperCase`, that converts strings
    to uppercase. `toUpperCase` and some other JavaScript functions will be discussed
    in [section 7.3](#ch07lev1sec3).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里行星名称是大写的。`getPlanetInfo` 函数使用了内置的 JavaScript 函数 `toUpperCase`，该函数将字符串转换为大写。`toUpperCase`
    和一些其他 JavaScript 函数将在 [第 7.3 节](#ch07lev1sec3) 中讨论。
- en: Listing 7.3\. A function to create planets ([http://jsbin.com/coyeta/edit?js,console](http://jsbin.com/coyeta/edit?js,console))
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 创建行星的函数 ([http://jsbin.com/coyeta/edit?js,console](http://jsbin.com/coyeta/edit?js,console))
- en: '![](088fig01_alt.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![图片](088fig01_alt.jpg)'
- en: 'The key-value pairs inside the object created by the `buildPlanet` function
    look a little strange at first:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `buildPlanet` 函数创建的对象中的键值对一开始看起来有点奇怪：
- en: '`name: name, position: position`, and so on.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`name: name, position: position`，等等。'
- en: For each key-value pair, the key is to the left of the colon and the value is
    to the right. You use the parameters as values, so for the function call
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个键值对，键位于冒号左侧，值位于冒号右侧。你使用参数作为值，所以对于函数调用
- en: '[PRE128]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: the object-creation code becomes
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 对象创建代码变为
- en: '[PRE129]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 7.2.2\. Points in 2D space
  id: totrans-890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 二维空间中的点
- en: 'Keen to create an animation showing the planets in the solar system, you start
    to investigate coordinates in two dimensions. All of the coordinates have two
    values associated with them, x and y. This seems like an obvious place to use
    objects. Each point is an object with x and y properties:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 热衷于创建一个显示太阳系中行星的动画，你开始研究二维坐标。所有坐标都与两个值相关联，x 和 y。这似乎是使用对象的一个明显的地方。每个点都是一个具有 x
    和 y 属性的对象：
- en: '[PRE130]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'You can access individual values using dot notation: `point1.x`, `point2.y`,
    and so on.'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用点符号来访问单个值：`point1.x`，`point2.y`，等等。
- en: As an initial experiment, you write a program to move a point a certain amount
    in the x direction and a certain amount in the y direction. Because the change
    in position also has x and y components, you use an object for that too. For example,
    to represent a movement of four across and two down you use the object `{` `x`
    `:` `4,` `y` `:` `-2` `}`.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始实验，你编写了一个程序，在 x 方向上移动一个点一定量，在 y 方向上移动一定量。因为位置的变化也有 x 和 y 的分量，所以你也使用一个对象来表示。例如，要表示向右移动四格和向下移动两格，你使用对象
    `{` `x` `:` `4,` `y` `:` `-2` `}`。
- en: '[Listing 7.4](#ch07ex04) includes a `move` function that takes two arguments,
    an initial point object and a change object. It returns a new point representing
    the final position if you started from the first point and moved by the change
    specified.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.4](#ch07ex04) 包含一个 `move` 函数，该函数接受两个参数，一个初始点对象和一个变化对象。如果你从第一个点开始，按照指定的变化移动，它将返回一个表示最终位置的新点。'
- en: 'The program uses a `showPoint` function to produce the following output:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用 `showPoint` 函数生成以下输出：
- en: '[PRE131]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Listing 7.4\. Moving a point in 2D ([http://jsbin.com/baxuvi/edit?js,console](http://jsbin.com/baxuvi/edit?js,console))
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 在 2D 中移动一个点 ([http://jsbin.com/baxuvi/edit?js,console](http://jsbin.com/baxuvi/edit?js,console))
- en: '![](090fig01_alt.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
  zh: '![](090fig01_alt.jpg)'
- en: 'The second argument you pass to the `move` function in [listing 7.4](#ch07ex04)
    is written using an object literal, `{ x : 4, y : -2 }`. You could assign it to
    a variable first but, because you use it only once, a literal value is okay too.
    The two points are plotted and their coordinates shown in [figure 7.5](#ch07fig05).'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '在[列表 7.4](#ch07ex04)中传递给`move`函数的第二个参数使用对象字面量 `{ x : 4, y : -2 }` 编写。你可以先将其分配给一个变量，但由于你只使用一次，直接量值也行。这两个点被绘制出来，它们的坐标在[图
    7.5](#ch07fig05)中显示。'
- en: Figure 7.5\. The points before and after the move of 4 across and 2 down (plotted
    using [desmos.com](http://desmos.com)—an application written in JavaScript)
  id: totrans-901
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5. 在4个单位向右和2个单位向下移动之前和之后的点（使用[desmos.com](http://desmos.com)绘制——一个用JavaScript编写的应用程序）
- en: '![](07fig05_alt.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig05_alt.jpg)'
- en: You’ve seen objects being passed to functions and objects being returned from
    functions and, in [listing 7.4](#ch07ex04), a function that uses objects as arguments
    and returns an object. That’s functions using objects. You can also set functions
    as properties of objects.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了对象被传递到函数中，对象从函数中返回，以及在[列表 7.4](#ch07ex04)中，一个使用对象作为参数并返回对象的函数。这就是函数使用对象。你还可以将函数设置为对象的属性。
- en: 7.3\. Methods—setting functions as properties of objects
  id: totrans-904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 方法——将函数设置为对象的属性
- en: In JavaScript, you can use functions as values, just like numbers, strings,
    and objects. That means you can pass them as arguments, return them from other
    functions, and set them as properties of objects. In this section, continuing
    the theme of functions working with objects, you look at an example of setting
    functions as properties of an object.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以像使用数字、字符串和对象一样使用函数作为值。这意味着你可以将它们作为参数传递，从其他函数中返回它们，并将它们设置为对象的属性。在本节中，继续探讨函数与对象一起工作的主题，你将查看一个将函数设置为对象属性的示例。
- en: 7.3.1\. Namespaces—organizing related functions
  id: totrans-906
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 命名空间——组织相关函数
- en: 'Let’s write some functions to help format text displayed on the console. Displaying
    text is a big part of your interactive console applications, so the number of
    helper functions you create will expand. For now, you start with two really simple
    functions: `blank` returns an empty string and `newLine` returns a new-line character.'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些函数来帮助格式化在控制台上显示的文本。显示文本是交互式控制台应用程序的一个重要部分，所以你创建的辅助函数的数量将会增加。现在，你从两个非常简单的函数开始：`blank`返回一个空字符串，`newLine`返回一个换行符。
- en: 'Because all of the functions are related to the same job, it’s good to collect
    them together. You can do just that by setting each function as the property of
    a single object. Call it `spacer`:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有函数都与同一项工作相关，所以将它们收集在一起是件好事。你可以通过将每个函数设置为单个对象的属性来实现这一点。称之为`spacer`：
- en: '[PRE132]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Once you have an object, you can set functions as properties. First, here’s
    a function to return an empty string:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个对象，你就可以将函数设置为属性。首先，这是一个返回空字符串的函数：
- en: '[PRE133]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[Figure 7.6](#ch07fig06) illustrates how you create the function and then assign
    it to the `blank` property of the `spacer` object.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.6](#ch07fig06)说明了如何创建函数并将其分配给`spacer`对象的`blank`属性。'
- en: Figure 7.6\. Create a function and assign it to an object property
  id: totrans-913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6. 创建一个函数并将其分配给对象属性
- en: '![](07fig06.jpg)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig06.jpg)'
- en: 'Sometimes it’s useful to include line breaks in a string, to space it over
    multiple lines. The special *escape sequence*, `"\n"`, is called the new-line
    character. Add a function to return the new-line character:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在字符串中包含换行符很有用，以便将其分散到多行。特殊的转义序列 `"\n"` 被称为换行符。添加一个函数来返回换行符：
- en: '[PRE134]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now you have two functions set as properties of the `spacer` object. When we
    use an object to collect functions together in this way, we call it a *namespace*.
    The `newLine` and `blank` functions belong to the `spacer` namespace. You can
    call the functions by adding parentheses as normal:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将两个函数设置为`spacer`对象的属性。当我们以这种方式使用对象收集函数时，我们称之为*命名空间*。`newLine`和`blank`函数属于`spacer`命名空间。你可以通过添加括号来调用函数，就像平常一样：
- en: '[PRE135]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'That code snippet produces this output:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码产生以下输出：
- en: '[PRE136]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The individual functions don’t have to be added to the namespace one at a time.
    You can use the object literal syntax, curly braces with comma-separated key-value
    pairs, to set up the namespace with properties in place:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 单个函数不必逐个添加到命名空间中。你可以使用对象字面量语法，即带有逗号分隔键值对的括号，来设置带有属性的命名空间：
- en: '[PRE137]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Functions set as properties of an object are called *methods*. Currently, the
    `spacer` object has two methods, `blank` and `newLine`. You’ll return to `spacer`
    in [sections 7.3.4](#ch07lev2sec8) and [7.3.5](#ch07lev2sec9), where you’ll add
    more methods and have a play with it on JS Bin.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象属性设置的功能被称为*方法*。目前，`spacer`对象有两个方法，`blank`和`newLine`。你将在[7.3.4](#ch07lev2sec8)和[7.3.5](#ch07lev2sec9)部分回到`spacer`，在那里你将添加更多方法，并在JS
    Bin上对其进行操作。
- en: JavaScript includes a number of useful objects and methods. Before you expand
    your `spacer` object, let’s investigate `Math` and `String` methods.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 包含了许多有用的对象和方法。在你扩展`spacer`对象之前，让我们来调查一下`Math`和`String`方法。
- en: 7.3.2\. Math methods
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. Math方法
- en: '`Math` is a namespace built into JavaScript that provides properties and functions
    all related to mathematical calculations. [Listing 7.5](#ch07ex05) shows the `Math.min`
    and `Math.max` methods in action. They return the smaller of two numbers and the
    larger of two numbers, respectively. The program produces the following output:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`是JavaScript中内置的一个命名空间，它提供了所有与数学计算相关的属性和函数。[列表7.5](#ch07ex05)展示了`Math.min`和`Math.max`方法的使用。它们分别返回两个数字中的较小值和较大值。程序产生以下输出：'
- en: '[PRE138]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Listing 7.5\. Using `Math.min` and `Math.max` ([http://jsbin.com/moyoti/edit?js,console](http://jsbin.com/moyoti/edit?js,console))
  id: totrans-928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. 使用`Math.min`和`Math.max` ([http://jsbin.com/moyoti/edit?js,console](http://jsbin.com/moyoti/edit?js,console))
- en: '![](093fig01_alt.jpg)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![](093fig01_alt.jpg)'
- en: '`Math.min` and `Math.max`, when used together, are useful for making sure a
    value is in a specified range. Say a `lineLength` variable has to be between 0
    and 40 inclusive. To force `lineLength` to be at least zero you can use'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 当一起使用时，`Math.min`和`Math.max`对于确保一个值在指定的范围内非常有用。比如说，一个`lineLength`变量必须介于0和40之间（包括0和40）。为了强制`lineLength`至少为零，你可以使用
- en: '[PRE139]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If `lineLength` is greater than zero, it will be the biggest and its value won’t
    change. But, if `lineLength` is less than zero, zero will be the biggest and `lineLength`
    will be assigned zero.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lineLength`大于零，它将是最大的，其值不会改变。但是，如果`lineLength`小于零，则零将是最大的，并且`lineLength`将被赋值为零。
- en: 'Similarly, you can force `lineLength` to be less than or equal to 40:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以强制`lineLength`小于或等于40：
- en: '[PRE140]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[Listing 7.6](#ch07ex06) shows such constraints in action. `line` is a function
    that returns a separator line of a specified length. The length must be between
    0 and 40\. Trying to display lines of length 30, 40, and 50 produces the following
    output:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.6](#ch07ex06)展示了这样的约束是如何工作的。`line`是一个返回指定长度分隔线的函数。长度必须在0到40之间。尝试显示长度为30、40和50的行会产生以下输出：'
- en: '[PRE141]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Notice, the last two lines are both of length 40\. Although 50 is specified
    as the length of the last line, the `line` function constrains the length to 40.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后两行长度都是40。尽管指定了最后一行的长度为50，但`line`函数将长度限制为40。
- en: Listing 7.6\. Using `Math.min` and `Math.max` to constrain an argument ([http://jsbin.com/qiziyo/edit?js,console](http://jsbin.com/qiziyo/edit?js,console))
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 使用`Math.min`和`Math.max`来约束参数 ([http://jsbin.com/qiziyo/edit?js,console](http://jsbin.com/qiziyo/edit?js,console))
- en: '![](093fig02_alt.jpg)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![](093fig02_alt.jpg)'
- en: The `substr` method returns part of a string and is discussed in the next section.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr`方法返回字符串的一部分，将在下一节中讨论。'
- en: There are a large number of `Math` methods for all kinds of mathematical tasks,
    many of which are used often. You can investigate some of them at [www.room51.co.uk/js/math.html](http://www.room51.co.uk/js/math.html).
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math`方法有很多，用于各种数学任务，其中许多经常被使用。你可以在[www.room51.co.uk/js/math.html](http://www.room51.co.uk/js/math.html)上调查其中的一些。'
- en: 7.3.3\. String methods
  id: totrans-942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 字符串方法
- en: 'For every string you create, JavaScript makes available a number of methods.
    These functions help you manipulate the strings in a variety of ways. The next
    listing uses the `toUpperCase` method to convert a string to uppercase, like this:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你创建的每个字符串，JavaScript 都提供了一系列方法。这些函数帮助你以各种方式操作字符串。下一个列表使用`toUpperCase`方法将字符串转换为大写，如下所示：
- en: '[PRE142]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Listing 7.7\. Converting a string to uppercase ([http://jsbin.com/jizaqu/edit?js,console](http://jsbin.com/jizaqu/edit?js,console))
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 将字符串转换为大写 ([http://jsbin.com/jizaqu/edit?js,console](http://jsbin.com/jizaqu/edit?js,console))
- en: '![](094fig01_alt.jpg)'
  id: totrans-946
  prefs: []
  type: TYPE_IMG
  zh: '![](094fig01_alt.jpg)'
- en: You use dot notation to call the method on the `planet` string. As a method,
    `toUpperCase` is able to use the value of the `planet` variable to which it’s
    attached; you don’t need to pass `planet` to the function as an argument in parentheses.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用点符号在`planet`字符串上调用方法。作为一个方法，`toUpperCase`能够使用附加到它的`planet`变量的值；你不需要将`planet`作为参数传递给函数。
- en: Although string methods can act on the variables to which they are attached,
    they’re still functions and you can also pass them arguments. [Figure 7.7](#ch07fig07)
    shows how the `substr` method uses the value of `message` and two arguments.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串方法可以作用于它们附加的变量，但它们仍然是函数，你也可以传递参数给它们。[图7.7](#ch07fig07)显示了`substr`方法如何使用`message`的值和两个参数。
- en: Figure 7.7\. Methods can use arguments as well as the value of the object to
    which they’re attached.
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7\. 方法可以使用参数以及它们附加的对象的值。
- en: '![](07fig07.jpg)'
  id: totrans-950
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig07.jpg)'
- en: The following listing shows an example of using the `substr` method, displaying
    a substring on the console.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了使用`substr`方法的示例，在控制台显示子字符串。
- en: '[PRE143]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Listing 7.8\. Finding substrings ([http://jsbin.com/mesisi/edit?js,console](http://jsbin.com/mesisi/edit?js,console))
  id: totrans-953
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. 查找子字符串 ([http://jsbin.com/mesisi/edit?js,console](http://jsbin.com/mesisi/edit?js,console))
- en: '[PRE144]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `substr` method accepts two arguments: the starting position in the original
    string and the number of characters to return. When specifying the position of
    a character in a string, counting is zero based: the first character is position
    0, the second position 1, the third position 2, and so on. (I know starting at
    zero seems a bit odd at first; it’s actually very common in programming languages.)'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr`方法接受两个参数：原始字符串中的起始位置和要返回的字符数。在指定字符串中字符的位置时，计数是从零开始的：第一个字符是位置0，第二个位置1，第三个位置2，依此类推。（我知道一开始从零开始可能有点奇怪；实际上，这在编程语言中是非常常见的。）'
- en: '| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |'
- en: '| W | e |   | c | h | o | o | s | e |   | t | o |  | g | o |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '| W | e |   | c | h | o | o | s | e |   | t | o |   | g | o |'
- en: '`substr(3,` `12)` starts with the character at position 3, *c*, and returns
    a string of length 12, from position 3 to position 14.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`substr(3,` `12)`从位置3的字符*c*开始，返回长度为12的字符串，从位置3到位置14。'
- en: But you don’t have to spend all your time counting the positions of characters
    in strings, however exciting that sounds; you can use the `indexOf` method instead.
    The `indexOf` method returns the position, or *index*, of the first occurrence
    of a specified search string within a string.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不必把所有时间都花在计算字符串中字符的位置上，尽管这听起来可能很有趣；你可以使用`indexOf`方法代替。`indexOf`方法返回指定搜索字符串在字符串中首次出现的位置，或称*索引*。
- en: The next listing uses `indexOf` to find the position of the *M* character in
    a string. It then passes the position to `substr` to grab a substring of length
    3, producing the bovine pronouncement `Moo` on the console.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表使用`indexOf`查找字符串中*M*字符的位置。然后将该位置传递给`substr`以获取长度为3的子字符串，在控制台产生牛叫声`Moo`。
- en: Listing 7.9\. Finding a character with `indexOf` ([http://jsbin.com/bidabi/edit?js,console](http://jsbin.com/bidabi/edit?js,console))
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. 使用`indexOf`查找字符 ([http://jsbin.com/bidabi/edit?js,console](http://jsbin.com/bidabi/edit?js,console))
- en: '[PRE145]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You can use `indexOf` to find search strings longer than a single character.
    Here’s an example using `message` from [listing 7.9](#ch07ex09):'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`indexOf`查找比单个字符更长的搜索字符串。以下是一个使用[列表7.9](#ch07ex09)中的`message`的示例：
- en: '[PRE146]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Notice that `indexOf` is case sensitive, so *the* and *The* are different, and
    it returns `-1` if a string is not found.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`indexOf`是区分大小写的，所以*the*和*The*是不同的，如果字符串未找到，则返回`-1`。
- en: 'Just like for `Math`, there are a lot of `String` methods available in JavaScript.
    Once again, the book’s website has you covered: [www.room51.co.uk/js/string-methods.html](http://www.room51.co.uk/js/string-methods.html).'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Math`一样，JavaScript中有许多`String`方法可用。再次强调，本书的网站为你提供了所有信息：[www.room51.co.uk/js/string-methods.html](http://www.room51.co.uk/js/string-methods.html)。
- en: '|  |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: '**“So, are strings objects now?”**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**“那么，字符串现在是对象了吗？”**'
- en: 'In [listing 7.7](#ch07ex07), the string `"Jupiter"` is assigned to the `planet`
    variable. The `toUpper``Case` method is then called: `planet.toUpperCase();`.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.7](#ch07ex07)中，字符串`"Jupiter"`被分配给`planet`变量。然后调用`toUpper``Case`方法：`planet.toUpperCase();`。
- en: If methods are functions set as properties of objects, how is it we can call
    methods on strings?
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法是被设置为对象属性的函数，那么我们是如何在字符串上调用方法的呢？
- en: Well, behind the scenes, whenever we access a string value, JavaScript creates
    a special `String` object that wraps the value. That object includes all the handy
    string methods. Once the statement has finished executing, the object is destroyed.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在幕后，每次我们访问字符串值时，JavaScript都会创建一个特殊的`String`对象来包装该值。该对象包括所有方便的字符串方法。一旦语句执行完毕，该对象就会被销毁。
- en: So, no, *strings are not objects*, but JavaScript provides a useful way to give
    us properties and methods for working with them.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不，*字符串不是对象*，但 JavaScript 提供了一种有用的方式来为我们提供处理它们的属性和方法。
- en: '|  |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.4\. spacer—more methods for your namespace
  id: totrans-974
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. spacer—为你的命名空间添加更多方法
- en: In [section 7.3.1](#ch07lev2sec5) you created a `spacer` object with a couple
    of functions attached, `blank` and `newLine`. You now add a few more interesting
    functions to help format your output nicely.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7.3.1 节](#ch07lev2sec5) 中，你创建了一个带有 `blank` 和 `newLine` 函数的 `spacer` 对象。你现在可以添加一些更有趣的函数来帮助你格式化输出。
- en: '`line` is your line separator function, upgraded! It returns a line of a given
    length between 0 and 40 characters long, now with a choice of five gorgeous characters!
    (`"*"`, `"+"`, `"="`, `"-"`, or `" "`).'
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line` 是你的行分隔函数，升级版！它返回长度在 0 到 40 个字符之间的行，现在可以选择五种华丽的字符！(`"*"`, `"+"`, `"="`,
    `"-"`, 或 `" "`)。'
- en: '[PRE147]'
  id: totrans-977
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`wrap` returns text padded to a given length with added prefix and suffix characters.'
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrap` 返回添加了前缀和后缀字符的填充到指定长度的文本。'
- en: '[PRE148]'
  id: totrans-979
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '`box` returns text padded to a given length, with a line of characters above
    and below.'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`box` 返回填充到指定长度的文本，上方和下方有一行字符。'
- en: '[PRE149]'
  id: totrans-981
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The following listing shows the code for your new methods. Notice that `spacer.wrap`
    uses `spacer.line` to pad the text with space characters and `spacer.box` uses
    both `spacer.line` and `spacer.wrap` to generate its box outline. You’ll look
    in detail at how the new methods work after the listing.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了新方法的代码。注意 `spacer.wrap` 使用 `spacer.line` 用空格字符填充文本，而 `spacer.box` 使用
    `spacer.line` 和 `spacer.wrap` 来生成其框轮廓。在列表之后，你将详细了解新方法的工作原理。
- en: Listing 7.10\. Organizing functions as object properties ([http://jsbin.com/kayono/edit?js,console](http://jsbin.com/kayono/edit?js,console))
  id: totrans-983
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 将函数作为对象属性组织 ([http://jsbin.com/kayono/edit?js,console](http://jsbin.com/kayono/edit?js,console))
- en: '![](ch07ex10-0.jpg)'
  id: totrans-984
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex10-0.jpg)'
- en: '![](ch07ex10-1.jpg)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex10-1.jpg)'
- en: '|  |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Notice how the `wrap` and `box` methods use the same parameters in the same
    order: `text`, `length`, and `character`. The `line` method has only two of those
    three parameters but is also consistent with the ordering: `length` and `character`.
    Such a conscious choice of parameter order reduces the chance of errors when calling
    the methods.'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `wrap` 和 `box` 方法如何使用相同的参数顺序：`text`、`length` 和 `character`。`line` 方法只有这三个参数中的两个，但也是一致的：`length`
    和 `character`。这种有意识的参数顺序选择减少了调用方法时的错误概率。
- en: '|  |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.5\. Deep namespace exploration
  id: totrans-990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.5\. 深层次命名空间探索
- en: 'So how do your wonderful new methods work? Be brave and curious as you indulge
    in some deep namespace exploration. And remember, you can try code out on JS Bin,
    both in the JavaScript panel and at the prompt. For example, for the `line` method
    explanation that follows, declare and assign the `longString` variable at the
    console prompt:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你这些奇妙的新方法是如何工作的呢？大胆且好奇地沉浸在一些深层次的命名空间探索中。记住，你可以在 JS Bin 上尝试代码，无论是在 JavaScript
    面板还是在提示符中。例如，对于接下来的 `line` 方法说明，请在控制台提示符中声明并分配 `longString` 变量：
- en: '[PRE150]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Then you can try out the `indexOf` method:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以尝试 `indexOf` 方法：
- en: '[PRE151]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Be playful and take your time. But don’t worry if you don’t follow everything
    the first time; the methods use a lot of ideas you’ve only just met. Stick with
    it; learning follows thinking.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 俏皮地玩，慢慢来。但如果你第一次没有完全跟上，不要担心；这些方法使用了你刚刚接触到的许多想法。坚持下去；学习跟随思考。
- en: The line method
  id: totrans-996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 行方法
- en: 'Both the `wrap` and `box` methods use the trusty `line` method. It returns
    a string of a given length made up of one of five repeated characters:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrap` 和 `box` 方法都使用了可靠的 `line` 方法。它返回由五个重复字符组成的一定长度的字符串：'
- en: '[PRE152]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The method starts by creating one long string made up of all of the characters
    to be made available. It uses the `+=` operator to append new strings to an existing
    string. The variable `longString` ends up as a string of the following form:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先创建一个由所有可用字符组成的长字符串。它使用 `+=` 操作符将新字符串追加到现有字符串中。变量 `longString` 最终形成以下形式的字符串：
- en: '[PRE153]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'This snippet has 10 of each character, whereas the actual method has 40 of
    each. The code uses the string method `indexOf` to find the position of the first
    character that matches the one specified when you call `line`. Here’s an example,
    using the shorter snippet shown previously:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段有每种字符 10 个，而实际方法有 40 个。代码使用字符串方法 `indexOf` 来找到当你调用 `line` 时指定的第一个匹配字符的位置。以下是一个示例，使用之前显示的较短的片段：
- en: '[PRE154]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Having found where the requested character first appears, the code then uses
    `substr` to grab a substring of the specified length:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 找到请求的字符首次出现的位置后，代码接着使用 `substr` 来获取指定长度的子字符串：
- en: '[PRE155]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'But the `line` method doesn’t use hard-coded values; it uses parameters, `length`
    and `character`, to hold the arguments passed in when you call it:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `line` 方法不使用硬编码的值；它使用参数 `length` 和 `character` 来保存调用时传入的参数：
- en: '[PRE156]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The extra variables aren’t really needed, although they could be used to make
    the method easier to follow. `line` finds the substring and returns it in one
    go:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的变量实际上并不需要，尽管它们可以被用来使方法更容易理解。`line` 方法找到子字符串，并一次性返回它：
- en: '[PRE157]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Notice that a space is one of the available characters. Strings of spaces can
    be used to pad titles and boxes on the console. The `wrap` method uses `line`
    to do just that.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到空格是可用的字符之一。空格字符串可以用来在控制台上填充标题和框。`wrap` 方法就是用这种方法来做的。
- en: The wrap method
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`wrap` 方法'
- en: 'To form the middle line of some boxed text, the `wrap` method returns a string
    of a specified length. The `character` argument specifies the first and last characters
    of the string:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 要形成某些框文本的中间行，`wrap` 方法返回一个指定长度的字符串。`character` 参数指定了字符串的第一个和最后一个字符：
- en: '[PRE158]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Here are some strings of increasing length returned by `wrap`:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `wrap` 方法返回的长度递增的字符串：
- en: '[PRE159]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The method pads the last character with spaces on its left to make the whole
    string the correct length ([figure 7.8](#ch07fig08)).
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过在左侧用空格填充最后一个字符，使整个字符串达到正确的长度（[图 7.8](#ch07fig08)）。
- en: Figure 7.8\. The wrapped text is made up of character + space + text + padding
    + character.
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 包裹的文本由字符 + 空格 + 文本 + 填充 + 字符组成。
- en: '![](07fig08.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig08.jpg)'
- en: 'To find the length of the padding, start with the desired length of the whole
    string and subtract the length of the text you’re wrapping and then three more
    to account for the first character, the leading space, and the last character:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到填充的长度，首先从整个字符串期望的长度开始，减去你要包裹的文本长度，然后再减去三个字符，以考虑到第一个字符、前导空格和最后一个字符：
- en: '[PRE160]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'JavaScript makes the `length` property available on all strings:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 在所有字符串上提供了 `length` 属性：
- en: '[PRE161]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Having calculated the required length of the padding, `wrap` then enlists the
    help of the `line` method to grab a string of spaces of that length:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出所需的填充长度后，`wrap` 方法接着请求 `line` 方法的帮助来获取该长度的空格字符串：
- en: '[PRE162]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The `wrap` method builds the string to be returned by concatenating all the
    pieces: character, space, text, padding, character.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrap` 方法通过连接所有部分来构建要返回的字符串：字符、空格、文本、填充、字符。'
- en: The box method
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 框方法
- en: 'And finally, the `box` method uses `line` and `wrap` to surround a string in
    a box of a specified length:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`box` 方法使用 `line` 和 `wrap` 来将字符串包裹在指定长度的框中：
- en: '[PRE163]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The method uses `newLine` so that the single returned string can span multiple
    lines on the console:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用 `newLine`，这样返回的单个字符串可以在控制台上跨越多行：
- en: '[PRE164]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Excellent! The `spacer` namespace now has a number of useful methods to format
    the display of information on the console. They’ll be really handy in *The Crypt*.
    So, let’s mix them in!
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`spacer` 命名空间现在有了一些有用的方法来格式化控制台上的信息显示。它们在《The Crypt》中将会非常有用。所以，让我们混合它们吧！
- en: 7.4\. The Crypt–player objects as arguments
  id: totrans-1031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 《The Crypt》– 玩家对象作为参数
- en: You’ll now apply your knowledge of JavaScript objects as arguments, return values,
    and namespaces to *The Crypt*. [Figure 7.9](#ch07fig09) shows where the focus
    of this section, showing player information by using functions with objects, fits
    into the overall structure of our ongoing game example.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用关于 JavaScript 对象作为参数、返回值和命名空间的知识到《The Crypt》中。[图 7.9](#ch07fig09) 显示了本节的重点，即通过使用带有对象的函数来显示玩家信息，如何融入到我们正在进行的游戏示例的整体结构中。
- en: Figure 7.9\. Elements in *The Crypt*
  id: totrans-1033
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 《The Crypt》中的元素
- en: '![](07fig09_alt.jpg)'
  id: totrans-1034
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig09_alt.jpg)'
- en: 'In [chapter 6](kindle_split_014.html#ch06) you built up a number of functions
    to help display information about players in the game. The functions rely on separate
    arguments for different player properties. Here’s the `getPlayerInfo` function
    being called:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](kindle_split_014.html#ch06) 中，你建立了一系列函数来帮助显示游戏中玩家的信息。这些函数依赖于不同玩家属性的单独参数。以下是
    `getPlayerInfo` 函数的调用示例：
- en: '[PRE165]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: You’ve seen in this chapter that you can simply pass a player object as an argument
    and let the function pick out the properties it needs. The `getPlayerInfo` function
    call should become
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中已经看到，你可以简单地传递一个玩家对象作为参数，让函数挑选出它需要的属性。`getPlayerInfo` 函数调用应该是
- en: '[PRE166]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Much neater!
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 很整洁！
- en: You can use the helper methods in your `spacer` namespace to format the text—`box`
    and `wrap` will do the trick. But how can you find the right box length to snugly
    wrap the information? The `place` string will probably be the longest, but might
    the `health` string sometimes stretch farther?
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `spacer` 命名空间中的辅助方法来格式化文本——`box` 和 `wrap` 就能解决问题。但你怎么能找到合适的框长度来紧密包裹信息？`place`
    字符串可能是最长的，但 `health` 字符串有时可能会更长？
- en: '[PRE167]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'You have to check which is the longest. The `Math.max` method has you covered:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须检查哪个是最长的。`Math.max` 方法可以解决这个问题：
- en: '[PRE168]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Don’t forget the border and single space at either end:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记两端的外边框和单空格：
- en: '[PRE169]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The following listing uses the `spacer` namespace methods, so the live example
    includes that code on JS Bin.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表使用了 `spacer` 命名空间的方法，因此 JS Bin 上的实时示例包括该代码。
- en: Listing 7.11\. Displaying player information using objects ([http://jsbin.com/beqabe/edit?js,console](http://jsbin.com/beqabe/edit?js,console))
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 使用对象显示玩家信息 ([http://jsbin.com/beqabe/edit?js,console](http://jsbin.com/beqabe/edit?js,console))
- en: '![](ch07ex11-0.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex11-0.jpg)'
- en: '![](ch07ex11-1.jpg)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex11-1.jpg)'
- en: 7.5\. Summary
  id: totrans-1050
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 概述
- en: 'Use objects as arguments and access their properties from within the function
    body:'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象作为参数，并在函数体内访问它们的属性：
- en: '[PRE170]'
  id: totrans-1052
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Update objects and add new properties from within the function body:'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数体内更新对象并添加新属性：
- en: '[PRE171]'
  id: totrans-1054
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Return new or existing objects from functions, using the `return` keyword:'
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `return` 关键字从函数中返回新或现有对象：
- en: '[PRE172]'
  id: totrans-1056
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Create *methods* by setting functions as properties of objects.
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将函数设置为对象的属性来创建 *方法*。
- en: 'Use objects as *namespaces* to collect related functions and properties:'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象作为 *命名空间* 来收集相关的函数和属性：
- en: '[PRE173]'
  id: totrans-1059
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Make use of the `Math` object and its methods, like `Math.max` and `Math.min`.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `Math` 对象及其方法，如 `Math.max` 和 `Math.min`。
- en: Use the `length` property of strings and string methods like `indexOf` and `substr`.
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串的 `length` 属性和字符串方法，如 `indexOf` 和 `substr`。
- en: 'Chapter 8\. Arrays: putting data into lists'
  id: totrans-1062
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 数组：将数据放入列表
- en: '***This chapter covers***'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Grouping values as lists
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值分组为列表
- en: Creating an array
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个数组
- en: Accessing elements in an array
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数组中的元素
- en: Manipulating the elements in an array
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数组中的元素
- en: Using `forEach` to visit each element
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `forEach` 遍历每个元素
- en: 'Almost everything you’ve covered so far has been about organizing your data
    or organizing your code. This chapter continues that theme but with a twist: it’s
    not just about grouping items; now you can put them in order.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所学到的几乎所有内容都是关于组织你的数据或组织你的代码。本章继续这一主题，但有所变化：它不仅仅是关于分组项目；现在你可以将它们排序。
- en: In *The Crypt*, you’ll finally have the ability for players to collect items
    they find on the journey; with arrays they can start on their very own treasure
    hoards.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *The Crypt* 中，你将最终拥有玩家收集他们在旅途中找到的物品的能力；使用数组，他们可以开始他们的个人宝藏积累。
- en: 8.1\. Creating arrays and accessing elements
  id: totrans-1071
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 创建数组和访问元素
- en: Working with lists is an essential part of programming. Blog posts, quiz questions,
    stock prices, emails, files, tweets, and bank transactions all turn up as lists.
    In fact, you’ve just read a list of lists! Sometimes the order doesn’t matter
    and sometimes it does. A list of names could represent the members of a team,
    with no order, or it could represent places in a race—I’m sure Usain Bolt thinks
    the order is important there! An ordered list is called an *array* in JavaScript,
    as it is in many programming languages.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列表是编程的基本部分。博客文章、测验问题、股票价格、电子邮件、文件、推文和银行交易都表现为列表。实际上，你刚刚读到的就是一个列表的列表！有时顺序无关紧要，有时则很重要。在
    JavaScript 中，有序列表被称为 *数组*，就像在许多编程语言中一样。
- en: The items in an array are called its *elements* and you usually want to work
    on the elements in some way. You might want to
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的项称为其 *元素*，你通常想以某种方式处理这些元素。你可能想
- en: Perform some action with each element, say display it on the console or increase
    it by 20%
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每个元素执行某些操作，例如在控制台上显示它或将其增加 20%
- en: Find only certain elements that match a condition, say all tweets by Lady Gaga,
    blog posts in a given month, or questions answered correctly
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅找到符合特定条件的某些元素，例如 Lady Gaga 的所有推文、给定月份的博客文章或正确回答的问题
- en: Combine all the elements into a single value, say to find the total of a list
    of prices or the average number of points scored per game
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有元素组合成一个单一值，例如找到价格列表的总和或每场比赛平均得分的数量
- en: The array object in JavaScript provides functions to help you perform all of
    these actions and more. But, we’re getting ahead of ourselves. Let’s go back to
    the start and find out how to create an array.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的数组对象提供了帮助您执行所有这些操作以及更多操作的功能。但是，我们可能有些过于急切了。让我们回到起点，了解如何创建一个数组。
- en: 8.1.1\. Creating an array
  id: totrans-1078
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 创建数组
- en: To create an array, use square brackets. Once it’s created, you can assign the
    array to a variable so you can refer to it in your code. [Figure 8.1](#ch08fig01)
    illustrates the process.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数组，请使用方括号。一旦创建，你可以将数组分配给一个变量，这样你就可以在代码中引用它。[图 8.1](#ch08fig01)说明了这个过程。
- en: Figure 8.1\. Use square brackets to create an array
  id: totrans-1080
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. 使用方括号创建数组
- en: '![](08fig01.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01.jpg)'
- en: 'The following listing creates two arrays and displays them on the console to
    give this output:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表创建了两个数组，并在控制台上显示它们，以给出以下输出：
- en: '[PRE174]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Listing 8.1\. Creating arrays ([http://jsbin.com/cevodu/edit?js,console](http://jsbin.com/cevodu/edit?js,console))
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 创建数组([http://jsbin.com/cevodu/edit?js,console](http://jsbin.com/cevodu/edit?js,console))
- en: '![](105fig01_alt.jpg)'
  id: totrans-1085
  prefs: []
  type: TYPE_IMG
  zh: '![图片](105fig01_alt.jpg)'
- en: Commas separate the elements, which can be numbers, strings, objects, functions,
    or any data type or mix of types—you can even have arrays of arrays. Like the
    curly braces for objects and the `function` keyword for functions, the square
    brackets tell JavaScript to create an array. Once it’s created, you can assign
    the array to a variable, set it as a property, include it in another array, or
    pass it to a function.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔元素，这些元素可以是数字、字符串、对象、函数或任何数据类型，甚至可以是数组的数组。就像对象的大括号和函数的关键字`function`一样，方括号告诉JavaScript创建一个数组。一旦创建，你可以将数组分配给一个变量，将其设置为属性，将其包含在另一个数组中，或者将其传递给一个函数。
- en: '[Listing 8.2](#ch08ex02) creates a couple of arrays of objects representing
    places to visit, `thisYear` and `nextYear`. [Figure 8.2](#ch08fig02) shows how
    JS Bin displays the arrays of objects.'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.2](#ch08ex02)创建了一些表示要访问地点的对象数组，`thisYear`和`nextYear`。[图 8.2](#ch08fig02)显示了JS
    Bin如何显示对象数组。'
- en: Figure 8.2\. JS Bin displays each of the two arrays in [listing 8.2](#ch08ex02)
    between square brackets.
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. JS Bin在[列表 8.2](#ch08ex02)中用方括号显示了两个数组。
- en: '![](08fig02_alt.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig02_alt.jpg)'
- en: Listing 8.2\. Using existing objects in an array ([http://jsbin.com/gizulu/edit?js,console](http://jsbin.com/gizulu/edit?js,console))
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 在数组中使用现有对象([http://jsbin.com/gizulu/edit?js,console](http://jsbin.com/gizulu/edit?js,console))
- en: '![](106fig01_alt.jpg)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![图片](106fig01_alt.jpg)'
- en: 8.1.2\. Accessing array elements
  id: totrans-1092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 访问数组元素
- en: You’ve created an array and assigned it to a variable, so now you can pass that
    variable to functions, like `console.log`. At some point you’ll want to access
    the elements that make up the array, to peel away the skin to get at the juicy
    goodness inside. Well, those square brackets do double duty; they enclose the
    list when you define the array, and you use them to access individual elements.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个数组并将其分配给一个变量，所以现在你可以将这个变量传递给函数，比如`console.log`。在某个时候，你将想要访问构成数组的元素，剥去外壳以获取里面的精华。嗯，那些方括号是双面刀；当你定义数组时，它们包围着列表，你使用它们来访问单个元素。
- en: As shown in [figure 8.3](#ch08fig03), you specify each element with an index,
    a whole number marking where in the list the element occurs. The first element
    in an array has an index of 0, the second an index of 1, and so on. You can think
    of the index as an offset from the start of the array; the first element is zero
    away from the start, the second is one away from the start, and so on.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 8.3](#ch08fig03)所示，你使用索引指定每个元素，这是一个表示元素在列表中位置的整数。数组中的第一个元素索引为0，第二个元素索引为1，依此类推。你可以将索引视为从数组开始处的偏移量；第一个元素距离开始为零，第二个元素距离开始为一，依此类推。
- en: Figure 8.3\. Each element of an array has an index, starting at 0.
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 数组的每个元素都有一个索引，从0开始。
- en: '![](08fig03.jpg)'
  id: totrans-1096
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig03.jpg)'
- en: To retrieve the value of an element at a given index, put the index inside square
    brackets after the name of a variable to which the array has been assigned, as
    shown in [figure 8.4](#ch08fig04).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索给定索引处的元素的值，请将索引放在分配给数组的变量的名称后面的方括号内，如图[图 8.4](#ch08fig04)所示。
- en: Figure 8.4\. Use square brackets and an index to access elements of an array
    assigned to a variable
  id: totrans-1098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. 使用方括号和索引访问分配给变量的数组元素
- en: '![](08fig04_alt.jpg)'
  id: totrans-1099
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04_alt.jpg)'
- en: 'Here, you create an array and assign it to a variable:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你创建了一个数组并将其分配给一个变量：
- en: '[PRE175]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'To get the value of the third item in the array, `8`, place the index, `2`
    (because you start with `0`), in square brackets after the name of the variable:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数组中第三项的值，`8`，将索引 `2`（因为从 `0` 开始）放在变量名称后面的方括号中：
- en: '[PRE176]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You can assign `scores[2]` to another variable, set it as a property on an
    object, use it in an expression, or pass it as an argument to a function. [Listing
    8.3](#ch08ex03) creates strings using the values of elements in the `scores` array
    and displays them on the console to give the following:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `scores[2]` 赋值给另一个变量，将其设置为对象的属性，在表达式中使用它，或者将其作为函数的参数传递。[列表 8.3](#ch08ex03)
    使用 `scores` 数组中的值创建字符串，并在控制台上显示以下内容：
- en: '[PRE177]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: It also makes use of the array’s `length` property that simply gives the number
    of elements in the array.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 它还使用了数组的 `length` 属性，它简单地给出了数组中的元素数量。
- en: Listing 8.3\. Accessing array elements ([http://jsbin.com/qemufe/edit?js,console](http://jsbin.com/qemufe/edit?js,console))
  id: totrans-1107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 访问数组元素 ([http://jsbin.com/qemufe/edit?js,console](http://jsbin.com/qemufe/edit?js,console))
- en: '![](108fig01_alt.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
  zh: '![](108fig01_alt.jpg)'
- en: Now, say you have a `days` array, holding the names of the weekdays, and you
    want to get the name of a particular day in the week, maybe the fourth day.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你有一个 `days` 数组，包含一周中每一天的名称，你想要获取一周中特定一天的名字，比如第四天。
- en: '[PRE178]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: There’s a mismatch between the index in JavaScript and the words used to describe
    a particular element. The first day of the week has index 0\. The fourth day of
    the week has index 3\. You might want to access a different day at different times,
    so you could use a variable, `dayInWeek`, to hold the day in the week you want.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的索引和描述特定元素的单词之间存在不匹配。一周的第一天索引为 0。一周的第四天索引为 3。你可能想在不同的时间访问不同的日子，所以你可以使用一个变量，`dayInWeek`，来保存你想要的一周中的哪一天。
- en: '[PRE179]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: But using `dayInWeek` as the index for the array will give you the wrong day.
    An index of 4 will give you the fifth day in the week.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用 `dayInWeek` 作为数组的索引会给你错误的一天。索引 4 会给你一周中的第五天。
- en: 'The next listing shows code for this scenario. It displays two days on the
    console: the wrong one (that is, not the fourth day of the week) and then the
    right one:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了这段代码。它在控制台上显示了两天：错误的一天（即，不是一周中的第四天）然后是正确的一天：
- en: '[PRE180]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Listing 8.4\. Using a variable as an index ([http://jsbin.com/veyexa/edit?js,console](http://jsbin.com/veyexa/edit?js,console))
  id: totrans-1116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 使用变量作为索引 ([http://jsbin.com/veyexa/edit?js,console](http://jsbin.com/veyexa/edit?js,console))
- en: '![](108fig02_alt.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![](108fig02_alt.jpg)'
- en: The first call to `console.log` displays the wrong day because the `dayInWeek`
    variable doesn’t take into account that arrays are zero-based; they start with
    an index of 0, not 1\. The second call to `console.log` fixes the problem by subtracting
    one from `dayInWeek`; the fourth day of the week has an index of 3.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `console.log` 显示了错误的日子，因为 `dayInWeek` 变量没有考虑到数组是从零开始的；它们从索引 0 开始，而不是 1。第二次调用
    `console.log` 通过从 `dayInWeek` 减去一来修复这个问题；一周中的第四天索引为 3。
- en: 'Okay. It’s time to hold onto your hat. In [listing 8.5](#ch08ex05) you’ll define
    a function and add it to the mix. The local pencil museum records the number of
    visitors through its doors each day. The owners ask you to create a program that,
    when given a week’s worth of visitor numbers as an array, will display how many
    visitors there were on a given day:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。现在是时候戴上你的帽子了。在 [列表 8.5](#ch08ex05) 中，你将定义一个函数并将其添加到混合中。当地的铅笔博物馆记录每天通过其大门的游客数量。老板要求你创建一个程序，当给定一周的游客数量数组时，将显示特定一天有多少游客：
- en: '[PRE181]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: You decide to write a function, `getVisitorReport`, to generate the report and
    return it. You then would have the option of displaying the report on the console,
    on a web page, or in an email. In the next listing you generate a report for a
    Tuesday and display it on the console.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定编写一个函数，`getVisitorReport`，来生成报告并返回它。然后你就有选择在控制台、网页或电子邮件中显示报告的选项。在下一个列表中，你生成了一份关于星期二的报告并在控制台上显示它。
- en: Listing 8.5\. Passing an array to a function ([http://jsbin.com/bewebi/edit?js,console](http://jsbin.com/bewebi/edit?js,console)
  id: totrans-1122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 将数组传递给函数 ([http://jsbin.com/bewebi/edit?js,console](http://jsbin.com/bewebi/edit?js,console))
- en: '![](109fig01_alt.jpg)'
  id: totrans-1123
  prefs: []
  type: TYPE_IMG
  zh: '![](109fig01_alt.jpg)'
- en: You create an array of visitor numbers, assign it to the `visitors` variable,
    and pass it to the `getVisitorReport` function as an argument. Within the function,
    the array is assigned to the `visitorArray` variable and used to generate the
    report. The report is returned from the function, assigned to the `report` variable,
    and displayed on the console. The `+=` operator in the function adds the value
    on its right to the variable on its left. Because a string has been assigned to
    the `visitorReport` variable, `+=` concatenates the value on its right to the
    variable on its left.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个包含访客数量的数组，将其分配给 `visitors` 变量，并将其作为参数传递给 `getVisitorReport` 函数。在函数内部，数组被分配给
    `visitorArray` 变量，并用于生成报告。报告从函数返回，分配给 `report` 变量，并在控制台上显示。函数中的 `+=` 运算符将其右侧的值添加到左侧的变量中。因为
    `visitorReport` 变量已被分配了一个字符串，`+=` 将其右侧的值连接到左侧的变量。
- en: So, you can create an array and access its elements. But, once you have data
    in an array, there’s a whole host of ways you can manipulate it. Let’s get started
    with a few of the most common ways to work with arrays.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以创建一个数组并访问其元素。但是，一旦数组中有数据，你就有很多种方法可以操作它。让我们从一些最常见的工作方式开始。
- en: 8.2\. Array methods
  id: totrans-1126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 数组方法
- en: Arrays are a type of object provided by the JavaScript language to help you
    manage lists. JavaScript also provides you with a number of functions you can
    use to work with arrays. When we assign functions to properties of an object,
    we call the functions *methods* of the object; arrays are a type of object, so
    their functions are also called methods.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 JavaScript 语言提供的一种对象类型，用于帮助你管理列表。JavaScript 还为你提供了一系列你可以用来操作数组的函数。当我们将函数分配给对象的属性时，我们称这些函数为对象的
    *方法*；数组是一种对象类型，因此它们的函数也称为方法。
- en: 'In this section you look at just a few of the many methods available when working
    with arrays: `push` and `pop` and `splice` let you add and remove elements, `slice`
    lets you grab consecutive elements, `join` lets you concatenate the array elements
    to form a string, and `forEach` allows you to pass each element as an argument
    to a specified function. These methods are summarized in [table 8.1](#ch08table01).
    Further array methods and examples can be found on the book’s website at [www.room51.co.uk/js/array-methods.html](http://www.room51.co.uk/js/array-methods.html).'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将查看与数组一起工作时可用的许多方法中的一些：`push` 和 `pop` 和 `splice` 允许你添加和删除元素，`slice` 允许你获取连续元素，`join`
    允许你连接数组元素以形成字符串，而 `forEach` 允许你将每个元素作为参数传递给指定的函数。这些方法总结在 [表 8.1](#ch08table01)
    中。更多数组方法和示例可以在本书的网站上找到，网址为 [www.room51.co.uk/js/array-methods.html](http://www.room51.co.uk/js/array-methods.html)。
- en: Table 8.1\. Array methods
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. 数组方法
- en: '| Method | What’s it for? | Example |'
  id: totrans-1130
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用于什么？ | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-1131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| push | Appending an element to the end of an array. | items.push("Put me
    last"); |'
  id: totrans-1132
  prefs: []
  type: TYPE_TB
  zh: '| push | 将一个元素追加到数组的末尾。 | items.push("Put me last"); |'
- en: '| pop | Removing an item from the end of an array. | wasLast = items.pop();
    |'
  id: totrans-1133
  prefs: []
  type: TYPE_TB
  zh: '| pop | 从数组的末尾删除一个项目。 | wasLast = items.pop(); |'
- en: '| join | Concatenating all of the elements in the array, inserting an optional
    string between each pair of elements. | allItems = items.join(","); |'
  id: totrans-1134
  prefs: []
  type: TYPE_TB
  zh: '| join | 连接数组中的所有元素，在每对元素之间插入一个可选的字符串。 | allItems = items.join(","); |'
- en: '| slice | Creating an array from a range of elements in an existing array.
    Passing in the indexes at which to start and stop the range. | section = items.slice(2,
    5); |'
  id: totrans-1135
  prefs: []
  type: TYPE_TB
  zh: '| slice | 从现有数组中创建一个包含一系列元素的数组。传入开始和停止范围的索引。 | section = items.slice(2, 5);
    |'
- en: '| splice | Changing an array by adding and/or removing consecutive elements.
    Passing in the index at which to start removing elements, the number of elements
    to remove, and any elements to add. | out = items.splice(1,2,"new"); |'
  id: totrans-1136
  prefs: []
  type: TYPE_TB
  zh: '| splice | 通过添加和/或删除连续元素来更改数组。传入开始删除元素的索引、要删除的元素数量以及要添加的任何元素。 | out = items.splice(1,2,"new");
    |'
- en: '| forEach | Passing each element in turn to a specified function. | items.forEach(function
    (item){ console.log(item);'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '| forEach | 将每个元素依次传递给指定的函数。 | items.forEach(function (item){ console.log(item);
    |'
- en: '} |'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '} |'
- en: Let’s begin with `push`, `pop`, and `join`.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `push`、`pop` 和 `join` 开始。
- en: 8.2.1\. Adding and removing elements
  id: totrans-1140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 添加和删除元素
- en: 'In [listing 8.6](#ch08ex06), you create an empty array and assign it to the
    `items` variable. The `push` method is used to append three elements to the array.
    Once you’ve added the three elements, you log the whole array to the console:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 8.6](#ch08ex06) 中，你创建了一个空数组并将其分配给 `items` 变量。使用 `push` 方法向数组中添加了三个元素。一旦添加了这三个元素，你就在控制台上记录了整个数组：
- en: '[PRE182]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: You then use the `pop` method to remove the last item and display it. Finally,
    you log the whole array to the console again, this time with the elements joined
    to make a single string.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `pop` 方法移除最后一个元素并显示它。最后，再次将整个数组记录到控制台，这次是将元素连接成一个字符串。
- en: '[PRE183]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Listing 8.6\. Manipulating arrays with push, pop, and join ([http://jsbin.com/faqabu/edit?js,console](http://jsbin.com/faqabu/edit?js,console))
  id: totrans-1145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 使用 push、pop 和 join 操作数组 ([http://jsbin.com/faqabu/edit?js,console](http://jsbin.com/faqabu/edit?js,console))
- en: '![](111fig01_alt.jpg)'
  id: totrans-1146
  prefs: []
  type: TYPE_IMG
  zh: '![111fig01_alt.jpg](111fig01_alt.jpg)'
- en: JavaScript makes the `push`, `pop,` and `join` functions available as properties
    on every array. Because they’re properties of the array, you can use dot notation
    to call the functions, `items.push(itemToAdd)`, just as you can to access any
    object property.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将 `push`、`pop` 和 `join` 函数作为属性提供给了每个数组。因为它们是数组的属性，所以你可以使用点符号来调用这些函数，例如
    `items.push(itemToAdd)`，就像访问任何对象的属性一样。
- en: 8.2.2\. Slicing and splicing arrays
  id: totrans-1148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 切片和拼接数组
- en: To demonstrate the two array methods, `slice` and `splice`, you continue with
    your array of holiday destinations. Play along on the JS Bin console. Commands
    can span multiple lines on the console; press Shift-Enter to move to a new line
    without executing a statement. If you press Enter by mistake and execute an unfinished
    statement, you may be able to retrieve your previous entry by pressing the up
    arrow on your keyboard. The statements that you type are shown starting with `>`.
    The console automatically shows the return value of each function called. I show
    those values in bold.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示两个数组方法 `slice` 和 `splice`，你继续使用你的假日目的地数组。在 JS Bin 控制台中一起玩。命令可以在控制台上跨越多行；按
    Shift-Enter 移动到新行而不执行语句。如果你不小心按下了 Enter 并执行了一个未完成的语句，你可能可以通过按键盘上的上箭头键来恢复你的上一个输入。你输入的语句以
    `>` 开头。控制台会自动显示每个调用的函数的返回值。我在粗体中显示了这些值。
- en: '[PRE184]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Slice
  id: totrans-1151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切片
- en: The `slice` method returns a new array made up of part of the original array.
    It doesn’t change the original array. The arguments are the index of the first
    element you want and the index of the first subsequent element you don’t want.
    Remember, the first element has index 0.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice` 方法返回一个新的数组，该数组由原始数组的一部分组成。它不会改变原始数组。参数是你想要的第一元素的索引和第一个你不想的后续元素的索引。记住，第一个元素的索引是
    0。'
- en: '[PRE185]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '`items.slice(2, 3)` says you want the items from index 2 onward but not the
    items from index 3 onward. In other words, you just want the item with index 2.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '`items.slice(2, 3)` 表示你想要从索引 2 开始的项目，但不包括从索引 3 开始的项目。换句话说，你只想得到索引为 2 的项目。'
- en: Omit the second argument if you want all elements after the one specified by
    the first argument. Omit both arguments if you want the whole array.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取第一个参数指定之后的所有元素，则省略第二个参数。如果你想获取整个数组，则省略两个参数。
- en: '[PRE186]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Splice
  id: totrans-1157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 切片
- en: The `splice` method does change the original array. It lets you remove items
    from an array and, optionally, insert new items. To remove items, specify the
    index of the first element to remove and the number of elements to remove. The
    method returns the removed elements as an array.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice` 方法会改变原始数组。它允许你从数组中删除项目，并且可以选择性地插入新项目。要删除项目，指定要删除的第一个元素的索引和要删除的元素数量。该方法返回一个包含被删除元素的数组。'
- en: '[PRE187]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'To insert new elements into the array, add them as arguments after the start
    index and the number of items to remove. In this example, no items are removed:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中插入新元素，将它们作为参数添加到起始索引和要删除的项目数量之后。在这个例子中，没有删除任何项目：
- en: '[PRE188]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'In this example, one item is removed:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个项目被移除了：
- en: '[PRE189]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: You’ll use both `slice` and `splice` when working with player and place items
    in *The Crypt*.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 *The Crypt* 中处理玩家和地点项目时，你会使用 `slice` 和 `splice` 两个数组方法。
- en: 8.2.3\. Visiting each element with forEach
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 使用 forEach 遍历每个元素
- en: 'If you have a list of items that you want to display on the console, you could
    manually call a function for each one:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个想要在控制台显示的项目列表，你可以为每个项目手动调用一个函数：
- en: '[PRE190]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Unfortunately, it’s common not to know in advance how many items will be in
    the list, so you can’t hard-code the right number of `showInfo` calls ahead of
    time. Also, as the number of elements increases, you don’t want to be manually
    calling a function for each one.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，通常无法提前知道列表中会有多少个项目，因此你无法在调用 `showInfo` 之前硬编码正确的调用次数。此外，随着元素数量的增加，你不想手动为每个元素调用函数。
- en: What you need is a way to make JavaScript call a given function for every element
    in the list, however many there are. That’s exactly what the `forEach` method
    does. To call `showInfo` for each element in the `items` array, replace the individual
    calls with
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是一个方法，让 JavaScript 为列表中的每个元素调用给定的函数，无论有多少个元素。这正是 `forEach` 方法所做的。要为 `items`
    数组中的每个元素调用 `showInfo`，将单独的调用替换为
- en: '[PRE191]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The `forEach` method *iterates* over the array, passing each element in turn
    as an argument to the function specified in parentheses, as shown in [figure 8.5](#ch08fig05).
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 方法 *迭代* 数组，依次将每个元素作为参数传递给括号中指定的函数，如图 8.5 所示。'
- en: Figure 8.5\. `items.forEach` passes each item in the `items` array to the `showInfo`
    function.
  id: totrans-1172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. `items.forEach` 将 `items` 数组中的每个项目传递给 `showInfo` 函数。
- en: '![](08fig05_alt.jpg)'
  id: totrans-1173
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig05_alt.jpg)'
- en: '[Listing 8.7](#ch08ex07) shows `forEach` in action, displaying the elements
    of an `items` array on the console:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.7](#ch08ex07) 展示了 `forEach` 的实际应用，在控制台显示 `items` 数组的元素：'
- en: '[PRE192]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Listing 8.7\. Iterating over an array with forEach ([http://jsbin.com/sokosi/edit?js,console](http://jsbin.com/sokosi/edit?js,console))
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 使用 `forEach` 迭代数组 ([http://jsbin.com/sokosi/edit?js,console](http://jsbin.com/sokosi/edit?js,console))
- en: '![](114fig01_alt.jpg)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
  zh: '![](114fig01_alt.jpg)'
- en: In [listing 8.7](#ch08ex07), your function to display each item was assigned
    to the `showInfo` variable. You then passed the `showInfo` variable to `forEach`
    as an argument.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.7 中，你的用于显示每个项目的函数被分配给 `showInfo` 变量。然后你将 `showInfo` 变量作为参数传递给 `forEach`。
- en: 'If you’re going to use a function only once, as the argument for `forEach`,
    you can create the function and pass it to `forEach` inline, without the need
    for an extra variable. The code in [listing 8.8](#ch08ex08) passes the function
    definition directly to `forEach`. You also add extra information to set the scene
    and improve the output:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算只使用一次函数，作为 `forEach` 的参数，你可以在 `forEach` 中直接创建该函数并传递，无需额外的变量。列表 8.8 中的代码直接将函数定义传递给
    `forEach`。你还可以添加额外的信息来设置场景并改进输出：
- en: '[PRE193]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Listing 8.8\. Calling forEach with an inline function ([http://jsbin.com/yapecu/edit?js,console](http://jsbin.com/yapecu/edit?js,console))
  id: totrans-1181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. 使用内联函数调用 `forEach` ([http://jsbin.com/yapecu/edit?js,console](http://jsbin.com/yapecu/edit?js,console))
- en: '![](115fig01_alt.jpg)'
  id: totrans-1182
  prefs: []
  type: TYPE_IMG
  zh: '![](115fig01_alt.jpg)'
- en: 'The `forEach` method actually passes three arguments to the specified function:
    the element, the index of the current element, and the whole array. You can capture
    the extra arguments by including extra parameters in the definition of the function
    you pass to `forEach`.'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 方法实际上将三个参数传递给指定的函数：当前元素的元素、当前元素的索引和整个数组。你可以在传递给 `forEach` 的函数的定义中包含额外的参数来捕获额外的参数。'
- en: '[PRE194]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[Listing 8.9](#ch08ex09) shows all three arguments in action. It uses `forEach`
    to pass each player in the `players` array to the `showArguments` function, producing
    the following output:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.9](#ch08ex09) 展示了所有三个参数的实际应用。它使用 `forEach` 将 `players` 数组中的每个玩家传递给 `showArguments`
    函数，产生以下输出：'
- en: '[PRE195]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Listing 8.9\. Using the arguments passed by forEach ([http://jsbin.com/suvegi/edit?js,console](http://jsbin.com/suvegi/edit?js,console))
  id: totrans-1187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 使用 `forEach` 传递的参数 ([http://jsbin.com/suvegi/edit?js,console](http://jsbin.com/suvegi/edit?js,console))
- en: '![](115fig02_alt.jpg)'
  id: totrans-1188
  prefs: []
  type: TYPE_IMG
  zh: '![](115fig02_alt.jpg)'
- en: The `forEach` method does the job of calling a function for you. In [listing
    8.9](#ch08ex09), it calls the `showArguments` function. It calls the function
    for each element in the `players` array. It always passes the three arguments
    to the function it calls, although you don’t have to use all three.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach` 方法为你调用函数。在列表 8.9 中，它调用 `showArguments` 函数。它为 `players` 数组中的每个元素调用该函数。它始终将三个参数传递给它调用的函数，尽管你不必使用所有三个。'
- en: You can call array methods like `forEach` directly on arrays without the need
    for variables. [Listing 8.10](#ch08ex10) rewrites [listing 8.9](#ch08ex09) without
    assigning the array or the function to variables.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在数组上调用数组方法，如 `forEach`，而不需要变量。列表 8.10 重新编写了列表 8.9，没有将数组或函数分配给变量。
- en: Listing 8.10\. Using the arguments passed by forEach—compact ([http://jsbin.com/pagahe/edit?js,console](http://jsbin.com/pagahe/edit?js,console))
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 使用 `forEach` 传递的参数——紧凑版 ([http://jsbin.com/pagahe/edit?js,console](http://jsbin.com/pagahe/edit?js,console))
- en: '[PRE196]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: If you’re using the array and function only once, the compact syntax in [listing
    8.10](#ch08ex10) can be appropriate. But the longer form in [listing 8.9](#ch08ex09)
    is more readable, so if the meaning of the code isn’t obvious in context, it might
    be better to opt for the longer version. Being able to write something like
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只使用一次数组和函数，[列表8.10](#ch08ex10) 中的紧凑语法可能是合适的。但是，[列表8.9](#ch08ex09) 中的较长形式更易于阅读，因此如果代码的含义在上下文中不明显，可能最好选择较长的版本。能够写出类似
- en: '[PRE197]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: can help you and other programmers make better sense of your code.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的内容可以帮助您和其他程序员更好地理解您的代码。
- en: 'To further demonstrate using the index argument, you’re off to the shops in
    [listing 8.11](#ch08ex11). (If you have your adventure head on, then maybe you’re
    buying equipment for your travels.) You buy four types of items but different
    amounts of each. The program calculates the total cost and displays it, like this:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步展示使用索引参数，您将在 [列表8.11](#ch08ex11) 中去商店。（如果您正在玩冒险游戏，那么您可能是在为旅行购买装备。）您购买了四种类型的物品，但每种物品的数量不同。程序计算总成本并显示，如下所示：
- en: '[PRE198]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: It uses two arrays, one for the numbers of each item bought and one for their
    costs.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用两个数组，一个用于存储每个物品购买的数量，另一个用于存储它们的成本。
- en: Listing 8.11\. Finding the total shopping bill ([http://jsbin.com/zizixu/edit?js,console](http://jsbin.com/zizixu/edit?js,console))
  id: totrans-1199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.11\. 计算购物账单总额 ([http://jsbin.com/zizixu/edit?js,console](http://jsbin.com/zizixu/edit?js,console))
- en: '![](116fig01_alt.jpg)'
  id: totrans-1200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](116fig01_alt.jpg)'
- en: '[Listing 8.11](#ch08ex11) uses the index to match the current item cost with
    the correct number of items. For this to work, the arrays have to be in the same
    order. I hope you noticed that `i` isn’t a very descriptive variable name! It
    is so common to need index variables that most programmers are happy to use short
    names—`i`, `j`, and `k`—for them. They’re quicker to type and it’s such a well-established
    convention that most people reading your code will expect them to be used as a
    counter or index. If you’d rather call the variable `index` or `itemIndex` or
    something similar, that’s fine.'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表8.11](#ch08ex11) 使用索引来匹配当前物品成本与正确数量的物品。为了使这可行，数组必须保持相同的顺序。我希望你已经注意到 `i`
    并不是一个非常描述性的变量名！由于需要索引变量非常普遍，大多数程序员都乐于使用简短的名称——`i`、`j` 和 `k`——来命名它们。它们更快地输入，并且这是一个如此根深蒂固的约定，大多数阅读你代码的人都会期望它们被用作计数器或索引。如果你更愿意将变量命名为
    `index` 或 `itemIndex` 或类似名称，那也是可以的。'
- en: 'As one last example, let’s return to your quiz questions. A multiple-choice
    question has a list of possible answers that need to be displayed to whomever
    is taking the quiz. Sounds like a good fit for an array and `forEach`; see [listing
    8.12](#ch08ex12). You could even have an array of question-and-answer objects.
    For now, stick with a single question, displayed like this:'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，让我们回到您的测验问题。多项选择题有一系列可能的答案，需要显示给正在参加测验的人。这似乎非常适合数组和使用 `forEach`；请参见
    [列表8.12](#ch08ex12)。您甚至可以有一个问题-答案对象数组。现在，让我们坚持一个单独的问题，如下所示显示：
- en: '[PRE199]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Listing 8.12\. Displaying a multiple choice question ([http://jsbin.com/lobahu/edit?js,console](http://jsbin.com/lobahu/edit?js,console))
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12\. 显示多项选择题 ([http://jsbin.com/lobahu/edit?js,console](http://jsbin.com/lobahu/edit?js,console))
- en: '![](117fig01_alt.jpg)'
  id: totrans-1205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](117fig01_alt.jpg)'
- en: You’ll look at actually answering questions when you investigate user interaction
    in [part 2](kindle_split_019.html#part02).
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 [第2部分](kindle_split_019.html#part02) 中研究用户交互时，您将了解如何实际回答问题。
- en: 8.3\. The Crypt—a player items array
  id: totrans-1207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. *The Crypt*——玩家物品数组
- en: You’ll now apply your knowledge of JavaScript arrays to *The Crypt*. [Figure
    8.6](#ch08fig06) shows where the focus of this section, displaying a list of player
    items by using arrays, fits into the overall structure of our ongoing game example.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将应用您对 JavaScript 数组的了解来 *The Crypt*。[图8.6](#ch08fig06) 显示了本节重点，即通过使用数组显示玩家物品列表，如何融入我们正在进行的游戏示例的整体结构。
- en: Figure 8.6\. Elements of *The Crypt*
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. *The Crypt* 的元素
- en: '![](08fig06_alt.jpg)'
  id: totrans-1210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig06_alt.jpg)'
- en: In [part 1](kindle_split_008.html#part01) of *Get Programming with JavaScript*,
    we’ve covered some core concepts to help you model and use players in *The Crypt*.
    You have variables to store and retrieve player information, objects to collect
    player properties together, arrays so you can list the items a player collects,
    array methods to add and remove items in the collection, and functions to display
    information about each player.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Get Programming with JavaScript* 的 [第1部分](kindle_split_008.html#part01) 中，我们介绍了一些核心概念，以帮助您在
    *The Crypt* 中建模和使用玩家。您有变量来存储和检索玩家信息，对象来收集玩家属性，数组以便您可以列出玩家收集的物品，数组方法来添加和删除集合中的物品，以及函数来显示每个玩家的信息。
- en: '[Listing 8.13](#ch08ex13) brings all of these concepts together: creating a
    player, displaying information about them, picking up a new item, and displaying
    the updated info. You format the output using the `spacer` namespace developed
    in [chapter 7](kindle_split_015.html#ch07). The elements that make up the output
    are highlighted in [figure 8.7](#ch08fig07).'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8.13](#ch08ex13) 将所有这些概念结合起来：创建一个玩家，显示他们的信息，拾取一个新物品，并显示更新后的信息。你使用在第 7 章（[kindle_split_015.html#ch07](kindle_split_015.html#ch07)）中开发的
    `spacer` 命名空间来格式化输出。组成输出的元素在 [图 8.7](#ch08fig07) 中突出显示。'
- en: Figure 8.7\. The elements shown when a `Player` object is displayed on the console
  id: totrans-1213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 在控制台上显示 `Player` 对象时显示的元素
- en: '![](08fig07_alt.jpg)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: '![08fig07_alt.jpg]'
- en: To save space, `spacer` isn’t shown in the listing (it hasn’t changed) but it
    is on JS Bin. The code in this listing builds on the player display code from
    [chapter 7](kindle_split_015.html#ch07), adding the ability to list a player’s
    items.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，列表中没有显示 `spacer`（它没有改变），但在 JS Bin 上有。此列表中的代码基于第 7 章（[kindle_split_015.html#ch07](kindle_split_015.html#ch07)）中的玩家显示代码，增加了列出玩家物品的功能。
- en: Listing 8.13\. Displaying player items ([http://jsbin.com/mecude/edit?js,console](http://jsbin.com/mecude/edit?js,console))
  id: totrans-1216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 显示玩家物品 ([http://jsbin.com/mecude/edit?js,console](http://jsbin.com/mecude/edit?js,console))
- en: '![](ch08ex13-0.jpg)'
  id: totrans-1217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex13-0.jpg)'
- en: '![](ch08ex13-1.jpg)'
  id: totrans-1218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch08ex13-1.jpg)'
- en: 'The `Player` object now includes an `items` array:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 对象现在包含一个 `items` 数组：'
- en: '[PRE200]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'It starts with only one element, but you add another by using the `push` array
    method:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 它最初只有一个元素，但你可以通过使用 `push` 数组方法添加另一个：
- en: '[PRE201]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '`getPlayerItems` uses `forEach` to pass each item in the `items` array to a
    function. The function appends the item to a string using `+=`, building a list
    of all of the player’s items:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlayerItems` 使用 `forEach` 将 `items` 数组中的每个项目传递给一个函数。该函数使用 `+=` 将项目附加到字符串中，构建玩家所有物品的列表：'
- en: '[PRE202]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The `showPlayerInfo` function calls `getPlayerInfo` to retrieve the player information
    string and then displays the information on the console.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '`showPlayerInfo` 函数调用 `getPlayerInfo` 来检索玩家信息字符串，然后在控制台上显示信息。'
- en: 'You’re starting to build up quite a collection of functions to help with the
    display of players; you should really organize them. You could collect them into
    a namespace or, seeing as they all relate to players, include them as part of
    each `Player` object. JavaScript provides a way to streamline the creation of
    many similar objects, incorporating the methods that work with them: *constructor
    functions*. That’s what you investigate in [chapter 9](kindle_split_017.html#ch09),
    where you also build the places the players will explore in *The Crypt*.'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始积累大量帮助显示玩家的函数；你真的应该组织它们。你可以将它们收集到一个命名空间中，或者由于它们都与玩家相关，可以将它们作为每个 `Player`
    对象的一部分。JavaScript 提供了一种简化创建许多类似对象的方法，包括与它们一起工作的方法：*构造函数*。这就是你在第 9 章（[kindle_split_017.html#ch09](kindle_split_017.html#ch09)）中调查的内容，在那里你还在
    *The Crypt* 中构建玩家将探索的地方。
- en: 8.4\. Summary
  id: totrans-1227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 概述
- en: 'Create an array with a comma-separated list of values between square brackets:'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号中的逗号分隔值列表创建一个数组：
- en: '[PRE203]'
  id: totrans-1229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Assign the array to a variable and then access its elements by adding an index
    in square brackets to the variable name. The following code displays `"Dax"`:'
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组分配给变量，然后通过在变量名后添加方括号中的索引来访问其元素。以下代码显示 `"Dax"`：
- en: '[PRE204]'
  id: totrans-1231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Remember to use a zero-based index for array elements. `items[1]` refers to
    the second element in the `items` array. You can think of the index as an offset
    from the start of the array: the first element is zero away from the start, the
    second is one away from the start, and so on.'
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住使用基于零的索引为数组元素。`items[1]` 指的是 `items` 数组中的第二个元素。你可以将索引视为从数组开始的一个偏移量：第一个元素距离开始零个单位，第二个元素距离开始一个单位，依此类推。
- en: Use array methods, functions provided by JavaScript, to add, remove, join, and
    iterate over array elements. The methods covered in this chapter are `push`, `pop`,
    `join`, `slice`, `splice`, and `forEach`.
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组方法，JavaScript 提供的函数，来添加、删除、连接和遍历数组元素。本章涵盖的方法是 `push`、`pop`、`join`、`slice`、`splice`
    和 `forEach`。
- en: 'Chapter 9\. Constructors: building objects with functions'
  id: totrans-1234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章\. 构造函数：使用函数构建对象
- en: '***This chapter covers***'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Using functions to create objects
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数创建对象
- en: The keyword `new`
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `new`
- en: Using constructor functions to create objects
  id: totrans-1238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数创建对象
- en: The special variable `this`
  id: totrans-1239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊变量 `this`
- en: Defining constructor functions for players and places
  id: totrans-1240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义玩家和地点的构造函数
- en: It’s common for programs to create many similar objects—a blog post could have
    hundreds of posts and a calendar thousands of events—and to include functions
    for working on those objects. Rather than building each object by hand using curly
    braces, you can use functions to streamline the process. You want to change
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常创建许多类似的对象是很常见的——一个博客文章可能有数百篇文章，而日历可能有数千个事件——并且包括用于处理这些对象的功能。而不是手动使用花括号构建每个对象，你可以使用函数来简化流程。你想要改变
- en: '[PRE205]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: into
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: into
- en: '[PRE206]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: where the `buildPlanet` function creates the planet object for you and adds
    the `show` method automatically. You define a blueprint for your object in the
    function body of `buildPlanet` and then use that blueprint to generate new objects
    whenever you need them. That keeps your object-creation code in one place; you’ve
    seen throughout the book how such organization makes it easier to understand,
    maintain, and use your programs.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `buildPlanet` 函数为你创建行星对象，并自动添加 `show` 方法。你在 `buildPlanet` 函数的函数体中定义了对象的蓝图，然后使用该蓝图在需要时生成新对象。这样就将你的对象创建代码集中在一个地方；你在整本书中看到，这种组织方式使得理解、维护和使用你的程序变得更加容易。
- en: 'You can do even better than a simple function to create many similar objects;
    you can use a *constructor function*. Writing functions to generate objects is
    so common that JavaScript includes a built-in way of streamlining the process.
    With a constructor function, creating and displaying a planet looks like this:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用 *构造函数* 来创建更多类似的对象；编写生成对象的函数是如此常见，以至于JavaScript包含了一种内置的方式来简化流程。使用构造函数，创建和显示行星看起来是这样的：
- en: '[PRE207]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Constructor functions standardize object creation—standardizing code is generally
    a good thing—and provide a way of identifying objects, making it easier to differentiate
    among planets, players, posts, and positions, for example. They also provide a
    way of sharing a single function among many objects by using *prototypes*, covered
    in part 4.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数标准化了对象的创建——标准化代码通常是一件好事——并提供了一种识别对象的方法，使得区分行星、玩家、文章和位置等变得更容易。它们还通过使用 *原型*（在第4部分中介绍）提供了一种在许多对象之间共享单个函数的方法。
- en: In [section 9.1](#ch09lev1sec1) you write your own functions to make it easier
    to build objects with properties and methods in place. In [section 9.2](#ch09lev1sec2),
    you investigate constructor functions and see how they simplify the process. It’s
    time to get the production line rolling.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第9.1节](#ch09lev1sec1) 中，你编写自己的函数来更容易地构建具有属性和方法的对象。在 [第9.2节](#ch09lev1sec2)
    中，你研究构造函数，并了解它们如何简化流程。现在是时候让生产线运转起来了。
- en: 9.1\. Using functions to build objects
  id: totrans-1250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 使用函数构建对象
- en: Rather than using curly braces to manually construct each object, create a function
    to do the heavy lifting. Just pass the function the information it needs and it
    will return a shiny new object for you. In larger programs, you may well want
    to create similar objects in a number of places in the code. Having a single function
    you can call on saves you from repeating yourself and makes it easy to make changes
    if what you need your object to do develops over time.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用花括号手动构建每个对象，创建一个函数来处理繁重的工作。只需将所需信息传递给函数，它就会为你返回一个崭新的对象。在更大的程序中，你可能会想在代码的多个地方创建类似的对象。拥有一个可以调用的单一函数可以避免重复，如果随着时间的推移你需要你的对象执行的操作发生变化，这也使得修改变得容易。
- en: '[Section 9.1.1](#ch09lev2sec1) shows a simple object-creation function, and
    [section 9.1.2](#ch09lev2sec2) builds on it to add a method to your created objects.'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9.1.1节](#ch09lev2sec1) 展示了一个简单的对象创建函数，而 [第9.1.2节](#ch09lev2sec2) 则在此基础上添加了方法到创建的对象中。'
- en: 9.1.1\. Adding properties
  id: totrans-1253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 添加属性
- en: '[Figure 9.1](#ch09fig01) shows a `buildPlanet` function to help you create
    each planet object. You pass the function the planet data as arguments and it
    returns an object with those arguments set as properties. You’ve only just started
    learning JavaScript and you’re already building planets!'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](#ch09fig01) 展示了一个 `buildPlanet` 函数，帮助你创建每个行星对象。你将行星数据作为参数传递给函数，它返回一个具有这些参数作为属性的对象。你刚刚开始学习JavaScript，就已经在构建行星了！'
- en: Figure 9.1\. The `buildPlanet` function creates and returns an object.
  id: totrans-1255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. `buildPlanet` 函数创建并返回一个对象。
- en: '![](09fig01_alt.jpg)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: The first listing shows the code for the `buildPlanet` function. Notice how
    it starts by creating an object and ends by returning the object.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表显示了 `buildPlanet` 函数的代码。注意它是如何开始创建一个对象，并以返回对象结束的。
- en: Listing 9.1\. Using a function to create an object ([http://jsbin.com/jiroyo/edit?js,console](http://jsbin.com/jiroyo/edit?js,console))
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 使用函数创建对象 ([http://jsbin.com/jiroyo/edit?js,console](http://jsbin.com/jiroyo/edit?js,console))
- en: '![](124fig01_alt.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
  zh: '![](124fig01_alt.jpg)'
- en: The steps the `buildPlanet` function takes are important for understanding how
    JavaScript’s constructor functions streamline the process of object creation.
    You take a look at constructor functions in [section 9.2](#ch09lev1sec2). But
    first, you enhance what your created objects can do, with methods.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPlanet` 函数所采取的步骤对于理解 JavaScript 的构造函数如何简化对象创建过程至关重要。你可以在 [第 9.2 节](#ch09lev1sec2)
    中查看构造函数。但首先，通过添加方法来增强你创建的对象的功能。'
- en: 9.1.2\. Adding methods
  id: totrans-1261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 添加方法
- en: As well as setting some initial properties, you can make `buildPlanet` add methods
    into the mix. Remember, a *method* is a just function you assign to an object
    property. Rather than defining an external function to display information about
    each planet object, bake it into the object itself.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置一些初始属性外，你还可以让 `buildPlanet` 添加方法。记住，*方法* 是你分配给对象属性的函数。与其定义一个外部函数来显示每个行星对象的信息，不如将其直接嵌入对象本身。
- en: 'In the next listing, you add a `showPlanet` method to each planet object before
    returning the object. The output looks like this:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你在返回对象之前为每个行星对象添加了一个 `showPlanet` 方法。输出结果如下：
- en: '[PRE208]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Listing 9.2\. Adding methods to your constructed object ([http://jsbin.com/zogure/edit?js,console](http://jsbin.com/zogure/edit?js,console))
  id: totrans-1265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 为构造对象添加方法 ([http://jsbin.com/zogure/edit?js,console](http://jsbin.com/zogure/edit?js,console))
- en: '![](125fig01_alt.jpg)'
  id: totrans-1266
  prefs: []
  type: TYPE_IMG
  zh: '![](125fig01_alt.jpg)'
- en: In the `showPlanet` method you build up an information string including the
    planet’s properties (`name`, `position`, and `type`) before logging the string
    to the console. You use the `+=` operator to append strings to the `info` variable.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `showPlanet` 方法中，你构建了一个包含行星属性（`name`、`position` 和 `type`）的信息字符串，然后将该字符串记录到控制台。你使用
    `+=` 运算符将字符串附加到 `info` 变量。
- en: You can include as many methods as you need to give your objects the functionality
    required. Every time you call `buildPlanet`, it returns an object with the properties
    and methods required to do its job in your program. You can put the function to
    work, churning out as many planet objects as you want. You can’t have too many
    planets, am I right?
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以包含所需数量的方法，以赋予你的对象所需的功能。每次调用 `buildPlanet` 时，它都会返回一个具有执行程序中工作所需属性和方法的对象。你可以使用这个函数，生成你想要的任意数量的行星对象。行星数量再多也不会有问题，对吧？
- en: '[Listing 9.3](#ch09ex03) uses the `buildPlanet` function to construct three
    planets (okay, not quite a production line, but you get the idea!) and display
    their details on the console:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.3](#ch09ex03) 使用 `buildPlanet` 函数构建了三个行星（好吧，还不完全是一个生产线，但你能理解这个概念！）并在控制台上显示它们的详细信息：'
- en: '[PRE209]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Listing 9.3\. An array of constructed objects ([http://jsbin.com/jiweze/edit?js,console](http://jsbin.com/jiweze/edit?js,console))
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 构造对象的数组 ([http://jsbin.com/jiweze/edit?js,console](http://jsbin.com/jiweze/edit?js,console))
- en: '![](ch09ex03-0.jpg)'
  id: totrans-1272
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex03-0.jpg)'
- en: '![](ch09ex03-1.jpg)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex03-1.jpg)'
- en: 'In [listing 9.3](#ch09ex03) you create an array with three elements, the objects
    that each call to `buildPlanet` returns. You assign the array to the `planets`
    variable and then iterate over the array using `forEach`. You don’t need to assign
    the three planets to individual variables; the objects are accessible via an array
    index, with the first planet at index 0:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.3](#ch09ex03) 中，你创建了一个包含三个元素的数组，这些元素是每次调用 `buildPlanet` 返回的对象。你将这个数组赋值给
    `planets` 变量，然后使用 `forEach` 方法遍历数组。你不需要将三个行星分别赋值给单独的变量；对象可以通过数组索引访问，第一个行星位于索引
    0：
- en: '[PRE210]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: In defining `buildPlanet`, you moved object creation into a function, returning
    the nascent planet once you had set its properties. But JavaScript can create
    and return objects for you. Let’s see how.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 `buildPlanet` 时，你将对象创建移动到了函数中，一旦设置了属性，就返回了新生的行星。但 JavaScript 可以为你创建和返回对象。让我们看看它是如何做到的。
- en: 9.2\. Using constructor functions to build objects
  id: totrans-1277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 使用构造函数构建对象
- en: Creating your own function to build objects and attach methods should have given
    you an insight into the steps involved in an object production line. It’s such
    a common way to build objects that JavaScript provides its own standard mechanism—the
    *constructor function*.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的函数来构建对象并附加方法应该让你了解了对象生产线中涉及的步骤。这是一种构建对象的常见方式，JavaScript 提供了自己的标准机制——*构造函数*。
- en: In the `buildPlanet` function, *you* created an empty object and set its properties,
    and *you* returned the object.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `buildPlanet` 函数中，*你* 创建了一个空对象并设置了其属性，*你* 返回了对象。
- en: '[PRE211]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Well, JavaScript has you covered; with constructor functions it will create
    the empty object and return it for you free of charge. You still get to set the
    properties, but the rest is automagical. And what mystic invocations transform
    an ordinary function into a constructor function? Two keywords: `this` and `new`.'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，JavaScript 为你提供了保障；使用构造函数，它会免费为你创建空对象并返回它。你仍然可以设置属性，但其余的都是自动完成的。那么是什么神秘的调用将一个普通函数转换成了构造函数呢？两个关键字：`this`
    和 `new`。
- en: 9.2.1\. Constructor functions
  id: totrans-1282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 构造函数
- en: 'In JavaScript, you define a *constructor function* just like any other function
    but call it after the `new` keyword. If you have a `Planet` function, you could
    create new planet objects like this:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你定义一个 *构造函数* 就像定义任何其他函数一样，但需要在 `new` 关键字之后调用它。如果你有一个 `Planet`
    函数，你可以这样创建新的行星对象：
- en: '[PRE212]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: To use the `Planet` function as a constructor function you simply add the `new`
    keyword before the call to `Planet`. It’s a convention to start the names of constructor
    functions with capital letters so programmers know to use the `new` keyword when
    calling them. [Figure 9.2](#ch09fig02) shows how the constructor function automatically
    creates and returns an object.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `Planet` 函数用作构造函数，你只需在调用 `Planet` 之前加上 `new` 关键字。构造函数的命名惯例是以大写字母开头，这样程序员在调用它们时就知道要使用
    `new` 关键字。[图 9.2](#ch09fig02) 展示了构造函数如何自动创建并返回一个对象。
- en: Figure 9.2\. Call the constructor with the `new` keyword. The constructor automatically
    creates and returns an object.
  id: totrans-1286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. 使用 `new` 关键字调用构造函数。构造函数会自动创建并返回一个对象。
- en: '![](09fig02_alt.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig02_alt.jpg)'
- en: The following listing shows the full `Planet` constructor along with an example
    of calling `Planet` with `new`.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了完整的 `Planet` 构造函数以及使用 `new` 调用 `Planet` 的示例。
- en: Listing 9.4\. The Planet constructor ([http://jsbin.com/bixico/edit?js,console](http://jsbin.com/bixico/edit?js,console))
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. Planet 构造函数 ([http://jsbin.com/bixico/edit?js,console](http://jsbin.com/bixico/edit?js,console))
- en: '![](128fig01_alt.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![](128fig01_alt.jpg)'
- en: Within the function body, but only when you call the function with `new`, JavaScript
    creates an empty object for you and assigns it to the special variable `this`.
    You can imagine the hidden first line of the `Planet` function being
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内，但只有当你用 `new` 调用函数时，JavaScript 才会为你创建一个空对象并将其分配给特殊变量 `this`。你可以想象 `Planet`
    函数的隐藏的第一行是这样的
- en: '[PRE213]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: You can then set properties on `this` just as you did with `planet` in the `buildPlanet`
    function earlier. The function automatically returns the object assigned to `this`,
    so there’s no need to add a `return` statement. You can imagine the hidden last
    line of the `Planet` function being
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像在之前的 `buildPlanet` 函数中处理 `planet` 一样设置 `this` 的属性。该函数会自动返回分配给 `this`
    的对象，因此不需要添加 `return` 语句。你可以想象 `Planet` 函数的隐藏的最后一行是这样的
- en: '[PRE214]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: When you execute the code in [listing 9.4](#ch09ex04), the newly created object
    replaces the call to the `Planet` constructor and is assigned to the `planet`
    variable. The following
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 [列表 9.4](#ch09ex04) 中的代码时，新创建的对象将替换 `Planet` 构造函数的调用，并分配给 `planet` 变量。接下来的
- en: '[PRE215]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: becomes
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: becomes
- en: '[PRE216]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'You can add as many properties and methods to the `this` object as you need.
    [Listing 9.5](#ch09ex05) extends the `Planet` constructor to add a `moons` property
    and an `addMoon` method to the generated objects:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 `this` 对象添加任意多的属性和方法。[列表 9.5](#ch09ex05) 扩展了 `Planet` 构造函数，为生成的对象添加了 `moons`
    属性和 `addMoon` 方法：
- en: '[PRE217]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Listing 9.5\. Including a moons array in the Planet constructor ([http://jsbin.com/wiguya/edit?js,console](http://jsbin.com/wiguya/edit?js,console))
  id: totrans-1301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 在 Planet 构造函数中包含月球数组 ([http://jsbin.com/wiguya/edit?js,console](http://jsbin.com/wiguya/edit?js,console))
- en: '![](ch09ex05-0.jpg)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex05-0.jpg)'
- en: '![](ch09ex05-1.jpg)'
  id: totrans-1303
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex05-1.jpg)'
- en: Remember from [chapter 8](kindle_split_016.html#ch08), the `push` method adds
    a new element to the end of an array and the `join` method joins all of the elements
    of an array to form a single string, with an optional separator string between
    each pair of elements.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从 [第 8 章](kindle_split_016.html#ch08)，`push` 方法向数组的末尾添加一个新元素，而 `join` 方法将数组的所有元素连接成一个字符串，元素之间可以有一个可选的分隔字符串。
- en: Planets *and* moons! Your industriousness knows no bounds. Io, Io, it’s off
    to work we go ....
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 行星 *和* 月球！你的勤奋是无边无际的。Io，Io，我们开始工作吧 ....
- en: 9.2.2\. World building—making use of the Planet constructor
  id: totrans-1306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 世界构建——使用 Planet 构造函数
- en: '[Listing 9.6](#ch09ex06) uses an updated implementation of the `Planet` constructor.
    When you call `addMoon`, it now prepends new moons at the beginning of the `moons`
    array using an array method you haven’t seen before: `unshift`. You create three
    planet objects and assign them to variables `planet1`, `planet2`, and `planet3`
    before calling `showPlanet` on each one. In the partial output shown here, pay
    close attention to the order of the moons:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.6](#ch09ex06) 使用了 `Planet` 构造函数的更新实现。当你调用 `addMoon` 时，它现在使用你之前未见过的方法
    `unshift` 在 `moons` 数组的开头添加新的卫星。在调用每个 `showPlanet` 之前，你创建了三个行星对象并将它们分配给变量 `planet1`、`planet2`
    和 `planet3`。在这里显示的部分输出中，请特别注意卫星的顺序：'
- en: '[PRE218]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Listing 9.6\. Creating multiple planets with our constructor ([http://jsbin.com/wewewe/edit?js,console](http://jsbin.com/wewewe/edit?js,console))
  id: totrans-1309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 使用我们的构造函数创建多个行星 ([http://jsbin.com/wewewe/edit?js,console](http://jsbin.com/wewewe/edit?js,console))
- en: '![](ch09ex06-0.jpg)'
  id: totrans-1310
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex06-0.jpg)'
- en: '![](ch09ex06-1.jpg)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex06-1.jpg)'
- en: In the code for `planet1`, you added Io first, then Europa. But in the output
    the order is reversed. That’s because you now use `unshift` to add items at the
    start of the `moons` array rather than `push` to add items at the end.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `planet1` 的代码中，你首先添加了 Io，然后是 Europa。但在输出中顺序被反转了。这是因为你现在使用 `unshift` 在 `moons`
    数组的开头添加项目，而不是使用 `push` 在末尾添加项目。
- en: 9.2.3\. Telling objects apart with the instanceof operator
  id: totrans-1313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 使用 instanceof 操作符区分对象
- en: 'When working with many different objects in a program, objects that you may
    have created with a number of different constructor functions, it’s sometimes
    useful to be able to tell one type of object from another: is `item1` a planet,
    a player, a post, or a position? The JavaScript `instanceof` operator lets you
    check if a particular constructor function was involved in the creation of an
    object. Assuming you’ve defined the `Planet` constructor, the following code snippet
    logs `true` to the console:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个程序中处理许多不同的对象时，你可能使用多个不同的构造函数创建的对象，有时能够区分一种类型的对象和另一种对象是有用的：`item1` 是一个行星、玩家、帖子还是位置？JavaScript
    的 `instanceof` 操作符允许你检查特定的构造函数是否参与了对象的创建。假设你已经定义了 `Planet` 构造函数，以下代码片段将 `true`
    输出到控制台：
- en: '[PRE219]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The `instanceof` operator returns either `true` or `false`. The values `true`
    and `false` are called *boolean* values. In fact, they’re the only two boolean
    values. You won’t be using `instanceof` in the rest of *Get Programming with JavaScript*—I
    mention it here as another reason why a programmer may prefer constructor functions
    over their own object-creation functions. You’ll see a lot more of `true` and
    `false` in [parts 2](kindle_split_019.html#part02) and [3](kindle_split_026.html#part03)
    of the book; they’re central to making decisions and running code only if certain
    conditions are met.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 操作符返回 `true` 或 `false`。`true` 和 `false` 被称为 *布尔值*。实际上，它们是唯一的两个布尔值。在
    *用 JavaScript 编程入门* 的其余部分中，你不会使用 `instanceof`——我在这里提到它，作为程序员可能更喜欢构造函数而不是他们自己的对象创建函数的另一个原因。你将在本书的第
    [2](kindle_split_019.html#part02) 和 [3](kindle_split_026.html#part03) 部分看到更多关于
    `true` 和 `false` 的内容；它们对于在满足某些条件时做出决策和运行代码至关重要。'
- en: To get a better feel for constructors, it’s worth looking at a few more examples.
    The next section does just that, with constructors for quiz questions and calendar
    events.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解构造函数，查看一些更多示例是值得的。下一节将这样做，其中包括测验问题和日历事件的构造函数。
- en: 9.3\. Building mastery—two examples of constructors
  id: totrans-1318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 建立精通——构造函数的两个示例
- en: A quiz is likely to have tens of questions and a calendar hundreds or thousands
    of events. The questions will probably all have a similar structure and the events
    likewise. Both types of objects seem like prime candidates for constructor functions.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 一次测验可能包含数十个问题，而日历可能包含数百或数千个事件。这些问题和事件很可能具有相似的结构。这两种类型的对象似乎都是构造函数的理想候选者。
- en: 'In [listing 9.7](#ch09ex07), you use a `QuizQuestion` constructor to create
    a single question and display it on the console:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.7](#ch09ex07) 中，你使用 `QuizQuestion` 构造函数创建一个单独的问题，并在控制台上显示它：
- en: '[PRE220]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Listing 9.7\. A quiz question constructor ([http://jsbin.com/vuyesi/edit?js,console](http://jsbin.com/vuyesi/edit?js,console))
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 试题构造函数 ([http://jsbin.com/vuyesi/edit?js,console](http://jsbin.com/vuyesi/edit?js,console))
- en: '![](ch09ex07-0.jpg)'
  id: totrans-1323
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex07-0.jpg)'
- en: '![](ch09ex07-1.jpg)'
  id: totrans-1324
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex07-1.jpg)'
- en: In the `showQuestion` function in [listing 9.7](#ch09ex07), you use the `forEach`
    method to iterate over the `options` array of possible answers. The `forEach`
    method passes each option and its index to a function that displays the option
    along with an option number.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9.7](#ch09ex07) 中的 `showQuestion` 函数中，你使用 `forEach` 方法遍历可能的答案数组 `options`。`forEach`
    方法将每个选项及其索引传递给一个函数，该函数显示选项及其编号。
- en: '[PRE221]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The index of the first option is 0 but you want the displayed numbers to start
    at (1). You use `(i + 1)` rather than `i` to shift each index up by one for display.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项的索引是 0，但你希望显示的数字从 (1) 开始。你使用 `(i + 1)` 而不是 `i` 来将每个索引向上移动一个，以便显示。
- en: '[PRE222]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'The next listing is a simple constructor for calendar events. The `showEvent`
    method produces the following output:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表是一个简单的日历事件构造函数。`showEvent` 方法产生以下输出：
- en: '[PRE223]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Listing 9.8\. A calendar event constructor ([http://jsbin.com/gemiyu/edit?js,console](http://jsbin.com/gemiyu/edit?js,console))
  id: totrans-1331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. 日历事件构造函数 ([http://jsbin.com/gemiyu/edit?js,console](http://jsbin.com/gemiyu/edit?js,console))
- en: '![](ch09ex08-0.jpg)'
  id: totrans-1332
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex08-0.jpg)'
- en: '![](ch09ex08-1.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex08-1.jpg)'
- en: 'In the `showEvent` method, you create and immediately `join` an array to form
    a string for the date information. You met the `join` method in [chapter 8](kindle_split_016.html#ch08).
    This is quite a neat way of building a string from multiple pieces. JavaScript
    programmers used to see string concatenation, for example, using `+=`, as a relatively
    slow way of building strings from substrings. Joining the elements of an array
    was a common alternative. These following two ways of building `dateString` give
    the same result:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `showEvent` 方法中，你创建并立即 `join` 一个数组来形成一个包含日期信息的字符串。你在 [第 8 章](kindle_split_016.html#ch08)
    中遇到了 `join` 方法。这是一种从多个部分构建字符串的相当巧妙的方法。JavaScript 程序员过去认为字符串连接，例如使用 `+=`，是从子字符串构建字符串的一种相对较慢的方法。将数组的元素连接起来是一种常见的替代方法。以下两种构建
    `dateString` 的方法会产生相同的结果：
- en: '[PRE224]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: These days, in modern browsers, string concatenation is much faster than it
    was. I’ve included an example of using `join` because you may well come across
    it in the wild.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，在现代浏览器中，字符串连接比以前快得多。我包含了一个使用 `join` 的例子，因为你很可能在野外遇到它。
- en: Constructor functions provide a standardized, streamlined way of creating multiple
    objects using a single template. A great adventure will involve many locations;
    let’s revisit *The Crypt* and use constructors to give your players plenty of
    places to plunder.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数提供了一种标准化、简化的方式，通过单个模板创建多个对象。一场伟大的冒险将涉及许多地点；让我们回顾一下 *The Crypt*，并使用构造函数为你的玩家提供许多可以掠夺的地方。
- en: 9.4\. The Crypt—providing places to plunder
  id: totrans-1338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. The Crypt—提供掠夺地点
- en: You’ll now apply your knowledge of constructor functions to *The Crypt*. [Figure
    9.3](#ch09fig03) shows where the focus of this section, creating `Place` objects
    by using constructor functions, fits into the overall structure of our ongoing
    game example.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用你对构造函数的知识到 *The Crypt* 上。[图 9.3](#ch09fig03) 显示了本节的重点，即通过使用构造函数创建 `Place`
    对象，如何适合我们正在进行的游戏示例的整体结构。
- en: Figure 9.3\. Elements of *The Crypt*
  id: totrans-1340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. *The Crypt* 的元素
- en: '![](09fig03_alt.jpg)'
  id: totrans-1341
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03_alt.jpg)'
- en: Up until now, you’ve been focusing on the players in *The Crypt*. It’s time
    to build some *places* to explore. Each place needs a title and description, a
    collection of items, and a collection of exits to other places. It also needs
    methods for adding items and exits and for displaying its information. [Figure
    9.4](#ch09fig04) highlights the elements you want to see when you display a `Place`
    object on the console.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直专注于 *The Crypt* 中的玩家。是时候构建一些可以探索的 *地点* 了。每个地点都需要一个标题和描述，一个物品集合，以及通向其他地点的出口集合。它还需要添加物品和出口的方法以及显示其信息的方法。[图
    9.4](#ch09fig04) 突出了当你将在控制台上显示的 `Place` 对象时想要看到的元素。
- en: Figure 9.4\. The elements shown when a `Place` object is displayed on the console.
  id: totrans-1343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 在控制台上显示 `Place` 对象时显示的元素。
- en: '![](09fig04_alt.jpg)'
  id: totrans-1344
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04_alt.jpg)'
- en: Managing all of those elements will require quite a lot of code. As you’ve seen,
    a constructor function is a good way to organize all that code and streamline
    the creation of multiple `Place` objects. This will be your most complicated constructor
    yet, so let’s build it in stages.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 管理所有这些元素将需要相当多的代码。正如你所见，构造函数是一个很好的方式来组织所有这些代码，并简化多个 `Place` 对象的创建。这将是你迄今为止最复杂的构造函数，所以让我们分阶段来构建它。
- en: 9.4.1\. Building the Place constructor—title and description
  id: totrans-1346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 构建 Place 构造函数—标题和描述
- en: 'Okay, here’s a nice bare-bones constructor to get you started. It simply sets
    up the `title` and `description` properties and a basic `getInfo` method that
    you can develop as you add more properties. The initial output looks like this:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个很好的骨架构造器，让你开始。它只是设置了`title`和`description`属性以及一个基本的`getInfo`方法，你可以随着添加更多属性来开发它。初始输出看起来像这样：
- en: '[PRE225]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Listing 9.9\. A Place constructor, [part 1](kindle_split_008.html#part01) ([http://jsbin.com/pogive/edit?js,console](http://jsbin.com/pogive/edit?js,console))
  id: totrans-1349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 地点构造器，[第一部分](kindle_split_008.html#part01) ([http://jsbin.com/pogive/edit?js,console](http://jsbin.com/pogive/edit?js,console))
- en: '![](135fig01_alt.jpg)'
  id: totrans-1350
  prefs: []
  type: TYPE_IMG
  zh: '![](135fig01_alt.jpg)'
- en: No boxes or borders yet—just the bare bones. You define a `getInfo` method that
    returns a string containing the place’s title and description. Remember, `"\n"`
    is an escape sequence used to specify a new-line character; the title will be
    on one line and the description on the next.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有盒子或边框—只有骨架。你定义一个`getInfo`方法，该方法返回一个包含地点标题和描述的字符串。记住，`"\n"`是一个转义序列，用于指定换行符；标题将在一行，描述将在下一行。
- en: Okay, so you can create places. But how can players plunder those places? You
    need some treasure!
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以你可以创建地点。但玩家如何掠夺这些地点？你需要一些宝藏！
- en: 9.4.2\. Building the Place constructor—items for your hoard
  id: totrans-1353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 构建地点构造器—为你收藏的物品
- en: As players explore their environment they expect to come across items that will
    help them solve puzzles and overcome obstacles like locked doors, putrid zombies,
    snarling leopards, and over-friendly tentacles. You need a way to add items to
    the places you create and to include the items in the information displayed about
    each location.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家探索他们的环境时，他们期望遇到可以帮助他们解决谜题和克服障碍的物品，如锁着的门、恶臭的僵尸、咆哮的豹子和过于友好的触手。你需要一种方法向你创建的地点添加物品，并将这些物品包含在每个地点显示的信息中。
- en: '[Listing 9.10](#ch09ex10) extends your bare-bones constructor to include the
    item functionality needed. You’ve upgraded the display of information by using
    the `spacer` namespace from [chapter 7](kindle_split_015.html#ch07); it now looks
    like this:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.10](#ch09ex10) 扩展了你的骨架构造器，包括所需的项目功能。你通过使用来自[第 7 章](kindle_split_015.html#ch07)的`spacer`命名空间来升级了信息的显示；它现在看起来像这样：'
- en: '[PRE226]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: That’s more like your target output from [figure 9.4](#ch09fig04)! The `spacer`
    code isn’t shown in the listing but is on JS Bin.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是来自[图 9.4](#ch09fig04)的目标输出！`spacer`代码在列表中没有显示，但在JS Bin上。
- en: Listing 9.10\. A Place constructor, [part 2](kindle_split_019.html#part02) ([http://jsbin.com/qemica/edit?js,console](http://jsbin.com/qemica/edit?js,console))
  id: totrans-1358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 地点构造器，[第二部分](kindle_split_019.html#part02) ([http://jsbin.com/qemica/edit?js,console](http://jsbin.com/qemica/edit?js,console))
- en: '![](ch09ex10-0.jpg)'
  id: totrans-1359
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex10-0.jpg)'
- en: '![](ch09ex10-1.jpg)'
  id: totrans-1360
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex10-1.jpg)'
- en: You use the `spacer` namespace to add new-line characters, put a box around
    the title, and end the information string with a border. There’s a detailed description
    of how the `spacer` methods work in [chapter 7](kindle_split_015.html#ch07), so
    check back there if you need a reminder.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`spacer`命名空间来添加换行符，将标题框起来，并在信息字符串末尾添加边框。`spacer`方法的工作方式在第 7 章中有详细描述，所以如果你需要提醒，请查看那里。
- en: You could have included an `items` parameter as part of the `Place` constructor
    function. But you want to be able to add items to a place while the game is running—when
    a player drops an item, for example—so you’ve kept the constructor function simple
    and included an `addItem` method instead.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Place`构造函数中将`items`参数作为一个部分。但你想在游戏运行时能够向地点添加物品—例如，当玩家丢弃一个物品时—所以你保持了构造函数的简单性，并包含了一个`addItem`方法。
- en: What’s that down that dark passageway? A dragon’s lair? The bridge of a starship?
    A lost valley of dinosaurs?
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 那黑暗通道里是什么？是龙穴？是星际飞船的桥？是恐龙遗失的峡谷？
- en: 9.4.3\. Building the Place constructor—exits to explore
  id: totrans-1364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 构建地点构造器—探索出口
- en: 'One location does not an adventure make; players want to wander vast worlds
    of wonder. The last addition to your `Place` constructor is a way to add exits
    leading to other locations. You include an array of exits for each place and a
    method for adding destinations to the array. You need to display the exits, leading
    to your target output:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 一个地点不能构成一场冒险；玩家想要漫游广阔的奇妙世界。你`Place`构造器的最后一个添加功能是添加通向其他地点的出口。你为每个地点包含一个出口数组和一个向数组添加目的地的方法。你需要显示出口，通向你的目标输出：
- en: '[PRE227]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Once again, the `spacer` code has been omitted from the printed listing.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，打印的列表中省略了`spacer`代码。
- en: Listing 9.11\. A Place constructor, [part 3](kindle_split_026.html#part03) ([http://jsbin.com/parale/edit?js,console](http://jsbin.com/parale/edit?js,console))
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11. 地点构造函数，[第3部分](kindle_split_026.html#part03) ([http://jsbin.com/parale/edit?js,console](http://jsbin.com/parale/edit?js,console))
- en: '![](ch09ex11-0.jpg)'
  id: totrans-1369
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex11-0.jpg](ch09ex11-0.jpg)'
- en: '![](ch09ex11-1.jpg)'
  id: totrans-1370
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex11-1.jpg](ch09ex11-1.jpg)'
- en: The listing is quite long, but you’ve seen all of the techniques before and
    there’s some repetition. Focus on the methods one by one and take your time to
    follow the code.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表相当长，但你之前已经看到了所有这些技术，也有一些重复。一次关注一个方法，并花时间跟随代码。
- en: You start by setting up a quick shortcut. The `spacer.newLine` method always
    returns the new-line escape sequence, `"\n"`, so you call it once and assign the
    return value to the `newLine` variable. You then use `newLine` instead of `spacer.newLine()`.
    That saves you some typing without impacting the readability of the code. You
    also add `getExits` and `getTitle` methods that build their part of the place
    information string. And the `addExits` method is just like the `addItems` method
    but—you guessed it—for adding exits instead of items.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先设置一个快速快捷方式。`spacer.newLine`方法总是返回换行转义序列`"\n"`，所以你只需调用一次，并将返回值赋给`newLine`变量。然后你使用`newLine`而不是`spacer.newLine()`。这样你就可以少打一些字，同时不影响代码的可读性。你还添加了`getExits`和`getTitle`方法，这些方法构建了它们的部分地点信息字符串。而`addExits`方法就像`addItems`方法一样，但——你猜对了——是用来添加出口而不是项目。
- en: The `exits` property holds an array of `Place` objects. In other words, each
    `Place` object contains a collection of `Place` objects. This ability to nest
    objects inside objects can lead to sophisticated models of real-world situations.
    Although a full model can be quite complicated, each component should be relatively
    easy to understand. Your game, *The Crypt*, provides you with enough moving parts
    to appreciate how complicated programs can be constructed from simple pieces.
    Let’s revisit a piece you know well and define a constructor function for player
    objects.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '`exits`属性包含一个`Place`对象的数组。换句话说，每个`Place`对象都包含一个`Place`对象的集合。这种在对象内部嵌套对象的能力可以导致复杂的现实世界情况模型。尽管完整的模型可能相当复杂，但每个组件应该相对容易理解。你的游戏《密室》为你提供了足够的组件来欣赏如何从简单的组件构建复杂的程序。让我们回顾一个你很熟悉的组件，并为玩家对象定义一个构造函数。'
- en: 9.5\. The Crypt—streamlining player creation
  id: totrans-1374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 密室——简化玩家创建
- en: '[Figure 9.5](#ch09fig05) shows where a `Player` constructor function fits into
    the overall structure of our ongoing game example.'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.5](#ch09fig05)显示了`Player`构造函数函数在我们正在进行的游戏示例的整体结构中的位置。'
- en: Figure 9.5\. Elements of *The Crypt*
  id: totrans-1376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5. 《密室》的元素
- en: '![](09fig05_alt.jpg)'
  id: totrans-1377
  prefs: []
  type: TYPE_IMG
  zh: '![09fig05_alt.jpg](09fig05_alt.jpg)'
- en: 'In [chapter 8](kindle_split_016.html#ch08) you added an array of items to `Player`
    objects and defined functions to include the items when displaying player information.
    You still created the players manually:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_016.html#ch08)中，你向`Player`对象添加了一个项目数组，并定义了函数来在显示玩家信息时包含这些项目。你仍然手动创建了玩家：
- en: '[PRE228]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: You assigned the player display functions to their own variables—you collected
    quite a bunch!
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 你将玩家显示函数分配给了它们自己的变量——你收集了一大堆！
- en: '[PRE229]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The display functions combined to show information on the console, as shown
    in [figure 9.6](#ch09fig06).
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 显示函数组合在一起，在控制台上显示信息，如图9.6所示[图9.6](#ch09fig06)。
- en: Figure 9.6\. The elements shown when a `Player` object is displayed on the console.
  id: totrans-1383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6. 在控制台上显示`Player`对象时显示的元素。
- en: '![](09fig06_alt.jpg)'
  id: totrans-1384
  prefs: []
  type: TYPE_IMG
  zh: '![09fig06_alt.jpg](09fig06_alt.jpg)'
- en: 'To add an item to the player’s collection, you pushed it directly to the items
    array:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 要向玩家的收藏夹中添加一个项目，你直接将其推送到项目数组中：
- en: '[PRE230]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 9.5.1\. Organizing player properties
  id: totrans-1387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1. 组织玩家属性
- en: 'It’s time to wrangle all those pieces; you use your mastery of constructor
    functions to streamline player creation, make the functions into methods, and
    do away with the growing number of variables. The `Player` constructor will let
    you create `Player` objects like this:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候整理所有这些组件了；你使用你对构造函数的掌握来简化玩家创建，将函数变成方法，并消除日益增长的变量数量。`Player`构造函数将允许你创建如下`Player`对象：
- en: '[PRE231]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The constructor will also add a method you can call to add items, for example:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还会添加一个你可以调用的方法来添加项目，例如：
- en: '[PRE232]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[Listing 9.12](#ch09ex12) shows the code for the `Player` constructor function.
    It uses methods from the `spacer` namespace introduced in [chapter 7](kindle_split_015.html#ch07).
    The `spacer` code is included on JS Bin but is not shown in the listing. To test
    a `Player` object created by the `Player` constructor, the listing also uses the
    `Place` constructor from [section 9.4](#ch09lev1sec4). Again, that code is omitted
    here but included on JS Bin. And there’s a new type of value, `null`, that’s explained
    in the sections after the listing.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 9.12](#ch09ex12) 展示了`Player`构造函数的代码。它使用了在[第7章](kindle_split_015.html#ch07)中引入的`spacer`命名空间中的方法。`spacer`代码包含在JS
    Bin中，但在代码清单中没有显示。为了测试由`Player`构造函数创建的`Player`对象，代码清单还使用了[第9.4节](#ch09lev1sec4)中的`Place`构造函数。同样，这段代码在这里省略了，但在JS
    Bin中包含了。此外，还有一个新的值类型`null`，在代码清单之后的章节中进行了解释。'
- en: Once again, there’s quite a lot of code here (and even more on JS Bin), but
    don’t worry; you’ve seen similar code before. Check the annotations, read the
    explanations below the listing, and try the *Further Adventures* on JS Bin. It
    might be worth having a quick look at *The Crypt* section from [chapter 8](kindle_split_016.html#ch08)
    too; this builds on that.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里有很多代码（JS Bin中还有更多），但不要担心；你之前已经见过类似的代码。检查注释，阅读代码清单下面的解释，并在JS Bin上尝试*Further
    Adventures*。快速查看[第8章](kindle_split_016.html#ch08)中的*The Crypt*部分也可能很有帮助；这基于前面的内容。
- en: Listing 9.12\. A Player constructor function ([http://jsbin.com/leqahi/edit?js,console](http://jsbin.com/leqahi/edit?js,console))
  id: totrans-1394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 9.12\. `Player`构造函数 ([http://jsbin.com/leqahi/edit?js,console](http://jsbin.com/leqahi/edit?js,console))
- en: '![](ch09ex12-0.jpg)'
  id: totrans-1395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex12-0.jpg)'
- en: '![](ch09ex12-1.jpg)'
  id: totrans-1396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex12-1.jpg)'
- en: Phew! That’s another long listing. Let’s break it down.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这又是一个很长的代码清单。让我们把它分解一下。
- en: 9.5.2\. Turning functions into methods
  id: totrans-1398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. 将函数转换为方法
- en: In [chapters 7](kindle_split_015.html#ch07) and [8](kindle_split_016.html#ch08),
    you defined a number of functions to build up a string of player information and
    display it, for example,
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_015.html#ch07)和[第8章](kindle_split_016.html#ch08)中，你定义了一系列函数来构建玩家信息字符串并显示它，例如，
- en: '[PRE233]'
  id: totrans-1400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'You pass a `Player` object to the function as an argument:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 你将一个`Player`对象作为参数传递给函数：
- en: '[PRE234]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The function then uses properties of the `Player` object to build up and return
    an information string.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后使用`Player`对象的属性来构建并返回一个信息字符串。
- en: You’ve now moved the functions into the `Player` constructor and assigned them
    to properties of the special `this` object.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将函数移动到`Player`构造函数中，并将它们分配给特殊`this`对象的属性。
- en: '[PRE235]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'When we assign functions as properties of objects, we call them *methods*.
    You invoke the methods by using dot notation and parentheses:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数作为对象的属性时，我们称它们为*方法*。你通过使用点符号和括号来调用方法：
- en: '[PRE236]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: You no longer need to pass the `Player` object as an argument to the function.
    Where `this` has been used in the function body, `player1` will take its place.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要将`Player`对象作为参数传递给函数。在函数体中使用`this`的地方，将用`player1`来代替。
- en: '[PRE237]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: becomes
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE238]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Converting all of the functions into methods of the `Player` object does away
    with the need for a separate variable for each function. It also keeps the function
    definitions with the object on which they act. Neat!
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有函数转换为`Player`对象的方法消除了为每个函数单独变量需要的必要性。它还保持了与对象一起的函数定义。真不错！
- en: 9.5.3\. Assigning places to players
  id: totrans-1413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3\. 为玩家分配地点
- en: 'You need to know where players are in *The Crypt*. In earlier chapters, you
    assigned a string to each player’s `place` property:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道玩家在*The Crypt*的位置。在早期章节中，你为每个玩家的`place`属性分配了一个字符串：
- en: '[PRE239]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'But places are more than titles; `Place` objects created with the `Place` constructor
    have titles, descriptions, arrays of items, exits, and methods. From now on, you’ll
    assign players full `Place` objects:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 但地点不仅仅是标题；使用`Place`构造函数创建的`Place`对象有标题、描述、物品数组、出口和方法。从现在开始，你将为玩家分配完整的`Place`对象：
- en: '[PRE240]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: As players explore their environment, you’re able to update the `place` property,
    assigning a previously built `Place` object for each new location.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家探索他们的环境时，你可以更新`place`属性，为每个新位置分配一个之前构建的`Place`对象。
- en: 'Now that you’re assigning full `Place` objects to a player’s place property,
    the `getPlace` method has to do a little extra work to build its information string:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将完整的`Place`对象分配给玩家的地点属性，`getPlace`方法必须做一些额外的工作来构建其信息字符串：
- en: '[PRE241]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Previously, `this.place` held the title of the player’s current location; it
    now holds a `Place` object. The title is now accessed via `this.place.title`.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`this.place`保存了玩家当前地点的标题；现在它保存了一个`Place`对象。标题现在通过`this.place.title`来访问。
- en: 9.5.4\. Using null as a placeholder for objects
  id: totrans-1422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.4\. 使用 `null` 作为对象的占位符
- en: Notice, in [listing 9.12](#ch09ex12), that you assign the special value `null`
    to the `place` property in the constructor function. This shows that you intend
    to use a `place` property in your program but you don’t have a value for it yet;
    you’ll only be able to assign a player’s `place` property when you’ve created
    some places.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [列表 9.12](#ch09ex12) 中，你将特殊值 `null` 分配给构造函数中的 `place` 属性。这表明你打算在你的程序中使用
    `place` 属性，但目前还没有值；你只能在创建了一些地点之后才能分配玩家的 `place` 属性。
- en: '[PRE242]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '|  |'
  id: totrans-1425
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-1426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '`null` is its own type of value. It’s not a string, number, boolean (`true`
    or `false`), or `undefined`. And it’s not an object. Programmers often use it,
    as you have, to show that they haven’t yet assigned an object to a variable or
    property but expect to assign one at some point.'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 是其自身类型的价值。它不是字符串、数字、布尔值（`true` 或 `false`）或 `undefined`。它也不是一个对象。程序员经常像你一样使用它来表明他们尚未将对象分配给变量或属性，但预期在某个时刻会分配一个。'
- en: '|  |'
  id: totrans-1428
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you have an efficient way of creating many objects, you can build all
    of the places in *The Crypt* using a constructor function. You can add items and
    link the places together into a map. You can assign places to players. You still
    need to find a way for players to move from place to place. Once you’ve done that,
    you’ll have a game environment you can explore!
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了创建许多对象的效率方法，你可以使用构造函数构建 *The Crypt* 中的所有地方。你可以添加物品并将地点链接成一个地图。你可以将地点分配给玩家。你仍然需要找到一种让玩家在地点之间移动的方法。一旦你做到了这一点，你将拥有一个可以探索的游戏环境！
- en: 9.6\. Summary
  id: totrans-1430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. 摘要
- en: Use constructor functions to create objects with similar structures.
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数创建具有相似结构的对象。
- en: 'Assign constructor functions to variables starting with a capital letter. Naming
    constructor functions this way is a widely followed convention:'
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构造函数分配给以大写字母开头的变量。以这种方式命名构造函数是一种广泛遵循的约定：
- en: '[PRE243]'
  id: totrans-1433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Call constructor functions with the `new` keyword. Assign the object returned
    to a variable:'
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `new` 关键字调用构造函数。将返回的对象分配给一个变量：
- en: '[PRE244]'
  id: totrans-1435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Use the special `this` variable to set properties within the constructor function.
    `this` is automatically returned from the constructor:'
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊的 `this` 变量在构造函数中设置属性。`this` 会自动从构造函数返回：
- en: '[PRE245]'
  id: totrans-1437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Access properties of the returned object just like any other object:'
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像访问任何其他对象的属性一样访问返回对象的属性：
- en: '[PRE246]'
  id: totrans-1439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Assign functions to properties to create methods. Call the methods using dot
    notation and parentheses:'
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数分配给属性以创建方法。使用点符号和括号调用方法：
- en: '[PRE247]'
  id: totrans-1441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Assign the value `null` to variables or properties if you expect to assign
    an object at some point but the object is not yet available:'
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你预期在某个时刻会分配一个对象，但对象目前不可用，则将值 `null` 分配给变量或属性：
- en: '[PRE248]'
  id: totrans-1443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Use the `instanceof` operator to check if a constructor function was involved
    in creating an object. The operator returns a boolean value, `true` or `false`:'
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `instanceof` 操作符检查构造函数是否参与了对象的创建。操作符返回一个布尔值，`true` 或 `false`：
- en: '[PRE249]'
  id: totrans-1445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Chapter 10\. Bracket notation: flexible property names'
  id: totrans-1446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。括号表示法：灵活的属性名称
- en: '***This chapter covers***'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容有***'
- en: Square brackets as an alternative to dot notation
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号作为点符号的替代
- en: The use of square brackets to set and get properties
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号设置和获取属性
- en: The flexibility of square bracket notation
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号表示法的灵活性
- en: How to build a working game in *The Crypt*
  id: totrans-1451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 *The Crypt* 中构建一个可工作的游戏
- en: In [chapter 3](kindle_split_011.html#ch03) you saw how to create objects with
    curly braces and get and set properties with dot notation. You’ve used objects
    to model players, places, planets, and posts as well as quizzes and calendar events.
    You’ve added functions as properties to make methods and passed your objects to
    and from functions as arguments and return values. Objects are the center of the
    JavaScript universe!
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3章](kindle_split_011.html#ch03) 中，你看到了如何使用花括号创建对象，以及如何使用点符号获取和设置属性。你已经使用对象来模拟玩家、地点、行星、帖子以及测验和日历事件。你将函数作为属性添加以创建方法，并将对象作为参数和返回值传递给函数。对象是
    JavaScript 世界的中心！
- en: In this chapter you take a look at a new way of working with object properties
    that gives you more flexibility with the property names, lets you use variables
    as keys, and gives you the ability to generate new properties from data while
    programs are running.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解一种新的处理对象属性的方法，这种方法使你在属性名称上拥有更多灵活性，允许你使用变量作为键，并在程序运行时从数据中生成新的属性。
- en: We also bring [part 1](kindle_split_008.html#part01) of *Get Programming with
    JavaScript* to a close with a working version of *The Crypt*, finally giving players
    the chance to explore a map and collect treasure! Square bracket notation provides
    a better way for you to manage the links between locations in the game, create
    a web of `Place` objects, and add a touch of mystery to the adventure. Ooooo,
    mystery ...
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还完成了*Get Programming with JavaScript*的第一部分，通过一个可工作的版本*The Crypt*，最终给了玩家探索地图和收集宝藏的机会！方括号符号为你提供了更好的方式来管理游戏中地点之间的链接，创建一个`Place`对象的网络，并为冒险增添一丝神秘感。Ooooo，神秘...
- en: 10.1\. Using square brackets instead of dots
  id: totrans-1455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 使用方括号而不是点
- en: Up until now you’ve used dot notation to set and get object properties.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直使用点符号来设置和获取对象属性。
- en: '[PRE250]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The property name, its *key*, is joined to a variable name with a period, or
    dot. JavaScript also offers an alternative approach: you can set and get properties
    by including a property’s key as a string between square brackets.'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名，即其*键*，通过一个点与变量名连接。JavaScript还提供了一种替代方法：你可以通过在方括号中包含属性键作为字符串来设置和获取属性。
- en: '[PRE251]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This new approach gives you more flexibility in the strings you can use as keys
    and lets you add dynamic properties while your programs are running. Say you had
    a `states` object that held the abbreviations of U.S. states as values, using
    the full names of states as keys. You could use dot notation to find the abbreviation
    for Ohio
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法为你提供了更多灵活性，可以在用作键的字符串中使用，并允许你在程序运行时添加动态属性。比如说，你有一个`states`对象，它存储了美国各州的缩写作为值，使用州的全名作为键。你可以使用点符号来查找俄亥俄州的缩写
- en: '[PRE252]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: but, because of that pesky space, not for New Hampshire
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于那个讨厌的空格，不是用于新罕布什尔州
- en: '[PRE253]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Square brackets solve the problem ([figure 10.1](#ch10fig01)):'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号解决了问题([图10.1](#ch10fig01))：
- en: Figure 10.1\. Using square bracket notation to set a property
  id: totrans-1465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 使用方括号符号设置属性
- en: '![](10fig01.jpg)'
  id: totrans-1466
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig01.jpg)'
- en: '[PRE254]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'And if you had a `getStateCode` function that used the `states` object, square
    bracket notation would let you use a parameter as a key:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个使用`states`对象的`getStateCode`函数，方括号符号将允许你使用参数作为键：
- en: '[PRE255]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Using a parameter to provide the key isn’t possible with dot notation. [Table
    10.1](#ch10table01) shows more situations in which square bracket notation is
    needed.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数提供键在点符号中是不可能的。[表10.1](#ch10table01)展示了更多需要使用方括号符号的情况。
- en: Table 10.1\. Situations in which certain keys do and don’t work
  id: totrans-1471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1\. 某些键是否有效的情况
- en: '| I want to | I try | Success? |'
  id: totrans-1472
  prefs: []
  type: TYPE_TB
  zh: '| 我想 | 我尝试 | 成功？ |'
- en: '| --- | --- | --- |'
  id: totrans-1473
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Use ohio as a key in an object literal | states = { ohio : "OH"'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在对象字面量中使用ohio作为键 | states = { ohio : "OH"'
- en: '}; | Yes |'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '}; | 是 |'
- en: '| Use new hampshire as a key in an object literal | states = { new hampshire
    : "NH"'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在对象字面量中使用new hampshire作为键 | states = { new hampshire : "NH"'
- en: '}; | No |'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '}; | 否 |'
- en: '| Use "new hampshire" as a key in an object literal | states = { "new hampshire"
    : "NH"'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在对象字面量中使用"new hampshire"作为键 | states = { "new hampshire" : "NH"'
- en: '}; | Yes |'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '}; | 是 |'
- en: '| Use maryland as a key with dot notation | states.maryland = "MD"; | Yes |'
  id: totrans-1480
  prefs: []
  type: TYPE_TB
  zh: '| 使用点符号将maryland作为键 | states.maryland = "MD"; | 是 |'
- en: '| Use south carolina as a key with dot notation | states.south carolina = "SC";
    | No |'
  id: totrans-1481
  prefs: []
  type: TYPE_TB
  zh: '| 使用点符号将south carolina作为键 | states.south carolina = "SC"; | 否 |'
- en: '| Use south carolina as a key with square bracket notation | states["south
    carolina"] = "SC"; | Yes |'
  id: totrans-1482
  prefs: []
  type: TYPE_TB
  zh: '| 使用方括号符号将south carolina作为键 | states["south carolina"] = "SC"; | 是 |'
- en: '| Use a parameter as a key with dot notation | function (stateName) { return
    states.stateName;'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: '| 使用点符号将参数作为键 | function (stateName) { return states.stateName;'
- en: '} | No |'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '} | 否 |'
- en: '| Use a parameter as a key with square bracket notation | function (stateName)
    { return states[stateName];'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '| 使用方括号符号将参数作为键 | function (stateName) { return states[stateName];'
- en: '} | Yes |'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '} | 是 |'
- en: Let’s investigate these ideas with a few more examples.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些更多的例子来调查这些想法。
- en: 10.1.1\. Brackets in action—people’s names as keys
  id: totrans-1488
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 方括号的实际应用——人名作为键
- en: 'Say you need to keep a simple record of people’s ages. You could use an `ages`
    object where each person’s name is a key and their age is the corresponding value.
    [Listings 10.1](#ch10ex01), [10.2](#ch10ex02), and [10.3](#ch10ex03) develop this
    approach, logging two ages to the console:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要记录人们的简单年龄记录。你可以使用一个`ages`对象，其中每个人的名字是键，他们的年龄是对应的值。[列表10.1](#ch10ex01)，[10.2](#ch10ex02)，和[10.3](#ch10ex03)展示了这种方法，将两个年龄记录到控制台：
- en: '[PRE256]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: In the first listing, you set the properties using bracket notation and get
    them using dot notation.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个列表中，你使用方括号符号设置属性，并使用点符号获取它们。
- en: Listing 10.1\. Bracket notation for object properties ([http://jsbin.com/kipedu/edit?js,console](http://jsbin.com/kipedu/edit?js,console))
  id: totrans-1492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 对象属性的括号符号 ([http://jsbin.com/kipedu/edit?js,console](http://jsbin.com/kipedu/edit?js,console))
- en: '![](150fig01_alt.jpg)'
  id: totrans-1493
  prefs: []
  type: TYPE_IMG
  zh: '![](150fig01_alt.jpg)'
- en: The two methods are equivalent for the keys used in [listing 10.1](#ch10ex01).
    If you want to include spaces in the property names, you *must* use bracket notation.
    The next listing shows a similar example using full names.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法对于在[列表10.1](#ch10ex01)中使用的键是等效的。如果你想在属性名称中包含空格，*必须*使用括号符号。下一个列表展示了使用完整名称的类似示例。
- en: Listing 10.2\. Longer strings as keys ([http://jsbin.com/toviya/edit?js,console](http://jsbin.com/toviya/edit?js,console))
  id: totrans-1495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 较长的字符串作为键 ([http://jsbin.com/toviya/edit?js,console](http://jsbin.com/toviya/edit?js,console))
- en: '[PRE257]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Trying to use dot notation with property names that include spaces will confuse
    JavaScript: `ages.Kandra Smith` will be interpreted as `ages.Kandra` and `Smith`
    will be seen as a separate variable name, as shown in [figure 10.2](#ch10fig02).'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用点符号与包含空格的属性名称将使JavaScript困惑：`ages.Kandra Smith`将被解释为`ages.Kandra`，而`Smith`将被视为一个单独的变量名，如图10.2所示。
- en: Figure 10.2\. Spaces in property names don’t work with dot notation.
  id: totrans-1498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 属性名称中的空格与点符号不兼容。
- en: '![](10fig02.jpg)'
  id: totrans-1499
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig02.jpg)'
- en: The bracket notation immediately gives you the flexibility to use property names
    that may make more sense in context, like people’s names, rather than being restricted
    to the single words of dot notation.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 括号符号立即为您提供使用在上下文中可能更有意义的属性名称的灵活性，例如人名，而不是被限制在点符号的单个单词中。
- en: Bracket notation also allows you to add properties on the fly, when you may
    not know the keys in advance. Maybe a user is entering the information or it’s
    being fetched from a file or database. In the next listing, you include an `addAge`
    function for adding new people to the `ages` object. If you run this listing you’ll
    be able to use the function to add new people via the console.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 括号符号还允许你在不知道键的情况下动态添加属性。也许用户正在输入信息，或者信息是从文件或数据库中获取的。在下一个列表中，你包括一个`addAge`函数来向`ages`对象添加新的人。如果你运行这个列表，你将能够通过控制台使用该函数添加新的人。
- en: Listing 10.3\. Using a function to add ages ([http://jsbin.com/pipuva/edit?js,console](http://jsbin.com/pipuva/edit?js,console))
  id: totrans-1502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 使用函数添加年龄 ([http://jsbin.com/pipuva/edit?js,console](http://jsbin.com/pipuva/edit?js,console))
- en: '![](151fig01_alt.jpg)'
  id: totrans-1503
  prefs: []
  type: TYPE_IMG
  zh: '![](151fig01_alt.jpg)'
- en: In [listing 10.3](#ch10ex03) you use the `name` parameter in the `addAge` function
    as the key for the `ages` object. When you call `addAge`, the first argument you
    include in the call is assigned to the `name` parameter. For example,
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表10.3](#ch10ex03)中，你将`addAge`函数中的`name`参数用作`ages`对象的键。当你调用`addAge`时，你包含在调用中的第一个参数被分配给`name`参数。例如，
- en: '[PRE258]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: assigns `"Kandra Smith"` to `name` and `56` to `age`, so that
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 将`"Kandra Smith"`分配给`name`，将`56`分配给`age`，因此
- en: '[PRE259]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: becomes
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE260]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: This ability to use a variable between the square brackets for setting a property
    gives you great versatility to dynamically create and mutate objects in your programs.
    You make further use of the technique in [sections 10.1.2](#ch10lev2sec2) and
    [10.2](#ch10lev1sec2).
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号之间使用变量来设置属性的能力，使你在程序中动态创建和修改对象具有极大的灵活性。你将在[10.1.2节](#ch10lev2sec2)和[10.2节](#ch10lev1sec2)中进一步使用这项技术。
- en: If you want to create an object with properties already in place, then you use
    the curly braces syntax, with commas separating the key-value pairs. You can include
    spaces in the keys if you wrap the keys in quotation marks. The following listing
    shows the idea. It also introduces the `Object.keys` method that returns an array
    containing all of the keys set on an object. In the listing, you print the `keys`
    array to the console.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个已经包含属性的对象，那么你使用大括号语法，用逗号分隔键值对。如果你在键周围加上引号，你可以在键中包含空格。以下列表展示了这个概念。它还介绍了`Object.keys`方法，该方法返回一个包含对象上设置的所有键的数组。在列表中，你将`keys`数组打印到控制台。
- en: '[PRE261]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Listing 10.4\. Using Object.keys ([http://jsbin.com/mehuno/edit?js,console](http://jsbin.com/mehuno/edit?js,console))
  id: totrans-1513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 使用Object.keys ([http://jsbin.com/mehuno/edit?js,console](http://jsbin.com/mehuno/edit?js,console))
- en: '![](152fig01_alt.jpg)'
  id: totrans-1514
  prefs: []
  type: TYPE_IMG
  zh: '![](152fig01_alt.jpg)'
- en: '`Object` is a built-in JavaScript object. It provides a number of methods,
    one of which is called `keys`. Because `Object.keys` returns an array, you can
    use `forEach` to pass each key to a function. [Listing 10.5](#ch10ex05) passes
    each key in turn to the `console.log` function that simply logs the key to the
    console.'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 是一个内置的 JavaScript 对象。它提供了一些方法，其中之一被称为 `keys`。因为 `Object.keys` 返回一个数组，所以你可以使用
    `forEach` 将每个键传递给一个函数。[列表 10.5](#ch10ex05) 依次将每个键传递给 `console.log` 函数，该函数只是将键记录到控制台。'
- en: '[PRE262]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Listing 10.5\. Iterating over Object.keys with forEach ([http://jsbin.com/seteco/edit?js,console](http://jsbin.com/seteco/edit?js,console))
  id: totrans-1517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 使用 `forEach` 遍历 `Object.keys` ([http://jsbin.com/seteco/edit?js,console](http://jsbin.com/seteco/edit?js,console))
- en: '![](152fig02_alt.jpg)'
  id: totrans-1518
  prefs: []
  type: TYPE_IMG
  zh: '![图片](152fig02_alt.jpg)'
- en: Let’s check out another example of using square bracket notation’s ability to
    include complicated property names.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用方括号表示法包含复杂属性名的另一个例子。
- en: 10.1.2\. Making the most of square bracket notation—word counts
  id: totrans-1520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 充分利用方括号表示法——单词计数
- en: As the social media expert at your workplace, you’ve been tasked with analyzing
    tweets. Your first job is to count the number of times each word is used in a
    batch of tweets. [Figure 10.3](#ch10fig03) shows parts of the console output of
    a tweet-analyzing program.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你工作场所的社会媒体专家，你被分配了分析推文的任务。你的第一项工作是计算每个单词在一批推文中使用的次数。[图 10.3](#ch10fig03) 显示了推文分析程序控制台输出的部分。
- en: Figure 10.3\. Counting words used in tweets
  id: totrans-1522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. 计数推文中使用的单词
- en: '![](10fig03.jpg)'
  id: totrans-1523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig03.jpg)'
- en: The program is shown in the following listing (with only three tweets to save
    space) and uses an object, `words`, to record the word counts.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如下所示（只包含三个推文以节省空间）并使用一个对象 `words` 来记录单词计数。
- en: Listing 10.6\. Counting words from tweets ([http://jsbin.com/figati/edit?js,console](http://jsbin.com/figati/edit?js,console))
  id: totrans-1525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 从推文中计数单词 ([http://jsbin.com/figati/edit?js,console](http://jsbin.com/figati/edit?js,console))
- en: '![](153fig01_alt.jpg)'
  id: totrans-1526
  prefs: []
  type: TYPE_IMG
  zh: '![图片](153fig01_alt.jpg)'
- en: The program does quite a lot in a few lines of code. First, it uses the `join`
    array method (introduced in [chapter 8](kindle_split_016.html#ch08)) to join all
    of the tweets to form one long string with a space between each pair of tweets.
    Next, it uses the `split` method to create an array of all of the words. `split`
    is a built-in string method. You can use it to break a string into pieces, with
    each piece as an element of an array. If you assign a string to the `mes``sage`
    variable
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在几行代码中做了很多事情。首先，它使用 `join` 数组方法（在第 8 章中介绍）将所有推文连接成一个长字符串，每对推文之间有一个空格。然后，它使用
    `split` 方法创建一个包含所有单词的数组。`split` 是一个内置的字符串方法。你可以使用它将字符串拆分成片段，每个片段作为数组的元素。如果你将一个字符串赋值给
    `message` 变量
- en: '[PRE263]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: you can break the string into an array with three elements by calling the `split`
    method on the variable.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在变量上调用 `split` 方法将字符串拆分成一个包含三个元素的数组。
- en: '[PRE264]'
  id: totrans-1530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'The argument you pass to the `split` method is a string the function uses to
    decide where to split the text. The previous example uses a space as the separator,
    but any string will work. Here’s an example using commas:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给 `split` 方法的参数是一个字符串，该函数使用它来决定在哪里分割文本。上一个例子使用空格作为分隔符，但任何字符串都可以工作。以下是一个使用逗号的例子：
- en: '[PRE265]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'If you pass the empty string, `""`, as the argument to `split`, it creates
    an array of all of the individual characters used in the text:'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将空字符串 `""` 作为 `split` 的参数传递，它将创建一个包含文本中使用的所有单个字符的数组：
- en: '[PRE266]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Back to your tweet analyzer. Once it generates the array of words with `split`,
    [listing 10.6](#ch10ex06) iterates over the array of words twice. The first time,
    it creates properties with the words as keys and zero as the values. `["I", "love",
    "donuts"]` leads to
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的推文分析器。一旦它使用 `split` 生成单词数组，[列表 10.6](#ch10ex06) 就会两次遍历单词数组。第一次，它使用单词作为键并使用零作为值创建属性。`["I",
    "love", "donuts"]` 导致
- en: '[PRE267]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: If a word appears more than once, its property will be assigned zero each time—a
    little redundancy but not a problem. On the second iteration, the code adds one
    to a property’s value every time the word appears.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单词出现多次，它的属性将在每次出现时被分配零——有一点冗余但不是问题。在第二次迭代中，代码每次单词出现时都会将属性值加一。
- en: '[PRE268]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Alternatively, you could use the `+=` operator to add one to the count for
    each word. You’ve seen `+=` used to concatenate strings but it also works with
    numbers, adding a new number to an existing number. The following two statements
    are equivalent:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 `+=` 运算符为每个单词的计数加一。你已经看到 `+=` 用于连接字符串，但它也可以与数字一起使用，将新数字添加到现有数字上。以下两个语句是等价的：
- en: '[PRE269]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'In fact, if you just want to add one each time, there’s an operator for exactly
    that purpose, `++`. The following two statements are equivalent:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你只想每次添加一个，有一个运算符正好为此目的，`++`。以下两个语句是等价的：
- en: '[PRE270]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: But you want your code to be easy to follow and `++` is a bit terse (as well
    as having some other complications we won’t go into). You’ll probably bump into
    it out and about in codeland, but you won’t use it in this book until part 4.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 但你希望你的代码易于理解，`++`有点简短（以及还有一些我们不深入探讨的复杂问题）。你可能会在代码世界中遇到它，但直到第4部分你不会在这本书中使用它。
- en: You’ve iterated over all of the words twice. By the end of the second iteration,
    each property has a word as a key and the word’s count as its value. Well done;
    have a pay raise! Do check out the working example on JS Bin and add more tweets
    or text from other sources for analysis.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对所有的单词进行了两次迭代。到第二次迭代的结束时，每个属性都有一个单词作为键，单词的计数作为其值。做得好；涨工资！请务必查看JS Bin上的工作示例，并添加更多推文或来自其他来源的文本进行分析。
- en: With a simple tweak, you can perform a letter count instead of a word count.
    The next listing shows how.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的调整，你可以执行字母计数而不是单词计数。下一个列表显示了如何操作。
- en: Listing 10.7\. Counting letters from tweets ([http://jsbin.com/rusufi/edit?js,console](http://jsbin.com/rusufi/edit?js,console))
  id: totrans-1546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 从推文中计数字母([http://jsbin.com/rusufi/edit?js,console](http://jsbin.com/rusufi/edit?js,console))
- en: '![](155fig01_alt.jpg)'
  id: totrans-1547
  prefs: []
  type: TYPE_IMG
  zh: '![](155fig01_alt.jpg)'
- en: '[Listing 10.7](#ch10ex07) works in the same way as [listing 10.6](#ch10ex06),
    using `join` and `split` to create an array and then iterating over the array
    twice to perform the count.'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.7](#ch10ex07)与[列表10.6](#ch10ex06)的工作方式相同，使用`join`和`split`创建一个数组，然后迭代数组两次进行计数。'
- en: In the next section, you put square bracket notation’s ability to work with
    arbitrary strings to good use managing exits in *The Crypt*.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将利用方括号符号处理任意字符串的能力来管理*The Crypt*中的出口。
- en: 10.2\. The Crypt—enhancing exit excitement
  id: totrans-1550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. The Crypt——增强出口的兴奋感
- en: You’ll now apply your knowledge of square bracket notation to *The Crypt*. [Figure
    10.4](#ch10fig04) shows where the focus of this section, linking places via exits,
    fits into the overall structure of our ongoing game example.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将应用你对方括号符号的知识到*The Crypt*。[图10.4](#ch10fig04)显示了本节的重点，通过出口连接地点，如何融入到我们正在进行的游戏示例的整体结构中。
- en: Figure 10.4\. Elements of *The Crypt*
  id: totrans-1552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. *The Crypt*的元素
- en: '![](10fig04_alt.jpg)'
  id: totrans-1553
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig04_alt.jpg)'
- en: 'As it stands, the `Place` constructor you defined for *The Crypt* in [chapter
    9](kindle_split_017.html#ch09) gives away a little too much when it lists the
    exits for the current place in a game:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当你为*The Crypt*定义的`Place`构造函数在[第9章](kindle_split_017.html#ch09)中列出当前地点的出口时，会泄露一些信息：
- en: '[PRE271]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: It lists what players will find when they leave the current location. By the
    end of this section, you inject a bit more mystery by simply listing the directions
    available rather than the destinations.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 它列出了玩家离开当前位置时会发现什么。到本节结束时，你通过只列出可用的方向而不是目的地，增加了一丝神秘感。
- en: '[PRE272]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Players will find out what’s around the corner only when they get there. Feel
    the tension!
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家只有在到达那里后才会发现角落里有什么。感受紧张气氛！
- en: To help you focus on using objects with square bracket notation to enhance the
    exits—that’s what this chapter is all about after all—you create a new, simplified
    `Place` constructor on which to experiment. Then, in [section 10.2.4](#ch10lev2sec6),
    you use your burgeoning square bracket skills to update your constructor from
    [chapter 9](kindle_split_017.html#ch09).
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你专注于使用方括号符号的对象来增强出口——毕竟，这正是本章的主要内容——你创建了一个新的、简化的`Place`构造函数来进行实验。然后，在[第10.2.4节](#ch10lev2sec6)中，你使用你正在发展的方括号技能来更新你的构造函数，从[第9章](kindle_split_017.html#ch09)开始。
- en: 10.2.1\. Using an object to hold the exits
  id: totrans-1560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 使用对象来保存出口
- en: To add that extra layer of the unknown, you use an exits *object* rather than
    an exits *array*. The object keys are directions, like `"north"` or `"the trapdoor"`,
    and the values are the destinations. [Listing 10.8](#ch10ex08) displays the directions
    and destinations on the console. You hide the destinations later.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加未知的一层，你使用出口*对象*而不是出口*数组*。对象键是方向，如`"north"`或`"the trapdoor"`，值是目的地。[列表10.8](#ch10ex08)在控制台上显示了方向和目的地。你稍后会隐藏目的地。
- en: '[PRE273]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Listing 10.8\. An exits object ([http://jsbin.com/daqato/edit?js,console](http://jsbin.com/daqato/edit?js,console))
  id: totrans-1563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 出口对象([http://jsbin.com/daqato/edit?js,console](http://jsbin.com/daqato/edit?js,console))
- en: '![](156fig01_alt.jpg)'
  id: totrans-1564
  prefs: []
  type: TYPE_IMG
  zh: '![](156fig01_alt.jpg)'
- en: In [listing 10.8](#ch10ex08), you begin by defining a very simple `Place` constructor
    function. Remember from [chapter 9](kindle_split_017.html#ch09) that when you
    call a constructor function with the `new` keyword, JavaScript automatically creates
    an empty object and assigns it to the special `this` variable. You set the `title`
    property of `this` to the value of the `title` parameter.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 10.8](#ch10ex08) 中，你首先定义了一个非常简单的 `Place` 构造函数。记得从 [第 9 章](kindle_split_017.html#ch09)
    中，当你使用 `new` 关键字调用构造函数时，JavaScript 会自动创建一个空对象并将其分配给特殊的 `this` 变量。你将 `this` 的 `title`
    属性设置为 `title` 参数的值。
- en: '[PRE274]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'You immediately use the constructor function to create two `Place` objects:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 你立即使用构造函数来创建两个 `Place` 对象：
- en: '[PRE275]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'To keep things simple, you use a single `exits` variable for now. Later, you
    include it as part of the `Place` constructor function. So, you create an empty
    object and assign it to the `exits` variable:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，你目前使用一个单独的 `exits` 变量。稍后，你将其作为 `Place` 构造函数函数的一部分包含在内。因此，你创建一个空对象并将其分配给
    `exits` 变量：
- en: '[PRE276]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'You have two `Place` objects, `kitchen` and `dungeon`, and you want to set
    them as destinations for different directions. You create corresponding properties
    on the `exits` object, using the directions as keys and the destinations as values:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个 `Place` 对象，`kitchen` 和 `dungeon`，并且你想要将它们设置为不同方向的目的地。你使用方向作为键，目的地作为值，在
    `exits` 对象上创建相应的属性：
- en: '[PRE277]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Finally, you use the `forEach` method to pass each key (in other words, each
    direction) in turn to the function specified.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用 `forEach` 方法依次将每个键（换句话说，每个方向）传递给指定的函数。
- en: '[PRE278]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The keys are `"north"` and `"the trapdoor"`, so the code is the same as
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 键是 `"north"` 和 `"the trapdoor"`，所以代码与
- en: '[PRE279]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: But `exits["north"]` is the `kitchen` object and `exits["the trapdoor"]` is
    the `dungeon` object, so the code becomes
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `exits["north"]` 是 `kitchen` 对象，而 `exits["the trapdoor"]` 是 `dungeon` 对象，所以代码变为
- en: '[PRE280]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: leading to the output shown before the listing.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 导致在列表之前显示的输出。
- en: 10.2.2\. Creating functions to add and display exits
  id: totrans-1580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 创建用于添加和显示出口的函数
- en: 'Okay, so you successfully used square bracket notation to associate directions
    and destinations. In [listing 10.9](#ch10ex09) you add a couple of helper functions
    to the code, `addExit` and `showExits`, to simplify the adding and displaying
    of exits. The output is the same as for [listing 10.8](#ch10ex08):'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以你成功地使用了方括号表示法来关联方向和目的地。在 [列表 10.9](#ch10ex09) 中，你向代码中添加了两个辅助函数，`addExit`
    和 `showExits`，以简化出口的添加和显示。输出与 [列表 10.8](#ch10ex08) 相同：
- en: '[PRE281]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: Listing 10.9\. Functions to add and show exits ([http://jsbin.com/mibube/edit?js,console](http://jsbin.com/mibube/edit?js,console))
  id: totrans-1583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 添加和显示出口的函数 ([http://jsbin.com/mibube/edit?js,console](http://jsbin.com/mibube/edit?js,console))
- en: '![](ch10ex09-0.jpg)'
  id: totrans-1584
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex09-0.jpg)'
- en: '![](ch10ex09-1.jpg)'
  id: totrans-1585
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex09-1.jpg)'
- en: 'The `addExit` function takes two arguments: a `direction` string and a `Place`
    object. The `direction` string becomes a new key on the `exits` object; the `Place`
    object becomes the corresponding value.'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: '`addExit` 函数接受两个参数：一个 `direction` 字符串和一个 `Place` 对象。`direction` 字符串成为 `exits`
    对象上的新键；`Place` 对象成为相应的值。'
- en: '[PRE282]'
  id: totrans-1587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: executes the code
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码
- en: '[PRE283]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The `showExits` function iterates over the keys of the `exits` object (in other
    words, it iterates over the directions) and displays the destination for each
    direction.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: '`showExits` 函数遍历 `exits` 对象的键（换句话说，它遍历方向）并显示每个方向的目的地。'
- en: 10.2.3\. Giving each place object its own set of exits
  id: totrans-1591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 为每个地点对象设置其自己的出口集合
- en: 'You’ve seen how you can use an `exits` object to model directions and destinations.
    But each place object needs its own set of exits. You don’t want to mix up the
    exits from The Fairy Fun Park with the exits from The Dungeon of Doom. In [listing
    10.10](#ch10ex10), you move the `exits` object into the `Place` constructor. To
    test the functionality of the new `Place` constructor, you create three places,
    `library`, `kitchen`, and `garden`, and add a couple of exits to `kitchen`. The
    `kitchen` exits are then displayed:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用 `exits` 对象来模拟方向和目的地。但每个地点对象都需要其自己的出口集合。你不想把《仙子欢乐园》的出口和《末日地牢》的出口混淆起来。在
    [列表 10.10](#ch10ex10) 中，你将 `exits` 对象移动到 `Place` 构造函数中。为了测试新的 `Place` 构造函数的功能，你创建了三个地点，`library`、`kitchen`
    和 `garden`，并在 `kitchen` 上添加了一些出口。然后显示 `kitchen` 的出口：
- en: '[PRE284]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Listing 10.10\. An exits object in the Place constructor ([http://jsbin.com/foboka/edit?js,console](http://jsbin.com/foboka/edit?js,console))
  id: totrans-1594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 地点构造函数中的出口对象 ([http://jsbin.com/foboka/edit?js,console](http://jsbin.com/foboka/edit?js,console))
- en: '![](ch10ex10-0.jpg)'
  id: totrans-1595
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex10-0.jpg)'
- en: '![](ch10ex10-1.jpg)'
  id: totrans-1596
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex10-1.jpg)'
- en: 'The `addExit` and `showExits` functions are designed to work with `Place` and
    `exits` objects, so it makes sense to bundle them with the other place code inside
    the constructor. You can then use dot notation and parentheses to call the functions:'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '`addExit`和`showExits`函数被设计成与`Place`和`exits`对象一起工作，因此将它们捆绑在构造函数内的其他地点代码中是有意义的。然后你可以使用点符号和括号来调用函数：'
- en: '[PRE285]'
  id: totrans-1598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[Listing 10.11](#ch10ex11) uses the same `Place` code to build a slightly bigger
    map, linking four locations, as shown in [figure 10.5](#ch10fig05).'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.11](#ch10ex11)使用相同的`Place`代码构建了一个稍微大一点的地图，链接了四个地点，如图10.5所示。'
- en: Figure 10.5\. A map with four locations
  id: totrans-1600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 一个包含四个地点的地图
- en: '![](10fig05_alt.jpg)'
  id: totrans-1601
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig05_alt.jpg)'
- en: 'The output from two locations is shown on the console:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 两个地点的输出显示在控制台上：
- en: '[PRE286]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Listing 10.11\. A map with four locations ([http://jsbin.com/bufico/edit?js,console](http://jsbin.com/bufico/edit?js,console))
  id: totrans-1604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11\. 一个包含四个地点的地图([http://jsbin.com/bufico/edit?js,console](http://jsbin.com/bufico/edit?js,console))
- en: '![](ch10ex11-0.jpg)'
  id: totrans-1605
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex11-0.jpg)'
- en: '![](ch10ex11-1.jpg)'
  id: totrans-1606
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex11-1.jpg)'
- en: Notice how, once you’ve defined a `Place` constructor, you can use it to create
    and link as many places as you need. The constructor code can stay the same—you
    can move it from one adventure into another—all you need to change are the places
    you create, the map data.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦你定义了一个`Place`构造函数，你就可以用它来创建和链接你需要的任意数量的地点。构造函数代码可以保持不变——你可以将它从一个冒险移动到另一个冒险——你只需要更改你创建的地点和地图数据。
- en: 10.2.4\. Adding the exits object to the full Place constructor
  id: totrans-1608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.4\. 将`exits`对象添加到完整的`Place`构造函数中
- en: So far in [section 10.2](#ch10lev1sec2), you’ve seen how to combine an `exits`
    object with square bracket notation to manage the links between `Place` objects
    in *The Crypt*. To keep the focus on the square brackets, you built up the code
    starting with a new, simple `Place` constructor. It’s time to combine the enhanced
    exits with the great work you did building constructors in [chapter 9](kindle_split_017.html#ch09),
    to produce the format of output for each place shown in [figure 10.6](#ch10fig06).
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在[第10.2节](#ch10lev1sec2)中，你已经看到了如何将`exits`对象与方括号符号结合使用来管理*The Crypt*中`Place`对象之间的链接。为了保持对方括号的关注，你从一个新的简单`Place`构造函数开始构建代码。现在是时候将增强的出口与你在[第9章](kindle_split_017.html#ch09)中构建构造函数所做的出色工作结合起来，以生成[图10.6](#ch10fig06)中显示的每个地点的输出格式。
- en: Figure 10.6\. The console output for a `Place` object when you call `showInfo`
  id: totrans-1610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6\. 当你调用`showInfo`时`Place`对象的控制台输出
- en: '![](10fig06.jpg)'
  id: totrans-1611
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig06.jpg)'
- en: '[Listing 10.12](#ch10ex12) shows the complete `Place` constructor function
    code. Most of it was discussed in [chapter 9](kindle_split_017.html#ch09), so
    head back there if you need to refresh your memory. The new exits code is shown
    in bold and is annotated. The listing on JS Bin includes map info that is discussed
    in the next section.'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.12](#ch10ex12)显示了完整的`Place`构造函数代码。其中大部分内容在第9章中已经讨论过，所以如果你需要刷新记忆，请回到那里。新的出口代码以粗体显示，并附有注释。JS
    Bin上的列表包括下一节中讨论的地图信息。'
- en: Listing 10.12\. A Place constructor function ([http://jsbin.com/zozule/edit?js,console](http://jsbin.com/zozule/edit?js,console))
  id: totrans-1613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12\. `Place`构造函数([http://jsbin.com/zozule/edit?js,console](http://jsbin.com/zozule/edit?js,console))
- en: '![](ch10ex12-0.jpg)'
  id: totrans-1614
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex12-0.jpg)'
- en: '![](ch10ex12-1.jpg)'
  id: totrans-1615
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex12-1.jpg)'
- en: With this latest version of the `Place` constructor, you can create place objects,
    manage their items and exits, and display formatted information (courtesy of `spacer`)
    on the console. Let’s take it for a spin.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个最新的`Place`构造函数版本，你可以创建地点对象，管理它们的物品和出口，并在控制台上显示格式化的信息（由`spacer`提供）。让我们试一试。
- en: 10.2.5\. Testing the Place constructor
  id: totrans-1617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.5\. 测试`Place`构造函数
- en: 'To test the `Place` constructor, you re-create the map from [listing 10.11](#ch10ex11)
    that links four locations: `kitchen`, `library`, `garden`, and `cupboard`. The
    next listing shows the map-creation code. The output is shown in [figure 10.6](#ch10fig06).'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`Place`构造函数，你重新创建了[列表10.11](#ch10ex11)中的地图，该地图链接了四个地点：`厨房`、`图书馆`、`花园`和`壁橱`。下一个列表显示了地图创建代码。输出显示在[图10.6](#ch10fig06)中。
- en: Listing 10.13\. Testing the Place constructor ([http://jsbin.com/zozule/edit?js,console](http://jsbin.com/zozule/edit?js,console))
  id: totrans-1619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13\. 测试`Place`构造函数([http://jsbin.com/zozule/edit?js,console](http://jsbin.com/zozule/edit?js,console))
- en: '![](ch10ex13-0.jpg)'
  id: totrans-1620
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex13-0.jpg)'
- en: '![](ch10ex13-1.jpg)'
  id: totrans-1621
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex13-1.jpg)'
- en: You follow the map-creation code with a call to `kitchen.showInfo` to test that
    the `kitchen` object and its items and exits have been created as expected.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 你跟随地图创建代码，调用`kitchen.showInfo`来测试`厨房`对象及其物品和出口是否已按预期创建。
- en: 10.3\. The Crypt—let the games begin!
  id: totrans-1623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. The Crypt——游戏开始！
- en: 'You’re so close! You have everything you need to build and display a universe
    of worlds for players to explore:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经非常接近了！您已经有了构建和显示玩家可以探索的宇宙所需的一切：
- en: The `spacer` namespace
  id: totrans-1625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spacer` 命名空间'
- en: The `Player` constructor
  id: totrans-1626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player` 构造函数'
- en: The `Place` constructor
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Place` 构造函数'
- en: The map-creation code
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图创建代码
- en: 'There’s one more piece to be added before players can be set free on their
    adventures:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家可以开始他们的冒险之前，还需要添加一个部分：
- en: Game controls
  id: totrans-1630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏控制
- en: '[Figure 10.7](#ch10fig07) shows the three game functions you’ll create in this
    section and how they fit into the overall structure of our ongoing example.'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.7](#ch10fig07) 展示了本节中您将创建的三个游戏函数以及它们如何融入我们正在进行的示例的整体结构。'
- en: Figure 10.7\. Elements of *The Crypt*
  id: totrans-1632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. 《The Crypt》的元素
- en: '![](10fig07_alt.jpg)'
  id: totrans-1633
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig07_alt.jpg)'
- en: You want players to be able to issue commands at the console prompt, commands
    to move from place to place and to pick up items that they find. For example,
    to move north and pick up an item, a player would type
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望玩家能够在控制台提示符下发出命令，命令从地点移动到地点以及捡起他们找到的物品。例如，要向北移动并捡起物品，玩家将输入
- en: '[PRE287]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Luckily, because of the work you put into the constructors, the game control
    code is actually quite short. It’s shown here.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于您在构造函数中投入了工作，游戏控制代码实际上相当简短。它在这里显示。
- en: Listing 10.14\. Playing the game ([http://jsbin.com/sezayo/edit?js,console](http://jsbin.com/sezayo/edit?js,console))
  id: totrans-1637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 玩游戏 ([http://jsbin.com/sezayo/edit?js,console](http://jsbin.com/sezayo/edit?js,console))
- en: '![](ch10ex14-0.jpg)'
  id: totrans-1638
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex14-0.jpg)'
- en: '![](ch10ex14-1.jpg)'
  id: totrans-1639
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex14-1.jpg)'
- en: 'You create three functions: `render`, `go`, and `get`. Each function is discussed
    in its own section next. Both `go` and `get` end by returning an empty string,
    `""`. When you call functions at the console, it automatically displays their
    return values. Returning an empty string prevents the console from displaying
    the return value `undefined`.'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了三个函数：`render`、`go` 和 `get`。每个函数将在下面的单独部分中进行讨论。`go` 和 `get` 函数都以返回一个空字符串
    `""` 结束。当您在控制台调用函数时，它将自动显示它们的返回值。返回空字符串可以防止控制台显示返回值 `undefined`。
- en: 10.3.1\. Updating the display—render
  id: totrans-1641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 更新显示—渲染
- en: At the start of each game and each time a player takes an action, you want to
    update the display on the console. Both `Place` objects and `Player` objects have
    `showInfo` methods to display their current state; for example,
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次游戏开始以及玩家采取行动时，您都希望更新控制台上的显示。`Place` 对象和 `Player` 对象都有 `showInfo` 方法来显示它们当前的状态；例如，
- en: '[PRE288]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: The program assigns the player’s current location to their `place` property.
    To display information about the current place, you therefore include the code
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将玩家的当前位置分配给他们的 `place` 属性。因此，要显示当前位置的信息，您需要包含以下代码
- en: '[PRE289]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: You could keep appending text to the console, but it’s neater to clear it and
    start from a blank slate after each player action. The `clear` method removes
    the text from the console.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续向控制台追加文本，但每次玩家采取行动后清除它并从一张白纸开始会更整洁。`clear` 方法从控制台移除文本。
- en: '[PRE290]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: You update the console after a player moves and after they pick up an item.
    Rather than repeating the display code, you wrap it inside the `render` function
    and call it on demand.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家移动后以及他们捡起物品后，您需要更新控制台。您不是重复显示代码，而是将其包装在 `render` 函数中，并在需要时调用它。
- en: 10.3.2\. Exploring the map—go
  id: totrans-1649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 探索地图—移动
- en: 'To move to a new location, a player calls the `go` function, specifying the
    direction in which they want to move:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动到新位置，玩家需要调用 `go` 函数，并指定他们想要移动的方向：
- en: '[PRE291]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'You need to find the destination for the direction the player specifies and
    assign it as the player’s new location:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要找到玩家指定的方向的终点，并将其指定为玩家的新的位置：
- en: '[PRE292]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'In the expression on the right side of the assignment, you use square bracket
    notation to retrieve the `Place` object for the direction specified, `exits[direction]`.
    You use dot notation to access the `exits` object:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值表达式的右侧，您使用方括号表示法来检索指定方向的 `Place` 对象，即 `exits[direction]`。您使用点表示法来访问 `exits`
    对象：
- en: '[PRE293]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: The `Place` object for the destination is assigned to the player’s `place` property,
    replacing their old location. They’ve moved.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标位置的 `Place` 对象分配给玩家的 `place` 属性，替换他们的旧位置。他们已经移动了。
- en: 10.3.3\. Collecting all the things—get
  id: totrans-1657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 收集所有物品—获取
- en: 'To pick up an item, the player calls the `get` function:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 要捡起物品，玩家调用 `get` 函数：
- en: '[PRE294]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'You remove the item from the current location and add it to the player’s array
    of items. The current location is `player.place`. The items at the current location
    are held in the `player.place.items` array. To remove and return the last item
    in the `items` array, you use the `pop` method:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 你将物品从当前位置移除并添加到玩家的物品数组中。当前位置是 `player.place`。当前位置的物品存储在 `player.place.items`
    数组中。要移除并返回 `items` 数组中的最后一个物品，你使用 `pop` 方法：
- en: '[PRE295]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'You then add it to the player’s collection:'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到玩家的收藏中：
- en: '[PRE296]'
  id: totrans-1663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: And that’s it! You’ve given players the ability to boldly go from place to place,
    picking up any treasure they might find.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你已经给了玩家从地方到地方大胆前进的能力，收集他们可能找到的任何宝藏。
- en: 10.3.4\. Designing a bigger adventure—Jahver’s ship
  id: totrans-1665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4. 设计更大的冒险——贾弗的船
- en: Four locations based around a kitchen may not be the world of adventure you
    were hoping for. To conjure mystical realms, replicate dystopian futures, and
    weave webs of intrigue, all you need to do is change the map section of the code.
    Have a go at building your own locations, linking them via exits, and stocking
    them with interesting artifacts.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 基于厨房的四个位置可能不是你希望中的冒险世界。为了创造神秘领域、复制反乌托邦未来和编织阴谋网，你只需要更改代码中的地图部分。尝试构建你自己的位置，通过出口将它们连接起来，并填充有趣的文物。
- en: To get you started, there’s a brief adventure you can explore and extend on
    JS Bin, at [http://jsbin.com/yadabo/edit?console](http://jsbin.com/yadabo/edit?console).
    You may need to click Run to start the game. It’s set on a small space-freighter
    called *The Sparrow*. There are six items to collect, not including your blaster.
    Once you’ve collected all of the items, open up the JavaScript panel and try adding
    a few more locations. Happy hunting!
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始，有一个简短的冒险可以探索和扩展在 JS Bin 上，网址为 [http://jsbin.com/yadabo/edit?console](http://jsbin.com/yadabo/edit?console)。你可能需要点击运行来启动游戏。它设置在一个名为
    *The Sparrow* 的小型太空货船上。有六个物品可以收集，不包括你的激光枪。收集完所有物品后，打开 JavaScript 面板并尝试添加更多位置。祝您狩猎愉快！
- en: 10.4\. What’s next?
  id: totrans-1668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 接下来是什么？
- en: 'While it’s great to have a working game, the code for *The Crypt* isn’t very
    robust. A player can easily break it, by trying to go in a nonexistent direction,
    for example. They can also access all the game objects at the console—it’s easy
    to award themselves extra treasure or teleport to a new location:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个工作良好的游戏很棒，但 *The Crypt* 的代码并不非常健壮。玩家可以很容易地通过尝试进入一个不存在的方向等方式来破坏它。他们还可以在控制台中访问所有游戏对象——很容易给自己额外的宝藏或传送到新的位置：
- en: '[PRE297]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: And the game could certainly do with more challenge. There should be puzzles
    that can be overcome only with certain items.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏当然需要更多的挑战。应该有一些只有使用特定物品才能克服的谜题。
- en: In [part 2](kindle_split_019.html#part02) of *Get Programming with JavaScript*,
    you’ll address those issues by splitting your code into modules, preventing access
    to objects, setting conditions for when code runs, and separating data from the
    display of data. Such organization will help you design and manage programs as
    they get larger and more complicated and set you up nicely for working with web
    pages in [part 3](kindle_split_026.html#part03).
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Get Programming with JavaScript* 的 [第2部分](kindle_split_019.html#part02) 中，你将通过将代码拆分为模块、防止访问对象、设置代码运行的条件以及将数据与数据的显示分离来解决这些问题。这种组织将帮助你设计和管理更大、更复杂的程序，并为在
    [第3部分](kindle_split_026.html#part03) 中与网页一起工作做好准备。
- en: 10.5\. Summary
  id: totrans-1673
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5. 摘要
- en: 'Use a string between square brackets to specify property names:'
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方括号中的字符串来指定属性名：
- en: '[PRE298]'
  id: totrans-1675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'In particular, use square brackets when the property names include spaces or
    other characters not allowed with dot notation:'
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是，当属性名包含空格或其他不允许使用点表示法的字符时，使用方括号：
- en: '[PRE299]'
  id: totrans-1677
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'Use function parameters to dynamically assign property names when the function
    is called:'
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数参数在调用函数时动态分配属性名：
- en: '[PRE300]'
  id: totrans-1679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'Pass an object as an argument to the `Object.keys` method to create an array
    of the object’s keys:'
  id: totrans-1680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象作为参数传递给 `Object.keys` 方法以创建对象的键数组：
- en: '[PRE301]'
  id: totrans-1681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Break a string into an array with the `split` method. Pass as an argument the
    string used to determine where to make the breaks:'
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `split` 方法将字符串拆分成数组。将用作确定拆分位置的字符串作为参数传递：
- en: '[PRE302]'
  id: totrans-1683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
