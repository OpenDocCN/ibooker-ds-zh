- en: 7 Using functions beyond the basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 超越基础的函数使用
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using lambda functions for a small job
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda函数处理小任务
- en: Working with higher-order functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: Creating and using decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用装饰器
- en: Using generators to obtain data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生成器获取数据
- en: Creating partial functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部分函数
- en: You may have realized that in every project, the greatest amount of time that
    you spend in development is devoted to writing functions. In chapter 6, we focused
    on the fundamentals of writing and using functions. After covering these topics,
    you’re able to write user-friendly functions to serve your work needs. Python
    knows the integral role of functions in any project; thus, it has advanced features
    that you can take advantage of to make functions serve your work better.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，在每一个项目中，你花费在开发上的最大时间都用于编写函数。在第6章中，我们专注于编写和使用函数的基础知识。在覆盖了这些主题之后，你将能够编写用户友好的函数来满足你的工作需求。Python知道函数在任何一个项目中的重要作用；因此，它有你可以利用的先进功能，以使函数更好地服务于你的工作。
- en: In this chapter, you’ll learn about more-advanced function topics. You’ll find
    that the pertinent concepts may sound advanced, but the pragmatic techniques are
    not hard to apply to your daily coding work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解更高级的函数主题。你会发现相关概念可能听起来很高级，但实用技术并不难应用到你的日常编码工作中。
- en: 7.1 How do I use lambda functions for small jobs?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 我如何使用lambda函数处理小任务？
- en: When we define functions, we use the def keyword and then give the name to the
    function, which serves as the identifier for the function. Although the terminology
    isn’t common, we can refer to these functions as *named functions* because they
    have associated identifiers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义函数时，我们使用def关键字，然后给函数命名，这个名称作为函数的标识符。尽管这个术语并不常见，但我们可以将这些函数称为*命名函数*，因为它们有相关的标识符。
- en: 'By contrast, you can define another type of function without specifying names
    in Python. These functions are called *anonymous functions**.* More formally,
    these functions are known as *lambda functions.* When we discussed advanced sorting
    with custom functions (section 3.2), we used an example involving setting a lambda
    function to the key parameter in the sort method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在Python中，你可以定义另一种类型的函数，而不需要指定名称。这些函数被称为*匿名函数**.* 更正式地说，这些函数被称为*lambda函数.*
    当我们讨论使用自定义函数的高级排序（第3.2节）时，我们使用了一个将lambda函数设置为排序方法中的键参数的例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this section, you’ll learn everything you need to know about using lambda
    functions: the components and the best practices.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解使用lambda函数所需的一切：组成部分和最佳实践。
- en: Trivia Calling anonymous functions *lambda functions* or *expressions* exists
    not only in Python, but also in many other languages, such as Java. This name
    is derived from the lambda calculus in mathematics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 将匿名函数称为*lambda函数*或*表达式*不仅存在于Python中，还存在于许多其他语言中，如Java。这个名字来源于数学中的lambda演算。
- en: 7.1.1 Creating a lambda function
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 创建lambda函数
- en: You may have seen some examples of lambdas but haven’t formally learned about
    creating them. First, let’s review the key elements that constitute a lambda function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了一些lambda函数的例子，但还没有正式学习如何创建它们。首先，让我们回顾一下构成lambda函数的关键元素。
- en: Creating lambdas doesn’t involve using the def keyword and supplying an identifier,
    as we do for a regular function. Instead, we use the lambda keyword to signal
    that we’re creating a lambda function. Figure 7.1 shows the components of a lambda
    function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建lambda函数不需要使用def关键字和提供标识符，就像我们为常规函数所做的那样。相反，我们使用lambda关键字来表示我们正在创建一个lambda函数。图7.1显示了lambda函数的组成部分。
- en: '![CH07_F01_Cui](../Images/CH07_F01_Cui.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Cui](../Images/CH07_F01_Cui.png)'
- en: 'Figure 7.1 Creating a lambda function that consists of three components: the
    lambda keyword, the arguments, and the expression'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 创建由三个部分组成的lambda函数：lambda关键字、参数和表达式
- en: As shown in figure 7.1, after the lambda keyword, we provide the arguments and
    a single expression that uses the arguments to produce a value. Don’t forget that
    you need to append a colon to the arguments. Please note that you can use zero
    for multiple arguments in a lambda function. When the lambda function contains
    no arguments, the colon is still required before you specify the expression.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.1所示，在lambda关键字之后，我们提供参数和一个使用参数产生值的单个表达式。别忘了你需要在参数后添加一个冒号。请注意，在lambda函数中，你可以使用零个参数。当lambda函数没有参数时，在指定表达式之前仍然需要冒号。
- en: Concept *Keywords* are special words reserved by Python for performing predefined
    operations, such as def for creating a function, class for creating a class, and
    lambda for creating a lambda function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 概念：*关键字*是Python为执行预定义操作而保留的特殊单词，例如def用于创建函数，class用于创建类，以及lambda用于创建lambda函数。
- en: 'Unlike regular functions, which may return an object, lambda functions don’t
    return anything. When they do, you get a syntax error:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数不同，常规函数可能返回一个对象，而lambda函数不返回任何内容。当它们返回时，你会得到一个语法错误：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The SyntaxError is expected because lambdas use expressions as opposed to statements,
    and return x * 2 is a kind of statement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SyntaxError是预期的，因为lambda使用表达式而不是语句，而return x * 2是一种语句。
- en: Reminder An expression evaluates to a single value or an object, whereas a statement
    performs a specific action without evaluating to any object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：表达式计算出一个单一值或对象，而语句执行一个特定的动作，但不计算为任何对象。
- en: 'Now we know how to create a lambda function, and it’s time to give it a try:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建一个lambda函数，是时候尝试一下了：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This lambda function multiplies a number by 2\. For demonstration purposes,
    we assign the lambda function to a variable doubler, which allows us to inspect
    a lambda function in greater detail. As you’ll see in the next section, however,
    it’s not good practice to assign a lambda function to a variable. When you inspect
    the lambda function’s type, you’ll see that it is indeed a kind of function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda函数将一个数字乘以2。为了演示目的，我们将lambda函数赋值给变量doubler，这使我们能够更详细地检查lambda函数。然而，如你将在下一节中看到的，将lambda函数赋值给变量并不是一个好的做法。当你检查lambda函数的类型时，你会发现它确实是一种函数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lambda functions are functions at their core, so we can call them as regular
    functions. When you call a lambda function, you send the needed arguments as you
    normally do with a regular function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数在本质上就是函数，因此我们可以像常规函数一样调用它们。当你调用一个lambda函数时，你发送所需的参数，就像你通常使用常规函数一样：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 7.1.2 Using lambdas to perform a small one-time job
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 使用lambda函数执行一次性的小任务
- en: In section 7.1.1, I mentioned that you shouldn’t assign a lambda function to
    a variable. The major reason is that a lambda function is supposed to perform
    a small job, and it’s used a single time. In this section, I discuss what I mean
    by *a small job.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在7.1.1节中，我提到你不应该将lambda函数赋值给变量。主要原因是一个lambda函数应该执行一个小任务，并且只使用一次。在本节中，我将讨论我所说的“小任务”是什么意思。
- en: You may wonder what kind of use case a small job is. If you recall, you learned
    to perform more complicated sorting with a custom function (listing 3.3) in section
    3.2.1\. For your quick reference, the code is shown in the next listing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道小任务有什么样的用例。如果你回忆一下，你在3.2.1节中学习了如何使用自定义函数（列表3.3）进行更复杂的排序。为了快速参考，代码将在下一个列表中展示。
- en: Listing 7.1 Sorting a list with a custom function
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 使用自定义函数排序列表
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We define the using_urgency_level function and set it to the key argument in
    the sort method call. Notably, this using_urgency_level function performs a small
    job to get a dict object’s value. Moreover, this function is used only once as
    the key argument in the sort method. By using the single-use lambda function part
    of calling sort as the key argument, you’re not creating extra “noise” (the explicitly
    defined function), making your code cleaner. Thus, this example is a perfect scenario
    for the use of a lambda function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义using_urgency_level函数，并将其设置为sort方法调用中的key参数。值得注意的是，这个using_urgency_level函数执行一个小任务来获取字典对象的价值。此外，这个函数只作为sort方法中的key参数使用一次。通过将单次使用的lambda函数部分作为key参数调用sort，你不会创建额外的“噪音”（显式定义的函数），使你的代码更简洁。因此，这是一个使用lambda函数的完美场景：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This lambda function takes one parameter, which stands for each dict object
    of the list object, as in the using_urgency_level function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda函数接受一个参数，代表列表对象中的每个字典对象，就像在using_urgency_level函数中一样。
- en: Reminder Calling both regular and lambda functions is an expression, taking
    input and generating output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：调用常规函数和lambda函数都是表达式，接受输入并生成输出。
- en: 7.1.3 Avoiding pitfalls when using lambda functions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 使用lambda函数时避免陷阱
- en: After you learn about lambda functions, you may think that they’re cool advanced
    features for a variety of reasons. The name—lambda!—is cool. A lambda function
    is concise—one line of code. Also, many Python beginners don’t know lambda functions
    well, and they think that if they use this advanced feature, they’re no longer
    beginners. If you have any of these thoughts, chances are that you’ll run into
    one of the following pitfalls.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习lambda函数之后，你可能会认为它们是各种原因下的酷炫高级特性。名字——lambda！——很酷。lambda函数简洁——一行代码。此外，许多Python初学者对lambda函数了解不深，他们认为如果使用这个高级特性，他们就不再是初学者了。如果你有任何这些想法，那么你可能会遇到以下陷阱之一。
- en: Assigning a lambda to a variable
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将lambda赋值给变量
- en: 'I have mentioned a couple of times that we don’t assign a lambda function to
    a variable. Our reasoning (implied in the preceding section) is that we use a
    lambda function only once. From a readability perspective, however, it appears
    to be good practice to assign a lambda function to a variable so that we can name
    the variable sensibly and tell readers more about the lambda function. Consider
    the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到过几次，我们不会将lambda函数赋值给变量。我们的理由（在上一个部分中暗示）是，我们只使用一次lambda函数。然而，从可读性的角度来看，将lambda函数赋值给变量似乎是一个好的实践，这样我们可以合理地命名变量，并让读者更多地了解lambda函数。考虑以下示例：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we use using_urgency_level to refer to the lambda function,
    and it does give us some information about the sorting algorithm. The more important
    reason to avoid assigning a lambda function to a variable, however, is that debugging
    is harder if the function goes wrong, as the next listing shows.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用using_urgency_level来指代lambda函数，并且它确实给我们提供了一些关于排序算法的信息。然而，避免将lambda函数赋值给变量的更重要原因是，如果函数出错，调试会更困难，正如下面的列表所示。
- en: Listing 7.2 KeyError with a lambda function
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2：使用lambda函数时的KeyError
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For a direct comparison, apply the same error (using a wrong key to access the
    value) to a named function. The following listing shows what happens.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直接比较，将相同的错误（使用错误的键访问值）应用于命名函数。以下列表显示了会发生什么。
- en: Listing 7.3 KeyError with a named function
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3：使用命名函数时的KeyError
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Between listings 7.2 and 7.3, I’ve highlighted the most significant difference,
    although both code snippets show the same KeyError. When we use a named function,
    the error message clearly shows where things went wrong: in the using_urgency_level1
    function. By contrast, when we use a lambda function that uses a wrong key, the
    error message tells us only that something is wrong with a <lambda> function.
    Such an error message is unclear about where you can fix the problem, particularly
    if you’re using a lambda function defined elsewhere.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.2和7.3之间，我突出显示了最显著的区别，尽管两个代码片段都显示了相同的KeyError。当我们使用命名函数时，错误信息清楚地显示了问题所在：在using_urgency_level1函数中。相比之下，当我们使用使用错误键的lambda函数时，错误信息只告诉我们<lambda>函数有问题。这样的错误信息不清楚你可以在哪里修复问题，尤其是如果你使用的是在其他地方定义的lambda函数。
- en: Maintainability Don’t assign a lambda function to a variable; the code will
    be hard to debug if things go wrong.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性：不要将lambda函数赋值给变量；如果出现问题，代码将难以调试。
- en: Using better alternatives
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更好的替代方案
- en: We understand that lambda functions are intended to perform a small job. A common
    use scenario is to set a lambda function as the key parameter in functions, such
    as sort, sorted, and max. In some situations, however, better alternatives exist.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解lambda函数的目的是执行一个小任务。一个常见的使用场景是将lambda函数设置为函数的键参数，例如sort、sorted和max。然而，在某些情况下，存在更好的替代方案。
- en: 'Suppose that we have a list of numbers, and we want to create a new list object
    that has these numbers ordered based on their absolute values. You might come
    up with the following solution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数字列表，我们想要创建一个新的列表对象，该对象根据这些数字的绝对值进行排序。你可能会有以下解决方案：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the lambda function, we use the built-in abs function, which calculates
    the absolute value of the item. A more Pythonic solution is to use the abs function
    directly as the key parameter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda函数中，我们使用内置的abs函数，该函数计算项的绝对值。一个更Pythonic的解决方案是直接将abs函数用作键参数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For another example, suppose that we have a list of tuples, with each tuple
    recording a student’s scores in math, science, and art, and we want to find out
    what tuple object has the highest total score. Consider the following solution:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个例子，假设我们有一个包含元组的列表，每个元组记录一个学生在数学、科学和艺术中的分数，我们想要找出哪个元组对象的总分最高。考虑以下解决方案：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this lambda function, we use indexing to retrieve each of the three scores
    and add them to obtain the total score. But we know that the built-in sum function
    can take any iterable to generate the sum for its items. Thus, we should take
    advantage of the sum function directly. As a side note, you can call max(scores)
    to produce the same result. Here, I’m including key=sum to be explicit regarding
    how the maximal item should be selected:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个lambda函数中，我们使用索引来检索三个分数中的每一个，并将它们相加得到总分。但我们知道内置的sum函数可以接受任何可迭代对象来生成其项的总和。因此，我们应该直接利用sum函数。作为旁注，你可以调用max(scores)来得到相同的结果。在这里，我包括key=sum来明确说明如何选择最大项：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Readability Prefer using built-in functions or applicable alternatives, which
    are generally more concise, to creating lambda functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性：优先使用内置函数或适用的替代方案，这些通常更简洁，而不是创建lambda函数。
- en: 7.1.4 Discussion
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 讨论
- en: Lambda functions should perform only a small job for one-time use, such as serving
    the key argument in built-in functions such as sorted, max, and min. Notably,
    lambda functions are widely used in third-party libraries, such as pandas, a popular
    data science library. In pandas, for example, we can use the apply function to
    create new data from the existing DataFrame. The apply function takes a key parameter,
    which specifies how you create the new data from existing data. Thus, lambda functions
    are a universal technique that you can use to specify a small job in terms of
    data extraction or conversion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数应该只执行一个小任务，用于一次性使用，例如在sorted、max和min等内置函数中作为key参数。值得注意的是，lambda函数在第三方库中得到了广泛的应用，例如pandas，一个流行的数据科学库。例如，在pandas中，我们可以使用apply函数从现有的DataFrame创建新的数据。apply函数接受一个key参数，它指定了如何从现有数据创建新数据。因此，lambda函数是一种通用的技术，你可以用它来指定数据提取或转换中的小任务。
- en: 7.1.5 Challenge
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 挑战
- en: High-school student Linda is learning Python to batch-process her pictures and
    video files. She knows that Python functions have a special attribute called __name__.
    She tried to access this attribute for a lambda function and a named function.
    What do you think the values should be?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 高中生琳达正在学习Python来批量处理她的图片和视频文件。她知道Python函数有一个特殊的属性叫做__name__。她尝试访问lambda函数和命名函数的这个属性。你认为这些值应该是什么？
- en: Hint Go back to listings 7.2 and 7.3 to see what the error message says about
    the named function and the lambda function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：回到7.2和7.3列表中，看看错误信息对命名函数和lambda函数说了什么。
- en: 7.2 What are the implications of functions as objects?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 函数作为对象的意义是什么？
- en: 'We know that Python is an object-oriented programming (OOP) language at its
    core. From a general perspective, when we talk about objects, we’re usually referring
    to an object as an entity that represents specific data. In the first five chapters,
    we focused on a variety of topics related to data models, such as str, list, tuple,
    dict, and set. These classes and their respective instances are examples of objects.
    An essential implication of being an object is that we can manipulate the represented
    data by sending it to a function. The following code snippet shows that we can
    use int and str instance objects in functions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Python在核心上是面向对象编程（OOP）语言。从一般的角度来看，当我们谈论对象时，我们通常是指一个代表特定数据的实体。在前五章中，我们关注了与数据模型相关的各种主题，如str、list、tuple、dict和set。这些类及其各自的实例是对象的例子。作为对象的一个重要含义是，我们可以通过将其发送到函数来操作代表的数据。以下代码片段显示我们可以使用int和str实例对象在函数中：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Uses an int object in a function
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在函数中使用int对象
- en: ❷ Uses a str object in a function
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在函数中使用str对象
- en: 'Notably, in the preceding section, we mentioned that we could pass a named
    or lambda function to the sort method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，在上一节中，我们提到我们可以将一个命名函数或lambda函数传递给sort方法：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Being able to set a function as an argument seems to imply that lambda functions,
    or functions in general, represent some data, like other data models such as int
    and str. If you go a step further, you may wonder whether functions are also objects.
    Indeed, there is a saying that everything is an object in Python: *Python treats
    functions like objects too.* In this section, I’ll cover the most significant
    implications of functions being objects and present some practical use cases.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将函数作为参数设置似乎意味着lambda函数，或者函数一般，代表了一些数据，就像其他数据模型如int和str一样。如果你再进一步思考，可能会想知道函数是否也是对象。确实，有句话是“在Python中，一切都是对象”：*Python也将函数视为对象*。在本节中，我将介绍函数作为对象的最重要含义，并展示一些实际的应用案例。
- en: 7.2.1 Storing functions in a data container
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 在数据容器中存储函数
- en: 'We know that basic data models can be interwoven to create enormous possibilities.
    Particularly, we can use data containers to store almost any kind of data model.
    You can have a list of int, str, dict, and set. In a dict, you can store int,
    str, list, and dict as its values. In this section, you’ll learn about the first
    implication of functions as objects: using functions with other data models. Specifically,
    we’ll see how we can take advantage of storing functions in a data container.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道基本数据模型可以交织在一起，创造出巨大的可能性。特别是，我们可以使用数据容器来存储几乎任何类型的数据模型。你可以有一个包含 int、str、dict
    和 set 的列表。在一个字典中，你可以将 int、str、list 和 dict 作为其值存储。在本节中，你将了解函数作为对象的第一个含义：与其他数据模型一起使用函数。具体来说，我们将看到我们如何利用在数据容器中存储函数的优势。
- en: 'Suppose that we have an application programming interface (API) that allows
    users to send a list of numbers and specify the needed action for the data. For
    simplicity, let’s say the action is to calculate the mean, min, or max. The API
    function looks like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序编程接口（API），允许用户发送一个数字列表并指定所需的数据操作。为了简单起见，让我们说操作是计算平均值、最小值或最大值。API
    函数看起来像这样：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code snippet, get_mean, get_min, and get_max represent the functions
    that perform the respective calculations. As you may notice, the process_data’s
    body is rather cumbersome. Instead, if we save functions as values in a dict object,
    we’ll have a better solution, as shown in the following listing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，get_mean、get_min 和 get_max 代表执行相应计算的函数。正如你可能注意到的，process_data 的主体相当繁琐。相反，如果我们将函数作为字典对象中的值保存，我们将有一个更好的解决方案，如下面的列表所示。
- en: Listing 7.4 Saving functions in a dict object
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 在字典对象中保存函数
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The fallback function is called when none of the defined actions are used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当未使用定义的任何操作时，将调用后备函数。
- en: In listing 7.4, we have the actions dict, which saves all the needed actions.
    When the user specifies an action, we can look up the dict object to locate the
    needed function. By doing so, we eliminate the use of multiple branches of the
    if...elif...else... statement. If you have more actions, you can improve readability
    significantly by saving functions in a dict object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.4 中，我们有 actions 字典，它保存了所有需要的操作。当用户指定一个操作时，我们可以查找字典对象以定位所需的函数。通过这样做，我们消除了使用
    if...elif...else... 语句的多个分支。如果你有更多操作，通过在字典对象中保存函数，你可以显著提高可读性。
- en: Readability Code is less readable if you have a complicated structure for an
    if...elif...else... statement. Consider other alternatives whenever possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有复杂的 if...elif...else... 语句结构，可读性代码的可读性较低。尽可能考虑其他替代方案。
- en: 7.2.2 Sending functions as arguments to higher-order functions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 将函数作为参数传递给高阶函数
- en: The second implication of using functions as objects is that we can use functions
    as arguments when we call other functions. When functions can accept other functions
    as input (arguments) or return a function as output, we refer to these functions
    as *higher-order functions*—functions on top of other functions. In this section,
    we’ll focus on one notable higher-order function, map, to illustrate how to send
    a function as data (argument) to another function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数作为对象时的第二个含义是，当我们调用其他函数时，我们可以将函数作为参数使用。当函数可以接受其他函数作为输入（参数）或返回一个函数作为输出时，我们称这些函数为
    *高阶函数*——在函数之上的函数。在本节中，我们将重点关注一个著名的高阶函数 map，以说明如何将一个函数作为数据（参数）传递给另一个函数。
- en: Higher-order functions
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数
- en: '*Higher-order functions* take functions as arguments or return functions as
    output, as shown in the following figure. Please note that if a function takes
    one or more functions as parameters, it’s a higher-order function, and if a function
    returns a function as its output, it’s a higher-order function too. If a function
    does both things, it’s certainly a higher-order function.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶函数*接受函数作为参数或返回函数作为输出，如下面的图所示。请注意，如果一个函数接受一个或多个函数作为参数，它就是一个高阶函数，如果一个函数返回一个函数作为其输出，它也是一个高阶函数。如果一个函数同时做这两件事，它肯定是一个高阶函数。'
- en: '![CH07_F01_UN01_Cui](../Images/CH07_F01_UN01_Cui.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_UN01_Cui](../Images/CH07_F01_UN01_Cui.png)'
- en: Higher-order functions use functions as arguments and/or return functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数使用函数作为参数和/或返回函数。
- en: '*First-order functions* are the opposite of higher-order functions. Notably,
    the concept of higher-order functions is prevalent in many modern languages, such
    as JavaScript, Kotlin, and Swift. Knowing this concept can benefit you if you
    ever need to use other languages.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*一阶函数*是高阶函数的对立面。值得注意的是，高阶函数的概念在许多现代语言中都很普遍，如JavaScript、Kotlin和Swift。如果你需要使用其他语言，了解这个概念会对你有所帮助。'
- en: 'In section 5.1, I briefly mentioned the map function, which has the calling
    signature map(func, iterable), in which func is a function object, often called
    the mapping function. The map function creates a map iterator, and I’ve shown
    you how to construct a list object from the map iterator, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5.1节中，我简要提到了map函数，其调用签名是map(func, iterable)，其中func是一个函数对象，通常称为映射函数。map函数创建一个map迭代器，我已经向你展示了如何从map迭代器构建列表对象，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Trivia The map function can take more than one iterable. When there are multiple
    iterables, the items from each iterable are sent to the mapping function based
    on the order of the iterables. The most common use case of the map function deals
    with one iterable, so it can be confusing for some beginners if you use multiple
    iterables in map. Use this feature with caution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点：map函数可以接受多个可迭代对象。当有多个可迭代对象时，每个可迭代对象的项目将根据可迭代对象的顺序发送到映射函数。map函数最常见的使用案例是处理一个可迭代对象，所以如果你在map中使用多个可迭代对象，对于一些初学者来说可能会有些困惑。谨慎使用此功能。
- en: 'Notably, from the perspective of writing Pythonic code, if you’re trying to
    create a list object from the map iterator, it’s best to use the list comprehension
    technique instead:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，从编写Python代码的角度来看，如果你试图从map迭代器创建列表对象，最好使用列表推导式技术：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using a higher-order function, however, represents the functional coding style
    (formally known as functional programming), as opposed to the more prevalent OOP
    style in Python. In the functional coding style, we focus on applying and composing
    functions. By contrast, in the OOP style, we focus on working with a variety of
    objects. Because of list comprehension and generator expression (section 7.4),
    you can replace most map-related usages with these two techniques, which are respected
    as being more Pythonic. Because the map object can be an iterator, a valid use
    case is to implement it in a for loop when the involved operations are complicated:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶函数，然而，代表了函数式编程风格（正式称为函数式编程），与在Python中更为普遍的面向对象编程风格相对。在函数式编程风格中，我们专注于应用和组合函数。相比之下，在面向对象编程风格中，我们专注于与各种对象一起工作。由于列表推导式和生成器表达式（第7.4节），你可以用这两种技术替换大多数与map相关的用法，这些技术被认为更符合Python风格。因为map对象可以是一个迭代器，一个有效的用例是在涉及的操作复杂时，在for循环中实现它：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the for loop includes multiple operations that don’t fit into
    a list comprehension. In this case, you should take advantage of the map iterator,
    which renders its items one by one without the need for you to construct a list
    object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，for循环包含了多个不适合放入列表推导式中的操作。在这种情况下，你应该利用map迭代器，它逐个渲染其项目，而无需你构建列表对象。
- en: 7.2.3 Using functions as a return value
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 使用函数作为返回值
- en: In the preceding section, we focused on how to use functions as objects by sending
    them as parameters to higher-order functions, such as map. In this section, we’ll
    focus on the third implication of using functions as objects. Specifically, I’ll
    show you how to create a higher-order function that returns a function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们关注了如何通过将它们作为参数传递给高阶函数（如map）来使用函数作为对象。在本节中，我们将关注使用函数作为对象的第三个含义。具体来说，我将向你展示如何创建一个返回函数的高阶函数。
- en: 'We use def to signify that we’re creating a function. You may not know that
    we can embed the definition of a function inside another function, following this
    general format:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用def来表示我们正在创建一个函数。你可能不知道我们可以在另一个函数内部嵌入函数的定义，遵循以下一般格式：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reminder We use the pass statement to satisfy the syntactic requirements where
    statements are expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们使用pass语句来满足期望语句的语法要求。
- en: Suppose that we want to create a higher-order function. With this new function,
    we can create incrementing functions that add a predefined number. Applying the
    preceding syntax, we can come up with the solution shown in the next listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个高阶函数。使用这个新函数，我们可以创建增加预定义数字的递增函数。应用前面的语法，我们可以得出以下列表中的解决方案。
- en: Listing 7.5 Creating a function that returns a function
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 创建一个返回函数的函数
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Readability Add a blank line between the inner function and the outer function’s
    return statement to improve readability. As a general rule, spaces and empty lines
    are natural separators between different logical components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 在内部函数和外部函数的返回语句之间添加一个空行以提高可读性。作为一般规则，空格和空行是不同逻辑组件之间的自然分隔符。
- en: As shown in listing 7.5, the outside function, known as the *outer function,*
    takes the number parameter. Within the increment_maker function, we define an
    *inner function:* the increment function, which takes another number (the num0
    parameter). Unlike first-order functions, which return None or some form of data,
    the higher-order function increment_maker returns the increment function as its
    output. Now we can see how useful this higher-order function is because it allows
    us to create a series of incrementing functions, as shown in the next listing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 7.5 所示，外部函数，称为**外部函数**，接受一个数字参数。在 increment_maker 函数内部，我们定义了一个**内部函数**：增量函数，它接受另一个数字（num0
    参数）。与返回 None 或某种形式数据的首次函数不同，高阶函数 increment_maker 返回增量函数作为其输出。现在我们可以看到这个高阶函数是多么有用，因为它允许我们创建一系列的增量函数，如下一个列表所示。
- en: Listing 7.6 Creating functions by calling a higher-order function
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 通过调用高阶函数创建函数
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As shown in listing 7.6, we can create multiple functions conveniently by specifying
    the desired incrementing values. When we call these functions, we obtain expected
    results.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 7.6 所示，我们可以通过指定所需的增量值方便地创建多个函数。当我们调用这些函数时，我们会得到预期的结果。
- en: 7.2.4 Discussion
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4 讨论
- en: As an OOP language, Python gives us additional flexibility to use functions
    by treating them as regular objects. You may wonder whether the example shown
    in listing 7.5 and 7.6 is too trivial to be practical, and I absolutely agree.
    Here, I’m using this simple example to provide a proof of concept. In section
    7.3, I’ll talk about using decorators, a practical technique built on creating
    a higher-order function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为面向对象的语言，Python 允许我们通过将函数视为常规对象来使用它们，从而提供了额外的灵活性。您可能会想知道列表 7.5 和 7.6 中所示的示例是否过于简单而不实用，我完全同意。在这里，我使用这个简单的示例来提供一个概念证明。在
    7.3 节中，我将讨论使用装饰器，这是一种基于创建高阶函数的实用技术。
- en: 7.2.5 Challenge
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5 挑战
- en: In listing 7.4, we saved functions in a dict object. Besides these functions,
    do you understand the rationale for creating the fallback_action function? On
    a related note, why do we use the get method instead of subscript notation?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.4 中，我们将函数保存在字典对象中。除了这些函数之外，您是否理解创建 fallback_action 函数的理由？相关地，为什么我们使用 get
    方法而不是下标表示法？
- en: Hint You can never predict how users will call a function that you define. How
    do you handle a possible call like process_data([1, 2, 3], "maxx")?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 您永远无法预测用户将如何调用您定义的函数。您如何处理 process_data([1, 2, 3], "maxx") 这样的可能调用？
- en: 7.3 How do I check functions’ performance with decorators?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 我该如何使用装饰器检查函数的性能？
- en: Functions are integral components of any application. Your application’s performance,
    particularly its responsiveness, depends largely on how fast your functions can
    process the data. Thus, during development, we often want to record the speed
    of our functions. Using a naïve approach, we may create the solution shown in
    the next listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何应用程序的基本组成部分。您应用程序的性能，尤其是其响应性，在很大程度上取决于您的函数处理数据的速度有多快。因此，在开发过程中，我们通常希望记录函数的运行速度。使用一种简单的方法，我们可能会创建如下列表中所示解决方案。
- en: Listing 7.7 Recording a function’s performance
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 记录函数的性能
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Injects a random delay (0.1-0.5 second) to mimic actual operations
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个随机延迟（0.1-0.5 秒）来模拟实际操作
- en: ❷ Injects a random delay (0.6-1 second) to mimic actual operations
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个随机延迟（0.6-1 秒）来模拟实际操作
- en: 'In listing 7.7, we calculate the time difference between when the function
    starts running and when it ends so that we know how long it takes. When this function
    is called, we can observe its performance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.7 中，我们计算函数开始运行和结束时的时间差，以便我们知道它需要多长时间。当这个函数被调用时，我们可以观察其性能：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Readability It’s a good idea to have some patterned prefix if you expect many
    lines of output that have similar words. These prefixes serve as distinct visual
    cues.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 如果您预计会有许多具有相似单词的输出行，那么有一个有规律的缩进前缀是个好主意。这些前缀作为独特的视觉提示。
- en: 'You won’t have only one or two functions in your application that you need
    to observe. Chances are that you’ll need to monitor the performance of tens or
    hundreds of functions. It could be tedious to add the pertinent lines of code
    in listing 7.7 (highlighted in bold) to all these functions. If you recall the
    DRY (Don’t Repeat Yourself) principle, if there are significant repetitions, it’s
    almost guaranteed that we’ll need to refactor our code. In this section, I’ll
    show you how to use decorators to solve this kind of problem: applying a shared
    action to multiple functions.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你不会只有一个或两个需要观察的函数。很可能你需要监控数十个或数百个函数的性能。将7.7列表（粗体突出显示）中的相关代码行添加到所有这些函数中可能会很繁琐。如果你还记得DRY（不要重复自己）原则，如果有显著的重复，我们几乎可以肯定需要重构我们的代码。在本节中，我将向你展示如何使用装饰器来解决这类问题：将共享操作应用于多个函数。
- en: 7.3.1 Decorating a function to show its performance
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 装饰函数以显示其性能
- en: I’ve mentioned decorators a few times, but you may not know what this term means.
    *Decorators* are functions that provide additional functionalities to the decorated
    functions. It’s important to note that decorators don’t change the way the decorated
    functions work; thus, we call this process *decoration.* In this section, we’ll
    build a decorator to track a function’s performance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到过装饰器几次，但你可能不知道这个术语的含义。"装饰器"是提供额外功能给被装饰函数的函数。需要注意的是，装饰器不会改变被装饰函数的工作方式；因此，我们称这个过程为“装饰”。在本节中，我们将构建一个装饰器来跟踪函数的性能。
- en: Without introducing the mechanisms, I’ll show you some code before I explain
    how things work. For now, you can skim the logging_time function and start to
    read the code from the line @logging_time in the next listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍机制之前，我会先展示一些代码，然后再解释事情是如何工作的。现在，你可以快速浏览一下logging_time函数，并从下一列表中的@logging_time行开始阅读代码。
- en: Listing 7.8 Using a performance-logging decorator
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 使用性能日志装饰器
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see in listing 7.8, when we call the example_func2 function, we get
    the output showing its performance. No code does such a thing in the body of example_
    func2, however. So what makes example_func2 output its performance data?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表7.8所示，当我们调用example_func2函数时，我们得到显示其性能的输出。然而，example_func2的主体中并没有代码做这样的事情。那么是什么让example_func2输出其性能数据呢？
- en: 'The magic results from the @logging_time right above example_func2’s head.
    This special syntax is about decoration; it means that the function defined below
    will be decorated by the decorator function logging_time. We can apply this decorator
    function to as many functions as we like, as in this example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在example_func2上方使用@logging_time产生的魔法效果。这种特殊语法与装饰有关；这意味着下面定义的函数将被装饰器函数logging_time装饰。我们可以将这个装饰器函数应用于我们喜欢的任何函数，就像这个例子一样：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Maintainability Decorators extract the shared utility functionalities that can
    be used by multiple functions. You need to maintain only the decorator functions,
    not all individual decorated functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性装饰器提取出可以被多个函数使用的共享实用功能。你只需要维护装饰器函数，而不是所有被装饰的函数。
- en: We’ve seen that we can apply the decorator function to multiple functions to
    perform the shared functionalities. But we haven’t discussed what constitutes
    a decorator, which is the topic of the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以将装饰器函数应用于多个函数以执行共享功能。但我们还没有讨论构成装饰器的要素，这是下一节的主题。
- en: 7.3.2 Dissecting the decorator function
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 解构装饰器函数
- en: In section 7.2, I mentioned that a decorator is a kind of higher-order function.
    As shown in listing 7.8, the logging_time function is a decorator—a form of closure.
    (See the following sidebar for additional information.) Using this example, we’ll
    dissect the decorator by identifying its key elements in this section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在7.2节中，我提到装饰器是一种高阶函数。如列表7.8所示，logging_time函数是一个装饰器——一种闭包形式。（有关更多信息，请参阅以下侧边栏。）通过这个例子，我们将在本节中通过识别其关键元素来解构装饰器。
- en: 'Behind decorators: Closures'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器背后的：闭包
- en: Decorators are a form of closure. From a broad perspective, closures represent
    an advanced programming concept in many modern languages, including Kotlin, Swift,
    and certainly Python. A closure is an inner function that is created and returned
    from the outer function. Moreover, it requires the inner function to use the variable(s)
    in the outer function’s scope, a technique called nonlocal variable binding*.*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种闭包形式。从广义上讲，闭包在许多现代语言中代表了一种高级编程概念，包括Kotlin、Swift和当然还有Python。闭包是一个在外部函数中创建并返回的内部函数。此外，它要求内部函数使用外部函数作用域中的变量（或变量），这种技术称为非局部变量绑定****。
- en: As you will notice, several new terminologies are involved, including scopes
    and nonlocal variable binding. Explaining this concept fully would require a whole
    section, if not more. Nevertheless, this topic is an important one that can help
    you understand related techniques, particularly decorators. Thus, I’m providing
    a figure to show the essential components of a closure. Please note that you can
    use closures’ applications, such as decorators, without fully understanding closures,
    so don’t worry if the concept doesn’t make sense to you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，涉及了几个新的术语，包括作用域和非局部变量绑定。要完全解释这个概念可能需要整个章节，甚至更多。尽管如此，这个主题是一个重要的主题，可以帮助你理解相关的技术，特别是装饰器。因此，我提供了一个图来展示闭包的基本组成部分。请注意，你可以使用闭包的应用，例如装饰器，而不必完全理解闭包，所以如果你觉得这个概念不太明白，不必担心。
- en: '![CH07_F01_UN02_Cui](../Images/CH07_F01_UN02_Cui.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_UN02_Cui](../Images/CH07_F01_UN02_Cui.png)'
- en: A higher-order function that returns a function as output
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数作为输出的高阶函数
- en: 'In this figure, note three things: In the body of the outer function, we create
    an inner function; the inner function uses parameters that belong to the outer
    function; and the outer function returns the inner function as its output.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，请注意三个要点：在外部函数的主体中，我们创建了一个内部函数；内部函数使用属于外部函数的参数；外部函数将其返回的内部函数作为其输出。
- en: 'When we create a function by calling the outer function, we’re creating a closure.
    If you inspect the closure, you see that it is indeed the inner function created
    in the outer function, and you can call the closure too:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用外部函数创建一个函数时，我们正在创建一个闭包。如果你检查闭包，你会发现它确实是外部函数中创建的内部函数，你也可以调用这个闭包：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are even more ways to inspect the closure on a more in-depth level. We
    can check, for example, what variables the closure binds:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查闭包的更深入的方法还有很多。例如，我们可以检查闭包绑定了哪些变量：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Essential structure: A closure-generating function'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构：生成闭包的函数
- en: 'If we leave out the implementation details of the logging_time function, we
    can have the following backbone structure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略logging_time函数的实现细节，我们可以得到以下基本结构：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you recall, this structure represents a higher-order function, taking a
    function as input and returning a function as output. In essence, a decorator
    processes a function, and we call this process *decoration.* But what’s happening
    to the decoration process behind the scenes? To illustrate the underlying mechanism,
    I’ll show you this code snippet first:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，这个结构代表了一个高阶函数，它接受一个函数作为输入，并返回一个函数作为输出。本质上，装饰器处理一个函数，我们称这个过程为*装饰*。但是，幕后发生了什么？为了说明底层机制，我将首先展示这个代码片段：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It’s interesting to observe that calling the after_deco function results in
    the same performance-related output as that of other previously decorated functions
    using @logging_time. If you go back one step, you see that the after_deco function
    is created by calling the decorator function logging_time and passing in the before_deco
    function. Thus, as you may have figured out, decoration is a process of creating
    a closure by sending an existing function to the decorator. Figure 7.2 shows this
    process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到调用after_deco函数会产生与之前使用@logging_time装饰的其他函数相同的性能相关输出，这很有趣。如果你退一步，你会看到after_deco函数是通过调用装饰器函数logging_time并将before_deco函数传递给它来创建的。因此，正如你可能已经猜到的，装饰是一个通过将现有函数发送到装饰器来创建闭包的过程。图7.2展示了这个过程。
- en: '![CH07_F02_Cui](../Images/CH07_F02_Cui.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Cui](../Images/CH07_F02_Cui.png)'
- en: Figure 7.2 Applying a decorator is the process of creating a closure from the
    decorator function. The decorator function is a higher-order function that takes
    a function (the to-be-decorated function) and returns a function (the decorated
    function, a closure). Please note that we can use the same variable name in an
    assignment statement. The Python interpreter will evaluate the right side first
    and assign the evaluated value to the left side. Because the name is the same,
    the old variable’s value is replaced by the new value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 应用装饰器是创建装饰器函数的闭包的过程。装饰器函数是一个高阶函数，它接受一个函数（待装饰的函数）并返回一个函数（装饰后的函数，一个闭包）。请注意，我们可以在赋值语句中使用相同的变量名。Python解释器会首先评估右侧，并将评估后的值赋给左侧。因为名称相同，旧变量的值会被新值替换。
- en: '*args and **kwargs in the inner function'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数中的 *args 和 **kwargs
- en: 'In section 6.4, you learned the concepts of *args and **kwargs and saw how
    to use them to allow users to pass any number of positional and keyword arguments,
    respectively. The rationale of using *args and **kwargs in the inner function
    is the same: you want the decorator to be compatible with all functions, regardless
    of their calling signatures.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在6.4节中，你学习了 *args 和 **kwargs 的概念，并看到了如何使用它们分别允许用户传递任意数量的位置参数和关键字参数。在内部函数中使用
    *args 和 **kwargs 的理由是相同的：你希望装饰器与所有函数兼容，无论它们的调用签名如何。
- en: 'To illustrate the necessity of using *args and **kwargs, consider a decorator
    that doesn’t use them to see the problem we may run into. For simplicity, the
    decorator monitor reports when a function is called:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用 *args 和 **kwargs 的必要性，考虑一个不使用它们的装饰器，看看我们可能会遇到的问题。为了简单起见，装饰器 monitor 在函数被调用时报告：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we use this decorator for a function that doesn’t take any parameters, everything
    works out fine:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为不带任何参数的函数使用这个装饰器，一切都会顺利：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we use this decorator for a function that takes one or multiple parameters,
    however, we’re running into a TypeError:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们为接受一个或多个参数的函数使用这个装饰器，我们将会遇到一个 TypeError：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The error message tells us where the problem is. In the fourth line of the decorator
    function monitor, we call the decorated function by using func(), which doesn’t
    specify any parameters! But the decorated example1 function expects one positional
    argument. As you can imagine, such incompatibility significantly restricts where
    you can use decorators. Thus, to maximize decorators’ flexibility, it’s essential
    to include *args and **kwargs in the inner function, because the created inner
    function will be the decorated function, and using *args and **kwargs makes the
    inner function compatible with any calling signature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息告诉我们问题所在。在装饰器函数 monitor 的第四行中，我们通过使用 func() 调用装饰后的函数，但没有指定任何参数！但是装饰后的 example1
    函数期望一个位置参数。正如你可以想象的那样，这种不兼容性显著限制了装饰器的使用范围。因此，为了最大限度地提高装饰器的灵活性，在内部函数中包含 *args 和
    **kwargs 是至关重要的，因为创建的内部函数将是装饰后的函数，使用 *args 和 **kwargs 使得内部函数与任何调用签名兼容。
- en: Maintainability Use *args and **kwargs in the inner function of a decorator
    to provide maximum flexibility to the decorator.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 在装饰器的内部函数中使用 *args 和 **kwargs 可以提供最大的灵活性给装饰器。
- en: the return statement in the inner function
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数中的返回语句
- en: Section 6.2 mentions that every Python function returns a value either implicitly
    as None or as an explicitly returned value. Thus, when we define the inner function,
    we shouldn’t forget to add the return statement. Specifically, the return value
    should be the one that you get by calling the decorated function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 6.2节提到，每个Python函数要么隐式返回None，要么显式返回一个返回值。因此，当我们定义内部函数时，我们不应该忘记添加返回语句。具体来说，返回值应该是通过调用装饰后的函数获得的值。
- en: On a related note, be cautious about where you place the return statement. As
    you may know, any code below the return statement can’t be executed because return
    means that the current execution is done, and we’re giving the control back to
    the caller where the execution was initiated. Thus, when we want to apply operations
    after calling the decorated function, we use a temporary variable to store the
    return value. After the extra operations, we return this variable. This is exactly
    what we did for the logging_time function in listing 7.8\. Figure 7.3 shows the
    contrast.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关的问题上，注意返回语句的位置。正如你所知，任何位于返回语句下面的代码都无法执行，因为返回意味着当前执行已完成，我们将控制权交回给调用者，执行是从那里开始的。因此，当我们想在调用装饰函数后应用操作时，我们使用一个临时变量来存储返回值。在额外的操作之后，我们返回这个变量。这正是我们在列表
    7.8 中的 logging_time 函数所做的事情。图 7.3 展示了对比。
- en: '![CH07_F03_Cui](../Images/CH07_F03_Cui.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Cui](../Images/CH07_F03_Cui.png)'
- en: Figure 7.3 Place the return statement at the end of the inner function. First,
    we shouldn’t forget to add the return statement. Otherwise, we’re changing how
    the decorated function behaves, as the expected return value vanishes in the inner
    function. Second, we should place the return value at the end of the inner function
    instead of somewhere in the middle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 将返回语句放置在内部函数的末尾。首先，我们不应该忘记添加返回语句。否则，我们正在改变装饰函数的行为，因为预期的返回值在内部函数中消失了。其次，我们应该将返回值放置在内部函数的末尾，而不是中间的某个位置。
- en: 7.3.3 Wrapping to carry over the decorated function’s metadata
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 包装以传递装饰函数的元数据
- en: 'So far, I’ve introduced the core features of decorators and how to create a
    logging_ time decorator to monitor the performance of any function through decoration.
    But the decoration process may make the decorated function lose its metadata,
    such as its docstring. In this section, we’ll see how to keep the decorated function’s
    metadata. Before you jump into the solution, examine the following code for potential
    problems that might arise after decoration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经介绍了装饰器的核心特性和如何创建一个 logging_time 装饰器来通过装饰监控任何函数的性能。但是，装饰过程可能会使装饰函数丢失其元数据，例如其文档字符串。在本节中，我们将看到如何保留装饰函数的元数据。在你跳入解决方案之前，检查以下代码在装饰后可能出现的潜在问题：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As shown in this code, without decoration, we retrieved the say_hi function’s
    docstring by accessing its __doc__ attribute. By contrast, after decoration, we
    lost say_hello’s docstring. In a similar manner, the decoration changed the function’s
    name (accessible with the __name__ attribute). These function attributes, including
    __doc__ and __name__ (known as its metadata), are affected by the decoration process.
    Why? Give yourself a few seconds to think about it before moving on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，未经装饰，我们通过访问其 __doc__ 属性检索了 say_hi 函数的文档字符串。相比之下，经过装饰后，我们丢失了 say_hello
    的文档字符串。以类似的方式，装饰改变了函数的名称（可以通过 __name__ 属性访问）。这些函数属性，包括 __doc__ 和 __name__（称为其元数据），会受到装饰过程的影响。为什么？在继续之前，给自己几秒钟时间思考一下。
- en: Hint Decoration converts the original function to a closure, which is an inner
    function created from the decorator.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 装饰器将原始函数转换为闭包，这是一个由装饰器创建的内部函数。
- en: 'When we define a function without a decorator, the identifier (function name)
    represents the defined function and its associated operations. By contrast, when
    we define a function with a decorator, the decorated function is more than a function,
    as it appears to be. Instead, the inner function is created and returned by the
    decorator function, and is known as a *closure**.* Thus, accessing say_hello’s
    __doc__ attribute is equivalent to accessing the __doc__ attribute of logging_time’s
    inner function, logger. To prove it, we can run an experiment by adding some docstring
    to the inner function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个没有装饰器的函数时，标识符（函数名）代表定义的函数及其相关操作。相比之下，当我们用装饰器定义一个函数时，装饰函数不仅仅是一个函数，它看起来是这样的。相反，内部函数是由装饰器函数创建并返回的，这被称为
    *闭包**。因此，访问 say_hello 的 __doc__ 属性等同于访问 logging_time 的内部函数，logger 的 __doc__ 属性。为了证明这一点，我们可以通过向内部函数添加一些文档字符串来进行实验：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output supports our prediction, as it is indeed the docstring of the decorator’s
    inner function. If we use this decorator for multiple functions, all the decorated
    functions will have the same docstring and name that matches the inner function!
    We can’t make things happen this way. Fortunately, Python provides a solution:
    we can use the wraps decorator in the functools module, which takes care of keeping
    the correct metadata for the decorated function. Observe this effect in the next
    listing.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出支持我们的预测，因为的确是装饰器内部函数的文档字符串。如果我们使用这个装饰器为多个函数，所有被装饰的函数都将具有相同的文档字符串和与内部函数匹配的名称！我们不能这样做事。幸运的是，Python
    提供了一个解决方案：我们可以使用 functools 模块中的 wraps 装饰器，它负责为被装饰的函数保持正确的元数据。观察下一个列表中的这个效果。
- en: Listing 7.9 Wrapping the decorated function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 包装被装饰的函数
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use the wraps decorator (boldface in listing 7.9) to decorate the inner function
    logger. Notably, this decorator is different from what you’ve learned; it takes
    the decorated function (func) as a parameter besides performing its decoration
    of the logger function. In other words, the wraps decorator uses both func and
    logger as its arguments. This feature is valid, as decorators are higher-order
    functions at their core, and they can accept as many functions as applicable to
    use as arguments. More generally, this feature—a decorator accepting parameters—is
    more advanced, and typically, we don’t need to use it. But I do want to challenge
    you on it at the end of this section!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 wraps 装饰器（列表 7.9 中的粗体）来装饰内部函数 logger。值得注意的是，这个装饰器与您所学的不同；它除了装饰 logger 函数外，还接受被装饰的函数（func）作为参数。换句话说，wraps
    装饰器使用 func 和 logger 作为其参数。这个特性是有效的，因为装饰器本质上是一等函数，并且它们可以接受尽可能多的函数作为参数来使用。更普遍地说，这个特性——接受参数的装饰器——更为高级，通常我们不需要使用它。但我在本节结束时确实想挑战一下您！
- en: Maintainability Don’t forget to use the wraps decorator to keep the decorated
    function’s metadata, particularly its docstring and name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 不要忘记使用 wraps 装饰器来保持被装饰函数的元数据，特别是它的文档字符串和名称。
- en: 7.3.4 Discussion
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 讨论
- en: This section’s topic probably represents one of the hardest that I’ve covered
    so far. Nevertheless, after learning the material, you should feel accomplished;
    we conquered some complicated concepts and made a useful logging decorator. You
    should know what constitutes a closure and why a decorator is an application of
    the closure technique. In terms of best practices, when you define a decorator,
    it’s important to use the wraps decorator to carry over the decorated function’s
    metadata.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主题可能代表了我迄今为止所覆盖的最难的主题之一。尽管如此，在学习完材料后，你应该感到自豪；我们克服了一些复杂的概念，并创建了一个有用的日志装饰器。你应该知道闭包的构成以及为什么装饰器是闭包技术的应用。在最佳实践方面，当你定义装饰器时，使用
    wraps 装饰器来传递被装饰函数的元数据是很重要的。
- en: 7.3.5 Challenge
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 挑战
- en: 'Mike is a web developer using Python as his work language. His work requires
    him to define a few decorators that can take arguments. As a best practice, can
    you help him write a decorator function—say, one named logging_time_app—that accepts
    an argument? The decorator performs the same job as the logging_time decorator.
    The parameter is a string to denote the application’s name, which serves as the
    prefix for all the output strings in the print function. When we use the decorator,
    we want to achieve the following effect:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Mike 是一位使用 Python 作为工作语言的网页开发者。他的工作需要他定义一些可以接受参数的装饰器。作为一个最佳实践，你能帮助他编写一个装饰器函数——比如说，命名为
    logging_time_app 的装饰器函数——接受一个参数吗？这个装饰器执行与 logging_time 装饰器相同的任务。参数是一个字符串，用来表示应用程序的名称，它作为
    print 函数中所有输出字符串的前缀。当我们使用装饰器时，我们希望达到以下效果：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Hint 1 When a parameter is used in @decorator(param), we call the higher-order
    function decorator with the param first, which subsequently returns another decorator,
    perhaps called true_decorator. Next, the true_ decorator is applied to the to-be-decorated
    function as though we’d used @true_decorator.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 1 当在 @decorator(param) 中使用参数时，我们首先用 param 调用高阶函数装饰器，然后它返回另一个装饰器，可能称为 true_decorator。接下来，true_decorator
    被应用于待装饰的函数，就像我们使用了 @true_decorator 一样。
- en: Hint 2 Don’t be afraid to create a higher-order function within another higher-order
    function when both higher-order functions are decorators!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 2 当两个高阶函数都是装饰器时，不要害怕在另一个高阶函数内部创建一个高阶函数！
- en: 7.4 How can I use generator functions as a memory-efficient data provider?
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 我该如何使用生成器函数作为内存高效的数据提供者？
- en: The core of any application is data. With the advent of data science and machine
    learning, many users have used Python to process enormous amounts of data—gigabytes
    or more. When you deal with this magnitude of data, it can take minutes or even
    hours to load all the data into memory. When multiple data processing steps are
    involved, each step can take a long time, and the code is hard to debug if any
    step goes wrong. Besides the extended wait time throughout processing, probably
    the biggest limitation is the fact that some computers don’t have sufficient memory
    to handle so much data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心是数据。随着数据科学和机器学习的出现，许多用户已经使用 Python 处理了大量的数据——数 GB 或更多。当你处理这种规模的数据时，将所有数据加载到内存中可能需要几分钟甚至几个小时。当涉及多个数据处理步骤时，每个步骤都可能需要很长时间，如果任何步骤出错，代码就难以调试。除了处理过程中的延长等待时间外，可能最大的限制是某些计算机没有足够的内存来处理如此多的数据。
- en: 'As an illustration, consider a simple example that involves a large amount
    of data. (Please note that I could have used a larger number, but the example
    might not have been easy to run on a regular computer, so I used a moderately
    large number.) Suppose that we need to calculate the sum of perfect squares that
    are generated for 1 to 1,000,000\. Using a typical approach, we create a list
    object to hold these numbers and then calculate their sum:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑一个涉及大量数据的一个简单示例。（请注意，我本可以使用更大的数字，但这个例子可能不容易在普通计算机上运行，所以我使用了适度的较大数字。）假设我们需要计算从
    1 到 1,000,000 生成的完全平方数的和。使用典型方法，我们创建一个列表对象来保存这些数字，然后计算它们的和：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ The stop index isn't used. Correct it by 1.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 停止索引没有被使用。将其更正为 1。
- en: Question Can you write a function that is decorated by logging_time to see the
    time cost of running this sum operation?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 你能编写一个由 logging_time 装饰的函数来查看运行此求和操作的时间成本吗？
- en: 'If you run the code, you’ll notice that it takes quite some time to obtain
    the result. And note that the object consumes considerable memory:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，你会注意到获取结果需要相当长的时间。并且请注意，该对象消耗了相当大的内存：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Different computers may produce varied results due to different storage mechanisms.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于不同的存储机制，不同的计算机可能会产生不同的结果。
- en: In this section, you’ll learn how to use generator functions to provide the
    needed data in a memory-efficient approach.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用生成器函数以内存高效的方式提供所需的数据。
- en: 7.4.1 Creating a generator to yield perfect squares
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 创建一个生成器以产生完全平方数
- en: As a special kind of iterator, a *generator* is created from a generator function.
    Because a generator is an iterator, it can render its items one by one. A generator
    is special because it doesn’t store its items, and it retrieves and renders its
    items when needed. This characteristic means that it’s a memory-efficient iterator
    for data rendering. In this section, we’ll focus on generators.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种特殊的迭代器，生成器是由生成器函数创建的。因为生成器是一个迭代器，它可以逐个渲染其项目。生成器之所以特殊，是因为它不存储其项目，而是在需要时检索和渲染其项目。这一特性意味着它是一个内存高效的渲染迭代器。在本节中，我们将重点关注生成器。
- en: 'First, let’s solve the problem with the new technique: using generators to
    compute the sum of perfect squares. The code in the next listing shows a solution.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用新技术解决这个问题：使用生成器来计算完全平方数的和。下一列表中的代码展示了解决方案。
- en: Listing 7.10 Creating a generator to calculate the sum of perfect squares
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 创建一个生成器以计算完全平方数的和
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The perfect_squares function is a generator function. By calling this function
    with upper_limit, we’re creating a generator named squares_gen. This generator
    renders perfect squares: 1², 2², 3², 4², ... until 1,000,000². As expected, the
    sum of these perfect squares obtained from the generator is the same as the result
    obtained from the list object squares_list.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: perfect_squares 函数是一个生成器函数。通过使用 upper_limit 调用此函数，我们创建了一个名为 squares_gen 的生成器。这个生成器渲染完全平方数：1²、2²、3²、4²、...
    直到 1,000,000²。正如预期的那样，从生成器获得的这些完全平方数的和与从列表对象 squares_list 获得的结果相同。
- en: The reason why this generator works resides in the body of the generator function.
    The most significant feature to observe is the yield keyword, which is the hallmark
    of a generator function. Whenever the operation executes to the yield line, it
    provides the item n * n. The coolest thing about a generator is the fact that
    *it remembers which item it should yield next.* Figure 7.4 shows how a generator
    works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器之所以能工作，是因为它位于生成器函数的主体中。最显著的特征是`yield`关键字，这是生成器函数的标志。每当操作执行到`yield`行时，它就会提供`n
    * n`这个项目。生成器最酷的地方在于它能够*记住下一个应该产生的项目*。图7.4展示了生成器是如何工作的。
- en: '![CH07_F04_Cui](../Images/CH07_F04_Cui.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Cui](../Images/CH07_F04_Cui.png)'
- en: Figure 7.4 The flow of creating and using a generator. Calling a generator function
    creates a generator. When we use the generator, it iterates its applicable items
    by going through the while loop. Every time it encounters the yield keyword, it
    yields an item by calling next behind the scenes, as shown in the gray box. When
    the condition (n <= limit) is no longer satisfied, the while loop ends, and there
    is no more chance to encounter the yield keyword, so iteration ends.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 创建和使用生成器的流程。调用生成器函数创建一个生成器。当我们使用生成器时，它通过while循环遍历其适用的项目。每次遇到`yield`关键字时，它都会通过在幕后调用`next`来产生一个项目，如图中的灰色框所示。当条件`(n
    <= limit)`不再满足时，while循环结束，就没有更多机会遇到`yield`关键字，因此迭代结束。
- en: 'As shown in figure 7.4, a generator is an iterator at its core, so using a
    generator involves invoking the next function. Every next(squares_gen) call reinstates
    the execution of the generator, starting from where it was left: the line following
    the last yield execution. As the yield statement is part of the while loop, the
    loop runs continuously, and each loop encounters the yield term once. When the
    loop is terminated, all the items are yielded, the generator is exhausted, and
    we’re done with the iteration.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.4所示，生成器在核心上是一个迭代器，因此使用生成器涉及到调用`next`函数。每次调用`squares_gen.next()`都会重新启动生成器的执行，从上次停止的地方开始：最后一个`yield`执行之后的行。由于`yield`语句是while循环的一部分，循环会持续运行，并且每个循环都会遇到一次`yield`项。当循环结束时，所有项目都会被产生，生成器耗尽，迭代完成。
- en: Reminder When you call next on iterators manually, you’ll encounter the StopIteration
    exception.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当你手动在迭代器上调用`next`时，你会遇到`StopIteration`异常。
- en: As an important conception, yield is different from return, which terminates
    the current execution and gives control back to the caller. By contrast, yield
    pauses the current execution and gives control back to the caller temporarily.
    When requested, it continues the execution. The scenario is like driving a car
    on a two-lane road. You can yield to other cars when necessary, and after the
    yield, you go back to the original lane.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个重要的概念，`yield`与`return`不同，`return`会终止当前执行并将控制权交回调用者。相比之下，`yield`会暂停当前执行并将控制权暂时交回调用者。当请求时，它继续执行。这种情况就像在双车道路上开车。当需要时，你可以让其他车辆先行，让行后，你就可以回到原来的车道。
- en: 7.4.2 Using generators for their memory efficiency
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 使用生成器提高内存效率
- en: In the preceding section, you learned how to create a generator from a generator
    function. But why do we bother using generators? In this section, we’ll find out.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何从一个生成器函数创建生成器。但我们为什么要费心使用生成器呢？在本节中，我们将找到答案。
- en: The most important feature of a generator is that it renders an item when it’s
    asked to do so. Related to this feature is a computer programming concept called
    *lazy evaluation**,* in which specific operations or variables aren’t evaluated
    until the need arises. In terms of generators, they don’t create all the items
    in the first place. Instead, a generator creates the next item only when it’s
    called on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器最重要的特性是当需要时才会渲染一个项目。与这个特性相关的一个计算机编程概念叫做*惰性求值**，其中特定的操作或变量只有在需要时才会被评估。在生成器的术语中，它们最初不会创建所有项目。相反，生成器只有在被调用时才会创建下一个项目。
- en: Lazy evaluation
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Lazy evaluation exists in various forms in different programming languages,
    such as Kotlin and Swift. An object can have an attribute that has a significant
    amount of data, but this attribute is not an essential one. When we create such
    an object, it can take a long time to prepare the attribute before we can use
    the object. Instead, we can make this attribute “lazily” evaluated, which means
    that we’ll make the object without having that attribute. The first time it’s
    called, we’ll prepare the attribute.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性求值以各种形式存在于不同的编程语言中，例如Kotlin和Swift。一个对象可能有一个包含大量数据的属性，但这个属性并不是必需的。当我们创建这样的对象时，在可以使用对象之前，准备这个属性可能需要很长时间。相反，我们可以使这个属性“惰性”评估，这意味着我们将没有那个属性来创建对象。第一次调用时，我们将准备这个属性。
- en: 'Because they yield their items once upon request, generators are memory-efficient.
    By contrast, we’ve seen that the list object of the perfect squares of 1 to 1
    million consumes more than 8 MB (converted from 8,448,712 bytes). Now, it’s time
    to observe how much memory a generator, which can render the same amount of data,
    costs:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们在请求时才生成项目，生成器是内存高效的。相比之下，我们已经看到，从1到1百万的完全平方数的列表对象消耗了超过8 MB（从8,448,712字节转换而来）。现在，是时候观察一个生成器，它能够生成相同数量的数据，需要多少内存了：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Your computer may show a different value.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你的电脑可能显示不同的值。
- en: The size of the generator is only 88 bytes, which is about 0.001 percent of
    the list object. The reason why it’s much smaller is that it needs to know only
    its current state; when it needs the next item, it can start from its current
    state and create the next item. By contrast, the list object needs to load all
    its items up front before it can use the items.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的大小仅为88字节，大约是列表对象的0.001%。它之所以如此小，是因为它只需要知道它的当前状态；当它需要下一个项目时，它可以从当前状态开始并创建下一个项目。相比之下，列表对象在使用项目之前需要预先加载所有项目。
- en: 7.4.3 Using generator expressions where applicable
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 在适用的情况下使用生成器表达式
- en: 'We’ve seen how useful a generator is. But we need to create a generator function
    before we can use it, which can be tedious. In this section, you’ll learn an alternative
    way to create a generator: using an expression in a process called *generator
    expression.*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了生成器是多么有用。但在使用它之前，我们需要创建一个生成器函数，这可能会很繁琐。在本节中，你将学习一种创建生成器的替代方法：使用称为*生成器表达式*的过程中的表达式。
- en: 'When you learned about comprehensions in section 5.2, I mentioned that there
    is no tuple comprehension, which otherwise could have used the following syntax:
    (expression for x in iterable). In fact, this expression is the syntax for generator
    expression. Now let’s rewrite the perfect_squares function as a generator expression:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在5.2节中学习到列表推导时，我提到没有元组推导，否则可以使用以下语法：（expression for x in iterable）。实际上，这个表达式是生成器表达式的语法。现在让我们将perfect_squares函数重写为生成器表达式：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Instead of using the yield keyword in a generator function, a generator expression
    uses an expression directly to denote what the data should render. From the syntax
    perspective, you must pay attention to using parentheses; otherwise, you’ll produce
    a list instead if you accidentally use square brackets. To show that a generator
    is an iterator, you can use the next function to retrieve items from the generator
    one at a time:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式不是在生成器函数中使用yield关键字，而是直接使用表达式来表示应该渲染的数据。从语法角度来看，你必须注意使用括号；否则，如果你不小心使用了方括号，你将产生一个列表。为了表明生成器是一个迭代器，你可以使用next函数逐个检索生成器中的项目：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s calculate the sum for the generator expression:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算生成器表达式的总和：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It’s working! But wait a second—why is the sum off by 14 compared with the sum
    that we calculated previously?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在工作！但是等等——为什么与之前我们计算出的总和相比，这个总和少了14？
- en: QUestion What did we do before using the squares_gen_exp?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：在使用squares_gen_exp之前我们做了什么？
- en: As I mentioned before, a generator is lazily rendering its items by remembering
    its state. The first next call retrieves 1, the second next call retrieves 4,
    and the third next call retrieves 9\. When we call sum(squares_gen_exp), the generator
    still remembers its state, so it starts to render the next item, which is 16\.
    As you should have noticed, the difference of the sums results from being unable
    to use the first three items, which have already been consumed by invoking next
    manually three times.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，生成器通过记住其状态来懒加载其项。第一次 next 调用检索 1，第二次 next 调用检索 4，第三次 next 调用检索 9。当我们调用
    sum(squares_gen_exp) 时，生成器仍然记住其状态，因此它开始渲染下一个项，即 16。正如你应该注意到的，求和结果的差异是由于无法使用前三个已经被手动调用
    next 三次消耗掉的项。
- en: 'From a syntax perspective, we can call the sum function with a generator expression
    directly, which eliminates the need to create an intermediate variable. When a
    generator is straightforward, it’s the preferred approach:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法角度来看，我们可以直接使用生成器表达式调用 sum 函数，这消除了创建中间变量的需要。当生成器很简单时，这是首选的方法：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Please note that in this expression, we omit the parentheses for the generator
    expression, as it’s optional if it’s used within another pair of parentheses.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个表达式中，我们省略了生成器表达式的括号，因为如果它被用于另一对括号内，则是可选的。
- en: 7.4.4 Discussion
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 讨论
- en: Under the hood, the implementation of generators involves using the yield keyword.
    Besides generators, an advanced technique, coroutines, also uses yield, and these
    coroutines are called *generator-based coroutines**.* These coroutines, however,
    are being phased out of Python, and you may see this technique only in legacy
    projects that use older versions of Python. So don’t worry if you don’t know generator-based
    coroutines well.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，生成器的实现涉及使用 yield 关键字。除了生成器之外，一种高级技术，协程，也使用 yield，这些协程被称为**基于生成器的协程**。然而，这些协程正在从
    Python 中逐步淘汰，你可能在仅使用较旧版本的 Python 的遗留项目中看到这种技术。所以，如果你不太了解基于生成器的协程，请不要担心。
- en: 7.4.5 Challenge
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.5 挑战
- en: James teaches introductory Python programming to undergraduates in the mathematics
    department. To use a familiar concept, he thought about Fibonacci numbers—a sequence
    of numbers whose value is the sum of the previous two numbers, as in 0, 1, 1,
    2, 3, 5, 8, 13\. He challenged his students to write a generator function with
    an upper limit to produce a generator that renders Fibonacci numbers until it
    reaches the specified limit.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯在数学系为本科生教授入门级 Python 编程。为了使用一个熟悉的概念，他想到了斐波那契数列——一个数列，其值是前两个数的和，如 0, 1, 1,
    2, 3, 5, 8, 13。他挑战他的学生编写一个具有上限的生成器函数，以生成一个生成器，直到达到指定的限制时渲染斐波那契数。
- en: Hint You can define the first two numbers yourself and then build the formula
    by using the definition value[n+2] = value[n] + value[n+1].
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以自己定义前两个数字，然后通过使用定义值[n+2] = value[n] + value[n+1]来构建公式。
- en: 7.5 How do I create partial functions to make routine function calls easier?
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 我如何创建部分函数以简化常规函数调用？
- en: Functions aren’t isolated from other components of your application. Instead,
    they interact with other entities by taking the input and returning the processed
    output. To increase a function’s flexibility, we often define multiple parameters
    in a function so that it can handle different forms of input to derive the needed
    results for different scenarios.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 函数并不是与应用程序的其他组件隔离的。相反，它们通过接收输入并返回处理后的输出与其他实体进行交互。为了增加函数的灵活性，我们经常在函数中定义多个参数，以便它可以处理不同形式的输入，从而为不同的场景推导出所需的结果。
- en: 'Suppose that you use Python for your data science work. You have the following
    function to perform statistical modeling using the specified dataset:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用 Python 进行数据科学工作。你有一个以下函数来使用指定的数据集进行统计分析：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Nominal value to make the code run
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使代码运行的标称值
- en: 'This function is so important and universal that you use it in multiple projects.
    In each of your projects, you use the same model and output to the same folder
    on different datasets. The following code snippet may reveal what you may be doing
    across projects:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数如此重要且通用，以至于你在多个项目中都会使用它。在你的每个项目中，你使用相同的模型并将输出到不同的数据集上的相同文件夹。以下代码片段可能会揭示你在项目之间可能正在做的事情：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you may realize, there is a repetition pattern here because the same parameters
    are used across multiple function calls. Your first reaction may be to apply the
    default parameters to the run_stats_model function. This solution is not optimal,
    however, as you may still have to specify these parameters for other projects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所意识到的那样，这里有一个重复模式，因为相同的参数被用于多个函数调用。你的第一个反应可能是将默认参数应用到run_stats_model函数上。然而，这个解决方案并不理想，因为你可能仍然需要为其他项目指定这些参数：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, you’ll learn about a new technique called partial functions,
    and we’ll see how to use partial functions to simplify function calls when common
    parameters are shared within each project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解一种名为部分函数的新技术，我们将看到如何使用部分函数在项目内部共享参数时简化函数调用。
- en: 7.5.1 “Localizing” shared functions to simplify function calls
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 “本地化”共享函数以简化函数调用
- en: For this business need, we use the same model and output path for the run_stats_
    model function in each project. Because the run_stats_model is shared across multiple
    projects, using this function within each project is local. Thus, we can operationalize
    the need as a localization question. This section discusses a working solution
    that uses our existing knowledge.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个业务需求，我们在每个项目中使用相同的模型和输出路径来调用run_stats_model函数。由于run_stats_model在多个项目中共享，因此在每个项目中使用此函数是局部的。因此，我们可以将这种需求操作化为一个本地化问题。本节讨论了一个使用我们现有知识的工作解决方案。
- en: 'Because each project uses the same model and output path, we could create a
    variation version of the shared function for each project. At the top of the Project
    A file, for example, we might create a function like this one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个项目使用相同的模型和输出路径，我们可以为每个项目创建共享函数的变体版本。例如，在Project A文件顶部，我们可能创建一个如下所示的函数：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Readability Even though I can write return run_stats_models(dataset, "model_a",
    "project_a/stats/"), I want to use an intermediate variable to denote the exact
    nature of the return value from the function call. In general, it’s a good idea
    to return a clearly-defined variable instead of returning something directly from
    another function call.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 尽管我可以写return run_stats_models(dataset, "model_a", "project_a/stats/"), 我仍然想使用一个中间变量来表示函数调用的确切返回值。一般来说，返回一个明确定义的变量而不是直接从另一个函数调用返回东西是一个好主意。
- en: 'The run_stats_model_a function is rather straightforward. It provides a convenience
    function call wrapped around the run_stats_models function. With this localized
    function, all the original calls to run_stats_models become the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: run_stats_model_a函数相当直接。它提供了一个便利的函数调用，该调用被run_stats_models函数包装。使用这个局部函数，所有对run_stats_models的原始调用都变成了以下形式：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 7.5.2 Creating a partial function to localize a function
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 创建局部函数以定位函数
- en: 'The preceding section defines a regular function to localize the shared function.
    It works. But it reinvents the wheel, as Python has already implemented such functionality
    for us. The more Pythonic solution is to use the partial function to localize
    a shared function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节定义了一个常规函数来定位共享函数。它是有效的。但它重写了轮子，因为Python已经为我们实现了这样的功能。更Pythonic的解决方案是使用partial函数来定位共享函数：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The partial function exists in the functools module, which has a collection
    of advanced function-related tools in the standard Python library. In the partial
    function, we specify the shared function and any additional parameters that we
    want to set—in this case, the project-specific model and output path.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: partial函数存在于functools模块中，该模块是Python标准库中包含一系列高级函数相关工具的模块。在partial函数中，我们指定共享函数以及我们想要设置的任何附加参数——在这种情况下，特定于项目的模型和输出路径。
- en: Reminder We previously used wraps to keep a function’s metadata during decoration.
    The wraps function is also in the functools module.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：我们之前使用wraps来在装饰期间保持函数的元数据。wraps函数也在functools模块中。
- en: The created function run_stats_model_a is known as a *partial* function. When
    we call it, we no longer need to specify the shared parameters, which have already
    been taken care of. Using the partial function technique, we can create separate
    partial functions for each project, and they can significantly simplify the calling
    signature, making your code more readable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的函数run_stats_model_a被称为*部分*函数。当我们调用它时，我们不再需要指定共享参数，这些参数已经被处理好了。使用partial函数技术，我们可以为每个项目创建单独的部分函数，并且它们可以显著简化调用签名，使代码更易读。
- en: 7.5.3 Discussion
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 讨论
- en: 'This entire section (7.5) is brief. I use a simple example to show you a useful
    technique: partial functions. When you accumulate your codebase, you’ll find that
    you often need to use some functions across multiple locations. In this case,
    you can create partial functions from existing functions. These partial functions
    freeze the shared parameters in a location, and you can omit these parameters
    to improve the clarity of your code.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 整个这一节（7.5）内容简短。我通过一个简单的例子向你展示一个有用的技巧：偏函数。当你积累代码库时，你会发现你经常需要在多个位置使用一些函数。在这种情况下，你可以从现有函数创建偏函数。这些偏函数在某个位置冻结共享参数，你可以省略这些参数以提高代码的清晰度。
- en: 7.5.4 Challenge
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.4 挑战
- en: Partial functions are created from other functions. How can you find out which
    function a partial function is created from?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 偏函数是从其他函数创建的。你如何找出偏函数是从哪个函数创建的？
- en: Hint A partial function has extra attributes compared with a regular function.
    You can check its attributes by calling dir(partial_function_created). Inspect
    the list to see which attribute is relevant.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：与普通函数相比，偏函数有额外的属性。你可以通过调用dir(partial_function_created)来检查其属性。检查列表以查看哪个属性是相关的。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Lambda functions are intended to perform a small job for one-time use, which
    implies that you don’t assign a lambda function to a variable.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数旨在执行一次性的小任务，这意味着你不会将lambda函数赋值给变量。
- en: 'Although lambda functions are handy, don’t reinvent the wheel. Where applicable,
    use built-in functions to perform the same job without defining a lambda function,
    such as using the built-in int instead of lambda x: int(x).'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '虽然lambda函数很方便，但不要重新发明轮子。在适用的情况下，使用内置函数来完成相同的工作，而不需要定义lambda函数，例如使用内置的int而不是lambda
    x: int(x)。'
- en: Functions are first-class citizens in Python, as they’re other objects. Any
    operations that you can do with an object can be applied to functions too.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数在Python中是一等公民，因为它们是其他对象。你可以对对象执行的所有操作也可以应用于函数。
- en: Higher-order functions take functions as input and/or return functions as output.
    Some notable built-in higher-order functions include sorted, map, and filter.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数接受函数作为输入和/或返回函数作为输出。一些值得注意的内置高阶函数包括sorted、map和filter。
- en: Using decorators, we can apply additional functionalities to other functions
    without changing the decorated functions’ original functionalities.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器，我们可以将额外的功能应用于其他函数，而无需更改被装饰函数的原始功能。
- en: Although not introduced formally in this chapter, closures are an essential
    programming concept. They’re inner functions created and returned by higher-order
    functions, and they also bind variables defined by the higher-order function.
    Decorators are an application of the closure technique.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然本章没有正式介绍，但闭包是一个重要的编程概念。它们是高阶函数创建并返回的内联函数，并且它们还绑定高阶函数定义的变量。装饰器是闭包技术的一种应用。
- en: We can create generators from a generator function, which uses the yield keyword
    to yield an item and gives up control temporarily. When it’s called again, it
    remembers its state and continues the execution by rendering the next applicable
    item or completing iteration.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从生成器函数创建生成器，它使用yield关键字产生一个项目并暂时放弃控制。当再次调用时，它会记住其状态，并通过渲染下一个适用的项目或完成迭代来继续执行。
- en: Compared with other iterators, generators are more memory-efficient, as they
    don’t load all their elements up front, unlike conventional iterators such as
    lists and tuples, which must load all their items before they can be iterated.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他迭代器相比，生成器更节省内存，因为它们不需要在开始迭代之前加载所有元素，而传统的迭代器（如列表和元组）必须在迭代之前加载所有元素。
- en: We use partial functions to freeze some parameters of a shared function so that
    we have a localized version of the function that specifically serves the project.
    A partial function eliminates the need to specify the frozen parameters, which
    makes your code cleaner.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用偏函数来冻结共享函数的一些参数，以便我们有一个专门为项目服务的本地化版本的功能。偏函数消除了指定冻结参数的需要，这使得你的代码更简洁。
