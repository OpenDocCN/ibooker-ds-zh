- en: 4 Patterns for infrastructure dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施依赖关系的4种模式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Writing loosely coupled infrastructure modules using dependency patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖模式编写松散耦合的基础设施模块
- en: Identifying ways to decouple infrastructure dependencies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别解耦基础设施依赖关系的方法
- en: Recognizing infrastructure use cases for dependency patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别依赖模式的基础设施用例
- en: An infrastructure system involves a set of resources that depend on each other.
    For example, a server depends on the existence of a network. How do you know the
    network exists before creating a server? You can express this with an *infrastructure
    dependency*. An infrastructure dependency happens when a resource requires another
    one to exist before creating or modifying the first one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施系统涉及一组相互依赖的资源。例如，服务器依赖于网络的存在。您如何在创建服务器之前知道网络是否存在？您可以使用*基础设施依赖*来表示这一点。当资源在创建或修改第一个资源之前需要另一个资源存在时，就会发生基础设施依赖。
- en: Definition An *infrastructure dependency* expresses a relationship in which
    an infrastructure resource depends on the existence and attributes of another
    resource.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*基础设施依赖*表达了基础设施资源依赖于另一个资源的存在和属性的关系。
- en: Usually, you identify the server’s dependency on the network by hardcoding the
    network identifier. However, hardcoding more tightly binds the dependency between
    server and network. Anytime you change the network, you must update the hardcoded
    dependency.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您通过硬编码网络标识符来识别服务器对网络的依赖。然而，硬编码更紧密地绑定服务器和网络之间的依赖关系。每次您更改网络时，都必须更新硬编码的依赖关系。
- en: In chapter 2, you learned how to avoid hardcoding values with variables to promote
    reproducibility and evolvability. Passing the network identifier as a variable
    better decouples the server and network. However, a variable works between resources
    only in the same module. How can you express dependencies *between* modules?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，您学习了如何使用变量避免硬编码值以促进可重复性和可演化性。将网络标识符作为变量传递可以更好地解耦服务器和网络。然而，变量仅在相同模块的资源之间工作。您如何表达*模块之间*的依赖关系？
- en: The preceding chapter grouped resources into modules to enhance composability.
    This chapter covers patterns for managing infrastructure dependencies to enhance
    evolvability (change). You can more easily replace one module with another when
    they have a loose dependency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章将资源分组到模块中以提高可组合性。本章涵盖了管理基础设施依赖关系以增强可演化的模式（变更）。当它们具有松散依赖关系时，您可以更容易地用另一个模块替换一个模块。
- en: In reality, infrastructure systems can be pretty complex, and you can’t swap
    modules without some disruption. Loosely coupled dependencies offer mitigation
    for change failure but don’t guarantee 100% availability!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，基础设施系统可能相当复杂，而且在不造成某些干扰的情况下无法交换模块。松散耦合的依赖关系可以减轻变更失败的风险，但并不能保证100%的可用性！
- en: 4.1 Unidirectional relationships
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 单向关系
- en: Different dependency relationships affect infrastructure change. Imagine you
    add a firewall rule each time you create a new application. The firewall rule
    has a *unidirectional dependency* on the application IP address to allow traffic.
    Any change to the application gets reflected in the firewall rule.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的依赖关系会影响基础设施变更。想象一下，每次您创建一个新的应用程序时，都会添加一个防火墙规则。防火墙规则对应用程序IP地址有一个*单向依赖*，以允许流量。任何对应用程序的更改都会反映在防火墙规则中。
- en: Definition A *unidirectional dependency* expresses a one-way relationship in
    which only one resource refers to another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*单向依赖*表达了一种单向关系，其中只有一个资源引用另一个资源。
- en: You can express unidirectional dependencies between any set of resources or
    modules. Figure 4.1 describes the unidirectional relationship between the firewall
    rule and the application. The rule *depends on* the application, which makes it
    higher up the infrastructure stack than the lower-level application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何一组资源或模块之间表达单向依赖关系。图4.1描述了防火墙规则与应用程序之间的单向关系。规则*依赖于*应用程序，这使得它在基础设施堆栈中的位置高于较低级别的应用程序。
- en: '![](../../OEBPS/Images/CH04_F01_Wang.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F01_Wang.png)'
- en: Figure 4.1 The firewall rule unidirectionally depends on the application’s IP
    address.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 防火墙规则单向依赖于应用程序的IP地址。
- en: When you express a dependency, you have a *high-level* *resource* like the firewall
    that depends on the existence of a *low-level* *resource* like the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您表达依赖关系时，您有一个*高级* *资源*，如防火墙，它依赖于*低级* *资源*，如应用程序的存在。
- en: Definition A *high-level resource* depends on another resource or module. A
    *low-level resource* has high-level resources depending on it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*高级资源*依赖于另一个资源或模块。一个*低级资源*有高级资源依赖于它。
- en: Let’s say a reporting application needs a list of rules for the firewall. It
    sends the rules to an audit application. However, the firewall needs to know the
    IP address of the reporting application. Should you update the IP address of the
    reporting application or the firewall rule first? Figure 4.2 shows the conundrum
    of deciding which application you should update first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个报告应用程序需要一个防火墙的规则列表。它将规则发送到审计应用程序。然而，防火墙需要知道报告应用程序的 IP 地址。您应该先更新报告应用程序的 IP
    地址还是防火墙规则？图 4.2 展示了决定应该先更新哪个应用程序的困境。
- en: '![](../../OEBPS/Images/CH04_F02_Wang.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F02_Wang.png)'
- en: Figure 4.2 The reporting application and the firewall have a circular dependency
    on each other. Changes block connectivity to the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 报告应用程序和防火墙相互之间存在循环依赖。变更阻止了对应用程序的连接。
- en: This example encounters a circular dependency, which introduces a chicken-or-egg
    problem. You cannot change one resource without affecting the other. If you first
    change the address of the reporting application, the firewall rule must change.
    However, the reporting application fails because it can’t connect. You might have
    blocked its request!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例遇到了循环依赖，这引入了一个“先有鸡还是先有蛋”的问题。您不能更改一个资源而不影响另一个资源。如果您首先更改报告应用程序的地址，防火墙规则必须更改。然而，报告应用程序失败，因为它无法连接。您可能已经阻止了它的请求！
- en: 'Circular dependencies cause unexpected behaviors during changes, which ultimately
    affect composability and evolvability. You don’t know which resource to update
    first. By contrast, you can identify how a low-level module’s change might affect
    the high-level one. Unidirectional dependency relationships make changes more
    predictable. After all, a successful infrastructure change depends on two factors:
    predictability and isolation.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖在变更过程中会导致意外的行为，这最终会影响可组合性和可扩展性。您不知道应该先更新哪个资源。相比之下，您可以确定低级模块的变更可能会如何影响高级模块。单向依赖关系使变更更加可预测。毕竟，成功的基础设施变更取决于两个因素：可预测性和隔离性。
- en: 4.2 Dependency injection
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 依赖注入
- en: 'Unidirectional dependencies help you engineer ways to minimize the impact of
    low-level module changes to high-level modules. For example, network changes should
    not disrupt high-level resources like queues, applications, or databases. This
    section applies the software development concept of dependency injection to infrastructure
    and further decouples unidirectional dependencies. Dependency injection involves
    two principles: inversion of control and dependency inversion.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单向依赖有助于您设计方法以最小化低级模块变更对高级模块的影响。例如，网络变更不应干扰高级资源，如队列、应用程序或数据库。本节将软件开发中的依赖注入概念应用于基础设施，并进一步解耦单向依赖。依赖注入涉及两个原则：控制反转和依赖反转。
- en: 4.2.1 Inversion of control
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 控制反转
- en: When you enforce unidirectional relationships in your infrastructure dependencies,
    your high-level resource gets information about the low-level resource. Then it
    can run its changes. For example, a server gets information about the network’s
    ID and IP address range before it claims an IP address (figure 4.3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在基础设施依赖中强制执行单向关系时，您的高级资源会获取有关低级资源的信息。然后它可以运行其变更。例如，服务器在声明 IP 地址之前会获取有关网络 ID
    和 IP 地址范围的详细信息（图 4.3）。
- en: '![](../../OEBPS/Images/CH04_F03_Wang.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F03_Wang.png)'
- en: Figure 4.3 With inversion of control, the high-level resource or module calls
    the low-level module for information and parses its metadata for any dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 在控制反转中，高级资源或模块调用低级模块以获取信息，并解析其元数据以查找任何依赖项。
- en: The server calls the network, naturally applying a software development principle
    called *inversion of control*. The high-level resource calls for information about
    the low-level resource before updating.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器调用网络，自然应用了称为*控制反转*的软件开发原则。在更新之前，高级资源会调用低级资源以获取信息。
- en: Definition *Inversion of control* is the principle by which the high-level resource
    calls the low-level one for attributes or references.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *控制反转*是高级资源调用低级资源以获取属性或引用的原则。
- en: As a nontechnical example, you use inversion of control when you call to schedule
    a doctor’s appointment instead of the doctor’s office automatically scheduling
    your appointment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为非技术示例，当你通过电话预约医生而不是由医生办公室自动预约时，你使用控制反转。
- en: Let’s apply inversion of control to implement the server’s dependency on the
    network. You create the network by using a network module. In the following listing,
    the network module outputs a network name and saves it in a file called terraform.tfstate.
    High-level resources, like the server, can parse the network name from this JSON
    file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用控制反转来实现服务器对网络的依赖。你通过使用网络模块创建网络。在下面的列表中，网络模块输出一个网络名称并将其保存到名为terraform.tfstate的文件中。高级资源，如服务器，可以从此JSON文件中解析网络名称。
- en: Listing 4.1 Network module outputs in JSON file
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 网络模块在JSON文件中的输出
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Creating the network with Terraform generates a JSON file with a list of outputs.
    Terraform uses this file to track the resources it creates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用Terraform创建网络生成一个包含输出列表的JSON文件。Terraform使用此文件来跟踪它创建的资源。
- en: ❷ The network module outputs the subnet name as a string.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 网络模块以字符串形式输出子网名称。
- en: ❸ The remainder of the JSON file has been omitted for clarity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了清晰起见，省略了JSON文件的其余部分。
- en: Using inversion of control, the server *calls* the network’s terraform.tfstate
    file in listing 4.2 and reads the subnet name. Since the module expresses outputs
    in the JSON file, your server module needs to parse for the value of the subnet
    name (`hello-world-subnet`).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制反转，服务器在列表4.2中调用网络的terraform.tfstate文件并读取子网名称。由于模块在JSON文件中表达输出，你的服务器模块需要解析子网名称的值（`hello-world-subnet`）。
- en: Listing 4.2 Applying inversion of control to create a server on a network
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 应用控制反转在网络中创建服务器
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Creates an object that captures the schema of the network module’s output.
    This makes it easier for the server to retrieve the subnet name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个对象来捕获网络模块输出的模式。这使得服务器更容易检索子网名称。
- en: ❷ The object for the network output parses the value of the subnet name from
    the JSON object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解析网络输出对象的子网名称值。
- en: ❸ Creates a module for the server, which uses the factory pattern
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个服务器模块，它使用工厂模式
- en: ❹ Creates the Google compute instance using a Terraform resource with a name
    and zone
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用具有名称和区域的Terraform资源创建Google计算实例
- en: ❺ The server module calls the network output object, which contains the subnet
    name parsed from the network module’s JSON file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 服务器模块调用包含从网络模块的JSON文件中解析出的子网名称的网络输出对象。
- en: ❻ Uses the module to create the JSON configuration for the server using the
    subnetwork name
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用模块根据子网名称创建服务器的JSON配置
- en: ❼ The server module references the network output’s name and passes it to the
    “subnetwork” field.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 服务器模块引用网络输出的名称并将其传递给“子网”字段。
- en: ❽ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将Python字典写入JSON文件，以便Terraform稍后执行
- en: AWS and Azure equivalents
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure的等效方案
- en: In AWS, you would use the `aws_instance` Terraform resource with a reference
    to the network you want to use ([http://mng.bz/PnPR](http://mng.bz/PnPR)). In
    Azure, use the `azurerm_ linux_virtual_machine` Terraform resource ([http://mng.bz/J2DZ](http://mng.bz/J2DZ))
    on the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中，你会使用带有网络引用的`aws_instance` Terraform资源（[http://mng.bz/PnPR](http://mng.bz/PnPR)）。在Azure中，使用网络上的`azurerm_linux_virtual_machine`
    Terraform资源（[http://mng.bz/J2DZ](http://mng.bz/J2DZ)）。
- en: Implementing inversion of control eliminates a direct reference to the subnet
    in your server module. You can also control and limit the information the network
    returns for high-level resources to use. More important, you improve my composability
    because you can create other servers and high-level resources on the subnet name
    offered by the network module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实现控制反转可以消除服务器模块中对子网的直接引用。你也可以控制并限制网络为高级资源返回的信息。更重要的是，你提高了我的可组合性，因为你可以使用网络模块提供的子网名称创建其他服务器和高级资源。
- en: What if other high-level resources need other low-level attributes? For example,
    you might create a queue that needs the subnet IP address range. To solve this
    problem, you evolve the network module to output the subnet IP address range.
    The queue can reference the outputs for the address it needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他高级资源需要其他低级属性怎么办？例如，你可能创建一个需要子网IP地址范围的队列。为了解决这个问题，你将网络模块进化为输出子网IP地址范围。队列可以引用它需要的地址的输出。
- en: Inversion of control improves evolvability as high-level resources require different
    attributes. You can evolve low-level resources without rewriting the infrastructure
    as code for high-level resources. However, you need a way to protect the high-level
    resources from any attribute updates or renaming on the low-level resources.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转通过高级资源需要不同的属性来提高可进化性。你可以不重写高级资源的基础设施代码来进化低级资源。然而，你需要一种方法来保护高级资源免受低级资源任何属性更新或重命名的影响。
- en: 4.2.2 Dependency inversion
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 依赖倒置
- en: While inversion of control enables the evolution of high-level modules, it does
    not protect them from changes to low-level modules. Let’s imagine you change the
    network name to its ID. The next time you deploy changes to your server module,
    it breaks! The server module does not recognize the network ID.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制反转使得高级模块能够进化，但它并不能保护它们免受低级模块变更的影响。让我们想象一下，你将网络名称更改为其ID。下次你部署服务器模块的变更时，它就崩溃了！服务器模块无法识别网络ID。
- en: To protect your server module from changes to the network outputs, you add a
    layer of abstraction between the network output and server. In figure 4.4, the
    server accesses the network’s attributes through an API or a stored configuration
    instead of the network output. All of these interfaces serve as abstractions to
    retrieve network metadata.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护你的服务器模块免受网络输出的变更影响，你在网络输出和服务器之间添加了一层抽象。在图4.4中，服务器通过API或存储的配置访问网络的属性，而不是网络输出。所有这些接口都作为抽象来检索网络元数据。
- en: '![](../../OEBPS/Images/CH04_F04_Wang.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F04_Wang.png)'
- en: Figure 4.4 Dependency inversion returns an abstraction of the low-level resource
    metadata to the resource that depends on it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 依赖倒置将低级资源元数据的抽象返回给依赖它的资源。
- en: You can use dependency inversion to isolate changes to low-level modules and
    mitigate disruption to their dependencies. *Dependency inversion* dictates that
    high-level and low-level resources should have dependencies expressed through
    abstractions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用依赖倒置来隔离对低级模块的变更，并减轻对其依赖的破坏。*依赖倒置*原则规定，高级和低级资源应通过抽象表达依赖关系。
- en: Definition *Dependency inversion* is the principle of expressing dependencies
    between high-level and low-level modules or resources through abstractions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*依赖倒置*是通过抽象表达高级和低级模块或资源之间依赖关系的原则。
- en: 'The abstraction layer behaves as a translator that communicates the required
    attributes. It serves as a buffer for changes to the low-level module away from
    the high-level one. In general, you can choose from three types of abstraction:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层充当一个翻译者，用于传达所需的属性。它作为低级模块对高级模块变更的缓冲。一般来说，你可以从三种类型的抽象中进行选择：
- en: Interpolation of resource attributes (within modules)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源属性插值（模块内）
- en: Module outputs (between modules)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块输出（模块之间）
- en: Infrastructure state (between modules)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施状态（模块之间）
- en: Some abstractions, such as attribute interpolation or module outputs, depend
    on your tool. Abstraction by infrastructure state will depend on your tool or
    infrastructure API. Figure 4.5 shows the abstractions by attribute interpolation,
    module output, or infrastructure state to pass network metadata to the server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些抽象，如属性插值或模块输出，取决于你的工具。通过基础设施状态进行的抽象将取决于你的工具或基础设施API。图4.5显示了通过属性插值、模块输出或基础设施状态来传递网络元数据到服务器的抽象。
- en: '![](../../OEBPS/Images/CH04_F05_Wang.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F05_Wang.png)'
- en: Figure 4.5 Depending on the tool and dependencies, abstractions for dependency
    inversion can use attribute interpolation, module outputs, or infrastructure state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 根据工具和依赖关系，依赖倒置的抽象可以使用属性插值、模块输出或基础设施状态。
- en: Let’s examine how to implement the three types of abstraction by building modules
    for the network and server in listing 4.3\. I’ll start with attribute interpolation.
    Attribute interpolation handles attribute passing between resources or tasks within
    a module or configuration. Using Python, a subnet interpolates the name of the
    network by accessing the `name` attribute assigned to the network object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建列表4.3中的网络和服务器模块来检查如何通过实现三种类型的抽象。我将从属性插值开始。属性插值处理模块或配置内资源或任务之间的属性传递。使用Python，子网通过访问分配给网络对象的`name`属性来插值网络名称。
- en: Listing 4.3 Using attribute interpolation to get the network name
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 使用属性插值获取网络名称
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates the Google network using a Terraform resource named “hello-network”
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用名为“hello-network”的 Terraform 资源创建 Google 网络
- en: ❷ Uses the module to create the JSON configuration for the network
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模块创建网络的 JSON 配置
- en: ❸ Creates the Google subnetwork using a Terraform resource named after the region,
    us-central1
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用名为 us-central1 的区域名称的 Terraform 资源创建 Google 子网
- en: ❹ Passes the entire network object to the subnet. The subnet calls the network
    object for the attributes it needs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将整个网络对象传递给子网。子网调用网络对象以获取它需要的属性。
- en: ❺ Interpolates the network name by retrieving it from the object
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过从对象中检索来插值网络名称
- en: ❻ Uses the module to create the JSON configuration for the network
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用模块创建网络的 JSON 配置
- en: ❼ Uses the module to create the JSON configuration for the subnet and passes
    the network object to the subnet
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 使用模块创建子网和网络 JSON 配置，并将网络对象传递给子网
- en: ❽ Merges the network and subnet JSON objects into a Terraform-compatible JSON
    structure
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将网络和子网 JSON 对象合并为 Terraform 兼容的 JSON 结构
- en: ❾ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 将 Python 字典写入 JSON 文件，供 Terraform 后续执行
- en: Domain-specific languages
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: IaC tools that use DSLs offer their own variable interpolation format. The example
    in Terraform would use `google_compute_network.hello-world-network .name` to dynamically
    pass the name of the network to the subnet. CloudFormation allows you to reference
    parameters with `Ref`. You can reference `properties` of a resource in Bicep.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DSL 的 IaC 工具提供自己的变量插值格式。在 Terraform 中的示例将使用 `google_compute_network.hello-world-network
    .name` 动态传递网络名称到子网。CloudFormation 允许您使用 `Ref` 引用参数。在 Bicep 中，您可以引用资源的 `properties`。
- en: Attribute interpolation works between modules or resources in a configuration.
    However, interpolation works for only specific tools and not necessarily across
    tools. When you have more resources and modules in composition, you cannot use
    interpolation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中的模块或资源之间可以进行属性插值。然而，插值仅适用于特定工具，并不一定适用于所有工具。当在组合中有更多资源和模块时，您不能使用插值。
- en: One alternative to attribute interpolation uses explicit module outputs to pass
    resource attributes between modules. You can customize outputs to any schema or
    parameters you need. For example, you can group the subnet and network into one
    module and export its attributes for the server to use. Let’s refactor the subnet
    and network and add the server, as in the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 属性插值的另一种替代方法是使用显式的模块输出在模块之间传递资源属性。您可以自定义输出以符合任何所需的模式或参数。例如，您可以将子网和网络组合到一个模块中，并导出其属性以供服务器使用。让我们重构子网和网络，并添加服务器，如下所示。
- en: Listing 4.4 Setting the subnet name as the output for a module
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 将子网名称设置为模块的输出
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Network and subnet objects omitted for clarity
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为了清晰起见省略了网络和子网对象
- en: ❷ Refactors network and subnet creation into a module. This follows the composite
    pattern. The module creates the Google network and subnet using Terraform resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将网络和子网创建重构为一个模块。这遵循了组合模式。该模块使用 Terraform 资源创建 Google 网络和子网。
- en: ❸ Uses the module to create the JSON configuration for the network and subnet
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用模块创建网络和子网的 JSON 配置
- en: ❹ Creates a nested class for the network module output. The nested class exports
    the name of the subnet for high-level attributes to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为网络模块输出创建一个嵌套类。该嵌套类导出子网名称，以便高级属性可以使用。
- en: ❺ Creates an output function for the network module to retrieve and export all
    network outputs
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为网络模块创建一个输出函数，以检索和导出所有网络输出
- en: ❻ This module creates the Google compute instance (server) using a Terraform
    resource.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 此模块使用 Terraform 资源创建 Google 计算实例（服务器）。
- en: ❼ Passes the network outputs as an input variable for the server module. The
    server will choose the attributes it needs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将网络输出作为输入变量传递给服务器模块。服务器将选择它需要的属性。
- en: ❽ Using the network output object, gets the subnet name and sets it to the server’s
    subnet name attribute
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 使用网络输出对象，获取子网名称并将其设置为服务器的子网名称属性
- en: ❾ Uses the module to create the JSON configuration for the server
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使用模块创建服务器的 JSON 配置
- en: ❿ Refactors network and subnet creation into a module. This follows the composite
    pattern. The module creates the Google network and subnet using Terraform resources.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 将网络和子网创建重构为一个模块。这遵循了组合模式。该模块使用 Terraform 资源创建 Google 网络和子网。
- en: ⓫ Merges the network and server JSON objects into a Terraform-compatible JSON
    structure
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将网络和服务器 JSON 对象合并为 Terraform 兼容的 JSON 结构
- en: ⓬ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 将 Python 字典写入 JSON 文件，供 Terraform 后续执行
- en: Domain-specific languages
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 专用领域语言
- en: For a provisioning tool like CloudFormation, Bicep, or Terraform, you generate
    outputs for modules or stacks that higher-level ones can consume. A configuration
    management tool such as Ansible passes variables by standard output between automation
    tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 CloudFormation、Bicep 或 Terraform 这样的配置工具，您为模块或堆栈生成输出，以便高级工具可以消费。例如，Ansible
    这样的配置管理工具通过标准输出在自动化任务之间传递变量。
- en: Module outputs help expose specific parameters for high-level resources. The
    approach copies and repeats the values. However, module outputs can get complicated!
    You’ll often forget which outputs you exposed and their names. Contract testing
    in chapter 6 might help you enforce required module outputs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模块输出有助于暴露高级资源的特定参数。这种方法复制并重复值。然而，模块输出可能会变得复杂！您通常会忘记您暴露了哪些输出以及它们的名称。第 6 章中的合同测试可能有助于您强制执行所需的模块输出。
- en: Rather than use outputs, you can use infrastructure state as a state file or
    infrastructure provider’s API metadata. Many tools keep a copy of the infrastructure
    state, which I call *tool state*, to detect drift between actual resource state
    and configuration and track which resources it manages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用输出，您可以使用基础设施状态作为状态文件或基础设施提供者的 API 元数据。许多工具保留基础设施状态的一个副本，我称之为 *工具状态*，以检测实际资源状态与配置之间的偏差，并跟踪它管理的资源。
- en: Definition *Tool state* is a representation of infrastructure state stored by
    an IaC tool. It tracks the configuration of resources managed by the tool.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *工具状态* 是 IaC 工具存储的基础设施状态表示。它跟踪工具管理的资源配置。
- en: Tools often store their state in a file. You already encountered an example
    of using tool state in listing 4.2\. You parsed the name of the network from a
    file called terraform.tfstate, which is the tool state for Terraform. However,
    not all tools offer a state file. As a result, you may have difficulty parsing
    low-level resource attributes across tools.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 工具通常将它们的状态存储在文件中。您已经在列表 4.2 中遇到了使用工具状态的例子。您从名为 terraform.tfstate 的文件中解析了网络名称，这是
    Terraform 的工具状态。然而，并非所有工具都提供状态文件。因此，您可能难以在工具之间解析低级资源属性。
- en: If you have multiple tools and providers in your system, you have two main options.
    First, consider using a configuration manager as a standard interface to pass
    metadata. A *configuration manager*, like a key-value store, manages a set of
    fields and their values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统中有多达多个工具和提供者，您有两个主要选项。首先，考虑使用配置管理器作为标准接口来传递元数据。*配置管理器*，如键值存储，管理一组字段及其值。
- en: The configuration manager helps you create your own abstraction layer for tool
    state. For example, some network automation scripts might read IP address values
    stored in a key-value store. However, you have to maintain the configuration manager
    and make sure your IaC can access it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理器帮助您为工具状态创建自己的抽象层。例如，一些网络自动化脚本可能读取存储在键值存储中的 IP 地址值。但是，您必须维护配置管理器，并确保您的 IaC
    可以访问它。
- en: As a second option, consider using an infrastructure provider’s API. Infrastructure
    APIs do not often change; they provide detailed information and account for out-of-band
    changes that a state file may not include. You can use client libraries to access
    information from infrastructure APIs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个选项，考虑使用基础设施提供者的 API。基础设施 API 不常更改；它们提供详细的信息，并考虑到状态文件可能不包括的带外更改。您可以使用客户端库从基础设施
    API 中访问信息。
- en: Domain-specific languages
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 专用领域语言
- en: Many provisioning tools offer a capability to make API calls to an infrastructure
    API. For example, AWS-specific parameter types and `Fn::ImportValue` in CloudFormation
    retrieve values from the AWS API or other stacks. Bicep offers a keyword called
    `existing` to import resource properties outside of the current file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多配置工具提供了一种能力，可以向基础设施 API 发起 API 调用。例如，AWS 特定的参数类型和 CloudFormation 中的 `Fn::ImportValue`
    从 AWS API 或其他堆栈检索值。Bicep 提供了一个名为 `existing` 的关键字，用于导入当前文件之外的资源属性。
- en: Terraform offers data sources to read metadata on an infrastructure resource
    from the API. Similarly, a module can reference Ansible facts, which gather metadata
    about a resource or your environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 提供数据源，可以从 API 中读取基础设施资源的元数据。同样，模块可以引用 Ansible 事实，这些事实收集有关资源或您环境的元数据。
- en: You will encounter a few downsides to using the infrastructure API. Unfortunately,
    your IaC needs network access. You won’t know the *value* of the attribute until
    you run the IaC because the code must make a request to the API. If the infrastructure
    API experiences an outage, your IaC may not resolve attributes for low-level resources.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施API时，您会遇到一些缺点。不幸的是，您的IaC需要网络访问。您只有在运行IaC之后才知道属性的*值*，因为代码必须向API发出请求。如果基础设施API出现故障，您的IaC可能无法解析低级资源的属性。
- en: 'When you add an abstraction with dependency inversion, you protect high-level
    resources from changing attributes on lower-level resources. While you can’t prevent
    all failures or disruptions, you minimize the blast radius of potential failures
    due to updated low-level resources. Think of it as a contract: if both high- and
    low-level resources agree on the attributes they need, they can evolve independently
    of one another.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用依赖反转添加抽象时，您会保护高级资源免受低级资源属性更改的影响。虽然您不能防止所有故障或中断，但您可以通过更新低级资源最小化潜在故障的破坏范围。将其视为一项合同：如果高级和低级资源就它们需要的属性达成一致，它们可以独立于彼此发展。
- en: 4.2.3 Applying dependency injection
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 应用依赖注入
- en: What happens when you combine inversion of control and dependency inversion?
    Figure 4.6 shows how you can combine both principles to decouple the server and
    network example. The server calls the network for attributes and parses the metadata
    using the infrastructure API or state. If you make changes to the network name,
    it updates the metadata. The server retrieves the updated metadata and adjusts
    its configuration separately.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您结合控制反转和依赖反转时会发生什么？图4.6显示了如何结合这两个原则来解耦服务器和网络示例。服务器调用网络以获取属性，并使用基础设施API或状态解析元数据。如果您更改网络名称，它将更新元数据。服务器检索更新后的元数据并单独调整其配置。
- en: '![](../../OEBPS/Images/CH04_F06_Wang.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F06_Wang.png)'
- en: Figure 4.6 Dependency injection combines inversion of control and dependency
    inversion to loosen infrastructure dependencies and isolate low-level and high-level
    resources.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 依赖注入结合了控制反转和控制依赖反转，以放宽基础设施依赖并隔离低级和高级资源。
- en: Harnessing the power of both principles helps promote evolution and composability
    because the abstraction layer behaves as a buffer between each building block
    of your system. You use *dependency injection* to combine inversion of control
    and dependency inversion. Inversion of control isolates changes to the high-level
    modules or resources, while dependency inversion isolates changes to the low-level
    resources.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这两个原则的力量有助于促进演化和可组合性，因为抽象层充当系统每个构建块之间的缓冲区。您使用 *依赖注入* 来结合控制反转和依赖反转。控制反转隔离了高级模块或资源的更改，而依赖反转隔离了低级资源的更改。
- en: Definition *Dependency injection* combines the principles of inversion of control
    and dependency inversion. High-level modules or resources call for attributes
    from low-level ones through an abstraction.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *依赖注入* 结合了控制反转和控制依赖反转的原则。高级模块或资源通过抽象从低级资源请求属性。
- en: Let’s implement dependency injection for the server and network example with
    Apache Libcloud, a library for the GCP API, as shown in listing 4.5\. You use
    Libcloud to search for the network. The server calls the GCP API for the subnet
    name, parses the GCP API metadata, and assigns itself the fifth IP address in
    the network’s range.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Apache Libcloud库为服务器和网络示例实现依赖注入，Apache Libcloud是一个用于GCP API的库，如列表4.5所示。您使用Libcloud来搜索网络。服务器调用GCP
    API获取子网名称，解析GCP API元数据，并将网络范围内的第五个IP地址分配给自己。
- en: Listing 4.5 Using dependency injection to create a server on a network
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 使用依赖注入在网络上创建服务器
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Imports the Libcloud library, which allows you to access the GCP API. You
    must import the provider object and Google driver.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入Libcloud库，该库允许您访问GCP API。您必须导入提供者对象和Google驱动程序。
- en: ❷ This function retrieves the network information using the Libcloud library.
    The network and subnet were created separately. Their code has been omitted for
    clarity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数使用Libcloud库检索网络信息。网络和子网是分别创建的。为了清晰起见，它们的代码已被省略。
- en: ❸ Imports the Google Compute Engine driver for Libcloud
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导入Libcloud的Google Compute Engine驱动程序
- en: ❹ Passes the GCP service account credentials you want Libcloud to use for accessing
    the GCP API
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将您希望Libcloud用于访问GCP API的GCP服务帐户凭据传递过去
- en: ❺ Uses the Libcloud driver to get the subnet information by its name
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用Libcloud驱动程序通过名称获取子网信息
- en: ❻ This module creates the Google compute instance (server) using a Terraform
    resource
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 此模块使用Terraform资源创建Google计算实例（服务器）
- en: ❼ Parses the subnet name from the GCP network object returned by Libcloud and
    uses it to create the server
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 从Libcloud返回的GCP网络对象中解析子网名称，并使用它来创建服务器
- en: ❽ Parses the CIDR block from the GCP network object returned by Libcloud and
    uses it to calculate the fifth IP address on the network. The server uses the
    result as its network IP address.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 从Libcloud返回的GCP网络对象中解析CIDR块，并使用它来计算网络上的第五个IP地址。服务器使用此结果作为其网络IP地址。
- en: ❾ Uses the module to create the JSON configuration for the server
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使用该模块创建服务器的JSON配置
- en: ❿ Parses the subnet name from the GCP network object returned by Libcloud and
    uses it to create the server
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 从Libcloud返回的GCP网络对象中解析子网名称，并使用它来创建服务器
- en: ⓫ Parses the CIDR block from the GCP network object returned by Libcloud and
    uses it to calculate the fifth IP address on the network. The server uses the
    result as its network IP address.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 从Libcloud返回的GCP网络对象中解析CIDR块，并使用它来计算网络上的第五个IP地址。服务器使用此结果作为其网络IP地址。
- en: ⓬ This module creates the Google compute instance (server) using a Terraform
    resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 此模块使用Terraform资源创建Google计算实例（服务器）。
- en: ⓭ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 将Python字典写入JSON文件，供Terraform稍后执行
- en: AWS and Azure equivalents
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure等效
- en: To convert listing 4.5, you need to update the IaC to create an Amazon Elastic
    Compute Cloud (EC2) instance or Azure Linux virtual machine. You need to update
    the Libcloud driver to use Amazon EC2 Driver ([http://mng.bz/wo95](http://mng.bz/wo95))
    or Azure ARM Compute Driver ([http://mng.bz/qY9x](http://mng.bz/qY9x)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换列表4.5，你需要更新IaC以创建Amazon Elastic Compute Cloud (EC2)实例或Azure Linux虚拟机。你需要更新Libcloud驱动程序以使用Amazon
    EC2 Driver ([http://mng.bz/wo95](http://mng.bz/wo95))或Azure ARM Compute Driver
    ([http://mng.bz/qY9x](http://mng.bz/qY9x))。
- en: Using the infrastructure API as an abstraction layer, you account for the evolution
    of the network independent of the server. For example, what happens when you change
    the IP address range for the network? You deploy the update to the network before
    you run the IaC for the server. The server calls the infrastructure API for network
    attributes and recognizes a new IP address range. Then it recalculates the fifth
    IP address.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施API作为抽象层，你可以独立于服务器进化网络。例如，当你更改网络的IP地址范围时会发生什么？在运行服务器的IaC之前，你将更新部署到网络的更新。服务器调用基础设施API以获取网络属性，并识别新的IP地址范围。然后它重新计算第五个IP地址。
- en: Figure 4.7 shows the responsiveness of the server to the change because of dependency
    injection. When you change the IP address range for the network, your server gets
    the updated address range and reallocates the IP address if needed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7显示了由于依赖注入而导致的服务器对变化的响应。当你更改网络的IP地址范围时，你的服务器会获取更新的地址范围，并在需要时重新分配IP地址。
- en: '![](../../OEBPS/Images/CH04_F07_Wang.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F07_Wang.png)'
- en: Figure 4.7 Dependency injection allows me to change the low-level module (the
    network) and automatically propagate the change to the high-level module (the
    server).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 依赖注入允许我更改低级模块（网络）并自动将更改传播到高级模块（服务器）。
- en: Thanks to dependency inversion, you can evolve low-level resources separately
    from dependencies. Inversion of control helps high-level resources respond to
    changes in low-level resources. Combining the two as dependency injection ensures
    the composability of the system, as you can add more high-level resources on the
    low-level ones. Decoupling due to dependency injection helps you minimize the
    blast radius of failed changes across modules in your system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了依赖反转，你可以独立于依赖关系进化低级资源。控制反转有助于高级资源响应低级资源的变化。将两者结合为依赖注入确保了系统的可组合性，因为你可以向低级资源添加更多高级资源。由于依赖注入导致的解耦有助于你最小化系统模块中失败更改的爆炸半径。
- en: In general, you should apply dependency injection as an essential principle
    for infrastructure dependency management. If you apply dependency injection when
    you write your infrastructure configuration, you sufficiently decouple dependencies
    so that you can change them independently without affecting other infrastructure.
    As your module grows, you can continue to refactor to more specific patterns and
    further decouple infrastructure based on the type of resources and modules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该将依赖注入作为基础设施依赖管理的基本原则。如果你在编写基础设施配置时应用依赖注入，你就可以充分解耦依赖关系，以便你可以独立地更改它们而不会影响其他基础设施。随着你的模块增长，你可以继续重构以使用更具体的模式，并进一步根据资源类型和模块类型解耦基础设施。
- en: 4.3 Facade
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 外观模式
- en: Applying the principle of dependency injection generates similar patterns for
    expressing dependencies. The patterns align with structural design patterns in
    software development. In the pursuit of decoupling dependencies, I often find
    myself repeating the same three patterns in my IaC.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应用依赖注入原则生成表达依赖关系的类似模式。这些模式与软件开发中的结构设计模式相一致。在追求解耦依赖的过程中，我经常在我的基础设施即代码（IaC）中重复使用相同的三个模式。
- en: Imagine you want to create a storage bucket to store static files. You can control
    who accesses the files with an access control API in GCP. Figure 4.8 creates the
    bucket and sets the outputs to include the bucket’s name. The access control rules
    for the bucket can use the outputs to get the bucket’s name.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要创建一个存储桶来存储静态文件。你可以使用 GCP 中的访问控制 API 来控制谁可以访问文件。图 4.8 创建了桶并设置输出以包括桶的名称。桶的访问控制规则可以使用输出获取桶的名称。
- en: '![](../../OEBPS/Images/CH04_F08_Wang.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F08_Wang.png)'
- en: Figure 4.8 The facade simplifies attributes to the name of the storage bucket
    for use by the access control module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 外观模式简化了属性，将其作为存储桶的名称供访问控制模块使用。
- en: The pattern of using outputs and an abstraction layer seems *very* familiar.
    In fact, you encountered it in the chapter’s first half. You’ve been unknowingly
    using the facade pattern to pass multiple attributes between modules!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输出和抽象层的模式看起来 *非常熟悉*。实际上，你在章节的前半部分就遇到了它。你一直在不知不觉中使用外观模式在模块之间传递多个属性！
- en: The *facade pattern* uses module outputs as the abstraction for dependency injection.
    It behaves like a mirror, reflecting the attributes to other modules and resources.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*外观模式* 使用模块输出作为依赖注入的抽象。它像一个镜子，将属性反射到其他模块和资源。'
- en: Definition The *facade pattern* outputs attributes from resources in a module
    for dependency injection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *外观模式* 从模块的资源中输出属性以进行依赖注入。
- en: A facade reflects the attributes and nothing more. The pattern does decouple
    dependencies between high- and low-level resources and conforms to the principle
    of dependency injection. The high-level resource still calls the low-level resource
    for information, and outputs serve as the abstraction.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式只反映属性，没有更多。该模式解耦了高层和底层资源之间的依赖关系，并符合依赖注入的原则。高层资源仍然调用底层资源以获取信息，而输出充当抽象。
- en: The following listing implements the facade pattern in code by building an output
    method. Your bucket module returns the bucket object and name in its output method.
    Your access module uses the output method to retrieve the bucket object and access
    its name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例通过构建一个输出方法实现了外观模式。你的桶模块在其输出方法中返回桶对象和名称。你的访问模块使用输出方法来检索桶对象并访问其名称。
- en: Listing 4.6 Outputting the bucket name as a facade for access control rules
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 将桶名称作为外观用于访问控制规则
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Using the facade pattern, outputs the bucket name as part of the storage output
    object. This implements dependency inversion to abstract away unnecessary bucket
    attributes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用外观模式，将桶名称作为存储输出对象的一部分输出。这实现了依赖反转，以抽象掉不必要的桶属性。
- en: ❷ Creates a low-level module for the GCP storage bucket, which uses the factory
    pattern to generate a bucket
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为 GCP 存储桶创建一个低级模块，该模块使用工厂模式生成一个桶
- en: ❸ Creates the Google storage bucket using a Terraform resource based on the
    name and location
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用基于名称和位置的 Terraform 资源创建 Google 存储桶
- en: ❹ Sets an attribute on the Google storage bucket to destroy it when you delete
    Terraform resources
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 Google 存储桶上设置一个属性，当删除 Terraform 资源时销毁它
- en: ❺ Creates an output method for the module that returns a list of attributes
    for the storage bucket
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为模块创建一个输出方法，返回存储桶的属性列表
- en: ❻ Creates a high-level module to add access control rules to the storage bucket
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 创建一个高级模块，向存储桶添加访问控制规则
- en: ❼ Passes the bucket’s output facade to the high-level module
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将桶的输出外观传递给高级模块
- en: ❽ Validates that the users passed to the module match valid user group types
    for all users or all authenticated users
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 验证传递给模块的用户是否与所有用户或所有认证用户的有效用户组类型匹配
- en: ❾ Validates that the roles passed to the module match valid roles in GCP
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 验证传递给模块的角色是否与GCP中的有效角色匹配
- en: ❿ Creates Google storage bucket access control rules using a Terraform resource
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 使用Terraform资源创建Google存储桶访问控制规则
- en: AWS and Azure equivalents
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AWS和Azure的等效产品
- en: A GCP storage bucket is similar to an Amazon Simple Storage Service (S3) bucket
    or Azure Blob Storage.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Google云平台（GCP）存储桶类似于Amazon Simple Storage Service（S3）桶或Azure Blob Storage。
- en: Why output the entire bucket object and not just the name? Remember that you
    want to build an abstraction layer to conform to the principle of dependency inversion.
    If you create a new module that depends on the bucket location, you can update
    the bucket object’s facade to output the name and location. The update does not
    affect the access module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么输出整个桶对象而不是只输出名称？记住，你想要构建一个抽象层，以符合依赖反转原则。如果你创建了一个依赖于桶位置的模块，你可以更新桶对象的外观以输出名称和位置。更新不会影响访问模块。
- en: You can implement a facade with low effort and still get the benefits from decoupling
    of dependencies. One such benefit includes the flexibility to make isolated, self-contained
    updates in one module without affecting others. Adding new high-level dependencies
    does not require much effort.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以低努力成本实现外观，同时仍然从依赖解耦中获得好处。这样的好处之一包括在一个模块中执行隔离、自包含更新而不会影响其他模块的灵活性。添加新的高级依赖关系不需要太多努力。
- en: The facade pattern also makes it easier to debug problems. It mirrors the outputs
    without adding logic for parsing, making it simple to trace problems to the source
    and fix the system. You’ll learn more about reverting failed changes in chapter
    11.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式还使得调试问题更加容易。它镜像输出而不添加解析逻辑，这使得追踪问题到源头并修复系统变得简单。你将在第11章中了解更多关于回滚失败更改的内容。
- en: Domain-specific languages
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Using a DSL, you can mimic a facade by using an output variable with a customized
    name. The high-level resource references the customized output names.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用领域特定语言（DSL），你可以通过使用具有自定义名称的输出变量来模拟外观。高级资源引用自定义输出名称。
- en: As a general practice, you’ll start a facade with one or two fields. Always
    keep this to the minimum number of fields you’ll need for high-level resources.
    Review and prune the fields when you don’t need them every few weeks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般做法，你应该从一个或两个字段开始创建外观。始终将其保持为所需的最小字段数，用于高级资源。每几周审查并修剪不需要的字段。
- en: The facade pattern works for simpler dependencies, such as a few high-level
    modules to one low-level one. However, when you add many high-level modules and
    the depth of your dependencies increases, you will have difficulty maintaining
    the facade pattern for the low-level modules. When you need to change a field
    name in the output, you must change every module that references it. Changing
    every module reference does not scale when you have hundreds of resources that
    depend on one low-level module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式适用于更简单的依赖关系，例如几个高级模块到一个低级模块。然而，当你添加许多高级模块并且依赖关系的深度增加时，你将难以维护低级模块的外观模式。当你需要更改输出中的字段名称时，你必须更改引用它的每个模块。当你有数百个资源依赖于一个低级模块时，更改每个模块引用的缩放性不好。
- en: 4.4 Adapter
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 适配器
- en: The facade mirrors the values as outputs for one infrastructure module to high-level
    modules in the previous section. It works well for simple dependency relationships
    but falls apart with more complex modules. More complex modules usually involve
    one-to-many dependencies or span multiple infrastructure providers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 外观将一个基础设施模块的值作为输出镜像到上一节的高级模块。这对于简单的依赖关系工作良好，但在更复杂的模块中会崩溃。更复杂的模块通常涉及一对一或多对一的依赖关系，或者跨越多个基础设施提供者。
- en: Let’s say you have an identity module that passes a list of users and roles
    for configuring infrastructure. The identity module needs to work across multiple
    platforms. In figure 4.9, you set up the module to output a JSON-formatted object
    that maps permissions such as `read`, `write`, or `admin` with the corresponding
    usernames. Teams must map these usernames and their generic permissions to GCP-specific
    terms. GCP’s access management uses `viewer`, `editor`, and `owner`, which transform
    to `read`, `write`, and `admin`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个身份模块，它传递一个用户和角色的列表来配置基础设施。该身份模块需要在多个平台上工作。在图 4.9 中，你设置模块以输出一个 JSON 格式的对象，将权限如
    `read`、`write` 或 `admin` 与相应的用户名相对应。团队必须将这些用户名及其通用权限映射到 GCP 特定的术语。GCP 的访问管理使用
    `viewer`、`editor` 和 `owner`，它们分别转换为 `read`、`write` 和 `admin`。
- en: '![](../../OEBPS/Images/CH04_F09_Wang.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F09_Wang.png)'
- en: Figure 4.9 The adapter pattern transforms attributes to a different interface
    that high-level modules can consume.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 适配器模式将属性转换为高级模块可以消费的不同接口。
- en: How do you map a generic set of roles to the specific infrastructure provider
    roles? The mapping needs to ensure that you can reproduce and evolve the module
    over multiple infrastructure providers. You want to extend the module in the future
    to add users to equivalent roles across platforms.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将一组通用角色映射到特定基础设施提供商的角色？映射需要确保你可以在多个基础设施提供商上复制和扩展模块。你希望在将来扩展模块，以添加跨平台的等效角色中的用户。
- en: As a solution, the *adapter pattern* transforms metadata from the low-level
    resource so that any high-level resource can use it. An adapter behaves like a
    travel plug. You can change the plug depending on the country’s outlet and still
    use your electronic devices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决方案，*适配器模式* 将低级资源的元数据转换，以便任何高级资源都可以使用它。适配器的作用就像旅行插头。你可以根据国家的插座更换插头，仍然可以使用你的电子设备。
- en: Definition The *adapter pattern* transforms and outputs metadata from the low-level
    resource or module so any high-level resource or module can use it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *适配器模式* 将低级资源或模块的元数据转换并输出，以便任何高级资源或模块都可以使用它。
- en: To start, you create a dictionary that maps generic role names to users. In
    listing 4.7, you want to assign a read-only role to the audit team and two users.
    These generic roles and usernames do not match any of the GCP permissions and
    roles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个字典，将通用角色名称映射到用户。在列表 4.7 中，你想要将只读角色分配给审计团队和两个用户。这些通用角色和用户名与 GCP 的权限和角色不匹配。
- en: Listing 4.7 Creating a static object that maps generic roles to usernames
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 创建将通用角色映射到用户名的静态对象
- en: '[PRE6]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Assigns the audit-team, user-01, and user-02 to a read-only role. The mapping
    describes that the user can only read information on any infrastructure provider.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 audit-team、user-01 和 user-02 分配到只读角色。映射描述了用户只能读取任何基础设施提供商上的信息。
- en: ❷ Assigns the infrastructure-team, user-02, and automation-01 to a write role.
    The mapping describes that the user can update information on any infrastructure
    provider.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 infrastructure-team、user-02 和 automation-01 分配到写角色。映射描述了用户可以更新任何基础设施提供商上的信息。
- en: ❸ Assigns the manager team to the administrator role. The mapping describes
    that the user can manage any infrastructure provider.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 manager team 分配到管理员角色。映射描述了用户可以管理任何基础设施提供商。
- en: AWS and Azure equivalents
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 的等效项
- en: For those more familiar with AWS, the equivalent policies for each permission
    set would be `AdministratorAccess` for `admin`, `PowerUserAccess` for `write`,
    and `ViewOnlyAccess` for `read`. Azure role-based access control uses `Owner`
    for `admin`, `Contributor` for `write`, and `Reader` for `read`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更熟悉 AWS 的人来说，每个权限集的等效策略将是 `admin` 的 `AdministratorAccess`，`write` 的 `PowerUserAccess`，以及
    `read` 的 `ViewOnlyAccess`。Azure 基于角色的访问控制使用 `Owner` 代表 `admin`，`Contributor` 代表
    `write`，`Reader` 代表 `read`。
- en: However, you cannot do anything with the static object in role mappings. GCP
    does not understand the usernames or roles! Implement the adapter pattern to map
    generic permissions to the infrastructure-specific permissions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你无法在角色映射中的静态对象上做任何事情。GCP 不理解用户名或角色！实现适配器模式以将通用权限映射到特定于基础设施的权限。
- en: The following listing builds an identity adapter specific to GCP, which maps
    generic permissions like `read` to GCP-specific terms like `roles/viewer`. GCP
    can use the map to add users, service accounts, and groups to the correct roles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表构建了一个针对 GCP 特定的身份适配器，它将通用权限如 `read` 映射到 GCP 特定的术语如 `roles/viewer`。GCP 可以使用此映射将用户、服务帐户和组添加到正确的角色中。
- en: Listing 4.8 Using the adapter pattern to transform generic permissions
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 使用适配器模式转换通用权限
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates an adapter to map generic role types to Google role types
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个适配器，将通用角色类型映射到 Google 角色类型
- en: ❷ Sets the email domain as a constant, which you’ll append to each user
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将电子邮件域名设置为常量，您将将其附加到每个用户
- en: ❸ Creates a dictionary to map generic roles to GCP-specific permissions and
    roles
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个字典，将通用角色映射到 GCP 特定权限和角色
- en: ❹ For each permission and user, builds a tuple with the user, GCP identity,
    and role
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于每个权限和用户，构建一个包含用户、GCP 身份和角色的元组
- en: ❺ Transforms the usernames to GCP-specific member terminology, which uses user
    type and email address
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将用户名转换为 GCP 特定的成员术语，该术语使用用户类型和电子邮件地址
- en: ❻ If the username has “team,” the GCP identity needs to be prefixed with “group”
    and suffixed with the email domain.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果用户名包含“团队”，则 GCP 身份需要以“group”为前缀，以电子邮件域为后缀。
- en: ❼ If the username has “automation,” the GCP identity needs to be prefixed with
    “serviceAccount” and suffixed with the email domain.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果用户名包含“自动化”，则 GCP 身份需要以“serviceAccount”为前缀，以电子邮件域为后缀。
- en: ❽ For all other users, the GCP identity needs to be prefixed with “user” and
    suffixed with the email domain.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 对于所有其他用户，GCP 身份需要以“user”为前缀，以电子邮件域为后缀。
- en: ❾ Outputs the list of tuples containing the users, GCP identities, and roles
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出包含用户、GCP 身份和角色的元组列表
- en: ❿ Creates a module for the GCP project users, which uses the factory pattern
    to attach users to GCP roles for a given project
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 创建一个 GCP 项目用户模块，该模块使用工厂模式将用户附加到给定项目的 GCP 角色中
- en: ⓫ Uses the module to create the JSON configuration for the project’s users and
    roles
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 使用该模块创建项目的用户和角色的 JSON 配置
- en: ⓬ Creates a dictionary to map generic roles to GCP-specific permissions and
    roles
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 创建一个字典，将通用角色映射到 GCP 特定权限和角色
- en: ⓭ Creates a list of Google project IAM members using a Terraform resource. The
    list retrieves the GCP identity, role, and project to attach a username to read,
    write, or administrator permissions in GCP.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 使用 Terraform 资源创建一个 Google 项目 IAM 成员列表。该列表检索 GCP 身份、角色和项目，以便将用户名附加到 GCP 中的读取、写入或管理员权限。
- en: ⓮ Creates an adapter to map generic role types to Google role types
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 创建一个适配器，将通用角色类型映射到 Google 角色类型
- en: ⓯ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⓯ 将 Python 字典写入 JSON 文件，以便 Terraform 后续执行
- en: AWS and Azure equivalents
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: To convert the code listing to AWS, you would map references to the GCP project
    to an AWS account. GCP project users align with an AWS IAM user and their attached
    roles. Similarly, you would create an Azure subscription and add a user account
    and their API permissions in Azure Active Directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码列表转换为 AWS，您需要将 GCP 项目的引用映射到 AWS 账户。GCP 项目用户与 AWS IAM 用户及其附加的角色相对应。同样，您会在
    Azure 订阅中创建一个用户账户，并在 Azure Active Directory 中添加其 API 权限。
- en: You could extend your identity adapter to map the generic dictionary of access
    requirements to another infrastructure provider, like AWS or Azure. In general,
    an adapter translates the provider-specific or prototype module-specific language
    into generic terms. This pattern works best for modules with different infrastructure
    providers or dependencies. I also use the adapter pattern to create a consistent
    interface for infrastructure providers with poorly defined resource parameters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将您的身份适配器扩展到将通用访问要求字典映射到另一个基础设施提供者，如 AWS 或 Azure。一般来说，适配器将特定提供者或原型模块特定的语言转换为通用术语。此模式最适合具有不同基础设施提供者或依赖项的模块。我还使用适配器模式为资源参数定义不佳的基础设施提供者创建一个一致的接口。
- en: For a more complex example, imagine configuring a virtual private network (VPN)
    connection between two clouds. Instead of passing network information from each
    provider through a facade, you use an adapter, as in figure 4.10\. Your network
    modules for each provider output a network object with more general fields, such
    as `name` and `IP` `address`. This use case benefits from an adapter because it
    reconciles the semantics of two different languages (e.g., a GCP Cloud VPN gateway
    and AWS customer gateway).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更复杂的示例，想象配置两个云之间的虚拟专用网络（VPN）连接。而不是通过外观传递每个提供者的网络信息，您使用适配器，如图 4.10 所示。每个提供者的网络模块输出一个具有更通用字段（如
    `name` 和 `IP` `address`）的网络对象。此用例受益于适配器，因为它协调了两种不同语言的语义（例如，GCP 云 VPN 网关和 AWS 客户端网关）。
- en: '![](../../OEBPS/Images/CH04_F10_Wang.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F10_Wang.png)'
- en: Figure 4.10 An adapter translates language and attributes between two cloud
    providers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 一个适配器在两个云服务提供商之间转换语言和属性。
- en: Azure equivalent
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Azure等效
- en: An Azure VPN gateway achieves similar functionality to an AWS customer gateway
    and GCP Cloud VPN gateway.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Azure VPN网关实现了与AWS客户网关和GCP云VPN网关类似的功能。
- en: Why use an adapter to promote composability and evolvability? The pattern heavily
    relies on dependency inversion to abstract any transformation of attributes between
    resources. An adapter behaves as a contract between modules. As long as both modules
    agree on the contract outlined by the adapter, you can continue to change high-level
    and low-level modules somewhat independently of each other.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用适配器来提高可组合性和可扩展性？该模式严重依赖于依赖反转来抽象资源之间任何属性转换。适配器充当模块间的契约。只要两个模块都同意适配器概述的契约，你就可以在一定程度上独立地更改高级和低级模块。
- en: Domain-specific languages
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 专用领域语言
- en: A DSL translates the provider- or resource-specific language or resource. DSLs
    implement an adapter within their framework to represent infrastructure state.
    Infrastructure state often includes the same resource metadata as the infrastructure
    API. Some tools will allow you to interface with the state file and treat the
    schema as an adapter for high-level modules.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 专用领域语言（DSL）将提供者或资源特定的语言或资源进行转换。DSL在它们的框架内实现适配器，以表示基础设施状态。基础设施状态通常包括与基础设施API相同的资源元数据。一些工具将允许你与状态文件接口，并将模式视为高级模块的适配器。
- en: However, the adapter pattern works only if you *maintain the contract* between
    modules. Recall that you built an adapter to transform permissions and usernames
    to GCP. What happens if your teammate accidentally updates the mapping for read-only
    roles to `roles/reader`, which doesn’t exist? Figure 4.11 demonstrates that if
    you don’t use the right role specific to GCP, your IaC fails.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，适配器模式仅在您*维护模块间的契约*时才有效。回想一下，你构建了一个适配器来将权限和用户名转换为GCP。如果你的队友不小心将只读角色的映射更新为`roles/reader`，而这个角色不存在，会发生什么？图4.11展示了如果你不使用针对GCP的特定角色，你的基础设施即代码（IaC）将失败。
- en: '![](../../OEBPS/Images/CH04_F11_Wang.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH04_F11_Wang.png)'
- en: Figure 4.11 You need to troubleshoot and test the adapter to map the fields
    correctly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 你需要调试和测试适配器以正确映射字段。
- en: In the example, you broke the contract between the generic and GCP roles! The
    broken contract causes your IaC to fail. Make sure you maintain and update the
    correct mappings in your adapter to minimize failure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你破坏了通用角色和GCP角色之间的契约！破坏的契约导致你的IaC失败。确保你维护并更新适配器中的正确映射，以最大限度地减少失败。
- en: Furthermore, troubleshooting becomes more difficult with an adapter. The pattern
    obfuscates the resources depending on a specific adapter attribute. You need to
    investigate whether an error results from the wrong field output from the source
    module, an incorrect attribute in the adapter, or the wrong field consumed by
    the dependent module. Module versioning and testing in chapters 5 and 6, respectively,
    can alleviate the challenges and troubleshooting of an adapter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用适配器后，调试变得更加困难。该模式模糊了依赖于特定适配器属性的资源。你需要调查错误是否由源模块输出的错误字段、适配器中的错误属性或依赖模块消费的错误字段引起的。第5章和第6章分别介绍了模块版本控制和测试，可以缓解适配器的挑战和调试问题。
- en: 4.5 Mediator
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 中介者
- en: The adapter and facade patterns isolate changes and make it easy to manage one
    dependency. However, IaC often includes complex resource dependencies. To detangle
    the web of dependencies, you can build opinionated automation that structures
    when and how IaC should create resources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器和外观模式隔离了变化，并使管理单个依赖变得容易。然而，基础设施即代码（IaC）通常包括复杂的资源依赖关系。为了解开依赖关系的网，你可以构建有见地的自动化，以确定何时以及如何创建资源。
- en: Imagine you want to add a firewall rule to allow SSH to the server’s IP address
    in our canonical server and network example. However, you can create the firewall
    rule only if the server exists. Similarly, you can create the server only if the
    network exists. You need automation to capture the complexity of the relationships
    among firewall, server, and network.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要在我们的标准服务器和网络示例中添加一条防火墙规则，允许SSH访问服务器的IP地址。然而，只有当服务器存在时，你才能创建防火墙规则。同样，只有当网络存在时，你才能创建服务器。你需要自动化来捕捉防火墙、服务器和网络之间关系的复杂性。
- en: Let’s try to capture the logic of creating the network, the server, and the
    firewall. Automation can help *mediate* which resources to create first. Figure
    4.12 diagrams the workflow for the automation. If the resource is a server, IaC
    creates the network and then the server. If the resource is a firewall rule, IaC
    creates the network first, the server second, and the firewall rule third.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试捕捉创建网络、服务器和防火墙的逻辑。自动化可以帮助 *调解* 首先创建哪些资源。图 4.12 绘制了自动化的工作流程。如果资源是服务器，IaC
    首先创建网络，然后是服务器。如果资源是防火墙规则，IaC 首先创建网络，然后是服务器，最后是防火墙规则。
- en: '![](../../OEBPS/Images/CH04_F12_Wang.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F12_Wang.png)'
- en: Figure 4.12 The mediator becomes the authority on which resource to configure
    first.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 中介成为决定首先配置哪个资源的权威机构。
- en: The IaC implements dependency injection to abstract and control network, server,
    and firewall dependencies. It relies on the principle of idempotency to run continuously
    and achieve the same end state (network, server, and firewall), no matter the
    existing resources. Composability also helps establish the building blocks of
    infrastructure resources and dependencies.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: IaC 实现了依赖注入来抽象和控制网络、服务器和防火墙的依赖关系。它依赖于幂等性原则来持续运行并达到相同的目标状态（网络、服务器和防火墙），无论现有资源如何。可组合性还有助于建立基础设施资源和依赖关系的基本构建块。
- en: This *mediator pattern* works like air-traffic control at an airport. It controls
    and manages inbound and outbound flights. A mediator’s sole purpose is to organize
    the dependencies among these resources and to create or delete objects as needed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 *中介模式* 的工作方式类似于机场的空中交通管制。它控制和管理工作站的进出航班。中介的唯一目的是组织这些资源之间的依赖关系，并根据需要创建或删除对象。
- en: Definition The *mediator pattern* organizes dependencies among infrastructure
    resources and includes logic to create or delete objects based on their dependencies.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *中介模式* 组织基础设施资源之间的依赖关系，并包含基于其依赖关系创建或删除对象的逻辑。
- en: Let’s implement the mediator pattern for the network, server, and firewall.
    Implementing a mediator in Python requires a few if-else statements to check each
    resource type and build its low-level dependencies. In listing 4.9, the firewall
    depends on creating the server and the network first.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现网络、服务器和防火墙的中介模式。在 Python 中实现中介模式需要一些 if-else 语句来检查每种资源类型并构建其低级依赖。在列表 4.9
    中，防火墙依赖于首先创建服务器和网络。
- en: Listing 4.9 Using the mediator pattern to organize server and dependencies
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 使用中介模式组织服务器和依赖
- en: '[PRE8]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Imports the factory modules for the network, server, and firewall
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入网络、服务器和防火墙的工厂模块
- en: ❷ Creates a mediator to decide how and in which order to automate changes to
    resources
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个中介来决定如何以及按何种顺序自动化资源更改
- en: ❸ When you call the mediator to create a resource like a network, server, or
    firewall, you allow the mediator to decide all the resources to configure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当你调用中介来创建网络、服务器或防火墙等资源时，你允许中介决定所有要配置的资源。
- en: ❹ If you want to create a firewall rule as a resource, the mediator will recursively
    call itself to create the server first.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果你想创建一个作为资源的防火墙规则，中介将递归地调用自己以首先创建服务器。
- en: ❺ After the mediator creates the server configuration, it builds the firewall
    rule configuration.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在中介创建服务器配置后，它构建防火墙规则配置。
- en: ❻ If you want to create a server as a resource, the mediator will recursively
    call itself to create the network first.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果你想创建一个作为资源的服务器，中介将递归地调用自己以首先创建网络。
- en: ❼ After the mediator creates the network configuration, it builds the server
    configuration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在中介创建网络配置后，它构建服务器配置。
- en: ❽ If you pass any other resource to the mediator, such as the network, it will
    build its default configuration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 如果你向中介传递任何其他资源，例如网络，它将构建其默认配置。
- en: ❾ Uses the module to create a list of resources from the mediator and render
    the JSON configuration
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使用模块从中介创建资源列表并渲染 JSON 配置
- en: ❿ Passes the mediator a firewall resource. The mediator will create the network,
    server, and then the firewall configuration.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 将防火墙资源传递给中介。中介将创建网络、服务器，然后是防火墙配置。
- en: ⓫ Writes the Python dictionary to a JSON file to be executed by Terraform later
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字典写入 JSON 文件，以便 Terraform 后续执行
- en: AWS and Azure equivalents
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 的等效功能
- en: Firewall rules for GCP are similar in behavior to rules for an AWS security
    group or Azure network security group. The rules control ingress and egress traffic
    to and from IP address ranges to tagged targets.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: GCP 的防火墙规则在行为上与 AWS 安全组或 Azure 网络安全组的规则相似。这些规则控制来自和发往标记目标的 IP 地址范围的网络流量。
- en: If you have a new resource, such as a load balancer, you can expand the mediator
    to build it after the server or firewall. The mediator pattern works best with
    modules that have many levels of dependencies and multiple system components.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个新的资源，例如负载均衡器，你可以在服务器或防火墙之后扩展中介器来构建它。中介器模式最适合具有多层依赖关系和多个系统组件的模块。
- en: However, you might find the mediator challenging to implement. The mediator
    pattern must follow idempotency. You need to run multiple times and achieve the
    same target state. You have to write and test all of the logic in a mediator.
    If you do not test your mediator, you may accidentally break a resource. Writing
    your own mediator takes lots of code!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能发现实现中介器具有挑战性。中介器模式必须遵循幂等性。你需要多次运行并达到相同的目标状态。你必须编写和测试中介器中的所有逻辑。如果你不测试你的中介器，你可能会意外地破坏资源。编写自己的中介器需要大量的代码！
- en: Fortunately, you do not have to implement your own mediator often. Most IaC
    tools behave as mediators to resolve complex dependencies and decide how to create
    resources. The majority of provisioning tools have built-in mediators to identify
    dependencies and order of operations. For example, the container orchestration
    of Kubernetes uses a mediator to orchestrate changes to the resources in the cluster.
    Ansible uses a mediator to determine which automation steps to compose and run
    from various configuration modules.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你通常不需要自己实现中介器。大多数基础设施即代码（IaC）工具都充当中介器，以解决复杂的依赖关系并决定如何创建资源。大多数配置工具都内置了中介器来识别依赖关系和操作顺序。例如，Kubernetes
    的容器编排使用中介器来协调集群中资源的变更。Ansible 使用中介器来确定从各种配置模块中组合和运行哪些自动化步骤。
- en: Note Some IaC tools implement the mediator pattern by using graph theory to
    map dependencies between resources. The resources serve as nodes. Links pass attributes
    to dependent resources. If you want to create resources without a tool, you can
    manually diagram dependencies in your system. Diagrams can help organize your
    automation and code. They also identify which modules you can decouple. The exercise
    of graphing dependencies might help you implement a mediator.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些 IaC 工具通过使用图论来映射资源之间的依赖关系来实现中介器模式。资源作为节点。链接将属性传递给依赖资源。如果你没有工具来创建资源，你可以手动在你的系统中绘制依赖关系图。图可以帮助组织你的自动化和代码。它们还可以确定你可以解耦哪些模块。绘制依赖关系的练习可能有助于你实现中介器。
- en: I implement the mediator pattern only when I cannot find it in a tool or need
    something between tools. For example, I sometimes write a mediator to control
    creating a Kubernetes cluster in one tool before another tool deploys services
    on the Kubernetes cluster. A mediator reconciles automation between these two
    tools, such as checking cluster health before deploying services with the second
    tool.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我只在找不到工具或需要在工具之间添加某些内容时实现中介器模式。例如，我有时会编写一个中介器来控制在一个工具中创建 Kubernetes 集群，在另一个工具部署
    Kubernetes 集群上的服务之前。中介器协调这两个工具之间的自动化，例如在第二个工具部署服务之前检查集群健康。
- en: 4.6 Choosing a pattern
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 选择一个模式
- en: The facade, adapter, and mediator all use dependency injection to decouple changes
    between high-level and low-level modules. You can apply any of the patterns, and
    they will express dependencies between modules and isolate changes within them.
    As your system grows, you may need to change these patterns depending on the structure
    of your module.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 门面、适配器和中介器都使用依赖注入来解耦高级模块和低级模块之间的更改。你可以应用任何一种模式，它们将表达模块之间的依赖关系并在其中隔离更改。随着你的系统增长，你可能需要根据模块的结构更改这些模式。
- en: Your choice of pattern depends on the number of dependencies you have on a low-level
    module or resource. The facade pattern works for one low-level module to a few
    high-level ones. Consider an adapter if you have a low-level module with many
    high-level module dependencies. When you have many dependencies among modules,
    you may need a mediator to control resource automation. Figure 4.13 outlines the
    decision tree for identifying which dependency pattern to use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择模式取决于你对低级模块或资源的依赖数量。外观模式适用于一个低级模块到几个高级模块。如果你有一个具有许多高级模块依赖的低级模块，请考虑适配器。当你模块之间存在许多依赖时，你可能需要一个中介者来控制资源自动化。图
    4.13 概述了确定使用哪种依赖模式的决策树。
- en: '![](../../OEBPS/Images/CH04_F13_Wang.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F13_Wang.png)'
- en: Figure 4.13 Choosing your abstraction depends on the relationship of the dependency,
    whether it is intra-module, one to one, or one to many.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 选择你的抽象取决于依赖关系的关系，无论是模块内、一对一还是一对多。
- en: All of the patterns promote idempotency, composability, and evolvability through
    dependency injection. However, why would you start with a facade and then consider
    the adapter or mediator? As your system grows, you will need to optimize your
    dependency management pattern to reduce the operational burden of changes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模式都通过依赖注入促进幂等性、可组合性和可进化性。然而，为什么你会从外观（facade）开始，然后考虑适配器（adapter）或中介者（mediator）呢？随着你的系统增长，你需要优化你的依赖管理模式以减少变更的操作负担。
- en: Figure 4.14 shows the relationship between troubleshooting and implementation
    effort and scalability and isolation for facade, mediator, and adapter patterns.
    For example, a facade has the benefit of minimal effort for implementation and
    troubleshooting but does not scale or isolate changes with more resources. Adapters
    and mediators offer improved scalability and isolation at the cost of troubleshooting
    and implementation effort.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 显示了故障排除和实施工作量与外观、中介者和适配器模式的可扩展性和隔离性之间的关系。例如，外观在实施和故障排除方面具有最小努力的优势，但不能随着更多资源的增加而扩展或隔离变更。适配器和中介者在故障排除和实施工作量的代价下提供了改进的可扩展性和隔离性。
- en: '![](../../OEBPS/Images/CH04_F14_Wang.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH04_F14_Wang.png)'
- en: Figure 4.14 Some patterns may have a low cost of troubleshooting and implementation
    but cannot isolate changes to modules and scale.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 一些模式可能有较低的故障排除和实施成本，但不能隔离模块的变更和扩展。
- en: Lower your initial effort by choosing a tool with a mediator implementation.
    Then use the tool’s built-in facade implementation to manage dependencies between
    modules or resources. When you find it difficult to manage a facade because you
    have multiple systems depending on each other, you can start examining an adapter
    or mediator.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择具有中介者实现的工具来降低初始工作量。然后使用工具内置的外观实现来管理模块或资源之间的依赖关系。当你发现难以管理外观，因为你有许多系统相互依赖时，你可以开始检查适配器或中介者。
- en: An adapter takes more effort to implement but provides the best foundation for
    expanding and growing your infrastructure system. You can always add new infrastructure
    providers and systems without worrying about changing low-level modules. However,
    you cannot expect to use the adapter for every module because it takes time to
    implement and troubleshoot.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器的实现需要更多的工作，但它为你扩展和增长基础设施系统提供了最佳基础。你总是可以添加新的基础设施提供者和系统，而不用担心更改低级模块。然而，你不能期望为每个模块都使用适配器，因为它需要时间来实现和故障排除。
- en: A tool with a mediator chooses which components get updated and when. An existing
    tool lowers your overall implementation effort but introduces some concerns during
    troubleshooting. You need to know your tool’s behavior to troubleshoot failed
    changes for dependencies. Depending on how you use the tool, a tool with a mediator
    allows you to scale but may not fully isolate changes to modules.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中介者的工具选择哪些组件需要更新以及何时更新。现有的工具可以降低你的整体实施工作量，但在故障排除期间会引入一些问题。你需要了解你的工具行为来排除依赖失败的变更。根据你如何使用工具，具有中介者的工具允许你扩展，但可能无法完全隔离模块的变更。
- en: Exercise 4.1
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: How can we better decouple the database’s dependency on the network via the
    following IaC?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何通过以下 IaC 更好地解耦数据库对网络的依赖？
- en: '[PRE9]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A) The approach adequately decouples the database from the network.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: A) 该方法充分解耦了数据库和网络。
- en: B) Pass the network ID as a variable instead of hardcoding it as `default`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: B) 将网络 ID 作为变量传递，而不是将其硬编码为 `default`。
- en: C) Implement and pass a `NetworkOutput` object to the database module for all
    network attributes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C) 为所有网络属性实现并传递一个`NetworkOutput`对象到数据库模块。
- en: D) Add a function to the network module to push its network ID to the database
    module.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: D) 向网络模块添加一个函数，将其网络ID推送到数据库模块。
- en: E) Add a function to the database module to call the infrastructure API for
    the `default` network ID.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: E) 向数据库模块添加一个函数，用于调用基础设施API以获取`default`网络ID。
- en: See appendix B for answers to exercises.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录B以获取练习题的答案。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Apply infrastructure dependency patterns such as facade, adapter, and mediator
    to decouple modules and resources, and you can make changes to modules in isolation.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用基础设施依赖模式，如外观模式、适配器模式和中介者模式，以解耦模块和资源，这样你可以独立地对模块进行更改。
- en: Inversion of control states that the high-level resource calls the low-level
    one for attributes.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制反转表明高级资源调用低级资源以获取属性。
- en: The dependency inversion principle states that the high-level resource should
    use an abstraction of low-level resource metadata.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则表明高级资源应该使用低级资源元数据的抽象。
- en: Dependency injection combines the principles of inversion of control and dependency
    inversion.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入结合了控制反转和依赖倒置的原则。
- en: If you do not recognize an applicable pattern, you can use dependency injection
    for a high-level resource to call a low-level resource and parse its object structure
    for the values it needs.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有识别出适用的模式，你可以使用依赖注入，让高级资源调用低级资源，并解析其对象结构以获取所需的值。
- en: Use the facade pattern to reference a simplified interface for attributes.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外观模式引用属性的简化接口。
- en: Use the adapter pattern to transform metadata from one resource for another
    to use. This pattern works best with resources across different infrastructure
    providers or prototype modules.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适配器模式将一种资源中的元数据转换为另一种资源以使用。这种模式与来自不同基础设施提供商或原型模块的资源配合得最好。
- en: The mediator pattern organizes the dependencies between these resources and
    creates or deletes objects as needed. Most tools serve as a mediator between resources.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者模式组织这些资源之间的依赖关系，并根据需要创建或删除对象。大多数工具都充当资源之间的中介。
