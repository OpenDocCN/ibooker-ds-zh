- en: Chapter 4\. Working with different vector file formats
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 使用不同的矢量文件格式
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Choosing a vector data file format
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择矢量数据文件格式
- en: Working with various vector data formats
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种矢量数据格式
- en: Checking what edits are allowed on a data source
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查数据源允许的编辑操作
- en: As mentioned in the previous chapter, there are many different vector file formats,
    and they’re not always interchangeable, at least in a practical sense. Certain
    formats are more appropriate for certain uses than others. In this chapter you’ll
    learn several of the differences and their strengths and weaknesses.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，存在许多不同的矢量文件格式，它们并不总是可以互换的，至少在实用意义上是这样。某些格式比其他格式更适合某些用途。在本章中，您将了解这些差异以及它们的优缺点。
- en: Another consideration with format is what you can and can’t do with the data
    using OGR. In general, working with one type is the same as working with another,
    but sometimes how you open the data source is different. The larger issue is the
    difference in capabilities of each driver. For example, certain formats can be
    read from but not written to, and others can be created but existing data can’t
    be edited. You’ll also learn how to determine what you can and can’t do with a
    dataset.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式方面，另一个考虑因素是使用OGR可以做什么和不能做什么。一般来说，处理一种类型与处理另一种类型相同，但有时打开数据源的方式可能不同。更大的问题是每个驱动程序的功能差异。例如，某些格式可以读取但不能写入，而其他格式可以创建但无法编辑现有数据。您还将学习如何确定您可以使用数据集做什么和不能做什么。
- en: 4.1\. Vector file formats
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 矢量文件格式
- en: Up to this point, you’ve only worked with shapefiles, but many more vector file
    formats are available. Chances are that you’ll probably only use a handful of
    them on a regular basis, but you need to have an idea of the available options.
    Several formats have open specifications and are supported by many different software
    programs, while others are used more sparingly. Certain formats also support more
    capabilities than others. Most of these formats allow for easy transfer from one
    user to another, much like you can give someone else your spreadsheet file. A
    few use database servers, however, which allows for many users to access and edit
    the same dataset at a central location, but sometimes makes it more difficult
    to move the data from one place to another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只使用过shapefiles，但还有许多其他矢量文件格式可供选择。您可能只会经常使用其中的一小部分，但您需要了解可用的选项。一些格式具有开放规范，并被许多不同的软件程序支持，而其他一些则使用较少。某些格式支持比其他格式更多的功能。大多数这些格式允许用户之间轻松传输，就像您可以将电子表格文件给其他人一样。然而，一些格式使用数据库服务器，这允许许多用户从中央位置访问和编辑相同的数据集，但有时会使数据从一个地方移动到另一个地方变得更加困难。
- en: 4.1.1\. File-based formats such as shapefiles and geoJSON
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1\. 基于文件的格式，如shapefiles和geoJSON
- en: What I call *file-based formats* are made up of one or more files that live
    on a disk drive and can be easily transferred from one location to another, such
    as from your hard drive to another computer or an external drive. Several of these
    are relational databases, but are designed to be easily moved around (think of
    Microsoft Access relational databases), so they’re considered file-based for the
    purposes of this discussion. Several of these formats have open standards so anyone
    can create software to use them, while others are proprietary and limited to smaller
    numbers of software. Examples of open formats are GeoJSON, KML, GML, shapefiles,
    and SpatiaLite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我称之为*基于文件的格式*由一个或多个位于磁盘驱动器上的文件组成，可以轻松地从一处转移到另一处，例如从您的硬盘驱动器转移到另一台计算机或外部驱动器。其中一些是关系数据库，但设计得可以轻松移动（想想微软Access的关系数据库），因此在本讨论中被认为是基于文件的。其中一些格式具有开放标准，因此任何人都可以创建软件来使用它们，而其他一些则是专有的，并且仅限于较小的软件数量。开放格式的例子包括GeoJSON、KML、GML、shapefiles和SpatiaLite。
- en: Spatial data can also be stored in Excel spreadsheets, comma- or tab-delimited
    files, or other similar formats, although this is most common for point data when
    only x and y coordinates are required. Most spatial data, however, is stored using
    formats designed specifically for GIS data. Several of these formats are plain
    text, meaning that you can open them in any text editor and look at them, and
    others are binary files that require software capable of understanding them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据也可以存储在Excel表格中，逗号分隔或制表符分隔的文件中，或其他类似格式，尽管这在只需要x和y坐标的点数据时最为常见。然而，大多数空间数据都是使用专门为GIS数据设计的格式存储的。这些格式中有几个是纯文本格式，这意味着您可以在任何文本编辑器中打开它们并查看它们，而其他一些则是二进制文件，需要能够理解它们的软件。
- en: As mentioned previously, one advantage of plain text files is that you can open
    them in a text editor and inspect their contents. You can even edit them by hand,
    rather than using GIS software, if you’re so inclined. [Listing 4.1](#ch04ex01)
    shows an example of a GeoJSON file that contains two cities in Switzerland, Geneva
    and Lausanne, both represented as points.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，纯文本文件的一个优点是你可以用文本编辑器打开它们并检查其内容。如果你愿意，甚至可以手动编辑它们，而不是使用 GIS 软件。[列表 4.1](#ch04ex01)
    展示了一个 GeoJSON 文件的示例，其中包含瑞士的两个城市，日内瓦和洛桑，两者都表示为点。
- en: Listing 4.1\. An example GeoJSON file with two features
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 一个包含两个特征的 GeoJSON 文件示例
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s okay if you don’t understand everything in this example. The point here
    is that you can open and edit the file in a text editor instead of using GIS software.
    For example, you could easily fix the spelling of a city name or tweak one of
    the point coordinates. While we’re on the subject, it’s worth mentioning that
    small GeoJSON files are automatically rendered as interactive maps when uploaded
    to GitHub. The example shown here is saved as a gist at [https://gist.github.com/cgarrard/8049400](https://gist.github.com/cgarrard/8049400).
    If you have a GitHub account, you can copy this gist to your own account, make
    changes, and instantly see the result.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解这个示例，那没关系。这里的重点是你可以用文本编辑器打开和编辑文件，而不是使用 GIS 软件。例如，你可以轻松地纠正城市名称的拼写或调整一个点的坐标。在此话题上，值得一提的是，小型的
    GeoJSON 文件在上传到 GitHub 时会自动渲染为交互式地图。这里展示的示例保存为 gist，在 [https://gist.github.com/cgarrard/8049400](https://gist.github.com/cgarrard/8049400)。如果你有
    GitHub 账户，你可以将这个 gist 复制到自己的账户，进行修改，并立即看到结果。
- en: Plain text formats such as GeoJSON, KML, and GML are popular for transferring
    small amounts of data and for web applications, but they don’t work so well for
    data analysis. For one thing, all three of these formats allow different geometry
    types to be present in the same dataset, which GIS software doesn’t really appreciate.
    For example, data in the popular shapefile format contains all points, all lines,
    or all polygons, but not a mixture. Therefore, a shapefile could contain roads
    (lines) or city boundaries (polygons), but not both. A GeoJSON file, on the other
    hand, can contain a combination of all three geometries in the same dataset, such
    as the roads and city boundaries mentioned previously that would have to live
    in two different shapefiles. Because you have only one file to download and process,
    this is an excellent solution for passing data to a web browser so it can render
    it on a map. However, most GIS software expects only points, only lines, or only
    polygons, and won’t read the data correctly if it has a mixture. If you need to
    load the data into GIS software, don’t combine multiple geometry types into one
    dataset, even when allowed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如 GeoJSON、KML 和 GML 这样的纯文本格式，对于传输少量数据和网络应用来说很受欢迎，但它们在数据分析方面并不适用。一方面，这三种格式都允许在同一个数据集中存在不同的几何类型，而
    GIS 软件并不真正欣赏这一点。例如，流行的 shapefile 格式的数据包含所有点、所有线或所有多边形，但不混合。因此，shapefile 可以包含道路（线）或城市边界（多边形），但不能两者兼有。另一方面，GeoJSON
    文件可以在同一个数据集中包含所有三种几何类型的组合，例如前面提到的道路和城市边界，这些内容原本需要存在于两个不同的 shapefile 中。因为你只需要下载和处理一个文件，所以这是一个将数据传递给网络浏览器以便在地图上渲染的绝佳解决方案。然而，大多数
    GIS 软件只期望有点、只有线或只有多边形，如果数据混合，则无法正确读取数据。如果你需要将数据加载到 GIS 软件，即使允许，也不要将多个几何类型组合到一个数据集中。
- en: Perhaps a more serious problem with plain text formats when it comes to data
    analysis is that they don’t have the same indexing capabilities as many binary
    formats. Indexes are used for searching and accessing data quickly. Attribute
    indexes allow for searching on values in the attribute fields for the features,
    such as searching for all cities in a dataset with a population over 100,000\.
    Spatial indexes store information about the spatial location of features in the
    dataset so that searching can be limited to features in a certain geographic area,
    for example, when you overlay a small watershed polygon on a larger dataset of
    water-monitoring stations. A spatial index would be used to quickly find the monitoring
    stations that fall within the watershed boundary. Both of these operations, finding
    large cities and finding water-monitoring stations, would be slow on large datasets
    if the appropriate attribute or spatial index didn’t exist. In addition, spatial
    indexes can help a dataset be drawn more quickly because they help find the features
    that fall within the viewport. For example, if you’re looking at Asian cities
    and zoom in on Japan, the spatial index helps find Japanese cities faster while
    ignoring cities in western China.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据分析时，纯文本格式可能存在一个更严重的问题，那就是它们没有像许多二进制格式那样的索引能力。索引用于快速搜索和访问数据。属性索引允许在特征属性字段中的值上进行搜索，例如，搜索具有超过10万人口的某个数据集中的所有城市。空间索引存储数据集中特征的空间位置信息，以便搜索可以限制在特定地理区域内的特征，例如，当你在更大规模的水文监测站数据集上叠加一个小流域多边形时。空间索引可以快速找到位于流域边界内的监测站。如果不存在适当的属性或空间索引，这两个操作（寻找大城市和寻找水文监测站）在大数据集中将会很慢。此外，空间索引可以帮助数据集更快地绘制，因为它们有助于找到位于视口内的特征。例如，如果你正在查看亚洲城市，并放大到日本，空间索引有助于更快地找到日本城市，同时忽略中国西部的城市。
- en: These issues aren’t as important with small datasets, but they’re extremely
    important with large ones. Certain formats have ways around these problems, though.
    For example, although the KML format doesn’t have true spatial indexes, it does
    allow for datasets to be broken up into different files for different spatial
    locations. This allows for smaller datasets to be loaded as a user zooms and pans
    around the map, which increases rendering speed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在小数据集中，这些问题并不重要，但在大数据集中，它们却极为重要。某些格式有解决这些问题的方法。例如，尽管KML格式没有真正的空间索引，但它确实允许将数据集拆分为不同空间位置的不同文件。这允许在用户在地图上缩放和平移时加载更小的数据集，从而提高了渲染速度。
- en: Several vector data formats use familiar desktop-based, or personal, relational
    database software under the hood. This is true for Esri personal geodatabases
    and GeoMedia .mdb files, which use Microsoft Access databases to store data. Another
    example of a vector format based on an existing database format is SpatiaLite,
    a spatial extension for the SQLite database management system. These vector data
    formats can take advantage of the capabilities built into the database software,
    such as indexes. The underlying database also imposes much stricter rules for
    storing data. For example, all geographic features in a dataset must have the
    same geometry type and the same set of attribute fields. Similar to the way nonspatial
    databases can contain multiple tables, a spatial database can contain multiple
    datasets. Although an individual dataset is limited to a single geometry type,
    a solitary database file can contain multiple datasets, each with different geometry
    types and attribute fields. This is convenient for keeping related datasets together
    and for moving them from disk to disk. [Figure 4.1](#ch04fig01) shows a schematic
    of a single SpatiaLite database file that contains multiple datasets with different
    geometries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几种矢量数据格式在底层使用熟悉的基于桌面或个人关系型数据库软件。这是Esri个人地理数据库和GeoMedia .mdb文件的情况，它们使用Microsoft
    Access数据库来存储数据。另一个基于现有数据库格式的矢量格式示例是SpatiaLite，它是SQLite数据库管理系统的一个空间扩展。这些矢量数据格式可以利用数据库软件中内置的功能，例如索引。底层数据库还对存储数据施加了更严格的规则。例如，数据集中的所有地理特征必须具有相同的几何类型和相同的属性字段集合。与非空间数据库可以包含多个表的方式类似，空间数据库可以包含多个数据集。尽管单个数据集限制为单个几何类型，但单个数据库文件可以包含多个数据集，每个数据集具有不同的几何类型和属性字段。这对于将相关数据集放在一起以及将它们从磁盘移动到磁盘来说很方便。[图4.1](#ch04fig01)显示了包含具有不同几何形状的多个数据集的单个SpatiaLite数据库文件的示意图。
- en: Figure 4.1\. A sample SpatiaLite database containing multiple layers with different
    geometry types. All of these various datasets are contained within one easily
    transportable file.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1\. 一个包含多个不同几何类型的SpatiaLite数据库示例。所有这些各种数据集都包含在一个易于携带的文件中。
- en: '![](04fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig01.jpg)'
- en: Other vector formats consist of several files, such as the ever popular shapefile.
    These datasets store geometries, attribute values, and indexes in separate files.
    If you move a shapefile from one location to another, you need to ensure that
    you move all of the required files. Other format types that require multiple files
    make it a bit easier by using dedicated folders that contain the necessary files.
    As with shapefiles, you don’t need to know anything about the individual files,
    but you shouldn’t change anything in the folder. Two examples of formats that
    use this system are Esri grids and file geodatabases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其他矢量格式由多个文件组成，例如一直很受欢迎的shapefile。这些数据集将几何形状、属性值和索引存储在单独的文件中。如果你将shapefile从一个位置移动到另一个位置，你需要确保移动所有必需的文件。其他需要多个文件的格式类型通过使用包含必要文件的专用文件夹来简化这个过程。与shapefile一样，你不需要了解任何关于单个文件的信息，但你不应该更改文件夹中的任何内容。使用这种系统的格式示例包括Esri网格和文件地理数据库。
- en: Many other vector data formats haven’t been mentioned here, but you should now
    have an idea of the types of formats and their strengths and weaknesses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有提到许多其他矢量数据格式，但你现在应该对格式类型及其优缺点有所了解。
- en: 4.1.2\. Multi-user database formats such as PostGIS
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2\. 多用户数据库格式，如PostGIS
- en: You’ve seen that file-based formats come in many shapes and sizes, including
    desktop relational database models such as SpatiaLite. One limitation of these
    formats is that they don’t allow multiple people to edit, or sometimes even use,
    a specific dataset at the same time. This is where the multi-user client-server
    database architecture comes in, because the data are stored in a database that
    is accessible by multiple clients across the network. Users access data from the
    server rather than opening a file on a local disk. Although this is certainly
    not for everyone, it’s a great choice for making data available to many users
    from a central location. This is especially useful if the data are updated frequently
    or are used by many different users, because all users will instantly have access
    to the updated data. It also allows multiple people to edit a dataset at once,
    which isn’t usually possible with file-based formats. In addition, in many cases
    the indexing and querying capabilities of these database systems provide faster
    performance when accessing data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，基于文件的格式有很多形状和大小，包括桌面关系数据库模型，如SpatiaLite。这些格式的局限性之一是它们不允许多个人同时编辑，有时甚至使用特定的数据集。这就是多用户客户端-服务器数据库架构发挥作用的地方，因为数据存储在多个客户端可以通过网络访问的数据库中。用户从服务器访问数据，而不是在本地磁盘上打开文件。虽然这当然不是为每个人准备的，但它是一个从中央位置向许多用户提供数据的绝佳选择。如果数据经常更新或被许多不同的用户使用，这尤其有用，因为所有用户将立即能够访问更新后的数据。它还允许多个人同时编辑数据集，这在基于文件的格式中通常是不可能的。此外，在许多情况下，这些数据库系统的索引和查询能力在访问数据时提供了更快的性能。
- en: The most popular client-server database solutions for spatial data include PostgreSQL
    with the PostGIS spatial extension, ArcSDE, SQL Server, and Oracle Spatial and
    Graph. If you want to host the data on your own computer, you need to invest in
    a system like these. My favorite is PostGIS ([www.postgis.net](http://www.postgis.net))
    because it’s open source and provides a feature-rich environment with many functions,
    operators, and indexes that are specific to spatial data. Even with huge amounts
    of data, you can still get good performance. Although you can’t zip up a PostGIS
    dataset and email it to a colleague, it comes with utilities to import and export
    several popular file-based formats, and it’s straightforward to run a query and
    export the data to a portable format. Not only does PostGIS store the data, but
    you can use it for many types of analyses as well, without the need for other
    GIS software. PostGIS also works with raster data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 空间数据最流行的客户端-服务器数据库解决方案包括带有PostGIS空间扩展的PostgreSQL、ArcSDE、SQL Server以及Oracle Spatial和Graph。如果你想在你的电脑上托管数据，你需要投资这样的系统。我最喜欢的是PostGIS
    ([www.postgis.net](http://www.postgis.net))，因为它开源，提供了一个功能丰富的环境，包含许多针对空间数据特定的函数、运算符和索引。即使有大量数据，你仍然可以获得良好的性能。虽然你不能压缩PostGIS数据集并通过电子邮件发送给同事，但它附带了一些导入和导出几种流行文件格式的小工具，并且运行查询并将数据导出到便携格式非常直接。PostGIS不仅存储数据，你还可以用它进行许多类型的分析，而无需其他GIS软件。PostGIS还支持栅格数据。
- en: If you’re not familiar with relational databases, then it might take effort
    to set one of these systems up and learn how to use it. But it’s extremely powerful
    and worth the investment in brain cells if you need to give multiple users simultaneous
    access to data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉关系数据库，那么设置这些系统之一并学习如何使用它可能需要付出努力。但如果你需要为多个用户提供同时访问数据的能力，那么它非常强大，值得在脑细胞上的投资。
- en: 4.2\. Working with more data formats
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 处理更多数据格式
- en: 'Until now we’ve only worked with one data format out of many. The basics don’t
    change between formats, though. Once you open the data source, reading the data
    is pretty much the same. But for kicks, let’s look at several formats that support
    more than one layer, because we haven’t done that yet. Until now, we’ve used the
    first and only layer in a data source, but if multiple layers exist, you need
    to know either the name or the index of the one you’re interested in. Generally,
    I’d use ogrinfo to get this information, but because this is a book on Python,
    let’s write a simple function that opens a data source, loops through the layers,
    and prints their names and indexes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了众多数据格式中的一种。尽管格式不同，基本原理没有变化。一旦打开数据源，读取数据基本上是相同的。但为了好玩，让我们看看支持多个层的几种格式，因为我们还没有这样做过。到目前为止，我们只使用数据源中的第一个和唯一一层，但如果存在多个层，你需要知道你感兴趣的那个层的名称或索引。通常，我会使用ogrinfo来获取这些信息，但鉴于这是一本关于Python的书，让我们编写一个简单的函数，该函数打开数据源，遍历层，并打印它们的名称和索引：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function takes the filename of the data source as a parameter, and the
    first thing it does is open the file. Then it uses `GetLayerCount` to find out
    how many layers the data source contains, and iterates through a loop that many
    times. Each time through the loop, it uses the `i` variable to get the layer at
    the index corresponding to that iteration. Then it prints the name of the layer
    and its index. This function is included in the ospybook module, and you’ll use
    it to inspect other data sources in the following examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受数据源文件名作为参数，它首先执行的操作是打开文件。然后它使用`GetLayerCount`来找出数据源包含多少层，并循环多次。每次循环中，它使用`i`变量来获取对应迭代索引的层。然后它打印出层的名称及其索引。这个函数包含在ospybook模块中，你将在下面的示例中使用它来检查其他数据源。
- en: 4.2.1\. SpatiaLite
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. SpatiaLite
- en: 'Let’s start with a SpatiaLite database. This type of data source can contain
    many different layers, all with unique (and hopefully descriptive) names. To see
    this, list the layers in the natural_earth_50m.sqlite file in the data download:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从SpatiaLite数据库开始。这种类型的数据源可以包含许多不同的层，所有层都有独特（并且希望是描述性的）名称。为了查看这一点，请在数据下载中的natural_earth_50m.sqlite文件中列出层：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the dataset has two layers. How would you get a handle to the
    populated_places layer? Well, you could use either the index or the layer name,
    so both `ds.GetLayer(1)` and `ds.GetLayer('populated_places')` would do the trick.
    It’s probably better to use the name rather than the index, however, because the
    index might change if other layers are added to the data source. To prove that
    this works, try plotting the layer, which will be dots representing cities around
    the world, as shown in [figure 4.2](#ch04fig02).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据集有两个层。你将如何获取 populated_places 层的句柄？嗯，你可以使用索引或层名，所以 `ds.GetLayer(1)` 和
    `ds.GetLayer('populated_places')` 都可以行得通。然而，使用名称而不是索引可能更好，因为索引可能会在数据源中添加其他层时发生变化。为了证明这一点，尝试绘制层，这将显示代表世界各地城市的点，如图
    4.2 所示。
- en: Figure 4.2\. The populated_places layer in natural_earth_50m.sqlite
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. natural_earth_50m.sqlite 中的 populated_places 层
- en: '![](04fig02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig02.jpg)'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Ogrinfo**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ogrinfo**'
- en: 'GDAL comes with several extremely useful command-line utilities, and in fact,
    you’ve already seen how to use ogrinfo to find out which vector data formats your
    version of OGR supports. You can also use ogrinfo to get information about specific
    data sources and layers. If you pass it a data source name, it will print a list
    of layers contained in that data source:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 包含几个极其有用的命令行工具，实际上，你已经看到了如何使用 ogrinfo 来找出你的 OGR 版本支持的矢量数据格式。你也可以使用 ogrinfo
    来获取有关特定数据源和层的详细信息。如果你传递一个数据源名称，它将打印出该数据源中包含的层列表：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also use ogrinfo to see metadata about a layer and even all of the attribute
    data. This example will show a summary only (`-so`) of the countries layer in
    the natural earth SQLite database. This includes metadata such as the extent,
    spatial reference, and a list of attribute fields and their data types. The second
    will show all attribute values for the first feature in the layer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 ogrinfo 来查看层的元数据，甚至所有属性数据。以下示例将仅显示自然地球 SQLite 数据库中 countries 层的摘要（`-so`）。这包括范围、空间参考以及属性字段及其数据类型列表。第二个示例将显示层中第一个特征的全部属性值。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To display all of the attribute values for the feature with an FID of 1, you
    could do something like this, where `–q` means *don’t print the metadata* and
    `–geom=NO` means *don’t print out a text representation of the geometry* (which
    would be long).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示具有 FID 为 1 的特征的全部属性值，你可以这样做，其中 `–q` 表示 *不打印元数据*，而 `–geom=NO` 表示 *不打印几何形状的文本表示*（这将非常长）。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See [http://www.gdal.org/ogrinfo.html](http://www.gdal.org/ogrinfo.html) for
    full ogrinfo documentation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 ogrinfo 的完整文档，请参阅 [http://www.gdal.org/ogrinfo.html](http://www.gdal.org/ogrinfo.html)。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2.2\. PostGIS
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. PostGIS
- en: What about connecting to a database server such as the PostGIS spatial extension
    for PostgreSQL? Note a couple of extra considerations that you don’t need to worry
    about with local files. You need to know the connection string to use, which involves
    host, port, database name, username, and password. You also need permission to
    connect to the database and tables in question. If you’re not managing your own
    database server, then you might need to talk to the database administrator to
    set all of this up. The following example connects to the geodata database being
    served by a PostgreSQL instance running on my local machine. It won’t work for
    you unless you go to the trouble to install PostgreSQL and PostGIS, and then set
    up a database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，连接到数据库服务器，如 PostgreSQL 的 PostGIS 空间扩展呢？请注意一些额外的考虑因素，这些因素你不需要在本地文件中担心。你需要知道要使用的连接字符串，这涉及到主机、端口、数据库名称、用户名和密码。你还需要有权限连接到相关的数据库和表。如果你不是管理自己的数据库服务器，那么你可能需要与数据库管理员交谈，以设置所有这些。以下示例连接到由运行在我本地机器上的
    PostgreSQL 实例提供服务的地理数据库。除非你费心安装 PostgreSQL 和 PostGIS，并设置数据库，否则它不会对你起作用。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You see four layers here, but they’re divided up into three different groups,
    or schemas. The time zones layer is in the default schema, counties is in the
    *us* schema, and the remaining two are in the *global* schema. Every user of the
    database could have access to different schemas, and even different layers within
    a schema, depending on how the database administrator has set up the security.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到四个层，但它们被分成三个不同的组，或称为模式。时区层位于默认模式中，县位于 *us* 模式，其余两个位于 *global* 模式。数据库的每个用户都可以访问不同的模式，甚至一个模式内的不同层，具体取决于数据库管理员如何设置安全设置。
- en: As you can see, you can access PostGIS databases with OGR, but you can do many
    things with a PostGIS database that aren’t covered in this book. If you’re interested
    in learning more about it, take a look at *PostGIS in Action*, also published
    by Manning.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以使用OGR访问PostGIS数据库，但您可以使用PostGIS数据库做很多事情，这些内容本书并未涵盖。如果您想了解更多关于它的信息，可以看看由Manning出版的*PostGIS
    in Action*。
- en: 4.2.3\. Folders as data sources (shapefiles and CSV)
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3. 作为数据源的文件夹（shapefiles和CSV）
- en: 'In certain cases OGR will treat entire folders as data sources. Two examples
    of this are the shapefile and comma-delimited text file (.csv) drivers, which
    can be used to open either individual files or entire folders as data sources.
    If you use a folder, then each file inside of the folder is treated as a layer.
    If a folder contains a variety of file types, then the shapefile driver is used.
    For example, try listing the layers in the US folder:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，OGR会将整个文件夹视为数据源。两个例子是shapefile和逗号分隔的文本文件(.csv)驱动程序，它们可以用来打开单个文件或整个文件夹作为数据源。如果您使用文件夹，那么文件夹中的每个文件都被视为一个图层。如果一个文件夹包含多种文件类型，则使用shapefile驱动程序。例如，尝试列出US文件夹中的图层：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compare this list to the contents of the folder, and you’ll see that it listed
    each of the shapefiles, but none of the others. The CSV driver is a little pickier,
    however, and wants all of the files in the folder to be CSV files. Although it
    won’t work with the US folder, it works fine with the csv subfolder. Does this
    mean that you can’t open a CSV file that’s in a folder with a bunch of other files?
    Fortunately, no. All you have to do is treat the CSV file itself as a data source
    with only one layer. You can do the exact same thing with a shapefile by providing
    the name of the .shp file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表与文件夹内容进行比较，您会发现它列出了每个形状文件，但没有列出其他文件。然而，CSV驱动程序比较挑剔，它希望文件夹中的所有文件都是CSV文件。尽管它不能与US文件夹一起工作，但它与csv子文件夹配合得很好。这意味着您不能打开一个包含大量其他文件的文件夹中的CSV文件吗？幸运的是，不是这样。您只需将CSV文件本身视为只有一个图层的单一数据源。您也可以通过提供.shp文件名来用形状文件做同样的事情。
- en: 4.2.4\. Esri file geodatabases
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.4. Esri文件地理数据库
- en: You Esri users out there might expect to see feature datasets inside file geodatabases
    treated like the schemas in PostGIS. If so, you’ll be disappointed, because all
    you see are feature class names. [Figure 4.3](#ch04fig03) shows what the natural_earth
    file geodatabase looks like in ArcCatalog, but the large_scale feature dataset
    name isn’t included in the layer names that OGR uses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在场的Esri用户可能期望在文件地理数据库中看到特征数据集被像PostGIS中的模式一样处理。如果是这样，您可能会失望，因为您看到的所有都是特征类名称。[图4.3](#ch04fig03)显示了在ArcCatalog中自然地球文件地理数据库的外观，但大比例尺特征数据集的名称并未包含在OGR使用的图层名称中。
- en: Figure 4.3\. The natural_earth file geodatabase as seen in ArcCatalog
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3. 在ArcCatalog中看到的natural_earth文件地理数据库
- en: '![](04fig03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig03.jpg)'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fortunately, you don’t need the feature dataset name to access the layer, though;
    the feature class name works fine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不需要特征数据集的名称来访问图层；特征类名称就足够了：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'File geodatabases have two different drivers. You can read more about the differences
    on the OGR website, but one huge difference is that the read-only OpenFileGDB
    driver is compiled into OGR by default and the read/write FileGDB driver isn’t
    because it requires a third-party library from Esri. If somebody gave you a file
    geodatabase that you needed to change but you didn’t have access to the FileGDB
    driver, you could still use the OpenFileGDB driver to open the geodatabase and
    copy the data to a format that you could edit. This may not be ideal, but at least
    you have the option. For example, you could copy the countries_110m feature class
    in the natural earth geodatabase to a shapefile like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文件地理数据库有两个不同的驱动程序。您可以在OGR网站上了解更多关于它们之间的区别，但一个巨大的区别是，只读的OpenFileGDB驱动程序默认编译进OGR，而读写FileGDB驱动程序则不是，因为它需要来自Esri的第三方库。如果有人给了您一个需要修改的文件地理数据库，但您没有访问FileGDB驱动程序的权限，您仍然可以使用OpenFileGDB驱动程序打开地理数据库并将数据复制到您可以编辑的格式。这可能不是最佳选择，但至少您有这个选项。例如，您可以将自然地球地理数据库中的countries_110m要素类复制到如下形状文件：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You haven’t seen the `CopyLayer` method before. This allows you to easily copy
    the contents of an entire layer into a new data source or to the same data source
    but with a different layer name. To use it, you need to get the layer that you
    want to make a copy of and open the data source that you want to save the copy
    into. Then call `CopyLayer` on the data source that will get the copy, and pass
    it the original layer and a name for the new layer that will be created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前还没有见过 `CopyLayer` 方法。这允许你轻松地将整个图层的所有内容复制到新的数据源或相同的数据源，但具有不同的图层名称。要使用它，你需要获取你想要复制的图层以及你想要保存副本的数据源。然后在对获取副本的数据源调用
    `CopyLayer`，并传递原始图层和为新图层创建的名称。
- en: 'If you do have the Esri FileGDB driver, you can create new file geodatabases,
    and even feature datasets even though OGR doesn’t show you feature dataset names.
    [Listing 4.2](#ch04ex02) shows a function that imports all of the layers from
    a data source into a feature dataset within a file geodatabase, but note that
    this only works if you have the FileGDB driver. If you try to use this function
    without that driver installed, you’ll get an error message that says AttributeError:
    ‘NoneType’ object has no attribute ‘CreateDataSource’.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你已经安装了Esri FileGDB驱动程序，你可以创建新的文件地理数据库，甚至特征数据集，尽管OGR不会显示特征数据集的名称。[列表 4.2](#ch04ex02)
    展示了一个将数据源中的所有图层导入文件地理数据库中的特征数据集的功能，但请注意，这仅在你有FileGDB驱动程序的情况下有效。如果你在没有安装该驱动程序的情况下尝试使用此功能，你会收到一个错误消息，显示
    AttributeError: ‘NoneType’ 对象没有属性 ‘CreateDataSource’。'
- en: Listing 4.2\. Function to import layers to a file geodatabase
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2. 导入图层到文件地理数据库的功能
- en: '![](075fig01_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![075fig01_alt.jpg](075fig01_alt.jpg)'
- en: 'This function requires three parameters: the path to the original data source,
    the path to the file geodatabase, and the name of the feature dataset to copy
    the layers into. After opening the original data source, it checks to see if the
    file geodatabase exists. If it does, then the geodatabase is opened for writing.
    If it doesn’t exist, it’s created. Feature datasets are specified using layer-creation
    options, so then a list containing a single option for `FEATURE_DATASET` is created.
    After that, all of the layers in the original data source are looped over and
    copied into the geodatabase while keeping the same layer name (although they’ll
    be renamed if naming conflicts arise in the geodatabase). If the `FEATURE_DATASET`
    layer-creation option wasn’t provided, then the layer will be added to the file
    geodatabase, but it will be at the top level instead of in a feature dataset.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要三个参数：原始数据源的路径、文件地理数据库的路径以及要复制图层的特征数据集的名称。在打开原始数据源后，它会检查文件地理数据库是否存在。如果存在，则地理数据库将用于写入。如果不存在，则创建它。特征数据集使用图层创建选项指定，因此创建了一个包含单个
    `FEATURE_DATASET` 选项的列表。之后，将遍历原始数据源中的所有图层，并将它们复制到地理数据库中，同时保持相同的图层名称（尽管如果地理数据库中发生命名冲突，它们将被重命名）。如果没有提供
    `FEATURE_DATASET` 图层创建选项，则图层将被添加到文件地理数据库中，但将位于顶级而不是特征数据集中。
- en: 'Now that you have this function, you could copy all of the shapefiles in a
    folder into a geodatabase like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了这个函数，你可以将文件夹中的所有shapefile复制到地理数据库中，如下所示：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you wanted to have the option of saving the feature classes to the top level
    of the geodatabase instead of in a feature dataset, you could modify this function
    so it doesn’t pass the option list to `CopyLayer` if the `dataset_name` parameter
    is `None` or an empty string.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将特征类保存到地理数据库的顶级而不是特征数据集中，你可以修改此函数，使其在 `dataset_name` 参数为 `None` 或空字符串时不将选项列表传递给
    `CopyLayer`。
- en: 4.2.5\. Web feature services
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.5. 网络特征服务
- en: 'You can also access online services, such as *Web Feature Services* (WFS).
    Let’s try this using a WFS hosted by the United States National Oceanic and Atmospheric
    Administration (NOAA) that serves out hazardous weather watches and advisories.
    Start with getting the list of available layers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以访问在线服务，例如 *Web Feature Services* (WFS)。让我们尝试使用由美国国家海洋和大气管理局 (NOAA) 托管的 WFS，该服务提供危险天气警报和咨询。首先获取可用图层的列表：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can loop through these layers like the layers from other data sources,
    but all of the data are fetched immediately, so there could be quite a lag if
    the list has lots of features. It looks like the second layer only contains warnings,
    which are more severe than watches, so it should have less data. Let’s find out
    what type of warning the first feature represents. I’ve discovered that things
    crash if I try to use `GetFeature` with an FID, but you can do it using `GetNextFeature`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理其他数据源中的图层一样遍历这些图层，但所有数据都是立即获取的，所以如果列表中有许多特征，可能会有相当大的延迟。看起来第二个图层只包含警告，比监视更严重，所以它应该有更少的数据。让我们找出第一个特征代表的是哪种类型的警告。我发现如果尝试使用FID与`GetFeature`一起使用，事情会崩溃，但你可以使用`GetNextFeature`来完成它：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I can recommend an easier and faster way to get only the first few features
    if that’s all you want, however. Tack a `MAXFEATURES` parameter onto your URL,
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取前几个特征，我可以推荐一种更简单、更快的方法。只需在你的URL上添加一个`MAXFEATURES`参数，如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also work with the geometries from a WFS. [Figure 4.4](#ch04fig04) shows
    my results when I used VectorPlotter to draw the watchWarn:WatchesWarnings layer
    on top of states.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用WFS中的几何形状。[图4.4](#ch04fig04)展示了当我使用VectorPlotter在州上绘制watchWarn:WatchesWarnings层时的结果。
- en: Figure 4.4\. The WatchesWarnings layer from the NOAA web feature service. If
    you plot it, your results will differ because this layer shows real-time data.
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.4\. 来自NOAA网络特征服务的WatchesWarnings层。如果你绘制它，你的结果会有所不同，因为这个图层显示实时数据。
- en: '![](04fig04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig04.jpg)'
- en: 'Let’s do something a little different—save real-time data from a WFS and use
    it to build a simple web map using Folium, which is a Python module that creates
    Leaflet maps. If you have no idea what Leaflet is, that’s okay, because you don’t
    have to know anything about web mapping to work through this example. First you
    need to install Folium, though. On my Windows computer, I opened up a command
    prompt and used pip to install Folium and Jinja2 (another module that Folium requires
    in order to work) for Python 3.3 like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些不同的事情——从WFS中保存实时数据，并使用它通过Folium构建一个简单的网络地图，Folium是一个创建Leaflet地图的Python模块。如果你不知道Leaflet是什么，没关系，因为你不需要了解任何关于网络地图的知识来完成这个示例。不过，你首先需要安装Folium。在我的Windows电脑上，我打开了一个命令提示符，并使用pip安装了Folium和Jinja2（Folium工作所需的另一个模块），如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you’re not familiar with installing Python modules via pip, please refer
    to the installation instructions in [appendix A](kindle_split_022.html#app01).
    Now let’s look at the example script, which breaks things out into functions so
    code can be easily reused. [Listing 4.3](#ch04ex03) contains a function to retrieve
    stream gauge data from a WFS and save it as GeoJSON; a function to make the web
    map showing these stream gauges; a function to get a geometry so that the map
    focuses on a single state instead of the whole country; and a couple of helper
    functions to format data for the WFS request and the map.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉通过pip安装Python模块，请参阅[附录A](kindle_split_022.html#app01)中的安装说明。现在让我们看看示例脚本，它将代码分解成函数，以便代码可以轻松重用。[列表4.3](#ch04ex03)包含一个从WFS检索流量计数据并将其保存为GeoJSON的函数；一个创建显示这些流量计的网络地图的函数；一个获取几何形状的函数，以便地图聚焦于单个州而不是整个国家；以及几个辅助函数，用于格式化WFS请求和地图的数据。
- en: Listing 4.3\. Create a web map from WFS data
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3\. 从WFS数据创建网络地图
- en: '![](ch04ex03-0.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex03-0.jpg)'
- en: '![](ch04ex03-1.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex03-1.jpg)'
- en: You can probably understand what the `get_state_geom` function does and how
    it does it, because you’ve seen the same process before. It takes a state name
    as a parameter, finds the corresponding feature in a layer, and returns the cloned
    geometry. The filename is hardcoded because you assume that the location of this
    state boundary file won’t change.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能可以理解`get_state_geom`函数的作用及其工作方式，因为你之前已经见过同样的过程。它接受一个州名作为参数，在图层中找到相应的特征，并返回克隆的几何形状。文件名是硬编码的，因为你假设这个州边界文件的位置不会改变。
- en: The two helper functions are also simple. The `get_center` function takes a
    geometry, gets its centroid, and then returns the coordinates as a [y, x] list.
    The order might seem weird to you, but that’s the order that Folium wants them
    in for the map.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 两个辅助函数也很简单。`get_center`函数接受一个几何形状，获取其质心，然后以[y, x]列表的形式返回坐标。这个顺序可能看起来很奇怪，但这是Folium希望它们在地图中的顺序。
- en: The `get_bbox` function takes a geometry and returns its bounding coordinates
    as a string formatted like min_x,min_y,max_x,max_y. This is the format that a
    WFS uses to spatially subset results, and it’s how you’ll limit your gauge results
    to the bounding box of a state. This function takes advantage of the string formatting
    rules to rearrange the results of `GetEnvelope`, which returns a geometry’s bounding
    box ([figure 4.5](#ch04fig05)) as a [min_x, max_x, min_y, max_y] list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_bbox` 函数接受一个几何形状，并以 min_x,min_y,max_x,max_y 的格式返回其边界坐标作为字符串。这是 WFS 用于空间子集结果的格式，也是你如何将测量结果限制在州边界框内的方法。此函数利用字符串格式化规则重新排列
    `GetEnvelope` 的结果，它返回一个几何形状的边界框（[图 4.5](#ch04fig05)）作为一个 [min_x, max_x, min_y,
    max_y] 列表。'
- en: Figure 4.5\. The line is the bounding box for the state of Oklahoma.
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5。这条线是俄克拉荷马州的边界框。
- en: '![](04fig05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![04fig05.jpg](04fig05.jpg)'
- en: 'Now let’s look at the slightly more complicated `save_state_gauges` function.
    Here you hardcode in the URL for a WFS that returns the observed river stages
    data from the Advanced Hydrologic Prediction Service. You also create a dictionary
    containing the parameters to be passed to the WFS. As you already know, the `typeNames`
    parameter is the name of the layer to retrieve data from. The `version` is the
    WFS version to use, and `srsName` specifies which coordinate system you’d like
    your data to be returned in. You can see the available options for this in the
    WFS’s capabilities output, which you can get by tacking ?request=GetCapabilities
    onto the end of the service URL and visiting it in a web browser. For example,
    part of the output from [http://gis.srh.noaa.gov/arcgis/services/ahps_gauges/MapServer/WFSServer?request=GetCapabilities](http://gis.srh.noaa.gov/arcgis/services/ahps_gauges/MapServer/WFSServer?request=GetCapabilities)
    looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下稍微复杂一点的 `save_state_gauges` 函数。在这里，你将 WFS 的 URL 硬编码为返回高级水文预测服务观察到的河流水位数据的
    URL。你还创建了一个包含要传递给 WFS 的参数的字典。正如你所知，`typeNames` 参数是要检索数据的层的名称。`version` 是要使用的 WFS
    版本，而 `srsName` 指定你希望数据返回的坐标系。你可以在 WFS 的能力输出中看到此选项，你可以在服务 URL 的末尾附加 ?request=GetCapabilities
    并在网页浏览器中访问它。例如，[http://gis.srh.noaa.gov/arcgis/services/ahps_gauges/MapServer/WFSServer?request=GetCapabilities](http://gis.srh.noaa.gov/arcgis/services/ahps_gauges/MapServer/WFSServer?request=GetCapabilities)
    的部分输出如下：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From this you can see that the default spatial reference system (`DefaultSRS`)
    is EPSG 4269, which happens to be unprojected data using the NAD83 datum. If that
    doesn’t make much sense, don’t worry about it for now, because you’ll learn all
    about it in [chapter 8](kindle_split_016.html#ch08). All you need to know now
    is that web-mapping libraries generally want coordinates that use WGS84, which
    corresponds to EPSG 4326\. Fortunately, that’s listed as an `OtherSRS` option
    in the capabilities output, so you insert it into your parameters dictionary:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里你可以看到默认的坐标参考系统 (`DefaultSRS`) 是 EPSG 4269，这恰好是使用 NAD83 基准的未投影数据。如果你现在还不明白，不用担心，因为你在第
    8 章中会学到所有关于它的知识。你现在需要知道的是，网络地图库通常希望使用 WGS84 坐标，这对应于 EPSG 4326。幸运的是，这在能力输出中列为 `OtherSRS`
    选项，所以你将其插入到参数字典中：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the user provided a `bbox` parameter to the function, you also insert that
    into your dictionary. If a `bbox` parameter is provided to the WFS, it returns
    features that fall in that box instead of returning all of them. Remember that
    your `get_bbox` function creates a string in the correct format for this based
    on a geometry’s bounding box.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户向该函数提供了 `bbox` 参数，你也需要将其插入到你的字典中。如果向 WFS 提供了 `bbox` 参数，它将返回该框内的要素，而不是返回所有要素。请记住，你的
    `get_bbox` 函数根据几何形状的边界框创建一个正确格式的字符串。
- en: 'Creating this dictionary wasn’t absolutely necessary, because you could have
    built your query string the same way you did in earlier examples, but I think
    that using a dictionary makes it easier to see what parameters are being passed.
    It’s easy to create the query string from the dictionary by using the `urlencode`
    function, which formats everything for you. In Python 2, this function lives in
    the urllib module, but in Python 3 it lives in urllib.parse, which is why you
    have the next step in a try/except block. You try to create the query string using
    the Python 2 function, but if that fails because the script was run with Python
    3, then you do it the Python 3 way instead:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个字典并不是绝对必要的，因为你可以用与之前示例相同的方式构建你的查询字符串，但我认为使用字典可以使看到传递的参数更容易。使用 `urlencode`
    函数很容易从字典中创建查询字符串，它会为你格式化一切。在 Python 2 中，这个函数位于 urllib 模块中，但在 Python 3 中位于 urllib.parse，这就是为什么你有一个
    try/except 块中的下一步。你尝试使用 Python 2 函数创建查询字符串，但如果因为脚本是用 Python 3 运行的而失败，那么你就用 Python
    3 的方式来做：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After creating your query string, you use it to open a connection to the WFS
    and get the layer. You want to save the output to a local file this time, though,
    so then you create an empty GeoJSON data source. Data sources have a `CopyLayer`
    function that copies an existing layer into the data source; this existing layer
    can be from another data source altogether. You use that function to copy the
    data from the WFS into your new GeoJSON file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你的查询字符串之后，你使用它来打开与 WFS 的连接并获取层。不过，这次你想要将输出保存到本地文件中，所以你创建了一个空的 GeoJSON 数据源。数据源有一个
    `CopyLayer` 函数，可以将现有的层复制到数据源中；这个现有的层可以完全来自另一个数据源。你使用这个函数将 WFS 中的数据复制到你的新 GeoJSON
    文件中：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The second parameter to `CopyLayer` is the name for the new layer, but GeoJSON
    layers don’t have names, so you pass a blank string. You could pass a real layer
    name, but it wouldn’t do much good. When your function returns after creating
    the layer, the data sources go out of scope, so the files get closed automatically,
    which is why you don’t bother to close them inside the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyLayer` 的第二个参数是新层的名称，但 GeoJSON 层没有名称，所以你传递一个空字符串。你也可以传递一个真实的层名称，但这并不会带来太多好处。当你的函数在创建层之后返回，数据源就会超出作用域，因此文件会自动关闭，这就是为什么你不需要在函数内部关闭它们的原因。'
- en: 'The last function you write is called `make_map`. It wants a state name along
    with filenames for the output GeoJSON and HTML files. It can also take other named
    arguments that get passed to Folium, which allows you to pass optional Folium
    parameters without having to worry about them in your `make_map` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后编写的函数被称作 `make_map`。它需要一个状态名称以及输出 GeoJSON 和 HTML 文件的文件名。它还可以接受其他命名参数，这些参数会被传递给
    Folium，这使得你可以在不担心它们的情况下传递可选的 Folium 参数：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The basic outline is shown in [figure 4.6](#ch04fig06), but the first thing
    this function does is get the geometry for the state of interest. Then it gets
    the `bbox` for the geometry and passes that, along with the output GeoJSON filename,
    to the function that saves the WFS data to file. Then it creates a Folium map
    centered on the geometry, and also uses any named arguments that the user might
    have passed in. Remember that `**` explodes a dictionary into key/value pairs,
    so all of the arguments are treated as if they’re an exploded dictionary called
    `kwargs`. You can read about the optional parameters at [http://folium.readthedocs.org/en/latest/](http://folium.readthedocs.org/en/latest/).
    This map uses OpenStreetMap tiles as the basemap by default, but that’s one of
    the things you can change.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基本轮廓在 [图 4.6](#ch04fig06) 中显示，但这个函数首先做的事情是获取感兴趣州份的几何形状。然后它获取几何形状的 `bbox` 并将其传递，包括输出
    GeoJSON 文件名，到保存 WFS 数据到文件的函数。然后它创建一个以几何形状为中心的 Folium 地图，并使用用户可能传递的任何命名参数。记住，`**`
    会将字典展开成键/值对，所以所有的参数都被当作是名为 `kwargs` 的展开字典来处理。你可以在 [http://folium.readthedocs.org/en/latest/](http://folium.readthedocs.org/en/latest/)
    中阅读有关可选参数的信息。这个地图默认使用 OpenStreetMap 瓦片作为底图，但你也可以更改这一点。
- en: Figure 4.6\. Tasks in the `make_map` function
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. `make_map` 函数中的任务
- en: '![](04fig06_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![04fig06_alt.jpg](04fig06_alt.jpg)'
- en: After creating the basic map, the contents of the GeoJSON file are added and
    the map is saved to the HTML filename provided by the user. All that’s left is
    to use it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建基本地图之后，GeoJSON 文件的内容会被添加，并且地图会被保存到用户提供的 HTML 文件名中。剩下的就是使用它了。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I used a Dropbox folder so that I could view the output on the web using the
    Dropbox public link functionality. You probably won’t have much luck viewing the
    output straight from your local drive without using a web server. If you don’t
    have something like Dropbox you can use, check out the sidebar to learn how to
    start up a simple Python web server on your local machine instead. I wanted to
    make a map of Oklahoma, and I also passed one of those optional parameters, `zoom_start`,
    through to Folium. By default, Folium maps start with a zoom level of 10, which
    is zoomed in too far to see the entire state. A start level of 7 works much better
    for this example.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个 Dropbox 文件夹，这样我就可以通过 Dropbox 公共链接功能在网络上查看输出。如果你不使用网络服务器，直接从本地驱动器查看输出可能不会有太多运气。如果你没有可用的类似
    Dropbox 的服务，请查看侧边栏了解如何在本地机器上启动简单的 Python 网络服务器。我想制作一个俄克拉荷马州的地图，我还将一个可选参数 `zoom_start`
    传递给了 Folium。默认情况下，Folium 地图以 10 级缩放开始，这太近了，无法看到整个州。在这个例子中，7 级起始缩放效果会更好。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Python SimpleHTTPServer**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python SimpleHTTPServer**'
- en: Python ships with a simple web server that you can use for testing things out,
    although you probably shouldn’t use it for production websites. The easiest way
    to use it is to open up a terminal window or command prompt, change to the directory
    that contains the files you want to serve, and then invoke the server from the
    command line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Python 随带了一个简单的网络服务器，你可以用它来测试一些事情，尽管你可能不应该用它来生产网站。使用它的最简单方法是打开一个终端窗口或命令提示符，切换到包含你想要提供服务的文件的目录，然后从命令行调用服务器。
- en: 'For Python 2:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 2：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For Python 3:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will start up a web server running on your local port 8000, so you can
    get to it in a web browser at http://localhost:8000/. If a file called index.html
    is in the folder you started the server from (d:\dropbox\public\webmaps, in this
    case), then that page will automatically be displayed. Otherwise, a list of files
    in the folder will display, and you can click on one to see it. The URL for the
    Oklahoma example would be http://localhost:8000/ok.html.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地端口 8000 上启动一个网络服务器，因此你可以在网页浏览器中通过 http://localhost:8000/ 访问它。如果你启动服务器所在的文件夹中有一个名为
    index.html 的文件（在这个例子中是 d:\dropbox\public\webmaps），那么该页面将自动显示。否则，将显示文件夹中的文件列表，你可以点击其中一个来查看它。俄克拉荷马州示例的
    URL 将是 http://localhost:8000/ok.html。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you’ve run the script, you can get the Dropbox public link for ok.html
    and view it in a web browser. If all went well, it will look something like [figure
    4.7](#ch04fig07).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，你可以获取 ok.html 的 Dropbox 公共链接并在网页浏览器中查看它。如果一切顺利，它看起来就像 [图 4.7](#ch04fig07)
    一样。
- en: Figure 4.7\. A simple Folium map made with a GeoJSON file
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 使用 GeoJSON 文件制作的简单 Folium 地图
- en: '![](04fig07.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![04fig07.jpg]'
- en: The map in [figure 4.7](#ch04fig07) shows the location of stream gauges, but
    other than that, it’s not too useful. Smaller markers would be nice, and so would
    popups that provide the gauge reading if you click on the marker. Unfortunately,
    I don’t believe there’s a way to do this by adding a GeoJSON file to the map directly,
    but it’s not hard to do manually. Let’s add a function to make custom markers,
    along with a couple of helper functions, and then change the `make_map` function
    to use those instead of adding the GeoJSON straight to the map.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 中的地图显示了流量计的位置，但除此之外，它并不太有用。更小的标记会更好，如果你点击标记，弹出窗口会提供计数值。不幸的是，我相信没有直接通过添加
    GeoJSON 文件到地图上来实现这一功能的方法，但这并不难手动完成。让我们添加一个函数来制作自定义标记，以及几个辅助函数，然后更改 `make_map`
    函数，使其使用这些而不是直接将 GeoJSON 添加到地图中。
- en: Listing 4.4\. Custom markers for a Folium map
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. Folium 地图的自定义标记
- en: '![](ch04ex04-0.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex04-0.jpg)'
- en: '![](ch04ex04-1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex04-1.jpg)'
- en: The first thing you do here is set up colors to use. These come from the online
    legend for this map service, which is available at [http://gis.srh.noaa.gov/arcgis/rest/services/ahps_gauges/MapServer/0](http://gis.srh.noaa.gov/arcgis/rest/services/ahps_gauges/MapServer/0).
    The keys in the `colors` dictionary are possible values in the `Status` attribute
    field, and the values are hex strings that describe a color.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你首先需要设置要使用的颜色。这些来自该地图服务的在线图例，该图例可在 [http://gis.srh.noaa.gov/arcgis/rest/services/ahps_gauges/MapServer/0](http://gis.srh.noaa.gov/arcgis/rest/services/ahps_gauges/MapServer/0)
    找到。`colors` 字典中的键是 `Status` 属性字段中的可能值，而值是描述颜色的十六进制字符串。
- en: The `get_popup` function creates an HTML string by exploding the attributes
    dictionary for a feature and inserting the values in the corresponding placeholders
    in a template string. For example, the value from the `Location` field would get
    inserted in place of “{location}” in the template string.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_popup` 函数通过将特征的属性字典展开，并将值插入到模板字符串中相应的占位符来创建一个 HTML 字符串。例如，`Location` 字段中的值将被插入到模板字符串中的“{location}”位置。'
- en: The markers are created in the `add_markers` function, which loops through the
    GeoJSON layer and creates a marker for each point in the layer. This uses the
    Folium `circle_marker` function, which wants a [y, x] list as its first argument.
    This is where the marker will be placed on the map. You used a different color
    based on the flood status at that location, and also added a popup to go along
    with the marker. The `radius` parameter is the marker radius in pixels. Yours
    are a little larger than the default.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 标记是在 `add_markers` 函数中创建的，该函数遍历 GeoJSON 图层并为图层中的每个点创建一个标记。这使用了 Folium 的 `circle_marker`
    函数，它希望第一个参数是一个 [y, x] 列表。这是标记将在地图上放置的位置。你根据该位置的洪水状态使用了不同的颜色，并为标记添加了一个弹出窗口。`radius`
    参数是标记的像素半径。你的标记比默认的要大一些。
- en: The last steps are to change the `make_map` function so that it calls `add_markers`
    instead of `geo_json`, and then to create a new map. This time you use Stamen
    Toner tiles instead of OpenStreetMap, mostly because the markers are easier to
    see that way. Your output should look like [figure 4.8](#ch04fig08), and if you
    click on a marker, you’ll see a popup containing the relevant information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是将 `make_map` 函数更改为调用 `add_markers` 而不是 `geo_json`，然后创建一个新的地图。这次你使用 Stamen
    Toner 瓦片而不是 OpenStreetMap，主要是因为这样标记更容易看到。你的输出应该看起来像 [图 4.8](#ch04fig08)，如果你点击一个标记，你会看到一个包含相关信息的弹出窗口。
- en: Figure 4.8\. A nicer map created by manually constructing colored markers with
    popups
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. 通过手动构建带弹出窗口的彩色标记创建的更美观的地图
- en: '![](04fig08_alt.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig08_alt.jpg)'
- en: Although it isn’t the subject of this book, I hope you enjoyed the short foray
    into web mapping. If you didn’t know anything on the subject and are anything
    like me, you now have another item on your “to learn” list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是本书的主题，但我希望你喜欢这次对网络地图的短暂探索。如果你对这个主题一无所知，并且像我一样，你现在又有一个“要学习”的项目。
- en: 4.3\. Testing format capabilities
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 测试格式功能
- en: As mentioned earlier, not all operations are available with all data formats
    and drivers. How do you find out what’s allowed on your data, other than trying
    it and crossing your fingers that your code doesn’t crash? Fortunately, drivers,
    data sources, and layers are all willing to convey that information if you ask.
    [Table 4.1](#ch04table01) shows which capabilities you can check for each of these
    data types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，并非所有操作都适用于所有数据格式和驱动程序。除了尝试并祈祷你的代码不会崩溃之外，你如何找出你的数据允许什么操作？幸运的是，如果询问，驱动程序、数据源和图层都愿意传达这些信息。[表
    4.1](#ch04table01) 展示了你可以检查每种数据类型的哪些功能。
- en: Table 4.1\. Constants used for testing capabilities
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. 用于测试功能的常量
- en: '| Driver capabilities | OGR constant |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 驱动程序功能 | OGR 常量 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create new data sources | ODrCCreateDataSource |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 创建新数据源 | ODrCCreateDataSource |'
- en: '| Delete existing data sources | ODrCDeleteDataSource |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 删除现有数据源 | ODrCDeleteDataSource |'
- en: '| **DataSource capabilities** | **OGR constant** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **数据源功能** | **OGR 常量** |'
- en: '| Create new layers | ODsCCreateLayer |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 创建新图层 | ODsCCreateLayer |'
- en: '| Delete existing layers | ODsCDeleteLayer |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 删除现有图层 | ODsCDeleteLayer |'
- en: '| **Layer capabilities** | **OGR constant** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **图层功能** | **OGR 常量** |'
- en: '| Read random features using GetFeature | OLCRandomRead |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 使用 GetFeature 读取随机特征 | OLCRandomRead |'
- en: '| Add new features | OLCSequentialWrite |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 添加新特征 | OLCSequentialWrite |'
- en: '| Update existing features | OLCRandomWrite |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 更新现有特征 | OLCRandomWrite |'
- en: '| Supports efficient spatial filtering | OLCFastSpatialFilter |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 支持高效的空间过滤 | OLCFastSpatialFilter |'
- en: '| Has an efficient implementation of GetFeatureCount | OLCFastFeatureCount
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 具有高效的 GetFeatureCount 实现 | OLCFastFeatureCount |'
- en: '| Has an efficient implementation of GetExtent | OLCFastGetExtent |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 具有高效的 GetExtent 实现 | OLCFastGetExtent |'
- en: '| Create new fields | OLCCreateField |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 创建新字段 | OLCCreateField |'
- en: '| Delete existing fields | OLCDeleteField |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 删除现有字段 | OLCDeleteField |'
- en: '| Reorder fields in the attribute table | OLCReorderFields |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 在属性表中重新排序字段 | OLCReorderFields |'
- en: '| Alter properties of existing fields | OLCAlterFieldDefn |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 修改现有字段的属性 | OLCAlterFieldDefn |'
- en: '| Supports transactions | OLCTransactions |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 支持事务 | OLCTransactions |'
- en: '| Delete existing features | OLCDeleteFeature |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 删除现有要素 | OLCDeleteFeature |'
- en: '| Has an efficient implementation of SetNextByIndex | OLCFastSetNextByIndex
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 具有高效的SetNextByIndex实现 | OLCFastSetNextByIndex |'
- en: '| Values of string fields are guaranteed to be UTF-8 encoding | OLCStringsAsUTF8
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 字符串字段的值保证是UTF-8编码 | OLCStringsAsUTF8 |'
- en: '| Supports ignoring fields when fetching feature data, which can speed up data
    access | OLCIgnoreFields |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 支持在获取要素数据时忽略字段，这可以加快数据访问速度 | OLCIgnoreFields |'
- en: 'To check for a given capability, all you have to do is call the `TestCapability`
    function on a driver, data source, or layer, and pass a constant from [table 4.1](#ch04table01)
    as a parameter. The function will return `True` if that operation is allowed and
    `False` if it isn’t. Try using this to determine if you can add new shapefiles
    to a folder:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查某个特定功能，你只需在驱动程序、数据源或层上调用`TestCapability`函数，并将[表4.1](#ch04table01)中的一个常量作为参数传递。如果该操作允许，函数将返回`True`，如果不允许，则返回`False`。尝试使用此方法确定是否可以将新的shapefiles添加到文件夹中：
- en: '![](085fig01_alt.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](085fig01_alt.jpg)'
- en: 'As you probably could’ve guessed, you’re allowed to create new layers when
    the folder has been opened for writing, but not when it has been opened read-only.
    How could you use this information to make sure you didn’t attempt to do something
    that would cause an error? You can modify your code to add checks before you try
    to do any editing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你或许能猜到的，当文件夹以写入方式打开时，你可以创建新层，但在只读方式打开时则不行。你如何使用这个信息来确保你不尝试做会导致错误的事情？你可以在尝试任何编辑之前修改你的代码以添加检查：
- en: '![](086fig01_alt.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](086fig01_alt.jpg)'
- en: This snippet will raise an error and not continue if you aren’t allowed to add
    fields to the layer. You could catch and handle this error if you needed to, or
    let it bail out. If you don’t want to handle the errors, the biggest reason for
    checking beforehand is to make sure that all edits are possible before you start.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许添加字段到层，这个片段将引发错误并停止继续。如果你需要，你可以捕获并处理这个错误，或者让它退出。如果你不想处理错误，事先检查的最大原因是在开始编辑之前确保所有编辑都是可能的。
- en: For example, what if a layer supported editing fields but not deleting features,
    and you wanted to do both? If you edited the fields before deleting the features,
    then part of your changes would take place (the field edits) before your code
    crashed when trying to delete features. Obviously, this is a problem if you want
    all or none when it comes to your edits. If partial edits don’t bother you, then
    you may not want to worry about this issue, but you can avoid the problem by checking
    capabilities beforehand and not proceeding if you’re not allowed to make all of
    your changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个层支持编辑字段但不支持删除要素，而你想要同时进行这两项操作？如果你在删除要素之前编辑了字段，那么部分更改（字段编辑）将在你的代码尝试删除要素时崩溃之前发生。显然，如果你想要所有或没有更改，这是一个问题。如果你不介意部分更改，那么你可能不需要担心这个问题，但你可以通过事先检查功能并在你不被允许进行所有更改时停止操作来避免这个问题。
- en: Another option, if partial edits are okay in your book but you still want to
    handle errors instead of letting the script crash, is to use OGR exceptions. You
    wouldn’t need to add any code to test capabilities, but you’d need to remember
    to add `ogr.Use-Exceptions()` somewhere early in your script. Using this approach,
    the attempt to delete a feature would still fail, but it then throws a `RuntimeError`
    that you could catch.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是，如果你认为部分编辑是可以接受的，但仍然想要处理错误而不是让脚本崩溃，可以使用OGR异常。你不需要添加任何代码来测试功能，但你需要记得在脚本早期添加`ogr.Use-Exceptions()`。使用这种方法，尝试删除要素的尝试仍然会失败，但它会抛出一个你可以捕获的`RuntimeError`。
- en: 'A function in the ospybook module called `print_capabilities` will print what
    capabilities a driver, data source, or layer supports. Here’s how to use it from
    the Python interactive window:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ospybook模块中的一个函数`print_capabilities`会打印出驱动程序、数据源或层支持的功能。这是如何在Python交互式窗口中使用它的方法：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Because this function only prints out information, you can’t use it in your
    code to determine what action to take based on available capabilities. You can
    use it in an interactive window to determine what actions were allowed on an object,
    though.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个函数只打印出信息，所以你不能在代码中使用它来确定基于可用功能采取什么行动。不过，你可以在交互式窗口中使用它来确定对象上允许执行哪些操作。
- en: 4.4\. Summary
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 摘要
- en: The vector file format you choose to use might depend on the application. You
    might go with GeoJSON for making a web map, but use shapefiles or PostGIS for
    data analysis.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择使用的矢量文件格式可能取决于应用。你可能选择GeoJSON来制作网络地图，但使用shapefiles或PostGIS进行数据分析。
- en: Perhaps the most popular data transfer format is the shapefile because it’s
    simple, the specifications are public, and it has been around for a long time.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最受欢迎的数据传输格式是shapefile，因为它简单，规范是公开的，并且已经存在很长时间了。
- en: Formats based on databases, such as SpatiaLite, PostGIS, and Esri geodatabases,
    tend to be more efficient and support more features than other vector formats.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数据库的格式，如SpatiaLite、PostGIS和Esri地理数据库，通常比其他矢量格式更高效，并支持更多功能。
- en: Although the syntax for opening various data source types differs, once you
    have the data source open, you can access the layers and features the same way
    no matter the source.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管打开各种数据源类型的语法不同，但一旦数据源打开，无论数据源如何，你都可以以相同的方式访问图层和功能。
- en: Multiple layers in a data source can be different from one another. For example,
    they can have different geometry types, attribute fields, spatial extents, and
    spatial reference systems.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据源中的多个图层可能彼此不同。例如，它们可以具有不同的几何类型、属性字段、空间范围和空间参考系统。
- en: You can use `TestCapability` to determine which edits are allowed on your dataset.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`TestCapability`来确定在你的数据集中允许哪些编辑。
