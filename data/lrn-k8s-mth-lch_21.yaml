- en: 17 Securing resources with role-based access control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 使用基于角色的访问控制保护资源
- en: 'You have complete control over your lab cluster: you can deploy workloads,
    read Secrets, and even delete control plane components if you want to see how
    quickly they return. You don’t want anyone to have that much power in a production
    cluster, because if they have full admin control, then it’s really their cluster.
    Their account could be compromised, and then some rogue party deletes all your
    apps and turns your cluster into their personal Bitcoin miner. Kubernetes supports
    least-privilege access with *role-based access control* (RBAC). In this chapter,
    you’ll learn how RBAC works and some of the challenges that come with restricting
    access.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您对您的实验室集群拥有完全控制权：您可以部署工作负载、读取机密，甚至如果您想看看它们返回得有多快，还可以删除控制平面组件。您不希望在生产集群中让任何人拥有如此大的权力，因为如果他们拥有完整的管理员控制权，那么这实际上就是他们的集群。他们的账户可能会被破坏，然后某个恶意方会删除您所有的应用程序，并将您的集群变成他们的个人比特币矿工。Kubernetes通过基于角色的访问控制（RBAC）支持最小权限访问。在本章中，您将了解RBAC是如何工作的以及随之而来的限制访问的一些挑战。
- en: RBAC applies to end users working with kubectl and to internal components using
    the Kubernetes API with service account tokens. You need a different RBAC approach
    for each of those, which we’ll cover in this chapter, together with the best practices.
    You’ll also learn how Kubernetes gets the credentials for external users and how
    you can manage end users inside the cluster if you don’t have an external authentication
    system. RBAC is a straightforward model but with lots of moving pieces, and it
    can be hard to keep track of who can do what, so we’ll finish the chapter looking
    at management tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC适用于使用kubectl进行工作的最终用户以及使用服务账户令牌通过Kubernetes API进行内部组件的访问。您需要为这些不同的用途采用不同的RBAC方法，我们将在本章中介绍，包括最佳实践。您还将了解Kubernetes如何获取外部用户的凭证，以及如果您没有外部身份验证系统，您如何管理集群内的最终用户。RBAC是一个简单的模型，但有很多可移动的部分，因此很难跟踪谁可以做什么，所以我们将通过查看管理工具来结束本章。
- en: 17.1 How Kubernetes secures access to resources
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 Kubernetes如何保护对资源的访问
- en: RBAC works by granting permissions to perform actions on resources. Every resource
    type can be secured, so you can set up permissions to get Pod details, list Services,
    and delete Secrets. You apply permissions to a subject, which could be a user,
    a system account, or a group, but you don’t apply them directly, because that
    would create an unmanageable sprawl of permissions. You set permissions in a role,
    and you apply a role to one or more subjects with a role binding, as shown in
    figure 17.1.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC通过授予对资源执行操作的权限来工作。每种资源类型都可以被保护，因此您可以设置权限来获取Pod详情、列出服务以及删除机密。您将权限应用于一个主题，这可能是用户、系统账户或组，但您不会直接应用它们，因为这会创建一个难以管理的权限蔓延。您在角色中设置权限，并通过角色绑定将角色应用于一个或多个主题，如图17.1所示。
- en: '![](../Images/17-1.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-1.jpg)'
- en: Figure 17.1 RBAC is a security abstraction; object permissions are granted through
    roles and bindings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 RBAC是一种安全抽象；对象权限通过角色和绑定授予。
- en: 'Some Kubernetes resources are specific to a namespace, and some are clusterwide,
    so the RBAC structure actually has two sets of objects to describe and allocate
    permissions: Role and RoleBinding objects work on namespaced objects, and ClusterRole
    and ClusterRoleBinding objects work on the whole cluster. RBAC is technically
    an optional component in Kubernetes, but it is enabled in almost all platforms
    now. You can check that it’s enabled and see some of the default roles using standard
    kubectl commands.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Kubernetes资源是特定于命名空间的，而有些是集群范围的，因此RBAC结构实际上有两套对象来描述和分配权限：Role和RoleBinding对象在命名空间对象上工作，而ClusterRole和ClusterRoleBinding对象在整个集群上工作。从技术上讲，RBAC是Kubernetes中的一个可选组件，但现在几乎在所有平台上都启用了它。您可以使用标准的kubectl命令来检查它是否已启用并查看一些默认的角色。
- en: Try it now You can check the features in your cluster by printing the API versions
    it supports. Docker Desktop, K3s, and all the cloud platforms support RBAC by
    default.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。您可以通过打印它支持的API版本来检查您集群中的功能。Docker Desktop、K3s以及所有云平台默认支持RBAC。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see in figure 17.2 a whole lot of built-in roles are clusterwide. One
    is cluster-admin, and that’s the role you have in your lab cluster. It has permissions
    for all actions (Kubernetes calls them *verbs*) on all resources, and that’s why
    you can do anything you like. The next most powerful role is admin, which has
    pretty much all permissions on all objects but limited to a single namespace.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图17.2中看到许多内置的角色都是集群级别的。其中一个就是cluster-admin，这就是你在你的实验室集群中的角色。它对所有资源上的所有操作（Kubernetes称它们为*动词*）都有权限，这就是为什么你可以做任何你想做的事情。下一个最强大的角色是admin，它在所有对象上几乎都有权限，但限制在单个命名空间内。
- en: '![](../Images/17-2.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图17-2](../Images/17-2.jpg)'
- en: Figure 17.2 RBAC has a default set of roles and bindings for users and service
    accounts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 RBAC为用户和服务账户提供了一组默认的角色和绑定。
- en: That’s all very well, but *who* has the cluster-admin role? You don’t log in
    to kubectl with a username and password for your own lab, and there is no user
    object in Kubernetes, so how does Kubernetes know who the user is? Kubernetes
    does not authenticate end users; it relies on external identity providers and
    trusts them to authenticate. In a production system, your cluster would be configured
    to use your organization’s existing authentication system—Active Directory (AD),
    LDAP, and OpenID Connect (OIDC) are all options.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，但*谁*拥有cluster-admin角色？你不会用你的实验室的用户名和密码登录kubectl，而且在Kubernetes中没有用户对象，所以Kubernetes是如何知道用户是谁的呢？Kubernetes不验证最终用户；它依赖于外部身份提供者，并信任它们进行验证。在生产系统中，你的集群将被配置为使用你组织现有的身份验证系统——Active
    Directory (AD)、LDAP和OpenID Connect (OIDC)都是可行的选项。
- en: Cloud platforms integrate Kubernetes with their own authentication, so AKS users
    authenticate with Azure AD accounts. You can configure your own OIDC provider,
    but the setup is quite heavy, so in our lab cluster, we’ll stick with certificates.
    Kubernetes is able to issue client certificates for end users, which you request
    with a username. When the Kubernetes API server sees that certificate in incoming
    requests, it trusts the issuer (itself) and accepts that the user is who they
    say they are. We’ll start by generating a new certificate for a user who will
    have limited access in the cluster.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 云平台将Kubernetes与其自身的身份验证集成，因此AKS用户使用Azure AD账户进行身份验证。你可以配置自己的OIDC提供者，但设置相当复杂，所以在我们实验室集群中，我们将坚持使用证书。Kubernetes可以为最终用户颁发客户端证书，你可以通过用户名来请求这些证书。当Kubernetes
    API服务器看到传入请求中的证书时，它会信任发行者（即自身）并接受用户是他们所说的那个人。我们将首先为将在集群中拥有有限访问权限的用户生成一个新的证书。
- en: Try it now Creating certificate requests for Kubernetes to sign requires a few
    steps, which I’ve scripted in a container image. Run a Pod from that image to
    generate certificates and then copy the certificate and key onto your local machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 创建Kubernetes签名证书请求需要几个步骤，我已经在容器镜像中编写了脚本。从这个镜像中运行一个Pod来生成证书，然后将证书和密钥复制到你的本地机器上。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll see in the output from the first command that the exercise creates some
    roles and bindings of its own. The Pod container runs a script that uses kubectl
    to issue the client certificate. That’s a privileged action, so the manifest makes
    sure the Pod has the permissions it needs. The steps are a bit convoluted, which
    is why I’ve wrapped them in a container image—the script `user-cert-generator/start.sh`
    does the work, if you want to dig into the detail. My output in figure 17.3 shows
    that the certificate and key file are on my local machine, which is all I need
    to access my cluster as an authenticated user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在第一个命令的输出中看到，练习创建了一些自己的角色和绑定。Pod容器运行一个脚本，使用kubectl颁发客户端证书。这是一个特权操作，所以清单确保Pod有它需要的权限。步骤有点复杂，这就是为什么我把它们封装在一个容器镜像中——脚本`user-cert-generator/start.sh`执行工作，如果你想深入了解细节。我图17.3中的输出显示，证书和密钥文件在我的本地机器上，这就是我作为已验证用户访问集群所需的一切。
- en: '![](../Images/17-3.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图17-3](../Images/17-3.jpg)'
- en: Figure 17.3 Kubernetes can issue its own client certificates for new authenticated
    users.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 Kubernetes可以为新的已验证用户颁发自己的客户端证书。
- en: If you’re into OpenSSL and certificates, you can decode that certificate file
    and see the common name is reader@kiamol.net. Kubernetes treats this as the name
    of the user, and that will be the subject we can use to apply RBAC. Permissions
    are all additive with RBAC, so subjects start with no permissions, and as role
    bindings are applied, they end up with the sum total of all role permissions.
    The RBAC model is grant-only—you can’t deny permissions. The absence of a permission
    is the same as a deny. We can set up a kubectl context with the new certificate
    and confirm the user starts with zero access.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对OpenSSL和证书感兴趣，您可以解码该证书文件，并看到通用名称是reader@kiamol.net。Kubernetes将其视为用户名称，这将是我们可以用来应用RBAC的主题。权限在RBAC中都是累加的，因此主题初始时没有权限，随着角色绑定的应用，最终将拥有所有角色权限的总和。RBAC模型是仅授权的——您不能拒绝权限。权限的缺失等同于拒绝。我们可以使用新证书设置kubectl上下文，并确认用户初始时没有访问权限。
- en: Try it now Create a new context in kubectl using the generated certificate as
    the credentials, and confirm you can use it to access the cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：使用生成的证书作为凭据，在kubectl中创建一个新的上下文，并确认您可以使用它访问集群。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are two parts to a context in kubectl: the user credentials and the cluster
    to which to connect. In figure 17.4, you can see the user is configured with the
    client certificates, which are embedded into the kubectl config file. If you use
    client certificates like this, your config file is sensitive: if someone obtains
    a copy, they have all they need to connect to your cluster with one of your contexts.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在kubectl中，一个上下文有两个部分：用户凭据和要连接的集群。在图17.4中，您可以看到用户配置了客户端证书，这些证书嵌入到kubectl配置文件中。如果您使用这样的客户端证书，您的配置文件是敏感的：如果有人获得了副本，他们就可以使用您的上下文中之一连接到您的集群。
- en: '![](../Images/17-4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-4.jpg)'
- en: Figure 17.4 Authenticated but unauthorized—users start with no RBAC roles.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 已认证但未授权——用户初始时没有RBAC角色。
- en: The last command in the exercise uses impersonation to confirm that the new
    user doesn’t have any permissions, but Kubernetes doesn’t store users. You can
    use any random string for the username in the `as` parameter, and the output will
    tell you it doesn’t have permissions. What Kubernetes actually looks for is any
    role binding where the username matches the name in the request. If there are
    no bindings, then there are no permissions, so the action is blocked, whether
    or not the username exists in the authentication system. Listing 17.1 shows a
    role binding we can apply to give the new user read-only access to resources in
    the default namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 练习中的最后一个命令使用模拟来确认新用户没有任何权限，但Kubernetes不存储用户。您可以在`as`参数中使用任何随机的字符串作为用户名，输出将告诉您它没有权限。Kubernetes实际上寻找的是任何与请求中名称匹配的用户名称的角色绑定。如果没有绑定，则没有权限，因此操作被阻止，无论用户名是否存在于认证系统中。列表17.1显示了我们可以应用的角色绑定，以给新用户在默认命名空间中只读访问资源的权限。
- en: Listing 17.1 reader-view-default.yaml, applying permissions with a role binding
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.1 reader-view-default.yaml，使用角色绑定应用权限
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a good way to get started with RBAC—use the predefined cluster roles,
    and bind them to subjects for a specified namespace. As we go through the chapter,
    you’ll see how to build custom roles, which are great when you want explicit access
    permissions, but they get hard to manage at scale. Role bindings abstract the
    subject from the roles they have, so you can make changes to access without changing
    roles or objects. When you deploy the role binding from listing 17.1, the new
    user will be able to view resources in the default namespace.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种开始使用RBAC的好方法——使用预定义的集群角色，并将它们绑定到指定命名空间的主题。随着我们进入本章，您将看到如何构建自定义角色，当您需要明确的访问权限时，它们非常棒，但规模扩大时管理起来会变得困难。角色绑定将主题从它们拥有的角色中抽象出来，因此您可以在不更改角色或对象的情况下更改访问权限。当您从列表17.1部署角色绑定时，新用户将能够查看默认命名空间中的资源。
- en: Try it now Apply a role binding, and impersonate the new user to confirm that
    they have read-only access to resources.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：应用一个角色绑定，并模拟新用户以确认他们只有对资源的只读访问权限。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see the view role in action in figure 17.5—the new user can list Pods
    but only in the default namespace. The role has no permission to delete objects,
    so the reader user can see Pods but not delete them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图17.5中看到视图角色的实际应用——新用户可以列出Pods，但仅限于默认命名空间。该角色没有删除对象的权限，因此读者用户可以看到Pods但不能删除它们。
- en: '![](../Images/17-5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-5.jpg)'
- en: Figure 17.5 Role bindings are scoped so the permissions apply to only one namespace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 角色绑定的作用域仅限于一个命名空间。
- en: The disconnect between users and roles feels slightly odd and can lead to problems.
    Kubernetes has no real integration with the authentication system, so it doesn’t
    validate that usernames are correct or that groups exist. It’s strictly authorization
    you configure in RBAC as far as end users are concerned. But you know from chapter
    16 that you also need to secure the cluster from inside for apps that use the
    Kubernetes API, and the cluster manages both authentication and authorization
    for service accounts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和角色之间的脱节感觉有点奇怪，可能会导致问题。Kubernetes 与认证系统没有真正的集成，因此它不会验证用户名是否正确或组是否存在。对于最终用户而言，RBAC
    中配置的完全是严格的授权。但你知道，从第 16 章中你可以了解到，你还需要保护使用 Kubernetes API 的应用程序的集群内部安全，集群管理服务账户的认证和授权。
- en: 17.2 Securing resource access within the cluster
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 在集群内保护资源访问
- en: 'Every namespace has a default service account created automatically, and any
    Pods that don’t specify a service account will use the default. The default service
    account is just like any other RBAC subject: it starts off with no permissions
    until you add some, and you add them using the same role bindings and cluster
    role bindings that you use with end user subjects. Service accounts are different
    because apps generally need a much more limited set of permissions, so the best
    practice is to create a dedicated service account for each component.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命名空间都会自动创建一个默认服务账户，任何未指定服务账户的 Pod 都会使用默认账户。默认服务账户就像任何其他 RBAC 主体一样：它一开始没有任何权限，直到你添加一些，你将使用与最终用户主体相同的角色绑定和集群角色绑定来添加它们。服务账户之所以不同，是因为应用程序通常需要更有限的权限集，因此最佳实践是为每个组件创建一个专用的服务账户。
- en: Creating a service account and setting up roles and bindings adds a lot of overhead,
    but remember that this is not about restricting access to resources in your application
    model. You can include ConfigMaps and Secrets and whatever else you need in your
    manifests, and they not are affected by the service account permissions at run
    time. RBAC for service accounts is purely about securing apps that use the Kubernetes
    API server—like Prometheus, which queries the API to get lists of Pods. This situation
    should be rare with your standard business apps, so this procedure is just about
    securing the special cases where you’ll run into problems if you use the default
    service account in the same namespace for every app. We’ll start this section
    by creating a new namespace to look at its default service account.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务账户并设置角色和绑定会增加很多开销，但请记住，这并不是限制你应用程序模型中资源访问的问题。你可以在你的清单中包含 ConfigMaps 和 Secrets
    以及你需要的任何其他内容，它们在运行时不会受到服务账户权限的影响。服务账户的 RBAC 仅关于保护使用 Kubernetes API 服务器的应用程序——比如
    Prometheus，它会查询 API 以获取 Pod 列表。这种情况在你的标准商业应用程序中应该是很少见的，所以这个程序只是关于保护那些如果你为每个应用程序在同一个命名空间中使用默认服务账户会遇到问题的特殊情况。我们将从这个部分开始，创建一个新的命名空间来查看其默认服务账户。
- en: Try it now Create a new namespace, and check the permissions of its service
    account—and fixing a bug with Docker Desktop if you use it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 创建一个新的命名空间，并检查其服务账户的权限——如果你使用 Docker Desktop，还需要修复其上的一个 bug。
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `can-i` command is a useful way to check permissions without actually affecting
    any objects. You can see in figure 17.6 that you can combine the command with
    impersonation and a namespace scope to show the permissions for another subject,
    which could be a user or a service account.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`can-i` 命令是一个检查权限而不实际影响任何对象的有用方法。你可以在图 17.6 中看到，你可以将此命令与模拟和命名空间范围结合使用，以显示另一个主体的权限，这可以是用户或服务账户。'
- en: '![](../Images/17-6.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6](../Images/17-6.jpg)'
- en: Figure 17.6 A system controller ensures every namespace has a default service
    account.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 系统控制器确保每个命名空间都有一个默认服务账户。
- en: 'You saw in the exercise that new service accounts start with zero permissions,
    which is where the trouble starts if you use the default account for all your
    apps. Each app might need a set of permissions—they all get added to the default
    account, which soon ends up with far more power than it needs. If any of the apps
    using that service account are compromised, the attacker finds themselves with
    a bonus set of roles. The certificate generator from section 17.1 is a good example:
    it uses the Kubernetes API to issue client certificates, which is a privileged
    action. Listing 17.2 shows the cluster role the app’s service account uses to
    get the permissions it needs. The full manifest also contains a cluster role binding.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你在练习中看到，新的服务账户从零权限开始，如果你为所有应用使用默认账户，麻烦就从此开始了。每个应用可能都需要一组权限——它们都被添加到默认账户中，很快这个账户就拥有了比所需更多的权力。如果使用该服务账户的任何应用被攻破，攻击者就会发现自己获得了一组额外的角色。第
    17.1 节中的证书生成器就是一个很好的例子：它使用 Kubernetes API 发布客户端证书，这是一个特权操作。列表 17.2 展示了应用的服务账户使用的集群角色，以获取所需的权限。完整的清单还包含了一个集群角色绑定。
- en: Listing 17.2 user-cert-generator.yaml, a custom cluster role for certificate
    generation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.2 user-cert-generator.yaml，用于证书生成的自定义集群角色
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Generating certificates needs permission to create signing requests and approve
    them using the API Server issuer. If I was lazy, I could bind this role to the
    default service account on the justification that this app isn’t publicly accessible,
    so the attack surface is small, and no other apps are using that account. But,
    of course, it’s the default service account, and Kubernetes mounts the account
    token by default. If someone deploys a vulnerable web app in this same namespace,
    it will have permission to generate user certificates so attackers could generate
    their own credentials. Instead, I created a dedicated service account just for
    the certificate generator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成证书需要使用 API 服务器发行者创建签名请求并批准它们，如果我很懒，我可以基于这个应用不是公开可访问的、攻击面很小、没有其他应用使用该账户的论据，将这个角色绑定到默认的服务账户上。但是，当然，这是默认服务账户，Kubernetes
    默认挂载账户令牌。如果有人在同一个命名空间中部署了一个有漏洞的 Web 应用，它将有权生成用户证书，攻击者就可以生成他们自己的凭证。相反，我创建了一个专门用于证书生成器的服务账户。
- en: Try it now Confirm that the custom service account for the certificate generator
    app has permission to create certificate-signing requests, but standard service
    accounts don’t have that permission.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Confirm that the custom service account for the certificate generator app
    has permission to create certificate-signing requests, but standard service accounts
    don’t have that permission.
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll see in this exercise that only the certificate-generator service account
    has the certificate permissions. In fact, those are the only permissions that
    account has, so you can’t use it to list namespaces or delete persistent volume
    claims or anything else. You also see in figure 17.7 that the syntax for referring
    to a service account is different from other resource references in Kubernetes-`system:serviceaccount`
    is the prefix, followed by the namespace and account name separated by colons.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你会发现只有证书生成器服务账户才有证书权限。实际上，账户只有这些权限，所以你不能用它来列出命名空间或删除持久卷声明或其他任何东西。你还在图
    17.7 中看到，引用服务账户的语法与 Kubernetes 中的其他资源引用不同——`system:serviceaccount` 是前缀，后面跟着冒号分隔的命名空间和账户名称。
- en: '![](../Images/17-7.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-7.jpg)'
- en: Figure 17.7 Using separate service accounts for apps ensures the least-privilege
    approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 使用单独的服务账户为应用确保最小权限方法。
- en: Issuing client certificates is not a typical app requirement, but creating a
    separate service account for every app that uses the Kubernetes API is still a
    best practice. We’ve got two more examples in this section to show you how apps
    might need to use the API and how to secure them. The key thing to understand
    in RBAC is the scope of your bindings, to be sure you’re applying permissions
    at the right level—typically for a single namespace. The first example of that
    is for a simple web app that lists Pods and lets you delete them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 发布客户端证书不是典型应用的需求，但为每个使用 Kubernetes API 的应用创建单独的服务账户仍然是一个最佳实践。在本节中，我们还有两个示例来展示应用可能需要如何使用
    API 以及如何保护它们。在 RBAC 中，你需要理解绑定的作用域，以确保你在正确的级别应用权限——通常是单个命名空间。第一个例子是一个简单的 Web 应用，它可以列出
    Pods 并允许你删除它们。
- en: Try it now Run the Kube Explorer app, which lists Pods in a web UI. This deployment
    uses a custom service account and role for permissions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Run the Kube Explorer app，它通过 Web UI 列出 Pods。这个部署使用了一个自定义的服务账户和角色来管理权限。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: My output is in figure 17.8, where you can see the app is happily listing and
    deleting Pods for the default namespace. When you switch to a different namespace,
    you’ll see an authorization error, which comes from the Kubernetes API (it’s an
    HTTP API so you actually get a 403 forbidden response). The app uses the service
    account token mounted in the Pod to authenticate, and the account has list and
    delete Pod permissions for only the default namespace, not for other namespaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出在图17.8中，你可以看到应用程序正在愉快地列出和删除默认命名空间中的Pods。当你切换到不同的命名空间时，你会看到一个授权错误，这来自Kubernetes
    API（它是一个HTTP API，所以你实际上会收到一个403禁止响应）。应用程序使用挂载在Pod中的服务账户令牌进行身份验证，并且该账户只有默认命名空间的列出和删除Pod权限，没有其他命名空间的权限。
- en: '![](../Images/17-8.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-8.jpg)'
- en: Figure 17.8 An app with its own service account and just enough permissions
    to do its job
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 拥有自己的服务账户和足够权限完成其工作的应用程序
- en: Little apps like this take no time to build because most languages have a Kubernetes
    library, which takes care of authentication by using the token in the default
    path. They can be very useful for sharing a limited view of the cluster for teams
    who don’t need kubectl access and who don’t need to learn how Kubernetes works
    just to see what’s running. This app needs RBAC permissions to list Pods, show
    their details, and delete them. Right now, those permissions are in a role that
    is bound to the default namespace. To make other namespaces available, we need
    to add more roles and bindings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的小程序构建起来不费时，因为大多数语言都有Kubernetes库，该库通过使用默认路径中的令牌来处理身份验证。它们对于不需要kubectl访问权限且不需要学习Kubernetes的工作原理仅为了查看正在运行的内容的团队非常有用。此应用程序需要RBAC权限来列出Pods、显示它们的详细信息以及删除它们。目前，这些权限在一个绑定到默认命名空间的角色中。为了使其他命名空间可用，我们需要添加更多角色和绑定。
- en: Listing 17.3 shows the new rules that grant permission to get and list Pods
    in the `kube-system` namespace. The most important thing to take away here is
    that the namespace in the role metadata is not just where the role gets created,
    it’s also the scope where the role applies. This role grants access to Pods in
    the `kube-system` namespace.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.3显示了授予在`kube-system`命名空间中获取和列出Pod权限的新规则。这里最重要的要点是，角色元数据中的命名空间不仅仅是角色创建的地方，也是角色应用的范围。此角色授予对`kube-system`命名空间中Pods的访问权限。
- en: Listing 17.3 rbac-with-kube-system.yaml, applying a role to the system namespace
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.3 rbac-with-kube-system.yaml，将角色应用于系统命名空间
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The role binding that adds that role to the app’s service account is in the
    same manifest file, but I’ve split it into two listings to examine them separately
    and make sense of all the namespaces. The namespace for the role is the scope
    of the permissions; the role binding refers to the role, and it needs to be in
    the same namespace, but it also refers to the subject, and that can be in a different
    namespace. In listing 17.4, the role binding is created in the `kube-system` namespace
    along with the role. Between them, they provide access to the Pods in that namespace.
    The subject is the app’s service account, which is in the `default` namespace.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将该角色添加到应用程序服务账户的绑定角色位于同一清单文件中，但我将其拆分为两个列表，以便分别检查它们并理解所有命名空间。角色的命名空间是权限的范围；角色绑定引用角色，并且它需要在同一命名空间中，但它也引用主体，这可以是在不同的命名空间中。在列表17.4中，角色绑定与角色一起在`kube-system`命名空间中创建。它们之间，它们提供了对该命名空间中Pods的访问权限。主体是应用程序的服务账户，它在`default`命名空间中。
- en: Listing 17.4 rbac-with-kube-system.yaml, role binding to a subject
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.4 rbac-with-kube-system.yaml，将角色绑定到主体
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see how things spiral when you have permission requirements that aren’t
    a good fit for the standard cluster roles. In this case, permissions are different
    for different namespaces, so you need a set of roles and role bindings for each
    namespace. When you deploy these new rules, the app will be able to show system
    Pods. Access rules are evaluated when the API call is made, so there are no changes
    to the app or the service account; the new permissions take effect right away.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到不适合标准集群角色的权限要求时，你可以看到事情是如何螺旋上升的。在这种情况下，不同命名空间的权限是不同的，所以你需要为每个命名空间设置一组角色和角色绑定。当你部署这些新规则时，应用程序将能够显示系统Pods。访问规则在API调用时进行评估，所以应用程序或服务账户没有变化；新的权限立即生效。
- en: Try it now Add access rules for system Pods to the Kube Explorer app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试它 向Kube Explorer应用程序添加系统Pods的访问规则。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As shown in figure 17.9, the payback for managing lots of roles and bindings
    is that you can build very fine-grained access policies. This app can list and
    delete Pods in the default namespace, but it can only list Pods in the system
    namespace. No other apps can get those permissions by accident; they would need
    to specify the Kube Explorer service account and be deployed by someone who has
    access to use that account.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如图17.9所示，管理许多角色和绑定所带来的回报是您可以构建非常细粒度的访问策略。此应用可以列出和删除默认命名空间中的Pod，但它只能列出系统命名空间中的Pod。其他应用不可能意外获得这些权限；它们需要指定Kube
    Explorer服务账户，并由有权使用该账户的人部署。
- en: '![](../Images/17-9.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-9.jpg)'
- en: Figure 17.9 RBAC rules take immediate effect when you apply or remove a binding.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 RBAC规则在应用或删除绑定时立即生效。
- en: The last example in this section shows how apps might need to get some configuration
    data from the cluster that isn’t in a ConfigMap or Secret. We’ll use the to-do
    app again. This version displays a banner message on the home page, and it gets
    the content for the banner from the `kiamol` label on the namespace where the
    Pod is running. An init container sets up kubectl with the service account token,
    grabs the label value for the namespace, and writes it to a config file, which
    the app container picks up. It’s not a very realistic scenario, but it shows you
    how to inject data from the cluster into app configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后一个示例展示了应用可能需要从不在ConfigMap或Secret中的集群获取一些配置数据。我们将再次使用待办事项应用。这个版本在主页上显示横幅消息，并从Pod运行的命名空间上的`kiamol`标签获取横幅内容。一个初始化容器使用服务账户令牌设置kubectl，获取命名空间的标签值，并将其写入配置文件，然后应用容器拾取该文件。这不是一个非常现实的场景，但它展示了如何将集群中的数据注入到应用配置中。
- en: Try it now Deploy the new to-do list app, and confirm the banner message is
    populated from the namespace label.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：部署新的待办事项应用，并确认横幅消息是否已从命名空间标签中填充。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: My output is shown in figure 17.10, where you can see the init container has
    fetched the metadata from the namespace. The application container doesn’t use
    the Kubernetes API, but the service account token is mounted to all containers
    in the Pod, so potentially the app could be compromised and an attacker could
    use the Kubernetes API in the context of the service account.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出显示在图17.10中，您可以看到初始化容器已从命名空间中获取了元数据。应用容器不使用Kubernetes API，但服务账户令牌被挂载到Pod中的所有容器上，因此应用可能被破坏，攻击者可能利用服务账户的上下文使用Kubernetes
    API。
- en: '![](../Images/17-10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-10.jpg)'
- en: Figure 17.10 Applications might need to access configuration data from other
    cluster resources.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10 应用可能需要访问来自其他集群资源的配置数据。
- en: 'There’s not much an attacker could do if they did get access to the API from
    the to-do list app. The app uses a dedicated service account, and that account
    has a single permission: it can get the details of the namespace `kiamol-ch17`.
    Listing 17.5 shows how rules inside roles and cluster roles can restrict permissions
    to named resources.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者从待办事项应用中获得了对API的访问权限，他们能做的事情并不多。该应用使用一个专用的服务账户，并且该账户只有一个权限：它可以获取命名空间`kiamol-ch17`的详细信息。列表17.5展示了角色和集群角色内部的规则如何限制对命名资源的权限。
- en: Listing 17.5 02-rbac.yaml, rules for named resources
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.5 02-rbac.yaml，命名资源规则
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One drawback with RBAC is that resources need to exist before the rules can
    be applied, so in this case, the namespace and service account must exist before
    the role and role binding can be created. When you apply a folder of manifests
    with kubectl, it doesn’t look for dependencies to create resources in the correct
    order. It just applies the files in filename order. That’s why the RBAC manifest
    in listing 17.6 is called `02-rbac.yaml`, to ensure it is created after the service
    account and namespace exist.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC的一个缺点是规则在应用之前需要资源存在，因此在这种情况下，命名空间和服务账户必须在创建角色和角色绑定之前存在。当您使用kubectl应用一个manifest文件夹时，它不会寻找依赖关系以正确顺序创建资源。它只是按照文件名顺序应用文件。这就是为什么列表17.6中的RBAC
    manifest被称为`02-rbac.yaml`，以确保它在服务账户和命名空间存在之后创建。
- en: We’ve looked at drilling down into specific permissions for individual apps,
    but the other major function of RBAC is to apply the same set of rules to groups
    of subjects. We’ll move on to that next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了深入到特定应用的权限，但RBAC的另一个主要功能是将同一组规则应用于一组主体。我们将继续探讨这一点。
- en: 17.3 Binding roles to groups of users and service accounts
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 将角色绑定到用户组和服务账户
- en: 'Role bindings and cluster role bindings can be applied to groups, and both
    users and service accounts can belong to groups, although they work differently.
    End users are authenticated outside of Kubernetes, and the API trusts the username
    and group information that is presented. Users can be members of multiple groups,
    and the group name and membership are managed by the authentication system. Service
    accounts are more restricted; they always belong to two groups: a group for all
    service accounts in the cluster, and a group for all the service accounts in a
    namespace.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 角色绑定和集群角色绑定可以应用于组，用户和服务帐户都可以属于组，尽管它们的工作方式不同。最终用户在 Kubernetes 外部进行身份验证，API 信任提供的用户名和组信息。用户可以是多个组的成员，组名和成员资格由身份验证系统管理。服务帐户的限制更多；它们始终属于两个组：集群中所有服务帐户的组，以及命名空间中所有服务帐户的组。
- en: Groups are another kind of subject for a binding, so the spec is the same, except
    you bind a role—or cluster role—to a group instead of a user or service account.
    Kubernetes doesn’t validate the group name, so it’s up to you to make sure the
    group in the binding matches the group set by the authentication system. Certificates
    can include group information, so we can create certificates for users who belong
    to different groups.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 组是绑定的另一种主题，所以规范是相同的，只是你将角色或集群角色绑定到组而不是用户或服务帐户。Kubernetes 不验证组名，所以确保绑定中的组与身份验证系统设置的组相匹配的责任在你。证书可以包含组信息，因此我们可以为属于不同组的用户创建证书。
- en: Try it now Use the certificate generator to create some more authenticated users,
    this time with group membership set in the certificate, for a site reliability
    engineer (SRE) group and a group for testers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 使用证书生成器创建更多经过身份验证的用户，这次在证书中设置组成员资格，为一个站点可靠性工程师（SRE）组和测试者组。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you have two user certificates where the user belongs to a group representing
    their team: SREs and testers. No bindings exist in the cluster for either of the
    usernames or the groups, so the users can’t do anything yet. Figure 17.11 shows
    that Kubernetes uses standard fields in the certificate’s subject—the common name
    is the username and the organization is the group (multiple organizations can
    map to multiple groups).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了两个用户证书，其中用户属于代表他们团队的组：SRE 和测试者。集群中不存在任何用户名或组的绑定，所以用户目前什么都不能做。图 17.11 显示
    Kubernetes 使用证书主题的标准字段——通用名是用户名，组织是组（多个组织可以映射到多个组）。
- en: '![](../Images/17-11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.11](../Images/17-11.jpg)'
- en: Figure 17.11 Certificates can contain zero or more groups as well as the username.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.11 证书可以包含零个或多个组以及用户名。
- en: We do want SREs to be able to delete Pods, and we do want testers to be able
    to read Pod logs. We can apply bindings at the group level to give all the users
    in the team the same permissions. We then move responsibility for managing group
    membership to the authentication system. For SREs, the simplest thing is for them
    to have the view role throughout the cluster so they can help diagnose issues,
    and the edit role for the namespaces their team manages. Those are built-in cluster
    roles, so we just need bindings where the subject is the SRE group. For testers,
    we want the very restricted set of permissions in listing 17.6.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望 SRE 能够删除 Pods，我们也希望测试者能够读取 Pod 日志。我们可以在组级别应用绑定，以给团队中的所有用户相同的权限。然后我们将管理组成员资格的责任移交给身份验证系统。对于
    SRE 来说，最简单的事情是让他们在整个集群中拥有查看角色，这样他们就可以帮助诊断问题，以及拥有他们团队管理的命名空间中的编辑角色。这些是内置的集群角色，所以我们只需要绑定，其中主题是
    SRE 组。对于测试者，我们希望拥有列表 17.6 中非常受限的权限集。
- en: Listing 17.6 test-group.yaml, a role to get Pod details and read logs
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.6 test-group.yaml，一个用于获取 Pod 详细信息和读取日志的角色
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The full manifest from listing 17.6 includes a cluster role binding, giving
    this role to the test group, which effectively gives testers permission to look
    at any Pods and view their logs, but not to list Pods or do anything to any other
    resources. Some resources have subresources, which are permissioned separately,
    so if you have permission to get Pods, you can’t read the logs unless you also
    have permission to get the logs subresource. When you apply the bindings for the
    two groups, the users will have the permissions they need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.6 中的完整清单包括一个集群角色绑定，将此角色授予测试组，这实际上赋予了测试者查看任何 Pods 和查看其日志的权限，但不能列出 Pods
    或对任何其他资源进行操作。某些资源有子资源，这些子资源是单独授权的，所以如果你有获取 Pods 的权限，除非你也有获取日志子资源的权限，否则你不能读取日志。当你为两个组应用绑定时，用户将拥有他们需要的权限。
- en: Try it now Empower the new users by binding the roles they need to the groups
    they belong to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 通过将他们需要的角色绑定到他们所属的组来赋予新用户权力。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see in figure 17.12 that this works as expected: the users have the
    permissions they need, but we apply them at a higher level, binding roles to groups.
    We can change permissions without modifying users or groups. New users can arrive,
    and people can move between teams without any RBAC changes, as long as the authentication
    system is kept up to date so Kubernetes sees the current group membership in the
    API call.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图17.12中看到，这正如预期的那样工作：用户拥有所需的权限，但我们是在更高级别应用它们，将角色绑定到组。我们可以更改权限而无需修改用户或组。新用户可以到来，人们可以在团队之间移动，只要认证系统保持最新，Kubernetes在API调用中看到当前的组成员关系即可，无需进行任何RBAC更改。
- en: '![](../Images/17-12.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-12.jpg)'
- en: Figure 17.12 Permissions at the group level give users what they need with an
    easy management experience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12 在组级别设置权限，为用户提供所需权限并具有易于管理的体验。
- en: This is all fine in a corporate environment with Active Directory configured
    or a cloud environment with integrated authentication. In smaller-scale clusters,
    you may want to manage authentication within Kubernetes, but generating certificates
    like we’ve done in this section isn’t really feasible. The script creates certificates
    which are valid for a year, and the group list is baked into the certificate,
    so it’s hard to make changes to group membership. If you want to revoke access,
    you need to rotate the Kubernetes issuer certificate and distribute new certificates
    to every user.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了Active Directory的企业环境中或具有集成认证的云环境中，这一切都很正常。在较小规模的集群中，您可能希望在Kubernetes内管理认证，但像本节中那样生成证书实际上并不可行。该脚本创建的证书有效期为一年，并且组列表已嵌入到证书中，因此很难更改组成员关系。如果您想撤销访问权限，您需要轮换Kubernetes颁发者证书并向每个用户分发新证书。
- en: A common alternative is to misuse service accounts, creating a service account
    for every end user and distributing a token for authentication with kubectl. This
    approach doesn’t scale to hundreds of users, but it is a viable option if you
    don’t have an external authentication system and you want secure access to Kubernetes
    for a small number of users. You have to take a slightly quirky approach to groups,
    because you can’t create a group and add a service account to it. Instead, you
    need to treat namespaces as groups, create a namespace for each group you want,
    and put all the service accounts in that group. Figure 17.13 shows the setup.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的替代方法是误用服务账户，为每个最终用户创建一个服务账户，并使用kubectl分发令牌进行认证。这种方法无法扩展到数百个用户，但如果您没有外部认证系统，并且希望为数不多的用户提供对Kubernetes的安全访问，它是一个可行的选项。您需要对组采取稍微古怪的方法，因为您不能创建一个组并将服务账户添加到其中。相反，您需要将命名空间视为组，为每个您想要的组创建一个命名空间，并将所有服务账户放入该组。图17.13显示了设置。
- en: '![](../Images/17-13.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-13.jpg)'
- en: Figure 17.13 Service accounts have tokens and groups so they can be misused
    as user accounts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.13 服务账户有令牌和组，因此它们可以像用户账户一样被误用。
- en: Service accounts work as user accounts because you can manage them within the
    cluster, creating or removing them easily and revoking access by deleting the
    token. We can recreate our SRE and tester users with service accounts, using separate
    namespaces to represent the two groups and applying bindings to the groups.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户作为用户账户工作，因为您可以在集群内管理它们，轻松地创建或删除它们，并通过删除令牌来撤销访问权限。我们可以使用服务账户重新创建我们的SRE和测试用户，使用单独的命名空间来表示这两个组，并将绑定应用于这些组。
- en: Try it now Create namespaces for the SRE and tester groups and a service account
    and token for a user in each namespace.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 为SRE和测试组创建命名空间，并为每个命名空间中的用户创建一个服务账户和令牌。
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new cluster role bindings apply to the service account groups, which is
    the namespace where the service accounts have been created. The difference between
    these cluster roles and the user certificate cluster roles is just the group name:
    `system:serviceaccounts:kiamol-authn-sre` for SREs, which is the group for all
    the service accounts in the `kiamol-authn-sre` namespace, as you can see in figure
    17.14.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 新的集群角色绑定适用于服务账户组，这是服务账户已被创建的命名空间。这些集群角色与用户证书集群角色的区别只是组名：`system:serviceaccounts:kiamol-authn-sre`用于SRE，这是`kiamol-authn-sre`命名空间中所有服务账户的组，如图17.14所示。
- en: '![](../Images/17-14.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-14.jpg)'
- en: Figure 17.14 Faking an authentication system with service accounts, tokens,
    and namespaces
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.14 使用服务账户、令牌和命名空间伪造认证系统
- en: Service accounts use a JSON Web Token (JWT) to authenticate. This token is prepopulated
    in Pod volumes. Tokens are created as a Secret of type `kubernetes.io/` `service-account-token`,
    and Kubernetes ensures every service account has at least one token. You can also
    create your own, which makes it easy to distribute, rotate, and revoke the token.
    The process is simple because Kubernetes actually generates the token; you just
    need to create an empty Secret of the correct type, and the cluster adds the data—you
    did that in the previous exercise, so these accounts are ready to use.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户使用JSON Web Token (JWT)进行身份验证。此令牌预先填充在Pod卷中。令牌作为类型为`kubernetes.io/` `service-account-token`的Secret创建，Kubernetes确保每个服务账户至少有一个令牌。您也可以创建自己的令牌，这使得分发、轮换和吊销令牌变得容易。这个过程很简单，因为Kubernetes实际上生成令牌；您只需创建一个正确类型的空Secret，集群就会添加数据——您在之前的练习中已经做到了这一点，所以这些账户已经准备好使用。
- en: Kubectl supports several different authentication options—certificates we’ve
    already seen as well as username and password, third-party authentication, and
    JWT. You can authenticate to the cluster by setting up a new context with credentials
    that use the token from the service account. Any kubectl commands using that context
    will operate as the service account, so the permissions for the service account
    group will apply.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl支持多种不同的身份验证选项——我们已经看到的证书以及用户名和密码、第三方身份验证和JWT。您可以通过设置使用服务账户令牌的凭据的新上下文来对集群进行身份验证。任何使用该上下文的kubectl命令都将作为服务账户运行，因此将应用服务账户组的权限。
- en: Try it now Create a new context in kubectl for the SRE service account and confirm
    you can access the cluster. This will work with your cluster, whatever authentication
    system it uses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 创建一个新的上下文，用于SRE服务账户的kubectl，并确认您能够访问集群。这将在使用您集群的任何身份验证系统时都有效。
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This exercise works on all clusters, even if they have third-party authentication
    configured, because it uses Kubernetes’s own authentication for service accounts.
    You can see in figure 17.15 that I can issue commands as the SRE service account
    and that user has access to delete Pods in the `kiamol-ch17` namespace.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习适用于所有集群，即使它们配置了第三方身份验证，因为它使用Kubernetes自己的服务账户身份验证。您可以在图17.15中看到，我可以以SRE服务账户的身份发出命令，并且该用户有权删除`kiamol-ch17`命名空间中的Pod。
- en: '![](../Images/17-15.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图17-15](../Images/17-15.jpg)'
- en: Figure 17.15 Distributing the service account token lets users authenticate
    as the account.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.15 分发服务账户令牌使用户能够以该账户的身份进行身份验证。
- en: 'If you’re into JWT, you can decode the contents of that `sa-token` file (the
    online tool at [https://jwt.io](https://jwt.io) will do it for you), and you’ll
    see that Kubernetes is the issuer and the subject is the service account name
    `system:serviceaccount:kiamol-authn-sre:sre2`. RBAC permissions are the combined
    roles for that service account, the group for the service account namespace, and
    the group for all service accounts. A small note of caution here: Be very careful
    with the subject when you grant roles to service account groups. It’s easy to
    accidentally make every account a cluster admin by leaving the namespace off the
    subject (which is the exact problem with some versions of Docker Desktop; see
    the history at [https://github.com/docker/for-mac/issues/4774](https://github.com/docker/for-mac/issues/4774)).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对JWT感兴趣，可以解码`sa-token`文件的内容（[https://jwt.io](https://jwt.io)上的在线工具会为您完成），您会看到Kubernetes是发行者，而主题是服务账户名称`system:serviceaccount:kiamol-authn-sre:sre2`。RBAC权限是该服务账户的联合角色、服务账户命名空间中的组以及所有服务账户的组。在此提醒一点：在授予服务账户组角色时，请非常小心主题。很容易不小心通过省略主题中的命名空间将每个账户都变成集群管理员（这正是某些版本的Docker
    Desktop的问题；请参阅[https://github.com/docker/for-mac/issues/4774](https://github.com/docker/for-mac/issues/4774)的历史记录）。
- en: Now that we manage authentication within the cluster, it’s easy to revoke access
    to a specific user by deleting the token for their service account. The token
    they present from kubectl no longer authenticates the service account, so they’ll
    get unauthorized errors for every action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们管理集群内的身份验证，很容易通过删除特定用户的令牌来撤销其访问权限。他们从kubectl提供的令牌不再验证服务账户，因此他们会对每个操作收到未经授权的错误。
- en: Try it now Stop users authenticating as the SRE service account by deleting
    the token.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 通过删除令牌来停止用户以SRE服务账户的身份进行身份验证。
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Revoking access is easy, as you can see in figure 17.16\. Rotating tokens requires
    a bit more of a process; you can create a new token and send it to the user (securely!)
    and then delete the old token once the user has updated their context. Changing
    groups is more involved because you need to create a new service account in the
    namespace for the group, create and send the new token, and delete the old service
    account.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销访问权限很简单，如图 17.16 所示。轮换令牌需要更多一些过程；您可以创建一个新的令牌并发送给用户（安全地！），然后用户更新了上下文后删除旧令牌。更改组更复杂，因为您需要在组的命名空间中创建一个新的服务账户，创建并发送新的令牌，然后删除旧的服务账户。
- en: '![](../Images/17-16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.16](../Images/17-16.jpg)'
- en: Figure 17.16 You can remove access without removing service accounts by deleting
    tokens.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.16 您可以通过删除令牌来移除访问权限，而不必删除服务账户。
- en: Service accounts for users is a simple approach to securing your cluster, if
    you can live with the limitations. It might be a reasonable way to get started,
    but you should understand your road map, which will most likely be to use OpenID
    Connect (OIDC) for authentication and bind your RBAC rules to OIDC username and
    group claims.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户的服务账户是一种简单的保护集群的方法，如果您能接受其局限性。这可能是一个合理的入门方式，但您应该了解您的路线图，这很可能会使用 OpenID Connect
    (OIDC) 进行身份验证并将您的 RBAC 规则绑定到 OIDC 用户名和组声明。
- en: When you have your authentication system wired up and your RBAC rules set, you
    still have a challenge. Kubernetes doesn’t have a great set of tools for auditing
    permissions, so in the next section, we’ll look at third-party options for verifying
    permissions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的身份验证系统已经配置好并且 RBAC 规则已经设置后，您仍然面临挑战。Kubernetes 没有一套很好的工具用于审计权限，所以在下文中，我们将探讨第三方选项以验证权限。
- en: 17.4 Discovering and auditing permissions with plugins
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 使用插件发现和审计权限
- en: The kubectl `can-i` command is useful for checking if a user can perform a function,
    but that’s the only tool you get for validating permissions, and it doesn’t really
    go far enough. You often want to approach it the other way around and ask who
    can perform a function or print out a matrix of access permissions or search for
    an RBAC subject and see their roles. Kubectl has a plugin system to support additional
    commands, as well as plugins to satisfy all these different ways to approach RBAC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl can-i` 命令对于检查用户能否执行某个功能很有用，但这是您用于验证权限的唯一工具，而且它并没有真正深入到足够远。您通常希望从另一个角度来处理，询问谁可以执行某个功能或打印出访问权限矩阵，或者搜索
    RBAC 主体并查看他们的角色。Kubectl 有一个插件系统来支持额外的命令，以及插件来满足所有这些不同的 RBAC 接近方式。'
- en: The best way to add kubectl plugins is with Krew, the plugin manager. You can
    install Krew directly on your machine, but the installation isn’t super-smooth,
    and you might not want plugins installed on that machine (if you do, the install
    documentation is here [https://krew.sigs.k8s.io/docs/user-guide/setup/install](https://krew.sigs.k8s.io/docs/user-guide/setup/install)).
    I’ve prepped a container image with Krew already installed—you can use that image
    to try out plugins in a safe way. The first one we’ll look at is `who-can`, which
    is like the reverse of `can-i`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 kubectl 插件的最佳方式是使用 Krew，即插件管理器。您可以直接在您的机器上安装 Krew，但安装过程并不十分顺畅，您可能不希望在机器上安装插件（如果您这样做，安装文档在这里
    [https://krew.sigs.k8s.io/docs/user-guide/setup/install](https://krew.sigs.k8s.io/docs/user-guide/setup/install)）。我已经准备了一个已经安装了
    Krew 的容器镜像——您可以使用这个镜像以安全的方式尝试插件。我们将首先查看的是 `who-can`，它类似于 `can-i` 的逆操作。
- en: Try it now Start the Krew Pod, and connect to install and use the `who-can`
    plugin.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 启动 Krew Pod，并连接以安装和使用 `who-can` 插件。
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any binary can be a kubectl plugin, but Krew simplifies the setup and adds some
    process by curating useful plugins. (Krew is a Kubernetes Special Interest Group
    project.) Plugins operate in the context of your authenticated user, so you need
    to be sure they don’t do anything they shouldn’t. The `who-can` plugin from this
    exercise is published by Aqua Security, and as you see in figure 17.17, it works
    by traversing RBAC roles to find matching permissions and then prints the subjects
    who have bindings for those roles.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 任何二进制文件都可以是 kubectl 插件，但 Krew 通过精选有用的插件简化了设置并增加了一些流程。（Krew 是 Kubernetes 特别兴趣小组项目。）插件在您的认证用户上下文中运行，因此您需要确保它们不会执行不应该做的事情。本练习中的
    `who-can` 插件由 Aqua Security 发布，如图 17.17 所示，它通过遍历 RBAC 角色以找到匹配的权限，然后打印出具有这些角色绑定的主体。
- en: '![](../Images/17-17.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.17](../Images/17-17.jpg)'
- en: 'Figure 17.17 Plugins add new features to kubectl: `who-can` is a useful tool
    for RBAC queries.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.17 插件为 kubectl 添加了新功能：`who-can` 是 RBAC 查询的有用工具。
- en: We’ll look at two more plugins that fill gaps in RBAC auditing. The next is
    `access-matrix`, which operates on a resource type or a specific resource and
    prints all the access rules for that object, showing who can do what. This is
    the most useful tool for ongoing auditing, where you could run a scheduled job
    that collects a set of access matrices and confirms no unexpected permissions
    have been set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看另外两个插件，它们填补了 RBAC 审计的空白。下一个是 `access-matrix`，它在一个资源类型或特定资源上操作，并打印出该对象的全部访问规则，显示谁可以做什么。这是持续审计中最有用的工具，您可以在计划作业中运行，收集一系列访问矩阵，并确认没有设置意外的权限。
- en: Try it now Install the `access-matrix` plugin, and print the matrices for different
    resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 安装 `access-matrix` 插件，并打印不同资源的矩阵。
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The default output from `access-matrix` prints nice icons, as you see in figure
    17.18, but you can configure plain ASCII output in the command line. My output
    is heavily snipped because the full permissions list includes all the controllers
    and other system components. The access matrix for a ConfigMap is more manageable,
    and you can see the SRE groups created in section 17.3 have list permission, so
    they can see this object, but the `rbac-tools` service account has full update
    and delete permissions. That’s because I was lazy for this exercise and gave the
    account the `cluster-admin` role instead of building a custom role with just the
    permissions the plugins need.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`access-matrix` 的默认输出会打印出漂亮的图标，如图 17.18 所示，但您可以在命令行中配置纯 ASCII 输出。我的输出被大量截断，因为完整的权限列表包括了所有控制器和其他系统组件。ConfigMap
    的访问矩阵更容易管理，您可以看到在第 17.3 节中创建的 SRE 组具有列表权限，因此它们可以看到这个对象，但 `rbac-tools` 服务账户具有完全更新和删除权限。这是因为我在这个练习中偷懒，给了账户
    `cluster-admin` 角色，而不是构建一个只包含插件所需权限的自定义角色。'
- en: '![](../Images/17-18.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-18.jpg)'
- en: Figure 17.18 The `access-matrix` plugin shows who can do what with different
    resources.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.18 `access-matrix` 插件显示了谁可以使用不同的资源进行什么操作。
- en: The last plugin we’ll look at is `rbac-lookup`, which is useful for searching
    RBAC subjects. It finds matches in users, service accounts, and groups and shows
    you the roles that are bound to the subject. It’s a good one for checking RBAC
    from the user perspective, when you want to confirm that a subject has the correct
    roles assigned.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个插件是 `rbac-lookup`，它对于搜索 RBAC 实体非常有用。它会在用户、服务账户和组中找到匹配项，并显示绑定到实体的角色。这是一个从用户角度检查
    RBAC 的好工具，当您想确认一个实体是否分配了正确的角色时。
- en: Try it now Install the `rbac-lookup` plugin, and search for SRE and test subjects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 安装 `rbac-lookup` 插件，并搜索 SRE 和测试实体。
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One thing no plugin can do is give you the consolidated permissions for a user
    and all the groups they belong to, because Kubernetes has no idea about group
    membership. RBAC works by getting the consolidated permissions when a user is
    presented with the list of their groups, but outside of an incoming request, there
    is no link between users and groups. That’s different with service accounts because
    they always belong to known groups—you can see the SRE groups in figure 17.19\.
    There’s no way to find which users belong to the SRE user group, but you can list
    all the service accounts in the `kiamol-authn-sre` namespace to see who belongs
    to the service account group.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何插件能为您提供一个用户及其所属所有组的综合权限，因为 Kubernetes 对组成员关系一无所知。RBAC 通过在用户展示其组列表时获取综合权限来工作，但在传入请求之外，用户和组之间没有联系。这与服务账户不同，因为它们始终属于已知的组——您可以在图
    17.19 中看到 SRE 组。没有方法可以找到属于 SRE 用户组的用户，但您可以通过列出 `kiamol-authn-sre` 命名空间中的所有服务账户来查看属于服务账户组的成员。
- en: '![](../Images/17-19.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-19.jpg)'
- en: Figure 17.19 Searching for RBAC subjects and printing the roles to which they’re
    bound
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.19 搜索 RBAC 实体并打印它们所绑定的角色
- en: It’s worth exploring the Krew catalog to find more plugins that can help your
    daily workflow. This section focused on the established plugins that help with
    RBAC; they’re popular and have been around for a long time, but there are plenty
    more gems to find. That’s it for the practical work in this chapter. We’ll finish
    up looking at how RBAC affects your workloads and guidance for implementing access
    controls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值得探索 Krew 目录以找到更多可以帮助您日常工作的插件。本节重点介绍了帮助 RBAC 的成熟插件；它们很受欢迎，并且存在很长时间，但还有许多其他宝藏等待发现。本章的实用工作到此结束。我们将完成对
    RBAC 如何影响您的工作负载以及实施访问控制的指导的探讨。
- en: 17.5 Planning your RBAC strategy
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5 规划您的 RBAC 策略
- en: RBAC gives you a consistent way to secure Kubernetes for external users and
    apps running in the cluster. The mechanics of roles and bindings are the same
    for both types of subject, but they need very different approaches. Users are
    authenticated by a separate, trusted system that asserts the username and groups
    the user belongs to. Guidance here is to start with the predefined cluster roles—view,
    edit, and admin—and apply them to groups. The cluster admin role should be strictly
    guarded and used only if you really need it, preferably restricting it to service
    accounts for automated processes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC（基于角色的访问控制）为外部用户和集群中运行的应用程序提供了统一的方式来保护Kubernetes。角色和绑定机制对这两种类型的主体都是相同的，但它们需要非常不同的方法。用户通过一个独立的、受信任的系统进行认证，该系统声明用户名和用户所属的组。这里的指导是，从预定义的集群角色——查看、编辑和管理——开始，并将它们应用于组。集群管理员角色应严格保护，并且仅在真正需要时使用，最好将其限制为自动化流程的服务账户。
- en: Think about using namespaces as a security boundary so you can limit scope further.
    If your authentication system has group information that identifies someone’s
    team and their function on that team, that might be enough to map bindings to
    a role and a product namespace. Be wary of clusterwide roles because they can
    be used to gain elevated access. If a user can read Secrets in any namespace,
    they can potentially grab the JWT token for a privileged service account and get
    admin access to that namespace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将命名空间用作安全边界，以便进一步限制范围。如果你的身份验证系统有分组信息，可以识别某人的团队及其在该团队中的职能，这可能足以将绑定映射到角色和产品命名空间。对集群范围内的角色保持警惕，因为它们可以用来获得提升的访问权限。如果用户可以在任何命名空间中读取机密信息，他们可能能够获取特权服务账户的JWT令牌，并获取该命名空间的管理员访问权限。
- en: Service accounts should be used sparingly and only by apps that need access
    to the Kubernetes API server. You can disable automounting the token in Pods as
    a property of the default service account, so Pods never see the token unless
    they actively request it. Remember that RBAC is not about restricting access at
    deployment time. Pods don’t need a service account configured to use a ConfigMap
    that is mounted as a volume. You need service accounts only for apps that use
    the Kubernetes API, and in those cases, each app should have a dedicated service
    account with just enough permissions for the app to do what it needs, preferably
    with named resources.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应谨慎使用服务账户，并且仅由需要访问Kubernetes API服务器的应用程序使用。你可以通过将默认服务账户的属性设置为禁用自动挂载令牌来禁用Pod中的令牌自动挂载，这样Pod永远不会看到令牌，除非它们主动请求它。记住，RBAC并不是关于在部署时限制访问。Pod不需要配置服务账户来使用作为卷挂载的ConfigMap。你需要服务账户仅用于使用Kubernetes
    API的应用程序，在这些情况下，每个应用程序都应该有一个专门的服务账户，它仅具有足够的权限来完成应用程序所需的工作，最好是与命名资源相关联的权限。
- en: Applying RBAC isn’t the end of the story. As your security profile matures,
    you’ll want to add auditing to ensure policies don’t get subverted and admission
    controllers to ensure new apps have the required security controls. We won’t cover
    that here; just be aware that securing your cluster is about using multiple approaches
    to gain security in depth.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用RBAC并不是故事的结束。随着你的安全配置文件成熟，你将希望添加审计以确保策略不会被规避，并添加准入控制器以确保新应用程序具有所需的安全控制。我们在这里不会涉及这些内容；只需知道，保护你的集群是关于使用多种方法来获得深度安全。
- en: Okay, time to clear down the cluster before you move on to the lab.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在你进入实验室之前，先清空集群。
- en: Try it now Remove all of the chapter’s resources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 移除本章的所有资源。
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 17.6 Lab
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.6 实验室
- en: 'The Kube Explorer app you ran in section 17.2 can also display service accounts,
    but it needs some more permissions to do that. There’s a new set of manifests
    for the app in the lab folder that give it permissions to access Pods in the default
    namespace. Your task for this lab is to add roles and bindings so the app can
    do the following things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你在17.2节中运行的Kube Explorer应用程序也可以显示服务账户，但它需要更多的权限才能做到这一点。实验室文件夹中有该应用程序的新一组清单，它赋予了它访问默认命名空间中Pods的权限。本实验室的任务是为该应用程序添加角色和绑定，以便它可以执行以下操作：
- en: Display and delete Pods in the `kiamol-ch17-lab` namespace
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`kiamol-ch17-lab`命名空间中显示和删除Pods
- en: Display service accounts in the `default` namespace
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`default`命名空间中显示服务账户
- en: Display service accounts in the `kiamol-ch17-lab` namespace
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`kiamol-ch17-lab`命名空间中显示服务账户
- en: 'Look closely at how the existing RBAC rules are set up—that should make this
    one straightforward. Just remember how namespaces in the bindings affect scope.
    My solution is available for you to check: [https://github.com/sixeyed/kiamol/blob/master/ch17/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch17/lab/README.md).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看现有的 RBAC 规则是如何设置的——这应该会让这个过程变得简单。只需记住绑定中的命名空间如何影响作用域。我的解决方案可供您检查：[https://github.com/sixeyed/kiamol/blob/master/ch17/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch17/lab/README.md).
