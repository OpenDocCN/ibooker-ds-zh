- en: 1 Hello again, C++!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 再次欢迎，C++
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why C++ is relevant
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 C++ 仍然相关
- en: When C++ is useful
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 何时有用
- en: What you need to know before reading this book
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在阅读本书之前你需要知道什么
- en: How this book will bootstrap your knowledge of C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书将如何帮助你启动 C++ 知识
- en: What you’ll learn in this book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在本书中学到什么
- en: C++ is an old but evolving language. In programming, you can use it for almost
    anything and will find its application in many places. In fact, C++’s inventor,
    Bjarne Stroustrup, described it as the invisible foundation of everything. Sometimes,
    C++ might be present deep inside a library of another language because it can
    be used for performance-critical paths. Furthermore, it can run in small, embedded
    systems, or it can power video games. Even your browser might be using the language.
    C++ is almost everywhere.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一种古老但不断发展的语言。在编程中，你可以用它来做几乎所有的事情，你会在许多地方找到它的应用。实际上，C++ 的发明者 Bjarne Stroustrup
    将其描述为“一切的无形基础”。有时，C++ 可能深深地存在于另一种语言的库中，因为它可以用于性能关键路径。此外，它可以在小型嵌入式系统中运行，或者为视频游戏供电。甚至你的浏览器可能也在使用这种语言。C++
    几乎无处不在。
- en: The language is compiled and targeted at specific architectures such as a PC,
    mainframe, embedded devices, bespoke hardware, or anything else you can think
    of. If you need your code to run on different types of machines, you need to recompile
    it. This has pros and cons. Different configurations give you more to maintain,
    but compiling to a specific architecture gets you down to the metal, allowing
    the speed advantage. Whatever platform you target, you will need a compiler. You
    will also need an editor or integrated development environment (IDE) to write
    code in C++.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言是编译的，针对特定的架构，如 PC、大型机、嵌入式设备、定制硬件，或任何你能想到的东西。如果你需要你的代码在不同的机器上运行，你需要重新编译它。这既有优点也有缺点。不同的配置给你带来更多的维护工作，但针对特定架构的编译可以使你深入到底层，从而获得速度优势。无论你针对哪个平台，你都需要一个编译器。你还需要一个编辑器或集成开发环境（IDE）来编写
    C++ 代码。
- en: C++ stems from C, which has similar advantages but is a lower-level language.
    If you recognize `++` as the increment operator, you’ll realize that the language’s
    very name suggests it is a successor to C. You can avoid the depths of pointers
    and memory allocations with C++ by writing higher-level code. You can equally
    drop down to C or even assembly language in C++ code. Although C++ was never intended
    to take over the world or even replace C, it does provide many new ways to approach
    coding. For example, you can do a surprising number of things at compile time,
    using type-safe features rather than preprocessor macros often used in C.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 源于 C，它具有类似的优点但是一种更低级的语言。如果你认识到 `++` 是增量运算符，你就会意识到语言的名称本身暗示它是 C 的继承者。你可以通过编写高级代码来避免
    C++ 中指针和内存分配的深度，你同样可以在 C++ 代码中下降到 C 或甚至汇编语言。尽管 C++ 从未打算接管世界或甚至取代 C，但它确实提供了许多新的编程方法。例如，你可以在编译时做许多令人惊讶的事情，使用类型安全特性而不是
    C 中常用的预处理器宏。
- en: This language underpins diverse technologies, including compilers or interpreters
    for other languages, and even C++ compilers themselves. You can develop libraries
    for use in other languages, write games, price financial instruments, and do much
    more. If you ever typed `make` at a prompt, you were probably using C++ without
    knowing it. C++ may power your browser or e-reader if you are reading this book
    in digital form, or it may have been used to write device drivers for your machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言支撑着各种技术，包括其他语言的编译器或解释器，甚至 C++ 编译器本身。你可以为其他语言开发库，编写游戏，定价金融工具，以及做更多的事情。如果你曾在提示符中输入过
    `make`，你很可能在不自知的情况下使用了 C++。如果你以数字形式阅读这本书，C++ 可能正在为你的浏览器或电子阅读器供电，或者它可能被用来编写你机器的设备驱动程序。
- en: This book will give you a firm grounding in a handful of C++ language and library
    features. Each chapter walks through a small, self-contained project, focusing
    on one area. Along with each chapter’s main feature, other parts of the language
    will be covered. For example, if you fill a container, such as a vector or an
    array, you may also want a way to display and manipulate its contents. Thus, the
    next chapter focuses on vectors but also introduces ranges and lambdas, as well
    as using `format` to display output. By gradually building up your repertoire,
    you will gain confidence, which will allow you to rediscover the joy of C++. This
    book will focus on several fundamental parts, showing you various ways in which
    the language is easier now than it used to be. You will end up with a firm grounding,
    ready to use and learn more C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将为你打下C++语言和库特性的坚实基础。每一章都通过一个小型、自包含的项目进行讲解，专注于一个领域。除了每一章的主要特性外，还会涵盖语言的其他部分。例如，如果你填充了一个容器，比如向量或数组，你可能还希望有一种方式来显示和操作其内容。因此，下一章将专注于向量，同时也介绍了范围和lambda表达式，以及使用`format`来显示输出。通过逐渐积累你的知识库，你将获得信心，这将使你能够重新发现C++的乐趣。本书将重点关注几个基本部分，展示语言现在比过去更容易的各种方式。你将获得坚实的基础，准备好使用和学习更多的C++。
- en: 1.1 Why does C++ matter?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 为什么C++很重要？
- en: C++ is designed by a committee. Some languages are introduced and developed
    by a company or an individual. C++ is not. Originally invented by Bjarne Stroustrup,
    Working Group 21 (WG21) of the International Organization for Standardization
    (ISO) is now responsible for its new versions. You can find more details at [https://isocpp.org/std](https://isocpp.org/std).
    There’s been a new ratified standard every three years since 2011, each adding
    new features and sometimes simplifying ways of doing things. This means there
    is a lot to learn. Some documentation and descriptions sound as if they were written
    in legalese, which can be overwhelming. This book will use a few precise definitions
    to help you get the hang of parsing such explanations. Members of the committee
    make suggestions, write papers to explain their ideas, and demonstrate how to
    implement new features or small improvements, which leads to innovations that
    influence other programming languages too. For example, Java and C# would not
    have generics if C++ hadn’t introduced templates. Ideas do flow in both directions.
    C++ also takes on board ideas from other languages, including functional programming
    idioms, such as lambdas.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++是由一个委员会设计的。有些语言是由公司或个人引入和开发的。C++不是。最初由Bjarne Stroustrup发明，国际标准化组织（ISO）的工作组21（WG21）现在负责其新版本。你可以在[https://isocpp.org/std](https://isocpp.org/std)找到更多详细信息。自2011年以来，每三年就会有一个新的标准被批准，每次都会添加新特性，有时还会简化做事的方式。这意味着有很多东西要学习。一些文档和描述听起来就像是用法律术语写的，可能会让人感到压倒。本书将使用一些精确的定义来帮助你理解这些解释。委员会成员提出建议，撰写论文来解释他们的想法，并展示如何实现新特性或小的改进，这导致了影响其他编程语言的创新。例如，如果没有C++引入模板，Java和C#可能就不会有泛型。思想是双向流动的。C++也吸收了其他语言的想法，包括函数式编程习惯，如lambda表达式。
- en: These recent standards injected new life into C++, causing lots of excitement.
    Companies that have been using C++ for years may previously have relied on in-house
    libraries to support features that are now part of the core language. Upgrading
    to a newer standard can be hard work, but it means more people will be able to
    work on the code base without spending time getting up to speed with a niche implementation.
    In addition to changes in the technology stack in businesses, there are now several
    conferences devoted to C++, along with podcasts and blogs, as a new cohort gets
    involved. C++ has a reputation for being very hard-core, with geeks arguing about
    difficult stuff and being mean to newbies (and each other). This is partially
    unfair, but the IncludeCpp group ([https://www.includecpp.org/](https://www.includecpp.org/))
    tries to be inclusive and welcoming. They have a discord group and tend to have
    a stall at C++ conferences, so if you go alone, you can head straight to them
    and say hi. Recent changes have made several parts of C++ easier to explain and
    use but have introduced more edge cases and complications. This book will tend
    to stick with commonly available features that make your life easier, but it’s
    worth knowing a bit about some new, less widely supported features.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最近的标准为C++注入了新的活力，引起了极大的兴奋。那些多年来一直在使用C++的公司可能之前依赖于内部库来支持现在已成为核心语言特性的功能。升级到较新标准可能是一项艰巨的工作，但这意味着更多的人将能够在不花费时间熟悉特定实现的情况下参与代码库的开发。除了企业技术栈的变化之外，现在还有几个专注于C++的会议，以及播客和博客，因为新一代的人开始参与其中。C++以其非常核心而闻名，极客们争论着困难的问题，对新手（以及彼此）都很刻薄。这部分是不公平的，但IncludeCpp小组([https://www.includecpp.org/](https://www.includecpp.org/))试图包容和欢迎。他们有一个Discord群组，并在C++会议上设有摊位，所以如果你一个人去，可以直接去找他们打招呼。最近的变化使得C++的几个部分更容易解释和使用，但同时也引入了更多的边缘情况和复杂性。这本书将倾向于坚持那些使你的生活更轻松的常用特性，但了解一些新特性是有价值的，尽管这些特性支持度不高。
- en: If you knew C++ before C++11, you might be intimidated by the changes. In fact,
    if you spent time catching up and blinked, you've still missed a lot. Fear not.
    Although C++ may resemble riding a bicycle (it hurts if you fall off), C++ doesn’t
    have to be painful. This book will stop you from falling down the rabbit hole.
    You can have fun and learn many approaches and paradigms, from object-oriented
    programming to functional approaches. A grounding in C++ will make other languages
    and approaches easier to understand too. Furthermore, C++ is so pervasive that
    it will never go away, so it’s useful to understand a little. You’ll never know
    all of it. Even Bjarne himself is reputed to have said he’d rate himself at seven
    out of ten on C++ knowledge, so fear not. To be a good programmer, you don’t have
    to know every detail of the language. Knowing enough as a basis to learn more
    is important. If you bootstrap your understanding now, you will also find it easier
    to keep up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在C++11之前了解C++的，你可能会被这些变化吓到。实际上，如果你花时间追赶并眨眼，你仍然错过了很多东西。不必担心。尽管C++可能类似于骑自行车（如果你摔倒了会受伤），但C++不必痛苦。这本书将阻止你掉进兔子洞。你可以享受乐趣，并学习许多方法和范式，从面向对象编程到函数式方法。C++的基础知识也会使其他语言和方法更容易理解。此外，C++如此普遍，它永远不会消失，所以了解一点是有用的。你永远不可能知道所有内容。甚至Bjarne本人据称也说过，他在C++知识方面的评分是七分。所以不必担心。要成为一名优秀的程序员，你不必知道语言的每一个细节。在了解足够的基础上学习更多是很重要的。如果你现在就建立你的理解，你也会发现跟上进度更容易。
- en: C++ has grown over time. Initially, C++ was C with classes, introducing the
    keyword `new` (along with `delete` and `class`) and the idea of constructors and
    destructors. These are functions that run automatically when an object is created
    and when it goes out of scope or is deleted. Unlike garbage-collected languages,
    such as C# and Java, you have control over an object’s lifetime. Proponents of
    garbage-collected languages sometimes deride C++, claiming it’s all too easy to
    end up with memory leaks. Now, you don’t need to use `new` and `delete`, and C++
    has smart pointers to help with memory management. The language evolved over time,
    adding various new features. It still remains relatively compact, although it
    has grown since it began. The language, like all others, is what you make of it.
    You can write terrible code in any language. You can also write beautiful code
    in any language, but you need to learn how. By trying out code as you read this
    book, you will end up with some small programs to play with. They will cover various
    aspects of the language, giving you a firm grounding. You will see how C++ can
    be awesome.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 随着时间的推移而发展壮大。最初，C++ 是在 C 的基础上增加了类，引入了关键字 `new`（以及 `delete` 和 `class`）以及构造函数和析构函数的概念。这些函数在对象创建时以及对象超出作用域或被删除时自动运行。与垃圾回收语言（如
    C# 和 Java）不同，你控制着对象的整个生命周期。垃圾回收语言的拥护者有时会贬低 C++，声称它很容易导致内存泄漏。现在，你不需要使用 `new` 和
    `delete`，C++ 有智能指针来帮助进行内存管理。该语言随着时间的推移而发展，增加了各种新特性。尽管它从开始到现在已经有所增长，但它仍然相对紧凑。就像所有其他语言一样，它取决于你如何使用它。你可以在任何语言中编写糟糕的代码。你同样也可以在任何语言中编写优美的代码，但你需要学会如何做。通过在阅读这本书的过程中尝试代码，你将最终得到一些可以玩耍的小程序。它们将涵盖语言的各个方面，为你打下坚实的基础。你将看到
    C++ 可以有多么出色。
- en: There are many rivals to C++, yet C++ has staying power. It consistently remains
    at the top of the TIOBE index (https://www.tiobe.com/tiobe-index/#2022) and was
    ranked among the top three in 2022\. You could use C instead, but you will see
    stars (pointers being represented with an `*` character). If you want a data structure
    beyond an array, you’ll have to roll your own. You could use High Performance
    Fortran for extremely fast computation. The UK Met Office uses Fortran for their
    weather modeling because they have a vast amount of data to crunch in a very short
    time. Fortran also loiters in many academic institutions, so you may have seen
    or used it if you are an academic or student. However, it is a little niche. You
    are more likely to come across some C++ code in the wider world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多 C++ 的竞争对手，但 C++ 仍然具有持久力。它始终位居 TIOBE 指数（https://www.tiobe.com/tiobe-index/#2022）的榜首，并在
    2022 年排名前三。你可以使用 C，但你将看到星星（指针用 `*` 字符表示）。如果你想使用比数组更复杂的数据结构，你必须自己实现。你可以使用高性能 Fortran
    进行极快的计算。英国气象办公室使用 Fortran 进行他们的天气预报，因为他们需要在非常短的时间内处理大量数据。Fortran 还在许多学术机构中存在，所以如果你是学者或学生，你可能见过或使用过它。然而，它是一个相对较小的领域。你在更广阔的世界中更有可能遇到一些
    C++ 代码。
- en: Various new languages have been invented, aiming to deal with C++ defects or
    annoyances. D feels similar to C++ because of the C-like syntax and high-level
    constructs, and it was invented to deal with the aspects of C++ the creators didn’t
    like. Meanwhile, C++ continues to evolve, but it always aims to remain backward
    compatible, so it is constrained by historical decisions. New languages don’t
    have a legacy and thus have more freedom. Go, Objective C, Swift, Rust, and recently
    Carbon also rival C++ in some areas. That’s fine, and learning several languages
    and thinking about what might make a programmer’s life easier is a good thing.
    Many times, new ideas introduced into the latest C++ standards are based on insights
    from other languages. As new languages have been introduced, C++ still remains
    prevalent and often takes on board any challenges they present. C++ isn’t going
    away anytime soon. You can get involved and submit bug reports or suggestions
    too if you like. The committee consists of volunteers, who work hard to improve
    the language. ISOCpp provides details on how to get involved ([https://isocpp.org/std/meetings-and-participation](https://isocpp.org/std/meetings-and-participation)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 已经发明了各种新的语言，旨在处理 C++ 的缺陷或烦恼。D 语言由于类似 C 的语法和高层结构，感觉与 C++ 类似，它是为了处理创作者不喜欢的 C++
    方面而发明的。同时，C++ 仍在不断发展，但它始终旨在保持向后兼容性，因此受到历史决策的限制。新语言没有遗留问题，因此有更多的自由。Go、Objective
    C、Swift、Rust 以及最近出现的 Carbon 在某些领域也挑战了 C++。这很好，学习几种语言并思考什么可能使程序员的职业生涯更轻松是件好事。很多时候，最新
    C++ 标准中引入的新想法都是基于其他语言的洞察。随着新语言的引入，C++ 仍然非常流行，并且经常接受它们提出的任何挑战。C++ 在不久的将来不会消失。如果你愿意，你也可以参与其中，提交错误报告或建议。委员会由志愿者组成，他们努力改进该语言。ISOCpp
    提供了如何参与的详细信息 ([https://isocpp.org/std/meetings-and-participation](https://isocpp.org/std/meetings-and-participation))。
- en: If you learn C++, you will have a solid foundation for other languages. The
    similarity to other languages can help you quickly pick up how to use them. You
    will get familiar with some data structures and algorithms, as well as various
    paradigms ranging from functional programming to object-oriented code. Even if
    you don’t end up on the standards committee or inventing your own programming
    language, you will be well placed to continue a journey of lifelong learning and
    understand what is happening under the hood.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学习了 C++，你将为其他语言打下坚实的基础。与其他语言的相似性可以帮助你快速掌握如何使用它们。你将熟悉一些数据结构和算法，以及从函数式编程到面向对象代码的各种范式。即使你最终没有加入标准委员会或发明自己的编程语言，你也将处于继续终身学习之旅并理解底层发生的事情的有利位置。
- en: 1.2 When should you use C++?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 你应该在什么时候使用 C++？
- en: You can use C++ for anything, but some use cases are more sensible than others.
    To prototype some machine learning or run a statistics calculation, it might be
    quickest to start in Python and use existing libraries. Of course, those libraries
    may include some C++. If you feel confident enough to look at the source for a
    library to figure out why a bug happens, you have a head start on other programmers.
    If someone needs a program with a frontend, be that a website or local program
    with a graphical user interface (GUI), you could build the whole thing in C++,
    but it might be easier to split up the software. C++ doesn’t support GUIs in the
    core language, unlike, say, C#, so the frontend would require an external library,
    such as the cross-platform C++ library Qt ([https://www.qt.io/](https://www.qt.io/)).
    You could also write the frontend in something completely different and call the
    C++ code as a service or library. So, given that you might start in another language
    to try out an idea or build part of your application in another tool chain, when
    should you use C++?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 C++ 做任何事情，但有些用例比其他用例更有意义。为了原型设计一些机器学习或运行统计计算，可能最快的方法是从 Python 开始，并使用现有的库。当然，这些库可能包含一些
    C++ 代码。如果你足够自信，可以查看库的源代码来找出为什么出现错误，你将比其他程序员有先发优势。如果有人需要一个具有前端（无论是网站还是具有图形用户界面
    (GUI) 的本地程序），你可以用 C++ 构建整个系统，但可能更容易将其拆分。与 C# 等语言不同，C++ 核心语言不支持 GUI，因此前端将需要一个外部库，例如跨平台的
    C++ 库 Qt ([https://www.qt.io/](https://www.qt.io/))。你也可以用完全不同的东西编写前端，并将 C++ 代码作为服务或库调用。所以，考虑到你可能从另一种语言开始尝试一个想法，或在另一个工具链中构建应用程序的一部分，你什么时候应该使用
    C++？
- en: If you want a first-person shooter-style game, you could try to write it in
    JavaScript, but using a language that compiles to the hardware is more sensible.
    An interpreted language will be slower than a compiled language. C++ is therefore
    frequently used to write the game engine, render the graphics, work out the physics,
    detect collisions, and provide sound and artificial intelligence for bots. A scripting
    language might call into this engine, but the engine’s power and speed often come
    from C++, squeezing every inch of power out of a top-end graphics card or another
    component of an expensive gaming rig. This also makes C++ suitable for high-performance
    computing (HPC), financial applications, embedded devices, and robotics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一款第一人称射击风格的电子游戏，你可以尝试用JavaScript编写，但使用编译到硬件的语言更合理。解释型语言会比编译型语言慢。因此，C++经常被用来编写游戏引擎、渲染图形、处理物理、检测碰撞，并为机器人提供声音和人工智能。脚本语言可能会调用这个引擎，但引擎的强大和速度通常来自C++，从高端显卡或其他昂贵的游戏设备中榨取每一寸性能。这也使C++适合高性能计算（HPC）、金融应用、嵌入式设备和机器人技术。
- en: Because C++ takes you close to the metal, you can break things. It’s possible
    to brick an embedded device if you are not careful, rendering the machine inoperable.
    You’re unlikely to manage that if you write a program to run on your laptop or
    computer. It might crash, proudly announcing a segmentation fault or similar on
    the way out. An embedded device without an operating system is different. If it’s
    only running one program without an operating system, and that goes wrong, bad
    things can happen. That’s okay too. Bjarne Stroustrup once said, “If you never
    fail, you aren't trying hard enough” ([https://www.stroustrup.com/quotes.html](https://www.stroustrup.com/quotes.html)).
    Although the language allows you to use raw pointers and potentially step over
    memory bounds or invoke undefined behavior, this book will steer you away from
    danger. Just remember, it has been said that with great power comes great responsibility.
    With enough of a solid foundation, you can program responsibly, learn lots, and
    have fun.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为C++让你接近底层硬件，你可以破坏东西。如果你不小心，可能会 brick一个嵌入式设备，使机器无法使用。如果你编写一个在笔记本电脑或计算机上运行的程序，你不太可能做到这一点。它可能会崩溃，自豪地宣布在退出时出现段错误或类似错误。没有操作系统的嵌入式设备是不同的。如果它只运行一个程序而没有操作系统，并且出了问题，可能会发生糟糕的事情。这也是可以接受的。Bjarne
    Stroustrup曾经说，“如果你从未失败，那么你努力的程度还不够”([https://www.stroustrup.com/quotes.html](https://www.stroustrup.com/quotes.html))。尽管这种语言允许你使用原始指针，并可能超出内存边界或调用未定义的行为，但本书将引导你远离危险。只需记住，人们常说，权力越大，责任越大。有了足够坚实的基础，你可以负责任地编程，学到很多东西，并享受乐趣。
- en: Although C++ doesn’t support several things natively, such as unit testing,
    GUI coding, or even networking (that nearly made it into C++23 and might make
    it into a future standard), you can do these things using a suitable third-party
    library. What the core C++ language does provide is a large and thought-through
    standard library. If you were using C and wanted a normal distribution of random
    numbers, you’d need to dust off a mathematics book or read what Donald Knuth has
    to say on the matter. If you need a lookup table, you can use C++’s standard map.
    In C, you’d have to write your own. In fact, you get stacks, queues, heaps, and
    almost every data structure you can think of in C++ out of the box, along with
    a vast number of algorithms. This means learning C++ provides a solid foundation
    for understanding other languages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++原生不支持几件事情，例如单元测试、GUI编码，甚至网络（几乎进入C++23，可能在未来标准中实现），但你可以使用合适的第三方库来做这些事情。核心C++语言提供的是一个大而周到的标准库。如果你使用C，并需要一个正态分布的随机数，你需要翻阅一本数学书或阅读Donald
    Knuth关于这个问题的看法。如果你需要一个查找表，你可以使用C++的标准map。在C中，你必须自己编写。事实上，你从C++中得到堆栈、队列、堆，以及几乎所有你能想到的数据结构，还有大量的算法。这意味着学习C++为理解其他语言提供了坚实的基础。
- en: If you need to do a lot of number crunching quickly, C++ is a great choice.
    Modern language versions also support a variety of random number distributions,
    as you will see in this book, making it relatively easy to set up a variety of
    complicated simulations. Even without using the latest and greatest parts of the
    language, you can build some serious applications in C++. For example, the MRC
    Centre for Global Infectious Disease Analysis, affiliated with Imperial College
    in the United Kingdom, open sourced their COVID-19 simulation model ([https://github.com/mrc-ide/covid-sim](https://github.com/mrc-ide/covid-sim)).
    These models were used to decide public policy in the United Kingdom during the
    pandemic. C++ does the heavy lifting, and some scripts, written in R, are provided
    to display the results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速进行大量数值计算，C++ 是一个很好的选择。现代语言版本也支持各种随机数分布，正如你将在本书中看到的那样，这使得设置各种复杂的模拟相对容易。即使不使用语言中最新和最优秀的部分，你也能用
    C++ 构建一些严肃的应用程序。例如，英国帝国理工学院附属的 MRC 中心全球传染病分析中心开源了他们的 COVID-19 模拟模型 ([https://github.com/mrc-ide/covid-sim](https://github.com/mrc-ide/covid-sim))。这些模型在英国疫情期间被用于决定公共政策。C++
    承担了繁重的工作，并提供了一些用 R 编写的脚本以显示结果。
- en: C++ is often described as a multi-paradigm language. It supports object-oriented
    programming, but you are allowed to write free functions too. You can write low-level
    procedural code if you want, but you can also use generics (i.e., templates) and
    functional-style programming. You can even do template meta-programming (TMP),
    making the compiler do calculations for you. This was an accidental discovery,
    presented by Erwin Unruh at a C++ committee meeting in 1994\. He demonstrated
    a program that didn’t compile but rather printed out the prime numbers in the
    compiler error messages. Playing with TMP can be fun to explore and push to extremes,
    but simpler cases can give faster runtimes with type-safe, compiler-evaluated
    constants. If you learn how to use some C++, you will have a stable foundation
    for many other languages and know a great variety of different programming paradigms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 通常被描述为一种多范式语言。它支持面向对象编程，但你也允许编写自由函数。如果你想写低级过程式代码，你也可以使用泛型（即模板）和函数式编程风格。你甚至可以进行模板元编程（TMP），让编译器为你进行计算。这其实是一个意外发现，由
    Erwin Unruh 在 1994 年的一次 C++ 委员会会议上提出。他展示了一个无法编译但会打印出编译器错误信息中的素数的程序。玩转 TMP 可以很有趣，探索并推向极致，但简单的案例可以提供更快的运行时间，以及类型安全的、编译器评估的常量。如果你学会了如何使用一些
    C++，你将为许多其他语言打下稳定的基石，并了解各种不同的编程范式。
- en: 1.3 Why read this book?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 为什么阅读这本书？
- en: As the language evolves, people are writing books for each new standard and
    more general-purpose style guides. The style guides won’t make any sense if you
    don’t know the new features, and the new features build on previous changes, so
    the full details can be overwhelming. Where do you start in the face of a moving
    target? Where you are. You need a way to bootstrap your learning. This book will
    take you through some central changes via small projects so you have something
    to experiment with. By using some of the new features, you’ll be better able to
    recognize what modern C++ code is doing and know where to keep an eye out for
    further changes and developments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着语言的发展，人们为每个新的标准和更通用的风格指南编写书籍。如果你不了解新特性，风格指南将毫无意义，而新特性建立在之前的变化之上，所以全部细节可能会让人感到压倒性。面对不断变化的目标，你从哪里开始？从你所在的地方开始。你需要一种方法来自我启动学习。这本书将通过一些小型项目带你了解一些核心变化，这样你就有东西可以实验。通过使用一些新特性，你将更好地识别现代
    C++ 代码正在做什么，并知道在哪里关注进一步的变更和发展。
- en: Instead of reading a list of all the changes you may have missed, the ISOCpp
    website has a FAQ section ([https://isocpp.org/wiki/faq](https://isocpp.org/wiki/faq))
    that provides an overview of some recent changes and big-picture questions. This
    website is run by the Standard C++ Foundation, a not-for-profit organization whose
    purpose is to support the C++ software developer community and promote the understanding
    and use of modern Standard C++. The site even has a section for people with a
    background in other languages who want to learn C++. It doesn’t have a section
    for “Learning C++ if you already knew C++ a while ago.” This book plugs that gap.
    You don’t need a long list of every feature that’s been introduced over the years.
    You need just enough to get your confidence back.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与其阅读可能错过的所有更改列表，ISOCpp 网站有一个常见问题解答部分 ([https://isocpp.org/wiki/faq](https://isocpp.org/wiki/faq))，它概述了一些最近的更改和宏观问题。该网站由标准
    C++ 基金会运营，这是一个非营利组织，其目的是支持 C++ 软件开发社区并推广对现代标准 C++ 的理解和应用。该网站甚至有一个针对有其他语言背景且想学习
    C++ 的人的板块。它没有针对“如果你之前已经知道 C++ 有一段时间了，如何学习 C++”的板块。这本书填补了这一空白。你不需要一个包含多年来引入的所有功能的冗长列表。你需要的是足够的，以恢复你的信心。
- en: You can keep an eye on the myriad and excellent resources online to stay aware
    of what has been and is changing in the language. ISOCpp will help you do this.
    However, you do need to stop and try things out to learn. Spending time experimenting
    will pay off, and this book will guide you through some useful experiments. Trying
    out features in bite-sized chunks will help you crystalize ideas and concepts.
    You will see alternative approaches from time to time. By seeing two ways to put
    items in a `vector`, you will learn a new feature (the `emplace` methods) and
    recall an old feature (`push_back`). This will help you read other people’s code
    and not be wrong-footed by unfamiliar approaches. You will learn how to think
    through alternatives, becoming aware of advice from different places, which sometimes
    conflicts. This book will take a pragmatic approach while encouraging you to think
    about alternatives.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以关注网上众多优秀的资源，以保持对语言中已经发生和正在发生的变化的了解。ISOCpp 将帮助你做到这一点。然而，你需要停下来尝试一些事情来学习。花时间进行实验将会有回报，这本书将引导你通过一些有用的实验。以小块的形式尝试功能将帮助你使思想和概念具体化。你将不时看到替代方法。通过看到将项目放入
    `vector` 的两种方式，你将学习一个新特性（`emplace` 方法）并回忆起一个旧特性（`push_back`）。这将帮助你阅读他人的代码，不会被不熟悉的方法所困惑。你将学习如何考虑替代方案，意识到来自不同地方的建议，有时这些建议是相互冲突的。这本书将采取实用主义的方法，同时鼓励你考虑替代方案。
- en: 1.4 How does this book teach C++?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 这本书是如何教授 C++ 的？
- en: This book covers a subset of features introduced into C++, from C++11 onward.
    At the time of writing, C++23 is in feature-freeze, making it ready for a new
    standard. Each chapter focuses on one main feature, although it introduces and
    uses other modern features and idioms as well. Some people who used to know C++
    well are put off by how many new things they will have to learn to start using
    it again, and beginners often get frightened off quickly. It doesn’t have to be
    so hard. Getting up to speed now will make it easier to keep track as C++ continues
    to change and evolve. If you haven’t used C++ for a long time and have seen other
    books going through an extensive list of all the new features and idioms, but
    you don’t know where to start or how to use them, this book will help you focus
    on some important parts, enabling you to dive into gnarly edge cases and thorough
    explanations elsewhere afterward.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了从 C++11 开始引入的 C++ 特性的子集。在撰写本书时，C++23 正处于特性冻结阶段，使其准备好推出新的标准。每一章都专注于一个主要特性，尽管它也介绍了并使用了其他现代特性和惯用法。有些人以前对
    C++ 很熟悉，但被需要学习的新事物数量所吓倒，而初学者往往很快就会感到害怕。这不必如此困难。现在跟上进度将使跟踪 C++ 继续变化和发展的过程变得更加容易。如果你已经有一段时间没有使用
    C++，并且看到其他书籍列出了所有新的特性和惯用法，但你不知道从哪里开始或如何使用它们，这本书将帮助你专注于一些重要的部分，使你能够在其他地方深入探讨复杂边缘情况和详细解释。
- en: This book focuses on self-contained projects using various parts of C++. You
    will try out some ideas and learn language features on the ride, rather than plow
    through each part of the language’s syntax and standard libraries using one-line
    examples. If you have gone rusty, this book will give you a chance to practice
    and rediscover the joy of using C++. As you probably realize, writing a whole
    program gives you more practice than playing around with one or two lines. This
    book will therefore help you teach yourself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书专注于使用 C++ 的各个部分进行独立项目。你将在旅途中尝试一些想法，并学习语言特性，而不是通过一行行的示例来逐个分析语言的语法和标准库。如果你已经生疏了，这本书将给你一个练习和重新发现使用
    C++ 欢乐的机会。正如你可能意识到的，编写一个完整的程序比玩弄一两行代码能提供更多的实践机会。因此，这本书将帮助你自学。
- en: 1.4.1 Who this book is for
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 这本书面向的对象
- en: This book is aimed at people who have used a little, or even a lot, of the language
    and lost track of recent changes. If you recognize the syntax and want to try
    to learn more, you will gain something from this book. If you know what `int`
    `x` `=` `5;` `int` `&` `y=x;` do, have used an `std::vector<int>` before, and
    recognize `std::cout` `<<` `x`, you will be able to follow. If you’ve seen `int
    x{1};` before, you’re part way there. If not, don’t panic. The curly braces are
    a new way to initialize almost everything, which you’ll soon get the hang of.
    If you used to know all the gnarly edge cases and quote chapter and verse of a
    previous standard, this book will help you focus on a handful of new features
    to get you back in the driving seat. Once you’ve finished reading this book, you
    will know where to get an up-to-date compiler and how to keep an eye on upcoming
    changes, and you’ll be able to read and write modern C++. Let’s look at some code
    now to get a feel for a few new ways of writing the language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标读者是那些曾经使用过一些，甚至很多，这种语言但失去了对最近变化跟踪的人。如果你认识这种语法并想尝试学习更多，你将从这本书中获得一些收获。如果你知道
    `int x = 5;` `int &y = x;` 的作用，之前使用过 `std::vector<int>`，并认识 `std::cout << x`，你将能够理解。如果你之前见过
    `int x{1};`，你已经走了一半的路。如果没有，不要慌张。花括号是初始化几乎所有内容的新方法，你很快就会习惯的。如果你以前知道所有复杂的边缘情况，并能引用之前标准的章节和段落，这本书将帮助你专注于一些新特性，让你重新回到驾驶座。一旦你读完这本书，你将知道如何获取最新的编译器以及如何关注即将到来的变化，你将能够阅读和编写现代
    C++。现在让我们看看一些代码，以了解一些编写语言的新方法。
- en: 1.4.2 Hello, again, C++!
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 再次，C++！
- en: It’s conventional to start learning a language with a “Hello, World!” program,
    so let’s do just that. The following code prints a greeting onscreen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会从“Hello, World!”程序开始学习一门语言，所以我们就这样做。以下代码会在屏幕上打印一条问候信息。
- en: Listing 1.1 Hello, World
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 Hello, World
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Includes a header
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含一个头文件
- en: ❷ Trailing return type
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 后置返回类型
- en: '❸ Operators :: and <<'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ 运算符 :: 和 <<'
- en: If you save this to a file called `hello_world.cpp`, you can compile it. For
    example, using the GNU compiler collection (gcc; see [https://gcc.gnu.org/](https://gcc.gnu.org/)),
    use g++ supporting C++11 with
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个程序保存为名为 `hello_world.cpp` 的文件，你可以编译它。例如，使用 GNU 编译器集合（gcc；见 [https://gcc.gnu.org/](https://gcc.gnu.org/)），使用支持
    C++11 的 g++：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This book assumes you recognize the `include` statement, the scope resolution
    `operator::`, and the stream insertion `operator` `<<`. The code inserts the greeting
    to standard (std) `cout` inside the `main` function, the usual entry point for
    executable code. You knew that, however, the *trailing return type* `->` at the
    end of a function name may be unfamiliar, together with the keyword *auto* at
    the start of the line. You can write `int main()` here instead, as you always
    used to, but when C++11 introduced this feature, many people started using it
    everywhere for consistency. It becomes useful when you want to deduce the type
    a function returns. Our hello program doesn’t need the trailing return. Furthermore,
    `main` is special in that it returns 0 by default, so it does not need a return
    statement even though it returns an `int`. Without a trailing return type, some
    template functions can be very tricky to specify. Let’s consider an example that
    uses a template function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你认识 `include` 语句、作用域解析 `operator::` 和流插入 `operator` `<<`。代码在 `main` 函数中向标准（std）`cout`
    插入问候语，这是可执行代码的常规入口点。然而，你可能不熟悉函数名称末尾的 *尾随返回类型* `->`，以及行首的关键字 *auto*。你可以在这里写 `int
    main()`，就像你以前一直做的那样，但自从 C++11 引入这个特性后，许多人开始为了保持一致性而到处使用它。当你想要推断函数返回的类型时，这很有用。我们的
    hello 程序不需要尾随返回。此外，`main` 函数是特殊的，因为它默认返回 0，所以即使它返回 `int` 类型，也不需要返回语句。没有尾随返回类型，一些模板函数可能很难指定。让我们考虑一个使用模板函数的例子。
- en: You can use the + operator easily enough to add numbers. For example, `auto
    x = 1 + 1.23.` There’s our friend `auto` again. We’re trying to sum an integer
    (1) and a double (1.23), so the result is a double due to *integer* *promotion*.
    If you want a general-purpose addition function, you could attempt to write overloads
    for every possible pair of parameters or, more sensibly, write a template function.
    Even better, you can use one that is already written for you. The `functional`
    header includes a definition of `plus.` In fact, this header contains two definitions,
    one of which sums two parameters of the same type, which we create by saying `std::plus<int>`
    to add two integers. Since C++14, a version that deduces the template argument
    types was introduced. Using `std::plus<>` picks the new specialization, which
    works out the types for us. If you try the first version, 1.23 gets converted
    to an `int`, so you get 1 + 1, which some compilers warn about, whereas the second
    version adds the `int` 1 and the `double` 1.23 to get 2.23\. Try it out!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 + 运算符轻松地添加数字。例如，`auto x = 1 + 1.23.`。我们的朋友 `auto` 又出现了。我们试图将一个整数（1）和一个双精度浮点数（1.23）相加，所以结果是双精度浮点数，这是由于
    *整数* *提升*。如果你想有一个通用加法函数，你可以尝试为每一对可能的参数编写重载，或者更合理地，编写一个模板函数。甚至更好，你可以使用已经为你编写好的一个。`functional`
    头文件包含 `plus` 的定义。事实上，这个头文件包含两个定义，其中一个将两个相同类型的参数相加，我们通过说 `std::plus<int>` 来添加两个整数。自
    C++14 以来，引入了一个可以推断模板参数类型的版本。使用 `std::plus<>` 选择新的特化，它会为我们计算出类型。如果你尝试第一个版本，1.23
    会被转换为 `int`，所以你会得到 1 + 1，这可能会让一些编译器发出警告，而第二个版本将 `int` 1 和 `double` 1.23 相加得到 2.23。试试看！
- en: Listing 1.2 Adding two numbers
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 添加两个数字
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Enforces a sum of two ints, so returns 2
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 强制两个整数的和，因此返回 2
- en: ❷ Figures out the different types
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确定不同的类型
- en: You are used to functions starting with the return type and then having a name
    and parameters, such as `int main()`. The return type is given first. To specify
    the return type, `plus` needs to express the addition operation of the two function
    arguments. This is much easier to do with parameter names, but those are not visible
    to the usual return type. The trailing return type makes using parameter names
    to specify the return type possible. You need to say `auto` at the start and indicate
    what type is returned after the trailing `->`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你习惯于函数以返回类型开头，然后是名称和参数，例如 `int main()`。返回类型是首先给出的。为了指定返回类型，`plus` 需要表达两个函数参数的加法操作。这使用参数名称来做要容易得多，但那些名称对于通常的返回类型是不可见的。尾随返回类型使得使用参数名称来指定返回类型成为可能。你需要在开头说
    `auto`，并在尾随 `->` 后面指出返回的类型。
- en: Let’s look at a simplified version of the `operator()` for the `plus<>` specialization.
    Remember, we want to declare a function that takes two things and returns the
    sum of them. We’re going to use a template with two typenames, allowing two different
    types to be summed. The addition itself is the easy part and simply uses the `+`
    operator. The declaration has `auto` at the start and a type at the end.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `plus<>` 特化版本的 `operator()` 的简化版本。记住，我们想要声明一个函数，它接受两个参数并返回它们的和。我们将使用一个模板，包含两个类型名，允许相加两种不同的类型。加法本身是简单的部分，只需简单地使用
    `+` 操作符。声明从 `auto` 开始，以类型结束。
- en: Listing 1.3 A function to add two different types
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 添加两种不同类型的功能
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The operator function is a template using two different types, `T` and `U`,
    for the left-hand side (`lhs`) and right-hand side (`rhs`) of the binary operation,
    respectively. The return type is declared using `decltype` specifier and the expression
    `lhs` `+` `rhs`. If you squint, you can see how that’s similar to the syntax for
    the `main` function we saw earlier. Put them side by side and have a look:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符函数是一个模板，使用两种不同的类型 `T` 和 `U` 分别表示二元运算的左侧 (`lhs`) 和右侧 (`rhs`)。返回类型使用 `decltype`
    指示符和表达式 `lhs + rhs` 声明。如果你眯起眼睛看，你会发现这与我们之前看到的 `main` 函数的语法相似。将它们并排放置，看看：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see the `auto` followed by the function name and parameters, then the
    arrow and the trailing return type in both cases. When we add 1 and 1.23, the
    parameter types are deduced to be an integer and a double. The trailing return
    type uses the expression (1 + 1.23) to get the return type of a double.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在两种情况下都跟随 `auto`、函数名和参数，然后是箭头和尾随返回类型。当我们添加 1 和 1.23 时，参数类型被推断为整数和双精度浮点数。尾随返回类型使用表达式
    (1 + 1.23) 来获取双精度浮点数的返回类型。
- en: 'If you already recognize these new features, great. There are plenty more new
    things to learn. If you’ve never seen any of them before, concentrate on the main
    point here, which you saw when you tried out “Hello, World!”: the trailing return
    type. You’ve learned something already.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经认识这些新特性，那太好了。还有很多新事物要学习。如果你以前从未见过这些，请专注于这里的主要观点，这是你在尝试“Hello, World!”时看到的：尾随返回类型。你已经学到了一些东西。
- en: 1.4.3 What you’ll learn from reading this book
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 从阅读本书中你将学到什么
- en: You’ll learn how to use some new elements of the language, from ranges to random
    numbers, and learn several other simpler ways of doing things on the journey.
    This book starts with a vector and builds up from there. Vectors are a good way
    to revise and then learn new features, including ranges, views, functors, and
    lambdas. Once you’re comfortable filling, displaying, querying, and manipulating
    a vector using ranges and algorithms, you’ll be ready to use other parts of the
    standard library, including time (`chrono`), random numbers, and, finally, coroutines.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何使用语言的一些新元素，从范围到随机数，并在旅途中学习几种其他更简单的方法来做事情。这本书从向量开始，并在此基础上构建。向量是一个很好的复习和学习新特性的方法，包括范围、视图、函数式对象和lambda表达式。一旦你熟悉了使用范围和算法填充、显示、查询和操作向量，你就可以准备使用标准库的其他部分，包括时间（`chrono`）、随机数，最后是协程。
- en: Range-based `for` loops introduced in C++11 made the language simpler. You can
    use them to walk over a container without needing to dive into iterators first.
    Over time, full-blown ranges have become standard too, providing convenience and
    avoiding the direct use of iterators, as well as offering more unified lookup
    and extra safety. Previously, it was possible to pass the start of one container
    and the end of another to an algorithm and not realize this until something horrible
    happened at runtime. Ranges avoid that problem. You’ll become familiar with using
    ranges to view and copy the contents of a container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 中引入的基于范围的 `for` 循环使语言变得更简单。你可以使用它们遍历容器，而无需首先深入迭代器。随着时间的推移，完整的范围也已成为标准，提供了便利，避免了直接使用迭代器，同时提供了更统一的查找和额外的安全性。以前，可以将一个容器的开始传递给算法，并将另一个容器的结束传递给算法，而不会意识到这个问题，直到运行时发生可怕的事情。范围避免了这个问题。你将熟悉使用范围来查看和复制容器的内容。
- en: You’ll find out how and why you don’t need so much boilerplate code in a class
    by using the `default` keyword for constructors and operators. You’ll learn how
    to use the new random number distributions. If you’re used to calling C’s `rand`
    function, the new approach might seem complicated at first, but it’s powerful,
    and when used properly, it helps you avoid mistakes people often make, for example,
    when simulating rolling dice or shuffling a deck of cards.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用构造函数和操作符的 `default` 关键字，你会发现为什么在类中不需要那么多样板代码。你将学习如何使用新的随机数分布。如果你习惯于调用 C
    的 `rand` 函数，新的方法一开始可能看起来很复杂，但它很强大，并且当正确使用时，可以帮助你避免人们常犯的错误，例如在模拟掷骰子或洗牌时。
- en: 'By using self-contained projects in each chapter, you’ll get the chance to
    use all kinds of new and old features. You’ll get to the point where you understand
    new features, knowing when and why to use them in an idiomatic way. Sometimes
    opinions on the best way to do things differ. You saw the trailing return type
    early: `auto` `main()` `->` `int`. Some people love it and use it everywhere,
    but some people hate it. The language’s evolution has taken us beyond arguing
    about brace placement (sorry in advance if you don’t like my approach) and given
    us lots more to argue about. This book will give alternatives, firmly sitting
    on the fence when it comes to such discussions so that you can concentrate on
    trying to write some code and experiment with new ways of expressing yourself.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个章节中使用自包含的项目，你将有机会使用各种新功能和旧功能。你将达到理解新功能的地步，知道何时以及如何以惯用的方式使用它们。有时关于做事的最佳方式有不同的观点。你早些时候看到了尾随返回类型：`auto`
    `main()` `->` `int`。有些人非常喜欢它并在任何地方使用它，但有些人则不喜欢。语言的演变使我们超越了争论括号放置（如果你不喜欢我的方法，请提前原谅）并给了我们更多可以争论的东西。这本书将提供替代方案，在讨论此类问题时坚定地站在中间，这样你就可以专注于尝试编写一些代码并尝试用新的方式表达自己。
- en: 1.5 Some pro tips
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 一些专业技巧
- en: It’s possible to get lost or overwhelmed when learning, especially if you are
    trying to tackle a big topic. If you bear in mind the following few tips, you’ll
    be able to find your way.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习过程中可能会感到迷茫或不知所措，尤其是当你试图处理一个大主题时。如果你记住以下几点，你将能够找到自己的路。
- en: First, many of the new features are *syntactic sugar*, and second, many elements
    of code use punctuation, which is hard to look up. If you wanted to find out what
    the `->` symbol was doing in the main function given previously, where would you
    start? One very useful tool is Andreas Fertig’s C++ Insights ([https://cppinsights.io/](https://cppinsights.io/))
    website. C++ Insights transforms code to show the details behind some newer C++
    features. It is based on Clang ([https://clang.llvm.org/](https://clang.llvm.org/))
    and Andreas’ understanding of C++ ([https://cppinsights.io/about.html](https://cppinsights.io/about.html)).
    If you type in the `plus` code we looked at in listing 1.2, C++ Insights will
    transform the code for you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，许多新特性都是 *语法糖*，其次，许多代码元素使用标点符号，这很难查找。如果你想知道之前给出的主函数中 `->` 符号的作用，你会从哪里开始？一个非常有用的工具是
    Andreas Fertig 的 C++ Insights ([https://cppinsights.io/](https://cppinsights.io/))
    网站。C++ Insights 将代码转换为显示一些较新 C++ 功能背后的细节。它基于 Clang ([https://clang.llvm.org/](https://clang.llvm.org/))
    和 Andreas 对 C++ 的理解 ([https://cppinsights.io/about.html](https://cppinsights.io/about.html))。如果你输入我们在列表
    1.2 中查看的 `plus` 代码，C++ Insights 将为你转换代码。
- en: Listing 1.4 C++ Insights output
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 C++ Insights 输出
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The trailing return has been rewritten.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 追加返回值已被重写。
- en: ❷ Spelling out << and () are operators and convert 1.23 to an int.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 明确写出 << 和 () 是操作符，并将 1.23 转换为 int 类型。
- en: ❸ Spelling out << and () are operators.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 明确写出 << 和 () 是操作符。
- en: ❹ We didn’t explicitly return 0, but it happens for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们没有明确返回 0，但它对我们来说发生了。
- en: Try it out directly ([https://cppinsights.io/s/508b2063](https://cppinsights.io/s/508b2063)).
    The insight may show lots of details, and the generated code is based on Clang,
    so it may not always work on other compilers, but listing 1.4 shows the transformed
    trailing return symbol `->`, along with the `std::plus<int>` and `std::plus<void>`
    structures being used. If you can’t understand a function you come across, try
    out C++ Insights for clues.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 直接尝试一下 ([https://cppinsights.io/s/508b2063](https://cppinsights.io/s/508b2063))。洞察力可能会显示很多细节，生成的代码基于
    Clang，所以它可能不总是适用于其他编译器，但列表 1.4 显示了转换后的尾随返回符号 `->`，以及使用的 `std::plus<int>` 和 `std::plus<void>`
    结构。如果你不能理解你遇到的一个函数，尝试使用 C++ Insights 获取线索。
- en: The next thing to bear in mind is that not all compilers support all the new
    features, so you might need more than one. At the very least, you might need to
    use the option `/std:c++latest` in Visual Studio or `--std=c++20` for g++. If
    you can’t face having to set up another tool, you can always try out C++ code
    in various compilers online via Matt Godbolt’s Compiler Explorer ([https://godbolt.org/](https://godbolt.org/)).
    It supports a huge variety of different compilers, allowing you to see how each
    behaves. This book will try to stick to common parts, but if you want to explore
    more, this is a great resource, along with C++ Insights. Each has a link to the
    other, so why not use both? Before spending time getting a toolchain setup, CppReference
    has a list of compiler support for each of the new features ([https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support))
    to help you decide which version you need. This is another great resource for
    checking function signatures or simply finding which standard header file you
    need to include to use a feature.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，并非所有编译器都支持所有新特性，因此你可能需要多个编译器。至少，你可能需要在Visual Studio中使用`/std:c++latest`选项或在g++中使用`--std=c++20`。如果你不想设置另一个工具，你总是可以通过Matt
    Godbolt的编译器探索器([https://godbolt.org/](https://godbolt.org/))在线尝试各种编译器中的C++代码。它支持大量的不同编译器，让你可以看到每个编译器的行为。这本书会尽量遵循常见的部分，但如果你想要探索更多，这是一个很好的资源，与C++
    Insights一起使用。每个资源都有一个链接到另一个资源，所以为什么不两者都使用呢？在花费时间设置工具链之前，CppReference有一个列表，列出了每个新特性的编译器支持([https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support))，以帮助你决定你需要哪个版本。这是检查函数签名或简单地找到你需要包含以使用某个特性的标准头文件的一个很好的资源。
- en: Finally, if you get stuck, don’t panic. The compiler may well still give you
    several errors if you forget a semicolon deep inside some template code. Newer
    compilers might pinpoint the actual problem, though, rather than giving pages
    of errors to wade through. Most modern compilers do try to be slightly more helpful,
    so if you had pain previously and gave up, things might be easier now. Nonetheless,
    you will get incomprehensible errors from time to time. If you can’t figure them
    out, ask someone for help or try starting at the first error. If that doesn’t
    work, try starting at the last error, or at least find one pointing at your code,
    rather than library code. If that doesn’t work either, comment it all out and
    add your code back in slowly. Or, even better, consider using version control
    and reverting to what worked. This book won’t take you through all the details
    of how to set up a sensible working environment but will point you to useful tools
    and things to consider along the way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你遇到了困难，不要慌张。编译器可能会因为你在某个模板代码中忘记分号而给出几个错误。不过，较新的编译器可能会指出实际的问题，而不是给出需要翻阅的页面错误。大多数现代编译器确实会尝试提供一些帮助，所以如果你之前遇到过困难并放弃了，现在可能会更容易一些。然而，你有时还是会遇到难以理解的错误。如果你无法解决它们，可以寻求帮助，或者尝试从第一个错误开始。如果这也不行，尝试从最后一个错误开始，或者至少找到一个指向你的代码的错误，而不是库代码。如果这也不行，可以全部注释掉，然后慢慢将你的代码添加回去。或者，更好的是，考虑使用版本控制并回滚到之前工作过的版本。这本书不会带你详细了解如何设置一个合理的开发环境，但会指出一些有用的工具和需要考虑的事项。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: C++ is everywhere and can be used for almost anything.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++无处不在，几乎可以用于任何事情。
- en: C++ is evolving, with a new standard every three years, decided on by WG21 of
    ISO.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++正在不断发展，每三年就会有一个新的标准，由ISO的WG21决定。
- en: C++ is a multi-paradigm language.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++是一种多范式语言。
- en: You need a compiler that supports your chosen platform.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个支持你选择平台的编译器。
- en: Other similar languages are available, but C++ gives you a solid grounding in
    a variety of techniques and idioms.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类似的语言也都有，但C++能为你打下各种技术和习惯用法坚实的基础。
- en: No single compiler currently supports every feature of the latest version of
    the language, but you can use Godbolt and C++ Insights to try out short snippets
    to check whether they compile.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前没有任何单个编译器支持该语言最新版本的每个特性，但你可以使用Godbolt和C++ Insights来尝试短小的代码片段，以检查它们是否可以编译。
- en: Coding a whole program is a great way to learn, and you’ll do just that in the
    rest of this book.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写整个程序是学习的好方法，你将在本书的其余部分中这样做。
