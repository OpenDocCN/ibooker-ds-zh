- en: 7 Mapping inheritance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 映射继承
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining inheritance-mapping strategies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查继承映射策略
- en: Investigating polymorphic associations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查多态关联
- en: We deliberately haven’t talked much about inheritance mapping so far. Mapping
    makes the connection between the object-oriented world and the relational world,
    but inheritance is specific to object-oriented systems. Consequently, mapping
    a hierarchy of classes to tables can be a complex problem, and we’ll demonstrate
    various strategies in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们故意没有过多地讨论继承映射。映射建立了面向对象世界和关系世界之间的联系，但继承是面向对象系统的特性。因此，将类层次映射到表可能是一个复杂的问题，我们将在本章中展示各种策略。
- en: A basic strategy for mapping classes to database tables might be “one table
    for every persistent entity class.” This approach sounds simple enough and indeed
    works well until we encounter inheritance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将类映射到数据库表的基本策略可能是“每个持久化实体类一个表”。这种方法听起来足够简单，并且确实在遇到继承之前工作得很好。
- en: Inheritance is such a visible structural mismatch between the object-oriented
    and relational worlds because the object-oriented model provides both *is a* and
    *has a* relationships. SQL-based models provide only *has a* relationships; SQL
    database management systems don’t support type inheritance, and even when it’s
    available, it’s usually proprietary or incomplete.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象和关系世界之间的一种明显的结构不匹配，因为面向对象模型提供了“是”和“有”的关系。基于SQL的模型只提供“有”的关系；基于SQL的数据库管理系统不支持类型继承，即使它可用，通常也是专有的或不完整的。
- en: 'There are four different strategies for representing an inheritance hierarchy:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同的策略来表示继承层次：
- en: Use one table per concrete class and default runtime polymorphic behavior.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个具体类使用一个表，并默认启用运行时多态行为。
- en: Use one table per concrete class, but discard polymorphism and inheritance relationships
    completely from the SQL schema. Use SQL `UNION` queries for runtime polymorphic
    behavior.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个具体类使用一个表，但完全从SQL模式中丢弃多态性和继承关系。使用SQL `UNION` 查询来实现运行时多态行为。
- en: 'Use one table per class hierarchy: enable polymorphism by denormalizing the
    SQL schema and rely on row-based discrimination to determine supertypes and subtypes.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类层次使用一个表：通过非规范化SQL模式启用多态性，并依赖于基于行的区分来确定超类型和子类型。
- en: 'Use one table per subclass: represent *is a* (inheritance) relationships as
    *has a* (foreign key) relationships, and use SQL `JOIN` operations.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子类使用一个表：将“是”关系（继承）表示为“有”关系（外键），并使用SQL `JOIN` 操作。
- en: This chapter takes a top-down approach, assuming that we’re starting with a
    domain model and trying to derive a new SQL schema. The mapping strategies described
    here are just as relevant if you’re working from the bottom up, starting with
    existing database tables. We’ll examine some tricks along the way to help you
    deal with imperfect table layouts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章采用自顶向下的方法，假设我们从领域模型开始，试图推导出一个新的SQL模式。这里描述的映射策略，如果你是从现有的数据库表开始的，也是同样相关的。我们将检查一些技巧，以帮助你处理不完美的表布局。
- en: 7.1 Table per concrete class with implicit polymorphism
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 每个具体类一个表，具有隐式多态
- en: 'We are working on the CaveatEmptor application, implementing persistence for
    a hierarchy of classes. We could stick with the simplest approach suggested: use
    exactly one table for each concrete class. We can map all the properties of a
    class, including inherited properties, to columns of a table, as shown in figure
    7.1.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发CaveatEmptor应用程序，为类层次实现持久化。我们可以坚持最简单的方法建议：每个具体类恰好使用一个表。我们可以将类的所有属性，包括继承属性，映射到表的列中，如图7.1所示。
- en: Note To be able to execute the examples from this chapter’s source code, you
    will first need to run the Ch07.sql script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要能够执行本章源代码中的示例，您首先需要运行Ch07.sql脚本。
- en: '![](../../OEBPS/Images/CH07_F01_Tudose2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F01_Tudose2.png)'
- en: Figure 7.1 Mapping all concrete classes to an independent table
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 将所有具体类映射到独立表
- en: Relying on this implicit polymorphism, we’ll map concrete classes with `@Entity`,
    as usual. By default, properties of the superclass are ignored and not persistent!
    We’ll have to annotate the superclass with `@MappedSuperclass` to enable the embedding
    of its properties in the concrete subclass tables; see listing 7.1, which can
    be found in the mapping-inheritance-mappedsuperclass folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于这种隐式多态，我们将使用 `@Entity` 映射具体类，就像通常一样。默认情况下，超类的属性被忽略且不持久化！我们必须在超类上注解 `@MappedSuperclass`
    以启用其属性在具体子类表中的嵌入；参见列表 7.1，它位于 mapping-inheritance-mappedsuperclass 文件夹中。
- en: Listing 7.1 Mapping `BillingDetails` (abstract superclass) with implicit polymorphism
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 映射 `BillingDetails`（抽象超类）并使用隐式多态
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we’ll map the concrete subclasses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将映射具体子类。
- en: Listing 7.2 Mapping `CreditCard` (concrete subclass)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 映射 `CreditCard`（具体子类）
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can override column mappings from the superclass in a subclass with the `@AttributeOverride`
    annotation. Starting with JPA 2.2, we can use several `@AttributeOverride` annotations
    on the same class; up to JPA 2.1, we had to group the `@AttributeOverride` annotations
    within an `@AttributeOverrides` annotation. The previous example renames the `OWNER`
    column to `CC_OWNER` in the `CREDITCARD` table.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在子类中使用 `@AttributeOverride` 注解覆盖从超类继承的列映射。从 JPA 2.2 开始，我们可以在同一类上使用多个 `@AttributeOverride`
    注解；在 JPA 2.1 之前，我们必须在 `@AttributeOverrides` 注解内分组 `@AttributeOverride` 注解。前面的示例将
    `CREDITCARD` 表中的 `OWNER` 列重命名为 `CC_OWNER`。
- en: The following listing shows the mapping of the `BankAccount` subclass.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `BankAccount` 子类的映射。
- en: Listing 7.3 Mapping `BankAccount` (concrete subclass)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 映射 `BankAccount`（具体子类）
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can declare the identifier property in the superclass, with a shared column
    name and generator strategy for all subclasses (as in listing 7.3), or we can
    repeat it inside each concrete class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在超类中声明标识属性，为所有子类共享列名和生成策略（如列表 7.3 所示），或者我们可以在每个具体类内部重复它。
- en: To work with these classes, we’ll create three Spring Data JPA repository interfaces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类，我们将创建三个 Spring Data JPA 仓库接口。
- en: Listing 7.4 The `BillingDetailsRepository` interface
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 `BillingDetailsRepository` 接口
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding listing, the `BillingDetailsRepository` interface is annotated
    with `@NoRepositoryBean`. This prevents its instantiation as a Spring Data JPA
    repository instance. This is necessary because, following the schema from figure
    7.1, there will be no `BILLINGDETAILS` table. However, the `BillingDetailsRepository`
    interface intends to be extended by the repository interfaces to deal with the
    `CreditCard` and `BankAccount` subclasses. That is why `BillingDetailsRepository`
    is generified by a `T` that extends `BillingDetails`. Additionally, it contains
    the `findByOwner` method. The `owner` field from `BillingDetails` will be included
    in both the `CREDITCARD` and `BANKACCOUNT` tables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`BillingDetailsRepository` 接口被注解为 `@NoRepositoryBean`。这阻止了其作为 Spring
    Data JPA 仓库实例的实例化。这是必要的，因为根据图 7.1 的模式，将没有 `BILLINGDETAILS` 表。然而，`BillingDetailsRepository`
    接口意图被仓库接口扩展以处理 `CreditCard` 和 `BankAccount` 子类。这就是为什么 `BillingDetailsRepository`
    通过一个扩展 `BillingDetails` 的 `T` 进行泛型化。此外，它还包含 `findByOwner` 方法。`BillingDetails`
    中的 `owner` 字段将包含在 `CREDITCARD` 和 `BANKACCOUNT` 表中。
- en: We’ll now create two more Spring Data repository interfaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另外两个 Spring Data 仓库接口。
- en: Listing 7.5 The `BankAccountRepository` interface
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 `BankAccountRepository` 接口
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `BankAccountRepository` interface extends `BillingDetailsRepository`, generified
    by `BankAccount` (as it deals with `BankAccount` instances) and by `Long` (as
    the ID of the class is of this type). It adds the `findBySwift` method, whose
    name follows the Spring Data JPA conventions (see chapter 4).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankAccountRepository` 接口扩展了 `BillingDetailsRepository`，通过 `BankAccount` 泛型化（因为它处理
    `BankAccount` 实例）和通过 `Long` 泛型化（因为类的 ID 是这种类型）。它添加了 `findBySwift` 方法，其名称遵循 Spring
    Data JPA 规范（见第 4 章）。'
- en: Listing 7.6 The `CreditCardRepository` interface
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 `CreditCardRepository` 接口
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `CreditCardRepository` interface extends `BillingDetailsRepository`, generified
    by `CreditCard` (as it deals with `CreditCard` instances) and by `Long` (as the
    ID of the class is of this type). It adds the `findByExpYear` method, whose name
    follows the Spring Data JPA conventions (see chapter 4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreditCardRepository` 接口扩展了 `BillingDetailsRepository`，通过 `CreditCard` 泛型化（因为它处理
    `CreditCard` 实例）和通过 `Long` 泛型化（因为类的 ID 是这种类型）。它添加了 `findByExpYear` 方法，其名称遵循 Spring
    Data JPA 规范（见第 4 章）。'
- en: We’ll create the following test to check the functionality of the persistence
    code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下测试来检查持久化代码的功能。
- en: Listing 7.7 Testing the functionality of the persistence code
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 测试持久化代码的功能
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ Extend the test using `SpringExtension`. This extension is used to integrate
    the Spring test context with the JUnit 5 Jupiter test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`SpringExtension`扩展测试。这个扩展用于将Spring测试上下文与JUnit 5 Jupiter测试集成。
- en: Ⓑ The Spring test context is configured using the beans defined in the `SpringDataConfiguration`
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用在`SpringDataConfiguration`类中定义的bean配置Spring测试上下文。
- en: Ⓒ A `CreditCardRepository` bean is injected by Spring through autowiring.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 通过Spring自动装配注入`CreditCardRepository`对象。
- en: Ⓓ A `BankAccountRepository` bean is injected by Spring through autowiring. This
    is possible as the `com.manning.javapersistence.ch07.repositories` package where
    `CreditCardRepository` and `BankAccountRepository` are located was used as the
    argument of the `@EnableJpaRepositories` annotation on the `SpringDataConfiguration`
    class. To recall what the `SpringDataConfiguration` class looks like, refer to
    chapter 2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 通过Spring自动装配注入`BankAccountRepository`对象。这是可能的，因为`CreditCardRepository`和`BankAccountRepository`所在的`com.manning.javapersistence.ch07.repositories`包被用作`SpringDataConfiguration`类上`@EnableJpaRepositories`注解的参数。要回忆`SpringDataConfiguration`类的样子，请参阅第2章。
- en: Ⓔ Create a credit card and save it to the repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 创建一张信用卡并将其保存到仓库中。
- en: Ⓕ Create a bank account and save it to the repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 创建一个银行账户并将其保存到仓库中。
- en: Ⓖ Get the list of all credit cards having John Smith as owner.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 获取所有以John Smith为所有者的信用卡列表。
- en: Ⓗ Get the list of all bank accounts having Mike Johnson as owner.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 获取所有以Mike Johnson为所有者的银行账户列表。
- en: Ⓘ Get the credit cards expiring in 2030.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 获取2030年到期信用卡。
- en: Ⓙ Get the bank accounts with SWIFT BANKXY12.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 获取拥有SWIFT BANKXY12的银行账户。
- en: Ⓚ Check the size of the list of credit cards.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 检查信用卡列表的大小。
- en: Ⓛ Get the number of the first credit card in the list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 获取列表中第一张信用卡的编号。
- en: Ⓜ Check the size of the list of bank accounts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 检查银行账户列表的大小。
- en: Ⓝ Check the number of the first bank account in the list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 检查列表中第一个银行账户的数量。
- en: Ⓞ Check the size of the list of credit cards expiring in 2030.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 检查2030年到期信用卡列表的大小。
- en: Ⓟ Check the owner of the first credit card in this list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 检查此列表中第一张信用卡的所有者。
- en: Ⓠ Check the size of the list of bank accounts with SWIFT BANKXY12.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 检查拥有SWIFT BANKXY12银行账户的账户列表的大小。
- en: Ⓡ Check the owner of the first bank account in this list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓡ 检查此列表中第一个银行账户的所有者。
- en: The source code for this chapter also demonstrates how to test these classes
    using JPA and Hibernate.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码还演示了如何使用JPA和Hibernate测试这些类。
- en: The main problem with implicit inheritance mapping is that it doesn’t support
    polymorphic associations very well. In the database, we usually represent associations
    as foreign key relationships. In the schema from figure 7.1, if the subclasses
    are all mapped to different tables, a polymorphic association to their superclass
    (the abstract `BillingDetails`) can’t be represented as a simple foreign key relationship.
    We can’t have another entity mapped with a foreign key “referencing `BILLINGDETAILS`”—there
    is no such table. This would be problematic in the domain model because `BillingDetails`
    is associated with `User`; both the `CREDITCARD` and `BANKACCOUNT` tables would
    need a foreign key reference to the `USERS` table. None of these problems can
    be easily resolved, so we should consider an alternative mapping strategy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式继承映射的主要问题是它不支持多态关联。在数据库中，我们通常将关联表示为外键关系。在图7.1的方案中，如果所有子类都映射到不同的表，那么到其超类（抽象的`BillingDetails`）的多态关联就无法表示为一个简单的外键关系。我们不能有另一个实体通过外键“引用`BILLINGDETAILS`”——没有这样的表。这在领域模型中会存在问题，因为`BillingDetails`与`User`相关联；`CREDITCARD`和`BANKACCOUNT`表都需要一个外键引用到`USERS`表。这些问题都无法轻易解决，因此我们应该考虑一种替代的映射策略。
- en: 'Polymorphic queries that return instances of all classes that match the interface
    of the queried class are also problematic. Hibernate must execute a query against
    the superclass as several SQL `SELECT`s—one for each concrete subclass. The JPA
    query `select bd from BillingDetails bd` requires two SQL statements:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与查询类接口匹配的所有类实例的多态查询也存在问题。Hibernate必须对超类执行多个SQL `SELECT`查询——每个具体的子类一个。JPA查询`select
    bd from BillingDetails bd`需要两个SQL语句：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hibernate or Spring Data JPA using Hibernate uses a separate SQL query for each
    concrete subclass. On the other hand, queries against the concrete classes are
    trivial and perform well—Hibernate uses only one of the statements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 或使用 Hibernate 的 Spring Data JPA 对每个具体子类使用单独的 SQL 查询。另一方面，对具体类的查询既简单又表现良好——Hibernate
    只使用一条语句。
- en: A further conceptual problem with this mapping strategy is that several different
    columns of different tables share exactly the same semantics. This makes schema
    evolution more complex. For example, renaming or changing the type of a superclass
    property results in changes to multiple columns in multiple tables. Many of the
    standard refactoring operations offered by your IDE would require manual adjustments,
    because the automatic procedures usually don’t count for things like `@AttributeOverride`
    or `@AttributeOverrides`. It is much more difficult to implement database integrity
    constraints that apply to all subclasses.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射策略的进一步概念问题是，不同表中的几个不同列具有完全相同的语义。这使得模式演变更加复杂。例如，更改超类属性的名称或类型会导致多个表中的多个列发生变化。许多由您的
    IDE 提供的标准重构操作都需要手动调整，因为自动程序通常不考虑像 `@AttributeOverride` 或 `@AttributeOverrides`
    这样的东西。实现适用于所有子类的数据库完整性约束要困难得多。
- en: We recommend this approach only for the top level of your class hierarchy, where
    polymorphism isn’t usually required and when modification of the superclass in
    the future is unlikely. This may work for particular domain models that you face
    in your real-life applications, but it isn’t a good fit for the CaveatEmptor domain
    model, where queries and other entities refer to `BillingDetails`. We’ll look
    for other alternatives.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只推荐这种方法用于类层次结构的顶层，在那里通常不需要多态，并且未来修改超类的可能性不大。这可能适用于您在现实生活中的应用程序中遇到的特定领域模型，但它不适合
    CaveatEmptor 领域模型，其中查询和其他实体引用 `BillingDetails`。我们将寻找其他替代方案。
- en: With the help of the SQL `UNION` operation, we can eliminate most of the concerns
    with polymorphic queries and associations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 SQL `UNION` 操作的帮助，我们可以消除大多数与多态查询和关联相关的问题。
- en: 7.2 Table per concrete class with unions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 每个具体类一个表与联合
- en: 'Let’s consider a union subclass mapping with `BillingDetails` as an abstract
    class (or interface), as in the previous section. In this situation, there are
    again two tables and superclass columns that are duplicated in both: `CREDITCARD`
    and `BANKACCOUNT`. What’s new here is an inheritance strategy known as `TABLE_PER_CLASS`,
    declared on the superclass, as shown in the following listing. The source code
    can be found in the `mapping-inheritance-tableperclass` folder.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有 `BillingDetails` 作为抽象类（或接口）的联合子类映射，就像上一节中那样。在这种情况下，又有两个表和重复在两个表中的超类列：`CREDITCARD`
    和 `BANKACCOUNT`。这里的新特点是声明在超类上的一个称为 `TABLE_PER_CLASS` 的继承策略，如下面的列表所示。源代码可以在 `mapping-inheritance-tableperclass`
    文件夹中找到。
- en: Note The JPA standard specifies that `TABLE_PER_CLASS` is optional, so not all
    JPA implementations support it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：JPA 标准指定 `TABLE_PER_CLASS` 是可选的，因此并非所有 JPA 实现都支持它。
- en: Listing 7.8 Mapping `BillingDetails` with `TABLE_PER_CLASS`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 使用 `TABLE_PER_CLASS` 映射 `BillingDetails`
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The database identifier and its mapping have to be present in the superclass
    to share it in all subclasses and their tables. This is no longer optional, as
    it was for the previous mapping strategy. The `CREDITCARD` and `BANKACCOUNT` tables
    both have an `ID` primary key column. All concrete class mappings inherit persistent
    properties from the superclass (or interface). An `@Entity` annotation on each
    subclass is all that is required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库标识符及其映射必须在超类中存在，以便在所有子类及其表中共享。这不再是可选的，就像之前的映射策略那样。`CREDITCARD` 和 `BANKACCOUNT`
    表都有 `ID` 主键列。所有具体类映射都从超类（或接口）继承持久属性。每个子类上的 `@Entity` 注解就足够了。
- en: Listing 7.9 Mapping `CreditCard`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 `CreditCard` 映射
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 7.10 Mapping `BankAccount`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 `BankAccount` 映射
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll have to change the `BillingDetailsRepository` interface and remove the
    `@NoRepositoryBean` annotation. This change, together with the fact that the `BillingDetails`
    class is now annotated as `@Entity`, will allow this repository to interact with
    the database. This is what the `BillingDetailsRepository` interface looks like
    now.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不更改 `BillingDetailsRepository` 接口并移除 `@NoRepositoryBean` 注解。这个更改，加上 `BillingDetails`
    类现在被标注为 `@Entity`，将允许此存储库与数据库交互。这就是现在的 `BillingDetailsRepository` 接口的样子。
- en: Listing 7.11 The `BillingDetailsRepository` interface
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 `BillingDetailsRepository` 接口
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Keep in mind that the SQL schema still isn’t aware of the inheritance; the tables
    look exactly alike, as shown in figure 7.1.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，SQL模式仍然没有意识到继承；表看起来完全一样，如图7.1所示。
- en: If `BillingDetails` were concrete, we’d need an additional table to hold instances.
    Keep in mind that there is still no relationship between the database tables,
    except for the fact that they have some (many) similar columns.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BillingDetails`是具体的，我们需要一个额外的表来存储实例。请记住，数据库表之间仍然没有关系，除了它们有一些（许多）相似的列。
- en: The advantages of this mapping strategy are clearer if we examine polymorphic
    queries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查多态查询，这种映射策略的优点将更加明显。
- en: 'We can use the Spring Data JPA `BillingDetailsRepository` interface to query
    the database, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Spring Data JPA的`BillingDetailsRepository`接口来查询数据库，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or from JPA or Hibernate, we can execute the following query:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从JPA或Hibernate执行以下查询：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Both approaches will generate the following SQL statement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会生成以下SQL语句：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `SELECT` uses a `FROM`-clause subquery to retrieve all instances of `BillingDetails`
    from all concrete class tables. The tables are combined with a `UNION` operator,
    and a literal (in this case, `1` and `2`) is inserted into the intermediate result;
    Hibernate reads this to instantiate the correct class given the data from a particular
    row. A union requires that the queries that are combined project over the same
    columns, so you have to pad and fill nonexistent columns with `NULL`. You may
    wonder whether this query will really perform better than two separate statements.
    Here you can let the database optimizer find the best execution plan to combine
    rows from several tables instead of merging two result sets in memory as Hibernate’s
    polymorphic loader engine would do.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SELECT`语句使用一个`FROM`子句子查询从所有具体类表中检索所有`BillingDetails`实例。这些表通过`UNION`运算符组合在一起，并在中间结果中插入一个字面量（在这种情况下，`1`和`2`）；Hibernate读取这个来根据特定行的数据实例化正确的类。联合要求组合的查询在相同的列上投影，因此你必须用`NULL`填充不存在的列。你可能想知道这个查询是否真的会比两个单独的语句表现得更好。在这里，你可以让数据库优化器找到最佳执行计划来合并来自多个表的行，而不是像Hibernate的多态加载引擎那样在内存中合并两个结果集。
- en: An important advantage is the ability to handle polymorphic associations; for
    example, an association mapping from `User` to `BillingDetails` will now be possible.
    Hibernate can use a `UNION` query to simulate a single table as the target of
    the association mapping.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的优点是能够处理多态关联；例如，从`User`到`BillingDetails`的关联映射现在将变得可能。Hibernate可以使用`UNION`查询来模拟关联映射的目标作为单个表。
- en: So far, the inheritance-mapping strategies we’ve examined don’t require extra
    consideration of the SQL schema. This situation changes with the next strategy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们检查的继承映射策略不需要对SQL模式进行额外考虑。这种情况在下一个策略中发生了变化。
- en: 7.3 Table per class hierarchy
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 每个类层次结构的表
- en: We could map an entire class hierarchy to a single table. This table includes
    columns for all properties of all classes in the hierarchy. The value of an extra
    type discriminator column or formula identifies the concrete subclass represented
    by a particular row. Figure 7.2 shows this approach. The source code that follows
    can be found in the mapping-inheritance-singletable folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将整个类层次结构映射到一个单独的表中。这个表包括层次结构中所有类的所有属性列。额外的类型判别器列或公式的值标识了特定行表示的具体子类。图7.2显示了这种方法。下面的源代码可以在`mapping-inheritance-singletable`文件夹中找到。
- en: '![](../../OEBPS/Images/CH07_F02_Tudose2.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F02_Tudose2.png)'
- en: Figure 7.2 Mapping an entire class hierarchy to a single table
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 将整个类层次结构映射到单个表]'
- en: This mapping strategy is a winner in terms of both performance and simplicity.
    It’s the best-performing way to represent polymorphism—both polymorphic and non-
    polymorphic queries perform well, and it’s even easy to write queries by hand.
    Ad hoc reporting is possible without complex joins or unions. Schema evolution
    is straightforward.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射策略在性能和简单性方面都是赢家。这是表示多态的最佳性能方式——多态和非多态查询都表现良好，而且手动编写查询也很容易。无需复杂的连接或联合即可进行临时报告。模式演变简单直接。
- en: 'There is one major problem: data integrity. We must declare columns for properties
    declared by subclasses to be nullable. If the subclasses each define several non-nullable
    properties, the loss of `NOT NULL` constraints may be a serious problem from the
    point of view of data correctness. Imagine that an expiration date for credit
    cards is required, but the database schema can’t enforce this rule because all
    columns of the table can be `NULL`. A simple application programming error can
    lead to invalid data.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个主要问题：数据完整性。我们必须声明子类声明的属性列可以为空。如果子类各自定义了多个不可为空的属性，那么 `NOT NULL` 约束的丢失可能从数据正确性的角度来看是一个严重问题。想象一下，信用卡的到期日期是必需的，但数据库模式无法强制执行此规则，因为表的所有列都可以是
    `NULL`。一个简单的应用程序编程错误可能导致无效数据。
- en: Another important concern is normalization. We’ve created functional dependencies
    between non-key columns, violating the third normal form. As always, denormalization
    for performance reasons can be misleading because it sacrifices long-term stability,
    maintainability, and the integrity of data for immediate gains that may also be
    achieved by proper optimization of the SQL execution plans (in other words, ask
    the DBA).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是规范化。我们已经在非键列之间创建了函数依赖关系，违反了第三范式。像往常一样，出于性能原因的规范化可能会产生误导，因为它牺牲了长期稳定性、可维护性和数据完整性，以换取可能通过正确优化
    SQL 执行计划（换句话说，询问数据库管理员）也能实现的即时收益。
- en: We’ll use the `SINGLE_TABLE` inheritance strategy to create a table-per-class
    hierarchy mapping, as shown in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `SINGLE_TABLE` 继承策略来创建一个表级类层次结构映射，如下所示。
- en: Listing 7.12 Mapping `BillingDetails` with `SINGLE_TABLE`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 使用 `SINGLE_TABLE` 映射 `BillingDetails`
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The root class of the inheritance hierarchy, `BillingDetails`, is mapped to
    the `BILLINGDETAILS` table automatically. Shared properties of the superclass
    can be `NOT NULL` in the schema; every subclass instance must have a value. An
    implementation quirk of Hibernate requires that we declare nullability with `@Column`
    because Hibernate ignores Bean Validation’s `@NotNull` when it generates the database
    schema.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次结构的根类 `BillingDetails` 自动映射到 `BILLINGDETAILS` 表。超类共享属性在模式中可以是 `NOT NULL`；每个子类实例必须有一个值。Hibernate
    的一个实现怪癖要求我们使用 `@Column` 声明可空性，因为当 Hibernate 生成数据库模式时，它会忽略 Bean Validation 的 `@NotNull`。
- en: We have to add a special discriminator column to distinguish what each row represents.
    This isn’t a property of the entity; it’s used internally by Hibernate. The column
    name is `BD_TYPE`, and the values are strings—in this case, `"CC"` or `"BA"`.
    Hibernate or Spring Data JPA using Hibernate automatically sets and retrieves
    the discriminator values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个特殊的区分器列来区分每一行代表的内容。这不是实体属性；它是 Hibernate 内部使用的。列名为 `BD_TYPE`，值是字符串——在这种情况下，`"CC"`
    或 `"BA"`。Hibernate 或使用 Hibernate 的 Spring Data JPA 自动设置和检索区分器值。
- en: If we don’t specify a discriminator column in the superclass, its name defaults
    to `DTYPE,` and the values are strings. All concrete classes in the inheritance
    hierarchy can have a discriminator value, such as `CreditCard`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不在超类中指定区分器列，其名称默认为 `DTYPE`，值是字符串。继承层次结构中的所有具体类都可以有区分器值，例如 `CreditCard`。
- en: Listing 7.13 Mapping `CreditCard` using the `SINGLE_TABLE` inheritance strategy
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 使用 `SINGLE_TABLE` 继承策略映射 `CreditCard`
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Without an explicit discriminator value, Hibernate defaults to the fully qualified
    class name if we use Hibernate XML files and to the simple entity name if we use
    annotations or JPA XML files. Note that JPA doesn’t specify a default for non-string
    discriminator types; each persistence provider can have different defaults. Therefore,
    we should always specify discriminator values for the concrete classes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显式的区分器值，当使用 Hibernate XML 文件时，Hibernate 默认使用完全限定类名；如果使用注解或 JPA XML 文件，则默认使用简单实体名称。请注意，JPA
    没有指定非字符串区分器类型的默认值；每个持久化提供者可能有不同的默认值。因此，我们应该始终为具体类指定区分器值。
- en: We’ll annotate every subclass with `@Entity`, and then map properties of a subclass
    to columns in the `BILLINGDETAILS` table. Remember that `NOT NULL` constraints
    aren’t allowed in the schema because a `BankAccount` instance won’t have an `expMonth`
    property, and the `EXPMONTH` column must be `NULL` for that row. Hibernate and
    Spring Data JPA using Hibernate ignore the `@NotNull` for schema DDL generation,
    but they observe it at runtime before inserting a row. This helps us avoid programming
    errors; we don’t want to accidentally save credit card data without its expiration
    date. (Other, less well-behaved applications can, of course, still store incorrect
    data in this database.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `@Entity` 注解每个子类，然后将子类的属性映射到 `BILLINGDETAILS` 表的列上。记住，由于 `BankAccount`
    实例不会有 `expMonth` 属性，`EXPMONTH` 列必须为 `NULL`，因此架构中不允许使用 `NOT NULL` 约束。Hibernate
    和 Spring Data JPA 在生成架构 DDL 时忽略 `@NotNull`，但在插入行之前在运行时观察它。这有助于我们避免编程错误；我们不希望意外保存没有到期日期的信用卡数据。（当然，其他行为不佳的应用程序仍然可以在这个数据库中存储错误数据。）
- en: 'We can use the Spring Data JPA `BillingDetailsRepository` interface to query
    the database, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Spring Data JPA 的 `BillingDetailsRepository` 接口来查询数据库，如下所示：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, from JPA or Hibernate, we can execute the following query:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从 JPA 或 Hibernate，我们可以执行以下查询：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both approaches will generate the following SQL statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会生成以下 SQL 语句：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To query the `CreditCard` subclass, we also have alternatives.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询 `CreditCard` 子类，我们也有其他选择。
- en: 'We can use the Spring Data JPA `CreditCardRepository` interface to query the
    database, like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Spring Data JPA 的 `CreditCardRepository` 接口来查询数据库，如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or, from JPA or Hibernate, we can execute the following query:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从 JPA 或 Hibernate，我们可以执行以下查询：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Hibernate adds a restriction on the discriminator column:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 对区分符列添加了一个限制：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes, especially in legacy schemas, we don’t have the freedom to include
    an extra discriminator column in the entity tables. In this case, we can apply
    an expression to calculate a discriminator value for each row. Formulas for discrimination
    aren’t part of the JPA specification, but Hibernate has an extension annotation,
    `@DiscriminatorFormula`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，尤其是在遗留架构中，我们无法在实体表中包含额外的区分符列。在这种情况下，我们可以对每一行应用一个表达式来计算一个区分符值。区分公式不是 JPA 规范的一部分，但
    Hibernate 有一个扩展注解，`@DiscriminatorFormula`。
- en: Listing 7.14 Mapping `BillingDetails` with a `@DiscriminatorFormula`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 使用 `@DiscriminatorFormula` 映射 `BillingDetails`
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is no discriminator column in the schema, so this mapping relies on an
    SQL `CASE/WHEN` expression to determine whether a particular row represents a
    credit card or a bank account (many developers have never used this kind of SQL
    expression; check the ANSI standard if you aren’t familiar with it). The result
    of the expression is a literal, `CC` or `BA`, declared on the subclass mappings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 架构中没有区分符列，因此这种映射依赖于 SQL 的 `CASE/WHEN` 表达式来确定特定行是否代表信用卡或银行账户（许多开发者从未使用过这种类型的
    SQL 表达式；如果你不熟悉它，请查看 ANSI 标准）。表达式的结果是声明在子类映射中的字面量，`CC` 或 `BA`。
- en: The disadvantages of the table-per-class hierarchy strategy may be too serious
    for your design—denormalized schemas can become a major burden in the long term,
    and your DBA may not like it at all. The next inheritance-mapping strategy doesn’t
    expose you to this problem.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表-类层次结构策略的缺点可能对你的设计来说过于严重——非规范化架构可能会在长期内成为主要负担，你的 DBA 可能根本不喜欢它。下一个继承映射策略不会让你面临这个问题。
- en: 7.4 Table per subclass with joins
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 表-子类与连接
- en: The fourth option is to represent inheritance relationships as SQL foreign key
    associations. Every class or subclass that declares persistent properties—including
    abstract classes and even interfaces—has its own table. The source code that follows
    can be found in the mapping-inheritance-joined folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种选项是将继承关系表示为 SQL 外键关联。每个声明持久属性（包括抽象类甚至接口）的类或子类都有自己的表。以下源代码可以在 mapping-inheritance-joined
    文件夹中找到。
- en: Unlike the table-per-concrete-class strategy we mapped first, the table of a
    concrete `@Entity` here contains columns only for each non-inherited property
    declared by the subclass itself, along with a primary key that is also a foreign
    key of the superclass table. This is easier than it sounds; have a look at figure
    7.3.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初映射的表-具体类策略不同，这里的具体 `@Entity` 表只包含子类本身声明的非继承属性列，以及也是超类表外键的主键。这比听起来容易；看看图
    7.3。
- en: '![](../../OEBPS/Images/CH07_F03_Tudose2.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F03_Tudose2.png)'
- en: Figure 7.3 Mapping all classes of the hierarchy to their own tables
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 将层次结构中的所有类映射到它们自己的表
- en: 'If we make an instance of the `CreditCard` subclass persistent, Hibernate inserts
    two rows: The values of properties declared by the `BillingDetails` superclass
    are stored in a new row of the `BILLINGDETAILS` table. Only the values of properties
    declared by the subclass are stored in a new row of the `CREDITCARD` table. The
    primary key shared by the two rows links them together. Later, the subclass instance
    can be retrieved from the database by joining the subclass table with the superclass
    table.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使`CreditCard`子类实例持久化，Hibernate将插入两行：`BillingDetails`超类声明的属性值存储在`BILLINGDETAILS`表的新行中。只有子类声明的属性值存储在`CREDITCARD`表的新行中。两行共享的主键将它们链接在一起。稍后，可以通过将子类表与超类表连接来从数据库中检索子类实例。
- en: The primary advantage of this strategy is that it normalizes the SQL schema.
    Schema evolution and integrity-constraint definition are straightforward. A foreign
    key referencing the table of a particular subclass may represent a polymorphic
    association to that particular subclass. We’ll use the `JOINED` inheritance strategy
    to create a table-per-subclass hierarchy mapping.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的主要优势是它使SQL模式规范化。模式演变和完整性约束定义简单明了。引用特定子类表的表的外键可能代表对该特定子类的多态关联。我们将使用`JOINED`继承策略创建按子类创建的表层次结构映射。
- en: Listing 7.15 Mapping `BillingDetails` with `JOINED`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 使用`JOINED`映射`BillingDetails`
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The root class `BillingDetails` is mapped to the table `BILLINGDETAILS`. Note
    that no discriminator is required with this strategy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根类`BillingDetails`映射到`BILLINGDETAILS`表。请注意，此策略不需要使用鉴别器。
- en: In subclasses, we don’t need to specify the join column if the primary key column
    of the subclass table has (or is supposed to have) the same name as the primary
    key column of the superclass table. In the following listing, `BankAccount` will
    be a subclass of `BillingDetails`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中，如果子类表的主键列具有（或应该具有）与超类表的主键列相同的名称，我们不需要指定连接列。在以下列表中，`BankAccount`将是`BillingDetails`的子类。
- en: Listing 7.16 Mapping `BankAccount` (concrete class)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.16 映射 `BankAccount`（具体类）
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This entity has no identifier property; it automatically inherits the `ID` property
    and column from the superclass, and Hibernate knows how to join the tables if
    we want to retrieve instances of `BankAccount`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该实体没有标识符属性；它自动继承自超类的`ID`属性和列，如果我们要检索`BankAccount`实例，Hibernate知道如何连接表。
- en: Of course, we could specify the column name explicitly, using the @PrimaryKeyJoinColumn
    annotation, as shown in the following listing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过使用`@PrimaryKeyJoinColumn`注解显式指定列名，如下所示。
- en: Listing 7.17 Mapping `CreditCard`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.17 映射 `CreditCard`
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The primary key columns of the `BANKACCOUNT` and `CREDITCARD` tables each also
    have a foreign key constraint referencing the primary key of the `BILLINGDETAILS`
    table.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`BANKACCOUNT`和`CREDITCARD`表的主键列各自也有一个外键约束，该约束引用`BILLINGDETAILS`表的主键。'
- en: 'We can use the Spring Data JPA `BillingDetailsRepository` interface to query
    the database, like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Spring Data JPA的`BillingDetailsRepository`接口查询数据库，如下所示：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or, from JPA or Hibernate, we can execute the following query:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从JPA或Hibernate中，我们可以执行以下查询：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Hibernate relies on an SQL outer join and will generate the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate依赖于SQL外连接，并将生成以下内容：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The SQL `CASE . . . WHEN` clause detects the existence (or absence) of rows
    in the subclass tables `CREDITCARD` and `BANKACCOUNT`, so Hibernate or Spring
    Data using Hibernate can determine the concrete subclass for a particular row
    of the `BILLINGDETAILS` table.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQL的`CASE . . . WHEN`子句检测子类表`CREDITCARD`和`BANKACCOUNT`中的行是否存在（或不存在），因此Hibernate或使用Hibernate的Spring
    Data可以确定`BILLINGDETAILS`表的特定行的具体子类。
- en: For a narrow subclass query like this,
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的狭窄子类查询，
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or this,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样，
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hibernate uses an inner join:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate使用内连接：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, this mapping strategy is more difficult to implement by hand—even
    ad hoc reporting is more complex. This is an important consideration if you plan
    to mix Spring Data JPA or Hibernate code with handwritten SQL. A usual approach
    and a portable solution may be working with JPQL (Jakarta Persistence Query Language)
    and annotating methods with JPQL queries.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种映射策略手动实现起来更为复杂——即使是临时报告也更为复杂。如果您计划将Spring Data JPA或Hibernate代码与手写的SQL混合使用，这是一个重要的考虑因素。一种常见的方法和可移植的解决方案可能是使用JPQL（Jakarta
    Persistence Query Language）并使用JPQL查询注解方法。
- en: Furthermore, even though this mapping strategy is deceptively simple, our experience
    is that performance can be unacceptable for complex class hierarchies. Queries
    always require a join across many tables or many sequential reads.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管这种映射策略表面上看起来很简单，但我们的经验是，对于复杂的类层次结构，性能可能无法接受。查询总是需要跨多个表或多个顺序读取。
- en: Inheritance with joins and a discriminator
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接和区分器的继承
- en: Hibernate doesn’t need a special discriminator database column to implement
    the `InheritanceType.JOINED` strategy, and the JPA specification doesn’t contain
    any requirements either. The `CASE` `.` `.` `.` `WHEN` clause in the SQL `SELECT`
    statement is a smart way to distinguish the entity type of each retrieved row.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 不需要一个特殊的区分器数据库列来实现 `InheritanceType.JOINED` 策略，JPA 规范也没有任何要求。SQL `SELECT`
    语句中的 `CASE` `.` `.` `.` `WHEN` 子句是一种区分检索到的每一行实体类型的智能方式。
- en: Some JPA examples you might find elsewhere, however, use `InheritanceType.JOINED`
    *and* a `@DiscriminatorColumn` mapping. Apparently some other JPA providers don’t
    use `CASE` `.` `.` `.` `WHEN` clauses and rely only on a discriminator value,
    even for the `InheritanceType.JOINED` strategy. Hibernate doesn’t need the discriminator
    but uses a declared `@DiscriminatorColumn`, even with a `JOINED` mapping strategy.
    If you prefer to ignore the discriminator mapping with `JOINED` (it was ignored
    in older Hibernate versions), enable the configuration property `hibernate .discriminator.ignore_explicit_for_joined`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能在其他地方找到的一些 JPA 示例使用了 `InheritanceType.JOINED` *和* 一个 `@DiscriminatorColumn`
    映射。显然，一些其他的 JPA 提供商不使用 `CASE` `.` `.` `.` `WHEN` 子句，并且仅依赖于一个区分值，即使是对于 `InheritanceType.JOINED`
    策略。Hibernate 不需要区分器，但使用声明的 `@DiscriminatorColumn`，即使在 `JOINED` 映射策略中也是如此。如果你更喜欢忽略
    `JOINED`（在较旧的 Hibernate 版本中已被忽略）的区分器映射，请启用配置属性 `hibernate .discriminator.ignore_explicit_for_joined`。
- en: Before we look at when you should choose which strategy, let’s consider mixing
    inheritance-mapping strategies in a single class hierarchy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨何时应该选择哪种策略之前，让我们考虑在单个类层次结构中混合继承映射策略。
- en: 7.5 Mixing inheritance strategies
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 混合继承策略
- en: We can map an entire inheritance hierarchy with the `TABLE_PER_CLASS`, `SINGLE_
    TABLE`, or `JOINED` strategy. We can’t mix them—for example, switching from a
    table-per-class hierarchy with a discriminator to a normalized table-per-subclass
    strategy. Once we’ve decided on an inheritance strategy, we have to stick with
    it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `TABLE_PER_CLASS`、`SINGLE_TABLE` 或 `JOINED` 策略来映射整个继承层次结构。我们不能混合它们——例如，从具有区分器的表层次结构切换到规范化的表层次结构策略。一旦我们决定了一个继承策略，我们就必须坚持使用它。
- en: Except, this isn’t completely true. By using some tricks, we can switch the
    mapping strategy for a particular subclass. For example, we can map a class hierarchy
    to a single table, but, for a particular subclass, switch to a separate table
    with a foreign key–mapping strategy, just as with table-per-subclass. Look at
    the schema in figure 7.4\. The source code that follows can be found in the mapping-inheritance-mixed
    folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完全正确。通过使用一些技巧，我们可以切换特定子类的映射策略。例如，我们可以将类层次结构映射到单个表中，但对于特定的子类，可以切换到使用外键映射策略的单独表中，就像在表层次结构中一样。查看图
    7.4 中的模式。下面的源代码可以在 `mapping-inheritance-mixed` 文件夹中找到。
- en: '![](../../OEBPS/Images/CH07_F04_Tudose2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F04_Tudose2.png)'
- en: Figure 7.4 Breaking out a subclass to its own secondary table
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 将子类分离到其自己的二级表
- en: We’ll map the superclass `BillingDetails` with `InheritanceType.SINGLE_TABLE`,
    as we did before. Then we’ll map the `CreditCard` subclass we want to break out
    of the single table to a secondary table.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `InheritanceType.SINGLE_TABLE` 映射超类 `BillingDetails`，就像之前做的那样。然后我们将我们想要从单表中分离出来的
    `CreditCard` 子类映射到一个二级表中。
- en: Listing 7.18 Mapping `CreditCard`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.18 映射 `CreditCard`
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `@SecondaryTable` and `@Column` annotations group some properties and tell
    Hibernate to get them from a secondary table. We map all the properties that we
    moved into the secondary table with the name of that secondary table. This is
    done with the `table` parameter of `@Column`, which we haven’t shown before. This
    mapping has many uses, and you’ll see it again later in this book. In this example,
    it separates the `CreditCard` properties from the single table strategy into the
    `CREDITCARD` table. This would be a viable solution if we wanted to add a new
    class to extend `BillingDetails`; `Paypal` for example.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SecondaryTable` 和 `@Column` 注解将一些属性分组并告诉 Hibernate 从辅助表中获取它们。我们使用辅助表的名字来映射我们移动到辅助表中的所有属性。这是通过
    `@Column` 的 `table` 参数实现的，我们之前没有展示过。这种映射有许多用途，你将在本书后面的内容中再次看到它。在这个例子中，它将 `CreditCard`
    属性从单表策略中分离到 `CREDITCARD` 表中。如果我们想添加一个新的类来扩展 `BillingDetails`，例如 `Paypal`，这将是一个可行的解决方案。'
- en: The `CREDITCARD_ID` column of this table is also the primary key, and it has
    a foreign key constraint referencing the `ID` of the single hierarchy table. If
    we don’t specify a primary key join column for the secondary table, the name of
    the primary key of the single inheritance table is used—in this case, `ID`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表的 `CREDITCARD_ID` 列也是主键，并且有一个外键约束引用单继承表中的 `ID`。如果我们没有指定辅助表的主键连接列，则使用单继承表的主键名称——在这种情况下，是
    `ID`。
- en: Remember that `InheritanceType.SINGLE_TABLE` enforces all columns of subclasses
    to be nullable. One of the benefits of this mapping is that we can now declare
    columns of the `CREDITCARD` table as `NOT NULL`, guaranteeing data integrity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`InheritanceType.SINGLE_TABLE` 强制所有子类的列都必须是可空的。这种映射的一个好处是，我们现在可以声明 `CREDITCARD`
    表的列作为 `NOT NULL`，从而保证数据完整性。
- en: 'At runtime, Hibernate executes an outer join to fetch `BillingDetails` and
    all subclass instances polymorphically:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Hibernate 执行一个外连接来多态地获取 `BillingDetails` 和所有子类实例：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can also use this trick for other subclasses in the class hierarchy. For
    an exceptionally wide class hierarchy, the outer join can become a problem. Some
    database systems (Oracle, for example) limit the number of tables in an outer
    join operation. For a wide hierarchy, you may want to switch to a different fetching
    strategy that executes an immediate second SQL select instead of an outer join.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这个技巧用于类层次结构中的其他子类。对于异常广泛的类层次结构，外连接可能会成为一个问题。一些数据库系统（例如 Oracle）限制了外连接操作中表的数量。对于广泛的层次结构，你可能想要切换到不同的获取策略，该策略执行一个立即的第二
    SQL 查询而不是外连接。
- en: 7.6 Inheritance of embeddable classes
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 嵌入类继承
- en: 'An embeddable class is a component of its owning entity, so the normal entity
    inheritance rules presented in this chapter don’t apply. As a Hibernate extension,
    we can map an embeddable class that inherits some persistent properties from a
    superclass (or interface). Let’s consider two new attributes of an auction item:
    dimensions and weight.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入类是其所属实体的一个组成部分，因此本章中介绍的正常实体继承规则不适用。作为 Hibernate 扩展，我们可以映射一个嵌入类，该类从超类（或接口）继承一些持久属性。让我们考虑拍卖物品的两个新属性：尺寸和重量。
- en: 'An item’s dimensions are its width, height, and depth, expressed in a given
    unit and its symbol: for example, inches (`"`) or centimeters (`cm`). An item’s
    weight also carries a unit of measurement: for example, pounds (`lbs`) or kilograms
    (`kg`). To capture the common attributes (name and symbol) of measurement, we’ll
    define a superclass for `Dimensions` and `Weight` called `Measurement`. The source
    code that follows can be found in the mapping-inheritance-embeddable folder.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目的尺寸是其宽度、高度和深度，以给定的单位和其符号表示：例如，英寸 (`"`) 或厘米 (`cm`)。一个项目的重量也携带一个度量单位：例如，磅
    (`lbs`) 或千克 (`kg`)。为了捕获度量（名称和符号）的常见属性，我们将为 `Dimensions` 和 `Weight` 定义一个名为 `Measurement`
    的超类。接下来的源代码可以在 `mapping-inheritance-embeddable` 文件夹中找到。
- en: Listing 7.19 Mapping the `Measurement` abstract embeddable superclass
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.19 映射 `Measurement` 抽象嵌入超类
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ve used the `@MappedSuperclass` annotation on the superclass of the embeddable
    class we’re mapping, just like we would for an entity. Subclasses will inherit
    the properties of this class as persistent properties.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在映射的嵌入类超类上使用了 `@MappedSuperclass` 注解，就像我们会对一个实体做的那样。子类将继承这个类的属性作为持久属性。
- en: We’ll define the `Dimensions` and `Weight` subclasses as `@Embeddable`. For
    `Dimensions`, we’ll override all the superclass attributes and add a column-name
    prefix.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义 `Dimensions` 和 `Weight` 子类为 `@Embeddable`。对于 `Dimensions`，我们将覆盖所有超类属性并添加一个列名前缀。
- en: Listing 7.20 Mapping the `Dimensions` class
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.20 映射`Dimensions`类
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Without this override, an `Item` embedding both `Dimensions` and `Weight` would
    map to a table with conflicting column names.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个覆盖，同时嵌入`Dimensions`和`Weight`的`Item`将映射到一个具有冲突列名的表。
- en: Next is the `Weight` class; its mapping also overrides the column names with
    a prefix (for uniformity, we avoid the conflict with the previous override).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Weight`类；其映射也覆盖了列名前缀（为了统一，我们避免与之前的覆盖冲突）。
- en: Listing 7.21 Mapping the `Weight` class
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.21 映射`Weight`类
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The owning entity `Item` defines two regular persistent embedded properties.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有实体`Item`定义了两个常规持久化嵌入式属性。
- en: Listing 7.22 Mapping the `Item` class
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.22 映射`Item`类
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Figure 7.5 illustrates this mapping.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5展示了这种映射。
- en: '![](../../OEBPS/Images/CH07_F05_Tudose2.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F05_Tudose2.png)'
- en: Figure 7.5 Mapping concrete embeddable classes with their inherited properties
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 映射具有继承属性的实体类
- en: Alternatively, we could override the conflicting `Measurement` column names
    of the embedded properties in the `Item` class, as was demonstrated in section
    6.2\. However, we prefer to override them once in the `@Embeddable` classes, so
    consumers of these classes don’t have to resolve the conflict.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在`Item`类中覆盖嵌入式属性的冲突`Measurement`列名，正如在第6.2节中演示的那样。然而，我们更喜欢在`@Embeddable`类中一次性覆盖它们，这样这些类的消费者就不必解决冲突。
- en: A pitfall to watch out for is embedding a property of an abstract superclass
    type (like `Measurement`) in an entity (like `Item`). This can never work; the
    JPA provider doesn’t know how to store and load `Measurement` instances polymorphically.
    It doesn’t have the information necessary to decide whether the values in the
    database are `Dimensions` or `Weight` instances because there is no discriminator.
    This means although we *can* have an `@Embeddable` class inherit some persistent
    properties from a `@MappedSuperclass`, the reference *to* an instance isn’t polymorphic—it
    always names a concrete class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的陷阱是将抽象超类类型（如`Measurement`）的属性嵌入到实体（如`Item`）中。这永远不可能工作；JPA提供者不知道如何以多态方式存储和加载`Measurement`实例。它没有必要的信息来决定数据库中的值是`Dimensions`还是`Weight`实例，因为没有区分器。这意味着虽然我们*可以*让`@Embeddable`类从`@MappedSuperclass`继承一些持久化属性，但*引用*实例不是多态的——它总是指一个具体类。
- en: Compare this with the alternative inheritance strategy for embeddable classes
    examined in the section “Converting properties of components” (within section
    6.3.2), which supported polymorphism but required some custom type-discrimination
    code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与第6.3.2节中“转换组件属性”部分检查的嵌入式类的替代继承策略进行比较，该策略支持多态性，但需要一些自定义类型区分代码。
- en: Next we’ll provide some tips on how to choose an appropriate combination of
    mapping strategies for an application’s class hierarchies.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将提供一些关于如何为应用程序的类层次结构选择合适的映射策略的技巧。
- en: 7.7 Choosing a strategy
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 选择策略
- en: 'Which inheritance-mapping strategy you choose will depend on how superclasses
    are used in the entity hierarchy. You’ll have to consider how frequently you query
    for instances of the superclasses and whether you have associations targeting
    the superclasses. Another important aspect is the attributes of super- and subtypes:
    whether subtypes have many additional attributes or only different behavior than
    their supertypes. Here are some rules of thumb:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的继承映射策略将取决于超类在实体层次结构中的使用方式。您必须考虑您查询超类实例的频率以及您是否有针对超类的关联。另一个重要方面是超类和子类的属性：子类是否具有许多额外的属性，或者是否仅与超类有不同的行为。以下是一些经验法则：
- en: If you don’t require polymorphic associations or queries, lean toward table-per-concrete
    class—in other words, if you never or rarely `select` `bd` `from BillingDetails
    bd`, and you have no class that has an association to `BillingDetails`. An explicit
    `UNION`-based mapping with `InheritanceType.TABLE_PER_CLASS` should be preferred
    because (optimized) polymorphic queries and associations will be possible later.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您不需要多态关联或查询，则倾向于按具体类创建表——换句话说，如果您从不或很少`select` `bd` `from BillingDetails bd`，并且没有具有`BillingDetails`关联的类。应首选基于显式`UNION`映射的`InheritanceType.TABLE_PER_CLASS`，因为（优化后的）多态查询和关联将在以后成为可能。
- en: If you do require polymorphic associations (an association to a superclass,
    and hence to all classes in the hierarchy with a dynamic resolution of the concrete
    class at runtime) or queries, and subclasses declare relatively few properties
    (particularly if the main difference between subclasses is in their behavior),
    lean toward `InheritanceType.SINGLE_TABLE`. This approach can be chosen if it
    involves setting a minimal number of columns as nullable. You’ll need to convince
    yourself (and the DBA) that a denormalized schema won’t create problems in the
    long run.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确实需要多态关联（一个指向超类的关联，因此指向在运行时动态解析的具体类）或查询，并且子类声明了相对较少的属性（尤其是如果子类之间的主要区别在于它们的行为），则倾向于使用
    `InheritanceType.SINGLE_TABLE`。如果这涉及到设置尽可能少的可空列，则可以选择这种方法。你需要说服自己（以及数据库管理员），非规范化的模式在长期内不会造成问题。
- en: If you do require polymorphic associations or queries, and subclasses declare
    many (non-optional) properties (subclasses differ mainly by the data they hold),
    lean toward `InheritanceType.JOINED`. Alternatively, depending on the width and
    depth of the inheritance hierarchy and the possible cost of joins versus unions,
    use `InheritanceType.TABLE_PER_CLASS`. This decision might require the evaluation
    of SQL execution plans with real data.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你确实需要多态关联或查询，并且子类声明了许多（非可选）属性（子类主要在它们持有的数据上有所不同），则倾向于使用 `InheritanceType.JOINED`。或者，根据继承层次结构的宽度和深度以及连接与联合的可能成本，使用
    `InheritanceType.TABLE_PER_CLASS`。这个决定可能需要评估带有真实数据的 SQL 执行计划。
- en: By default, choose `InheritanceType.SINGLE_TABLE` only for simple problems.
    For complex cases, or when a data modeler insists on the importance of `NOT NULL`
    constraints and normalization overrules you, you should consider the `Inheritance-Type
    .JOINED` strategy. At that point, you should ask yourself whether it may not be
    better to remodel inheritance as delegation in the class model. Complex inheritance
    is often best avoided for all sorts of reasons unrelated to persistence or ORM.
    Hibernate acts as a buffer between the domain and relational models, but that
    doesn’t mean you can ignore persistence concerns completely when designing the
    classes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，仅对于简单问题选择 `InheritanceType.SINGLE_TABLE`。对于复杂情况，或者当数据模型师坚持认为 `NOT NULL`
    约束和规范化比你的需求更重要时，你应该考虑 `Inheritance-Type .JOINED` 策略。在这种情况下，你应该问自己，是否可能将继承在类模型中重新建模为代理更好。由于各种与持久化或
    ORM 无关的原因，复杂的继承通常最好避免。Hibernate 作为领域模型和关系模型之间的缓冲区，但这并不意味着在设计类时可以完全忽略持久化问题。
- en: When you start thinking about mixing inheritance strategies, you must remember
    that implicit polymorphism in Hibernate is smart enough to handle exotic cases.
    Also, you must consider that you can’t put inheritance annotations on interfaces;
    this isn’t standardized in JPA.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始考虑混合继承策略时，你必须记住，Hibernate 中的隐式多态足够智能，可以处理复杂的情况。此外，你必须考虑，你无法在接口上放置继承注解；这在
    JPA 中没有标准化。
- en: 'For example, suppose you needed to add an interface in the CaveatEmptor application:
    `ElectronicPaymentOption`. This is a business interface that doesn’t have a persistence
    aspect except that a persistent class such as `CreditCard` will likely implement
    this interface. No matter how we map the `BillingDetails` hierarchy, Hibernate
    can answer the query `select` `o` `from` `ElectronicPaymentOption` `o` correctly.
    This even works if other classes, which aren’t part of the `BillingDetails` hierarchy,
    are mapped as persistent and implement this interface. Hibernate always knows
    what tables to query, which instances to construct, and how to return a polymorphic
    result.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要在 CaveatEmptor 应用程序中添加一个接口：`ElectronicPaymentOption`。这是一个没有持久化方面的业务接口，除了持久化类如
    `CreditCard` 可能会实现这个接口。无论我们如何映射 `BillingDetails` 层次结构，Hibernate 都可以正确地回答查询 `select
    o from ElectronicPaymentOption o`。即使其他不属于 `BillingDetails` 层次结构的类被映射为持久化并实现这个接口，这也同样适用。Hibernate
    总是知道要查询哪些表，要构造哪些实例，以及如何返回多态结果。
- en: We can apply all mapping strategies to abstract classes. Hibernate won’t try
    to instantiate an abstract class, even if we query or load it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有映射策略应用于抽象类。即使我们查询或加载它，Hibernate 也不会尝试实例化一个抽象类。
- en: 'We mentioned the relationship between `User` and `BillingDetails` several times,
    and we looked at how it influences the selection of an inheritance-mapping strategy.
    In the following and last section of this chapter, we’ll explore this more advanced
    topic in detail: polymorphic associations. If you don’t have such a relationship
    in your model right now, you may want to come back to this topic later, when you
    encounter the issue in your application.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次提到了`User`和`BillingDetails`之间的关系，并探讨了它如何影响继承映射策略的选择。在接下来的最后一节中，我们将详细探讨这个更高级的主题：多态关联。如果你现在模型中没有这样的关系，你可能希望在遇到应用程序中的问题时再回过头来研究这个主题。
- en: 7.8 Polymorphic associations
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 多态关联
- en: Polymorphism is a defining feature of object-oriented languages like Java. Support
    for polymorphic associations and polymorphic queries is a fundamental feature
    of an ORM solution like Hibernate. Surprisingly, we’ve managed to get this far
    without needing to talk much about polymorphism. Refreshingly, there isn’t much
    to say on the topic—polymorphism is so easy to use in Hibernate that we don’t
    need to expend a lot of effort explaining it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是像Java这样的面向对象语言的一个定义性特征。对多态关联和多态查询的支持是像Hibernate这样的ORM解决方案的一个基本特性。令人惊讶的是，我们设法走到了这里而不需要过多地谈论多态。令人耳目一新的是，关于这个话题没有太多可说的——多态在Hibernate中如此容易使用，以至于我们不需要花费太多精力来解释它。
- en: To provide an overview, we’ll first consider a *many-to-one* association to
    a class that may have subclasses and then a *one-to-many* relationship. For both
    examples, the classes of the domain model are the same; see figure 7.6.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个概述，我们首先考虑一个可能具有子类的一个到多关联，然后是一个多对一关系。对于这两个例子，领域模型中的类是相同的；参见图7.6。
- en: '![](../../OEBPS/Images/CH07_F06_Tudose2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F06_Tudose2.png)'
- en: Figure 7.6 A user has either a credit card or a bank account as the default
    billing details.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 一个用户默认的账单详情要么是信用卡要么是银行账户。
- en: 7.8.1 Polymorphic many-to-one associations
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.1 多态多对一关联
- en: First, consider the `defaultBilling` property of `User`. It references one particular
    `BillingDetails` instance, which at runtime can be any concrete instance of that
    class. The source code that follows can be found in the mapping-inheritance-manytoone
    folder.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑`User`的`defaultBilling`属性。它引用了一个特定的`BillingDetails`实例，在运行时可以是该类任何具体的实例。下面的源代码可以在`mapping-inheritance-manytoone`文件夹中找到。
- en: 'We’ll map this unidirectional association to the abstract class `BillingDetails`
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个单向关联映射到抽象类`BillingDetails`，如下所示：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `USERS` table now has the join/foreign-key column `DEFAULTBILLING_ID` representing
    this relationship. It’s a nullable column because a `User` might not have a default
    billing method assigned. Because `BillingDetails` is abstract, the association
    must refer to an instance of one of its subclasses—`CreditCard` or `BankAccount`—at
    runtime.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERS`表现在有一个表示这个关系的连接/外键列`DEFAULTBILLING_ID`。它是一个可空列，因为一个`User`可能没有分配默认的账单方法。因为`BillingDetails`是抽象的，所以关联必须在运行时引用其子类之一——`CreditCard`或`BankAccount`。'
- en: We don’t have to do anything special to enable polymorphic associations in Hibernate.
    If the target class of an association is mapped with `@Entity` and `@Inheritance`,
    the association is naturally polymorphic.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hibernate中启用多态关联不需要做任何特殊的事情。如果一个关联的目标类用`@Entity`和`@Inheritance`映射，那么这个关联就是自然的多态的。
- en: 'The following Spring Data JPA code demonstrates the creation of an association
    to an instance of the `CreditCard` subclass:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Spring Data JPA代码演示了创建一个到`CreditCard`子类实例的关联：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, when we navigate the association in a second unit of work, Hibernate automatically
    retrieves the `CreditCard` instance:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在一个工作单元中导航这个关联时，Hibernate会自动检索`CreditCard`实例：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second line here will invoke the `pay` method from the concrete subclass
    of `BillingDetails`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二行将调用`BillingDetails`具体子类的`pay`方法。
- en: We can handle *one-to-one* associations the same way. What about plural associations,
    like the collection of `billingDetails` for each `User`? Let’s look at that next.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以相同的方式处理一对一关联。那么对于多对一关联，比如每个`User`的`billingDetails`集合，怎么办呢？让我们接下来看看。
- en: 7.8.2 Polymorphic collections
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.2 多态集合
- en: A `User` may have references to many `BillingDetails`, not only a single default
    (one of the many is the default, but let’s ignore that for now). We can map this
    with a bidirectional *one-to-many* association. The source code that follows can
    be found in the mapping-inheritance-onetomany folder.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `User` 可能会引用多个 `BillingDetails`，而不仅仅是单个默认值（许多中的一个可能是默认值，但现在我们忽略这一点）。我们可以通过双向
    *一对多* 关联来映射这一点。接下来的源代码可以在 `mapping-inheritance-onetomany` 文件夹中找到。
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, here’s the owning side of the relationship (declared with `mappedBy` in
    the previous mapping). By the *owning side*, we mean that side of the relationship
    that owns the foreign key in the database, which is `BillingDetails` in this example.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是关系的拥有方（在前一个映射中用 `mappedBy` 声明）。通过“拥有方”，我们指的是在数据库中拥有外键的关系那一方，在这个例子中是 `BillingDetails`。
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So far, there is nothing special about this association mapping. The `BillingDetails`
    class hierarchy can be mapped with `TABLE_PER_CLASS`, `SINGLE_TABLE`, or a `JOINED`
    inheritance type. Hibernate is smart enough to use the right SQL queries, with
    either `JOIN` or `UNION` operators, when loading the collection elements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这种关联映射并没有什么特别之处。`BillingDetails` 类层次结构可以使用 `TABLE_PER_CLASS`、`SINGLE_TABLE`
    或 `JOINED` 继承类型进行映射。Hibernate 足够智能，在加载集合元素时，会使用正确的 SQL 查询，无论是使用 `JOIN` 还是 `UNION`
    操作符。
- en: 'There is one limitation, however: the `BillingDetails` class can’t be a `@MappedSuperclass`,
    as discussed in section 7.1\. It has to be mapped with `@Entity` and `@Inheritance`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个限制：如第 7.1 节所述，`BillingDetails` 类不能是 `@MappedSuperclass`。它必须使用 `@Entity`
    和 `@Inheritance` 进行映射。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Table-per-concrete-class with implicit polymorphism is the simplest strategy
    for mapping inheritance hierarchies of entities, and it doesn’t support polymorphic
    associations very well.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按具体类表与隐式多态是映射实体继承层次结构的最简单策略，但它并不很好地支持多态关联。
- en: Different columns from different tables share exactly the same semantics, making
    schema evolution more complex.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自不同表的列具有完全相同的语义，这使得模式演变更加复杂。
- en: This table-per-concrete-class approach is recommended for the top level of the
    class hierarchy only, where polymorphism isn’t usually required and when modification
    of the superclass in the future is unlikely.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种按具体类表的方法仅推荐用于类层次结构的顶层，因为在这些地方通常不需要多态性，并且未来修改超类不太可能。
- en: The table-per-concrete-class-with-unions strategy is optional, and JPA implementations
    may not support it, but it does handle polymorphic associations.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按具体类表与并集的策略是可选的，并且 JPA 实现可能不支持它，但它确实处理了多态关联。
- en: The table-per-class-hierarchy strategy is a winner in terms of both performance
    and simplicity. Ad hoc reporting is possible without complex joins or unions,
    and schema evolution is straightforward.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类层次结构表的方法在性能和简单性方面都是赢家。可以执行临时报告，而无需复杂的连接或并集操作，并且模式演变是直接的。
- en: 'The one major problem with the single-table strategy is data integrity, because
    we must declare some columns as nullable. Another concern is normalization: this
    strategy creates functional dependencies between non-key columns, violating the
    third normal form.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单表策略的一个主要问题是数据完整性，因为我们必须将一些列声明为可空的。另一个关注点是规范化：这种策略在非键列之间创建了函数依赖关系，违反了第三范式。
- en: The table-per-subclass-with-joins strategy has as its primary advantage the
    fact that it normalizes the SQL schema, making schema evolution and integrity
    constraint definition straightforward. The disadvantages are that it’s more difficult
    to implement by hand, and performance can be unacceptable for complex class hierarchies.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按子类表连接的策略的主要优点是它使 SQL 模式规范化，使得模式演变和完整性约束定义变得直接。缺点是手动实现更困难，并且对于复杂的类层次结构，性能可能无法接受。
