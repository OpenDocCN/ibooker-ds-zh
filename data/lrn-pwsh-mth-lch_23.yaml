- en: 23 Adding logic and loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 23 添加逻辑和循环
- en: Looping (or going through a list of objects one at a time) is a fundamental
    concept in any language, and PowerShell is no exception. There will come a time
    when you will need to execute a block of code numerous times. PowerShell is well
    equipped to handle this for you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 循环（或逐个遍历对象列表）是任何语言中的基本概念，PowerShell 也不例外。总会有需要多次执行代码块的时候。PowerShell 已经准备好为你处理这个问题。
- en: 23.1 Foreach and Foreach-Object
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.1 Foreach 和 Foreach-Object
- en: This section may be a bit confusing, as there is a difference between `Foreach`
    and `Foreach-Object`. Take a look at figure 23.1 for a visual representation of
    how `Foreach` works.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节可能有点令人困惑，因为 `Foreach` 和 `Foreach-Object` 之间有一个区别。请参阅图 23.1 以了解 `Foreach`
    的工作原理的视觉表示。
- en: '![](Images/CH23_F01_Plunk.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH23_F01_Plunk.png)'
- en: Figure 23.1 Diagram of how `Foreach` works
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.1 `Foreach` 的工作原理图
- en: 23.1.1 Foreach
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.1 Foreach
- en: Probably the most common form of looping is the `Foreach` command. `Foreach`
    allows you to iterate through a series of values in a collection of items, such
    as an array. The syntax of a `Foreach` command is
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的循环形式可能是 `Foreach` 命令。`Foreach` 允许你遍历集合中一系列值，例如数组。`Foreach` 命令的语法是
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The process block (the part surrounded by `{}` ) will execute as many times
    as the number of collection objects. Let’s look at the following command and break
    it down:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 过程块（被 `{}` 包围的部分）将根据集合对象的数量执行多次。让我们看看以下命令并对其进行分解：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we made a variable called `$array` that will contain an array of numbers
    from 1 to 10\. Next, we are making a temporary variable (`$a`) and assigning it
    to the current item in the collection that we are working with. The variable is
    available only inside the script block and will change as we iterate through the
    array.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为 `$array` 的变量，它将包含从 1 到 10 的数字数组。接下来，我们创建了一个临时变量（`$a`）并将其分配给我们在处理的集合中的当前项。该变量仅在脚本块内部可用，并且在我们遍历数组时将发生变化。
- en: Finally, the script block represented by the curly braces `{ }` will output
    `$a` to the screen (figure 23.2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由大括号 `{}` 表示的脚本块将输出 `$a` 到屏幕上（图 23.2）。
- en: '![](Images/CH23_F02_Plunk.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH23_F02_Plunk.png)'
- en: Figure 23.2 Writing the output of an array using `foreach`
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.2 使用 `foreach` 编写数组输出
- en: 23.1.2 Foreach-Object
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.2 Foreach-Object
- en: The `Foreach-Object` cmdlet performs an operation defined in a script block
    on each item in the input collection objects. Most frequently, the `Foreach-Object`
    is called via the pipeline.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foreach-Object` cmdlet 在输入集合对象中的每个项目上执行在脚本块中定义的操作。最常见的是，`Foreach-Object` 通过管道调用。'
- en: TIP Use `Foreach` if you are looping through multiple objects, and use `Foreach-Object`
    if you are using it in the pipeline.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你正在遍历多个对象，请使用 `Foreach`；如果你在管道中使用它，请使用 `Foreach-Object`。
- en: Let’s look at the command `Get-ChildItem | ForEach-Object {$_.name}`. First,
    we are running the command `Get-ChildItem` and sending the objects down the pipeline
    to the `Foreach-Object` cmdlet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看命令 `Get-ChildItem | ForEach-Object {$_.name}`。首先，我们运行 `Get-ChildItem` 命令，并将对象通过管道发送到
    `Foreach-Object` cmdlet。
- en: Next, we are saying for every item received from `Get-ChildItem`, run the command
    `$_.name` (figure 23.3). If you recall from earlier in the text, `$_` is simply
    the current object in the pipeline. By using `$_`.`Name`, we are taking the `name`
    property from the object and displaying it on the screen.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们说对于从 `Get-ChildItem` 收到的每个项目，运行命令 `$_.name`（图 23.3）。如果你还记得文本前面的内容，`$_`
    简单地是管道中的当前对象。通过使用 `$_`.`Name`，我们从对象中获取 `name` 属性并将其显示在屏幕上。
- en: '![](Images/CH23_F03_Plunk.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH23_F03_Plunk.png)'
- en: Figure 23.3 This shows how to use `foreach-object` with the pipeline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.3 展示了如何使用 `foreach-object` 与管道结合。
- en: For both the `Foreach` and `Foreach-Object` cmdlets, the commands are executed
    sequentially, meaning it will take `item[0]`, run the commands you have specified,
    followed by the following `item[1]`, and so on until the input collection is empty.
    Usually this isn’t a problem, but eventually, if you have a lot of commands in
    the process block or your input collection is enormous, you can see where executing
    these one at a time would impact your script’s run time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Foreach` 和 `Foreach-Object` cmdlet，命令是顺序执行的，这意味着它将依次执行 `item[0]`，然后运行你指定的命令，接着是
    `item[1]`，依此类推，直到输入集合为空。通常这不会成问题，但最终，如果你在过程块中有许多命令或你的输入集合非常大，你就可以看到逐个执行这些命令会对脚本的运行时间产生影响。
- en: Hopefully, before you started diving into the chapter, you used the help feature
    to look at all the parameters available for `Foreach-Object`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在你开始深入研究本章之前，你已经使用了帮助功能来查看所有可用的`Foreach-Object`参数。
- en: Try it Now Run `get-help` `Foreach-Object` and review the results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看；运行`get-help` `Foreach-Object`并查看结果。
- en: Above and beyond
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: The `%` is also an alias for the `ForEach-Object` command. The command from
    earlier could have been written
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`也是`ForEach-Object`命令的别名。之前的命令可以写成'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: which would have yielded the same results. But let’s remember that it is always
    best to use full cmdlet names.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生相同的结果。但让我们记住，始终使用完整的cmdlet名称是最好的。
- en: 23.1.3 Foreach-Object -Parallel
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1.3 Foreach-Object -Parallel
- en: As we mentioned before, the main drawback with the `Foreach-Object` command
    has been that it runs sequentially. There have been a few community-driven modules
    to help enable a parallel feature for the `Foreach-Object` command. With the introduction
    of PowerShell 7 (preview 3), a new `-Parallel` parameter was added to the `Foreach-Object`
    command. Instead of the command(s) being run sequentially, we can now run the
    same commands on most or all of our input objects at the same time. For example,
    suppose you are creating 1,000 new users in Active Directory. You could run the
    command
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`Foreach-Object`命令的主要缺点是它是顺序运行的。有几个由社区驱动的模块旨在帮助为`Foreach-Object`命令启用并行功能。随着PowerShell
    7（预览版3）的引入，`Foreach-Object`命令中添加了一个新的`-Parallel`参数。现在，我们可以在大多数或所有输入对象上同时运行相同的命令，而不是顺序运行命令。例如，假设你正在Active
    Directory中创建1,000个新用户。你可以运行以下命令
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'which would run the `New-Aduser` command 1,000 times sequentially. Or you can
    run the command with the `Parallel` parameter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将依次运行`New-Aduser`命令1,000次。或者，你可以使用`Parallel`参数来运行该命令：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following command takes an array of numbers (1–5) and pipes it to a traditional
    `Foreach-Object` command, writes the output to the screen, and sleeps for 2 seconds
    (figure 23.4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令接受一个数字数组（1-5），将其通过管道传递到传统的`Foreach-Object`命令，将输出写入屏幕，并暂停2秒（图23.4）。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](Images/CH23_F04_Plunk.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH23_F04_Plunk.png)'
- en: Figure 23.4 Takes an array, pipes to `Foreach-Object`, then runs a second command
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.4接受一个数组，通过管道传递到`Foreach-Object`，然后运行第二个命令
- en: We can see by using the `measure-command` cmdlet that this will take 10 seconds
    to complete.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`measure-command` cmdlet，我们可以看到这将需要10秒才能完成。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we add the `-parallel` parameter, we will execute what is inside the command
    block on all the numbers in the array at once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加`-parallel`参数时，我们将一次性在数组中的所有数字上执行命令块内的内容。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using the `parallel` parameter, we decreased our run time from 10 seconds
    to 2 seconds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`parallel`参数，我们将运行时间从10秒减少到2秒。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because each script block is running simultaneously, the order in which the
    results are returned to the screen cannot be guaranteed. There is also a throttle
    limit or the maximum number of script blocks that can be run in parallel at once
    that we need to make sure you know about—the default is 5\. In our example, we
    had only 5 items in our input collection, so all 5 script blocks were running
    simultaneously. However, if we change our example from 5 items to 10 items, we
    will notice the run time changes from 2 seconds to 4 seconds. We can, however,
    change the throttle limit to a higher one by using the `-throttlelimit` parameter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个脚本块都是同时运行的，所以返回到屏幕上的结果顺序无法保证。同时，还有一个节流限制，即一次可以并行运行的脚本块的最大数量，我们需要确保你知道这一点——默认值是5。在我们的例子中，我们的输入集合中只有5个项目，所以所有5个脚本块都是同时运行的。然而，如果我们把我们的例子从5个项目改为10个项目，我们会注意到运行时间从2秒变为4秒。但是，我们可以通过使用`-throttlelimit`参数来将节流限制提高到更高的值。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Try it Now Change the array to 10 items; then use the `measure-command` cmdlet
    to see how long it takes to execute.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看；将数组改为10个项目；然后使用`measure-command` cmdlet来查看执行所需的时间。
- en: There is, however, a limitation with the `parallel` feature. In order to run
    each script block simultaneously, a new runspace is created. This can lead to
    significant performance degradation if the script blocks you are running are resource
    intensive.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`parallel`功能有一个限制。为了同时运行每个脚本块，会创建一个新的运行空间。如果你的脚本块是资源密集型的，这可能会导致性能显著下降。
- en: 23.3 While
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.3 当
- en: 'If you have done any kind of scripting or programming before, then a `while`
    loop should not be new concept to you. A `while` loop is an iterative loop, or
    it will run until the terminating condition is satisfied. Like the `Foreach` loop
    we just talked about, the `while` loop has a script block, where you can put your
    commands to be executed (figure 23.5). The basic syntax is as follows: `While`
    (`condition`) {`commands`}.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前做过任何类型的脚本或编程，那么 `while` 循环应该对你来说不是一个新概念。`while` 循环是一个迭代循环，它将一直运行，直到满足终止条件。就像我们刚才提到的
    `Foreach` 循环一样，`while` 循环有一个脚本块，你可以在这里放置要执行的命令（图 23.5）。基本语法如下：`While` (`condition`)
    {`commands`}。
- en: '![](Images/CH23_F05_Plunk.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH23_F05_Plunk.png)'
- en: Figure 23.5 Diagram showing how a `while` loop works
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.5 展示了 `while` 循环的工作原理
- en: '*Condition*—A Boolean (`$True` or `$False`) statement. The loop will execute
    while the condition is `True` and will terminate when the condition is `False`.
    Example: `While ($n -ne 10)`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*条件*—一个布尔 (`$True` 或 `$False`) 表达式。循环将在条件为 `True` 时执行，并在条件为 `False` 时终止。例如：`While
    ($n -ne 10)`。'
- en: '*Commands*—Simple or complex commands that you want to execute while the condition
    is `True`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命令*—在条件为 `True` 时要执行的简单或复杂命令。'
- en: 'Here is a quick example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also start adding logic operators such as `-and` and `-or` into our
    condition statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以开始将逻辑运算符如 `-and` 和 `-or` 添加到我们的条件语句中：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: TIP If you were to run the above command, it would run indefinitely unless you
    happened to run it on `25-December`. Use Ctrl-C to break the execution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你运行上述命令，它将无限期地运行，除非你恰好是在 `25-December` 运行的。使用 Ctrl-C 来中断执行。
- en: 23.3 Do While
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.3 Do While 循环
- en: As we mentioned before, the `while` loop will execute only while the condition
    is `true`. But what if you wanted to execute the loop at least once regardless
    of whether the condition was `true` or not? That is where the `Do While` loop
    comes into play.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`while` 循环只有在条件为 `true` 时才会执行。但如果你想要至少执行一次循环，无论条件是否为 `true`，那该怎么办？这就是
    `Do While` 循环发挥作用的地方。
- en: '*With* `Do` {`commands`} `While` (`condition`), notice that the script block
    and condition block are reversed. This will allow us to execute the script block
    at least one time, then evaluate our condition to see if we need to repeat the
    loop:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用* `Do` {`commands`} `While` (`condition`)，请注意，脚本块和条件块是相反的。这将允许我们至少执行一次脚本块，然后评估我们的条件以确定是否需要重复循环：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 23.4 Lab
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.4 实验内容
- en: Find a directory that has a lot of items in it. Use a `Foreach` loop and count
    the number of characters in each filename.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包含大量项目的目录中查找。使用 `Foreach` 循环并计算每个文件名的字符数。
- en: Do the same, but this time use the `-parallel` parameter.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样操作，但这次使用 `-parallel` 参数。
- en: 'Start the notepad process (or text editor of your choice); then write a `do
    while` loop that will display the following text until the process is closed:
    `$process is open`.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动记事本进程（或你选择的文本编辑器）；然后编写一个 `do while` 循环，直到进程关闭时显示以下文本：`$process is open`。
- en: 23.5 Lab answers
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23.5 实验答案
- en: '`$items = Get-ChildItem SOMEWHERE YOU |CHOSE`'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$items = Get-ChildItem SOMEWHERE YOU |CHOSE`'
- en: '`foreach ($i in $items){Write-Output "The character length of $i is`'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`foreach ($i in $items){Write-Output "The character length of $i is`'
- en: '`➥ "($i).Length}`'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ "($i).Length"`'
- en: '`start-process notepad`'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start-process notepad`'
- en: '`$Process = "notepad"`'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$Process = "notepad"`'
- en: '`do {`'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`do {`'
- en: '`    Write-Host "$process is open"`'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`    Write-Host "$process is open"`'
- en: '`} while ((get-process).name -contains "notepad")`'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`} while ((get-process).name -contains "notepad")`'
