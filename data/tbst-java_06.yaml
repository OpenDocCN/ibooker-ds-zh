- en: '5 Making the most of logs: Auditing an app’s behavior'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 充分利用日志：审计应用程序的行为
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Effectively using logs to understand an app’s behavior
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用日志来理解应用程序的行为
- en: Correctly implementing log capabilities in your app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确实现应用程序中的日志功能
- en: Avoiding issues caused by logs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免由日志引起的问题
- en: In this chapter, we will discuss using log messages that an app records. The
    concept of logging didn’t first appear with software. For centuries, people used
    logs to help them understand past events and processes. People have used logging
    since writing was invented, and we still use it today. All ships have logbooks.
    Sailors record decisions (direction, speed increase or decrease, etc.) and given
    or received orders, along with any encountered event (figure 5.1). If something
    happens to the onboard equipment, they can use the logbook notes to understand
    where they are and navigate to the nearest shore. If an accident happens, the
    logbook notes can be used in the investigation to determine how the unfortunate
    event could have been avoided.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用应用程序记录的日志消息。日志的概念并非随着软件的出现而出现。几个世纪以来，人们使用日志来帮助他们理解过去的事件和过程。自从书写发明以来，人们就开始使用日志，并且我们今天仍在使用它。所有船只都有航海日志。水手记录决策（方向、速度增加或减少等）和下达或接收的命令，以及遇到的任何事件（图5.1）。如果船上设备出现问题，他们可以使用航海日志的记录来了解自己的位置，并导航到最近的岸边。如果发生事故，航海日志的记录可以在调查中用来确定如何避免不幸事件。
- en: '![](../../OEBPS/Images/CH05_F01_Spilca3.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F01_Spilca3.png)'
- en: Figure 5.1 Sailors store events in logs that they can use to determine their
    route or analyze the crew’s response to a given event. In the same way, apps store
    log messages so that developers can later analyze a potential issue or discover
    breaches in the app.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 水手将事件存储在日志中，他们可以使用这些日志来确定自己的航线或分析船员对特定事件的反应。同样，应用程序存储日志消息，以便开发者可以在以后分析潜在问题或发现应用程序中的漏洞。
- en: If you’ve ever watched a chess game, you know that both players write down each
    piece’s movement. Why? These logs help them re-create the entire game afterward.
    They study both their and their opponent’s moves to spot potential mistakes or
    vulnerabilities.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经观看过棋局，你就会知道两位棋手都会记录每一步棋的移动。为什么？这些日志帮助他们之后重新创建整个游戏。他们研究自己和对手的走法，以发现潜在的错误或弱点。
- en: For similar reasons, applications also log messages. We can use those messages
    to understand what happens when an app executes. By reading the log messages,
    you can re-create the execution in the same way that a chess player re-creates
    a whole chess game. We can use logs when we investigate a strange or unwanted
    behavior or more hard-to-see issues such as security vulnerabilities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 出于类似的原因，应用程序也会记录日志消息。我们可以使用这些消息来了解应用程序执行时发生了什么。通过阅读日志消息，你可以像棋手重新创建整个棋局一样重新创建执行过程。当我们调查异常或不受欢迎的行为，或者更难以察觉的问题，如安全漏洞时，我们可以使用日志。
- en: I’m sure you already know what logs look like. You’ve seen log messages, at
    least when running your app with an IDE (figure 5.2). All IDEs have a *log console*.
    It’s one of the first things all software developers learn. But an app doesn’t
    just display log messages in the IDE’s console. Real-world apps store logs to
    allow developers to investigate a specific app behavior at a given time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经知道日志看起来像什么了。你至少在用IDE（图5.2）运行你的应用程序时见过日志消息。所有IDE都有一个*日志控制台*。这是所有软件开发者最初学习的内容之一。但是，应用程序不仅仅在IDE的控制台中显示日志消息。现实世界的应用程序会将日志存储起来，以便开发者可以调查特定时间点的应用程序行为。
- en: '![](../../OEBPS/Images/CH05_F02_Spilca3.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F02_Spilca3.png)'
- en: Figure 5.2 IDE log console. All IDEs have a log console. While logging messages
    in the console is useful when running the app locally, real-world apps also store
    logs that are needed to understand how the app behaved at a given time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 IDE日志控制台。所有IDE都有一个日志控制台。在本地运行应用程序时，在控制台中记录日志消息是有用的，但现实世界的应用程序也会存储日志，这些日志是理解应用程序在特定时间行为所必需的。
- en: Figure 5.3 shows the anatomy of a standard-formatted log message. A log message
    is just a string, so theoretically it can be any sentence. However, clean and
    easy-to-use logs need to follow some best practices (that you’ll learn throughout
    this chapter). For example, in addition to a description, a log message contains
    a timestamp of when the app wrote the message, a description of the severity,
    and a notation for the part of the app that wrote the message (figure 5.3).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3展示了标准格式日志消息的结构。日志消息只是一个字符串，所以从理论上讲，它可以是一句任何句子。然而，干净且易于使用的日志需要遵循一些最佳实践（你将在本章中学习到）。例如，除了描述外，日志消息还包含应用程序写入消息的时间戳、严重性的描述以及记录消息的应用程序部分的标记（图5.3）。
- en: '![](../../OEBPS/Images/CH05_F03_Spilca3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3](../../OEBPS/Images/CH05_F03_Spilca3.png)'
- en: 'Figure 5.3 The anatomy of a well-formatted log message. In addition to describing
    a situation or an event, a log message should also contain several other relevant
    details: the timestamp of when the app logged the message, the event''s severity,
    and where the message was written. Using the details in these logs allows you
    to more easily investigate a problem.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 优质日志消息的结构。除了描述一个情况或事件外，日志消息还应包含其他一些相关细节：应用程序记录消息的时间戳、事件的严重性以及消息被写入的位置。使用这些日志中的细节可以让你更容易地调查问题。
- en: 'In many cases, logs are an efficient way to investigate an app’s behavior.
    Some examples include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，日志是调查应用程序行为的一种有效方式。以下是一些例子：
- en: Investigating an event or a timeline of events that already happened
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查已经发生的事件或事件时间线
- en: Investigating issues where interfering with the app changes the app’s behavior
    (Heisenbugs)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查那些干扰应用程序会改变应用程序行为的（海森堡）问题
- en: Understanding the application’s behavior over the long term
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解应用程序长期的行为
- en: Raising alarms for critical events that require immediate attention
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对需要立即关注的临界事件发出警报
- en: We generally don’t use just one technique when investigating how a particular
    app capability behaves. Depending on the scenario, a developer may combine several
    techniques to understand a particular behavior. In some cases, you’ll use the
    debugger with logs as well as other techniques (which you’ll learn in the following
    chapters) to figure out why something works the way it does.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调查特定应用程序功能的行为时通常不会只使用一种技术。根据场景的不同，开发者可能需要结合几种技术来理解特定的行为。在某些情况下，你将使用调试器以及日志和其他技术（你将在接下来的章节中学习）来找出为什么某些事情会以这种方式工作。
- en: I always recommend that developers check the logs before doing anything else
    when investigating an issue (figure 5.4). Logs often allow you to immediately
    identify strange behavior that helps you to pinpoint where to begin your investigation.
    The logs won’t necessarily answer all your questions, but having a starting point
    is extremely important. If the log messages show you where to begin, you’ve already
    saved a lot of time!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查问题时，我总是建议开发者在进行其他任何操作之前先检查日志（图5.4）。日志通常能让你立即识别出异常行为，这有助于你确定调查的起点。日志不一定能回答你所有的问题，但有一个起点极其重要。如果日志消息显示了你应该从哪里开始，那么你已经节省了很多时间！
- en: '![](../../OEBPS/Images/CH05_F04_Spilca3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3](../../OEBPS/Images/CH05_F04_Spilca3.png)'
- en: Figure 5.4 Whenever you investigate an issue, the first thing you should always
    do is read the app’s logs. In many cases, the log messages give you a starting
    point or offer valuable hints on what you should do next to solve the problem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 在你调查问题时，你应该做的第一件事就是阅读应用程序的日志。在许多情况下，日志消息为你提供了一个起点，或提供了关于下一步如何解决问题的宝贵提示。
- en: In my opinion, logs are not just extremely valuable; they are, in fact, indispensable
    for any application. In the next section, we discuss how to use logs and learn
    the typical investigation scenarios in which logs are essential. In section 5.2,
    you’ll learn how to properly implement logging capabilities in your app. We’ll
    discuss using logging levels to help you more easily filter events and issues
    caused by logs. In section 5.3, we’ll talk about the differences between using
    logs and remote debugging.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，日志不仅极其有价值，实际上对于任何应用程序都是不可或缺的。在下一节中，我们将讨论如何使用日志，并了解日志在典型调查场景中的必要性。在5.2节中，你将学习如何正确实现应用程序中的日志功能。我们将讨论使用日志级别来帮助你更容易地过滤由日志引起的事件和问题。在5.3节中，我们将讨论使用日志和远程调试之间的区别。
- en: I also recommend reading part 4 of *Logging in Action* by Phil Wilkins (Manning,
    2022). This chapter focuses more on investigation techniques with logs, while
    *Logging in Action* dives more deeply into logs’ technicalities. You’ll also find
    logging demonstrated using a different language than Java (Python).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我还推荐阅读Phil Wilkins所著的《Logging in Action》第四部分（Manning, 2022）。这一章更多地关注使用日志的调查技术，而《Logging
    in Action》则更深入地探讨了日志的技术细节。你还会发现使用不同于Java（Python）的语言演示了日志记录。
- en: 5.1 Investigating issues with logs
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 检查日志中的问题
- en: Like any other investigation technique, using logs makes sense in some situations
    and doesn’t in others. In this section, we examine various scenarios in which
    using logs can help you to more easily understand software’s behavior. We’ll begin
    by discussing several key points of log messages and then analyze how these characteristics
    assist developers in their investigation of app issues.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他调查技术一样，在某些情况下使用日志是有意义的，而在其他情况下则不然。在本节中，我们将探讨各种场景，在这些场景中使用日志可以帮助你更轻松地理解软件的行为。我们将首先讨论日志消息的几个关键点，然后分析这些特征如何帮助开发者调查应用问题。
- en: One of the biggest advantages of log messages is that they allow you to visualize
    the execution of a certain piece of code at a given time. When you use a debugger,
    as we discussed in chapters 2 through 4, your attention is mainly on the present.
    You look at how the data looks while the debugger pauses the execution on a specific
    line of code. A debugger doesn’t give you many details on the execution history.
    You can use the execution stack trace to identify the execution path, but everything
    else is focused on the present.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息的一个最大优点是它们允许你可视化特定时间点某段代码的执行。当我们讨论第2-4章时，使用调试器时，你的注意力主要在当前。你查看调试器在特定代码行暂停执行时数据的外观。调试器不会给你很多关于执行历史的细节。你可以使用执行堆栈跟踪来识别执行路径，但其他所有内容都集中在当前。
- en: In contrast, logs focus on the app’s execution over a past period (figure 5.5).
    Log messages have a strong relationship with time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，日志关注的是过去一段时间内应用的执行（图5.5）。日志消息与时间有很强的关联性。
- en: '![](../../OEBPS/Images/CH05_F05_Spilca3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F05_Spilca3.png)'
- en: Figure 5.5 When investigating an issue with the debugger, you focus on the present.
    When you use log messages, you focus on a given period in the past. This difference
    can help you to decide which to use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 在使用调试器调查问题时，你关注的是当前。当你使用日志消息时，你关注的是过去的一个特定时间段。这种差异可以帮助你决定使用哪种方法。
- en: Remember to consider the time zone of the system on which your app is running.
    The log time may be shifted by a few hours because of different time zones (e.g.,
    between where the app runs and where the developer is), and this can be confusing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记得考虑你的应用运行在的系统时区。由于时区不同（例如，应用运行的地方和开发者所在的地方之间），日志时间可能会偏移几个小时，这可能会造成混淆。
- en: NOTE Always include the timestamp in a log message. You’ll use the timestamp
    to easily identify the order in which messages were logged, which will give you
    an idea of when the app wrote a certain message. I recommend the timestamp be
    in the first part (at the beginning) of the message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：始终在日志消息中包含时间戳。你将使用时间戳来轻松识别消息记录的顺序，这将给你一个关于应用何时写入特定消息的线索。我建议时间戳位于消息的第一部分（开头）。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_girl2.png)'
- en: 5.1.1 Using logs to identify exceptions
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 使用日志来识别异常
- en: 'Logs help you to identify a problem after it occurred and investigate its root
    cause. Often, we use logs to decide where to start an investigation. We then continue
    exploring the problem using other tools and techniques, such as the debugger (as
    discussed in chapters 2–4) or a profiler (as discussed in chapters 6–9). You can
    often find exception stack traces in the logs. The next snippet shows an example
    of a Java exception stack trace:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可以帮助你在问题发生后识别问题并调查其根本原因。通常，我们使用日志来决定从哪里开始调查。然后我们继续使用其他工具和技术探索问题，例如调试器（如第2-4章所述）或分析器（如第6-9章所述）。你通常可以在日志中找到异常堆栈跟踪。下面的代码片段显示了Java异常堆栈跟踪的一个示例：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Seeing this exception stack trace, or something similar, in the application’s
    log tells you that something potentially went wrong with a given feature. Each
    exception has its own meaning that helps you to identify where the app encountered
    a problem. For example, a `NullPointerException` tells you that somehow an instruction
    referred to an attribute or a method through a variable that didn’t contain a
    reference to an object instance (figure 5.6).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的日志中看到这个异常堆栈跟踪或类似的内容，告诉你某个功能可能出现了问题。每个异常都有其自己的含义，有助于你确定应用程序遇到问题的位置。例如，`NullPointerException`
    告诉你，某种方式下，一个指令通过一个不包含对象实例引用的变量引用了一个属性或方法（图5.6）。
- en: '![](../../OEBPS/Images/CH05_F06_Spilca3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F06_Spilca3.png)'
- en: Figure 5.6 A `NullPointerException` indicates the app execution encountered
    a behavior that was called without the behaving instance. But that doesn’t mean
    that the line that produced the exception is also the cause of the problem. The
    exception could be a consequence of the root cause. You should always look for
    the root cause instead of locally treating a problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 `NullPointerException` 表示应用程序执行遇到了没有行为实例的行为。但这并不意味着产生异常的行也是问题的原因。异常可能是根本原因的结果。你应该始终寻找根本原因，而不是局部处理问题。
- en: Note Remember that where an exception occurs is not necessarily the location
    of the root cause of the problem. An exception tells you where something went
    wrong, but the exception itself can be a consequence of a problem elsewhere. It
    is not necessarily the problem itself. Don’t make a decision about solving the
    exception locally by adding a `try-catch-finally` block or an `if-else` statement
    too quickly. First, make sure you understand the root cause of the problem before
    looking for a solution to solve it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住，异常发生的地方不一定是问题的根本原因的位置。异常告诉你哪里出了问题，但异常本身可能是其他地方问题的结果。它不一定是问题本身。不要急于通过添加
    `try-catch-finally` 块或 `if-else` 语句来本地解决异常。首先，确保你在寻找解决问题的解决方案之前理解了问题的根本原因。
- en: 'I often find that this concept confuses beginners. Let’s take a simple `NullPointerException`,
    which is probably the first exception any Java developer encounters and one of
    the simplest to understand. However, when you find a `NullPointerException` in
    the logs, you need first to ask yourself: why is that reference missing? It could
    be missing because a particular instruction that the app executed earlier didn’t
    work as expected (figure 5.7).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现这个概念会让初学者感到困惑。让我们以一个简单的 `NullPointerException` 为例，这可能是任何Java开发者遇到的第一个异常，也是最容易理解的。然而，当你发现日志中的
    `NullPointerException` 时，你首先需要问自己：为什么那个引用缺失？它可能是因为应用程序之前执行的一个特定指令没有按预期工作（图5.7）。
- en: '![](../../OEBPS/Images/CH05_F07_Spilca3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F07_Spilca3.png)'
- en: Figure 5.7 Locally solving the problem is in many cases equivalent to sweeping
    it under the rug. If the root cause remains, more issues can appear later. Remember
    that an exception in the logs doesn’t necessarily indicate the root cause.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 在许多情况下，局部解决问题等同于把问题扫到地毯下。如果根本原因仍然存在，以后可能会出现更多问题。记住，日志中的异常并不一定表示根本原因。
- en: 5.1.2 Using exception stack traces to identify what calls a method
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 使用异常堆栈跟踪来识别调用方法
- en: One of the techniques developers consider unusual, but that I find advantageous
    in practice, is logging an exception stack trace to identify what calls a specific
    method. Since starting my career as a software developer, I’ve worked with messy
    codebases of (usually) large applications. One of the difficulties I frequently
    encounter is figuring out who calls a given method when an app is running in a
    remote environment. If you just read the app’s code, you will discover hundreds
    of ways that method could’ve been called.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者认为的一种不寻常的技术，但我在实践中发现它很有优势，就是记录异常堆栈跟踪以识别调用特定方法的代码。自从我开始作为软件开发者职业生涯以来，我就一直在处理（通常是）大型应用的混乱代码库。我经常遇到的一个困难是在远程环境中运行应用程序时，确定谁调用了给定的方法。如果你只是阅读应用程序的代码，你会发现数百种调用该方法的方式。
- en: Of course, if you are lucky enough, and have access, you can use remote bugging
    as discussed in chapter 4\. You can then access the execution stack trace the
    debugger provides. But what if you can’t use a debugger remotely? In this case,
    you can use a logging technique instead!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你足够幸运，并且有权访问，你可以使用第4章中讨论的远程调试。然后你可以访问调试器提供的执行堆栈跟踪。但如果你无法远程使用调试器怎么办？在这种情况下，你可以使用日志技术代替！
- en: 'Exceptions in Java have a capability that is often disregarded: they keep track
    of the execution stack trace. When discussing exceptions, we often call the execution
    stack trace an *exception* stack trace. But they are, in the end, the same thing.
    The exception stack trace displays the chain of method calls that cause a specific
    exception, and you have access to this information even without throwing that
    exception. In code, it’s enough to use the exception:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的异常具有常被忽视的能力：它们记录执行堆栈跟踪。在讨论异常时，我们经常将执行堆栈跟踪称为 *异常* 堆栈跟踪。但最终，它们是同一件事。异常堆栈跟踪显示了导致特定异常的方法调用链，即使没有抛出该异常，你也能访问到这些信息。在代码中，使用异常就足够了：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Consider the method in listing 5.1\. If you don’t have a debugger, you can simply
    print the exception stack trace, as I did in this example, as the first line in
    the method to find the execution stack trace. Keep in mind that this only prints
    the stack trace and doesn’t throw the exception, so it doesn’t interfere with
    the executed logic. This example is in project da-ch5-ex1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑列表 5.1 中的方法。如果你没有调试器，你可以简单地像我在这个示例中做的那样，在查找执行堆栈跟踪的方法中打印异常堆栈跟踪，作为第一行。记住，这只会打印堆栈跟踪，并不会抛出异常，所以它不会干扰执行的逻辑。这个示例在项目
    da-ch5-ex1 中。
- en: Listing 5.1 Printing the execution stack trace in logs using an exception
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 使用异常打印执行堆栈跟踪
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Prints the exception stack trace
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印异常堆栈跟踪
- en: 'The next snippet shows how the app prints the exception stack trace in the
    console. In a real-world scenario, the stack trace helps you to immediately identify
    the execution flow, which leads to the call you want to investigate, as we discussed
    in chapters 2 and 3\. In this example, you can see from the logs that the `extractDigits()`
    method was called on line 11 of the `Decoder` class from within the `decode()`
    method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个片段展示了应用如何在控制台中打印异常堆栈跟踪。在现实场景中，堆栈跟踪帮助你立即识别执行流程，这导致你想要调查的调用，正如我们在第 2 章和第 3
    章中讨论的那样。在这个示例中，你可以从日志中看到，`extractDigits()` 方法是在 `decode()` 方法内部从 `Decoder` 类的第
    11 行被调用的：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 5.1.3 Measuring time spent to execute a given instruction
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 测量执行给定指令花费的时间
- en: Log messages are an easy way to measure the time a given set of instructions
    takes to execute. You can always log the difference between the timestamp before
    and after a given line of code. Suppose you are investigating a performance issue
    in which some given capability takes too long to execute. You suspect that the
    cause is a query the app executes to retrieve data from the database. For some
    parameter values, the query is slow, which is decreasing the app’s overall performance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息是衡量给定指令集执行时间的一种简单方法。你总是可以记录给定行代码前后的时间戳之间的差异。假设你正在调查一个性能问题，其中某些给定功能执行时间过长。你怀疑原因是应用执行以从数据库检索数据的查询。对于某些参数值，查询很慢，这降低了应用的总体性能。
- en: To find which parameter is causing the problem, you can write the query and
    the query execution time in logs. Once you identify the troublesome parameter
    values, you can start looking for a solution. Maybe you need to add one more index
    to a table in the database, or perhaps you can rewrite the query to make it faster.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪个参数导致了问题，你可以在日志中编写查询和查询执行时间。一旦你确定了麻烦的参数值，你就可以开始寻找解决方案。也许你需要向数据库中的表添加一个额外的索引，或者也许你可以重写查询以使其更快。
- en: Listing 5.2 shows you how to log the time spent by the execution of a specific
    piece of code. For example, let’s figure out how much time it takes the app to
    run the operation of finding all the products from the database. Yes, I know,
    we have no parameters here; I simplified the example to allow you to focus on
    the discussed syntax. But in a real-world app, you would most likely investigate
    a more complex operation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 展示了如何记录特定代码片段的执行时间。例如，让我们找出应用运行从数据库中查找所有产品操作所需的时间。是的，我知道，这里没有参数；我简化了示例，以便你能够专注于讨论的语法。但在现实世界的应用中，你可能会调查更复杂的操作。
- en: Listing 5.2 Logging the execution time for a certain line of code
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 记录特定代码行的执行时间
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Logs the timestamp before the method’s execution
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 记录方法执行前的时间戳
- en: ❷ Executes the method for which we want to calculate the execution time
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行我们想要计算执行时间的那个方法
- en: ❸ Calculates the time spent between the timestamp after execution and the timestamp
    before the execution
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算执行后的时间戳与执行前的时间戳之间的时间差
- en: ❹ Prints the execution time
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打印执行时间
- en: Precisely measuring how much time an app spends executing a given instruction
    is a simple but effective technique. However, I would only use this technique
    temporarily when investigating an issue. I don’t recommend you keep such logs
    in the code for long since they most likely will not be needed later, and they
    make the code more difficult to read. Once you’ve solved the problem and no longer
    need to know the execution time for that line of code, you can remove the logs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 准确测量应用程序执行给定指令花费的时间是一种简单但有效的技术。然而，我只会暂时使用这种技术在调查问题时使用。我不建议您长时间保留此类日志在代码中，因为它们很可能以后不再需要，并且会使代码更难以阅读。一旦您解决了问题，不再需要知道该行代码的执行时间，您就可以删除日志。
- en: 5.1.4 Investigating issues in multithreaded architectures
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 调查多线程架构中的问题
- en: A multithreaded architecture is a type of capability that uses multiple threads
    to define its functionality and is often sensitive to external interference (figure
    5.8). For example, if you use a debugger or a profiler (tools that interfere with
    the app’s execution), the app’s behavior may change (figure 5.9).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程架构是一种使用多个线程来定义其功能的能力类型，并且通常对外部干扰很敏感（图5.8）。例如，如果您使用调试器或分析器（干扰应用程序执行的工具），应用程序的行为可能会改变（图5.9）。
- en: '![](../../OEBPS/Images/CH05_F08_Spilca3.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F08_Spilca3.png)'
- en: Figure 5.8 A multithreaded architecture. An app with the capability to use multiple
    threads running concurrently to process data is a multithreaded app. Unless explicitly
    synchronized, instructions running on independent threads (A, B, and C) can run
    in any order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 多线程架构。具有使用多个线程并发处理数据的能力的应用程序是多线程应用程序。除非显式同步，否则在独立线程（A、B和C）上运行的指令可以以任何顺序执行。
- en: '![](../../OEBPS/Images/CH05_F09_Spilca3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F09_Spilca3.png)'
- en: Figure 5.9 Using a tool such as a debugger or a profiler interferes with the
    execution, making some (or all) threads slower. Because of this, the execution
    often changes, and some instructions may execute in a different order than the
    scenario you wanted to investigate. In such a case, the tool is no longer useful
    since you can’t research the behavior you're interested in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 使用调试器或分析器等工具会干扰执行，使某些（或所有）线程变慢。因此，执行通常会改变，某些指令可能以与您想要调查的场景不同的顺序执行。在这种情况下，该工具就不再有用，因为您无法研究您感兴趣的行为。
- en: However, if you use logs, there’s a smaller chance the app will be affected
    while running. Logs can also sometimes interfere in multithreaded apps, but they
    don’t have a big enough impact on the execution to change the app’s flow. Thus,
    they can be a solution for retrieving the data needed for your investigation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您使用日志，应用程序在运行时受到影响的可能性较小。日志有时也会在多线程应用程序中干扰，但它们对执行的影响不足以改变应用程序的流程。因此，它们可以成为检索您调查所需数据的解决方案。
- en: 'Since log messages contain a timestamp (as discussed earlier in the chapter),
    you can order the log messages to find the sequence in which the operations execute.
    In a Java app, it is sometimes helpful to log the thread’s name that executes
    a certain instruction. You can get the name of the current thread in execution
    using the following instruction:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志消息包含时间戳（如本章前面所述），您可以按顺序排列日志消息，以找到操作执行的顺序。在Java应用程序中，有时记录执行特定指令的线程名称是有帮助的。您可以使用以下指令获取当前执行线程的名称：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Java apps, all threads have a name. The developer can name them, or the JVM
    will identify the threads using a name with the pattern Thread-x, where x is an
    incremented number. For example, the first thread created will be named Thread-0;
    the next one, Thread-1; and so on. As we’ll discuss in chapter 10 when we address
    thread dumps, naming your app’s threads is good practice so that you can identify
    them easier when investigating a case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序中，所有线程都有一个名称。开发者可以命名它们，或者JVM将使用具有模式Thread-x的名称来识别线程，其中x是一个递增的数字。例如，第一个创建的线程将被命名为Thread-0；下一个，Thread-1；依此类推。正如我们在第10章中讨论线程转储时将讨论的，命名应用程序的线程是一种良好的实践，这样在调查案例时可以更容易地识别它们。
- en: 5.2 Implementing logging
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 实现日志记录
- en: In this section, we discuss best practices for implementing logging capabilities
    in apps. To make your app’s log messages ready for investigations and avoid causing
    trouble with the app’s execution, you need to take care of some implementation
    details.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了在应用程序中实现日志记录功能的最佳实践。为了使应用程序的日志消息准备好调查，并避免对应用程序的执行造成麻烦，您需要关注一些实现细节。
- en: We’ll start by discussing how apps persist logs in section 5.2.1—specifically
    the advantages and disadvantages of these practices. In section 5.2.2, you’ll
    learn how to use the log messages more efficiently by classifying them based on
    severity and thus make the app perform better. In section 5.2.3, we’ll discuss
    the problems log messages can cause and how to avoid them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在5.2.1节中首先讨论应用程序如何持久化日志，具体讨论这些实践的优势和劣势。在5.2.2节中，你将学习如何通过根据严重性对日志消息进行分类来更有效地使用日志消息，从而提高应用程序的性能。在5.2.3节中，我们将讨论日志消息可能引起的问题以及如何避免这些问题。
- en: 5.2.1 Persisting logs
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 持久化日志
- en: 'Persistence is one of the essential characteristics of log messages. As discussed
    earlier in this chapter, logging is different from other investigation techniques
    because it focuses more on the past than the present. We read logs to understand
    something that happened, so the app needs to store them so that we can read them
    later. How log messages are stored can affect the logs’ usability and the app’s
    performance. I’ve worked with many apps and have had the chance to see various
    ways developers implement log message persistence:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性是日志消息的一个基本特征。正如本章前面所讨论的，日志记录与其他调查技术不同，因为它更多地关注过去而不是现在。我们读取日志是为了理解已经发生的事情，因此应用程序需要存储它们，以便我们可以在以后阅读。日志消息的存储方式可以影响日志的可用性和应用程序的性能。我已与许多应用程序合作，并有幸看到开发人员实现日志消息持久化的各种方法：
- en: Storing logs in a nonrelational database
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志存储在非关系型数据库中
- en: Storing logs in files
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志存储在文件中
- en: Storing logs in a relational database
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志存储在关系型数据库中
- en: These can all be good choices depending on what your app does. Let’s look at
    some of the main things you need to consider to make the right decision.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的功能，这些都可以是好的选择。让我们看看你需要考虑的一些主要事项，以便做出正确的决定。
- en: Storing logs in nonrelational databases
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志存储在非关系型数据库中
- en: Nonrelational (NoSQL) databases help you to make compromises between performance
    and consistency. You can use a NoSQL database to store logs in a more performant
    way, which gives the database a chance to miss log messages or not store them
    in the exact chronological order in which the app wrote them. But, as we discussed
    earlier in this chapter, a log message should always contain the timestamp when
    the message was stored, preferably at the beginning of the message.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型（NoSQL）数据库帮助你权衡性能和一致性。你可以使用NoSQL数据库以更高效的方式存储日志，这给数据库一个机会错过日志消息或不在应用程序写入它们的精确时间顺序中存储它们。但是，正如本章前面所讨论的，日志消息应该始终包含消息存储时的时间戳，最好放在消息的开头。
- en: Storing log messages in NoSQL databases is common. In most cases, apps use a
    complete engine that stores the logs and has the capability to retrieve, search,
    and analyze the log messages. Today’s two most-used engines are the ELK stack
    ([https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack))
    and Splunk ([https://www.splunk.com/](https://www.splunk.com/)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中存储日志消息是常见的。在大多数情况下，应用程序使用一个完整的引擎来存储日志，并具有检索、搜索和分析日志消息的能力。今天使用最广泛的两个引擎是ELK堆栈([https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack))和Splunk([https://www.splunk.com/](https://www.splunk.com/))。
- en: Storing logs in files
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志存储在文件中
- en: In the past, apps stored logs in files. You may still find older applications
    that write log messages directly in files, but this approach is less common today
    because it is generally slower, and searching for logged data is more difficult.
    I bring this to your attention because you’ll find many tutorials and examples
    in which apps store their logs in files, but with more current apps, you should
    avoid this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，应用程序将日志存储在文件中。你可能会发现一些较老的应用程序直接在文件中写入日志消息，但这种方法现在不太常见，因为它通常较慢，并且搜索已记录的数据更困难。我提醒你这一点，因为你会发现在许多教程和示例中，应用程序将它们的日志存储在文件中，但在更现代的应用程序中，你应该避免这样做。
- en: Storing logs in a relational database
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志存储在关系型数据库中
- en: We rarely use relational databases to store log messages. A relational database
    mainly guarantees data consistency, which ensures log messages are not lost. Once
    they are stored, you can retrieve them. But consistency comes with a compromise
    in performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少使用关系型数据库来存储日志消息。关系型数据库主要保证数据一致性，这确保日志消息不会丢失。一旦存储，你就可以检索它们。但一致性会带来性能上的妥协。
- en: In most apps, losing a log message is not a big deal, and performance is generally
    preferred over consistency. But, as always, in real-world apps, there are exceptions.
    For example, governments worldwide impose log message regulations for financial
    apps, especially for payment capabilities. Such capabilities should generally
    have specific log messages that the app isn’t allowed to lose. Failure to comply
    with these regulations can result in sanctions and fines.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，丢失一条日志消息并不是什么大问题，并且性能通常比一致性更重要。但是，正如往常一样，在现实世界应用程序中，总有一些例外。例如，全球各国政府为金融应用程序施加日志消息规定，特别是对于支付功能。这样的功能通常应该有特定的日志消息，应用程序不允许丢失。未能遵守这些规定可能导致处罚和罚款。
- en: 5.2.2 Defining logging levels and using logging frameworks
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 定义日志级别和使用日志框架
- en: In this section, we discuss logging levels and properly implementing logging
    in an app using logging frameworks. We’ll start by examining why logging levels
    are essential and then implement an example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论日志级别以及在应用程序中使用日志框架正确实现日志记录。我们将首先探讨为什么日志级别是必要的，然后实现一个示例。
- en: 'Logging levels, also called *severities*, are a way to classify log messages
    based on their importance to your investigation. An app usually produces a large
    number of log messages while running. However, you often don’t need all the details
    in all the log messages. Some of the messages are more important to your investigation
    than others: some represent critical events that always require attention.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别，也称为*严重性*，是一种根据它们对你调查的重要性来分类日志消息的方法。应用程序在运行时通常会生成大量的日志消息。然而，你通常不需要所有日志消息中的所有细节。其中一些消息对你的调查比其他消息更重要：一些代表需要始终关注的关键事件。
- en: 'The most common log levels (severities) are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的日志级别（严重性）如下：
- en: '*Error*—A critical issue. The app should always log such events. Usually, unhandled
    exceptions in Java apps are logged as errors.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*—一个关键问题。应用程序应该始终记录此类事件。通常，Java应用程序中的未处理异常被记录为错误。'
- en: '*Warn*—An event that is potentially an error, but the application handles it.
    For example, if a connection to a third-party system initially fails but the app
    manages to send the call on a second try, the problem should be logged as a warning.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*警告*—一个可能出错的事件，但应用程序能够处理它。例如，如果一个第三方系统的连接最初失败，但应用程序在第二次尝试中成功发送了呼叫，那么这个问题应该被记录为警告。'
- en: '*Info*—“Common” log messages. These messages represent the main app execution
    events that help you to understand the app’s behavior in most situations.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信息*—“常见”的日志消息。这些消息代表了应用程序的主要执行事件，有助于你理解在大多数情况下应用程序的行为。'
- en: '*Debug*—Fine-grained details that you should enable only when info messages
    are not enough.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*—细粒度的详细信息，你只有在信息消息不足以满足需求时才应该启用。'
- en: Note that different libraries may use more than, or different names for, these
    four severity levels. For example, in some cases, apps or frameworks may use the
    severity levels fatal (more critical than error) and trace (less critical than
    debug). In this chapter, I focus only on the most encountered severities and terminologies
    in real-world apps.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不同的库可能使用多于或不同的名称来表示这四个严重性级别。例如，在某些情况下，应用程序或框架可能使用严重性级别“致命”（比错误更严重）和“跟踪”（比调试更不严重）。在本章中，我仅关注在现实世界应用程序中最常遇到的严重性和术语。
- en: '![](../../OEBPS/Images/icon_guy2.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy2.png)'
- en: Classifying the log messages based on severity allows you to minimize the number
    of log messages your app stores. You should only allow your app to log the most
    relevant details and enable more logging only when you need more details.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据严重性对日志消息进行分类，可以让你最小化应用程序存储的日志消息数量。你应该只允许应用程序记录最相关的细节，并在需要更多细节时才启用更多日志。
- en: 'Look at figure 5.10, which presents the log severity pyramid:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看图5.10，它展示了日志严重性金字塔：
- en: An app logs a small number of critical issues, but these have high importance,
    so they always need to be logged.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序记录少量关键问题，但这些问题非常重要，因此它们始终需要被记录。
- en: The closer you get to the bottom of the pyramid, the more log messages the app
    writes, but they become less critical and less frequently needed in investigations.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你越接近金字塔的底部，应用程序写入的日志消息就越多，但它们在调查中变得不那么关键，也不那么频繁地需要。
- en: '![](../../OEBPS/Images/CH05_F10_Spilca3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F10_Spilca3.png)'
- en: Figure 5.10 The log severity pyramid. On the top are the critical log messages
    that usually require immediate attention. The bottom represents the log messages
    that provide details you’ll rarely need. From the top to the bottom, the log messages
    become less essential but greater in number. Usually, the debug-level messages
    are disabled by default, and the developer can choose to enable them if their
    investigation requires fine-grained details about the app’s execution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 日志严重性金字塔。顶部是通常需要立即关注的临界日志消息。底部代表您很少需要的详细日志消息。从上到下，日志消息变得不那么重要，但数量更多。通常，调试级别的消息默认禁用，开发者可以选择在需要关于应用程序执行细粒度详细信息的研究时启用它们。
- en: For most investigation cases, you won’t need the messages classified as debug.
    Plus, because of their large number, they make your research more challenging.
    For this reason, debug messages are generally disabled, and you should enable
    them only when you face a problem for which you need more details.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数调查案例，您不需要将消息分类为调试。此外，由于数量庞大，它们使您的调查更具挑战性。因此，调试消息通常被禁用，并且您应该仅在遇到需要更多详细信息的特定问题时启用它们。
- en: When you started learning Java, you were taught how to print something in the
    console using `System.out` or `System.err`. Eventually, you learned to use `printStackTrace()`
    to log an exception message, as I used in section 5.1.2\. But these ways of working
    with logs in Java apps don’t give enough flexibility for configuration. So, instead
    of using them in real-world apps, I recommend you use a logging framework.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始学习 Java 时，您被教导如何使用 `System.out` 或 `System.err` 在控制台打印某些内容。最终，您学习了如何使用 `printStackTrace()`
    记录异常消息，正如我在 5.1.2 节中所做的那样。但是，这些在 Java 应用程序中处理日志的方式并不提供足够的配置灵活性。因此，在现实世界的应用程序中，我建议您使用日志框架。
- en: Implementing the logging levels is simple. Today, the Java ecosystem offers
    various logging framework options such as Logback, Log4j, and the Java Logging
    API. These frameworks are similar, and using them is straightforward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现日志级别很简单。今天，Java 生态系统提供了各种日志框架选项，如 Logback、Log4j 和 Java 日志 API。这些框架相似，使用它们很简单。
- en: Let’s take an example and implement logging with Log4j. This example is in project
    da-ch5-ex2\. To implement the logging capabilities with Log4j, you first need
    to add the Log4j dependency. In our Maven project, you must change the pom.xml
    and add the Log4j dependency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来实现使用 Log4j 的日志记录。此示例位于项目 da-ch5-ex2\. 要使用 Log4j 实现日志记录功能，您首先需要添加 Log4j
    依赖项。在我们的 Maven 项目中，您必须更改 pom.xml 并添加 Log4j 依赖项。
- en: Listing 5.3 Dependencies you need to add in the pom.xml file to use Log4j
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 在 pom.xml 文件中需要添加的依赖项以使用 Log4j
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you have the dependency in the project, you can declare a `Logger` instance
    in any class where you want to write log messages. With Log4j, the simplest way
    to create a `Logger` instance is by using the `LogManager.getLogger()` method,
    as presented in listing 5.4\. This method allows you to write log messages that
    are named the same as the severity of the event they represent. For example, if
    you want to log a message with the info sever-ity level, you’ll use the `info()`
    method. If you want to log a message with the debug severity level, you’ll use
    the `debug()` method, and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在项目中添加了依赖项，您就可以在任何想要写入日志消息的类中声明一个 `Logger` 实例。使用 Log4j，创建 `Logger` 实例的最简单方法是使用
    `LogManager.getLogger()` 方法，如列表 5.4 所示。此方法允许您写入与表示的事件严重性名称相同的日志消息。例如，如果您想以信息严重性级别记录一条消息，您将使用
    `info()` 方法。如果您想以调试严重性级别记录一条消息，您将使用 `debug()` 方法，依此类推。
- en: Listing 5.4 Writing the log messages with different severities
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 使用不同严重性写入日志消息
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Declares a logger instance for the current class to write log messages
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为当前类声明一个用于写入日志消息的日志记录器实例
- en: ❷ Writes a message with the info severity
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用信息严重性写入消息
- en: ❸ Writes a message with the debug severity
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用调试严重性写入消息
- en: 'Once you’ve decided which messages to log and used the `Logger` instance to
    write them, you need to configure Log4j to tell the app how and where to write
    these messages. We’ll use an XML file that we name log4j2.xml to configure Log4j.
    This XML file must be in the app’s class path, so we’ll add it to the resources
    folder of our Maven project. We need to define three things (figure 5.11):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定要记录哪些消息并使用 `Logger` 实例写入它们，您需要配置 Log4j 以告诉应用程序如何以及在哪里写入这些消息。我们将使用一个名为 log4j2.xml
    的 XML 文件来配置 Log4j。此 XML 文件必须位于应用程序的类路径中，因此我们将将其添加到我们的 Maven 项目的资源文件夹中。我们需要定义三件事（见图
    5.11）：
- en: '*A logger*—Tells Log4j which messages are to be written to which appender'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*logger*——告诉 Log4j 哪些消息应该写入哪个 appender'
- en: '*An appender*—Tells Log4j where to write the log messages'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*appender*——告诉 Log4j 将日志消息写入何处'
- en: '*A formatter*—Tells Log4j how to print the messages'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*formatter*——告诉 Log4j 如何打印消息'
- en: '![](../../OEBPS/Images/CH05_F11_Spilca3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F11_Spilca3.png)'
- en: Figure 5.11 The relationship between the appender, logger, and formatter. A
    logger uses one or more appenders. The logger decides what to write (e.g., only
    log messages printed by objects in the package). The logger gives the messages
    to be written to one or more appenders. Each appender then implements a certain
    way to store the messages. The appender uses formatters to shape the messages
    before storing them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 展示了 appender、logger 和 formatter 之间的关系。logger 使用一个或多个 appender。logger
    决定要写入什么内容（例如，仅写入包中对象的日志消息）。logger 将要写入的消息交给一个或多个 appender。每个 appender 然后以某种方式存储这些消息。appender
    使用 formatter 在存储之前对消息进行格式化。
- en: The logger defines which messages the app logs. In this example, we use `Root`
    to write the messages from any part of the app. Its attribute level, which has
    the value `info`, means only the messages with a severity of info and higher are
    logged. The logger can also decide to log only messages from specific app parts.
    For example, when using a framework, you are rarely interested in the log messages
    the framework prints, but you are often interested in your app’s log messages,
    so you can define a logger that excludes the framework’s log messages and only
    prints those coming from your app. Remember that you want to write only essential
    log messages. Otherwise, an investigation can become unnecessarily more challenging
    since you must then filter out the nonessential log messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: logger 定义了要记录哪些消息。在这个例子中，我们使用 `Root` 来从应用的任何部分写入消息。其属性 level，值为 `info`，意味着只有严重性为
    info 及以上的消息会被记录。logger 也可以决定只记录来自特定应用部分的消息。例如，当使用框架时，你很少对框架打印的日志消息感兴趣，但你通常对应用的日志消息感兴趣，因此你可以定义一个排除框架日志消息并只打印来自应用的日志消息的
    logger。记住，你只想写入必要的日志消息。否则，调查可能会变得不必要地更具挑战性，因为你必须过滤掉非必要的日志消息。
- en: In a real-world app, you can define multiple appenders, which will most likely
    be configured to store the messages in different sources, like a database or files
    in the filesystem. In section 5.2.1, we discussed multiple ways apps can retain
    log messages. Appenders are simply implementations that take care of storing the
    log messages in a given way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可以定义多个 appender，它们很可能会被配置为将消息存储在不同的来源，如数据库或文件系统中的文件。在第 5.2.1 节中，我们讨论了应用保留日志消息的多种方式。appender
    只是负责以特定方式存储日志消息的实现。
- en: The appender also uses a formatter that defines the format of the message. For
    this example, the formatter specifies that the messages should include the timestamp
    and the severity level, so the app only needs to send the description.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: appender 也使用一个 formatter，该 formatter 定义了消息的格式。在这个例子中，formatter 指定消息应包括时间戳和严重性级别，因此应用只需要发送描述。
- en: Listing 5.5 shows the configuration that defines both an appender and a logger.
    In this example, we define just one appender, which tells Log4j to log the messages
    in the standard output stream of the system (the console).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 展示了定义了 appender 和 logger 的配置。在这个例子中，我们定义了一个 appender，它告诉 Log4j 将消息记录在系统的标准输出流（控制台）中。
- en: Listing 5.5 Configuring the appender and the logger in the log4j2.xml file
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 展示了在 log4j2.xml 文件中配置 appender 和 logger 的配置
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines an appender
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义 appender
- en: ❷ Defines a logger configuration
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义 logger 配置
- en: 'Figure 5.12 visually shows the link between the XML configuration in listing
    5.5 and the three components it defines: the logger, appender, and formatter.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 可视化地展示了列表 5.5 中的 XML 配置与它定义的三个组件之间的联系：logger、appender 和 formatter。
- en: '![](../../OEBPS/Images/CH05_F12_Spilca3.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F12_Spilca3.png)'
- en: Figure 5.12 The components in configuration. The logger `Root` takes all the
    log messages with severity level info that the app writes. The logger sends the
    messages to the appender named `Console`. The appender `Console` is configured
    to send the messages to the system terminal. It uses a formatter to attach the
    timestamp and the severity level to the message before writing it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 配置中的组件。logger `Root` 接收应用写入的所有严重性级别为 info 的日志消息。logger 将消息发送到名为 `Console`
    的 appender。appender `Console` 被配置为将消息发送到系统终端。它使用 formatter 在写入之前将时间戳和严重性级别附加到消息上。
- en: The next snippet shows a section of the logs printed when the example runs.
    Note that debug messages aren’t logged since they are lower in severity than info
    (line 10 in listing 5.5).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了示例运行时打印的日志部分。请注意，调试消息没有被记录，因为它们的严重性低于信息（列表 5.5 中的第 10 行）。
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we wanted the app to also log the messages with the debug severity, we would
    have to change the logger definition.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让应用程序也记录调试严重性的消息，我们就必须更改日志定义。
- en: Listing 5.6 Using a different severity configuration
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 使用不同的严重性配置
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Sets the logging level for internal Log4j events
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置内部 Log4j 事件的日志级别
- en: ❷ Changes the logging level to debug
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将日志级别更改为调试
- en: In listing 5.6, you can see a status and a logging level. This usually creates
    confusion. Most of the time, you care about the `level` attribute, which shows
    which messages will be logged according to severity. The `status` attribute in
    the `<Configuration>` tag is the severity of the Log4J events, the issues the
    library encounters. That is, the `status` attribute is the logging configuration
    of the logging library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.6 中，您可以看到一个状态和一个日志级别。这通常会引起混淆。大多数时候，您关心的是 `level` 属性，它显示根据严重性哪些消息将被记录。在
    `<Configuration>` 标签中的 `status` 属性是 Log4J 事件的严重性，库遇到的问题。也就是说，`status` 属性是日志库的日志配置。
- en: 'We can change the logger in listing 5.6 to also write the messages with the
    priority:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表 5.6 中的日志记录器更改为也记录具有优先级的消息：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A logger library gives you the flexibility to log only what you need. Writing
    the minimum number of log messages necessary to investigate a certain issue is
    good practice as it can help you to understand the logs more easily and keep the
    app performing well and maintainable. A logging library also gives you the capability
    of configuring the logs without needing to recompile the app.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库为您提供了灵活性，让您只记录所需的内容。编写最少数量的日志消息以调查特定问题是一种良好的实践，因为它可以帮助您更容易地理解日志，并保持应用程序的性能良好和易于维护。日志库还使您能够在不重新编译应用程序的情况下配置日志。
- en: 5.2.3 Problems caused by logging and how to avoid them
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 日志引起的问题及其避免方法
- en: 'We store log messages so that we can use them to understand how an app behaved
    at a certain point in time or over time. Logs are necessary and extremely helpful
    in many cases, but they can also become malicious if mishandled. In this section,
    we discuss three main problems logs can cause and how to avoid them (figure 5.13):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储日志消息，以便我们可以使用它们来了解应用程序在某个时间点或一段时间内的行为。在许多情况下，日志是必要的并且非常有帮助，但如果不妥善处理，它们也可能变得有害。在本节中，我们将讨论日志可能引起的主要问题以及如何避免这些问题（图
    5.13）：
- en: '*Security and privacy issues*—Caused by log messages exposing private data'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全和隐私问题*—由暴露私人数据的日志消息引起'
- en: '*Performance issues*—Caused by the app storing too many or too-large log messages'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*性能问题*—由应用程序存储过多或过大的日志消息引起'
- en: '*Maintainability issues*—Caused by log instructions that make the source code
    more difficult to read'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性问题*—由使源代码更难阅读的日志指令引起'
- en: '![](../../OEBPS/Images/CH05_F13_Spilca3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F13_Spilca3.png)'
- en: Figure 5.13 Small details can cause big problems. Developers sometimes consider
    an app’s logging capability harmless by default and disregard the problems logging
    can introduce. Logging, however, like all the other software capabilities, deals
    with the data and, wrongly implemented, can affect the app’s functionality and
    maintainability.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 小细节可能导致大问题。开发者有时会认为应用程序的日志功能默认无害，并忽视日志可能引入的问题。然而，日志，就像所有其他软件功能一样，处理数据，如果实现不当，可能会影响应用程序的功能和可维护性。
- en: Security and privacy issues
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 安全和隐私问题
- en: 'Security is one of my favorite topics and one of the most important subjects
    a developer needs to consider when they implement an app. One of the books I wrote
    concerns security, and if you implement apps using the Spring Framework and want
    to learn more about securing them, I recommend you read it: *Spring Security in
    Action* (Manning, 2020).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是我最喜欢的主题之一，也是开发者在实现应用程序时需要考虑的最重要主题之一。我写的一本书就是关于安全的，如果你使用 Spring 框架实现应用程序并想了解更多关于如何保护它们的信息，我建议你阅读它：*Spring
    Security in Action*（Manning，2020）。
- en: Surprisingly, logs can sometimes cause vulnerabilities in applications, and
    in most cases, these issues happen because developers are not attentive to the
    details they expose. Remember that logs make specific details visible to anyone
    who can access them. You always need to think about whether the data you log should
    be visible to those who can access the logs (figure 5.14).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，日志有时会导致应用程序出现漏洞，在大多数情况下，这些问题发生是因为开发者没有注意到他们暴露的细节。请记住，日志使特定细节对任何可以访问它们的人可见。你始终需要考虑你记录的数据是否应该对可以访问日志的人可见（图5.14）。
- en: '![](../../OEBPS/Images/CH05_F14_Spilca3.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 日志消息不应包含秘密或私人细节。任何在应用程序或应用程序部署的基础设施上工作的人都不应访问此类数据。在日志中暴露敏感细节可以帮助恶意人员（黑客）找到更容易的方法来破坏系统或创建与安全相关的问题。](../../OEBPS/Images/CH05_F14_Spilca3.png)'
- en: Figure 5.14 Log messages should not contain secret or private details. No one
    working on the app or the infrastructure where the app is deployed should access
    such data. Exposing sensitive details in logs can help a malicious person (hacker)
    to find easier ways to break the system or create security-related problems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 日志消息不应包含秘密或私人细节。任何在应用程序或应用程序部署的基础设施上工作的人都不应访问此类数据。在日志中暴露敏感细节可以帮助恶意人员（黑客）找到更容易的方法来破坏系统或创建与安全相关的问题。
- en: 'The following snippet shows some examples of log messages that expose sensitive
    details and cause vulnerabilities:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了某些日志消息的示例，这些消息暴露了敏感细节并导致漏洞：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What’s wrong with the logs presented here? The first two log messages expose
    private details. You should never log passwords or private keys that are used
    to sign tokens, or any other exchanged information. A password is something only
    its owner should know. For this reason, no app should store any passwords in clear
    text (whether in a log or a database). Private keys and similar secret details
    should be stored in a secrets vault to protect them from being stolen. If someone
    gets the value of such a key, they can impersonate an application or a user.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的日志有什么问题？前两个日志消息暴露了私人细节。你不应该记录用于签名令牌的密码或私人密钥，或任何其他交换的信息。密码是只有其所有者应该知道的东西。因此，没有任何应用程序应该以明文形式存储任何密码（无论是在日志中还是在数据库中）。私人密钥和类似的秘密细节应该存储在秘密库中，以防止被盗。如果有人获得了此类密钥的值，他们可以冒充应用程序或用户。
- en: The third log message example exposes a phone number. A phone number is considered
    a personal detail, and around the world, specific regulations restrict the use
    of such details. For example, the European Union implemented the General Data
    Protection Regulation (GDPR) in May 2018\. An application with users in any European
    Union state must comply with these regulations to avoid severe sanctions. The
    regulations allow any user to request all their personal data an app uses and
    to request immediate deletion of the data. Storing information such as phone numbers
    in logs exposes these private details and makes retrieving and deleting them more
    difficult.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个日志消息示例暴露了一个电话号码。电话号码被视为个人细节，并且在全球范围内，特定的法规限制了此类细节的使用。例如，欧盟在2018年5月实施了通用数据保护条例（GDPR）。任何欧盟国家的应用程序都必须遵守这些规定，以避免严重的处罚。这些规定允许任何用户请求应用程序使用的所有个人数据，并要求立即删除这些数据。在日志中存储如电话号码之类的信息会暴露这些私人细节，并使检索和删除它们变得更加困难。
- en: Performance issues
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题
- en: Writing logs entails sending details (usually as strings) through an I/O stream
    somewhere outside the app. We can simply send this information to the app’s console
    (terminal), or we can store it in files or even a database, as we discussed in
    section 5.2.1\. Either way, you need to remember that logging a message is also
    an instruction that takes time; adding too many log messages can dramatically
    decrease an app’s performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编写日志意味着将细节（通常作为字符串）发送到应用程序外部的I/O流中。我们可以简单地将此信息发送到应用程序的控制台（终端），或者我们可以将其存储在文件中，甚至是一个数据库，正如我们在5.2.1节中讨论的那样。无论如何，你需要记住，记录消息也是一个耗时指令；添加过多的日志消息会显著降低应用程序的性能。
- en: I remember an issue my team investigated some years ago. A customer in Asia
    reported a problem with the application we were implementing in factories for
    inventory purposes. The problem wasn’t causing much trouble, but we found it challenging
    to get to the root cause, so we decided to add more log messages. After delivering
    a patch with the small change, the system became very slow, almost unresponsive
    sometimes, which ultimately caused a production standstill, and we had to quickly
    revert our change. We somehow managed to change a mosquito into an elephant.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得几年前我的团队调查了一个问题。亚洲的一个客户报告了我们为工厂库存目的实施的应用程序的问题。这个问题并没有造成太多麻烦，但我们发现很难找到根本原因，所以我们决定添加更多的日志信息。在交付包含微小更改的补丁后，系统变得非常慢，有时几乎无法响应，这最终导致了生产停滞，我们不得不迅速撤销我们的更改。我们
    somehow managed to change a mosquito into an elephant。
- en: '![](../../OEBPS/Images/CH05_UN03_Spilca3.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_UN03_Spilca3.png)'
- en: But how could some simple log messages cause such big trouble? The logs were
    configured to send the messages to a separate server in the network, where they
    persisted. Not only was the network extremely slow in that factory, but also the
    log message added to a loop that was iterating over a significant number of items,
    making the app extremely slow.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但一些简单的日志信息是如何造成如此大的麻烦的呢？这些日志被配置为将消息发送到网络中的另一个独立服务器，并且它们在那里持续存在。在那个工厂，网络极其缓慢，而且日志信息被添加到一个迭代大量项目的循环中，这使得应用程序变得极其缓慢。
- en: 'In the end, we learned some things that helped us be more careful and avoid
    repeating the same mistake:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学到了一些有助于我们更加小心并避免重复同样错误的事情：
- en: Make sure you understand how the app logs the messages. Remember that even for
    the same app different deployments can have different configurations (see section
    5.2.2).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你理解应用程序如何记录消息。记住，即使是同一个应用程序，不同的部署也可能有不同的配置（参见5.2.2节）。
- en: Avoid logging too many messages. Don’t log messages in loops iterating over
    a large number of elements. Logging too many messages will also make reading the
    logs complicated. If you need to log messages in a large loop, use a condition
    to narrow the number of iterations for which the message is logged.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免记录过多的信息。不要在迭代大量元素的循环中记录日志信息。记录过多的信息也会使阅读日志变得复杂。如果你需要在大型循环中记录日志信息，使用条件来缩小记录消息的迭代次数。
- en: Make sure that the app stores a given log message only when that’s really needed.
    You limit the number of log messages you store by using logging levels, as we
    discussed in section 5.2.2.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序仅在真正需要时存储给定的日志信息。你可以通过使用我们在5.2.2节中讨论的日志级别来限制你存储的日志信息数量。
- en: Implement the logging mechanism in such a way that you enable and disable it
    without needing to restart the service. This will allow you to change to a finer-grained
    logging level, get your needed details, and then make your logging less sensitive
    again.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种方式实现日志记录机制，使得你可以在不重启服务的情况下启用和禁用它。这将允许你切换到更细粒度的日志级别，获取所需详细信息，然后再使日志不那么敏感。
- en: Maintainability
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性
- en: 'Log messages can also negatively affect an app’s maintainability. If you add
    log messages too frequently, they can make the app’s logic more difficult to understand.
    Let’s look at an example: try reading listings 5.7 and 5.8\. Which code is easier
    to understand?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 日志信息也可能对应用程序的可维护性产生负面影响。如果你太频繁地添加日志信息，它们可能会使应用程序的逻辑更难以理解。让我们看看一个例子：尝试阅读列表5.7和5.8。哪段代码更容易理解？
- en: Listing 5.7 A method implementing a simple piece of logic
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 实现简单逻辑的方法
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing 5.8 A method implementing a simple piece of logic crowded with log messages
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 实现简单逻辑的方法，其中包含大量日志信息
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both show the same piece of implemented logic. But in listing 5.8, I added numerous
    log messages, which make the method’s logic more challenging to read.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都展示了相同的实现逻辑。但在列表5.8中，我添加了大量的日志信息，这使得方法的逻辑更难以阅读。
- en: How do we avoid affecting an app’s maintainability?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免影响应用程序的可维护性？
- en: You don’t necessarily need to add a log message for each instruction in the
    code. Identify those instructions that provide the most relevant details. Remember,
    you can add extra logging later if the existing log messages are not enough.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不一定需要在代码中的每条指令后都添加日志信息。识别那些提供最相关细节的指令。记住，如果现有的日志信息不够，你可以稍后添加额外的日志。
- en: Keep the methods small enough so that you only need to log the parameters’ values
    and the value the method returned after the execution.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保方法足够小，以至于你只需要记录参数的值和执行后方法返回的值。
- en: Some frameworks allow you to decouple part of the code from the method. For
    example, in Spring, you can use custom aspects to log the result of a method’s
    execution (including the parameters’ values and the value the method returned
    after the execution).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些框架允许你将部分代码与方法解耦。例如，在Spring中，你可以使用自定义方面来记录方法执行的输出（包括参数值和方法执行后的返回值）。
- en: 5.3 Logs vs. remote debugging
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 日志与远程调试比较
- en: In chapter 4, we discussed remote debugging, and you learned that you can connect
    the debugger to an app executing in an external environment. I start this discussion
    because my students often ask me why we need to use logs since we can connect
    and directly debug a given issue. But as I mentioned earlier in this chapter,
    and in previous ones, these debugging techniques don’t exclude one another. Sometimes
    one is better than the other; in other cases, you need to use them together.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们讨论了远程调试，你了解到你可以将调试器连接到在外部环境中运行的应用。我开始这个讨论是因为我的学生经常问我为什么我们需要使用日志，因为我们可以直接连接并调试特定的问题。但正如我在本章前面以及之前章节中提到的，这些调试技术并不相互排斥。有时一个比另一个更好；在其他情况下，你需要将它们一起使用。
- en: Let’s analyze what we can and can’t do with logs versus remote debugging to
    figure out how you can efficiently use these two techniques. Table 5.1 shows a
    side-by-side comparison of logs and remote debugging.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下与远程调试相比，我们可以做什么以及不能做什么，以了解如何高效地使用这两种技术。表5.1展示了日志和远程调试的并列比较。
- en: Table 5.1 Logs vs. remote debugging
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 日志与远程调试比较
- en: '| Capability | Logs | Remote debugging |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 日志 | 远程调试 |'
- en: '| Can be used to understand a remotely executing app’s behavior | ![](../../OEBPS/Images/green.png)
    | ![](../../OEBPS/Images/green.png) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 可以用来理解远程执行应用的行为 | ![](../../OEBPS/Images/green.png) | ![](../../OEBPS/Images/green.png)
    |'
- en: '| Needs special network permissions or configurations | ![](../../OEBPS/Images/red.png)
    | ![](../../OEBPS/Images/green.png) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 需要特殊的网络权限或配置 | ![](../../OEBPS/Images/red.png) | ![](../../OEBPS/Images/green.png)
    |'
- en: '| Persistently stores execution clues | ![](../../OEBPS/Images/green.png) |
    ![](../../OEBPS/Images/red.png) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 持久存储执行线索 | ![](../../OEBPS/Images/green.png) | ![](../../OEBPS/Images/red.png)
    |'
- en: '| Allows you to pause the execution on a given line of code to understand what
    the app does | ![](../../OEBPS/Images/red.png) | ![](../../OEBPS/Images/green.png)
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 允许你在代码的指定行暂停执行以理解应用的行为 | ![](../../OEBPS/Images/red.png) | ![](../../OEBPS/Images/green.png)
    |'
- en: '| Can be used to understand an app’s behavior without interfering with the
    executed logic | ![](../../OEBPS/Images/yellow.png) | ![](../../OEBPS/Images/red.png)
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 可以用来理解应用的行为而不干扰执行逻辑 | ![](../../OEBPS/Images/yellow.png) | ![](../../OEBPS/Images/red.png)
    |'
- en: '| Is recommended for production environments | ![](../../OEBPS/Images/green.png)
    | ![](../../OEBPS/Images/red.png) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 建议用于生产环境 | ![](../../OEBPS/Images/green.png) | ![](../../OEBPS/Images/red.png)
    |'
- en: You can use both logs and remote debugging to understand the behavior of a remotely
    executing app. But both approaches have their own difficulties. Logging implies
    that the app writes the events and the data needed for the investigation. If that’s
    not the case, you need to add those instructions and redeploy the app. This is
    what developers usually call “adding extra logs.” Remote debugging allows your
    debugger to connect to the remotely executing app, but specific network configurations
    and permissions need to be granted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用日志和远程调试来理解远程执行应用的行为。但两种方法都有自己的困难。日志意味着应用会记录调查所需的事件和数据。如果不是这种情况，你需要添加这些指令并重新部署应用。这就是开发者通常所说的“添加额外的日志”。远程调试允许你的调试器连接到远程执行的应用，但需要授予特定的网络配置和权限。
- en: A big difference is the philosophy each technique implies. Debugging is focused
    on the present. You pause the execution and observe the app’s current state. Logging
    is more about the past. You get a bunch of log messages and analyze the execution,
    focusing on a timeline. It’s common to use debugging and logging simultaneously
    to understand more complex issues, and I can tell you from experience that sometimes
    using logs versus debugging depends on the developer’s preference. I sometimes
    see developers using a technique simply because they are more comfortable with
    one than another.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很大的区别是每种技术所体现的哲学。调试关注的是现在。你暂停执行并观察应用当前的状态。日志更多地关于过去。你得到一堆日志消息并分析执行情况，关注时间线。同时使用调试和日志来理解更复杂的问题是很常见的，我可以从经验中告诉你，有时使用日志与调试取决于开发者的偏好。我有时看到开发者使用一种技术仅仅是因为他们比另一种更舒服。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Always check the app’s logs when you start investigating any issue. The logs
    may indicate what’s wrong or at least give you a starting point for your investigation.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始调查任何问题时，始终检查应用程序的日志。日志可能会指示出了什么问题，或者至少为您的研究提供一个起点。
- en: All log messages should include a timestamp. Remember that in most cases a system
    doesn’t guarantee the order in which the logs are stored. The timestamp will help
    you to order the log messages chronologically.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有日志消息都应该包含时间戳。记住，在大多数情况下，系统不保证日志存储的顺序。时间戳将帮助您按时间顺序排列日志消息。
- en: Avoid saving too many log messages. Not every detail is relevant or helpful
    in investigating a potential issue, and storing too many log messages can affect
    the app’s performance and make the code more difficult to read.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免保存过多的日志消息。并非每个细节都与调查潜在问题相关或有帮助，并且保存过多的日志消息可能会影响应用程序的性能并使代码更难以阅读。
- en: You should implement more logging only if needed. A running app should only
    log essential messages. If you require more details, you can always enable more
    logging for a short time.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在需要时才应实现更多日志记录。运行中的应用程序应仅记录必要的信息。如果您需要更多详细信息，您始终可以暂时启用更多日志记录。
- en: An exception in the logs is not necessarily the root of the problem. It could
    be a consequence of a problem. Research what caused the exception before treating
    it locally.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志中的异常不一定是问题的根源。它可能是问题的后果。在本地处理之前，研究导致异常的原因。
- en: You can use exception stack traces to figure out what called a given method.
    In large, messy, and difficult-to-understand codebases, this approach can be very
    helpful and save you time.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用异常堆栈跟踪来确定调用了哪个给定方法。在大型、混乱且难以理解的代码库中，这种方法可能非常有帮助并节省您的时间。
- en: Never write sensitive details (e.g., passwords, private keys, or personal details)
    in a log message. Logging passwords or private keys introduces security vulnerabilities
    since anyone with access to the logs can see and use them. Writing personal details
    such as names, addresses, or phone numbers also may not comply with various government
    regulations.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在日志消息中写入敏感细节（例如，密码、私钥或个人信息）。在日志中记录密码或私钥会引入安全漏洞，因为任何可以访问日志的人都可以看到并使用它们。写入诸如姓名、地址或电话号码等个人信息也可能不符合各种政府法规。
