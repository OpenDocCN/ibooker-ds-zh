- en: 6 Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Identifying which type of tests to write for infrastructure systems
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定为基础设施系统编写哪种类型的测试
- en: Writing tests to verify infrastructure configuration or modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试以验证基础设施配置或模块
- en: Understanding the cost of various types of tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种类型测试的成本
- en: Recall from chapter 1 that infrastructure as code involves an entire process
    to push a change to a system. You update scripts or configurations with infrastructure
    changes, push them to a version control system, and apply the changes in an automated
    way. However, you can use every module and dependency pattern from chapters 3
    and 4 and still have failed changes! How do you catch a failed change before you
    apply it to production?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 1 章回忆起，基础设施即代码涉及将更改推送到系统的一个完整过程。您通过更新脚本或配置来应用基础设施更改，将它们推送到版本控制系统，并以自动化的方式应用更改。然而，您可以使用第
    3 章和第 4 章中的每个模块和依赖模式，但仍可能遇到失败的更改！如何在将更改应用到生产之前捕捉到失败的更改？
- en: You can solve this problem by implementing tests for IaC. *Testing* is a process
    that evaluates whether a system works as expected. This chapter reviews some considerations
    and concepts related to testing IaC to reduce the rate of change failure and build
    confidence in infrastructure changes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实现 IaC 的测试来解决此问题。*测试*是一个评估系统是否按预期工作的过程。本章回顾了与测试 IaC 相关的一些考虑因素和概念，以降低变更失败率并增强对基础设施变更的信心。
- en: Definition *Testing* IaC is a process that evaluates whether infrastructure
    works as expected.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*测试*IaC是一个评估基础设施是否按预期工作的过程。
- en: Imagine you configure a network switch with a new network segment. You can manually
    test existing networks by pinging each server on each network and verifying their
    connectivity. To test that you set up the new network correctly, you create a
    new server and check whether it responds when you connect to it. This manual test
    takes a few hours for two or three networks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象您使用新的网络段配置了一个网络交换机。您可以通过对每个网络上的每台服务器进行ping测试并验证其连通性来手动测试现有网络。为了测试您是否正确设置了新网络，您创建了一个新的服务器并检查当您连接到它时它是否响应。这种手动测试对于两个或三个网络可能需要几个小时。
- en: As you create more networks, you can take days to verify your network connectivity.
    For every network segment update, you must manually verify the network connectivity
    and the servers, queues, databases, and other resources running on the network.
    You *cannot* test everything, so you check only a few resources. Unfortunately,
    this approach can leave hidden bugs or issues that appear only weeks, even months,
    later!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您创建更多的网络，您可能需要几天时间来验证您的网络连通性。对于每个网络段更新，您必须手动验证网络的连通性以及运行在网络上服务器、队列、数据库和其他资源。您*不能*测试一切，所以您只检查几个资源。不幸的是，这种方法可能会留下隐藏的虫子或问题，这些问题可能只会在几周甚至几个月后出现！
- en: To reduce the burden of manual testing, you can instead *automate* your tests
    by scripting each command. Your script creates a server on the new network, checks
    its connectivity, and tests connections to existing networks. You invest some
    time and effort into writing the tests but save hours of manual verification by
    running an automated script for any subsequent changes to the network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻手动测试的负担，您可以通过编写脚本来自动化测试，每个命令都编写一个脚本。您的脚本在新的网络上创建一个服务器，检查其连通性，并测试与现有网络的连接。您投入一些时间和精力来编写测试，但通过运行自动化脚本来对网络的任何后续更改进行验证，可以节省数小时的手动验证时间。
- en: '![](../../OEBPS/Images/CH06_F01_Wang.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Wang.png)'
- en: Figure 6.1 Manual testing may require lower effort initially, but as the number
    of infrastructure resources in your system increases, that effort increases. Automated
    testing takes a high initial effort that decreases as you grow your system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 手动测试可能最初需要较低的努力，但随着您系统中基础设施资源的增加，这种努力也会增加。自动化测试需要较高的初始努力，但随着您系统的扩展，这种努力会减少。
- en: Figure 6.1 shows the amount of effort in hours compared to the number of infrastructure
    resources when you do manual and automated testing. When you run the network tests
    manually, you have to spend a lot of time on testing. The effort increases the
    more resources you add to your system. By comparison, writing automated tests
    takes an initial effort. However, the effort to maintain the test generally decreases
    as your system grows. You can even run automated tests in parallel to reduce the
    overall testing effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1显示了手动和自动测试时，每小时所需的工作量与基础设施资源数量的对比。当你手动运行网络测试时，你必须在测试上花费大量时间。随着你向系统中添加更多资源，工作量也会增加。相比之下，编写自动化测试需要初始的努力。然而，随着系统的增长，维护测试所需的工作量通常会减少。你甚至可以并行运行自动化测试以减少总体测试工作量。
- en: Of course, testing doesn’t catch every problem or eliminate all failures from
    your system. However, automated testing serves as documentation for what you should
    test in your system every time you make a change. If a hidden bug chooses to appear,
    you spend some effort writing a new test to verify the bug doesn’t happen again!
    Tests lower the overall operational effort over time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试并不能捕捉到每个问题或消除系统中的所有故障。然而，自动化测试作为每次你进行变更时你应该在系统中测试什么的文档。如果一个隐藏的bug选择出现，你需要花费一些努力编写一个新的测试来验证bug不会再次发生！随着时间的推移，测试可以降低总体运营工作量。
- en: You can use testing frameworks for your infrastructure provider or tool or native
    testing libraries in programming languages. The code listings use a Python testing
    framework called `pytest` and Apache Libcloud, a Python library to connect to
    GCP. I wrote the tests to focus on *what the test verifies* and not the syntax.
    You can apply the general approach to any tool or framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用基础设施提供商或工具的测试框架，或者使用编程语言中的原生测试库。代码示例使用了一个名为`pytest`的Python测试框架和Apache Libcloud，这是一个连接到GCP的Python库。我编写的测试侧重于*测试验证的内容*而不是语法。你可以将这种方法应用于任何工具或框架。
- en: For more on pytest and Apache Libcloud
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于pytest和Apache Libcloud的信息
- en: To run the tests, refer to the code repository at [https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book)
    for instructions, examples, and dependencies. It includes links and references
    for getting started with pytest and Libcloud.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请参考[https://github.com/joatmon08/manning-book](https://github.com/joatmon08/manning-book)中的说明、示例和依赖项。它包括有关如何开始使用pytest和Libcloud的链接和参考。
- en: '*Do not* write tests for every single bit of IaC in your system. Tests can
    become difficult to maintain and, on occasion, redundant. Instead, I’ll explain
    how to assess when to write a test and which type of test applies to the resource
    you’re changing. Infrastructure testing is a heuristic; you’re never going to
    be able to predict or simulate a change to production fully. A helpful test provides
    insight and practice into configuring infrastructure or how a change will impact
    a system. I’ll also separate which tests apply to modules such as factories, prototypes,
    or builders versus general composite or singleton *configuration* for a live environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要*为系统中每一块IaC编写测试。测试可能变得难以维护，有时甚至可能是冗余的。相反，我将解释如何评估何时编写测试以及适用于你正在更改的资源类型的测试类型。基础设施测试是一种启发式方法；你永远无法完全预测或模拟生产中的变更。一个有用的测试可以提供配置基础设施或变更如何影响系统的见解和实践。我还会区分哪些测试适用于如工厂、原型或构建器等模块，以及针对实时环境的通用复合或单例*配置*。'
- en: 6.1 The infrastructure testing cycle
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 基础设施测试周期
- en: Testing helps you gain confidence and assess the impact of changes to infrastructure
    systems. However, how can you test a system without creating it first? Furthermore,
    how do you know that your system works after applying changes?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以帮助你建立信心并评估对基础设施系统变更的影响。然而，在没有首先创建系统的情况下，你如何测试一个系统呢？此外，你如何知道在应用变更后系统是否正常工作？
- en: You can use the infrastructure testing cycle in figure 6.2 to structure your
    testing workflow. After you define an infrastructure configuration, you run initial
    tests to check your configuration. If they pass, you can apply the changes to
    active infrastructure and test the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用图6.2中的基础设施测试周期来构建你的测试工作流程。在你定义基础设施配置后，运行初始测试以检查你的配置。如果测试通过，你可以将变更应用到活动基础设施并测试系统。
- en: In this workflow, you run two types of tests. One kind statically analyzes the
    configuration before you deploy the infrastructure changes, and the other dynamically
    analyzes the infrastructure resource to make sure it still works. Most of your
    tests follow this pattern by running before and after change deployment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流程中，您运行两种类型的测试。一种是在您部署基础设施更改之前对配置进行静态分析，另一种是对基础设施资源进行动态分析，以确保它仍然正常工作。大多数测试都遵循在更改部署前后运行的这种模式。
- en: '![](../../OEBPS/Images/CH06_F02_Wang.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F02_Wang.png)'
- en: Figure 6.2 Infrastructure testing indicates whether you can apply changes to
    a system. After applying changes, you can use additional tests to confirm that
    the changes succeeded.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 基础设施测试表明您是否可以应用更改到系统中。在应用更改后，您可以使用额外的测试来确认更改是否成功。
- en: 6.1.1 Static analysis
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 静态分析
- en: How would you apply the infrastructure testing cycle to our network example?
    Imagine you parse your network script to verify that the new network segment has
    the correct IP address range. You don’t need to deploy the changes to the network.
    Instead, you analyze the script, a static file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您会如何将基础设施测试周期应用到我们的网络示例中？想象一下，您解析网络脚本以验证新的网络段是否具有正确的IP地址范围。您不需要将更改部署到网络中。相反，您分析脚本，这是一个静态文件。
- en: In figure 6.3, you define the network script and run static analysis. If you
    find the wrong IP address, the tests fail. You can revert or fix your network
    changes and rerun the tests. If they pass, you can apply the correct network IP
    address to the active network.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在图6.3中，您定义网络脚本并运行静态分析。如果您发现错误的IP地址，测试将失败。您可以回滚或修复您的网络更改并重新运行测试。如果它们通过，您可以将正确的网络IP地址应用到活动网络中。
- en: '![](../../OEBPS/Images/CH06_F03_Wang.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F03_Wang.png)'
- en: Figure 6.3 You can either fix the configuration to pass the tests or revert
    to a previously successful configuration when static analysis fails.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 您可以选择固定配置以通过测试，或者在静态分析失败时恢复到之前成功的配置。
- en: Tests that evaluate infrastructure configuration before deploying changes to
    infrastructure resources perform *static analysis*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在将更改部署到基础设施资源之前评估基础设施配置的测试执行*静态分析*。
- en: Definition *Static analysis* for IaC verifies plaintext infrastructure configuration
    before deploying changes to live infrastructure resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IaC的*静态分析*定义，在将更改部署到实际基础设施资源之前，验证明文基础设施配置。
- en: Tests for static analysis do not require infrastructure resources since they
    usually parse the configuration. They do not run the risk of impacting any active
    systems. If static analysis tests pass, we have more confidence that we can apply
    the change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的测试不需要基础设施资源，因为它们通常解析配置。它们不会对任何活动系统造成影响的风险。如果静态分析测试通过，我们更有信心可以应用更改。
- en: I often use static analysis tests to check for infrastructure naming standards
    and dependencies. They run before applying changes, and in a matter of seconds,
    they identify any inconsistent naming or configuration concerns. I can correct
    the changes, rerun the tests to pass, and apply the changes to infrastructure
    resources. Refer to chapter 2 for clean IaC, linting, and formatting rules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用静态分析测试来检查基础设施命名标准和依赖关系。它们在应用更改之前运行，并在几秒钟内识别任何不一致的命名或配置问题。我可以纠正更改，重新运行测试以通过，并将更改应用到基础设施资源中。请参阅第2章以获取干净的IaC、linting和格式化规则。
- en: Tests for static analysis do not apply changes to active infrastructure, making
    rollback more straightforward. If tests for static analysis fail, you can return
    to the infrastructure configuration, correct the problems, and commit the changes
    again. If you cannot fix the configuration to pass static analysis, you can revert
    your commit to a previous one that succeeds! You’ll learn more about reverting
    changes in chapter 11.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析的测试不会对活动基础设施进行更改，这使得回滚更加直接。如果静态分析的测试失败，您可以返回到基础设施配置，纠正问题，并再次提交更改。如果您无法修复配置以通过静态分析，您可以回滚您的提交到一个成功的版本！您将在第11章中了解更多关于回滚更改的内容。
- en: 6.1.2 Dynamic analysis
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 动态分析
- en: If the static analysis passes, you can deploy changes to the network. However,
    you don’t know whether the network segment actually works. After all, a server
    needs to connect to the network. To test connectivity, you create a server on
    the network and run a test script to check inbound and outbound connectivity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态分析通过，您可以部署更改到网络。然而，您不知道网络段是否实际上工作。毕竟，服务器需要连接到网络。为了测试连通性，您在网络中创建一个服务器并运行测试脚本以检查入站和出站连通性。
- en: Figure 6.4 shows the cycle of testing network functionality. Once you apply
    changes to the live infrastructure environment, you run tests to check the functionality
    of the system. If the test script fails and shows the server cannot connect, you
    return to the configuration and fix it for the system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4显示了测试网络功能性的周期。一旦你将更改应用到活动基础设施环境，你就运行测试来检查系统的功能。如果测试脚本失败并显示服务器无法连接，你将返回到配置并修复它以供系统使用。
- en: Note that your testing script needs a live network to create a server and test
    its connectivity. The tests that verify infrastructure functionality after applying
    changes to live infrastructure resources perform *dynamic analysis*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的测试脚本需要一个活动网络来创建服务器并测试其连接性。在将更改应用到活动基础设施资源后验证基础设施功能性的测试执行*动态分析*。
- en: '![](../../OEBPS/Images/CH06_F04_Wang.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F04_Wang.png)'
- en: Figure 6.4 When dynamic analysis fails, you can fix the testing environment
    by updating the configuration or reverting to a previously working configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 当动态分析失败时，你可以通过更新配置或回滚到之前可工作的配置来修复测试环境。
- en: Definition *Dynamic analysis* for IaC verifies system functionality after applying
    changes to live infrastructure resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 对于IaC的*动态分析*验证在将更改应用到活动基础设施资源后系统功能。
- en: When these tests pass, we have more confidence that the update succeeded. However,
    if they fail, they identify a problem in the system. If the tests fail, you know
    that you need to debug, fix the configuration or scripts, and rerun the tests.
    They provide an early warning system for changes that might break infrastructure
    resources and system functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些测试通过时，我们更有信心更新成功。然而，如果它们失败，它们会识别系统中的问题。如果测试失败，你知道你需要调试，修复配置或脚本，并重新运行测试。它们为可能破坏基础设施资源和系统功能的变化提供了一个早期预警系统。
- en: You can only dynamically analyze a live environment. What if you don’t know
    whether the update will work? Can you isolate these tests from a production environment?
    Rather than apply all changes to a production environment and test it, you can
    use an intermediate testing environment to separate your updates and test them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能动态分析一个活动环境。如果你不知道更新是否可行怎么办？你能将这些测试从生产环境中隔离出来吗？与其将所有更改应用到生产环境并测试它，你可以在中间测试环境中分离你的更新并测试它们。
- en: 6.1.3 Infrastructure testing environments
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 基础设施测试环境
- en: Some organizations duplicate entire networks in a separate environment so they
    can test larger network changes. Applying changes to a testing environment makes
    it easier to identify and fix the broken system, update configuration, and commit
    the new changes without affecting business-critical systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织在单独的环境中复制整个网络，以便他们可以测试更大的网络更改。将更改应用到测试环境中可以更容易地识别和修复损坏的系统，更新配置，并提交新更改，而不会影响业务关键系统。
- en: When you run your tests in a separate environment before promoting to the active
    one, you add to the infrastructure testing cycle. In figure 6.5, you keep the
    static analysis step. However, you apply your network change in a testing environment
    and run dynamic analysis. If it passes the testing environment, you can apply
    the changes to production and run dynamic analysis in production.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在提升到活动环境之前在单独的环境中运行测试时，你增加了基础设施测试周期。在图6.5中，你保留了静态分析步骤。然而，你在测试环境中应用网络更改并运行动态分析。如果它通过了测试环境，你就可以将更改应用到生产，并在生产中运行动态分析。
- en: A *testing environment* isolates changes and tests from the production environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*测试环境*将更改和测试与生产环境隔离开。
- en: Definition A *testing environment* is separate from production and used for
    testing infrastructure changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*测试环境*与生产环境分离，用于测试基础设施更改。
- en: '![](../../OEBPS/Images/CH06_F05_Wang.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F05_Wang.png)'
- en: Figure 6.5 You can run a static and dynamic analysis of infrastructure in a
    testing environment before applying the changes to production.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 在将更改应用到生产之前，你可以在测试环境中运行基础设施的静态和动态分析。
- en: 'A testing environment before production helps you *practice* and *check* changes
    before deploying to production. You better understand how they affect existing
    systems. If you cannot fix the updates, you can revert the testing environment
    to a working configuration version. You can use testing environments for the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产之前设置一个测试环境可以帮助你在部署到生产环境之前*练习*和*检查*更改。这样你就能更好地理解它们如何影响现有系统。如果你无法修复更新，你可以将测试环境回滚到一个可工作的配置版本。你可以使用测试环境进行以下操作：
- en: Examining the effect of an infrastructure change before applying it to a production
    system
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将基础设施更改应用于生产系统之前检查其影响
- en: Isolating testing for infrastructure modules (refer to chapter 5 for module-sharing
    practices)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离基础设施模块的测试（有关模块共享实践，请参阅第5章）
- en: 'However, keep in mind that you have to maintain testing environments like production
    environments. When possible, an infrastructure testing environment should adhere
    to the following requirements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，你必须像维护生产环境一样维护测试环境。当可能时，基础设施测试环境应遵守以下要求：
- en: Its configuration must be as similar to production as possible.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的配置必须尽可能接近生产环境。
- en: It must be a different environment from the application’s development environment.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须与应用程序的开发环境不同。
- en: It must be persistent (i.e., do not create and destroy it each time you test).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是持久的（即，每次测试时不要创建和销毁它）。
- en: In previous chapters, I mentioned the importance of reducing drift across environments.
    If your infrastructure testing environment duplicates production, you will have
    more accurate testing behavior. You also want to test infrastructure changes in
    isolation, away from a development environment dedicated to applications. Once
    you’ve confirmed that your infrastructure changes have not broken anything, you
    can push them to the application’s development environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我提到了减少环境漂移的重要性。如果你的基础设施测试环境与生产环境相同，你将获得更准确的测试行为。你还希望将基础设施更改的测试与专门用于应用程序的开发环境隔离。一旦你确认你的基础设施更改没有破坏任何东西，你就可以将它们推送到应用程序的开发环境。
- en: It helps to have a persistent infrastructure testing environment. This way,
    you can test whether updates to running infrastructure will potentially affect
    business-critical systems. Unfortunately, maintaining an infrastructure testing
    environment may not be practical from a cost or resources standpoint. I outline
    some techniques for cost management of testing environments in chapter 12.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个持久的测试基础设施环境很有帮助。这样，你可以测试运行中的基础设施更新是否可能影响业务关键系统。不幸的是，从成本或资源角度来看，维护一个基础设施测试环境可能并不实际。我在第12章概述了一些测试环境成本管理的技巧。
- en: In the remainder of this chapter, I’ll discuss the different types of tests
    that perform static and dynamic analysis and how they fit into your testing environment.
    Some tests will allow you to reduce your dependency on a testing environment.
    Others will be critical to assessing the functionality of a production system
    after changes. In chapter 11, I cover rollback techniques specific to production
    and incorporate testing into continuous infrastructure delivery.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将讨论执行静态和动态分析的不同类型的测试以及它们如何适应你的测试环境。一些测试将允许你减少对测试环境的依赖。其他测试对于评估更改后的生产系统功能至关重要。在第11章中，我涵盖了特定于生产的回滚技术，并将测试纳入持续基础设施交付。
- en: 6.2 Unit tests
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 单元测试
- en: I mentioned the importance of running static analysis on IaC. Static analysis
    evaluates the files for specific configurations. What kinds of tests can you write
    for static analysis?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了在基础设施即代码（IaC）上运行静态分析的重要性。静态分析评估文件的具体配置。你可以为静态分析编写哪些类型的测试？
- en: Imagine you have a factory module to create a network named `hello-world-network`
    and three subnets with IP address ranges on 10.0.0.0/16\. You want to verify their
    network names and IP ranges. You *expect* the subnets to divide the 10.0.0.0/16
    range among themselves.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个工厂模块来创建一个名为`hello-world-network`的网络和三个具有10.0.0.0/16 IP地址范围的子网。你想要验证它们的网络名称和IP地址范围。你*期望*子网将10.0.0.0/16范围分配给自己。
- en: As a solution, you can write tests to check the network name and subnet IP address
    ranges in your IaC without creating the network and subnet. This static analysis
    verifies the configuration parameters for expected values in a matter of seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决方案，你可以在不创建网络和子网的情况下编写测试来检查网络名称和子网IP地址范围。这种静态分析可以在几秒钟内验证配置参数的预期值。
- en: Figure 6.6 shows that your static analysis consists of several tests run simultaneously.
    You check the network name, number of subnets, and IP ranges for subnets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6显示，你的静态分析包括同时运行的几个测试。你检查网络名称、子网数量和子网的IP地址范围。
- en: '![](../../OEBPS/Images/CH06_F06_Wang.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F06_Wang.png)'
- en: Figure 6.6 Unit tests verify that a configuration parameter, such as network
    name, equals an expected value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 单元测试验证配置参数，例如网络名称，是否等于预期值。
- en: We just ran unit tests on the network IaC. A *unit test* runs in isolation and
    statically analyzes infrastructure configuration or state. These tests do not
    rely on active infrastructure resources or dependencies and check for the smallest
    subset of configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚对网络 IaC 运行了单元测试。*单元测试* 在隔离环境中运行，并静态分析基础设施配置或状态。这些测试不依赖于活动的基础设施资源或依赖，并检查配置的最小子集。
- en: Definition *Unit tests* statically analyze plaintext infrastructure configuration
    or state. They do not rely on live infrastructure resources or dependencies.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *单元测试* 静态分析纯文本基础设施配置或状态。它们不依赖于实时基础设施资源或依赖。
- en: Note that unit tests can analyze metadata in infrastructure configuration *or*
    state files. Some tools offer information directly in configuration, while others
    expose values through state. The next few sections provide examples to test both
    types of files. Depending on your IaC tool, testing framework, and preference,
    you may test one, the other, or both.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，单元测试可以分析基础设施配置或状态文件中的元数据。一些工具直接在配置中提供信息，而其他工具则通过状态暴露值。接下来的几节将提供测试这两种类型文件的示例。根据你的
    IaC 工具、测试框架和偏好，你可能测试其中一种、两种或全部。
- en: 6.2.1 Testing infrastructure configuration
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 测试基础设施配置
- en: We’ll start by writing unit tests for modules that use templates to generate
    infrastructure configuration. Our network factory module uses a function to create
    an object with the network configuration. You need to know whether the function
    `_network_ configuration` generates the correct configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写使用模板生成基础设施配置的模块的单元测试。我们的网络工厂模块使用一个函数来创建具有网络配置的对象。你需要知道函数 `_network_configuration`
    是否生成正确的配置。
- en: For the network factory module, you can write unit tests in pytest to check
    the functions that generate the JSON configuration for networks and subnets. The
    testing file includes three tests, one for the network name, the number of subnets,
    and IP ranges.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络工厂模块，你可以使用 pytest 编写单元测试来检查生成网络和子网 JSON 配置的函数。测试文件包括三个测试，一个用于网络名称，一个用于子网数量，一个用于
    IP 范围。
- en: Pytest will identify tests by looking for files and tests prefixed by test_.
    In listing 6.1, we named the testing file test_network.py so pytest can find it.
    The tests in the file each have the prefix test_ and descriptive information on
    what the test checks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 通过寻找以 test_ 前缀的文件和测试来识别测试。在列表 6.1 中，我们命名了测试文件为 test_network.py，这样 pytest
    就能找到它。文件中的每个测试都有 test_ 前缀以及描述测试检查内容的说明信息。
- en: Listing 6.1 Using pytest to run unit tests in test_network.py
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 使用 pytest 在 test_network.py 中运行单元测试
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Imports pytest, a Python testing library. You need to name the file and tests
    prefixed with test_ for pytest to run them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 pytest，一个 Python 测试库。你需要命名文件和以 test_ 前缀的测试，以便 pytest 能够运行它们。
- en: ❷ Imports the network factory module from main.py. You need to run the method
    for network configuration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 main.py 中导入网络工厂模块。你需要运行网络配置的方法。
- en: ❸ Sets expected values as constants, such as network prefix and IP range
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将预期值设置为常量，例如网络前缀和 IP 范围
- en: ❹ Creates the network from the module as a test fixture based on expected values.
    This fixture offers a consistent network object for all tests to reference.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 根据预期值从模块中创建网络作为测试固定装置。此装置为所有测试提供了一个一致的网络对象以供引用。
- en: ❺ Creates a separate fixture for the network configuration since you need to
    parse google_compute_network. One test uses this fixture to test the network name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 由于需要解析 google_compute_network，因此为网络配置创建了一个单独的固定装置。一个测试使用此装置来测试网络名称。
- en: ❻ Creates a separate fixture for the subnet configuration since you need to
    parse for google_compute_subnetwork. Two tests use this fixture for checking the
    number of subnets and their IP address ranges.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于需要解析 google_compute_subnetwork，因此为子网配置创建了一个单独的固定装置。两个测试使用此装置来检查子网数量及其 IP
    地址范围。
- en: ❼ Pytest will run this test to check the configuration for the network name
    to match hello-world-network. It references the network_configuration fixture.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Pytest 将运行此测试以检查网络名称是否匹配 hello-world-network。它引用了 network_configuration 固定装置。
- en: ❽ Pytest will run this test to check the configuration for the number of subnets
    to equal 3\. It references the subnet_configuration fixture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Pytest 将运行此测试以检查子网数量是否等于 3。它引用了 subnet_configuration 固定装置。
- en: ❾ Pytest will check the correct subnet IP range in the network example configuration.
    It references the subnet_configuration fixture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ Pytest 将检查网络示例配置中的正确子网 IP 范围。它引用了 subnet_configuration 固定装置。
- en: AWS and Azure equivalents
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: To convert listing 6.1 to AWS, use the `aws_subnet` Terraform resource ([http://mng.bz/J2vZ](https://shortener.manning.com/J2vZ))
    and retrieve the value for the `cidr_block` attribute.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将列表6.1转换为AWS，请使用`aws_subnet` Terraform资源([http://mng.bz/J2vZ](https://shortener.manning.com/J2vZ))并检索`cidr_block`属性的值。
- en: For Azure, use the `azurerm_subnet` Terraform resource ([http://mng.bz/wo05](https://shortener.manning.com/wo05))
    and retrieve the value for the `address_prefixes` attribute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Azure，请使用`azurerm_subnet` Terraform资源([http://mng.bz/wo05](https://shortener.manning.com/wo05))并检索`address_prefixes`属性的值。
- en: The testing file includes a static network object passed between tests. This
    *test fixture* creates a consistent network object that each test can reference.
    It reduces repetitive code used to build a test resource.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件包括在测试之间传递的静态网络对象。此 *测试固定装置* 创建一个一致的网络对象，每个测试都可以引用。它减少了构建测试资源时使用的重复代码。
- en: Definition A *test fixture* is a known configuration used to run a test. It
    often reflects known or expected values for a given infrastructure resource. Some
    of the fixtures separately parse the network and subnet information. Anytime we
    add new tests, we don’t have to copy and paste the parsing. Instead, we reference
    the fixture for the configuration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A *测试固定装置* 是用于运行测试的已知配置。它通常反映了给定基础设施资源的已知或预期值。一些固定装置会分别解析网络和子网信息。每次我们添加新的测试时，我们不必复制和粘贴解析。相反，我们引用固定装置以获取配置。
- en: 'You can run pytest at your command line and pass an argument with a test file.
    Pytest runs a set of three tests and outputs their success:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在命令行中运行pytest并传递一个带有测试文件的参数。pytest运行一组三个测试并输出它们的成功：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, you import the network factory module, create a network object
    with configuration, and test it. You don’t need to write any configuration to
    a file. Instead, you reference the function and test the object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您导入网络工厂模块，创建一个带有配置的网络对象，并对其进行测试。您不需要将任何配置写入文件。相反，您引用函数并测试对象。
- en: This example uses the same approach I take to unit testing application code.
    It often results in smaller, more modular functions that you can test more efficiently.
    The function that generates the network configuration needs to output the configuration
    for the test. Otherwise, the tests cannot parse and compare the values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用我用于单元测试应用程序代码的相同方法。这通常会导致更小、更模块化的函数，您可以更有效地进行测试。生成网络配置的函数需要输出测试配置。否则，测试无法解析和比较值。
- en: 6.2.2 Testing domain-specific languages
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 测试特定领域语言
- en: How do you test your network and subnet configuration if you use a DSL? You
    don’t have functions that you can call in your test. Instead, your unit tests
    must parse values out of the configuration or dry-run file. Both types of files
    store some kind of plaintext metadata about infrastructure resources.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用DSL，您如何测试您的网络和子网配置？您没有可以在测试中调用的函数。相反，您的单元测试必须从配置或干运行文件中解析值。这两种类型的文件都存储有关基础设施资源的一些plaintext元数据。
- en: Imagine you use a DSL instead of Python to create your network. This example
    creates a JSON file with Terraform-compatible configuration. The JSON file contains
    all three subnetworks, their IP address ranges, and names. In figure 6.7, you
    decide to run the unit tests against the network’s JSON configuration file. The
    tests run quickly because you do not deploy the networks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您使用DSL而不是Python来创建您的网络。此示例创建一个与Terraform兼容的配置的JSON文件。该JSON文件包含所有三个子网、它们的IP地址范围和名称。在图6.7中，您决定针对网络的JSON配置文件运行单元测试。测试运行得很快，因为您没有部署网络。
- en: '![](../../OEBPS/Images/CH06_F07_Wang.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F07_Wang.png)'
- en: Figure 6.7 Unit tests against dry runs require generating a preview of changes
    to infrastructure resources and checking it for valid parameters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 单元测试与干运行测试需要生成基础设施资源的更改预览，并检查其有效参数。
- en: In general, you can always unit-test the files you used to define IaC. If a
    tool uses a configuration file, like CloudFormation, Terraform, Bicep, Ansible,
    Puppet, Chef, and more, you can unit-test any lines in the configuration.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您始终可以对您用于定义IaC的文件进行单元测试。如果工具使用配置文件，如CloudFormation、Terraform、Bicep、Ansible、Puppet、Chef等，您可以对配置中的任何行进行单元测试。
- en: In listing 6.2, you can test the network name, number of subnets, and subnet
    IP address ranges for your network module *without* generating a dry run. I run
    similar tests with pytest to check the same parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表6.2中，您可以在不生成干运行的情况下测试您的网络模块的网络名称、子网数量和子网IP地址范围。我用pytest运行类似的测试来检查相同的参数。
- en: Listing 6.2 Using pytest to run unit tests in test_network_configuration.py
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 使用 pytest 在 test_network_configuration.py 中运行单元测试
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Imports Python’s JSON library because you will need to load a JSON file
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Python 的 JSON 库，因为你需要加载 JSON 文件
- en: ❷ Sets a constant with the expected filename for the network configuration.
    The tests read the network configuration from network.tf.json.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个常量，用于网络配置的预期文件名。测试从 network.tf.json 读取网络配置。
- en: ❸ Sets the expected network name to hello-world-network
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置预期的网络名称为 hello-world-network
- en: ❹ Opens the JSON file with the network configuration and loads it as a test
    fixture
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 打开包含网络配置的 JSON 文件并将其作为测试固定配置加载
- en: ❺ Creates a new test fixture that references the loaded JSON configuration and
    parses for any resource type. It parses the JSON based on Terraform’s JSON resource
    structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个新的测试固定配置，它引用已加载的 JSON 配置并解析任何资源类型。它根据 Terraform 的 JSON 资源结构解析 JSON。
- en: ❻ Gets the google_compute_network Terraform resource out of the JSON file
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从 JSON 文件中获取 google_compute_network Terraform 资源
- en: ❼ Gets the google_compute_subnetwork Terraform resource out of the JSON file
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 从 JSON 文件中获取 google_compute_subnetwork Terraform 资源
- en: ❽ Pytest will run this test to check the configuration for the network name
    to match hello-world-network. It references the network fixture.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Pytest 将运行此测试以检查网络名称配置是否与 hello-world-network 匹配。它引用了网络固定配置。
- en: ❾ Pytest will run this test to check the configuration for the number of subnets
    to equal 3\. It references the subnet fixture.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ Pytest 将运行此测试以检查子网数量配置是否等于 3。它引用了子网固定配置。
- en: ❿ Pytest will check for the correct subnet IP range configuration. It references
    the subnet fixture.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ Pytest 将检查正确的子网 IP 范围配置。它引用了子网固定配置。
- en: AWS and Azure equivalents
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 等效
- en: To convert listing 6.2 to AWS, use the `aws_subnet` Terraform resource ([http://mng.bz/J2vZ](https://shortener.manning.com/J2vZ))
    and retrieve the value for the `cidr_block` attribute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要将列表 6.2 转换为 AWS，使用 `aws_subnet` Terraform 资源 ([http://mng.bz/J2vZ](https://shortener.manning.com/J2vZ))
    并检索 `cidr_block` 属性的值。
- en: For Azure, use the `azurerm_subnet` Terraform resource ([http://mng.bz/wo05](https://shortener.manning.com/wo05))
    and retrieve the value for the `address_prefixes` attribute.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Azure，使用 `azurerm_subnet` Terraform 资源 ([http://mng.bz/wo05](https://shortener.manning.com/wo05))
    并检索 `address_prefixes` 属性的值。
- en: You might notice that the unit tests for DSLs look similar to those of programming
    languages. They check the network name, number of subnets, and IP addresses. Some
    tools have specialized testing frameworks. They usually use the same workflow
    of generating a dry-run or state file and parsing it for values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 DSL 的单元测试看起来与编程语言的测试相似。它们检查网络名称、子网数量和 IP 地址。一些工具具有专门的测试框架。它们通常使用相同的流程生成干运行或状态文件，并解析其中的值。
- en: However, your configuration file may not contain everything. For example, you
    won’t have certain configurations in Terraform or Ansible until *after* you do
    a dry run. A *dry run* previews IaC changes without deploying them and internally
    identifies and resolves potential problems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的配置文件可能不包含所有内容。例如，你不会在 Terraform 或 Ansible 中拥有某些配置，直到 *之后* 你进行了干运行。*干运行*
    预览 IaC 变更而不部署它们，并内部识别和解决潜在问题。
- en: Definition A *dry run* previews IaC changes without deploying them. It internally
    identifies and resolves potential problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 A *干运行* 预览 IaC 变更而不部署它们。它内部识别并解决潜在问题。
- en: Dry runs come in different formats and standards. Most dry runs output to a
    terminal, and you can save the output to a file. Some tools will automatically
    generate the dry run to a file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 干运行有不同的格式和标准。大多数干运行输出到终端，并且你可以将输出保存到文件。一些工具将自动将干运行生成到文件。
- en: Generating dry runs for unit tests
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为单元测试生成干运行
- en: 'Some tools save their dry runs in a file, while others output the changes in
    a terminal. If you use Terraform, you write the Terraform plan to a JSON file
    by using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具将它们的干运行保存到文件中，而其他工具则在终端中输出更改。如果你使用 Terraform，你可以使用以下命令将 Terraform 计划写入 JSON
    文件：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: AWS CloudFormation offers change sets, and you can parse the change set description
    after it completes. Similarly, you can get Kubernetes dry-run information with
    the `kubectl` `run`’s `-–dry-run=client` option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation 提供更改集，你可以在完成后解析更改集描述。同样，你可以使用 `kubectl` `run` 的 `-–dry-run=client`
    选项获取 Kubernetes 干运行信息。
- en: As a general practice, I prioritize tests that check configuration files. I
    write tests to parse dry runs when I cannot get the value from configuration files.
    A dry run typically needs network access to the infrastructure provider API and
    takes a bit of time to run. On occasion, the output or file contains sensitive
    information or identifiers that I do not want a test to explicitly parse.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般做法，我优先考虑检查配置文件的测试。当我无法从配置文件中获取值时，我会编写解析dry-run的测试。dry-run通常需要访问基础设施提供者API的网络，并且运行需要一些时间。有时，输出或文件包含我不想让测试明确解析的敏感信息或标识符。
- en: While dry-run configuration may not adhere to the more traditional software
    development definition of unit tests, the parsing of dry runs does not require
    any changes to active infrastructure. It remains a form of static analysis. The
    dry run itself serves as a unit test to validate and output the expected change
    behavior before applying the change.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然dry-run配置可能不符合更传统的软件开发定义的单元测试，但解析dry-run不需要对活动基础设施进行任何更改。它仍然是一种静态分析。dry-run本身作为单元测试，用于在应用更改之前验证和输出预期的更改行为。
- en: 6.2.3 When should you write unit tests?
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 你应该在什么时候编写单元测试？
- en: Unit tests help you verify that your logic generates the correct names, produces
    the correct number of infrastructure resources, and calculates the correct IP
    ranges or other attributes. Some unit tests may overlap with formatting and linting,
    concepts I mentioned in chapter 2\. I classify linting and formatting as part
    of unit testing because they help you understand how to name and organize your
    configuration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试帮助你验证你的逻辑生成正确的名称，产生正确数量的基础设施资源，并计算正确的IP范围或其他属性。一些单元测试可能与格式化和linting重叠，这些概念我在第2章中提到。我将linting和formatting归类为单元测试的一部分，因为它们帮助你了解如何命名和组织你的配置。
- en: Figure 6.8 summarizes some use cases for unit tests. You should write additional
    unit tests to verify any logic you used to generate infrastructure configuration,
    especially with loops or conditional (if-else) statements. Unit tests can also
    capture wrong or problematic configurations, such as the wrong operating system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8总结了单元测试的一些用例。你应该编写额外的单元测试来验证你用于生成基础设施配置的任何逻辑，特别是涉及循环或条件（if-else）语句的逻辑。单元测试还可以捕获错误或问题配置，例如错误的操作系统。
- en: '![](../../OEBPS/Images/CH06_F08_Wang.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F08_Wang.png)'
- en: Figure 6.8 Write unit tests to verify the resource logic, highlight potential
    problems, or identify team standards.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 编写单元测试以验证资源逻辑，突出潜在问题或确定团队标准。
- en: Since unit tests check the configuration in isolation, they do not precisely
    reflect the way a change will affect a system. As a result, you can’t expect a
    unit test to prevent a major failure during production changes. However, you should
    still write unit tests! While they won’t identify problems while running a change,
    unit tests can *prevent* problematic configurations before production.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试是在隔离状态下检查配置，它们并不能精确反映更改将如何影响系统。因此，你不能期望单元测试在生产更改期间防止重大故障。然而，你仍然应该编写单元测试！虽然它们在运行更改时不会识别问题，但单元测试可以在生产之前*预防*问题配置。
- en: For example, someone might accidentally type a configuration for 1,000 servers
    instead of 10 servers. A test to verify the maximum number of servers in a configuration
    can prevent someone from overwhelming the infrastructure and manage the cost.
    Unit tests can also prevent any insecure or noncompliant infrastructure configuration
    from a production environment. I cover how to apply unit tests to secure and audit
    infrastructure configuration in chapter 8.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有人可能会不小心为1,000台服务器而不是10台服务器输入配置。一个验证配置中服务器最大数量的测试可以防止某人压倒基础设施并管理成本。单元测试还可以防止从生产环境中出现任何不安全或不合规的基础设施配置。我在第8章中介绍了如何将单元测试应用于安全和审计基础设施配置。
- en: In addition to early identification of wrong configuration values, unit tests
    help automate checking complex systems. When you have many infrastructure resources
    managed by different teams, you can no longer manually search through one resource
    list and check each configuration. Unit tests communicate the most critical or
    standard configurations to other teams. When you write unit tests for infrastructure
    modules, you verify that the internal logic of the module produces the expected
    resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了早期识别错误的配置值之外，单元测试还有助于自动化检查复杂系统。当你有许多由不同团队管理的基础设施资源时，你不能再手动搜索一个资源列表并检查每个配置。单元测试将最重要的或标准配置传达给其他团队。当你为基础设施模块编写单元测试时，你验证模块的内部逻辑是否产生了预期的资源。
- en: Unit testing your automation
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试自动化
- en: Good unit tests require an entire book to describe! I scoped my explanation
    in this section to testing infrastructure configuration. However, you might write
    a custom automation tool directly accessing an infrastructure API. Automation
    uses a more sequential approach to configure a resource step-by-step (also known
    as the imperative style).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的单元测试需要一本书来描述！我在本节中限定了对基础设施配置的测试解释。然而，你可能会编写一个直接访问基础设施API的定制自动化工具。自动化使用更顺序的方法逐步配置资源（也称为命令式风格）。
- en: You should use unit tests to check the individual steps and their idempotency.
    Unit tests should run the individual steps with various prerequisites and check
    that they have the same result. If you need to access an infrastructure API, you
    can mock the API responses in your unit tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用单元测试来检查单个步骤及其幂等性。单元测试应该在各种先决条件下运行单个步骤，并检查它们是否具有相同的结果。如果你需要访问基础设施API，你可以在单元测试中模拟API响应。
- en: Use cases for unit tests include checking that you’ve created the expected number
    of infrastructure resources, pinned specific versions of infrastructure, or used
    the correct naming standard. Unit tests run quickly and offer rapid feedback at
    virtually zero cost (after you’ve written them!). They run on the order of seconds
    because they do not post updates to infrastructure or require the creation of
    active infrastructure resources. If you write unit tests to check the output of
    a dry run, you add a bit of time because of the initial time spent generating
    the dry run.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的用例包括检查你是否创建了预期的数量的基础设施资源，固定了特定版本的基础设施，或者使用了正确的命名标准。单元测试运行迅速，几乎零成本（在你编写它们之后！）提供快速反馈。它们的运行时间在秒级，因为它们不需要向基础设施发布更新或创建活动的基础设施资源。如果你编写单元测试来检查干运行的结果，你会因为生成干运行所花费的初始时间而增加一点时间。
- en: 6.3 Contract tests
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 合同测试
- en: Unit tests verify configuration or modules in isolation, but what about dependencies
    between modules? In chapter 4, I mentioned the idea of a contract between dependencies.
    The output from a module must agree with the expected input to another. You can
    use tests to enforce that agreement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试验证配置或模块的独立性，但模块之间的依赖关系怎么办？在第4章中，我提到了依赖关系之间合同的想法。一个模块的输出必须与另一个模块的预期输入一致。你可以使用测试来强制执行这种一致性。
- en: For example, let’s create a server on a network. The server accesses the network
    name and IP address by using a facade, which mirrors the name and IP address range
    of the network. How do you know that the network module outputs the network name
    and IP CIDR range and not another identifier or configuration?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在网络上创建一个服务器。服务器通过使用外观来访问网络名称和IP地址，该外观反映了网络的名称和IP地址范围。你如何知道网络模块输出的是网络名称和IP
    CIDR范围，而不是另一个标识符或配置？
- en: You use a contract test in figure 6.9 to test that the network module outputs
    the facade correctly. The facade must contain the network name and IP address
    range. If the test fails, it shows that the server cannot create itself on the
    network.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你在图6.9中使用了合同测试来测试网络模块是否正确输出外观。外观必须包含网络名称和IP地址范围。如果测试失败，则表明服务器无法在网络中创建自身。
- en: '![](../../OEBPS/Images/CH06_F09_Wang.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F09_Wang.png)'
- en: Figure 6.9 Contract tests can quickly verify that a configuration parameter
    equals an expected value, such as a network facade with proper outputs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 合同测试可以快速验证配置参数是否等于预期值，例如具有正确输出的网络外观。
- en: A *contract test* uses static analysis to check that module inputs and outputs
    match an expected value or format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*合同测试*通过静态分析来检查模块的输入和输出是否与预期值或格式匹配。'
- en: Definition *Contract tests* statically analyze and compare module or resource
    inputs and outputs to match an expected value or format.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *合同测试* 静态分析并比较模块或资源的输入和输出，以匹配预期值或格式。
- en: Contract tests help enable evolvability of individual modules while preserving
    the integration between the two. When you have many infrastructure dependencies,
    you cannot manually check all of their shared attributes. Instead, a contract
    test automates the verification of the type and value of attributes between modules.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试有助于使单个模块具有可扩展性，同时保持两者之间的集成。当你有许多基础设施依赖项时，你不能手动检查它们的所有共享属性。相反，合同测试自动化了模块之间属性的类型和值的验证。
- en: You’ll find contract tests most useful for checking inputs and outputs of heavily
    parameterized modules (such as factory, prototype, or builder patterns). Writing
    and running contract tests helps detect wrong inputs and outputs and documents
    the module’s minimum resources. When you do not have contract tests for your modules,
    you won’t find out if you broke something in the system until the next time you
    apply the configuration to a live environment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现合同测试对于检查高度参数化模块（如工厂、原型或构建器模式）的输入和输出最有用。编写和运行合同测试有助于检测错误的输入和输出，并记录模块的最小资源。当你没有为你的模块编写合同测试时，你不会知道你在系统中破坏了什么，直到你下一次将配置应用到实际环境中。
- en: Let’s implement a contract test for the server and the network in listing 6.3\.
    Using pytest, you set up the test by creating a network with a factory module.
    Then you verify that the network’s output includes a facade object with the network
    name and IP address range. You add these tests to the server’s unit tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在列表 6.3 中实现服务器和网络合同测试。使用 pytest，你通过创建一个带有工厂模块的网络来设置测试。然后你验证网络输出是否包含具有网络名称和
    IP 地址范围的外观对象。你将这些测试添加到服务器的单元测试中。
- en: Listing 6.3 Contract test to compare the module outputs with inputs
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 比较模块输出与输入的合同测试
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Pytest will run this test to check if the network name matches the expected
    value, hello-world.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Pytest 将运行此测试以检查网络名称是否与预期值匹配，hello-world。
- en: ❷ Pytest will run this test to check that the network output’s IP CIDR range
    matches 10.0.0.0/16.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Pytest 将运行此测试以检查网络输出的 IP CIDR 范围是否与 10.0.0.0/16 匹配。
- en: ❸ Sets up the test with a fixture that uses a network factory module and returns
    its outputs
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用网络工厂模块和返回其输出的固定装置设置测试
- en: ❹ Creates a network by using the factory module with the name and IP address
    range
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用带有名称和 IP 地址范围的网络工厂模块创建网络
- en: ❺ The test fixture should return a network facade with different output attributes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测试固定装置应返回具有不同输出属性的网络外观。
- en: ❻ Pytest will run this test to check if the module outputs the network facade
    object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Pytest 将运行此测试以检查模块是否输出网络外观对象。
- en: ❼ Pytest will run this test to check if the network name matches the expected
    value, hello-world.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Pytest 将运行此测试以检查网络名称是否与预期值匹配，hello-world。
- en: ❽ Pytest will run this test to check that the network output’s IP CIDR range
    matches 10.0.0.0/16.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Pytest 将运行此测试以检查网络输出的 IP CIDR 范围是否与 10.0.0.0/16 匹配。
- en: Imagine you update the network module to output the network ID instead of the
    name. That breaks the functionality of the upstream server module because the
    server expects the network name! Contract testing ensures that you do not break
    the *contract* (or interface) between two modules when you update either one.
    Use a contract test to verify your facades and adapters when expressing dependencies
    between resources.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你更新了网络模块，以输出网络 ID 而不是名称。这破坏了上游服务器模块的功能，因为服务器期望网络名称！合同测试确保当你更新任何一个模块时，你不会破坏两个模块之间的
    *合同*（或接口）。使用合同测试来验证你在表达资源之间的依赖关系时使用的外观和适配器。
- en: Why should you add the example contract test to the server, a higher-level resource?
    Your server *expects* specific outputs from the network. If the network module
    changes, you want to detect it from the high-level module first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该将示例合同测试添加到服务器，一个更高级的资源？你的服务器**期望**从网络获得特定的输出。如果网络模块发生变化，你希望首先从高级模块检测到它。
- en: In general, a high-level module should defer to changes in the low-level module
    to preserve composability and evolvability. You want to avoid making significant
    changes to the interface of a low-level module because it may affect other modules
    that depend on it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个高级模块应该推迟对低级模块的更改，以保持可组合性和可扩展性。你希望避免对低级模块的接口进行重大更改，因为这可能会影响依赖于它的其他模块。
- en: Domain-specific languages
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Listing 6.3 uses Python to verify the module outputs. If you use a tool with
    a DSL, you might be able to use built-in functionality that allows you to validate
    that inputs adhere to certain types or regular expressions (such as checking for
    a valid ID or name formatting). If a tool does not have a validation function,
    you may need to use a separate testing framework to parse the output types from
    one module’s configuration and compare them to the high-level module inputs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 使用Python验证模块输出。如果你使用具有DSL的工具，你可能能够使用内置功能来验证输入是否遵循某些类型或正则表达式（例如检查有效的ID或名称格式）。如果一个工具没有验证函数，你可能需要使用单独的测试框架来解析一个模块配置的输出类型，并将其与高级模块输入进行比较。
- en: Infrastructure contract tests require some way to extract the expected inputs
    and outputs, which may involve API calls to infrastructure providers and verifying
    the responses against expected values for modules. Sometimes this involves creating
    test resources to examine the parameters and understand how fields like ID should
    be structured. When you need to make API calls or create temporary resources,
    your contract tests can run longer than a unit test.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施合同测试需要一种方法来提取预期的输入和输出，这可能涉及对基础设施提供商的API调用，并验证模块的响应是否符合预期值。有时这涉及到创建测试资源来检查参数和理解字段如ID应该如何结构化。当你需要执行API调用或创建临时资源时，你的合同测试可能比单元测试运行时间更长。
- en: 6.4 Integration tests
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 集成测试
- en: How do you know that you can apply your configuration or module changes to an
    infrastructure system? You need to apply the changes to a testing environment
    and *dynamically analyze* the running infrastructure. An *integration test* runs
    against test environments to verify successful changes to a module or configuration.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道你可以将你的配置或模块更改应用到基础设施系统中？你需要将更改应用到测试环境中，并*动态分析*运行中的基础设施。*集成测试*针对测试环境运行，以验证模块或配置的成功更改。
- en: Definition *Integration tests* run against testing environments and dynamically
    analyze infrastructure resources to verify that they are affected by module or
    configuration changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*集成测试*针对测试环境运行，并动态分析基础设施资源，以验证它们是否受到模块或配置更改的影响。
- en: Integration tests require an isolated testing environment to verify the integration
    of modules and resources. In the next sections, you’ll learn about the integration
    tests you can write for infrastructure modules and configurations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要一个隔离的测试环境来验证模块和资源的集成。在接下来的章节中，你将了解可以为基础设施模块和配置编写的集成测试。
- en: 6.4.1 Testing modules
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 测试模块
- en: Imagine a module that creates a GCP server. You want to make sure you can create
    and update the server successfully, so you write an integration test, as shown
    in figure 6.10.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个创建GCP服务器的模块。你想要确保你可以成功创建和更新服务器，因此你编写了一个集成测试，如图6.10所示。
- en: First, you configure the server and apply the changes to a testing environment.
    Then, you run integration tests to check that your configuration update succeeds,
    create a server, and name it `hello-world-test`. The total runtime of the test
    takes a few minutes because you need to wait for a server to provision.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你配置服务器并将更改应用到测试环境中。然后，你运行集成测试以检查你的配置更新是否成功，创建一个服务器，并将其命名为`hello-world-test`。测试的总运行时间需要几分钟，因为你需要等待服务器配置完成。
- en: '![](../../OEBPS/Images/CH06_F10_Wang.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F10_Wang.png)'
- en: Figure 6.10 Integration tests usually create and update infrastructure resources
    in a testing environment, test their configuration and status for correctness
    or availability, and remove them after the tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 集成测试通常在测试环境中创建和更新基础设施资源，测试其配置和状态的正确性或可用性，并在测试后删除它们。
- en: When you implement an integration test, you need to compare the active resource
    to your IaC. The active resource tells you whether your module deployed successfully.
    If someone cannot deploy the module, they potentially break their infrastructure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现集成测试时，你需要比较活动资源与你的IaC。活动资源告诉你你的模块是否成功部署。如果有人无法部署模块，他们可能破坏了他们的基础设施。
- en: An integration test must retrieve information about the active resource with
    the infrastructure provider’s API. For example, you can import a Python library
    to access the GCP API in your server module’s integration test. The integration
    test imports Libcloud, a Python library, as a client SDK for the GCP API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试必须使用基础设施提供者的 API 获取活动资源的有关信息。例如，你可以在服务器模块的集成测试中导入一个 Python 库来访问 GCP API。集成测试导入
    Libcloud，一个 Python 库，作为 GCP API 的客户端 SDK。
- en: The test in listing 6.4 builds the server’s configuration by using the module,
    waits for the server to deploy, and checks the server’s state in the GCP API.
    If the server returns a `running` status, the test passes. Otherwise, the test
    fails and identifies a problem with the module. Finally, the test tears down the
    test server it created.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 中的测试通过使用模块构建服务器的配置，等待服务器部署，并在 GCP API 中检查服务器的状态。如果服务器返回 `running` 状态，则测试通过。否则，测试失败并识别模块中的问题。最后，测试会拆除它创建的测试服务器。
- en: Listing 6.4 Integration tests for server creation in test_integration.py
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 test_integration.py 中的服务器创建集成测试
- en: '[PRE5]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Pytest uses Libcloud to call the GCP API and get the server’s current state.
    It checks that the server is running.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Pytest 使用 Libcloud 调用 GCP API 并获取服务器的当前状态。它检查服务器是否正在运行。
- en: ❷ During the test session, uses a pytest test fixture to apply the configuration
    and creates a test server on GCP
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在测试会话期间，使用 pytest 测试 fixture 应用配置并在 GCP 上创建测试服务器
- en: ❸ Generates a Terraform JSON file that uses the server module
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成一个使用服务器模块的 Terraform JSON 文件
- en: ❹ Using Terraform, initializes and deploys the server using the Terraform JSON
    file
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 Terraform，通过 Terraform JSON 文件初始化和部署服务器
- en: ❺ Deletes the test server with Terraform and removes the JSON configuration
    file at the end of the test session
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在测试会话结束时使用 Terraform 删除测试服务器并移除 JSON 配置文件
- en: ❻ Pytest will run this test to verify that the output status of the changes
    has succeeded.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Pytest 将运行此测试以验证更改的输出状态是否成功。
- en: ❼ Pytest will run this test to verify that the changes do not return with an
    error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Pytest 将运行此测试以验证更改不会返回错误。
- en: ❽ Pytest will run this test and check that the configuration adds one resource,
    the server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Pytest 将运行此测试并检查配置是否添加了一个资源，即服务器。
- en: ❾ Pytest uses Libcloud to call the GCP API and get the server’s current state.
    It checks that the server is running.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ Pytest 使用 Libcloud 调用 GCP API 并获取服务器的当前状态。它检查服务器是否正在运行。
- en: AWS and Azure equivalents
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 的等效项
- en: To convert listing 6.4, you need to update the IaC to create an Amazon EC2 instance
    or Azure Linux virtual machine. Then you need to update the Apache Libcloud driver
    to use Amazon EC2 Driver ([http://mng.bz/qYex](https://shortener.manning.com/qYex))
    or Azure ARM Compute Driver ([http://mng.bz/7yjQ](https://shortener.manning.com/7yjQ)).
    The initialization of the driver and IaC will change, but the test does not.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换列表 6.4，你需要更新 IaC 以创建一个 Amazon EC2 实例或 Azure Linux 虚拟机。然后你需要更新 Apache Libcloud
    驱动程序以使用 Amazon EC2 驱动程序 ([http://mng.bz/qYex](https://shortener.manning.com/qYex))
    或 Azure ARM Compute 驱动程序 ([http://mng.bz/7yjQ](https://shortener.manning.com/7yjQ))。驱动程序和
    IaC 的初始化将发生变化，但测试不会。
- en: 'When you run the tests in this file at your command line, you’ll notice that
    it takes a few minutes because the test session creates the server and deletes
    it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中运行此文件中的测试时，你会注意到它需要几分钟的时间，因为测试会话会创建并删除服务器：
- en: '[PRE6]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The integration tests for the server apply two main practices. First, the tests
    follow this sequence:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器集成测试应用了两种主要实践。首先，测试遵循以下顺序：
- en: Render configuration, if applicable
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果适用，渲染配置
- en: Deploy changes to infrastructure resources
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改部署到基础设施资源
- en: Run tests, accessing the infrastructure provider’s API for comparison
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试，访问基础设施提供者的 API 进行比较
- en: Delete infrastructure resources, if applicable.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果适用，删除基础设施资源。
- en: This example implements the sequence using a fixture. You can use it to apply
    any arbitrary infrastructure configuration and remove it after testing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 fixture 实现了序列。你可以用它来应用任何任意的基础设施配置，并在测试后移除它。
- en: Note Integration tests work very similarly for configuration management tooling.
    For example, you can install packages and run processes on your server. After
    running the tests, you can expand the server integration tests by checking the
    server’s packages and processes and destroying the server. Rather than writing
    the tests using a programming language, I recommend evaluating specialized server
    testing tooling that logs into the server and runs tests against the system.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 集成测试对于配置管理工具的工作方式非常相似。例如，你可以在服务器上安装软件包并运行进程。在运行测试后，你可以通过检查服务器的软件包和进程以及销毁服务器来扩展服务器集成测试。与其使用编程语言编写测试，我建议评估专门的服务器测试工具，该工具登录到服务器并针对系统运行测试。
- en: Second, you run module integration tests in a separate *module-testing environment*
    (such as a test account or project) away from testing or production environments
    supporting applications. To prevent conflicts with other module tests in the environment,
    you label and name the resources based on the specific module type, version, or
    commit hash.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你在远离支持应用程序的测试或生产环境的单独 *模块测试环境*（例如测试账户或项目）中运行模块集成测试。为了避免与环境中其他模块测试发生冲突，你根据特定的模块类型、版本或提交哈希对资源进行标记和命名。
- en: Definition A *module-testing environment* is separate from production and used
    for testing module changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A *模块测试环境* 是与生产环境分开的，用于测试模块更改。
- en: Testing modules in a different environment than a testing or production environment
    helps isolate failed modules from an active environment with applications. You
    can also measure and control your infrastructure cost from testing modules. Chapter
    12 covers the cost of cloud computing in greater detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在与测试或生产环境不同的环境中测试模块有助于将失败的模块与具有应用程序的活跃环境隔离。你还可以从测试模块中测量和控制你的基础设施成本。第12章更详细地介绍了云计算的成本。
- en: 6.4.2 Testing configuration for environments
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 环境配置测试
- en: Integration tests for infrastructure modules can create and delete resources
    in a testing environment, but integration tests for environment configurations
    cannot. Imagine you need to add an A record to your current domain name configured
    by a composite or singleton configuration. How do you write integration tests
    to check that you added the record correctly?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施模块的集成测试可以在测试环境中创建和删除资源，但环境配置的集成测试则不能。想象一下，你需要向由组合或单例配置设置的当前域名添加一个A记录。你该如何编写集成测试来检查你是否正确添加了该记录？
- en: You encounter two problems. First, you cannot simply create and then destroy
    DNS records as part of your integration tests because it may affect applications.
    Second, the A record depends on a server IP address to exist before you can configure
    the domain.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到两个问题。首先，你不能简单地在集成测试中创建和销毁DNS记录，因为这可能会影响应用程序。其次，A记录的存在依赖于在配置域名之前的服务器IP地址。
- en: Instead of creating and destroying the server and A record in a testing environment,
    you run the integration tests against a *persistent* testing environment that
    matches production. In figure 6.11, you update the DNS record in IaC for the testing
    environment. Your integration tests check that the DNS in the testing environment
    matches the expected correct DNS record. After the test passes, you can update
    the DNS record for production.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在测试环境中创建和销毁服务器和A记录，你可以在与生产环境匹配的 *持久性* 测试环境中运行集成测试。在图6.11中，你更新测试环境的IaC中的DNS记录。你的集成测试检查测试环境中的DNS是否与预期的正确DNS记录匹配。测试通过后，你可以更新生产环境的DNS记录。
- en: '![](../../OEBPS/Images/CH06_F11_Wang.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F11_Wang.png)'
- en: Figure 6.11 You can run integration tests against a testing environment with
    long-lived resources to isolate the changes from production and reduce the dependencies
    you need to create for the test.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 你可以对具有长期资源的测试环境运行集成测试，以隔离生产环境中的更改并减少你需要为测试创建的依赖。
- en: Why run the DNS test in a *persistent* testing environment? First, it can take
    a long time to create a testing environment. As a high-level resource, DNS depends
    on many low-level ones. Second, you want an accurate representation of how the
    change behaves before you update production.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在 *持久性* 测试环境中运行DNS测试？首先，创建测试环境可能需要很长时间。作为高级资源，DNS依赖于许多低级资源。其次，你希望在更新生产环境之前，对更改的行为有一个准确的表示。
- en: The testing environment captures a subset of dependencies and complexities of
    the production system so you can check that your configuration works as expected.
    Keeping similar testing and production environments means that a change in testing
    provides an accurate perspective of its behavior in production. You want to aim
    for early detection of problems in the testing environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 测试环境捕获了生产系统的一部分依赖和复杂性，以便您可以检查您的配置是否按预期工作。保持与生产环境相似的测试环境意味着测试中的变化可以提供一个准确的生产行为视角。您希望尽早检测测试环境中的问题。
- en: 6.4.3 Testing challenges
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 测试挑战
- en: Without the integration tests, you would not know whether a server module or
    DNS record updates successfully until you manually check it. They expedite the
    process of verifying that your IaC works. However, you will encounter a few challenges
    with integration testing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 没有集成测试，您将不知道服务器模块或DNS记录更新是否成功，直到您手动检查。它们加快了验证您的IaC是否工作的过程。然而，您在集成测试中会遇到一些挑战。
- en: You might have difficulty determining which configuration parameters to test.
    Should you write integration tests to verify that every configuration parameter
    you’ve configured in IaC matches the live resource? Not necessarily!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能难以确定要测试哪些配置参数。您是否应该编写集成测试来验证您在基础设施即代码（IaC）中配置的每个配置参数是否与实际资源匹配？不一定！
- en: Most tools already have *acceptance tests* that create a resource, update its
    configuration, and destroy the resource. Acceptance tests certify that the tool
    can release new code changes. These tests must pass in order for the tool to support
    changes to infrastructure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工具已经具有*验收测试*，这些测试会创建一个资源，更新其配置，然后销毁该资源。验收测试可以证明工具能够发布新的代码更改。这些测试必须通过，以便工具能够支持基础设施的更改。
- en: You don’t want to spend additional time or effort writing tests that match the
    acceptance tests. As a result, your integration tests should cover whether *multiple*
    resources have the correct configuration and dependencies. If you write custom
    automation, you will need to write integration tests to create, update, and delete
    resources.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望花费额外的时间或精力编写与验收测试相匹配的测试。因此，您的集成测试应该涵盖*多个*资源是否具有正确的配置和依赖关系。如果您编写自定义自动化，您将需要编写集成测试来创建、更新和删除资源。
- en: Another challenge involves deciding whether you should create or delete resources
    during each test or run a persistent testing environment. Figure 6.12 shows a
    decision tree for whether to create, delete, or use a persistent testing environment
    for an integration test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战涉及决定在每个测试期间是否应该创建或删除资源，或者运行持久测试环境。图6.12显示了是否为集成测试创建、删除或使用持久测试环境的决策树。
- en: '![](../../OEBPS/Images/CH06_F12_Wang.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F12_Wang.png)'
- en: Figure 6.12 Your integration test should create and delete resources based on
    module or configuration type and dependencies.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 您的集成测试应根据模块或配置类型及其依赖关系创建和删除资源。
- en: In general, if a configuration or module does not have too many dependencies,
    you can create, test, and delete it. However, if your configuration or module
    takes time to create or requires the existence of many other resources, you will
    need to use a persistent testing environment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果一个配置或模块没有太多依赖，您可以创建、测试和删除它。然而，如果您的配置或模块创建需要花费时间或需要许多其他资源的存在，您将需要使用持久测试环境。
- en: Not all modules benefit from a create-and-delete approach in integration testing.
    I recommend running integration tests for low-level modules, such as networks
    or DNS, and avoid removing the resources. These modules usually require in-place
    updates in environments with a minimal financial cost. I often find it more realistic
    to test the update instead of creating and deleting the resource.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有模块都从创建和删除的集成测试方法中受益。我建议为低级模块，如网络或DNS，运行集成测试，并避免删除资源。这些模块通常需要在具有最小财务成本的环境中就地更新。我经常发现测试更新比创建和删除资源更现实。
- en: Resources created by integration tests for mid-level modules, such as workload
    orchestrators, may be persistent or temporary depending on the size of the module
    and resource. The larger the module, the more likely it will need to be long-lived.
    You can run integration tests for high-level modules, such as application deployments
    or SaaS, and create and delete the resources each time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 中级模块（如工作负载编排器）的集成测试创建的资源可能是持久的或临时的，这取决于模块和资源的大小。模块越大，需要长期存在的可能性就越高。你可以为高级模块（如应用部署或SaaS）运行集成测试，每次都创建和删除资源。
- en: A persistent testing environment does have its limits. Integration tests tend
    to take a long time to run because creating or updating resources takes time.
    As a rule, keep modules smaller with fewer resources. This practice reduces the
    amount of time you need for a module integration test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 持久的测试环境确实有其局限性。集成测试通常需要很长时间才能运行，因为创建或更新资源需要时间。一般来说，保持模块较小，资源较少。这种做法可以减少你需要进行模块集成测试的时间。
- en: Even if you keep configurations and modules small with few resources, integration
    tests often become the culprit of your infrastructure provider bill’s increasing
    cost. A number of tests need long-lived resources like networks, gateways, and
    more. Weigh the cost of running an integration test and catching problems against
    the cost of misconfiguration or a broken infrastructure resource.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你保持配置和模块较小，资源较少，集成测试也常常成为你基础设施提供商账单成本增加的罪魁祸首。许多测试需要长期资源，如网络、网关等。权衡运行集成测试和发现问题与配置错误或损坏的基础设施资源成本之间的关系。
- en: You may consider using infrastructure mocks to lower the cost of running an
    integration test (or any test). Some frameworks replicate an infrastructure provider’s
    APIs for local testing. I do not recommend relying heavily on mocks. Infrastructure
    providers change APIs frequently and often have complex errors and behaviors,
    which mocks do not often capture. In chapter 12, I discuss techniques to manage
    the cost of testing environments and avoid mocks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑使用基础设施模拟来降低运行集成测试（或任何测试）的成本。一些框架为本地测试复制了基础设施提供者的API。我不建议过度依赖模拟。基础设施提供者经常更改API，并且经常有复杂的错误和行为，这些模拟通常无法捕捉。在第12章中，我讨论了管理测试环境成本和避免模拟的技术。
- en: 6.5 End-to-end tests
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 端到端测试
- en: While integration tests dynamically analyze configuration and catch errors during
    resource creation or update, they do not indicate whether an infrastructure resource
    is *usable*. Usability requires that you or a team member use the resource as
    intended.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然集成测试在资源创建或更新期间动态分析配置并捕获错误，但它们并不表明基础设施资源是否*可用*。可用性要求你或团队成员按预期使用该资源。
- en: For example, you might use a module to create an application, called a *service*,
    on GCP Cloud Run. GCP Cloud Run deploys any service in a container and returns
    a URL endpoint. Your integration tests pass, indicating that your module correctly
    creates the service resource and permissions to access the service.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会使用一个模块在GCP Cloud Run上创建一个名为*服务*的应用程序。GCP Cloud Run将任何服务部署到容器中，并返回一个URL端点。你的集成测试通过，表明你的模块正确创建了服务资源以及访问服务的权限。
- en: How do you know whether someone can access the application URL? Figure 6.13
    shows how to check that the service endpoint works. First, you write a test to
    retrieve the application URL as an output from your infrastructure configuration.
    Then, you make an HTTP request to the URL. The total run time takes a few minutes,
    most of it from creating the service.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道某人能否访问应用程序URL？图6.13显示了如何检查服务端点是否工作。首先，你编写一个测试来从你的基础设施配置中检索应用程序URL作为输出。然后，你向该URL发出HTTP请求。总运行时间需要几分钟，其中大部分时间用于创建服务。
- en: You’ve created a test for dynamic analysis that differs from an integration
    test called an *end-to-end test*. It verifies the end-user functionality of the
    infrastructure.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个与集成测试不同的动态分析测试，称为*端到端测试*。它验证了基础设施的最终用户功能。
- en: Definition *End-to-end tests* dynamically analyze infrastructure resources and
    end-to-end system functionality to verify that they are affected by IaC changes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 定义*端到端测试*动态分析基础设施资源和端到端系统功能，以验证它们是否受到IaC更改的影响。
- en: The example end-to-end test verifies the end-to-end workflow of the end user
    accessing the page. It does *not* check for the successful configuration of infrastructure.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 示例端到端测试验证了最终用户访问页面的端到端工作流程。它**不**检查基础设施配置的成功配置。
- en: '![](../../OEBPS/Images/CH06_F13_Wang.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F13_Wang.png)'
- en: Figure 6.13 End-to-end tests verify the end user’s workflow by accessing the
    web page at the application’s URL.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 端到端测试通过访问应用程序的 URL 中的网页来验证最终用户的流程。
- en: End-to-end tests become vital for ensuring that your changes don’t break upstream
    functionality. For example, you might accidentally update a configuration that
    allows authenticated users to access the GCP Cloud Run service URL. Your end-to-end
    test fails after applying the change, indicating that someone may no longer access
    the service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试对于确保你的更改不会破坏上游功能至关重要。例如，你可能会意外更新一个允许认证用户访问 GCP Cloud Run 服务 URL 的配置。更改后，你的端到端测试失败，表明有人可能无法再访问该服务。
- en: Let’s implement an end-to-end test for the application URL in Python in the
    following listing. The test for this example needs to make an API request to the
    service’s public URL. It uses a pytest fixture to create the GCP Cloud Run service,
    test the URL for the running page, and delete the service from a testing environment.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的列表中实现一个在 Python 中针对应用程序 URL 的端到端测试。此示例的测试需要向服务的公共 URL 发送 API 请求。它使用 pytest
    夹具创建 GCP Cloud Run 服务，测试运行页面的 URL，并从测试环境中删除服务。
- en: Listing 6.5 End-to-end test for GCP Cloud Run service
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 GCP Cloud Run 服务的端到端测试
- en: '[PRE7]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Using Terraform, initializes and deploys the service using the Terraform JSON
    file
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Terraform，通过 Terraform JSON 文件初始化和部署服务
- en: ❷ During the test session, uses a pytest test fixture to apply the configuration
    and create a test service on GCP
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在测试会话期间，使用 pytest 测试夹具应用配置并在 GCP 上创建测试服务
- en: ❸ Generates a Terraform JSON file that uses the GCP Cloud Run module
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成一个使用 GCP Cloud Run 模块的 Terraform JSON 文件
- en: ❹ Destroys the GCP Cloud Run service in the testing environment, so you do not
    have a persistent service in your GCP project
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在测试环境中销毁 GCP Cloud Run 服务，这样你就不需要在 GCP 项目中有一个持久的服务
- en: ❺ Uses a pytest fixture to parse the output of the configuration for the service’s
    URL
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 pytest 夹具解析服务 URL 配置的输出
- en: ❻ In the test, makes an API request to the service’s URL using Python’s requests
    library
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在测试中，使用 Python 的 requests 库向服务的 URL 发送 API 请求
- en: ❼ In the test, checks the service’s URL response containing a specific string
    to indicate the service is running
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在测试中，检查包含特定字符串的服务 URL 响应，以指示服务正在运行
- en: AWS and Azure equivalents
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 和 Azure 的等效产品
- en: AWS Fargate with Amazon Elastic Kubernetes Service (EKS) or Azure Container
    Instances (ACI) roughly equates to GCP Cloud Run.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Fargate 与 Amazon Elastic Kubernetes Service (EKS) 或 Azure Container Instances
    (ACI) 大约等同于 GCP Cloud Run。
- en: Note that if you want to run an end-to-end test in production, you do not want
    to delete the service. You usually run end-to-end tests against existing environments
    without creating new or test resources. You apply changes to the existing system
    and run the tests against the active infrastructure resources.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你想在生产环境中运行端到端测试，你不想删除服务。你通常会在现有环境中运行端到端测试，而不是创建新的或测试资源。你将对现有系统应用更改，并在活动基础设施资源上运行测试。
- en: Smoke tests
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: As a type of end-to-end test, a smoke test provides rapid feedback on whether
    a change has broken critical business functionality. Running all end-to-end tests
    can take time, and you need to fix a change failure quickly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种端到端测试，烟雾测试可以快速提供有关更改是否破坏了关键业务功能的反馈。运行所有端到端测试可能需要时间，你需要快速修复更改失败。
- en: If you can run a smoke test first, you can verify that the change has not gone
    catastrophically and proceed with further testing. As a quality assurance analyst
    once told me, “If you power up some hardware and it smokes, you know something
    is wrong. It’s not worth your time to test it further.”
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先运行烟雾测试，你可以验证更改没有造成灾难性的后果，然后继续进行进一步测试。正如一位质量保证分析师曾经告诉我的，“如果你启动一些硬件并且它冒烟，你就知道有问题。不值得你花时间去进一步测试。”
- en: More complex infrastructure systems benefit from end-to-end tests because they
    become the primary indicator of whether a change has affected critical business
    functionality. As a result, they help test composite or singleton configurations.
    You do not usually run end-to-end tests on modules unless they have many resources
    and dependencies.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的系统架构受益于端到端测试，因为它们成为更改是否影响关键业务功能的主要指标。因此，它们有助于测试组合或单例配置。除非模块具有许多资源和依赖项，否则通常不会在模块上运行端到端测试。
- en: I write most of my end-to-end tests for network or compute resources. For example,
    you can write a few tests to check network peering. The tests provision a server
    on each network and check whether the servers can connect.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我为网络或计算资源编写了大部分端到端测试。例如，你可以编写一些测试来检查网络对等。这些测试在每个网络上配置一个服务器，并检查服务器是否可以连接。
- en: Another use case for end-to-end tests involves submitting a job to a workload
    orchestrator and completing it. This test determines whether the workload orchestrator
    functions properly for application deployment. I once included end-to-end tests
    that issued Hypertext Transfer Protocol (HTTP) requests with varying payloads
    to ensure that upstream services could call each other without disruption, no
    matter the payload size or protocol.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的另一个用例是向工作负载协调器提交一个作业并完成它。这个测试确定工作负载协调器是否在应用部署方面正常工作。我曾经包含了一些端到端测试，这些测试使用不同负载的HTTP请求来确保上游服务可以互相调用而不会中断，无论负载大小或协议。
- en: Outside of network or compute use cases, end-to-end tests can verify the expected
    behavior of any system. If you use configuration management with a provisioning
    tool, your end-to-end tests verify that you can connect to the server and run
    the expected functionality. For monitoring and alerts, you can run end-to-end
    tests to simulate the expected system behavior, verify that metrics have been
    collected, and test the triggering of the alert.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络或计算用例之外，端到端测试可以验证任何系统的预期行为。如果你使用配置管理工具进行配置，你的端到端测试将验证你是否可以连接到服务器并运行预期的功能。对于监控和警报，你可以运行端到端测试来模拟预期的系统行为，验证是否已收集指标，并测试警报的触发。
- en: However, end-to-end tests are the most expensive tests to execute in terms of
    time and resources. Most end-to-end tests need every infrastructure resource available
    to fully evaluate the system. As a result, you may run end-to-end tests only against
    production infrastructure. You may not run them in a testing environment because
    it often costs too much money to procure enough resources for the test.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，端到端测试在时间和资源方面是最昂贵的测试。大多数端到端测试需要所有基础设施资源来完全评估系统。因此，你可能只针对生产基础设施运行端到端测试。你可能在测试环境中无法运行它们，因为为测试获取足够的资源通常花费太多金钱。
- en: 6.6 Other tests
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 其他测试
- en: You may encounter other types of tests outside of unit, contract, integration,
    and end-to-end tests. For example, say you want to roll out a configuration change
    to a production server that reduces memory. However, you don’t know whether the
    memory reduction will affect the overall system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到单元、契约、集成和端到端测试之外的测试类型。例如，假设你想要将减少内存的配置更改部署到生产服务器。然而，你不知道内存减少是否会影响整个系统。
- en: Figure 6.14 shows that you can check whether your change affected the system
    by using system monitoring. Monitoring continuously aggregates metrics on the
    server’s memory. If you receive an alert that the server’s memory reaches a percentage
    of its capacity, you know that you may affect the overall system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14显示，你可以通过使用系统监控来检查你的更改是否影响了系统。监控持续聚合服务器内存上的指标。如果你收到服务器内存达到其容量百分比的警报，你知道你可能影响了整个系统。
- en: '![](../../OEBPS/Images/CH06_F14_Wang.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F14_Wang.png)'
- en: Figure 6.14 Continuous tests run at short intervals to verify that a set of
    metrics does not exceed a threshold.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 短时间间隔内运行的连续测试，以验证一组指标是否不超过阈值。
- en: Monitoring implements *continuous testing* with “tests” to check that metrics
    do not exceed thresholds run at regular, frequent intervals.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 监控通过“测试”实现 *连续测试*，以检查指标是否在规律、频繁的时间间隔内超过阈值。
- en: Definition *Continuous tests* (such as monitoring) run at regular, frequent
    intervals to check that the current value matches an expected value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *连续测试*（例如监控）在规律、频繁的时间间隔内运行，以检查当前值是否与预期值匹配。
- en: Continuous testing includes monitoring system metrics and security events (when
    the root user logs into a server). They offer dynamic analysis on an active infrastructure
    environment. Most continuous tests take the form of alerts, which notify you of
    any problems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 连续测试包括监控系统指标和安全事件（当root用户登录到服务器时）。它们在活动基础设施环境中提供动态分析。大多数连续测试以警报的形式出现，通知你任何问题。
- en: You may encounter another type of test called a *regression test*. For example,
    you may run a test over a period of time to check whether your server configuration
    conforms to your organization’s expectations. Regression tests run regularly but
    do not have the frequency of monitoring or other forms of continuous testing.
    You may choose to run them every few weeks or months to check for out-of-band,
    manual changes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到另一种称为**回归测试**的测试类型。例如，你可能会在一段时间内运行测试，以检查你的服务器配置是否符合你组织的期望。回归测试定期运行，但频率低于监控或其他形式的持续测试。你可以选择每隔几周或几个月运行它们，以检查异常情况。
- en: Definition *Regression tests* run periodically over an extended period of time
    to check whether infrastructure configuration conforms to the expected state or
    functionality. They can help mitigate configuration drift.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义**回归测试**在较长时间内定期运行，以检查基础设施配置是否符合预期的状态或功能。它们可以帮助缓解配置漂移。
- en: Continuous and regression tests often require special software or systems to
    run. They ensure that running infrastructure behaves with expected functionality
    and performance. These tests also set a foundation for automating a system to
    respond to anomalies.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 持续和回归测试通常需要特殊的软件或系统来运行。它们确保运行的基础设施具有预期的功能和性能。这些测试还为自动化系统以响应异常奠定了基础。
- en: For example, systems configured with IaC and continuous tests can use autoscaling
    to adjust resources based on the metrics such as CPU or memory. These systems
    can also implement other self-healing mechanisms, such as diverting traffic to
    an older version of an application upon errors.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，配置了基础设施即代码（IaC）和持续测试的系统可以使用自动扩展来根据CPU或内存等指标调整资源。这些系统还可以实施其他自我修复机制，例如在出现错误时将流量重定向到应用程序的旧版本。
- en: 6.7 Choosing tests
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 选择测试
- en: I explained some of the most common tests in infrastructure, from unit tests
    to end-to-end tests. However, do you need to write all of them? Where should you
    spend your time and effort in writing them? Your *infrastructure testing strategy*
    will evolve, depending on the complexity and growth of your system. As a result,
    you will constantly be assessing which tests will help you catch configuration
    issues before production.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我解释了基础设施中最常见的测试，从单元测试到端到端测试。然而，你是否需要编写所有这些测试？你在编写它们时应该在哪里投入时间和精力？你的**基础设施测试策略**将根据你系统的复杂性和增长而演变。因此，你将不断评估哪些测试能帮助你捕捉到生产前的配置问题。
- en: I use a pyramid shape as a *guideline* for infrastructure testing strategy.
    In figure 6.15, the widest part of the pyramid indicates you should have more
    of that type of test, while the narrowest part indicates that you should have
    fewer. At the top of the pyramid are end-to-end tests, which may cost more time
    and money because they require active infrastructure systems. At the bottom of
    the pyramid are unit tests, which run in seconds and do not require entire infrastructure
    systems.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我将金字塔形状作为基础设施测试策略的**指南**。在图6.15中，金字塔最宽的部分表示你应该有更多这种类型的测试，而最窄的部分表示你应该有更少的测试。金字塔的顶部是端到端测试，由于它们需要活跃的基础设施系统，因此可能需要更多的时间和金钱。金字塔的底部是单元测试，它们可以在几秒钟内运行，并且不需要整个基础设施系统。
- en: '![](../../OEBPS/Images/CH06_F15_Wang.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15](../../OEBPS/Images/CH06_F15_Wang.png)'
- en: Figure 6.15 Based on the test pyramid, you should have more unit tests than
    end-to-end tests because it costs less time, money, and resources to run them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 根据测试金字塔，你应该有比端到端测试更多的单元测试，因为运行它们花费的时间、金钱和资源更少。
- en: This guideline, called the *test pyramid*, provides a framework for different
    types of tests, their scope, and frequency. I adapted the test pyramid from software
    testing to infrastructure, modifying it to infrastructure tools and constraints.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个被称为**测试金字塔**的指南为不同类型的测试、它们的范围和频率提供了一个框架。我将测试金字塔从软件测试改编到基础设施，修改了它以适应基础设施工具和约束。
- en: Definition The *test pyramid* serves as a guideline for your overall testing
    strategy. As you go up the pyramid, the type of test will cost more time and money.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 定义**测试金字塔**作为你整体测试策略的指南。随着你向上移动金字塔，测试类型将花费更多的时间和金钱。
- en: In reality, your test pyramid may be shaped more like a rectangle or pear, sometimes
    with missing levels. You *will not* and *should not* write every type of test
    for every infrastructure configuration. At some point, the tests become redundant
    and impractical to maintain.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你的测试金字塔可能更像是一个矩形或梨形，有时会有缺失的层级。你**不会**，**也不应该**为每种基础设施配置编写每种类型的测试。在某个时候，测试变得重复且难以维护。
- en: Depending on the system you want to test, it may not be practical to adhere
    to the test pyramid in its ideal. However, avoid what I jokingly call the *test
    signpost*. A signpost favors many manual tests and not much of anything else.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要测试的系统，可能无法在实际中完全遵循理想的测试金字塔。然而，避免我戏称为*测试路标*的做法。路标倾向于许多手动测试，而其他方面则很少。
- en: 6.7.1 Module-testing strategy
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.1 模块测试策略
- en: I alluded to the practice of testing modules before releasing them in chapter
    5\. Let’s return to that example, where you updated a database module to PostgreSQL
    12\. Rather than manually creating the module and testing to see whether it works,
    you add a series of automated tests. They check for the module’s formatting and
    create a database in an isolated module-testing environment.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我提到了在发布模块之前测试模块的做法。让我们回到那个例子，你更新了一个数据库模块到PostgreSQL 12。而不是手动创建模块并测试其是否工作，你添加了一系列自动化测试。它们检查模块的格式并创建一个在隔离的模块测试环境中的数据库。
- en: Figure 6.16 updates the module release workflow with the unit, contract, and
    integration tests you can add to check that your module works. After the contract
    tests pass, you run an integration test that sets up the database module on a
    network and checks whether the database runs. After completing the integration
    test, you delete the test database created by the module and release the module.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 更新了模块发布工作流程，其中包含了你可以添加以检查模块是否正常工作的单元测试、契约测试和集成测试。在契约测试通过后，你运行一个集成测试，在网络上设置数据库模块并检查数据库是否运行。完成集成测试后，你删除由模块创建的测试数据库并发布模块。
- en: A combination of unit, contract, and integration tests adequately represents
    whether a module will work correctly. Unit tests check for module formatting and
    your team’s standard configurations. You run them first, so you get fast feedback
    on any violations in formatting or configurations.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试、契约测试和集成测试的组合可以充分代表模块是否能够正确工作。单元测试检查模块格式和你的团队的标准配置。你首先运行它们，以便快速获得关于格式或配置违规的反馈。
- en: '![](../../OEBPS/Images/CH06_F16_Wang.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16](../../OEBPS/Images/CH06_F16_Wang.png)'
- en: Figure 6.16 You can break down the testing stage of your module release workflow
    to include unit, contract, and integration tests.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 你可以将模块发布工作流程的测试阶段分解为包括单元测试、契约测试和集成测试。
- en: Next, you run a few contract tests. In the case of the database module, you
    check whether the network ID input to the database module matches the output of
    the network ID from the network module. Catching these mistakes will identify
    problems between dependencies earlier in your deployment process.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你运行一些契约测试。在数据库模块的情况下，你检查输入到数据库模块的网络ID是否与网络模块输出的网络ID匹配。捕捉这些错误将有助于在部署过程中早期识别依赖项之间的问题。
- en: Focus on unit or contract testing to enforce proper configuration, correct module
    logic, and specific inputs and outputs. The testing workflow outlined in figure
    6.16 works best for modules that use the factory, builder, or prototype patterns.
    These patterns isolate the smallest subset of infrastructure components and provide
    a flexible set of variables for your teammates to customize.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于单元测试或契约测试，以确保适当的配置、正确的模块逻辑以及特定的输入和输出。图6.16中概述的测试工作流程最适合使用工厂、构建器或原型模式的模块。这些模式隔离了基础设施组件的最小子集，并为你的队友提供了一组灵活的变量，以便进行定制。
- en: Depending on the cost of your development environment, you can write a few integration
    tests to run against temporary infrastructure resources, which you delete at the
    end of the test. By investing some time and effort into writing tests for modules
    with many inputs and outputs, you ensure that changes do not affect upstream configuration
    and that the module can run successfully on its own.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的开发环境成本，你可以编写一些集成测试，针对临时基础设施资源运行，并在测试结束时删除这些资源。通过投入一些时间和精力来编写具有许多输入和输出的模块的测试，你可以确保更改不会影响上游配置，并且该模块可以独立成功运行。
- en: Exercise 6.1
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.1
- en: You notice that a new version of a load balancer module is breaking your DNS
    configuration. A teammate updated the module to output private IP addresses instead
    of public IP addresses. What can you do to help your team better remember that
    the module needs public IP addresses?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到负载均衡器模块的新版本破坏了你的DNS配置。一位队友更新了该模块，使其输出私有IP地址而不是公共IP地址。你能做些什么来帮助你的团队更好地记住该模块需要公共IP地址？
- en: A) Create a separate load balancer module for private IP addresses.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: A) 为私有IP地址创建一个单独的负载均衡器模块。
- en: B) Add module contract tests to verify that the module outputs both private
    and public IP addresses.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: B) 添加模块合同测试，以验证模块输出私有和公开IP地址。
- en: C) Update the module’s documentation with a note that it needs public IP addresses.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: C) 在模块的文档中添加备注，说明它需要公开IP地址。
- en: D) Run integration tests on the module and check that the IP address is publicly
    accessible.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: D) 在模块上运行集成测试，并检查IP地址是否公开可访问。
- en: See appendix B for answers to exercises.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录B以获取练习的答案。
- en: 6.7.2 Configuration testing strategy
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.2 配置测试策略
- en: Infrastructure configurations for active environments use more complex patterns
    like singleton or composite. A singleton or composite configuration has many infrastructure
    dependencies and often references other modules. Adding end-to-end tests to your
    testing workflow can help identify issues between the infrastructure and modules.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 活动环境的配置使用更复杂的模式，如单例或组合。单例或组合配置有许多基础设施依赖项，并且经常引用其他模块。将端到端测试添加到你的测试工作流程中可以帮助识别基础设施和模块之间的问题。
- en: Imagine you have a singleton configuration with an application server on a network.
    Figure 6.17 outlines each step after you update the size of the server. After
    pushing the change to version control, you deploy the change to a testing environment.
    Your testing workflow begins with unit tests to verify formatting and configuration
    quickly.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个单例配置，其中包含一个网络上的应用服务器。图6.17概述了在更新服务器大小后的每个步骤。在将更改推送到版本控制后，你将更改部署到测试环境。你的测试工作流程从单元测试开始，以快速验证格式和配置。
- en: Next, you run integration tests to apply changes and verify that the server
    still runs and has a new size. You complete your verification by using an end-to-end
    test to test the entire system. The end-to-end test issues an HTTP GET to the
    application endpoint. Figure 6.17 repeats the process in production to ensure
    that the system did not break.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你运行集成测试以应用更改并验证服务器是否仍在运行以及具有新的大小。你通过使用端到端测试来测试整个系统来完成你的验证。端到端测试向应用程序端点发出HTTP
    GET请求。图6.17在生产中重复此过程以确保系统没有损坏。
- en: '![](../../OEBPS/Images/CH06_F17_Wang.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17](../../OEBPS/Images/CH06_F17_Wang.png)'
- en: Figure 6.17 IaC using the singleton and composite patterns should run unit,
    integration, and end-to-end tests in a testing environment before deploying the
    changes to production.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 使用单例和组合模式进行IaC应该在将更改部署到生产之前在测试环境中运行单元、集成和端到端测试。
- en: Just because you created or updated a server successfully does not mean the
    application it hosts can serve requests! With a complex infrastructure system,
    you need additional tests to verify dependencies or communication between infrastructure.
    End-to-end tests can help preserve the functionality of the system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为你成功创建或更新了服务器，并不意味着它所托管的应用程序可以处理请求！在复杂的系统架构中，你需要额外的测试来验证基础设施之间的依赖或通信。端到端测试可以帮助保持系统的功能。
- en: Repeating the same tests between testing and production environments offers
    quality control. If you have any configuration drift between testing and production
    environments, your tests may reflect those differences. You can enable or disable
    specific tests depending on the environment.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试和生产环境之间重复相同的测试提供质量控制。如果你在测试和生产环境之间存在任何配置漂移，你的测试可能会反映这些差异。你可以根据环境启用或禁用特定测试。
- en: Image building and configuration management
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建和配置管理
- en: Tests for image building and configuration management tools follow a similar
    approach to testing the configuration for provisioning tools. Unit testing image
    building or configuration management metadata involves checking configuration.
    You do not need contract tests unless you modularize your configuration management,
    in which you follow the testing approach for modules. Integration tests should
    run in a testing environment, either to test that the server successfully starts
    with a new image or applies the correct configuration. End-to-end tests ensure
    that your new images and configurations do not impact the functionality of the
    system.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建和配置管理工具的测试遵循与测试配置工具配置类似的方法。单元测试镜像构建或配置管理元数据涉及检查配置。除非你模块化配置管理，并遵循模块的测试方法，否则你不需要合同测试。集成测试应在测试环境中运行，以测试服务器是否能够使用新镜像成功启动或应用正确的配置。端到端测试确保你的新镜像和配置不会影响系统的功能。
- en: Exercise 6.2
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 练习6.2
- en: You add firewall rules to allow an application to access a new queue. Which
    combination of tests would be most valuable to your team for the change?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加防火墙规则以允许应用程序访问新的队列。对于这个更改，哪种测试组合对你的团队最有价值？
- en: A) Unit and integration tests
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: A) 单元和集成测试
- en: B) Contract and end-to-end tests
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: B) 合同和端到端测试
- en: C) Contract and integration tests
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: C) 合同和集成测试
- en: D) Unit and end-to-end tests
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: D) 单元和端到端测试
- en: See appendix B for answers to exercises.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录B以获取练习的答案。
- en: 6.7.3 Identifying useful tests
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7.3 识别有用的测试
- en: The testing strategies for modules and configurations can help guide your initial
    approach to writing valuable tests. Figure 6.18 summarizes the types of tests
    you might consider for modules and configurations. Modules rely on unit, contract,
    and integration tests, while configurations rely on unit, integration, and end-to-end
    tests.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和配置的测试策略可以帮助指导你编写有价值测试的初始方法。图6.18总结了你可能考虑用于模块和配置的测试类型。模块依赖于单元、合同和集成测试，而配置依赖于单元、集成和端到端测试。
- en: '![](../../OEBPS/Images/CH06_F18_Wang.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F18_Wang.png)'
- en: Figure 6.18 Your testing approach will differ depending on whether you write
    a module or environment configuration.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 你编写模块或环境配置时，你的测试方法会有所不同。
- en: How do you know *when* to write a test? Imagine your teammate might know that
    a database password needs to have alphanumeric characters with a 16-character
    limit. However, you might not know this fact until you update a 24-character password,
    deploy the change, and wait five minutes for the change to fail.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道何时编写测试？想象一下，你的队友可能知道数据库密码需要是16位数的字母数字字符。然而，你可能直到更新一个24位密码、部署更改并等待五分钟以查看更改是否失败，才知道这个事实。
- en: I consider the practice of updating your tests a matter of turning unknown knowns
    into known knowns in your system. After all, you use observability to debug unknown
    unknowns and monitoring to track the known unknowns. In figure 6.19, you convert
    siloed knowledge (unknown knowns) that someone else knows into tests (known knowns)
    for team knowledge. New tests often reflect siloed knowledge that the team should
    know and acknowledge.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为更新测试的做法是将系统中的未知已知转化为已知已知。毕竟，你使用可观察性来调试未知未知，使用监控来跟踪已知未知。在图6.19中，你将其他人可能知道但孤立的（未知已知）知识转化为测试（已知已知），以反映团队的知识。新的测试通常反映了团队应该知道并承认的孤岛知识。
- en: '![](../../OEBPS/Images/CH06_F19_Wang.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F19_Wang.png)'
- en: Figure 6.19 Infrastructure testing converts siloed knowledge, something someone
    else might know, into a test to reflect the team’s knowledge.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19展示了基础设施测试如何将孤岛知识（其他人可能知道的知识）转化为测试，以反映团队的知识。
- en: A good test shares knowledge to the rest of the team. You don’t always need
    to build a new test. Instead, you might find an existing test that doesn’t check
    for everything. Use a test to prevent your team from repeating problems.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试会将知识分享给团队的其他成员。你不必总是构建一个新的测试。相反，你可能找到一个现有的测试，它没有检查所有内容。使用测试来防止你的团队重复出现相同的问题。
- en: Besides adding tests, you’ll remove tests. You might write a test and discover
    that it fails half the time. It does not provide helpful information or increase
    your confidence in the system because of its unreliability. Removing the test
    cleans up your testing suite and helps eliminate flaky tests that constantly fail
    but do not indicate a true failure in the system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加测试，你还将移除测试。你可能编写了一个测试，但发现它有一半的时间会失败。由于其不可靠性，它并没有提供有用的信息，也没有增加你对系统的信心。移除测试可以清理你的测试套件，并帮助消除那些经常失败但并不表明系统真正失败的不可靠测试。
- en: Furthermore, you’ll remove tests because you don’t need them. For example, you
    might not need contract tests for every module, or integration tests for every
    environment configuration. Always ask yourself if the tests provide value and
    if they run reliably enough for you to get sufficient information about the system.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将移除测试，因为你可能不需要它们。例如，你可能不需要为每个模块编写合同测试，或者为每个环境配置编写集成测试。始终问自己测试是否提供了价值，以及它们是否运行得足够可靠，以便你能够获得足够的信息来了解系统。
- en: The next chapter shows how to add tests to a delivery pipeline for your IaC.
    Even if you do not choose to automate the testing workflow, you have an opportunity
    to examine how changes could potentially affect your infrastructure.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将展示如何为你的IaC添加测试到交付管道。即使你选择不自动化测试工作流程，你也有机会检查更改可能如何影响你的基础设施。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The test pyramid outlines an approach to testing. The higher the test level
    in the pyramid, the more costly the test.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔概述了一种测试方法。金字塔中测试级别越高，测试成本越高。
- en: Unit tests verify static parameters in modules or configurations.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试验证模块或配置中的静态参数。
- en: Contract tests verify that the inputs and outputs of a module match expected
    values and formats.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合同测试验证模块的输入和输出是否与预期值和格式匹配。
- en: Integration tests create test resources, verify their configuration and creation,
    and delete them.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试创建测试资源，验证其配置和创建，然后删除它们。
- en: End-to-end tests verify that the end user of an infrastructure system can run
    the expected functionality.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试验证基础设施系统的最终用户能否运行预期的功能。
- en: Modules using factory, builder, or prototype patterns benefit from unit, contract,
    and integration tests.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂、构建器或原型模式的模块可以从单元、合同和集成测试中受益。
- en: Configurations using composite or singleton patterns applied to environments
    benefit from unit, integration, and end-to-end tests.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在环境中应用组合或单例模式配置可以从单元、集成和端到端测试中受益。
- en: Other tests include monitoring for continuously testing system metrics, regression
    tests for out-of-band manual changes, or security tests for misconfigurations.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他测试包括持续监测系统指标、回归测试用于处理带外手动更改，或安全测试用于配置错误。
