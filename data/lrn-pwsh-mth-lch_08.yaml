- en: '8 Objects: Data by another name'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 对象：另一种名称的数据
- en: We’re going to do something a little different in this chapter. PowerShell’s
    use of objects can be one of its most confusing elements, but at the same time
    it’s also one of the shell’s most critical concepts, affecting everything you
    do in the shell. We’ve tried various explanations over the years, and we’ve settled
    on a couple that each work well for distinctly different audiences. If you have
    programming experience and are comfortable with the concept of objects, we want
    you to skip to section 8.2\. If you don’t have a programming background and haven’t
    programmed or scripted with objects before, start with section 8.1 and read straight
    through the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做一些不同的事情。PowerShell对对象的使用可能是它最令人困惑的元素之一，但与此同时，它也是shell中最关键的概念之一，影响着你在shell中做的每一件事。多年来，我们尝试了各种解释，并最终选择了几个针对不同受众都效果良好的解释。如果你有编程经验并且对对象的概念感到舒适，我们希望你跳到第8.2节。如果你没有编程背景，之前也没有使用对象进行编程或脚本编写，请从第8.1节开始，并直接阅读整章。
- en: 8.1 What are objects?
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 什么是对象？
- en: Take a second to run `Get-Process` in PowerShell. You should see a table with
    several columns, but those columns barely scratch the surface of the wealth of
    information available about processes. Each process object also has a machine
    name, a main window handle, a maximum working set size, an exit code and time,
    processor affinity information, and a great deal more. You’ll find more than 60
    pieces of information associated with a process. Why does PowerShell show so few
    of them?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间在PowerShell中运行`Get-Process`。你应该会看到一个包含多个列的表格，但这些列只是触及了关于进程的丰富信息的表面。每个进程对象还有一个机器名、主窗口句柄、最大工作集大小、退出代码和时间、处理器亲和力信息等等。你会发现与进程相关联的信息超过60条。为什么PowerShell只显示这么少的信息呢？
- en: The simple fact is that *most* of the things PowerShell can access offer more
    information than will comfortably fit on the screen. When you run any command,
    such as `Get-Process`, `Get-AzVm`, or `Get-AzStorageBlob`, PowerShell constructs—entirely
    in memory—a table that contains all of the information about those items. For
    `Get-Process`, that table consists of something like 67 columns, with one row
    for each process that’s running on your computer. Each column contains a bit of
    information, such as virtual memory, CPU utilization, process name, process ID,
    and so on. Then PowerShell looks to see whether you’ve specified which of those
    columns you want to view. If you haven’t, the shell looks up a configuration file
    provided by Microsoft and displays only those table columns that Microsoft thinks
    you want to see.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实简单来说就是，PowerShell可以访问的*大多数*事物提供的信息比屏幕上能舒适显示的还要多。当你运行任何命令，例如`Get-Process`、`Get-AzVm`或`Get-AzStorageBlob`时，PowerShell完全在内存中构建一个包含那些项目所有信息的表格。对于`Get-Process`，这个表格包含大约67列，每列对应你电脑上运行的一个进程。每一列包含一些信息，例如虚拟内存、CPU利用率、进程名称、进程ID等等。然后PowerShell会查看你是否指定了想要查看的列。如果你没有指定，shell会查找由Microsoft提供的配置文件，并仅显示Microsoft认为你想要看到的表格列。
- en: 'One way to see all of the columns is to use `ConvertTo-Html`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一种查看所有列的方法是使用`ConvertTo-Html`：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That cmdlet doesn’t bother filtering the columns. Instead, it produces an HTML
    file that contains all of them. That’s one way to see the entire table.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该cmdlet不会过滤列。相反，它生成一个包含所有列的HTML文件。这是查看整个表格的一种方法。
- en: In addition to all of those columns of information, each table row has actions
    associated with it. Those actions include what the operating system can do to,
    or with, the process listed in that table row. For example, the operating system
    can close a process, kill it, refresh its information, or wait for the process
    to exit, among other things.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些信息列之外，每一行表格都与一些操作相关联。这些操作包括操作系统可以对表格中列出的进程执行或与之相关的操作。例如，操作系统可以关闭进程、终止它、刷新其信息或等待进程退出等等。
- en: Anytime you run a command that produces output, that output takes the form of
    a table in memory. When you pipe output from one command to another, like this
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你运行产生输出的命令，该输出都以内存中的表格形式存在。当你将一个命令的输出通过管道传递到另一个命令时，就像这样
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: the entire table is passed through the pipeline. The table isn’t filtered down
    to a smaller number of columns until every command has run.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 整个表格都会通过管道传递。表格不会过滤到更少的列，直到每个命令都运行完毕。
- en: 'Now for some terminology changes. PowerShell doesn’t refer to this in-memory
    table as a *table*. Instead, it uses these terms:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一些术语上的变化。PowerShell不会将这个内存中的表格称为表格。相反，它使用以下术语：
- en: '*Object*—This is what we’ve been calling a *table row*. It represents a single
    thing, such as a single process or a single storage account.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象*——这是我们所说的表格行。它代表单个事物，例如单个进程或单个存储账户。'
- en: '*Property*—This is what we called a *table column*. It represents one piece
    of information about an object, such as a process name, a process ID, or a VM’s
    running status.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*属性*——这是我们所说的表格列。它代表关于一个对象的信息的一部分，例如进程名称、进程ID或虚拟机的运行状态。'
- en: '*Method*—This is what we called an *action*. A method is related to a single
    object and makes that object do something—for example, killing a process or starting
    a VM.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*方法*——这是我们所说的动作。方法与单个对象相关联，并使该对象执行某些操作——例如，终止进程或启动虚拟机。'
- en: '*Collection*—This is the entire set of objects, or what we’ve been calling
    a *table*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集合*——这是整个对象集合，或者我们称之为表格。'
- en: If you find the following discussion on objects to be confusing, refer to this
    four-point list. Always imagine a *collection* of objects as being a big, in-memory
    table of information, with *properties* as the columns and individual *objects*
    as the rows (figure 8.1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现以下关于对象的讨论令人困惑，请参考以下四点清单。始终想象一个*集合*的对象是一个大型的内存中的信息表，其中*属性*是列，而单个*对象*是行（图8.1）。
- en: '![](Images/CH08_F01_Plunk.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH08_F01_Plunk.png)'
- en: Figure 8.1 Showing that the object (file) has multiple properties such as `Author`
    and `FileType`
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 展示对象（文件）具有多个属性，如`Author`和`FileType`
- en: 8.2 Understanding why PowerShell uses objects
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 理解PowerShell使用对象的原因
- en: One of the reasons that PowerShell uses objects to represent data is that, well,
    you have to represent data *somehow*, right? PowerShell could have stored that
    data in a format such as XML, or perhaps its creators could have decided to use
    plain-text tables. But they had specific reasons for not taking those routes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell使用对象来表示数据的一个原因是，毕竟，你必须以某种方式表示数据，对吧？PowerShell本可以将数据存储为XML格式，或者也许它的创造者可能决定使用纯文本表格。但他们有特定的原因不选择这些路径。
- en: The first reason is due to PowerShell’s history of previously being Windows-only.
    Windows itself is an object-oriented operating system—or at least, most of the
    software that runs on Windows is object-oriented. Choosing to structure data as
    a set of objects is easy, because most of the operating system lends itself to
    those structures. As it turns out, we can apply that object-oriented mindset to
    other operating systems, and even other paradigms like the cloud and DevOps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是由于PowerShell之前的历史，它曾经是仅限Windows使用的。Windows本身是一个面向对象的操作系统——至少，在Windows上运行的大多数软件都是面向对象的。选择将数据结构化为对象集合是很容易的，因为操作系统的大部分功能都适合这些结构。实际上，我们可以将面向对象的思想应用到其他操作系统，甚至应用到云和DevOps等其他范式。
- en: 'Another reason to use objects is that they ultimately make things easier on
    you and give you more power and flexibility. For the moment, let’s pretend that
    PowerShell doesn’t produce objects as the output of its commands. Instead, it
    produces simple text tables, which is what you probably thought it was doing in
    the first place. When you run a command such as `Get-Process`, you’re getting
    formatted text as the output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象的另一个原因是它们最终使你的工作变得更简单，并赋予你更多的权力和灵活性。暂时假设PowerShell的命令不会以对象的形式输出。相反，它以简单的文本表格的形式输出，这可能是你最初认为它正在做的事情。当你运行`Get-Process`这样的命令时，你得到的是格式化的文本输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if you want to do something else with this information? Perhaps you want
    to make a change to all of the processes running `Code`. To do this, you have
    to filter the list a bit. On UNIX or Linux, you might try to use a command such
    as `grep` (which you *could* run in PowerShell, by the way!), telling it, “Look
    at this text list for me. Keep only those rows where columns 58–64 contain the
    characters `Code`. Delete all of the other rows.” The resulting list contains
    only those processes you specified:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用这些信息做其他事情呢？也许你想要更改所有正在运行的`Code`进程。为此，你需要对列表进行一些筛选。在UNIX或Linux系统上，你可能尝试使用`grep`命令（顺便说一句，你可以在PowerShell中运行它！），告诉它，“为我查看这个文本列表。只保留那些第58至64列包含字符`Code`的行。删除所有其他行。”结果列表中只包含你指定的进程：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You then pipe that text to another command, perhaps telling it to extract the
    process ID from the list. “Go through this and get the characters from columns
    52–56, but drop the first two (header) rows.” The result might be this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将文本传递给另一个命令，可能告诉它从列表中提取进程ID。“遍历这个列表，从第52到第56列获取字符，但丢弃前两行（标题行）。”结果可能如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, you pipe *that* text to yet *another* command, asking it to kill the
    processes (or whatever else you were trying to do) represented by those ID numbers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将*那个*文本传递给另一个命令，要求它终止由那些ID号表示的进程（或你试图做的其他任何事情）。
- en: 'This is exactly how IT professionals that use `bash` work. They spend a lot
    of time learning how to get better at parsing text; using tools such as `grep`,
    `awk`, and `sed`; and becoming proficient in the use of regular expressions. Going
    through this learning process makes it easier for them to define the text patterns
    they want their computer to look for. In the old days before PowerShell was cross-platform,
    UNIX and Linux IT professionals would rely on scripting languages like Perl and
    Python, which have more batteries included in terms of text parsing. But this
    text-based approach does present some problems:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是使用`bash`的IT专业人士的工作方式。他们花费大量时间学习如何更好地解析文本；使用`grep`、`awk`和`sed`等工具；并精通正则表达式的使用。通过这个过程的学习，他们更容易定义他们想要计算机查找的文本模式。在PowerShell跨平台之前的日子里，UNIX和Linux
    IT专业人士会依赖于像Perl和Python这样的脚本语言，这些语言在文本解析方面提供了更多的功能。但这种方法确实存在一些问题：
- en: You can spend more time messing around with text than doing your real job.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会花更多的时间在文本上，而不是做你的本职工作。
- en: If the output of a command changes—say, moving the ProcessName column to the
    start of the table—then you have to rewrite all of your commands, because they’re
    all dependent on things like column positions.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命令的输出发生了变化——比如说，将ProcessName列移动到表格的开始位置——那么你必须重写所有的命令，因为它们都依赖于诸如列位置之类的因素。
- en: You have to become proficient in languages and tools that parse text—not because
    your job involves parsing text, but because parsing text is a means to an end.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须精通解析文本的语言和工具——不是因为你的工作涉及解析文本，而是因为解析文本是实现目标的一种手段。
- en: Languages like Perl and Python are solid scripting languages . . . but are not
    shells as well.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Perl和Python这样的语言是可靠的脚本语言……但它们并不是shell。
- en: PowerShell’s use of objects helps to remove all of that text-manipulation overhead.
    Because objects work like tables in memory, you don’t have to tell PowerShell
    which text column a piece of information is located at. Instead, you tell it the
    column name, and PowerShell knows exactly where to go to get that data. Regardless
    of how you arrange the final output on the screen or in a file, the in-memory
    table is always the same, so you never have to rewrite your commands because a
    column moved. You spend a lot less time on overhead tasks and more time focusing
    on what you want to accomplish.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell使用对象有助于消除所有这些文本操作的开销。因为对象在内存中像表格一样工作，你不必告诉PowerShell信息所在的文本列。相反，你只需告诉它列名，PowerShell就能准确地知道去哪里获取那些数据。无论你如何安排最终在屏幕或文件中的输出，内存中的表格总是相同的，所以你永远不需要因为列的移动而重写命令。你将花费更少的时间在开销任务上，更多的时间专注于你想要完成的事情。
- en: True, you do have to learn a few syntax elements that let you properly instruct
    PowerShell, but you have to learn a *lot* less than if you were working in a purely
    text-based shell.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，你必须学习一些语法元素，以便正确地指导PowerShell，但你必须学习的比在纯文本shell中工作时要少得多。
- en: DON’T GET MAD None of the preceding is intended as a dig at Bash, Perl, or Python,
    by the way. Every tool has pros and cons. Python is a great general-purpose programming
    language that has even found its way into the machine learning and artificial
    intelligence space—but that’s not why you’re reading this book. You’re looking
    for something to up your game as an IT professional, and PowerShell is the perfect
    tool for it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要生气** 顺便说一下，前面提到的内容并不是在贬低Bash、Perl或Python。每个工具都有其优缺点。Python是一种伟大的通用编程语言，甚至已经进入机器学习和人工智能领域——但这并不是你阅读这本书的原因。你是在寻找能够提升你作为IT专业人士技能的东西，而PowerShell正是这样的工具。'
- en: '8.3 Discovering objects: Get-Member'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 发现对象：Get-Member
- en: If objects are like a giant table in memory, and PowerShell shows you only a
    portion of that table on the screen, how can you see what else you have to work
    with? If you’re thinking that you should use the `Get-Help` command, we’re glad,
    because we’ve certainly been pushing that down your throat in the previous few
    chapters. But unfortunately, you’d be wrong.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象在内存中就像一个巨大的表格，而 PowerShell 只在屏幕上显示表格的一部分，你怎么能看到你还有哪些可以操作的呢？如果你认为你应该使用 `Get-Help`
    命令，我们很高兴，因为我们确实在前面几章中一直在推荐这个命令。但不幸的是，你会错的。
- en: 'The help system documents only background concepts (in the form of the about
    topics) and command syntax. To learn more about an object, you use a different
    command: `Get-Member`. You should become comfortable using this command—so much
    so, that you start looking for a shorter way to type it. We’ll give you that right
    now: the alias `gm`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助系统仅记录背景概念（以 about 主题的形式）和命令语法。要了解更多关于对象的信息，你使用不同的命令：`Get-Member`。你应该习惯使用这个命令——如此习惯，以至于你开始寻找更简短的输入方式。我们现在就给你：别名
    `gm`。
- en: 'You can use `gm` after any cmdlet that normally produces output. For example,
    you already know that running `Get-Process` produces output on the screen. You
    can pipe it to `gm`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何通常产生输出的 cmdlet 后面使用 `gm`。例如，你已经知道运行 `Get-Process` 会在屏幕上产生输出。你可以将其管道化到
    `gm`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whenever a cmdlet produces a collection of objects, as `Get-Process` does,
    the entire collection remains accessible until the end of the pipeline. It’s not
    until every command has run that PowerShell filters the columns of information
    to be displayed and creates the final text output you see. Therefore, in the preceding
    example, `gm` has complete access to all of the process objects’ properties and
    methods, because they haven’t been filtered for display yet. `gm` looks at each
    object and constructs a list of the objects’ properties and methods. It looks
    like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 cmdlet 产生一系列对象，就像 `Get-Process` 所做的那样，整个集合在管道的末端之前都是可访问的。只有在每个命令都运行之后，PowerShell
    才会过滤要显示的信息列并创建你看到的最终文本输出。因此，在上面的例子中，`gm` 对所有进程对象的属性和方法都有完全的访问权限，因为它们还没有被过滤以供显示。`gm`
    会查看每个对象并构建一个包含对象属性和方法的列表。它看起来像这样：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve trimmed the preceding list because it’s long, but hopefully you get the
    idea.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经缩减了前面的列表，因为它很长，但希望你能理解这个概念。
- en: Try it Now Don’t take our word for it. This is the perfect time to follow along
    and run the same commands we do, to see their complete output.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试 不要只听我们的话。现在是跟随我们运行相同的命令并查看它们完整输出的完美时机。
- en: By the way, it may interest you to know that all of the properties, methods,
    and other things attached to an object are collectively called its *members*,
    as if the object itself were a country club and all of these properties and methods
    belonged to the club. That’s where `Get-Member` takes its name from—it’s getting
    a list of the objects’ members. But remember, because the PowerShell convention
    is to use singular nouns, the cmdlet name is `Get-Member`, not `Get-Members`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你可能想知道，所有附加到对象上的属性、方法和其他东西统称为该对象的 *members*，就像对象本身是一个俱乐部，所有这些属性和方法都属于这个俱乐部。这就是
    `Get-Member` 命令名称的由来——它正在获取对象成员的列表。但请记住，因为 PowerShell 习惯于使用单数名词，所以 cmdlet 名称是
    `Get-Member`，而不是 `Get-Members`。
- en: Important It’s easy to overlook, but pay attention to the first line of output
    from `Get-Member`. It’s `TypeName`, which is the unique name assigned to that
    particular type of object. It may seem unimportant now—after all, who cares what
    it’s named? But it’s going to become crucial in the next chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项 它很容易被忽视，但请注意 `Get-Member` 命令输出的第一行。它是 `TypeName`，这是分配给该特定类型对象的唯一名称。现在可能看起来并不重要——毕竟，谁在乎它叫什么名字呢？但它在下一章中将会变得至关重要。
- en: 8.4 Using object attributes, or properties
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用对象属性，或属性
- en: 'When you examine the output of `gm`, you’ll notice several kinds of properties:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查 `gm` 的输出时，你会注意到几种不同的属性：
- en: '`ScriptProperty`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScriptProperty`'
- en: '`Property`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Property`'
- en: '`NoteProperty`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoteProperty`'
- en: '`AliasProperty`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AliasProperty`'
- en: Above and beyond
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Normally, objects in .NET—which is where all of PowerShell’s objects come from—have
    only properties. PowerShell dynamically adds the other stuff: `ScriptProperty`,
    `NoteProperty`, `AliasProperty`, and so on. If you happen to look up an object
    type in Microsoft’s documentation (you can plug the object’s `TypeName` into your
    favorite search engine to find the docs.microsoft.com page), you won’t see these
    extra properties.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，.NET 中的对象——所有 PowerShell 对象都来自这里——只有属性。PowerShell 动态添加其他内容：`ScriptProperty`、`NoteProperty`、`AliasProperty`
    等等。如果你在微软的文档中查找一个对象类型（你可以将对象的 `TypeName` 插入你喜欢的搜索引擎以找到 docs.microsoft.com 页面），你不会看到这些额外的属性。
- en: PowerShell has an extensible type system (ETS) that’s responsible for adding
    these last-minute properties. Why does it do this? In some cases, it’s to make
    objects more consistent, such as adding a `Name` property to objects that natively
    have only something like `ProcessName` (that’s what an `AliasProperty` is for).
    Sometimes it’s to expose information that’s deeply buried in the object (process
    objects have a few `ScriptProperties` that do this).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有一个可扩展的类型系统（ETS），它负责添加这些最后的属性。为什么它会这样做呢？在某些情况下，是为了使对象更加一致，例如为只具有类似
    `ProcessName`（这就是 `AliasProperty` 的用途）的对象添加一个 `Name` 属性。有时是为了暴露对象中深深隐藏的信息（进程对象有几个
    `ScriptProperties` 用于此目的）。
- en: 'Once you’re in PowerShell, these properties all behave the same way. But don’t
    be surprised when they don’t show up on the official documentation page: the shell
    adds these extras, often to make your life easier.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入 PowerShell，这些属性的行为方式都是相同的。但当你发现它们没有出现在官方文档页面上时，不要感到惊讶：shell 添加了这些额外的功能，通常是为了使你的生活更轻松。
- en: For your purposes, these properties are all the same. The only difference is
    in how the properties were originally created, but that’s not something you need
    to worry about. To you, they’re all properties, and you’ll use them the same way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的用途来说，这些属性都是相同的。唯一的区别在于属性最初是如何创建的，但这不是你需要担心的事情。对你来说，它们都是属性，你将以相同的方式使用它们。
- en: 'A property always contains a value. For example, the value of a process object’s
    `ID` property might be `1234`, and the `Name` property of that object might have
    a value of `Code`. Properties describe something about the object: its status,
    its ID, its name, and so on. In PowerShell, properties are often read-only, meaning
    you can’t change the name of a service by assigning a new value to its `Name`
    property. But you can retrieve the name of a service by reading its `Name` property.
    We estimate that 90% of what you’ll do in PowerShell will involve properties.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 属性总是包含一个值。例如，进程对象的 `ID` 属性的值可能是 `1234`，而该对象的 `Name` 属性的值可能是 `Code`。属性描述了关于对象的一些信息：其状态、其
    ID、其名称等等。在 PowerShell 中，属性通常是只读的，这意味着你不能通过为其 `Name` 属性分配新值来更改服务的名称。但你可以通过读取其 `Name`
    属性来检索服务的名称。我们估计，你将在 PowerShell 中做的 90% 的工作都涉及到属性。
- en: 8.5 Using object actions, or methods
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用对象操作或方法
- en: Many objects support one or more methods, which, as we mentioned earlier, are
    actions that you can direct the object to take. A process object has a `Kill`
    method, which terminates the process. Some methods require one or more input arguments
    that provide additional details for that particular action, but you won’t be running
    into any of those this early in your PowerShell education. You may spend months
    or even years working with PowerShell and never need to execute a single object
    method. That’s because many of those actions are also provided by cmdlets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对象支持一个或多个方法，正如我们之前提到的，这些方法是你可以指示对象执行的操作。进程对象有一个 `Kill` 方法，它可以终止进程。一些方法需要一个或多个输入参数，这些参数为该特定操作提供额外的详细信息，但在这个
    PowerShell 教育的早期阶段，你不会遇到这些。你可能会花几个月甚至几年时间使用 PowerShell，但可能永远不需要执行单个对象方法。这是因为许多这些操作也由
    cmdlet 提供。
- en: 'For example, if you need to terminate a process, you have three ways to do
    so. One way is to retrieve the object and then somehow execute its `Kill` method.
    Another way is to use a couple of cmdlets:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要终止一个进程，你有三种方法可以做到。一种方法是通过检索对象然后以某种方式执行其 `Kill` 方法。另一种方法是使用几个 cmdlet：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also accomplish that by using a single cmdlet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用单个 cmdlet 来完成这个操作：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our focus in this book is entirely on using PowerShell cmdlets to accomplish
    tasks. They provide the easiest, most IT professional–centric, most task-focused
    way of accomplishing things. Using methods starts to edge into .NET programming,
    which can be more complicated and can require a lot more background information.
    For that reason, you’ll rarely—if ever—see us execute an object method in this
    book. Our general philosophy at this point is, “If you can’t do it with a cmdlet,
    go back and use the GUI.” You won’t feel that way for your entire career, we promise,
    but for now it’s a good way to stay focused on the “PowerShell way” of doing things.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要关注点是使用 PowerShell cmdlets 完成任务。它们提供了最简单、最以 IT 专业人士为中心、最以任务为导向的方式来实现目标。使用方法开始逐渐涉及
    .NET 编程，这可能更复杂，可能需要更多的背景信息。因此，你很少——如果有的话——会看到我们在本书中执行对象方法。我们现在的普遍哲学是，“如果你不能用 cmdlet
    完成，就回去使用 GUI。”我们承诺，你不会在整个职业生涯中都这样感觉，但现在这是一个保持对“PowerShell 方式”做事的关注的好方法。
- en: Above and beyond
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: You don’t need to know about them at this stage in your PowerShell education,
    but in addition to properties and methods, objects can also have events. An event
    is an object’s way of notifying you that something happened to it. A process object,
    for example, can trigger its `Exited` event when the process ends. You can attach
    your own commands to those events, so that, for example, an email is sent when
    a process exits. Working with events in this fashion is an advanced topic that’s
    beyond the scope of this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 PowerShell 教育的这个阶段，你不需要了解它们，但除了属性和方法之外，对象还可以有事件。事件是对象通知你发生了某种事情的方式。例如，进程对象可以在进程结束时触发其
    `Exited` 事件。你可以将你自己的命令附加到这些事件上，例如，当进程退出时发送电子邮件。以这种方式处理事件是一个高级主题，超出了本书的范围。
- en: 8.6 Sorting objects
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 对象排序
- en: Most PowerShell cmdlets produce objects in a deterministic fashion, which means
    that they tend to produce objects in the same order every time you run the command.
    Both Azure VMs and processes, for example, are listed in alphabetical order by
    name. What if we want to change that?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 PowerShell cmdlets 以确定性的方式生成对象，这意味着它们倾向于在每次运行命令时以相同的顺序生成对象。例如，Azure VM 和进程都是按名称的字母顺序列出的。如果我们想改变这一点怎么办？
- en: 'Suppose we want to display a list of processes, with the biggest consumers
    of CPU at the top of the list and the smallest consumers at the bottom. We need
    to somehow reorder that list of objects based on the `CPU` property. PowerShell
    provides a simple cmdlet, `Sort-Object`, that does exactly that:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要显示一个进程列表，将 CPU 消耗最大的进程放在列表顶部，最小的消耗者放在底部。我们需要根据 `CPU` 属性重新排序这个对象列表。PowerShell
    提供了一个简单的 cmdlet，`Sort-Object`，它正好可以做到这一点：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Try it Now We’re hoping that you’ll follow along and run the commands in this
    chapter. We aren’t pasting the output into the book because these tables are long.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 我们希望你能跟随并运行本章中的命令。我们不会将输出粘贴到书中，因为这些表格很长。
- en: That command isn’t exactly what we want. It does sort on CPU, but it does so
    in ascending order, with the largest values at the bottom of the list. Reading
    the help for `Sort-Object`, we see that it has a `-Descending` parameter that
    should reverse the sort order. We also notice that the `-Property` parameter is
    positional, so we don’t need to type the parameter name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令并不完全符合我们的要求。它确实按 CPU 排序，但它是以升序排序的，最大的值在列表底部。阅读 `Sort-Object` 的帮助，我们看到它有一个
    `-Descending` 参数，可以反转排序顺序。我们还注意到 `-Property` 参数是位置参数，因此我们不需要输入参数名。
- en: We abbreviated `-Descending` to `-desc`, and we have the result we want. The
    `-Property` parameter accepts multiple values (which we’re sure you saw in the
    help file, if you looked).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `-Descending` 缩写为 `-desc`，我们得到了我们想要的结果。`-Property` 参数接受多个值（我们确信如果你查看了帮助文件，你会看到）。
- en: 'In the event that two processes are using the same amount of virtual memory,
    we want them sorted by process ID, and the following command accomplishes that:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个进程使用了相同数量的虚拟内存，我们希望它们按进程ID排序，以下命令可以完成这个任务：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As always, a comma-separated list is the way to pass multiple values to any
    parameter that supports them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，逗号分隔的列表是传递多个值给任何支持它们的参数的方式。
- en: 8.7 Selecting the properties you want
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 选择你想要的属性
- en: 'Another useful cmdlet is `Select-Object`. It accepts objects from the pipeline,
    and you can specify the properties that you want displayed. This enables you to
    access properties that are normally filtered out by PowerShell’s configuration
    rules, or to trim down the list to a few properties that interest you. This can
    be useful when piping objects to `ConvertTo-HTML`, because that cmdlet usually
    builds a table containing every property. Compare the results of these two commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的cmdlet是`Select-Object`。它接受来自管道的对象，你可以指定你想要显示的属性。这使你能够访问通常由PowerShell的配置规则过滤掉的性质，或者将列表缩减到你感兴趣的一两个属性。这在将对象传递给`ConvertTo-HTML`时非常有用，因为该cmdlet通常构建包含每个属性的表格。比较以下两个命令的结果：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Try it Now Go ahead and run each of these commands separately, and then examine
    the resulting HTML files in a web browser to see the differences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试试吧，分别运行这些命令，然后在网页浏览器中查看生成的HTML文件以查看差异。
- en: 'Look at the help for `Select-Object` (or you can use its alias, `Select`).
    The `-Property` parameter is positional, which means we could shorten that last
    command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于`Select-Object`的帮助（或者你可以使用它的别名`Select`）。`-Property`参数是位置参数，这意味着我们可以缩短最后一个命令：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Spend some time experimenting with `Select-Object`. Try variations of the following
    command, which allows the output to appear on the screen:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间实验`Select-Object`。尝试以下命令的变体，它允许输出显示在屏幕上：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try adding and removing different process object properties from that list and
    reviewing the results. How many properties can you specify and still get a table
    as the output? How many properties force PowerShell to format the output as a
    list rather than as a table?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从该列表中添加和删除不同的进程对象属性，并查看结果。你能指定多少个属性仍然得到表格作为输出？有多少个属性会强制PowerShell将输出格式化为列表而不是表格？
- en: Above and beyond
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: '`Select-Object` also has `-First` and `-Last` parameters, which let you keep
    a subset of the objects in the pipeline. For example, `Get-Process` `|` `Select`
    `-First` `10` keeps the first 10 objects. There are no criteria involved, such
    as keeping certain processes; it’s merely grabbing the first (or last) 10.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select-Object`也有`-First`和`-Last`参数，这让你可以保留管道中的对象子集。例如，`Get-Process` `|` `Select`
    `-First` `10`保留前10个对象。这里没有涉及任何标准，例如保留某些进程；它只是获取前（或后）10个。'
- en: 'Caution People often get mixed up about two PowerShell commands: `Select-Object`
    and `Where-Object`, which you haven’t seen yet. `Select-Object` is used to choose
    the properties (or columns) you want to see, and it can also select an arbitrary
    subset of output rows (using `-First` and `-Last`). `Where-Object` removes, or
    filters, objects out of the pipeline based on criteria you specify.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：人们经常混淆两个PowerShell命令：`Select-Object`和`Where-Object`，你还没有看到过。`Select-Object`用于选择你想要看到的属性（或列），它还可以选择输出行的任意子集（使用`-First`和`-Last`）。`Where-Object`根据你指定的标准从管道中删除或过滤对象。
- en: 8.8 Objects until the end
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 对象直到结束
- en: The PowerShell pipeline always contains objects until the last command has been
    executed. At that time, PowerShell looks to see what objects are in the pipeline,
    and then looks at its various configuration files to see which properties to use
    to construct the onscreen display. It also decides whether that display will be
    a table or a list, based on internal rules and on its configuration files. (We’ll
    explain more about those rules and configurations, and how you can modify them,
    in chapter 10.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell管道在最后一个命令执行之前始终包含对象。那时，PowerShell会查看管道中的对象，然后查看其各种配置文件以确定使用哪些属性来构建屏幕显示。它还会根据内部规则和配置文件决定该显示是表格还是列表。（我们将在第10章中解释更多关于这些规则和配置，以及如何修改它们。）
- en: 'An important fact is that the pipeline can contain many kinds of objects over
    the course of a single command line. For the next few examples, we’re going to
    take a single command line and physically type it so that only one command appears
    on a single line of text. That’ll make it a bit easier to explain what we’re talking
    about. Here’s the first one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事实是，管道可以在单个命令行中包含许多种类的对象。在接下来的几个例子中，我们将取一个单独的命令行并实际输入，这样只有一条命令出现在文本的一行上。这将使解释我们谈论的内容更容易一些。这是第一个例子：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we start by running `Get-Process`, which puts process objects
    into the pipeline. The next command is `Sort-Object`. That doesn’t change what’s
    in the pipeline; it changes only the order of the objects, so at the end of `Sort-Object`,
    the pipeline still contains processes. The last command is `Out-File`. Here, PowerShell
    has to produce output, so it takes whatever’s in the pipeline—processes—and formats
    them according to its internal rule set. The results go into the specified file.
    Next up is a more complicated example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先运行 `Get-Process`，将进程对象放入管道。下一个命令是 `Sort-Object`。这不会改变管道中的内容；它只改变对象的顺序，所以在
    `Sort-Object` 的末尾，管道仍然包含进程。最后一个命令是 `Out-File`。在这里，PowerShell 必须生成输出，所以它会将管道中的内容——进程——格式化为其内部规则集。结果被放入指定的文件。接下来是一个更复杂的例子：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This starts off in the same way. `Get-Process` puts process objects into the
    pipeline. Those go to `Sort-Object`, which sorts them and puts the same process
    objects into the pipeline. But `Select-Object` works a bit differently. A process
    object always has the exact same members. In order to trim down the list of properties,
    `Select-Object` can’t remove the properties you don’t want, because the result
    wouldn’t be a process object anymore. Instead, `Select-Object` creates a new kind
    of custom object called a PSObject. It copies over the properties you do want
    from the process, resulting in a custom object being placed into the pipeline.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从相同的方式开始的。`Get-Process` 将进程对象放入管道。这些对象进入 `Sort-Object`，对其进行排序并将相同的进程对象放入管道。但
    `Select-Object` 的工作方式略有不同。进程对象始终具有完全相同的成员。为了缩减属性列表，`Select-Object` 不能删除您不想要的属性，因为结果将不再是进程对象。相反，`Select-Object`
    创建了一种新的自定义对象，称为 PSObject。它从进程复制您想要的属性，从而在管道中放置一个自定义对象。
- en: Try it Now Try running this three-cmdlet command line, keeping in mind that
    you should type the whole thing on a single line. Notice how the output is different
    from the normal output of `Get-Process`?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行这个三个 cmdlet 的命令行，记住您应该在一行中输入整个命令。注意输出与 `Get-Process` 的正常输出有何不同？
- en: When PowerShell sees that it’s reached the end of the command line, it has to
    decide how to lay out the text output. Because there are no longer any process
    objects in the pipeline, PowerShell won’t use the default rules and configurations
    that apply to process objects. Instead, it looks for rules and configurations
    for a PSObject, which is what the pipeline now contains. Microsoft doesn’t provide
    any rules or configurations for PSObjects, because they’re meant to be used for
    custom output. Instead, PowerShell takes its best guess and produces a table,
    on the theory that those three pieces of information probably will still fit in
    a table. The table isn’t as nicely laid out as the normal output of `Get-Process`,
    though, because the shell lacks the additional configuration information needed
    to make a nicer-looking table.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PowerShell 发现它已经到达了命令行的末尾，它必须决定如何布局文本输出。因为管道中不再有任何进程对象，PowerShell 不会使用适用于进程对象的默认规则和配置。相反，它会寻找适用于
    PSObject 的规则和配置，这正是管道现在所包含的内容。Microsoft 没有为 PSObjects 提供任何规则或配置，因为它们旨在用于自定义输出。相反，PowerShell
    会做出最佳猜测，并生成一个表格，基于这样的理论：这三条信息可能仍然适合放入表格中。然而，这个表格的布局并不像 `Get-Process` 的正常输出那样整齐，因为外壳缺少制作更美观表格所需的额外配置信息。
- en: 'You can use `gm` to see the objects that wind up in the pipeline. Remember,
    you can add `gm` after any cmdlet that produces output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `gm` 来查看最终进入管道的对象。记住，您可以在任何产生输出的 cmdlet 后添加 `gm`：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Try it Now Try running those two command lines separately, and notice the difference
    in the output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试分别运行这两个命令行，并注意输出的差异。
- en: Notice that, as part of the `gm` output, PowerShell shows you the type name
    for the object it sees in the pipeline. In the first case, that’s a `System.Diagnostics.Process`
    object, but in the second case the pipeline contains a different kind of object.
    Those new *selected* objects contain only the three properties specified—`Name`,
    `ID`, and `CPU`—plus a couple of system-generated members.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为 `gm` 输出的一部分，PowerShell 会向您显示它在管道中看到的对象的类型名称。在第一种情况下，这是一个 `System.Diagnostics.Process`
    对象，但在第二种情况下，管道包含不同类型的对象。这些新的 *选定* 对象仅包含指定的三个属性——`Name`、`ID` 和 `CPU`——以及一些系统生成的成员。
- en: 'Even `gm` produces objects and places them into the pipeline. After running
    `gm`, the pipeline no longer contains either process or the *selected* objects;
    it contains the type of object produced by `gm`: a `Microsoft.PowerShell.Commands.MemberDefinition`.
    You can prove that by piping the output of `gm` to `gm` itself:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`gm`也会产生对象并将它们放入管道中。运行`gm`后，管道中不再包含进程或*选定的*对象；它包含`gm`产生的对象类型：`Microsoft.PowerShell.Commands.MemberDefinition`。你可以通过将`gm`的输出管道传输到`gm`本身来证明这一点：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Try it Now You’ll definitely want to try this, and think hard about it to make
    sure it makes sense to you. You start with `Get-Process`, which puts process objects
    into the pipeline. Those go to `gm`, which analyzes them and produces its own
    `MemberDefinition` objects. Those are then piped to `gm`, which analyzes them
    and produces output that lists the members of each `Member-Definition` object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：你肯定会想尝试这个，并且要深思熟虑，确保它对你来说是有意义的。你从`Get-Process`开始，它将进程对象放入管道。这些对象进入`gm`，它分析它们并产生自己的`MemberDefinition`对象。然后这些对象被管道传输到`gm`，它分析它们并产生输出，列出每个`Member-Definition`对象的成员。
- en: A key to mastering PowerShell is learning to keep track of the kind of object
    that’s in the pipeline at any given point. While `gm` can help you do that, sitting
    back and verbally walking yourself through the command line is also a good exercise
    that can help clear up confusion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握 PowerShell 的关键在于学会在任何给定时刻跟踪管道中对象的类型。虽然`gm`可以帮助你做到这一点，但退后一步，通过口头解释命令行也是一项很好的练习，可以帮助消除困惑。
- en: 8.9 Common points of confusion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 常见混淆点
- en: Newcomers tend to make a few common mistakes as they get started with PowerShell.
    Most of these go away with a little experience, but we direct your attention to
    them with the following list, to give you a chance to catch yourself if you start
    heading down the wrong path.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新手在开始使用 PowerShell 时往往会犯一些常见的错误。大多数这些错误随着经验的积累会消失，但我们通过以下列表将你的注意力引向它们，以便你在开始走错路时有机会纠正自己。
- en: Remember that the PowerShell help files don’t contain information on objects’
    properties. You’ll need to pipe the objects to `gm` (`Get-Member`) to see a list
    of properties.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，PowerShell 的帮助文件不包含关于对象属性的信息。你需要将对象管道传输到`gm`（`Get-Member`）以查看属性列表。
- en: Remember that you can add `gm` to the end of any pipeline that typically produces
    results. A command line such as `Get-Process` `-Name` `Code` `|` `Stop-Process`
    doesn’t usually produce results, so tacking `|` `gm` onto the end won’t produce
    anything either.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，你可以在通常会产生结果的任何管道末尾添加`gm`。例如，像`Get-Process -Name Code | Stop-Process`这样的命令行通常不会产生结果，所以将`|
    gm`附加到末尾也不会产生任何结果。
- en: Pay attention to neat typing. Put a space on either side of every pipeline character,
    because your command lines should read as `Get-Process` `|` `gm` and not `Get-Process|gm`.
    That spacebar key is extra large for a reason—use it.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意整洁的打字。在每一个管道字符的两侧都加上一个空格，因为你的命令行应该读作`Get-Process | gm`而不是`Get-Process|gm`。那个空格键之所以特别大，是有原因的——请使用它。
- en: Remember that the pipeline can contain various types of objects at each step.
    Think about what type of object is in the pipeline, and focus on what the next
    command will do to that *type* of object.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，管道在每一步都可能包含各种类型的对象。思考一下管道中是什么类型的对象，并关注下一个命令将对这种类型的对象做什么。
- en: 8.10 Lab
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.10 实验室
- en: Note For this lab, you need any computer running PowerShell v7 or later.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验，你需要任何运行 PowerShell v7 或更高版本的计算机。
- en: 'This chapter has probably covered more, and more difficult, new concepts than
    any chapter to this point. We hope that you were able to make sense of it all
    and that these exercises will help you cement what you’ve learned. The lab may
    be more challenging than previous labs, but we want you to start getting in the
    habit of figuring out which commands to use—and relying on `get-command` and help,
    rather than on us, to find the correct command. After all, that is what you’ll
    be doing once you start working with PowerShell on the job and encountering all
    sorts of situations we don’t address in the book. Some of these tasks draw on
    skills you’ve learned in previous chapters, to refresh your memory and keep you
    sharp:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能涵盖了比迄今为止任何章节都多、难度更大的新概念。我们希望你能理解所有这些内容，并且希望这些练习能帮助你巩固所学知识。实验室可能比之前的实验室更具挑战性，但我们希望你能养成找出要使用哪些命令的习惯——依靠`get-command`和帮助，而不是依靠我们，来找到正确的命令。毕竟，一旦你开始在工作中使用
    PowerShell 并遇到书中未涉及的各种情况，你将需要这样做。其中一些任务依赖于你在前面章节中学到的技能，以帮助你刷新记忆并保持敏锐：
- en: Identify a cmdlet that produces a random number.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别一个产生随机数的cmdlet。
- en: Identify a cmdlet that displays the current date and time.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别一个显示当前日期和时间的cmdlet。
- en: What type of object does the cmdlet from task 2 produce? (What is the *TypeName*
    of the object produced by the cmdlet?)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务2中的cmdlet产生什么类型的对象？（cmdlet产生的对象的*TypeName*是什么？）
- en: 'Using the cmdlet from task 2 and `Select-Object`, display only the current
    day of the week in a table like the following (caution: the output will right-align,
    so make sure your PowerShell window doesn’t have a horizontal scrollbar):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任务2中的cmdlet和`Select-Object`，以如下表格形式显示当前星期几（注意：输出将右对齐，所以请确保你的PowerShell窗口没有水平滚动条）：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Identify a cmdlet that will show you all the times in a directory.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别一个可以显示目录中所有时间的cmdlet。
- en: Using the cmdlet from task 5, display all the times in the directory of your
    choice. Then extend the expression to sort the list by the time the items were
    created and display only the filename(s) and the date created. Remember that the
    column headers shown in a command’s default output aren’t necessarily the real
    property names—you need to look up the real property names to be sure.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任务5中的cmdlet，显示你选择的目录中的所有时间。然后扩展表达式，按创建时间对列表进行排序，并仅显示文件名和创建日期。记住，命令默认输出中显示的列标题不一定是真正的属性名——你需要查找真正的属性名来确保。
- en: Repeat task 6, but this time sort the items by the last write time; then display
    the filename, creation time, and the last write time. Save this in a CSV file
    and an HTML file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复任务6，但这次按最后写入时间对项目进行排序；然后显示文件名、创建时间和最后写入时间。将此保存为CSV文件和HTML文件。
- en: 8.11 Lab answers
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.11 实验答案
- en: '`Get-Random`'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Random`'
- en: '`Get-Date`'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Date`'
- en: '`System.DateTime`'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.DateTime`'
- en: '`Get-Date | select DayofWeek`'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Date | select DayofWeek`'
- en: '`Get-ChildItem`'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem`'
- en: '`Get-ChildItem | Sort-Object CreationTime | Select-Object`'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem | Sort-Object CreationTime | Select-Object`'
- en: '`➥ Name,CreationTime`'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ 名称,创建时间`'
- en: '`Get-ChildItem | Sort-Object LastWritetime | Select-Object`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem | Sort-Object LastWritetime | Select-Object`'
- en: '`➥ Name,LastWritetime,CreationTime | Export-CSV files.csv`'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ 名称,最后写入时间,创建时间 | Export-CSV files.csv`'
- en: '`Get-ChildItem | Sort-Object LastWritetime | Select-Object`'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-ChildItem | Sort-Object LastWritetime | Select-Object`'
- en: '`➥ Name,LastWritetime,CreationTime | Out-file files.html`'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`➥ 名称,最后写入时间,创建时间 | Out-file files.html`'
