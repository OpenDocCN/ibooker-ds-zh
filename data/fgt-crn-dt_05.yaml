- en: 4 Observing renewal and churn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 观察续订和流失
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Picking a lead time in advance of churns for observation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流失前选择观察的提前期
- en: Picking observation dates from subscriptions or activity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从订阅或活动中选择观察日期
- en: Creating an analytic dataset by flattening metric data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过展平指标数据创建分析数据集
- en: Exporting a current customer list for segmentation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出当前客户列表以进行细分
- en: The essence of fighting churn with data is learning from the natural experiments
    that occur every time a customer chooses to stay with or churn from the service.
    A natural experiment in this context means a situation that tests an outcome you
    are interested in, but you didn’t set it up like a formal experiment. These experiments
    are the churns and renewals that have already occurred, and the results are waiting
    for you in your data warehouse. Why aren’t you learning from the results already?
    Actually, observing these experiments and reading the results can be a little
    tricky if you’ve never done it before. This chapter teaches you the right way
    to observe the customer experiments that have already taken place in your own
    data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据对抗流失的本质是从每次客户选择继续服务或流失时发生的自然实验中学习。在这个背景下，自然实验意味着一个测试你感兴趣的结果的情况，但你没有像正式实验那样设置它。这些实验是已经发生的流失和续订，结果正等待你在数据仓库中。为什么你不从这些结果中学习呢？实际上，如果你以前从未这样做过，观察这些实验和阅读结果可能会有些棘手。本章教您正确观察已经在你自己的数据中发生的客户实验的方法。
- en: The scenario in this chapter assumes you have already produced behavioral metrics
    (as described in chapter 3) and calculated some kind of churn rate measurement
    (chapter 2). This chapter is a preparation step for the churn analysis. You are
    going to collect observations of customer metrics at known times when customers
    churned or continued with the service. In relation to the overall book scenario
    introduced in chapter 1, this chapter focuses on the processes highlighted in
    figure 4.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的场景假设您已经生成了行为指标（如第3章所述）并计算了一些类型的客户流失率测量（第2章）。本章是流失分析的准备步骤。您将收集在客户流失或继续服务时已知时间点的客户指标观察结果。与第1章中引入的整体书籍场景相关，本章重点介绍图4.1中突出的过程。
- en: '![](../Images/4-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-01.png)'
- en: Figure 4.1 This chapter’s place in the process of fighting churn with data
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 本章在用数据对抗流失的过程中的位置
- en: 'The chapter is organized as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的组织结构如下：
- en: In section 4.1, I introduce the idea of using a dataset to learn from your customers.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在4.1节中，我介绍了使用数据集从客户那里学习想法。
- en: Section 4.2 discusses how to choose the observations at a conceptual level and
    introduces the concept of lead time.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.2节讨论了在概念层面上如何选择观察结果，并介绍了提前期（lead time）的概念。
- en: Section 4.3 shows how to simplify the data where there are multiple overlapping
    subscriptions or gaps between subscriptions. This greatly simplifies the process
    of choosing the observation dates.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.3节展示了如何简化存在多个重叠订阅或订阅之间有间隔的数据。这极大地简化了选择观察日期的过程。
- en: Section 4.4 adapts these techniques for products where there are no actual subscriptions
    and instead uses customer event data by merging the activity and then applying
    the techniques from section 4.3.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.4节将这些技术应用于没有实际订阅的产品，而是通过合并活动并应用第4.3节的技术来使用客户事件数据。
- en: Section 4.5 teaches you how to generate a set of observation dates for customers,
    having prepared the data using the techniques in sections 4.2 and 4.3.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.5节教您如何生成一组观察日期，这些日期是在使用第4.2节和第4.3节的技术准备数据后为顾客生成的。
- en: Section 4.6 brings it all together by teaching you how to combine the observation
    dates with the metrics from chapter 3 to form a dataset for the analysis of churn.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.6节通过教您如何将观察日期与第3章中的指标结合起来，形成分析流失的数据集。
- en: 'Section 4.7 adds a related technique: exporting the current, or most recent,
    customer snapshot to use for segmentation.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.7节增加了一个相关技术：导出当前或最近的客户快照以用于细分。
- en: 4.1 Introduction to datasets
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 数据集简介
- en: As in most of these scenarios, the challenge in learning from your customers
    is partly due to complexity and partly due to logistical considerations. What
    makes observing a lot of customers complex is that they are all at different points
    in their journey with your product. It doesn’t make sense to just look at all
    your customers right now or at any single fixed point in time. You want to observe
    them all at the same point (or points) relative to their life cycle with the product,
    which makes them comparable. If you do this incorrectly and observe at the wrong
    times, it may distort your analysis and be counterproductive in the fight against
    churn. This chapter teaches you how to pick appropriate observation points in
    the customer life cycle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数这些场景中，从客户那里学习所面临的挑战部分是由于复杂性，部分是由于后勤考虑。观察许多客户复杂的原因在于他们都在与您的产品的旅程中处于不同的阶段。现在就查看所有客户或任何单一固定时间点是没有意义的。您希望在他们与产品的生命周期中的相同点（或几个点）观察他们，这样他们才是可比较的。如果您这样做不正确，在错误的时间观察，可能会扭曲您的分析，并在对抗流失的斗争中适得其反。本章将向您介绍如何在客户生命周期中挑选合适的观察点。
- en: Then, at all the observation points for all the customers, you take a snapshot
    of all the metrics as they were measured at those times. (The metric calculations
    in the last chapter were all run at sequences of times to make this possible.)
    This combined set of customer snapshots is called a dataset of customer observations,
    or simply the dataset. In case you are not already familiar with the term, a dataset
    is used in data science and statistics for a collection of data assembled for
    a particular analysis.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在所有客户的观察点，您都会捕捉到所有指标在那个时间点的快照。（上一章中的指标计算都是在一系列时间序列中运行的，以便实现这一点。）这个客户快照的组合集合被称为客户观察数据集，或简单地称为数据集。如果您还不熟悉这个术语，数据集在数据科学和统计学中用于特定分析的数据集合。
- en: DEFINITION Dataset —A concise summary of a set of situations (facts) and outcomes
    that you are interested in analyzing. Usually, a dataset is a single table (or
    file) with the same number of columns for every row and in which every row contains
    complete information for one situation and outcome.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 数据集——对一组您感兴趣分析的情境（事实）和结果的简要总结。通常，数据集是一个单张表格（或文件），每一行都有相同数量的列，并且每一行都包含一个情境和结果的完整信息。'
- en: When a collection of data is called a dataset, it implies that the data is organized
    in a table having the same number of columns for every row. Every row contains
    complete information for one instance or observation of the phenomena in question
    (meaning separate rows are separate observations), and every column corresponds
    to one type of fact about the situation (typically a measurement or a metric).
    When you create a dataset, you ensure that there are no missing fields or null
    (empty) values. You have to either come up with sensible defaults for missing
    measurements or exclude the observations that contain the missing data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当一组数据被称为数据集时，这意味着数据被组织在一个表格中，每一行都有相同数量的列。每一行都包含一个实例或现象观察的完整信息（意味着不同的行是不同的观察），每一列对应于关于该情况的一种事实（通常是测量或指标）。当您创建数据集时，您确保没有缺失字段或空（空）值。您必须为缺失的测量提供合理的默认值或排除包含缺失数据的观察。
- en: DEFINITION Churn analysis dataset —A dataset in which every row represents a
    customer facing the decision to churn or stay. The outcome is what they do. The
    facts about these situations are the customer’s behavioral metric measurements
    (and possibly other data you have about them).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 流失分析数据集——每一行代表一个面临流失或留存决策的客户的数据集。结果是他们的行为。这些情境的事实是客户的行为指标测量（以及可能关于他们的其他数据）。'
- en: 'The logistical challenges in creating this dataset are the same two as in chapters
    2 and 3: the data is sensitive and it can be large, so you are better off if you
    can do all the data processing in your database or data warehouse. The way to
    make this work, as in earlier chapters, is to write short programs in SQL and
    save key results in the data warehouse. In the end, a concise dataset with only
    the minimum possible amount of sensitive information can be efficiently extracted
    for further analysis.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此数据集的后勤挑战与第2章和第3章中相同：数据是敏感的，并且可能很大，因此如果您能在数据库或数据仓库中完成所有数据处理，那就更好了。像前几章一样，使这成为可能的方法是编写简短的SQL程序并将关键结果保存在数据仓库中。最终，可以有效地提取一个简洁的数据集，其中只包含尽可能少的敏感信息，以便进行进一步分析。
- en: 4.2 How to observe customers
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 如何观察客户
- en: To observe the natural experiments that occur when customers churn or continue
    to use a product, you need to start by asking when to make the observation. First
    we consider the question at an abstract level (code is coming in later sections).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察客户流失或继续使用产品时发生的自然实验，你需要首先询问何时进行观察。首先，我们以抽象层面考虑这个问题（代码将在后面的章节中介绍）。
- en: 4.2.1 Observation lead time
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 观察提前期
- en: 'When to observe customers is an easy question, right? Observe a customer when
    they have churned, isn’t that the point? Not quite. Think about it this way: what
    will a customer’s behavioral metrics for a media-sharing app look like when the
    customer has churned? Logins? Zero. Downloads? Zero. Likes? Zero. Because they’ve
    churned, all their behaviors on the product should have stopped. Observing a customer
    when they have already churned is not very helpful. Also, after someone has churned,
    you don’t have much chance of getting them to sign up again: you have a better
    chance of influencing them before they have made up their mind.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 何时观察客户是一个简单的问题，对吧？在客户流失时观察客户，难道不是这个目的吗？并不完全是这样。这样思考一下：当客户流失时，一个媒体分享应用客户的用户行为指标会是什么样子？登录？零。下载？零。点赞？零。因为他们已经流失，他们在产品上的所有行为都应该已经停止。在客户已经流失时观察他们并不很有帮助。此外，在有人流失后，你几乎没有机会让他们再次注册：你更有可能在他们在做出决定之前影响他们。
- en: TAKEAWAY It is easier to convince customers to stay before they churn than to
    sign up anew after they churn. The period before churn, therefore, is the focus
    of the analysis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 吸收要点：在客户流失前说服客户留下比在客户流失后重新注册更容易。因此，流失前的时间段是分析的重点。
- en: 'Observe customers before they churn. Right! I call this observing customers
    with a lead time in making the observation, which means making the observations
    before the thing you are really interested in (the renewal or churn). How long
    before the churn should you observe a customer: a day before they churned? Maybe,
    but most likely you should observe what customers were doing even longer before
    they churned. That’s because, often, the customer’s behavior changes in the time
    immediately before they churn. This is illustrated in figure 4.2, with a hypothetical
    example for a media-sharing service.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户流失前观察客户。对！我称之为在观察时具有观察提前期的客户，这意味着在真正感兴趣的事情（续订或流失）之前进行观察。在客户流失前应该观察多久：在他们流失前一天？也许吧，但更有可能的是，你应该观察他们在流失前更长时间的行为。这是因为，通常，客户在流失前的行为会发生变化。这如图4.2中的假设例子所示。
- en: '![](../Images/4-02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-02.png)'
- en: Figure 4.2 Lead time and customer behavior before churn
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 流失前的时间段和客户行为
- en: If someone is planning to churn, some behaviors are likely to be reduced in
    the period right before the churn, whereas others may increase. In the example
    of a hypothetical file-sharing service, uploads might completely stop before churning
    because the customer doesn’t want to waste time contributing anything else. Instead,
    they focus on downloading content before their access to the service ends. As
    another example, logins can increase in the period before churn, before going
    to zero.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人计划流失，在流失前的时期，某些行为可能会减少，而其他行为可能会增加。以一个假设的文件共享服务为例，在流失前，上传可能会完全停止，因为客户不想浪费时间贡献任何其他东西。相反，他们会在服务结束前专注于下载内容。作为另一个例子，登录在流失前的时期可能会增加，然后变为零。
- en: For some products, these kinds of changes in behavior can make likely churners
    easy to spot in the period before churn. But behaviors brought on by imminent
    churn are still not what you want to observe because that’s not going to tell
    you why the customer chose to churn in the first place. You want to observe what
    the customer was like in the time before they decided to churn, because then you
    are observing what a customer looks like when they are still making up their mind.
    This is important because when the customer is still making up their mind, you
    have the best chance to influence them! I will emphasize the point again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些产品，这类行为的变化可以在客户流失前的一段时间内轻易地识别出可能流失的客户。但是，由即将发生的流失引起的行为仍然不是你想要观察的，因为那并不能告诉你客户最初为什么选择流失。你想要观察的是客户在决定流失之前的状态，因为那时你正在观察客户在做出决定时的样子。这很重要，因为当客户还在做决定时，你最有机会影响他们！我再次强调这个观点。
- en: TAKEAWAY The goal of the analysis is to identify and understand customers who
    are still making up their minds about churn, because that is when you have the
    best chance of influencing them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点**：分析的目标是识别和理解仍在权衡是否流失的客户，因为那时你影响他们的机会最大。'
- en: 'How do you know when customers are still making up their minds about churning
    or continuing to use the product? You can’t know exactly, unless you are psychic.
    You have to observe customers at a time when it is reasonable to expect them to
    be thinking about their next renewal, not immediately after the last renewal,
    and not right before the upcoming renewal where they might churn. The amount of
    time depends on the service, but generally, the longer the commitment and the
    more expensive the service, the longer the lead time should be:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道客户是否还在权衡是否流失或继续使用产品？除非你有预知能力，否则你无法确切知道。你必须观察客户在合理预期他们正在考虑下一次续订的时间，而不是在最后一次续订后立即，也不是在即将到来的续订前，他们可能会流失。所需的时间取决于服务类型，但一般来说，承诺期限越长，服务越昂贵，提前期就应该越长：
- en: For monthly subscriptions, observe customers one to two weeks before the monthly
    renewal or about one-half to three-quarters of the way through the current month.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于月度订阅，在月度续订前一周到两周观察客户，或者在当前月份的一半到四分之三处。
- en: For annual subscriptions with consumers or small businesses, observe customers
    about one month before the annual renewal.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于消费者或小型企业的年度订阅，在年度续订前大约一个月观察客户。
- en: For annual subscriptions with large businesses, observe customers anywhere from
    two to four months before renewal; 90 days is typical.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于与大型企业的年度订阅，在续订前观察客户的时间从两个月到四个月不等；90天是典型的时间。
- en: For nonsubscription products, you don’t pick a lead time. You pick a sequence
    of regularly spaced observation dates, just like for a subscription product. But
    since there are no renewals, you have no guide as to when someone might be considering
    canceling.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非订阅产品，你不需要选择提前期。你选择一系列定期间隔的观察日期，就像订阅产品一样。但由于没有续订，你无法确定何时有人可能考虑取消。
- en: 4.2.2 Observing sequences of renewals and a churn
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 观察续订和流失的序列
- en: 'When you create a dataset, you don’t want to observe just customers who churn.
    You also want to observe customers who renew. That way, you can compare churns
    and renewals and see the difference in your analysis. And you don’t want to choose
    just a few renewals: for the purpose of the analysis, you want to pick enough
    renewals to observe that the renewal observations in your dataset are in proportion
    to the true retention rate.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建数据集时，你不想只观察流失的客户。你还想观察续订的客户。这样，你可以比较流失和续订，并在分析中看到差异。而且，你不想只选择少数续订：为了分析的目的，你想要选择足够的续订，以便观察数据集中的续订观察与真实的保留率相匹配。
- en: TAKEAWAY For a churn analysis dataset, try to make the renewals in your dataset
    in proportion to the true retention rate. Churns should be in your dataset in
    proportion to the true churn rate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点**：对于流失分析数据集，尽量使数据集中的续订比例与真实的保留率相匹配。流失应在数据集中按真实流失率的比例存在。'
- en: 'For example, if you have a 5% churn rate and a 95% retention rate, you want
    to make a set of observations that is also around 5% churns and 95% renewals.
    That might sound complicated to arrange, but it’s straightforward: you just observe
    every renewal for every account as well as the churns. This results in about the
    same proportion of renewals and churns in your observations as your true churn
    rate.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有5%的流失率（churn rate）和95%的保留率（retention rate），你希望观察到的数据集也大约有5%的流失和95%的续订。这可能听起来安排起来很复杂，但实际上很简单：你只需观察每个账户的每次续订以及流失情况。这样，你观察到的续订和流失的比例将与你的真实流失率大致相同。
- en: 'If the subscription does not have a fixed term or it automatically renews,
    observations should be made based on when each payment is due. Payments are typically
    due at fixed periods after the subscription begins: every month, for most consumer
    subscriptions. For consistency with the churn observations that have a lead time,
    you should also apply the same lead time before each renewal or payment. Figure
    4.3 illustrates this scenario.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订阅没有固定期限或自动续订，观察应根据每次付款到期的时间进行。付款通常在订阅开始后固定时间段内到期：对于大多数消费者订阅，通常是每月一次。为了与有提前期的流失观察保持一致，你应在每次续订或付款前应用相同的提前期。图4.3说明了这种情况。
- en: A subscription has periodic payments (for example, monthly) and continues until
    canceled. The observation dates selected are the lead time before each payment
    is due. The subscription finally ends after the last paid month ends, and the
    churn observation is made in the lead time before the end of that month; that
    was when the customer was making the final determination to churn or renew. This
    is why the title of this section is “Observing sequences of renewals and a churn.”
    Typically, you observe each account many times as they renew and then only once
    when they churn.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅有定期支付（例如，每月）并持续到取消为止。选择的观察日期是每次付款到期前的提前期。订阅最终在最后一个付费月份结束后结束，流失观察是在该月结束前的提前期进行的；那时客户正在做出最终决定是否流失或续费。这就是为什么本节标题为“观察续费和流失序列”的原因。通常，您会在他们续费时观察每个账户多次，而在他们流失时只观察一次。
- en: '![](../Images/4-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-03.png)'
- en: Figure 4.3 Payment cycle dates, lead time, and observation sequences
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 支付周期日期、提前期和观察序列
- en: 'What if your product has subscriptions that are on different renewal or payment
    cycles? For example, many products have both monthly and annual plans. There are
    multiple ways to handle this, but my advice is to observe all customers at the
    same frequency by assuming they are all on the same renewal or payment cycle.
    The observation frequency to choose is the payment or renewal cycle that is the
    most common. Usually this is the period that you use to quote your churn, so the
    choice should be obvious:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的产品有在不同续费或支付周期上的订阅怎么办？例如，许多产品既有月度计划也有年度计划。有多种处理方式，但我的建议是假设所有客户都在相同的续费或支付周期上，以相同的频率观察所有客户。要选择的观察频率是最常见的支付或续费周期。通常，这是您用来报价流失的周期，所以选择应该是显而易见的：
- en: For a consumer subscription that reports a monthly churn rate, observe customers
    every month even if some renew or pay on annual contracts.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于报告每月流失率的消费者订阅，即使有些客户续费或支付年度合同，也要每月观察客户。
- en: For a business subscription that reports an annual churn rate, observe customers
    every year, even if some pay or renew on monthly and quarterly schedules.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于报告年度流失率的商业订阅，即使有些客户支付或续费按月或季度计划，也要每年观察客户。
- en: 'Remember: when in doubt, if it makes the most sense to quote your churn based
    on a particular period (monthly, quarterly, or annual), then that is probably
    the right period to use when observing subscribers throughout their lifetime on
    the product.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：当不确定时，如果根据特定时期（每月、每季度或每年）计算您的流失率最有意义，那么这可能就是观察产品整个生命周期中订阅者的正确时期。
- en: If you think about it, in a way, it doesn’t make sense to observe an annual
    customer midway through the year because they don’t have a chance to churn at
    that point, and they are probably not thinking about it. But if you observe the
    annual customers only once a year, it complicates reproducing the churn and renewal
    rate in your data and also makes it harder to interpret the impact of being on
    the annual plan versus being on the monthly plan. (I will explain further when
    you learn how to analyze the churn impact of plans in chapter 5.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您这么想，从某种意义上说，在年中观察年度客户是没有意义的，因为他们那时没有机会流失，而且他们可能也没有在考虑这个问题。但如果你每年只观察一次年度客户，这会使得在数据中重现流失和续费率变得复杂，同时也使得解释年度计划和月度计划的影响变得更加困难。（我将在第5章学习如何分析计划的流失影响时进一步解释。）
- en: 4.2.3 Overview of creating a dataset from subscriptions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 从订阅创建数据集的概述
- en: Now I’ll go over the procedure to create a dataset for the case of having actual
    subscriptions; the process for when there are no subscriptions is covered in section
    4.4\. An overview of the entire process is shown in figure 4.4\. The starting
    point of the process is the subscription data described in chapter 2 and the metrics
    you created in chapter 3 and saved in the data warehouse.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将介绍创建实际订阅数据集的步骤；没有订阅的情况在4.4节中介绍。整个过程的概述如图4.4所示。过程的起点是第2章中描述的订阅数据以及您在第3章中创建并在数据仓库中保存的指标。
- en: 'The main steps shown in figure 4.4 are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4中展示的主要步骤如下：
- en: Identify periods when customers are subscribed to one or more subscriptions
    that are ongoing at the present time (no churn, yet). These are called active
    periods that are ongoing.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别客户目前订阅的一个或多个正在进行的订阅（没有流失）。这些被称为持续进行的活跃期。
- en: Identify periods when each customer is subscribed to one or more subscriptions
    and when these periods end in churn. These are called active periods ending in
    churn.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别每个客户订阅一个或多个订阅的时间段以及这些时间段何时以流失结束。这些被称为以流失结束的活跃期。
- en: Using these active periods, pick sequences of observation dates for each customer
    using the payment or renewal cycle and lead times as described in the last section.
    Keep track of which of these observations are made in the lead time before an
    actual churn.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些活跃期，根据上一节中描述的支付或续订周期和提前期，为每个客户选择观察日期序列。跟踪这些观察中哪些是在实际流失前的提前期内进行的。
- en: Use the sequences of observation dates to choose metrics saved in the data warehouse.
    The metric values, along with the churn and observation details, are selected
    in a single dataset, one observation per customer per row of the dataset.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用观察日期序列来选择数据仓库中保存的指标。指标值，连同流失和观察细节，在一个数据集中选择，每个客户每行数据集为一个观察。
- en: '![](../Images/4-04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-04.png)'
- en: Figure 4.4 Process for creating a dataset from subscriptions in four steps
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 从订阅中创建数据集的四个步骤流程
- en: I just mentioned an important new concept that will be used throughout the process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚提到了一个将在整个过程中使用的重要新概念。
- en: DEFINITION Active period —A span of time when a subscriber has at least one
    active subscription. There can be small gaps between subscriptions without disrupting
    the active period.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 活跃期 —— 指订阅者至少有一个活跃订阅的时间段。订阅之间可以有小的间隔，而不会打断活跃期。
- en: 'Section 4.3 provides details on steps 1 and 2 of this process: creating the
    active periods. Section 4.4 takes a detour to explain how this process differs
    for products where there is not an actual subscription. Section 4.5 picks up and
    explains step 3 in this process: selecting observation dates. Finally, section
    4.6 discusses the final step: merging the metric data with the observation dates
    and exporting the dataset.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3节提供了此过程步骤1和2的详细信息：创建活跃期。第4.4节偏离主题，解释了对于没有实际订阅的产品，此过程有何不同。第4.5节继续并解释此过程的第3步：选择观察日期。最后，第4.6节讨论了最终步骤：将指标数据与观察日期合并并导出数据集。
- en: 4.3 Identifying active periods from subscriptions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 从订阅中识别活跃期
- en: The goal in this phase of the process is to make regular observations of your
    subscribers at appropriate times to understand why they churn. The first step
    is to handle problems caused by redundancy or irregularity in the subscriptions.
    These are the same issues encountered in chapter 3 when you learned how to calculate
    account tenure. There can be multiple subscriptions for some customers so that
    the effective period the customer is active is longer than any single subscription,
    and there can be short gaps between the individual subscriptions that you might
    not want to consider churns. Also, some customers have multiple subscriptions
    at the same time when there is more than one product or if there is a base product
    and add-ons. The dates for these additional subscriptions may not align with the
    main subscription.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程阶段的目标是在适当的时间对您的订阅者进行定期观察，以了解他们为何流失。第一步是处理由订阅中的冗余或不规则性引起的问题。这些问题与你在第3章学习如何计算账户期限时遇到的问题相同。某些客户可能有多个订阅，这样客户活跃的有效期可能比任何单个订阅都要长，而且个人订阅之间可能有短间隔，这些间隔你可能不想视为流失。此外，当有多个产品或存在基础产品和附加产品时，一些客户可能同时拥有多个订阅。这些额外订阅的日期可能不会与主要订阅对齐。
- en: If your subscription product does not have any of the complexities that this
    step is designed to handle, you can skip to section 4.5\. To be clear, skip this
    section only if your product’s subscriptions are already guaranteed to consist
    of single, non-overlapping periods for each account, with no unintentional gaps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的订阅产品没有这个步骤旨在处理的任何复杂性，您可以跳到第4.5节。为了明确，只有当您产品的订阅已经保证由每个账户的单个、不重叠的周期组成，且没有无意中产生的间隔时，才跳过本节。
- en: 4.3.1 Active periods
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 活跃期
- en: An active period, illustrated in figure 4.5, is a period of time when an account
    is continuously subscribed, through one or more individual subscriptions. In figure
    4.5, there are a total of seven separate subscriptions, numbered sequentially
    by their start time. An active period differs from a subscription in that the
    active period merges any multiple subscriptions and ignores short gaps. Each account
    can be in only one active period at a time, and any gaps between active periods
    represent genuine churn followed by resubscribing at a later date.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃期间，如图4.5所示，是指账户通过一个或多个单独的订阅持续订阅的一段时间。在图4.5中，总共有七个单独的订阅，按照它们的开始时间顺序编号。活跃期间与订阅的不同之处在于，活跃期间合并了任何多个订阅并忽略了短暂的间隔。每个账户一次只能处于一个活跃期间，活跃期间之间的任何间隔都代表真正的流失，随后在稍后的日期重新订阅。
- en: NOTE If an account is not in an active period, the end of the last active period
    was a churn.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果一个账户不在活跃期间，则最后一个活跃期间的结束即为流失。
- en: 'In figure 4.5, the first active period is a simple one: a single subscription.
    Period 2 in the figure is an example of a complex active period made of three
    main subscriptions (numbers 2, 3, and 5). Between subscriptions 2 and 3 is a short
    gap—short enough that it should not be considered a churn. Subscriptions 3 and
    5 align, so there is no gap; and another subscription, an add-on (number 4), begins
    in the middle of subscription 3 and ends in the middle of subscription 5\. All
    of these meet the condition that they make up one active period. Period 3 is an
    example of an active period that is ongoing; this is when the subscription has
    no end date or an end date in the future at the time the analysis is done.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.5中，第一个活跃期间是一个简单的单一订阅。图中的第2期是一个由三个主要订阅（编号2、3和5）组成的复杂活跃期间的例子。在订阅2和3之间有一个短暂的间隔——短到不应该被视为流失。订阅3和5对齐，因此没有间隔；还有一个附加订阅（编号4），它在订阅3的中间开始，在订阅5的中间结束。所有这些都符合构成一个活跃期间的条件。第3期是一个活跃期间正在进行的例子；这是当订阅没有结束日期或在分析时结束日期在未来的情况。
- en: '![](../Images/4-05.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5](../Images/4-05.png)'
- en: Figure 4.5 Determining active periods from multiple subscriptions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 从多个订阅中确定活跃期间
- en: 4.3.2 Schema for storing active periods
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 存储活跃期间的架构
- en: 'The active periods are just one step in the process of forming the dataset,
    and it is convenient to store them in the database. Alternatively, you might choose
    to combine all the short programs in this chapter into one large program that
    produces the dataset without any permanent storage. Because this book teaches
    each step in a short program, I store the results in a table. The schema required
    to store the active periods is shown in table 4.1\. It has some similarities to
    the schema for storing subscriptions (chapter 2, table 2.1) in that each record
    has an account ID and a start date, which are required, and another date that
    is the churn date, which is nullable like the end date on the subscription. But
    an active period record has some important differences from a subscription:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃期间只是形成数据集过程的一步，将它们存储在数据库中很方便。或者，您可能选择将本章中所有简短程序合并成一个大型程序，该程序生成数据集而不需要任何永久存储。因为这本书通过简短程序教授每个步骤，所以我将结果存储在表中。存储活跃期间的所需模式如图4.1所示。它在某些方面与存储订阅的模式（第2章，表2.1）相似，因为每条记录都有一个账户ID和开始日期，这是必需的，还有一个日期是流失日期，它像订阅的结束日期一样可以为空。但是，活跃期间记录与订阅有一些重要的不同：
- en: The combination of `account_id` and `start_date` must be unique for an active
    period, so they should be implemented as a compound key or index on the table.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个活跃期间，`account_id`和`start_date`的组合必须是唯一的，因此它们应该作为表上的复合键或索引来实现。
- en: Active periods have none of the details associated with a subscription, like
    the product or MRR.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活跃期间没有与订阅相关的任何细节，如产品或MRR。
- en: (If you need a reminder about how to calculate metrics like the MRR in the context
    of multiple subscriptions, see section 3.10.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您需要关于如何在多个订阅的上下文中计算MRR等指标的帮助，请参阅第3.10节。）
- en: 'NOTE The constraint on `account_id` and `start_date` can be implemented as
    a constraint on the table, but there is another implied constraint that must be
    implemented by the application logic. For each account, the start dates and churn
    dates of active periods must define non-overlapping time periods, and there can
    be only one active period without a churn date for each account: the currently
    active period.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：`account_id` 和 `start_date` 的约束可以作为一个表约束实现，但还有一个隐含的约束必须通过应用程序逻辑实现。对于每个账户，活跃周期的开始日期和流失日期必须定义非重叠的时间段，并且每个账户只能有一个没有流失日期的活跃周期：当前活跃周期。
- en: Table 4.1 Active period table schema
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 活跃周期表架构
- en: '| Column | Type | Notes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `account_id` | `integer` or `char` | Not null; compound key |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer` 或 `char` | 不为空；复合键 |'
- en: '| `start_date` | `date` | Not null; compound key |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `start_date` | `date` | 不为空；复合键 |'
- en: '| `churn_date` | `date` | Nullable |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `churn_date` | `date` | 可为空 |'
- en: 4.3.3 Finding active periods that are ongoing
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 查找正在进行的活跃周期
- en: 'I show you how to find active periods that are still ongoing first because
    it’s easier than finding active periods that ended in churn. For ongoing active
    periods, you don’t need to find churn dates because you know they don’t end in
    churn: it’s just a matter of finding the start date. Look at figure 4.5, and think
    back to the account tenure calculation you learned in section 3.10 (see figures
    3.19-3.21). Finding the start date of an active period that is ongoing is basically
    the same as finding the tenure of every account (the tenure of every account as
    of today, that is). The only difference is that the desired result is the start
    date of the period when customers were actively subscribed rather than how long
    they have been an active subscriber. As with calculating account tenure, you need
    to find the start of not just the current subscription but the oldest subscription
    that overlaps or forms a contiguous series up to the present.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先向您展示如何找到仍在进行的活跃周期，因为这与找到已经结束的活跃周期更容易。对于正在进行的活跃周期，您不需要找到流失日期，因为您知道它们不会以流失结束：这只是找到开始日期的问题。看看图
    4.5，回想一下您在 3.10 节中学到的账户租期计算（见图 3.19-3.21）。找到正在进行的活跃周期的开始日期基本上与找到每个账户的租期相同（即今天为止的每个账户的租期）。唯一的区别是，所需的结果是客户积极订阅的周期开始日期，而不是他们作为积极订阅者的时长。与计算账户租期一样，您需要找到的不仅仅是当前订阅的开始，还要找到最老的、与当前订阅重叠或形成连续序列的订阅。
- en: 'Listing 4.1 shows a short SQL program that calculates the currently ongoing
    active periods. Again, note that the result is simply a list of all accounts that
    are currently in the middle of an active subscription and the earliest start date
    when they entered into any active subscription that is continuous at present.
    This is the same as the account tenure calculation using a recursive common table
    expression (CTE), described in the last chapter, but I will go through it again
    as a quick review. The process is implemented with the following `SELECT` statements:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 展示了一个简短的 SQL 程序，用于计算当前正在进行的活跃周期。再次注意，结果仅仅是一个列表，列出了目前正处于活跃订阅中的所有账户以及它们进入任何当前连续活跃订阅的最早开始日期。这与上一章中描述的，使用递归公用表表达式（CTE）进行的账户租期计算相同，但我会再次讲解，作为快速回顾。这个过程通过以下
    `SELECT` 语句实现：
- en: A CTE holds parameters controlling when and how active periods are found.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 CTE 包含控制何时以及如何找到活跃周期的参数。
- en: A recursive CTE in two parts finds sequences of active subscriptions.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个两部分的递归 CTE 找到活跃订阅的序列。
- en: The initialization `SELECT` statement finds all accounts that are currently
    active.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 `SELECT` 语句找出所有当前活跃的账户。
- en: The recursive `SELECT` statement finds earlier subscriptions that overlap with
    or are continuous with but older than the subscriptions currently found.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归 `SELECT` 语句找出与当前找到的订阅重叠或与当前订阅连续但更早的早期订阅。
- en: An aggregate `SELECT` statement finds the earliest start date of any subscriptions
    for each account.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个聚合 `SELECT` 语句找出每个账户的任何订阅的最早开始日期。
- en: Because this result is saved and combined with the results for active periods
    ending in churn, the final `SELECT` statement includes an `INSERT` statement to
    save the result in the table named `active_period`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个结果被保存并与其他以流失结束的活跃周期的结果合并，所以最终的 `SELECT` 语句包括一个 `INSERT` 语句，将结果保存到名为 `active_period`
    的表中。
- en: Listing 4.1 Active periods that are currently ongoing
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 当前正在进行的活跃周期
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① This CTE holds constant parameters.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此 CTE 包含常量参数。
- en: ② The maximum time without subscription before churn
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在流失前的最大无订阅时间
- en: ③ Latest date to consider
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 考虑的最新日期
- en: ④ This is the same as calculating account tenure (chapter 3).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 这与计算账户任期（第 3 章）相同
- en: ⑤ Initializes recursive CTE with the start of every current subscription
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 使用每个当前订阅的开始初始化递归 CTE
- en: ⑥ Inserts new account IDs and start dates during recursion
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 在递归过程中插入新的账户 ID 和开始日期
- en: ⑦ The new records must be for the same account.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 新记录必须属于同一账户。
- en: ⑧ The new records are for subscriptions that start earlier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 新记录是为开始时间更早的订阅
- en: ⑨ New records must have an end date within the allowed gap.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 新记录必须有一个在允许的间隔内的结束日期。
- en: ⑩ Saves the result to the active_period table
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将结果保存到 active_period 表中
- en: ⑪ Selects the earliest start date and null for the churn date
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 选择最早的开始日期和为流失日期选择 null
- en: ⑫ Groups by account_id; churn_date must be in the GROUP BY
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 按 account_id 分组；流失日期必须在 GROUP BY 中
- en: 'Run listing 4.1 by following the instructions in the book’s downloadable code
    at [www.manning.com/books/fighting-churn-with-data](https://www.manning.com/books/fighting-churn-with-data)
    or [https://github.com/carl24k/ fight-churn](https://github.com/carl24k/fight-churn).
    It is preconfigured to run on the default simulated dataset. (Instructions for
    the data simulation are in the README page.) After setting up your environment,
    run listing 4.1 with this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按照书中可下载代码的说明运行列表 4.1，代码位于 [www.manning.com/books/fighting-churn-with-data](https://www.manning.com/books/fighting-churn-with-data)
    或 [https://github.com/carl24k/fight-churn](https://github.com/carl24k/fight-churn)。它已预配置为在默认模拟数据集上运行。（数据模拟的说明在
    README 页面中。）设置好你的环境后，使用以下命令运行列表 4.1：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The wrapper program `run_churn_listing` prints the SQL it is running. But note
    that listing 4.1 performs an insert into the database, so it does not produce
    any output. To see the result, run a query using a SQL query method of your choice
    (see the README for suggestions); for example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 包装程序 `run_churn_listing` 打印它正在运行的 SQL。但请注意，列表 4.1 在数据库中执行插入操作，因此不会产生任何输出。要查看结果，请使用你选择的
    SQL 查询方法运行查询（参见 README 获取建议）；例如：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 4.6 shows the results of running listing 4.1 on the default simulated
    dataset and then viewing the results with a `SELECT` statement like the previous
    one. Use a `LIMIT` clause if you have a large amount of data, but you shouldn’t
    need it for the default simulation. The result contains accounts that began near
    the start of the simulation, as well as accounts that were added at the end of
    the simulation. Due to the constraint on the `active_period` table, you can run
    listing 7.1 only once without deleting the data already in the table.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 显示了在默认模拟数据集上运行列表 4.1 的结果，然后使用类似于上一个的 `SELECT` 语句查看结果。如果你有大量数据，请使用 `LIMIT`
    子句，但对于默认模拟，你可能不需要它。结果包含在模拟开始附近开始的账户，以及模拟结束时添加的账户。由于对 `active_period` 表的约束，你只能运行列表
    7.1 一次，而无需删除表中已有的数据。
- en: '![](../Images/4-06.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-06.png)'
- en: Figure 4.6 Result of running listing 4.1 for active periods that are ongoing
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 运行列表 4.1 的活动期结果
- en: 4.3.4 Finding active periods ending in churn
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 寻找以流失结束的活动期
- en: 'Finding active periods ending in churn is probably the most advanced SQL program
    in this book. But this program is not harder than anything you’ve seen; it just
    combines other techniques you have already mastered: the outer join technique
    from chapter 2 used to calculate churn, and the recursive CTE from chapter 3 (and
    reviewed in the last section) to find the earliest start of any subscription continuously
    up to another subscription.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以流失结束的活动期可能是本书中最先进的 SQL 程序。但这个程序并不比你所见过的任何程序更难；它只是结合了你已经掌握的其他技术：第 2 章中用于计算流失的外连接技术，以及第
    3 章中（并在上一节中回顾）用于找到任何订阅最早开始时间并持续到另一个订阅的递归 CTE。
- en: The algorithm for finding all the churns is based on the outer join method demonstrated
    in chapter 2 for calculating the churn rate, but it is not exactly the same. It
    starts with the observation that every churn must correspond to an end date of
    a subscription. Further, an end date on a subscription is a churn if there was
    no other extension through a new subscription by the same account.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找所有流失的算法基于第 2 章中用于计算流失率的示例外连接方法，但它并不完全相同。它从观察开始，即每次流失都必须对应一个订阅的结束日期。进一步来说，如果一个订阅的结束日期没有通过相同账户的新订阅进行其他扩展，那么这个结束日期就是一个流失。
- en: DEFINITION Extension —Another subscription that begins either before a previous
    subscription ends or within the allowed gap period and that has a future end date.
    An extension extends an active period. This definition of extension is specific
    to the discussion of the current algorithm and is not a term generally used in
    the trade.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定义延期——另一个在先前订阅结束之前或允许的间隔期内开始，并且具有未来结束日期的订阅。延期延长了活跃期。这种延期定义仅适用于当前算法的讨论，并不是贸易中一般使用的术语。
- en: '![](../Images/4-07.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-07.png)'
- en: Figure 4.7 Finding churns from end dates and extensions
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 从结束日期和延期中查找流失
- en: 'An extension is so named because it extends the end date of a prior subscription
    and prevents that end date from being churn. The key is that a churn is an end
    date with no extension. Figure 4.7 provides an example of finding churns by considering
    end dates and extensions. It’s based on the sequence of subscriptions illustrated
    in figure 4.5\. To identify churns of one account, you use the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 延期之所以被称为延期，是因为它延长了先前订阅的结束日期，并防止该结束日期发生流失。关键是流失是一个没有延期的结束日期。图4.7提供了一个通过考虑结束日期和延期来查找流失的例子。它基于图4.5中所示的订阅序列。为了识别一个账户的流失，你使用以下步骤：
- en: Identify all the end dates of subscriptions for that account. (Subscriptions
    with no end dates cannot be churns, so ignore them.) This is limited to end dates
    within a time period that ends at the current date and can start as far back as
    you are interested in when looking for churns.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别该账户所有订阅的结束日期。（没有结束日期的订阅不能是流失，所以忽略它们。）这限于在当前日期结束的时间段内的结束日期，并且可以追溯到你在寻找流失时感兴趣的最早日期。
- en: Identify all extensions that extend those end dates. These are subscriptions
    that begin before the other subscriptions’ end date or within the allowed gap
    time and end later in the future.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别所有延长这些结束日期的延期。这些是在其他订阅结束日期之前或允许的间隔时间内开始，并在未来较晚结束的订阅。
- en: Select the end dates that do not have an extension. These are the churns. In
    SQL, use an outer join for the end dates with the extensions and select those
    subscriptions from step 1 with `null` on the outer join and the extension subscriptions
    from step 2\. These end dates correspond to active periods ending in churn.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择没有延期的结束日期。这些就是流失。在SQL中，使用外连接来处理有延期的结束日期，并选择步骤1中的那些订阅，在外连接上使用`null`，以及步骤2中的延期订阅。这些结束日期对应于以流失结束的活跃期。
- en: 'Figure 4.8 shows the complete process for finding churns and their corresponding
    start dates. It consists of first finding churns by considering end dates and
    extensions and then finding the start dates of the active periods that ended with
    a churn. This takes place in two additional steps (4 and 5):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8显示了查找流失及其对应开始日期的完整过程。它包括首先通过考虑结束日期和延期来查找流失，然后查找以流失结束的活跃期的开始日期。这发生在两个额外的步骤（4和5）中：
- en: 'The start dates are found in the same way as the start dates for ongoing active
    periods (and for account tenure calculations): using a recursive CTE that searches
    for progressively earlier start dates.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始日期的查找方式与持续活跃期的开始日期（以及账户任期计算）相同：使用递归CTE来搜索越来越早的开始日期。
- en: Take the minimum of the start dates from the subscriptions that precede the
    subscription ending in churn (if any).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从在流失结束的订阅之前的订阅中取最小开始日期（如果有）。
- en: '![](../Images/4-08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-08.png)'
- en: Figure 4.8 Process for finding churns and the corresponding active period start
    dates
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 寻找流失和相应的活跃期开始日期的过程
- en: 'Listing 4.2 is the SQL program that finds the active periods ending in churn.
    It includes four CTEs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2是查找以流失结束的活跃期的SQL程序。它包括四个CTE：
- en: '`active_period_params`—Contains the fixed constants that define when the program
    will find churns and the maximum allowed gap between subscriptions that is not
    considered a churn.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_period_params`—包含定义程序何时查找流失以及订阅之间允许的最大间隔（不被视为流失）的固定常数。'
- en: '`end_dates`—Contains all subscriptions that have end dates within the desired
    periods. As a convenience for the next step, it also calculates the maximum date
    for which an extension could occur to extend this end date: the end date plus
    the allowed gap defined in the parameters.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_dates`—包含所有在所需时间段内有结束日期的订阅。为了方便下一步操作，它还计算了可以延长此结束日期的最大日期：结束日期加上参数中定义的允许的间隔。'
- en: '`extensions`—Contains every subscription end date that has another subscription
    that extends it (an extension). This is any subscription for a matching account
    that begins before the maximum extension date (calculated in the `end_dates` CTE)
    and has an end date in the future or a `null` end date.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extensions`—包含所有具有另一个扩展其订阅（扩展）的订阅结束日期。这是任何在最大扩展日期（在`end_dates` CTE中计算）之前开始且具有未来结束日期或`null`结束日期的匹配账户的订阅。'
- en: '`churns`—A recursive CTE that performs the key calculation of the algorithm:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`churns`—一个递归CTE，执行算法的关键计算：'
- en: The initializing `SELECT` statement is an outer join between the end dates and
    the extensions, which selects only end dates that don’t have an extension. These
    are the churns.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`SELECT`语句是结束日期和扩展的外连接，它只选择没有扩展的结束日期。这些是取消订阅。
- en: The recursive `SELECT` statement finds earlier start dates for subscriptions
    that come before the churn for the same account; the earliest of these is the
    beginning of the active period.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归的`SELECT`语句找到在相同账户的取消订阅之前的订阅的较早开始日期；这些中的最早的是活跃期的开始。
- en: The final `SELECT` statement in listing 4.2 finds the minimum start date corresponding
    to every end date that is a churn the same way as in listing 4.1 for active periods
    that are still active. It also contains the `INSERT` statement to save this result
    along with the ongoing active periods in the `active_period` table. Crucially,
    the end dates of the subscriptions that had no extension are the churn dates.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2中的最后一个`SELECT`语句以与列表4.1中活跃期仍然活跃的方式找到每个结束日期对应的最低开始日期。它还包含`INSERT`语句，将此结果与`active_period`表中的持续活跃期一起保存。关键的是，没有扩展的订阅的结束日期是取消订阅日期。
- en: Listing 4.2 Active periods that end in churn
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 以取消订阅结束的活跃期
- en: '[PRE3]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① This CTE holds constant parameters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE持有常量参数。
- en: ② Maximum time without a subscription before churn
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在取消订阅前的最大无订阅时间
- en: ③ Latest date to consider for finding churns
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 用于查找取消订阅的最新日期
- en: ④ Earliest date to consider for finding churns
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 用于查找取消订阅的最早日期
- en: ⑤ This CTE contains unique start and end dates for every account.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 此CTE包含每个账户的唯一开始和结束日期。
- en: ⑥ Uses DISTINCT in case multiple subscriptions have the same end
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果多个订阅有相同的结束日期，则使用DISTINCT
- en: ⑦ Date by which the account should be re-signed up to avoid churn
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 账户应重新注册以避免取消订阅的日期
- en: ⑧ Limit to end dates within the period being checked for churns
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 限制在检查取消订阅期间的结束日期
- en: ⑨ This CTE contains subscriptions that extend the end dates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 此CTE包含扩展结束日期的订阅。
- en: ⑩ Uses DISTINCT in case multiple subscriptions have the same date
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果多个订阅有相同的日期，则使用DISTINCT
- en: ⑪ Other subscription must start by the date the extension period ends.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 其他订阅必须从扩展期结束的日期开始。
- en: ⑫ Other subscription must have an end date after the original.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 其他订阅必须有一个在原始结束日期之后的结束日期。
- en: ⑬ This CTE identifies churns and finds the period start dates.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 此CTE识别取消订阅并找到周期开始日期。
- en: ⑭ The end date of the subscription is the churn date.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 订阅的结束日期是取消订阅日期。
- en: ⑮ Identifies churns with an outer join
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 通过外连接识别取消订阅
- en: ⑯ Joins the end dates and extensions
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 连接结束日期和扩展
- en: ⑰ Identifies churns that don’t have extensions
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 识别没有扩展的取消订阅
- en: ⑱ The recursive SELECT finds the earliest start date.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 递归SELECT找到最早开始日期。
- en: ⑲ Inserts the result in the active_periods table
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 将结果插入到active_periods表中
- en: ⑳ Selects the minimum start date for each churn
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ⑳ 选择每个取消订阅的最小开始日期
- en: 'Run listing 4.2 by following the instructions in this book’s downloadable code.
    If you ran the other listings, then by now you know how to do this by changing
    the parameters of the wrapper program to `—chapter 4 —listing 2`. Note that listing
    4.2 performs an insert into the database, just like listing 4.1\. It does not
    produce any output (the code that runs the listing prints the SQL that is being
    run). To see the result after you have run listing 4.2, run a query like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本书可下载代码中的说明运行列表4.2。如果您运行了其他列表，那么现在您知道如何通过更改包装程序的参数为`—chapter 4 —listing 2`来做这件事。请注意，列表4.2执行数据库插入操作，就像列表4.1一样。它不会产生任何输出（运行列表的代码打印正在运行的SQL）。要查看运行列表4.2后的结果，运行如下查询：
- en: '[PRE4]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Figure 4.9 shows the results of running listing 4.2 on the default simulated
    dataset and then viewing the results with a `SELECT` statement like the previous
    one. Use a `LIMIT` clause if you have a large amount of data, but you shouldn’t
    need it for the default simulation. Active periods ending in churn begin in all
    parts of the simulation times and have a variety of lengths. Due to the constraint
    on the `active_period` table, you can run this SQL only once without deleting
    the data already in the table.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9展示了在默认模拟数据集上运行列表4.2的结果，然后使用类似于之前的`SELECT`语句查看结果。如果你有大量数据，请使用`LIMIT`子句，但对于默认模拟，你可能不需要它。活跃期结束时的活跃期开始于模拟时间的所有部分，并且长度各异。由于`active_period`表的约束，你只能运行此SQL一次，而无需删除表中已有的数据。
- en: '![](../Images/4-09.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-09.png)'
- en: Figure 4.9 Result of running listing 4.2 for the active periods ending in churn
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 运行列表4.2的活跃期结束时的结果
- en: 4.4 Identifying active periods for nonsubscription products
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 为非订阅产品识别活跃期
- en: Since chapter 1, I have been telling you that the techniques for analyzing churn
    in this book apply to products without actual subscriptions, like ad-supported
    media, apps with in-app purchases, and retail websites. Now I will (finally) explain
    how to calculate the active periods for those accounts. I waited until now because,
    at this point, you have learned the necessary techniques.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一章开始，我就一直在告诉你，本书中分析流失的技术适用于没有实际订阅的产品，如广告支持的媒体、带有应用内购买的APP和零售网站。现在（终于）我将解释如何计算这些账户的活跃期。我等到现在是因为，到这个时候，你已经学到了必要的技巧。
- en: 4.4.1 Active period definition
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 活跃期定义
- en: In chapter 2, I mentioned that the key to understanding churn in nonsubscription
    products is to calculate active periods that reflect the periods when an individual
    account was live on the product, similar to a subscription. In this context, a
    churn is defined to be whenever an account goes inactive for more than some maximum
    allowed time, typically one month or a few months. You should choose this time
    limit so that most people who go inactive don’t come back, or if they do, it would
    be fair to consider it a fresh start.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我提到，理解非订阅产品流失的关键是计算反映个人账户在产品上活跃的时期的活跃期，类似于订阅。在这种情况下，流失被定义为账户在超过一些最大允许时间后变得不活跃。你应该选择这个时间限制，以便大多数变得不活跃的人不会回来，或者如果他们回来了，也应该公平地将其视为一个新的开始。
- en: Figure 4.10 presents the idea of active periods derived from events. The point
    is to find, for each account, groups of events in which no events are farther
    apart than the allowed gap. Once such active periods are calculated, the churn
    rate can be calculated as if these were subscriptions. Also, all the analytic
    techniques described in the rest of the book can be applied without any other
    modifications.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10展示了从事件中派生的活跃期的概念。目的是为每个账户找到一组事件，其中没有事件之间的间隔超过允许的间隔。一旦计算出这样的活跃期，就可以像订阅一样计算流失率。此外，本书中描述的所有分析技术都可以应用，无需任何其他修改。
- en: DEFINITION Active period derived from events —A span of time when a user has
    had at least one event. There can be gaps between events up to the limit, without
    disrupting the active period. The definition of active periods from events is
    similar to the definition of active periods from multiple subscriptions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：从事件中派生的活跃期——一个用户至少有一个事件的时间段。事件之间可以有间隔，但不超过限制，不会打断活跃期。从事件中派生的活跃期的定义与从多个订阅中派生的活跃期的定义相似。
- en: '![](../Images/4-10.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-10.png)'
- en: Figure 4.10 Active periods from events
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 从事件中派生的活跃期
- en: 'Here’s the basic idea: in the last section, I demonstrated algorithms in SQL
    to handle scenarios where accounts can have multiple subscriptions over time.
    It’s necessary to find the earliest start date of any of those subscriptions and
    to find when sequences of subscriptions end. All those calculations on subscriptions
    also include an allowed gap, in case customers have short periods of time without
    a subscription. If you think about it, that’s exactly the calculation that needs
    to happen with events to determine periods when accounts are active. The subscriptions
    and events both have to be grouped so that no subscription/event in the group
    is further apart than an allowed gap. The only difference is that a subscription
    has a duration (a subscription has an end date that comes after the start date),
    but an event is at a single point in time. An algorithm similar to the one used
    to find active periods from subscriptions will work to find active periods from
    events.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路是这样的：在上一个部分，我展示了如何使用 SQL 算法处理账户在一段时间内可能拥有多个订阅的情况。找到这些订阅中任何一个的最早开始日期以及订阅序列何时结束是必要的。所有这些关于订阅的计算还包括一个允许的间隔，以防客户在订阅之间有短暂的空档期。如果你这么想，这正是确定账户活跃期间所需进行的计算。订阅和事件都需要分组，以确保组内没有任何订阅/事件之间的间隔超过允许的间隔。唯一的区别是，订阅有一个持续时间（订阅的结束日期在开始日期之后），但事件是在一个特定的时间点。一个类似于从订阅中查找活跃期间的算法也可以用来从事件中查找活跃期间。
- en: 'But there is one important difference between subscriptions and events that
    impacts the performance of this algorithm, if not the logic: accounts typically
    have only one or a few subscriptions at a time, but accounts can have a very large
    number of events. To put it another way, subscriptions are usually small data,
    whereas events are often big data. It might not be a good idea, therefore, to
    apply the active period algorithms from the last section directly to the events.
    Instead, make a simplification: define an active week as seven days during which
    an account has any event.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，订阅和事件之间有一个重要的区别，这会影响该算法的性能，如果不是逻辑：账户通常一次只有一到几个订阅，但账户可以有非常大量的事件。换句话说，订阅通常是小数据，而事件通常是大数据。因此，直接将上一节中提到的活跃期间算法应用于事件可能不是一个好主意。相反，进行简化：定义一个活跃周为账户在这七天内发生任何事件的七天。
- en: DEFINITION Active week —A seven-day period when an account has at least one
    event.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：活跃周——一个账户在七天内至少有一个事件的七天周期。
- en: The first step is to calculate which weeks are active for all accounts. This
    can be done by using an aggregation query and saving the result. This simple first
    step reduces the size of the data for the steps that follow. If your users typically
    have 100 events per week (for example), then after aggregation, the data representing
    the activity is one-hundredth the size. And if customers have 1,000 events per
    week . . . (you get the drift).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算所有账户哪些周是活跃的。这可以通过使用聚合查询并保存结果来完成。这个简单的第一步减少了后续步骤所需的数据量。如果你的用户通常每周有 100
    个事件（例如），那么在聚合之后，表示活动数据的大小就减少到原来的百分之一。如果客户每周有 1,000 个事件……（你明白我的意思）。
- en: Of course, such active periods allow accuracy in identifying churn dates only
    up to the weekly interval defined for measuring activity in the aggregation step.
    These active periods do not tell you the precise date or time the user became
    active or churned. If you think the weekly period is not accurate enough for finding
    the start and end of the active periods, switch to daily aggregation. Then you
    can have daily precision in the computation, which is seven times as much. If
    that works for the size of your data and the system you use to run the process,
    no problem. It’s a trade-off between the accuracy you want in timing churns versus
    the size of the data you have and the available computing resources. I will continue
    with the examples assuming weekly aggregation periods, because this is usually
    the best compromise between accuracy and computational cost.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的活跃期间只能精确到聚合步骤中定义的每周间隔，以识别流失日期。这些活跃期间并不能告诉你用户何时变得活跃或流失的确切日期或时间。如果你认为每周的周期对于找到活跃期间的开始和结束不够精确，可以切换到每日聚合。这样你就可以在计算中获得每日的精确度，这是每周精确度的七倍。如果这对你的数据规模和运行过程的系统来说没问题，那就没问题。这是在所需的时间精度和拥有的数据规模以及可用的计算资源之间的一种权衡。我将继续使用假设每周聚合周期的例子，因为这通常是精度和计算成本之间最好的折衷方案。
- en: 4.4.2 Process for forming datasets from events
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 从事件形成数据集的过程
- en: 'After the active weeks are calculated, you can use the ongoing active period
    algorithms (listing 4.1) and the churned active period algorithms (listing 4.2)
    on active weeks instead of subscriptions to create the churn analysis dataset.
    Because those algorithms are designed to merge sequential subscriptions, they
    can also merge active weeks, and you can choose to allow no gaps (or gaps consisting
    of any number of weeks) in forming active weeks. (If you choose to work with active
    days, instead, you can run the same algorithm in terms of days with an allowed
    gap defined as a number of days.) The results of running listings 4.1 and 4.2
    on the week are what you are looking for: the dates of continuous periods of time
    when accounts had events (at least one per week). Those active periods are known
    to either have ended in churn in the past or continue up to the present. Figure
    4.11 illustrates the complete process for forming a churn dataset from events.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算完活跃周之后，你可以使用持续活跃期算法（列表4.1）和已流失活跃期算法（列表4.2）对活跃周进行处理，而不是使用订阅来创建流失分析数据集。因为这些算法旨在合并连续的订阅，它们也可以合并活跃周，你可以选择在形成活跃周时允许没有间隔（或任何数量的周组成的间隔）。（如果你选择使用活跃日，而不是活跃周，你可以运行相同的算法，以天为单位，允许的间隔定义为天数。）运行列表4.1和4.2的结果就是你要找的：账户在连续时间段内发生事件（每周至少一次）的日期。这些活跃期已知在过去已经结束流失或一直持续到目前。图4.11说明了从事件形成流失数据集的完整过程。
- en: '![](../Images/4-11.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-11.png)'
- en: Figure 4.11 Process for finding event-based periods of activity
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 基于事件的活动周期查找过程
- en: 'If you compare the process for forming a dataset from events without subscriptions
    (figure 4.11) to the process of forming a dataset from subscriptions in the last
    section, the only difference is one extra step at the beginning: grouping events
    into weeks of activity. Because the rest of the process is the same, the weekly
    grouping is the only new code necessary.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将形成事件数据集的过程（图4.11）与上一节中形成订阅数据集的过程进行比较，唯一的区别是在开始时多了一步：将事件分组到活动周。因为其余的过程是相同的，所以每周分组是唯一需要的新代码。
- en: 4.4.3 SQL for calculating active weeks
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 计算活跃周的SQL
- en: Because the weeks with activity are stored, you need to create a database table
    to hold them, using the schema shown in table 4.2\. This is similar to the schemas
    you have seen for subscriptions and active periods. For active weeks, the end
    date is redundant with the start date because the start date uniquely identifies
    the end date for a fixed-length period. But including the end date allows the
    SQL programs used for subscriptions in the last section to work with the active
    weeks without changing the logic of the queries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因为存储了有活动的周，你需要创建一个数据库表来保存它们，使用表4.2中显示的架构。这与你之前看到的订阅和活跃期架构类似。对于活跃周，结束日期与开始日期是冗余的，因为开始日期唯一地标识了固定长度周期的结束日期。但包括结束日期允许上一节中用于订阅的SQL程序与活跃周一起工作，而不改变查询的逻辑。
- en: Table 4.2 Active weeks table schema
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 活跃周表架构
- en: '| Column | Type | Notes |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `account_id` | `integer` or `char` | Not null; compound key |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer`或`char` | 不为空；复合键 |'
- en: '| `start_date` | `date` | Not null; compound key |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `start_date` | `date` | 不为空；复合键 |'
- en: '| `end_date` | `date` | Not null |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `end_date` | `date` | 不为空 |'
- en: Listing 4.3 provides the SQL for grouping events into weeks with activity. This
    technique is known to anyone who knows aggregate `GROUP BY` queries because the
    main logic of the query is to make groups of events defined by one-week periods.
    The only remarkable technique in listing 4.3 is using a generated series function
    to pick the dates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3提供了将事件分组到周活动的SQL语句。这个技术对于任何了解聚合`GROUP BY`查询的人来说都是众所周知的，因为查询的主要逻辑是按照一周的时间段定义事件组。列表4.3中唯一值得注意的技术是使用生成序列函数来选择日期。
- en: Listing 4.3 Grouping events into weeks of activity
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 将事件分组到周活动的代码
- en: '[PRE5]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① This CTE holds a sequence of weekly intervals.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此CTE包含一系列周间隔。
- en: ② Inserts the result into the active_periods table
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将结果插入到`active_periods`表
- en: ③ The start and end of each period from the sequence
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 序列中每个周期的开始和结束
- en: ④ Event time is greater than or equal to the period start.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 事件时间大于或等于周期开始。
- en: ⑤ Event time must be strictly less than the period end.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 事件时间必须严格小于周期结束。
- en: ⑥ GROUP BY account ID and period dates
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 按`account ID`和周期日期分组
- en: 'Run listing 4.3 by following the instructions in the book’s downloadable code.
    Using the wrapper program, change the parameters to `—chapter 4 —listing 3`. Note
    that listing 4.3 performs an insert into the database, just like listings 4.1
    and 4.2, so it does not produce any output. (The code that runs the listing prints
    the SQL that is being run.) To see the result after you have run listing 4.3,
    run a query like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按照书中可下载代码的说明运行列表 4.3。使用包装程序，将参数更改为 `—chapter 4 —listing 3`。请注意，列表 4.3 在数据库中执行插入操作，就像列表
    4.1 和 4.2 一样，因此不会产生任何输出。（运行列表的代码会打印正在运行的 SQL 语句。）要查看运行列表 4.3 后的结果，请运行类似以下的查询：
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 4.12 shows the results of running listing 4.3 on the default simulated
    dataset and then viewing the results with a `SELECT` statement like the previous
    one. Use a `LIMIT` clause if you have a large amount of data, but you shouldn’t
    need it for the default simulation. Note that the code saved in the GitHub repository
    is not set up to calculate active periods from the active weeks. I encourage you
    to make those modifications yourself.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 显示了在默认模拟数据集上运行列表 4.3 的结果，然后使用类似于之前的 `SELECT` 语句查看结果。如果你有大量数据，请使用 `LIMIT`
    子句，但对于默认模拟通常不需要。请注意，GitHub 仓库中保存的代码没有设置为从活跃周计算活跃期。我鼓励你自己进行这些修改。
- en: '![](../Images/4-12.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](../Images/4-12.png)'
- en: Figure 4.12 Example output from running listing 4.3
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 运行列表 4.3 的示例输出
- en: After calculating active weeks and saving them in a table, you can use the same
    programs as in listings 4.1 and 4.2 to find active periods. Modify these to use
    the `active_week` table (table 4.2) instead of the subscription table (table 2.1).
    Once you calculate active periods from the active weeks, these can be used in
    place of subscriptions in the standard churn calculation in chapter 2 (listing
    2.2).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算活跃周并将它们保存到表中之后，你可以使用列表 4.1 和 4.2 中的相同程序来查找活跃期。将这些程序修改为使用 `active_week` 表（表
    4.2）而不是订阅表（表 2.1）。一旦从活跃周计算出活跃期，这些就可以在第二章的标准流失计算（列表 2.2）中替代订阅使用。
- en: NOTE To use the programs in listings 4.1 and 4.2 with active weeks derived from
    activity instead of subscriptions, modify the code by replacing the `subscription`
    table in the joins with the `active_period` table; no other changes are required.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要使用列表 4.1 和 4.2 中的程序，并使用从活动而非订阅中得出的活跃周，请通过将连接中的 `subscription` 表替换为 `active_period`
    表来修改代码；不需要进行其他更改。
- en: NOTE To use the program in listing 2.2 to calculate the churn rate from activity
    instead of subscriptions, modify the code by replacing the subscription table
    in the joins with the `active_period` table; also, the `churn_date` column in
    `active_period` replaces the `end_date` column from the `subscription` table.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要使用列表 2.2 中的程序计算从活动而非订阅中的流失率，请通过将连接中的订阅表替换为 `active_period` 表来修改代码；此外，`active_period`
    中的 `churn_date` 列替换了 `subscription` 表中的 `end_date` 列。
- en: 4.5 Picking observation dates
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 选择观察日期
- en: Your goal is to make regular observations of your subscribers at appropriate
    times to understand why they churn. Once the subscriptions (or events) have been
    divided into active periods (whether from subscriptions or activity), the next
    step is to pick the actual observation dates for each account.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是定期在适当的时间观察你的订阅者，以了解他们为何会流失。一旦订阅（或事件）被划分为活跃期（无论来自订阅还是活动），下一步就是为每个账户选择实际的观察日期。
- en: 4.5.1 Balancing churn and nonchurn observations
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 平衡流失和非流失观察
- en: As I described in section 4.2, the idea is not only to observe accounts when
    they churn but also to take snapshots of accounts when they don’t churn. The churn
    analysis works best when the churn and nonchurn observations in the dataset are
    in the same proportion as the churn rate and renewal rates. The way to accomplish
    that is to observe every account on the same periodic cycle that you use when
    calculating your churn rate. Also recall that the observations are offset by a
    lead time. As described in section 4.2, the lead time is designed so the observation
    is made at a point before the customer has probably made up their mind about churning
    or staying. This process was illustrated previously in figure 4.3 and is reproduced
    in figure 4.13.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第4.2节中描述的，这个想法不仅是在账户流失时观察账户，还要在账户没有流失时对账户进行快照。当数据集中的流失和非流失观察与流失率和续订率成比例时，流失分析效果最佳。实现这一目标的方法是观察每个账户在计算流失率时使用的相同周期周期。此外，请记住，观察是提前进行的。正如第4.2节中所述，提前期被设计得如此之短，以至于在客户可能已经决定是否流失或留下之前进行观察。这个过程之前在图4.3中已经说明，并在图4.13中重现。
- en: '![](../Images/4-13.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13](../Images/4-13.png)'
- en: 'Figure 4.13 Reprise: payment cycle dates, lead time, and observation sequences'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 重述：支付周期日期、提前期和观察序列
- en: 'As shown, in addition to observing customers before they churn, observations
    should be made periodically throughout the subscription. These observations should
    be made at the same frequency that the organization measures its churn, which
    is normally the same frequency with which customers renew (for termed subscriptions)
    or pay their bills (for evergreen subscriptions): annual frequency for B2B (business)
    products and monthly frequency for B2C (consumer) or SMB (small and medium businesses)
    products. For consistency with churn observations, these observations are made
    with a lead time before each payment or renewal.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，除了在客户流失前观察客户外，在整个订阅期间应定期进行观察。这些观察应以与组织衡量其流失频率相同的频率进行，这通常与客户续订（对于定期订阅）或支付账单（对于常青订阅）的频率相同：B2B（商业）产品的年度频率和B2C（消费者）或SMB（小型和中型企业）产品的月度频率。为了与流失观察保持一致，这些观察在每次支付或续订前都使用提前期。
- en: 4.5.2 Observation date-picking algorithm
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 观察日期选择算法
- en: 'Considering figure 4.13, the detailed algorithm for picking the observation
    dates is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图4.13，选择观察日期的详细算法如下：
- en: Begin with the start date of every active period for each account.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个账户每个活跃期间的起始日期开始。
- en: 'For the first observation:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于首次观察：
- en: Add the periodic time interval at which you will be making observations (for
    example, a month) to the start date separately for all accounts and active periods.
    For subscriptions, this is usually the next payment or renewal date.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你将进行观察的周期时间间隔（例如，一个月）分别加到所有账户和活跃期间的起始日期上。对于订阅，这通常是下一次支付或续订日期。
- en: Subtract the lead time to find the first observation date in each active period.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去提前期以找到每个活跃期间的首次观察日期。
- en: If this observation date is followed by a churn, flag it as a churn observation,
    meaning if the active period ends in churn between this observation and one observation
    period later, then this is the last observation before the churn.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此观察日期之后发生流失，将其标记为流失观察，这意味着如果活跃期间在这次观察和下一次观察期间结束流失，那么这是流失前的最后一次观察。
- en: 'For the second observation on each account:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个账户的第二次观察：
- en: Add two times the observation period to the start dates for each account.
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将观察期的时间加倍加到每个账户的起始日期上。
- en: Subtract the lead time.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去提前期。
- en: If this observation date is followed by a churn, flag it as a churn observation.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此观察日期之后发生流失，将其标记为流失观察。
- en: Repeat step 3 for each account, incrementing the number of periods added to
    the start (and always subtracting the lead time) until the next observation date
    is beyond the active period.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个账户重复步骤3，将添加到起始日期的周期数递增（并且始终减去提前期），直到下一个观察日期超出活跃期。
- en: An example of running the algorithm for picking monthly observation dates with
    a seven-day lead time for two accounts is shown in figure 4.14\. It demonstrates
    that after some initial calculation, each account is repeatedly observed on the
    same day of the month. If there are monthly payments or subscription renewals,
    the date is timed to be one week before the monthly payment. If this were a product
    with an annual subscription, the observation dates would be on the same day every
    year. Again, the observations would be timed to have a lead time before the annual
    renewal (or payment), and the lead time would be longer—one to three months, as
    described in section 4.2—but the idea is the same.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 展示了运行算法选择每月观察日期的示例，其中有两个账户，提前期为七天。它表明在初始计算之后，每个账户都会在每月的同一天重复观察。如果有月度付款或订阅续订，日期会被安排在每月付款前一周。如果这是一个年度订阅的产品，观察日期将每年在同一天。再次强调，观察会被安排在年度续订（或付款）之前有提前期，提前期会更长——一到三个月，如第
    4.2 节所述，但原理是相同的。
- en: '![](../Images/4-14.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-14.png)'
- en: Figure 4.14 Illustration of the observation date-picking algorithm
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 观察日期选择算法示意图
- en: To pick observation dates for each account, begin with the start date for each
    active period and add the observation period (one month, in this example) less
    the lead time (one week) to get the first observation date. To get the second
    observation date, add two times the observation period, less the lead time, to
    the start date. To get the third observation date, add three times the observation
    period, less the lead time, and so on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个账户选择观察日期，从每个活跃期的起始日期开始，加上观察周期（在这个例子中是一个月），再减去提前期（一周），以得到第一个观察日期。要得到第二个观察日期，将观察周期加两次，再减去提前期，加到起始日期上。要得到第三个观察日期，将观察周期加三次，再减去提前期，依此类推。
- en: 4.5.3 Observation date SQL program
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 观察日期 SQL 程序
- en: 'Because the observation dates are stored, at least temporarily, you need to
    create another table for them. Table 4.3 shows the schema to hold the observation
    dates. This table contains the account ID and observation date, which together
    define a compound primary key on the table, and one additional column: a logical
    value that tracks whether the observation is the last observation in an active
    period ending in churn.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因为观察日期被存储，至少暂时如此，所以你需要为它们创建另一个表。表 4.3 展示了用于存储观察日期的架构。此表包含账户 ID 和观察日期，这两者共同定义了表上的复合主键，以及一个额外的列：一个逻辑值，用于跟踪观察是否是导致流失的活跃期结束时的最后一个观察。
- en: Observation dates table schema
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 观察日期表架构
- en: '| Column | Type | Notes |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 类型 | 备注 |'
- en: '| `account_id` | `integer` or `char` | Not null; compound key |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `account_id` | `integer` 或 `char` | Not null; compound key |'
- en: '| `observation_date` | `date` | Not null; compound key |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `observation_date` | `date` | Not null; compound key |'
- en: '| `is_churn` | `logical` | Not null |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `is_churn` | `logical` | Not null |'
- en: 'Listing 4.4 provides the SQL program to produce the observation dates. It assumes
    there is a table `active_period` with periods defined from subscriptions. The
    SQL program for generating observation dates uses a recursive CTE, and the strategy
    for creating the observation dates recursively is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 提供了生成观察日期的 SQL 程序。它假设存在一个 `active_period` 表，其中包含从订阅中定义的周期。生成观察日期的 SQL
    程序使用递归 CTE，创建观察日期的递归策略如下：
- en: 'Initialize the recursive CTE with one observation for every `active_period`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化递归 CTE，为每个 `active_period` 设置一个观察：
- en: Pick the first observation date to be one observation interval after the start
    date, less the lead time.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个观察日期为起始日期后的一个观察间隔，减去提前期。
- en: Set a counter to 1 on the observation. This is used to calculate the time of
    later observations.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在观察上设置计数器为 1。这用于计算后续观察的时间。
- en: Set a Boolean indicating whether the churn date is between that observation
    date and the next observation date, which will be the observation interval after
    this observation date.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个布尔值，指示流失日期是否在观察日期和下一个观察日期之间，这将是在此观察日期之后的观察间隔。
- en: 'Recursively insert additional observation dates into the CTE for each active
    period:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地插入每个活跃期的额外观察日期到 CTE 中：
- en: Increment the counter by one.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计数器加一。
- en: The new observation date is calculated from the start date plus the new counter
    value multiplied by the observation period, less the lead time.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的观察日期是从起始日期加上新的计数器值乘以观察周期，再减去提前期计算得出的。
- en: Set a Boolean indicator on every observation so that an observation that immediately
    precedes the end of the active period (the churn) is set to true.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个观测上设置一个布尔指示符，以便紧接活跃期结束（流失）的观测被设置为 true。
- en: 'Exit recursion when one of the following conditions is met:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当满足以下条件之一时退出递归：
- en: The next observation date is after the end of the active period.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个观测日期是在活跃期结束之后。
- en: The next observation date is after the end of the overall period being considered.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个观测日期是在考虑的整体周期结束之后。
- en: 'The SQL program for the observation dates uses just two CTEs: one to set the
    constant parameters and one for the recursion. After this recursive procedure,
    the results are inserted into the observation table. The SQL program in listing
    4.4 uses a one-month observation interval and one week of lead time.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 观测日期的 SQL 程序仅使用两个 CTE：一个用于设置常数参数，另一个用于递归。在此递归过程之后，结果被插入到观测表中。列表 4.4 中的 SQL 程序使用一个月的观测间隔和一周的提前时间。
- en: Listing 4.4 SQL for observation dates
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 观测日期的 SQL
- en: '[PRE7]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① The RECURSIVE keyword goes at the beginning.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ① RECURSIVE 关键字位于开头。
- en: ② This CTE holds constant parameters.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此 CTE 保持常数参数。
- en: ③ Observations are one calendar month apart.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 观测之间相隔一个月的日历月。
- en: ④ Observations are made with a lead time of seven days prior.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 观测是在提前七天进行。
- en: ⑤ Observations are made between these dates.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 观测是在这些日期之间进行的。
- en: ⑥ This recursive CTE holds the sequences of observation dates.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 此递归 CTE 包含观测日期的序列。
- en: ⑦ Initializes with a record for the first observation of each account
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 初始化每个账户的第一个观测记录
- en: ⑧ Counter to determine the later observation dates
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 计数器用于确定后续的观测日期
- en: ⑨ The observation is one period after the start, less the lead time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 观测是在开始后一个周期，减去提前时间。
- en: ⑩ Sets is_churn to true if churn is between the observation and the next period
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果流失发生在观测和下一个周期之间，则将 is_churn 设置为 true。
- en: ⑪ Skips cases where churn comes before the first observation
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 跳过流失发生在第一次观测之前的案例。
- en: ⑫ The recursive SELECT adds additional observations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 递归的 SELECT 添加了额外的观测。
- en: ⑬ Increments the counter by one with each new observation
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 每次新的观测增加计数器一次
- en: ⑭ Starts plus the counter times the interval, less the lead time
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 开始时间加上计数器乘以间隔，减去提前时间
- en: ⑮ Sets is_churn to true if the churn is between the observation and the next
    period
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 如果流失发生在观测和下一个周期之间，则将 is_churn 设置为 true。
- en: ⑯ Don’t add an observation if it would go past the date limit.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 如果观测会超过日期限制，则不要添加观测。
- en: ⑰ Joins with the previous result by account
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 通过账户与上一个结果进行连接
- en: ⑱ Adds new observations for subscription periods that continue
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 为继续的订阅周期添加新的观测。
- en: 'Run listing 4.4 by following the instructions in the book’s downloadable code.
    Using the wrapper program, change the parameters to `—chapter 4 —listing 4`. Note
    that like listings 4.1-4.3, listing 4.4 performs an insert into the database,
    so it does not produce any output. (The code that runs the listing prints the
    SQL that is being run.) To see the result after you have run listing 4.4, run
    a query like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 按照书中可下载代码的说明运行列表 4.4。使用包装程序，将参数更改为 `—chapter 4 —listing 4`。请注意，与列表 4.1-4.3 一样，列表
    4.4 在数据库中执行插入操作，因此不会产生任何输出。（运行列表的代码会打印正在运行的 SQL。）要查看运行列表 4.4 后的结果，请运行如下查询：
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 4.15 shows the results of running listing 4.4 on the default simulated
    dataset and then viewing the results with a `SELECT` statement like the previous
    one. Use a `LIMIT` clause if you have a large amount of data, but you shouldn’t
    need it for the default simulation. The observations where `is_churn = TRUE` are
    those that occur immediately before the churn date. For each account, the observation
    dates are spaced one month apart, as specified by the observation interval.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 显示了在默认模拟数据集上运行列表 4.4 的结果，然后使用类似于前面的 `SELECT` 语句查看结果。如果你有大量数据，请使用 `LIMIT`
    子句，但对于默认模拟通常不需要。`is_churn = TRUE` 的观测是在流失日期之前立即发生的。对于每个账户，观测日期按照观测间隔均匀分布，如指定。
- en: '![](../Images/4-15.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-15.png)'
- en: Figure 4.15 Example output of running listing 4.4
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 运行列表 4.4 的示例输出
- en: 'You might wonder why the SQL program in listing 4.4 keeps a counter and multiplies
    it by the observation period duration to calculate each observation date. This
    leads to the following expression appearing repeatedly in the code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么列表 4.4 中的 SQL 程序保持一个计数器并将其乘以观测期持续时间来计算每个观测日期。这导致代码中反复出现以下表达式：
- en: '[PRE9]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An alternative would be to add the observation period to the last observation
    date. Although it would be simpler to add the observation period to dates in sequence,
    doing so would lead to poor handling for dates around the month’s end: for example,
    if the start date is the 31st. Then when February comes around, the day of the
    month would become the 28th. This is how the database defines the result when
    you add a month to January 31\. But when the next month rolls around, if the algorithm
    simply adds the observation period, it does not shift the date back to the 31st;
    it would use March 28 and continue to use the 28th in subsequent months. In non-leap
    years, all end-of-month renewals would be shifted to the 28th after February.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将观察期添加到最后一次观察日期。虽然将观察期按顺序添加到日期会更简单，但这样做会导致月末日期处理不当：例如，如果起始日期是31日。那么当二月到来时，月份的天数会变成28日。这就是数据库在将月份加到1月31日时定义的结果。但是当下一个月到来时，如果算法简单地添加观察期，它不会将日期回移到31日；它会使用3月28日，并在随后的月份继续使用28日。在非闰年，所有月末续订都会在二月之后移至28日。
- en: By multiplying the observation period and adding it to the start date anew on
    each observation, a renewal on the 31st is treated as the 31st in every month
    with 31 days. Although it shifts as necessary in a month with fewer days, it does
    not change the result in subsequent months.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将观察期乘以并添加到每个观察的起始日期，31日的续订被视为每个月有31天的31日。尽管在天数较少的月份中会相应地调整，但它不会改变后续月份的结果。
- en: 4.6 Exporting a churn dataset
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 导出流失数据集
- en: The final step in creating the dataset is to select all the metrics for the
    accounts on the dates of their observations. In principle, this is simple, but
    as usual, there are a few complications.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据集的最终步骤是从观察日期选择所有账户的指标。原则上，这很简单，但像往常一样，还有一些复杂的情况。
- en: An important part of extracting the dataset is to transform the data from the
    convention of database tables to the convention of analytic datasets, which is
    illustrated in figure 4.16\. In an analytic dataset, you have to arrange the data
    so that each row corresponds to a single observation of an account (that churned
    or didn’t), and each column corresponds to one behavioral metric. In the database
    table, though, the data is normalized so the values of all metrics are in a single
    column, and another column identifies which metrics are on a given row. In the
    database, the behavioral snapshot for a single account on a single date is spread
    over many rows. This is often referred to as wide data versus tall data. An analytic
    dataset is wide because it has many columns for all the different variables; a
    database table is tall because the data is all stacked up in one column. Converting
    data from tall to wide is often known as flattening the data, and that is what
    you must do to create the churn dataset. (It is also referred to as pivoting the
    data by those who have seen this done with the Pivot function in a spreadsheet.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 提取数据集的一个重要部分是将数据从数据库表的传统格式转换为分析数据集的格式，这在图4.16中有说明。在分析数据集中，你必须安排数据，使得每一行对应一个账户的单次观察（无论是流失了还是未流失），每一列对应一个行为指标。然而，在数据库表中，数据是归一化的，因此所有指标的值都在一个单独的列中，另一个列标识了给定行中的哪些指标。在数据库中，单个账户在单个日期的行为快照分布在许多行中。这通常被称为宽数据与长数据。分析数据集是宽的，因为它有多个列用于所有不同的变量；数据库表是长的，因为数据都堆叠在一个列中。将数据从长转换为宽通常被称为数据展平，这就是创建流失数据集必须做的事情。（对于那些已经看到在电子表格中使用Pivot函数进行数据旋转的人来说，这也被称为数据旋转。）
- en: 4.6.1 Dataset creation SQL program
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 数据集创建SQL程序
- en: There is a trick to pivoting data in standard SQL; if you know it, feel free
    to skip ahead. If you don’t, get ready to either love it or hate it, but I promise
    you will find yourself using this trick again!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准SQL中进行数据旋转有一个技巧；如果你知道它，可以随意跳过。如果你不知道，准备好要么喜欢它要么讨厌它，但我保证你会再次使用这个技巧！
- en: You can flatten a tall table like the metric table illustrated in figure 4.16
    into a wide dataset with a `GROUP BY` aggregation, where you group all the separate
    rows of metrics for each account into one row for each date. You have probably
    seen the use of aggregation to merge multiple rows into one with a function like
    a sum or an average that combines the values. Aggregate functions can also be
    used to choose specific values from among multiple rows and put each in a specific
    column, which is the transformation needed for flattening.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `GROUP BY` 聚合将如图 4.16 所示的度量表这样的高维表展平为宽数据集，其中将每个账户的单独度量行分组到每个日期的一行中。你可能已经看到了使用聚合函数（如求和或平均值）将多行合并为一行的用法。聚合函数也可以用于从多行中选择特定值并将每个值放入特定的列中，这是展平所需进行的转换。
- en: '![](../Images/4-16.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 4-16](../Images/4-16.png)'
- en: Figure 4.16 Flattening tall data into wide data
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 展平高维数据为宽数据]'
- en: Listing 4.5 shows the trick to flatten data. It uses multiple `SUM` aggregate
    functions, one for each metric that you want to flatten from the tall table to
    the wide table. To take the desired value from the column (and not add anything
    to it), you put a `CASE` statement inside each `SUM` that selects just one type
    of metric value from the tall table. A series of such `SELECT` statements inside
    a `GROUP BY` aggregation effectively flattens the tall data to wide. It isn’t
    pretty, but it works!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 展示了将数据展平的技巧。它使用了多个 `SUM` 聚合函数，每个函数对应于你想要从高维表展平到宽表的每个度量指标。为了从列中获取所需的值（而不是向其添加任何内容），你需要在每个
    `SUM` 函数内放置一个 `CASE` 语句，以从高维表中仅选择一种类型的度量值。一系列这样的 `SELECT` 语句在 `GROUP BY` 聚合内执行，有效地将高维数据展平为宽表。这样做可能不太美观，但它确实有效！
- en: Another complication is that you might not have calculated metrics for your
    accounts every single day. I have encouraged you to calculate metrics just once
    a week. If you follow my advice and do not calculate the metrics every day, then
    when you create the dataset, you need to select metrics that are not necessarily
    on the exact day of the observation. This leads to using a date range for picking
    the metrics in the `SELECT`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂的问题是，你可能并不是每天都为你的账户计算度量指标。我建议你每周只计算一次度量指标。如果你遵循我的建议并且不每天计算度量指标，那么在创建数据集时，你需要选择那些不一定在观察当天存在的度量指标。这导致在
    `SELECT` 中使用日期范围来选择度量指标。
- en: 'One last trick in listing 4.5 is handling cases where a metric was not calculated
    for an account around the observation date at all. Recall that in chapter 3, the
    count and average value metrics were defined so that when an account had no events,
    no metric value was stored. This means for such metrics, there might not be any
    value for the `JOIN` statement in listing 4.5\. But one metric always has a value,
    regardless of the events for an account: the account tenure.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 中的最后一个技巧是处理在观察日期附近没有为账户计算度量指标的情况。回想一下，在第 3 章中，计数和平均值度量指标被定义为当账户没有事件时，不存储任何度量值。这意味着对于这类度量指标，列表
    4.5 中的 `JOIN` 语句可能没有任何值。但有一个度量指标始终有值，无论账户的事件如何：账户使用期限。
- en: The account tenure must always have a value for a user who has active subscriptions
    or is in an active period of usage. The fact that account tenure always has a
    value means the `JOIN` in listing 4.5 always finds at least one metric around
    the observation date for every account. What about the other metrics? The logic
    of the `CASE` statement means any other metrics being flattened are filled with
    zero, which effectively handles the problem of filling missing values for these
    kinds of metrics.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 账户使用期限必须始终有一个值，对于有活跃订阅或处于活跃使用期间的用户来说更是如此。账户使用期限始终有值的事实意味着列表 4.5 中的 `JOIN` 操作始终为每个账户在观察日期周围找到至少一个度量指标。那么其他度量指标呢？`CASE`
    语句的逻辑意味着任何其他被展平的度量指标都将填充为零，这有效地处理了这些类型度量指标的缺失值问题。
- en: WARNING If you do not use the account tenure metric or at least one metric that
    is guaranteed to have a value for every account every time you calculate it, then
    the query in listing 4.5 might drop account observations with no metrics. This
    problem can be solved with an outer join between the metrics and the observations,
    but my recommendation is to include the account tenure in your analysis.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：如果你在每次计算时都不使用账户使用期限度量指标或至少一个保证每个账户每次计算都有值的度量指标，那么列表 4.5 中的查询可能会丢弃没有度量指标的账户观察结果。这个问题可以通过度量指标和观察结果之间的外连接来解决，但我的建议是在你的分析中包含账户使用期限。  '
- en: Listing 4.5 uses a CTE to hold constant parameters, including one that is the
    metric calculation interval. The `INNER JOIN` statement uses the metric interval
    to select the last metric calculated within the seven days before the observation
    date.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 使用 CTE 来保存常量参数，包括一个指标计算间隔。`INNER JOIN` 语句使用指标间隔来选择在观测日期前七天内计算的最后指标。
- en: NOTE The output of listing 4.5 also includes the account ID and the observation
    date. Although not necessary for the analysis, this kind of descriptive data is
    often useful for quality-checking the data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：列表 4.5 的输出还包括账户 ID 和观测日期。尽管这些信息对于分析不是必需的，但这种描述性数据对于数据质量检查通常很有用。
- en: In the next chapter, you’ll spend more time looking at how to check the quality
    of datasets extracted in this manner.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将花费更多时间了解如何检查以这种方式提取的数据集的质量。
- en: Listing 4.5 SQL for dataset creation
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 数据集创建的 SQL
- en: '[PRE10]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① This CTE holds constant parameters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ① 此 CTE 保存常量参数。
- en: '② The frequency at which metrics were calculated: every seven days'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指标计算的频率：每七天一次
- en: ③ Forms observations over this date range
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在此日期范围内形成观测值
- en: ④ One observation per account per date; includes the churn flag
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 每个账户每天一个观测值；包括流失标志
- en: ⑤ Sums the result of a CASE statement to flatten the data
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将 CASE 语句的结果求和以简化数据
- en: ⑥ Joins on observation parameters to limit the overall date range
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 通过观测参数连接以限制整体日期范围
- en: ⑦ Joins on the observations, selecting the most recent metric
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在观测值上连接，选择最新的指标
- en: ⑧ GROUP BY for the SUM/CASE aggregation pattern
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用 SUM/CASE 聚合模式的 GROUP BY
- en: 'Run listing 4.5 by following the instructions in the book’s downloadable code.
    Using the wrapper program, change the parameters to `—chapter 4 —listing 5`. Listing
    4.5 ends with a `SELECT` statement containing the result. If you run it using
    the code in the GitHub repository, it saves the result in a CSV file for you.
    The wrapper program prints the path to the file; for example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 按照书中可下载代码的说明运行列表 4.5。使用包装程序，将参数更改为 `—chapter 4 —listing 5`。列表 4.5 以一个包含结果的 `SELECT`
    语句结束。如果你使用 GitHub 仓库中的代码运行它，它会为你保存结果到一个 CSV 文件中。包装程序会打印出文件的路径；例如：
- en: '[PRE11]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figure 4.17 shows an example of the result of running listing 4.5\. It skips
    rows to follow a few accounts through the dataset; the dataset observations are
    arranged by date, so records for a single account are dispersed throughout.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 展示了运行列表 4.5 的结果示例。它跳过一些行以跟踪几个账户通过数据集；数据集观测值按日期排列，因此单个账户的记录分散在整个数据集中。
- en: '![](../Images/4-17.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-17.png)'
- en: Figure 4.17 Example output of running listing 4.5
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 运行列表 4.5 的示例输出
- en: 'Note that listing 4.5 is hardcoded to a fixed number of metrics with predefined
    names, so listing 4.5 works only for the default simulated dataset. If you want
    to run listing 4.5 on your own data, you need to modify it so that it reflects
    the specific metrics you have created. However, a better option is to automate
    this step with a script that generates the right SQL based on whatever metrics
    are in the database. A function that does that is also in the book’s code, but
    not with the listings: the dataset-export folder contains a script that cleans
    the results tables and runs all the listings in this chapter with a custom-generated
    metric-flattening script as the finale. The README documentation has more information
    on how to configure and run that program.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，列表 4.5 是硬编码到固定数量的指标，具有预定义的名称，因此列表 4.5 只适用于默认的模拟数据集。如果你想在你的数据上运行列表 4.5，你需要修改它，使其反映你创建的具体指标。然而，更好的选择是使用一个脚本来自动化这一步骤，该脚本根据数据库中的任何指标生成正确的
    SQL。书中代码中也包含了一个执行此操作的函数，但不是在列表中：数据集导出文件夹中包含一个脚本，用于清理结果表，并使用自定义生成的指标简化脚本作为本章所有列表的结束。README
    文档中提供了有关如何配置和运行该程序的更多信息。
- en: Account key alignment issues
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 账户键对齐问题
- en: The code in this section assumes that you can simply link the account IDs on
    the subscriptions used to create the active periods with the account IDs on the
    events used to create the metrics. Unfortunately, the subscription database and
    event data warehouse are often different systems. To keep things simple, this
    book presents them as residing in a common database and using a common set of
    account IDs. To prepare you for what you may face in the real world, I will explain
    some of the practical issues you might face if your subscription (observation)
    and event (metric) data are in two different systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码假设你可以简单地将用于创建活跃期间的订阅中的账户ID与用于创建指标的活动中使用的账户ID相链接。不幸的是，订阅数据库和事件数据仓库通常是不同的系统。为了简化问题，本书将它们表示为位于一个共同的数据库中，并使用一个共同的账户ID集。为了让你为现实世界可能遇到的情况做好准备，我将解释一些你可能遇到的实际问题，如果你的订阅（观察）和事件（指标）数据位于两个不同的系统中。
- en: You cannot run a program like listing 4.5 with events and subscriptions on different
    systems. You must either make the observation dates available to the system with
    the metrics or the metrics available to the system with the subscriptions and
    observation dates. Usually, it is easiest to generate the active period data from
    the system with the subscriptions and load them into the system with the metrics,
    and then generate observation dates from the active periods on the system with
    the metrics. This minimizes the amount of data you need to transfer. That’s the
    easy part.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在不同的系统上运行像列表4.5那样的程序。你必须要么让包含指标的系统的观察日期可用，要么让包含订阅和观察日期的系统的指标可用。通常，从包含订阅的系统生成活跃期间数据并将其加载到包含指标的系统中，然后从包含指标的系统的活跃期间生成观察日期是最简单的。这是容易的部分。
- en: Things get more difficult when the account IDs in the two systems don’t match
    and you need a mapping. A lookup table must be created where each row has the
    unique matching identifiers for an account in both systems. Such a mapping can
    be used as an additional inner join in listing 4.5\. That’s not too hard, but
    the real problem arises when it is not possible to create a perfect mapping, resulting
    in dropped accounts, duplicates, or both. For example, this might occur when event
    data is tracked by email, subscriptions are tracked by some kind of database primary
    key, and there are emails with the subscriptions, but the emails don’t reliably
    match the event data. Another version of the problem can arise in a business context
    where you have subscriptions at the departmental level, and the event data is
    tracked by user, but some users are assigned to multiple departments or no department.
    Unless you have worked on a lot of extract-transform-load (ETL) pipelines, it
    may surprise you that such mapping problems could occur. I assure you, they are
    very common. If you find yourself in this situation, at least you have plenty
    of company!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个系统中的账户ID不匹配且需要映射时，事情会变得更加困难。必须创建一个查找表，其中每一行都有两个系统中账户的唯一匹配标识符。这种映射可以用作列表4.5中的额外内部连接。这并不太难，但真正的问题出现在无法创建完美映射的情况下，导致账户被删除、重复或两者兼而有之。例如，这可能会发生在事件数据通过电子邮件跟踪，而订阅通过某种数据库主键跟踪，并且有包含订阅的电子邮件，但这些电子邮件与事件数据不可靠地匹配的情况下。在业务环境中，如果部门级别有订阅，而事件数据通过用户跟踪，但某些用户被分配到多个部门或没有部门，也可能出现问题的另一种版本。除非你参与过大量的提取-转换-加载（ETL）管道，否则你可能不会想到这种映射问题可能会发生。我向你保证，它们非常常见。如果你发现自己处于这种情况，至少你并不孤单！
- en: In any event, there is no trick I can teach you that will always fix these kinds
    of issues. My approach is to drop incomplete records rather than try to repair
    them, as long as you end up with enough data to analyze. The good news is, your
    data doesn’t have to be perfect to use it! A small proportion of dropped or duplicated
    accounts in the analytic dataset does not invalidate your dataset. By a small
    proportion, I mean problematic data should be much less than half the total. Data
    is clean, in my opinion, if it is 90% good; and it can be somewhat messy and still
    be usable.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我无法教给你一个总是能解决这类问题的技巧。我的方法是放弃不完整的记录，而不是试图修复它们，只要最终你拥有足够的数据进行分析即可。好消息是，你的数据不必完美才能使用！在我看来，如果数据有90%是好的，那么它就是干净的；即使有些许杂乱，仍然可以使用。
- en: It’s also important that the affected data is more or less random in terms of
    the types of customers affected. For example, if all the dropped customers use
    one particular product feature or come from one sales channel, then your results
    on those groups will be off. But if a small number of accounts are dropped randomly
    or duplicated randomly across all product features and sales channels, then you
    should have nothing to worry about. We will review some additional methods to
    remove problematic records from datasets in later chapters, but your best bet
    is to get the mapping as correct as possible at the start. Just don’t expect it
    to be perfect.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受影响的数据来说，重要的是它在大体上是随机的，就受影响的客户类型而言。例如，如果所有流失的客户都使用一个特定的产品功能或来自一个销售渠道，那么你在这些群体上的结果将会不准确。但如果只有少数账户随机流失，或者随机地分布在所有产品功能和销售渠道中，那么你就不必担心。我们将在后面的章节中回顾一些从数据集中删除问题记录的额外方法，但你的最佳选择是在一开始就尽可能准确地获取映射。只是不要期望它完美无缺。
- en: 4.7 Exporting the current customers for segmentation
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 导出当前客户进行分段
- en: 'This chapter taught you how to prepare a dataset to analyze your customers.
    But eventually, you will also want to take some actions to try to reduce churn.
    As I explained in chapter 1, there are a variety of possible strategies to reduce
    churn. From a data point of view, all churn-reduction methods have one thing in
    common: you have to use the data to pick the most appropriate customers to target.
    This is usually called segmentation.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教了你如何准备一个数据集来分析你的客户。但最终，你也会想要采取一些行动来尝试减少流失。正如我在第一章中解释的，有各种可能的策略来减少流失。从数据的角度来看，所有减少流失的方法都有一个共同点：你必须使用数据来挑选最合适的客户进行目标定位。这通常被称为分段。
- en: DEFINITION Segmentation —Selecting a set of customers according to a set of
    criteria.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 分段——根据一组标准选择一组客户。'
- en: For now, you will learn a technique that lays the groundwork for segmentation
    by making a snapshot of current customers. More about segmentation is coming in
    later chapters.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将学习一种技术，通过制作当前客户的快照来为分段打下基础。更多关于分段的内容将在后面的章节中介绍。
- en: 4.7.1 Selecting active accounts and metrics
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.1 选择活跃账户和度量
- en: The first step in segmentation and targeting customers for interventions is
    to make a snapshot of how your customers are doing right now. That is the same
    as a dataset of the current set of customers and their metrics, but with no history.
    This is simpler than constructing the historical dataset.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 分段和针对干预措施定位客户的第一步是制作一个快照，显示你的客户当前的表现。这与当前客户集及其度量值的数据集相同，但没有历史记录。这比构建历史数据集简单。
- en: TAKEAWAY A dataset containing only current customers is used for customer segmentation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点** 仅包含当前客户的数据库用于客户分段。'
- en: 'Listing 4.6 shows a SQL `SELECT` statement that creates a current customer
    dataset suitable for segmentation. It uses two tricks: first, a CTE selects the
    most recent date with metrics using `MAX` aggregation. You also have the option
    of simply hardcoding a date, but presumably the most recent date with any metrics
    would be the last day you updated your data. Then listing 4.6 uses the flattening
    aggregation trick you learned in the last section. That’s all there is to it!
    Run the SQL and check that the result is similar to that from listing 4.5, but
    with all the accounts observed on a single date: the most recent.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6展示了一个SQL `SELECT`语句，用于创建一个适合分段的当前客户数据集。它使用了两个技巧：首先，一个CTE使用`MAX`聚合选择带有度量值的最新日期。你也可以简单地硬编码一个日期，但可能最带有任何度量值的最新日期就是你更新数据的最后一天。然后列表4.6使用了你在上一节中学到的扁平化聚合技巧。这就是全部内容！运行SQL并检查结果是否与列表4.5相似，但所有账户都在一个日期上观察：最新的。
- en: Listing 4.6 Selecting the currently active accounts
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 选择当前活跃账户
- en: '[PRE12]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① This CTE selects the most recent date with metrics.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这个CTE选择了带有度量值的最新日期。
- en: ② This is the flattening aggregation taught with listing 4.5.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这就是与列表4.5一起教授的扁平化聚合。
- en: ③ Selects the metrics for a single date only
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 仅选择单日度量
- en: ④ Joins subscriptions to ensure that customers are currently active
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过连接订阅来确保客户当前活跃
- en: Listing 4.6 also uses a join on the subscription table to make sure these customers
    are still within an active subscription. The code that calculated the metrics
    back in chapter 3 never checked that customers were active, so there can be entries
    for customers who have already churned but still have events in the time period
    for the metric. From the point of view of metric calculation, the result is only
    a few extra records, so I didn’t bother showing you how to prevent those metrics
    from being saved. And in the historical dataset, I took care that every observation
    corresponded to an active customer. But for the current customer list, you need
    to make sure you’re pulling data only for active subscribers, and the join on
    the subscription table takes care of that detail.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列出4.6还使用订阅表上的连接来确保这些客户仍然处于活跃订阅状态。在第三章中计算指标时，代码从未检查过客户是否活跃，因此可能会有已经淘汰但仍在指标时间段内有事件的客户条目。从指标计算的角度来看，结果只是额外的一些记录，所以我没有麻烦展示如何防止这些指标被保存。但在历史数据集中，我确保每个观察结果都对应一个活跃客户。但对于当前客户列表，你需要确保你只获取活跃订阅者的数据，订阅表上的连接处理了这个细节。
- en: NOTE In practice, listing 4.6 would have to include account names or emails,
    or whatever identifiers are necessary to link the accounts with other systems
    used to make interventions with customers, like email marketing and customer relationship
    management systems. I omit these details from this simulated example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在实际操作中，列出4.6时必须包括账户名称或电子邮件，或任何必要的标识符，以将账户与其他用于与客户进行干预的系统（如电子邮件营销和客户关系管理系统）联系起来。我在这个模拟示例中省略了这些细节。'
- en: 4.7.2 Segmenting customers by their metrics
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.2 按指标细分客户
- en: 'Now that you have a list of current customers and all their metrics, the act
    of segmenting is straightforward. If you gave the output of listing 4.6 to your
    business colleagues, they would probably know what to do: open it in a spreadsheet
    and use the filtering features to explore and select customers who match different
    behavioral profiles based on the metrics. You can also define segments by putting
    criteria in the `SELECT` statement of listing 4.6\. The hard part is knowing what
    to choose for the values to define the segments and which behaviors to focus on
    in the first place. To do that in a data-driven way, you need to really understand
    how the behaviors relate to churn and engagement, and that’s the subject of the
    next chapter.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个当前客户列表以及他们所有的指标，细分行为是直接的。如果你将列出4.6的输出给业务同事，他们可能会知道该怎么做：在电子表格中打开它，并使用过滤功能探索和选择基于指标的不同的行为轮廓的客户。你还可以通过在列出4.6的`SELECT`语句中放入标准来定义细分。困难的部分是知道应该选择什么值来定义细分，以及首先应该关注哪些行为。为了以数据驱动的方式进行，你需要真正理解这些行为如何与淘汰和参与度相关联，这就是下一章的主题。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A churn analysis dataset is a table of behavioral snapshots of customers, including
    both customers who churned and customers who did not churn.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淘汰分析数据集是客户行为快照的表格，包括已经淘汰和未淘汰的客户。
- en: Churn leading indicators are behaviors that suggest a high likelihood of churn
    at a time when the customer has not yet made up their mind. Churn leading indicators
    are usually the focus in fighting churn.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淘汰领先指标是在客户尚未做出决定时表明淘汰可能性很高的行为。淘汰领先指标通常是抗淘汰工作的重点。
- en: Churn lagging indicators are behaviors that customers often engage in after
    they have already decided to churn. Churn lagging behaviors are usually not the
    underlying cause of churn.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淘汰滞后指标是客户在已经决定淘汰后通常会采取的行为。淘汰滞后行为通常不是淘汰的根本原因。
- en: To focus the analysis on churn leading indicators, a behavioral snapshot of
    customers who churn is made with a lead time before the actual churn occurred.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将分析集中在淘汰领先指标上，在实际淘汰发生之前，对淘汰客户的客户行为快照进行了提前的领先时间处理。
- en: Lead times for observing churn are usually a few weeks in advance of churn for
    a consumer product and one to three months for a business product.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察淘汰所需的时间通常在消费者产品淘汰前几周，对于商业产品则是一到三个月。
- en: It is important to ensure that churns and nonchurns in the dataset are sampled
    roughly in proportion to the actual churn rate and renewal rate, respectively.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据集中的淘汰和非淘汰客户样本大致按实际淘汰率和续订率成比例，这一点很重要。
- en: 'Behavioral snapshots of customers who renew are made at the same regular interval
    at which churn is measured: typically monthly for a consumer product and annually
    for a business product. This ensures that the proportion of churns in the dataset
    approximately matches the churn rate.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于续订的客户，行为快照的生成频率与流失测量频率相同：通常对于消费产品是每月一次，对于商业产品是每年一次。这确保了数据集中流失的比例大致与流失率相匹配。
- en: For subscription products, behavioral snapshots of customers who did not churn
    are made prior to the renewal or payment dates, also with a lead time.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于订阅产品，在续订或付款日期之前，会对未流失的客户进行行为快照，同时也有一个提前量。
- en: The first step in creating the churn analysis dataset is identifying active
    periods for each customer, when the customer had at least one subscription (for
    subscription products) or at least one event (for nonsubscription products) within
    a short time.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流失分析数据集的第一步是确定每个客户的活动期，即客户在短时间内至少有一个订阅（对于订阅产品）或至少有一个事件（对于非订阅产品）。
- en: For nonsubscription products, events are first aggregated into weeks as a single
    indicator of whether each account had any events that week. Active periods are
    found from the active weeks.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非订阅产品，事件首先被聚合到周，作为一个单一指标来表示每个账户在该周是否有任何事件。通过活跃周找到活跃期。
- en: After active periods are found, observation dates are selected for each account
    in a series based on the start of the active period.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到活跃期后，根据活跃期的开始，为每个账户按顺序选择观测日期。
- en: The dataset is created by merging the observation dates with the previously
    calculated metrics.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集是通过将观测日期与先前计算的指标合并来创建的。
- en: When the dataset is created, the metrics are flattened, meaning they are converted
    from a format with different metrics all in one column to a format in which different
    metrics are each in their own column.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建数据集时，指标会被展平，这意味着它们从所有指标都在一列的格式转换为每个指标都在自己一列的格式。
