- en: 10 Persistent state management with databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用数据库进行持久状态管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Storing data and authenticating users with MongoDB
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoDB 存储数据和认证用户
- en: Using PostgreSQL from Vert.x
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vert.x 从 PostgreSQL
- en: Testing strategies for integration testing of event-driven services that interact
    with databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与数据库交互的事件驱动服务的集成测试策略
- en: Reactive applications favor *stateless* designs, but state has to be managed
    somewhere.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式应用程序倾向于无状态设计，但状态必须被管理。
- en: 'Databases are essential in most applications, because data needs to be stored,
    retrieved, and queried. Databases can store all kinds of data, such as application
    state, facts, or user credentials. There are different types of databases on the
    market: some are generalist and others are specialized for certain types of use
    cases, access patterns, and data.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库在大多数应用程序中都是必不可少的，因为数据需要被存储、检索和查询。数据库可以存储各种数据，如应用程序状态、事实或用户凭证。市场上存在不同类型的数据库：有些是通用型的，而有些则针对某些类型的用例、访问模式和数据进行专门化。
- en: In this chapter we’ll explore database and state management with Vert.x by diving
    into the implementation of the user and activity services. These services will
    allow us to use a document-oriented database (MongoDB) and a relational database
    (PostgreSQL). You will also see how you can use MongoDB for authenticating users,
    and how to write integration tests for data-driven services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过深入了解用户和服务活动的实现来探索 Vert.x 的数据库和状态管理。这些服务将使我们能够使用面向文档的数据库（MongoDB）和关系型数据库（PostgreSQL）。你还将看到如何使用
    MongoDB 进行用户认证，以及如何为数据驱动的服务编写集成测试。
- en: 10.1 Databases and Vert.x
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 数据库和 Vert.x
- en: Vert.x offers a wide range of clients for connecting to data sources. These
    clients contain drivers that talk to servers, and that may offer efficient connection
    management, like connection pooling. This is useful for building all kinds of
    services, from APIs backed by a data source to integration services that mix data
    sources, messaging, and APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 提供了广泛的客户端来连接数据源。这些客户端包含与服务器通信的驱动程序，并且可能提供高效的连接管理，如连接池。这对于构建各种服务很有用，从由数据源支持的
    API 到混合数据源、消息和 API 的集成服务。
- en: 10.1.1 What the Eclipse Vert.x stack provides
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 Eclipse Vert.x 堆栈提供的内容
- en: The Eclipse Vert.x project provides the data client modules listed in table
    10.1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Vert.x 项目提供了表 10.1 中列出的数据客户端模块。
- en: Table 10.1 Data client modules supported by Eclipse Vert.x
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 Eclipse Vert.x 支持的数据客户端模块
- en: '| Identifier | Description |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 标识符 | 描述 |'
- en: '| `vertx-mongo-client` | MongoDB is a document-oriented database. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `vertx-mongo-client` | MongoDB 是一个面向文档的数据库。|'
- en: '| `vertx-jdbc-client` | Supports any relational database that offers a JDBC
    driver. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `vertx-jdbc-client` | 支持任何提供 JDBC 驱动程序的关系型数据库。|'
- en: '| `vertx-pg-client` and `vertx-mysql-client` | Access PostgreSQL and MySQL
    relational databases through dedicated Vert.x reactive drivers. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `vertx-pg-client` 和 `vertx-mysql-client` | 通过专门的 Vert.x 反应式驱动程序访问 PostgreSQL
    和 MySQL 关系型数据库。|'
- en: '| `vertx-redis-client` | Redis is versatile data structure store. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `vertx-redis-client` | Redis 是一种多用途的数据结构存储。|'
- en: '| `vertx-cassandra-client` | Apache Cassandra is a database tailored for very
    large volumes of data. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `vertx-cassandra-client` | Apache Cassandra 是一个针对大量数据定制的数据库。|'
- en: You can find drivers for other kinds of data sources in the larger Vert.x community.
    Those are beyond the scope of the project at the Eclipse Foundation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在更大的 Vert.x 社区中找到其他类型数据源的驱动程序。这些超出了 Eclipse 基金会项目的范围。
- en: MongoDB is a popular document-oriented database; it is a good match with Vert.x
    since it manipulates JSON documents. Redis is an in-memory data structure store
    with configurable on-disk data snapshots that can be used as a cache, as a database,
    and as a message broker. Apache Cassandra is a multinode, replicated database
    designed for storing huge amounts of data. Cassandra is well suited for databases
    where size is measured in hundreds of terabytes or even petabytes. You can, of
    course, use it for just a few terabytes, but a more traditional database may suffice
    in these cases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一个流行的面向文档的数据库；它与 Vert.x 很好地匹配，因为它操作 JSON 文档。Redis 是一个内存中的数据结构存储，具有可配置的磁盘数据快照，可以用作缓存、数据库和消息代理。Apache
    Cassandra 是一个多节点、复制的数据库，旨在存储大量数据。Cassandra 非常适合以数百个或甚至数个千兆字节计量的数据库。当然，你也可以用它来存储几个千兆字节的数据，但在这些情况下，更传统的数据库可能就足够了。
- en: Speaking of “traditional” relational databases, Vert.x can connect to *anything*
    for which there is a JDBC driver. That being said, JDBC is an older protocol based
    on a multithreaded design and blocking I/O. The JDBC support in Vert.x offloads
    database calls to worker thread pools, and it pushes results back to event-loop
    contexts. This is to avoid blocking event loops, since JDBC calls do block. This
    design limits scalability, as worker threads are needed, but for moderate workloads
    it should be fine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到“传统”的关系数据库，Vert.x 可以连接到任何有 JDBC 驱动的“东西”。话虽如此，JDBC 是一种基于多线程设计和阻塞 I/O 的较老协议。Vert.x
    中的 JDBC 支持将数据库调用卸载到工作线程池，并将结果推回到事件循环上下文中。这是为了避免阻塞事件循环，因为 JDBC 调用确实会阻塞。这种设计限制了可伸缩性，因为需要工作线程，但对于中等负载来说应该没问题。
- en: If you use PostgreSQL or MySQL, Vert.x provides its own reactive drivers. These
    drivers implement the network protocols of each database server, and they are
    built in a purely asynchronous fashion using Netty, the networking foundation
    of Vert.x. The drivers offer excellent performance, both in terms of latency and
    concurrent connections. They are also very stable and implement the current protocols
    and features of the databases. You should prefer the Vert.x reactive driver clients
    for PostgreSQL and MySQL, and use the JDBC client when you need to connect to
    other databases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 PostgreSQL 或 MySQL，Vert.x 提供了自己的反应式驱动程序。这些驱动程序实现了每个数据库服务器的网络协议，并且它们完全以异步方式构建，使用
    Netty，这是 Vert.x 的网络基础。这些驱动程序在延迟和并发连接方面都提供了出色的性能。它们也非常稳定，并实现了数据库的当前协议和功能。你应该优先考虑
    PostgreSQL 和 MySQL 的 Vert.x 反应式驱动程序客户端，并在需要连接到其他数据库时使用 JDBC 客户端。
- en: If you are looking for a solid database, PostgreSQL is probably a good bet.
    PostgreSQL is versatile and has been used in all sorts of small and large-scale
    projects over the years. You can, of course, use it as a traditional relational
    database, but it also supports JSON documents as first-class objects, and geographic
    objects through the PostGIS extension.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个可靠的数据库，PostgreSQL 可能是一个不错的选择。PostgreSQL 通用性强，多年来在各种小型和大型项目中都得到了应用。当然，你可以将其用作传统的关系数据库，但它也支持作为一等对象的
    JSON 文档，以及通过 PostGIS 扩展的地理对象。
- en: 10.1.2 A note on data/object mapping, and why you may not always need it
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2 关于数据/对象映射的注意事项，以及为什么你可能并不总是需要它
- en: Before we dive into the user profile service design and implementation with
    MongoDB, I would like to quickly discuss certain established idioms of enterprise
    Java development, and explain why, in search of simplicity and efficiency, the
    code in this chapter deviates intentionally from supposed best practices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨使用 MongoDB 的用户配置文件服务设计和实现之前，我想简要讨论一些企业 Java 开发中已经确立的惯例，并解释为什么，在追求简单和效率的过程中，本章中的代码故意偏离了所谓的最佳实践。
- en: The code of the 10k steps challenge may surprise you, because it does not perform
    object data mapping, where any data has to be mapped to some Java object model
    that represents the application domain, such as data transfer objects (DTOs).[1](#pgfId-1037129)
    For instance, some JSON data representing a pedometer update would be mapped to
    a `DeviceUpdate` Java class before any further processing was done. Here we will
    directly manipulate data in `JsonObject` instances as they flow between HTTP,
    Kafka, and database interfaces. We will not map, say, device update JSON data
    to `DeviceUpdate`; we will work with the `JsonObject` representation of that data
    instead.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 10k 步挑战的代码可能会让你感到惊讶，因为它不执行对象数据映射，即任何数据都必须映射到表示应用域的某些 Java 对象模型，例如数据传输对象 (DTOs)。[1](#pgfId-1037129)
    例如，一些表示计步器更新的 JSON 数据在进一步处理之前会被映射到 `DeviceUpdate` Java 类。在这里，我们将直接在 `JsonObject`
    实例中操作数据，这些数据在 HTTP、Kafka 和数据库接口之间流动。我们不会将设备更新 JSON 数据映射到 `DeviceUpdate`；我们将使用该数据的
    `JsonObject` 表示形式进行工作。
- en: 'Vert.x does allow you to do data mapping from and to Java classes, but unless
    the object model contains some significant business logic or can be leveraged
    by some processing in a third-party library, I see little value in doing any form
    of data binding. I advocate such a design for several reasons:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 允许你从 Java 类中进行数据映射，但除非对象模型包含一些重要的业务逻辑或可以被第三方库中的某些处理利用，我认为进行任何形式的数据绑定都没有太大价值。我主张这种设计有几个原因：
- en: It saves us from writing classes that have no functionality except exposing
    trivial getters and setters.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们免于编写除了暴露简单的获取器和设置器之外没有功能性的类。
- en: It avoids unnecessary allocation of objects with typically short lifetimes (e.g.,
    the lifespan of processing an HTTP request).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它避免了为通常寿命较短的对象分配不必要的资源（例如，处理HTTP请求的生命周期）。
- en: Data is not always easy to map to an object model, and you may not be interested
    in all the data, but rather in some selected entries.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并不总是容易映射到对象模型，你可能对所有的数据不感兴趣，而只是对一些选定的条目感兴趣。
- en: In the case of relational databases, the object and the models have some well-known
    mismatches that can result in complex mappings and bad performance due to excessive
    queries.[2](#pgfId-1037203)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关系型数据库的情况下，对象和模型之间有一些众所周知的不匹配，这可能导致复杂的映射和由于查询过多而导致的性能不佳。[2](#pgfId-1037203)
- en: It eventually leads to code that is more *functional*.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这最终导致代码更加*函数式*。
- en: If you’re in doubt, always ask yourself whether you actually need an object
    model, or whether the data representation is good enough for the processing work
    that you are doing. If your object model consists of nothing but getters and setters,
    perhaps it’s a good sign that (at least initially) you don’t need it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有疑问，总是问问自己你是否真的需要一个对象模型，或者数据表示是否足够好，足以处理你正在进行的处理工作。如果你的对象模型只包含获取器和设置器，那么这可能是一个好迹象，表明（至少最初）你可能不需要它。
- en: Let’s now dive into using MongoDB in the user profile service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解在用户配置文件服务中使用MongoDB。
- en: 10.2 User profile service with MongoDB
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 使用MongoDB的用户配置文件服务
- en: The user profile service manages user data such as name, email, and city, and
    it’s also used to authenticate a user against login/password credentials. This
    service is used by other services that need to retrieve and correlate data against
    user information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户配置文件服务管理用户数据，如姓名、电子邮件和城市，并且它还用于验证用户的登录/密码凭据。此服务被其他需要检索和关联用户信息的数据服务使用。
- en: 'The user service makes use of MongoDB for two purposes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户服务利用MongoDB的两个目的：
- en: 'Storing user data: username, password, email, city, device identifier, and
    whether data should appear in public rankings'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储用户数据：用户名、密码、电子邮件、城市、设备标识符以及数据是否应出现在公共排名中
- en: Authenticating users against a username plus password combination
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户名加密码组合
- en: MongoDB is a good fit here because it is a document database; each user can
    be represented as a document. We will use the `vertx-mongo-client` module to connect
    to MongoDB instances, and we will use the `vertx-auth-mongo` module for authentication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在这里是一个很好的选择，因为它是一个文档数据库；每个用户都可以表示为一个文档。我们将使用`vertx-mongo-client`模块连接到MongoDB实例，并使用`vertx-auth-mongo`模块进行身份验证。
- en: 10.2.1 Data model
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 数据模型
- en: 'The `vertx-auth-mongo` module is a turnkey solution for doing user authentication
    on top of a MongoDB database, as it manages all the intricacies of properly storing
    and retrieving credentials. It implements the common authentication interface
    of module `vertx-auth-common`. It especially deals with storing cryptographic
    hashes of passwords with a *salt* value, because storing actual passwords is never
    a good idea. According to the conventions defined in the `vertx-auth-mongo` module,
    there is a document for each user in the target database with the following entries:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertx-auth-mongo`模块是一个现成的解决方案，用于在MongoDB数据库上执行用户身份验证，因为它管理了正确存储和检索凭据的所有复杂性。它实现了模块`vertx-auth-common`的通用身份验证接口。它特别处理存储带有*salt*值的密码加密哈希，因为存储实际密码从来不是一个好主意。根据`vertx-auth-mongo`模块中定义的约定，目标数据库中的每个用户都有一个文档，包含以下条目：'
- en: '`username`--A string for the username'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`--用户名的字符串'
- en: '`salt`--A random data string used to secure the password'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt`--一个用于保护密码的随机数据字符串'
- en: '`password`--A string made by computing the SHA-512 hash from the actual password
    plus the `salt` value'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`--通过从实际密码加上`salt`值计算SHA-512哈希得到的字符串'
- en: '`roles`--An array of strings defining *roles* (such as “administrator”)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles`--一个定义*角色*（例如“管理员”）的字符串数组'
- en: '`permissions`--An array of strings defining *permissions* (such as “`can_access
    _beta`”).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permissions`--一个定义*权限*（例如“`can_access_beta`”）的字符串数组'
- en: In our case, we won’t use roles and permissions, since all users will be equal,
    so these entries will be empty arrays. We will not have to deal with the subtleties
    of handling salts and password hashing, as this is taken care of by the authentication
    module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们不会使用角色和权限，因为所有用户都将平等，所以这些条目将是空数组。我们不需要处理盐和密码哈希处理的复杂性，因为这是由身份验证模块处理的。
- en: 'While this data model is prescribed by `vertx-auth-mongo`, nothing precludes
    us from adding more fields to the documents that represent users. We can thus
    add the following entries:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个数据模型由`vertx-auth-mongo`指定，但并没有阻止我们向代表用户的文档中添加更多字段。因此，我们可以添加以下条目：
- en: '`city`--A string for the user’s city'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`city`--用户所在城市的字符串'
- en: '`deviceId`--A string for the pedometer device identifier'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deviceId`--计步器设备标识符的字符串'
- en: '`email`--A string for the user’s email address'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`--用户电子邮件地址的字符串'
- en: '`makePublic`--A Boolean to indicate whether or not the user wants to appear
    in public rankings'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makePublic`--一个布尔值，表示用户是否希望出现在公共排名中'
- en: 'We’ll also enforce two integrity constraints with MongoDB indexes: both `username`
    and `deviceId` must be unique across all documents. This avoids duplicate user
    names as well as two users having the same device. This will pose a correctness
    challenge when registering new users, because we will not be able to use any transaction
    mechanism. We will need to roll back partial data inserts when the `deviceId`
    uniqueness constraint prevents a duplicate insert.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将使用MongoDB索引强制执行两个完整性约束：`username`和`deviceId`必须在所有文档中是唯一的。这避免了重复的用户名以及两个用户使用相同的设备。这将在注册新用户时提出一个正确性挑战，因为我们无法使用任何事务机制。当`deviceId`唯一性约束阻止重复插入时，我们需要回滚部分数据插入。 '
- en: Let’s now look at how we can use the Vert.x MongoDB client and Vert.x authentication
    support.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用Vert.x MongoDB客户端和Vert.x身份验证支持。
- en: 10.2.2 User profile API verticle and initialization
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 用户配置API垂直和初始化
- en: 'The `UserProfileApiVerticle` class exposes the HTTP API for the user profile
    service. It holds three important fields:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserProfileApiVerticle`类公开了用户配置服务的HTTP API。它包含三个重要字段：'
- en: '`mongoClient`, of type `MongoClient`, is used to connect to a MongoDB server.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoClient`，类型为`MongoClient`，用于连接到MongoDB服务器。'
- en: '`authProvider`, of type `MongoAuthentication`, is used to perform authentication
    checks using MongoDB.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authProvider`，类型为`MongoAuthentication`，用于使用MongoDB执行身份验证检查。'
- en: '`userUtil`, of type `MongoUserUtil`, is used to facilitate new user creation.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userUtil`，类型为`MongoUserUtil`，用于简化新用户的创建。'
- en: We initialize these fields from the `rxStart` verticle initialization method
    (since we use RxJava), as shown in the following listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`rxStart`垂直初始化方法中初始化这些字段（因为我们使用RxJava），如下一列表所示。
- en: Listing 10.1 Initializing the MonbgoDB client and authentication provider
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.1 初始化MonbgoDB客户端和身份验证提供者
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Create a client based on some configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于某些配置创建一个客户端。
- en: ❷ Create an authentication provider on MongoDB.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在MongoDB上创建一个身份验证提供者。
- en: ❸ Helper to create users in the MongoDB database
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在MongoDB数据库中创建用户的辅助函数
- en: The authentication provider piggybacks on the MongoDB client instance, which
    is configured as in the next listing. We pass empty configuration options for
    the authentication provider as we follow the conventions of the Vert.x MongoDB
    authentication module. The same goes with the utility that will help us when adding
    users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证提供者依赖于MongoDB客户端实例，配置方式如下一列表所示。我们为身份验证提供者传递空配置选项，因为我们遵循Vert.x MongoDB身份验证模块的约定。同样，对于帮助我们添加用户的实用工具也是如此。
- en: Listing 10.2 MongoDB client configuration method
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 MongoDB客户端配置方法
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ We will be testing locally.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将在本地进行测试。
- en: ❷ profiles is the database name, but we could equally use something else.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `profiles`是数据库名称，但我们可以使用其他任何名称。
- en: Since we are exposing an HTTP API, we’ll use a Vert.x web router to configure
    the various routes to be handled by the service, as shown in the following listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们公开了HTTP API，我们将使用Vert.x web路由器来配置服务要处理的各个路由，如下一列表所示。
- en: Listing 10.3 User profile service HTTP routing
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 用户配置服务HTTP路由
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The processing logic is split between two chained handlers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理逻辑被分为两个链式处理器。
- en: Note that we use two chained handlers for the registration. The first handler
    is for data validation, and the second handler is for the actual processing logic.
    But what is in the validation logic?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在注册时使用了两个链式处理器。第一个处理器用于数据验证，第二个处理器用于实际的处理逻辑。但验证逻辑中有什么？
- en: 10.2.3 Validating user input
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 验证用户输入
- en: Registration is a critical step, so we must ensure that the data is valid. We
    must check that the incoming data (a JSON document) contains all required fields,
    and that they are all valid. For instance, we need to check that an email is actually
    an email, and that a username is not empty and does not contain unwanted characters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注册是一个关键步骤，因此我们必须确保数据有效。我们必须检查传入的数据（一个 JSON 文档）是否包含所有必需的字段，并且它们都是有效的。例如，我们需要检查电子邮件地址实际上是一个电子邮件地址，并且用户名不为空且不包含不想要的字符。
- en: The `validateRegistration` method in the following listing delegates the validation
    to the helper methods `anyRegistrationFieldIsMissing` and `anyRegistrationFieldIsWrong`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的 `validateRegistration` 方法将验证委托给辅助方法 `anyRegistrationFieldIsMissing`
    和 `anyRegistrationFieldIsWrong`。
- en: Listing 10.4 The registration validation method
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.4 注册验证方法
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Registration failed, so we end the HTTP request with status code 400.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注册失败，因此我们以状态码 400 结束 HTTP 请求。
- en: ❷ The next handler in the chain is called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用链中的下一个处理器。
- en: When any validation steps fails, we respond with a 400 HTTP status code; otherwise,
    we call the next handler, which in our case will be the `register` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何验证步骤失败时，我们以 400 HTTP 状态码响应；否则，我们调用下一个处理器，在我们的例子中将是 `register` 方法。
- en: The implementation of the `anyRegistrationFieldIsMissing` method is quite simple.
    We check that the provided JSON document contains the required fields, as follows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyRegistrationFieldIsMissing` 方法的实现相当简单。我们检查提供的 JSON 文档是否包含所需的字段，如下所示。'
- en: Listing 10.5 Checking for missing JSON fields
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 检查缺失的 JSON 字段
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Check that all fields are present.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查所有字段是否存在。
- en: The `anyRegistrationFieldIsWrong` method delegates checks to regular expressions,
    as in the following listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`anyRegistrationFieldIsWrong` 方法将检查委托给正则表达式，如下面的列表所示。'
- en: Listing 10.6 Validating specific fields
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 验证特定字段
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Regular expression for valid usernames like `abc`, `a-b-c`, etc.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 有效的用户名正则表达式，如 `abc`、`a-b-c` 等。
- en: ❷ Regular expression matching
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 正则表达式匹配
- en: ❸ `trim` removes whitespace at the beginning and end of the string and then
    checks for emptiness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `trim` 移除字符串开头和结尾的空白字符，然后检查是否为空。
- en: The `validDeviceId` regular expression is the same as `validUsername`. Validating
    an email address (`validEmail`) is a more sophisticated regular expression. I
    chose to use one of the safe regular expressions from the Open Web Application
    Security Project (OWASP) for that purpose ([www.owasp.org/index.php/OWASP_Validation_Regex
    _Repository](http://www.owasp.org/index.php/OWASP_Validation_Regex_Repository)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`validDeviceId` 正则表达式与 `validUsername` 相同。验证电子邮件地址（`validEmail`）是一个更复杂的正则表达式。我选择使用来自
    Open Web Application Security Project (OWASP) 的一个安全正则表达式来完成这个目的 ([www.owasp.org/index.php/OWASP_Validation_Regex_Repository](http://www.owasp.org/index.php/OWASP_Validation_Regex_Repository))。'
- en: Now that we have validated the data, it is time to register the users.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了数据，是时候注册用户了。
- en: 10.2.4 Adding users in MongoDB
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 在 MongoDB 中添加用户
- en: 'Inserting a new user in the database requires two steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中插入新用户需要两个步骤：
- en: We need to ask the helper to insert a new user, as it will also deal with other
    aspects like hashing passwords and having a salt value.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要请助手插入一个新用户，因为它还将处理其他方面，如哈希密码和盐值。
- en: We need to update the user document to add extra fields that are not required
    by the authentication provider schema.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新用户文档以添加认证提供者模式不需要的额外字段。
- en: Since this is a two-step data insert, and we cannot use any transaction management
    facility, we need to take care of the data integrity ourselves, as shown in figure
    10.1.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个两步数据插入过程，我们无法使用任何事务管理功能，因此我们需要自己确保数据完整性，如图 10.1 所示。
- en: '![](../Images/CH10_F01_Ponge.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1](../Images/CH10_F01_Ponge.png)'
- en: Figure 10.1 Steps to successfully add a user
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 成功添加用户的步骤
- en: Fortunately RxJava makes the error management declarative, so we won’t have
    to deal with nested conditionals of asynchronous operations, which would be complicated
    to do with callbacks or promises/futures.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，RxJava 使得错误管理声明式，所以我们不需要处理异步操作的嵌套条件，这会使用回调或承诺/未来变得复杂。
- en: The `register` method starts by extracting the JSON payload from the HTTP request,
    and then the username and password of the user to create, as follows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法首先从 HTTP 请求中提取 JSON 有效负载，然后是创建用户的用户名和密码，如下所示。'
- en: Listing 10.7 Preamble of the register method
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 `register` 方法的序言
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Extract the JSON body.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提取 JSON 主体。
- en: ❷ Insert a new user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 插入一个新用户。
- en: Remember that `register` is called after validation, so we expect the JSON data
    to be good. We pass the authentication provider the username and password. There
    is also a form where `rxCreateUser` accepts two extra lists for defining roles
    and permissions. Then the helper populates the database with a new document.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`register` 在验证之后被调用，所以我们期望 JSON 数据是好的。我们向身份验证提供者传递用户名和密码。还有一个表单，其中 `rxCreateUser`
    接受两个额外的列表来定义角色和权限。然后助手用新的文档填充数据库。
- en: Next we have to run a query to update the newly created document and append
    new entries. The MongoDB query is shown in the following listing and is represented
    as a JSON object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须运行一个查询来更新新创建的文档并附加新条目。MongoDB 查询在下面的列表中显示，并表示为 JSON 对象。
- en: Listing 10.8 MongoDB query to update a new user
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 更新新用户的 MongoDB 查询
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This is the $set operator from MongoDB.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是 MongoDB 的 `$set` 操作符。
- en: We must thus chain the `rxInsertUser` operation with a MongoDB update query,
    knowing that `rxInsertUser` returns a `Single<String>` where the value is the
    identifier of the new document. The following listing shows the complete user
    addition processing with RxJava.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将 `rxInsertUser` 操作与 MongoDB 更新查询链式执行，知道 `rxInsertUser` 返回一个 `Single<String>`，其值是新文档的标识符。下面的列表展示了使用
    RxJava 的完整用户添加处理过程。
- en: Listing 10.9 Complete user addition processing with RxJava
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 使用 RxJava 的完整用户添加处理
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ User insert query
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用户插入查询
- en: ❷ Update query
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新查询
- en: ❸ HTTP 200
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ HTTP 200
- en: ❹ Deal with the error
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 处理错误
- en: The `flatMapMaybe` operator allows us to chain the two queries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMapMaybe` 操作符允许我们链式执行两个查询。'
- en: The `insertExtraInfo` method is shown in the next listing and returns a `MaybeSource`,
    because finding and updating a document may not hold a result if no matching document
    was found.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中展示了 `insertExtraInfo` 方法，它返回一个 `MaybeSource`，因为查找和更新文档可能在没有找到匹配文档的情况下不保留结果。
- en: Listing 10.10 Implementation of the `insertExtraInfo` method
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10 `insertExtraInfo` 方法的实现
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Find and update a document.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找并更新文档。
- en: ❷ Manual rollback
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 手动回滚
- en: Note that the update query can fail; for example, if another user has already
    registered a device with the same identifier. In this case, we need to manually
    roll back and remove the document that was created by the authentication provider,
    because otherwise we would have an incomplete document in the database. The following
    listing holds the implementation of the `deleteIncompleteUser` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更新查询可能会失败；例如，如果另一个用户已经使用相同的标识符注册了设备。在这种情况下，我们需要手动回滚并移除由身份验证提供者创建的文档，否则数据库中会有一个不完整的文档。下面的列表展示了
    `deleteIncompleteUser` 方法的实现。
- en: Listing 10.11 Implementation of the `deleteIncompleteUser` method
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 `deleteIncompleteUser` 方法的实现
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ This is the technical code for an index constraint violation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是索引约束违规的技术代码。
- en: ❷ Remove the document.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 移除文档。
- en: ❸ Replace the result with the original exception and propagate it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将结果替换为原始异常并传播它。
- en: ❹ err is another kind of error, and we propagate it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `err` 是另一种错误，我们需要传播它。
- en: We need to rely on a technical code in an exception message to distinguish between
    index violation errors and other types of errors. In the first case, the previous
    data has to be removed because we want to deal with it and recover; in the second
    case, this is another error and we cannot do much, so we propagate it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在异常消息中的技术代码来区分索引违规错误和其他类型的错误。在前一种情况下，必须删除先前数据，因为我们想处理它并恢复；在后一种情况下，这是另一种错误，我们无法做太多，所以我们需要传播它。
- en: Finally, the `handleRegistrationError` method shown in the next listing needs
    to inspect the error to respond with the appropriate HTTP status code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下一个列表中显示的 `handleRegistrationError` 方法需要检查错误以响应适当的 HTTP 状态码。
- en: Listing 10.12 Implementation of the `handleRegistrationError` method
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 `handleRegistrationError` 方法的实现
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The error is because the user provided an existing username or device identifier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 错误是因为用户提供了现有的用户名或设备标识符。
- en: ❷ This is a technical error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是一个技术错误。
- en: It is important to notify the requester if the request failed because the username
    or device identifier has already been taken, or if it failed due to some technical
    error. In one case, the error is the fault of the requester, and in the other
    case, the service is the culprit, and the requester can try again later.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求失败是因为用户名或设备标识符已被占用，或者由于某些技术错误而失败，那么通知请求者是很重要的。在一种情况下，错误是请求者的责任，在另一种情况下，服务是罪魁祸首，请求者可以稍后再次尝试。
- en: 10.2.5 Authenticating a user
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5 用户认证
- en: Authenticating a user against a username and password is very simple. All we
    need to do is query the authentication provider, which returns an `io.vertx.ext.auth.User`
    instance on success. In our case, we are not interested in querying permissions
    or roles--all we want to do is check that authentication succeeded.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名和密码进行用户身份验证非常简单。我们只需要查询身份验证提供者，如果成功，它将返回一个 `io.vertx.ext.auth.User` 实例。在我们的案例中，我们对查询权限或角色不感兴趣——我们只想检查身份验证是否成功。
- en: Assuming that an HTTP `POST` request sent to `/authenticate` has a JSON body
    with `username` and `password` fields, we can perform the authentication request
    as follows.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设发送到 `/authenticate` 的 HTTP `POST` 请求有一个包含 `username` 和 `password` 字段的 JSON
    主体，我们可以按以下方式执行身份验证请求。
- en: Listing 10.13 Authenticating a user
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 验证用户
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Authentication method
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 身份验证方法
- en: ❷ Success
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 成功
- en: ❸ Report an authentication failure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 报告身份验证失败。
- en: The result of an authentication request is a `User`, or an exception if it failed.
    Depending on the outcome, we end the HTTP request with a 200 or 401 status code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证请求的结果是一个 `User`，或者如果失败，则是一个异常。根据结果，我们以 200 或 401 状态码结束 HTTP 请求。
- en: 10.2.6 Fetching a user’s data
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6 获取用户数据
- en: HTTP `GET` requests to `/username` must return the data associated with that
    user (e.g., `/foo`, `/bar`, etc.). To do that, we need to prepare a MongoDB query
    and return the data as a JSON response.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `/username` 的 HTTP `GET` 请求必须返回与该用户关联的数据（例如，`/foo`，`/bar` 等）。为此，我们需要准备一个 MongoDB
    查询并以 JSON 响应返回数据。
- en: 'We need a MongoDB “find” query to locate a user document. To do that we need
    two JSON documents:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 MongoDB “find” 查询来定位用户文档。为此，我们需要两个 JSON 文档：
- en: A query document to find based on the value of the `username` field of the database
    documents
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数据库文档中 `username` 字段值进行查询的查询文档
- en: A document to specify the fields that should be returned.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文档用于指定应返回的字段。
- en: The following code performs such a query.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行此类查询。
- en: Listing 10.14 Fetching a user’s data in MongoDB
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.14 在 MongoDB 中获取用户数据
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ We want to match exactly the username.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们想要精确匹配用户名。
- en: ❷ We don’t want the document identifier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不想要文档标识符。
- en: ❸ We want to repeat the username.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们想要重复用户名。
- en: ❹ Find one document.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 查找一个文档。
- en: It is important to specify which fields should be part of the response, and
    to be explicit about it. In our case, we don’t want to reveal the document identifier,
    so we set it to `0` in the `fields` document. We also explicitly list the fields
    that we want to be returned with `1` values. This also ensures that other fields
    like the password and salt values from the authentication are not accidentally
    revealed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 指定哪些字段应包含在响应中，并对此进行明确是很重要的。在我们的案例中，我们不希望泄露文档标识符，因此我们在 `fields` 文档中将它设置为 `0`。我们还明确列出我们希望以
    `1` 值返回的字段。这也确保了密码和盐值等身份验证字段不会意外泄露。
- en: The next listing shows the two methods that complete the fetch request and HTTP
    response.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了完成获取请求和 HTTP 响应的两个方法。
- en: Listing 10.15 Completing a user fetch request
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.15 完成用户获取请求
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Complete successfully by forwarding the JSON result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过转发 JSON 结果成功完成。
- en: ❷ Fail with a 404 if the user does not exist, or with a 500 if a technical error
    was encountered.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果用户不存在，则返回 404 错误，如果遇到技术错误，则返回 500 错误。
- en: It is important to properly deal with the error cases and to distinguish between
    a non-existing user and a technical error.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理错误情况并区分不存在用户和技术错误是很重要的。
- en: Let’s now see the case of updating a user.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更新用户的案例。
- en: 10.2.7 Updating a user’s data
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.7 更新用户数据
- en: 'Updating a user’s data is similar to fetching data, as we need two JSON documents:
    one to match documents, and one to specify what fields need to be updated. The
    following listing shows the corresponding code.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更新用户数据与获取数据类似，因为我们需要两个 JSON 文档：一个用于匹配文档，另一个用于指定需要更新的字段。以下列表显示了相应的代码。
- en: Listing 10.16 Updating a user’s data with MongoDB
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.16 使用 MongoDB 更新用户数据
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ We want to match by username.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们想要通过用户名进行匹配。
- en: ❷ We selectively check each allowed field for updates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们选择性地检查每个允许的字段以进行更新。
- en: ❸ If no allowed field was specified, we quickly return.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果未指定任何允许的字段，我们快速返回。
- en: ❹ The $set operator is used in MongoDB to update data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 MongoDB 中使用 `$set` 操作符来更新数据。
- en: ❺ We search and update one document.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们搜索并更新一个文档。
- en: 'Since the update request is a JSON document coming from an HTTP request, there
    is always the possibility of an external attack if we are not careful. A malicious
    user could craft a JSON document in the request with updates to the password or
    username, so we test for the presence of each allowed field in updates: `city`,
    `email`, and `makePublic`. We then create a JSON document with updates just for
    these fields, rather than reusing the JSON document received over HTTP, and we
    make an update request to the Vert.x MongoDB client.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更新请求是一个来自 HTTP 请求的 JSON 文档，如果我们不小心，总有可能遭受外部攻击。恶意用户可能会在请求中构建一个包含密码或用户名更新的 JSON
    文档，因此我们测试更新中是否存在每个允许的字段：`city`、`email` 和 `makePublic`。然后我们创建一个仅包含这些字段的更新 JSON
    文档，而不是重用通过 HTTP 收到的 JSON 文档，并向 Vert.x MongoDB 客户端发送更新请求。
- en: We have now covered the typical use of MongoDB in Vert.x, as well as how to
    use it for authentication purposes. Let’s move on to PostgreSQL and the activity
    service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了 Vert.x 中 MongoDB 的典型用法，以及如何将其用于认证目的。让我们继续讨论 PostgreSQL 和活动服务。
- en: 10.3 Activity service with PostgreSQL
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 使用 PostgreSQL 的活动服务
- en: The activity service stores all the step updates as they are received from pedometers.
    It is a service that reacts to new step update events (to store data), and it
    can be queried by other services to get step counts for a given device on a given
    day, month, or year.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务存储从计步器接收到的所有步数更新。它是一个响应新步数更新事件（以存储数据）的服务，并且可以被其他服务查询以获取特定设备在特定日期、月份或年份的步数。
- en: The activity service uses PostgreSQL to store activity data after device updates
    have been accepted by the ingestion service. PostgreSQL is well suited for this
    purpose because the SQL query language makes it easy to compute aggregates, such
    as step counts for a device on a given month.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务在设备更新被摄取服务接受后使用 PostgreSQL 存储活动数据。PostgreSQL 非常适合这个目的，因为 SQL 查询语言使得计算聚合数据变得容易，例如计算特定月份设备的步数。
- en: 'The service is split into two independent verticles:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 服务被拆分为两个独立的垂直线：
- en: '`EventsVerticle` listens for incoming activity updates over Kafka and then
    stores data in the database.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventsVerticle` 监听来自 Kafka 的传入活动更新，然后将数据存储在数据库中。'
- en: '`ActivityApiVerticle` exposes an HTTP API for querying activity data.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityApiVerticle` 提供了一个用于查询活动数据的 HTTP API。'
- en: We could have put all the code on a single verticle, but this decoupling renders
    the code more manageable, as each verticle has a well-defined purpose. `EventsVerticle`
    performs writes to the database, whereas `ActivityApiVerticle` performs the read
    operations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将所有代码放在单个垂直线上，但这种解耦使得代码更易于管理，因为每个垂直线都有一个明确的目的。`EventsVerticle` 执行对数据库的写入操作，而
    `ActivityApiVerticle` 执行读取操作。
- en: 10.3.1 Data model
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 数据模型
- en: The data model is not terribly complex and fits in a single *relation* `stepevent`.
    The SQL instructions for creating the `stepevent` table are shown in the following
    listing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型并不复杂，可以放入单个 *关系* `stepevent` 中。创建 `stepevent` 表的 SQL 指令如下所示。
- en: Listing 10.17 SQL instruction for creating the `stepevent` table
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.17 创建 `stepevent` 表的 SQL 指令
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ A timestamp with a timezone
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 带有时区的日期时间
- en: ❷ A composite primary key
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 复合主键
- en: The primary key uniquely identifies an activity update based on a device identifier
    (`device_id`) and a synchronization counter from the device (`device_sync`). The
    timestamp of the event is recorded (`sync_timestamp`), and finally the number
    of steps is stored (`steps_count`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 主键根据设备标识符（`device_id`）和设备同步计数器（`device_sync`）唯一标识活动更新。事件的时间戳被记录（`sync_timestamp`），最后存储步数（`steps_count`）。
- en: 'Tip If you come from a background with a heavy use of *object-relational mappers*
    (ORMs), you may be surprised by the preceding database schema, and especially
    the fact that it uses a composite primary key rather than some auto-incremented
    number. You may want to first consider the proper design of your relational model
    with respect to normal forms, and only then see how to handle data in your code,
    be it with collections and/or objects that reflect the data. If you’re interested
    in the topic, Wikipedia provides a good introduction to database normalization:
    [https://en.wikipedia.org/wiki/Database_normalization](https://en.wikipedia.org/wiki/Database_normalization).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你来自一个大量使用 *对象关系映射器* (ORMs) 的背景，你可能会对前面的数据库模式感到惊讶，尤其是它使用的是复合主键而不是某个自动增长的数字。你可能首先需要考虑你的关系模型在范式方面的适当设计，然后再看看如何在代码中处理数据，无论是使用集合和/或反映数据的对象。如果你对这个主题感兴趣，维基百科提供了数据库规范化的良好介绍：[https://en.wikipedia.org/wiki/Database_normalization](https://en.wikipedia.org/wiki/Database_normalization)。
- en: 10.3.2 Opening a connection pool
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 打开连接池
- en: The `vertx-pg-client` module contains the `PgPool` interface that models a pool
    of connections to a PostgreSQL server, where each connection can be reused for
    subsequent queries. `PgPool` is your main access point in the client for performing
    SQL queries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertx-pg-client` 模块包含了一个 `PgPool` 接口，该接口模拟了一个连接到 PostgreSQL 服务器的连接池，其中每个连接都可以用于后续的查询。`PgPool`
    是客户端执行 SQL 查询的主要访问点。'
- en: The following listing shows how to create a PostgreSQL connection pool.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何创建 PostgreSQL 连接池。
- en: Listing 10.18 Creating a PostgreSQL connection pool
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.18 创建 PostgreSQL 连接池
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Create a connection pool.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建连接池。
- en: ❷ Configuration for the connection
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 连接配置
- en: The pool creation requires a Vert.x context, a set of connection options such
    as the host, database, and password, and pool options. The pool options can be
    tuned to set the maximum number of connections as well as the size of the waiting
    queue, but default values are fine here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池的创建需要一个 Vert.x 上下文，一组连接选项，如主机、数据库和密码，以及池选项。池选项可以调整以设置最大连接数以及等待队列的大小，但这里默认值是足够的。
- en: The `pool` object is then used to perform queries to the database, as you will
    see next.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `pool` 对象执行对数据库的查询，正如你接下来将看到的。
- en: 10.3.3 Life of a device update event
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 设备更新事件的寿命
- en: 'The `EventsVerticle` is in charge of listening to Kafka records on the `incoming.steps`
    topic, where each record is an update received from a device through the ingestion
    service. For each record, `EventsVerticle` must do the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventsVerticle` 负责监听 `incoming.steps` 主题上的 Kafka 记录，其中每个记录是通过摄入服务从设备接收到的更新。对于每个记录，`EventsVerticle`
    必须执行以下操作：'
- en: Insert the record into the PostgreSQL database.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将记录插入到 PostgreSQL 数据库中。
- en: Generate an updated record with the daily step count for the device of the record.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成包含设备每日步数的更新记录。
- en: Publish it as a new Kafka record to the `daily.step.updates` Kafka topic.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其作为新的 Kafka 记录发布到 `daily.step.updates` Kafka 主题。
- en: This is illustrated in figure 10.2.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图 10.2 中得到了说明。
- en: '![](../Images/CH10_F02_Ponge.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F02_Ponge.png)'
- en: Figure 10.2 Steps for recording a device update and producing an update event
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 记录设备更新和生成更新事件的步骤
- en: These steps are modeled by the RxJava pipeline defined in the following listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤由以下列表中定义的 RxJava 管道进行建模。
- en: Listing 10.19 RxJava pipeline for processing updates in `EventsVerticle`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.19 `EventsVerticle` 中处理更新的 RxJava 管道
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Subscribe to the Kafka topic.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 订阅 Kafka 主题。
- en: ❷ Insert a new record in the database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在数据库中插入一条新记录。
- en: ❸ Query the database to publish another record.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查询数据库以发布另一条记录。
- en: ❹ Commit the record to Kafka.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将记录提交到 Kafka。
- en: This RxJava pipeline is reminiscent of those we saw earlier in the messaging
    and eventing stack, as we compose three asynchronous operations. This pipeline
    reads from Kafka, inserts database records (`insertRecord`), produces a query
    to write to Kafka (`generateActivityUpdate`), and commits it (`commitKafkaConsumerOffset`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 RxJava 管道让人联想到我们在消息和事件堆栈中看到的那些，因为我们组合了三个异步操作。这个管道从 Kafka 读取，插入数据库记录 (`insertRecord`)，生成写入
    Kafka 的查询 (`generateActivityUpdate`)，并将其提交 (`commitKafkaConsumerOffset`)。
- en: 10.3.4 Inserting a new record
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 插入新记录
- en: The SQL query to insert a record is shown next.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了插入记录的 SQL 查询。
- en: Listing 10.20 SQL query to insert step events
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.20 插入步事件 SQL 查询
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ $n is the n th entry in the values tuple.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ $n 是值元组的第 n 个条目。
- en: Tip Vert.x does not prescribe any object-relational mapping tool. Using plain
    SQL is a great option, but if you want to abstract your code from the particularities
    of databases and use an API to build your queries rather than using strings, I
    recommend looking at jOOQ ([www.jooq.org/](http://www.jooq.org/)). You can even
    find a Vert.x/jOOQ integration module in the community.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 Vert.x不指定任何对象关系映射工具。使用纯SQL是一个很好的选择，但如果您想将代码从数据库的特定性中抽象出来，并使用API来构建查询而不是使用字符串，我建议查看jOOQ
    ([www.jooq.org/](http://www.jooq.org/))。您甚至可以在社区中找到一个Vert.x/jOOQ集成模块。
- en: We use a class with static methods to define SQL queries, as it is more convenient
    than plain string constants in our code. The query will be used as a prepared
    statement, where values prefixed by a `$` symbol will be taken from a tuple of
    values. Since we use a prepared statement, these values are safe from SQL injection
    attacks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个具有静态方法的类来定义SQL查询，因为它比我们代码中的普通字符串常量更方便。该查询将用作预处理语句，其中以`$`符号为前缀的值将从值元组中获取。由于我们使用预处理语句，这些值可以免受SQL注入攻击。
- en: The `insertRecord` method is called for each new Kafka record, and the method
    body is shown in the following listing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertRecord`方法为每个新的Kafka记录调用，方法体如下所示。'
- en: Listing 10.21 Implementation of the `insertRecord` method
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.21 `insertRecord`方法的实现
- en: '[PRE20]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ JSON body from the Kafka record
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Kafka记录的JSON体
- en: ❷ Tuple structure
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 元组结构
- en: ❸ Insert request
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 插入请求
- en: ❹ Execute the request with parameters.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用参数执行请求。
- en: ❺ Remap the Kafka record for processing in the generateActivityUpdate method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在`generateActivityUpdate`方法中重新映射Kafka记录以进行处理。
- en: ❻ Handle duplicate inserts gracefully.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 优雅地处理重复插入。
- en: We first extract the JSON body from the record, and then prepare a tuple of
    values to pass as parameters to the SQL query in listing 10.20\. The result of
    the query is a row set, but since this is not a `SELECT` query, we do not care
    about the result. Instead, we simply remap the result with the original Kafka
    record value, so the `generateActivityUpdate` method can reuse it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从记录中提取JSON体，然后准备一个值元组作为参数传递给列表10.20中的SQL查询。查询的结果是一个行集，但由于这不是`SELECT`查询，所以我们不关心结果。相反，我们只是将结果重新映射到原始Kafka记录值，这样`generateActivityUpdate`方法就可以重用它。
- en: The `onErrorReturn` operator allows us to handle duplicate inserts gracefully.
    It is possible that after a service restart we’ll end up replaying some Kafka
    events that we had already processed, so the `INSERT` queries will fail instead
    of creating entries with duplicate primary keys.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorReturn`运算符允许我们优雅地处理重复插入。可能的情况是在服务重启后，我们将重新播放一些我们已处理的Kafka事件，因此`INSERT`查询将失败，而不是创建具有重复主键的条目。'
- en: The `duplicateKeyInsert` method in the following listing shows how we can distinguish
    between a duplicate key error and another technical error.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的`duplicateKeyInsert`方法展示了我们如何区分重复键错误和其他技术错误。
- en: Listing 10.22 Detecting a duplicate key error
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.22 检测重复键错误
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Technical code error for a duplicate key insertion attempt
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重复键插入尝试的技术代码错误
- en: We again have to search for a technical error code in the exception message,
    and if it corresponds to a PostgreSQL duplicate key error, then `onErrorReturn`
    puts the original Kafka record in the pipeline rather than letting an error be
    propagated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次需要在异常消息中搜索技术错误代码，如果它与PostgreSQL重复键错误相对应，那么`onErrorReturn`将原始Kafka记录放入管道，而不是让错误传播。
- en: 10.3.5 Generating a device’s daily activity update
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 生成设备的每日活动更新
- en: The next step in the RxJava processing pipeline after a record has been inserted
    is to query the database to find out how many steps have been taken on the current
    day. This is then used to prepare a new Kafka record and push it to the `daily.step.updates`
    Kafka topic.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录已插入到RxJava处理管道之后的下一步是查询数据库以找出当天已经执行了多少步。然后，这些信息被用来准备一个新的Kafka记录并将其推送到`daily.step.updates`
    Kafka主题。
- en: The SQL query corresponding to that operation is specified by the `stepsCountForToday`
    method in the following listing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于该操作的SQL查询由以下列表中的`stepsCountForToday`方法指定。
- en: Listing 10.23 SQL query to get the steps count for a device on the current day
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.23 获取当前设备步骤计数的SQL查询
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Steps count will be 0 if there are no matching entries.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果没有匹配的条目，步骤计数将为0。
- en: ❷ Match records for the current day, truncating hours, minutes, and seconds.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 匹配当前天的记录，截断小时、分钟和秒。
- en: This request computes the sum (or 0) of the steps taken on the current day for
    a given device identifier.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求计算给定设备标识符在当前日期所采取的步数之和（或0）。
- en: The next listing shows the implementation of the `generateActivityUpdate` method,
    picking up the original Kafka record forwarded by the `insertRecord` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`generateActivityUpdate`方法的实现，它拾取`insertRecord`方法转发的原始Kafka记录。
- en: Listing 10.24 Implementation of the `generateActivityUpdate` method
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.24 `generateActivityUpdate`方法实现
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Extract the device identifier from the original Kafka record.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从原始Kafka记录中提取设备标识符。
- en: ❷ Key for the new Kafka record
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 新Kafka记录的关键
- en: ❸ Prepared statement with a tuple of one value
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含一个值的元组的预处理语句
- en: ❹ We expect just one row.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们期望只有一行。
- en: ❺ Create a new JsonObject out of the row values.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从行值创建一个新的JsonObject。
- en: ❻ Compose the Kafka send operation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 组合Kafka发送操作。
- en: This code shows how we can manipulate rows following a `SELECT` query. The result
    of a query is `RowSet`, materialized here by the `rs` argument in the first `map`
    operator, and which can be iterated row by row. Since the query returns a single
    row, we can directly access the first and only row by calling `next` on the `RowSet`
    iterator. We then access the row elements by type and index to build a `JsonObject`
    that creates the Kafka record sent to the `daily.step.updates` topic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了我们如何在`SELECT`查询之后操作行。查询的结果是`RowSet`，在这里通过第一个`map`运算符的`rs`参数物化，并且可以逐行迭代。由于查询返回单行，我们可以通过在`RowSet`迭代器上调用`next`直接访问第一行和唯一一行。然后我们通过类型和索引访问行元素，构建一个`JsonObject`，该对象创建发送到`daily.step.updates`主题的Kafka记录。
- en: 10.3.6 Activity API queries
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.6 活动API查询
- en: The `ActivityApiVerticle` class exposes the HTTP API for the activity service--all
    routes lead to SQL queries. I won’t show all of them. We’ll focus on the monthly
    steps for a device, handled through HTTP `GET` requests to `/:deviceId/:year/:month`.
    The SQL query is shown next.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityApiVerticle`类公开了活动服务的HTTP API--所有路由都导向SQL查询。我不会展示所有这些。我们将关注设备的月度步数，通过HTTP
    `GET`请求到`/:deviceId/:year/:month`来处理。接下来的SQL查询将展示。'
- en: Listing 10.25 Monthly step count SQL query
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.25 月度步数SQL查询
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The value needs to be coalesced to a timestamp.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要将值合并为时间戳。
- en: The `stepsOnMonth` method is shown in the next listing. It performs the SQL
    query based on the year and month path parameters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`stepsOnMonth`方法，它根据年和月路径参数执行SQL查询。
- en: Listing 10.26 Handling monthly steps requests
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.26 处理月度步数请求
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Query arguments tuple
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查询参数元组
- en: ❷ JSON response based on the row data
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 基于行数据的JSON响应
- en: ❸ Sends an HTTP 400 error
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发送HTTP 400错误
- en: ❹ When a URL parameter is not a number or does not result in a valid date
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当URL参数不是数字或不会产生有效日期时
- en: The query result is again a `RowSet`, and we know from the SQL query that only
    one row can be returned, so we use the `map` operator to extract it. The `sendCount`
    method sends the data as a JSON document, while the `handleError` method produces
    an HTTP 500 error. When a year or month URL parameter is not a number or does
    not result in a valid date, `sendBadRequest` produces an HTTP 400 response to
    let the request know of the mistake.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果再次是`RowSet`，我们从SQL查询中知道只能返回一行，所以我们使用`map`运算符来提取它。`sendCount`方法将数据作为JSON文档发送，而`handleError`方法产生HTTP
    500错误。当年份或月份URL参数不是数字或不会产生有效日期时，`sendBadRequest`产生HTTP 400响应，让请求知道错误。
- en: It is now time to move on to integration testing strategies. I’ll also show
    you some other data client methods, such as SQL batch queries, when we have to
    prepopulate a PostgreSQL database.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转向集成测试策略了。当我们需要预先填充PostgreSQL数据库时，我还会向你展示一些其他数据客户端方法，例如SQL批查询。
- en: 10.4 Integration tests
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 集成测试
- en: 'Testing the user profile service involves issuing HTTP requests to the corresponding
    API. The activity service has two facets: one that involves the HTTP API, and
    one that involves crafting Kafka events and observing the effects in terms of
    persisted state and produced events.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用户配置文件服务涉及向相应的API发出HTTP请求。活动服务有两个方面：一个涉及HTTP API，另一个涉及构建Kafka事件并观察持久状态和产生事件的效应。
- en: 10.4.1 Testing the user profile service
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 测试用户配置文件服务
- en: The user profile tests rely on issuing HTTP requests that impact the service
    state and the database (e.g., creating a user) and then issuing further HTTP requests
    to perform some assertions, as illustrated in figure 10.3.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 用户配置文件测试依赖于发出影响服务状态和数据库的HTTP请求（例如，创建用户），然后发出进一步的HTTP请求来执行一些断言，如图10.3所示。
- en: '![](../Images/CH10_F03_Ponge.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Ponge.png)'
- en: Figure 10.3 Testing the user profile service
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 测试用户配置文件服务
- en: The integration tests rely again on Testcontainers, as we need to have a MongoDB
    instance running. Once we have the container running, we need to prepare the MongoDB
    database to be in a *clean state* before we run any tests. This is important to
    ensure that a test is not affected by data left by a previous test’s execution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试再次依赖于 Testcontainers，因为我们需要一个运行的 MongoDB 实例。一旦容器运行，我们需要在运行任何测试之前将 MongoDB
    数据库准备为 *干净状态*。这很重要，以确保测试不受先前测试执行留下的数据的影响。
- en: The `setup` method of the `IntegrationTest` class performs the test preparation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntegrationTest` 类的 `setup` 方法执行测试准备。'
- en: Listing 10.27 User profile integration test setup
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.27 用户配置文件集成测试设置
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Ensure we have an index on username.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确保我们对 username 有索引。
- en: ❷ Ensure we have an index on deviceId.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保我们对 deviceId 有索引。
- en: ❸ Drop all users.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 删除所有用户。
- en: We first connect to the MongoDB database and then ensure we have two indexes
    for the `username` and `deviceId` fields. We then remove all existing documents
    from the `profiles` database (see listing 10.28), and deploy an instance of the
    `UserProfileApiVerticle` verticle before successfully completing the initialization
    phase.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先连接到 MongoDB 数据库，然后确保我们有两个索引，用于 `username` 和 `deviceId` 字段。然后我们从 `profiles`
    数据库中删除所有现有文档（见列表 10.28），并在成功完成初始化阶段之前部署 `UserProfileApiVerticle` 实例。
- en: Listing 10.28 Deleting all users in the MongoDB database
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.28 删除 MongoDB 数据库中的所有用户
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Match unconditionally with an empty JSON query document.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无条件匹配一个空的 JSON 查询文档。
- en: The `IntegrationTest` class provides different test cases of operations that
    are expected to succeed, as well as operations that are expected to fail. RestAssured
    is used to write the test specifications of the HTTP requests, as in the following
    listing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntegrationTest` 类提供了预期成功和预期失败的操作的不同测试用例。RestAssured 用于编写 HTTP 请求的测试规范，如下所示。'
- en: Listing 10.29 Test for authenticating a missing user
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.29 测试验证缺失用户
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ This user does not exist.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此用户不存在。
- en: ❷ We expect an HTTP 401 status code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们期望得到一个 HTTP 401 状态码。
- en: The `authenticateMissingUser` method checks that authenticating against invalid
    credentials results in an HTTP 401 status code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticateMissingUser` 方法检查使用无效凭据进行身份验证是否会导致 HTTP 401 状态码。'
- en: Another example is the following test, where we check what happens when we attempt
    to register a user twice.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是以下测试，其中我们检查当我们尝试两次注册一个用户时会发生什么。
- en: Listing 10.30 Test for registering a user twice
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.30 测试两次注册用户
- en: '[PRE29]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ This method returns a predefined JSON object for a user.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此方法为用户返回一个预定义的 JSON 对象。
- en: ❷ The first attempt is ok.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一次尝试是正常的。
- en: ❸ The second attempt is not ok!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二次尝试不正常！
- en: We could also peek into the database and check the data that is being stored
    after each action. Since we need to cover all functional cases of the HTTP API,
    it is more straightforward to focus on just the HTTP API in the integration tests.
    However, there are cases where an API on top of a database may not expose you
    to some important effects on the stored data, and in these cases, you will need
    to connect to the database to make some further assertions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以查看数据库并检查每次操作后存储的数据。由于我们需要覆盖 HTTP API 的所有功能用例，因此在集成测试中只关注 HTTP API 更为直接。然而，在某些情况下，数据库上的
    API 可能不会暴露存储数据的一些重要影响，在这些情况下，您将需要连接到数据库以进行进一步的断言。
- en: 10.4.2 Testing the activity service API
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 测试活动服务 API
- en: Testing the activity service API is quite similar to testing the user profile
    service, except that we use PostgreSQL instead of MongoDB.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 测试活动服务 API 与测试用户配置文件服务非常相似，只是我们使用 PostgreSQL 而不是 MongoDB。
- en: We first need to ensure that the data schema is defined as in listing 10.17\.
    To do that, the SQL script in init/postgres/setup.sql is run automatically when
    the PostgreSQL container starts. This works because the container image specifies
    that any SQL script found in /docker-entrypoint-initdb.d/ will be run when it
    starts, and the Docker Compose file that we use mounts init/postgres to /docker-entrypoint-initdb.d/,
    so the SQL file is available in the container.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确保数据模式定义如列表 10.17 所示。为此，当 PostgreSQL 容器启动时，会自动运行 init/postgres/setup.sql
    中的 SQL 脚本。这是因为容器镜像指定了在启动时将运行在 /docker-entrypoint-initdb.d/ 中找到的任何 SQL 脚本，而我们使用的
    Docker Compose 文件将 init/postgres 挂载到 /docker-entrypoint-initdb.d/，因此 SQL 文件在容器中可用。
- en: Once the database has been prepared with some predefined data, we issue HTTP
    requests to perform assertions, as shown in figure 10.4.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据库准备好了预定义的数据，我们就发出 HTTP 请求来进行断言，如图 10.4 所示。
- en: '![](../Images/CH10_F04_Ponge.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F04_Ponge.png)'
- en: Figure 10.4 Testing the activity service API
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 测试活动服务 API
- en: We again rely on Testcontainers to start a PostgreSQL server, and then we rely
    on the test setup method to prepare the data as follows.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次依赖 Testcontainers 启动一个 PostgreSQL 服务器，然后我们依赖测试设置方法来准备数据如下。
- en: Listing 10.31 Preparing the activity service API test
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.31 准备活动服务 API 测试
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Query to insert data
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 插入数据的查询
- en: ❷ A set of entries for the database
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数据库的条目集
- en: ❸ Ensure no event is left.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确保没有事件被留下。
- en: ❹ Insert our data.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 插入我们的数据。
- en: ❺ Deploy the API verticle.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 部署 API 垂直服务。
- en: ❻ Close the connection pool.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 关闭连接池。
- en: Here we want a database with a data set that we control, with activities for
    devices `123`, `456`, `abc`, and `def` at various points in time. For instance,
    device `123` recorded 320 steps on 2019/05/21 at 11:00, and that was the fourth
    time the device made a successful synchronization with the backend. We can then
    perform checks against the HTTP API, as in the following listing, where we check
    the number of steps for device `123` in May 2019.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个我们控制的数据库和数据集，其中包含设备 `123`、`456`、`abc` 和 `def` 在不同时间点的活动。例如，设备 `123` 在
    2019/05/21 11:00 记录了 320 步，这是该设备与后端成功同步的第四次。然后我们可以执行以下列表中的 HTTP API 检查，检查 2019
    年 5 月设备 `123` 的步数。
- en: Listing 10.32 Checking steps for device 123 on a given month
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.32 检查设备 123 在指定月份的步数
- en: '[PRE31]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ URL of the query
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查询 URL
- en: ❷ Check the JSON result.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查 JSON 结果。
- en: The activity HTTP API is the read-only part of the service, so let’s now look
    at the other part of the service.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 活动HTTP API是服务的只读部分，因此现在让我们看看服务的另一部分。
- en: 10.4.3 Testing the activity service’s event handling
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 测试活动服务的イベント处理
- en: 'The technique for testing the Kafka event processing part of `EventsVerticle`
    is very similar to what we did in the previous chapter: we’ll send some Kafka
    records and then observe what Kafka records the service produces.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `EventsVerticle` 的 Kafka 事件处理部分的技巧与我们在上一章中做的是非常相似的：我们将发送一些 Kafka 记录，然后观察服务产生的
    Kafka 记录。
- en: By sending multiple step updates for a given device, we should observe that
    the service produces updates that accumulate the steps on the current day. Since
    the service both consumes and produces Kakfa records that reflect the current
    state of the database, we won’t need to perform SQL queries--observing that correct
    Kafka records are being produced is sufficient. Figure 10.5 provides an overview
    of how the testing is done.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为特定设备发送多个步数更新，我们应该观察到服务产生了累积当前日步数的更新。由于服务既消费又产生反映数据库当前状态的 Kafka 记录，我们不需要执行
    SQL 查询--观察是否产生了正确的 Kafka 记录就足够了。图 10.5 提供了测试的概述。
- en: '![](../Images/CH10_F05_Ponge.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F05_Ponge.png)'
- en: Figure 10.5 Testing the activity service event handling
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 测试活动服务的事件处理
- en: 'The integration test class (`EventProcessingTest`) again uses TestContainers
    to start the required services: PostgreSQL, Apache Kafka, and Apache ZooKeeper.
    Before any test is run, we must start from a clean state by using the test preparation
    code in the following listing.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试类 (`EventProcessingTest`) 再次使用 TestContainers 启动所需的服务：PostgreSQL、Apache
    Kafka 和 Apache ZooKeeper。在运行任何测试之前，我们必须使用以下列表中的测试准备代码从干净状态开始。
- en: Listing 10.33 Preparation code for the event-processing integration tests
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.33 事件处理集成测试的准备工作代码
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Delete data from the database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据库中删除数据。
- en: ❷ Delete Kafka topics.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 删除 Kafka 主题。
- en: ❸ Close the database connection pool.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 关闭数据库连接池。
- en: We need to ensure that the PostgreSQL database is empty, and that the Kafka
    topics we use to receive and send events are deleted. We can then focus on the
    test method, where we will send two step updates for device `123`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保 PostgreSQL 数据库为空，并且我们用于接收和发送事件的 Kafka 主题已被删除。然后我们可以专注于测试方法，我们将为设备 `123`
    发送两个步数更新。
- en: Before that, we must first subscribe to the `daily.step.updates` Kafka topic,
    where the `EventsVerticle` class will send Kafka records. The following listing
    shows the first part of the test case.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们必须首先订阅 `daily.step.updates` Kafka 主题，其中 `EventsVerticle` 类将发送 Kafka 记录。以下列表显示了测试用例的第一部分。
- en: Listing 10.34 First part of the events verticle test case
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.34 事件垂直测试用例的第一部分
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Skip the first update.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过第一次更新。
- en: ❷ Get the second update.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取第二次更新。
- en: ❸ Perform some assertions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行一些断言。
- en: Since we send two updates, we skip the emitted record and only perform assertions
    on the second one, as it should reflect the sum of the steps from the two updates.
    The preceding code is waiting for events to be produced, so we now need to deploy
    `EventsVerticle` and send the two updates as follows.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们发送了两个更新，我们跳过了发出的记录，并且只对第二个进行断言，因为它应该反映两个更新的步骤总和。前面的代码正在等待事件产生，因此我们现在需要部署`EventsVerticle`并发送以下两个更新。
- en: Listing 10.35 Second part of the events verticle test case
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.35事件垂直测试用例的第二部分
- en: '[PRE34]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Deploy EventsVerticle.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 部署EventsVerticle。
- en: ❷ First update
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一次更新
- en: ❸ Second update
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二次更新
- en: The test completes as `EventsVerticle` properly sends correct updates to the
    `daily.step.updates` Kafka topic. We can again note how RxJava allows us to compose
    asynchronous operations in a declarative fashion and ensure the error processing
    is clearly identified. We have essentially two RxJava pipelines here, and any
    error causes the test context to fail.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 测试以`EventsVerticle`正确地向`daily.step.updates` Kafka主题发送正确的更新而完成。我们再次注意到RxJava如何以声明式方式组合异步操作并确保错误处理被清楚地识别。我们实际上有两个RxJava管道，任何错误都会导致测试上下文失败。
- en: note There is a tiny vulnerability window for this test to fail if the first
    update is sent before midnight and the second right after midnight. In that case,
    the second event will not be a sum of the steps in the two events. This is very
    unlikely to happen, since the two events will be emitted a few milliseconds apart,
    but still, it *could* happen.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: note 如果第一次更新在午夜之前发送，第二次更新在午夜之后发送，则此测试可能会出现微小的漏洞窗口导致失败。在这种情况下，第二个事件将不会是两个事件步骤的总和。这种情况非常不可能发生，因为两个事件将在几毫秒内发出，但仍然，*可能*会发生。
- en: Speaking of event streams, the next chapter will focus on advanced event processing
    services with Vert.x.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到事件流，下一章将重点介绍Vert.x的高级事件处理服务。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The Vert.x MongoDB client allows you to store and query documents.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x MongoDB客户端允许您存储和查询文档。
- en: Vert.x can also use MongoDB to perform authentication and safely store user
    credentials, roles, and permissions.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x还可以使用MongoDB进行身份验证并安全地存储用户凭据、角色和权限。
- en: Vert.x offers an efficient reactive driver for PostgreSQL.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x提供了一个高效的响应式驱动程序用于PostgreSQL。
- en: You do not always need an object-relational mapper. Working directly with SQL
    and relational data can be simple and efficient.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你并不总是需要一个对象关系映射器。直接使用SQL和关系数据可以简单且高效。
- en: It is important to ensure clean state in databases before executing integration
    tests.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行集成测试之前确保数据库中的状态清洁是很重要的。
- en: '* * *'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.For information on DTOs, see Martin Fowler’s “Data Transfer Object” article
    at [https://martinfowler.com/ eaaCatalog/dataTransferObject.html](https://martinfowler.com/eaaCatalog/dataTransferObject.html).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 1.有关DTO的信息，请参阅Martin Fowler的“数据传输对象”文章，[https://martinfowler.com/eaaCatalog/dataTransferObject.html](https://martinfowler.com/eaaCatalog/dataTransferObject.html)。
- en: 2.See Ted Neward, “The Vietnam of Computer Science,” [http://blogs.tedneward.com/post/the-vietnam-of-computer-science/](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 2.参见Ted Neward的“计算机科学的越南”，[http://blogs.tedneward.com/post/the-vietnam-of-computer-science/](http://blogs.tedneward.com/post/the-vietnam-of-computer-science/)。
