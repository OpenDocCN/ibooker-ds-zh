- en: 8 Deploying our full stack GraphQL application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 部署我们的全栈 GraphQL 应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Deploying our full stack GraphQL application so it is accessible to users on
    the web
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署我们的全栈 GraphQL 应用程序，使其可供网络上的用户访问
- en: Using serverless deployment and cloud-managed services like Netlify, AWS Lambda,
    and Neo4j Aura
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器部署和云托管服务，如 Netlify、AWS Lambda 和 Neo4j Aura
- en: A framework for evaluating various deployment options to help us reconcile the
    inherent tradeoffs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估各种部署选项的框架，帮助我们解决固有的权衡
- en: While developing our application so far, we have been running it locally on
    our machine for testing. Now, it’s time to deploy our application so we can share
    it with the world and have users interact with it. There are many different ways
    to deploy applications, especially with the growth and evolution of cloud-managed
    services that offer improved developer experiences and usage pricing. There is
    not a single best deployment option for any application, as each choice has tradeoffs;
    ultimately, the developer must decide what options make the most sense for them
    and their use case.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的开发过程中，我们一直在本地机器上运行我们的应用程序进行测试。现在，是时候部署我们的应用程序，以便我们可以与世界分享它，并让用户与之交互。部署应用程序的方法有很多种，尤其是在云托管服务的增长和演变中，这些服务提供了改进的开发体验和定价。没有一种单一的最好部署选项适用于任何应用程序，因为每个选择都有权衡；最终，开发者必须决定哪些选项对他们及其用例最有意义。
- en: In this chapter, we explore an opinionated approach to deploying our full stack
    GraphQL application, taking advantage of third-party service providers, like Netlify,
    AWS Lambda, and Neo4j Aura. This approach of leveraging managed services, outsourcing
    much of the operations of these services to the provider, is often referred to
    as *serverless*. We evaluate the advantages and disadvantages of this deployment
    approach, using a framework focused on operations, scale, and developer experience.
    Finally, we review alternative options for deployment and discuss the tradeoffs
    introduced.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一种有见地的部署我们的全栈 GraphQL 应用程序的方法，利用第三方服务提供商，如 Netlify、AWS Lambda 和 Neo4j
    Aura。这种利用托管服务、将这些服务的许多运营外包给提供商的方法通常被称为*无服务器*。我们使用一个关注运营、规模和开发者体验的框架来评估这种部署方法的优缺点。最后，我们回顾了其他部署选项，并讨论了引入的权衡。
- en: 8.1 Deploying our full stack GraphQL application
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 部署我们的全栈 GraphQL 应用程序
- en: '*Serverless* computing is a paradigm that describes a way of allocating computing
    resources and execution on demand; it’s a way for developers to ship their application
    without concerning themselves with provisioning and maintaining servers. Services
    like the AWS Lambda Function as a Service (FaaS) platform are said to be *serverless*—not
    because no servers are involved in the process of serving an application, but
    rather, the developer need not think about servers, and instead, the relevant
    abstraction becomes the *function*, or unit of code. Usage of the term *serverless*
    has expanded to describe not just computing runtimes like AWS Lambda and Google
    App Engine but also databases and other managed cloud services.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*无服务器*计算是一种描述按需分配计算资源和执行方式的范例；它是开发者无需关心服务器配置和维护即可交付其应用程序的方式。像 AWS Lambda Function
    as a Service (FaaS) 平台这样的服务被称为*无服务器*——并不是因为在这个过程中没有服务器参与服务应用程序，而是开发者无需考虑服务器，相反，相关的抽象变成了*函数*，或代码单元。*无服务器*这一术语的使用已经扩展，不仅描述了像
    AWS Lambda 和 Google App Engine 这样的计算运行时，还包括数据库和其他托管云服务。'
- en: The first deployment paradigm we will examine takes advantage of *managed services*.
    A managed service is a way of outsourcing responsibility for operating software,
    infrastructure, or networking to a cloud service provider. This means developers
    can spend less time maintaining and operating things like the database, scaling
    up webservers, installing security updates, and renewing SSL certificates and
    can, instead, focus on building aspects of their application in which they have
    a competitive advantage, such as the core business competency and business logic.
    Our approach has special appeal for full stack developers, who may not be experts
    or care to take on responsibility for managing databases, servers, dealing with
    SSL certificates, DNS configuration, and other aspects needed for operating a
    full stack web application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考察的第一个部署范式利用了*托管服务*。托管服务是将操作软件、基础设施或网络的责任外包给云服务提供商的一种方式。这意味着开发者可以花更少的时间维护和操作数据库、扩展Web服务器、安装安全更新以及续订SSL证书，相反，他们可以专注于构建他们在其中具有竞争优势的应用程序方面，例如核心业务能力和业务逻辑。我们的方法对全栈开发者特别有吸引力，他们可能不是数据库、服务器管理、处理SSL证书、DNS配置和其他操作全栈Web应用程序所需方面的专家，或者他们不愿意承担这些责任。
- en: 8.1.1 Advantages of this deployment approach
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 这种部署方法的优势
- en: Embracing managed services offers advantages over alternative approaches. Here
    we highlight the advantages of developer productivity, usage-based pricing, scalability,
    and maintenance and operations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 采用托管服务相对于其他方法具有优势。在这里，我们强调了开发者生产力、基于使用的定价、可扩展性和维护和运营的优势。
- en: Developer productivity
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者生产力
- en: 'Many managed services pride themselves on offering an improved developer experience
    that abstracts away many unnecessary complexities or concerns that are unrelated
    to the goals of the developer: building and shipping their application. Tooling
    like web consoles to configure services and command line interfaces (CLIs) that
    can be integrated into developer workflows enable developers to be more productive.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多托管服务以提供改进的开发者体验而自豪，这种体验抽象了许多与开发者目标无关的不必要复杂性和关注点：构建和发布他们的应用程序。像Web控制台这样的工具可以配置服务，以及可以集成到开发者工作流程中的命令行界面（CLI），使开发者能够更加高效。
- en: Usage pricing
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定价
- en: Incurring costs based on the usage of the service is a core tenet of this paradigm.
    If an application has very little usage, it will incur little cost for the developer.
    This allows developers to build, deploy, and test their applications with little
    upfront cost, since their costs are not fixed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务的使用情况来产生成本是这个范式的一个核心原则。如果一个应用程序的使用非常少，那么对于开发者来说，产生的成本也会很小。这允许开发者以较低的前期成本构建、部署和测试他们的应用程序，因为他们的成本不是固定的。
- en: Scalability
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Services should scale on demand driven by usage. For example, a FaaS runtime
    like AWS Lambda executes in response to events, such as the invocation of an API
    endpoint. Each function invocation is stateless and runs concurrently, allowing
    for greater elasticity and on-demand scaling than a single web server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应根据需求驱动进行扩展。例如，AWS Lambda 这样的函数即服务（FaaS）运行时会在响应事件时执行，例如调用API端点。每个函数调用都是无状态的，可以并发运行，这比单个Web服务器提供了更大的弹性和按需扩展能力。
- en: Maintenance and operations
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 维护和运营
- en: By using managed services, the responsibility for ensuring that the service
    operates in a healthy, secure, and high-performing state is outsourced to the
    service provider. This benefit often resonates with the full-stack developer who
    is typically responsible for many components of the overall application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用托管服务，确保服务在健康、安全和高性能状态下的责任被外包给了服务提供商。这种好处通常与那些通常负责整个应用程序许多组件的全栈开发者产生共鸣。
- en: 8.1.2 Disadvantages of our deployment approach
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 我们部署方法的不利因素
- en: Of course, managed services are not a silver bullet that will solve all our
    problems, and they can introduce some disadvantages. These disadvantages include
    vendor lock-in, performance optimization, and usage-based pricing (a double-edged
    sword!).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，托管服务并不是一个万能的解决方案，它不能解决我们所有的问题，而且可能会带来一些不利因素。这些不利因素包括供应商锁定、性能优化和基于使用的定价（一把双刃剑！）。
- en: Vendor lock-in
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商锁定
- en: Outsourcing the responsibility for maintaining and updating the service to a
    service provider means the developer is at the mercy of the service provider to
    provide continuous operation of the service—and at a reasonable cost. Services
    can sometimes be discontinued or deprecated, as many services have specific APIs,
    libraries, or paradigms that may be costly for a developer to adapt to an alternative.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将维护和更新服务的责任外包给服务提供商意味着开发者将依赖于服务提供商提供服务的持续运行——并且成本合理。服务有时可能会被停止或弃用，因为许多服务都有特定的
    API、库或范式，这可能对开发者适应替代方案来说成本高昂。
- en: Performance optimizations
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化
- en: Since many services operate in a multitenant architecture, performance cannot
    always be guaranteed to be consistent, as resources may be shared or allocated
    to other users. Given the on-demand nature of many services, there may be some
    overhead, as resources are provisioned to respond to increased usage.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多服务在多租户架构中运行，性能可能无法始终保证一致，因为资源可能被共享或分配给其他用户。鉴于许多服务的按需性质，可能会有一些开销，因为资源被配置以响应增加的使用量。
- en: Usage pricing
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用费用
- en: Usage pricing can be both an advantage and a disadvantage. If the cost structure
    and usage patterns are not understood, or if there is a surge in unanticipated
    usage, then an unexpected increase in costs could be most unwelcome.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用费用可能既有利又有弊。如果成本结构和使用模式没有得到理解，或者如果出现了未预见的用量激增，那么成本的不预期增加可能会非常不受欢迎。
- en: 8.1.3 Overview of our approach to full stack GraphQL
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 我们对完整堆栈 GraphQL 的方法概述
- en: 'Our deployment approach will take advantage of three managed services (see
    figure 8.1):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的部署方法将利用三种托管服务（见图 8.1）：
- en: '*Neo4j Aura database as a service*—For deploying a managed, scalable graph
    database in the cloud. By using Neo4j Aura, we eliminate the need to think about
    how to manage our database instance. Operations and maintenance, such as regular
    backups and updates, are handled for us by the service.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Neo4j Aura 数据库作为服务*—用于在云中部署一个可管理的、可扩展的图数据库。通过使用 Neo4j Aura，我们消除了考虑如何管理我们的数据库实例的需求。操作和维护，如定期备份和更新，都由服务为我们处理。'
- en: '*Netlify Build*—For building, deploying, and updating our React application
    and serving it globally through a content delivery network (CDN). Using the Netlify
    platform will not only give us access to a global CDN to ensure our site loads
    fast, regardless of where in the world our users are located, but Netlify also
    offers a smooth developer experience and integration with version control systems,
    such as GitHub.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Netlify Build*—用于构建、部署和更新我们的 React 应用程序，并通过内容分发网络（CDN）在全球范围内提供服务。使用 Netlify
    平台不仅将使我们能够访问全球 CDN，以确保无论用户位于世界何处，网站都能快速加载，而且 Netlify 还提供流畅的开发者体验，并与版本控制系统（如 GitHub）集成。'
- en: '*AWS Lambda (via Netlify Functions)*—For deploying our GraphQL API as a scalable
    serverless function. Using AWS Lambda for our GraphQL API means we don’t have
    to think about hosting and managing webservers and scaling servers up and down
    as incoming requests grow.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*AWS Lambda (via Netlify Functions)*—用于将我们的 GraphQL API 部署为一个可扩展的无服务器函数。使用
    AWS Lambda 部署我们的 GraphQL API 意味着我们不需要考虑托管和管理 web 服务器，以及随着请求量的增加而上下调整服务器规模。'
- en: '![CH08_F01_Lyon](../../OEBPS/Images/CH08_F01_Lyon.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Lyon](../../OEBPS/Images/CH08_F01_Lyon.png)'
- en: Figure 8.1 A full stack GraphQL deployment from the user’s perspective
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 从用户角度看到的完整堆栈 GraphQL 部署
- en: 8.2 Neo4j Aura database as a service
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 Neo4j Aura 数据库作为服务
- en: 'Neo4j Aura is Neo4j’s managed cloud service, offering Neo4j database clusters
    as a cloud service. Neo4j Aura offers scalable, highly available Neo4j clusters
    without dealing with operations or maintenance. Developers can provision Neo4j
    clusters with the click of a button and have access to Neo4j developer tooling,
    like Neo4j Browser, Neo4j Bloom, and the APOC standard library. There are two
    flavors of Neo4j Aura: AuraDB and AuraDS. AuraDB is Neo4j’s standard database-as-a-service
    offering, which is suitable for backing web applications and API services. AuraDS
    is Neo4j’s hosted graph data science platform and includes features specific to
    data science workloads. For our purposes, we will be using Neo4j AuraDB.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j Aura 是 Neo4j 的托管云服务，提供 Neo4j 数据库集群作为云服务。Neo4j Aura 提供可扩展、高可用的 Neo4j 集群，无需处理操作或维护。开发者可以一键部署
    Neo4j 集群，并访问 Neo4j 开发者工具，如 Neo4j 浏览器、Neo4j Bloom 和 APOC 标准库。Neo4j Aura 有两种版本：AuraDB
    和 AuraDS。AuraDB 是 Neo4j 的标准数据库作为服务提供，适用于支持 Web 应用程序和 API 服务。AuraDS 是 Neo4j 的托管图数据科学平台，包括针对数据科学工作负载的特定功能。对于我们的目的，我们将使用
    Neo4j AuraDB。
- en: 8.2.1 Creating a Neo4j Aura cluster
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 创建 Neo4j Aura 集群
- en: Since Neo4j Aura is a managed service, we’ll need to first sign up by either
    logging in with a Google account or creating an account using email and password
    at [neo4j.com/aura](https://neo4j.com/cloud/platform/aura-graph-database/) and
    then selecting *Sign Up Now*. Since I use Gmail, I’ll choose to sign in with Google.
    After signing in, we’ll see the Neo4j Aura Dashboard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Neo4j Aura 是一个托管服务，我们首先需要通过登录 Google 账户或使用电子邮件和密码在 [neo4j.com/aura](https://neo4j.com/cloud/platform/aura-graph-database/)
    创建账户，然后选择“立即注册”。由于我使用 Gmail，我将选择使用 Google 登录。登录后，我们将看到 Neo4j Aura 仪表板。
- en: The Neo4j Aura Dashboard is our mission control central for our Neo4j clusters
    in the cloud. We can monitor our databases, provision new databases, import data,
    scale databases up or down, and access developer tooling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j Aura 仪表板是我们云中 Neo4j 集群的指挥控制中心。我们可以监控我们的数据库，配置新的数据库，导入数据，调整数据库大小，以及访问开发者工具。
- en: However, since we haven’t created any Neo4j Aura clusters yet, our dashboard
    looks empty. Let’s create a new cluster by clicking the *Create a database* button
    (see figure 8.2). There is an AuraDB Free tier that offers a Neo4j instance without
    any cost or requirement to input a credit card, so I’ll choose this option. For
    larger applications, we can choose the AuraDB Professional tier, which offers
    additional features and the ability to scale the resources available to our database
    instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们尚未创建任何 Neo4j Aura 集群，我们的仪表板看起来是空的。让我们通过点击“创建数据库”按钮（见图 8.2）来创建一个新的集群。AuraDB
    免费层提供无任何成本且无需输入信用卡的 Neo4j 实例，所以我会选择这个选项。对于大型应用程序，我们可以选择 AuraDB 专业层，它提供额外的功能和扩展数据库实例可用资源的可能性。
- en: '![CH08_F02_Lyon](../../OEBPS/Images/CH08_F02_Lyon.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Lyon](../../OEBPS/Images/CH08_F02_Lyon.png)'
- en: Figure 8.2 Configuring a Neo4j AuraDB deployment
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 配置 Neo4j AuraDB 部署
- en: Be sure to select the *AuraDB Free* database type. Next, we’ll need to choose
    a name for our database. I went with *GRANDstack Business Reviews*. We can choose
    from different regions where our database will be deployed. I just left the default,
    but feel free to select the location closest to you. In the *Starting dataset*
    option, we can choose to start with a predefined dataset or load our own data.
    Since we’ll be working with our own data, select *Load or create your own data
    in a blank database*. After selecting the configuration options, we’ll be presented
    with a random password, which we’ll use to access our Neo4 Aura instance (see
    figure 8.3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要选择“AuraDB 免费版”数据库类型。接下来，我们需要为我们的数据库选择一个名称。我选择了“GRANDstack Business Reviews”。我们可以选择数据库部署的不同区域。我只是保留了默认设置，但您也可以选择离您最近的位置。在“起始数据集”选项中，我们可以选择从预定义的数据集开始，或者加载我们自己的数据。由于我们将使用自己的数据，请选择“在空白数据库中加载或创建自己的数据”。在选择了配置选项后，我们将看到一个随机密码，我们将使用它来访问我们的
    Neo4 Aura 实例（见图 8.3）。
- en: '![CH08_F03_Lyon](../../OEBPS/Images/CH08_F03_Lyon.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F03_Lyon](../../OEBPS/Images/CH08_F03_Lyon.png)'
- en: Figure 8.3 Database credentials for our Neo4j AuraDB deployment
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 Neo4j AuraDB 部署的数据库凭据
- en: Be sure to save the password somewhere safe. We’ll change it, but we will need
    it to log in with Neo4j Browser in a moment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将密码保存在安全的地方。我们将更改密码，但稍后使用 Neo4j 浏览器登录时还需要它。
- en: Clicking *Continue* will take us back to the Neo4j Aura dashboard, but now,
    we’ll see details for the database cluster we’ve just deployed with options to
    *Explore*, *Query*, or *Import* (see figure 8.4). The *Explore* button will launch
    Neo4j Browser, which we’ve used in previous chapters to execute Cypher queries
    and visualize the results. The *Query* button will launch Neo4j Bloom, a visual
    graph exploration tool, which we will explore in a moment. Finally, the *Import*
    button will launch the Neo4j Data Importer, a tool for loading data into Neo4j
    from flat files such as CSV format.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“继续”将带我们回到 Neo4j Aura 仪表板，但现在，我们将看到我们刚刚部署的数据库集群的详细信息，包括“探索”、“查询”或“导入”的选项（见图
    8.4）。“探索”按钮将启动 Neo4j 浏览器，我们在前面的章节中使用它来执行 Cypher 查询并可视化结果。“查询”按钮将启动 Neo4j Bloom，这是一个可视化的图形探索工具，我们将在稍后探索它。最后，“导入”按钮将启动
    Neo4j 数据导入器，这是一个将数据从如 CSV 格式的平面文件加载到 Neo4j 的工具。
- en: '![CH08_F04_Lyon](../../OEBPS/Images/CH08_F04_Lyon.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F04_Lyon](../../OEBPS/Images/CH08_F04_Lyon.png)'
- en: Figure 8.4 The Neo4j AuraDB dashboard, showing our new database
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 Neo4j AuraDB 仪表板，显示我们的新数据库
- en: 'If we click on the database name, we can see more detailed information and
    options specific to our database. For our cluster, we can see the following details:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击数据库名称，我们可以看到更多详细信息和针对我们的数据库的特定选项。对于我们的集群，我们可以看到以下详细信息：
- en: '*Connection URI*—This is the connection string used to connect to our Neo4j
    cluster using the Neo4j client drivers.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接URI*—这是用于使用Neo4j客户端驱动程序连接到我们的Neo4j集群的连接字符串。'
- en: '*Tier*—This tells us the service tier for this database (Free, Professional,
    or Enterprise).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*层级*—这告诉我们数据库的服务层级（免费、专业或企业）。'
- en: '*Cloud provider*—This is the cloud platform where this cluster is deployed.
    In this case, it is Google Cloud Platform.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*云服务提供商*—这是部署此集群的云平台。在这种情况下，它是Google Cloud Platform。'
- en: '*Region*—This is the geographical region of the data center where the cluster
    is deployed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*区域*—这是集群部署的数据中心的地理区域。'
- en: '*Memory*—This is the current size of the database, which can be scaled up or
    down at any time.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*—这是数据库的当前大小，可以在任何时候进行扩展或缩减。'
- en: We also have the *Open with* dropdown button to access Neo4j Browser or Neo4j
    Bloom developer tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个“打开方式”下拉按钮，用于访问Neo4j浏览器或Neo4j Bloom开发者工具。
- en: 8.2.2 Connecting to a Neo4j Aura cluster
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 连接到Neo4j Aura集群
- en: Now that we’ve provisioned our Neo4j Aura cluster, we’re ready to connect to
    it using the Neo4j JavaScript driver. First, let’s change the initial password
    for the neo4j database user. To do this, we’ll launch Neo4j Browser by clicking
    the *Query* button. This will open Neo4j Browser, which we’re familiar with from
    previous chapters. Refer back to chapter 3 for an overview of how to use Neo4j
    Browser. We’ll be prompted to sign in using the neo4j database user and initial
    password we were assigned.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Neo4j Aura集群，我们准备好使用Neo4j JavaScript驱动程序连接到它。首先，让我们更改neo4j数据库用户的初始密码。为此，我们将通过点击*查询*按钮启动Neo4j浏览器。这将打开我们熟悉的Neo4j浏览器。请参考第3章以了解如何使用Neo4j浏览器。我们将被提示使用分配给我们的neo4j数据库用户和初始密码进行登录。
- en: 'After signing in, let’s change our password for user neo4j. To do this, we’ll
    need to execute a Cypher command against the *system* database. Any administrative
    commands, like changing user passwords, need to be done against this system database.
    First, we tell Neo4j Browser to switch to the system database:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，让我们更改用户neo4j的密码。为此，我们需要在*系统*数据库上执行Cypher命令。任何管理命令，如更改用户密码，都需要针对此系统数据库执行。首先，我们告诉Neo4j浏览器切换到系统数据库：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we’ll use the ALTER CURRENT USER Cypher command to change the password
    of the default neo4j user:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用ALTER CURRENT USER Cypher命令更改默认neo4j用户的密码：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be sure to replace <OUR_RANDOM_INITIAL_PASSWORD_HERE> with the initial password
    and <NEW_SECRET_PASSWORD_HERE> with a new secure password. For the remaining examples,
    we’ll use the password *graphqlapi*, but using a stronger password is encouraged.
    To switch back to the default *neo4j* database, we can use the command :use neo4j.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将<OUR_RANDOM_INITIAL_PASSWORD_HERE>替换为初始密码，将<NEW_SECRET_PASSWORD_HERE>替换为新安全密码。对于剩余的示例，我们将使用密码*graphqlapi*，但鼓励使用更强的密码。要切换回默认的*neo4j*数据库，我们可以使用命令:use
    neo4j。
- en: Note Commands like :use are utility commands specific to Neo4j Browser and are
    not Cypher commands. For more information on using these commands in Neo4j Browser,
    run :help or :help commands.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：像:use这样的命令是针对Neo4j浏览器的特定实用命令，不是Cypher命令。有关在Neo4j浏览器中使用这些命令的更多信息，请运行:help或:help
    commands。
- en: Now that we’ve changed our database user’s password, let’s test whether we can
    connect to our Neo4j Aura cluster, using the Neo4j JavaScript driver. From the
    Aura dashboard, if we click on our database name, we can see code samples showing
    how to connect to our Neo4j Aura instance using different language drivers (see
    figure 8.5).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更改了数据库用户的密码，让我们测试是否可以使用Neo4j JavaScript驱动程序连接到我们的Neo4j Aura集群。从Aura仪表板，如果我们点击我们的数据库名称，我们可以看到代码示例，展示如何使用不同的语言驱动程序连接到我们的Neo4j
    Aura实例（见图8.5）。
- en: '![CH08_F05_Lyon](../../OEBPS/Images/CH08_F05_Lyon.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F05_Lyon](../../OEBPS/Images/CH08_F05_Lyon.png)'
- en: Figure 8.5 The Connect tab in Neo4j Aura, showing code examples in various languages
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 Neo4j Aura中的“连接”选项卡，显示各种语言的代码示例
- en: In listing 8.1, let’s adapt the JavaScript example to simply count the number
    of nodes in the database and return the results. We’ll create a new file in the
    API directory, called aura-connect.js, with our simplified JavaScript example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.1中，让我们将JavaScript示例调整为简单地计算数据库中的节点数并返回结果。我们将在API目录中创建一个新文件，命名为aura-connect.js，并包含我们的简化JavaScript示例。
- en: Note Note the neo4j+s:// URI scheme used in the code sample. Previously, we
    used bolt://, which indicated a connection to a specific Neo4j instance. With
    Neo4j Aura, we’ve deployed a cluster—a series of Neo4j instances that talk to
    each other to replicate and distribute data—so we use the neo4j scheme to tell
    the driver to route requests to different machines in the cluster, instead of
    to a single machine. The +s tells the driver we want to use a secure encrypted
    connection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码示例中使用的 neo4j+s:// URI方案。之前，我们使用 bolt://，它表示连接到特定的Neo4j实例。在Neo4j Aura中，我们已经部署了一个集群——一系列相互通信以复制和分发数据的Neo4j实例——因此我们使用neo4j方案来告诉驱动器将请求路由到集群中的不同机器，而不是单个机器。+s告诉驱动器我们想要使用安全的加密连接。
- en: 'Listing 8.1 aura-connect.js: Querying our Neo4j Aura instance'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 aura-connect.js：查询我们的Neo4j Aura实例
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code imports the Neo4j JavaScript driver, creating an instance of the
    driver with our Neo4j Aura credentials, executing a Cypher query in a read transaction,
    and then logging the results of the query to the console. If we run this file,
    we should verify that we are able to connect to our Neo4j Aura database and that
    the database is currently empty:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导入Neo4j JavaScript驱动程序，使用我们的Neo4j Aura凭据创建驱动程序的实例，在读取事务中执行Cypher查询，然后将查询结果记录到控制台。如果我们运行此文件，我们应该验证我们能够连接到我们的Neo4j
    Aura数据库，并且数据库目前为空：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our next step is to upload data from our local Neo4j instance that we’ve been
    using to develop our application to our Neo4j Aura database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是从我们用于开发应用程序的本地Neo4j实例上传数据到我们的Neo4j Aura数据库。
- en: 8.2.3 Uploading data to Neo4j Aura
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 将数据上传到Neo4j Aura
- en: Previously, we used the :play grandstack Neo4j Browser guide to load some initial
    data to import our business reviews data, but in this case, we may have added
    user information, new reviews, or updated businesses. Let’s discuss the process
    of dumping and loading data from a local Neo4j database into our new Neo4j Aura
    cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 :play grandstack Neo4j Browser指南来加载一些初始数据以导入我们的业务评论数据，但在此情况下，我们可能已添加用户信息、新的评论或更新了企业。让我们讨论将数据从本地Neo4j数据库导出到我们的新Neo4j
    Aura集群的过程。
- en: There are a few different ways to import data into Neo4j Aura, but we will use
    the push-to-cloud tool. If you select the *Import* tab in the Neo4j Aura dashboard,
    you’ll be presented with a wizard-like interface to walk you through the steps
    of uploading a local Neo4j database into your Neo4j Aura cloud database. We’ll
    go through those steps now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据导入Neo4j Aura有多种不同的方法，但我们将使用推送到云的工具。如果您在Neo4j Aura仪表板中选择**导入**选项卡，您将看到一个类似向导的界面，引导您完成将本地Neo4j数据库上传到您的Neo4j
    Aura云数据库的步骤。我们现在将介绍这些步骤。
- en: First, we want to make sure our local Neo4j database is in a stopped state.
    We can verify this in Neo4j Desktop and click the *Stop* button if it is not (see
    figure 8.6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想确保我们的本地Neo4j数据库处于停止状态。我们可以在Neo4j Desktop中验证这一点，如果它没有停止，则点击**停止**按钮（见图8.6）。
- en: '![CH08_F06_Lyon](../../OEBPS/Images/CH08_F06_Lyon.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F06_Lyon](../../OEBPS/Images/CH08_F06_Lyon.png)'
- en: Figure 8.6 Stopping the database and opening the management pane
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 停止数据库并打开管理面板
- en: Next, we’ll open a terminal in Neo4j Desktop that will allow us to run the neo4j-admin
    command for this specific Neo4j instance. The neo4j-admin command line tool has
    several useful features, such as a high-volume data import from CSV files, generating
    recommended memory configuration, and the push-to-cloud command, which we will
    use to upload this database to our Neo4j Aura instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在Neo4j Desktop中打开一个终端，这将允许我们运行针对此特定Neo4j实例的neo4j-admin命令。neo4j-admin命令行工具具有一些有用的功能，例如从CSV文件中导入大量数据、生成推荐的内存配置以及推送到云的命令，我们将使用该命令将此数据库上传到我们的Neo4j
    Aura实例。
- en: 'Select the drop-down arrow next to the *Open* button, and choose *Terminal*
    to open a new window with a command prompt. The working directory for this new
    command prompt is set to the directory where this particular Neo4j instance has
    been installed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在**打开**按钮旁边的下拉箭头处选择，然后选择**终端**以打开一个带有命令提示符的新窗口。此新命令提示符的工作目录设置为安装此特定Neo4j实例的目录：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we’re ready to use the push-to-cloud command to upload this database to
    Neo4j Aura. We’ll specify the Bolt URI of our Neo4j Aura instance as well as the
    --overwrite flag to indicate we want to replace any data we may have already created
    in the Neo4j Aura instance. We’ll be prompted for database user and password,
    and then our local database will be exported and uploaded to our Neo4j Aura database:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用推送到云的命令将此数据库上传到 Neo4j Aura。我们将指定我们的 Neo4j Aura 实例的 Bolt URI 以及 --overwrite
    标志，以指示我们想要替换在 Neo4j Aura 实例中可能已经创建的任何数据。我们将被提示输入数据库用户名和密码，然后我们的本地数据库将被导出并上传到我们的
    Neo4j Aura 数据库：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can verify the data was uploaded to our Neo4j Aura instance. If we
    run our aura-connect.js script again, we should see that we have a total of 36
    nodes in the database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以验证数据是否已上传到我们的 Neo4j Aura 实例。如果我们再次运行 aura-connect.js 脚本，我们应该看到数据库中总共有
    36 个节点：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 8.2.4 Exploring the graph with Neo4j Bloom
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 使用 Neo4j Bloom 探索图
- en: We can also visually inspect and explore the data we’ve just uploaded to Neo4j
    Aura. Let’s return to the Neo4j Aura dashboard, and this time we’ll open the database
    using *Neo4j Bloom.* Neo4j Bloom is a graph exploration application for visually
    interacting with Neo4j graphs and is included with Neo4j Aura. From the Neo4j
    Aura dashboard, click the *Explore* button. A new tab will open, and we’ll be
    prompted to log in, using our database username and password.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直观地检查和探索我们刚刚上传到 Neo4j Aura 的数据。让我们回到 Neo4j Aura 仪表板，这次我们将使用 *Neo4j Bloom*
    打开数据库。Neo4j Bloom 是一个用于与 Neo4j 图进行视觉交互的图探索应用程序，并包含在 Neo4j Aura 中。从 Neo4j Aura
    仪表板，点击 *探索* 按钮。将打开一个新标签页，我们将被提示使用数据库用户名和密码登录。
- en: Once we are signed in, Neo4j Bloom will connect to our Neo4j Aura instance and
    allow us to visually explore our graph data. First, we’ll need to configure a
    *perspective* (see figure 8.7). In Neo4j Bloom, a perspective defines the domain
    or view of the graph data that should be exposed and how that data should be styled.
    For our purposes, the default-generated perspective should be sufficient, so select
    *Create Perspective* to generate a perspective from the database, and then select
    the perspective to use it for visualization.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，Neo4j Bloom 将连接到我们的 Neo4j Aura 实例，并允许我们直观地探索我们的图数据。首先，我们需要配置一个 *视角*（见图
    8.7）。在 Neo4j Bloom 中，一个视角定义了应该公开的图数据域或视图以及如何样式化这些数据。就我们的目的而言，默认生成的视角应该足够，因此选择
    *创建视角* 从数据库生成一个视角，然后选择要用于可视化的视角。
- en: '![CH08_F07_Lyon](../../OEBPS/Images/CH08_F07_Lyon.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F07_Lyon](../../OEBPS/Images/CH08_F07_Lyon.png)'
- en: Figure 8.7 Creating a perspective in Neo4j Bloom
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 在 Neo4j Bloom 中创建视角
- en: 'Once we’ve created the perspective, we can begin our visual exploration of
    the graph. This main view in Neo4j Bloom is called the scene and serves as a kind
    of canvas for us to paint on with our graph data, based on the data we select.
    To bring data into the scene, we use natural language, like search terms in the
    search bar that will be translated to graph patterns (see figure 8.8). For example,
    if we begin to type User name: Will WROTE Review, we can see helpful autocomplete
    graph patterns start to be suggested for us. Selecting one of these patterns will
    execute the search and populate the scene with data matching the graph search
    pattern.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们创建了视角，我们就可以开始对图进行视觉探索。Neo4j Bloom 中的这个主要视图称为场景，它为我们提供了一个画布，我们可以根据选择的数据在上面绘制图数据。要将数据带入场景，我们使用自然语言，如搜索栏中的搜索词，这些词将被翻译成图模式（见图
    8.8）。例如，如果我们开始输入 User name: Will WROTE Review，我们可以看到开始为我们建议有用的自动完成图模式。选择这些模式之一将执行搜索，并将与图搜索模式匹配的数据填充到场景中。'
- en: '![CH08_F08_Lyon](../../OEBPS/Images/CH08_F08_Lyon.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F08_Lyon](../../OEBPS/Images/CH08_F08_Lyon.png)'
- en: Figure 8.8 Natural language search in Neo4j Bloom
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 Neo4j Bloom 中的自然语言搜索
- en: We said earlier that perspectives can configure how the visualization is styled
    (see figure 8.9). One such styling we can configure is the icons used to represent
    nodes in the visualization. By selecting a category in the legend panel, we can
    apply styling, such as the color, size, icon, or caption of the node.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，视角可以配置可视化样式（见图 8.9）。我们可以配置的一种样式是用于表示可视化中节点的图标。通过在图例面板中选择一个类别，我们可以应用样式，例如节点的颜色、大小、图标或标题。
- en: '![CH08_F09_Lyon](../../OEBPS/Images/CH08_F09_Lyon.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F09_Lyon](../../OEBPS/Images/CH08_F09_Lyon.png)'
- en: Figure 8.9 Configuring category icons in Neo4j Bloom
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 在 Neo4j Bloom 中配置类别图标
- en: The visualization is interactive and can be used to explore the graph or validate
    that the data uploaded is as we expected. Selecting nodes will allow us to view
    their properties (see figure 8.10). We can also right-click on nodes or relationships
    to further expand or filter the data shown in the scene.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是交互式的，可以用来探索图或验证上传的数据是否符合预期。选择节点将允许我们查看它们的属性（见图8.10）。我们还可以在节点或关系上右键单击以进一步扩展或过滤场景中显示的数据。
- en: '![CH08_F10_Lyon](../../OEBPS/Images/CH08_F10_Lyon.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F10_Lyon](../../OEBPS/Images/CH08_F10_Lyon.png)'
- en: Figure 8.10 View node details in Neo4j Bloom
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 在Neo4j Bloom中查看节点详情
- en: At this point, we’ve provisioned our Neo4j Aura cluster, changed the password,
    uploaded our data, explored the data, and verified and explored our graph in Neo4j
    Bloom. Now, let’s turn our attention to deploying our React application and GraphQL
    API using Netlify and AWS Lambda.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了Neo4j Aura集群，更改了密码，上传了数据，探索了数据，并在Neo4j Bloom中验证和探索了我们的图。现在，让我们将注意力转向使用Netlify和AWS
    Lambda部署我们的React应用程序和GraphQL API。
- en: 8.3 Deploying a React application with Netlify Build
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用Netlify Build部署React应用程序
- en: To deploy our React application, we’ll make use of Netlify. Netlify is a cloud
    platform focused on a smooth developer experience and workflow for building and
    deploying web applications. Netlify combines an automated build system, global
    content delivery network, serverless functions, edge handlers, and other features,
    all wrapped up in a platform focused on a smooth developer experience and workflow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署我们的React应用程序，我们将使用Netlify。Netlify是一个专注于构建和部署Web应用程序的流畅开发体验和工作流程的云平台。Netlify结合了自动构建系统、全球内容分发网络、无服务器函数、边缘处理器和其他功能，所有这些都被封装在一个专注于流畅开发体验和工作流程的平台中。
- en: Services with similar features include Vercel, DigitalOcean App Platform, Cloudflare
    Pages, and Azure Static Web Apps. Netlify also has a free tier, so we can deploy
    our application and try out the service without needing to input a credit card
    or incur any charges.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 具有类似功能的包括Vercel、DigitalOcean App Platform、Cloudflare Pages和Azure Static Web
    Apps。Netlify也提供免费层，因此我们可以部署我们的应用程序并尝试该服务，而无需输入信用卡或产生任何费用。
- en: Netlify also enables us to trigger builds and deployments via commits and pull
    requests to a Git version control system, like GitHub or GitLab. We’ll make use
    of GitHub in this section to trigger Netlify deployments and show a great feature
    of Netlify, called preview builds, that allows us to deploy and test the application
    from a pull request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify还允许我们通过提交和拉取请求到Git版本控制系统（如GitHub或GitLab）来触发构建和部署。在本节中，我们将使用GitHub来触发Netlify部署并展示Netlify的一个出色功能，称为预览构建，它允许我们从拉取请求中部署和测试应用程序。
- en: 8.3.1 Adding a site to Netlify
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 将网站添加到Netlify
- en: Let’s start by navigating to [netlify.com](https://www.netlify.com/) and clicking
    the *Sign up* button to create a free Netlify account. Since we’ll be taking advantage
    of the GitHub integration to deploy and update our application from GitHub, we
    can sign in to Netlify using our GitHub account, and our Netlify account will
    then be linked to GitHub (see figure 8.11). We can also sign in with another option,
    such as email and password, and choose to link our Netlify account to GitHub later
    on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导航到[netlify.com](https://www.netlify.com/)并点击*注册*按钮来创建一个免费的Netlify账户开始。由于我们将利用GitHub集成从GitHub部署和更新我们的应用程序，我们可以使用GitHub账户登录Netlify，然后我们的Netlify账户将与GitHub关联（见图8.11）。我们还可以选择其他登录方式，例如电子邮件和密码，并在稍后选择将Netlify账户链接到GitHub。
- en: '![CH08_F11_Lyon](../../OEBPS/Images/CH08_F11_Lyon.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F11_Lyon](../../OEBPS/Images/CH08_F11_Lyon.png)'
- en: Figure 8.11 Signing in to Netlify
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 登录Netlify
- en: Once we’ve signed in, we are presented with an overview of the web sites we’ve
    added to Netlify (see figure 8.12). Since we just created our account, this page
    is a bit sparse.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，我们将看到我们添加到Netlify的网站概览（见图8.12）。由于我们刚刚创建了账户，这个页面略显空旷。
- en: '![CH08_F12_Lyon](../../OEBPS/Images/CH08_F12_Lyon.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F12_Lyon](../../OEBPS/Images/CH08_F12_Lyon.png)'
- en: Figure 8.12 The Netlify dashboard
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 Netlify仪表板
- en: To add our first site to Netlify, let’s create a GitHub repository for our application
    so we can add it as a site to Netlify to start deployments. We’ll need to create
    a new GitHub repository for our application (see figure 8.13). To do that, first
    navigate to [github.com/new](https://github.com/new). We’ll need to choose a name
    for our repository—I chose grandstack-business-reviews. We can also choose to
    make our repository private if we don’t want to expose it to the world.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的第一个站点添加到 Netlify，让我们为我们的应用程序创建一个 GitHub 仓库，这样我们就可以将其作为站点添加到 Netlify 以开始部署。我们需要为我们的应用程序创建一个新的
    GitHub 仓库（见图 8.13）。为此，首先导航到 [github.com/new](https://github.com/new)。我们需要为我们的仓库选择一个名称——我选择了
    grandstack-business-reviews。我们还可以选择将我们的仓库设置为私有，如果我们不想将其暴露给公众。
- en: '![CH08_F13_Lyon](../../OEBPS/Images/CH08_F13_Lyon.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F13_Lyon](../../OEBPS/Images/CH08_F13_Lyon.png)'
- en: Figure 8.13 Creating a new GitHub repository
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 创建新的 GitHub 仓库
- en: We’ve now created an empty GitHub repository, and it’s time to add our business
    reviews application code to the repository. This screen shows the common terminal
    commands used to initialize a git repository, commit code, and push to GitHub
    (see figure 8.14). There is also a Desktop client that can be used with GitHub;
    however, we’ll use the command line to do this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已创建了一个空的 GitHub 仓库，现在是时候将我们的业务评审应用程序代码添加到仓库中。此屏幕显示了初始化 git 仓库、提交代码和推送到 GitHub
    所使用的常用终端命令（见图 8.14）。还有一个可以与 GitHub 一起使用的桌面客户端；然而，我们将使用命令行来完成这项工作。
- en: '![CH08_F14_Lyon](../../OEBPS/Images/CH08_F14_Lyon.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F14_Lyon](../../OEBPS/Images/CH08_F14_Lyon.png)'
- en: Figure 8.14 Instructions for pushing a local Git repository to GitHub
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 将本地 Git 仓库推送到 GitHub 的说明
- en: 'Let’s open a terminal and navigate to the web-react directory that holds the
    React application we’ve been building. First, we initialize a blank GitHub repository:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个终端，导航到包含我们一直在构建的 React 应用程序的 web-react 目录。首先，我们初始化一个空的 GitHub 仓库：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can view the status of our local working directory with the git status command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 git status 命令查看我们本地工作目录的状态：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we have haven’t made any commits to the repository yet, so let’s
    stage our code to be added. To do this, we’ll use the git add command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还没有向仓库提交任何内容，所以让我们暂存要添加的代码。为此，我们将使用 git add 命令：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The -A flag indicates we want to stage all files in the project to be added.
    We typically don’t want to add *all* files to the repository; things like the
    node_modules directory and secrets shouldn’t be checked into version control.
    The create-react-app tool we used earlier to create the skeleton of our React
    application also created a .gitignore file that includes rules for files to be
    excluded from git. Thanks to this file, we can safely make use of the -A flag
    when staging files for a commit. Now, as we run git status again, we’ll see all
    the files to be added to the repository in our commit:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: -A 标志表示我们想要将项目中的所有文件暂存以添加。我们通常不想将 *所有* 文件添加到仓库中；像 node_modules 目录和机密信息这样的东西不应该被提交到版本控制中。我们之前用来创建
    React 应用程序骨架的 create-react-app 工具也创建了一个 .gitignore 文件，其中包含要排除的文件的规则。多亏了这个文件，我们可以在暂存文件进行提交时安全地使用
    -A 标志。现在，当我们再次运行 git status 时，我们将看到要添加到我们提交中的所有文件：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s make our commit with the git commit command. Every commit also includes
    a message that indicates the reason or functionality introduced in the commit.
    This message can be added using the -m flag, or we can omit that flag and then
    be prompted for a commit message:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 git commit 命令进行提交。每个提交还包括一个消息，表明提交中引入的原因或功能。此消息可以使用 -m 标志添加，或者我们可以省略该标志，然后被提示输入提交消息：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we connect our local Git repository with the remote GitHub repository
    we created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将我们的本地 Git 仓库与创建的远程 GitHub 仓库连接起来：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And finally, we push our local commit up to the remote GitHub repository with
    the git push command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 git push 命令将我们的本地提交推送到远程 GitHub 仓库：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we refresh the GitHub web page for our repository, we’ll now see the code
    we’ve committed and a history of the commits (see figure 8.15).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新我们的 GitHub 仓库网页，现在我们将看到我们已提交的代码和提交历史（见图 8.15）。
- en: '![CH08_F15_Lyon](../../OEBPS/Images/CH08_F15_Lyon.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F15_Lyon](../../OEBPS/Images/CH08_F15_Lyon.png)'
- en: Figure 8.15 Viewing our new repository on GitHub
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 在 GitHub 上查看我们的新仓库
- en: Now, we’re ready to deploy our React application with Netlify. Return to the
    Netlify dashboard, and click on *Add site from Git*. We’ll be prompted to select
    the Git provider we want to connect to and then the repository we want to add.
    Select GitHub, and choose the repository we just created and pushed our code to
    (see figure 8.16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用 Netlify 部署我们的 React 应用程序。返回 Netlify 仪表板，点击 *从 Git 添加网站*。我们将被提示选择要连接的
    Git 提供商以及要添加的存储库。选择 GitHub，并选择我们刚刚创建并推送代码的存储库（见图 8.16）。
- en: '![CH08_F16_Lyon](../../OEBPS/Images/CH08_F16_Lyon.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F16_Lyon](../../OEBPS/Images/CH08_F16_Lyon.png)'
- en: Figure 8.16 Adding a new site in Netlify
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 在 Netlify 中添加新网站
- en: Netlify will inspect the code to determine that this is a React application
    built using the command npm run build, and the content should be served from the
    /build directory. We shouldn’t need to make any changes here, as the defaults
    will typically be sufficient to build and deploy our React application. We can
    change these build settings later if needed (see figure 8.17).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 将检查代码以确定这是一个使用 npm run build 命令构建的 React 应用程序，内容应从 /build 目录提供。我们在这里通常不需要做任何更改，因为默认设置通常足以构建和部署我们的
    React 应用程序。如果需要，我们可以在稍后更改这些构建设置（见图 8.17）。
- en: '![CH08_F17_Lyon](../../OEBPS/Images/CH08_F17_Lyon.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F17_Lyon](../../OEBPS/Images/CH08_F17_Lyon.png)'
- en: Figure 8.17 Configuring our new Netlify site
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 配置我们的新 Netlify 网站
- en: Netlify will now pull down our code from GitHub to build and deploy the site.
    We can view the build logs from the dashboard as this happens. Each site in Netlify
    is assigned a URL and SSL certificate, so we can immediately preview our application
    once it’s been built and deployed without needing to add a custom domain (see
    figure 8.18).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 现在将从 GitHub 拉取我们的代码以构建和部署网站。我们可以在构建过程中从仪表板查看构建日志。Netlify 中的每个网站都分配了一个
    URL 和 SSL 证书，因此一旦构建和部署完成，我们就可以立即预览我们的应用程序，而无需添加自定义域名（见图 8.18）。
- en: '![CH08_F18_Lyon](../../OEBPS/Images/CH08_F18_Lyon.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F18_Lyon](../../OEBPS/Images/CH08_F18_Lyon.png)'
- en: Figure 8.18 Configuring the deploy settings in Netlify
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 在 Netlify 中配置部署设置
- en: Once the build is finished, we can navigate to our application in a web browser
    (see figure 8.19). In this case, the URL is [https://hungry-thompson-86fbf3.netlify.app/](https://hungry-thompson-86fbf3.netlify.app/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，我们就可以在网页浏览器中导航到我们的应用程序（见图 8.19）。在这种情况下，URL 是 [https://hungry-thompson-86fbf3.netlify.app/](https://hungry-thompson-86fbf3.netlify.app/)。
- en: '![CH08_F19_Lyon](../../OEBPS/Images/CH08_F19_Lyon.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F19_Lyon](../../OEBPS/Images/CH08_F19_Lyon.png)'
- en: Figure 8.19 A Netlify site deploy in progress
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 Netlify 网站部署进行中
- en: 'But we have a problem: the GraphQL API is pointing to http://localhost:4000,
    our local machine, which means anyone else loading this application won’t be able
    to connect to the GraphQL API and view these results. We can verify this by opening
    the developer tools in our web browser and inspecting the network requests. We’ll
    deploy the GraphQL API application in the next section, but let’s explore a few
    features of Netlify first (see figure 8.20).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们有一个问题：GraphQL API 指向 http://localhost:4000，即我们的本地机器，这意味着加载此应用程序的其他人将无法连接到
    GraphQL API 并查看这些结果。我们可以通过在网页浏览器中打开开发者工具并检查网络请求来验证这一点。我们将在下一节部署 GraphQL API 应用程序，但让我们先探索
    Netlify 的几个功能（见图 8.20）。
- en: '![CH08_F20_Lyon](../../OEBPS/Images/CH08_F20_Lyon.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F20_Lyon](../../OEBPS/Images/CH08_F20_Lyon.png)'
- en: Figure 8.20 Our newly deployed application
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 我们新部署的应用程序
- en: 8.3.2 Setting environment variables for Netlify builds
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 为 Netlify 构建设置环境变量
- en: If we take a look at src/index.js, where we create the Apollo Client instance,
    to connect to our GraphQL API, we’ll see that we’ve left the URI for the GraphQL
    API hardcoded as http://localhost:4000, as shown in the next listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看创建 Apollo 客户端实例以连接到我们的 GraphQL API 的 src/index.js，我们会看到我们已将 GraphQL API
    的 URI 固定编码为 http://localhost:4000，如以下列表所示。
- en: 'Listing 8.2 src/index.js: Using an Apollo Link to connect to our GraphQL API'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 src/index.js：使用 Apollo Link 连接到我们的 GraphQL API
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is fine for local development and testing, but now we want to use the same
    code for local development and our deployed application. To allow for using a
    local GraphQL URI during development, but to connect to a deployed GraphQL API
    in our deployed application, we’ll set an environment variable to be read at build
    time for the GraphQL URI. We’ll determine this value depending on the environment
    being used—for local development, we’ll leave the GraphQL URI as http://localhost:4000,
    but we’ll configure a different value for our Netlify builds.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于本地开发和测试来说是不错的，但现在我们希望使用相同的代码进行本地开发和我们的部署应用程序。为了允许在开发期间使用本地 GraphQL URI，但在我们的部署应用程序中连接到部署的
    GraphQL API，我们将设置一个在构建时读取 GraphQL URI 的环境变量。我们将根据使用的环境确定此值——对于本地开发，我们将保持 GraphQL
    URI 为 http://localhost:4000，但我们将为我们的 Netlify 构建配置不同的值。
- en: Let’s create a .env file to store local development environment variables. One
    convenient feature of Create React App is that any values specified in .env will
    be set as environment variables, and any variables that begin with REACT_APP will
    be replaced in the client React application during the build. Let’s set the local
    value we want to use for development for the GraphQL API in this .env file, as
    shown next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 .env 文件来存储本地开发环境变量。Create React App 的一个便利功能是，任何在 .env 中指定的值都将被设置为环境变量，并且任何以
    REACT_APP 开头的变量将在构建期间在客户端 React 应用程序中替换。让我们在下面的 .env 文件中设置我们想要用于开发的 GraphQL API
    的本地值。
- en: 'Listing 8.3 .env: Setting environment variables for our React application'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 .env：为我们的 React 应用程序设置环境变量
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’ll update our code in the next listing to read from these environment variables
    when setting the URI of our GraphQL API and to specify our Auth0 domain, client
    ID, and audience values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新我们的代码以从这些环境变量中读取，以设置我们的 GraphQL API 的 URI 并指定我们的 Auth0 域、客户端 ID 和受众值。
- en: 'Listing 8.4 src/index.js: Using environment variables'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.4 src/index.js：使用环境变量
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For local development, we want to develop using the local GraphQL API URI, but
    in the deployed application, we want the React application to connect to the deployed
    GraphQL API. To enable this, we’ll now set the REACT_APP_GRAPHQL_URI environment
    variable in the Netlify building settings for our site (see figure 8.21). Choose
    *Site Settings* in the Netlify dashboard for our site, and then choose *Build
    & deploy* in the left-side navigation. We’ll create a new environment variable
    called REACT_APP_GRAPHQL_URI with the value /graphql.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发，我们希望使用本地的 GraphQL API URI 进行开发，但在部署的应用程序中，我们希望 React 应用程序连接到部署的 GraphQL
    API。为了启用此功能，我们现在将在我们的网站 Netlify 构建设置中设置 REACT_APP_GRAPHQL_URI 环境变量（见图 8.21）。在我们的网站
    Netlify 控制台中，选择 *站点设置*，然后在左侧导航中选择 *构建和部署*。我们将创建一个名为 REACT_APP_GRAPHQL_URI 的新环境变量，其值为
    /graphql。
- en: '![CH08_F21_Lyon](../../OEBPS/Images/CH08_F21_Lyon.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F21_Lyon](../../OEBPS/Images/CH08_F21_Lyon.png)'
- en: Figure 8.21 Setting Netlify environment variables
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 设置 Netlify 环境变量
- en: This means that our deployed application will try to connect to a GraphQL API
    at /graphql on the same domain. We haven’t deployed the GraphQL API here yet,
    so our application will return an error for now until we add the GraphQL API.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的部署应用程序将尝试连接到同一域上的 /graphql 上的 GraphQL API。我们还没有在这里部署 GraphQL API，所以我们的应用程序现在将返回错误，直到我们添加
    GraphQL API。
- en: 8.3.3 Netlify deploy previews
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 Netlify 部署预览
- en: A convenient feature of services like Netlify is the deploy preview. A *deploy
    preview* is a build triggered by a change to the code (often from a pull request)
    that is deployed to a temporary URL, different from the main application. This
    build has all the functionality of the main application and can be shared with
    teammates and other stakeholders to review before the pull request is committed
    and the change is reflected in the main application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 等服务的一个便利功能是部署预览。*部署预览* 是由代码更改（通常来自拉取请求）触发的构建，部署到一个临时 URL，与主应用程序不同。这个构建具有主应用程序的所有功能，可以在拉取请求提交并更改反映在主应用程序之前与团队成员和其他利益相关者共享以进行审查。
- en: 'Let’s see how this works by creating a pull request and deploying a preview
    updating our React application to read from the REACT_APP_GRAPHQL_URI environment
    variable. If we run the command git status, we’ll see that we’ve made a change
    to src/index.js:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个拉取请求并部署一个更新我们的 React 应用程序以从 REACT_APP_GRAPHQL_URI 环境变量中读取的预览来查看这是如何工作的。如果我们运行
    git status 命令，我们会看到我们对 src/index.js 进行了更改：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s switch to a new Git branch, called env-var-graphql-uri. We’ll commit
    our change to this new branch:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到一个新的 Git 分支，称为 env-var-graphql-uri。我们将把我们的更改提交到这个新分支：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let’s add our change to index.js in a commit. Since we’ve switched our
    working directory to a new Git branch, this commit will be made to the env-var-graphql-uri
    branch, not the main branch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的更改添加到 index.js 中进行提交。由于我们已经将我们的工作目录切换到了一个新的 Git 分支，这个提交将是对 env-var-graphql-uri
    分支的提交，而不是主分支：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we push this new branch to GitHub. Since we’re pushing a new branch to
    our remote repository, GitHub helpfully tells us that we can create a pull request
    from this new branch:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将这个新分支推送到 GitHub。由于我们正在将新分支推送到我们的远程仓库，GitHub 会友好地告诉我们，我们可以从这个新分支创建一个拉取请求：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A pull request is a way to request a change from another branch or fork of the
    repository to be merged into the main branch. Let’s create a pull request that
    requests merging the new branch, env-var-graphql-uri, into the main branch (see
    figure 8.22).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求是从仓库的另一个分支或分叉请求更改以合并到主分支的一种方式。让我们创建一个拉取请求，请求将新的分支，env-var-graphql-uri，合并到主分支（见图
    8.22）。
- en: '![CH08_F22_Lyon](../../OEBPS/Images/CH08_F22_Lyon.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F22_Lyon](../../OEBPS/Images/CH08_F22_Lyon.png)'
- en: Figure 8.22 Creating a pull request in GitHub
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 在 GitHub 中创建拉取请求
- en: Since we’ve connected Netlify to this GitHub repository, Netlify will immediately
    start a deploy preview build based on the changes in this pull request. We can
    see the status of this build in the *Checks* section of the pull request page
    on GitHub. Once the build is complete, we can visit this deploy preview to see
    the changes reflected in a live deployment (see figure 8.23). We can also share
    this temporary URL with others to review the changes to the site.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 Netlify 连接到这个 GitHub 仓库，Netlify 将立即基于这个拉取请求中的更改启动部署预览构建。我们可以在 GitHub
    上拉取请求页面的 *检查* 部分查看此构建的状态。一旦构建完成，我们可以访问这个部署预览来查看反映在实时部署中的更改（见图 8.23）。我们还可以将这个临时
    URL 分享给其他人以审查网站更改。
- en: '![CH08_F23_Lyon](../../OEBPS/Images/CH08_F23_Lyon.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F23_Lyon](../../OEBPS/Images/CH08_F23_Lyon.png)'
- en: Figure 8.23 Triggering a Netlify deploy preview from a pull request
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 从拉取请求触发 Netlify 部署预览
- en: Once we’re satisfied with the changes, we’ll merge the pull request. We can
    do this on GitHub by clicking the *Merge pull request* button. This will merge
    the changes from the env-var-graphql-uri branch into the main branch. This merge
    will then trigger a build and deployment on Netify, which will then replace the
    main version of our application (see figure 8.24).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对这些更改感到满意，我们就会合并拉取请求。我们可以在GitHub上通过点击 *合并拉取请求* 按钮来完成此操作。这将把从 env-var-graphql-uri
    分支到主分支的更改合并。然后，这次合并将在 Netify 上触发构建和部署，这将替换我们应用程序的主版本（见图 8.24）。
- en: '![CH08_F24_Lyon](../../OEBPS/Images/CH08_F24_Lyon.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F24_Lyon](../../OEBPS/Images/CH08_F24_Lyon.png)'
- en: Figure 8.24 Viewing the status of our Netlify builds
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 查看我们的 Netlify 构建状态
- en: Now that we’ve deployed the React application, it’s time to deploy our GraphQL
    API. To do this, we’ll convert our GraphQL API into a serverless function so it
    can be deployed on the AWS Lambda service. We’ll take advantage of the Netlify
    Functions feature to enable this for us.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了 React 应用程序，是时候部署我们的 GraphQL API 了。为此，我们将我们的 GraphQL API 转换为无服务器函数，以便可以在
    AWS Lambda 服务上部署。我们将利用 Netlify Functions 功能来实现这一点。
- en: 8.4 Serverless GraphQL with AWS Lambda and Netlify Functions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用 AWS Lambda 和 Netlify Functions 的无服务器 GraphQL
- en: AWS Lambda is an FaaS compute platform that allows us to run code on demand
    without provisioning or managing servers. Functions are invoked in response to
    events, such as an HTTP request. When combined with AWS’s API Gateway service,
    Lambda functions can be used to implement API endpoints and applications, such
    as a GraphQL API. AWS Lambda supports Node.js, Python, Java, Go, Ruby, Swift,
    and C# and can include packaged dependencies. Unlike other cloud services that
    incur costs metered by the hour, AWS Lambda is priced based on the number of requests,
    and the duration of those requests is measured in increments of 1 millisecond.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda 是一个 FaaS 计算平台，允许我们按需运行代码，而无需配置或管理服务器。函数在响应事件时被调用，例如 HTTP 请求。当与 AWS
    的 API Gateway 服务结合使用时，Lambda 函数可以用来实现 API 端点和应用程序，例如 GraphQL API。AWS Lambda 支持
    Node.js、Python、Java、Go、Ruby、Swift 和 C#，并且可以包含打包的依赖项。与其他按小时计费的成本云服务不同，AWS Lambda
    的定价基于请求数量，以及这些请求的持续时间以 1 毫秒为增量进行测量。
- en: The Netlify Functions service allows us to deploy Lambda functions directly
    from the Netlify function without the need for creating an AWS account. Netlify
    handles the build and deployment of Lambda functions using the same Git version
    control features, such as deploy previews, which means we can manage the code
    for our Lambda functions alongside the rest of our site. Currently, Netlify can
    deploy Lambda functions for Node.js and Go.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 函数服务允许我们直接从 Netlify 函数部署 Lambda 函数，无需创建 AWS 账户。Netlify 使用与 Git 版本控制相同的特性（如部署预览）来处理
    Lambda 函数的构建和部署，这意味着我们可以将 Lambda 函数的代码与网站的其他部分一起管理。目前，Netlify 可以部署 Node.js 和 Go
    的 Lambda 函数。
- en: So far, we’ve built our GraphQL API application as a Node.js Express server
    using Apollo Server. In this section, we will convert our GraphQL API to a Lambda
    function, using a Lambda-specific version of Apollo Server, and deploy alongside
    our Netlify site using the Netlify Functions feature.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将我们的 GraphQL API 应用程序作为 Node.js Express 服务器使用 Apollo Server 构建。在本节中，我们将使用特定于
    Lambda 的 Apollo Server 版本将我们的 GraphQL API 转换为 Lambda 函数，并使用 Netlify 函数功能与我们的 Netlify
    网站一起部署。
- en: 8.4.1 Serving a GraphQL API as a Lambda function
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 将 GraphQL API 作为 Lambda 函数提供服务
- en: 'Since our Lambda GraphQL API will be deployed via Netlify as part of our Netlify
    site, we’ll place the code and dependencies in our existing project. Let’s install
    the dependencies needed:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 Lambda GraphQL API 将作为我们 Netlify 网站的一部分通过 Netlify 部署，我们将代码和依赖项放在现有的项目中。让我们安装所需的依赖项：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we install apollo-server-lambda, a special version of Apollo Server
    that will allow us to structure our GraphQL API as a Lambda function. We also
    install the Neo4j JavaScript driver, the Neo4j GraphQL integration library, and
    libraries necessary for working with JWTs that we saw in the previous chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们安装了 apollo-server-lambda，这是 Apollo Server 的一个特殊版本，它将允许我们将我们的 GraphQL API
    结构化为 Lambda 函数。我们还安装了 Neo4j JavaScript 驱动程序、Neo4j GraphQL 集成库以及我们在上一章中看到的用于处理
    JWT 的库。
- en: Let’s create a new file, src/graphql.js, in the same directory where our React
    application is located. Later, we’ll check this file into version control and
    push it up to GitHub, triggering a Netlify build and deployment. We’ll use apollo-server-lambda
    to create a simple GraphQL API with a single query field, greetings, that returns
    a greeting message, as the following listing shows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在与我们的 React 应用程序位于同一目录下创建一个新文件，src/graphql.js。稍后，我们将把这个文件提交到版本控制并推送到 GitHub，触发
    Netlify 构建 和部署。我们将使用 apollo-server-lambda 创建一个简单的 GraphQL API，它有一个名为 greetings
    的查询字段，返回一个问候消息，如下所示。
- en: 'Listing 8.5 src/graphql.js: A simple GraphQL API using AWS Lambda'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 src/graphql.js：使用 AWS Lambda 的简单 GraphQL API
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Note that we are importing the apollo-server-lambda flavor of Apollo Server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意，我们正在导入 Apollo Server 的 apollo-server-lambda 版本。
- en: ❷ Since we are creating an AWS Lambda function, we need to export a handler
    function that wraps our Apollo Server instance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 由于我们正在创建 AWS Lambda 函数，我们需要导出一个包装我们的 Apollo Server 实例的处理函数。
- en: Next, we need to configure our Netlify site so it knows where we’ve created
    our new Lambda function and that we want to serve the GraphQL API at the /graphql
    endpoint of our site. To do this, we’ll create a netlify.toml file in the root
    of our project, as shown in the following listing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的 Netlify 网站以便它知道我们创建的新 Lambda 函数的位置，并且我们希望在网站的 /graphql 端点处提供 GraphQL
    API。为此，我们将在项目的根目录中创建一个 netlify.toml 文件，如下所示。
- en: 'Listing 8.6 netlify.toml: Configuring the Netlify build'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 netlify.toml：配置 Netlify 构建
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By default, our Netlify Functions are exposed at /.netlify/functions/, followed
    by the filename of the function. We create a redirect, so our GraphQL API can
    be accessed at /graphql.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的 Netlify 函数在 /.netlify/functions/ 下暴露，后面跟着函数的文件名。我们创建了一个重定向，因此我们的 GraphQL
    API 可以在 /graphql 下访问。
- en: 8.4.2 The Netlify dev CLI
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 Netlify 开发 CLI
- en: 'So far, we’ve treated Netlify as a deployment service for our React application.
    If we wanted to build and serve the React application locally, then when running
    npm run start, we used the react-scripts tool without getting Netlify involved.
    Now that we’re adding Lambda functions, we’ll need to do a bit more to test out
    our application locally. We’ll install the Netlify command line tool to build
    and run our GraphQL Lambda function and React application locally using Netlify
    dev:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将 Netlify 视为我们 React 应用程序的部署服务。如果我们想在本地构建和提供 React 应用程序，那么在运行 npm run
    start 时，我们使用了 react-scripts 工具，而没有涉及 Netlify。现在，我们添加 Lambda 函数后，我们需要做更多的工作来在本地测试我们的应用程序。我们将安装
    Netlify 命令行工具，使用 Netlify dev 构建和运行我们的 GraphQL Lambda 函数和 React 应用程序：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we’ve installed the Netlify CLI, we can use the dev command to start
    our site locally. This will build and serve our React application and Lambda function
    locally without triggering a deployment:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Netlify CLI，我们可以使用dev命令在本地启动我们的网站。这将本地构建和提供我们的React应用程序和Lambda函数，而不会触发部署：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After running netlify dev, we can open a web browser and navigate to http://localhost:8888/graphql.
    We should see Apollo Studio, where we can run a GraphQL query against our Lambda
    GraphQL API, as shown in the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行netlify dev后，我们可以打开一个网络浏览器并导航到http://localhost:8888/graphql。我们应该看到Apollo Studio，在那里我们可以运行针对我们的Lambda
    GraphQL API的GraphQL查询，如下所示。
- en: Listing 8.7 Querying our simple GraphQL API
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 查询我们的简单GraphQL API
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of this query will show the greeting message we defined in the resolver:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果将显示我们在解析器中定义的问候消息：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, this is just a simple Hello World GraphQL API, so let’s bring over
    the rest of our GraphQL API application for the business reviews application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的Hello World GraphQL API，所以让我们将业务评论应用程序的其余GraphQL API应用程序迁移过来。
- en: 8.4.3 Converting our GraphQL API to a Netlify function
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 将我们的GraphQL API转换为Netlify函数
- en: As shown in listing 8.8, to convert our existing GraphQL API to make use of
    AWS Lambda and apollo-server-lambda, we need to change a few lines. The most significant
    changes are the use of the apollo-server-lambda package, instead of apollo-server-express,
    and exporting a handler function for our AWS Lambda. Otherwise, this will look
    similar to the GraphQL API code we’ve been building up through chapter 7.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表8.8所示，要将现有的GraphQL API转换为使用AWS Lambda和apollo-server-lambda，我们需要更改几行。最显著的变化是使用apollo-server-lambda包，而不是apollo-server-express，并为我们的AWS
    Lambda导出处理函数。否则，这看起来将与我们在第7章中构建的GraphQL API代码相似。
- en: 'Listing 8.8 src/graphql.js: Converting our GraphQL API to an AWS Lambda function'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8 src/graphql.js：将我们的GraphQL API转换为AWS Lambda函数
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Using the apollo-server-lambda flavor of Apollo Server, instead of apollo-server
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用Apollo Server的apollo-server-lambda版本，而不是apollo-server
- en: ❷ We use event here because the request signature for AWS Lambda is slightly
    different than Express.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们在这里使用事件，因为AWS Lambda的请求签名与Express略有不同。
- en: ❸ Exporting a handler function for our AWS Lambda function
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为我们的AWS Lambda函数导出处理函数
- en: We can now commit our changes to this file and push to GitHub to deploy. Deploying
    our application is almost complete. In the next section, we add a custom domain
    and assign it to our site in Netlify.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将更改提交到这个文件并推送到GitHub以部署。部署我们的应用程序几乎完成。在下一节中，我们将添加一个自定义域名并将其分配给Netlify中的网站。
- en: 8.4.4 Adding a custom domain in Netlify
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.4 在Netlify中添加自定义域名
- en: So far, our application has been running on the [https://hungry-thompson-86fbf3.netlify.app/](https://hungry-thompson-86fbf3.netlify.app/)
    subdomain assigned by Netlify. Let’s set up a custom domain that better aligns
    with the branding we’d like for the site. In Netlify, select *Domains* from the
    top navbar. From here, we can add custom domains and assign them to our sites
    in Netlify (see figure 8.25).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序一直在Netlify分配的[https://hungry-thompson-86fbf3.netlify.app/](https://hungry-thompson-86fbf3.netlify.app/)子域名上运行。让我们设置一个与网站品牌更匹配的自定义域名。在Netlify中，从顶部导航栏选择*域名*。从这里，我们可以添加自定义域名并将它们分配给Netlify中的网站（见图8.25）。
- en: '![CH08_F25_Lyon](../../OEBPS/Images/CH08_F25_Lyon.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F25_Lyon](../../OEBPS/Images/CH08_F25_Lyon.png)'
- en: Figure 8.25 Adding a custom domain to Netlify
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 在Netlify中添加自定义域名
- en: We can purchase domain names directly from Netlify or add domains purchased
    through other registrars. In this case, I want to add a domain I’ve purchased
    elsewhere, so I’ll point the domain at Netlify’s nameservers, allowing Netlify
    to manage the domain and DNS records for the domain (see figure 8.26).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从Netlify购买域名，或者添加通过其他注册商购买的域名。在这种情况下，我想添加我在其他地方购买的域名，所以我将域名指向Netlify的名称服务器，允许Netlify管理域和域的DNS记录（见图8.26）。
- en: '![CH08_F26_Lyon](../../OEBPS/Images/CH08_F26_Lyon.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F26_Lyon](../../OEBPS/Images/CH08_F26_Lyon.png)'
- en: Figure 8.26 Pointing our domain at the Netlify nameservers
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 将我们的域名指向Netlify名称服务器
- en: Finally, we’ll need to update the Auth0 application settings so the authentication
    functionality provided by Auth0 works, using the new domain. We’ll update the
    *Allow Callback URLs* and *Allowed Logout URLs* in Auth0, adding the default localhost
    URLs as well as our Netlify site URL and our custom domain (see figure 8.27).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新Auth0应用程序设置，以便使用新域名提供的Auth0认证功能。我们将在Auth0中更新*允许回调URL*和*允许注销URL*，添加默认的localhost
    URL以及我们的Netlify网站URL和我们的自定义域名（见图8.27）。
- en: '![CH08_F27_Lyon](../../OEBPS/Images/CH08_F27_Lyon.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F27_Lyon](../../OEBPS/Images/CH08_F27_Lyon.png)'
- en: Figure 8.27 Updating the allowed callback URLs in Auth0
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 在 Auth0 中更新允许的回调 URL
- en: And with that, our application is now deployed and ready to use on our custom
    domain (see figure 8.28).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的应用程序现在已部署并准备好在我们的自定义域名上使用（见图 8.28）。
- en: '![CH08_F28_Lyon](../../OEBPS/Images/CH08_F28_Lyon.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F28_Lyon](../../OEBPS/Images/CH08_F28_Lyon.png)'
- en: Figure 8.28 Our deployed full stack GraphQL application after signing in
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 登录后我们的部署的完整堆栈 GraphQL 应用程序
- en: 8.5 Our deployment approach
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 我们的部署方法
- en: In this chapter, we explored an approach to deploying our full stack GraphQL
    application that embraced taking advantage of managed services, specifically Neo4j
    Aura, Netlify, and AWS Lambda (see figure 8.29). At the beginning of this chapter,
    we discussed some of the advantages and disadvantages of managed services in general.
    Let’s review the services from the developer’s perspective.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一种部署我们的全栈 GraphQL 应用程序的方法，该方法采用了利用托管服务（特别是 Neo4j Aura、Netlify 和 AWS
    Lambda）的优势（见图 8.29）。在本章开头，我们讨论了一些托管服务的一般优缺点。让我们从开发者的角度回顾一下这些服务。
- en: '![CH08_F29_Lyon](../../OEBPS/Images/CH08_F29_Lyon.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F29_Lyon](../../OEBPS/Images/CH08_F29_Lyon.png)'
- en: Figure 8.29 A full stack GraphQL deployment, from the developer’s perspective
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 从开发者视角看完整的 GraphQL 部署
- en: Netlify allows for automated builds and deployment of our React application
    to the Netlify global content delivery network, ensuring our frontend application
    is accessible to anyone in the world without unnecessary network latency. Converting
    our GraphQL API to an AWS Lambda function and leveraging Netlify Functions means
    we can integrate the API application into the same application codebase. By integrating
    with GitHub, our workflow for development and deployment is improved, allowing
    us to create preview deployments from pull requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify 允许自动构建和部署我们的 React 应用程序到 Netlify 全球内容分发网络，确保我们的前端应用程序对世界上任何人都可访问，而无需不必要的网络延迟。将我们的
    GraphQL API 转换为 AWS Lambda 函数并利用 Netlify Functions 意味着我们能够将 API 应用程序集成到相同的代码库中。通过集成
    GitHub，我们的开发和部署工作流程得到改善，使我们能够从拉取请求中创建预览部署。
- en: With the Neo4j Aura database as a service, we are able to take advantage of
    developer tooling like Neo4j Desktop and Neo4j Browser for development and not
    have to concern ourselves with maintaining and operating a Neo4j cluster in the
    cloud. Now that our application has been deployed, in the next chapter, we move
    away from our business reviews application and focus on more-advanced GraphQL
    features, such as abstract types, cursor-based pagination and the Relay connection
    model, and working with relationship properties in the graph.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 Neo4j Aura 数据库作为服务，我们能够利用 Neo4j Desktop 和 Neo4j Browser 等开发者工具进行开发，而不必担心在云中维护和操作
    Neo4j 集群。现在我们的应用程序已经部署，在下一章中，我们将从业务审查应用程序转向更高级的 GraphQL 功能，例如抽象类型、基于游标的分页和 Relay
    连接模型，以及在图中的关系属性操作。
- en: 8.6 Exercises
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 练习
- en: 'Use Neo4j Bloom to find the user who has reviewed businesses belonging to the
    greatest number of categories. What are the categories of the businesses this
    user has reviewed? Hint: creating a Neo4j Bloom search phrase might be helpful
    with this exercise. Consult the documentation at [http://mng.bz/XZR6](http://mng.bz/XZR6).'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Neo4j Bloom 查找已评论属于最多类别的业务用户。这位用户评论了哪些类别？提示：创建一个 Neo4j Bloom 搜索短语可能有助于这个练习。请参阅[http://mng.bz/XZR6](http://mng.bz/XZR6)上的文档。
- en: Create a new pull request that updates the business review application to always
    order the results by business name. Use Netlify’s deploy feature to review this
    update before merging the pull request and updating the application.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的拉取请求，更新业务审查应用程序，使其始终按业务名称排序结果。使用 Netlify 的部署功能在合并拉取请求并更新应用程序之前审查此更新。
- en: Create a new Netlify Function that uses the Neo4j JavaScript driver to query
    our Neo4j Aura cluster and return a list of the most recent reviews. Run it locally
    using the netlify dev command before deploying. Use the netlify.toml configuration
    to redirect /reviews to this function.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Netlify Function，使用 Neo4j JavaScript 驱动程序查询我们的 Neo4j Aura 集群，并返回最新评论的列表。在部署之前，使用
    netlify dev 命令在本地运行它。使用 netlify.toml 配置将 /reviews 重定向到该函数。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Leveraging managed cloud services can smooth the developer experience for deploying
    and maintaining web applications and address scale, operations, and pricing that
    can be appealing for full stack developers who may be responsible for all components
    of the application.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用托管云服务可以平滑开发者在部署和维护Web应用程序时的体验，并解决全栈开发者可能负责应用程序所有组件的扩展、运营和定价问题，这可能对全栈开发者具有吸引力。
- en: Neo4j Aura is a managed cloud database service that provides Neo4j clusters
    that can be provisioned with a single click. These database instances can be scaled
    up and down as needed and remove the need for maintenance or operations of Neo4j.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Neo4j Aura是一种托管云数据库服务，提供一键配置的Neo4j集群。这些数据库实例可以根据需要扩展或缩减，并消除对Neo4j维护或运营的需求。
- en: The Netlify platform and CDN can be used to automate building and deploying
    web applications, taking advantage of GitHub integration and deploy previews that
    make it easier to review changes to an application before it is shipped.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify平台和CDN可用于自动化构建和部署Web应用程序，利用GitHub集成和部署预览功能，使得在应用程序发布前审查更改变得更加容易。
- en: GraphQL APIs can be deployed as an AWS Lambda function, taking advantage of
    the stateless scale and demand-based pricing that make AWS Lambda appealing. Netlify
    Functions can be used to provision AWS Lambda functions as part of a Netlify site,
    removing the need for a separate code base or deployment process.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL API可以作为AWS Lambda函数部署，利用无状态扩展和基于需求的定价，这使得AWS Lambda具有吸引力。Netlify Functions可用于将AWS
    Lambda函数作为Netlify站点的一部分进行配置，从而消除单独的代码库或部署流程的需求。
