- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Angular in production
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的Angular
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: How to properly build Angular for production environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何正确构建Angular以用于生产环境
- en: Ways to architect your application for best practices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构应用程序以实现最佳实践的途径
- en: Inspecting your final bundle to determine how dependencies impact your app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您的最终包以确定依赖项如何影响您的应用程序
- en: Deployment options and a sample Dockerfile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署选项和示例Dockerfile
- en: So, you’ve built your application—now what? That’s a loaded question, but we’ll
    try to unpack it in this chapter. You could do or focus on a lot of things, but
    not everything is necessary in all projects. There are many general web development
    things you can do, such as enabling gzip on your server, and there are things
    specific to Angular, such as ensuring you run the build using Ahead-of-Time compilation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经构建了您的应用程序——接下来是什么？这是一个棘手的问题，但我们将尝试在本章中解开它。您可以做或关注很多事情，但并非所有事情在所有项目中都是必要的。有许多通用的Web开发事项您可以做，例如在您的服务器上启用gzip，以及一些特定于Angular的事项，例如确保您使用即时编译运行构建。
- en: The way we’ve been developing our application by running `ng` `serve` is perfectly
    acceptable for development but unacceptable for production. The dev server isn’t
    designed to handle real web traffic, can expose vulnerabilities, and can easily
    crash without warning. You’ll want to use a hardened web server for hosting your
    application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行`ng serve`来开发应用程序的方式对于开发来说是完全可接受的，但对于生产来说则不可接受。开发服务器不是为处理真实Web流量而设计的，可能会暴露漏洞，并且可能会在没有警告的情况下轻易崩溃。您将想要使用一个加固的Web服务器来托管您的应用程序。
- en: You may be writing applications for customers, or for the enterprise. I have
    experience in both spaces to share. In an enterprise environment, for example,
    often there are different constraints or greater separation of responsibilities
    across different teams.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在为客户或企业编写应用程序。我在这两个领域都有经验可以分享。例如，在企业环境中，通常会有不同的约束或不同团队之间更大的责任分离。
- en: I’ll cover many important production topics, but remember, there’s always room
    to improve and there are nearly infinite ways to orchestrate tooling for building
    your application. This chapter focuses on the primary things that most applications
    should do and gives you a good foundation of knowledge to apply to any unique
    or customized environments you might be working in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将涵盖许多重要的生产主题，但请记住，总有改进的空间，并且几乎有无限种方式来编排构建应用程序的工具。本章重点介绍大多数应用程序应该做的事情，并为您提供一个良好的知识基础，以便应用于您可能正在工作的任何独特或定制环境中。
- en: 11.1 Building Angular for production
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 为生产构建Angular
- en: Throughout this book we’ve been doing only development builds of our application. That
    won’t serve us well when we want to deploy our application in a real environment—it
    has a lot of extra code, isn’t optimized, and needs cleanup. Our goal is to optimize
    the final built assets for our application so that it’s as small and efficient
    as possible. We want to also ensure that the files can be downloaded as quickly
    as possible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们一直在进行应用程序的开发构建。当我们想在真实环境中部署我们的应用程序时，这不会对我们有太大的帮助——它包含大量额外的代码，没有优化，并且需要清理。我们的目标是优化最终构建资产，以便尽可能小和高效。我们还想确保文件可以尽可能快地下载。
- en: Keep in mind that Angular is constantly evolving, and new releases will add
    additional capabilities and changes to the platform and tooling. I expect everything
    in this chapter to remain accurate in principle over time, but a number of specifics
    will in fact change, so keep an eye on the releases and take advantage of improvements
    as they arrive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，Angular一直在不断发展，新版本将添加额外的功能和平台及工具的变化。我预计本章中的所有内容在原则上都将随着时间的推移保持准确，但确实有一些具体细节将会发生变化，因此请关注发布情况，并在新功能到来时利用改进。 '
- en: 11.1.1 Production build
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 生产构建
- en: The CLI provides for a *production build* option, which adds a number of steps
    to optimize the final code generated by the build. During development, we do everything
    as quickly as possible, but at the cost of larger file sizes. This works just
    fine because you’re working on a local server, where sending 5 MB isn’t too slow—but
    that would be unbearably slow for anyone using a 3G mobile connection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CLI提供了一个*生产构建*选项，它为构建生成的最终代码添加了多个优化步骤。在开发过程中，我们尽可能快地做所有事情，但代价是文件大小更大。这完全没问题，因为您正在本地服务器上工作，发送5MB并不太慢——但对于使用3G移动连接的人来说，这将是无法忍受的慢。
- en: 'You can run a production build by running the following CLI command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下CLI命令来运行生产构建：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The CLI will build the assets and put them into a directory called dist. These
    files are now ready to be deployed as a set of static assets to your target server.
    I’ll cover some details about that later, but the CLI makes it surprisingly simple
    to generate these assets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将构建资源并将它们放入一个名为dist的目录中。这些文件现在已准备好作为一组静态资源部署到您的目标服务器。我稍后会详细介绍这一点，但CLI使生成这些资源变得非常简单。
- en: 'When it does a production build, a few important things happen (note that this
    list may change over time as the CLI tool evolves):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当它进行生产构建时，会发生一些重要的事情（请注意，随着CLI工具的演变，此列表可能会发生变化）：
- en: '*Uses production environment —*If you’ve used the environment configuration
    targets, it will automatically use the production version during build.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用生产环境* — 如果您已使用环境配置目标，则在构建过程中将自动使用生产版本。'
- en: '*Uses minification —*Files are minimized by running them through a tool to
    reduce the number of bytes required to perform tasks.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用压缩* — 通过运行工具来最小化文件，以减少执行任务所需的字节数。'
- en: '*Bundles assets —*Instead of having every file loaded individually, it splits
    them into smaller bundles. These bundles are grouped by purpose, such as vendor
    files placed in one, polyfills in another, the application in another, and so
    on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*打包资源* — 而不是每个文件单独加载，它将它们分割成更小的包。这些包根据用途分组，例如将供应商文件放在一个包中，polyfills放在另一个包中，应用程序放在另一个包中，等等。'
- en: '*Sets the base*`href`—If you plan to deploy the application outside of the
    root directory for a domain, you’ll have to set the base `href` to match the file
    path. You can configure that by passing the `--base-href` flag.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置基本*`href` — 如果您计划将应用程序部署到域的根目录之外，您必须设置基本`href`以匹配文件路径。您可以通过传递`--base-href`标志来配置它。'
- en: '*Filename hashing —*To prevent issues with caching, files are named with a
    unique hash, so that when you deploy a new version, the browser doesn’t ignore
    the update and use its internal cache.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件名哈希化* — 为了防止缓存问题，文件使用唯一的哈希值命名，这样当您部署新版本时，浏览器不会忽略更新并使用其内部缓存。'
- en: '*File copying —*Any static assets like CSS, images, or fonts are copied over
    into the dist directory.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件复制* — 任何静态资源，如CSS、图像或字体，都将复制到dist目录中。'
- en: '*Tree shaking —*The bundles themselves are optimized by tree shaking, a process
    in which unreachable or uncalled code is removed from the bundle. Due to ES2015
    modules, the tooling can determine exactly which lines of code are executed or
    not, and “shake out” the unused bits. This is a tricky feature, and as of this
    writing there are some known issues to be fixed.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*摇树优化* — 这些包本身通过摇树优化进行优化，这是一个从包中删除不可达或未调用的代码的过程。由于ES2015模块，工具可以确定哪些代码行被执行或未执行，并“摇出”未使用的部分。这是一个复杂的功能，并且截至本文撰写时，有一些已知问题需要修复。'
- en: '*AoT —*Ahead-of-Time compilation is enabled to pre-compile the component templates,
    helping to speed up initial render time and allowing Angular to not ship a lot
    of additional code required to compile.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AoT编译* — 启用提前编译组件模板，有助于加快初始渲染时间，并允许Angular不传输大量用于编译的额外代码。'
- en: You can disable some of these by using flags, such as `aot=false`, and you can
    review the CLI documentation for other flags to enable other things, such as translations
    or alternative output directories.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用标志来禁用其中的一些功能，例如`aot=false`，并且您可以通过查看CLI文档来了解其他标志，以启用其他功能，如翻译或替代输出目录。
- en: 11.1.2 Optimizing for target browsers
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 优化目标浏览器
- en: Have you put together a plan for which browsers you want to target? If not,
    you should figure out what versions of which browsers you plan to support. In
    the age of evergreen browsers, it becomes important to continuously evaluate which
    browsers you support and figure out what deficiencies they may have.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否为要针对的浏览器制定了一个计划？如果没有，您应该弄清楚您计划支持哪些浏览器的哪些版本。在持续更新的浏览器时代，持续评估您支持的浏览器以及它们可能存在的缺陷变得很重要。
- en: Polyfills are included by default in projects to bridge the gap in missing features,
    and you can customize what’s used. If you have a good grasp on the browsers you
    support and on what features your application uses, you can customize the polyfills.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在项目中包含polyfills以填补缺失特性的差距，并且您可以自定义使用的内容。如果您对支持的浏览器以及应用程序使用的功能有很好的了解，您可以自定义polyfills。
- en: The file src/polyfills.ts contains a list of polyfills that get imported into
    the project. Some might be needed, but others might not be. You’ll have to evaluate
    your codebase to see for sure, but check to see if you can remove any of them
    to optimize the bundle size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 src/polyfills.ts 包含一个导入到项目中的 polyfills 列表。其中一些可能需要，但其他一些可能不需要。你需要评估你的代码库来确定，但检查一下是否可以移除其中的一些以优化包大小。
- en: 11.1.3 Progressive Web Apps
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 进阶式网络应用（Progressive Web Apps）
- en: Progressive Web Apps (PWAs) are a specific category of apps that have a few
    features. They’re designed to help provide fast-loading web apps for mobile experience
    that can also work offline. You can read more about them at [https://developers.google.com/web/progressive-web-apps](https://developers.google.com/web/progressive-web-apps).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 进阶式网络应用（Progressive Web Apps，简称 PWAs）是一类具有一些特定功能的特定应用程序。它们旨在帮助提供快速加载的移动体验网络应用，同时也可以离线工作。你可以在[https://developers.google.com/web/progressive-web-apps](https://developers.google.com/web/progressive-web-apps)上了解更多关于它们的信息。
- en: At the time of writing, Angular is still working on the tooling for making a
    PWA using Angular. Angular’s site dedicated to this work ([http://mobile.angular.io](http://mobile.angular.io))
    is worth following. As this goes from an alpha state to a stable feature, you
    can expect the tooling to be available through the CLI (as it already is, somewhat).
    The site should provide you with the instructions on how to try it out yourself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular 仍在开发使用 Angular 制作 PWA 的工具。Angular 专门为此工作而建立的网站([http://mobile.angular.io](http://mobile.angular.io))值得关注。随着它从
    alpha 状态发展到稳定功能，你可以期待通过 CLI（正如它已经做到的那样）提供工具。该网站应提供如何尝试它的说明。
- en: The goal is to make it simple for Angular applications to be deployed as PWAs,
    and the Angular documentation is already a working example of this idea. Supporting
    PWA in Angular is a major boost for applications that need to work in mobile environments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是使 Angular 应用程序能够简单部署为 PWAs，并且 Angular 文档已经是这个想法的一个工作示例。在 Angular 中支持 PWA
    对需要在移动环境中工作的应用程序是一个巨大的推动。
- en: 11.1.4 Internationalization (i18n)
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.4 国际化（i18n）
- en: Angular has built-in support for providing local translations of your application,
    but it’s quite lengthy to go through, and not every application may need it. The
    Angular documentation on internationalization ([https://angular.io/guide/i18n](https://angular.io/guide/i18n))
    is quite thorough, and this is an area that the Angular community expects to invest
    in and improve upon in the coming years. Because it’s covered so well in that
    guide, I’ll talk more about the concepts and less about the implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 内置了对提供应用程序本地化翻译的支持，但这相当长，并不是每个应用程序都需要它。Angular 关于国际化的文档([https://angular.io/guide/i18n](https://angular.io/guide/i18n))非常详尽，这是
    Angular 社区预计将在未来几年投资和改进的领域。由于该指南中已经覆盖得很好，我将更多地讨论概念而不是实现。
- en: Translations are difficult and time consuming, but unavoidable for many. Angular
    can’t provide you support to actually do the translation work—as in the work required
    to convert one language to another—but it is designed to fit into a typical translation
    workflow. The basic idea is that all your text messages—anything inside the template
    that is written language—can be extracted out of the application, translated,
    and then recompiled for different languages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译是困难和耗时的，但对于许多人来说是不可避免的。Angular 无法提供实际进行翻译工作的支持——即转换一种语言到另一种语言所需的工作——但它被设计成适合典型的翻译工作流程。基本思想是，所有文本消息——模板中用语言编写的任何内容——都可以从应用程序中提取出来，翻译，然后为不同的语言重新编译。
- en: 'Here are the typical steps to implement i18n in an application. Typically,
    the sooner you set up your i18n process, the easier it will be to implement and
    maintain:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现应用程序中 i18n 的典型步骤。通常，你越早设置你的 i18n 流程，实施和维护就会越容易：
- en: 1 Identify and format any static messages in your application. There are several
    ways to do this depending on your preference and how your translation should be
    managed.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1 识别和格式化应用程序中的任何静态消息。根据你的偏好和翻译管理方式，有多种方法可以做到这一点。
- en: 2 Extract the messages from the application using the CLI (`ng xi18n`), which
    will generate a file in the Xliff 1.2 (default), Xliff 2, or XMB format.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 使用 CLI (`ng xi18n`) 从应用程序中提取消息，这将生成一个 Xliff 1.2（默认）、Xliff 2 或 XMB 格式的文件。
- en: 3 A translator does the manual work of taking the list of original language
    messages and translating them into the other language. Expect this step to take
    time, and you’ll have to identify the person for this work (it might be you, someone
    on your team, or someone external to your team).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3 翻译员的工作是手动将原始语言的消息列表翻译成另一种语言。请预期这一步骤需要花费时间，并且你需要确定负责这项工作的人员（可能是你，也可能是你团队的一员，或者团队外部的人）。
- en: 4 Using the CLI, build a new version of the application and define the translation
    file to use during compilation (`ng build --i18n-file`). This will output a full
    build with the translation messages replaced inside the templates.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4 使用CLI构建应用程序的新版本，并定义在编译期间使用的翻译文件（`ng build --i18n-file`）。这将输出一个完整的构建，其中模板内的翻译消息已被替换。
- en: As of this writing, one major limitation is that translations can’t be dynamically
    loaded into a running application. These messages are hard-coded during the build
    into the resulting output. If you have multiple languages, you’ll have to build
    it once for each language, passing the appropriate i18n file. This is certainly
    a potential area for improvement, so I refer you again to the documentation to
    see if it has become more flexible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到本文撰写时，一个主要的限制是翻译不能动态加载到运行中的应用程序中。这些消息在构建过程中被硬编码到输出结果中。如果你有多个语言，你必须为每种语言构建一次，传递适当的i18n文件。这当然是一个潜在的改进领域，因此我再次建议你查阅文档，看看它是否变得更加灵活。
- en: 11.1.5 Using alternative build tooling
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.5 使用替代构建工具
- en: Although space prohibits my covering all scenarios here, many people are producing
    various alternative build tools for Angular, ranging from using different module
    loaders (such as SystemJS) to different tree-shaking optimizers (such as Rollup).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空间限制了我不能在这里涵盖所有场景，但许多人正在为Angular开发各种替代构建工具，从使用不同的模块加载器（如SystemJS）到不同的摇树优化器（如Rollup）。
- en: These all attempt to optimize various aspects of the build process while rolling
    their own solutions. Some are quite good for specific use cases. The larger your
    project, or the more important it is that a certain aspect is optimized, the more
    you may want to consider additional tooling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具都试图优化构建过程的各个方面，同时提供自己的解决方案。如果你的项目越大，或者某个特定方面需要优化的重要性越高，你可能就越需要考虑额外的工具。
- en: Although choosing to go your own route with build tooling is certainly a viable
    option, for most scenarios I highly suggest you use the CLI. This is a time-saving
    tool that’s growing with the Angular platform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选择使用自己的构建工具路线当然是一个可行的选项，但在大多数情况下，我强烈建议你使用CLI。这是一个节省时间的工具，它随着Angular平台的发展而不断成长。
- en: I originally set up my own tooling before the CLI was available, and it was
    a lot of work to maintain. I might have had full control over certain things,
    but at the cost of much more time and effort. I’ve also worked with projects that
    have maintained their own tooling using Grunt or Gulp, and I found that they add
    a lot of code to a project to manage the same tasks that the CLI provides. Invariably,
    there tends to be only one person who understands the build tooling, making it
    hard for others to understand what is happening.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI可用之前，我最初设置了自家的工具，维护起来非常费时。我可能对某些事情有完全的控制权，但代价是花费更多的时间和精力。我也与那些使用Grunt或Gulp维护自己工具的项目合作过，我发现它们为项目添加了大量代码来管理CLI提供的相同任务。不可避免的是，通常只有一个人理解构建工具，这使得其他人难以理解正在发生的事情。
- en: If you have custom needs, consider using the Angular CLI as part of the process
    instead of duplicating its behaviors, especially those related to how it builds
    the application. If you want to do additional processing after the build, better
    to do it after the CLI has run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有自己的需求，考虑将Angular CLI作为流程的一部分使用，而不是复制其行为，特别是那些与其构建应用程序的方式相关的行为。如果你想在构建后进行额外的处理，最好在CLI运行后进行。
- en: At the time of writing, the CLI is being reworked into more of a software development
    kit (SDK) so that it can be better integrated into custom solutions and tooling.
    I expect that this will evolve into an even more powerful set of tools that provides
    greater flexibility and opens many more options.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，CLI正在被重新设计为一个更完整的软件开发工具包（SDK），以便更好地集成到定制解决方案和工具中。我预计这将演变成一个更强大的工具集，提供更大的灵活性和更多的选择。
- en: 11.1.6 Server-side rendering or pre-rendering
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.6 服务器端渲染或预渲染
- en: Some applications have important needs such as search engine optimization (SEO),
    meaning they need to be easily crawled by search engines. Or perhaps being able
    to quickly see the content of the page is important (as is the case with our forum
    and chat application example from chapter 7).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序有重要的需求，例如搜索引擎优化（SEO），这意味着它们需要被搜索引擎轻松抓取。或者，可能快速查看页面内容很重要（就像我们在第 7 章中的论坛和聊天应用程序示例中那样）。
- en: Angular has a package called platform-server that provides a way to render Angular
    on the server. Like the PWA support, at the time of writing it’s still in active
    development. You can find out more about it at [https://github.com/angular/universal](https://github.com/angular/universal).
    The goal of such an approach is to render pages of your application on the server,
    which would be best for crawlers and for users. Users would see the page content
    sooner than they do today, because the rendered version would still bootstrap
    Angular after the initial content has displayed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有一个名为 platform-server 的包，它提供了一种在服务器上渲染 Angular 的方法。就像 PWA 支持，在撰写本文时，它仍在积极开发中。您可以在
    [https://github.com/angular/universal](https://github.com/angular/universal) 上了解更多信息。这种方法的目的是在服务器上渲染您应用程序的页面，这对爬虫和用户来说都是最好的。用户将比现在更早地看到页面内容，因为渲染版本会在初始内容显示后启动
    Angular。
- en: Think of how a blog post might appear where you could begin to read, but until
    Angular finished loading the rest of the assets in the background, the ability
    to click links would be delayed. Angular is smart enough to capture those events
    and replay them after the background loading has finished, so it doesn’t prevent
    users from interacting—it’s largely about getting content displayed before the
    bootstrapping of Angular.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想想一个博客文章可能看起来怎样，你可能会开始阅读，但直到 Angular 在后台完成其余资源的加载，点击链接的能力将会延迟。Angular 足够智能，能够捕获这些事件，并在后台加载完成后重新播放它们，这样就不会阻止用户交互——这主要是关于在
    Angular 启动之前显示内容。
- en: This could be tremendously beneficial for many applications, and of not much
    value to others. Your use case will determine its usefulness for you, but expect
    server-side rendering to be an important feature of the Angular platform in coming
    releases. As of Angular 4, the rendering is all part of the official build process,
    but still has a number of roadmap tasks to tackle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这对许多应用程序可能非常有用，但对其他应用程序的价值不大。您的用例将决定它对您的有用性，但预计服务器端渲染将成为 Angular 平台未来版本中的一个重要功能。截至
    Angular 4，渲染是官方构建过程的一部分，但仍有许多路线图任务要解决。
- en: 11.1.7 Build pipelines
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.7 构建管道
- en: Gone are the days when you simply upload a file to a remote server and let it
    run. Most applications, including those built with Angular, require build tooling
    and orchestration for how to build a production version. Today, we have extensive
    tooling to help with processes, known as *continuous integration and delivery*
    (CI/CD). There are many ways to approach the build orchestration problem, but
    the basics usually include a chain of tools that automatically run to validate
    a particular build of your application, run tests, build it for production, and
    push it into production.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 那些简单地将文件上传到远程服务器并让其运行的日子已经过去了。大多数应用程序，包括使用 Angular 构建的应用程序，都需要构建工具和编排来构建生产版本。今天，我们有广泛的工具来帮助处理称为
    *持续集成和交付*（CI/CD）的过程。有许多方法可以解决构建编排问题，但基本通常包括一系列工具，这些工具会自动运行以验证您应用程序的特定构建，运行测试，为生产构建它，并将其推送到生产环境。
- en: Angular itself uses a number of tools to aid in the automated testing of the
    framework, and because it’s an open source project, it can do so freely. Many
    tools provide free accounts for open source projects or trial accounts if you’d
    like to try them. I’m not going to focus on any specific tool here, but instead
    on the kinds of things you should consider putting into your own pipelines.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 本身使用一系列工具来辅助框架的自动化测试，并且由于它是一个开源项目，它可以自由地这样做。许多工具为开源项目提供免费账户，或者如果您想尝试它们，可以提供试用账户。在这里，我不会专注于任何特定的工具，而是会关注您应该考虑将哪些类型的事情放入自己的管道中。
- en: There isn’t much special about Angular related to build pipelines, except that
    Angular has plans to surface a set of tools from the Google ecosystem that would
    be a great option for applications to leverage when the tools are stable. Pay
    attention to release notes and project announcements, because the addition of
    more CI/CD tools is sure to be a major capability.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与构建管道相关的Angular并没有什么特别之处，除了Angular计划从Google生态系统推出一系列工具，这些工具在工具稳定时将是应用程序可以利用的绝佳选择。请注意发布说明和项目公告，因为更多CI/CD工具的添加肯定会是一个主要的功能。
- en: 11.2 Angular architecture choices
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 Angular架构选择
- en: If you didn’t start out planning your application’s architecture before you
    wrote code, you missed an opportunity to think about design choices that will
    help you later on. It’s better late than never to review your architecture and
    consider what potential choices you can make to either simplify or optimize.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在编写代码之前规划应用程序的架构，你就错过了一个思考有助于你以后的设计选择的机会。审查你的架构并考虑你可以做出的简化或优化选择，即使晚些时候也比没有好。
- en: This section covers what could be considered a list of best practices for writing
    your application, and you should follow these approaches in most scenarios. They
    all have an impact on the quality, performance, or stability of your application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了编写应用程序时可能被认为是最佳实践列表的内容，你应该在大多数情况下遵循这些方法。它们都会对你的应用程序的质量、性能或稳定性产生影响。
- en: Most of these are also choices you have to make continuously as you build the
    application. They’re not steps you take once but principles that you should apply
    as you build and maintain the application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也都是你在构建应用程序时需要持续做出的选择。它们不是你一次性采取的步骤，而是你应该在构建和维护应用程序时应用的原则。
- en: 11.2.1 Lazy load routes
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 懒加载路由
- en: When it comes to making your application quick to load and run, *lazy loading*
    your routes is likely to be the most important step you can take. One of the biggest
    measures of performance is time for the application to load and become ready for
    the user to interact with.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到使你的应用程序快速加载和运行时，*懒加载*路由可能是你可以采取的最重要的一步。性能的最大衡量标准之一是应用程序加载并准备好与用户交互所需的时间。
- en: There are a number of milestones along that path, but the faster your users
    can start to use your application, the more likely they are to stay around. This
    is especially true on mobile devices where slow loading and rendering causes user
    retention to drop quickly after a few seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条路上有许多里程碑，但用户能够更快地开始使用你的应用程序，他们留下来的可能性就越大。这在移动设备上尤其如此，因为缓慢的加载和渲染会在几秒钟后迅速降低用户留存率。
- en: When you look at your application, think about how every route is structured.
    You likely want to bundle your default route without lazy loading it, but most
    every other route is probably a good candidate to separate out into its own module
    and lazy load.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你审视你的应用程序时，考虑每个路由的结构。你可能希望将默认路由捆绑在一起而不进行懒加载，但大多数其他路由可能都是将其分离到自己的模块并懒加载的好候选者。
- en: Chapter 7, section 7.8 covered lazy loading, so refer back to that for a refresher
    on the specifics of how it works and how to employ it in your application. My
    suggestion is to make every route its own feature module (except the default route,
    like the home page and perhaps the login). When you do that, the build files will
    be split into many different files for each route, and only the core bundles will
    be loaded on app load. The rest will be loaded as the user navigates around the
    application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第7章第7.8节涵盖了懒加载，所以请回顾那个部分以刷新关于其工作原理和如何在应用程序中应用的具体细节。我的建议是将每个路由都做成自己的功能模块（除了默认路由，如主页和可能登录页面）。当你这样做时，构建文件将根据每个路由分成许多不同的文件，只有核心包在应用程序加载时加载。其余的将在用户在应用程序中导航时加载。
- en: Imagine your application has 10 routes and a few shared services and components.
    The 10 routes could represent something like 60–70% of the code weight for your
    application (excluding libraries), so you could achieve significant savings by
    extracting them. Every application will be different, but the more routes you
    have, the greater the potential savings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你的应用程序有10个路由和一些共享服务和组件。这10个路由可能代表了应用程序代码重量的60-70%（不包括库），因此通过提取它们可以实现显著的节省。每个应用程序都会有所不同，但路由越多，潜在节省的可能性就越大。
- en: You could also consider preloading the lazy loaded modules, which is a way to
    download the modules in the background after the initial route has loaded. This
    means subsequent routes will be faster to render, but it does load the application
    files. If you’re on mobile, that might not be great if you have a very large application
    or routes that are rarely loaded.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以考虑预加载懒加载的模块，这是一种在初始路由加载后，在后台下载模块的方式。这意味着后续路由将更快地渲染，但这确实会加载应用程序文件。如果您在移动设备上，如果您的应用程序非常大或者很少加载路由，这可能不是很好。
- en: There are also strategies for preloading only specific modules unless they’re
    explicitly used, but that takes a little more custom wiring. Both of these strategies
    are nicely laid out by Victor Savkin, a former Angular core member, at [https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb](https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不明确使用，也有策略仅预加载特定模块，但这需要一些额外的定制配置。这两项策略都由前Angular核心成员Victor Savkin在[https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb](https://vsavkin.com/angular-router-preloading-modules-ba3c75e424cb)上进行了很好的阐述。
- en: 11.2.2 Reduce external dependencies
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 减少外部依赖
- en: There are a lot of useful external libraries out there, but everything comes
    at a cost. There’s always a tradeoff, but it’s something you should consider carefully.
    If you include a dependency, be prepared to keep track of how it’s used in your
    application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 外部库有很多有用的，但任何事物都有代价。总是存在权衡，但这是您应该仔细考虑的事情。如果您包含一个依赖项，请准备好跟踪它在您的应用程序中的使用情况。
- en: In all the earlier chapter examples, I’ve included some external dependencies,
    like UI libraries. These libraries provide immense value because we don’t have
    to build and implement those features ourselves. That’s the whole reason for including
    external dependencies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有早期的章节示例中，我都包含了一些外部依赖项，如UI库。这些库提供了巨大的价值，因为我们不必自己构建和实现这些功能。这就是包含外部依赖项的全部原因。
- en: On the flip side, the more dependencies you include, the larger your application
    will become. You have little control over these dependencies, and many of us don’t
    spend much time inspecting them carefully, if at all.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，您包含的依赖项越多，您的应用程序就会变得越大。您对这些依赖项几乎没有控制权，我们中的许多人几乎没有花时间仔细检查它们，如果不是完全没有的话。
- en: There are some tools and techniques that can help you inspect the impact of
    these dependencies in your application. Most of the time, though, you need to
    practice common sense and restrict yourself to the most important dependencies.
    My primary concerns about dependencies follow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具和技术可以帮助您检查这些依赖项在您的应用程序中的影响。然而，大多数时候，您需要运用常识并限制自己只关注最重要的依赖项。我对依赖项的主要担忧如下。
- en: Security concerns
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全问题
- en: Libraries are often treated as black boxes, and it’s always possible that they
    contain security issues. Keep a close eye on them and review them. Dependencies
    may also import additional sub-dependencies, and that can make security issues
    hard to keep track of.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 库通常被视为黑盒，它们可能包含安全漏洞。密切关注它们并审查它们。依赖项也可能导入额外的子依赖项，这可能会使安全漏洞难以跟踪。
- en: You can look at the Node Security project for help tracking known vulnerabilities
    in Node modules, at [https://nodesecurity.io/opensource](https://nodesecurity.io/opensource).
    This is a free tool, though it has some paid solutions as well. It looks at your
    project’s package.json file and compares it against its database of vulnerabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看Node Security项目以帮助跟踪Node模块中已知的漏洞，请访问[https://nodesecurity.io/opensource](https://nodesecurity.io/opensource)。这是一个免费工具，尽管它也有一些付费解决方案。它会检查您的项目package.json文件，并将其与漏洞数据库进行比较。
- en: Quality and size
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 质量和大小
- en: Not every dependency is written with production use cases in mind. Many are
    written because they solved a problem and were published for others to consume.
    Always measure the impact they have on your application and make sure to evaluate
    more than one option if it exists—or see if it’s better to do yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个依赖都是针对生产用途编写的。许多依赖之所以被编写，是因为它们解决了某个问题，并且被发布供他人使用。始终衡量它们对您应用程序的影响，并在存在多个选项的情况下确保评估它们——或者看看自己动手做是否更好。
- en: I often review a dependency by looking at the type and quality of testing it
    has in place. Unfortunately, many dependencies don’t have any testing, or the
    testing is inadequate. That’s because so often things are published quickly as
    a hobby.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常通过查看依赖项的测试类型和质量来审查依赖项。遗憾的是，许多依赖项没有任何测试，或者测试不足。这是因为事情往往被迅速发布，作为一种爱好。
- en: As far as the size impact, you can use a tool called source-map-explorer, shown
    in [figure 11.1](#figure11.1), to see the impact of each directory and file on
    your overall bundle size.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就尺寸影响而言，您可以使用一个名为source-map-explorer的工具，如图11.1所示，来查看每个目录和文件对您整体捆绑包尺寸的影响。
- en: '![c11-1.png](image_fi/293313c11/c11-1.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![c11-1.png](image_fi/293313c11/c11-1.png)'
- en: '[**Figure 11.1**](#figureanchor11.1) source-map-explorer lets you view the
    size of each part of your bundle to identify potential optimizations.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图11.1**](#figureanchor11.1) source-map-explorer 允许您查看您捆绑包中每个部分的尺寸，以识别潜在的优化。'
- en: 'To use source-map-explorer, you’ll need to install it on your system using
    the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用source-map-explorer，您需要使用以下命令在您的系统上安装它：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then you’ll need to build the application, but make sure you build it with
    sourcemaps. You can do a production build, but toggle sourcemaps on (which are
    defaulted to off in production build):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要构建应用程序，但请确保您使用带有sourcemaps的方式构建它。您可以进行生产构建，但切换sourcemaps为开启（在生产构建中默认是关闭的）：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That will output your files into the dist directory, and then you can inspect
    the various bundle files by running the following, where the second parameter
    is the filename you want to analyze:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将您的文件输出到dist目录中，然后您可以通过运行以下命令来检查各种捆绑文件，其中第二个参数是要分析的文件名：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A browser window will open, looking like figure 10.1\. The text is quite small
    in the image, but you can click various files and zoom into the internals of that
    package. For example, figure 10.1 shows that the Angular Material package from
    the chapter 8 example is ~35% of the vendors bundle, whereas Covalent is ~18%
    and RxJS is ~6%. This is helpful to know—you want to see the impact of a module
    on the size of your bundles. Run this tool against all your bundle output files
    and see which components are the largest, or how much a polyfill weighs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个浏览器窗口，看起来像图10.1。图像中的文本相当小，但您可以点击各种文件并放大到该包的内部。例如，图10.1显示，第8章示例中的Angular
    Material包占供应商捆绑包的约35%，而Covalent占约18%，RxJS占约6%。了解这一点是有帮助的——您想看到模块对您捆绑包尺寸的影响。运行此工具针对所有您的捆绑输出文件，并查看哪些组件最大，或者polyfill有多重。
- en: Compatibility and supportability
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 兼容性和可支持性
- en: External dependencies aren’t necessarily maintained. When there are issues,
    can you trust they will be fixed? One example is TypeScript, which has added features
    Angular depends on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 外部依赖不一定得到维护。当出现问题时，您能信任它们会被修复吗？一个例子是TypeScript，它添加了Angular所依赖的功能。
- en: There are a couple of ways to determine supportability, and doing so is largely
    subjective. I personally like to spend time on the project’s site, often GitHub,
    to see how active it is. Are there many bug reports with no responses? What about
    commit activity? Just because there hasn’t been any activity in the past few months
    doesn’t mean it’s been abandoned. Some projects show helpful badges to declare
    if a dependency is actively maintained or not.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确定可支持性，而且这样做在很大程度上是主观的。我个人喜欢花时间在项目网站上，通常是GitHub，看看它有多活跃。是否有许多没有响应的bug报告？关于提交活动呢？仅仅因为过去几个月没有活动并不意味着它已经被放弃。一些项目会显示有用的徽章来声明依赖是否得到积极维护。
- en: Rather than opening an issue and asking if the project is active, I find it’s
    much better to find a small improvement to make. You can do that by adding a few
    lines to the documentation or README file, but the goal is to provide some value
    to the project and make it an easy contribution to merge. There are always documentation
    improvements to make, so use that as a way to gain a little favor with the maintainer
    and also figure out how responsive they are.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，打开一个问题并询问项目是否活跃，我发现找到一个小改进来做出贡献会更好。您可以通过添加几行到文档或README文件中来实现这一点，但目标是给项目提供一些价值，并使其成为一个容易合并的贡献。总是有可以改进的文档，所以利用这一点来赢得维护者的一丝好感，并了解他们的响应性。
- en: When it comes to compatibility, you’ll need to make sure you have good testing
    in place. The only way to verify whether things are working is to test, and you
    want to automate that as much as possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到兼容性时，您需要确保您有良好的测试环境。验证事物是否正常工作的唯一方法是测试，并且您希望尽可能自动化这一点。
- en: Another useful project is Green Keeper, which helps you keep your projects automatically
    updated with latest versions. It also tries to run your tests with the newer version
    to help determine if there are any breaking changes—good testing has to be in
    place for that to be useful. You can find the project at [https://greenkeeper.io](https://greenkeeper.io).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的项目是 Green Keeper，它可以帮助你自动将项目更新到最新版本。它还尝试使用较新版本运行你的测试，以帮助确定是否存在任何破坏性变化——良好的测试对于这一点来说至关重要。你可以在
    [https://greenkeeper.io](https://greenkeeper.io) 找到该项目。
- en: Import minimal items
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尽量减少导入的项目
- en: When you decide you need an external dependency, often there are ways to optimize
    how it’s used in your application. Well-designed libraries allow you to import
    only the specific pieces you need instead of the entire library. Any extra imported
    items may make it into your final build as dead code. It varies by library, but
    one example is RxJS, which allows you to import the specific items you need instead
    of the whole library. Likewise, the Covalent UI and Angular Material libraries
    both allow you to import specific portions of the library as needed instead of
    the entire bundle. This saves overall code weight, and I like it because you can
    be specific about what to import.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定需要外部依赖项时，通常有方法可以优化它在你的应用程序中的使用。设计良好的库允许你只导入你需要的特定部分，而不是整个库。任何额外的导入项都可能成为最终构建中的死代码。这因库而异，但一个例子是
    RxJS，它允许你导入你需要的特定项目，而不是整个库。同样，Covalent UI 和 Angular Material 库都允许你根据需要导入库的特定部分，而不是整个包。这可以节省总体代码量，我也喜欢这种做法，因为它可以明确指定要导入的内容。
- en: Long term, this may not be an issue if you’re able to optimize your bundle files
    to drop out any unused code. But it’s still a good idea to practice importing
    the fewest items possible in the meantime and focus on only what you need.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，如果你能够优化你的包文件以删除任何未使用的代码，这可能不会成为一个问题。但在此期间，实践尽可能少地导入项目，并专注于你真正需要的东西，仍然是一个好主意。
- en: 11.2.3 Stay up-to-date
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 保持更新
- en: When Angular 4 came out, it was possible for almost every application to upgrade
    without causing any breaking changes to deal with. That’s pretty impressive considering
    the number of changes and improvements made between the Angular 2 and 4 releases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 4 发布时，几乎每个应用程序都可以升级而不会引起任何需要处理的破坏性变化。考虑到 Angular 2 和 4 之间所做的更改和改进的数量，这相当令人印象深刻。
- en: One of the key improvements was related to the Angular compiler, and due to
    the way it was optimized under the hood, the size of application bundles decreased
    significantly. The savings varied by application, but it was estimated that the
    compiler would reduce the size of components by around 60%. The only thing applications
    had to do to achieve these savings was update!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一项关键改进与 Angular 编译器有关，由于它在底层进行了优化，应用程序包的大小显著减小。节省量因应用程序而异，但据估计，编译器可以将组件的大小减少约
    60%。应用程序要实现这些节省，只需更新即可！
- en: As Angular evolves, this type of scenario will continue. The Angular library
    will evolve and optimize itself, the build tooling will keep getting smarter,
    and those who use the latest and greater versions will be able to take advantage
    of those benefits.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Angular 的发展，这种类型的场景将继续存在。Angular 库将不断发展和优化自身，构建工具将变得越来越智能，而使用最新和更高版本的人将能够利用这些好处。
- en: As I’ve stressed, Angular is more of a platform than just a framework. The combination
    of the tooling, various libraries, and other ecosystem components is being constantly
    improved. I’ve sat down with the Angular team to talk about priorities and goals,
    and optimization is one that comes up consistently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前强调的，Angular 更多的是一个平台，而不仅仅是一个框架。工具、各种库和其他生态系统组件的组合正在不断改进。我曾与 Angular 团队坐下来讨论优先事项和目标，优化是一个始终出现的话题。
- en: The takeaway here is to not lock yourself into a version of Angular and forget
    about upgrading. Keep track of the development notes and enjoy the regular, incremental
    releases. There is a six-month cycle for major releases that may contain some
    breaking changes. Angular hopes to minimize the number of breaking changes and
    provide clear upgrade paths for keeping on the latest versions. This does mean
    making changes to your applications over time, but if you aren’t doing that, you’re
    losing out on all the potential benefits. Plus you might be open to any security
    issues that have been reported and resolved.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是不要将自己锁定在 Angular 的某个版本上并忘记升级。跟踪开发笔记并享受定期的增量发布。主要版本可能每六个月发布一次，可能包含一些破坏性更改。Angular
    希望最小化破坏性更改的数量，并为保持最新版本提供清晰的升级路径。这确实意味着随着时间的推移对您的应用程序进行更改，但如果不这样做，您就会失去所有潜在的好处。此外，您可能容易受到已报告并解决的任何安全问题的攻击。
- en: 11.3 Deployment
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 部署
- en: There are a lot of potential ways of deploying your application and a lot of
    opinions about which is best. You may have to work with a specific option because
    that’s what your company or team always uses, or you may be able to choose your
    own. Either way, a few basics remain consistent. This section looks at a few of
    these considerations and at a couple deployment approaches. I hope it serves as
    a helpful guide for you to base your own deployment strategy on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序有无数种潜在方式，关于哪种方式最好也有很多意见。您可能必须与特定的选项合作，因为这是您公司或团队一直使用的，或者您可能能够选择自己的。无论如何，一些基本要点是一致的。本节探讨了这些考虑因素和几种部署方法。我希望它能作为您制定自己的部署策略的有用指南。
- en: 'No matter which server you plan to use, you should make sure a few things are
    set up to work properly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您计划使用哪个服务器，您都应该确保一些事情设置正确以正常工作：
- en: '*gzip compression —*Configure your server to send files with gzip compression
    enabled. gzip is a simple configuration value supported by most browsers that
    significantly reduces the sizes of files sent over the network. Savings vary,
    but 30% or more isn’t uncommon.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gzip 压缩* — 配置您的服务器以启用 gzip 压缩发送文件。gzip 是大多数浏览器支持的简单配置值，可以显著减少通过网络发送的文件大小。节省的量各不相同，但
    30% 或更多并不罕见。'
- en: '*Fall back to index.html by rewriting URLs —*Any single page application (Angular
    or otherwise) needs the server to handle rewriting URLs to serve up the index
    file even if another file is requested. Imagine you land on example.com/blog/my-post-123\.
    The server will first look for an asset at the /blog/my-post-123 location, but
    that file doesn’t exist because it’s just an Angular route. Instead, the server
    needs to fall back to sending the index.html file so Angular can execute.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过重写 URL 回退到 index.html* — 任何单页应用程序（Angular 或其他）都需要服务器处理重写 URL 以提供索引文件，即使请求了其他文件也是如此。想象一下，您到达
    example.com/blog/my-post-123。服务器将首先在 /blog/my-post-123 位置查找资产，但该文件不存在，因为它只是一个
    Angular 路由。相反，服务器需要回退到发送 index.html 文件，以便 Angular 可以执行。'
- en: '*CORS or reverse proxy —*Many APIs run from a different domain (or even subdomain),
    and it’s easy to enable CORS headers in the API server. Alternatively, you can
    use a reverse proxy to map URLs so they proxy through your domain to another.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORS 或反向代理* — 许多 API 都运行在不同的域名（甚至子域名）上，因此很容易在 API 服务器中启用 CORS 头部。或者，您可以使用反向代理来映射
    URL，以便它们通过您的域名代理到另一个域名。'
- en: Depending on your server, other optimizations or configurations may be available
    to you. My suggestions here aren’t exhaustive, so it’s best to research a bit
    more about what your server has available.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的服务器，可能还有其他优化或配置可供您使用。这里提出的建议并不全面，因此最好进一步研究一下您的服务器提供了哪些功能。
- en: Once you’ve run the CLI `build` command, you can take the dist directory and
    drop it on a server that handles service static files. You should automate the
    process, but there are a few ways you could deploy it for free on a service like
    GitHub pages, Heroku, or Firebase.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了 CLI `build` 命令，您就可以将 dist 目录放在处理服务静态文件的服务器上。您应该自动化这个过程，但有一些方法可以在 GitHub
    pages、Heroku 或 Firebase 等服务上免费部署它。
- en: That’s the most common and easiest approach, but sometimes you’ll want to wrap
    it up in a container and deploy it that way. The following example uses the nginx
    server and builds a container that has your application files. You can create
    a file called Dockerfile in your project directory and use code from [listing
    11.1](#listing11.1). You also need to have an nginx.conf file in your directory,
    as you see in [listing 11.2](#listing11.2).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见且最简单的方法，但有时你可能想要将其封装在容器中并以此方式部署。以下示例使用nginx服务器构建一个包含应用程序文件的容器。你可以在你的项目目录中创建一个名为Dockerfile的文件，并使用[列表11.1](#listing11.1)中的代码。你还需要在你的目录中有一个nginx.conf文件，如[列表11.2](#listing11.2)所示。
- en: '[**Listing 11.1**](#listinganchor11.1) Sample Dockerfile for nginx'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表11.1**](#listinganchor11.1) 样本nginx Dockerfile'
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[**Listing 11.2**](#listinganchor11.2) Sample nginx config'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[**列表11.2**](#listinganchor11.2) 样本nginx配置'
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding two listings will allow you to build a container that has nginx
    to serve your application. Assuming you have Docker installed on your machine,
    you can run the following commands to build and run the container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个列表将允许你构建一个包含nginx以服务你的应用程序的容器。假设你在机器上安装了Docker，你可以运行以下命令来构建和运行容器：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are many ways to configure this Dockerfile, and this is just meant as
    a basic starter. You can fine-tune the nginx config as well, including handling
    error pages and adjusting gzip settings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 配置这个Dockerfile有多种方式，这只是一个基本的入门级示例。你还可以微调nginx配置，包括处理错误页面和调整gzip设置。
- en: Because Angular provides you with the built static assets, injecting them into
    many different server environments is easy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Angular为你提供了构建的静态资源，将它们注入到许多不同的服务器环境中很容易。
- en: Congrats! You’ve designed, built, and now deployed your Angular application!
    At this point, you can either lie back and enjoy your success or start on your
    next project!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经设计、构建并现在部署了你的Angular应用程序！在这个时候，你可以要么放松享受你的成功，要么开始你的下一个项目！
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered a lot of details around building and deploying Angular
    for production. There’s a lot of detail work you can do, and many opportunities
    for optimizing. Over time, new abilities will be added to the Angular platform
    that you’ll want to take advantage of. Here are the key highlights covered in
    this chapter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了构建和部署Angular到生产环境的许多细节。你可以做很多细致的工作，并且有很多优化机会。随着时间的推移，Angular平台将添加新的功能，你将想要利用这些功能。以下是本章涵盖的关键亮点：
- en: Angular CLI provides a production build option that does a number of tasks as
    it builds your application’s final bundle assets. It can optimize and shake out
    dead code, implement cache-busting names, and provide you a directory with everything
    your app needs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CLI提供了一个生产构建选项，在构建你的应用程序最终包资源时会执行多项任务。它可以优化并移除死代码，实现缓存破坏名称，并提供一个包含你应用程序所需一切内容的目录。
- en: Some best practices to follow include lazy loading your routes and importing
    only the necessary pieces of libraries. As you add more dependencies to your application,
    more things can potentially bloat your bundle size or have an impact on your ability
    to maintain the application.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些最佳实践包括懒加载你的路由和只导入必要的库组件。随着你向应用程序添加更多依赖项，可能会增加你的包大小，或者影响你维护应用程序的能力。
- en: Deploying to servers is easy because you get the final rendered assets. You
    can bundle these static files into a container or include them in other server
    environments. Be sure you’ve handled falling back to the index.html file and other
    server considerations.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到服务器上很容易，因为你得到了最终的渲染资源。你可以将这些静态文件打包到容器中，或者包含在其他服务器环境中。确保你已经处理了回退到index.html文件和其他服务器考虑事项。
