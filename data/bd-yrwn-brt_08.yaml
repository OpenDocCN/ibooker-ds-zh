- en: 8 Keyboard-controlled camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 键盘控制相机
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Capturing images and streaming live videos from the camera
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相机捕获图像和流式传输实时视频
- en: Drawing shapes and writing text using the OpenCV library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV库绘制形状和写入文本
- en: Moving servo motors to specific angles and positions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将伺服电机移动到特定的角度和位置
- en: Using keyboard events in OpenCV to make servo movements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV中的键盘事件来控制伺服电机运动
- en: In this chapter, we will build a robot with a camera attached to two servo motors.
    One servo will allow us to pan the camera, and the other will apply a tilt motion.
    In this way, we can point the camera in many different directions. In addition,
    we will detect and use keyboard events to move the motors in different directions
    and capture and save photos from the live camera stream.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个带有两个伺服电机连接相机的机器人。一个伺服电机将允许我们平移相机，另一个将应用倾斜运动。这样，我们可以将相机指向许多不同的方向。此外，我们将检测和使用键盘事件来在不同方向上移动电机，并从实时相机流中捕获和保存照片。
- en: We have explored the use of touch screens on mobile devices and joysticks as
    human interaction devices. Now we will use a keyboard to control our robot movements
    and camera. Keyboards are one of the oldest and most established input devices.
    Compared to joysticks, they come with every desktop computer and laptop and have
    excellent built-in support in most software, not requiring much additional effort.
    This makes them an excellent alternative to joysticks when we either don’t want
    to add additional hardware requirements or just want to simplify our device handling.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在移动设备上使用触摸屏和操纵杆作为人机交互设备。现在，我们将使用键盘来控制我们的机器人运动和相机。键盘是最古老和最成熟的输入设备之一。与操纵杆相比，它们随每台台式计算机和笔记本电脑一起提供，并且在大多数软件中都有出色的内置支持，不需要额外的工作。这使得它们在不想添加额外的硬件要求或只想简化设备处理时成为操纵杆的绝佳替代品。
- en: 8.1 Hardware stack
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 硬件堆栈
- en: Figure 8.1 shows the hardware stack, with the specific components used in this
    chapter highlighted. The camera can be directly connected to the Raspberry Pi
    using the camera connector. The camera used in this chapter is the Raspberry Pi
    Camera Module 2\.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1显示了硬件堆栈，本章中使用的特定组件被突出显示。相机可以直接通过相机连接器连接到Raspberry Pi。本章中使用的相机是Raspberry
    Pi Camera Module 2。
- en: '![](../Images/CH08_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F01_Alsabbagh.png)'
- en: 'Figure 8.1 Hardware stack: the camera and servo will be controlled using the
    keyboard.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 硬件堆栈：相机和伺服电机将通过键盘进行控制。
- en: The servo motors are part of a Pan-Tilt Kit that comes fully assembled. The
    camera will be mounted to this kit. For further details on the robot assembly,
    check the robot assembly guide in appendix C. It shows how to assemble the robot
    used in this chapter. Also, make sure to check the hardware purchasing guide in
    appendix A before buying the hardware needed in this chapter. Any keyboard can
    be used for the robot; whether it is a USB or Bluetooth keyboard, there are no
    special requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机是Pan-Tilt套件的一部分，该套件已完全组装。相机将安装在此套件上。有关机器人组装的更多详细信息，请参阅附录C中的机器人组装指南。它展示了如何组装本章中使用的机器人。此外，在购买本章所需的硬件之前，请务必查阅附录A中的硬件购买指南。任何键盘都可以用于机器人；无论是USB键盘还是蓝牙键盘，都没有特殊要求。
- en: 8.2 Software stack
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 软件堆栈
- en: Details of the specific software used in this chapter are described in figure
    8.2\. The `draw` and `snapshot` applications in this chapter will use the OpenCV
    and NumPy libraries to capture images from the camera and draw shapes and write
    text on images. We will also learn how to read keyboard events using the OpenCV
    library and perform actions such as taking photos when specific keyboard events
    are detected. The OpenCV library will be used to interact with the Linux kernel
    video subsystem to capture images from the camera hardware. The `sweep` and `pan`
    applications come later in the chapter and will let us control the servo motor
    hardware, as well as take photos with the camera.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息在图8.2中描述。本章中的`draw`和`snapshot`应用程序将使用OpenCV和NumPy库从相机捕获图像，并在图像上绘制形状和写入文本。我们还将学习如何使用OpenCV库读取键盘事件，并在检测到特定键盘事件时执行拍照等操作。OpenCV库将用于与Linux内核视频子系统交互，以从相机硬件捕获图像。`sweep`和`pan`应用程序将在本章的后面部分介绍，并将允许我们控制伺服电机硬件，以及使用相机拍照。
- en: '![](../Images/CH08_F02_Alsabbagh.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F02_Alsabbagh.png)'
- en: 'Figure 8.2 Software stack: the OpenCV library will capture images from the
    camera.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 软件堆栈：OpenCV库将捕获相机图像。
- en: 8.3 Capturing images using OpenCV
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 使用OpenCV捕获图像
- en: 'OpenCV is a very popular and powerful computer vision library. We will use
    it to interact with the camera to show a live video stream and save snapshots.
    In later chapters, we will expand our usage to perform face detection and QR code
    detection and decoding. We need to create an application to meet the following
    requirements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个非常流行且功能强大的计算机视觉库。我们将使用它来与相机交互，显示实时视频流并保存快照。在后面的章节中，我们将扩展我们的使用范围，以执行人脸检测和二维码检测与解码。我们需要创建一个满足以下要求的应用程序：
- en: A Python application that uses the OpenCV library to show a live video feed
    from the camera should be created.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该创建一个使用OpenCV库显示来自相机的实时视频流的Python应用程序。
- en: It should be possible to save a snapshot image with a time stamp whenever the
    user presses the spacebar.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户按下空格键时，应该能够保存带有时间戳的快照图像。
- en: A text message should be displayed every time an image is saved.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次保存图像时，应显示一条文本消息。
- en: The application should terminate whenever we press the Esc key or the letter
    Q.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该在按下Esc键或字母Q时终止。
- en: We are creating this application to have some fundamental pieces in place that
    we can use to build more complex applications. Interacting with live video from
    the camera will give us exposure to the camera frame rates and prepare for face
    and QR code detection from a live video feed. Doing all these operations using
    OpenCV is strategic, as it is the library of choice for computer vision in Python.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个应用程序是为了放置一些基本的组件，我们可以使用这些组件来构建更复杂的应用程序。与来自相机的实时视频交互将使我们接触到相机帧率，并为从实时视频流中进行人脸和二维码检测做准备。使用OpenCV执行所有这些操作是战略性的，因为它是Python中计算机视觉的首选库。
- en: 8.3.1 Exploring the OpenCV library
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 探索OpenCV库
- en: To work with the camera in OpenCV, we will first have to enable legacy camera
    support on the Raspberry Pi. Use the `raspi-config` in a terminal and enable the
    Legacy
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OpenCV中使用相机，我们首先必须在Raspberry Pi上启用旧版相机支持。在终端中使用`raspi-config`并启用Legacy
- en: Camera option in the Interface Options menu. Figure 8.3 shows a photo of the
    Raspberry Pi Camera placed in an Adafruit camera case to protect it and make it
    easier to attach to the robot.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面选项菜单中的相机选项。图8.3显示了一台放置在Adafruit相机外壳中的Raspberry Pi相机的照片，以保护它并使其更容易连接到机器人。
- en: '![](../Images/CH08_F03_Alsabbagh.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Alsabbagh.png)'
- en: 'Figure 8.3 Raspberry Pi camera: the camera is enclosed in an Adafruit camera
    case.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 Raspberry Pi相机：相机被封装在Adafruit相机外壳中。
- en: 'The OpenCV library uses the Python NumPy library heavily. The NumPy user guide
    ([https://numpy.org/doc/stable/user/](https://numpy.org/doc/stable/user/)) is
    an excellent resource for NumPy management offering details on the installation
    procedure. As per the guide, it requires the `libatlas-base-dev` package to be
    installed before NumPy. OpenCV requires the `libgtk2.0-dev` package to support
    its graphical interface features. Run the following command to install these two
    packages:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV库大量使用Python NumPy库。NumPy用户指南([https://numpy.org/doc/stable/user/](https://numpy.org/doc/stable/user/))是一个优秀的资源，提供了关于安装程序的详细信息。根据指南，在安装NumPy之前需要安装`libatlas-base-dev`包。OpenCV需要`libgtk2.0-dev`包来支持其图形界面功能。运行以下命令来安装这两个包：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now install OpenCV with the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令安装OpenCV：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The same command also installs NumPy automatically, as it is an adjunct of OpenCV.
    OpenCV has a large code base, and its installation on the Raspberry Pi can take
    up to 70 min to complete; keep this in mind when you perform the installation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个命令也会自动安装NumPy，因为它是OpenCV的辅助工具。OpenCV有一个庞大的代码库，它在Raspberry Pi上的安装可能需要长达70分钟才能完成；在执行安装时请记住这一点。
- en: 'We can now dive right into a REPL session and start interacting with OpenCV
    and the camera. We start our adventure by first importing `cv2` and calling `VideoCapture`
    with `0` as an argument to open the default camera. We save the `VideoCapture`
    object in a variable called `cap`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以直接进入REPL会话并开始与OpenCV和相机交互。我们首先导入`cv2`，并使用`0`作为参数调用`VideoCapture`以打开默认相机。我们将`VideoCapture`对象保存在名为`cap`的变量中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can check whether the camera was initialized correctly and is open by calling
    the `isOpened` method. It will return `True` if the camera was initialized correctly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`isOpened`方法来检查相机是否正确初始化并且是打开的。如果相机正确初始化，它将返回`True`：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also inquire about different properties relating to the video capture
    device. The following session shows that the size of images to be captured is
    set at the width `640` and height `480`. We can also check the frame rate of the
    video, which is set at 30 frames per second in our case:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查询与视频捕获设备相关的不同属性。以下会话显示，要捕获的图像大小设置为宽度`640`和高度`480`。我们还可以检查视频的帧率，在我们的情况下设置为每秒30帧：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we call the `read` method to grab and decode the next video frame. It
    will return two values. The first is a Boolean value indicating whether the call
    was successful. The second value is the image itself. By inspecting the value
    of `ret`, we can see that the call was successful. If we check what data type
    `frame` is, we see it reported as a `numpy .ndarray`. This data structure is at
    the heart of NumPy and provides an n-dimensional array of data types that perform
    very efficiently:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`read`方法来抓取和解码下一个视频帧。它将返回两个值。第一个是一个布尔值，表示调用是否成功。第二个值是图像本身。通过检查`ret`的值，我们可以看到调用是成功的。如果我们检查`frame`的数据类型，我们会看到它报告为`numpy
    .ndarray`。这种数据结构是NumPy的核心，它提供了一个执行非常高效的n维数组数据类型：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Whenever we work with images in OpenCV, we will be using `ndarray` objects.
    There are some useful attributes we can inspect to get more details about the
    image we have just captured. The `shape` attribute is showing us that as expected,
    our image has a height of `480` and a width of `640`. The last part showing `3`
    indicates that it is a color image and has the three color components: red, green
    and blue. The `dtype` indicates the data type of each item in the array. The `uint8`
    data type shows that each value is an 8-bit integer, which relates to each color
    component being a value ranging from 0 to 255:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们在OpenCV中处理图像，我们都会使用`ndarray`对象。有一些有用的属性我们可以检查，以获取有关我们刚刚捕获的图像的更多详细信息。`shape`属性显示，正如预期的那样，我们的图像高度为`480`，宽度为`640`。显示`3`的最后部分表示它是一个彩色图像，并具有三个颜色组件：红色、绿色和蓝色。`dtype`表示数组中每个项的数据类型。`uint8`数据类型表明每个值是一个8位整数，这与每个颜色组件的值范围从0到255相关：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now save our image data to disk by calling the `imwrite` method with
    our filename. This method will use the file extension to encode the image data
    in the expected image format. Next, we will find an image called `photo.jpg` in
    our current directory that is a snapshot taken from the camera:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用`imwrite`方法并传入我们的文件名来将图像数据保存到磁盘。此方法将使用文件扩展名来编码图像数据为预期的图像格式。接下来，我们将在当前目录中找到一个名为`photo.jpg`的图像，这是从相机捕获的快照：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we are done working with the camera, it is always a good idea to close
    the video stream in a smooth fashion by calling the `release` method. We can see
    that the video stream state is closed when we call `isOpened` after closing the
    capture device:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成与摄像头的操作后，通过调用`release`方法以平稳的方式关闭视频流总是一个好主意。当我们关闭捕获设备后调用`isOpened`时，我们可以看到视频流状态已关闭：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This gave us some good exposure to both OpenCV and NumPy. We were able to get
    familiar with the core objects and operations required for capturing images using
    OpenCV.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们接触到了OpenCV和NumPy。我们能够熟悉使用OpenCV捕获图像所需的核心对象和操作。
- en: 8.3.2 Drawing shapes and displaying text with OpenCV
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用OpenCV绘制形状和显示文本
- en: 'When performing computer vision activities such as facial detection, it is
    very useful to be able to draw shapes, such as rectangles, over the exact parts
    of an image that has been detected. Placing text on an image is another common
    drawing operation to display a message. We will write a script to call the main
    drawing functions in OpenCV and demonstrate how they are used. First, we import
    the `string` module from the Python standard library that we will use to display
    the lowercase letters. Then we import the `cv2` and `numpy` modules:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行如人脸检测等计算机视觉活动时，能够绘制形状，如矩形，覆盖已检测图像的精确部分是非常有用的。在图像上放置文本是另一种常见的绘图操作，用于显示消息。我们将编写一个脚本，调用OpenCV的主要绘图函数，并演示它们的使用。首先，我们从Python标准库中导入`string`模块，我们将使用它来显示小写字母。然后我们导入`cv2`和`numpy`模块：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we define three colors as constants to be used for drawing our shapes.
    As in most systems, colors are represented by their red, green, and blue elements.
    Most systems use an RGB encoding, and it is important to keep in mind that the
    default color encoding in OpenCV is BGR:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义三个常量颜色，用于绘制我们的形状。在大多数系统中，颜色由它们的红色、绿色和蓝色元素表示。大多数系统使用RGB编码，并且需要记住，OpenCV中的默认颜色编码是BGR：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create a new image, we call `np.zeros`, which will create a new `ndarray`
    object filled with zero values. When all the color components of an image have
    a zero value, the color will be black. The `shape` of the array is the same as
    the one we used with the captured image from the camera. This array is a black-colored
    BGR image with a width `640` and height `480`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的图像，我们调用 `np.zeros`，这将创建一个新的 `ndarray` 对象，填充为零值。当图像的所有颜色分量都为零值时，颜色将是黑色。数组的
    `shape` 与我们从摄像头捕获的图像所使用的相同。这个数组是一个宽度为 `640` 和高度为 `480` 的黑色 BGR 图像：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now start drawing shapes on the image. The next line will draw a red
    circle with a radius of 100 px centered at the (x, y) coordinates `(200, 110)`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在图像上绘制形状。下一行将绘制一个半径为 100 px 的红色圆圈，圆心位于 `(x, y)` 坐标 `(200, 110)`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we draw a green line from the top-left part of the image at coordinates
    `(0, 0)` to the center of the circle at `(200, 110)`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从图像的左上角 `(0, 0)` 开始绘制一条绿色线条到圆的中心 `(200, 110)`：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then call `rectangle` to draw a blue box under the circle with one corner
    at `(50,` `250)` and the other at `(350,` `350)`. This creates a box with a width
    `300` and height `100`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用 `rectangle` 在圆下方绘制一个蓝色矩形框，一个角在 `(50, 250)`，另一个角在 `(350, 350)`。这创建了一个宽度为
    `300` 和高度为 `100` 的矩形框：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last thing we will place on the image is some text by calling the `putText`
    function. We will display the alphabet in lowercase letters using the `FONT_HERSHEY_SIMPLEX`
    font at the position `(10, 380)` with a normal scale and the color red:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过调用 `putText` 函数在图像上放置一些文本。我们将使用 `FONT_HERSHEY_SIMPLEX` 字体在位置 `(10, 380)`
    以正常比例和红色显示小写字母的字母表：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last two lines of the script will display the image and wait for a key
    to be pressed before exiting the application:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后两行将显示图像，并在退出应用程序之前等待按键：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The full script can be saved as `draw.py` on the Pi and then executed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `draw.py` 在 Pi 上，然后执行。
- en: 'Figure 8.1 `draw.py`: Drawing shapes of different sizes and positions using
    OpenCV'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 `draw.py`：使用 OpenCV 绘制不同大小和位置的形状
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This script will create a window, so it needs to be run in an environment that
    supports creating graphical windows. There are three options supported by OpenCV:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将创建一个窗口，因此需要在支持创建图形窗口的环境中运行。OpenCV 支持三种选项：
- en: Run the script directly on the Raspberry Pi in a desktop environment with a
    connected keyboard, mouse, and monitor.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连接了键盘、鼠标和显示器的桌面环境中直接在 Raspberry Pi 上运行脚本。
- en: Run the script remotely over VNC using a VNC viewer.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VNC 观察器远程通过 VNC 运行脚本。
- en: Run the script remotely with SSH X11 forwarding using `ssh robo@robopi` `-X`.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SSH X11 转发远程运行脚本，命令为 `ssh robo@robopi -X`。
- en: It is very handy to have multiple ways to run these graphical scripts, as you
    can choose whichever approach best suits the hardware and software you have on
    hand. Figure 8.4 shows what the window and image generated by the script will
    look like.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式运行这些图形脚本非常方便，因为你可以选择最适合你手头硬件和软件的方法。图 8.4 显示了脚本生成的窗口和图像的外观。
- en: '![](../Images/CH08_F04_Alsabbagh.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F04_Alsabbagh.png)'
- en: 'Figure 8.4 Drawing shapes: OpenCV supports drawing shapes and text on images.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 绘制形状：OpenCV 支持在图像上绘制形状和文本。
- en: Now that we have the fundamentals of drawing shapes using OpenCV out of the
    way, we can move on to the next task at hand. In the next sections, we will use
    some of these functions to help us display text in the application as we take
    snapshots.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了使用 OpenCV 绘制形状的基础，我们可以继续进行下一个任务。在接下来的几节中，我们将使用其中一些函数来帮助我们显示在应用程序中的文本，当我们进行快照时。
- en: 8.3.3 Taking snapshots with OpenCV
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 使用 OpenCV 拍照
- en: 'We have now done enough exploration to create our camera application that will
    let us take photo snapshots from the live camera video feed. We import `datetime`
    to help us generate filenames with time stamps. We also import the OpenCV module:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探索得足够多，可以创建我们的相机应用程序，它将允许我们从实时摄像头视频流中拍摄照片快照。我们导入 `datetime` 来帮助我们生成带时间戳的文件名。我们还导入了
    OpenCV 模块：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For readability, we save the key code for the escape key in a constant called
    `ESC_KEY`. We also save the color code for blue and save the font we will use
    in `FONT`. When we display text messages in the application, we will position
    them in the top left corner using `TEXT_POS`. We will be capturing and displaying
    images from the camera at the default frame rate of 30 frames per second. We want
    to show our text messages for a specific number of frames. We save this setting
    in a constant called `MSG_FRAME_COUNT`. It is set at 10 frames, so it will show
    the messages for one-third of a second:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我们将Esc键的键码保存到一个名为`ESC_KEY`的常量中。我们还保存了蓝色的颜色码，并将我们将要使用的字体保存到`FONT`中。当我们在应用程序中显示文本消息时，我们将它们定位在左上角使用`TEXT_POS`。我们将以每秒30帧的默认帧率从摄像头捕获和显示图像。我们希望显示特定的帧数文本消息。我们将此设置保存到一个名为`MSG_FRAME_COUNT`的常量中。它设置为10帧，因此将显示消息三分之一秒：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function `main` is at the heart of our application. It opens the default
    camera as a `VideoCapture` object in the variable `cap`. We then use the `assert`
    statement to make sure the camera was initialized correctly; otherwise, we exit
    with a `''Cannot` `open` `camera''` message. The `assert` statement is a great
    way to ensure certain conditions are met at different points in your program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`main`是我们应用程序的核心。它以`VideoCapture`对象的形式打开默认摄像头，并将其保存在变量`cap`中。然后我们使用`assert`语句来确保摄像头被正确初始化；否则，我们以`'Cannot
    open camera'`消息退出。`assert`语句是确保程序中不同点满足某些条件的一种很好的方式：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the same function, we then initialize the `messages` variables as an empty
    list that will store any text messages to be displayed in the application. Next,
    we enter our main event loop that calls `waitKey` during each loop. In the previous
    section, we called it with no arguments, so it would wait indefinitely until a
    key is pressed. Here, we call it as `waitKey(1)`, which will make it wait for
    1 ms and return. If a key is pressed, it will return the code of the pressed key;
    otherwise, it will return the value `-1`. Calling `waitKey` also serves the important
    purpose of fetching and handling GUI events on the window. We save the returned
    value using the Python walrus operator into the variable `key`. We then check
    whether the key pressed is either the Esc key or the letter Q. The loop is then
    exited:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，我们首先将`messages`变量初始化为一个空列表，该列表将存储要在应用程序中显示的任何文本消息。接下来，我们进入主事件循环，在每次循环中调用`waitKey`。在上一节中，我们不带参数调用它，因此它会无限期地等待直到按键。这里，我们调用它为`waitKey(1)`，这将使其等待1毫秒并返回。如果按下按键，它将返回按下的键的代码；否则，它将返回值`-1`。调用`waitKey`还起到了在窗口上获取和处理GUI事件的重要作用。我们使用Python的walrus操作符将返回值保存到变量`key`中。然后我们检查按下的键是否是Esc键或字母Q。然后退出循环：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once we enter the event loop, we capture an image from the camera and save
    it in `frame`. Like before, we use `assert` to make sure our call to `cap.read`
    was successful. If the space key was pressed, we call the `save_photo` function
    to save the image. We then call `set_message` to set the text message in the application
    to the value `''saving photo...''`. At the end of the loop, we call `show_image`
    to display the image. When the loop is exited, `cap.release` is called to close
    the video capture stream:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入事件循环，我们从摄像头捕获图像并将其保存到`frame`中。像之前一样，我们使用`assert`来确保`cap.read`的调用是成功的。如果按下空格键，我们调用`save_photo`函数来保存图像。然后我们调用`set_message`将应用程序中的文本消息设置为`'saving
    photo...'`。循环结束时，我们调用`show_image`来显示图像。当退出循环时，调用`cap.release`来关闭视频捕获流：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we define the function `save_photo` that receives the image data in an
    argument called `frame`. We generate a time stamp using `datetime.now().isoformat()`
    and replace all the occurrences of `'':''` with `''.''`. This is so that we can
    avoid putting the `:` character in the image filename. Some software does not
    play well with filenames that have colons in the filename. We then call `imwrite`
    to save the image data to the current directory with a time-stamped file name:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为`save_photo`的函数，该函数接收一个名为`frame`的参数，其中包含图像数据。我们使用`datetime.now().isoformat()`生成一个时间戳，并将所有`':'`替换为`'.'`。这样做是为了避免在图像文件名中放置`:`字符。某些软件与包含冒号的文件名不兼容。然后我们调用`imwrite`将图像数据保存到当前目录，并使用带时间戳的文件名：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now define `show_image` to display the image with the given text in `messages`.
    If `messages` has any text items, they are removed from the list by calling `pop`
    and are displayed on the image with `putText`. Then, the image is displayed by
    calling `imshow`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义 `show_image` 以显示在 `messages` 中给定文本的消息。如果 `messages` 中有任何文本项，它们将通过调用 `pop`
    从列表中删除，并使用 `putText` 在图像上显示。然后，通过调用 `imshow` 显示图像：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `set_message` is defined next. It will take the argument `text`
    and will set the contents of the `messages` list to be a list of the value `text`
    repeating 10 times as defined in the `MSG_FRAME_COUNT` variable. This will display
    that message text for 10 frames.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `set_message` 将在下面定义。它将接受参数 `text` 并将 `messages` 列表的内容设置为重复 10 次的 `text`
    值列表，正如在 `MSG_FRAME_COUNT` 变量中定义的那样。这将显示该消息文本 10 帧。
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The full script can be saved as `snapshot.py` on the Pi and then executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `snapshot.py` 并执行。
- en: 'Figure 8.2 `snapshot.py`: Taking a snapshot when the space key is pressed'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 `snapshot.py`：在按下空格键时拍摄快照
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you run this application, it will show a window with images being captured
    and displayed at a rate of 30 frames per second, which will create a live video
    feed. You can
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此应用程序时，它将显示一个窗口，以每秒 30 帧的速度捕获并显示图像，这将创建一个实时视频流。您可以
- en: wave your hands at the camera to test the latency and response of capturing
    and displaying the images in the application. Then, strike different poses and
    press the spacebar to take snapshots of each. You will find each photo saved in
    your current directory. You can then exit the application by pressing either the
    Esc key or the Q key on your keyboard. Figure 8.5 shows what the snapshot application
    will look like as a photo is being saved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在相机前挥动手臂来测试捕获和显示图像的应用程序的延迟和响应。然后，摆出不同的姿势并按下空格键来拍摄每个姿势的快照。您会发现每张照片都保存在您的当前目录中。然后，您可以通过按下键盘上的
    Esc 键或 Q 键来退出应用程序。图 8.5 显示了在保存快照时快照应用程序的外观。
- en: '![](../Images/CH08_F05_Alsabbagh.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F05_Alsabbagh.png)'
- en: 'Figure 8.5 Taking a snapshot: a photo preview is shown in the snapshot application.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 拍摄快照：在快照应用程序中显示照片预览。
- en: 8.4 Moving a camera with servos
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用伺服电机移动相机
- en: 'We will now combine OpenCV and the CRICKIT library by having OpenCV capture
    images from the camera and the CRICKIT library issue movement instructions to
    the servo motors. We need to create an application that meets the following requirements:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过 OpenCV 从相机捕获图像，并通过 CRICKIT 库向伺服电机发出运动指令来结合 OpenCV 和 CRICKIT 库。我们需要创建一个满足以下要求的应用程序：
- en: Pressing the left and right keys will pan the camera with servos in that direction.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下左键和右键将使用伺服电机在该方向平移相机。
- en: Pressing the up and down keys will tilt the camera with the servos in that direction.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下上键和下键将使用伺服电机在该方向倾斜相机。
- en: Pressing the spacebar will save a snapshot image from the camera.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下空格键将保存来自相机的快照图像。
- en: Movement and snapshot actions should be displayed as text messages in the application.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的移动和快照动作应显示为文本消息。
- en: Creating this application will let us combine the camera and motor libraries
    we have used so far to create an application that lets us control what the camera
    is pointing at using our keyboard and motors. We get a live preview of what the
    camera is seeing and then can use the keyboard to save snapshot images from the
    camera.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此应用程序将使我们能够将迄今为止使用的相机和电机库结合起来，创建一个应用程序，使我们能够通过键盘和电机控制相机指向的位置。我们可以实时预览相机所看到的内容，然后可以使用键盘保存来自相机的快照图像。
- en: 8.4.1 Exploring the servo motors with the CRICKIT library
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 使用 CRICKIT 库探索伺服电机
- en: Servo motors have a DC motor in them. They, however, also have a sensor built
    into the hardware that can detect their exact position. So unlike the DC motors
    that we have worked with in previous chapters, we can move servo motors to exact
    positions. This makes them ideal for applications such as robotic arms, where
    you want to move the arm to a specific place. The Pan-Tilt Kit that we will be
    using in this chapter comes
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机内部有一个直流电机。然而，它们还内置了一个传感器，可以检测它们的精确位置。因此，与我们在前几章中使用的直流电机不同，我们可以将伺服电机移动到精确的位置。这使得它们非常适合像机械臂这样的应用，你希望将机械臂移动到特定的位置。在本章中我们将使用的
    Pan-Tilt Kit 就是这样的设备。
- en: with two servo motors. Figure 8.6 shows a photo of the Pan-Tilt Kit. With the
    camera attached to the kit, we will be able to move the camera in many different
    directions. The bottom servo will pan the camera left and right, while the top
    servo will tilt the camera up and down. In this way, we can use the motors to
    point the camera in many different directions. It can be difficult to move the
    servos in their full range of motion with the camera attached, as the camera has
    a ribbon that isn’t always long enough for all the positions the kit will get
    in. For this reason, it is a good idea to remove the camera when you first experiment
    with the full range of motion the kit provides.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 配有两个伺服电机。图8.6显示了Pan-Tilt Kit的照片。将相机连接到套件后，我们将能够将相机移动到许多不同的方向。底部的伺服电机将使相机左右移动，而顶部的伺服电机将使相机上下倾斜。通过这种方式，我们可以使用电机将相机指向许多不同的方向。当相机连接时，移动伺服电机在其完整运动范围内可能会很困难，因为相机有一条带子，它不一定总是足够长，以适应套件可能到达的所有位置。因此，在第一次尝试套件提供的完整运动范围时，移除相机是一个好主意。
- en: '![](../Images/CH08_F06_Alsabbagh.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F06_Alsabbagh.png)'
- en: 'Figure 8.6 Adafruit Pan-Tilt Kit: the kit has two servo motors included.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 Adafruit Pan-Tilt Kit：套件包含两个伺服电机。
- en: 'We can use the read–evaluate–print loop (REPL) to dive right into the CRICKIT
    library. We first import the `crickit` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用读取-评估-打印循环（REPL）直接进入CRICKIT库。我们首先导入`crickit`模块：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The servo that will pan the kit is connected to the first servo connection
    and is accessed using `crickit.servo_1`. We move the servo by setting the angle
    we would like to position it in. By default, the CRICKIT library sets the lowest
    angle or position of a servo as `0` degrees and the highest as `180` degrees.
    We can set the servo position by setting a value to `angle`. Run the following
    in the REPL to move the servo to the lowest angle:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于平移套件的伺服电机连接到第一个伺服连接，并使用`crickit.servo_1`来访问。我们通过设置我们想要定位的角度来移动伺服电机。默认情况下，CRICKIT库将伺服电机的最低角度或位置设置为`0`度，最高设置为`180`度。我们可以通过设置`angle`的值来设置伺服电机的位置。在REPL中运行以下代码来将伺服电机移动到最低角度：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can move the motor to the middle position by setting the value to `90`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将值设置为`90`来将电机移动到中间位置：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we set the value to `180`, the servo will move to its highest position:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将值设置为`180`，伺服电机将移动到其最高位置：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we measure how far the physical servo actually moved, we will see it wasn’t
    `180` degrees. The pan servo we are using has an actual range that goes from `0`
    to `142` degrees. The CRICKIT library has a feature where we can set the actual
    real-world value on a software level. Once we do this, the angle values we set
    in software will match the real-world angle values. We now move the servo back
    to the lowest position and then set the actuation range of the servo with the
    following lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测量物理伺服电机实际移动的距离，我们会看到它不是`180`度。我们使用的平移伺服电机的实际范围是从`0`度到`142`度。CRICKIT库有一个功能，我们可以设置软件层面的实际真实世界值。一旦我们这样做，我们在软件中设置的角值将匹配真实世界的角值。我们现在将伺服电机移动回最低位置，然后使用以下行设置伺服电机的动作范围：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can again move the servo to the lowest, middle, and highest angles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将伺服电机再次移动到最低、中间和最高角度：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If, however, we try to set a value beyond the actuation range, the library
    will raise a `ValueError` exception to stop us:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试设置超出动作范围的值，库将引发一个`ValueError`异常来阻止我们：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can move the other servo as well to control the tilt position of the camera.
    The lowest tilt position is correlated with the highest angle value of `180`.
    Run the following line to set this position:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以移动另一个伺服电机来控制相机的倾斜位置。最低的倾斜位置与`180`的最高角度值相关。运行以下行来设置此位置：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The highest tilt position that would point the camera upward is correlated
    with the angle value of `90`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将相机向上指的最高倾斜位置与角度值`90`相关联：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Unlike the pan, the tilt is more limited in range, and we won’t need to set
    an actuation range for it. We now have enough info to put together a script to
    move our servos in different directions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与平移不同，倾斜的范围更有限，我们不需要为它设置一个动作范围。我们现在有足够的信息来编写一个脚本，使我们的伺服电机在不同方向上移动。
- en: 'Going Deeper: Servo motors'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：伺服电机
- en: The CRICKIT board supports many different servo motors. It can have up to four
    different servos connected at the same time. It is quite flexible in the types
    of servos you can connect, as it supports any 5V-powered servo motor. The Adafruit
    online store offers a wide range of servo motors ([https://adafruit.com/category/232](https://adafruit.com/category/232))
    in the servo section of their store. The two servos that come as part of the Pan-Tilt
    Kit used in the book are called micro servos. They are smaller and less powerful
    than other servos. The strength of a servo is specified by the servo torque rating.
    Some of the standard servo motors will have more than double the power of a micro
    servo. Depending on the weight a servo must carry or push, you might want to get
    a larger and more powerful servo.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: CRICKIT板支持许多不同的伺服电机。它可以同时连接多达四个不同的伺服电机。它在连接伺服电机的类型上非常灵活，因为它支持任何5V供电的伺服电机。Adafruit在线商店在其商店的伺服电机部分提供了一系列伺服电机（[https://adafruit.com/category/232](https://adafruit.com/category/232)）。书中使用的Pan-Tilt套件中包含的两个伺服电机被称为微型伺服电机。它们比其他伺服电机更小、功率更低。伺服电机的强度由伺服扭矩等级指定。一些标准伺服电机可能比微型伺服电机多出超过一倍的功率。根据伺服电机必须携带或推动的重量，你可能需要获得更大、更强大的伺服电机。
- en: The Motor Selection Guide ([http://mng.bz/YRRB](http://mng.bz/YRRB)) on the
    Adafruit site is a great resource for learning more about how servo motors work.
    It also provides good information on the variety of sizes, torque, and speed ratings
    of different servo motors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit网站上的《电机选择指南》（[http://mng.bz/YRRB](http://mng.bz/YRRB)）是了解伺服电机工作原理的绝佳资源。它还提供了关于不同伺服电机尺寸、扭矩和速度等级的详细信息。
- en: 8.4.2 Performing a pan-and-tilt sweep
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 执行俯仰和倾斜扫描
- en: 'Ultimately, we want to control the servo pan and tilt movements with our keyboard
    arrow keys. Something that will help us move in that direction would be to translate
    up- and down-movement requests to their associated angle changes in the tilt servo.
    Also, to do the same for the left and right movements on the pan servo, we will
    create a script that issues a bunch of movement commands in those four directions
    and then translates them to the needed servo angle changes. First, we import the
    `crickit` module to control the servos and the `time` module to pause between
    movements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望用键盘的方向键来控制伺服电机的俯仰和倾斜运动。为了朝那个方向移动，我们需要将上下移动请求转换为倾斜伺服电机的相关角度变化。同样，为了在俯仰伺服电机的左右移动上做同样的事情，我们将创建一个脚本，它发出四个方向的大量移动命令，然后将它们转换为所需的伺服角度变化。首先，我们导入`crickit`模块来控制伺服电机和`time`模块来在移动之间暂停：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We control how much of an angle change each movement will cause with `ANGLE_STEP`.
    Then we define `PAN` and `TILT` as data structures for each servo. Each one is
    a `dict` that uses `servo` to refer to its related servo motor, `min` to control
    the lowest allowed angle, and `max` to set the highest allowed motor. In the `dict`,
    the value of `start` will place the servo at that angle when the application starts,
    and `range` will be the value used to set the actuation range for that servo.
    `MOVE` maps each of the four movements to the related servo and the direction
    of movement for that servo:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ANGLE_STEP`来控制每次移动将引起的角度变化量。然后我们定义`PAN`和`TILT`作为每个伺服电机的数据结构。每个都是一个`dict`，使用`servo`来引用其相关的伺服电机，`min`来控制允许的最小角度，`max`来设置允许的最大电机。在`dict`中，`start`的值将在应用程序启动时将伺服电机放置在该角度，`range`将用于设置该伺服电机的驱动范围。`MOVE`将每个四个运动映射到相关的伺服电机和该伺服电机的移动方向：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the script starts, we call `init_motors` to set the actuation range for
    each motor and position the motor in the specified starting angle:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本开始时，我们调用`init_motors`来设置每个电机的驱动范围并将电机定位在指定的起始角度：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now define `move_motor` that will be called with one of the four accepted
    movements. It will then use the `MOVE` dictionary to look up the related servo
    and `factor` to set which way the angle will be changed. Next, we calculate `new_angle`
    that indicates what the new angle would be. We then check if the new angle is
    within the defined range of `min` and `max`. If the new angle is allowed, we apply
    it by setting the value of `angle` of the related servo:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义了`move_motor`，它将使用四种接受的运动之一被调用。然后，它将使用`MOVE`字典来查找相关的伺服电机和`factor`来设置角度变化的方向。接下来，我们计算`new_angle`，它表示新的角度。然后我们检查新角度是否在定义的`min`和`max`范围内。如果新角度是允许的，我们将通过设置相关伺服电机的`angle`值来应用它：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `main` function first calls `init_motors` to initialize each motor’s actuation
    range and starting position. We then enter a loop for 20 iterations, making the
    camera move left and up in each. We print out details of our movements in each
    loop and then pause for 0.1 seconds before performing the next iteration of movements.
    The same style of loop is performed again, but for the right and down movements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数首先调用`init_motors`来初始化每个电机的驱动范围和起始位置。然后我们进入一个循环，进行20次迭代，每次使相机向左和向上移动。我们在每个循环中打印出我们动作的详细信息，然后在执行下一次动作迭代前暂停0.1秒。同样的循环风格再次执行，但这次是向右和向下移动：'
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The full script can be saved as `pan.py` on the Pi and then executed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`pan.py`在Pi上，然后执行。
- en: 'Figure 8.3 `pan.py`: Performing pan and tilt movements with the servo motors'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 `pan.py`：使用伺服电机执行水平和倾斜运动
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we execute this script, it will run a movement demonstration of the servo
    movements. The first set of movements will move the camera left and up 20 times
    until it reaches the maximum position we have set for panning left. Then, we will
    move right and down 20 times back to our starting position. The following session
    shows the output generated by the script:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个脚本时，它将运行伺服运动的演示。第一组动作将使相机向左和向上移动20次，直到达到我们为水平移动设定的最大位置。然后，我们将向右和向下移动20次，回到起始位置。以下会话显示了脚本生成的输出：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Robots in the real world: Robotic arms'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的机器人：机械臂
- en: Servo motors are at the heart of robotic arms. The arms are made up of multiple
    joints, which give the arm full freedom of movement. The servos in this chapter
    gave the camera the ability to pan and tilt in any direction. In the case of robotic
    arms, four servos at the different joints would be enough to give the arm a full
    range of motion.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机是机械臂的核心。机械臂由多个关节组成，这赋予了机械臂完全的自由运动。本章中的伺服电机使相机能够向任何方向进行水平和倾斜。在机械臂的情况下，不同关节上的四个伺服电机就足以使机械臂具有全范围的移动能力。
- en: The article ([http://mng.bz/G99v](http://mng.bz/G99v)) on robotic arms by Intel
    covers some of the many benefits of using robotic arms in different industries,
    ranging from manufacturing to agriculture. Older robotic arms were limited in
    their applications because of the lack of computer vision in software. This means
    the arms could only pick up items placed in exact locations and in a specific
    orientation. Combining robotics with powerful computer vision software gave the
    robots the ability to detect the location of objects and adjust to different orientations.
    The applications of robotics and computer vision go hand in hand to make more
    versatile robotics solutions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔关于机械臂的文章([http://mng.bz/G99v](http://mng.bz/G99v))涵盖了使用机械臂在不同行业中的许多好处，从制造业到农业。由于软件中缺乏计算机视觉，旧的机械臂在应用上受到了限制。这意味着机械臂只能拾取放置在精确位置且具有特定方向的物品。将机器人技术与强大的计算机视觉软件相结合，使机器人能够检测物体的位置并适应不同的方向。机器人和计算机视觉的应用是相辅相成的，以创造更多样化的机器人解决方案。
- en: 8.4.3 Controlling servos and the camera together
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 同时控制伺服电机和相机
- en: 'We can now pull all our work together and create the final application that
    will let us move the camera around using our keyboard and take snapshots on command.
    We start by importing the modules we need. We use `datetime` for time stamps like
    before, `cv2` to work with the camera and keyboard, and the `crickit` module to
    control the servo motors. We will be able to reuse the functionality we have written
    in this chapter by importing the needed functions from our `snapshot` and `pan`
    modules:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有工作整合在一起，创建一个最终的应用程序，使我们能够使用键盘移动相机并在命令下拍照。我们首先导入所需的模块。我们使用`datetime`来处理时间戳，就像之前一样，使用`cv2`与相机和键盘一起工作，以及`crickit`模块来控制伺服电机。我们将能够通过从我们的`snapshot`和`pan`模块中导入所需函数来重用本章中编写的功能：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ESC_KEY` value is the key code for the Esc key, as we have seen before.
    The `ARROW_KEYS` dictionary will be used to map the key codes for the arrow keys
    to their related key names. The names of the keys also directly pair up with our
    four supported movement actions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ESC_KEY`值是Esc键的键码，就像我们之前看到的那样。`ARROW_KEYS`字典将用于将箭头键的键码映射到它们相关的键名。键的名称也直接与我们的四个支持的动作相对应：'
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `handle_key` function will handle any key press events that occur. If the
    key pressed is the spacebar, the `save_photo` function will be called so as to
    save a snapshot. If one of the arrow keys is pressed, the `move_motor` function
    will be called with the associated key name that was pressed. After handling each
    of these key events, the `set_message` function will be called to update the text
    message displayed in the application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_key` 函数将处理发生的任何按键事件。如果按下的键是空格键，则将调用 `save_photo` 函数以保存快照。如果按下了箭头键之一，则将调用
    `move_motor` 函数，并带有按下的相关键名。处理完这些按键事件后，将调用 `set_message` 函数来更新应用程序中显示的文本消息：'
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, the `main` function will first call `init_motors` to initialize the
    servo motors. Then, the video capture device will be created, and the `messages`
    list will be initialized. At this point, we enter our main event loop, which loops
    until the Esc or Q key is pressed. In each loop, a frame will be captured from
    the camera, and `handle_key` will be called to process any keyboard events. The
    last part of the loop is to call `show_image` to display the latest captured image
    and any text messages. When this loop is exited, `cap.release` is called to release
    the video capture device:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数将首先调用 `init_motors` 来初始化伺服电机。然后，将创建视频捕获设备，并初始化 `messages` 列表。此时，我们进入主事件循环，该循环将一直持续到按下
    Esc 或 Q 键。在每次循环中，将从相机捕获一帧，并调用 `handle_key` 来处理任何键盘事件。循环的最后部分是调用 `show_image` 来显示最新捕获的图像和任何文本消息。当退出此循环时，将调用
    `cap.release` 来释放视频捕获设备：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The full script can be saved as `servocam.py` on the Pi and then executed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `servocam.py` 并执行。
- en: 'Figure 8.4 `servocam.py`: Controlling camera position with a keyboard'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 `servocam.py`：使用键盘控制相机位置
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When we run this script, the pan and tilt servos will move to their starting
    positions. You can now press the left and right arrow keys to pan the camera.
    Pressing the up and down keys will tilt the camera up and down. Experiment with
    panning and tilting to the furthest acceptable positions. The script will detect
    and reach these limits safely without going beyond the allowed servo angles. Press
    the spacebar at different angles to take snapshots at different camera positions.
    Figure 8.7 shows the message that is displayed when the tilt on the camera is
    moved upward.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此脚本时，云台伺服将移动到起始位置。现在您可以按左右箭头键来平移相机。按上下键将相机上下倾斜。尝试将相机平移和倾斜到最远可接受的位置。脚本将检测并安全地到达这些极限，而不会超出允许的伺服角度。在不同的角度按空格键以在不同相机位置拍摄快照。图
    8.7 显示了当相机倾斜向上移动时显示的消息。
- en: '![](../Images/CH08_F07_Alsabbagh.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F07_Alsabbagh.png)'
- en: 'Figure 8.7 Moving the camera: a text message is shown when a camera movement
    action is taken.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 移动相机：当执行相机移动操作时显示文本消息。
- en: By creating this application, we have learned how to react to keyboard events
    to control our robot motor and camera hardware, perform motor movements, and capture
    images from the camera using different keyboard control keys.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建此应用程序，我们学习了如何响应键盘事件来控制我们的机器人电机和相机硬件，执行电机运动，并使用不同的键盘控制键从相机捕获图像。
- en: 'Going Deeper: Robot kinematics'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：机器人运动学
- en: As you create robot projects that incorporate many servo motors acting as joints
    in a robotic arm, the field of robot kinematics has become increasingly important.
    By creating a model that incorporates the length of each link in the robotic arm
    and where each joint is, we can calculate at what angles to set each of our servos
    to move the robotic arm into different positions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您创建包含许多作为机器人臂关节的伺服电机的机器人项目，机器人运动学的领域变得越来越重要。通过创建一个包含机器人臂中每个连杆的长度以及每个关节位置的模式，我们可以计算出将每个伺服设置到什么角度，以将机器人臂移动到不同的位置。
- en: Forward kinematics work by taking the angle of each servo joint and then calculating
    where they would position the servo arm. Inverse kinematics work in reverse by
    taking a desired end position of the robotic arm and calculating what joint movements
    are required to get the arm into that position.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 前向运动学通过获取每个伺服关节的角度，然后计算伺服臂将放置的位置来工作。逆运动学通过取机器人臂的期望末端位置并计算将手臂移动到该位置所需的关节运动来反向工作。
- en: The Robotic Systems Guide ([https://motion.cs.illinois.edu/RoboticSystems](https://motion.cs.illinois.edu/RoboticSystems))
    by the University of Illinois at Urbana-Champaign provides an excellent reference
    on the topic of robot kinematics. Chapters 5 and 6 are dedicated to the topics
    of forward and inverse kinematics. The mathematical equations behind these calculations
    are presented with detailed visual diagrams of the robotic arms.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 伊利诺伊大学香槟分校的《机器人系统指南》([https://motion.cs.illinois.edu/RoboticSystems](https://motion.cs.illinois.edu/RoboticSystems))提供了关于机器人运动学的优秀参考资料。第5章和第6章专门讨论了正向和逆向运动学。这些计算背后的数学方程式通过详细的机器人臂视觉图进行展示。
- en: An interesting application of kinematics is creating a type of robot called
    a SCARA robot that only moves in the X–Y direction. This limitation makes the
    kinematics calculations simpler and requires fewer servo motors to create a functioning
    robot. The SCARA robot project ([http://mng.bz/z00B](http://mng.bz/z00B)) on the
    Instructables website uses servo motors like the ones covered in this book to
    create this robot. Only two servo motors are required to move the robotic arm
    in the X–Y direction. One additional servo is used to lower and raise the pen
    for drawing operations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学的一个有趣应用是创建一种名为SCARA机器人的机器人，它只能在X-Y方向上移动。这种限制使得运动学计算更简单，并且需要更少的伺服电机来创建一个功能性的机器人。Instructables网站上的SCARA机器人项目([http://mng.bz/z00B](http://mng.bz/z00B))使用本书中介绍过的伺服电机来创建这个机器人。仅需要两个伺服电机来在X-Y方向上移动机械臂。一个额外的伺服电机用于降低和提升笔进行绘图操作。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: There is a dedicated servo to perform the tilt movement on the camera.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相机上执行倾斜运动的专用伺服电机。
- en: The OpenCV library is used to interact with the Linux kernel video subsystem.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV库用于与Linux内核视频子系统交互。
- en: The data structures in the NumPy library are heavily used in the OpenCV library.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy库中的数据结构在OpenCV库中被广泛使用。
- en: Placing text on an image is one of the common drawing operations to display
    a message in an OpenCV application.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像上放置文本是OpenCV应用程序中常见的绘图操作之一，用于显示消息。
- en: The Raspberry Pi camera will capture video images at the default frame rate
    of 30 frames per second.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi相机将以默认的每秒30帧的帧率捕获视频图像。
- en: Unlike DC motors, we can move servo motors to exact positions because of their
    hardware sensors.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与直流电机不同，由于它们的硬件传感器，我们可以将伺服电机移动到精确的位置。
