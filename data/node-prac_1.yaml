- en: Part 2\. Real-world recipes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分. 真实世界配方
- en: In the first section of this book, we took a deep dive into Node’s standard
    library. Now we’ll take a broader look at real-world recipes many Node programs
    encounter. Node is most famously known for writing fast network-based programs
    (high-performance HTTP parsing, ease-of-use frameworks like Express), so we devoted
    a whole chapter to web development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，我们深入探讨了Node的标准库。现在，我们将更广泛地查看许多Node程序会遇到的真实世界配方。Node最著名的是编写快速基于网络的程序（高性能HTTP解析，易于使用的框架如Express），因此我们专门用了一章来介绍Web开发。
- en: In addition, there are chapters to help you grasp what a Node program is doing
    preemptively with tests, and post-mortem with debugging. In closing, we set you
    up for success when deploying your applications to production environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有章节帮助你通过测试预先了解Node程序的行为，以及通过调试进行事后分析。最后，我们为你部署应用程序到生产环境做好准备。
- en: 'Chapter 9\. The Web: Build leaner and meaner web applications'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 网络：构建更精简、更强大的Web应用程序
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Node for client-side development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node进行客户端开发
- en: Node in the browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器中的节点
- en: Server-side techniques and WebSockets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端技术及WebSocket
- en: Migrating Express 3 applications to Express 4
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Express 3应用程序迁移到Express 4
- en: Testing web applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Web应用程序
- en: Full-stack frameworks and real-time services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈框架和实时服务
- en: The purpose of this chapter is to bring together the things you’ve learned about
    networking, buffers, streams, and testing to write better web applications with
    Node. There are practical techniques for browser-based JavaScript, server-side
    code, and testing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是将你关于网络、缓冲区、流和测试的知识结合起来，用Node编写更好的Web应用程序。这里有基于浏览器的JavaScript、服务器端代码和测试的实用技术。
- en: Node can help you to write better web applications, no matter what your background
    is. If you’re a client-side developer, then you’ll find it can help you work more
    efficiently. You can use it for preprocessing client-side assets and for managing
    client-side workflows. If you’ve ever wanted to quickly spin up an HTTP server
    that builds your CSS or CoffeeScript for a single-page web app, or even just a
    website, then Node is a great choice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node可以帮助你编写更好的Web应用程序，无论你的背景如何。如果你是客户端开发者，你会发现它可以帮助你更高效地工作。你可以用它来预处理客户端资源和管理客户端工作流程。如果你曾经想要快速启动一个HTTP服务器来构建单页Web应用程序的CSS或CoffeeScript，或者甚至只是一个网站，那么Node是一个很好的选择。
- en: The previous book in this series, *Node.js in Action*, has a detailed introduction
    to web development with Connect and Express, and also templating languages like
    Jade and EJS. In this chapter we’ll build on some of these ideas, so if you’re
    completely new to Node, we recommend reading *Node.js in Action* as well. If you’re
    already using Express, then we hope you’ll find something new in this chapter;
    we’ve included techniques for structuring Express applications to make them easier
    to scale as your projects grow and mature.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的前一本书《Node.js实战》详细介绍了使用Connect和Express进行Web开发，以及像Jade和EJS这样的模板语言。在本章中，我们将在此基础上构建一些想法，因此如果你是Node的完全新手，我们建议你也阅读《Node.js实战》。如果你已经在使用Express，那么我们希望你在本章中能找到一些新内容；我们包括了结构化Express应用程序的技术，以便随着项目的增长和成熟，使它们更容易扩展。
- en: The first section in this chapter has some techniques that focus on the browser.
    If you’re a perplexed front-end developer who’s been using Node because your client-side
    libraries need it, then you should start here. If you’re a server-side developer
    who wants to bring Node to the browser, then skip ahead to [technique 66](#ch09lev2sec3)
    to see how to use Node modules in the browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一节介绍了一些关注浏览器的技术。如果你是一个困惑的前端开发者，因为你的客户端库需要Node而使用Node，那么你应该从这里开始。如果你是一个希望将Node引入浏览器的服务器端开发者，那么请跳到[技术66](#ch09lev2sec3)以了解如何在浏览器中使用Node模块。
- en: 9.1\. Front-end techniques
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 前端技术
- en: This section is all about Node and its relationship to client-side technology.
    You’ll see how to use the DOM in Node and Node in the DOM, and run your own local
    development servers. If you’ve come to Node from a web design background, then
    these techniques should help you get into the swing of things before we dive in
    to deeper server-side examples. But if you’re from a server-side background, then
    you might like to see how Node can help automate front-end chores.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节全部关于Node及其与客户端技术的关系。你将看到如何在Node中使用DOM，以及如何在DOM中使用Node，并运行你自己的本地开发服务器。如果你是从网页设计背景来到Node的，那么这些技术应该能帮助你在我们深入服务器端示例之前，快速进入状态。但如果你是从服务器端背景来的，你可能想看看Node如何帮助自动化前端任务。
- en: The first technique shows you how to create a quick, static server for simple
    websites or single-page web applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种技术展示了如何创建一个快速、静态的服务器，用于简单的网站或单页网页应用。
- en: Technique 64 Quick servers for static sites
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧64 静态站点的快速服务器
- en: Sometimes you just want to start a web server to work on a static site, or a
    single-page web application. Node’s a good choice for this, because it’s easy
    to get a web server running. It can also neatly encapsulate client-side workflows,
    making it easier to collaborate with others. Rather than manually running programs
    over your client-side JavaScript and CSS, you can write Node programs that you
    can share with other people.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你只是想启动一个网络服务器来工作于静态网站或单页网页应用。Node是这一选择的好选择，因为它很容易启动网络服务器。它还可以很好地封装客户端工作流程，使得与他人协作更容易。你不必手动运行客户端JavaScript和CSS上的程序，而是可以编写其他人可以共享的Node程序。
- en: 'This technique introduces three solutions for starting up a web server: a short
    Connect script, a command-line web server, and a mini–build system that uses Grunt.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术介绍了三种启动网络服务器的方法：一个简短的Connect脚本、一个命令行网络服务器，以及一个使用Grunt的迷你构建系统。
- en: Problem
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to quickly start a web server so you can develop a static site, or
    a single-page application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要快速启动一个网络服务器，以便开发静态网站或单页应用。
- en: Solution
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Connect, a command-line web server, or a client-side workflow tool like
    Grunt.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Connect，一个命令行网络服务器，或者像Grunt这样的客户端工作流程工具。
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Plain old HTML, JavaScript, CSS, and images can be viewed in a browser without
    a server. But because most web development tasks end up with files on a server
    somewhere, you often need a server just to make a static site. It’s a chore, but
    it doesn’t need to be! The power of browsers also means you can create sophisticated
    web applications by contacting external web APIs: single-page web applications,
    or so-called *serverless apps*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的HTML、JavaScript、CSS和图片可以在没有服务器的情况下通过浏览器查看。但因为在大多数网页开发任务中，文件最终都会出现在某个服务器上，所以你通常需要一个服务器来制作静态网站。这是一项繁琐的任务，但并不需要这样！浏览器的能力也意味着你可以通过调用外部网页API来创建复杂的网页应用：单页网页应用，或所谓的*无服务器应用*。
- en: In the case of serverless web applications, you can work more efficiently by
    using build tools to preprocess and package client-side assets. This technique
    will show you how to start a web server for developing static sites, and also
    how to use tools like Grunt to get a small project going without too much trouble.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器网页应用的情况下，你可以通过使用构建工具来预处理和打包客户端资源，从而更高效地工作。这项技术将向你展示如何启动一个用于开发静态站点的网络服务器，以及如何使用像Grunt这样的工具轻松启动一个小项目，而不会遇到太多麻烦。
- en: Although you could use Node’s built in `http` module to serve static sites,
    it’s a lot of work. You’ll need to do things like detect the content type of each
    file to send the right HTTP headers. While the `http` core module is a solid foundation,
    you can save time by using a third-party module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用Node内置的`http`模块来提供静态网站，但这需要做很多工作。你需要做诸如检测每个文件的内容类型并发送正确的HTTP头信息等事情。虽然`http`核心模块是一个坚实的基础，但你可以通过使用第三方模块来节省时间。
- en: First, let’s look at how to start a web server with Connect, the HTTP middleware
    module used to create the popular Express web framework. The first listing demonstrates
    just how simple this is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何使用Connect，即用于创建流行的Express网页框架的HTTP中间件模块，来启动一个网络服务器。第一个列表展示了这有多么简单。
- en: Listing 9.1\. A quick static web server
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1. 快速静态网络服务器
- en: '![](201fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](201fig01_alt.jpg)'
- en: 'To use the example in [listing 9.1](#ch09ex01), you’ll need to install Connect.
    You can do that by running `npm install connect`, but it’s a better idea to create
    a package.json file so it’s easier for other people to see how your project works.
    Even if your project is a simple static site, creating a package.json file will
    help your project to grow in the future. All you need to do is memorize these
    commands: `npm init` and `npm install --save connect`. The first command creates
    a manifest file for the current directory, and the second will install Connect
    and save it to the list of dependencies in the new package.json file. Learn these
    and you’ll be creating new Node projects in no time.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 [列表 9.1](#ch09ex01) 中的示例，你需要安装 Connect。你可以通过运行 `npm install connect` 来完成，但创建一个
    package.json 文件会更好，这样其他人更容易了解你的项目是如何工作的。即使你的项目是一个简单的静态网站，创建一个 package.json 文件也会帮助你的项目在未来成长。你需要记住的命令只有这些：`npm
    init` 和 `npm install --save connect`。第一个命令为当前目录创建一个清单文件，第二个命令将安装 Connect 并将其保存到新的
    package.json 文件中的依赖列表中。记住这些，你将很快就能创建新的 Node 项目。
- en: The `createServer` method ![](1.jpg) is derived from Node’s `http.createServer`,
    but it’s wrapped with a few things that Connect adds behind the scenes. The `static`
    server middleware component ![](2.jpg) is used to serve files from the current
    directory (`__dirname` with two underscores means “current directory”), but you
    can change the directory if you like. For example, if you have client-side assets
    in public/, then you can use `connect.static(__dirname + '/public')` instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`createServer` 方法 ![](1.jpg) 是从 Node 的 `http.createServer` 衍生出来的，但它被 Connect
    在幕后添加的一些东西所包装。用于服务当前目录中文件的 `static` 服务器中间件组件 ![](2.jpg) 被用来从当前目录 (`__dirname`
    有两个下划线表示“当前目录”）中提供文件，但如果你愿意，你也可以更改目录。例如，如果你在 public/ 中有客户端资源，那么你可以使用 `connect.static(__dirname
    + ''/public'')`。'
- en: Finally, the server is set to listen on port 8080 ![](3.jpg). That means if
    you run this script and visit http://localhost:8080/file.html in a browser, you
    should see file.html.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务器被设置为监听端口 8080 ![](3.jpg)。这意味着如果你运行这个脚本并在浏览器中访问 http://localhost:8080/file.html，你应该能看到
    file.html。
- en: If you’ve been sent a bunch of HTML files from a designer, and you want to use
    a server to view them because they make use of paths to images and CSS files with
    a leading forward slash (/), then you can also use a command-line web server.
    There are many of these available on npm, and they all support different options.
    One example is `glance` by Jesse Keane. You can find it on GitHub at [https://github.com/jarofghosts/glance](https://github.com/jarofghosts/glance),
    and on npm as `glance`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从设计师那里收到了一堆 HTML 文件，并且你想使用服务器来查看它们，因为它们使用了以斜杠 (/) 开头的图像和 CSS 文件路径，那么你也可以使用命令行网络服务器。npm
    上有这些服务器，它们都支持不同的选项。一个例子是 Jesse Keane 的 `glance`。你可以在 GitHub 上找到它 [https://github.com/jarofghosts/glance](https://github.com/jarofghosts/glance)，以及在
    npm 上作为 `glance`。
- en: To use `glance` on the command line, navigate to a directory where you have
    some HTML files that you want to look at. Then install `glance` systemwide with
    `npm install --global glance`, and type `glance`. Now go to http://localhost:61403/file,
    where *file* is a file you want to look at, and you should see it in your browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行上使用 `glance`，请导航到包含你想要查看的 HTML 文件的目录。然后全局安装 `glance`，使用 `npm install --global
    glance`，并输入 `glance`。现在访问 http://localhost:61403/file，其中 *file* 是你想要查看的文件，你应该能在浏览器中看到它。
- en: '`glance` can be configured in various ways—you can change the port from 61403
    to something else with `--port`, and specify the directory to be served with `--dir`.
    Type `--help` to get a list of options. It also has some nice defaults for things
    like 404s—[figure 9.1](#ch09fig01) shows what a 404 looks like.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`glance` 可以通过多种方式配置——你可以使用 `--port` 将端口从 61403 改为其他值，并使用 `--dir` 指定要服务的目录。输入
    `--help` 获取选项列表。它还有一些关于 404 错误的默认设置——[图 9.1](#ch09fig01) 展示了 404 错误的样貌。'
- en: Figure 9.1\. Glance has built-in pages for errors.
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. Glance 内置了错误页面。
- en: '![](09fig01_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01_alt.jpg)'
- en: 'The third way of running a web server is to use a task runner like Grunt. This
    allows you to automate your client-side tasks in a way that others can replicate.
    Using Grunt is a bit like a combination of the previous two approaches: it requires
    a web server module like Connect, and a command-line tool.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行网络服务器的第三种方式是使用像 Grunt 这样的任务运行器。这允许你以其他人可以复制的方式自动化客户端任务。使用 Grunt 有点像前两种方法的结合：它需要一个像
    Connect 这样的网络服务器模块和一个命令行工具。
- en: 'To use Grunt for a client-side project you’ll need to do three things:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Grunt 为客户端项目，你需要做三件事：
- en: '**1**.  Install the `grunt-cli` module.'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 安装 `grunt-cli` 模块。'
- en: '**2**.  Make a package.json to manage the dependencies for your project.'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 创建一个 package.json 文件来管理您项目的依赖关系。'
- en: '**3**.  Use a Grunt plugin that runs a web server.'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 使用一个运行 Web 服务器的 Grunt 插件。'
- en: 'The first step is easy: install `grunt-cli` as a global module with `npm install
    -g grunt-cli`. Now you can run Grunt tasks from any project that includes them
    by typing `grunt`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单：使用 `npm install -g grunt-cli` 将 `grunt-cli` 作为全局模块安装。现在您可以从包含它们的任何项目中运行
    Grunt 任务，只需输入 `grunt` 即可。
- en: 'Next, make a new directory for your project. Change to this new directory and
    type `npm init`—you can press Return to accept each of the defaults. Now you need
    to install a web server module: `npm install --save-dev grunt grunt-contrib-connect`
    will do the job.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为您的项目创建一个新的目录。切换到这个新目录并输入 `npm init`——您可以按 Return 键接受每个默认值。现在您需要安装一个 Web
    服务器模块：`npm install --save-dev grunt grunt-contrib-connect` 就可以完成这项工作。
- en: 'The previous command also installed `grunt` as a development dependency. The
    reason for this is it locks Grunt to the current version—if you look at package.json
    you’ll see something like `"grunt": "~0.4.2"`, which means Grunt was installed
    first at `0.4.2`, but newer versions on the `0.4` branch will be used in the future.
    The popularity of modules like Grunt forced npm to support something known as
    *peer dependencies*. Peer dependencies allow Grunt plugins to express a dependency
    on a specific version of Grunt, so the Connect module we’ll use actually has a
    `peerDependencies` property in its package.json file. The benefit of this is you
    can be sure plugins will work as Grunt changes—otherwise, as Grunt’s API changes,
    plugins might just break with no obvious cause.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '之前的命令还安装了 `grunt` 作为开发依赖。这样做的原因是它将 Grunt 锁定在当前版本——如果您查看 package.json，您会看到类似
    `"grunt": "~0.4.2"` 的内容，这意味着 Grunt 首次安装的版本是 `0.4.2`，但在未来的 `0.4` 分支上将会使用新版本。Grunt
    等模块的流行迫使 npm 支持一种称为 *依赖关系 peer* 的功能。依赖关系 peer 允许 Grunt 插件表达对 Grunt 特定版本的依赖，因此我们将使用的
    Connect 模块实际上在其 package.json 文件中有一个 `peerDependencies` 属性。这种做法的好处是您可以确信插件将在 Grunt
    变化时正常工作——否则，随着 Grunt API 的变化，插件可能会突然中断，而没有任何明显的原因。'
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Alternatives to Grunt
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grunt 的替代方案
- en: At the time of writing, Grunt was the most popular build system for Node. But
    new alternatives have appeared and are rapidly gaining adoption. One example is
    Gulp ([http://gulpjs.com/](http://gulpjs.com/)), which takes advantage of Node’s
    streaming APIs and has a light syntax that is easy to learn.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Grunt 是 Node 最受欢迎的构建系统。但新的替代方案已经出现，并且正在迅速获得采用。一个例子是 Gulp ([http://gulpjs.com/](http://gulpjs.com/))，它利用了
    Node 的流式 API，并且语法轻量，易于学习。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In case all this is new to you, we’ve included a screenshot of what your project
    should look like in [figure 9.2](#ch09fig02).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切对您来说都是新的，我们包括了您项目应该看起来像的截图 [图 9.2](#ch09fig02)。
- en: Figure 9.2\. Projects that use Grunt typically have a package.json and a Gruntfile.js.
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. 使用 Grunt 的项目通常有一个 package.json 和一个 Gruntfile.js。
- en: '![](09fig02_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![09fig02_alt.jpg](09fig02_alt.jpg)'
- en: Now that we have a fresh project set up, the final thing to do is create a file
    called Gruntfile.js. This file contains a list of tasks that `grunt` will run
    for you. The next listing shows an example that uses the `grunt-contrib-connect`
    module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个新的项目，最后要做的就是创建一个名为 Gruntfile.js 的文件。这个文件包含了一组 `grunt` 将为您运行的任务列表。接下来的列表展示了一个使用
    `grunt-contrib-connect` 模块的示例。
- en: Listing 9.2\. A Gruntfile for serving static files
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 用于服务静态文件的 Gruntfile
- en: '![](204fig01_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![204fig01_alt.jpg](204fig01_alt.jpg)'
- en: You should also create a directory called `public` with an index.html file—the
    HTML file can contain anything you like. After that, type `grunt connect` from
    the same directory as your Gruntfile.js, and the server should start. You can
    also type `grunt` by itself, because we set the default task to `connect:server`
    ![](4.jpg).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该创建一个名为 `public` 的目录，并包含一个 index.html 文件——这个 HTML 文件可以包含您喜欢的内容。之后，从与 Gruntfile.js
    相同的目录中输入 `grunt connect`，服务器应该会启动。您也可以直接输入 `grunt`，因为我们已经将默认任务设置为 `connect:server`
    ![4.jpg](4.jpg)。
- en: Gruntfiles use Node’s standard module system, and receive an object called `grunt`
    ![](1.jpg) that can be used to define tasks. Plugins are loaded with `grunt.loadNpmTasks`,
    allowing you to reference modules installed with npm ![](2.jpg). Most plugins
    have different options, and these are set by passing objects to `grunt.initConfig`—we’ve
    defined a server port and base path, which you can change by modifying the `base`
    property ![](3.jpg).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Gruntfile 使用 Node 的标准模块系统，并接收一个名为 `grunt` 的对象，可以用来定义任务。插件通过 `grunt.loadNpmTasks`
    加载，允许您引用使用 npm 安装的模块 ![1.jpg](1.jpg)。大多数插件都有不同的选项，这些选项通过传递对象给 `grunt.initConfig`
    来设置——我们已经定义了服务器端口和基本路径，您可以通过修改 `base` 属性来更改它们 ![2.jpg](2.jpg)。
- en: Using Grunt to start a web server is more work than writing a tiny Connect script
    or running `glance`, but if you take a look at Grunt’s plugin list ([http://gruntjs.com/plugins](http://gruntjs.com/plugins)),
    you’ll see over 2,000 entries that cover everything from building optimized CSS
    files to Amazon S3 integration. If you’ve ever needed to concatenate client-side
    JavaScript or generate image sprites, then chances are there’s a plugin that will
    help you automate it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Grunt启动Web服务器比编写一个微小的Connect脚本或运行`glance`要麻烦，但如果你看看Grunt的插件列表([http://gruntjs.com/plugins](http://gruntjs.com/plugins))，你会看到超过2,000个条目，涵盖了从构建优化的CSS文件到Amazon
    S3集成的所有内容。如果你曾经需要连接客户端JavaScript或生成图像精灵，那么很可能有一个插件可以帮助你自动化这个过程。
- en: In the next technique you’ll learn how to reuse client-side code in Node. We’ll
    also show you how to render web content inside Node processes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技术中，你将学习如何在Node中重用客户端代码。我们还将向你展示如何在Node进程中渲染网页内容。
- en: Technique 65 Using the DOM in Node
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧65 在Node中使用DOM
- en: With a bit of work, it’s possible to simulate a browser in Node. This is useful
    if you want to make web scrapers—programs that convert web pages into structured
    content. This is technically rather more complicated than it may seem. Browsers
    don’t just provide JavaScript runtimes; they also have Document Object Model (DOM)
    APIs that don’t exist in Node.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些工作，在Node中模拟浏览器是可能的。如果你想要制作网络爬虫——将网页转换为结构化内容的程序，这很有用。从技术上讲，这比看起来要复杂得多。浏览器不仅提供JavaScript运行时，还有在Node中不存在的文档对象模型（DOM）API。
- en: Such a rich collection of libraries has evolved around the DOM that it’s sometimes
    hard to imagine solving problems without them. If only there were a way to run
    libraries like jQuery inside Node! In this technique you’ll learn how to do this
    by using browser JavaScript in a Node program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕DOM的如此丰富的库集合有时很难想象没有它们就能解决问题。如果有一种方法可以在Node中运行像jQuery这样的库就好了！在这个技巧中，你将学习如何通过在Node程序中使用浏览器JavaScript来实现这一点。
- en: Problem
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to reuse client-side code that depends on the DOM in Node, or render
    entire web pages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在Node中重用依赖于DOM的客户端代码，或者渲染整个网页。
- en: Solution
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a third-party module that provides a DOM layer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供DOM层的第三方模块。
- en: Discussion
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The W3C DOM is a well-defined standard. When designers struggle with browser
    incompatibilities, they’re often dealing with the fact that standards require
    a degree of interpretation, and browser manufacturers have naturally interpreted
    the standards slightly differently. If your goal is just to run JavaScript that
    depends on the JavaScript DOM APIs, then you’re in luck: these standards can be
    re-created well enough that you can run popular client-side libraries in Node.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: W3C DOM是一个定义良好的标准。当设计师在与浏览器不兼容性作斗争时，他们通常在处理这样一个事实：标准需要一定程度的解释，浏览器制造商自然会对标准进行略微不同的解释。如果你的目标只是运行依赖于JavaScript
    DOM API的JavaScript，那么你很幸运：这些标准可以很好地重新创建，这样你就可以在Node中运行流行的客户端库。
- en: 'One early solution to this problem was `jsdom` ([https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom)).
    This module accepts an *environment* specification and then provides a `window`
    object. If you install it with `npm install -g jsdom`, you should be able to run
    the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的早期方案之一是`jsdom`([https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom))。此模块接受一个*环境*规范，然后提供一个`window`对象。如果你使用`npm
    install -g jsdom`安装它，你应该能够运行以下示例：
- en: '![](205fig01_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](205fig01_alt.jpg)'
- en: 'This example takes in HTML ![](1.jpg), fetches some remote scripts ![](2.jpg),
    and then gives you a `window` object that looks a lot like a browser `window`
    object ![](3.jpg). It’s good enough that you can use jQuery to manipulate the
    HTML snippet—jQuery works as if it’s running in a browser. This is useful because
    now you can write scripts that process HTML documents in the way you’re probably
    used to: rather than using a parser, you can query and manipulate HTML using the
    tools you’re familiar with. This is amazing for writing succinct code for tasks
    like web scraping, which would otherwise be frustrating and tedious.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例接受HTML ![](1.jpg)，获取一些远程脚本 ![](2.jpg)，然后给你一个看起来非常像浏览器`window`对象的`window`对象
    ![](3.jpg)。它足够好，以至于你可以使用jQuery来操作HTML片段——jQuery就像在浏览器中运行一样工作。这很有用，因为现在你可以编写处理HTML文档的脚本，就像你可能习惯的那样：而不是使用解析器，你可以使用你熟悉的工具查询和操作HTML。这对于编写像网络爬虫这样的简洁代码非常有用，否则这将是令人沮丧和繁琐的。
- en: Others have iterated on jsdom’s approach, simplifying the underlying dependencies.
    If you really just want to process HTML in a jQuery-like way, then you could use
    `cheerio` ([https://npmjs.org/package/cheerio](https://npmjs.org/package/cheerio)).
    This module is more suited to web scraping, so if you’re writing something that
    downloads, processes, and indexes HTML, then `cheerio` is a good choice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人对jsdom的方法进行了迭代，简化了底层依赖。如果你真的只想以jQuery类似的方式处理HTML，那么你可以使用`cheerio` ([https://npmjs.org/package/cheerio](https://npmjs.org/package/cheerio))。这个模块更适合网页抓取，所以如果你正在编写下载、处理和索引HTML的内容，那么`cheerio`是一个不错的选择。
- en: In the following example, you’ll see how to use `cheerio` to process HTML from
    a real web page. The actual HTML is from manning.com/index.html, but as designs
    change frequently, we’ve kept a copy of the page we used in our code samples.
    You can find it in cheerio-manning/index.html. The following listing opens the
    HTML file and queries it using a CSS selector, courtesy of `cheerio`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你将看到如何使用`cheerio`处理来自真实网页的HTML。实际的HTML来自manning.com/index.html，但由于设计经常变化，我们在代码示例中保留了一份页面的副本。你可以在cheerio-manning/index.html中找到它。下面的列表打开HTML文件，并使用CSS选择器查询它，这是由`cheerio`提供的。
- en: Listing 9.3\. Scraping a web page with `cheerio`
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 使用`cheerio`抓取网页
- en: '![](206fig01_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](206fig01_alt.jpg)'
- en: The HTML is loaded with `fs.readFile`. If you were doing this for real then
    you’d probably want to download the page using HTTP—feel free to replace `fs.readFile`
    with `http.get` to fetch Manning’s index page over the network. We have a detailed
    example of `http.get` in [chapter 7](kindle_split_016.html#ch07), [technique 51](kindle_split_016.html#ch07lev2sec10),
    “Following redirects.”
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fs.readFile`加载HTML。如果你真的要这样做，你可能想要使用HTTP下载页面——你可以自由地将`fs.readFile`替换为`http.get`来通过网络获取Manning的索引页面。我们在第7章（kindle_split_016.html#ch07）、技术51（kindle_split_016.html#ch07lev2sec10）“跟随重定向”中有一个详细的`http.get`示例。
- en: Once the HTML has been fetched, it’s passed to `cheerio.load` ![](1.jpg). Setting
    the result as a variable called `$` is just a convention that will make your code
    easier to read if you’re used to jQuery, but you could name it something else.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦HTML被获取，它就会被传递给`cheerio.load` ![](1.jpg)。将结果设置为名为`$`的变量只是一种约定，如果你习惯了jQuery，这将使你的代码更容易阅读，但你也可以给它起其他名字。
- en: Now that everything is set up, you can query the HTML; `$('.Releases a strong')`
    is used ![](2.jpg) to query the document for the latest books that have been released.
    They’re in a `div` with a class of `Releases`, as anchor tags.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，你可以查询HTML；使用`$('.Releases a strong')` ![](2.jpg)来查询文档中最新发布的书籍。它们位于一个带有`Releases`类的`div`中，作为锚标签。
- en: Each element is iterated over using `releases.each`, just like in jQuery. The
    callback’s context is changed to be the current element, so `this.text()` is called
    to get the text contained by the node ![](3.jpg).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`releases.each`遍历每个元素，就像在jQuery中一样。回调的上下文被更改为当前元素，因此调用`this.text()`来获取节点包含的文本
    ![](3.jpg)。
- en: Because Node has such a wide collection of third-party modules, you could take
    this example and make all sorts of amazing things with it. Add Redis for caching
    and queueing websites to process, then scrape the results and throw it at Elasticsearch,
    and you’ve got your own search engine!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node拥有如此广泛的第三方模块，你可以使用这个例子来做各种惊人的事情。添加Redis进行缓存和排队处理网站，然后抓取结果并将其投放到Elasticsearch，你就拥有了自己的搜索引擎！
- en: Now you’ve seen how to run JavaScript intended for browsers in Node, but what
    about the opposite? You might have some Node code that you want to reuse client-side,
    or you might want to just use Node’s module system to organize your client-side
    code. Much like we can simulate the DOM in Node, we can do the same in the browser.
    In the next technique you’ll learn how to do this by running your Node scripts
    in browsers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何在Node中运行针对浏览器的JavaScript，但反过来呢？你可能有一些想要在客户端重用的Node代码，或者你可能只想使用Node的模块系统来组织你的客户端代码。就像我们可以在Node中模拟DOM一样，我们也可以在浏览器中做到这一点。在下一个技术中，你将学习如何通过在浏览器中运行你的Node脚本来实现这一点。
- en: Technique 66 Using Node modules in the browser
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号66 在浏览器中使用Node模块
- en: 'One of Node’s selling points for JavaScript is that you can reuse your existing
    browser programming skills on servers. But what about *reusing* Node code in browsers
    without any changes? Wouldn’t that be cool? Here’s an example: you’ve defined
    data models in Node that do things like data validation, and you want to reuse
    them in the browser to automatically display error messages when data is invalid.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Node 对 JavaScript 的一个卖点是可以将现有的浏览器编程技能用于服务器。但如果没有任何更改，如何在浏览器中重用 Node 代码呢？这难道不是很酷吗？这里有一个例子：你在
    Node 中定义了数据模型，它们执行数据验证等操作，你希望在浏览器中重用它们，以便在数据无效时自动显示错误消息。
- en: 'This is almost possible, but not quite: unfortunately browsers have quirks
    that must be ironed out. Also, important features like `require` don’t exist in
    client-side JavaScript. In this technique you’ll see how you can take code intended
    for Node, and convert it to work with most web browsers.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎可能，但并不完全可能：不幸的是，浏览器有一些怪癖必须解决。此外，像 `require` 这样的重要功能在客户端 JavaScript 中不存在。在这个技术中，你将看到如何将针对
    Node 的代码转换为与大多数网络浏览器一起工作。
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use `require()` to structure your client-side code, or reuse entire
    Node modules in the browser.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用 `require()` 来结构化你的客户端代码，或者在浏览器中重用整个 Node 模块。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a program like Browserify that is capable of converting Node JavaScript
    into browser-friendly code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Browserify 这样的程序，它能够将 Node JavaScript 转换为浏览器友好的代码。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In this technique we’ll use Browserify ([http://browserify.org/](http://browserify.org/))
    to convert Node modules into browser-friendly code. Other solutions also exist,
    but at this point Browserify is one of the more mature and popular solutions.
    It doesn’t just patch in support for `require()`, though: it can convert code
    that relies on Node’s stream and network APIs. You can even use it to recursively
    convert modules from npm.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，我们将使用 Browserify ([http://browserify.org/](http://browserify.org/)) 将
    Node 模块转换为浏览器友好的代码。其他解决方案也存在，但到目前为止，Browserify 是更成熟和流行的解决方案之一。尽管它不仅仅是为了支持 `require()`
    而进行修补，它还可以转换依赖于 Node 的流和网络 API 的代码。你甚至可以使用它递归地将 npm 中的模块转换为浏览器模块。
- en: 'To see how it works, we’ll first look at a short self-contained example. To
    get started, install Browserify with npm: `npm install -g browserify`. Once you’ve
    got Browserify installed, you can convert your Node modules into Browser scripts
    with `browserify index.js -o bundle.js`. Any `require` statements will cause the
    files to be included in bundle.js, so you shouldn’t change this file. Instead,
    overwrite it whenever your original files have changed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，我们首先来看一个简短的自包含示例。要开始，使用 npm 安装 Browserify：`npm install -g browserify`。一旦安装了
    Browserify，你就可以使用 `browserify index.js -o bundle.js` 将你的 Node 模块转换为 Browser 脚本。任何
    `require` 语句都会导致文件被包含在 bundle.js 中，所以你不应该更改此文件。相反，每次原始文件有更改时，都要覆盖它。
- en: '[Listing 9.4](#ch09ex04) shows a sample Node program that uses `EventEmitter`
    and `utils.inherit` to make the basis of a small messaging class.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.4](#ch09ex04) 展示了一个使用 `EventEmitter` 和 `utils.inherit` 来构建小型消息类基础的示例
    Node 程序。'
- en: Listing 9.4\. Node modules in the browser
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 浏览器中的 Node 模块
- en: '![](207fig01_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](207fig01_alt.jpg)'
- en: Running Browserify on this script generates a bundle that’s about 1,000 lines
    long! But we can use `require` as we would in any Node program ![](1.jpg), and
    the Node modules we know and love will work, as you can see in [listing 9.4](#ch09ex04)
    by the use of `util.inherits` and `EventEmitter` ![](2.jpg).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本上运行 Browserify 会生成一个大约 1,000 行的包！但我们可以像在任何 Node 程序中一样使用 `require` ![](1.jpg)，我们熟悉和喜爱的
    Node 模块将正常工作，如 [列表 9.4](#ch09ex04) 中通过使用 `util.inherits` 和 `EventEmitter` ![](2.jpg)
    所见。
- en: With Browserify, you can also use `require` and `module.exports`, which is better
    than having to juggle `<script>` tags. The previous example can be extended to
    do just that. In [listing 9.5](#ch09ex05), Browserify is used to make a client-side
    script that can load `MessageBus` and jQuery with `require`, and then modify the
    DOM when messages are emitted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Browserify，你还可以使用 `require` 和 `module.exports`，这比手动操作 `<script>` 标签要好。上一个例子可以扩展为做到这一点。在
    [列表 9.5](#ch09ex05) 中，Browserify 被用来创建一个客户端脚本，该脚本可以使用 `require` 加载 `MessageBus`
    和 jQuery，并在消息发出时修改 DOM。
- en: Listing 9.5\. Node modules in the browser
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 浏览器中的 Node 模块
- en: '![](208fig01_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](208fig01_alt.jpg)'
- en: By creating a package.json file with `jquery` as a dependency, you can load
    jQuery using Browserify ![](1.jpg). Here we’ve used it to attach a `DOMContentLoaded`
    listener ![](2.jpg) and append paragraphs to a container element when messages
    are received.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个包含`jquery`作为依赖项的package.json文件，你可以使用Browserify加载jQuery ![图片](1.jpg)。在这里，我们使用它来附加一个`DOMContentLoaded`监听器
    ![图片](2.jpg)并在接收到消息时将段落附加到容器元素中。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Source maps**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**源映射**'
- en: If the JavaScript files you generate with Browserify raise errors, then it can
    be hard to untangle the line numbers in stack traces, because they refer to line
    numbers in the monolithic bundle. If you include the `--debug` flag when building
    the bundle, then Browserify will generate mappings that point to the original
    files and line numbers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Browserify生成的JavaScript文件出现错误，那么在堆栈跟踪中解开行号可能会很困难，因为这些行号指的是单体包中的行号。如果你在构建包时包含`--debug`标志，那么Browserify将生成指向原始文件和行号的映射。
- en: These mappings require a compatible debugger—you’ll also need to tell your browser’s
    debugging tools to use them. In Chrome you’ll need to select *Enable source maps*,
    under the options in Chrome’s DevTools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射需要一个兼容的调试器——你还需要告诉你的浏览器的调试工具使用它们。在Chrome中，你需要在Chrome的开发工具选项下选择“启用源映射”。
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To make this work, all you need to do is add `module.exports = MessageBus` to
    the example from [listing 9.4](#ch09ex04), and then generate the bundle with `browserify
    index.js -o bundle.js`, where index.js is [listing 9.5](#ch09ex05). Browserify
    will dutifully follow the `require` statements from index.js to pull in jQuery
    from `./node_modules` and the `MessageBus` class from messagebus.js.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，你只需要将`module.exports = MessageBus`添加到[列表9.4](#ch09ex04)的示例中，然后使用`browserify
    index.js -o bundle.js`生成包，其中index.js是[列表9.5](#ch09ex05)。Browserify将忠实地跟随index.js中的`require`语句，从`./node_modules`中拉入jQuery和从messagebus.js中的`MessageBus`类。
- en: 'Because people might forget how to build the script, you can add a `scripts`
    entry to your package.json file, like this: `"build": "browserify index.js -o
    bundle.js"`. The downloadable code samples for this book include both a sample
    package.json file and a suitable HTML file for running the entire example in a
    browser.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '由于人们可能会忘记如何构建脚本，你可以在package.json文件中添加一个`scripts`条目，如下所示：`"build": "browserify
    index.js -o bundle.js"`。本书的可下载代码示例包括一个示例package.json文件和一个适合在浏览器中运行整个示例的HTML文件。'
- en: 'There’s another way to build bundles with Browserify: by using Browserify as
    a module in a Node program. To use it, you need to create a `Browserify` instance
    ![](1.jpg) and then tell it what files you want to build ![](2.jpg):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Browserify构建包还有另一种方法：将Browserify作为Node程序中的模块使用。要使用它，你需要创建一个`Browserify`实例
    ![图片](1.jpg)，然后告诉它你想要构建哪些文件 ![图片](2.jpg)：
- en: '![](209fig01_alt.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](209fig01_alt.jpg)'
- en: You could use this as part of a more complex build process, or put in a Grunt
    task to automate your build process. Now that you’ve seen how to use Node modules
    in the browser and how to simulate the browser in Node, it’s time to learn how
    to improve your server-side web applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些作为更复杂构建过程的一部分，或者将其放入Grunt任务中以自动化你的构建过程。现在你已经看到了如何在浏览器中使用Node模块以及如何在Node中模拟浏览器，现在是时候学习如何改进你的服务器端Web应用程序了。
- en: 9.2\. Server-side techniques
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 服务器端技术
- en: This section includes general techniques for building web applications. If you’re
    already using Express, then you’ll be able to use these techniques to improve
    how your Express programs are organized. Express aims to be simple, which makes
    it flexible, but sometimes it’s not easy to see how to use it in the best way.
    The patterns and solutions we’ve created have come from using Express to build
    commercial and open source web applications over the last few years. We hope they’ll
    help you to write better web applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括构建Web应用程序的一般技术。如果你已经在使用Express，那么你可以使用这些技术来改进你的Express程序的组织方式。Express旨在保持简单，这使得它非常灵活，但有时并不容易看到如何以最佳方式使用它。我们创建的模式和解决方案来自于过去几年使用Express构建商业和开源Web应用程序的经验。我们希望它们能帮助你编写更好的Web应用程序。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Express 3 and 4
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Express 3和4
- en: The techniques in this section refer to Express 3\. Most will work with Express
    4, or may require minor modifications. For more about migrating to Express 4,
    see [technique 75](#ch09lev2sec12).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的技术主要针对Express 3。大多数都将与Express 4兼容，或者可能需要一些小的修改。有关迁移到Express 4的更多信息，请参阅[技术编号75](#ch09lev2sec12)。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Technique 67 Express route separation
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号67 Express路由分离
- en: The documentation and popular tutorials for Express usually organize all the
    code in a single file. In real projects, this eventually becomes unmanageable.
    This technique uses Node’s module system to separate related routes into files,
    and also includes ways to get around the Express `app` object being in a different
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的文档和流行的教程通常将所有代码组织在一个文件中。在实际项目中，这最终会变得难以管理。这项技术使用 Node 的模块系统将相关路由分离到文件中，并包括绕过
    Express `app` 对象位于不同文件中的方法。
- en: Problem
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Your main Express application file has become extremely large, and you want
    a better way to organize all of those routes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主要 Express 应用程序文件变得非常大，您希望有更好的方式来组织所有这些路由。
- en: Solution
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use route separation to split related routes into modules.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由分离将相关路由拆分为模块。
- en: Discussion
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Express is a minimalist framework, so it doesn’t hold your hand when it comes
    to organizing projects. Projects that start simple can become unwieldy if you
    don’t pay attention. The secret to successfully organizing larger projects is
    to embrace Node’s module system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个极简框架，因此它不会在组织项目时手把手地引导你。如果你不留意，一开始简单的项目可能会变得难以管理。成功组织大型项目的秘诀是拥抱 Node
    的模块系统。
- en: The first avenue of attack is routes, but you can apply this technique to every
    facet of development with Express. You can even treat applications as self-contained
    Node modules, and mount them within other applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首要的攻击途径是路由，但你也可以使用 Express 将这项技术应用到开发的各个方面。你甚至可以将应用程序视为自包含的 Node 模块，并在其他应用程序中挂载它们。
- en: 'Here’s a typical example of some Express routes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些 Express 路由的典型示例：
- en: '![](210fig01_alt.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](210fig01_alt.jpg)'
- en: 'The full example project can be found in listings/web/route_separation/app_monolithic.js.
    It contains a set of CRUD routes for creating, finding, and updating notes. An
    application like this would have other CRUD routes as well: perhaps notes can
    be organized into notebooks, and there will definitely be some user account management,
    and extra features like setting reminders. Once you have about four or five of
    these sets of routes, the application file could be hundreds of lines of code.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例项目可以在 listings/web/route_separation/app_monolithic.js 中找到。它包含一组用于创建、查找和更新笔记的
    CRUD 路由。这样的应用程序还会有其他 CRUD 路由：也许笔记可以组织到笔记本中，肯定会有一些用户账户管理，以及设置提醒等额外功能。一旦你有大约四到五个这样的路由集，应用程序文件可能会有数百行代码。
- en: 'If you wrote this project as a single, large file, then it would be prone to
    many problems. It would be easy to make mistakes where variables are accidentally
    global instead of local, so dangerous side effects can be encountered under certain
    conditions. Node has a built-in solution which can be applied to Express and other
    web frameworks: directories as modules.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个项目写成单个、大型的文件，那么它很容易出现许多问题。很容易在变量意外地成为全局而不是局部时出错，因此在某些条件下可能会遇到危险的副作用。Node
    有一个内置的解决方案，可以应用于 Express 和其他 Web 框架：目录作为模块。
- en: 'To refactor your routes using modules, first create a directory called `routes`,
    or `controllers` if you prefer. Then create a file called index.js. In our case
    it’ll be a simple three-line file that exports the notes routes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用模块重构路由，首先创建一个名为 `routes` 的目录，或者如果你更喜欢，可以创建一个名为 `controllers` 的目录。然后创建一个名为
    index.js 的文件。在我们的例子中，它将是一个简单的三行文件，导出笔记路由：
- en: '![](210fig02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](210fig02.jpg)'
- en: 'Here we have just one routing module, which can be loaded with `require` and
    a relative path ![](1.jpg). Next, copy and paste the entire set of routes into
    routes/notes.js. Then delete the route definition part—for example, `app.get(''/notes'',`,
    and replace it with an export: `module.exports.index = function(req, res) {`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只有一个路由模块，可以使用 `require` 和相对路径加载![](1.jpg)。接下来，将整个路由集复制并粘贴到 routes/notes.js
    中。然后删除路由定义部分——例如，`app.get('/notes',`，并用导出替换它：`module.exports.index = function(req,
    res) {}`。
- en: The refactored files should look like the next listing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的文件应该看起来像下面的列表。
- en: Listing 9.6\. A routing module without the rest of the application
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 没有其他应用程序的路由模块
- en: '![](211fig01_alt.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](211fig01_alt.jpg)'
- en: Each routing function is exported with a CRUD-inspired name (index, create,
    update, show) ![](1.jpg). The corresponding app.js file can now be cleared up.
    The next listing shows just how clean this can look.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由函数都使用 CRUD 启发的名称导出（index、create、update、show）![](1.jpg)。相应的 app.js 文件现在可以清理了。下面的列表展示了这可以看起来多么整洁。
- en: Listing 9.7\. A refactored app.js file
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 重构后的 app.js 文件
- en: '![](211fig02_alt.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](211fig02_alt.jpg)'
- en: All of the routes can be loaded at once with `require('./routes')`![](1.jpg).
    This is convenient and clean, because there are fewer `require` statements that
    would otherwise clutter app.js. All you need to do is remove the old route callbacks
    and add in references to each routing function ![](2.jpg).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由都可以一次性使用`require('./routes')`加载！![图片1](1.jpg)。这既方便又整洁，因为减少了会弄乱app.js的`require`语句。您只需删除旧的路由回调并添加对每个路由函数的引用！![图片2](2.jpg)。
- en: Don’t put an `app.listen` call in this file; export `app` instead ![](3.jpg).
    This makes it easier to test the application. Another advantage of exporting the
    `app` object is that you can easily load the `app.js` module from anywhere within
    the application. Express allows you to get and set configuration values, so making
    `app` accessible can be useful if you want to refer to these settings in places
    outside the routes. Also note that `res.app` is available from within routes,
    so you don’t need to pass the `app` object around too often.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在这个文件中放置`app.listen`调用；相反，导出`app`！![图片3](3.jpg)。这使得测试应用程序更加容易。导出`app`对象的另一个优点是，您可以从应用程序的任何地方轻松加载`app.js`模块。Express允许您获取和设置配置值，因此如果需要在路由之外的位置引用这些设置，使`app`可访问可能很有用。另外请注意，`res.app`在路由内部可用，因此您不需要经常传递`app`对象。
- en: If you want to easily load app.js without creating a server, then name the application
    file app.js, and have a separate server.js file that calls `app.listen`. You can
    set up the `server` property in package.json to use `node server.js`, which allows
    people to start the application with `npm start`—you can also leave out the `server`
    property, because `node server.js` is the default, but it’s better to define it
    so people know how you intend them to use it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想轻松加载app.js而不创建服务器，那么将应用程序文件命名为app.js，并有一个单独的server.js文件，该文件调用`app.listen`。您可以在package.json中设置`server`属性以使用`node
    server.js`，这样人们就可以使用`npm start`启动应用程序——您也可以省略`server`属性，因为`node server.js`是默认的，但最好定义它，以便人们知道您希望他们如何使用它。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Directories as modules**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**将目录作为模块**'
- en: This technique puts all of the routes in a directory, and then exports them
    with an index.js file so they can be loaded in one go with `require('./routes')`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将所有路由放在一个目录中，然后通过一个index.js文件导出它们，这样就可以一次性使用`require('./routes')`来加载。
- en: This pattern can be reused in other places. It’s great for organizing middleware,
    database modules, and configuration files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以在其他地方重用。它非常适合组织中间件、数据库模块和配置文件。
- en: For an example of using directories as modules to organize configuration files,
    see [technique 69](#ch09lev2sec6).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用目录作为模块来组织配置文件的示例，请参阅[技术69](#ch09lev2sec6)。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The full example for this technique can be found in listings/web/route-separation,
    and it includes sample tests in case you want to unit test your own projects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的完整示例可以在`listings/web/route-separation`中找到，其中还包括了示例测试，以防您想对您自己的项目进行单元测试。
- en: Properly organizing your Express projects is important, but there are also workflow
    issues that can slow down development. For example, when you’re working on a web
    application, you’ll typically make many small changes and then refresh the browser
    to see the results. Most Node frameworks require the process to be restarted before
    seeing the changes take effect, so the next technique explores how this works
    and how to efficiently solve this problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正确组织Express项目非常重要，但还有一些工作流程问题可能会减慢开发速度。例如，当您在Web应用程序上工作时，您通常会进行许多小的更改，然后刷新浏览器以查看结果。大多数Node框架要求在看到更改生效之前重启进程，所以下一个技术将探讨这是如何工作的以及如何有效地解决这个问题。
- en: Technique 68 Automatically restarting the server
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号68：自动重启服务器
- en: Although Node comes with tools for monitoring changes to files, it can be a
    lot of work to use them productively. This technique looks at `fs.watch`, and
    introduces a popular third-party tool for automatically restarting web applications
    as files are edited.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Node自带了监控文件变化的工具，但使用它们进行高效工作可能需要大量工作。这项技术探讨了`fs.watch`，并介绍了一个流行的第三方工具，该工具可以在编辑文件时自动重启Web应用程序。
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to restart your Node web application every time you edit files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编辑文件时，您都需要重启您的Node Web应用程序。
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a file watcher to restart the application automatically.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件监视器来自动重启应用程序。
- en: Discussion
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: If you’re used to languages like PHP or ASP, Node’s in-process server-based
    model might seem unusual. One of the big differences about Node’s model is that
    you need to restart the process when files change. If you think about how `require`
    and V8 work, then this makes sense—files are generally loaded and interpreted
    once.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了像PHP或ASP这样的语言，Node的进程内服务器模型可能会显得有些不寻常。Node模型的一个主要区别在于，当文件发生变化时，你需要重启进程。如果你考虑一下`require`和V8的工作方式，那么这就有道理了——文件通常只加载和解释一次。
- en: One way to get around this is to detect when files change, and then restart
    the application. Node makes good use of non-blocking I/O, and one of the properties
    of non-blocking file system APIs is that listeners can be used to wait for specific
    events. To solve this problem, you could set up file system event handlers for
    all of the files in your project. Then, when files change, your event handler
    can restart the project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是在文件发生变化时检测到这一点，然后重启应用程序。Node很好地利用了非阻塞I/O，非阻塞文件系统API的一个特性是可以使用监听器来等待特定事件。为了解决这个问题，你可以为你的项目中的所有文件设置文件系统事件处理器。然后，当文件发生变化时，你的事件处理器可以重启项目。
- en: Node provides an API for this in the `fs` module called `fs.watch`. At the time
    of writing, this API is unstable—that means it may be changed in subsequent versions
    of Node. This method has been covered in [chapter 6](kindle_split_015.html#ch06),
    [section 6.1.4](kindle_split_015.html#ch06lev2sec4). Let’s look at how it could
    be used with a web application. [Figure 9.8](#ch09fig08) shows a program that
    can watch and reload a simple web server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Node在`fs`模块中提供了一个名为`fs.watch`的API。在撰写本文时，这个API是不稳定的——这意味着它可能在Node的后续版本中发生变化。这种方法已在[第6章](kindle_split_015.html#ch06)、[第6.1.4节](kindle_split_015.html#ch06lev2sec4)中介绍。让我们看看它是如何与网络应用程序一起使用的。[图9.8](#ch09fig08)显示了一个可以监视和重新加载简单网络服务器的程序。
- en: Listing 9.8\. Reloading a Node process
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 重新加载Node进程
- en: '![](213fig01_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](213fig01_alt.jpg)'
- en: Watching a file for changes with `fs.watch` is slightly convoluted, but you
    can use `fs.watchFile`, which is based on file polling instead of I/O events.
    The way [listing 9.8](#ch09ex08) works is to start a child process—in this case
    `node server.js` ![](1.jpg)—and then watch that file for changes ![](2.jpg). Starting
    and stopping processes is managed with the `child_process` core module, and the
    `kill` method is used to stop the child process ![](3.jpg).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fs.watch`监视文件变化稍微有些复杂，但你可以使用基于文件轮询而不是I/O事件的`fs.watchFile`。[列表9.8](#ch09ex08)的工作方式是启动一个子进程——在这种情况下是`node
    server.js`！[](1.jpg)，然后监视该文件的变化！[](2.jpg)。进程的启动和停止由`child_process`核心模块管理，使用`kill`方法停止子进程！[](3.jpg)。
- en: On Mac OS we found it’s best to also stop watching the file with `watcher.close`
    ![](4.jpg), although Node’s documentation indicates that `fs.watch` should be
    “persistent.” Once all of that is done, the `watch` function is called recursively
    to launch the web server again ![](5.jpg).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS上，我们发现最好也使用`watcher.close`停止监视文件！[](4.jpg)，尽管Node的文档表明`fs.watch`应该是“持久的”。一旦完成所有这些，`watch`函数就会递归调用以再次启动网络服务器！[](5.jpg)。
- en: 'This example could be run with a server.js file like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以用如下服务器.js文件运行：
- en: '[PRE0]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This works, but it’s not exactly elegant. And it’s not complete, either. Most
    Node web applications consist of multiple files, so the file-watching logic will
    become more complicated. It’s not enough to recurse over the parent directories,
    because there are lots of files that you don’t want to watch—you don’t want to
    watch the files in `.git`, and if you’re writing an Express application you probably
    don’t want to watch view templates, because they’re loaded on demand without caching
    in development mode.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但并不十分优雅。而且它也不完整。大多数Node网络应用程序由多个文件组成，因此文件监视逻辑会变得更加复杂。仅仅递归遍历父目录是不够的，因为有许多你不想监视的文件——你不想监视`.git`中的文件，如果你正在编写Express应用程序，你可能也不想监视视图模板，因为它们在开发模式下按需加载且不缓存。
- en: Suddenly automatically restarting Node programs seems less trivial, and that’s
    where third-party modules can help. One of the most widely used modules that solves
    this problem is Remy Sharp’s `nodemon` ([http://nodemon.io/](http://nodemon.io/)).
    It works well for watching Express applications out of the box, and you can even
    use it to automatically restart any kind of program, whether it’s written in Node
    or Python, Ruby, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 突然自动重启 Node 程序似乎不再那么简单，这就是第三方模块可以提供帮助的地方。解决这个问题的最广泛使用的模块之一是 Remy Sharp 的 `nodemon`
    ([http://nodemon.io/](http://nodemon.io/))。它默认情况下非常适合监视 Express 应用程序，您甚至可以使用它来自动重启任何类型的程序，无论是用
    Node 编写还是 Python、Ruby 等等。
- en: To try it out, type `npm install -g nodemon`, and then navigate to a directory
    that contains a Node web application. If you want to use a small sample script,
    you can use our example from listings/web/watch/server.js.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试它，请输入 `npm install -g nodemon`，然后导航到包含 Node 网络应用程序的目录。如果您想使用一个小型示例脚本，可以使用我们来自
    listings/web/watch/server.js 的示例。
- en: Start running and watching server.js by typing `nodemon server.js`, and you’ll
    find you can edit the text in `res.end` and the change will be reflected the next
    time you load http://localhost:8080/.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 `nodemon server.js` 开始运行和监视 server.js，您会发现您可以编辑 `res.end` 中的文本，并且更改将在您下次加载
    http://localhost:8080/ 时反映出来。
- en: You might notice a small delay before changes are visible—that’s just Nodemon
    setting up `fs.watch`, or `fs.watchFile` if it’s not available on your OS. You
    can force it to reload by typing `rs` and pressing Return.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到在更改可见之前会有短暂的延迟——这仅仅是 Nodemon 在设置 `fs.watch`，或者如果您的操作系统上不可用，则为 `fs.watchFile`。您可以通过输入
    `rs` 并按回车键强制它重新加载。
- en: Nodemon has some other features that will help you work on web applications.
    Typing `nodemon --help` will show a list of command-line options, but you can
    get greater, VCS-friendly control by creating a nodemon.json file. This allows
    you to specify an array of files to ignore, and you can also map file extensions
    to program names by using the `execMap` setting. Nodemon’s documentation includes
    a sample file that illustrates each of the features.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Nodemon 有一些其他功能可以帮助您在网页应用程序上工作。输入 `nodemon --help` 将显示命令行选项列表，但您可以通过创建一个 nodemon.json
    文件来获得更大的、与版本控制系统友好的控制。这允许您指定要忽略的文件数组，您还可以通过使用 `execMap` 设置将文件扩展名映射到程序名称。Nodemon
    的文档包括一个示例文件，说明了每个功能。
- en: The next listing is an example Nodemon configuration that you can adapt for
    your own projects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表是一个示例 Nodemon 配置，您可以将其适应到您自己的项目中。
- en: Listing 9.9\. Nodemon’s configuration file
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. Nodemon 的配置文件
- en: '![](214fig01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![214fig01.jpg]'
- en: The basic options allow you to ignore specific paths ![](1.jpg), and list multiple
    paths to watch ![](3.jpg). This example uses `execMap` to automatically run `node`
    with the `--harmony` flag^([[1](#ch09fn01)]) for all JavaScript files ![](2.jpg).
    Nodemon can also set environmental variables—just add some values to the `env`
    property ![](4.jpg).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基本选项允许您忽略特定的路径 ![1.jpg]，并列出要监视的多个路径 ![3.jpg]。此示例使用 `execMap` 自动运行带有 `--harmony`
    标志的 `node` 以适用于所有 JavaScript 文件 ![2.jpg]。Nodemon 还可以设置环境变量——只需将一些值添加到 `env` 属性
    ![4.jpg]。
- en: ¹ `--harmony` is used to enable all of the newer ECMAScript features available
    to Node.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ `--harmony` 用于启用 Node 可用的所有新 ECMAScript 功能。
- en: Once your workflow is streamlined thanks to Nodemon, the next thing to do is
    to improve how your project is configured. Most projects need some level of configuration—examples
    include the database connection details and authorization credentials for remote
    APIs. The next technique looks at ways to configure your web application so you
    can easily deploy it to multiple environments, run it in test mode, and even tweak
    how it behaves during local development.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的流程通过 Nodemon 流程化，接下来要做的就是改进您的项目配置。大多数项目都需要一定程度的配置——例如，包括数据库连接细节和远程 API 的授权凭证。下一项技术将探讨配置您的网络应用程序的方法，以便您可以轻松地将它部署到多个环境，以测试模式运行，甚至调整本地开发期间的行为。
- en: Technique 69 Configuring web applications
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 69 配置网络应用程序
- en: This technique looks at the common patterns for configuring Node web applications.
    We’ll include examples for Express, but you can use these patterns with other
    web frameworks as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术探讨了配置 Node 网络应用程序的常见模式。我们将包括 Express 的示例，但您也可以将这些模式用于其他网络框架。
- en: Problem
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have configuration options that change between development, testing, and
    production.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您有配置选项，这些选项在开发、测试和生产之间会有所不同。
- en: Solution
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use JSON configuration files, environmental variables, or a module for managing
    settings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSON 配置文件、环境变量或模块来管理设置。
- en: Discussion
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Most web applications require some configuration values to operate correctly:
    database connection strings, cache settings, and email server credentials are
    typical. There are many ways to store application settings, but before you install
    a third-party module to do it, consider your requirements:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Web 应用程序都需要一些配置值才能正确运行：数据库连接字符串、缓存设置和电子邮件服务器凭据是典型的。存储应用程序设置的方法有很多，但在安装第三方模块之前，请考虑你的需求：
- en: Is it acceptable to leave database credentials in your version control repository?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在版本控制仓库中留下数据库凭据是否可以接受？
- en: Do you really need configuration files, or can you embed settings into the application?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的需要配置文件，还是可以将设置嵌入到应用程序中？
- en: How can configuration values be accessed in different parts of the application?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不同的应用程序部分访问配置值？
- en: Does your deployment environment offer a way to store configuration values?
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的部署环境是否提供了一种存储配置值的方法？
- en: The first point depends on your project or organization’s policies. If you’re
    building an open source web application, you don’t want to leave database accounts
    in the public repository, so configuration files might not be the best solution.
    You want people to install your application quickly and easily, but you don’t
    want to accidentally leak your passwords. Similarly, if you work in a large organization
    with database administrators, they might not be comfortable about letting everyone
    have direct access to databases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点取决于你的项目或组织的政策。如果你正在构建开源 Web 应用程序，你不想在公共仓库中留下数据库账户，因此配置文件可能不是最佳解决方案。你希望人们能够快速轻松地安装你的应用程序，但你不希望意外泄露你的密码。同样，如果你在一个拥有数据库管理员的大型组织中工作，他们可能不介意让每个人都直接访问数据库。
- en: In such cases, you can set configuration values as part of the deployment environment.
    Environmental variables are a standard way to configure the behavior of Unix and
    Windows programs, and you can access them with `process.env`. The basic example
    of this is switching between deployment environments, using the `NODE_ENV` setting.
    The following listing shows the pattern Express uses for storing configuration
    values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以将配置值作为部署环境的一部分来设置。环境变量是配置 Unix 和 Windows 程序行为的标准方式，你可以使用 `process.env`
    来访问它们。这个基本示例是使用 `NODE_ENV` 设置在部署环境之间切换。以下列表显示了 Express 用于存储配置值的模式。
- en: Listing 9.10\. Configuring an Express application
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 配置 Express 应用程序
- en: '![](216fig01_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](216fig01_alt.jpg)'
- en: 'Express has a small API for setting application configuration values: `app.set`,
    `app.get` ![](4.jpg), and `app.configure`. You can also use `app.enable` and `app.disable`
    to toggle Boolean values, and `app.enabled` and `app.disabled` to query them.
    The `app.configure` blocks are equivalent to `if (process.env.NODE_ENV === ''development'')`
    ![](2.jpg) and `if (process.env.NODE_ENV === ''production'')`![](3.jpg), so you
    don’t really need to use `app.configure` if you don’t want to. It will be removed
    in Express 4\. If you’re not using Express, you can just query `process.env`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Express 有一个用于设置应用程序配置值的 API：`app.set`、`app.get` ![](4.jpg) 和 `app.configure`。你还可以使用
    `app.enable` 和 `app.disable` 来切换布尔值，以及使用 `app.enabled` 和 `app.disabled` 来查询它们。`app.configure`
    块与 `if (process.env.NODE_ENV === 'development')` ![](2.jpg) 和 `if (process.env.NODE_ENV
    === 'production')`![](3.jpg) 等价，所以如果你不想使用 `app.configure`，你实际上不需要它。它将在 Express
    4 中被移除。如果你没有使用 Express，你只需查询 `process.env`。
- en: The `NODE_ENV` environmental variable is controlled by the shell. If you want
    to run [listing 9.10](#ch09ex10) in production mode, you can type `NODE_ENV=production
    node config.js`, and you should see it print the production database string. You
    could also type `export NODE_ENV=production`, which will cause the application
    to always run in production mode while the current shell is running.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_ENV` 环境变量由 shell 控制。如果你想以生产模式运行 [列表 9.10](#ch09ex10)，你可以输入 `NODE_ENV=production
    node config.js`，你应该会看到它打印出生产数据库字符串。你也可以输入 `export NODE_ENV=production`，这将导致应用程序在当前
    shell 运行期间始终以生产模式运行。'
- en: The reason we’ve used `PORT` ![](1.jpg) to set the port is because that’s the
    default name Heroku uses. This allows Heroku’s internal HTTP routers to override
    the port your application listens on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `PORT` ![](1.jpg) 来设置端口的理由是因为这是 Heroku 默认使用的名称。这允许 Heroku 的内部 HTTP 路由器覆盖应用程序监听的端口。
- en: You could use `process.env` throughout your code instead of `app.get`, but using
    the `app` object feels cleaner. You don’t need to pass `app` around—if you’ve
    used the route separation pattern from [technique 67](#ch09lev2sec4), then you’ll
    be able to access it through `res.app`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中使用 `process.env` 而不是 `app.get`，但使用 `app` 对象感觉更干净。你不需要传递 `app`——如果你已经使用了来自
    [技术 67](#ch09lev2sec4) 的路由分离模式，那么你将通过 `res.app` 访问它。
- en: If you’d rather use configuration files, the easiest and quickest way is to
    use the folder as a module technique with JSON files. Create a folder called config/,
    and then create an index.js file, and a JSON file for each environment. The next
    listing shows what the index.js file should look like.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意使用配置文件，最简单快捷的方法是使用文件夹作为模块技术与 JSON 文件结合。创建一个名为 config/ 的文件夹，然后创建一个 index.js
    文件，并为每个环境创建一个 JSON 文件。下一个列表显示了 index.js 文件应该是什么样子。
- en: Listing 9.11\. A JSON configuration file loader
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. JSON 配置文件加载器
- en: '![](217fig01_alt.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](217fig01_alt.jpg)'
- en: Node’s module system allows you to load a JSON file with `require` ![](1.jpg),
    so you can load each environment’s configuration file and then export the relevant
    one using `NODE_ENV` ![](2.jpg). Then whenever you need to access settings, just
    use `var config = require('./config')`—you’ll get a plain old JavaScript object
    that contains the settings for the current environment. The next listing shows
    an example Express application that uses this technique.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的模块系统允许你使用 `require` 加载 JSON 文件 ![1.jpg](1.jpg)，因此你可以加载每个环境的配置文件，然后使用 `NODE_ENV`
    ![2.jpg](2.jpg) 导出相关的配置。然后每当你需要访问设置时，只需使用 `var config = require('./config')`——你将得到一个包含当前环境设置的普通
    JavaScript 对象。下一个列表显示了使用此技术的示例 Express 应用程序。
- en: Listing 9.12\. Loading the configuration directory
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 加载配置目录
- en: '![](217fig02_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](217fig02_alt.jpg)'
- en: This is so easy it almost feels like cheating! All you have to do is call `require
    ('./config')` and you’ve got your settings. Node’s module system should cache
    the file as well, so once you’ve called `require` it shouldn’t need to evaluate
    the JSON files again. You can repeatedly call `require('./config')` throughout
    your application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎感觉像是作弊！你只需要调用 `require ('./config')`，你就有你的设置了。Node 的模块系统也应该缓存该文件，所以一旦你调用了
    `require`，它就不需要再次评估 JSON 文件。你可以在应用程序的任何地方重复调用 `require('./config')`。
- en: This technique takes advantage of JavaScript’s lightweight syntax for setting
    and accessing values on objects, as well as Node’s module system. It works well
    for lots of types of projects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术利用了 JavaScript 在对象上设置和访问值的轻量级语法，以及 Node 的模块系统。它适用于许多类型的项目。
- en: 'There’s one more approach to configuration: using a third-party module. After
    the last technique, you might think this is overkill, but third-party modules
    can offer a lot of functionality, including command-line option parsing. It might
    be that you often need to switch between different options, so overriding application
    settings with command-line options is attractive.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 配置还有另一种方法：使用第三方模块。在掌握最后一种技术之后，你可能认为这就足够了，但第三方模块可以提供很多功能，包括命令行选项解析。可能你经常需要在不同的选项之间切换，因此使用命令行选项覆盖应用程序设置是很有吸引力的。
- en: The web framework Flatiron ([http://flatironjs.org/](http://flatironjs.org/))
    has an application configuration module called `nconf` ([https://npmjs.org/package/nconf](https://npmjs.org/package/nconf))
    that handles configuration files, environmental variables, and command-line options.
    Each can be given precedence, so you can make command-line options override configuration
    files. It’s a unifying framework for processing options.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 网络框架 Flatiron ([http://flatironjs.org/](http://flatironjs.org/)) 有一个名为 `nconf`
    ([https://npmjs.org/package/nconf](https://npmjs.org/package/nconf)) 的应用程序配置模块，它可以处理配置文件、环境变量和命令行选项。每个都可以设置优先级，因此你可以使命令行选项覆盖配置文件。这是一个处理选项的统一框架。
- en: The following listing shows how `nconf` can be used to configure an Express
    application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如何使用 `nconf` 配置 Express 应用程序。
- en: Listing 9.13\. Using `nconf` to configure an Express application
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.13\. 使用 `nconf` 配置 Express 应用程序
- en: '![](218fig01_alt.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](218fig01_alt.jpg)'
- en: Here we’ve told `nconf` to prioritize options from the command line, but to
    also read a configuration file if one is available ![](1.jpg). You don’t need
    to create a configuration file, and `nconf` can create one for you if you use
    `nconf.save`. That means you could allow users of your application to change settings
    and persist them. This works best when `nconf` is set up to use a database to
    save settings—it comes with built-in Redis support.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已告诉`nconf`优先考虑命令行选项，但如果可用，也会读取配置文件！[](1.jpg)。您不需要创建配置文件，如果您使用`nconf.save`，`nconf`可以为您创建一个。这意味着您可以让应用程序的用户更改设置并持久保存它们。当`nconf`配置为使用数据库保存设置时，这效果最好——它内置了Redis支持。
- en: Default values can be set with `nconf.set` ![](2.jpg). If you run this example
    without any options, it should use port 3000, but if you start it with `node app.js
    --port 3001`, it’ll use whatever you pass with `--port`. Getting settings is as
    simple as `nconf.get` ![](3.jpg).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`nconf.set`！[](2.jpg)设置默认值。如果您在没有任何选项的情况下运行此示例，它应该使用端口3000，但如果您以`node app.js
    --port 3001`启动它，它将使用您通过`--port`传递的内容。获取设置就像`nconf.get`！[](3.jpg)一样简单。
- en: And you don’t need to pass the `nconf` object around! Settings are stored in
    memory. Other files in your project can access settings by loading `nconf` with
    `require`, and then calling `nconf.get`. The next listing loads `nconf` again,
    and then tries to access the `db` setting.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要传递`nconf`对象！设置存储在内存中。您的项目中的其他文件可以通过使用`require`加载`nconf`并调用`nconf.get`来访问设置。下一个列表再次加载`nconf`，然后尝试访问`db`设置。
- en: Listing 9.14\. Loading `nconf` elsewhere in the application
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. 在应用程序的其他地方加载`nconf`
- en: '![](218fig02_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](218fig02_alt.jpg)'
- en: Even though it seems like `var nconf = require('nconf')` might return a pristine
    copy of `nconf`, it doesn’t ![](1.jpg).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来`var nconf = require('nconf')`可能返回一个干净的`nconf`副本，但实际上并不是这样！[](1.jpg)。
- en: A well-organized and carefully configured web application can still go wrong.
    When your application crashes, you’ll want logs to help debug the problem. The
    next technique will help you improve how your application handles errors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织良好且配置仔细的Web应用程序仍然可能会出错。当您的应用程序崩溃时，您会希望日志帮助调试问题。下一个技术将帮助您改进应用程序处理错误的方式。
- en: Technique 70 Elegant error handling
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 70 精美的错误处理
- en: This technique looks at using the `Error` constructor to catch and handle errors
    in your application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术探讨了使用`Error`构造函数来捕获和处理应用程序中的错误。
- en: Problem
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to centralize error handling to simplify your web applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望集中处理错误以简化您的Web应用程序。
- en: Solution
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Inherit from `Error` with error classes that include HTTP status codes, and
    use a middleware component to handle errors based on content type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含HTTP状态代码的错误类继承自`Error`，并使用中间件组件根据内容类型处理错误。
- en: Discussion
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'JavaScript has an `Error` constructor that you can inherit from to represent
    specific types of errors. In web development, some errors frequently crop up:
    incorrect URLs, incorrect parameters for query parameters or form values, and
    authentication failures. That means you can define errors that include HTTP codes
    alongside the typical things `Error` provides.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一个`Error`构造函数，您可以从它继承来表示特定类型的错误。在Web开发中，一些错误经常出现：不正确的URL、查询参数或表单值的不正确参数，以及认证失败。这意味着您可以定义包含HTTP代码的错误，同时包含`Error`提供的典型内容。
- en: Rather than branching on error conditions in HTTP routers, you should call `next(err)`.
    The next listing shows how that works.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在HTTP路由器中根据错误条件进行分支，您应该调用`next(err)`。下一个列表显示了它是如何工作的。
- en: Listing 9.15\. Passing errors to middleware
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. 将错误传递给中间件
- en: '![](219fig01_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](219fig01_alt.jpg)'
- en: In this example, error classes have been defined in a separate file ![](1.jpg),
    which you can find in [listing 9.16](#ch09ex16). The route handler includes a
    third argument, `next` ![](2.jpg), after the standard `req, res` arguments that
    we’ve used in previous techniques.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，错误类别已在单独的文件中定义！[](1.jpg)，您可以在[列表 9.16](#ch09ex16)中找到它。路由处理程序包括一个第三个参数，`next`！[](2.jpg)，在之前技术中我们使用的标准`req,
    res`参数之后。
- en: Many of your route handlers will load data from a database, whether it’s MySQL,
    PostgreSQL, MongoDB, or Redis, so this example is based around a generic asynchronous
    database API. If an error was encountered by the database API, then return early
    and call `next`, including the error object as the first argument. This will pass
    the error along to the next middleware component ![](3.jpg). This route handler
    has an additional piece of logic—if a note wasn’t found in the database, then
    an error object is instantiated and passed along using `next` ![](4.jpg).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您的许多路由处理程序将加载数据库中的数据，无论是 MySQL、PostgreSQL、MongoDB 还是 Redis，因此此示例基于一个通用的异步数据库
    API。如果数据库 API 遇到错误，则提前返回并调用 `next`，包括错误对象作为第一个参数。这将把错误传递给下一个中间件组件 ![图片](3.jpg)。此路由处理程序还有一个额外的逻辑部分——如果数据库中没有找到笔记，则使用
    `next` 实例化错误对象并传递 ![图片](4.jpg)。
- en: The following listing shows how to inherit from `Error`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何从 `Error` 继承。
- en: Listing 9.16\. Inheriting errors and including status codes
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16\. 继承错误并包含状态码
- en: '![](220fig01_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](220fig01_alt.jpg)'
- en: Here we’ve opted to create two classes. Instead of just defining `NotFound`,
    we’ve created `HTTPError` ![](1.jpg) and inherited from it ![](5.jpg). This is
    so it’s easier to track if an error is related to HTTP, or if it’s something else.
    The base `HTTPError` class inherits from `Error` ![](2.jpg).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择创建两个类。我们不仅定义了 `NotFound`，还创建了 `HTTPError` ![图片](1.jpg) 并从它继承 ![图片](5.jpg)。这样做是为了更容易追踪错误是否与
    HTTP 相关，或者是否是其他原因。基本的 `HTTPError` 类从 `Error` ![图片](2.jpg) 继承。
- en: In the `NotFound` error, we’ve captured the stack trace to aid with debugging
    ![](3.jpg), and set a `statusCode` property ![](4.jpg) that can be reported to
    the browser.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotFound` 错误中，我们捕获了堆栈跟踪以帮助调试 ![图片](3.jpg)，并设置了一个 `statusCode` 属性 ![图片](4.jpg)，该属性可以报告给浏览器。
- en: The next listing shows how to create an error-handling middleware component
    in a typical Express application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何在典型的 Express 应用程序中创建一个错误处理中间件组件。
- en: Listing 9.17\. Using an error-handling middleware component
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17\. 使用错误处理中间件组件
- en: '![](ch09ex17-0.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex17-0.jpg)'
- en: '![](ch09ex17-1.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09ex17-1.jpg)'
- en: This middleware component is fairly simple, but it has some tweaks that we’ve
    found work well in production. To get the error objects passed by `next`, make
    sure to use the four-parameter form of `app.use`’s callback ![](1.jpg). Also note
    that this middleware component comes at the end of the chain, so you need to put
    it after all your other middleware and route definitions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件组件相当简单，但它有一些在生产中我们发现效果很好的调整。要获取 `next` 传递的错误对象，请确保使用 `app.use` 回调的四参数形式
    ![图片](1.jpg)。此外，请注意，这个中间件组件位于链的末尾，因此您需要将其放在所有其他中间件和路由定义之后。
- en: You can conditionally print stack traces so they’re not visible when specifically
    testing expected errors ![](2.jpg)—errors may be triggered as part of testing,
    and you wouldn’t want stack traces cluttering the test output.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以条件性地打印堆栈跟踪，以便在测试预期错误时它们不可见 ![图片](2.jpg)——错误可能是测试的一部分，您不希望堆栈跟踪弄乱测试输出。
- en: Because this centralizes error handling into the main application file, it’s
    a good idea to conditionally return different formats. This is useful if your
    application provides a JSON API as well as HTML pages. You can use `app.format`
    to do this ![](3.jpg), and it works by checking the MIME type in the request’s
    `Accept` header. The JSON response might not be needed, but it’s possible that
    your API would return well-formed errors that can be consumed by clients—it can
    be difficult to deal with APIs that suddenly respond with HTML when you’re asking
    for JSON.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将在主应用程序文件中集中处理错误，因此根据条件返回不同的格式是个好主意。如果您的应用程序同时提供 JSON API 和 HTML 页面，这很有用。您可以使用
    `app.format` 来实现这一点 ![图片](3.jpg)，它通过检查请求的 `Accept` 头中的 MIME 类型来工作。JSON 响应可能不是必需的，但您的
    API 可能会返回格式良好的错误，这些错误可以被客户端消费——当您请求 JSON 时，处理突然以 HTML 响应的 API 可能会很困难。
- en: 'Somewhere in your tests you should check that these errors do what you want.
    The following snippet shows a Mocha test that makes sure 404s are returned when
    expected, and in the expected format:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试中的某个地方，您应该检查这些错误是否按预期工作。以下片段显示了一个 Mocha 测试，确保当预期时返回 404，并且以预期的格式返回：
- en: '![](221fig01_alt.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](221fig01_alt.jpg)'
- en: This snippet includes two requests. The first checks that we get an error with
    a 404 ![](1.jpg), and the second sets the `Accept` header to make sure we get
    back JSON ![](2.jpg). This is implemented with SuperTest, which will give us JSON
    in responses, so the assertion can check to make sure we get an object in the
    format we expect ![](3.jpg). The full source for this example can be found in
    listings/web/error-handling.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段包括两个请求。第一个检查我们是否得到一个 404 错误 ![1.jpg]，第二个设置 `Accept` 头部信息以确保我们得到 JSON ![2.jpg]。这是通过
    SuperTest 实现的，它将在响应中返回 JSON，因此断言可以检查我们是否得到了我们期望的格式 ![3.jpg]。此示例的完整源代码可以在 listings/web/error-handling
    中找到。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Error email cheat sheet**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误电子邮件速查表**'
- en: 'If you’re going to make your application send email notifications when unexpected
    errors occur, here’s a list of things you should include in the email to aid with
    debugging:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在应用程序中添加当发生意外错误时发送电子邮件通知的功能，以下是在电子邮件中包含以帮助调试的一些内容列表：
- en: A string version of the error object
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误对象的字符串版本
- en: The contents of `err.stack`—this is a nonstandard property of error objects
    that Node includes
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err.stack` 的内容——这是 Node 包含的错误对象的非标准属性'
- en: The request method and URL
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求方法和 URL
- en: The Express `req.route` property, if available
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有的话，Express 的 `req.route` 属性
- en: The remote IP, which is `req.ip` in Express
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程 IP，在 Express 中为 `req.ip`
- en: The request body, which you can convert to a string with `inspect(req.body)`
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体，你可以使用 `inspect(req.body)` 将其转换为字符串
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This error-handling pattern is widely used in Express apps, and it’s even built
    into the restify framework ([https://npmjs.org/package/restify](https://npmjs.org/package/restify)).
    If you remember to pass error objects to `next`, you’ll find testing and debugging
    Express applications easier.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误处理模式在 Express 应用程序中广泛使用，甚至内置在 restify 框架中（[https://npmjs.org/package/restify](https://npmjs.org/package/restify)）。如果你记得将错误对象传递给
    `next`，你会发现测试和调试 Express 应用程序更容易。
- en: Errors can also be sent as emails with useful transcripts. To make the most
    out of error emails, include the request and error objects in the email so you
    can see exactly where things broke. Also, you probably don’t want to send details
    about errors with certain status codes, but that’s up to you.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 错误也可以作为带有有用记录的电子邮件发送。为了最大限度地利用错误电子邮件，请在电子邮件中包含请求和错误对象，以便您可以确切地看到问题出在哪里。此外，您可能不想发送有关某些状态代码的错误详细信息，但这取决于您。
- en: In this technique we mentioned adapting code to work with REST APIs. The next
    technique delves deeper into the world of REST, and has examples for both Express
    and restify.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧中，我们提到了将代码适配以与 REST API 一起工作。下一个技巧将更深入地探讨 REST 的世界，并为 Express 和 restify
    提供示例。
- en: Technique 71 RESTful web applications
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 71 RESTful 网络应用程序
- en: At some stage you might want to add an API to your application. This technique
    is all about building RESTful APIs. There are examples for both Express and restify,
    and tips on how to create APIs that use the right HTTP verbs and idiomatic URLs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个阶段，您可能想向您的应用程序添加一个 API。这项技术完全是关于构建 RESTful API。这里有 Express 和 restify 的示例，以及如何创建使用正确
    HTTP 动词和惯用 URL 的 API 的技巧。
- en: Problem
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a RESTful web service in Express, restify, or another web
    framework.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在 Express、restify 或其他 Web 框架中创建一个 RESTful Web 服务。
- en: Solution
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the right HTTP methods, URLs, and headers to build an intuitive, RESTful
    API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的 HTTP 方法、URL 和头部信息来构建直观的 RESTful API。
- en: Discussion
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: REST stands for *representational state transfer*,^([[2](#ch09fn02)]) which
    isn’t terribly useful to memorize unless you want to impress someone in a job
    interview. The way web developers talk about it is usually in contrast to SOAP
    (Simple Object Access Protocol), which is seen as a more corporate and strict
    way to create web APIs. In fact, there’s such a thing as a strict REST API, but
    the key distinction is that REST embraces HTTP at a fundamental level—the HTTP
    methods themselves have semantic meaning.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: REST 代表 *表征状态转移*，^([[2](#ch09fn02)]) 除非你想在面试中给人留下深刻印象，否则记住这一点并没有太大的帮助。网络开发者通常将其与
    SOAP（简单对象访问协议）相对比，SOAP 被视为一种更企业化、更严格的创建 Web API 的方式。实际上，确实存在严格的 REST API，但关键的区别在于
    REST 在根本层面上拥抱 HTTP——HTTP 方法本身具有语义意义。
- en: ² For more about REST, see Fielding’s dissertation on the subject at [http://mng.bz/7Fhj](http://mng.bz/7Fhj).
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 更多关于 REST 的信息，请参阅 Fielding 关于该主题的论文 [http://mng.bz/7Fhj](http://mng.bz/7Fhj)。
- en: You should be familiar with using `GET` and `POST` requests if you’ve ever made
    a basic HTML form. In REST, these HTTP verbs have specific meanings. For example,
    `POST` will *create a resource*, and `GET` means *fetch a resource*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经制作过基本的HTML表单，你应该熟悉使用`GET`和`POST`请求。在REST中，这些HTTP动词有特定的含义。例如，`POST`将*创建一个资源*，而`GET`意味着*获取一个资源*。
- en: Node developers typically create APIs that use JSON. JSON is the easiest structured
    data format to generate and read in Node, but it also works well in client-side
    JavaScript. But REST doesn’t imply JSON—you’re free to use any data format. Certain
    clients and services expect XML, and we’ve even seen those that work with CSV
    and spreadsheet formats like Excel.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Node开发者通常创建使用JSON的API。JSON是Node中生成和读取结构化数据格式最简单的方式，但它也适用于客户端JavaScript。但是REST并不暗示JSON——你可以自由使用任何数据格式。某些客户端和服务期望XML，我们甚至见过那些与CSV和Excel等电子表格格式一起工作的。
- en: The desired data format is specified by the request’s `Accept` header. For JSON
    that should be `application/json`, and `application/xml` for XML. There are other
    useful request headers as well—`Accept-Version` can be used to request a different
    version of the API. This allows clients to lock themselves against a supported
    version, while you’re free to improve the server without breaking backward compatibility—you
    can always update your server faster than people can update their clients.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的数据格式由请求的`Accept`头部指定。对于JSON，应该是`application/json`，对于XML则是`application/xml`。还有其他有用的请求头部——`Accept-Version`可以用来请求API的不同版本。这允许客户端锁定到一个受支持的版本，同时你可以自由地改进服务器而不会破坏向后兼容性——你总是可以比人们更新客户端更快地更新你的服务器。
- en: 'Express provides a lightweight layer over Node’s `http` core module, but it
    doesn’t include any data persistence functionality outside of in-memory sessions
    and cookies. You’ll have to decide which database and database module to use.
    The same is true with restify: it doesn’t automatically map data from HTTP to
    be stored offline; you’ll need to find a way to do that.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Express在Node的`http`核心模块之上提供了一个轻量级层，但它不包括任何除内存会话和cookie之外的数据持久性功能。你必须决定使用哪个数据库和数据库模块。restify也是如此：它不会自动将数据从HTTP映射到离线存储；你需要找到一种方法来实现这一点。
- en: Restify is superficially similar to Express. The difference is that Express
    has features that help you build web applications, which includes rendering templates.
    Conversely, restify is focused on building REST APIs, and that brings a different
    set of requirements. Restify makes it easy to serve multiple versions of an API
    with semantic versioning using HTTP headers, and has an event-based API for emitting
    and listening for HTTP-related events and errors. It also supports throttling,
    so you can control how quickly responses are made.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Restify在表面上与Express相似。区别在于Express具有帮助你构建Web应用程序的功能，包括渲染模板。相反，restify专注于构建REST
    API，这带来了一组不同的要求。Restify通过使用HTTP头部实现语义版本控制，使得轻松地为API的不同版本提供服务变得容易，并且有一个基于事件的API用于发射和监听与HTTP相关的事件和错误。它还支持节流，因此你可以控制响应的速度。
- en: '[Figure 9.3](#ch09fig03) shows a typical RESTful API that allows *page* objects
    to be created, read, updated, and deleted.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](#ch09fig03) 展示了一个典型的RESTful API，它允许创建、读取、更新和删除*页面*对象。'
- en: Figure 9.3\. Making requests to a REST API
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 向REST API发送请求
- en: '![](09fig03_alt.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03_alt.jpg)'
- en: 'To get started building REST APIs, you should consider what your objects are.
    Imagine you’re building a content management system: it probably has pages, users,
    and images. If you want to add a button that allows pages to be toggled between
    “published” and “draft,” and if you’ve already got a REST API and it supports
    requests to `PATCH /pages/:id`, you could just tie the button to some client-side
    JavaScript or a form that posts to `/pages/:id` with `{ state: ''published'' }`
    or `{ state: ''draft'' }`. If you’ve been given an Express application that only
    has `PUT /pages/:id`, then you could probably derive the code for `PATCH` from
    the existing implementation.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '要开始构建REST API，你应该考虑你的对象是什么。想象你正在构建一个内容管理系统：它可能包含页面、用户和图像。如果你想添加一个按钮，允许页面在“已发布”和“草稿”之间切换，并且如果你已经有一个支持`PATCH
    /pages/:id`请求的REST API，你只需将按钮绑定到一些客户端JavaScript或一个将`{ state: ''published'' }`或`{
    state: ''draft'' }`发送到`/pages/:id`的表单即可。如果你被提供了一个只有`PUT /pages/:id`的Express应用程序，那么你可能可以从现有实现中推导出`PATCH`的代码。'
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Plural or singular?**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**复数还是单数？**'
- en: When you design your API’s URI endpoints, you should generally use *plural nouns*.
    That means `/pages` and also `/pages/1` for a specific page, not `/page/1`. It’ll
    be easier to use your API if the endpoints are consistent.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计 API 的 URI 端点时，你应该通常使用复数名词。这意味着 `/pages` 以及 `/pages/1` 用于特定页面，而不是 `/page/1`。如果端点是一致的，那么使用你的
    API 会更容易。
- en: You may find there are certain resources that should be singular nouns, because
    there’s only ever one such item. If it makes semantic sense, use a singular noun,
    but use it consistently. For example, if your API requires that users sign in,
    and you don’t want to expose a unique user ID, then `/account` might be a sensible
    endpoint for user account management, if there’s only ever one account for a given
    user.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现有一些资源应该使用单数名词，因为只有一个这样的项目。如果语义上合理，可以使用单数名词，但使用时要保持一致。例如，如果你的 API 需要用户登录，并且你不想暴露唯一的用户
    ID，那么 `/account` 可能是用户账户管理的合理端点，如果对于特定用户只有一个账户。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 9.1](#ch09table01) shows HTTP verbs alongside the typical response.
    Note that `PUT` and `PATCH` have different but similar meanings—`PATCH` means
    modify some of the fields in a resource, while `PUT` means *replace* the entire
    resource. It can take some practice to get the hang of building applications this
    way, but it’s pragmatic and easy to test, so it’s worth learning properly. If
    these HTTP terms are new to you, then use [table 9.1](#ch09table01) when you’re
    designing the API for your application.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9.1](#ch09table01) 展示了 HTTP 动词和典型响应。请注意，`PUT` 和 `PATCH` 有不同但相似的含义——`PATCH`
    意味着修改资源中的某些字段，而 `PUT` 意味着 *替换* 整个资源。通过这种方式构建应用程序可能需要一些实践，但它很实用且易于测试，因此值得正确学习。如果你对这些
    HTTP 术语不熟悉，那么在为你的应用程序设计 API 时，请使用 [表 9.1](#ch09table01)。'
- en: Table 9.1\. Choosing the correct HTTP verbs
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.1\. 选择正确的 HTTP 动词
- en: '| Verb | Description | Response |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | 描述 | 响应 |'
- en: '| --- | --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| GET /animals | Get a list of animals. | An array of animal objects |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| GET /animals | 获取动物列表。 | 一组动物对象数组 |'
- en: '| GET /animals/:id | Get a single animal. | A single animal object, or an error
    |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| GET /animals/:id | 获取单个动物。 | 一个单个动物对象，或一个错误 |'
- en: '| POST /animals | Create an animal by sending the properties of a single animal.
    | The new animal |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| POST /animals | 通过发送单个动物的属性来创建一个动物。 | 新的动物 |'
- en: '| PUT /animals/:id | Update a single animal record. All properties will be
    replaced. | The updated animal |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| PUT /animals/:id | 更新单个动物记录。所有属性将被替换。 | 更新的动物 |'
- en: '| PATCH /animals/:id/ | Update a single animal record, but only change the
    fields specified. | The updated animal |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| PATCH /animals/:id/ | 更新单个动物记录，但只更改指定的字段。 | 更新的动物 |'
- en: In an Express application, these URLs and methods are mapped using routes. Routes
    specify the HTTP verb and a partial URL. You can map these to any function that
    you like, but if you use the route separation pattern from [technique 67](#ch09lev2sec4),
    which is advisable, then you should use the method names that are close to their
    associated HTTP verbs. [Listing 9.18](#ch09ex18) shows the routes for a RESTful
    resource in Express, and some of the required configuration to make it work.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 应用程序中，这些 URL 和方法是通过路由映射的。路由指定 HTTP 动词和部分 URL。你可以将这些映射到任何你喜欢的函数，但如果你使用来自
    [技术 67](#ch09lev2sec4) 的路由分离模式，这是建议的，那么你应该使用与相关 HTTP 动词相近的方法名。[列表 9.18](#ch09ex18)
    展示了 Express 中 RESTful 资源的路由，以及一些使其工作的必要配置。
- en: Listing 9.18\. A RESTful resource in Express
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18\. Express 中的 RESTful 资源
- en: '![](225fig01_alt.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片 225fig01_alt](225fig01_alt.jpg)'
- en: This example uses some middleware for automatically parsing JSON requests ![](1.jpg),
    and overrides the HTTP method `POST` with the query parameter, `_method` ![](2.jpg).
    That means that the `PUT`, `PATCH`, and `DELETE` HTTP verbs are actually determined
    by the `_method` query parameter. This is because most browsers can only send
    a `GET` or `POST`, so `_method` is a hack used by many web frameworks.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了一些中间件来自动解析 JSON 请求 ![图片 1](1.jpg)，并且通过查询参数 `_method` 覆盖了 HTTP 方法 `POST`
    ![图片 2](2.jpg)。这意味着 `PUT`、`PATCH` 和 `DELETE` HTTP 动词实际上是由 `_method` 查询参数确定的。这是因为大多数浏览器只能发送
    `GET` 或 `POST`，所以 `_method` 是许多 Web 框架使用的技巧。
- en: The routes in [listing 9.18](#ch09ex18) define each of the usual RESTful resource
    methods ![](3.jpg). [Table 9.1](#ch09table01) shows how these routes map to actions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.18](#ch09ex18) 中的路由定义了每个常用的 RESTful 资源方法 ![图片 3](3.jpg)。[表 9.1](#ch09table01)
    展示了这些路由如何映射到操作。'
- en: Table 9.2\. Mapping routes to responses
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 9.2\. 将路由映射到响应
- en: '| Verb, URL | Description |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 动词，URL | 描述 |'
- en: '| --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GET /pages | An array of pages. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| GET /pages | 一组页面。 |'
- en: '| GET /pages/:id | An object containing the page specified by id. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| GET /pages/:id | 包含指定 id 的页面的对象。 |'
- en: '| POST /pages | Create a page. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| POST /pages | 创建一个页面。 |'
- en: '| PATCH /pages/:id | Load the page for id, and change some of the fields. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| PATCH /pages/:id | 加载 id 对应的页面，并更改一些字段。 |'
- en: '| PUT /pages/:id | Replace the page for id. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| PUT /pages/:id | 替换 id 对应的页面。 |'
- en: '| DELETE /pages/:id | Remove the page for id. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| DELETE /pages/:id | 删除 id 对应的页面。 |'
- en: '[Listing 9.19](#ch09ex19) is an example implementation for the route handlers.
    It has a generic Node database API—a real Redis, MongoDB, MySQL, or PostgreSQL
    database module wouldn’t be too far off, so you should be able to adapt it.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.19](#ch09ex19) 是路由处理器的示例实现。它有一个通用的 Node 数据库 API——一个真实的 Redis、MongoDB、MySQL
    或 PostgreSQL 数据库模块不会太远，所以你应该能够适应它。'
- en: Listing 9.19\. RESTful route handlers
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. RESTful 路由处理器
- en: '![](ch09ex19-0.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex19-0.jpg)'
- en: '![](ch09ex19-1.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex19-1.jpg)'
- en: 'Although this example is simple, it illustrates something important: you should
    keep your route handlers lightweight. They deal with HTTP and then let other parts
    of your code handle the underlying business logic. Another pattern used in this
    example is the error handling—errors are passed by calling `next(err)` ![](1.jpg).
    Try to keep error-handling code centralizing and generic—[technique 70](#ch09lev2sec7)
    has more details on this.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然这个例子很简单，但它说明了很重要的一点：你应该保持你的路由处理器轻量级。它们处理 HTTP，然后让代码的其他部分处理底层业务逻辑。这个例子中使用的另一个模式是错误处理——通过调用
    `next(err)` 传递错误！![1](1.jpg)。尽量将错误处理代码集中化和通用化——[技术 70](#ch09lev2sec7) 有更多细节。 '
- en: To return the JSON to the browser, `res.send()` is called with a JavaScript
    object ![](2.jpg). Express knows how to convert the object to JSON, so that’s
    all you need to do.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JSON 返回到浏览器，使用 `res.send()` 并传入一个 JavaScript 对象！![2](2.jpg)。Express 知道如何将对象转换为
    JSON，所以你只需要做这件事。
- en: 'All of these route handlers use the same pattern: map the query or body to
    something the database can use, and then call the corresponding database method.
    If you’re using an ORM or ODM—a more abstracted database layer—then you’ll probably
    have something analogous to `PATCH` ![](3.jpg). This could be an API method that
    allows you to update only the specified fields. Relational databases and MongoDB
    work that way.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些路由处理器都使用相同的模式：将查询或请求体映射到数据库可以使用的某个东西，然后调用相应的数据库方法。如果你使用 ORM 或 ODM——一个更抽象的数据库层——那么你可能会有类似于
    `PATCH` 的东西！这可以是一个允许你只更新指定字段的 API 方法。关系数据库和 MongoDB 就是这么工作的。
- en: If you download this book’s source code, you’ll get the other files required
    to try out the full example. To run it, type `npm start`. Once the server is running,
    you can use some of the following Curl commands to communicate with the server.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下载这本书的源代码，你将获得尝试完整示例所需的其他文件。要运行它，请输入 `npm start`。一旦服务器运行，你可以使用以下一些 Curl 命令与服务器通信。
- en: 'The first command creates a page:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了一个页面：
- en: '![](227fig01_alt.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](227fig01_alt.jpg)'
- en: First we specify the `Content-Type` using the `-H` option ![](1.jpg). Next,
    the request is set to use `POST`, and the request body is included as a JSON string
    ![](2.jpg). The URL is /pages because we’re creating a resource ![](3.jpg).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `-H` 选项指定 `Content-Type`！![1](1.jpg)。接下来，请求被设置为使用 `POST`，请求体作为 JSON
    字符串包含在内！![2](2.jpg)。URL 是 /pages，因为我们正在创建一个资源！![3](3.jpg)。
- en: Curl is a useful tool for exploring APIs, once you understand the basic options.
    The ones to remember are `-H` for setting headers, `-X` for setting the HTTP method,
    and `-d` for the request body.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Curl 是一个探索 API 的有用工具，一旦你理解了基本选项。需要记住的是 `-H` 用于设置头部，`-X` 用于设置 HTTP 方法，以及 `-d`
    用于请求体。
- en: 'To see the list of pages, just use `curl http://localhost:3000/pages`. To change
    the contents, try `PATCH`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看页面列表，只需使用 `curl http://localhost:3000/pages`。要更改内容，尝试使用 `PATCH`：
- en: '[PRE1]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Express has a few other tricks up its sleeves for creating RESTful web services.
    Remember that some REST APIs use other data formats, like XML? What if you want
    both? You can solve this by using `res.format`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Express 在创建 RESTful 网络服务方面还有一些其他的技巧。记住，一些 REST API 使用其他数据格式，比如 XML？如果你两者都需要怎么办？你可以通过使用
    `res.format` 来解决这个问题：
- en: '![](228fig01_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](228fig01_alt.jpg)'
- en: 'To use XML instead of JSON, you have to include the `Accept` header in the
    request. With Curl, you can do this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 XML 而不是 JSON，你必须在请求中包含 `Accept` 头部。使用 Curl，你可以这样做：
- en: '[PRE2]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just remember that `Accept` is used to ask the server for a specific format,
    and `Content-Type` is used to tell the server what format you’re sending it. It
    sometimes makes sense to include both in a single request!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，`Accept` 用于请求服务器提供特定的格式，而 `Content-Type` 用于告诉服务器你发送的格式。有时在单个请求中包含两者是有意义的！
- en: Now that you’ve seen how REST APIs in Express work, we can compare them with
    restify. The patterns used to structure Express applications can be reused for
    restify projects. The two important patterns are route separation, as described
    in [technique 67](#ch09lev2sec4), and defining the application in a separate file
    to the server (for easier testing and internal reuse). [Listing 9.20](#ch09ex20)
    is the restify equivalent of [listing 9.18](#ch09ex18).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Express 中的 REST API 的工作方式，我们可以将其与 restify 进行比较。用于构建 Express 应用的模式可以用于
    restify 项目。两个重要的模式是路由分离，如 [技术 67](#ch09lev2sec4) 中所述，以及将应用程序定义在服务器之外的单独文件中（以便于测试和内部重用）。[列表
    9.20](#ch09ex20) 是 [列表 9.18](#ch09ex18) 在 restify 中的对应版本。
- en: Listing 9.20\. A restify application
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.20\. 一个 restify 应用
- en: '![](228fig02_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![228fig02_alt.jpg](228fig02_alt.jpg)'
- en: Using restify, instances of servers are created with some initial configuration
    options ![](1.jpg). You don’t have to pass in any options, but here we’ve specified
    a name. The options are actually the same as Node’s built-in `http.Server.listen`,
    so you can pass in options for SSL/TLS certificates, if you want to use encryption.
    Restify-specific options that aren’t available in Express include `formatters`,
    which allows you to set up functions that `res.send` will use for custom content
    types.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 restify，服务器实例通过一些初始配置选项创建 ![1.jpg](1.jpg)。你不必传递任何选项，但在这里我们指定了一个名称。这些选项实际上与
    Node 内置的 `http.Server.listen` 相同，因此你可以传递 SSL/TLS 证书的选项，如果你想使用加密的话。restify 特有的选项，在
    Express 中不可用，包括 `formatters`，它允许你设置 `res.send` 将用于自定义内容类型的函数。
- en: This example uses `bodyParser` to parse JSON in the request bodies ![](2.jpg).
    This is like the Express middleware component in the previous example.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `bodyParser` 解析请求体中的 JSON ![2.jpg](2.jpg)。这就像上一个示例中的 Express 中间件组件。
- en: The route definitions are identical to Express ![](3.jpg). The actual route
    callbacks are slightly different. [Listing 9.21](#ch09ex21) shows a translation
    of [listing 9.19](#ch09ex19). See if you can spot the differences.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义与 Express 的定义相同 ![3.jpg](3.jpg)。实际的回调函数略有不同。[列表 9.21](#ch09ex21) 展示了 [列表
    9.19](#ch09ex19) 的翻译。看看你是否能找出其中的差异。
- en: Listing 9.21\. Restify routes
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.21\. Restify 路由
- en: '![](ch09ex21-0.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex21-0.jpg](ch09ex21-0.jpg)'
- en: '![](ch09ex21-1.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex21-1.jpg](ch09ex21-1.jpg)'
- en: 'The first thing to note is the callback arguments for route handlers are the
    same as Express ![](1.jpg). In fact, you can almost lift the equivalent code directly
    from Express applications. There are a few differences though: `req.param()` doesn’t
    exist—you need to use `req.params` instead, and note this is an object rather
    than a method ![](2.jpg). Like Express, calling `res.send()` with an integer will
    return a status code to the client ![](3.jpg).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是路由处理程序的回调参数与 Express ![1.jpg](1.jpg) 相同。实际上，你几乎可以直接从 Express 应用中提取等效代码。尽管如此，也有一些差异：`req.param()`
    不存在——你需要使用 `req.params` 代替，注意这是一个对象而不是一个方法 ![2.jpg](2.jpg)。与 Express 一样，使用整数调用
    `res.send()` 将向客户端返回状态码 ![3.jpg](3.jpg)。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using other HTTP headers**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用其他 HTTP 头部**'
- en: In this technique you’ve seen how the `Content-Type` and `Accept` headers can
    be used to deal with different data formats. There are other useful headers that
    you should take into account when building APIs.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，你已经看到了如何使用 `Content-Type` 和 `Accept` 头部来处理不同的数据格式。在构建 API 时，你应该考虑其他有用的头部。
- en: One such header, supported by restify, is `Accept-Version`. When you define
    a route, you can include an optional first parameter that includes options, instead
    of the usual string. The `version` property allows your API to respond differently
    based on the `Accept-Version` header.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个受 restify 支持的头部是 `Accept-Version`。当你定义一个路由时，你可以包含一个可选的第一个参数，该参数包含选项，而不是通常的字符串。`version`
    属性允许你的 API 根据不同的 `Accept-Version` 头部做出不同的响应。
- en: 'For example, using `app.get({ path: ''/pages'', version: ''1.1.8'' }`, routes
    `.v1.pages)`; allows you to bind specific route handlers to version 1.1.8\. If
    you have to change your API in 2.0.0, then you can do this without breaking older
    clients.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，使用 `app.get({ path: ''/pages'', version: ''1.1.8'' })`，将 `.v1.pages` 路由绑定到特定版本
    1.1.8。如果你必须在 2.0.0 中更改你的 API，那么你可以这样做而不会破坏旧客户端。'
- en: There’s nothing to stop you from using this header in an Express application,
    but it’s easier in restify. If you decide to take this approach, you should learn
    how *major.minor.patch* works in semantic versioning ([http://semver.org/](http://semver.org/)).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 应用程序中使用此标题没有任何阻碍，但在 restify 中会更简单。如果你决定采取这种方法，你应该了解 *major.minor.patch*
    在语义版本控制中的工作方式 ([http://semver.org/](http://semver.org/))。
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you download the full example and run it (listings/web/restify), you can
    try out some of the Curl commands we described earlier. Create, update, and show
    should work the same way.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下载了完整示例并运行它（listings/web/restify），你可以尝试我们之前描述的一些 Curl 命令。创建、更新和显示应该以相同的方式工作。
- en: Knowing that Express and restify applications are similar is useful, because
    you can start to compose applications made from both frameworks. Both are based
    on Node’s `http` module, which means you could technically mount a restify application
    inside Express using `app.use(restifyApp)`. This works well if the restify application
    is in its own module—you could install it using npm, or put it in its own directory.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Express 和 restify 应用程序相似是有用的，因为你可以开始组合由这两个框架组成的应用程序。它们都基于 Node 的 `http` 模块，这意味着技术上你可以在
    Express 中挂载一个 restify 应用程序使用 `app.use(restifyApp)`。如果 restify 应用程序在其自己的模块中，这会工作得很好——你可以使用
    npm 安装它，或者将其放在自己的目录中。
- en: Both Express and restify use middleware, and you’ll find well-structured applications
    have loosely coupled middleware that can be reused across different projects.
    In the next technique you’ll see how to write your own middleware, so you can
    start decorating applications with useful features like custom logging.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Express 和 restify 都使用中间件，你会发现结构良好的应用程序具有松散耦合的中间件，可以在不同的项目中重用。在下一个技术中，你将看到如何编写自己的中间件，这样你就可以开始用有用的功能，如自定义日志记录来装饰应用程序。
- en: Technique 72 Using custom middleware
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 72 使用自定义中间件
- en: You’ve seen middleware being used for error handling, and you’ve also used some
    of Express’s built-in middleware. You can also use middleware to add custom behavior
    to routes; this might add new functionality, improve logging, or control access
    based on authentication or permissions.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了中间件被用于错误处理，你也使用了一些 Express 的内置中间件。你还可以使用中间件为路由添加自定义行为；这可能添加了新功能，改进了日志记录，或者基于身份验证或权限控制访问。
- en: The benefit of middleware is that it can improve code reuse in your application.
    This technique will teach you how to write your own middleware, so you can share
    code between projects, and structure projects in a more readable way.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的好处是它可以提高你应用程序中的代码重用性。这个技术将教会你如何编写自己的中间件，这样你就可以在项目之间共享代码，并以更可读的方式组织项目。
- en: Problem
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add behavior—in a reusable, testable manner—that’s triggered when
    certain routes are accessed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望添加行为——以可重用和可测试的方式——当访问某些路由时被触发。
- en: Solution
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write your own middleware.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 编写你自己的中间件。
- en: Discussion
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When you first start using Express, middleware sounds like a complicated concept
    that other people use for writing plugins that extend Express. But in fact, writing
    middleware is a fundamental part of using Express, and you should start writing
    middleware as soon as possible. And if you can write routes, then you can write
    middleware: it’s basically the same API!'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次开始使用 Express 时，中间件听起来像是一个复杂的概念，其他人用它来编写扩展 Express 的插件。但实际上，编写中间件是使用 Express
    的基本部分，你应该尽快开始编写中间件。而且如果你能编写路由，那么你就可以编写中间件：它基本上是相同的 API！
- en: 'In [technique 70](#ch09lev2sec7), you saw how to handle errors with a middleware
    component. Error handling is a special case—you have to include a fourth parameter
    to capture the error object: `app.use(function(err, req, res, next) {`. With other
    middleware, you can just use three arguments, like standard route handlers. This
    is the simplest middleware component:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [技巧 70](#ch09lev2sec7) 中，你看到了如何使用中间件组件处理错误。错误处理是一个特殊情况——你必须包含一个第四个参数来捕获错误对象：`app.use(function(err,
    req, res, next) {`。对于其他中间件，你可以只使用三个参数，就像标准的路由处理程序一样。这是最简单的中间件组件：
- en: '![](231fig01_alt.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](231fig01_alt.jpg)'
- en: 'By passing an anonymous callback to `app.use` ![](1.jpg), the middleware component
    will always run, unless a previous middleware component fails to call `next`.
    When your code is finished, you can call `next` ![](2.jpg) to trigger the next
    middleware component in the stack. That means two things: asynchronous APIs are
    supported, and the order in which you add middleware is important.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`app.use`传递匿名回调 ![](1.jpg)，中间件组件将始终运行，除非之前的中间件组件未能调用`next`。当您的代码完成后，您可以调用`next`
    ![](2.jpg)来触发堆栈中的下一个中间件组件。这意味着两件事：支持异步API，并且添加中间件的顺序很重要。
- en: 'The following example shows how you can use asynchronous APIs inside middleware.
    This example is based on the idea of loading a user based on a user ID that has
    been set in the session:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了您如何在中间件中使用异步API。此示例基于根据会话中设置的用户ID加载用户的思想：
- en: '![](232fig01_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig01_alt.jpg)'
- en: 'This middleware will be triggered for every request ![](1.jpg). It loads user
    accounts from a database, but only when the user’s ID has been set in the session
    ![](2.jpg). The code that loads the user is asynchronous, so `next` could be called
    after a short delay. There are several points where `next` is called: for example,
    if an error was encountered when loading the user, `next` will be called with
    an error ![](3.jpg).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件将对每个请求触发 ![](1.jpg)。它从数据库中加载用户账户，但仅在会话中设置了用户的ID ![](2.jpg)。加载用户的代码是异步的，因此`next`可以在短暂的延迟后调用。有几个地方会调用`next`：例如，如果在加载用户时遇到错误，`next`将带有错误调用
    ![](3.jpg)。
- en: In this example the loaded user is set as a property of `res.locals` ![](4.jpg).
    By using `res.locals`, you’ll be able to access the user in other middleware,
    route handlers, and templates.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，加载的用户被设置为`res.locals`属性 ![](4.jpg)。通过使用`res.locals`，您将能够在其他中间件、路由处理程序和模板中访问用户。
- en: 'This isn’t necessarily the best way to use middleware. Including an anonymous
    function this way means it can be hard to test—you can only test middleware by
    starting up the entire Express application. You might want to write simpler unit
    tests that don’t use HTTP requests, so it would be better to refactor this code
    into a function. The function would have the same signature, and would be used
    like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定是最有效的使用中间件的方式。以这种方式包含匿名函数意味着它很难测试——您只能通过启动整个Express应用程序来测试中间件。您可能想编写更简单的单元测试，这些测试不使用HTTP请求，因此最好将此代码重构为函数。该函数将具有相同的签名，并像这样使用：
- en: '![](232fig02_alt.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](232fig02_alt.jpg)'
- en: By grouping all the middleware together as modules ![](1.jpg), you can load
    the middleware from other locations, whether they’re entirely different projects,
    test code, or inside separated routes. This function has decoupled the middleware
    to improve how it can be reused.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有中间件模块化 ![](1.jpg)，您可以从其他位置加载中间件，无论是完全不同的项目、测试代码，还是分离的路由中。这个功能将中间件解耦，以改善其可重用性。
- en: 'If you’re using the route separation pattern from [technique 67](#ch09lev2sec4),
    then this makes sense, because middleware can be applied to specific routes that
    might be defined in different files. Let’s say you’re using the RESTful API style
    from [technique 71](#ch09lev2sec8), and your *page* resource can only be updated
    by signed-in users, but other parts of the application should be accessible to
    anyone. You can restrict access to the page resource routes like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用[技术67](#ch09lev2sec4)中的路由分离模式，那么这样做是有意义的，因为中间件可以应用于可能定义在不同文件中的特定路由。假设您正在使用[技术71](#ch09lev2sec8)中的RESTful
    API风格，并且您的*页面*资源只能由已登录用户更新，但应用程序的其他部分应该对任何人可访问。您可以这样限制对页面资源路由的访问：
- en: '![](233fig01_alt.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](233fig01_alt.jpg)'
- en: In this fragment, routes are defined for a resource called `pages`. Some routes
    are accessible to anyone ![](1.jpg), but creating or updating pages is limited
    to people with accounts on the system ![](2.jpg). This is done by supplying the
    `loadUser` middleware component as the second argument when defining a route.
    In fact, multiple arguments could be used—you could have a generic user loading
    route, and then a more specific permission checking route that ensures users are
    administrators, or have the necessary rights to change pages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，为名为`pages`的资源定义了路由。一些路由对任何人可访问 ![](1.jpg)，但创建或更新页面仅限于系统上有账户的人 ![](2.jpg)。这是通过在定义路由时将`loadUser`中间件组件作为第二个参数来实现的。实际上，可以使用多个参数——您可以有通用的用户加载路由，然后是一个更具体的权限检查路由，确保用户是管理员或拥有更改页面的必要权利。
- en: '[Figure 9.4](#ch09fig04) shows how requests can pass through several callbacks
    until the final response is sent back to the client. Sometimes this might cause
    a response to finish before other middleware has had a chance to run—if an error
    is encountered and passed to `next(err)`.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.4](#ch09fig04) 展示了请求如何穿过几个回调，直到最终将响应发送回客户端。有时这可能会在其他中间件有机会运行之前完成响应——如果遇到错误并将其传递给
    `next(err)`。'
- en: Figure 9.4\. Requests can pass through several callbacks until the final response
    is sent.
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 请求可以穿过几个回调，直到最终响应被发送。
- en: '![](09fig04.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04.jpg)'
- en: You can even apply middleware to batches of routes. It’s common to see something
    like `app.all('/admin/*', middleware.loadUser);` in Express applications.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将中间件应用到路由批处理中。在 Express 应用程序中，常见到类似 `app.all('/admin/*', middleware.loadUser);`
    的用法。
- en: If you use modules to manage your middleware, and simplify route handlers by
    moving shared functionality into separate files, then you’ll find that organizing
    middleware into modules becomes a fundamental architectural tool for organizing
    applications.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用模块来管理你的中间件，并通过将共享功能移动到单独的文件来简化路由处理程序，那么你会发现将中间件组织成模块成为组织应用程序的基本架构工具。
- en: If you’re designing a new Express application, you should think in terms of
    middleware. Ask yourself what kinds of HTTP requests you’re going to deal with,
    and what kinds of filtering they might need.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个新的 Express 应用程序，你应该从中间件的角度来思考。问问自己你将处理哪些类型的 HTTP 请求，以及它们可能需要什么样的过滤。
- en: 'Now it’s time to combine all of these ideas into a worked example. [Listing
    9.22](#ch09ex22) demonstrates one way of parsing requests that contain XML. Middleware
    has been used to parse the XML, turning it into plain old JavaScript objects.
    That means two things: only a small part of your code has to worry about XML,
    and you could potentially add support for other data formats as well.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将这些想法结合成一个工作示例了。[列表 9.22](#ch09ex22) 展示了处理包含 XML 的请求的一种方法。中间件被用来解析 XML，将其转换为普通的
    JavaScript 对象。这意味着两件事：只有你代码的一小部分需要关心 XML，而且你还可以潜在地添加对其他数据格式的支持。
- en: Listing 9.22\. Three types of middleware
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.22\. 三种类型的中间件
- en: '![](ch09ex22-0.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex22-0.jpg)'
- en: '![](ch09ex22-1.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex22-1.jpg)'
- en: In summary, this example defines three middleware components to parse XML, validate
    it, and then either respond with a JSON object or display an error. We’ve used
    an arbitrary data-validation library here ![](1.jpg)—your database module may
    come with something similar.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个示例定义了三个中间件组件来解析 XML，验证它，然后要么以 JSON 对象的形式响应，要么显示错误。我们在这里使用了一个任意的数据验证库
    ![1.jpg]——你的数据库模块可能自带类似的功能。
- en: The routes deal with *page* resources, and the expected format for pages is
    XML. It’s passed in as request bodies and validated. An error object, `ValidatorError`
    ![](2.jpg), is used to return a 400 error when invalid data is sent to the server.
    The XML parser ![](3.jpg) reads in the request body using the standard event-based
    API ![](4.jpg). This middleware component is called for every request ![](8.jpg)
    because it’s passed directly to `app.use`, but it only runs if the `Content-Type`
    is set to XML.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理 *页面* 资源，页面的预期格式是 XML。它作为请求体传递并进行验证。当将无效数据发送到服务器时，使用错误对象 `ValidatorError`
    ![2.jpg] 返回 400 错误。XML 解析器 ![3.jpg] 使用标准基于事件的 API ![4.jpg] 读取请求体。这个中间件组件对每个请求都进行调用
    ![8.jpg]，因为它直接传递给 `app.use`，但它只有在 `Content-Type` 设置为 XML 时才会运行。
- en: The data-validation middleware component ![](5.jpg) ensures a page title has
    been set—this is just an arbitrary example we’ve chosen to illustrate how this
    kind of validation works. If the data is invalid, an instance of `ValidatorError`
    is passed when `next` is called ![](6.jpg). This will trigger the error-handling
    middleware component ![](7.jpg).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证中间件组件 ![5.jpg] 确保页面标题已被设置——这只是一个我们选择的任意示例，用来说明这种验证是如何工作的。如果数据无效，当调用 `next`
    时会传递一个 `ValidatorError` 实例 ![6.jpg]。这将触发错误处理中间件组件 ![7.jpg]。
- en: Data is only validated for certain requests. This is done by passing `checkValidXml`
    when the /pages route is defined ![](9.jpg).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在特定的请求中对数据进行验证。这是通过在定义 /pages 路由时传递 `checkValidXml` 来完成的 ![9.jpg]。
- en: The global error handler is the last middleware component to be added ![](10.jpg).
    This should always be the case, because middleware is executed in the order it’s
    defined. Once `res.send` has been called, then no more processing will occur,
    so errors won’t be triggered.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 全局错误处理器是最后添加的中间件组件 ![10.jpg]。这应该是始终如此，因为中间件的执行顺序是按照定义的顺序。一旦调用 `res.send`，则不会进行更多处理，因此不会触发错误。
- en: 'To try this example out, run `node server.js` and then try posting XML to the
    server using `curl`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个示例，请运行`node server.js`，然后使用`curl`将XML发布到服务器：
- en: '[PRE3]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should try leaving out a title to ensure a 400 error is raised!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试省略标题以确保引发400错误！
- en: This approach can be used for XML, JSON, CSV, or any other data formats you
    like. It works well for minimizing the code that has to deal with XML, but there
    are other ways you can write decoupled code in Node web applications. In the next
    technique you’ll see how something fundamental to Node—events—can be used as another
    useful architectural pattern.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以用于XML、JSON、CSV或你喜欢的任何其他数据格式。它非常适合最小化处理XML的代码，但还有其他方法可以在Node网络应用程序中编写解耦代码。在下一个技巧中，你将看到Node的一个基本功能——事件——如何被用作另一个有用的架构模式。
- en: Technique 73 Using events to decouple functionality
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧73 使用事件解耦功能
- en: In the average Express application, most code is organized into methods and
    modules. This can make sharing functionality inconvenient in some cases, particularly
    if you want to neatly separate concerns within your application. This technique
    uses sending emails as an example of something that doesn’t fit neatly into routers,
    models, or views. Events are used to decouple emails from routers, which keeps
    email-related code outside of HTTP code.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在平均的Express应用程序中，大多数代码被组织成方法和模块。这可能在某些情况下使功能共享变得不方便，尤其是如果你想在你应用程序中整齐地分离关注点。这个技术以发送电子邮件作为例子，说明了一些不适合放入路由器、模型或视图中的东西。事件被用来解耦电子邮件和路由器，将电子邮件相关的代码保持在HTTP代码之外。
- en: Problem
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to do things that aren’t related to HTTP, like send emails, but aren’t
    sure how to structure the code so it’s neatly decoupled and easy to test.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你想做一些与HTTP无关的事情，比如发送电子邮件，但不确定如何构建代码以便它能够整齐地解耦且易于测试。
- en: Solution
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use easily accessible `EventEmitter` objects, like the Express `app` object.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用易于访问的`EventEmitter`对象，例如Express的`app`对象。
- en: Discussion
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Express and restify applications generally follow the Model-View-Controller
    (MVC) pattern. Models are used to save data, controllers are route handlers, and
    views are the templates in the views/directory.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Express和restify应用程序通常遵循模型-视图-控制器（MVC）模式。模型用于保存数据，控制器是路由处理器，视图是views目录中的模板。
- en: Some code doesn’t fit neatly into these categories. For example, where would
    you keep email-handling code? Email generation clearly doesn’t belong in routes,
    because email isn’t related to HTTP. But like route handlers, it does require
    templates. It also isn’t really a model, because it doesn’t interact with the
    database.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有些代码并不适合整齐地归入这些类别。例如，你会把处理电子邮件的代码放在哪里？显然，电子邮件生成不属于路由，因为电子邮件与HTTP无关。但就像路由处理器一样，它确实需要模板。它也不是真正的模型，因为它不与数据库交互。
- en: What if you did put the email-handling code into models? In that case, given
    an instance of a `User` model, you want to send an email when a new account is
    created. You could put the email code in the `User.prototype.registerUser` method.
    The problem with that is you might not always want to send emails when users are
    created. It might not be convenient during testing, or some kind of periodic maintenance
    tasks.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把处理电子邮件的代码放入模型中会怎样？在这种情况下，给定一个`User`模型的实例，你希望在创建新账户时发送电子邮件。你可以在`User.prototype.registerUser`方法中放置电子邮件代码。问题是，你可能并不总是想在用户创建时发送电子邮件。在测试期间可能不方便，或者是一些周期性的维护任务。
- en: 'The reason why sending email isn’t quite suitable for models or HTTP routes
    can be understood by thinking about the SOLID principles ([http://en.wikipedia.org/wiki/SOLID](http://en.wikipedia.org/wiki/SOLID)).
    There are two principles that are relevant to us: the *single responsibility principle*
    and the *dependency inversion principle*.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么发送电子邮件并不完全适合模型或HTTP路由可以通过思考SOLID原则([http://en.wikipedia.org/wiki/SOLID](http://en.wikipedia.org/wiki/SOLID))来理解。有两个原则与我们相关：*单一职责原则*和*依赖倒置原则*。
- en: Single responsibility dictates that the class that deals with HTTP routes really
    shouldn’t send emails, because these are different responsibilities that shouldn’t
    be mixed together. Inversion of control is a specific type of dependency inversion,
    and can be done by removing direct invocation—rather than calling `emails.sendAccount-Creation`,
    your email-handling class should respond to events.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则规定，处理HTTP路由的类实际上真的不应该发送电子邮件，因为这些是不同的职责，不应该混合在一起。控制反转是依赖倒置的一种特定类型，可以通过移除直接调用来实现——而不是调用`emails.sendAccount-Creation`，你的电子邮件处理类应该响应事件。
- en: For Node programmers, events are one of the most important tools available.
    And fortunately for us, the SOLID principles indicate that we can write better
    HTTP routers by removing our email code, and replacing it with abstract and generalized
    events. These events can then be responded to by the relevant classes.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node程序员来说，事件是他们可用的重要工具之一。幸运的是，SOLID原则表明我们可以通过移除我们的电子邮件代码，并用抽象和通用的事件来替换它，从而编写更好的HTTP路由器。这些事件然后可以被相关类响应。
- en: '[Figure 9.5](#ch09fig05) shows what our idealized application structure might
    look like. But how do we achieve this? Take Express applications as an example;
    they don’t typically have a suitable global event object. You could technically
    create a global variable somewhere central, like the file that calls `express()`,
    but that would introduce a global shared state, and that would break the principles
    we described earlier.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.5](#ch09fig05)显示了我们的理想化应用程序结构可能的样子。但我们如何实现这一点呢？以Express应用程序为例；它们通常没有合适的全局事件对象。你可以在某个中心位置技术上创建一个全局变量，比如调用`express()`的文件，但这会引入全局共享状态，这将破坏我们之前描述的原则。'
- en: Figure 9.5\. Applications can be easier to understand if organized according
    to the SOLID principles.
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. 如果根据SOLID原则组织，应用程序可能更容易理解。
- en: '![](09fig05.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig05.jpg)'
- en: Fortunately, Express includes a reference to the `app` object in the request.
    Route handlers, which accept the `req, res` parameters, always have access to
    `app` in `res.app`. The `app` object inherits from `EventEmitter`, so we can use
    it to broadcast when things happen. If your route handler creates and saves new
    users, then it can also call `res.app.emit('user:created', user)`, or something
    similar—you can use any naming scheme for events as long as it’s consistent. Then
    you can listen for `user:created` events and respond accordingly. This could include
    sending email notifications, or perhaps even logging useful statistics about users.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Express在请求中包含对`app`对象的引用。路由处理程序，接受`req, res`参数，始终可以在`res.app`中访问`app`。`app`对象继承自`EventEmitter`，因此我们可以用它来广播事件发生。如果你的路由处理程序创建并保存了新用户，那么它也可以调用`res.app.emit('user:created',
    user)`，或者类似的东西——只要命名方案一致，你可以使用任何命名方案来表示事件。然后你可以监听`user:created`事件并相应地做出反应。这可能包括发送电子邮件通知，或者甚至记录有关用户的有用统计数据。
- en: The following listing shows how to listen for events on the application object.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何在应用程序对象上监听事件。
- en: Listing 9.23\. Using events to structure an application
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.23\. 使用事件来构建应用程序
- en: '![](237fig01_alt.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](237fig01_alt.jpg)'
- en: In this example a route for registering users is defined ![](1.jpg), and then
    an event listener is defined and bound to a method that sends emails ![](2.jpg).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中定义了一个用于注册用户的路由![](1.jpg)，然后定义了一个事件监听器并将其绑定到一个发送电子邮件的方法![](2.jpg)。
- en: The route is shown in the next listing.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 路由在下一列表中显示。
- en: Listing 9.24\. Emitting events
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.24\. 发射事件
- en: '![](237fig02_alt.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](237fig02_alt.jpg)'
- en: This listing contains an example model for `User` objects. If a user is successfully
    created, then `user:created` is emitted on the `app` object. The downloadable
    code for this book includes a more complete example with the code that sends emails,
    but the basic principle for removing direct invocation and adhering to the single
    responsibility principle is represented here.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表包含`User`对象的示例模型。如果用户成功创建，则`app`对象上会发出`user:created`。本书的可下载代码包括一个更完整的示例，其中包含发送电子邮件的代码，但移除直接调用并遵循单一责任原则的基本原则在这里得到了体现。
- en: Communication with events inside applications is useful when you need to make
    the code easier for other developers to understand. There are also times when
    you need to communicate with client-side code. The next technique shows you how
    to take advantage of WebSockets in your Node applications, while still being able
    to access resources like sessions.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内部使用事件进行通信，当你需要使代码更容易让其他开发者理解时很有用。也有时候你需要与客户端代码进行通信。下一项技术将向你展示如何在Node应用程序中利用WebSockets，同时仍然能够访问会话等资源。
- en: Technique 74 Using sessions with WebSockets
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧74 使用WebSockets与会话
- en: 'Node has strong support for the real-time web. Adopting event-oriented, asynchronous
    APIs means supporting WebSockets is a natural fit. Also, it’s trivial to run two
    servers in the same process: a WebSocket server and a standard Node HTTP server
    can coexist happily.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Node对实时Web有很强的支持。采用面向事件、异步API意味着支持WebSockets是一个自然的选择。此外，在同一进程中运行两个服务器是微不足道的：WebSocket服务器和标准Node
    HTTP服务器可以愉快地共存。
- en: This technique shows you how to reuse the Connect and Express middleware that
    we’ve been using so far with a WebSocket server. If your application allows users
    to sign in, and you want to add WebSocket support, then read on to learn how to
    master sessions in WebSockets.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了如何重用我们迄今为止与WebSocket服务器一起使用的Connect和Express中间件。如果你的应用程序允许用户登录，并且你想添加WebSocket支持，那么继续阅读以了解如何掌握WebSocket中的会话。
- en: Problem
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add WebSocket support to an existing Express application, but you’re
    not sure how to access session variables, like whether the user is currently signed
    in.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你想为现有的Express应用程序添加WebSocket支持，但你不确定如何访问会话变量，比如用户是否当前已登录。
- en: Solution
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Reuse Connect’s cookie and session middleware with your WebSocket server.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的WebSocket服务器上重用Connect的cookie和session中间件。
- en: Discussion
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This technique assumes you have a passing familiarity with WebSockets. To recap:
    HTTP requests are stateless and relatively short-lived. They’re great for downloading
    documents, and requesting a state change for a resource. But what about streaming
    data to and from a server?'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术假设你对WebSockets有一定的了解。为了回顾：HTTP请求是无状态的，相对较短的生命周期。它们非常适合下载文档，以及请求资源的状态改变。但关于从服务器到服务器的数据流怎么办呢？
- en: Certain types of events originate from servers. Think about a web mail service.
    When you create and send a message, you push it to the server, and the server
    sends it to the recipients. If the recipient is sitting watching their inbox,
    there’s no easy way for their browser to get updated. It could periodically check
    for new messages using an Ajax request, but this isn’t very elegant. The server
    *knows* it has a new message for the recipient, so it would be much better if
    it could push that message directly to the user.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类型的事件起源于服务器。想想一个网络邮件服务。当你创建并发送一条消息时，你将其推送到服务器，服务器将其发送给收件人。如果收件人正在查看他们的收件箱，他们的浏览器没有简单的方法来更新。他们可以使用Ajax请求定期检查新消息，但这并不优雅。服务器*知道*它有新的消息要发送给收件人，所以如果它能直接将那条消息推送到用户，那就更好了。
- en: 'That’s where WebSockets come in. They’re conceptually like the TCP sockets
    we saw in [chapter 7](kindle_split_016.html#ch07): a bidirectional bridge is set
    up between the client and server. To do this you need a WebSocket server in addition
    to your standard Express server, or plain old Node `http` server. [Figure 9.6](#ch09fig06)
    illustrates how this works in a typical Node web application.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是WebSocket发挥作用的地方。它们在概念上类似于我们在第7章中看到的TCP套接字：在客户端和服务器之间建立了一个双向的桥梁。为此，你需要在标准的Express服务器或普通的Node
    `http`服务器之外，还需要一个WebSocket服务器。[图9.6](#ch09fig06)说明了这在典型的Node网络应用中的工作方式。
- en: Figure 9.6\. A Node web application should support both standard HTTP requests
    and WebSockets.
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. 一个Node网络应用应该支持标准的HTTP请求和WebSockets。
- en: '![](09fig06.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6](09fig06.jpg)'
- en: HTTP requests are short-lived, have specific endpoints, and use methods like
    `POST` and `PUT`. WebSockets are long-lived, don’t have specific endpoints, and
    don’t have methods. They’re conceptually different, but since they’re used to
    communicate with the same application, they typically need access to the same
    data.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求是短暂的，有特定的端点，并使用`POST`和`PUT`等方法。WebSockets是持久的，没有特定的端点，也没有方法。它们在概念上是不同的，但由于它们用于与同一应用程序通信，它们通常需要访问相同的数据。
- en: This presents a problem for sessions. The Express examples we’ve looked at used
    middleware to automatically load the session. Connect middleware is based on the
    HTTP request and response, so how do we map this to WebSockets, which are long-lived
    and bidirectional? To understand this, we need to look at how WebSockets and sessions
    work.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这给会话带来了问题。我们之前看过的Express示例使用了中间件来自动加载会话。Connect中间件基于HTTP请求和响应，那么我们如何将它们映射到持久且双向的WebSockets上呢？为了理解这一点，我们需要看看WebSockets和会话是如何工作的。
- en: 'Sessions are loaded based on unique identifiers that are included in cookies.
    Cookies are sent with every HTTP request. WebSockets are initiated with a standard
    HTTP request that asks to be upgraded to a WebSocket. This means there’s a point
    where you can grab the cookie from the request, and then load the session. For
    each WebSocket, you can store a reference to the user’s session. Now you can do
    all the usual things you need to do with a session: verify the user is signed
    in, set preferences, and so on.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 会话是基于包含在cookie中的唯一标识符加载的。cookie会随每个HTTP请求一起发送。WebSockets通过一个标准的HTTP请求启动，请求升级到WebSocket。这意味着有一个点可以抓取请求中的cookie，然后加载会话。对于每个WebSocket，您都可以存储对用户会话的引用。现在您可以使用会话执行所有需要执行的操作：验证用户是否已登录，设置首选项，等等。
- en: '[Figure 9.7](#ch09fig07) extends [figure 9.6](#ch09fig06) to show how sessions
    can be used with WebSockets, by incorporating the Connect middleware for parsing
    cookies and loading the session.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.7](#ch09fig07) 扩展了[图9.6](#ch09fig06)，展示了如何通过结合用于解析cookie和加载会话的Connect中间件来使用WebSockets。'
- en: Figure 9.7\. Accessing sessions from WebSockets
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. 通过WebSockets访问会话
- en: '![](09fig07.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig07.jpg)'
- en: Now that you know how the parts fit together, how do you go about building it?
    The cookie-parsing middleware component can be found in `express.cookieParser`.
    This is actually a simple method that gets the cookie from the request headers,
    and then parses the cookie string into separate values. It accepts an argument,
    `secret`, which is the value used to sign the cookie. Once the cookie is decrypted,
    you can get the session ID from it and load the session.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了各个部分是如何配合工作的，那么您是如何构建它的呢？cookie解析中间件组件可以在`express.cookieParser`中找到。这实际上是一个简单的方法，它从请求头中获取cookie，然后将cookie字符串解析成单独的值。它接受一个参数，`secret`，这是用于签名cookie的值。一旦cookie被解密，您就可以从中获取会话ID并加载会话。
- en: Sessions in Express are modeled on an asynchronous API for storing and retrieving
    values. They can be backed by a database, or you can use the built-in memory-based
    class. Passing the session ID and a callback to `sessionStore.get` will load the
    session, if the session ID is correct.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Express中的会话是基于存储和检索值的异步API建模的。它们可以由数据库支持，或者您可以使用内置的基于内存的类。通过传递会话ID和回调函数到`sessionStore.get`，如果会话ID正确，则会加载会话。
- en: In this technique we’ll use the `ws` WebSocket module ([https://www.npmjs.org/package/ws](https://www.npmjs.org/package/ws)).
    This is a fast-but-minimal implementation that has a very different API than Socket.IO.
    If you want to learn about Socket.IO, then *Node in Action* has some excellent
    tutorials. Here we’re using a simpler module so you can really see how WebSockets
    work.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将使用`ws` WebSocket模块([https://www.npmjs.org/package/ws](https://www.npmjs.org/package/ws))。这是一个快速但功能最少的实现，其API与Socket.IO非常不同。如果您想了解Socket.IO，那么*Node
    in Action*有一些非常优秀的教程。在这里，我们使用一个更简单的模块，这样您就可以真正看到WebSockets是如何工作的。
- en: To make `ws` load the session, you need to parse the cookies from the HTTP upgrade
    request, and then call `sessionStore.get`. A full example that shows how it all
    works follows.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`ws`加载会话，您需要解析HTTP升级请求中的cookie，然后调用`sessionStore.get`。以下是一个完整示例，展示了它是如何工作的。
- en: Listing 9.25\. An Express application that uses WebSockets
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.25\. 使用WebSockets的Express应用程序
- en: '![](ch09ex25-0.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex25-0.jpg)'
- en: '![](ch09ex25-1.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex25-1.jpg)'
- en: This example starts by loading and configuring the cookie parser ![](1.jpg)
    and the session store ![](2.jpg). We’re using signed cookies, so note that `ws.upgradeReq.signedCookies`
    is used when loading the session later.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例首先加载和配置了cookie解析器！[](1.jpg)和会话存储！[](2.jpg)。我们使用签名cookie，所以请注意，在稍后加载会话时使用`ws.upgradeReq.signedCookies`。
- en: Express is set up to use the session middleware component ![](3.jpg), and we’ve
    created a route that you can use for testing ![](4.jpg). Just load http://localhost:3000/random
    in your browser to set a random value in the session, and then visit http://localhost:3000/
    to see it printed back.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Express已配置为使用会话中间件组件！[](3.jpg)，我们已创建了一个可用于测试的路由！[](4.jpg)。只需在浏览器中加载http://localhost:3000/random，即可在会话中设置一个随机值，然后访问http://localhost:3000/以查看它被打印出来。
- en: The `ws` module works by using a plain old constructor, `WebSocketServer`, to
    handle WebSockets. To use it, you instantiate it with a Node HTTP server object—we’ve
    just passed in the Express server here ![](5.jpg). Once the server is started,
    it’ll emit events when connections are created ![](6.jpg).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`ws`模块通过使用普通的构造函数`WebSocketServer`来处理WebSockets。要使用它，您需要用Node HTTP服务器对象实例化它——我们在这里传递了Express服务器！一旦服务器启动，它将在创建连接时发出事件！[](5.jpg)。'
- en: The client code for this example sends JSON to the server, so there’s some code
    to parse the JSON string and check whether it’s valid ![](7.jpg). This wasn’t
    entirely necessary for this example, but we included it to show that `ws` requires
    this kind of extra work to be used in most practical situations.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的客户端代码向服务器发送 JSON，因此有一些代码用于解析 JSON 字符串并检查其是否有效 ![7.jpg](7.jpg)。这对于此示例来说并非完全必要，但我们包括它以展示
    `ws` 在大多数实际情况下需要这种额外的工作才能使用。
- en: Once the WebSocket server has a connection, the session ID can be accessed through
    the cookies on the upgrade request ![](8.jpg). This is similar to what Express
    does behind the scenes—we just need to manually pass a reference to the upgrade
    request to the cookie-parser middleware component. Then the session is loaded
    using the session store’s `get` method ![](9.jpg). Once the session has been loaded,
    a message is sent back to the client that contains a value from the session ![](10.jpg).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 WebSocket 服务器建立了连接，会话 ID 可以通过升级请求中的 cookies 访问 ![8.jpg](8.jpg)。这与 Express
    在幕后所做的工作类似——我们只需要手动将升级请求的引用传递给 cookie-parser 中间件组件。然后使用会话存储的 `get` 方法加载会话 ![9.jpg](9.jpg)。一旦会话被加载，就会向客户端发送一条包含会话值的消息
    ![10.jpg](10.jpg)。
- en: The associated client-side implementation that’s required to run this example
    is shown in the following listing.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例所需的关联客户端实现如下所示。
- en: Listing 9.26\. The client-side WebSocket implementation
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.26\. 客户端 WebSocket 实现
- en: '![](242fig01_alt.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![242fig01_alt.jpg](242fig01_alt.jpg)'
- en: All it does is periodically send a message to the server. It’ll display `undefined`
    until you visit http://localhost:3000/random. If you open two windows, one to
    http://localhost:3000/random and the other to http://localhost:3000/, you’ll be
    able to keep refreshing the random page so the WebSocket view shows new values.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的只是定期向服务器发送消息。直到你访问 http://localhost:3000/random，它将显示 `undefined`。如果你打开两个窗口，一个到
    http://localhost:3000/random，另一个到 http://localhost:3000/，你将能够不断刷新随机页面，以便 WebSocket
    视图显示新的值。
- en: Running this example requires Express 3 and `ws` 0.4—we’ve included a package.json
    with everything you need in the book’s full listings.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例需要 Express 3 和 `ws` 0.4——我们在书的全列表中包含了你需要的一切。
- en: The next technique has tips for migrating from Express 3 to Express 4.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术提供了从 Express 3 迁移到 Express 4 的技巧。
- en: Technique 75 Migrating Express 3 applications to Express 4
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 75 将 Express 3 应用程序迁移到 Express 4
- en: This book was written before Express 4 was released, so our Express examples
    are written with version 3 of the framework in mind. We’ve included this technique
    to help you migrate, and also so you can see how version 4 differs from the previous
    versions.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是在 Express 4 发布之前编写的，因此我们的 Express 示例是以框架的 3 版本为基础编写的。我们包括这个技巧是为了帮助你迁移，同时也是为了让你看到版本
    4 与之前版本的不同之处。
- en: Problem
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have an Express 3 application and want to upgrade it to use Express 4.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个 Express 3 应用程序，并希望将其升级以使用 Express 4。
- en: Solution
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Update your application configuration, install missing middleware, and take
    advantage of the new routing API.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 更新你的应用程序配置，安装缺失的中间件，并利用新的路由 API。
- en: Discussion
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Most of the updates from Express 3 to 4 were a long time coming. Certain changes
    have been hinted at in Express 3’s documentation, so the API changes weren’t unexpected
    or even too dramatic for the most part. You’ll probably spend most of your time
    replacing the middleware that used to ship with Express, because Express 4 no
    longer has any built-in middleware components, apart from `express.static`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Express 3 到 4 的大多数更新都经过了很长时间。某些更改已在 Express 3 的文档中提及，因此 API 变化并不令人意外，甚至大部分情况下也不太剧烈。你可能大部分时间都会花费在替换曾经与
    Express 一起提供的中间件上，因为 Express 4 除了 `express.static` 之外不再有任何内置的中间件组件。
- en: The `express.static` middleware component enables Express to mount your `public`
    folder that contains JavaScript, CSS, and image assets. This has been left in
    because it’s convenient, but the rest of the middleware components have gone.
    That means you’ll need to use `npm install --save body-parser` if you previously
    used `bodyParser`, for example. Refer to [table 9.1](#ch09table01) that has the
    old middleware names and the newer equivalents. Just remember that you need to
    `npm install --save` each one that you need, and then `require` it in your app.js
    file.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`express.static` 中间件组件使 Express 能够挂载包含 JavaScript、CSS 和图像资源的 `public` 文件夹。这被保留下来是因为它很方便，但其他中间件组件已经不再使用。这意味着如果你之前使用了
    `bodyParser`，你需要使用 `npm install --save body-parser`。请参考[表9.1](#ch09table01)，其中包含旧中间件名称和较新的等效名称。只需记住，你需要使用
    `npm install --save` 安装你需要的每个组件，然后在你的 app.js 文件中 `require` 它。'
- en: Table 9.3\. Migrating Express middleware components
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.3. 迁移 Express 中间件组件
- en: '| Express 3 | Express 4 npm package | Description |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| Express 3 | Express 4 npm 包 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| bodyParser | body-parser | Parses URL-encoded and JSON POST bodies |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| bodyParser | body-parser | 解析URL编码和JSON POST请求体 |'
- en: '| compress | compression | Compresses the server’s responses |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| compress | compression | 压缩服务器的响应 |'
- en: '| timeout | connect-timeout | Allows requests to timeout if they take too long
    |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| timeout | connect-timeout | 允许请求在耗时过长时超时 |'
- en: '| cookieParser | cookie-parser | Parses cookies from HTTP headers, leaving
    the result in req.cookies |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| cookieParser | cookie-parser | 从 HTTP 头部解析 cookies，并将结果留在 req.cookies 中 |'
- en: '| cookieSession | cookie-session | Simple session support using cookies |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| cookieSession | cookie-session | 使用 cookies 提供简单的会话支持 |'
- en: '| csrf | csurf | Adds a token to the session that you can use to protect forms
    from CSRF attacks |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| csrf | csurf | 向会话中添加一个令牌，可用于保护表单免受 CSRF 攻击 |'
- en: '| error-handler | errorhandler | The default error handler used by Connect
    |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| error-handler | errorhandler | Connect 默认使用的错误处理器 |'
- en: '| session | express-session | Simple session handler that can be extended with
    *stores* that write sessions to databases or files |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| session | express-session | 简单的会话处理器，可以通过 *stores* 扩展，将会话写入数据库或文件 |'
- en: '| method-override | method-override | Maps new HTTP verbs to the _method request
    variable |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| method-override | method-override | 将新的 HTTP 请求方法映射到 _method 请求变量 |'
- en: '| logger | morgan | Log formatting |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| logger | morgan | 日志格式化 |'
- en: '| response-time | response-time | Track response time |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| response-time | response-time | 跟踪响应时间 |'
- en: '| favicon | serve-favicon | Send favicons, including a built-in default if
    you don’t have one yet |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| favicon | serve-favicon | 发送 favicons，包括一个内置的默认图标，如果你还没有的话 |'
- en: '| directory | serve-index | Directory listings, similar to Apache’s directory
    indexing |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| directory | serve-index | 目录列表，类似于 Apache 的目录索引 |'
- en: '| vhost | vhost | Allow routes to match on subdomains |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| vhost | vhost | 允许路由匹配子域名 |'
- en: You might not use most of these modules. In my applications I (Alex) usually
    have only `body-parser`, `cookie-parser`, `csurf`, `express-session`, and `method-override`,
    so migration isn’t too difficult. The following listing shows a small application
    that uses these middleware components.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会使用这些模块中的大多数。在我的应用程序中，我（亚历克斯）通常只有 `body-parser`、`cookie-parser`、`csurf`、`express-session`
    和 `method-override`，因此迁移并不困难。以下列表显示了一个使用这些中间件组件的小型应用程序。
- en: Listing 9.27\. Express 4 middleware
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.27. Express 4 中间件
- en: '![](244fig01_alt.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](244fig01_alt.jpg)'
- en: 'To install Express 4 and the necessary middleware, you should run the following
    command in a new directory:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Express 4 和必要的中间件，你应该在新的目录中运行以下命令：
- en: '[PRE4]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will install all of the required middleware modules along with Express
    4, and save them to a package.json file. Once you’ve loaded the middleware components
    with `require` ![](1.jpg), you can add them to your application’s stack with `app.use`
    as you did in Express 3 ![](2.jpg). Route handlers can be added exactly as they
    were in Express 3 ![](3.jpg).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有必需的中间件模块以及 Express 4，并将它们保存到 package.json 文件中。一旦你使用 `require` 加载了中间件组件[![](1.jpg)]，你就可以像在
    Express 3 中一样使用 `app.use` 将它们添加到应用程序的堆栈中。路由处理器可以像在 Express 3 中一样添加[![](2.jpg)]。
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Official migration guide
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 官方迁移指南
- en: The Express authors have written a migration guide that’s available in the Express
    wiki on GitHub.^([[3](#ch09fn03)]) This includes a quick rundown of every change.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的作者编写了一份迁移指南，可在 GitHub 上的 Express wiki 中找到。[^([3](#ch09fn03))] 这包括每个更改的快速概述。
- en: ³ [https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ [https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x](https://github.com/visionmedia/express/wiki/Migrating-from-3.x-to-4.x)
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can’t use `app.configure` anymore, but it should be easy to stop using
    it. If you’re using `app.configure` to do only certain things for specific environments,
    then just use a conditional statement with `process.env.NODE_ENV`. The following
    example assumes a fictitious middleware component called `logger` that can be
    set to be noisy, which might not be desirable when the tests are running:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能再使用 `app.configure` 了，但停止使用它应该很容易。如果你使用 `app.configure` 只是为了特定环境执行某些操作，那么只需使用带有
    `process.env.NODE_ENV` 的条件语句。以下示例假设有一个虚构的中间件组件 `logger`，它可以被设置为嘈杂，这在测试运行时可能不是所希望的：
- en: '[PRE5]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new routing API reinforces the concept of mini-applications that can be
    mounted on different endpoints. That means your RESTful resources can leave off
    the resource name from URLs. Instead of writing `app.get('/songs', songs.index)`,
    you can now write `songs.get('/', index)` and mount `songs` on `/songs` with `app.use`.
    This fits in well with the route separation pattern in [technique 67](#ch09lev2sec4).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 新的路由 API 强调了可以在不同端点上挂载的微型应用程序的概念。这意味着你的 RESTful 资源可以省略 URL 中的资源名称。你不再需要编写 `app.get('/songs',
    songs.index)`，现在你可以编写 `songs.get('/', index)` 并使用 `app.use` 在 `/songs` 上挂载 `songs`。这与
    [技术 67](#ch09lev2sec4) 中的路由分离模式很好地结合在一起。
- en: The next listing shows how to use the new router API.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何使用新的路由 API。
- en: Listing 9.28\. Express 4 middleware
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.28. Express 4 中间件
- en: '![](245fig01_alt.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](245fig01_alt.jpg)'
- en: 'After creating a new router ![](1.jpg), you can add routes the same way you
    always did, using HTTP verbs like `get` ![](2.jpg). The cool thing about this
    is you can also add middleware that will be confined to these routes only: just
    call `songs.use`. That was previously trickier in older versions of Express.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个新的路由 ![图片描述](1.jpg) 之后，你可以像以前一样添加路由，使用 HTTP 动词如 `get` ![图片描述](2.jpg)。这个功能很酷，你还可以添加仅限于这些路由的中间件：只需调用
    `songs.use`。在 Express 的旧版本中，这曾经更复杂。
- en: Once you’ve set up a router, you can mount it using a URL prefix ![](3.jpg).
    That means you could do things like mount the same route handler on different
    URLs to easily alias them.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了一个路由器，你可以使用 URL 前缀 ![图片描述](3.jpg) 来挂载它。这意味着你可以做诸如在不同的 URL 上挂载相同的路由处理程序以轻松地别名它们的事情。
- en: If you put the routers in their own files and mount them in your main app.js
    file, then you could even distribute routers as modules on npm. That means you
    could compose applications from reusable routers.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将路由器放在它们自己的文件中，并在你的主 app.js 文件中挂载它们，那么你甚至可以将路由器作为模块在 npm 上分发。这意味着你可以从可重用的路由器中组合应用程序。
- en: The final thing we’ll mention about Express 4 is the new `router.param` method.
    This allows you to run asynchronous code when certain route parameters are present.
    Let’s say you have `'/songs/:song_id'`, and `:song_id` should only ever be a valid
    song that’s in the database. With `route.param` you can validate that the value
    is a number *and* exists in the database, before any route handlers run!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于 Express 4 的最后一件事是新的 `router.param` 方法。这允许你在某些路由参数存在时运行异步代码。假设你有 `'/songs/:song_id'`，而
    `:song_id` 应该始终是数据库中有效的歌曲。使用 `route.param`，你可以在任何路由处理程序运行之前验证该值是否为数字并且存在于数据库中！
- en: '[PRE6]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, `Song` is assumed to be a class that fetches songs from a database.
    The actual route handler is now extremely simple, because it only runs if a valid
    song has been found. Otherwise, `next` will shortcut execution and pass an error
    to the error-handling middleware.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Song` 被假定为从数据库中获取歌曲的一个类。实际的路由处理程序现在非常简单，因为它只会在找到有效的歌曲时运行。否则，`next` 将会跳过执行并传递一个错误给错误处理中间件。
- en: That wraps up our section on web application development techniques. There’s
    one more important thing before we move on to the next chapter. Like everything
    else, web applications should be well tested. The next section has some techniques
    that we’ve found useful when testing web applications.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于网络应用程序开发技术的讨论就到这里。在我们进入下一章之前，还有一件重要的事情需要说明。就像其他所有事情一样，网络应用程序应该得到充分的测试。下一节将介绍我们在测试网络应用程序时发现的一些有用技术。
- en: 9.3\. Testing web applications
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 测试网络应用程序
- en: Testing can feel like a chore, but it can also be an indispensable tool for
    verifying ideas, particularly if you’re creating web APIs without user interfaces.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可能会感觉像是一项繁琐的工作，但它也可以是验证想法不可或缺的工具，尤其是当你没有用户界面创建网络 API 时。
- en: '[Chapter 10](kindle_split_020.html#ch10) has an introduction to testing in
    Node, and [technique 84](kindle_split_020.html#ch10lev2sec6) has an example for
    testing web applications. In the next technique we extend this example to show
    you how to test authenticated routes.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](kindle_split_020.html#ch10)介绍了Node中的测试，[技术84](kindle_split_020.html#ch10lev2sec6)提供了一个测试Web应用的示例。在下一个技术中，我们将扩展这个示例来展示如何测试认证路由。'
- en: Technique 76 Testing authenticated routes
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号76：测试认证路由
- en: Test frameworks like Mocha make tests easy to read and write, and SuperTest
    helps keep HTTP-related tests clean. But authentication support isn’t usually
    built into such modules. In this technique you’ll learn one way to handle authentication
    in tests, and the approach is general enough that it can be reused with other
    test modules as well.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架如Mocha使测试易于阅读和编写，SuperTest有助于保持与HTTP相关的测试整洁。但认证支持通常不会内置到这样的模块中。在这个技术中，你将学习一种处理测试中认证的方法，这种方法足够通用，可以与其他测试模块一起重用。
- en: Problem
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test parts of your application that are behind a session-based username
    and password.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 你想测试你的应用程序中基于会话的用户名和密码的部分。
- en: Solution
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make a request that signs in during the setup phase of the tests, and then reuse
    the cookies for subsequent tests.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的设置阶段发送一个登录请求，然后重用cookies进行后续测试。
- en: Discussion
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Some web frameworks and testing libraries handle sessions for you, so you can
    test routes without worrying too much about logging in. This isn’t true for Mocha
    and SuperTest, which we’ve used before in this book, so you’ll need to know a
    bit about how sessions work.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架和测试库为你处理会话，因此你可以测试路由而不必过多担心登录。这对于我们在这本书中之前使用过的Mocha和SuperTest来说并不成立，所以你需要了解一些关于会话如何工作的知识。
- en: The session handling that Express uses from Connect is based around a cookie.
    Once the cookie has been set, it can be used to load the user’s session. That
    means that to write a test that accesses a secure part of your application, you’ll
    need to make a request that signs in the user, grabs the cookies, and then use
    the cookies for subsequent requests. This process is shown in [figure 9.8](#ch09fig08).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: Express从Connect使用的会话处理是基于cookie的。一旦cookie被设置，就可以用来加载用户的会话。这意味着要编写一个测试来访问应用程序的安全部分，你需要发送一个登录请求，获取cookies，然后使用这些cookies进行后续请求。这个过程在[图9.8](#ch09fig08)中展示。
- en: Figure 9.8\. You can test authenticated routes by catching cookies.
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8。你可以通过捕获cookie来测试认证路由。
- en: '![](09fig08_alt.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8](09fig08_alt.jpg)'
- en: To write tests that access authenticated routes, you’ll need a test user account,
    which usually involves creating database fixtures. You’ll read about fixtures
    in [chapter 10](kindle_split_020.html#ch10), [technique 87](kindle_split_020.html#ch10lev2sec9).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写访问认证路由的测试，你需要一个测试用户账户，这通常涉及到创建数据库固定值。你将在[第10章](kindle_split_020.html#ch10)和[技术87](kindle_split_020.html#ch10lev2sec9)中了解到固定值。
- en: Once the data is ready, you can use a library like SuperTest to make a `POST`
    to your session-handling endpoint with a username and password. Cookies are transmitted
    using HTTP headers, so you can read them from `res.headers['set-cookie']`. You
    should also make an assertion to ensure the account was signed in.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据准备就绪，你可以使用SuperTest之类的库向你的会话处理端点发送一个带有用户名和密码的`POST`请求。Cookies是通过HTTP头部传输的，因此你可以从`res.headers['set-cookie']`中读取它们。你还应该进行断言以确保账户已登录。
- en: Now any new requests just need to set the `Cookie` header with the value from
    `res.headers`, and your test user will be signed in. The next listing shows how
    this works.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任何新的请求只需要设置`Cookie`头部，使用`res.headers`中的值，你的测试用户就会登录。下一个列表展示了这是如何工作的。
- en: Listing 9.29\. Testing authenticated requests
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.29。测试认证请求
- en: '![](247fig01_alt.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图247.1](247fig01_alt.jpg)'
- en: The first part of this test loads the required modules and sets up an example
    user ![](1.jpg). This would usually be stored in a database, or set by a fixture.
    Next, a `POST` is made with the username and password ![](2.jpg). The session
    cookie will be available in the `set-cookie` header ![](3.jpg).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的第一部分加载所需的模块并设置一个示例用户![图1](1.jpg)。这通常会被存储在数据库中，或者通过固定值设置。接下来，使用用户名和密码发送一个`POST`请求![图2](2.jpg)。会话cookie将在`set-cookie`头部中可用![图3](3.jpg)。
- en: To access a route that’s behind a login ![](4.jpg), set the `Cookie` header
    with the previously saved cookies ![](5.jpg). You should find that the request
    is handled as if the user had signed in normally.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问登录后的路由![图4](4.jpg)，请设置`Cookie`头部，使用之前保存的cookies![图5](5.jpg)。你应该会发现请求被处理得就像用户正常登录一样。
- en: The trick to understanding testing with sessions can be learned by looking at
    how Connect’s session middleware component works. Other middleware isn’t as easy
    to manage during testing, so the next technique introduces the concept of test
    *seams*, which will allow you to bring middleware under control during testing.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 Connect 的会话中间件组件的工作方式，可以学会理解带有会话的测试的技巧。其他中间件在测试期间并不容易管理，所以下一个技巧引入了测试 *接口*
    的概念，这将允许你在测试期间控制中间件。
- en: Technique 77 Creating seams for middleware injection
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 77 为中间件注入创建接口
- en: 'Middleware is flexible and composable. This modular approach makes Connect-based
    applications a joy to work on. But there’s a downside to middleware: testability.
    Some middleware makes routes inherently difficult to test. This technique looks
    at ways to get around this by creating *seams*.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是灵活的和可组合的。这种模块化方法使得基于 Connect 的应用程序易于工作。但中间件也有一个缺点：可测试性。一些中间件使得路由本身难以测试。这个技巧通过创建
    *接口* 来探讨如何解决这个问题。
- en: Problem
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re using middleware that has made your application difficult to test.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用使你的应用程序难以测试的中间件。
- en: Solution
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Find seams where middleware can be replaced for the duration of the tests.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 找到在测试期间可以替换中间件的接口。
- en: Discussion
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The term *seam* is a formal way of describing places in code that can be changed
    without editing the original code. The concept is extended to apply to languages
    like JavaScript by Stephen Vance in his book *Quality Code: Software Testing Principles,
    Practices, and Patterns*.^([[4](#ch09fn04)])'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '术语 *接口* 是一种正式的描述代码中可以更改而不需要编辑原始代码的地方的方式。这个概念被扩展到适用于 JavaScript 等语言，由 Stephen
    Vance 在他的书 *Quality Code: Software Testing Principles, Practices, and Patterns*
    中提出。^([[4](#ch09fn04)])'
- en: ⁴ [https://www.informit.com/store/quality-code-software-testing-principles-practices-9780321832986](https://www.informit.com/store/quality-code-software-testing-principles-practices-9780321832986)
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ [https://www.informit.com/store/quality-code-software-testing-principles-practices-9780321832986](https://www.informit.com/store/quality-code-software-testing-principles-practices-9780321832986)
- en: '*A seam in our code gives us the opportunity to take control of that code and
    exercise it in a testing context. Any place that we can execute, override, inject,
    or control the code could be a seam.*'
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在我们的代码中，接口为我们提供了控制该代码并在测试环境中执行它的机会。任何我们可以执行、覆盖、注入或控制的代码的地方都可能是一个接口。*'
- en: 'One example of this is the `csrf` middleware component from Connect. It creates
    a session variable that can be included in forms to avoid cross-site request forgery
    attacks. Let’s say you have a web application that allows registered users to
    create calendar entries. If your site didn’t use CSRF protection, someone could
    create a web page that tricks a user of your site into deleting items from their
    calendar. The attack might look like this:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是 Connect 的 `csrf` 中间件组件。它创建了一个会话变量，可以包含在表单中以避免跨站请求伪造攻击。假设你有一个允许注册用户创建日历条目的网络应用程序。如果你的网站没有使用
    CSRF 保护，有人可以创建一个网页，诱骗你的网站用户删除他们的日历项目。攻击可能看起来像这样：
- en: '[PRE7]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The user’s browser will dutifully load the image source that’s hosted on an
    external site. But it references your site in a potentially dangerous way. To
    prevent this, a random token is generated on each request and inserted into forms.
    The attacker doesn’t have access to the token, so the attack is mitigated.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的浏览器将尽职尽责地加载托管在外部站点上的图像源。但它以可能危险的方式引用你的站点。为了防止这种情况，每次请求都会生成一个随机令牌并将其插入到表单中。攻击者无法访问令牌，因此攻击被缓解。
- en: Unfortunately, simply adding `express.csrf` to routes that render forms isn’t
    entirely testable. Tests can no longer post to route handlers without first loading
    the form and scraping out the session variable that contains the secret CSRF token.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅仅将 `express.csrf` 添加到渲染表单的路由中并不完全可测试。测试无法在没有首先加载表单并刮除包含 CSRF 令牌的会话变量之前向路由处理程序发送帖子。
- en: 'To get around this, you need to take `express.csrf` under your control. Refactor
    it to create a seam: place it in a module that contains your other custom middleware,
    and then change it during tests. You don’t need to test `express.csrf` because
    the authors of Express and Connect have done that for you—instead, change its
    behavior during tests.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要将 `express.csrf` 控制在自己的手中。重构它以创建一个接口：将其放置在一个包含你其他自定义中间件的模块中，然后在测试期间进行更改。你不需要测试
    `express.csrf`，因为 Express 和 Connect 的作者已经为你做了这项工作——相反，你可以在测试期间更改其行为。
- en: 'Two other options are available: checking if `process.env.NODE_ENV` is set
    to `test` and then branching to a test-only version of the CSRF middleware component,
    or patching `express.csrf`’s internals so you can extract the secret token. There
    are problems with both of these approaches: the first means you can’t get 100%
    code coverage—your production code has to include test code. The second approach
    is potentially brittle: it’s too sensitive to Connect changing the way CSRF works
    in the future.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个选项是可用的：检查`process.env.NODE_ENV`是否设置为`test`，然后分支到仅测试版本的CSRF中间件组件，或者修补`express.csrf`的内部结构，以便你可以提取密钥令牌。这两种方法都存在问题：第一种意味着你不能获得100%的代码覆盖率——你的生产代码必须包含测试代码。第二种方法可能是脆弱的：它对Connect未来更改CSRF工作方式过于敏感。
- en: The seam-based concept that we’ll use requires that you create a middleware
    file if you don’t already have one. This is just a file that groups all of your
    middleware together into a module that can be easily loaded. Then you need to
    create a function that wraps around `express.csrf`, or just returns it. A basic
    example follows.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的基于缝隙的概念要求你创建一个中间件文件，如果你还没有的话。这只是一个将所有中间件组合成一个可以轻松加载的模块的文件。然后你需要创建一个函数，它围绕`express.csrf`包装，或者只是返回它。以下是一个基本示例。
- en: Listing 9.30\. Taking control of middleware
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.30\. 控制中间件
- en: '![](249fig01_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![249fig01_alt.jpg](249fig01_alt.jpg)'
- en: All this does is export the original `csrf` middleware component ![](1.jpg),
    but now it’s much easier to inject different behavior during tests. The next listing
    shows what such a test might look like.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是导出原始的`csrf`中间件组件 ![1.jpg](1.jpg)，但现在在测试期间注入不同的行为要容易得多。下面的列表显示了这样的测试可能的样子。
- en: Listing 9.31\. Injecting new behavior during tests
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.31\. 在测试期间注入新行为
- en: '![](250fig01_alt.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_IMG
  zh: '![250fig01_alt.jpg](250fig01_alt.jpg)'
- en: This test loads our custom middleware module before anything else, and then
    replaces the `csrf` method ![](1.jpg). When it loads `app` and fires off a request
    using Super-Test, Express will use our injected middleware component because `middleware.js`
    will be cached. The `_csrf` value is set just in case any views expected it ![](2.jpg),
    and the request should return a 200 instead of a 403 (forbidden) ![](3.jpg).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在加载其他任何内容之前加载我们的自定义中间件模块，然后替换`csrf`方法 ![1.jpg](1.jpg)。当它加载`app`并使用Super-Test发起请求时，Express将使用我们注入的中间件组件，因为`middleware.js`将被缓存。`_csrf`值被设置，以防任何视图期望它
    ![2.jpg](2.jpg)，并且请求应该返回200而不是403（禁止） ![3.jpg](3.jpg)。
- en: It might not seem like we’ve done much, but by refactoring how `express.csrf`
    is loaded, we’ve been able to run our application in a more testable way. You
    may prefer to make two requests to ensure the `csrf` middleware component is used
    normally, but this technique can be used for other things as well. You can bring
    any middleware under control for testing. If there’s something you don’t want
    to run during tests, look for seams that allow you to inject the desired behavior,
    or try to create a seam using simple JavaScript or Node patterns—you don’t need
    a complex dependency injection framework; you can take advantage of Node’s module
    system.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们并没有做很多事情，但通过重构`express.csrf`的加载方式，我们已经能够以更可测试的方式运行我们的应用程序。你可能更喜欢进行两次请求以确保`csrf`中间件组件被正常使用，但这项技术也可以用于其他事情。你可以控制任何中间件进行测试。如果你在测试期间不想运行某些内容，寻找允许你注入所需行为的缝隙，或者尝试使用简单的JavaScript或Node模式创建缝隙——你不需要复杂的依赖注入框架；你可以利用Node的模块系统。
- en: The next technique builds on some of these ideas to allow tests to interact
    with simulated versions of remote services. This will make it easier if you’re
    writing tests for an application that accesses remote services, like a payment
    gateway.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术是在这些想法的基础上构建的，允许测试与远程服务的模拟版本进行交互。如果你正在为访问远程服务（如支付网关）的应用程序编写测试，这将使事情变得更容易。
- en: Technique 78 Testing applications that depend on remote services
  id: totrans-546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧78 测试依赖于远程服务的应用程序
- en: Third-party modules can help you integrate your applications with remote services
    like GitHub, Twitter, and Facebook. But how do you test applications that depend
    on such remote services? This technique looks at ways to insert stubs for remote
    dependencies, to make your tests faster and more maintainable.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方模块可以帮助你将你的应用程序与GitHub、Twitter和Facebook等远程服务集成。但你是如何测试依赖于这些远程服务应用程序的呢？这项技术探讨了插入远程依赖项存根的方法，以使你的测试更快、更易于维护。
- en: Problem
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re using a social network for authentication, or a service to accept payments,
    and you don’t want your tests to access these remote dependencies.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在使用社交网络进行身份验证，或者使用接受支付的服务，并且您不希望您的测试访问这些远程依赖。
- en: Solution
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Find the seams between your application, the remote service, and the things
    you want to test, and then insert your own HTTP servers to simulate parts of the
    remote dependency.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 找到您的应用程序、远程服务和您想要测试的内容之间的缝隙，然后插入您自己的HTTP服务器来模拟远程依赖的部分。
- en: Discussion
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: One of the things that most web applications need, yet is easy to get dangerously
    wrong, is user accounts. Using a Node module that supports the authorization services
    provided by companies like GitHub, Google, Facebook, and Twitter is both quick
    and potentially safer than creating a bespoke solution.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web应用程序都需要，但很容易出错的事情之一是用户账户。使用支持GitHub、Google、Facebook和Twitter等公司提供的授权服务的Node模块既快又可能比创建定制解决方案更安全。
- en: It’s comparatively easy to adopt one of these services, but how do you test
    it? In [technique 76](#ch09lev2sec13), you saw how to write tests for authenticated
    routes. This involved signing in and saving the session cookies so subsequent
    requests appeared authenticated. You can’t use the same approach with remote services,
    because your tests would have to make requests to real-life production services.
    You could use a test account, but what if you wanted to run your tests offline?
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这些服务中的一个相对容易，但您如何测试它呢？在[技术76](#ch09lev2sec13)中，您看到了如何编写认证路由的测试。这涉及到登录并保存会话cookie，以便后续请求看起来是经过认证的。您不能使用相同的方法来测试远程服务，因为您的测试将不得不向真实的生产服务发出请求。您可以使用测试账户，但如果您想离线运行测试呢？
- en: To get around this, you need to create a seam between your application and the
    remote service. Whenever your application attempts to communicate with the remote
    service, you need to slot in a fake version that emits similar responses. In unit
    tests, mock objects simulate other objects. What you want is to mock a service.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您需要在您的应用程序和远程服务之间创建一个缝隙。每当您的应用程序尝试与远程服务通信时，您需要插入一个发出类似响应的假版本。在单元测试中，模拟对象模拟其他对象。您想要模拟一个服务。
- en: 'There are two requirements that your application needs to satisfy to make this
    possible:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序需要满足以下两个要求才能实现这一点：
- en: Configurable remote services
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的远程服务
- en: A web server that can stand in for the remote service
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以替代远程服务的Web服务器
- en: The first condition means your application should allow the URLs of remote services
    to be changed. If it needs to connect to [http://auth.example.com/signin](http://auth.example.com/signin),
    then you’ll need to specify http://localhost:3001/signin during testing. The port
    is entirely up to you—some solutions we’ve seen use a sequence of port numbers
    so multiple services can be run at once for the same tests.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条件意味着您的应用程序应该允许更改远程服务的URL。如果它需要连接到[http://auth.example.com/signin](http://auth.example.com/signin)，那么在测试期间您需要指定http://localhost:3001/signin。端口号完全由您决定——我们见过的一些解决方案使用一系列端口号，以便在相同的测试中同时运行多个服务。
- en: The second condition can be handled however you want. If you’re using Express,
    you could start an Express server with a limited set of routes defined—just enough
    routes and code to simulate the remote service. This server can be kept in its
    own module, and loaded in the tests that need it.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条件可以按您希望的任何方式处理。如果您使用Express，您可以使用定义了有限路由集的Express服务器开始——只需要足够的路由和代码来模拟远程服务。这个服务器可以放在它自己的模块中，并在需要它的测试中加载。
- en: In practice this doesn’t require much code, so once you understand the principle
    it shouldn’t be too difficult to reuse it to handle practically any API. If the
    API you’re attempting to simulate isn’t well documented, then you may need to
    capture real requests to figure out how it works.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这不需要太多的代码，所以一旦您理解了原理，就不应该太难重用它来处理几乎任何API。如果您试图模拟的API没有很好地记录，那么您可能需要捕获真实请求来了解它是如何工作的。
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Investigating remote APIs**'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**调查远程API**'
- en: There are times when remote APIs aren’t well documented. Once you get beyond
    the basic API calls, there are bound to be parts that aren’t easy to understand.
    In cases like this, we find it’s best to make requests with a command-line tool
    like `curl`, and watch the requests and responses in an HTTP logging tool.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候远程API没有很好地记录。一旦您超越了基本的API调用，肯定会有一些部分不容易理解。在这种情况下，我们发现最好使用命令行工具如`curl`发出请求，并在HTTP日志工具中观察请求和响应。
- en: If you’re using Windows, then Fiddler ([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))
    is absolutely essential. It’s described as a HTTP debugging proxy, and it supports
    HTTPS as well.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows，那么 Fiddler ([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))
    是绝对必要的。它被描述为一个 HTTP 调试代理，并且也支持 HTTPS。
- en: '![](252fig01_alt.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![图片](252fig01_alt.jpg)'
- en: Glance has built-in pages for errors.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Glance 内置了错误页面。
- en: For Linux and Mac OS, mitmproxy ([http://mitmproxy.org/](http://mitmproxy.org/))
    is a powerful choice. It allows HTTP traffic to be observed in real time, dumped,
    saved, and replayed. We’ve found it perfect for debugging our own Node-powered
    APIs that support desktop apps, as well as figuring out the quirks of certain
    popular payment gateways.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 和 Mac OS，mitmproxy ([http://mitmproxy.org/](http://mitmproxy.org/))
    是一个强大的选择。它允许实时观察、转储、保存和重放 HTTP 流量。我们发现它非常适合调试我们自己的支持桌面应用程序的 Node.js 驱动的 API，以及了解某些流行支付网关的怪癖。
- en: '|  |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the following three listings, you’ll see how to create a *mock server* that
    a test can use to simulate some of PayPal’s behavior. The first listing shows
    the application itself.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个列表中，你将看到如何创建一个测试可以用来模拟 PayPal 的一些行为的 *模拟服务器*。第一个列表显示了应用程序本身。
- en: Listing 9.32\. A small web store that uses PayPal
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.32\. 一个使用 PayPal 的小型网店
- en: '![](252fig02_alt.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图片](252fig02_alt.jpg)'
- en: The settings passed to the `PayPal` class near the top of the file ![](1.jpg)
    are used to control PayPal’s behavior. One of them, `payPalUrl`, could be [https://www.sandbox.paypal.com/cgi-bin/webscr](https://www.sandbox.paypal.com/cgi-bin/webscr)
    for testing against PayPal’s staging server. Here we use a local URL, because
    we’re going to run our own mock server.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部附近的 `PayPal` 类传递的设置用于控制 PayPal 的行为。其中之一，`payPalUrl`，可能是 [https://www.sandbox.paypal.com/cgi-bin/webscr](https://www.sandbox.paypal.com/cgi-bin/webscr)
    以测试 PayPal 的测试服务器。在这里，我们使用本地 URL，因为我们打算运行自己的模拟服务器。
- en: If this were a real project, you should use a configuration file to store these
    options. One for each environment would make sense. Then the test configuration
    could point to a local server, staging could use PayPal sandbox, and live would
    use PayPal.com. For more on configuration files, see [technique 69](#ch09lev2sec6).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个真实的项目，你应该使用配置文件来存储这些选项。每个环境一个配置文件是有意义的。然后测试配置可以指向本地服务器，测试环境可以使用 PayPal
    沙盒，而生产环境可以使用 PayPal.com。有关配置文件的更多信息，请参阅[技术 69](#ch09lev2sec6)。
- en: To make a payment, the user is forwarded to PayPal’s hosted forms. Our demonstration
    `PayPal` class has the ability to generate this URL, and it’ll use `payPalUrl`
    ![](2.jpg). This example also features payment notification handling ![](3.jpg)—known
    as IPN in PayPal’s nomenclature.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行支付，用户将被转发到 PayPal 的托管表单。我们的演示 `PayPal` 类具有生成此 URL 的能力，并且它将使用 `payPalUrl`
    ![图片](2.jpg)。此示例还展示了支付通知处理 ![图片](3.jpg)——在 PayPal 的术语中称为 IPN。
- en: An extra feature we’ve added here is the call to `emit` ![](4.jpg). This makes
    it easier to test, because our tests can now listen for `purchase:accepted` events.
    It’s also useful for setting up email handling—see [technique 73](#ch09lev2sec10)
    for more on that.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的一个额外功能是调用 `emit` ![图片](4.jpg)。这使得测试变得更加容易，因为我们的测试现在可以监听 `purchase:accepted`
    事件。这对于设置电子邮件处理也非常有用——有关更多信息，请参阅[技术 73](#ch09lev2sec10)。
- en: Now for the mock PayPal server. All it needs to do is handle IPN requests. It
    basically needs to say, “Yes, that purchase has been validated.” It could also
    optionally report errors so we can test error handling on our side as well. The
    next listing shows what the tiny mocked server looks like.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是模拟 PayPal 服务器。它需要做的只是处理 IPN 请求。它基本上需要说，“是的，那个购买已被验证。”它还可以选择性地报告错误，这样我们也可以测试我们自己的错误处理。下一个列表显示了这个微型模拟服务器的外观。
- en: Listing 9.33\. Mocking PayPal’s IPN requests
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.33\. 模拟 PayPal 的 IPN 请求
- en: '![](253fig01_alt.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![图片](253fig01_alt.jpg)'
- en: Real-life PayPal stores receive a `POST` from PayPal with an order’s details,
    near the end of the sales process. You need to take that order and send it back
    to PayPal for verification. This prevents attackers from crafting a `POST` request
    that tricks your application into thinking a fake purchase was made.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生活中，PayPal 商店在销售流程接近尾声时从 PayPal 接收一个包含订单详情的 `POST` 请求。你需要接收那个订单并将其发送回 PayPal
    进行验证。这可以防止攻击者构建一个 `POST` 请求，欺骗你的应用程序认为已进行了虚假购买。
- en: This example includes a toggle so errors can be turned on ![](1.jpg). We’re
    not going to use it here, but it’s useful in real projects because you’ll want
    to test how errors are handled. There will be customers that encounter errors,
    so ensuring they’re handled gracefully is critical.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包括一个切换器，可以打开错误 ![1.jpg](1.jpg)。我们在这里不会使用它，但在实际项目中它很有用，因为您会想测试错误处理的方式。会有客户遇到错误，因此确保它们得到优雅的处理至关重要。
- en: Once all that’s in place, all we need to do is send back the text `VERIFIED`
    ![](2.jpg). That’s all PayPal does—it can be frustratingly abstruse at times!
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们只需发送回文本 `VERIFIED` ![2.jpg](2.jpg)。这就是 PayPal 所做的全部——有时它可能会让人感到令人沮丧的晦涩难懂！
- en: Finally, let’s look at a test that puts all of this together. The next listing
    uses both the mocked PayPal server and our application to make purchases.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一个将所有这些内容结合在一起的测试。接下来的列表使用模拟 PayPal 服务器和我们的应用程序进行购买。
- en: Listing 9.34\. Testing PayPal
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.34\. 测试 PayPal
- en: '![](ch09ex34-0.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex34-0.jpg](ch09ex34-0.jpg)'
- en: '![](ch09ex34-1.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![ch09ex34-1.jpg](ch09ex34-1.jpg)'
- en: This test sets up a sample order ![](2.jpg), which requires a customer ![](1.jpg).
    We also create an object that has the same fields as a PayPal IPN request—this
    is what we’re going to send to our mock PayPal server for validation. Before ![](4.jpg)
    and after ![](5.jpg) each test, we have to start and stop the mock PayPal server.
    That’s because we don’t want servers running when they’re not needed—it might
    cause other tests to behave strangely.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试设置了一个示例订单 ![2.jpg](2.jpg)，它需要一个客户 ![1.jpg](1.jpg)。我们还创建了一个具有与 PayPal IPN
    请求相同字段的对象——这是我们打算发送到我们的模拟 PayPal 服务器进行验证的。在每个测试的 ![4.jpg](4.jpg) 和 ![5.jpg](5.jpg)
    之前，我们必须启动和停止模拟 PayPal 服务器。这是因为我们不希望在不必要时运行服务器——这可能会使其他测试行为异常。
- en: When the user fills out the order form on our site, it will be posted to a route
    that generates a PayPal URL. The PayPal URL will forward the user’s browser to
    PayPal for payment. [Listing 9.34](#ch09ex34) includes a test for this ![](6.jpg),
    and the URL it generates will start with our local test PayPal URL from [listing
    9.32](#ch09ex32).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在我们的网站上填写订单表单时，它将被发布到一个生成 PayPal URL 的路由。PayPal URL 将将用户的浏览器转发到 PayPal 进行支付。[列表
    9.34](#ch09ex34) 包含了这个测试 ![6.jpg](6.jpg)，它生成的 URL 将以我们从 [列表 9.32](#ch09ex32) 的本地测试
    PayPal URL 开头。
- en: There’s also a test for the notification sent by PayPal ![](7.jpg). This is
    the one we’re focusing on that requires the PayPal mocked server. First we have
    to `POST` to our server at /paypal/success with the notification object ![](3.jpg)—this
    is what PayPal would normally do—and then our application will make an HTTP request
    to PayPal, which will hit the mocked server, and then return `VERIFIED`. The test
    simply ensures a 200 is returned, but it’s also able to listen for the `purchase:accepted`
    event, which indicates a given purchase is complete.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 还有对 PayPal 发送的通知的测试 ![7.jpg](7.jpg)。这是我们关注的需要 PayPal 模拟服务器的测试。首先，我们必须向我们的服务器
    `/paypal/success` 发送 `POST` 请求，并带上通知对象 ![3.jpg](3.jpg)——这是 PayPal 通常会做的——然后我们的应用程序将向
    PayPal 发送 HTTP 请求，这将击中模拟服务器，然后返回 `VERIFIED`。测试简单地确保返回 200，但它也能够监听 `purchase:accepted`
    事件，这表示特定的购买已完成。
- en: It might seem like a lot of work, but you’ll be able to work more efficiently
    once your remote services are simulated with mock servers. Your tests run faster,
    and you can work offline. You can also make your mocked services generate all
    kinds of unusual responses, which will help you get better test coverage if that’s
    one of your goals.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来工作量很大，但一旦您的远程服务通过模拟服务器进行模拟，您将能够更有效地工作。您的测试运行得更快，您还可以离线工作。您还可以让模拟服务生成各种不同寻常的响应，如果这是您的目标之一，这将有助于您获得更好的测试覆盖率。
- en: This is the last web-related technique that we cover in this chapter. The next
    sections discuss emerging trends in Node web development.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章中涵盖的最后一个与网络相关的技术。接下来的几节将讨论 Node 网络开发的最新趋势。
- en: 9.4\. Full stack frameworks
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 全栈框架
- en: In this chapter you’ve seen how to build web applications with Node’s built-in
    modules, Connect, and Express. There’s an emerging class of new frameworks known
    as *full stack frameworks*. They provide features that are needed to make rich,
    browser-based applications with modern tools like data binding, but also handle
    server-side concerns like modeling business logic and data persistence.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了如何使用 Node 的内置模块、Connect 和 Express 构建网络应用程序。有一类新兴的新框架被称为 *全栈框架*。它们提供了创建丰富、基于浏览器的应用程序所需的特性，例如数据绑定，同时也处理服务器端的问题，如建模业务逻辑和数据持久性。
- en: If you’re set on using Express, then you can still start working with full stack
    frameworks today. The *MEAN* solution stack uses MongoDB, Express, AngularJS,
    and Node. There could be many MEAN implementations out there, but the MEAN Stack
    from Linnovate ([https://github.com/linnovate/mean](https://github.com/linnovate/mean))
    is currently the most popular. It comes with Mongoose for data models, Passport
    for authorization, and Twitter Bootstrap for the user interface. If you’re working
    in a team that’s already familiar with Bootstrap, AngularJS, and Mongoose, then
    this is a great way to get new projects off the ground quickly.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决心使用 Express，那么你仍然可以今天就开始使用全栈框架。*MEAN* 解决方案堆栈使用 MongoDB、Express、AngularJS
    和 Node。可能存在许多 MEAN 实现，但 Linnovate 的 MEAN Stack ([https://github.com/linnovate/mean](https://github.com/linnovate/mean))
    目前是最受欢迎的。它包含 Mongoose 数据模型、Passport 授权和 Twitter Bootstrap 用户界面。如果你在一个已经熟悉 Bootstrap、AngularJS
    和 Mongoose 的团队中工作，那么这是一个快速启动新项目的好方法。
- en: The book *Getting MEAN*^([[5](#ch09fn05)]) introduces full stack development
    and covers Mongoose models, RESTful API design, and account management with Facebook
    and Twitter.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍 *Getting MEAN*^([[5](#ch09fn05)]) 介绍了全栈开发，并涵盖了 Mongoose 模型、RESTful API 设计以及使用
    Facebook 和 Twitter 的账户管理。
- en: '⁵ *Getting MEAN* by Simon Holmes: [http://www.manning.com/sholmes/](http://www.manning.com/sholmes/).'
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '⁵ *Getting MEAN* by Simon Holmes: [http://www.manning.com/sholmes/](http://www.manning.com/sholmes/).'
- en: Another framework that builds on Express and MongoDB is Derby ([http://derbyjs.com/](http://derbyjs.com/)).
    Instead of Mongoose, Derby uses Racer to implement data models. This allows data
    from different clients to be synchronized, using operational transformation (OT).
    OT is specifically designed to support collaborative systems, so Derby is a good
    choice for developing software inspired by Etherpad ([http://etherpad.org/](http://etherpad.org/)).
    It also has client-side features like templates and data binding.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基于 Express 和 MongoDB 的框架是 Derby ([http://derbyjs.com/](http://derbyjs.com/))。Derby
    使用 Racer 而不是 Mongoose 来实现数据模型。这允许使用操作转换 (OT) 同步来自不同客户端的数据。OT 是专门为支持协作系统而设计的，因此
    Derby 是开发受 Etherpad ([http://etherpad.org/](http://etherpad.org/)) 启发的软件的好选择。它还具有客户端功能，如模板和数据绑定。
- en: If you like Express but want more features, then one option that we haven’t
    covered is Kraken ([http://krakenjs.com/](http://krakenjs.com/)) by PayPal. This
    framework adds more structure to Express projects by adding subdirectories for
    configuration, controllers, Grunt tasks, and tests. It also supports internationalization
    out of the box.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢 Express 但想要更多功能，那么我们还没有介绍的一个选择是 PayPal 的 Kraken ([http://krakenjs.com/](http://krakenjs.com/))。这个框架通过添加配置、控制器、Grunt
    任务和测试的子目录来为 Express 项目添加更多结构。它还支持开箱即用的国际化。
- en: Some frameworks are almost entirely focused on the browser, relying on Node
    only for sensitive operations and data persistence. One popular example is Meteor
    ([https://www.meteor.com/](https://www.meteor.com/)). Like Derby and MEAN Stack,
    it uses MongoDB, but the creators are planning support for other databases. It’s
    based around a pub/sub architecture, where JSON documents are pushed between the
    client and server. Clients retain an in-memory copy of the documents—servers publish
    sets of documents, while clients subscribe to them. This means most model-related
    code in the browser can be written synchronously.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架几乎完全专注于浏览器，仅使用 Node 进行敏感操作和数据持久化。一个流行的例子是 Meteor ([https://www.meteor.com/](https://www.meteor.com/))。像
    Derby 和 MEAN Stack 一样，它使用 MongoDB，但创建者计划支持其他数据库。它基于 pub/sub 架构，其中 JSON 文档在客户端和服务器之间推送。客户端保留文档的内存副本——服务器发布文档集，而客户端订阅它们。这意味着浏览器中的大多数模型相关代码都可以同步编写。
- en: Meteor embraces reactive programming, a paradigm that’s currently popular in
    desktop development circles. This allows *reactive computations* to be bound to
    methods. If you subscribe a function to such a value, the function will be rerun
    when the value changes. The overall effect in a real application is streamlined
    code—there’s essentially less pub/sub management and event-handling code.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 接受了反应式编程，这是一种目前在桌面开发领域流行的范式。这允许 *反应式计算* 与方法绑定。如果你将一个函数订阅到这样的值，当值改变时，函数将被重新运行。在实际应用中的总体效果是代码流线化——基本上减少了
    pub/sub 管理和事件处理代码。
- en: Hoodie ([http://hood.ie/](http://hood.ie/)) is a competitor to Meteor. It uses
    CouchDB, and is suitable for mobile applications because it synchronizes data
    when possible. Almost everything can happen locally. It comes with built-in account
    management, which is as simple as `hoodie.account.signUp('alex@example.com', 'pass')`.
    There’s even a global public store, so data can be saved for specific users or
    made available to everyone using a given application.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: Hoodie ([http://hood.ie/](http://hood.ie/))是Meteor的竞争对手。它使用CouchDB，适合移动应用，因为它在可能的情况下同步数据。几乎所有的事情都可以在本地发生。它内置了账户管理，就像`hoodie.account.signUp('alex@example.com',
    'pass')`这样简单。甚至还有一个全局公共存储库，因此数据可以保存为特定用户使用，或者通过给定应用程序对所有人可用。
- en: 'There’s lots of activity in the Node web framework scene, but there’s another
    aspect to Node web development that we haven’t mentioned yet: real-time development.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node网络框架场景中有很多活动，但我们还没有提到Node网络开发的另一个方面：实时开发。
- en: 9.5\. Real-time services
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 实时服务
- en: 'Node is the natural choice for web-based real-time services. Broadly speaking,
    this involves three types of applications: statistics servers, collaboration services,
    and latency-sensitive applications like game servers.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: Node是网络实时服务的自然选择。从广义上讲，这涉及三种类型的应用程序：统计服务器、协作服务和像游戏服务器这样的对延迟敏感的应用程序。
- en: It’s not that difficult to start a server with Express and collect data about
    your other applications, servers, weather sensor data, or dog-feeding robot. Unfortunately,
    doing this well isn’t trivial. If you’re logging something every time someone
    plays your free-to-play iOS game, what happens when there are thousands of events
    a minute? How do you scale this, or view critical information in real time?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express启动服务器并收集有关您的其他应用程序、服务器、天气传感器数据或喂狗机器人的数据并不困难。不幸的是，做得好并不简单。如果你每次有人玩你的免费iOS游戏时都记录一些东西，那么当每分钟有数千个事件发生时会发生什么？你如何扩展它，或者实时查看关键信息？
- en: Some companies have this problem on a huge scale, and fortunately some of them
    have created open source tools that we can reuse. One example is Cube ([http://square.github.io/cube/](http://square.github.io/cube/))
    by Square. Cube allows you to collect timestamped events and then derive metrics
    on them. It uses MongoDB, so you could feed data out to something that generates
    graphs. Square has a solution for visualizing the data called Cubism.js ([http://square.github.io/cubism/](http://square.github.io/cubism/)),
    which renders new values in real-time (see [figure 9.9](#ch09fig09)).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司面临着巨大的这个问题，幸运的是，其中一些公司已经创建了开源工具，我们可以重用。一个例子是Square的Cube ([http://square.github.io/cube/](http://square.github.io/cube/))。Cube允许你收集带时间戳的事件，然后对它们进行度量。它使用MongoDB，因此你可以将数据输出到生成图表的东西。Square有一个用于可视化数据的解决方案，称为Cubism.js
    ([http://square.github.io/cubism/](http://square.github.io/cubism/))，它实时渲染新值（见[图9.9](#ch09fig09)）。
- en: Figure 9.9\. Cubism.js shows time series values in real time.
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9\. Cubism.js实时显示时间序列值。
- en: '![](09fig09_alt.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig09_alt.jpg)'
- en: 'The Etherpad project ([http://etherpad.org/](http://etherpad.org/)) is a Node-powered
    collaborative document editor. It allows users to chat as they make changes to
    documents, and color-codes the changes so it’s easy to see what each person is
    doing. It’s based on some of the modules you’ve seen in this book: Mikeal Rogers’
    `request`, Express, and Socket.IO.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: Etherpad项目 ([http://etherpad.org/](http://etherpad.org/))是一个由Node驱动的协作文档编辑器。它允许用户在修改文档时聊天，并使用颜色编码变化，以便容易看到每个人在做什么。它基于本书中的一些模块：Mikeal
    Rogers的`request`、Express和Socket.IO。
- en: WebSockets make these projects possible. Without WebSockets, pushing data to
    the client would be more cumbersome. Node has a rich set of WebSockets implementations—Socket.IO
    ([http://socket.io/](http://socket.io/)) is the most popular, but there’s also
    `ws` ([https://www.npmjs.org/package/ws](https://www.npmjs.org/package/ws)), which
    claims to be the fastest WebSocket implementation.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets使得这些项目成为可能。没有WebSockets，向客户端推送数据将会更加繁琐。Node有一套丰富的WebSockets实现——Socket.IO
    ([http://socket.io/](http://socket.io/))是最受欢迎的，但也有`ws` ([https://www.npmjs.org/package/ws](https://www.npmjs.org/package/ws))，它声称是速度最快的WebSocket实现。
- en: There’s a parallel between sockets and streams; SocketStream ([http://socketstream.org/](http://socketstream.org/))
    aims to bridge the gap by building web applications entirely around streams. It
    uses the HTML5 `history.pushState` API with single-page applications, Connect
    middleware, and code sharing with the browser.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字和流之间存在平行关系；SocketStream ([http://socketstream.org/](http://socketstream.org/))旨在通过构建完全围绕流的Web应用程序来弥合差距。它使用HTML5
    `history.pushState` API与单页应用程序、Connect中间件以及与浏览器的代码共享。
- en: 9.6\. Summary
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. 摘要
- en: In this chapter you’ve seen how Node fits in with modern web development. It
    can be used to improve client-side tooling—it’s now normal for client-side developers
    to install Node and a Node build tool.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了Node如何与现代Web开发相结合。它可以用于改进客户端工具——现在客户端开发者安装Node和Node构建工具已经成为常态。
- en: Node is also used for server-side development. Express is the major web framework,
    but many projects can get off the ground with a subset from Connect. Other frameworks
    are similar to Express, but have a different focus. Restify is one example, and
    can be used to make strict RESTful APIs ([technique 71](#ch09lev2sec8)).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Node也被用于服务器端开发。Express是主要的Web框架，但许多项目可以使用Connect的子集启动。其他框架与Express类似，但有不同的重点。Restify是一个例子，可以用来创建严格的RESTful
    API ([技术71](#ch09lev2sec8))。
- en: Writing well-structured Express applications means you should adopt certain
    patterns and idioms that the Node community has adopted. This includes error handling
    ([technique 70](#ch09lev2sec7)), folders as modules and route separation ([technique
    67](#ch09lev2sec4)), and decoupling through events ([technique 73](#ch09lev2sec10)).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 编写结构良好的Express应用程序意味着你应该采用Node社区已经采用的某些模式和习惯用法。这包括错误处理 ([技术70](#ch09lev2sec7))、文件夹作为模块和路由分离
    ([技术67](#ch09lev2sec4)) 以及通过事件解耦 ([技术73](#ch09lev2sec10))。
- en: It’s also increasingly common to use Node modules in the browser ([technique
    66](#ch09lev2sec3)), and client-side code in Node ([technique 65](#ch09lev2sec2)).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用Node模块 ([技术66](#ch09lev2sec3)) 和Node中的客户端代码 ([技术65](#ch09lev2sec2)) 也越来越普遍。
- en: If you want to write better code, you should adopt test-driven development as
    soon as possible. We’ve included some techniques that enable you to test things
    like authentication ([technique 76](#ch09lev2sec13)) and mocking remote APIs ([technique
    78](#ch09lev2sec15)), but the simple act of writing a test to think about new
    code is one of the best ways to improve your Node web applications. One way you
    can do this is every time you want to add a new route to a web application, write
    the test first. Practice using Super-Test, or a comparable HTTP request library,
    and use it to plan out new API methods, web pages, and forms.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写更好的代码，你应该尽快采用测试驱动开发。我们包括了一些使你能够测试诸如身份验证 ([技术76](#ch09lev2sec13)) 和模拟远程API
    ([技术78](#ch09lev2sec15)) 的技术，但编写测试来思考新代码是提高你的Node Web应用程序的最好方法之一。你可以这样做的一种方式是，每次你想向Web应用程序添加新路由时，先编写测试。练习使用Super-Test或类似的HTTP请求库，并使用它来规划新的API方法、网页和表单。
- en: The next chapter shows you how to write better tests, whether they’re simple
    scripts or database-driven web applications.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向您展示如何编写更好的测试，无论是简单的脚本还是数据库驱动的Web应用程序。
- en: 'Chapter 10\. Tests: The key to confident code'
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 测试：自信代码的关键
- en: '*This chapter covers*'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Assertions, custom assertions, and automated testing
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言、自定义断言和自动化测试
- en: Ensuring things fail as expected
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保事物按预期失败
- en: Mocha and TAP
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha和TAP
- en: Testing web applications
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Web应用程序
- en: Continuous integration
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Database fixtures
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库固定值
- en: 'Imagine that you wanted to add a new currency to an online shop. First you’d
    add a test to define the expected calculations: subtotal, tax, and the total.
    Then you’d write code to make this test pass. This chapter will help you learn
    how to write tests by looking at Node’s built-in features for testing: the `assert`
    module and test scripts that you can set in your package.json file. We also introduce
    two major test frameworks: Mocha and `node-tap`.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要向在线商店添加一种新的货币。首先，你会添加一个测试来定义预期的计算：小计、税和总计。然后你会编写代码使这个测试通过。本章将帮助你通过查看Node的内置测试功能来学习如何编写测试：`assert`模块和你可以设置在package.json文件中的测试脚本。我们还介绍了两个主要的测试框架：Mocha和`node-tap`。
- en: '|  |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Introduction to testing**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试简介**'
- en: This chapter assumes you have some experience at writing unit tests. [Table
    10.1](#ch10table01) includes definitions of the terminology used; if you want
    to know what we mean by assertions, test cases, or test harnesses, you can refer
    to this table.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您在编写单元测试方面有一些经验。[表10.1](#ch10table01) 包含了所使用术语的定义；如果您想了解我们所说的断言、测试用例或测试框架是什么，可以参考此表。
- en: Table 10.1\. Node testing concepts
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1\. 节点测试概念
- en: '| Term | Description |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 描述 |'
- en: '| --- | --- |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Assertion | A logical statement that allows you to test expressions. Supported
    by the assert core module; for example: assert.equal(user.email, ''name@example.com'');.
    |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 断言 | 允许您测试表达式的逻辑语句。由assert核心模块支持；例如：assert.equal(user.email, ''name@example.com'');。
    |'
- en: '| Test case | One or more assertions that test a particular concept. In Mocha,
    a test case looks like this: it(''should calculate the square of a number'', function()
    { assert.equal(square(4), 16);'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '| 测试用例 | 测试特定概念的断言之一或多个。在Mocha中，测试用例看起来像这样：it(''should calculate the square
    of a number'', function() { assert.equal(square(4), 16);'
- en: '}); |'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '}); |'
- en: '| Test harness | A program that runs tests and collates output. The resulting
    reports help diagnose problems when tests fail. This builds on the previous example,
    so with Mocha a test harness looks like this: var assert = require(''assert'');
    var square = require(''./square'');'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '| 测试框架 | 运行测试并汇总输出的程序。生成的报告有助于诊断测试失败时的问题。在之前的示例基础上，使用Mocha的测试框架看起来像这样：var assert
    = require(''assert''); var square = require(''./square'');'
- en: describe('Squaring numbers', function() {
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: describe('平方数', function() {
- en: it('should calculate the square of a number', function() {
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: it('should calculate the square of a number', function() {
- en: assert.equal(square(4), 16);
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: assert.equal(square(4), 16);
- en: '});'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: it('should return 0 for 0', function() {
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: it('should return 0 for 0', function() {
- en: assert.equal(square(0), 0);
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: assert.equal(square(0), 0);
- en: '});'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}); |'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '}); |'
- en: '| Fixture | Test data that is usually prepared before tests are run. Let’s
    say you want to test a user accounts system. You could predefine users and their
    passwords, and then include the passwords in the tests to ensure users can sign
    in correctly. In Node, JSON is a popular file format for fixtures, but you could
    use a database, SQL dump, or CSV file. It depends on your application’s requirements.
    |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| 配置 | 在运行测试之前通常准备好的测试数据。假设您想测试用户账户系统。您可以预先定义用户及其密码，然后在测试中包含密码以确保用户可以正确登录。在Node中，JSON是配置文件格式的流行格式，但您也可以使用数据库、SQL转储或CSV文件。这取决于您的应用程序需求。
    |'
- en: '| Mock | An object that simulates another object. Mocks are often used to replace
    I/O operations that are either slow or difficult to run in unit tests; for example,
    downloading data from a remote web API, or accessing a database. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 模拟另一个对象的对象。模拟通常用于替换在单元测试中既慢又难以运行的I/O操作；例如，从远程Web API下载数据或访问数据库。 |'
- en: '| Stub | A method stub is used to replace functionality for the duration of
    tests. For example, methods used to communicate with an I/O source like a disk
    or remote API can be stubbed to return predefined data. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| 存根 | 存根方法用于在测试期间替换功能。例如，用于与磁盘或远程API等I/O源通信的方法可以存根以返回预定义的数据。 |'
- en: '| Continuous integration server | A CI server runs automated tests whenever
    a project is updated through a version control server. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| 持续集成服务器 | 持续集成服务器在项目通过版本控制服务器更新时自动运行测试。 |'
- en: 'For a more detailed introduction to testing, *The Art of Unit Testing, Second
    Edition* (Roy Osherove, Manning, 2013; [http://manning.com/osherove2/](http://manning.com/osherove2/))
    has step-by-step examples for writing maintainable and readable tests. *Test Driven
    Development: By Example* (Kent Beck, Addison-Wesley, 2002; [http://mng.bz/UT12](http://mng.bz/UT12))
    is another wellknown foundational book on the topic.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试的更详细介绍，*《单元测试的艺术，第二版》*（Roy Osherove，Manning，2013；[http://manning.com/osherove2/](http://manning.com/osherove2/))
    提供了编写可维护和可读性测试的逐步示例。*《通过示例的测试驱动开发》*（Kent Beck，Addison-Wesley，2002；[http://mng.bz/UT12](http://mng.bz/UT12))
    是另一本关于该主题的知名基础书籍。
- en: '|  |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One of the advantages of working with Node is that the community adopted testing
    early on, so there’s no shortage of modules to help you write fast and readable
    tests. You might be wondering what’s so great about tests and why we write them
    early on during development. Well, tests are important for exploring ideas before
    committing to them—you can think of them like small, flexible experiments. They
    also communicate your *intent*, which means they help document and expand on the
    ideas in the key parts of the project. Tests can also help reduce maintenance
    in mature projects by allowing you to check that changes haven’t broken existing
    working features.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 与Node一起工作的一个优点是，社区早期就采用了测试，所以没有缺少帮助你编写快速且可读的测试的模块。你可能想知道测试有什么好处，为什么我们在开发早期就编写它们。好吧，测试在做出承诺之前探索想法很重要——你可以把它们看作是小型的、灵活的实验。它们还传达了你的*意图*，这意味着它们有助于记录和扩展项目关键部分的想法。测试还可以通过允许你检查更改是否破坏了现有功能来帮助减少成熟项目的维护工作。
- en: The first thing to learn about is Node’s `assert` module. This module allows
    you to define an expectation that will throw an error when it isn’t met. Expressing
    and confirming expectations is the main purpose of tests, so you’ll see a lot
    of assertions in this chapter. Although you don’t have to use `assert` to write
    tests, it’s a built-in core module and similar to assertion libraries you might’ve
    used before in other languages. The first set of techniques in this chapter is
    all about assertions.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要了解的是Node的`assert`模块。此模块允许你定义一个期望，当它不满足时将抛出错误。表达和确认期望是测试的主要目的，所以你将在本章中看到很多断言。虽然你不必使用`assert`来编写测试，但它是一个内置的核心模块，类似于你在其他语言中可能使用过的断言库。本章的第一套技术都是关于断言的。
- en: To get everyone up to speed, the next section includes a list of common terms
    used when working with tests.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让每个人都能跟上进度，下一节包括了一个列表，列出了在测试工作中常用的术语。
- en: 10.1\. Introduction to testing with Node
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 使用Node进行测试的介绍
- en: To make it easier for newcomers to automated testing, we’ve included [table
    10.1](#ch10table01) that defines common terminology. This table also outlines
    what we mean by specific terms, because some programming communities use the same
    terms slightly differently.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让新来的自动化测试人员更容易理解，我们包括了[表10.1](#ch10table01)，该表定义了常见的术语。此表还概述了我们所说的特定术语，因为一些编程社区对相同的术语使用略有不同。
- en: The only feature from [table 10.1](#ch10table01) that Node directly supports
    is assertions. The other features are provided through third-party libraries—you’ll
    learn about CI servers in [technique 86](#ch10lev2sec8), and mocks and fixtures
    in [technique 87](#ch10lev2sec9). You don’t have to use all of these things to
    write tests, you can actually write tests with just the assertion module. The
    next section introduces the `assert` module so you can start writing basic tests.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Node直接支持的[表10.1](#ch10table01)中的唯一功能是断言。其他功能是通过第三方库提供的——你将在[技巧86](#ch10lev2sec8)中了解CI服务器，在[技巧87](#ch10lev2sec9)中了解模拟和固定值。你不必使用所有这些工具来编写测试，实际上你只需使用断言模块就可以编写测试。下一节介绍了`assert`模块，这样你就可以开始编写基本测试了。
- en: 10.2\. Writing simple tests with assertions
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 使用断言编写简单测试
- en: So far we’ve briefly mentioned that assertions are used to test expressions.
    But what does this involve? Typically assertions are functions that cause an exception
    to be raised if a condition isn’t met. A failing assertion is like your credit
    card being declined in a store—your program will refuse to run no matter how many
    times you try. The idea of assertions has been around for a long time; even C
    has assertions.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们简要地提到断言用于测试表达式。但这究竟涉及什么？通常，断言是当条件不满足时引发异常的函数。失败的断言就像在商店里你的信用卡被拒绝一样——无论你尝试多少次，你的程序都不会运行。断言的想法已经存在很长时间了；甚至C语言也有断言。
- en: In C, the standard library includes the `assert()` macro, which is used for
    verifying expressions. In Node, we have the `assert` core module. There are other
    assertion modules out there, but `assert` is built-in and easy to use and extend.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，标准库包括用于验证表达式的`assert()`宏。在Node中，我们有`assert`核心模块。还有其他断言模块，但`assert`是内置的，易于使用和扩展。
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: CommonJS unit testing
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CommonJS 单元测试
- en: The `assert` module is based on the CommonJS Unit Testing 1.1 specification
    ([http://wiki.commonjs.org/wiki/Unit_Testing/1.1](http://wiki.commonjs.org/wiki/Unit_Testing/1.1)).
    So even though it’s a built-in core module, you can use other assertion modules
    as well. The underlying principles are always the same.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块基于 CommonJS 单元测试 1.1 规范([http://wiki.commonjs.org/wiki/Unit_Testing/1.1](http://wiki.commonjs.org/wiki/Unit_Testing/1.1))。因此，尽管它是一个内置的核心模块，但你也可以使用其他断言模块。底层原则始终相同。'
- en: '|  |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This section introduces Node’s built-in assertions. By following the first technique,
    you’ll be able to write tests using the `assert` core module by using `assert.equal`
    to check for equality, and to automate the running of tests by using npm scripts.^([[1](#ch10fn01)])
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 Node 的内置断言。通过遵循第一个技巧，你可以使用 `assert` 核心模块通过使用 `assert.equal` 来检查相等性，并通过使用
    npm 脚本来自动化测试的运行.^([[1](#ch10fn01)])
- en: ¹ This is defined by the `scripts` property in a package.json file. See `npm
    help scripts` for details on this feature.
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 这是由 package.json 文件中的 `scripts` 属性定义的。有关此功能的详细信息，请参阅 `npm help scripts`。
- en: Technique 79 Writing tests with built-in modules
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 79 使用内置模块编写测试
- en: Have you ever tried to write a quick test for an important feature, but you
    found yourself lost in test library documentation? It can be hard to get started
    actually writing tests; it seems like there’s a lot to learn. If you just start
    using the `assert` module, though, you can write tests right now without any special
    libraries.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经尝试为重要的功能编写快速测试，但发现自己迷失在测试库文档中？实际上开始编写测试可能很难；似乎有很多东西要学。如果你只是开始使用 `assert`
    模块，那么你现在就可以编写测试，而无需任何特殊库。
- en: This is great when you’re writing a small module and don’t want to install any
    dependencies. This technique demonstrates how to write clean, expressive, single-file
    tests.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个小的模块且不想安装任何依赖项时，这会非常棒。这个技巧演示了如何编写干净、表达力强、单文件测试。
- en: Problem
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have a clear idea of the acceptable input and output values for your module,
    class, or functions, and you want it to be clear when the output values don’t
    match the input.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 你对你的模块、类或函数的输入和输出值有一个清晰的认识，并且你希望当输出值与输入值不匹配时，这一点是明确的。
- en: Solution
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `assert` module and npm scripts.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assert` 模块和 npm 脚本。
- en: Discussion
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Node comes with an assertion module. You can think of this as a toolkit for
    checking expectations against outcomes. Internally this is done by comparing *actual*
    values against *expected* values. The `assert.equal` method demonstrates this
    perfectly: the arguments are `actual, expected`. There’s also a third optional
    argument: `message`. Passing a message makes it easier to understand what happened
    when tests fail.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: Node 内置了一个断言模块。你可以将其视为一个用于检查预期结果与实际结果之间差异的工具包。内部是通过比较 *实际* 值与 *预期* 值来完成的。`assert.equal`
    方法完美地展示了这一点：参数是 `actual, expected`。还有一个第三个可选参数：`message`。传递一个消息使得在测试失败时更容易理解发生了什么。
- en: 'Let’s say you’re writing an online shop that calculates order prices, and you’ve
    sold three items at $3.99 each. You could ensure the correct price gets calculated
    with this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个在线商店，该商店计算订单价格，并且你已经以每件 $3.99 的价格卖出了三件商品。你可以确保使用以下方法正确计算价格：
- en: '[PRE8]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In methods with only a single required argument, like `assert(value)`, the expected
    value is `true`, so it uses the same pattern.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个必需参数的方法中，如 `assert(value)`，预期值是 `true`，因此它使用相同的模式。
- en: To see what happens when a test fails, try running the next listing.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试失败时会发生什么，请尝试运行下一个列表。
- en: Listing 10.1\. The `assert` module
  id: totrans-680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. `assert` 模块
- en: '![](264fig01_alt.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![](264fig01_alt.jpg)'
- en: The first line you’ll see in most test files is one that loads the `assert`
    module ![](1.jpg). The `assert` variable is also a function aliased from `assert.ok`—which
    means you can use either `assert()` or `assert.ok()`![](2.jpg).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数测试文件中，你首先看到的是加载 `assert` 模块的代码！[](1.jpg)。`assert` 变量也是从 `assert.ok` 别名的一个函数——这意味着你可以使用
    `assert()` 或 `assert.ok()`！[](2.jpg)。
- en: It’s easy to forget the order of the arguments for `assert.equal`, so you might
    find yourself checking Node’s documentation a lot. It doesn’t really matter how
    you order the arguments—some people might find it easier to list the expected
    value first so they can scan the code for values—but you should be consistent.
    That’s why this example is explicit about the naming of `actual` and `expected`
    ![](3.jpg).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 容易忘记 `assert.equal` 的参数顺序，所以你可能发现自己经常查看 Node 的文档。实际上，参数的顺序并不重要——有些人可能觉得先列出预期值更容易，这样他们就可以扫描代码中的值——但是你应该保持一致。这就是为什么这个例子明确指出了
    `actual` 和 `expected` 的命名！[](3.jpg)。
- en: 'This test has a function that has an intentional bug ![](4.jpg). You can run
    the test with `node assertions.js`, which should display an error with a stack
    trace:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试有一个有意的错误函数 ![图片描述](4.jpg)。你可以使用 `node assertions.js` 运行测试，它应该显示一个带有堆栈跟踪的错误：
- en: '![](264fig02_alt.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](264fig02_alt.jpg)'
- en: These stack traces can be hard to read. But because we’ve included a message
    with the assertion that failed, we can see a description of what went wrong. We
    can also see that the assertion failed in the file assertions.js on line 7 ![](1.jpg).
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这些堆栈跟踪可能难以阅读。但因为我们已经包含了一个与失败的断言相关的消息，我们可以看到错误的描述。我们还可以看到断言失败在文件 assertions.js
    的第 7 行 ![图片描述](1.jpg)。
- en: The `assert` module has lots of other useful methods for testing values. The
    most significant is `assert.deepEqual`, which can check for equality between two
    objects. This is important because `assert.equal` can only compare shallow equality.
    Shallow equality is used for comparing primitive values like strings or numbers,
    whereas `deepEqual` can compare objects with nested objects and values.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块有许多其他有用的测试值方法。最重要的是 `assert.deepEqual`，它可以检查两个对象之间的相等性。这是很重要的，因为
    `assert.equal` 只能比较浅层相等性。浅层相等性用于比较原始值，如字符串或数字，而 `deepEqual` 可以比较包含嵌套对象和值的对象。'
- en: 'You might find `deepEqual` useful when you’re writing tests that return complex
    objects. Think about the online shop example from earlier. Your shopping cart
    might look like this: `{ items: [ { name: "Coffee beans", price: 4.95 } ], subtotal:
    4.95 }`. It’s an object that contains an array of shopping cart items, and a subtotal
    that is calculated by another object. Now, to check this entire object against
    one that you’ve defined in your unit test, you’d use `assert.deepEqual`, because
    it’s able to compare objects rather than just primitive values.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '当你编写返回复杂对象的测试时，你可能会发现 `deepEqual` 很有用。想想之前提到的在线商店示例。你的购物车可能看起来像这样：`{ items:
    [ { name: "Coffee beans", price: 4.95 } ], subtotal: 4.95 }`。这是一个包含购物车项目数组的对象，以及由另一个对象计算的小计。现在，为了检查这个整个对象与你在单元测试中定义的对象，你会使用
    `assert.deepEqual`，因为它能够比较对象，而不仅仅是原始值。'
- en: The `deepEqual` method can be seen in the next listing.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepEqual` 方法可以在下一个列表中看到。'
- en: Listing 10.2\. Testing object equality
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 测试对象相等
- en: '![](265fig01_alt.jpg)'
  id: totrans-691
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](265fig01_alt.jpg)'
- en: This example uses the `assert` module ![](1.jpg) to test objects created by
    a constructor function, and an imaginary login system. The login system is accidentally
    loading normal users as if they were administrators ![](3.jpg).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `assert` 模块 ![图片描述](1.jpg) 来测试由构造函数创建的对象，以及一个假设的登录系统。登录系统意外地将普通用户加载为管理员
    ![图片描述](3.jpg)。
- en: The `assert.deepEqual` method ![](2.jpg) will go over each property in the objects
    to see if any are different. When it runs into `user.permissions.admin` and finds
    the values differ, an `AssertionError` exception will be raised.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert.deepEqual` 方法 ![图片描述](2.jpg) 将遍历对象中的每个属性，以查看是否有任何不同的。当它遇到 `user.permissions.admin`
    并发现值不同时，将抛出 `AssertionError` 异常。'
- en: If you take a look at the `assert` module’s documentation, you’ll see many other
    useful methods. You can invert logic with `notDeepEqual` and `notEqual`, and even
    perform strict equality checks just like `===` with `strictEqual` and `notStrictEqual`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `assert` 模块的文档，你会看到许多其他有用的方法。你可以使用 `notDeepEqual` 和 `notEqual` 来反转逻辑，甚至可以使用
    `strictEqual` 和 `notStrictEqual` 来执行类似于 `===` 的严格相等检查。
- en: There’s another aspect to testing, and that’s ensuring that things fail the
    way we expect. The next technique looks at testing for failures.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 测试还有另一个方面，那就是确保事情以我们期望的方式失败。下一个技巧将探讨测试失败。
- en: Technique 80 Testing for errors
  id: totrans-696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 80 测试错误
- en: Programs will eventually fail, but when they do, we want them to produce useful
    errors. This technique is about ensuring that expected errors are raised, and
    about how to cause exceptions to be raised during testing.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 程序最终都会失败，但当我们遇到失败时，我们希望它们产生有用的错误。这项技术是确保预期的错误被抛出，以及如何在测试期间引发异常。
- en: Problem
  id: totrans-698
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test your error-handling code.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 你想测试你的错误处理代码。
- en: Solution
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `assert.throws` and `assert.ifError`.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assert.throws` 和 `assert.ifError`。
- en: Discussion
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: One of the conventions we use as Node developers is that asynchronous methods
    should return an error as the first argument. When we design our own modules,
    we know there are places where errors are likely to occur. Ideally we should test
    these cases to make sure the correct errors are passed to callbacks.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为 Node 开发者使用的约定之一是，异步方法应该将错误作为第一个参数返回。当我们设计自己的模块时，我们知道错误可能发生的地方。理想情况下，我们应该测试这些情况，以确保正确的错误被传递给回调。
- en: The following listing shows how to ensure an error hasn’t been passed to an
    asynchronous function.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何确保错误没有被传递给异步函数。
- en: Listing 10.3\. Handling errors from asynchronous APIs
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 处理异步 API 的错误
- en: '![](266fig01_alt.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![](266fig01_alt.jpg)'
- en: Although `assert.ifError` works synchronously, it makes semantic sense to use
    it for testing asynchronous functions that pass errors to callbacks. [Listing
    10.3](#ch10ex03) uses an asynchronous function called `readConfigFile` ![](1.jpg)
    to read a configuration file. In reality this might be the database configuration
    for a web application, or something similar. If the file isn’t found, then it
    returns default values ![](2.jpg). Any other error—and this is the important part—will
    be passed to the callback ![](3.jpg).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `assert.ifError` 可以同步工作，但将其用于测试传递错误给回调的异步函数在语义上是有意义的。[列表 10.3](#ch10ex03)
    使用了一个名为 `readConfigFile` 的异步函数 ![](1.jpg) 来读取配置文件。实际上，这可能是网络应用的数据库配置，或者类似的东西。如果找不到文件，则返回默认值
    ![](2.jpg)。任何其他错误——这是重要的一部分——将被传递给回调 ![](3.jpg)。
- en: That means the `assert.ifError` test ![](4.jpg) can easily detect whether an
    unexpected error has occurred. If something changes in the structure of the project
    that causes an unusual error to be raised, then this test will catch that and
    warn the developers before they release potentially dangerous code.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `assert.ifError` 测试 ![](4.jpg) 可以轻松地检测是否发生了意外的错误。如果项目的结构发生变化，导致抛出了不寻常的错误，那么这个测试将捕获它，并在开发者发布可能危险的代码之前警告他们。
- en: Now let’s look at raising exceptions during testing. Rather than using `try`
    and `catch` in our tests, we can use `assert.throws`.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看在测试期间抛出异常的情况。在我们的测试中，我们不必使用 `try` 和 `catch`，而是可以使用 `assert.throws`。
- en: To use `assert.throws`, you must supply the function to be run and an expected
    error constructor. Because a function is passed, this works well with asynchronous
    APIs, so you can use it to test things that depend on I/O operations.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `assert.throws`，你必须提供要运行的函数和预期的错误构造函数。因为传递了一个函数，所以它与异步 API 一起使用效果很好，因此你可以用它来测试依赖于
    I/O 操作的事情。
- en: The next listing shows how to use `assert.throws` with a fictitious user account
    system.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何使用 `assert.throws` 与一个虚构的用户账户系统。
- en: Listing 10.4\. Ensuring that exceptions are raised
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 确保抛出异常
- en: '![](267fig01_alt.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
  zh: '![](267fig01_alt.jpg)'
- en: The assertion ![](1.jpg) checks to ensure the expected exception is thrown.
    The first argument is a function to test, in this case `loginAdmin`, and the second
    is the expected error ![](2.jpg).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 断言 ![](1.jpg) 检查以确保抛出了预期的异常。第一个参数是要测试的函数，在这种情况下是 `loginAdmin`，第二个是预期的错误 ![](2.jpg)。
- en: 'This highlights two things about `assert.throws`: it can be used with asynchronous
    APIs because you pass it a function, and it expects error objects of some kind.
    When developing projects with Node, it’s a good idea to use `util.inherits` to
    inherit from the built-in `Error` constructor. This allows people to easily catch
    your errors, and you can decorate them with extra properties that include useful
    additional information if required.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这突出了 `assert.throws` 的两个特点：它可以与异步 API 一起使用，因为它传递了一个函数，并且它期望某种类型的错误对象。当使用 Node
    开发项目时，使用 `util.inherits` 从内置的 `Error` 构造函数继承是一个好主意。这允许人们轻松地捕获你的错误，如果需要，你可以用额外的属性来装饰它们，这些属性包括有用的附加信息。
- en: In this case we’ve created `PermissionError` ![](3.jpg), which is a clear name
    and therefore self-documenting—if someone sees a `PermissionError` in a stack
    trace, they’ll know what went wrong. A `PermissionError` is subsequently thrown
    in the `login-Admin` function ![](4.jpg).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了 `PermissionError` ![](3.jpg)，这是一个清晰的名字，因此是自文档化的——如果有人在堆栈跟踪中看到 `PermissionError`，他们会知道出了什么问题。随后在
    `login-Admin` 函数 ![](4.jpg) 中抛出了 `PermissionError`。
- en: This technique delved into error handling with the `assert` module. Combined
    with the previous techniques, you should have a good understanding of how to test
    a range of situations with assertions. With `assert.equal` you can quickly compare
    numbers and strings, and this covers a lot of problems like checking prices in
    invoices or email addresses in web application account-handling code. A lot of
    the time, `assert.ok`—which is aliased as `assert()`—is enough to get by, because
    it’s a quick and handy way for checking for *truthy* expressions. But there’s
    one last thing to master if you want to really take advantage of the `assert`
    module; read on to learn how to create custom assertions.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术深入探讨了 `assert` 模块的错误处理。结合前面的技巧，你应该对如何使用断言测试各种情况有很好的理解。使用 `assert.equal`
    你可以快速比较数字和字符串，这涵盖了检查发票中的价格或网络应用程序账户处理代码中的电子邮件地址等很多问题。很多时候，`assert.ok`（别名为 `assert()`）就足够了，因为它是一种快速便捷的检查真值表达式的手段。但如果你想要真正充分利用
    `assert` 模块，还有最后一件事需要掌握；继续阅读以了解如何创建自定义断言。
- en: Technique 81 Creating custom assertions
  id: totrans-718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 81 创建自定义断言
- en: Node’s built-in assertions can be extended to support application-specific expressions.
    Sometimes you find yourself repeatedly using the same code to test things, and
    it seems like there might be a better way. For example, suppose you’re checking
    for valid email addresses with a regular expression in `assert.ok`. Writing custom
    assertions can solve this problem, and is easier than you might think. Learning
    how to write custom assertions will also help you understand the assertion module
    from the inside out.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的内置断言可以扩展以支持特定于应用程序的表达式。有时你会发现自己反复使用相同的代码来测试事物，似乎有更好的方法。例如，假设你正在使用正则表达式在`assert.ok`中检查有效的电子邮件地址。编写自定义断言可以解决这个问题，而且比你想象的要简单。学习如何编写自定义断言也将帮助你从内到外理解断言模块。
- en: Problem
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re repeating a lot of code in your tests that could be replaced if only
    you had the right assertion.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你在测试中重复了很多代码，如果只有正确的断言，这些代码是可以被替换的。
- en: Solution
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Extend the built-in `assert` module.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展内置的 `assert` 模块。
- en: Discussion
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `assert` module is built around a single function: `fail`. `assert.ok`
    actually calls `fail` with the logic inverted, so it looks like this: `if (!value)
    fail(value)`. If you look at how `fail` works, you’ll see that it just throws
    an `assert.AssertionError`:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 模块围绕一个单一函数构建：`fail`。`assert.ok` 实际上是通过逻辑反转调用 `fail`，所以看起来像这样：`if (!value)
    fail(value)`。如果你查看 `fail` 的工作方式，你会看到它只是抛出一个 `assert.AssertionError`：'
- en: '[PRE9]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The error object is decorated with properties that make it easier for test reporters
    to break down the location and cause of failures. The people who wrote this module
    knew that others would like to write their own assertions, so the `fail` function
    is exported, which means it can be reused.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 错误对象被添加了使测试报告者更容易分解失败位置和原因的属性。编写此模块的人知道其他人会想编写自己的断言，因此导出了`fail`函数，这意味着它可以被重用。
- en: 'Writing a custom assertion involves the following steps:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自定义断言涉及以下步骤：
- en: '**1**.  Define a method with a signature similar to the existing assertion
    library.'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 定义一个与现有断言库签名类似的方法。'
- en: '**2**.  Call `fail` when an expectation isn’t matched.'
  id: totrans-730
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 当期望不匹配时调用 `fail`。'
- en: '**3**.  Test to ensure failure results in an `AssertionError`.'
  id: totrans-731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 测试以确保失败结果产生一个 `AssertionError`。'
- en: '[Listing 10.5](#ch10ex05) puts these steps together to define a custom assertion
    that ensures a regular expression is matched.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.5](#ch10ex05) 将这些步骤组合起来定义一个自定义断言，以确保正则表达式匹配。'
- en: Listing 10.5\. A custom assertion
  id: totrans-733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 自定义断言
- en: '![](269fig01_alt.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![](269fig01_alt.jpg)'
- en: This example loads the assertion module ![](1.jpg) and then defines a function
    called `match` that runs `assert.fail` to generate the right exception when the
    regular expression doesn’t match the *actual* value ![](2.jpg). The key detail
    to remember is to define the argument list to be consistent with other methods
    in the assertion module—the example here is based on `assert.equal`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例加载断言模块 ![](1.jpg) 并定义一个名为 `match` 的函数，该函数运行 `assert.fail` 以在正则表达式不匹配实际值时生成正确的异常
    ![](2.jpg)。要记住的关键细节是定义参数列表，使其与其他断言模块中的方法保持一致——这里的示例基于 `assert.equal`。
- en: '[Listing 10.5](#ch10ex05) also includes some tests. In reality these would
    be in a separate file, but here they illustrate how the custom assertion works.
    First we check to see if it passes a simple test by matching a string against
    a regular expression ![](3.jpg), and then `assert.throws` is used to ensure the
    test really does fail when it’s meant to ![](4.jpg).'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.5](#ch10ex05) 也包含了一些测试。实际上这些测试会在一个单独的文件中，但在这里它们展示了自定义断言的工作方式。首先我们检查它是否通过一个简单的测试，通过匹配字符串与正则表达式
    ![](3.jpg)，然后使用 `assert.throws` 确保测试在应该失败时确实失败了 ![](4.jpg)。'
- en: '|  |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Your own domain-specific language**'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '**您自己的领域特定语言**'
- en: Using custom assertions is but one technique for creating your own testing DSL
    (domain-specific language). If you find you’re duplicating code between test cases,
    then by all means wrap that code in a function or class.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义断言只是创建您自己的测试领域特定语言（DSL）的一种技术。如果您发现测试用例之间有代码重复，那么完全可以将这些代码封装在函数或类中。
- en: 'For example, `setUpUserAccount({ email: ''user@example.com'' })` is more readable
    than three or four lines of setup code, particularly if it’s repeated between
    test cases.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`setUpUserAccount({ email: ''user@example.com'' })` 比三到四行设置代码更易读，尤其是在测试用例之间重复时。'
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This example might seem simple, but understanding how to write custom assertions
    improves your knowledge of the underlying module. Custom assertions can help clean
    up tests where expectations have been made less expressive by squeezing concepts
    into built-in assertions. If you want to be able to say something like `assert.httpStatusOK`,
    now you can!
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来很简单，但了解如何编写自定义断言可以提高您对底层模块的了解。自定义断言可以帮助清理测试，其中期望由于将概念挤压到内置断言中而变得不那么表达。如果您想要能够说出像
    `assert.httpStatusOK` 这样的东西，现在您就可以做到了！
- en: With assertions out of the way, it’s time to look at how to organize tests across
    multiple files. The next technique introduces test harnesses that can be used
    to organize groups of test files and run them more easily.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 将断言处理完毕后，是时候看看如何跨多个文件组织测试了。接下来的技术将介绍可以用来组织测试文件组并更轻松运行它们的测试工具。
- en: 10.3\. Test harnesses
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 测试工具
- en: A test harness, or automated test framework, generally refers to a program that
    sets up the runtime environment and runs tests, and then collects and compares
    the results. Since it’s automated, tests can be run by other systems including
    continuous integration (CI) servers, covered in [technique 86](#ch10lev2sec8).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具或自动化测试框架通常指的是一个设置运行时环境并运行测试，然后收集和比较结果的程序。由于它是自动化的，测试可以被包括持续集成（CI）服务器在内的其他系统运行，这在技术86中有所介绍。[技术86](#ch10lev2sec8)。
- en: Test harnesses are used to execute groups of test files. That means you can
    easily run lots of tests with a single command. This not only makes it easier
    for you to run tests, but makes it easier for your collaborators as well. You
    may even decide to start all projects with a test harness before doing anything
    else. The next technique shows you how to make your own test harness, and how
    to save time by adding scripts to your package.json files.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具用于执行测试文件组。这意味着您可以使用单个命令轻松运行大量测试。这不仅使您更容易运行测试，也使您的合作者更容易。您甚至可能决定在开始任何其他事情之前，先为所有项目使用测试工具。接下来的技术将向您展示如何创建自己的测试工具，以及如何通过向
    package.json 文件中添加脚本来节省时间。
- en: Technique 82 Organizing tests with a test harness
  id: totrans-747
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号82：使用测试工具组织测试
- en: Suppose you’re working on a project and it keeps on growing, and using a single
    test file is starting to feel messy. It’s hard to read and causes confusion that
    leads to mistakes. So you’d like to use separate files that are related in some
    way. Perhaps you’d even like to run tests one file at a time to help track down
    issues when things go wrong.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在处理一个项目，它一直在增长，使用单个测试文件开始感觉杂乱无章。它难以阅读，并导致混淆，进而导致错误。因此，您希望使用一些相关联的单独文件。也许您甚至希望一次运行一个测试文件，以帮助在出错时追踪问题。
- en: Test harnesses solve this problem.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具解决了这个问题。
- en: Problem
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write tests organized into test cases and test suites.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望编写组织成测试用例和测试套件的测试。
- en: Solution
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a test harness.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试工具。
- en: Discussion
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: First, let’s consider what a test harness is. In Node, a test harness is a command-line
    script that you can run by typing the name of the script. At its most basic, it
    must run a group of test files and display any errors that occur. We don’t need
    anything particularly special to do that—a failed assertion will cause an exception
    to be thrown; otherwise the program will exit silently with a return code of `0`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下什么是测试框架。在Node中，测试框架是一个可以通过输入脚本名称来运行的命令行脚本。在最基本的情况下，它必须运行一组测试文件并显示发生的任何错误。我们不需要做任何特别的事情来做到这一点——失败的断言将抛出异常；否则程序将静默退出，返回代码为`0`。
- en: That means a basic test harness is just `node test/*.js`, where test/ is a directory
    that contains a set of test files. We can go one better than that. All Node projects
    should have a package.json file. One of the properties in this file is `scripts`,
    and one of the default scripts is `test`. Any string you set here will be executed
    like a shell command.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着基本的测试框架只是`node test/*.js`，其中test/是一个包含一组测试文件的目录。我们可以做得更好。所有Node项目都应该有一个package.json文件。这个文件中的一个属性是`scripts`，其中一个默认脚本就是`test`。你在这里设置的任何字符串都将像shell命令一样执行。
- en: The following listing shows an example package.json file with a test script.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个包含测试脚本的示例package.json文件。
- en: Listing 10.6\. A package.json with a test script
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 包含测试脚本的package.json
- en: '![](270fig01_alt.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![](270fig01_alt.jpg)'
- en: With `node test-runner.js test.js test2.js` set as the `test` script ![](1.jpg),
    other developers can now run your tests simply by typing `npm test`. This is much
    easier than having to remember a project-specific command.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 将`node test-runner.js test.js test2.js`设置为`test`脚本 ![](1.jpg)，其他开发者现在可以通过输入`npm
    test`来运行你的测试。这比记住一个特定项目的命令要容易得多。
- en: Let’s expand this example by looking at how test harnesses work. A test harness
    is a Node program that runs groups of test files. Therefore, we should be able
    to give such a program a list of files to test. Whenever a test fails, it should
    display a stack trace so we can easily track down the source of the failure.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看测试框架是如何工作的来扩展这个例子。测试框架是一个Node程序，它运行测试文件组。因此，我们应该能够给这样的程序提供一个要测试的文件列表。每当测试失败时，它应该显示堆栈跟踪，这样我们就可以轻松地追踪失败的源头。
- en: 'In addition, it should exit with a non-zero return code whenever a test fails.
    That allows tests to be run in an automated way—other software can easily see
    if a test failed without having to parse the textual output from the tests. This
    is how continuous integration (CI) servers work: they automatically run tests
    whenever code is committed to a version control system like Git.'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它应该在测试失败时以非零返回代码退出。这允许以自动化的方式运行测试——其他软件可以轻松地看到测试是否失败，而无需解析测试的文本输出。这就是持续集成（CI）服务器的工作方式：每当代码提交到版本控制系统（如Git）时，它们会自动运行测试。
- en: The next listing shows what a test file for this system should look like.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了这个系统应该看起来像的测试文件。
- en: Listing 10.7\. An example test file
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 一个示例测试文件
- en: '![](271fig01_alt.jpg)'
  id: totrans-765
  prefs: []
  type: TYPE_IMG
  zh: '![](271fig01_alt.jpg)'
- en: The `it` function ![](1.jpg) looks strange, but it’s a global function that
    will be provided by our test framework. It gives each test case a name so it’s
    easier to understand the results when the tests are run. A failing test is included
    ![](2.jpg) so we can see what happens when tests fail. The last test case ![](3.jpg)
    should run even though the second one failed.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`函数 ![](1.jpg)看起来很奇怪，但它是一个全局函数，将由我们的测试框架提供。它给每个测试案例一个名称，这样在运行测试时更容易理解结果。包含失败的测试
    ![](2.jpg)以便我们可以看到测试失败时会发生什么。最后一个测试案例 ![](3.jpg)即使在第二个测试失败的情况下也应该运行。'
- en: 'Now, the final piece of the puzzle: the next listing includes a program capable
    of executing this test.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一部分：下一个列表包含一个能够执行这些测试的程序。
- en: Listing 10.8\. Running tests in a prescribed manner
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 以规定的方式运行测试
- en: '![](272fig01_alt.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](272fig01_alt.jpg)'
- en: 'This example can be run by passing test files as arguments: `node test-runner.js
    test.js test2.js test-n.js`. The `it` function is defined as a global ![](1.jpg),
    and is called `it` so the tests and their output read logically. This makes sense
    when the results are printed ![](3.jpg).'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以通过传递测试文件作为参数来运行：`node test-runner.js test.js test2.js test-n.js`。`it`函数被定义为全局
    ![](1.jpg)，并被命名为`it`，这样测试及其输出在逻辑上读起来更合理。当结果被打印 ![](3.jpg)时，这很有意义。
- en: Because `it` takes a test case name and a callback, the callback can be run
    under whatever conditions we desire. In this case we’re running it inside a `try/catch`
    statement ![](2.jpg), which means we can catch failed assertions and report errors
    ![](4.jpg) to the user.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`it`接受一个测试用例名称和一个回调，所以回调可以在我们想要的任何条件下运行。在这种情况下，我们是在`try/catch`语句中运行它 ![2.jpg](2.jpg)，这意味着我们可以捕获失败的断言并向用户报告错误
    ![4.jpg](4.jpg)。
- en: Tests are loaded by calling `require` on each of the files passed in as command-line
    arguments ![](5.jpg). In a more polished version of this program, the file handling
    would need to be more sophisticated. Wildcard expressions would need to be supported,
    for example.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是通过在传递给命令行参数的每个文件上调用`require`来加载的 ![5.jpg](5.jpg)。在更完善的程序版本中，文件处理需要更复杂。例如，需要支持通配符表达式。
- en: A failed test case causes the `exitCode` variable to be set to a non-zero value.
    This is returned to the controlling process with `process.exit` in the exit handler
    ![](6.jpg).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败的测试用例会导致`exitCode`变量被设置为非零值。在退出处理程序中，这个值会通过`process.exit`返回给控制进程 ![6.jpg](6.jpg)。
- en: Even though this is a minimal example, it can be run with `npm test`, gives
    test cases a little syntax sugar with `it`, improves the error reporting over
    a simple file full of assertions, and returns a non-zero exit code when something
    goes wrong. This is the basis for most popular Node test frameworks like Mocha,
    which we’ll look at in the next section.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个最小化的示例，但它可以用`npm test`运行，通过`it`为测试用例提供一点语法糖，改进了比简单的断言文件更详细的错误报告，并在出错时返回非零退出代码。这是大多数流行的Node测试框架（如Mocha）的基础，我们将在下一节中探讨。
- en: 10.4\. Test frameworks
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4 测试框架
- en: 'If you’re starting a new project, then you should install a test framework
    early on. Suppose that you’re building an online blogging system, or perhaps a
    simple content management system. You’d like to allow people to sign in, but only
    allow specific users to access the administration interface. By using a test framework
    like Mocha or `node-tap`, you can write tests that address these specific concerns:
    users signing up for accounts, and administrators signing in to the admin interface.
    You could create separate test files for these concerns, or bundle them up as
    groups of test cases under “user accounts tests.”'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在启动一个新项目，那么你应该尽早安装一个测试框架。假设你正在构建一个在线博客系统，或者可能是一个简单的内容管理系统。你希望允许人们登录，但只允许特定的用户访问管理界面。通过使用Mocha或`node-tap`这样的测试框架，你可以编写针对这些特定问题的测试：用户注册账户，以及管理员登录到管理界面。你可以为这些关注点创建单独的测试文件，或者将它们作为“用户账户测试”下的测试用例组来打包。
- en: 'Test frameworks include scripts to run tests and other features that make it
    easier to write and maintain tests. This section features the Mocha test framework
    in [technique 84](#ch10lev2sec6) and the Test Anything Protocol (TAP; [http://testanything.org/](http://testanything.org/))
    in [technique 85](#ch10lev2sec7)—two popular test frameworks favored by the Node
    community. Mocha is lightweight: it runs tests, provides three styles for structuring
    test cases,^([[2](#ch10fn02)]) and expects you to use either Node’s `assert` module
    or another third-party module. Conversely, `node-tap`, which implements TAP, uses
    an API that includes assertions.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架包括运行测试和其他使编写和维护测试更简单的脚本。本节介绍了Mocha测试框架在[技巧84](#ch10lev2sec6)和测试任何协议（TAP；[http://testanything.org/](http://testanything.org/))在[技巧85](#ch10lev2sec7)中的应用——这两个是Node社区中受欢迎的测试框架。Mocha轻量级：它运行测试，提供三种结构测试用例的风格，^([[2](#ch10fn02)])并期望你使用Node的`assert`模块或另一个第三方模块。相反，实现了TAP的`node-tap`使用了一个包含断言的API。
- en: ² Mocha supports API styles based on Behavior Driven Development (BDD), Test
    Driven Development (TDD), and Node’s module system (exports).
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² Mocha支持基于行为驱动开发（BDD）、测试驱动开发（TDD）和Node模块系统（exports）的API风格。
- en: Technique 83 Writing tests with Mocha
  id: totrans-779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧83 使用Mocha编写测试
- en: There are many test frameworks for Node, so it’s difficult to choose the right
    one. Mocha is a popular choice because it’s well maintained and has the right
    balance of features and conventions.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Node来说，有众多测试框架，因此选择合适的框架有些困难。Mocha是一个受欢迎的选择，因为它维护得很好，并且具有合适的特性和约定的平衡。
- en: In general, you use a test framework to organize tests for a project. You’d
    like to use a test framework that other people are familiar with so they can easily
    navigate and collaborate without learning a new module. Perhaps you’re just looking
    for a way to run tests the same way every time, or trigger them from an automated
    system.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会使用测试框架来组织项目的测试。您可能希望使用其他人熟悉的测试框架，这样他们可以轻松导航和协作，而无需学习新的模块。也许您只是想找到一种每次都以相同方式运行测试的方法，或者从自动化系统中触发它们。
- en: Problem
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to organize your tests in a way other developers will be familiar with,
    and run the tests with a single command.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以其他开发者熟悉的方式组织测试，并使用单个命令运行测试。
- en: Solution
  id: totrans-784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use one of the many open source test frameworks for Node, like Mocha.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 的许多开源测试框架之一，如 Mocha。
- en: Discussion
  id: totrans-786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Mocha must be installed from npm before you can do anything else. The best way
    to install it is with `npm install --save-dev mocha`. The `--save-dev` option
    causes npm to install Mocha into `node_modules/` and update your project’s package.json
    file with the latest version from npm. It will be saved as a development dependency.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在您进行其他操作之前，必须从 npm 安装 Mocha。最佳安装方式是使用 `npm install --save-dev mocha`。`--save-dev`
    选项会导致 npm 将 Mocha 安装到 `node_modules/` 并更新您的项目 package.json 文件，以包含 npm 中的最新版本。它将被保存为开发依赖项。
- en: '[Listing 10.9](#ch10ex09) shows an example of a simple test written with Mocha.
    It uses the `assert` core module to make assertions, and should be invoked using
    the `mocha` command-line binary. You should add `"./node_modules/mocha/bin/mocha
    test/*.js"` to the `"test"` property in package.json—see [technique 82](#ch10lev2sec4)
    for more details on how to do that.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.9](#ch10ex09) 展示了使用 Mocha 编写的简单测试示例。它使用 `assert` 核心模块进行断言，并且应该使用 `mocha`
    命令行二进制文件来调用。您应该在 package.json 中的 `"test"` 属性中添加 `"./node_modules/mocha/bin/mocha
    test/*.js"`——有关如何做到这一点的更多详细信息，请参阅 [技术 82](#ch10lev2sec4)。'
- en: '|  |'
  id: totrans-789
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Mocha versions**'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha 版本**'
- en: The version of Mocha we use for this chapter is 1.13.x. We prefer to run the
    tests by installing it locally to the project rather than as a systemwide Node
    module. That means that tests can be run using `./node_modules/mocha/bin/mocha
    test/*.js` rather than just typing `mocha`. That allows different projects to
    have different versions of Mocha, just in case the API changes dramatically between
    major releases.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用的 Mocha 版本是 1.13.x。我们更倾向于在本项目本地安装 Mocha 来运行测试，而不是将其作为系统范围内的 Node 模块。这意味着可以使用
    `./node_modules/mocha/bin/mocha test/*.js` 来运行测试，而不是仅仅输入 `mocha`。这允许不同的项目使用不同版本的
    Mocha，以防 API 在主要版本之间发生重大变化。
- en: An alternative is to install Mocha globally with `npm install --global mocha`,
    and then run tests for a project by typing `mocha`. It will display an error if
    it can’t find any tests.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用 `npm install --global mocha` 全局安装 Mocha，然后通过输入 `mocha` 来运行项目的测试。如果它找不到任何测试，将会显示错误。
- en: '|  |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 10.9\. A simple Mocha test
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 一个简单的 Mocha 测试
- en: '![](274fig01_alt.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![](274fig01_alt.jpg)'
- en: The `describe` and `it` functions are provided by Mocha. The `describe` function
    can be used to group related test cases together, and `it` contains a collection
    of assertions that form a test case ![](1.jpg).
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 提供了 `describe` 和 `it` 函数。`describe` 函数可以用来将相关的测试用例分组在一起，而 `it` 包含形成测试用例的断言集合
    ![](1.jpg)。
- en: Special handling for asynchronous tests is required. This involves including
    a `done` argument in the callback for the test case ![](2.jpg), and then calling
    `done()` when the test has finished ![](3.jpg). In this example, a timeout will
    be triggered after a random interval, which means we need to call `done` in the
    `index.randomTimeout` method. The corresponding file under test is shown in the
    next listing.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步测试需要特殊处理。这涉及到在测试用例的回调中包含一个 `done` 参数 ![](2.jpg)，然后在测试完成后调用 `done()` ![](3.jpg)。在这个例子中，将在随机间隔后触发超时，这意味着我们需要在
    `index.randomTimeout` 方法中调用 `done`。相应的测试文件将在下一列表中展示。
- en: Listing 10.10\. A sample module to test
  id: totrans-798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 一个用于测试的示例模块
- en: '![](274fig02_alt.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![](274fig02_alt.jpg)'
- en: '|  |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Controlling synchronous and asynchronous behavior
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制同步和异步行为
- en: If `done` isn’t included as an argument to `it`, then Mocha will run the test
    synchronously. Internally, Mocha looks at the `length` property of the callback
    you pass to `it` to see if an argument has been included. This is how it switches
    between asynchronous and synchronous behavior. If you include an argument, then
    Mocha will wait around for `done` to be called until a timeout is reached.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有将 `done` 作为参数传递给 `it`，那么 Mocha 将同步运行测试。内部，Mocha 会查看传递给 `it` 的回调函数的 `length`
    属性，以确定是否包含参数。这就是它在异步和同步行为之间切换的方式。如果你包含一个参数，那么 Mocha 将等待 `done` 被调用，直到达到超时时间。
- en: '|  |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'This module defines two methods: one for squaring numbers ![](1.jpg) and another
    that runs a callback after a random amount of time ![](2.jpg). It’s just enough
    to demonstrate Mocha’s main features in [listing 10.9](#ch10ex09).'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块定义了两种方法：一种用于平方数字 ![1.jpg](1.jpg) 和另一种在随机时间后运行回调 ![2.jpg](2.jpg)。这足以展示 Mocha
    的主要功能，如 [列表 10.9](#ch10ex09) 所示。
- en: To set up a project for Mocha, the index.js file we’ve used in this example
    should be in its own directory, and at the same level should be a package.json
    file with a `test` subproperty of the `scripts` property set to `"./node_modules/mocha/bin/mocha
    test/*.js"`. There should also be a test/directory that contains `example_test.js`.^([[3](#ch10fn03)])
    With all that in place, you can run the tests with `npm test`.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Mocha 设置项目，我们在这个例子中使用的 index.js 文件应该在其自己的目录中，并且在同一级别应该有一个 package.json 文件，其中
    `scripts` 属性的 `test` 子属性设置为 `"./node_modules/mocha/bin/mocha test/*.js"`。还应该有一个包含
    `example_test.js` 的 test/directory。^([[3](#ch10fn03)]) 在所有这些就绪后，你可以使用 `npm test`
    运行测试。
- en: ³ The file can be called anything as long as it’s in the test/directory.
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 文件可以命名为任何名称，只要它在 test/directory 目录下。
- en: 'When the tests are run, you should notice some dots appearing. These mark a
    completed test case. When the tests take more than a preset amount of time, they’ll
    change color to denote they ran slower than is acceptable. Since `index.randomTimeout`
    prevents the second test from completing for a random amount of time, there will
    be times when Mocha thinks the tests are running too slowly. You can increase
    this threshold by passing `--slow` to Mocha, like this: `./node_modules/mocha/bin/mocha
    --slow 2000 test/*.js`. Now you don’t need to feel guilty about seemingly slow
    tests!'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，你应该注意到一些点出现。这些标记着一个完成的测试用例。当测试用时超过预设的时间时，它们会改变颜色，表示运行速度比可接受的速度慢。由于 `index.randomTimeout`
    防止第二个测试随机时间完成，因此有时 Mocha 会认为测试运行得太慢。你可以通过将 `--slow` 传递给 Mocha 来增加这个阈值，如下所示：`./node_modules/mocha/bin/mocha
    --slow 2000 test/*.js`。现在你不必为看似缓慢的测试感到内疚了！
- en: '|  |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Assertions per test**'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个测试的断言**'
- en: In [listing 10.9](#ch10ex09), each test case has a single assertion. Some consider
    this best practice—and it can result in readable tests.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 10.9](#ch10ex09) 中，每个测试用例只有一个断言。有些人认为这是最佳实践——它可以导致可读性强的测试。
- en: But we prefer the idea of a single concept per test. This style structures test
    cases around well-defined concepts, using the absolute necessary amount of assertions.
    This will typically be a small number, but occasionally more than one.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们更喜欢每个测试一个概念的思路。这种风格将测试用例构建在定义良好的概念周围，使用绝对必要的断言数量。这通常是一个小数字，但偶尔也可能超过一个。
- en: '|  |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To see all of the command-line options, type `node_modules/mocha/bin/mocha --help`
    or visit [http://mochajs.org/](http://mochajs.org/).
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有命令行选项，请输入 `node_modules/mocha/bin/mocha --help` 或访问 [http://mochajs.org/](http://mochajs.org/)。
- en: We’ve included the final package.json file in [listing 10.11](#ch10ex11) in
    case you have trouble writing your own. You can install Mocha and its dependencies
    with `npm install`.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [列表 10.11](#ch10ex11) 中包含了最终的 package.json 文件，以防你自己在编写时遇到困难。你可以使用 `npm install`
    安装 Mocha 及其依赖项。
- en: Listing 10.11\. The Mocha sample project’s JSON file
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. Mocha 示例项目的 JSON 文件
- en: '[PRE10]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this technique the `assert` core module has been used, but you could swap
    it for another assertion library if you prefer. Others are available, like chai
    ([https://npmjs.org/package/chai](https://npmjs.org/package/chai)) and should.js
    ([https://github.com/visionmedia/should.js](https://github.com/visionmedia/should.js)).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧中使用了 `assert` 核心模块，但如果你愿意，可以将其替换为另一个断言库。其他库也可用，如 chai ([https://npmjs.org/package/chai](https://npmjs.org/package/chai))
    和 should.js ([https://github.com/visionmedia/should.js](https://github.com/visionmedia/should.js))。
- en: Mocha is often used for testing web applications. In the next technique, you’ll
    see how to use Mocha for testing web applications written with Node.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 通常用于测试 Web 应用程序。在下一个技巧中，你将看到如何使用 Mocha 测试使用 Node 编写的 Web 应用程序。
- en: Technique 84 Testing web applications with Mocha
  id: totrans-819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 84 使用 Mocha 测试 Web 应用程序
- en: Let’s suppose you’re building a web application with Node. You’d like to test
    it by running it in a way that allows you to send requests and receive responses—you
    want to make HTTP requests to test the web application works as expected.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用 Node 构建一个 Web 应用程序。你希望以允许你发送请求并接收响应的方式运行它——你想要发送 HTTP 请求来测试 Web 应用程序是否按预期工作。
- en: Problem
  id: totrans-821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re building a web application and would like to test it with Mocha.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建一个 Web 应用程序，并希望使用 Mocha 来测试它。
- en: Solution
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write tests with Mocha and the standard `http` module. Consider using an HTTP
    module designed for testing to simplify your code.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Mocha 和标准 `http` 模块编写测试。考虑使用专为测试设计的 HTTP 模块来简化你的代码。
- en: Discussion
  id: totrans-825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The trick to understanding web application testing in Node is to learn to think
    in terms of HTTP. This technique starts off with a Mocha test and the `http` core
    module. Once you understand the principles at work and can write tests this way,
    we’ll introduce a third-party HTTP testing module to demonstrate how to simplify
    such tests. The built-in `http` module is demonstrated first because it’s useful
    to see what goes on behind the scenes and to get a handle on exactly how to construct
    such tests.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Node 中的 Web 应用程序测试，关键是学会从 HTTP 的角度思考。这种技术从 Mocha 测试和 `http` 核心模块开始。一旦你理解了其中的原理并能以这种方式编写测试，我们将介绍一个第三方
    HTTP 测试模块来演示如何简化此类测试。首先演示内置的 `http` 模块，因为它有助于了解幕后发生的事情，并确切了解如何构建此类测试。
- en: The following listing shows what the test looks like.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了测试的外观。
- en: Listing 10.12\. A Mocha test for a web application
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. 一个 Mocha 测试用例的 Web 应用程序
- en: '![](ch10ex12-0.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex12-0.jpg)'
- en: '![](ch10ex12-1.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex12-1.jpg)'
- en: This example is a test for a web service that can square numbers. It’s a simple
    web service that expects `GET` requests and responds with plain text. The goal
    of this test suite is to ensure that it returns the expected results and correctly
    raises errors when invalid data is sent. The tests aim to simulate browsers—or
    other HTTP clients, for that matter—and to do so, both the server and client are
    run in the same process.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是对一个可以平方数字的 Web 服务的测试。这是一个简单的 Web 服务，它期望 `GET` 请求并以纯文本响应。这个测试套件的目标是确保它返回预期的结果，并在发送无效数据时正确地引发错误。测试旨在模拟浏览器——或者更确切地说，其他
    HTTP 客户端——为此，服务器和客户端都在同一个进程中运行。
- en: To run a web service, all you need to do is create a web server with `http.create-Server()`.
    Exactly how this is done is shown in [listing 10.13](#ch10ex13). Before discussing
    that, let’s finish looking at this test.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个 Web 服务，你所需要做的就是使用 `http.create-Server()` 创建一个 Web 服务器。具体如何做在 [列表 10.13](#ch10ex13)
    中有展示。在讨论那之前，让我们先完成对这个测试的查看。
- en: The test starts by creating a function for making HTTP requests ![](1.jpg).
    This is to reduce the amount of duplication that would otherwise be present in
    the test cases. This function could be its own module, which could be used in
    other test files. After a request has been sent, it listens for `data` events
    on the response object to store any data returned by the server ![](2.jpg). Then
    it runs the provided callback ![](3.jpg), which is passed in from the test cases.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 测试首先通过创建一个用于发送 HTTP 请求的函数 ![](1.jpg) 来开始。这是为了减少测试用例中可能存在的重复。这个函数可以是它自己的模块，可以在其他测试文件中使用。在发送请求后，它监听响应对象上的
    `data` 事件以存储服务器返回的任何数据 ![](2.jpg)。然后它运行提供的回调 ![](3.jpg)，该回调是从测试用例中传递进来的。
- en: '[Figure 10.1](#ch10fig01) shows how Node can run both servers and clients in
    the same process to make web application testing possible.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.1](#ch10fig01) 展示了 Node 如何在同一个进程中运行服务器和客户端，以使 Web 应用程序测试成为可能。'
- en: Figure 10.1\. Node can run a web server and requests against it to support web
    application testing.
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. Node 可以运行一个 Web 服务器并对它进行请求，以支持 Web 应用程序测试。
- en: '![](10fig01_alt.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig01_alt.jpg)'
- en: An example of this is the test for the `/square` method that ensures `4 * 4
    === 16` ![](4.jpg). Once that’s done, we also make sure invalid HTTP query parameters
    cause the server to respond with a 500 error ![](5.jpg).
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个例子是对 `/square` 方法的测试，确保 `4 * 4 === 16` ![](4.jpg)。一旦完成，我们也确保无效的 HTTP 查询参数会导致服务器响应
    500 错误 ![](5.jpg)。
- en: The standard assertion module is used throughout, and `res.statusCode` is used
    to test the expected status codes are returned.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中使用了标准的断言模块，并使用 `res.statusCode` 来测试返回预期的状态码。
- en: The implementation of the corresponding web service is shown in the next listing.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了相应 Web 服务的实现。
- en: Listing 10.13\. A web application that can square numbers
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 一个可以平方数字的 Web 应用程序
- en: '![](278fig01_alt.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![](278fig01_alt.jpg)'
- en: Before doing anything else, `http.createServer` is used to create a server.
    Near the end of the file, `.listen(8000)` is used to make the server start up
    and listen for connections. Whenever a request with a URL matching/square comes
    in, the URL is parsed for a numerical parameter ![](1.jpg) and then the number
    is squared and sent to the client ![](2.jpg). When the expected parameter isn’t
    present, a 500 is returned instead ![](3.jpg).
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何其他事情之前，使用`http.createServer`创建一个服务器。在文件末尾附近，使用`.listen(8000)`使服务器启动并监听连接。每当收到与URL匹配/平方的请求时，就会解析URL以获取一个数值参数
    ![1.jpg](1.jpg) ，然后将该数字平方并发送给客户端 ![2.jpg](2.jpg) 。当预期的参数不存在时，将返回500 ![3.jpg](3.jpg)
    。
- en: One part of [listing 10.12](#ch10ex12) that can be improved on is the `request`
    method. Rather than defining a wrapper around `http.request`, we can use a library
    designed specifically for testing with web requests.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.12](#ch10ex12)中可以改进的部分是`request`方法。我们不是围绕`http.request`定义包装器，而是可以使用专门为测试Web请求而设计的库。'
- en: The module we’ve chosen is `SuperTest` ([https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest))
    by TJ Holowaychuk, who also wrote Mocha. There are other similar libraries out
    there. The general idea is to simplify HTTP requests and allow assertions to be
    made about the request.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的模块是TJ Holowaychuk编写的`SuperTest` ([https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest))，他也是Mocha的作者。还有其他类似的库。一般思路是简化HTTP请求并允许对请求进行断言。
- en: You can add SuperTest to the development dependencies for this example by running
    `npm install --save-dev supertest`.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`npm install --save-dev supertest`将SuperTest添加到这个示例的开发依赖项中。
- en: The following listing shows how the test can be refactored using the `SuperTest`
    module.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用`SuperTest`模块重构测试。
- en: Listing 10.14\. The refactored Mocha test that uses SuperTest
  id: totrans-847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14。使用SuperTest重构的Mocha测试
- en: '![](279fig01_alt.jpg)'
  id: totrans-848
  prefs: []
  type: TYPE_IMG
  zh: '![279fig01_alt.jpg](279fig01_alt.jpg)'
- en: Although functionally identical to [listing 10.12](#ch10ex12), this example
    improves it by removing the boilerplate for making HTTP requests. The `SuperTest`
    module is easier to understand, and allows assertions to be expressed with less
    code while still being asynchronous. `SuperTest` expects an instance of an HTTP
    server ![](1.jpg), which in this case is the application that we want to test.
    Once the application has been passed to `SuperTest`’s main function, `request`,
    we can then make a `GET` request using `request().get`. Other HTTP verbs are also
    supported, and form parameters can be sent when using `post()` with the `send`
    method.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在功能上与[列表10.12](#ch10ex12)相同，但这个例子通过移除创建HTTP请求的样板代码来改进它。`SuperTest`模块更容易理解，并且允许用更少的代码表达断言，同时仍然保持异步。`SuperTest`期望一个HTTP服务器的实例
    ![1.jpg](1.jpg) ，在这种情况下是我们想要测试的应用程序。一旦应用程序被传递给`SuperTest`的主要函数`request`，我们就可以使用`request().get`来发出`GET`请求。其他HTTP动词也得到支持，并且在使用`post()`与`send`方法时可以发送表单参数。
- en: '`SuperTest`’s methods are chainable, so once a request has been made, we can
    make an assertion by using `expect`. This method is polymorphic—it checks the
    type of the argument and acts accordingly. If you pass it a number ![](2.jpg),
    it’ll ensure that the HTTP status was that number. A regular expression will make
    it check the response body for a match ![](3.jpg). These expectations are perfect
    for the requirements of this test.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuperTest`的方法是可链式的，因此一旦发出请求，我们就可以使用`expect`来做出断言。此方法是多态的——它检查参数的类型并根据情况行事。如果你传递一个数字
    ![2.jpg](2.jpg) ，它将确保HTTP状态是那个数字。正则表达式将使其检查响应体是否匹配 ![3.jpg](3.jpg) 。这些期望非常适合这个测试的要求。'
- en: Any HTTP status can be checked, so when we actually expect a 500, we can test
    for it ![](4.jpg).
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检查任何HTTP状态，因此当我们实际期望一个500时，我们可以测试它 ![4.jpg](4.jpg) 。
- en: Though it’s useful to understand how to make simple web applications and test
    them using the built-in `http` module, we hope you can see how third-party modules
    like `SuperTest` can simplify your code and make your tests clearer.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解如何制作简单的Web应用程序并使用内置的`http`模块进行测试很有用，但我们希望你能看到第三方模块如`SuperTest`如何简化你的代码并使你的测试更清晰。
- en: Mocha captures the zeitgeist of the current state of testing in Node, but there
    are other approaches that are just as valid. The next technique introduces TAP
    and the Test Anything Protocol, due to its endorsement by Node’s maintainer and
    core contributors.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha捕捉了当前Node测试状态的潮流，但还有其他同样有效的方法。接下来的技术介绍了TAP和Test Anything Protocol，由于Node的维护者和核心贡献者的支持。
- en: Technique 85 The Test Anything Protocol
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧85：Test Anything Protocol
- en: Test harness output varies based on programming language and test framework.
    There are initiatives to unify these reports. One such effort that has been adopted
    by the Node community is the Test Anything Protocol ([http://testanything.org](http://testanything.org)).
    Tests that use TAP will produce lightweight streams of results that can be consumed
    by compatible tools.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架输出根据编程语言和测试框架而异。有一些努力旨在统一这些报告。Node 社区采纳的一个这样的努力是 Test Anything Protocol
    ([http://testanything.org](http://testanything.org))。使用 TAP 的测试将产生轻量级的流式结果，这些结果可以被兼容的工具消费。
- en: Suppose you need a test harness that’s compatible with the Test Anything Protocol,
    either because you have other tools that use TAP, or because you’re already familiar
    with it from other languages. It could be that you don’t like Mocha’s API and
    want an alternative, or are interested in learning about other solutions to testing
    in Node.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个与 Test Anything Protocol 兼容的测试框架，这可能是因为你有使用 TAP 的其他工具，或者因为你已经从其他语言中熟悉了它。可能是因为你不喜欢
    Mocha 的 API，想要一个替代方案，或者对 Node 中测试的其他解决方案感兴趣。
- en: Problem
  id: totrans-857
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use a test framework that’s designed to interoperate with other
    systems.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用一个旨在与其他系统互操作性的测试框架。
- en: Solution
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Isaac Z. Schlueter’s `tap` module.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Isaac Z. Schlueter 的 `tap` 模块。
- en: Discussion
  id: totrans-861
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: TAP is unique because it aims to bridge test frameworks and tools by specifying
    a protocol that implementors can use. The protocol is stream-based, lightweight,
    and human-readable. In comparison to other, heavier XML-based standards, TAP is
    easy to implement and use.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: TAP 是独特的，因为它旨在通过指定实现者可以使用的协议来连接测试框架和工具。该协议是基于流的，轻量级且可读。与其他基于 XML 的更重的标准相比，TAP
    实现和使用都很容易。
- en: It’s significant that the `tap` module ([https://npmjs.org/package/tap](https://npmjs.org/package/tap))
    is written by Node’s former maintainer, Isaac Z. Schlueter. This is an important
    seal of approval by someone highly influential in the Node community.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，`tap` 模块 ([https://npmjs.org/package/tap](https://npmjs.org/package/tap))
    是由 Node 的前维护者 Isaac Z. Schlueter 编写的。这是 Node 社区中一位极具影响力的人的重要认可。
- en: The example in this technique uses the number squaring and random timeout module
    used in [technique 83](#ch10lev2sec5) so you can compare how tests look in TAP
    and Mocha.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 本技术示例使用 [技术 83](#ch10lev2sec5) 中使用的数字平方和随机超时模块，这样你可以比较 TAP 和 Mocha 中测试的外观。
- en: The following listing shows what the test looks like. For the corresponding
    module, see [listing 10.10](#ch10ex10).
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了测试的外观。对于相应的模块，请参阅 [列表 10.10](#ch10ex10)。
- en: Listing 10.15\. Testing with TAP
  id: totrans-866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 使用 TAP 进行测试
- en: '![](280fig01_alt.jpg)'
  id: totrans-867
  prefs: []
  type: TYPE_IMG
  zh: '![280fig01_alt.jpg](280fig01_alt.jpg)'
- en: 'This is different from the Mocha example because it doesn’t assume there are
    any global test-related methods like `it` and `describe`: a reference to `tap.test`
    has to be set up ![](1.jpg) before doing anything else. Tests are then defined
    with the `t.test()` method ![](2.jpg), and can be nested if needed. Nesting allows
    related concerns to be grouped, so in this case we’ve created a test case for
    each method being tested.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Mocha 示例不同，因为它不假设存在任何全局测试相关方法，如 `it` 和 `describe`：在执行任何其他操作之前，必须设置对 `tap.test`
    的引用 ![1.jpg](1.jpg)。然后使用 `t.test()` 方法 ![2.jpg](2.jpg) 定义测试，如果需要可以嵌套。嵌套允许将相关关注点分组，因此在这种情况下，我们为每个要测试的方法创建了一个测试用例。
- en: The `tap` module has built-in assertions, and we’ve used these throughout the
    test file ![](3.jpg). Once a test case has finished, `t.end()` must be called
    ![](4.jpg). That’s because the `tap` module assumes tests are asynchronous, so
    `t.end()` could be called inside an asynchronous callback.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: '`tap` 模块内置了断言，我们在整个测试文件中使用了这些断言 ![3.jpg](3.jpg)。一旦测试用例完成，必须调用 `t.end()` ![4.jpg](4.jpg)。这是因为
    `tap` 模块假设测试是异步的，所以 `t.end()` 可以在异步回调中调用。'
- en: Another approach is to use `t.plan` ![](5.jpg). This method indicates that `n`
    assertions are expected. Once the last assertion has been called, the test case
    will finish running. Unlike the previous test case, the second one can leave off
    the call to `t.end()` ![](6.jpg).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `t.plan` ![5.jpg](5.jpg)。此方法表示预期有 `n` 个断言。一旦最后一个断言被调用，测试用例将完成运行。与上一个测试用例不同，第二个测试用例可以省略对
    `t.end()` 的调用 ![6.jpg](6.jpg)。
- en: This test can be run with `./node_modules/tap/bin/tap.js test/*_test.js`. You
    can add this line to the `test` property of `scripts` in the package.json file
    to make it run with `npm test`.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试可以使用 `./node_modules/tap/bin/tap.js test/*_test.js` 运行。你可以将此行添加到 package.json
    文件中 `scripts` 属性的 `test`，以便使用 `npm test` 运行。
- en: If you run the test with the `tap` script, you’ll see some clean output that
    consolidates the results of each assertion. This is generated by one of `tap`’s
    submodules called `tap-results`. The purpose of the `tap-results` module is to
    collect lines from a TAP stream and count up skips, passes, and fails to generate
    a simplified report;
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`tap`脚本运行测试，你会看到一些干净的输出，这些输出汇总了每个断言的结果。这是由`tap`的一个子模块`tap-results`生成的。`tap-results`模块的目的是从TAP流中收集行，并计算跳过、通过和失败的数量，以生成一个简化的报告；
- en: '[PRE11]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Due to the design of the `tap` module, you’re free to run the tests with `node
    test/index_test.js`. This will print out the TAP stream instead:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`tap`模块的设计，你可以自由地使用`node test/index_test.js`来运行测试。这将打印出TAP流而不是：
- en: '[PRE12]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tests written with the `tap` module will still return a non-zero exit code to
    the shell when tests fail—you can use `echo $?` to see the exit code. Try making
    the test in [listing 10.15](#ch10ex15) fail on purpose and take a look at `$?`.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tap`模块编写的测试在测试失败时仍会向shell返回非零退出代码——你可以使用`echo $?`来查看退出代码。尝试使[列表10.15](#ch10ex15)中的测试故意失败并查看`$?`。
- en: The fact that TAP is designed around producing and consuming streams fits in
    well with Node’s design. It’s also a fact of life that tests must interact with
    other automated systems in most projects, whether it’s a deployment system or
    a CI server. Working with this protocol is easier than heavyweight XML standards,
    so hopefully it will rise in popularity.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: TAP的设计围绕生成和消费流与Node的设计非常契合。在大多数项目中，测试必须与其他自动化系统交互，无论是部署系统还是CI服务器，这也是生活的一个事实。与这个协议一起工作比与重量级的XML标准一起工作要容易得多，所以希望它会越来越受欢迎。
- en: '[Figure 10.2](#ch10fig02) illustrates how some of `node-tap`’s submodules are
    used to test a program. Control is transferred from different modules, to your
    tests, back to your program, and then out through the reporter, which collects
    and analyzes results. The key thing to realize about this is that `node-tap`’s
    submodules can be reused and replaced—if you don’t like the way results are displayed
    with `tap-results`, it could be replaced with something else.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.2](#ch10fig02)说明了`node-tap`的一些子模块是如何用来测试程序的。控制从不同的模块转移到你的测试，然后回到你的程序，再通过报告器输出，报告器收集并分析结果。关于这一点，关键要认识到`node-tap`的子模块是可以重用和替换的——如果你不喜欢`tap-results`显示结果的方式，它可以被替换成其他东西。'
- en: Figure 10.2\. `node-tap` uses several reusable submodules to orchestrate tests.
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. `node-tap`使用几个可重用的子模块来协调测试。
- en: '![](10fig02_alt.jpg)'
  id: totrans-880
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02_alt.jpg)'
- en: Beyond test frameworks, real-world testing depends on several more important
    tools and techniques. The next section shows you how to use continuous integration
    servers and database fixtures, and how to mock I/O.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试框架之外，现实世界的测试还依赖于几个更重要的工具和技术。下一节将向你展示如何使用持续集成服务器和数据库固定值，以及如何模拟I/O。
- en: 10.5\. Tools for tests
  id: totrans-882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5. 测试工具
- en: When you’re working in a team, you want to quickly see when someone has committed
    changes that break the tests. This section will help you to set up a continuous
    integration server so you can do this. It also has techniques for other project-related
    issues like using databases with tests and mocking web services.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在团队中工作时，你希望快速看到有人提交了破坏测试的更改。本节将帮助你设置持续集成服务器，以便你可以这样做。它还包括其他与项目相关的问题的技术，如使用测试数据库和模拟Web服务。
- en: Technique 86 Continuous integration
  id: totrans-884
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧86 持续集成
- en: Your tests are running, but what happens when someone makes a change that breaks
    the project? Continuous integration (CI) servers are used to automatically run
    tests. Because most test harnesses return a non-zero exit code on failure, they’re
    conceptually simple enough. Their real value comes becomes apparent when they
    can easily be hooked up to services like GitHub and send out emails or instant
    messages to team members when tests fail.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试正在运行，但如果有人的更改导致项目崩溃会发生什么呢？持续集成（CI）服务器用于自动运行测试。由于大多数测试工具在失败时返回非零退出代码，它们在概念上足够简单。它们的真正价值在于它们可以轻松地连接到像GitHub这样的服务，并在测试失败时向团队成员发送电子邮件或即时消息。
- en: Problem
  id: totrans-886
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to see when members of a team commit broken code so you don’t accidentally
    release it.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 你想看到团队成员提交了有问题的代码，这样你就不会不小心发布它。
- en: Solution
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a continuous integration server.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持续集成服务器。
- en: Discussion
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: You’re working in a team and want to see when tests start to fail. You’re already
    using a version control system like Git, and want to run tests whenever code is
    committed to a tracked repository. Or you’ve written an open source project and
    want to indicate on the GitHub or Bitbucket page that it’s well tested.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 你在一个团队中工作，并想查看测试何时开始失败。你已经使用了一个版本控制系统，如 Git，并希望在代码提交到受跟踪的仓库时运行测试。或者，你已经编写了一个开源项目，并想在
    GitHub 或 Bitbucket 页面上表明它经过了良好的测试。
- en: There are many popular open source and proprietary continuous integration services.
    In this technique we’ll look at Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    because it’s free for open source projects and popular in the Node community.
    If you want an open source CI server that you can install locally, take a look
    at Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/)).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的开源和专有持续集成服务。在这个技术中，我们将查看 Travis CI ([https://travis-ci.org/](https://travis-ci.org/))，因为它对开源项目是免费的，并且在
    Node 社区中很受欢迎。如果你想安装本地的开源 CI 服务器，可以看看 Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/))。
- en: Travis CI provides a link to an image that shows your project’s build status.
    To add a project, sign in with your GitHub account at travis-ci.org, and then
    go to the profile page at travis-ci.org/profile. You’ll see a list of your GitHub
    projects, and toggling a switch to On will cause the repository to be updated
    with a service hook that will notify Travis CI whenever you push an update to
    GitHub.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI 提供了一个链接到显示你的项目构建状态的图片。要添加项目，在 travis-ci.org 使用你的 GitHub 账户登录，然后转到
    travis-ci.org/profile 中的个人资料页面。你会看到一个 GitHub 项目的列表，将开关切换到开启状态将导致仓库通过一个服务钩子更新，该钩子会在你向
    GitHub 推送更新时通知 Travis CI。
- en: Once you’ve done that, you need to add a .travis.yml file to the repository
    to tell Travis CI about the environment your code depends on. All you need to
    do is set the Node version.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，你需要在仓库中添加一个 .travis.yml 文件，以告诉 Travis CI 代码所依赖的环境。你只需要设置 Node 版本。
- en: 'Let’s work through a full example and set up a project on Travis so you can
    see how it works. You’ll need three files: a package.json, a file to test, and
    the .travis.yml file. The following listing shows the file we’ll be testing.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个完整的示例，并在 Travis 上设置一个项目，以便你可以看到它是如何工作的。你需要三个文件：一个 package.json 文件，一个测试文件，以及
    .travis.yml 文件。下面的列表显示了我们将要测试的文件。
- en: Listing 10.16\. A simple test to try with Travis CI
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.16\. 一个简单的测试，用于尝试使用 Travis CI
- en: '![](283fig01.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![283fig01.jpg](283fig01.jpg)'
- en: This is just a simple test ![](1.jpg) that we can play with to see what Travis
    CI does. After running, it should result in an exit code of zero—type `node test.js`
    and then `echo $?` to see the exit code. Put this file in a new directory so you
    can set up a Git repository for it later. Before that we’ll need to create a package.json
    file. The next listing is a simple package.json that allows the tests to be run
    with `npm test`.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的测试 ![1.jpg](1.jpg)，我们可以用它来查看 Travis CI 能做什么。运行后，它应该得到一个退出代码为零的结果——输入
    `node test.js` 然后输入 `echo $?` 来查看退出代码。将此文件放在一个新目录中，这样你就可以稍后为它设置 Git 仓库。在那之前，我们需要创建一个
    package.json 文件。下面的列表是一个简单的 package.json，允许使用 `npm test` 运行测试。
- en: Listing 10.17\. A basic package.json file
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17\. 一个基本的 package.json 文件
- en: '[PRE13]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, you’ll need a .travis.yml file. It doesn’t need to do much other than
    tell Travis CI that you’re using Node.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一个 .travis.yml 文件。它不需要做太多，只需告诉 Travis CI 你正在使用 Node。
- en: Listing 10.18\. Travis CI configuration
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18\. Travis CI 配置
- en: '[PRE14]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now go to GitHub.com and sign in; then click New Repository to create a public
    repository. We’ve called ours `travis-example` so people know it’s purely educational.
    Follow the instructions on how to commit and push the project to GitHub—you’ll
    need to run `git init` in the directory where you placed the preceding three code
    files, and then `git add .` and `git commit -m 'Initial commit'`. Then use `git
    remote add <url>` with the repository URL GitHub gives you, and push it with `git
    push -u origin master`.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 GitHub.com 并登录；然后点击新建仓库以创建一个公共仓库。我们将其命名为 `travis-example`，这样人们就知道它纯粹是教育性的。遵循如何提交和推送项目到
    GitHub 的说明——你需要在放置前面三个代码文件的目录中运行 `git init`，然后运行 `git add .` 和 `git commit -m
    'Initial commit'`。然后使用 `git remote add <url>` 与 GitHub 给你的仓库 URL，并使用 `git push
    -u origin master` 推送。
- en: Go to your profile at travis-ci.org/profile and toggle your new project to On.
    You might need to tell Travis CI to sync your project list—there’s a button near
    the top of the page.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 travis-ci.org/profile 中的你的个人资料，并将你的新项目切换到开启状态。你可能需要告诉 Travis CI 同步你的项目列表——页面顶部附近有一个按钮。
- en: There’s one last step before you can see any tests running on Travis CI. Make
    a single change in test.js—add another assertion if you like, and then commit
    and `git push` the change. This will cause GitHub to send an API request to Travis
    CI that will cause your tests to be run.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以在 Travis CI 上看到任何测试运行之前，还有最后一步。在 test.js 中进行单个更改——如果你喜欢，可以添加另一个断言，然后提交并
    `git push` 修改。这将导致 GitHub 向 Travis CI 发送 API 请求，从而运行你的测试。
- en: Travis CI knows how to run Node tests—it defaults to `npm test`. If you’re adapting
    this technique to an existing project and you use another command (perhaps `make
    test`), then you can change what Travis CI runs by setting the `script` value
    in the YML file. Documentation can be found under “Configuring your build” in
    the documentation ([http://about.travis-ci.org/docs/user/build-configuration/#script](http://about.travis-ci.org/docs/user/build-configuration/#script)).
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI 知道如何运行 Node 测试——默认为 `npm test`。如果你将此技术应用于现有项目并且使用其他命令（例如 `make test`），则可以通过在
    YML 文件中设置 `script` 值来更改 Travis CI 运行的命令。有关文档，请参阅“配置你的构建”部分（[http://about.travis-ci.org/docs/user/build-configuration/#script](http://about.travis-ci.org/docs/user/build-configuration/#script)）。
- en: If you go to the homepage at Travis CI, you should now see a console log with
    details on how the tests were run. [Figure 10.3](#ch10fig03) shows what successful
    tests look like.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 Travis CI 的主页，你现在应该看到一个包含测试运行详细信息的控制台日志。[图 10.3](#ch10fig03) 展示了成功的测试看起来是什么样子。
- en: Figure 10.3\. Travis CI running tests
  id: totrans-909
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. Travis CI 运行测试
- en: '![](10fig03_alt.jpg)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig03_alt.jpg)'
- en: Now that you have tests running successfully, you should edit test.js to make
    the tests fail to see what happens.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功运行了测试，你应该编辑 test.js 以使测试失败，以查看会发生什么。
- en: Travis can be configured to use most of the things you expect when running tests
    in real-world projects—databases and other services can be added ([http://about.travis-ci.org/docs/user/database-setup/](http://about.travis-ci.org/docs/user/database-setup/)),
    and even virtual machines.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: Travis 可以配置为使用你在现实世界项目中运行测试时预期的大多数东西——可以添加数据库和其他服务（[http://about.travis-ci.org/docs/user/database-setup/](http://about.travis-ci.org/docs/user/database-setup/)），甚至虚拟机。
- en: Getting a database configured with suitable fixtures for your projects is one
    of the most important parts of testing. The next technique shows how to set up
    databases for your tests.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目配置具有合适固定数据的数据库是测试最重要的部分之一。下一个技巧将展示如何为你的测试设置数据库。
- en: Technique 87 Database fixtures
  id: totrans-914
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 87 数据库固定数据
- en: 'Most applications need to persist data in some way, and it’s important to test
    that data is stored correctly. This technique explores three solutions for handling
    database fixtures in Node: loading database dumps, creating data during tests,
    and using mocks.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要以某种方式持久化数据，并且测试数据是否正确存储非常重要。此技术探讨了在 Node 中处理数据库固定数据的三个解决方案：加载数据库转储、在测试期间创建数据和使用模拟。
- en: Problem
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to test code that stores data in a database, or performs some other
    kind of I/O like sending data over a network. You don’t want to access this I/O
    resource during testing, or you have test data that you want to preload before
    tests. Either way, your application is highly dependent on an I/O service, and
    you want to carefully test how your code interacts with it.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要测试存储在数据库中的代码，或者执行某些其他类型的 I/O，例如通过网络发送数据。你不想在测试期间访问此 I/O 资源，或者你希望在测试之前预载数据。无论如何，你的应用程序高度依赖于
    I/O 服务，并且你希望仔细测试你的代码如何与之交互。
- en: Solution
  id: totrans-918
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Preload data before the tests, or mock the I/O layer.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前预载数据，或者模拟 I/O 层。
- en: Discussion
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The mark of well-written code is how testable it is. Code that performs I/O
    instinctively feels hard to test, but it shouldn’t be if the APIs are cleanly
    decoupled.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编写得好不好，看它是否易于测试。执行 I/O 的代码本能地感觉难以测试，但如果 API 清晰解耦，则不应该如此。
- en: For example, if your code performs HTTP requests, then as you’ve seen in previous
    techniques, you can run a customized HTTP server within your tests to simulate
    a remote service. This is known as *mocking*. But sometimes you don’t want to
    mock I/O. You may wish to write tests that result in changes being made against
    a real database, albeit an instance of the database that tests can safely destroy
    and re-create. These types of tests are known as *integration tests*—they “integrate”
    disparate layers of software to deeply test behavior.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的代码执行HTTP请求，那么正如你在之前的技巧中看到的，你可以在测试中运行一个定制的HTTP服务器来模拟远程服务。这被称为*模拟*。但有时你不想模拟I/O。你可能希望编写测试，以便对真实数据库进行更改，尽管是一个测试可以安全地销毁和重新创建的数据库实例。这类测试被称为*集成测试*——它们“集成”不同的软件层以深入测试行为。
- en: 'This technique presents two ways to handle database fixtures for integration
    tests; then we’ll broaden the scope by demonstrating how to use mocks. First up:
    preloading data using database dumps.'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了两种处理集成测试数据库数据的方法；然后我们将通过演示如何使用模拟来扩大范围。首先：使用数据库转储预加载数据。
- en: Database dumps
  id: totrans-924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据库转储
- en: Using database dumps is the sledgehammer of database fixture techniques. All
    you need is to be able to run some code before all of your other tests so you
    can clear out a database and drop in a pristine copy. If this test data is dumped
    from a database, then you can use your existing database tools for preparing and
    exporting the data.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库转储是数据库数据固定技术中的重型工具。你所需要的是在所有其他测试之前能够运行一些代码，以便清除数据库并插入一个原始副本。如果这些测试数据是从数据库转储的，那么你可以使用现有的数据库工具来准备和导出数据。
- en: '[Listing 10.19](#ch10ex19) uses Mocha and MySQL, but you could adapt the same
    principles to work with other databases and test frameworks. See [technique 83](#ch10lev2sec5)
    for more on Mocha.'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.19](#ch10ex19)使用Mocha和MySQL，但你可以将相同的原理应用于其他数据库和测试框架。有关Mocha的更多信息，请参阅[技巧83](#ch10lev2sec5)。'
- en: Listing 10.19\. The `assert` module
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.19\. `assert`模块
- en: '![](ch10ex19-0.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex19-0.jpg)'
- en: '![](ch10ex19-1.jpg)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex19-1.jpg)'
- en: The basic principle of this example is to run a database import before the other
    tests. If you use this approach with your own tests, make sure the import wipes
    the database first. Relational databases can do this with `DROP TABLE IF EXISTS`,
    for example.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的基本原理是在其他测试之前运行数据库导入。如果你在自己的测试中使用这种方法，请确保导入首先清除数据库。关系型数据库可以使用`DROP TABLE
    IF EXISTS`等命令来完成此操作。
- en: 'To actually run this test, you need to pass the filename to `mocha` before
    the other tests, and make sure the `test` environment is used. For example, if
    [listing 10.19](#ch10ex19) is called `test/init.js`, then you could run these
    commands in the shell: `NODE_ENV=test ./node_modules/.bin/mocha test/init.js test/**/*_test.js`.
    Or simply place the commands in your project’s package.json file under `scripts`,
    `test`.'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行此测试，需要在其他测试之前将文件名传递给`mocha`，并确保使用`test`环境。例如，如果[列表10.19](#ch10ex19)被命名为`test/init.js`，那么你可以在shell中运行以下命令：`NODE_ENV=test
    ./node_modules/.bin/mocha test/init.js test/**/*_test.js`。或者简单地将命令放在你的项目`package.json`文件下的`scripts`，`test`部分。
- en: The `ran` variable ![](1.jpg) is used to ensure the importer is only run once
    ![](6.jpg). Mocha’s `before` function is used ![](5.jpg) to run the importer once,
    but if `test/init.js` is accidentally loaded elsewhere (perhaps by running `mocha
    test/**/*.js`), then the import would happen twice.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ran`变量![图片](1.jpg)来确保导入器只运行一次![图片](6.jpg)。Mocha的`before`函数用于![图片](5.jpg)运行导入器一次，但如果`test/init.js`意外在其他地方加载（可能是因为运行`mocha
    test/**/*.js`），那么导入将会发生两次。
- en: To import the data, the `loadFixture` function is defined ![](2.jpg) and run
    in the `before` callback ![](8.jpg). It accepts a filename and a callback, so
    it’s easy to use asynchronously. An additional check is performed to make sure
    the import is only run in the `test` environment ![](7.jpg). The reasoning here
    is that the database settings would be set by the rest of the application based
    on `NODE_ENV`, and you wouldn’t want to lose data by overwriting your development
    or production databases with the test fixtures.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入数据，定义了`loadFixture`函数![图片](2.jpg)并在`before`回调中运行![图片](8.jpg)。它接受一个文件名和一个回调，因此使用起来非常方便，可以异步操作。此外，还会进行额外的检查以确保导入只在`test`环境中运行![图片](7.jpg)。这里的理由是数据库设置将由应用程序的其他部分根据`NODE_ENV`设置，你不想通过覆盖开发或生产数据库的测试数据来丢失数据。
- en: Finally, the shell command to import the data is built up ![](3.jpg) and run
    with `child_process` ![](4.jpg). This is database-dependent—we’ve used MySQL as
    an example, but a similar approach would work with MongoDB, PostgreSQL, or pretty
    much any database that has command-line tools.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，导入数据的shell命令是通过 ![](3.jpg) 构建起来的，并使用`child_process` ![](4.jpg) 运行。这取决于数据库——我们以MySQL为例，但类似的方法也可以与MongoDB、PostgreSQL或几乎任何具有命令行工具的数据库一起使用。
- en: 'Using dump files for fixtures has some benefits: you can author test data with
    your favorite database tool (we like Sequel Pro), and it’s easy to understand
    how it all works. If you change your database’s schema or the “model” classes
    that work with the data, then you’ll need to update your fixtures.'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转储文件作为固定数据有一些好处：您可以使用您喜欢的数据库工具（我们喜欢Sequel Pro）来编写测试数据，并且很容易理解它是如何工作的。如果您更改数据库的模式或与数据一起工作的“模型”类，那么您需要更新您的固定数据。
- en: Creating test data with your ORM
  id: totrans-936
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用您的ORM创建测试数据
- en: An alternative approach is to create data programmatically. This style requires
    setup code—run in `before` callbacks or the equivalent in your test framework—which
    creates database records using your model classes.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是程序化地创建数据。这种风格需要设置代码——在`before`回调或测试框架中的等效操作中运行——使用您的模型类创建数据库记录。
- en: The next listing shows how this works.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了它是如何工作的。
- en: Listing 10.20\. Preparing test data with an ORM
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.20\. 使用ORM准备测试数据
- en: '![](ch10ex20-0.jpg)'
  id: totrans-940
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex20-0.jpg)'
- en: '![](ch10ex20-1.jpg)'
  id: totrans-941
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex20-1.jpg)'
- en: This example can be run with Mocha, and although it doesn’t use a real database
    layer, the `User` class ![](1.jpg) fakes the kind of behavior you’re likely to
    see with a library for a relational database or even a NoSQL database. A `save`
    function is defined that has an asynchronous API ![](2.jpg) so the tests look
    close to a real-world test.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以使用Mocha运行，尽管它没有使用真实的数据库层，但`User`类 ![](1.jpg) 模拟了您可能会在关系数据库或甚至是NoSQL数据库的库中看到的行为。定义了一个具有异步API
    ![](2.jpg) 的`save`函数，以便测试看起来接近现实世界的测试。
- en: In the `describe` block that groups together each test case, a variable called
    `user` is defined ![](3.jpg). This will be used by some of the following test
    cases. It’s defined above their scope so they can all access it, but also because
    we want to persist it asynchronously in the `before` block. This runs prior to
    the test cases ![](4.jpg).
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在将每个测试用例组合在一起的`describe`块中，定义了一个名为`user`的变量 ![](3.jpg)。这将被以下一些测试用例使用。它在其作用域之上定义，以便它们都可以访问它，但也是因为我们希望在`before`块中异步持久化它。这会在测试用例之前运行
    ![](4.jpg)。
- en: Mocking the database
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模拟数据库
- en: The final approach that will be discussed in this technique is mocking the database
    API. Although you should always write *some* integration tests, you can also write
    tests that never touch the database at all. Instead, the database API is abstracted
    away.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在本技术中将要讨论的最终方法是模拟数据库API。尽管您应该始终编写*一些*集成测试，但您也可以编写根本不接触数据库的测试。相反，数据库API被抽象化。
- en: '|  |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Should I use the ORM for test data?**'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该为测试数据使用ORM吗？**'
- en: Like the database dump example in [listing 10.19](#ch10ex19), using an ORM to
    create test data is useful for integration tests where you really want to talk
    to a database server. It’s more programming effort than using database dumps,
    but it can be useful if you want to call methods defined above the database in
    the ORM layer. The downside of this technique is that a database schema change
    will potentially require changes in multiple test files.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表10.19](#ch10ex19)中的数据库转储示例类似，使用ORM创建测试数据对于需要真正与数据库服务器通信的集成测试非常有用。这比使用数据库转储需要更多的编程工作，但如果您想在ORM层中调用数据库之上的方法，这可能会很有用。这种技术的缺点是，数据库模式更改可能需要在多个测试文件中进行更改。
- en: '|  |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: JavaScript allows objects to be modified after they have been defined. That
    means you can override parts of the database module with your own methods to return
    test data. There are libraries designed to make this process easier and more expressive.
    One module that does this exceptionally well is Sinon.JS. The next example uses
    Sinon.JS along with Mocha to stub the database module.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许在定义对象之后修改它们。这意味着您可以使用自己的方法覆盖数据库模块的部分以返回测试数据。有一些库旨在使此过程更容易、更易于表达。一个做得特别好的模块是Sinon.JS。下一个示例使用Sinon.JS和Mocha来模拟数据库模块。
- en: '[Listing 10.21](#ch10ex21) presents an example that stubs a class that uses
    Redis for a user account database. The goal of the test is to check that password
    encryption works correctly.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.21](#ch10ex21) 展示了一个示例，该示例模拟了一个使用Redis作为用户账户数据库的类。测试的目标是检查密码加密是否正确工作。'
- en: Listing 10.21\. Stubbing a database
  id: totrans-952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.21\. 模拟数据库
- en: '![](ch10ex21-0.jpg)'
  id: totrans-953
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex21-0.jpg)'
- en: '![](ch10ex21-1.jpg)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex21-1.jpg)'
- en: This example is part of a large project that includes a package.json file and
    the `User` class being tested—it’s available in the code samples, under `testing/mocha-sinon`.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是大型项目的一部分，包括 package.json 文件和正在被测试的 `User` 类——它可以在代码示例中找到，位于 `testing/mocha-sinon`。
- en: 'On the third line you’ll notice something new: `sinon.mock` wraps the whole
    database module ![](1.jpg). The database module is one we’ve defined that loads
    the `node-redis` module, and then connects to the database. In this test we don’t
    want to connect to a real database, so we call `sinon.mock` to wrap it instead.
    This approach can be applied to other projects that use MySQL, PostgreSQL, and
    so on. As long as you design the project to centralize the database configuration,
    you can easily swap it for a mock.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行你会注意到一些新内容：`sinon.mock` 包装了整个数据库模块 ![图片](1.jpg)。这个数据库模块是我们定义的，它加载了 `node-redis`
    模块，然后连接到数据库。在这个测试中，我们不想连接到真实的数据库，所以调用 `sinon.mock` 来代替它。这种方法可以应用于使用 MySQL、PostgreSQL
    等其他项目的项目。只要你的项目设计成集中数据库配置，你就可以轻松地将其替换为模拟。
- en: Next we set up some fields that we want to use for this user ![](2.jpg). In
    an integration test, these fields would be returned by the database. We don’t
    want to do that here, so in the `before` callback, we use a stub to redefine what
    Redis `hmget` does ![](3.jpg). The stubbing API is chainable, so we chain on the
    definition of what we want *our* version of `hmget` to do by using `.callsArgWith`
    ![](4.jpg).
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们设置一些我们想要用于这个用户的字段 ![图片](2.jpg)。在一个集成测试中，这些字段将由数据库返回。我们不想在这里这样做，所以在 `before`
    回调中，我们使用模拟来重新定义 Redis `hmget` 的行为 ![图片](3.jpg)。模拟 API 是可链式的，所以我们可以通过使用 `.callsArgWith`
    来链式定义我们想要 *我们的* 版本的 `hmget` 要做什么。
- en: 'The semantics of `.callsArgWith` can be confusing, so here’s a breakdown of
    how it works. In the `User` class, `hmget` is called like this:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`.callsArgWith` 的语义可能令人困惑，所以这里有一个如何工作的分解。在 `User` 类中，`hmget` 被这样调用：'
- en: '[PRE15]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, it takes three arguments: the record key, the hash value to
    fetch, and then a callback that receives an optional error object and the loaded
    values. When we stub this, we need to tell Sinon.JS how to respond. Therefore,
    the first argument to `callsArgWith` is the index of the callback, which is `2`,
    and then the arguments that the callback should receive. We pass `null` for the
    error, and the user’s fields serialized as a `strong`. That gives us `callsArgWith(2,
    null, JSON.stringify(fields))`.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它需要三个参数：记录键、要获取的哈希值，然后是一个接收可选错误对象和加载值的回调。当我们模拟这个时，我们需要告诉 Sinon.JS 如何响应。因此，`callsArgWith`
    的第一个参数是回调的索引，它是 `2`，然后是回调应该接收的参数。我们传递 `null` 作为错误，并将用户字段序列化为 `strong`。这给了我们 `callsArgWith(2,
    null, JSON.stringify(fields))`。
- en: This test is useful because the intent of the test is to ensure users can sign
    in, but only with the correct password. The sign-in code doesn’t really require
    database access, so it’s better to pass in predefined values rather than going
    to the trouble of accessing the database. And, because the code serializes JSON
    to Redis, we don’t need a special library for serializing and decoding JSON—we
    can use the built-in `JSON` object.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很有用，因为测试的目的是确保用户可以登录，但只能使用正确的密码。登录代码实际上并不需要数据库访问，所以最好传递预定义的值，而不是麻烦去访问数据库。此外，因为代码将
    JSON 序列化到 Redis，我们不需要专门的库来序列化和解码 JSON——我们可以使用内置的 `JSON` 对象。
- en: Now you should know when and how to use integration tests, and mocks and stubs.
    All of these techniques will help you write better tests, but only if you use
    them in the correct circumstances. [Table 10.2](#ch10table02) provides a summary
    of these techniques and explains when to use each one.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该知道何时以及如何使用集成测试、模拟和存根。所有这些技术都将帮助你编写更好的测试，但只有在你正确使用它们的情况下。[表 10.2](#ch10table02)
    提供了这些技术的总结，并解释了何时使用每个技术。
- en: Table 10.2\. When to use integration tests, mocks, and stubs
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.2\. 何时使用集成测试、模拟和存根
- en: '| Technique | When to use it |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 何时使用 |'
- en: '| --- | --- |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integration testing | This means testing groups of modules. Here we’ve used
    the term to distinguish between tests that access a real database, and tests that
    somehow replace database access with a compatible API. You should use integration
    tests to ensure your database behaves the way you expect. Integration tests can
    help verify performance, but this is highly dependent on your test data. It may
    cause your tests to be more closely coupled to the database, which means that
    if you change the database or database API, you may need to change your test code
    as well. |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '| 集成测试 | 这意味着测试模块组。在这里，我们使用这个术语来区分访问真实数据库的测试和以某种方式用兼容的API替换数据库访问的测试。你应该使用集成测试来确保你的数据库按预期运行。集成测试可以帮助验证性能，但这高度依赖于你的测试数据。它可能会使你的测试与数据库耦合得更紧密，这意味着如果你更改数据库或数据库API，你可能还需要更改你的测试代码。|'
- en: '| Database dump | This is one way to preload data (before tests) into a test
    database. It requires a lot of work up front to prepare the data, and the data
    has to be maintained if you ever change the database schema. The added maintenance
    work is offset by the simplicity of the approach—you don’t need any special tools
    to create SQL, Mongo, or other data files. You should use this technique when
    you’re writing tests for a project that already has a database. Perhaps you’re
    moving to Node from another programming language or platform, and you’re using
    the existing database. You can take production data—being careful to remove or
    obscure any personal information, or other sensitive information—and then drop
    the resulting database export into your project’s repository. |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '| 数据库导出 | 这是一种在测试前将数据（在测试前）预加载到测试数据库中的方法。这需要在准备数据时做大量的前期工作，并且如果数据库模式有任何更改，数据也需要维护。这种额外的工作量可以通过方法的简单性来抵消——你不需要任何特殊的工具来创建SQL、Mongo或其他数据文件。当你为已经拥有数据库的项目编写测试时，你应该使用这种技术。也许你正在从其他编程语言或平台迁移到Node，并且正在使用现有的数据库。你可以将生产数据（注意移除或模糊任何个人信息或其他敏感信息）导入到你的项目仓库中，然后将其导出的数据库放入你的项目中。|'
- en: '| ORM fixture | Rather than creating a file to import before the tests are
    run, you can use your ORM module to create and store data in your test code. This
    can make it hard to maintain over time—any schema changes mean tests have to be
    carefully updated. You should use this technique for tests where algorithms are
    closely tied to the underlying data. By keeping the data near the code that uses
    it, any relating issues can be easier to understand and fix. |'
  id: totrans-968
  prefs: []
  type: TYPE_TB
  zh: '| ORM 固件 | 在测试运行之前创建一个导入文件，而不是使用你的ORM模块在测试代码中创建和存储数据。这可能会随着时间的推移变得难以维护——任何模式更改都意味着测试必须仔细更新。你应该在测试算法与底层数据紧密相关的情况下使用这种技术。通过将数据靠近使用它的代码，任何相关的问题都可以更容易地理解和解决。|'
- en: '| Mocks and stubs | Mocks are objects that simulate other objects. In this
    chapter you saw Sinon.JS, a library for handling mocks and stubs for tests. You
    should use mocks when you don’t want to access an I/O resource. For example, if
    you’re writing tests for code that talks to a payment provider like WorldPay or
    Stripe, then you’d create objects that behave like Stripe’s API without actually
    communicating with Stripe. It’s generally safer to ensure tests never need to
    access the internet, so anything that hits the network should be mocked. |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '| 模拟和存根 | 模拟是模拟其他对象的对象。在本章中，你看到了Sinon.JS，这是一个用于处理测试中模拟和存根的库。当你不希望访问I/O资源时，你应该使用模拟。例如，如果你正在为与支付提供商（如WorldPay或Stripe）通信的代码编写测试，那么你会创建一些像Stripe的API一样行为，但实际上并不与Stripe通信的对象。通常，确保测试永远不会需要访问互联网是更安全的，所以任何触网的东西都应该被模拟。|'
- en: The next time you want to test code that connects to a remote web service, or
    you need to write tests that run against a database, you should know what to do.
    If you’ve found this section interesting and you want to find out more, continue
    reading for some ideas on what to learn next.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你想测试连接远程Web服务的代码，或者你需要编写针对数据库运行的测试时，你应该知道该怎么做。如果你觉得这个部分很有趣，并且想了解更多，请继续阅读，以获取一些关于下一步学习什么的想法。
- en: 10.6\. Further reading
  id: totrans-971
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6. 进一步阅读
- en: Testing is a big topic, and although this chapter has been long, there are still
    important topics to consider. The Node community continues to explore ways to
    write better tests, and it has started to bring its ideas to client-side development.
    One such development is Browserify ([http://browserify.org](http://browserify.org))—this
    allows Node’s module pattern and core modules like `EventEmitter` and `stream.Readable`
    to be used in the browser.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个大主题，尽管本章已经很长，但仍有一些重要的话题需要考虑。Node 社区继续探索编写更好测试的方法，并将这些想法带到客户端开发中。其中一项发展是
    Browserify ([http://browserify.org](http://browserify.org))——这允许 Node 的模块模式和像
    `EventEmitter` 和 `stream.Readable` 这样的核心模块在浏览器中使用。
- en: Some Node developers are taking advantage of Browserify to write better client-side
    tests. Not only can they take advantage of streams and Node’s module pattern for
    cleaner dependency management, but they can also write Mocha or TAP tests the
    way they do on the server. James Halliday, the author of Browserify, created Testling,
    which is a browser automation module for running client-side tests.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Node 开发者正在利用 Browserify 来编写更好的客户端测试。他们不仅可以利用流和 Node 的模块模式来更干净地管理依赖关系，还可以像在服务器上一样编写
    Mocha 或 TAP 测试。Browserify 的作者 James Halliday 创建了 Testling，这是一个用于运行客户端测试的浏览器自动化模块。
- en: Along with continuous integration servers, another useful test-related tool
    is coverage reports. These analyze code to see how much of a project is hit when
    the tests are run. There may be functions, methods, or even clauses in `if` statements
    that never get executed, which means untested and potentially buggy code could
    be released to the production environment.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持续集成服务器外，另一个有用的测试相关工具是覆盖率报告。这些报告分析代码，以查看在运行测试时项目中有多少部分被击中。可能会有函数、方法，甚至在`if`语句中的某些子句从未被执行，这意味着未经测试且可能存在错误的代码可能会被发布到生产环境中。
- en: 10.7\. Summary
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7. 摘要
- en: In this chapter you’ve learned how to write assertions and extend them, and
    how to use two popular test frameworks. When writing tests for your Node projects,
    you should always err on the side of readability—tests should be fast, but if
    they don’t communicate intent, they can cause maintenance issues in the future.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写断言并扩展它们，以及如何使用两个流行的测试框架。在为你的 Node 项目编写测试时，你应该始终偏向于可读性——测试应该快速，但如果它们不传达意图，它们可能会在未来引起维护问题。
- en: 'Here’s a recap of the main points we covered:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对我们涵盖的主要点的回顾：
- en: Master the `assert` module by learning each method and how to ensure errors
    are correctly handled.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过学习每个方法和如何确保错误得到正确处理来掌握 `assert` 模块。
- en: Use test harnesses like Mocha and `node-tap` to help make tests readable and
    maintainable.
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mocha 和 `node-tap` 这样的测试工具来帮助使测试可读和维护。
- en: Write tests for code that uses a database by loading data or using mocks and
    stubs.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为使用数据库的代码编写测试，通过加载数据或使用模拟和存根。
- en: Improve mocks and stubs by using third-party modules like Sinon.JS.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用像 Sinon.JS 这样的第三方模块来改进模拟和存根。
- en: Develop your own domain-specific languages for tests—write functions and classes
    that help keep test cases lean and succinct.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试开发自己的领域特定语言——编写帮助保持测试用例精简和简洁的函数和类。
- en: One aspect of development that we haven’t covered yet is debugging Node programs.
    This can be an important part of writing software, depending on your development
    style and background. If you’re interested in learning the basics of the Node
    debugger, or want to learn more about it, then read on to dive into debugging
    with Node.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖的一个开发方面是调试 Node 程序。这可能是编写软件的一个重要部分，这取决于你的开发风格和背景。如果你对学习 Node 调试器的基础知识感兴趣，或者想了解更多，那么请继续阅读，深入了解使用
    Node 进行调试。
- en: 'Chapter 11\. Debugging: Designing for introspection and resolving issues'
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章. 调试：设计用于内省和解决问题
- en: '*This chapter covers*'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Handling uncaught exceptions
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未捕获的异常
- en: Linting Node applications
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Node 应用程序
- en: Using debugging tools
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试工具
- en: Profiling applications and investigating memory leaks
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析应用程序和调查内存泄漏
- en: Using a REPL to investigate a running process
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REPL 调查正在运行的过程
- en: Tracing system calls
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪系统调用
- en: Understanding how errors are generated and handled in any given platform is
    paramount to building stable applications. Good error introspection and tests
    that are built-in are the best offense for debugging issues later on. In this
    chapter we focus on *how to prepare for* and *what to do* when things go south.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在任何给定平台上错误是如何生成和处理的，对于构建稳定的应用程序至关重要。良好的错误内省和内置的测试是后来调试问题的最佳防御。在本章中，我们关注*如何准备*和*在事情出错时应该做什么*。
- en: Maybe your process keeps crashing or it’s using more memory than you expected.
    Perhaps it’s stuck at 100% CPU usage. We’ll look at debugging solutions for these
    and other problems you may encounter in your Node applications.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的进程不断崩溃，或者它使用的内存比你预期的要多。也许它卡在100%的CPU使用率上。我们将探讨这些以及其他你可能在Node应用程序中遇到的问题的调试解决方案。
- en: In the first part we’ll cover Node application design for error handling and
    detection. In the second half we’ll look at debugging specific types of problems.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将介绍Node应用程序的错误处理和检测设计。在下半部分，我们将探讨调试特定类型的问题。
- en: 11.1\. Designing for introspection
  id: totrans-995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 设计用于自省
- en: When we design applications, we need to be thinking about how we’ll handle errors.
    Relevant error logging and intervention takes thought. It also takes a good understanding
    of where errors can occur in order to trap them. Throughout this book, we’ve covered
    various forms of errors that can happen in Node applications. Let’s cover all
    the types here.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计应用程序时，我们需要思考如何处理错误。相关的错误日志记录和干预需要深思熟虑。同时，为了捕捉错误，还需要对错误可能发生的位置有良好的理解。在这本书中，我们已经涵盖了Node应用程序中可能发生的各种错误形式。让我们在这里全面了解所有这些类型。
- en: 11.1.1\. Explicit exceptions
  id: totrans-997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. 显式异常
- en: 'Explicit exceptions are those *explicitly* triggered by the `throw` keyword.
    They clearly indicate that something has gone wrong:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 显式异常是那些*明确地*由`throw`关键字触发的。它们清楚地表明出了问题：
- en: '[PRE16]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Explicit exceptions are handled by a `try/catch` block:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 显式异常由`try/catch`块处理：
- en: '[PRE17]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you `throw` your own exceptions, keep these guidelines in mind:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你`throw`自己的异常，请记住以下指南：
- en: '`throw` should be used only in synchronous functions; or in some cases, it
    makes sense before the asynchronous action has occurred in asynchronous functions
    (like API misuse).'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw`只应在同步函数中使用；或者在异步函数中，在某些情况下，在异步操作发生之前使用是有意义的（例如API误用）。'
- en: Always `throw` an `Error` object or something that inherits from `Error`. Using
    simple strings (like `throw "Oh no!"`) won’t generate a stack trace, so you’ll
    have no information as to where the error occurred.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是`throw`一个`Error`对象或从`Error`继承的对象。使用简单的字符串（如`throw "Oh no!"`）不会生成堆栈跟踪，因此你将没有关于错误发生位置的信息。
- en: Don’t `throw` inside Node-style callback functions; nothing exists on the stack
    to catch it! Instead, deal directly with the error or pass the error off to another
    function that can properly handle the error.
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在Node风格的回调函数中`throw`；堆栈上没有东西可以捕获它！相反，直接处理错误或将错误传递给可以正确处理错误的另一个函数。
- en: '|  |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Regaining throw
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 恢复`throw`
- en: You can regain the use of `throw` for asynchronous blocks if the structures
    support it; some notable ones are domains, promises, or generators.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构支持，你可以恢复异步块中使用`throw`的能力；一些值得注意的例子是域、承诺或生成器。
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.1.2\. Implicit exceptions
  id: totrans-1010
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 隐式异常
- en: '*Implicit exceptions* are any runtime JavaScript errors *not* triggered by
    the `throw` keyword. Unfortunately, these exceptions can sneak into our code too
    easily.'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式异常*是指不是由`throw`关键字触发的任何运行时JavaScript错误。不幸的是，这些异常很容易悄悄地进入我们的代码。'
- en: One common implicit exception is `ReferenceError`, which is caused when a reference
    to a variable or property can’t be found.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的隐式异常是`ReferenceError`，它发生在无法找到变量或属性的引用时。
- en: 'Here, we see an innocent misspelling of `data` causes an exception:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到一个无辜的`data`拼写错误导致了一个异常：
- en: '[PRE18]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another common implicit exception is `SyntaxError`, most famously triggered
    using `JSON.parse` on invalid JSON data:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的隐式异常是`SyntaxError`，最著名的是在无效的JSON数据上使用`JSON.parse`时触发：
- en: '[PRE19]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It’s a good idea to wrap `JSON.parse` with a `try/catch` block, especially if
    you aren’t in control of the input JSON data.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 将`JSON.parse`包裹在`try/catch`块中是个好主意，尤其是如果你不控制输入的JSON数据。
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Catch implicit exceptions early
  id: totrans-1019
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 早期捕捉隐式异常
- en: A great way to catch implicit exceptions early is to utilize linting tools like
    JSHint or JSLint. Adding them to your build process helps keep your code in check.
    We’ll talk more on subject this later in the chapter.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 早期捕捉隐式异常的一个好方法是利用代码检查工具，如JSHint或JSLint。将它们添加到你的构建过程中有助于保持你的代码整洁。我们将在本章后面更多地讨论这个话题。
- en: '|  |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.1.3\. The error event
  id: totrans-1022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3\. 错误事件
- en: 'The `error` event can be emitted from any `EventEmitter` in Node. If left unhandled,
    Node *will* `throw` the error. These events can be the most difficult to debug
    if not handled, since many times they’re triggered during asynchronous operations
    like streaming data where the call stack is minimal:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中，`error`事件可以从任何`EventEmitter`发出。如果未处理，Node将**抛出**错误。如果没有处理，这些事件可能是最难调试的，因为很多时候它们是在异步操作（如流数据）期间触发的，那里的调用栈很小：
- en: '[PRE20]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will output the following:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE21]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Luckily, we know where this error came from; we just wrote the code, after all!
    But in larger applications, we may have errors triggered at the DNS layer and
    we have no idea which module utilizing DNS just had a problem.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们知道这个错误是从哪里来的；毕竟，我们刚刚编写了代码！但在更大的应用程序中，我们可能有在DNS层触发的错误，而我们不知道哪个使用DNS的模块出了问题。
- en: 'So, when possible, handle error events:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当可能时，处理错误事件：
- en: '[PRE22]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When writing your own `EventEmitter`s, do yourself and your API consumers a
    favor and give them context to any errors in your dependencies that you’re propagating
    upward. Also, use `Error` objects over plain strings when emitting errors so a
    stack trace can be found.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的`EventEmitter`时，请为你自己和API消费者行个方便，并为他们提供任何你向上传播的错误依赖的上下文。此外，在发出错误时使用`Error`对象而不是纯字符串，以便可以找到堆栈跟踪。
- en: 11.1.4\. The error argument
  id: totrans-1031
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.4. 错误参数
- en: 'Errors that occur during an asynchronous operation are provided as the first
    argument in a callback function. Unlike the previous errors we’ve talked about,
    these never cause exceptions *directly*. But they can be the source of many implicit
    exceptions:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步操作期间发生的错误作为回调函数的第一个参数提供。与之前我们讨论的错误不同，这些错误**不会直接**导致异常。但它们可能是许多隐式异常的来源：
- en: '[PRE23]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we ignore the error returned from `readFile`, perhaps assuming we’ll always
    have a buffer of the file data to continue working with. Unfortunately, the day
    comes when we can’t read the file and we have a `ReferenceError` because `buf`
    is not defined.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们忽略了`readFile`返回的错误，可能假设我们总是会有一个文件数据的缓冲区来继续工作。不幸的是，有一天我们无法读取文件，我们有一个`ReferenceError`，因为`buf`未定义。
- en: 'It’s more robust to just handle the asynchronous errors. A lot of times this
    can mean simply passing the error to another function that can gracefully handle
    the error:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 只处理异步错误更健壮。很多时候，这意味着简单地将错误传递给另一个可以优雅地处理错误的函数：
- en: '[PRE24]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Handling each of these four types of errors effectively will give you much better
    data to work with when you’re debugging issues in the future!
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 有效处理这四种类型的错误将为你未来在调试问题时提供更好的数据。
- en: Even with our best efforts and tooling, though, we can still miss exceptions
    and have a crashed server on our hands. Let’s look at designing our applications
    to handle these situations so we can quickly address and fix uncaught exceptions.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们付出了最大的努力和工具支持，但我们仍然可能错过异常，导致服务器崩溃。让我们看看如何设计我们的应用程序来处理这些情况，以便我们能够快速处理和修复未捕获的异常。
- en: Technique 88 Handling uncaught exceptions
  id: totrans-1039
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧88 处理未捕获的异常
- en: How do you effectively handle Node crashes? One of the first things you discover
    when working with Node is that it terminates a process whenever an exception is
    uncaught. It’s important to understand why this behavior exists and how you handle
    uncaught exceptions in order to build robustness into your programs.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何有效地处理Node崩溃？当你与Node一起工作时，你首先发现的一件事是，每当未捕获异常时，它都会终止进程。了解这种行为存在的原因以及如何处理未捕获的异常，对于将健壮性构建到你的程序中非常重要。
- en: Problem
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have an uncaught exception taking down your process.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个未捕获的异常正在使你的进程崩溃。
- en: Solution
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Log the exception, and shut down gracefully.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 记录异常，并优雅地关闭。
- en: Discussion
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes exceptions go uncaught. When this happens, Node by default will terminate
    the process. There’s a good reason for this, which we’ll come back to, but let’s
    first talk about how we can change this default behavior.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 有时异常未被捕获。当这种情况发生时，Node默认会终止进程。这有一个很好的原因，我们稍后会回到这个问题，但首先让我们谈谈我们如何改变这种默认行为。
- en: 'With an `uncaughtException` handler set on the `process` object, Node will
    execute the handler *instead* of terminating your program:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 在`process`对象上设置`uncaughtException`处理程序后，Node将执行处理程序而不是终止你的程序：
- en: '[PRE25]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Yeah! Now your Node application will never crash! Although it’s true that exceptions
    won’t take down your process anymore, the drawbacks of leaving the Node program
    running will most likely outweigh the benefits. If you choose to keep the application
    running, the application could leak resources and possibly become unstable.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！现在你的Node应用程序永远不会崩溃！虽然确实异常不会再使你的进程崩溃，但让Node程序继续运行的缺点很可能会超过其好处。如果你选择让应用程序继续运行，应用程序可能会泄漏资源并可能变得不稳定。
- en: 'How does that happen? Let’s look at an example of an application we intend
    to run for a long time: a web server. We won’t allow Node to terminate the process
    by adding an `uncaughtException` handler that just logs the error. What do you
    think will happen when we have an uncaught exception while we’re handling a user’s
    request?'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何发生的？让我们看看一个我们打算长期运行的应用程序的例子：一个网络服务器。我们不会允许Node通过添加仅记录错误的`uncaughtException`处理程序来终止进程。你认为当我们处理用户请求时发生未捕获的异常会发生什么？
- en: '![](297fig01_alt.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![图片](297fig01_alt.jpg)'
- en: When a request comes in, an exception is thrown and then caught by the `uncaught-Exception`
    handler. What happens to the request? It is *leaked*, as that connection will
    remain open until the client times out (we also no longer have access to `res`
    to give a response back).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求进来时，会抛出一个异常，然后被`uncaught-Exception`处理程序捕获。请求会发生什么？它会*泄漏*，因为该连接将保持打开状态，直到客户端超时（我们也不再能访问`res`来给出响应）。
- en: In [figure 11.1](#ch11fig01), you can see an illustration of this leak happening.
    If we had no exception, we’d be fine, but since we had an exception, we leaked
    a resource.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11.1](#ch11fig01)中，你可以看到这种泄漏发生的示意图。如果我们没有异常，我们会没事，但由于我们有了异常，我们泄漏了资源。
- en: Figure 11.1\. Leaking resources when using `uncaughtException`
  id: totrans-1054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. 使用`uncaughtException`时泄漏资源
- en: '![](11fig01_alt.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig01_alt.jpg)'
- en: Although this example is simplified to be clear, uncaught exceptions are a reality.
    Most of the time it will be open handles to sockets or files that aren’t able
    to be closed properly. Uncaught exceptions are usually buried much deeper in the
    code, which makes determining what resources are being leaked even harder.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子被简化以使其清晰，未捕获的异常却是现实。大多数情况下，它将是无法正确关闭的套接字或文件的开销。未捕获的异常通常在代码中埋藏得更深，这使得确定正在泄漏的资源变得更加困难。
- en: State can also be affected, since an uncaught exception takes you out of your
    current context and places you in a completely different context (the `uncaughtException`
    handler) where you don’t have references to objects in order to clean things up.
    In our example, we didn’t have access to the `res` object in order to send a response
    back to the client.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 状态也可能受到影响，因为未捕获的异常会将你从当前上下文中移出，并将其置于一个完全不同的上下文中（`uncaughtException`处理程序），在那里你没有对对象的引用来清理东西。在我们的例子中，我们没有访问`res`对象来向客户端发送响应。
- en: 'So what good is the `uncaughtException` handler? It enables your application
    to log and restart gracefully. It’s wise to treat an `uncaughtException` handler
    as a last chance to say your goodbyes before going down. Write out the error,
    perhaps send an email or do some other notification, and then gracefully kill
    the app:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`uncaughtException`处理程序有什么好处呢？它使你的应用程序能够记录错误并优雅地重启。将`uncaughtException`处理程序视为在崩溃之前说再见的机会是明智的。记录错误，可能发送电子邮件或进行其他通知，然后优雅地关闭应用程序：
- en: '![](298fig01_alt.jpg)'
  id: totrans-1059
  prefs: []
  type: TYPE_IMG
  zh: '![图片](298fig01_alt.jpg)'
- en: The `uncaughtException` handler is a last defense. Ideally exceptions should
    be handled closer to the source so action can be taken to prevent leaks and instability.
    For that, you can use domains.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '`uncaughtException`处理程序是最后的防线。理想情况下，异常应该在更接近源的地方被处理，以便采取行动防止泄漏和不稳定。为此，你可以使用域。'
- en: Using domains for uncaught exceptions
  id: totrans-1061
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用域处理未捕获的异常
- en: 'Whereas an `uncaughtException` casts a net over the entirety of your application
    code base to catch errors, domains allow you to control the *portions of code*
    that are monitored by the domain and handle exceptions closer to the source (more
    on this back in [chapter 4](kindle_split_013.html#ch04)). Let’s implement the
    same `uncaughtException` example from earlier, but using domains instead:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 而`uncaughtException`会在整个应用程序代码库上撒网以捕获错误，域允许你控制由域监控的*代码部分*并更接近源处理异常（更多内容请参阅[第4章](kindle_split_013.html#ch04)）。让我们实现之前提到的相同的`uncaughtException`示例，但使用域代替：
- en: '![](298fig02_alt.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![图片](298fig02_alt.jpg)'
- en: Using domains allowed us to sandbox our server code and still have access to
    the `res` object to give the user a response, which is an improvement on the previous
    example. But even though we’re able to give the user a response and close the
    connection, it’s still best practice to close out the process.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 使用域允许我们沙盒化我们的服务器代码，同时仍然可以访问`res`对象以向用户提供响应，这是对之前示例的改进。但尽管我们能够向用户提供响应并关闭连接，关闭进程仍然是最佳实践。
- en: If you utilize domains, it’s not a bad idea to keep an `uncaughtException` handler
    as a catchall for those cases where an error slips by one of your domains, or
    your domain’s error handler throws an exception where no other domain is there
    to catch it.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用域，保留一个`uncaughtException`处理程序作为所有错误的情况，这些错误可能通过你的某个域遗漏，或者你的域错误处理程序抛出异常而没有其他域来捕获它，这并不是一个坏主意。
- en: 'Let’s switch to a helpful way to build introspection into your application
    and prevent errors before they happen: linting!'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向一种有助于在应用程序中建立内省并防止错误发生的方法：代码检查！
- en: Technique 89 Linting Node applications
  id: totrans-1067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧89：检查Node应用程序
- en: Lint tools can help catch a multitude of application errors when properly tuned.
    In our previous example, we misspelled `res`, which led to an uncaught exception.
    Although the code was *valid* JavaScript, we had an undefined variable being accessed.
    A lint tool would’ve caught this error.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查工具可以帮助捕捉到多种应用程序错误，当它们被正确调整时。在我们之前的例子中，我们拼写错误了`res`，这导致了一个未捕获的异常。尽管代码是*有效*的JavaScript，但我们访问了一个未定义的变量。代码检查工具会捕捉到这个错误。
- en: Problem
  id: totrans-1069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to catch potential coding errors and exceptions.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要捕捉潜在的编码错误和异常。
- en: Solution
  id: totrans-1071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a lint tool.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码检查工具。
- en: Discussion
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Let’s talk about setting up an application to use JSHint with Node. JSHint is
    an actively maintained lint tool that includes a number of customizable options
    for JavaScript code bases.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何设置一个应用程序以使用Node的JSHint。JSHint是一个活跃维护的代码检查工具，它为JavaScript代码库提供了一系列可定制的选项。
- en: 'First, we assume you already have a package.json file set up (if not: `npm
    init`) for your project. Next, let’s add `jshint` to our development dependencies:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们假设你已经在你的项目中设置了一个package.json文件（如果没有：`npm init`）。接下来，让我们将`jshint`添加到我们的开发依赖中：
- en: '[PRE26]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let’s configure JSHint so it knows what it’s working with. We just throw
    a .jshintrc file—which takes a JSON configuration—in our project root. Let’s look
    at a basic configuration for Node projects:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来配置JSHint，让它知道它在处理什么。我们只需在项目根目录中抛出一个`.jshintrc`文件——它包含一个JSON配置。让我们看看Node项目的基本配置：
- en: '![](299fig01_alt.jpg)'
  id: totrans-1078
  prefs: []
  type: TYPE_IMG
  zh: '![](299fig01_alt.jpg)'
- en: JSHint has a lot of options ([http://jshint.com/docs/options/](http://jshint.com/docs/options/))
    that bend rules to match your coding style and intent, but these just shown are
    some good basic defaults.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint有很多选项([http://jshint.com/docs/options/](http://jshint.com/docs/options/))，这些选项可以根据你的编码风格和意图调整规则，但这里仅展示了一些良好的基本默认设置。
- en: 'To run JSHint, add the following line to the `"scripts"` block in your package.json
    file (if you don’t have a `"scripts"` block, just add one):'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行JSHint，请将以下行添加到你的`package.json`文件中的`"scripts"`块（如果你没有`"scripts"`块，只需添加一个）：
- en: '![](300fig01.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![](300fig01.jpg)'
- en: 'You can then run JSHint from your project root this way:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从项目根目录以这种方式运行JSHint：
- en: '[PRE27]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: JSHint will give you output that tells you what errors it found, and you can
    either correct or update the options to better fit your coding style and intent.
    Similarly to tests, it’s helpful to have your build tools run the lint tools as
    you push code, since it’s easy to forget to run and can be automated away.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint会给出输出，告诉你它发现了什么错误，你可以纠正或更新选项以更好地适应你的编码风格和意图。类似于测试，当你在推送代码时运行代码检查工具是有帮助的，因为很容易忘记运行，而且可以自动化。
- en: Now that we’ve looked at ways to prevent and effectively handle application
    errors, let’s switch over to look at tools we can use to debug issues when they
    occur.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了防止和有效处理应用程序错误的方法，让我们转而看看当问题发生时我们可以使用的调试工具。
- en: 11.2\. Debugging issues
  id: totrans-1086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 调试问题
- en: We have our tests, our logging, and our linting. How do we actually debug and
    fix issues when they occur? Thankfully, there are a number of tools for a number
    of different situations. In this section we’ll take a look at various and likely
    unrelated problems you can encounter when running your applications, and techniques
    to solve them. We’ll start with using debuggers and move on to profiling, memory
    leaks, production debugging, and tracing.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有测试、日志和代码风格检查。当问题发生时，我们实际上如何调试和修复它们呢？幸运的是，有针对不同情况的各种工具。在本节中，我们将探讨在运行应用程序时可能遇到的各种可能不相关的问题，以及解决这些问题的技术。我们将从使用调试器开始，然后转向性能分析、内存泄漏、生产环境调试和跟踪。
- en: Technique 90 Using Node’s built-in debugger
  id: totrans-1088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 90 使用 Node 的内置调试器
- en: Whenever you need step-by-step analysis of the state of your application, a
    debugger can be an invaluable tool, and Node’s built-in debugger is no exception.
    Node’s built-in tooling allows you to watch variables, pause execution through
    breakpoints, step in and out of parts of your application, see backtraces, run
    an interactive context-aware REPL, and more.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要逐步分析应用程序的状态时，调试器可以是一个无价的工具，Node 的内置调试器也不例外。Node 的内置工具允许你监视变量、通过断点暂停执行、进入和退出应用程序的某些部分、查看回溯、运行交互式上下文感知的
    REPL，等等。
- en: Unfortunately, many shy away from the command-line tool, as it may seem intimidating
    at first. We want to debunk that and show how powerful it can be by walking you
    through most of the functionality it has to offer.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多人因为一开始可能觉得命令行工具令人生畏而回避它。我们希望通过向您展示它提供的功能来打破这种观念，并展示它的强大之处。
- en: Problem
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run a debugger to set breakpoints, watch variables, and step through
    your application.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 你想运行调试器来设置断点、监视变量以及逐步执行你的应用程序。
- en: Solution
  id: totrans-1093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `node debug`.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node debug`。
- en: Discussion
  id: totrans-1095
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Let’s take a simple program to debug in order to demonstrate some of the features
    of the debugger:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的程序来调试，以演示调试器的某些功能：
- en: '[PRE28]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To run the built-in debugging tool, simply use the `debug` command:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行内置的调试工具，只需使用 `debug` 命令：
- en: '[PRE29]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It will start the application with the debugger breaking on the first executable
    line:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以调试器在第一行可执行代码上中断的方式启动应用程序：
- en: '[PRE30]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To view all the available commands and debugging variables, you can type `help`:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的命令和调试变量，你可以键入 `help`：
- en: '[PRE31]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To continue from the default starting breakpoint, just type `cont`, or just
    `c` for short. Since we don’t have any other breakpoints, the application will
    terminate:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 要从默认的起始断点继续，只需键入 `cont`，或简写为 `c`。由于我们没有其他断点，应用程序将终止：
- en: '[PRE32]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But we’re *still* in the debugger and can restart the application again by
    using the `run` command (`r` for short):'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然在调试器中，并且可以通过使用 `run` 命令（简写为 `r`）再次重新启动应用程序。
- en: '[PRE33]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And we’re back in business. We can also restart the application with the `restart`
    command or manually kill the application with the `kill` command if we need to.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到了业务。我们还可以使用 `restart` 命令重新启动应用程序，或者如果我们需要，可以使用 `kill` 命令手动终止应用程序。
- en: 'The application is all about the letter *A*, so let’s take a peek at how that
    changes as our application executes by making a `watch` expression for that. The
    `watch` function takes an expression to watch as an argument:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的核心是字母 *A*，因此让我们通过为它创建一个 `watch` 表达式来看看它在应用程序执行过程中的变化。`watch` 函数接受一个要监视的表达式作为参数：
- en: '[PRE34]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can view the state of all that we’re watching using the `watchers` command:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `watchers` 命令来查看我们正在监视的所有内容的状态：
- en: '[PRE35]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Currently we’re paused before the assignment to 0 has even been made, so we’re
    `undefined`. Let’s step into the next line with `next`(or `n` for short):'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们在赋值为 0 之前就暂停了，所以我们是 `undefined`。让我们使用 `next`(或简写为 `n`) 步入下一行：
- en: '[PRE36]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Well, that’s convenient: the debugger outputs our watchers for us as we step
    to the next section. If we were to type `watchers` again, we’d see similar output:'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很方便：调试器在我们步入下一部分时为我们输出了监视器。如果我们再次键入 `watchers`，我们会看到类似的输出：
- en: '[PRE37]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we ever want to remove a watch expression, we can use the `unwatch` command
    given the same expression we used to create it.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想删除一个监视表达式，我们可以使用 `unwatch` 命令，给出与创建它相同的表达式。
- en: 'By default, the debugger will print just a couple lines before and after to
    give a sense of context. But sometimes we want to see more of what’s going on.
    We can use the `list` command, giving it the number of lines around the current
    line where we’re paused:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，调试器将打印出当前暂停行前后的一两行，以提供上下文感。但有时我们想看到更多发生的事情。我们可以使用 `list` 命令，给出我们想要查看的当前暂停行周围的行数：
- en: '[PRE38]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’re currently at line 11, the `changeA` function. If we were to type `next`,
    we’d move to the next line, which is the `addToA` function, but let’s investigate
    our `changeA` function more by stepping into it. To do that we just use the `step`
    command (or `s` for short):'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前在第11行，`changeA`函数。如果我们输入`next`，我们会移动到下一行，即`addToA`函数，但让我们更深入地调查`changeA`函数。要做到这一点，我们只需使用`step`命令（或简称`s`）：
- en: '[PRE39]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we’re in this function, we can step out of it at any time using the
    `out` command. We’ll automatically step out of it once we reach the end, so we
    can also use `next`; let’s try it:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在这个函数中，我们可以使用`out`命令随时从中退出。一旦我们到达末尾，我们会自动退出，所以我们也可以使用`next`；让我们试试：
- en: '[PRE40]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see, our watchers updated to show that *a* is now `50`. Let’s go
    to the next line:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的监视器更新了，显示现在*a*是`50`。让我们进入下一行：
- en: '[PRE41]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we’re back to the line after our `changeA` function. Let’s step into this
    next function again. Remember what command that was?
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到了`changeA`函数之后的行。让我们再次进入这个下一个函数。你还记得那个命令吗？
- en: '[PRE42]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s explore another neat aspect of the debugger: the built-in REPL! We can
    access it by using the `repl` command:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索调试器的另一个有趣方面：内置的REPL！我们可以通过使用`repl`命令来访问它：
- en: '[PRE43]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is a standard REPL that’s aware of the context that surrounds it when
    you used the `repl` command. So we can, for instance, output the value of the
    `toAdd` argument:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的REPL，当你使用`repl`命令时，它了解其周围的上下文。因此，例如，我们可以输出`toAdd`参数的值：
- en: '[PRE44]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can also introduce state into the application. Let’s create a global `b`
    variable:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将状态引入应用程序。让我们创建一个全局的`b`变量：
- en: '[PRE45]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In many ways, this behaves just like the standard Node REPL, so a lot of what
    you can do there, you can do here.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，这表现得就像标准的Node REPL一样，所以你可以在那里做的很多事情，你在这里也可以做。
- en: 'You can exit the REPL mode at any time with Ctrl-C. Let’s do that now. You’ll
    know you’ve exited because you’ll get your debug prompt back:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用Ctrl-C退出REPL模式。我们现在就做。你知道你已经退出了，因为你会回到你的调试提示符：
- en: '[PRE46]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We were in a REPL for a while, so we likely lost context when we were paused.
    Let’s use `list` again to get our bearings:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在REPL中停留了一段时间，所以当我们暂停时，我们可能失去了上下文。让我们再次使用`list`来找到我们的方向：
- en: '[PRE47]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Ah yes, that’s right, we were on line 8\. Well, you know what, we really wanted
    the `changeA` function to assign `a` to 100\. It’s such a nice number to accompany
    such a nice letter! But we forgot to do that when we started the debugger. No
    problem! We can set a breakpoint here to save our spot by using the `setBreakpoint`
    function (or `sb` for short):'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，是的，没错，我们在第8行。嗯，你知道的，我们真正想要的是让`changeA`函数将`a`赋值为100。这是一个如此美好的数字，与这样一个美好的字母相配！但我们忘记在开始调试器时这么做。没问题！我们可以使用`setBreakpoint`函数（或简称`sb`）在这里设置一个断点来保存我们的位置：
- en: '[PRE48]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that our line 8 now has a star (*) next to it indicating we have a breakpoint
    set there. Let’s change that function in our code file and save it:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们的第8行旁边有一个星号(*)，表示我们在那里设置了一个断点。让我们更改代码文件中的那个函数并保存它：
- en: '[PRE49]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Back in our debugger, we can restart the app:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的调试器中，我们可以重新启动应用：
- en: '[PRE50]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Looks like our program was restarted and the breakpoint we set is still intact.
    Did it get our changes? Let’s see:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的程序已经重新启动，我们设置的断点仍然有效。它获取了我们的更改吗？让我们看看：
- en: '[PRE51]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Another way we can set breakpoints right from our application code is to use
    the `debugger` keyword:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在应用程序代码中直接设置断点的方法是使用`debugger`关键字：
- en: '[PRE52]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we restart our application again, we’ll always stop on any `debugger` lines.
    We can clear breakpoints as well using `clearBreakpoint` (or `cb` for short).
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次重新启动应用程序，我们将在任何`debugger`行上停止。我们也可以使用`clearBreakpoint`（或简称`cb`）来清除断点。
- en: 'Let’s look at one more topic: uncaught exceptions. Let’s introduce a nasty
    `ReferenceError` in our `changeA` function:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个话题：未捕获的异常。让我们在`changeA`函数中引入一个讨厌的`ReferenceError`：
- en: '[PRE53]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we restart our application using `restart` and then `cont` to skip the initial
    breakpoint, our application will crash due to an uncaught exception. We can break
    on these exceptions instead using `breakOnException`:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`restart`重新启动应用程序，然后使用`cont`跳过初始断点，我们的应用程序会因为未捕获的异常而崩溃。我们可以使用`breakOnException`来在这些异常上设置断点：
- en: '[PRE54]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, instead of crashing, we’ll break first, allowing us to inspect the state
    of the application and use the REPL before the program terminates.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会崩溃，而是首先中断，这样我们就可以在程序终止之前检查应用程序的状态并使用REPL。
- en: '|  |'
  id: totrans-1155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Helpful multifile debugger commands
  id: totrans-1156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有用的多文件调试器命令
- en: This scenario only looked at a single file that included no other modules. The
    debugger also has a couple of commands that are helpful when you’re within multiple
    files. Use `backtrace` (or `bt` for short) to get a call stack on whatever line
    you’re currently paused at. You can also use `scripts` to get a list of loaded
    files and an indicator of what file you’re currently in.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景只查看了一个不包含其他模块的单个文件。调试器还有一些在多个文件中非常有用的命令。使用`backtrace`（或简称`bt`）来获取当前暂停的任何行的调用栈。你还可以使用`scripts`来获取已加载的文件列表以及当前所在的文件指示器。
- en: '|  |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The built-in debugger may feel odd at first if you’re used to a GUI tool for
    debugging applications, but it’s actually pretty versatile once you get the hang
    of it! Just throw a quick `debugger` statement where you’re working and fire it
    up.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了使用图形界面工具进行应用程序调试，那么内置的调试器一开始可能会感觉有些奇怪，但一旦你掌握了它的用法，它实际上非常灵活！只需在工作的地方快速输入一个`debugger`语句并启动它即可。
- en: Technique 91 Using Node Inspector
  id: totrans-1160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧91 使用Node检查器
- en: Want to do everything you can with the built-in debugger, but using the Chrome
    DevTools interface instead? There’s a module for that! It’s called `node-inspector`.
    In this technique we’ll look at how to set it up and start debugging.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 想要使用Chrome DevTools界面进行内置调试器的所有操作吗？有一个模块可以做到这一点！它被称为`node-inspector`。在这个技巧中，我们将探讨如何设置它并开始调试。
- en: Problem
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to debug a Node application using Chrome DevTools.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用Chrome DevTools调试Node应用程序。
- en: Solution
  id: totrans-1164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `node-inspector`.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`node-inspector`。
- en: Discussion
  id: totrans-1166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node allows remote debugging by exposing a debugging port that third-party modules
    and tools can hook into (including the built-in debugger). One popular module
    is `node-inspector`, which ties in debugging information from Node into the Chrome
    DevTools interface.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过暴露一个调试端口允许远程调试，第三方模块和工具可以将其挂钩（包括内置的调试器）。一个流行的模块是`node-inspector`，它将Node的调试信息集成到Chrome
    DevTools界面中。
- en: 'To set up `node-inspector`, simply install it:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`node-inspector`，只需安装它：
- en: '[PRE55]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Don’t forget the `-g` flag to install it globally. Once you have it, you can
    fire it up by running the following command:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用`-g`标志全局安装它。一旦安装，你可以通过运行以下命令来启动它：
- en: '[PRE56]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now `node-inspector` is ready to roll and will tell you where to reach it:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`node-inspector`已经准备好并会告诉你如何访问它：
- en: '[PRE57]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can then visit that URL in any Blink-enabled browser like Chrome or Opera.
    But we don’t have any Node program that has an open debugging port to start debugging,
    so we receive an error message, as shown in [figure 11.2](#ch11fig02).
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在任何Blink浏览器（如Chrome或Opera）中访问该URL。但是，我们没有打开调试端口的Node程序来开始调试，因此我们收到一个错误消息，如图11.2所示。
- en: Figure 11.2\. Error screen when no debugging agent is found
  id: totrans-1175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2. 未找到调试代理时的错误屏幕
- en: '![](11fig02_alt.jpg)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
  zh: '![11fig02_alt.jpg](11fig02_alt.jpg)'
- en: 'Let’s leave that running for now and write a little application to debug:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时让它运行，并编写一个小应用程序进行调试：
- en: '[PRE58]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we can run this application exposing the debugging port:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行这个应用程序并暴露调试端口：
- en: '[PRE59]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our application now lets us know that the debugger is listening on port 5858\.
    If we refresh our Node inspector web page, it’ll look more interesting, as shown
    in [figure 11.3](#ch11fig03).
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在会告诉我们调试器正在5858端口监听。如果我们刷新我们的Node检查器网页，它会看起来更有趣，如图11.3所示。
- en: Figure 11.3\. Node inspector connected to the debugger
  id: totrans-1182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3. Node检查器连接到调试器
- en: '![](11fig03_alt.jpg)'
  id: totrans-1183
  prefs: []
  type: TYPE_IMG
  zh: '![11fig03_alt.jpg](11fig03_alt.jpg)'
- en: We can use the inspector much like the built-in debugger to set breakpoints
    and watch expressions. It also includes a console that’s similar to the REPL to
    allow you to poke around at the state of your application while it’s paused.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用检查器就像内置调试器一样设置断点和监视表达式。它还包括一个类似于REPL的控制台，允许你在应用程序暂停时检查其状态。
- en: 'One difference between `node-inspector` and the built-in debugger is that Node
    doesn’t automatically break on the first expression. To enable that, you have
    to use the `--debug-brk` flag:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-inspector`和内置调试器之间的一个区别是Node不会自动在第一个表达式处中断。为了启用这一点，你必须使用`--debug-brk`标志：'
- en: '[PRE60]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This tells the debugger to break on the first line until the inspector can step
    through or continue execution. If we reload the inspector, we can see it’s paused
    on the first line, as shown in [figure 11.4](#ch11fig04).
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 这会告诉调试器在第一条语句处中断，直到检查器可以单步执行或继续执行。如果我们重新加载检查器，我们可以看到它暂停在第一条语句，如图11.4所示。
- en: Figure 11.4\. Using the `--debug-brk` flag
  id: totrans-1188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4. 使用`--debug-brk`标志
- en: '![](11fig04_alt.jpg)'
  id: totrans-1189
  prefs: []
  type: TYPE_IMG
  zh: '![11fig04_alt.jpg](11fig04_alt.jpg)'
- en: '`node-inspector` is continually being developed to support more of Chrome DevTools’
    functionality.'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`node-inspector`正在不断发展以支持更多Chrome DevTools的功能。'
- en: 'We’ve looked at two ways to use debugging tools in Node: the command-line debugger
    and `node-inspector`. Now, let’s switch to another tool for resolving performance-related
    issues: the profiler.'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了两种在Node中使用调试工具的方法：命令行调试器和`node-inspector`。现在，让我们切换到另一个用于解决性能相关问题的工具：分析器。
- en: Technique 92 Profiling Node applications
  id: totrans-1192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧92 分析Node应用程序
- en: 'Profiling aims to answer this question: *Where is my application spending its
    time?* For instance, you may have a long-running web server that gets stuck at
    100% CPU usage when you hit a particular route. At first glance, you might view
    the various functions that touch that route to see if anything stands out, or
    you could run a profiler and let Node tell you where it’s stuck. In this technique
    you’ll learn how to use the profiler and interpret the results.'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 分析性能的目的是回答这个问题：*我的应用程序在哪里花费了时间？*例如，你可能有一个长时间运行的Web服务器，当你访问特定的路由时，它会卡在100%的CPU使用率。一开始，你可能想查看所有触及该路由的函数，看看是否有任何异常，或者你可以运行一个分析器，让Node告诉你它卡在了哪里。在这个技术中，你将学习如何使用分析器并解释结果。
- en: Problem
  id: totrans-1194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find out where your application is spending its time.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道你的应用程序在哪里花费了时间。
- en: Solution
  id: totrans-1196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `node --prof`.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`node --prof`。
- en: Discussion
  id: totrans-1198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node taps into the underlying V8 statistical profiler by the use of the `--prof`
    command-line flag. It’s important to understand how it works in order to interpret
    the data.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过使用`--prof`命令行标志调用了底层的V8统计分析器。为了解释数据，理解它是如何工作的非常重要。
- en: Every two milliseconds, the profiler looks at the running application and records
    the function executing at that moment. The function may be a JavaScript function,
    but it also can come from C++, shared libraries, or V8 garbage collection. The
    profiler writes these “ticks” to a file named `v8.log`, where they’re then processed
    by a special V8 tick-processor program.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 每两毫秒，分析器查看正在运行的应用程序，并记录当时正在执行的函数。这个函数可能是一个JavaScript函数，但它也可以来自C++、共享库或V8垃圾回收。分析器将这些“tick”写入名为`v8.log`的文件中，然后由一个特殊的V8
    tick-processor程序进行处理。
- en: 'Let’s look at a simple application to see how this works. Here we have an application
    doing two different things—running a slower computational task every two seconds,
    and running a quicker I/O task more often:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的应用程序来了解它是如何工作的。这里有一个应用程序执行两种不同的任务——每两秒运行一个较慢的计算任务，并且更频繁地运行一个较快的I/O任务：
- en: '[PRE61]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can profile this application like so:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样分析这个应用程序：
- en: '[PRE62]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we let it run for 10 seconds or so and kill it, we’ll get a `v8.log` in
    that same directory. The log isn’t too helpful by itself. Let’s process the log
    by using the V8 tick-processor tools. Those tools require that you build V8 from
    source on your machine, but there’s a handy third-party module that allows you
    to skip that. Just run the following command to install:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让它运行大约10秒钟然后终止它，我们将在同一个目录下得到一个`v8.log`文件。日志本身并不太有帮助。让我们使用V8 tick-processor工具来处理日志。这些工具要求你在机器上从源代码构建V8，但有一个方便的第三方模块允许你跳过这一步。只需运行以下命令来安装：
- en: '[PRE63]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will install the appropriate tick processor for your operating system
    in order to view the data. You can then run the following command in the same
    directory as your `v8.log` file to get some more helpful output:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装适合你操作系统的适当tick处理器，以便查看数据。然后你可以在与你的`v8.log`文件相同的目录中运行以下命令以获得一些更有帮助的输出：
- en: '[PRE64]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You’ll get output that looks similar to the following (abbreviated to show
    structure):'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似以下输出的结果（为了显示结构而进行了缩写）：
- en: '[PRE65]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let’s look at what each section means:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个部分代表什么：
- en: '***Unknown*** —For that tick, the profiler couldn’t find a meaningful function
    attached to the pointer. These are noted in the output but aren’t much help beyond
    that and can be safely ignored.'
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***未知*** —对于那个tick，分析器无法找到与指针相关联的有意义的函数。这些在输出中都有记录，但除此之外帮助不大，可以安全忽略。'
- en: '***Shared libraries*** —These are usually underlying C++/C shared libraries;
    a lot of the I/O stuff happens here as well.'
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***共享库*** —这些通常是底层的C++/C共享库；大量的I/O操作也在这里进行。'
- en: '***JavaScript*** —This is typically the most interesting part; it includes
    your application code as well as Node and V8 internal native JavaScript code.'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***JavaScript*** —这通常是最有意思的部分；它包括你的应用程序代码以及Node和V8内部的原生JavaScript代码。'
- en: '***C++*** —This is C++ code in V8.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***C++*** —这是V8中的C++代码。'
- en: '***GC*** —This is the V8 garbage collector.'
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***GC*** —这是V8垃圾回收器。'
- en: '***Bottom up (heavy) profile*** —This shows a more detailed stack for the highest
    hitters found by the profiler.'
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***自下而上（繁重）分析*** — 这显示了分析器找到的最高调用者的更详细堆栈。'
- en: 'In our case, we can see that `*makeLoad` is the hottest JavaScript function,
    with 1997 ticks accounted for:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以看到`*makeLoad`是热点的JavaScript函数，占用了1997个tick：
- en: '[PRE66]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This makes sense since it has some heavy computation. Another interesting section
    to note is `RegExp: %[sdj%]`, which is used by `util.format`, which is used by
    `console.log`.'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '这是有意义的，因为它有一些繁重的计算。另一个值得注意的有趣部分是`RegExp: %[sdj%]`，它被`util.format`使用，而`util.format`被`console.log`使用。'
- en: The profiler’s job is to show you what functions are running most often. It
    doesn’t necessarily mean that the function is slow, but it does mean either a
    lot happens in the function or it’s called often. The results should serve as
    clues to help you understand what can be done to improve the performance. In some
    cases it may be surprising to find out certain functions are running hot; other
    times it may be expected. Profiling serves as one piece of the puzzle to help
    solve performance-related issues.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的任务是向您显示运行最频繁的函数。这并不一定意味着函数运行缓慢，但它确实意味着函数中发生了很多事情，或者它被频繁调用。结果应该作为线索，帮助您了解可以做什么来提高性能。在某些情况下，发现某些函数运行得很快可能会令人惊讶；在其他时候，这可能是预期的。分析是解决性能相关问题的谜题的一部分。
- en: Another potential source of performance-related issues is memory leaks, although,
    obviously they’re *first* a memory concern that may have performance ramifications.
    Let’s look at handling memory leaks next.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能导致性能相关问题的潜在来源是内存泄漏，尽管，显然它们首先是一个内存关注的问题，可能对性能产生影响。接下来让我们看看如何处理内存泄漏。
- en: Technique 93 Debugging memory leaks
  id: totrans-1223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 93 调试内存泄漏
- en: Before the days of Ajax and Node, there wasn’t much effort put into debugging
    JavaScript memory leaks, since page views were short-lived. But memory leaks can
    happen, especially in Node programs where a server process is expected to stay
    up and running for days, weeks, or months. How do you debug a leaking application?
    We’ll look at a technique that works locally or in production.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ajax和Node时代之前，并没有太多努力去调试JavaScript内存泄漏，因为页面浏览是短暂的。但内存泄漏可能发生，尤其是在Node程序中，服务器进程预计可以持续运行数天、数周或数月。您如何调试泄漏应用程序？我们将探讨一种在本地或生产环境中都有效的方法。
- en: Problem
  id: totrans-1225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to debug a program leaking memory.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 您想调试一个泄漏内存的程序。
- en: Solution
  id: totrans-1227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `heapdump` and Chrome DevTools.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`heapdump`和Chrome DevTools。
- en: Discussion
  id: totrans-1229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Let’s write a leaky application to demonstrate how to use a couple of tools
    to debug a memory leak. Let’s make a leak.js program:'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个泄漏应用程序来演示如何使用一些工具来调试内存泄漏。让我们创建一个leak.js程序：
- en: '![](312fig01_alt.jpg)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![312fig01_alt.jpg](312fig01_alt.jpg)'
- en: 'How do we know this application is growing in memory? We could sit and watch
    `top` or some other process-monitoring application. We can also test it by logging
    the memory used. To get an accurate read, let’s force a garbage collection before
    logging out the memory usage. Let’s add the following code to our leak.js file:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这个应用程序的内存正在增长？我们可以坐着观察`top`或其他进程监控应用程序。我们还可以通过记录内存使用来测试它。为了获得准确的读取，让我们在记录内存使用之前强制进行垃圾回收。让我们将以下代码添加到我们的leak.js文件中：
- en: '[PRE67]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In order to use the `gc()` function, we need to expose it by running our application
    with the `--expose-gc` flag:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`gc()`函数，我们需要通过运行带有`--expose-gc`标志的应用程序来暴露它：
- en: '[PRE68]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we can see some output showing clearly that we’re growing in memory usage:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到一些输出，清楚地显示我们的内存使用正在增长：
- en: '[PRE69]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Although we know we’re growing pretty steadily, we don’t really know “what”
    is leaking from this output. For that we need to take some heap snapshots and
    compare them to see what’s changing in our application. We’ll use the third-party
    `heapdump` module ([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump)).
    The `heapdump` module allows us to take snapshots either programmatically or by
    sending a signal to the process (UNIX only). These snapshots can be processed
    using the Chrome DevTools.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道我们的增长相当稳定，但我们并不真正知道从输出中“什么”正在泄漏。为此，我们需要拍摄一些堆快照，并将它们与我们的应用程序进行比较，看看有什么变化。我们将使用第三方`heapdump`模块([https://github.com/bnoordhuis/node-heapdump](https://github.com/bnoordhuis/node-heapdump))。`heapdump`模块允许我们以编程方式或通过向进程发送信号（仅限UNIX）来拍摄快照。这些快照可以使用Chrome
    DevTools进行处理。
- en: 'Let’s install the module first:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先安装这个模块：
- en: '[PRE70]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then include it in our leak.js file and instrument it to output a heap snapshot
    every 10 seconds:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其包含在我们的leak.js文件中，并对其进行配置以每10秒输出一个堆快照：
- en: '[PRE71]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, every 10 seconds a file is written to the current working directory of
    the process that contains the snapshot. A garbage collection is automatically
    performed whenever a snapshot is taken. Let’s run our application to write a couple
    snapshots and then terminate it:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每10秒钟，包含快照的进程的当前工作目录中就会写入一个文件。每次拍摄快照时都会自动执行垃圾回收。让我们运行我们的应用程序以写入几个快照然后终止它：
- en: '[PRE72]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now we can see what was written:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到写入了什么：
- en: '[PRE73]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The files are saved with their respective timestamps. The larger the number,
    the more recent the snapshot. Now we can load these files into Chrome DevTools.
    Open Chrome and then the Developer Tools, go to the Profiles tab, and right-click
    on Profiles to load a snapshot file (see [figure 11.5](#ch11fig05)).
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件以它们各自的日期时间戳保存。数字越大，快照越新。现在我们可以将这些文件加载到Chrome DevTools中。打开Chrome，然后开发者工具，转到配置文件标签页，右键单击配置文件以加载快照文件（见[图11.5](#ch11fig05)）。
- en: Figure 11.5\. Loading a heap snapshot into the Chrome DevTools
  id: totrans-1248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.5\. 将堆快照加载到Chrome DevTools中
- en: '![](11fig05_alt.jpg)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig05_alt.jpg)'
- en: To compare our two snapshots, let’s load them in the order we took them (see
    [figure 11.6](#ch11fig06)).
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较我们的两个快照，让我们按我们获取它们的顺序加载它们（见[图11.6](#ch11fig06)）。
- en: Figure 11.6\. Loading a second snapshot for comparison
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.6\. 加载第二个快照进行比较
- en: '![](11fig06_alt.jpg)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig06_alt.jpg)'
- en: Now that we have them loaded, we can do some investigation. Let’s select the
    second one and then choose the Comparison option. Chrome will automatically select
    the previous snapshot to compare to (see [figure 11.7](#ch11fig07)).
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将它们加载，我们可以进行一些调查。让我们选择第二个，然后选择比较选项。Chrome 将自动选择之前的快照进行比较（见[图11.7](#ch11fig07)）。
- en: Figure 11.7\. Using the comparison view
  id: totrans-1254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.7\. 使用比较视图
- en: '![](11fig07_alt.jpg)'
  id: totrans-1255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig07_alt.jpg)'
- en: Now we can see something immediately interesting in our view—a lot of strings
    are being created and not being garbage collected (see [figure 11.8](#ch11fig08)).
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的视图中立即看到一些有趣的东西——很多字符串被创建并且没有被垃圾回收（见[图11.8](#ch11fig08)）。
- en: Figure 11.8\. Examining memory allocations between the snapshots
  id: totrans-1257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. 检查快照之间的内存分配
- en: '![](11fig08_alt.jpg)'
  id: totrans-1258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig08_alt.jpg)'
- en: So we can see that strings could be a problem here. But what strings are getting
    created? Here we have to do some investigation. Expanding the (string) tree will
    show us the largest strings first—typically application source code and some larger
    strings used in Node core and V8\. But when we scroll down, we start to see strings
    generated in our application, and lots of them. By clicking one, we can see the
    retaining tree, or its relationship to other objects (see [figure 11.9](#ch11fig09)).
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们可以看到字符串可能在这里是个问题。但哪些字符串被创建了？在这里，我们必须做一些调查。展开（字符串）树将首先显示最大的字符串——通常是应用程序源代码和Node核心和V8中使用的某些较大的字符串。但当我们向下滚动时，我们开始看到在我们的应用程序中生成的字符串，而且很多。通过点击一个，我们可以看到保留树，或其与其他对象的关系（见[图11.9](#ch11fig09)）。
- en: Figure 11.9\. Drilling down to the types of data being created in memory
  id: totrans-1260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.9\. 深入到内存中创建的数据类型
- en: '![](11fig09_alt.jpg)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](11fig09_alt.jpg)'
- en: In this exercise, we had a hunch we were going to leak strings stored inside
    the `leaky-Arr` variable. But this exercise shows the relationship between the
    code and the tools to inspect memory usage. As a developer, you’ll know your source
    code, and the clues you get inside DevTools will be specific to your code and
    modules. The Comparison view can give a great snapshot of what’s changing.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们有一种预感，我们可能会在`leaky-Arr`变量中存储的字符串中泄漏。但这个练习显示了代码和检查内存使用工具之间的关系。作为一名开发者，你会了解你的源代码，你从DevTools中获得的线索将专门针对你的代码和模块。比较视图可以提供关于变化的精彩快照。
- en: 'We only talked about one way of creating snapshots. You can also send a SIGUSR2
    (on *NIX systems) to a process with `heapdump` to take a snapshots at will:'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只讨论了创建快照的一种方法。你还可以向带有`heapdump`的进程发送SIGUSR2（在*NIX系统上）以随意拍摄快照：
- en: '[PRE74]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Just remember that it’ll write the snapshot to the CWD of the process and will
    fail silently if the CWD isn’t writable by the process user.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，它将快照写入进程的当前工作目录，如果当前工作目录不可由进程用户写入，则将静默失败。
- en: You can also be programmatically clever, depending on your needs. For example,
    you could set up `heapdump` to take a snapshot after a certain memory threshold
    is breached, or if it grows faster than some expected limit given an interval.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求，你也可以编程地变得聪明。例如，你可以设置`heapdump`在达到某个内存阈值后或如果它以某个预期限制增长时拍摄快照。
- en: 'Taking heap snapshots is something you can do in production for a small performance
    penalty while the snapshot is being written to disk. Let’s turn our attention
    to another technique you can use in production that has a minimal penalty and
    lets you poke around at the application state: using a REPL.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在将快照写入磁盘时，你可以为生产环境中的堆快照付出一点性能代价。让我们把注意力转向另一个在生产环境中使用的技术，它具有最小的代价，并允许你检查应用程序状态：使用
    REPL。
- en: Technique 94 Inspecting a running program with a REPL
  id: totrans-1268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 94 使用 REPL 检查运行中的程序
- en: Attaching a debugger to a production process isn’t a viable option, as we don’t
    want to be pausing execution or adding a performance tax of running the V8 debugger.
    So how can we debug live or performance-sensitive issues? We can use a REPL to
    dive into the process and inspect or change state. In this technique we’ll first
    look at how a REPL works in Node, and how to set up your own REPL server and client.
    Then we’ll turn to inspecting a running process.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试器附加到生产进程不是一个可行的选项，因为我们不希望暂停执行或为运行 V8 调试器添加性能税。那么我们如何调试实时或性能敏感的问题呢？我们可以使用
    REPL 深入到进程并检查或更改状态。在这个技巧中，我们首先将查看 REPL 在 Node 中的工作方式，以及如何设置自己的 REPL 服务器和客户端。然后我们将转向检查运行中的进程。
- en: Problem
  id: totrans-1270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to interact with a running process to inspect or change its state.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 你想与一个正在运行的进程交互以检查或更改其状态。
- en: Solution
  id: totrans-1272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Set up a REPL in the process and a REPL client to access.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程中设置一个 REPL 并设置一个 REPL 客户端以访问。
- en: Discussion
  id: totrans-1274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The Node REPL is a great way to play around and experiment with JavaScript and
    Node. The simplest way to play around with a REPL is to run Node without any arguments,
    as shown in [figure 11.10](#ch11fig10).
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: Node REPL 是一种很好的方式，可以用来在 JavaScript 和 Node 中进行实验。与 REPL 一起玩耍的最简单方法是运行 Node 而不带任何参数，如图
    11.10 所示。
- en: Figure 11.10\. Sample Node REPL session
  id: totrans-1276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.10\. 样本 Node REPL 会话
- en: '![](11fig10_alt.jpg)'
  id: totrans-1277
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig10_alt.jpg)'
- en: 'But you can create your own REPLs using the built-in `repl` module. In fact,
    Node uses the same module when you type `node`. Let’s make our own REPL:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以使用内置的 `repl` 模块创建自己的 REPL。事实上，当你键入 `node` 时，Node 使用的是同一个模块。让我们创建自己的 REPL：
- en: '![](316fig01.jpg)'
  id: totrans-1279
  prefs: []
  type: TYPE_IMG
  zh: '![](316fig01.jpg)'
- en: 'Executing this program creates a REPL that looks and functions much like `node`
    does:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序创建了一个看起来和功能都与 `node` 相似的 REPL：
- en: '[PRE75]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'But we don’t need to use the process’s `stdio` for input and output; we can
    use a UNIX or a TCP socket! This allows us to connect to a long-running process
    from the outside. Let’s make a TCP REPL server:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要使用进程的 `stdio` 进行输入和输出；我们可以使用 UNIX 或 TCP 套接字！这允许我们从外部连接到长时间运行的进程。让我们创建一个
    TCP REPL 服务器：
- en: '![](317fig01_alt.jpg)'
  id: totrans-1283
  prefs: []
  type: TYPE_IMG
  zh: '![](317fig01_alt.jpg)'
- en: 'Now if we fire up our REPL server, it’ll be listening on port 1337:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们启动我们的 REPL 服务器，它将监听端口 1337：
- en: '[PRE76]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can then connect to it with a TCP client like telnet or Netcat. You can
    do this in a separate terminal window:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 TCP 客户端如 telnet 或 Netcat 连接到它。你可以在另一个终端窗口中这样做：
- en: '[PRE77]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That’s cool! But it doesn’t behave like our basic REPL (see [figure 11.11](#ch11fig11))
    or the `node` command:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 那很酷！但它不像我们的基本 REPL（见图 11.11）或 `node` 命令：
- en: Figure 11.11\. Using Netcat against a REPL server
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.11\. 使用 Netcat 对 REPL 服务器进行操作
- en: '![](11fig11_alt.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![](11fig11_alt.jpg)'
- en: The Tab key doesn’t autocomplete available properties and variables.
  id: totrans-1291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tab 键不会自动完成可用的属性和变量。
- en: We don’t have any readline support, so the Up Arrow key doesn’t give us any
    command history.
  id: totrans-1292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有 readline 支持，所以上箭头键不会给我们任何命令历史。
- en: No color or bold output.
  id: totrans-1293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有颜色或粗体输出。
- en: The reasons for this are twofold. First, the `repl` module can’t determine that
    we’re running a TTY (terminal) session, so it provides a minimal interface avoiding
    the use of ANSI/VT100 escape codes for color and formatting. These escape codes
    end up being noise to clients like Netcat. Second, our client isn’t behaving like
    a TTY. It isn’t sending the proper input codes to get nice perks like autocomplete
    behavior or history.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 原因有两个。首先，`repl` 模块无法确定我们正在运行一个 TTY（终端）会话，因此它提供了一个最小化的接口，避免了使用 ANSI/VT100 转义代码进行颜色和格式化。这些转义代码最终会成为像
    Netcat 这样的客户端的噪音。其次，我们的客户端不像 TTY。它没有发送正确的输入代码以获得诸如自动完成行为或历史记录等好处。
- en: 'In order to change this behavior, we need to modify both the server and client.
    First, to send proper ANSI/VT100 escape codes for things like color and bold output,
    we need to add the terminal option to our REPL configuration:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变这种行为，我们需要修改服务器和客户端。首先，为了发送正确的 ANSI/VT100 转义代码，例如颜色和粗体输出，我们需要将终端选项添加到我们的
    REPL 配置中：
- en: '![](318fig01.jpg)'
  id: totrans-1296
  prefs: []
  type: TYPE_IMG
  zh: '![](318fig01.jpg)'
- en: 'Second, to get the input tab completion and readline, we need to create a REPL
    client that can send the raw TTY input to the server. We can create that using
    Node:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，为了获取输入自动完成和readline，我们需要创建一个可以发送原始TTY输入到服务器的REPL客户端。我们可以使用Node创建它：
- en: '![](319fig01_alt.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![319fig01_alt.jpg](319fig01_alt.jpg)'
- en: 'Now we can start our REPL server with terminal support:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动带有终端支持的REPL服务器：
- en: '[PRE78]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can connect to the server with our REPL client in another terminal session:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在另一个终端会话中使用我们的REPL客户端连接到服务器：
- en: '[PRE79]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now our REPL session behaves as if we were running the `node` or a basic REPL.
    We can use autocomplete, access our command history, and get colored output. Sweet!
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的REPL会话表现得就像我们正在运行 `node` 或基本的REPL一样。我们可以使用自动完成功能，访问我们的命令历史，并获得彩色输出。太棒了！
- en: Inspecting a running process
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查运行中的进程
- en: We’ve discussed how to use the `repl` module to create connection points and
    use various clients to access it. We did this to get you comfortable setting up
    REPL instances on your applications so you can use them to inspect a running process.
    Now, let’s get practical and instrument an existing application with a REPL server,
    and interact with it using the REPL client we created.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用 `repl` 模块创建连接点并使用各种客户端访问它。我们这样做是为了让您熟悉在应用程序上设置REPL实例，以便您可以使用它们来检查运行中的进程。现在，让我们实际操作，使用REPL服务器仪表化现有应用程序，并使用我们创建的REPL客户端与之交互。
- en: 'First, let’s create a basic HTTP server:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个基本的HTTP服务器：
- en: '[PRE80]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This should look familiar. But let’s expose this server to our REPL server
    by adding the following code:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来应该很熟悉。但让我们通过添加以下代码将此服务器公开给我们的REPL服务器：
- en: '![](320fig01_alt.jpg)'
  id: totrans-1309
  prefs: []
  type: TYPE_IMG
  zh: '![320fig01_alt.jpg](320fig01_alt.jpg)'
- en: '|  |'
  id: totrans-1310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A note about useGlobal
  id: totrans-1311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于useGlobal的说明
- en: When enabled, whenever you create a new variable (like `var a = 1`), it will
    be put in the global context (`global.a === 1`). But `a` now will also be accessible
    in functions run in a later turn in the event loop.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，每次你创建一个新的变量（如 `var a = 1`），它将被放入全局上下文（`global.a === 1`）。但 `a` 现在也将可以在事件循环中稍后运行的函数中访问。
- en: '|  |'
  id: totrans-1313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We exposed the server by setting a property on `r.context`. We can expose anything
    we want to the REPL in order to interact with it. It’s important to note that
    we also can *override* anything already existing in the context. This includes
    all the standard Node global variables like `global`, `process`, or `Buffer`.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `r.context` 上设置属性来公开服务器。我们可以将任何我们想要公开给REPL的内容与之交互。需要注意的是，我们也可以*覆盖*上下文中已经存在的内容。这包括所有标准Node全局变量，如
    `global`、`process` 或 `Buffer`。
- en: 'Now that we have our server exposed, let’s see how we can inspect and debug
    our HTTP server. First let’s fire up our HTTP and REPL servers:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经公开了我们的服务器，让我们看看我们如何检查和调试我们的HTTP服务器。首先，让我们启动我们的HTTP和REPL服务器：
- en: '[PRE81]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now let’s use our REPL client to tap into the server:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的REPL客户端来连接到服务器：
- en: '[PRE82]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can tap into useful bits of information right away. For instance, we can
    see how long our process has been running, or how its memory usage is:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即访问有用的信息。例如，我们可以看到我们的进程运行了多长时间，或者它的内存使用情况如何：
- en: '![](320fig02.jpg)'
  id: totrans-1320
  prefs: []
  type: TYPE_IMG
  zh: '![320fig02.jpg](320fig02.jpg)'
- en: 'We also exposed the `server` object, and we can access that by just typing
    `server`:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还公开了 `server` 对象，我们可以通过简单地输入 `server` 来访问它：
- en: '[PRE83]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let’s see how many connections are currently active:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前有多少活动连接：
- en: '[PRE84]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Clearly this would be more interesting in a production context, since we are
    the only ones using the server and we haven’t made a connection yet! Let’s hit
    http://localhost:3000 in our browser and inspect the connections again and see
    if they’ve changed:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在生产环境中这会更有趣，因为我们是我们唯一使用服务器的用户，我们还没有建立连接！让我们在我们的浏览器中访问 http://localhost:3000
    并再次检查连接，看看它们是否有所变化：
- en: '![](321fig01.jpg)'
  id: totrans-1326
  prefs: []
  type: TYPE_IMG
  zh: '![321fig01.jpg](321fig01.jpg)'
- en: That works. Let’s instrument something more complex. Can you think of a way
    to start tallying the number of requests coming in to our server using the REPL?
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。让我们添加更复杂的仪表。你能想到一种方法来使用REPL开始计算进入我们服务器的请求数量吗？
- en: '|  |'
  id: totrans-1328
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Adding instrumentation
  id: totrans-1329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加仪表
- en: One powerful aspect of a REPL is the ability to add instrumentation to help
    us understand behavior in our application as it’s happening. This is especially
    handy for tricky problems where restarting the application loses our precious
    state and we have no idea how to duplicate the issue except to wait for it to
    happen again.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: REPL的一个强大功能是能够添加仪表来帮助我们理解应用程序的行为，因为它正在发生。这对于那些重启应用程序会丢失我们宝贵的状态且我们不知道如何重复问题的复杂问题特别有用。
- en: '|  |'
  id: totrans-1331
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Since our HTTP server is an `EventEmitter`, we can add another request handler
    that will be called on every request to instrument it with the behavior we want
    using the REPL:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的HTTP服务器是一个`EventEmitter`，我们可以添加另一个请求处理器，它将在每个请求上被调用，使用REPL来用我们想要的操作进行仪器化：
- en: '![](321fig02_alt.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
  zh: '![321fig02_alt.jpg](321fig02_alt.jpg)'
- en: 'Now we’re tracking incoming requests. Let’s hit Refresh a few times on our
    browser and see if it worked:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在跟踪传入的请求。让我们在我们的浏览器上刷新几次，看看是否有效：
- en: '[PRE85]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Excellent. Since we have access to the request objects, we can inspect any
    information about requests available to us: IP addresses, headers, paths, and
    so on. In this example we exposed an HTTP server, but any objects can be put on
    the context where it makes sense in your application. You may even consider writing
    a module exposing commonly used methods in the REPL.'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 极好。由于我们可以访问请求对象，我们可以检查我们可用的任何请求信息：IP地址、头部、路径等等。在这个例子中，我们暴露了一个HTTP服务器，但任何对象都可以放在你的应用程序中合适的位置。你甚至可以考虑编写一个模块，在REPL中暴露常用方法。
- en: Some issues can’t be resolved at an application level and need deeper system
    introspection. One way to gain deeper understanding is by tracing.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题不能在应用层面解决，需要更深入的系统检查。通过追踪获得更深入理解的一种方法。
- en: Technique 95 Tracing system calls
  id: totrans-1338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧95 追踪系统调用
- en: Understanding how the underlying system calls work can really help you understand
    a platform. For example, Python and Node both have functionality to perform DNS
    lookups, but they go about it differently at a lower level. And if you’re wondering
    why one is behaving differently than the other, tracing tools will show you that!
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 理解底层系统调用的工作原理可以帮助你真正理解一个平台。例如，Python和Node都具备执行DNS查找的功能，但在底层它们采取的方法不同。如果你想知道为什么一个的行为与另一个不同，追踪工具会向你展示这一点！
- en: At their core, tracing tools monitor underlying system calls (typically C function
    names, arguments, and return values) that an application or multiple applications
    are making, and do interesting things with the data (like logging or statistics).
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，追踪工具监控应用程序或多个应用程序正在进行的底层系统调用（通常是C函数名称、参数和返回值），并对数据进行有趣的处理（如记录或统计）。
- en: Tracing helps in production. If you have a process stuck at 100% and are unsure
    why, a tracer can help expose the underlying state at the system level. For example,
    you may discover in this instance that you exceeded the allowed open files for
    a process, and all I/O attempts are being rejected, causing the problem. Since
    tracing tools aren’t performance intrusive like a profiler, they can be valuable
    assets.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪有助于生产。如果你有一个进程卡在100%并且不确定原因，追踪器可以帮助暴露系统级别的底层状态。例如，你可能在这个例子中发现你超出了进程允许的打开文件数，所有I/O尝试都被拒绝，导致问题发生。由于追踪工具不像分析器那样影响性能，它们可以成为宝贵的资产。
- en: Problem
  id: totrans-1342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to understand what’s happening in your application at the system level.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 你想了解你的应用程序在系统层面的发生情况。
- en: Solution
  id: totrans-1344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use tracing tools specific to the operating system to gain introspection.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用针对操作系统的特定追踪工具进行深入检查。
- en: Discussion
  id: totrans-1346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'All the techniques we’ve discussed so far have been system-agnostic. This one
    is OS-specific. There are a lot of different tools, but most are unique to an
    operating system. For our example, we’ll use the Linux-specific tool called `strace`.
    Similar tools exists for Mac OS X/Solaris (`dtruss`) and Windows (`ProcessMonitor`:
    [http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx](http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx)).'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的所有技术都是系统无关的。这个是针对操作系统的。有很多不同的工具，但大多数都是特定于操作系统的。在我们的例子中，我们将使用名为`strace`的Linux特定工具。类似工具也存在于Mac
    OS X/Solaris（`dtruss`）和Windows（`ProcessMonitor`：[http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx](http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx))）。
- en: A tracing program is essentially a dump of system calls as they happen in a
    process. If you’re unfamiliar with the underlying OS, prepare to learn! We’ll
    walk through tracing a simple application to see what’s happening at the OS level
    when we run it to learn how to read trace logs.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪程序本质上是在进程中进行系统调用的转储。如果你对底层操作系统不熟悉，准备学习吧！我们将通过追踪一个简单的应用程序来了解当我们运行它时在操作系统层面发生了什么，以学习如何阅读追踪日志。
- en: 'Let’s write an extremely simple program to trace:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个极其简单的程序来追踪：
- en: '[PRE86]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This seems innocent enough. To see what’s going on behind the scenes, let’s
    trace this:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来足够无辜。为了看到幕后发生的事情，让我们追踪这个：
- en: '[PRE87]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You’ll see the program output “hello world” and exit as expected. But we also
    got a dump of every system call in trace.out. Let’s examine that file.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到程序输出“hello world”并按预期退出。但我们也得到了trace.out中每个系统调用的转储。让我们检查那个文件。
- en: 'Right at the top we can see our first call, which makes sense. We’re executing
    `/usr/bin/node`, passing it the arguments `node` and `hello`:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们可以看到我们的第一个调用，这是有意义的。我们正在执行`/usr/bin/node`，传递给它`node`和`hello`参数：
- en: '[PRE88]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If you ever wondered why `process.argv[0]` is `node` and `process.argv[1]` is
    the path to our Node program, now you can see how the underlying call is being
    made! The `strace` output tells us the arguments passed and the return value.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经想知道为什么`process.argv[0]`是`node`，`process.argv[1]`是我们Node程序的路径，现在你可以看到底层调用是如何进行的！`strace`输出告诉我们传递的参数和返回值。
- en: 'To find more information about what `execve` is (and any other system call),
    we can just look at the `man` pages on the host if available (best option), or
    if not, look online:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`execve`是什么（以及任何其他系统调用）的信息，如果可用，我们只需查看主机上的`man`页面（最佳选项），或者如果不可用，在网上查找：
- en: '[PRE89]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '|  |'
  id: totrans-1359
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: More on man command
  id: totrans-1360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更多关于man命令的信息
- en: Manual pages also include error codes that are helpful to get more details on,
    for example, what ENOENT or EPERM mean on an operating system. Many of these error
    codes can be found in the `openman` page.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页还包括一些有用的错误代码，例如，在操作系统上ENOENT或EPERM代表什么。许多这些错误代码可以在`openman`页面上找到。
- en: '|  |'
  id: totrans-1362
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s examine more of this file. Many of the initial calls are loading the
    shared libraries `libuv` needs. Then we get to our application:'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步检查这个文件。许多初始调用是加载`libuv`需要的共享库。然后我们到达我们的应用程序：
- en: '[PRE90]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We can see Node grabbing the current working directory and then looking up our
    file to run. Note that we executed our application *without* the .js extension,
    so Node first looks for a program called “hello” and doesn’t find it, and then
    looks for hello.js and is successful. If we were to run it with the .js extension,
    you wouldn’t see the first stat call.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Node获取当前工作目录，然后查找要运行的文件。注意，我们没有使用.js扩展名来执行我们的应用程序，所以Node首先查找名为“hello”的程序，但没有找到，然后查找hello.js并成功。如果我们使用.js扩展名运行它，你就不会看到第一个stat调用。
- en: 'Let’s look at the next interesting bit:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个有趣的片段：
- en: '[PRE91]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here we `open` the hello.js file in read-only mode and get assigned a file descriptor.
    File descriptors are just integers assigned by the OS. But to understand the subsequent
    calls, we should take note that `9` is the number assigned for hello.js until
    we see a subsequent `close` call.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以只读模式打开hello.js文件并分配一个文件描述符。文件描述符是由操作系统分配的整数。但为了理解后续的调用，我们应该注意，`9`是hello.js的分配号，直到我们看到随后的`close`调用。
- en: After `open`, we then see an `fstat` to get the file’s size. Then we read the
    contents of the file in the `read` line. The `strace` output also shows us the
    contents of the buffer we used to store the file. We then `close` the file descriptor.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`open`之后，我们接着看到一个`fstat`来获取文件的大小。然后我们在`read`行中读取文件的内容。`strace`输出还显示了我们用来存储文件的缓冲区内容。然后我们关闭文件描述符。
- en: 'A trace output file won’t show us any application code being run. We just see
    the system *effects* of what’s being run. That is, we won’t see V8 parsing or
    executing our `console.log` but we’ll see the underlying write out to `stdout`.
    Let’s look at that next:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪输出文件不会显示正在运行的应用程序代码。我们只看到正在运行的系统*效果*。也就是说，我们不会看到V8解析或执行我们的`console.log`，但我们会看到底层的写入到`stdout`。让我们看看下一个：
- en: '[PRE92]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Recall from [chapter 6](kindle_split_015.html#ch06) that every process has three
    file descriptors automatically assigned for stdin (0), stdout (1), and stderr
    (2). We can see that this `write` call uses stdout (1) to write out `hello world`.
    We also see that `console.log` appends a newline for us.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](kindle_split_015.html#ch06)，每个进程都有三个自动分配的文件描述符，分别是stdin（0）、stdout（1）和stderr（2）。我们可以看到这个`write`调用使用stdout（1）来写入`hello
    world`。我们还看到`console.log`为我们添加了换行符。
- en: 'Our program eventually exits on the last line of `trace.out`:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序最终在`trace.out`的最后一行退出：
- en: '[PRE93]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The zero (0) here represents the process exit code. In this case it’s successful.
    If we were to exit with `process.exit(1)` or some other status, we’d see that
    number reflected here.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的零（0）代表进程退出代码。在这种情况下，它是成功的。如果我们使用`process.exit(1)`或其他状态退出，我们会看到这个数字在这里反映出来。
- en: Tracing a running process
  id: totrans-1376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跟踪运行中的进程
- en: So far we’ve used `strace` to start and trace a program till it exits. How about
    tapping into a running process?
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`strace`启动并跟踪了一个程序，直到它退出。那么，如何连接到一个正在运行的进程呢？
- en: 'Here we can just grab the PID for the process:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需获取进程的PID：
- en: '[PRE94]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The first number in the row is our PID:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 行首的第一个数字是我们的PID：
- en: '[PRE95]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Once we have our PID, we can run `strace` against it:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的进程ID（PID），我们就可以对它运行`strace`：
- en: '[PRE96]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: All the currently running system calls will output to the console.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当前运行的系统调用都将输出到控制台。
- en: 'This can be a great first line of defense when debugging live issues where
    CPU is pegged. For example, if we’ve exceeded our `ulimit` for a process, this
    will typically peg our CPU, since `open` system calls continually will fail. Running
    `strace` on the process would quickly show a bunch of `ENFILE` errors occurring.
    And from the `openman` page, we can see a nice entry for the error:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 这在调试CPU被卡住的实时问题时可以作为一个很好的第一道防线。例如，如果我们超出了进程的`ulimit`，这通常会导致CPU被卡住，因为`open`系统调用会不断失败。在进程上运行`strace`会迅速显示大量的`ENFILE`错误。并且从`openman`页面，我们可以看到一个关于错误的良好条目：
- en: '[PRE97]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '|  |'
  id: totrans-1387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing open files
  id: totrans-1388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列出打开的文件
- en: In this case, we can use another handy Linux tool called `lsof` to get a list
    of open files for a process given a PID to further investigate what we have open
    right now.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们可以使用另一个实用的Linux工具`lsof`，通过PID获取一个进程打开的文件列表，以便进一步调查我们现在打开了什么。
- en: '|  |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'We can also get a CPU pegged at 100% and open up `strace` and see just the
    following repeating over and over:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以让CPU达到100%并打开`strace`，然后你会看到以下内容反复出现：
- en: '[PRE98]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This, for the most part, is just event loop noise, and it’s likely that your
    application code is stuck in an infinite loop somewhere. Tools like `node --prof`
    would help at this point.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分只是事件循环的噪音，很可能你的应用程序代码在某处陷入了无限循环。像`node --prof`这样的工具在这种情况下会有所帮助。
- en: About other operating system tools
  id: totrans-1394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于其他操作系统工具
- en: The actual system calls we looked at will be different on other operating systems.
    For example, you’ll see `epoll` calls being made on Linux that you won’t ever
    see on Mac OS X because `libuv` uses `kqueue` for Mac. Although most OSes have
    POSIX methods like `open`, the function signatures and error codes can vary. Get
    to understand the machines you host and develop your Node applications on to make
    best use of the tracing tools!
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的实际系统调用在其他操作系统上可能会有所不同。例如，你会在Linux上看到`epoll`调用，你永远不会在Mac OS X上看到，因为`libuv`在Mac上使用`kqueue`。尽管大多数操作系统都有POSIX方法，如`open`，但函数签名和错误代码可能会有所不同。了解你托管和开发Node应用程序的机器，以便最好地使用跟踪工具！
- en: '|  |'
  id: totrans-1396
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Homework!
  id: totrans-1397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 家庭作业！
- en: Make a simple HTTP server and trace it. Can you find out where the port is being
    bound, where connections are being accepted, and where responses are being written
    back to the client?
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个简单的HTTP服务器并跟踪它。你能找出端口在哪里被绑定，连接在哪里被接受，以及响应在哪里写回客户端吗？
- en: '|  |'
  id: totrans-1399
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.3\. Summary
  id: totrans-1400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3. 摘要
- en: 'In this chapter we looked at debugging Node applications. First, we focused
    on error handling and prevention:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了调试Node应用程序。首先，我们专注于错误处理和预防：
- en: How do you handle errors that your application generates?
  id: totrans-1402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是如何处理应用程序生成的错误的？
- en: How are you notified about crashes? Do you have domains set up or an `uncaughtException`
    handler?
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是如何被通知崩溃的？你是否设置了域名或`uncaughtException`处理程序？
- en: Are you using a lint tool to help prevent exceptions?
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否在使用lint工具来帮助防止异常？
- en: 'Then, we focused on debugging specific problems. We used various tools available
    in Node and third-party modules. The big thing to take away is knowing the right
    tool for the job, so when a problem arises, you can assess it and gain useful
    information:'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们专注于调试特定问题。我们使用了Node和第三方模块中可用的各种工具。重要的是要知道正确的工具，这样当问题出现时，你可以评估它并获得有用的信息：
- en: Do you need to be able to set breakpoints, watch expressions, and step through
    your code? Use the built-in `debug` command or `node-inspector`.
  id: totrans-1406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要能够设置断点、监视表达式和逐步执行你的代码吗？使用内置的`debug`命令或`node-inspector`。
- en: Do you need to see where your application is spending its time? Use the Node
    built-in profiler (`node --prof`).
  id: totrans-1407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要查看你的应用程序在哪里花费时间吗？使用Node内置的剖析器（`node --prof`）。
- en: Is your application using more memory than expected? Take heap snapshots and
    inspect the results.
  id: totrans-1408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序是否使用了比预期更多的内存？请获取堆快照并检查结果。
- en: Do you want to investigate a running process without pausing it or incurring
    a performance penalty? Set up and use a REPL server.
  id: totrans-1409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想在不停机或不受性能影响的情况下调查一个正在运行的过程吗？设置并使用REPL服务器。
- en: Do you want to see what underlying system calls are being made? Use your operating
    system’s tracing tools.
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想查看正在进行的系统调用吗？使用你的操作系统的跟踪工具。
- en: In the next chapter we’ll dive into writing web applications with Node!
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用Node编写Web应用程序！
- en: 'Chapter 12\. Node in production: Deploying applications safely'
  id: totrans-1412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章\. Node在生产环境中的部署：安全部署应用程序
- en: '*This chapter covers*'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Deploying Node applications to your own server
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Node应用程序部署到自己的服务器
- en: Deploying Node applications to cloud providers
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Node应用程序部署到云提供商
- en: Managing packages for production
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理生产环境中的包
- en: Logging
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Scaling with proxies and cluster
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理和集群进行扩展
- en: Once you’ve built and tested a Node application, you’ll want to release it.
    Popular PaaS (platform as a service) providers like Heroku and Nodejitsu make
    deployment simple, but you can also deploy to private servers. Once your code
    is out there, you’ll need to cope with unexpected errors, service outages, and
    bugs, and monitor performance.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建并测试了Node应用程序，你将希望发布它。像Heroku和Nodejitsu这样的流行PaaS（平台即服务）提供商使部署变得简单，但你也可以部署到私有服务器。一旦你的代码发布出去，你将需要应对意外错误、服务中断和错误，并监控性能。
- en: This chapter shows you how to safely release and maintain Node programs. It
    covers privately hosted servers that use Apache and nginx, WebSockets, horizontal
    scaling, automated deployment, logging, and ways to boost performance.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示如何安全地发布和维护Node程序。它涵盖了使用Apache和nginx的私有托管服务器、WebSockets、水平扩展、自动化部署、记录以及提高性能的方法。
- en: 12.1\. Deployment
  id: totrans-1421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 部署
- en: In this section you’ll learn how to deploy Node applications to popular cloud
    providers and your own private servers. It’s likely that you’ll only typically
    use one of these approaches, depending on the requirements of your application
    or employer, but being familiar with both is instructive. For example, the Git-based
    workflow employed by Heroku has influenced how people deploy applications to servers
    they control, and with a bit of knowledge you can set up a server without having
    to call for help from a DevOps specialist.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将Node应用程序部署到流行的云提供商和自己的私有服务器。根据你应用程序或雇主的要求，你可能只会使用这些方法之一，但了解两者都是有益的。例如，Heroku采用的基于Git的工作流程已经影响了人们将应用程序部署到他们控制的服务器上的方式，只要有一点知识，你就可以设置服务器而无需从DevOps专家那里寻求帮助。
- en: The first technique we cover is based on Windows Azure, Heroku, and Nodejitsu.
    This is probably the easiest way to deploy web applications today, and cloud providers
    have free plans that make it cheap and painless to share your work.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍的技术基于Windows Azure、Heroku和Nodejitsu。这可能是今天部署Web应用程序最简单的方法，云提供商提供了免费计划，使共享你的工作变得便宜且痛苦。
- en: Technique 96 Deploying Node applications to the cloud
  id: totrans-1424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧96 将Node应用程序部署到云
- en: This technique outlines how to use Node with PaaS providers, and has tips on
    how to configure and maintain applications in production. The focus is on the
    practical aspects of deployment and maintenance, rather than pricing or business
    models.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术概述了如何使用Node与PaaS提供商，并提供了如何在生产环境中配置和维护应用程序的技巧。重点是部署和维护的实用方面，而不是定价或商业模式。
- en: You can try out Heroku and Azure for free, so follow along if you’ve ever wanted
    to run a Node application in the cloud.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以免费试用Heroku和Azure，所以如果你曾经想在云中运行Node应用程序，就跟随操作。
- en: Problem
  id: totrans-1427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve built a Node web application and want to run it on servers so people
    can use it.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经构建了一个Node Web应用程序，并希望将其运行在服务器上供人们使用。
- en: Solution
  id: totrans-1429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a PaaS provider like Heroku or Nodejitsu.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Heroku或Nodejitsu这样的PaaS提供商。
- en: Discussion
  id: totrans-1431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'We’ll look at three options for cloud deployment: Nodejitsu, Heroku, and Windows
    Azure. All of these services allow you to deploy Node web applications, but they
    all handle things slightly differently. The methods for uploading an application
    and configuring it vary, even though the fundamental concepts are the same.'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种云部署选项：Nodejitsu、Heroku和Windows Azure。所有这些服务都允许你部署Node Web应用程序，但它们处理事情的方式略有不同。上传应用程序和配置应用程序的方法不同，尽管基本概念是相同的。
- en: Nodejitsu is an interesting case because it’s dedicated to Node. On the other
    hand, Windows Azure supports Microsoft’s software development tools, programming
    languages, and databases. Azure even has features beyond web application hosting,
    like databases and Active Directory integration. Heroku draws on a rich community
    of partners that offers add-ons, whereas Azure is more of a full-service offering.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: Nodejitsu是一个有趣的案例，因为它专注于Node。另一方面，Windows Azure支持微软的软件开发工具、编程语言和数据库。Azure甚至具有超越Web应用程序托管的功能，如数据库和Active
    Directory集成。Heroku则依赖于一个丰富的合作伙伴社区，提供附加组件，而Azure则更像是一个全面服务提供。
- en: If you look in the source code provided with this book, you should find a small
    Express application in production/inky. This is the application we used to research
    this technique, and you can use it as a sample application to try each service
    provider. Nodejitsu and Azure’s documentation includes examples based on Node’s
    `http` module, but you really need something with a package.json to see how things
    work for typical Node applications.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看本书提供的源代码，您应该在production/inky中找到一个小的Express应用程序。这是我们用来研究这项技术的应用程序，您可以用它作为示例应用程序来尝试每个服务提供商。Nodejitsu和Azure的文档包括基于Node的`http`模块的示例，但您真的需要有一个包含package.json的示例来了解典型Node应用程序的工作方式。
- en: The first service provider we’ll look at is Nodejitsu ([https://www.nodejitsu.com/](https://www.nodejitsu.com/)).
    Nodejitsu is based in New York, and has data centers in North America and Western
    Europe. Nodejitsu was founded in 2010, and has funding from the Bloomberg Beta
    fund.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个服务提供商是Nodejitsu ([https://www.nodejitsu.com/](https://www.nodejitsu.com/))。Nodejitsu总部位于纽约，在北美和西欧设有数据中心。Nodejitsu成立于2010年，并得到了Bloomberg
    Beta基金的支持。
- en: To get started with Nodejitsu, you’ll need to register an account. Go to Nodejitsu.com
    and sign up. You can sign up without selecting a pricing plan if you intend to
    release an open source project through Nodejitsu.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Nodejitsu，您需要注册一个账户。访问Nodejitsu.com并注册。如果您打算通过Nodejitsu发布开源项目，可以不选择定价计划进行注册。
- en: Nodejitsu has a command-line client called `jitsu`. You can install it with
    `npm install -g jitsu`. Once npm has finished, you’ll need to sign in—type `jitsu
    login` and enter your username and password. This will save an API token to a
    file called ~/.jitsuconf, so your password won’t be stored locally. [Figure 12.1](#ch12fig01)
    shows what this process looks like in the terminal.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: Nodejitsu有一个名为`jitsu`的命令行客户端。您可以使用`npm install -g jitsu`来安装它。一旦npm完成安装，您需要登录——输入`jitsu
    login`并输入您的用户名和密码。这将保存一个API令牌到一个名为~/.jitsuconf的文件中，这样您的密码就不会在本地存储。[图12.1](#ch12fig01)
    展示了在终端中这个过程的样子。
- en: Figure 12.1\. The `jitsu` command-line client allows you to sign in.
  id: totrans-1438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. `jitsu`命令行客户端允许您登录。
- en: '![](12fig01_alt.jpg)'
  id: totrans-1439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig01_alt.jpg)'
- en: To deploy an application, type `jitsu deploy`. The `jitsu` command will prompt
    with questions about your application, and then set it up to run on a temporary
    subdomain. If you’re using an Express application, it’ll automatically set `NODE_ENV`
    to production, but you can edit this setting along with other environmental variables
    in the web interface. In fact, the web interface can do most of the things the
    `jitsu` command does, which means you don’t necessarily need a developer on hand
    to do basic maintenance chores like restarting applications.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署一个应用程序，输入`jitsu deploy`。`jitsu`命令将提示您有关应用程序的问题，然后将其设置为在临时子域上运行。如果您使用的是Express应用程序，它将自动将`NODE_ENV`设置为生产环境，但您可以在Web界面中编辑此设置以及其他环境变量。实际上，Web界面可以完成`jitsu`命令的大部分功能，这意味着您不一定需要一个开发者来执行基本维护任务，如重启应用程序。
- en: '[Figure 12.2](#ch12fig02) shows a preview of Nodejitsu’s web interface, which
    is called *WebOps*. It allows you to stop and start applications, manage environmental
    variables, roll back to earlier versions of your application, and even stream
    logs in real time.'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.2](#ch12fig02) 展示了Nodejitsu的Web界面预览，该界面被称为*WebOps*。它允许您停止和启动应用程序，管理环境变量，回滚到应用程序的早期版本，甚至实时流式传输日志。'
- en: Figure 12.2\. The WebOps management interface
  id: totrans-1442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. WebOps管理界面
- en: '![](12fig02_alt.jpg)'
  id: totrans-1443
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig02_alt.jpg)'
- en: Unsurprisingly Nodejitsu is heavily tailored toward Node applications, and the
    deployment process is heavily influenced by npm. If you have a strong grasp of
    npm and package.json files, and your projects are all Node applications, then
    you’ll feel at home with Nodejitsu.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Nodejitsu主要针对Node应用程序进行了优化，部署过程也受到了npm的强烈影响。如果您对npm和package.json文件有深入了解，并且您的项目都是Node应用程序，那么您在Nodejitsu上会感到宾至如归。
- en: Another PaaS solution that’s popular with Node developers is Heroku. Heroku
    supports several programming languages and platforms, including Node, and was
    founded in 2007\. It has since been acquired by Salesforce.com, and uses a virtualized
    solution based on Ubuntu servers. To use Heroku, you’ll need to sign up at heroku
    .com. It’s easy to create a free account, and you can even run production applications
    on the free tier. Essential features like domain aliases and SSL are paid, so
    it doesn’t take many requirements to hit around $20 a month, but if you don’t
    mind using a Heroku subdomain, you can keep things running for free.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个受 Node 开发者欢迎的 PaaS 解决方案是 Heroku。Heroku 支持多种编程语言和平台，包括 Node，成立于 2007 年。自那以后，它已被
    Salesforce.com 收购，并使用基于 Ubuntu 服务器的虚拟化解决方案。要使用 Heroku，你需要在 heroku.com 上注册。创建免费账户很容易，你甚至可以在免费层上运行生产应用程序。像域名别名和
    SSL 这样的基本功能是付费的，所以不需要太多要求就能达到每月约 20 美元，但如果你不介意使用 Heroku 子域名，你可以免费运行。
- en: Once you’ve created an account, you’ll need to install the Heroku Toolbelt from
    toolbelt.heroku.com. There are installers for Linux, Mac OS X, and Windows. Once
    you’ve installed it, you’ll have a command-line client called `heroku` that can
    be used to create and manage applications. Before you can use it, you’ll have
    to sign in; `heroku login` can be used to do this, and functions in much the same
    way as Nodejitsu’s `jitsu` command. You only need to log in once because it stores
    a token that will be used for subsequent requests. [Figure 12.3](#ch12fig03) shows
    what this should look like.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了账户，你将需要从 toolbelt.heroku.com 安装 Heroku Toolbelt。它提供了 Linux、Mac OS X 和
    Windows 的安装程序。安装完成后，你将拥有一个名为 `heroku` 的命令行客户端，可以用来创建和管理应用程序。在使用它之前，你必须登录；可以使用
    `heroku login` 来完成登录，它的工作方式与 Nodejitsu 的 `jitsu` 命令非常相似。你只需要登录一次，因为它会存储一个用于后续请求的令牌。[图
    12.3](#ch12fig03) 展示了它应该看起来是什么样子。
- en: Figure 12.3\. Signing in with Heroku
  id: totrans-1447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 使用 Heroku 登录
- en: '![](12fig03_alt.jpg)'
  id: totrans-1448
  prefs: []
  type: TYPE_IMG
  zh: '![12fig03_alt.jpg](12fig03_alt.jpg)'
- en: 'The next step with a Heroku deploy is to prepare your repository. You’ll need
    to `git init` and commit your project. If you’re using our code samples and have
    checked them out of Git, then you should copy the specific project that you want
    to deploy out of our working tree. The full steps are as follows:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Heroku 部署的下一步是准备你的仓库。你需要执行 `git init` 并提交你的项目。如果你正在使用我们的代码示例并且已经从 Git 中检出，那么你应该将你想要部署的具体项目从我们的工作树中复制出来。完整的步骤如下：
- en: '**1**.  `git init`'
  id: totrans-1450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  `git init`'
- en: '**2**.  `git add.`'
  id: totrans-1451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  `git add.`'
- en: '**3**.  `git commit -m ''Create new project''`'
  id: totrans-1452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  `git commit -m ''Create new project''`'
- en: '**4**.  `heroku create`'
  id: totrans-1453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  `heroku create`'
- en: '**5**.  `git push heroku master`'
  id: totrans-1454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  `git push heroku master`'
- en: The `heroku create` command sets up a remote repository called `heroku`, and
    the first `git push` to it will trigger the creation of a temporary `herokuapp.com`
    subdomain.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '`heroku create` 命令设置了一个名为 `heroku` 的远程仓库，并且第一次向其推送 `git push` 将触发创建一个临时的 `herokuapp.com`
    子域名。'
- en: 'If your application can be started with `npm start`, it should just work. If
    not, you might need to add a file called Procfile to your application that contains
    `web: node yourapp.js`. This file lists the processes that your application needs
    to run—it could include background workers as well.'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你的应用程序可以通过 `npm start` 启动，它应该就能正常工作。如果不能，你可能需要在应用程序中添加一个名为 Procfile 的文件，该文件包含
    `web: node yourapp.js`。此文件列出了应用程序需要运行的过程——它可能包括后台工作进程。'
- en: If you’re using an Express application that expects `NODE_ENV` to be set, then
    you’ll need to do this manually with Heroku. The command is just `heroku config:set
    NODE_ENV=production`, but notice that this is automatic with Nodejitsu.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个期望 `NODE_ENV` 被设置的 Express 应用程序，那么你需要手动使用 Heroku 来做这件事。命令是 `heroku
    config:set NODE_ENV=production`，但请注意，这在使用 Nodejitsu 时是自动完成的。
- en: The last PaaS provider we’ll discuss is Windows Azure. Microsoft’s Azure platform
    can be used entirely through the web interface, but there’s also a command-line
    interface that you can install with `npm install -g azure-cli`. [Figure 12.4](#ch12fig04)
    shows what the command-line tool looks like.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一家 PaaS 提供商是 Windows Azure。Microsoft 的 Azure 平台可以通过完全的 Web 界面使用，但还有一个可以通过
    `npm install -g azure-cli` 安装的命令行界面。[图 12.4](#ch12fig04) 展示了命令行工具的外观。
- en: Figure 12.4\. The Azure CLI tool
  id: totrans-1459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.4\. Azure CLI 工具
- en: '![](12fig04_alt.jpg)'
  id: totrans-1460
  prefs: []
  type: TYPE_IMG
  zh: '![12fig04_alt.jpg](12fig04_alt.jpg)'
- en: Azure also has an SDK that you can download for Linux, Mac OS X, and Windows.
    The downloads are available at [www.windowsazure.com/en-us/downloads/](http://www.windowsazure.com/en-us/downloads/).
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 也提供了适用于 Linux、Mac OS X 和 Windows 的 SDK 下载。下载可在 [www.windowsazure.com/en-us/downloads/](http://www.windowsazure.com/en-us/downloads/)
    找到。
- en: 'To start using Azure, you’ll need to sign in to [www.windowsazure.com](http://www.windowsazure.com)
    with a Microsoft account. This is the same account that you can use for other
    Microsoft services, so if you already have an email account with Microsoft, you
    should be able to sign in. Azure’s registration process has extra security steps:
    a credit card and phone number are used to validate your account, so it’s a bit
    more tedious than Heroku or Nodejitsu.'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Azure，你需要使用Microsoft账户登录到[www.windowsazure.com](http://www.windowsazure.com)。这个账户你也可以用于其他Microsoft服务，所以如果你已经有Microsoft的电子邮件账户，你应该能够登录。Azure的注册流程有额外的安全步骤：使用信用卡和电话号码来验证你的账户，所以它比Heroku或Nodejitsu稍微繁琐一些。
- en: Once you’ve created your Windows Azure account, you’ll want to go to the Portal
    page. Next go to *Compute*, *Web Site*, and then *Quick Create*. Just keep in
    mind that you’re creating a “Web Site” and you should be fine—Microsoft supports
    a wide range of services that are partly tailored to .NET development with their
    existing tools like Visual Studio, so it can be bewildering for Mac and Unix developers.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了Windows Azure账户，你将想要访问门户页面。接下来，转到*计算*，*网站*，然后*快速创建*。只需记住你正在创建一个“网站”，你应该没问题——Microsoft支持广泛的与他们的现有工具（如Visual
    Studio）部分定制的服务，这些服务针对.NET开发，所以对于Mac和Unix开发者来说可能会令人困惑。
- en: Once your application has been created, you’ll need to tie it to a source control
    repository. Don’t worry, you can use GitHub! Before we go any further, check that
    you’re looking at a page like the one in [figure 12.5](#ch12fig05).
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用程序创建完成，你需要将其与源代码控制仓库关联起来。别担心，你可以使用GitHub！在我们继续之前，请确认你正在查看类似[图12.5](#ch12fig05)的页面。
- en: Figure 12.5\. Azure’s web interface after creating a website
  id: totrans-1465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.5\. 创建网站后Azure的Web界面
- en: '![](12fig05_alt.jpg)'
  id: totrans-1466
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig05_alt.jpg)'
- en: '|  |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Cloud configuration**'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '**云配置**'
- en: PaaS providers all seem to have their own approaches to application configuration.
    You can, of course, keep configuration settings in your code, or JSON files, but
    there are times when it’s useful to store them outside of your repository.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS提供商似乎都有自己的应用程序配置方法。当然，你可以将配置设置保存在你的代码或JSON文件中，但有时将它们存储在仓库之外是有用的。
- en: For example, we build open source web applications that we also run on Heroku,
    so we keep our database passwords outside of our open source repository and use
    `heroku config:set` instead.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们构建开源Web应用程序，我们也在Heroku上运行它们，因此我们将数据库密码保存在开源仓库之外，并使用`heroku config:set`代替。
- en: '|  |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Click your application’s name, select *Set up deployment from source control*,
    and then look for *site URL* on the right side. From here you’ll be able to choose
    from a huge range of repositories and service providers, but we tested our application
    with GitHub. Azure fetched the code and set up a Node application—it was the same
    Express code that we used for Heroku (listings/production/inky), and worked the
    first time.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 点击你的应用程序名称，选择*从源代码控制设置部署*，然后在右侧查找*站点URL*。从这里，你将能够从大量的仓库和服务提供商中进行选择，但我们使用GitHub测试了我们的应用程序。Azure抓取了代码并设置了一个Node应用程序——它是我们在Heroku上使用的相同Express代码（listings/production/inky），并且第一次就成功了。
- en: '[Table 12.1](#ch12table01) shows how to get and set configuration values on
    each of the cloud providers we’ve discussed here.'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12.1](#ch12table01)展示了如何在讨论的每个云提供商上获取和设置配置值。'
- en: Table 12.1\. Setting environmental variables
  id: totrans-1474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1\. 设置环境变量
- en: '| Provider | Set | Remove | List |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '| 提供商 | 设置 | 移除 | 列表 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Nodejitsu | jitsu env set name value | jitsu env delete name | jitsu env
    list |'
  id: totrans-1477
  prefs: []
  type: TYPE_TB
  zh: '| Nodejitsu | jitsu env set name value | jitsu env delete name | jitsu env
    list |'
- en: '| Heroku | heroku config:set name=value | heroku config:unset name | heroku
    config |'
  id: totrans-1478
  prefs: []
  type: TYPE_TB
  zh: '| Heroku | heroku config:set name=value | heroku config:unset name | heroku
    config |'
- en: '| Azure | azure site appsetting add name=value | azure site appsetting delete
    name | azure site appsetting list |'
  id: totrans-1479
  prefs: []
  type: TYPE_TB
  zh: '| Azure | azure site appsetting add name=value | azure site appsetting delete
    name | azure site appsetting list |'
- en: 'Although Azure’s registration requirements might seem less convenient than
    Heroku and Nodejitsu, it does have several benefits: if you’re working with .NET,
    then you can use your existing tools. Also, Microsoft’s documentation is excellent,
    and includes guides on setup and deploying for Linux and Mac OS X ([http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-develop-deploy-mac/](http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-develop-deploy-mac/)).'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Azure的注册要求可能看起来不如Heroku和Nodejitsu方便，但它确实有一些好处：如果你在使用.NET，那么你可以使用你现有的工具。此外，微软的文档非常出色，包括Linux和Mac
    OS X的设置和部署指南([http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-develop-deploy-mac/](http://www.windowsazure.com/en-us/documentation/articles/web-sites-nodejs-develop-deploy-mac/))。
- en: Your own servers, rented servers, or cheap virtual hosts all have their own
    advantages. If you want complete control over your server, or if your business
    already has its own servers or data centers, then read on to learn how to deploy
    Node to your own servers.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己的服务器、租用的服务器或便宜的虚拟主机都有它们自己的优势。如果你想完全控制你的服务器，或者如果你的企业已经拥有自己的服务器或数据中心，那么请继续阅读，了解如何将Node部署到你的服务器上。
- en: Technique 97 Using Node with Apache and nginx
  id: totrans-1482
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧97 使用Apache和nginx与Node结合
- en: Deploying Node to private servers running Apache or nginx is entirely possible,
    and recommended for certain situations. This technique demonstrates how to run
    a Node program behind Apache and nginx.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 将Node部署到运行Apache或nginx的私有服务器上是完全可能的，并且在某些情况下是推荐的。这种技术展示了如何在Apache和nginx后面运行Node程序。
- en: Problem
  id: totrans-1484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run a Node web application on your own server.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在你的服务器上运行一个Node Web应用程序。
- en: Solution
  id: totrans-1486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Apache or nginx proxying and a service supervisor like runit.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Apache或nginx代理和像runit这样的服务管理器。
- en: Discussion
  id: totrans-1488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: While PaaS solutions are easy to use, there are times when you have to use dedicated
    hardware, or virtual machines that you have full control over. Larger businesses
    often have investments in their own data centers, so it doesn’t make sense to
    switch to an external service provider.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PaaS解决方案易于使用，但有时你必须使用专用硬件，或者你可以完全控制的虚拟机。大型企业通常在其自己的数据中心有投资，因此切换到外部服务提供商是没有意义的。
- en: Virtualization has transformed web hosting. Linux virtual machines have been
    a key solution for hosting web applications for several years, and services like
    Amazon Elastic Compute Cloud make it easy to create and destroy services on demand.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化已经改变了Web托管。Linux虚拟机已经是在线应用程序托管的关键解决方案好几年了，像Amazon Elastic Compute Cloud这样的服务使得按需创建和销毁服务变得容易。
- en: It’s therefore likely that at some point you’ll be faced with deploying Node
    applications to servers that need configuration and maintenance. If you’re already
    experienced with basic systems administration tasks, then you can reuse your existing
    skills and software. Otherwise, you’ll have to become familiar with web server
    daemons and the tools used to keep Node programs running and recovering from errors.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会在某个时候面临将Node应用程序部署到需要配置和维护的服务器上的问题。如果你已经熟悉基本系统管理任务，那么你可以重用你现有的技能和软件。否则，你必须熟悉Web服务器守护进程以及用于保持Node程序运行和从错误中恢复的工具。
- en: This technique presents examples for Apache and nginx. They’re both web servers,
    but their configuration formats are very different, and they’re built in different
    ways. [Figure 12.6](#ch12fig06) shows the basic server architecture that we’ll
    create in this section.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提供了Apache和nginx的示例。它们都是Web服务器，但它们的配置格式非常不同，并且它们是以不同的方式构建的。[图12.6](#ch12fig06)显示了在本节中我们将创建的基本服务器架构。
- en: Figure 12.6\. A Node program running alongside Apache or nginx
  id: totrans-1493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. 与Apache或nginx一起运行的Node程序
- en: '![](12fig06.jpg)'
  id: totrans-1494
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig06.jpg)'
- en: It’s not actually necessary to run a web server—there are ways to make Node
    programs safely access port 80\. But we assume that you’re deploying to a server
    that has existing websites. Also, some people prefer to serve static assets from
    Apache or nginx.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上运行一个Web服务器并不是必要的——有方法可以使Node程序安全地访问端口80。但我们假设你正在部署到一个已经存在网站的服务器。此外，有些人更喜欢从Apache或nginx服务静态资源。
- en: 'The same technique is used for both servers: proxying. The following listing
    shows how to do this with Apache.'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个服务器，使用的技术是相同的：代理。以下列表展示了如何使用Apache来实现这一点。
- en: Listing 12.1\. Proxying requests to a Node application with Apache
  id: totrans-1497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1\. 使用Apache代理请求到Node应用程序
- en: '![](333fig01_alt.jpg)'
  id: totrans-1498
  prefs: []
  type: TYPE_IMG
  zh: '![](333fig01_alt.jpg)'
- en: The directives in [listing 12.1](#ch12ex01) should be added to your Apache configuration
    file. To find the right file, type `apache2 -V` on your server, and look for the
    `HTTPD_ROOT` and `SERVER_CONFIG_FILE` values—joining them will give you the right
    path and file. It’s likely that you won’t want to redirect *all* requests to your
    Node application, so you can add the proxy settings to a `VirtualHost` block.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12.1](#ch12ex01) 中的指令应添加到您的 Apache 配置文件中。要找到正确的文件，在您的服务器上输入 `apache2 -V`，并查找
    `HTTPD_ROOT` 和 `SERVER_CONFIG_FILE` 的值——将它们连接起来将给出正确的路径和文件。你可能不希望将所有请求都重定向到你的
    Node 应用程序，因此你可以将代理设置添加到 `VirtualHost` 块中。'
- en: With these three lines, requests to `/` will now be proxied to a process listening
    on port 3000 ![](1.jpg). In this case, the process is assumed to be a Node program
    that you’ve run with `node server.js` or `npm start`, but it could technically
    be any HTTP server. The `LoadModule` directives tell Apache to use the proxy ![](2.jpg)
    and HTTP proxying ![](3.jpg) modules.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三行，对 `/` 的请求现在将被代理到监听在端口 3000 的进程 ![1.jpg](1.jpg)。在这种情况下，该进程被假定为使用 `node
    server.js` 或 `npm start` 运行的 Node 程序，但从技术上讲，它可以是任何 HTTP 服务器。`LoadModule` 指令告诉
    Apache 使用代理 ![2.jpg](2.jpg) 和 HTTP 代理 ![3.jpg](3.jpg) 模块。
- en: If you forget to start the Node process, or quit it, then Apache will return
    a 503 error. To avoid errors like this, you need a way to keep the Node process
    running, and to also run it when the server boots. One way to do this is with
    runit ([http://smarden.org/runit/](http://smarden.org/runit/)).
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记启动 Node 进程，或者退出它，那么 Apache 将返回 503 错误。为了避免这种错误，你需要一种方法来保持 Node 进程运行，并在服务器启动时运行它。一种方法是用
    runit ([http://smarden.org/runit/](http://smarden.org/runit/))。
- en: 'If you’re using Debian or Ubuntu, you can install runit with `apt-get install
    runit`. Once it’s ready, create a shell script that can start your Node process.
    First, create a directory for your project: sudo mkdir /etc/service/nodeapp. Next,
    create a file that will be used for the script: sudo touch /etc/service/nodeapp/run.
    Then edit the file to make it look like the next listing.'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Debian 或 Ubuntu，你可以使用 `apt-get install runit` 安装 runit。一旦它就绪，创建一个可以启动你的
    Node 进程的 shell 脚本。首先，为你的项目创建一个目录：`sudo mkdir /etc/service/nodeapp`。然后，创建一个用于脚本的文件：`sudo
    touch /etc/service/nodeapp/run`。然后编辑该文件，使其看起来像下面的列表。
- en: Listing 12.2\. Running a program with `runit`
  id: totrans-1503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 使用 `runit` 运行程序
- en: '![](334fig01_alt.jpg)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![334fig01_alt.jpg](334fig01_alt.jpg)'
- en: Our server was using nvm ([https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    to manage the installed versions of Node, so we added its location to `$PATH`
    ![](1.jpg); otherwise the shell couldn’t find where `node` and npm were installed.
    You may have to modify this based on the output of `which node`, or remove it
    entirely. The last two lines ![](2.jpg) just change the directory to the location
    of your Node project, and then start it with `npm start`.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器使用 nvm ([https://github.com/creationix/nvm](https://github.com/creationix/nvm))
    来管理已安装的 Node 版本，因此我们将它的位置添加到 `$PATH` ![1.jpg](1.jpg)；否则 shell 找不到 `node` 和 npm
    的安装位置。你可能需要根据 `which node` 的输出进行修改，或者完全删除它。最后两行 ![2.jpg](2.jpg) 只是将目录更改为你的 Node
    项目的位置，然后使用 `npm start` 启动它。
- en: The application can be started with `sudo sv start /etc/service/nodeapp` and
    stopped with `sudo sv stop /etc/service/nodeapp`. Once the Node process is running,
    you can test it by killing it, and then checking to see that it automatically
    gets restarted by runit.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用 `sudo sv start /etc/service/nodeapp` 启动，并使用 `sudo sv stop /etc/service/nodeapp`
    停止。一旦 Node 进程运行，你可以通过杀死它来测试它，然后检查它是否由 runit 自动重启。
- en: Now that you know how Apache handles proxies, and how to keep a process running,
    let’s look at nginx. Nginx is often used as a web server, but it’s technically
    a reverse proxy server that supports HTTP, HTTPS, and email. To make nginx proxy
    connections to Node applications, you can use the `Proxy` module, which uses a
    `proxy_pass` directive in a way similar to Apache.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 Apache 如何处理代理，以及如何保持进程运行，让我们看看 nginx。Nginx 通常用作 web 服务器，但从技术上讲，它是一个支持
    HTTP、HTTPS 和电子邮件的反向代理服务器。为了使 nginx 代理到 Node 应用程序，你可以使用 `Proxy` 模块，它使用 `proxy_pass`
    指令的方式与 Apache 类似。
- en: '[Listing 12.3](#ch12ex03) has the settings needed by nginx. Like Apache, you
    could also put the `server` block in a virtual host file.'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12.3](#ch12ex03) 包含了 nginx 需要的设置。像 Apache 一样，你也可以将 `server` 块放在虚拟主机文件中。'
- en: Listing 12.3\. Proxying requests to a Node application with nginx
  id: totrans-1509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 12.3\. 使用 nginx 代理请求到 Node 应用程序
- en: '![](334fig02_alt.jpg)'
  id: totrans-1510
  prefs: []
  type: TYPE_IMG
  zh: '![334fig02_alt.jpg](334fig02_alt.jpg)'
- en: If you have multiple applications on the same server, then you can use a different
    port, but we’ve used 3000 here ![](1.jpg). This example is basically the same
    as Apache—you tell the server what location to proxy, and then the port. And of
    course, this example could be combined with runit.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在同一台服务器上有多个应用程序，则可以使用不同的端口，但在这里我们使用了 3000 ![1.jpg](1.jpg)。这个例子基本上与 Apache
    相同——您告诉服务器要代理的位置，然后是端口。当然，这个例子也可以与 runit 结合使用。
- en: If you don’t want to run Apache or nginx, you can run Node web applications
    without a web server. Read on to learn how to do this using firewall rules and
    other techniques.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想运行 Apache 或 nginx，则可以在没有网络服务器的情况下运行 Node 网络应用程序。继续阅读，了解如何使用防火墙规则和其他技术来完成此操作。
- en: Technique 98 Safely running Node on port 80
  id: totrans-1513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 98 在端口 80 上安全运行 Node
- en: You can still run Node without a web server daemon like Apache. To do this,
    you basically need to forward the external port 80 to an internal, unprivileged
    port. This technique presents some ways to do this in Linux.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以在没有 Apache 这样的网络服务器守护进程的情况下运行 Node。为此，您基本上需要将外部端口 80 转发到一个内部的无权限端口。这种技术在
    Linux 中提供了一些实现方式。
- en: Problem
  id: totrans-1515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You don’t want to use Apache or nginx.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 您不想使用 Apache 或 nginx。
- en: Solution
  id: totrans-1517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use firewall rules to redirect port 80 to another, unprivileged port.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 使用防火墙规则将端口 80 重定向到另一个无权限端口。
- en: Discussion
  id: totrans-1519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In most operating systems, binding to port 80 requires special privileges.
    That means that if you try to use `app.listen(80)` instead of port 3000 as we’ve
    used in most of our examples, you’ll see `Error: listen EACCES`. This happens
    because your current user account doesn’t have permission to bind to port 80.'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '在大多数操作系统中，绑定到端口 80 需要特殊权限。这意味着如果您尝试使用 `app.listen(80)` 而不是我们大多数示例中使用的端口 3000，您将看到
    `Error: listen EACCES`。这是因为您的当前用户账户没有权限绑定到端口 80。'
- en: You could get around this restriction by running `sudo npm start`, but this
    is dangerous. Ideally you want your Node program to run as a nonroot user.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `sudo npm start` 来绕过这个限制，但这很危险。理想情况下，您希望您的 Node 程序以非 root 用户身份运行。
- en: 'In Linux, traffic can be redirected from port 80 to a higher port number by
    using `iptables`. Linux uses `iptables` to manage firewall rules, so you just
    need a rule that maps from port 80 to 3000:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，可以通过使用 `iptables` 将流量从端口 80 重定向到更高的端口号。Linux 使用 `iptables` 来管理防火墙规则，因此您只需要一个将端口
    80 映射到 3000 的规则：
- en: '[PRE99]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To make this change permanent, you’ll need to save the rules to a file that
    gets run whenever the network interface is set up. The general approach is to
    save the rules to a file, like /etc/iptables.up.rules, and then edit /etc/network/interfaces
    to use it:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此更改永久生效，您需要将规则保存到一个文件中，该文件会在网络接口设置时运行。一般方法是将规则保存到一个文件中，例如 /etc/iptables.up.rules，然后编辑
    /etc/network/interfaces 以使用它：
- en: '[PRE100]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This is highly dependent on your operating system; these rules are adapted from
    Debian and Ubuntu’s documentation, but it may be different in other Linux distributions.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于您的操作系统；这些规则是从 Debian 和 Ubuntu 的文档中改编的，但在其他 Linux 发行版中可能会有所不同。
- en: One downside of this technique is that it maps traffic to *any* process that’s
    listening to that port. An alternative solution is to grant the Node binary extra
    capabilities. You can do this by installing `libcap2`.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的缺点是它将流量映射到监听该端口的任何进程。一个替代方案是授予 Node 二进制文件额外的能力。您可以通过安装 `libcap2` 来做到这一点。
- en: 'In Debian and Ubuntu, you can use `sudo apt-get install libcap2-bin`. Then
    you just need to grant the Node binary the capabilities for accessing privileged
    ports:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 和 Ubuntu 中，您可以使用 `sudo apt-get install libcap2-bin`。然后您只需要授予 Node 二进制文件访问特权端口的权限：
- en: '[PRE101]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You may need to change the path to Node—check the output of `which node` if
    you’re not sure where it is. The downside of using capabilities for this is that
    now the `node` binary can bind to all ports from 1–1024, so it’s not as specific
    as restricting it to port 80.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要更改 Node 的路径——如果您不确定它在哪，请检查 `which node` 的输出。使用能力来做到这一点的一个缺点是现在 `node` 二进制文件可以绑定到
    1-1024 之间的所有端口，因此它不如将其限制在端口 80 上那样具体。
- en: Once you’ve applied a capability to a binary, it will be fixed until the file
    changes. That means that you’ll need to run this command again if you upgrade
    Node.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将能力应用到二进制文件上，它就会固定，直到文件更改。这意味着如果您升级 Node，您将需要再次运行此命令。
- en: Now that your application is running on a server, you’ll want to ensure that
    it runs forever. There are many different ways to do this; the next technique
    outlines runit and the `forever` module.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用程序正在服务器上运行，您将希望确保它永远运行。有许多不同的方法可以实现这一点；下一个技巧概述了 runit 和 `forever` 模块。
- en: Technique 99 Keeping Node processes running
  id: totrans-1533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 99 保持 Node 进程运行
- en: Programs inevitably crash, and it’s unfortunate when this happens. What matters
    is how well you handle failure—users should be informed, and programs should recover
    elegantly. This technique is all about keeping Node programs running, no matter
    what.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 程序不可避免地会崩溃，当这种情况发生时，这是不幸的。重要的是您如何处理故障——用户应该被告知，程序应该优雅地恢复。这项技术完全是关于无论发生什么情况都要保持节点程序运行。
- en: Problem
  id: totrans-1535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Your program crashed in the middle of the night, and customers were unable to
    use the service until you restarted it.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序在半夜崩溃了，直到您重新启动它，客户都无法使用该服务。
- en: Solution
  id: totrans-1537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a process monitor to automatically restart the Node program.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 使用进程监控器自动重新启动节点程序。
- en: Discussion
  id: totrans-1539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'There are two main ways to keep a Node program running: service supervision
    or a Node program that manages other Node programs. The first method is a generic,
    operating system–specific technique. You’ve already seen runit in [technique 97](#ch12lev2sec2).
    Runit supports service supervision, which means it detects when a process stops
    running and tries to restart it.'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 保持节点程序运行主要有两种方式：服务监控或管理其他节点程序的节点程序。第一种方法是一种通用的、特定于操作系统的技术。您已经在[技术 97](#ch12lev2sec2)中看到了runit。Runit支持服务监控，这意味着它会检测进程何时停止运行，并尝试重启它。
- en: Another daemon manager is Upstart ([http://upstart.ubuntu.com/](http://upstart.ubuntu.com/)).
    You may have seen Upstart if you use Ubuntu. To use it, you’ll need a configuration
    file that describes how the Node program is managed. [Listing 12.4](#ch12ex04)
    contains an example that you can modify for your server—it should be saved in
    /etc/init/nodeapp.conf, where `nodeapp` is the name of your application.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个守护进程管理器是Upstart ([http://upstart.ubuntu.com/](http://upstart.ubuntu.com/))。如果您使用Ubuntu，您可能已经见过Upstart。要使用它，您需要一个配置文件，该文件描述了如何管理节点程序。[列表
    12.4](#ch12ex04) 包含了一个示例，您可以根据您的服务器进行修改——它应该保存在 /etc/init/nodeapp.conf 中，其中 `nodeapp`
    是您应用程序的名称。
- en: Listing 12.4\. Managing a Node program with Upstart
  id: totrans-1542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. 使用 Upstart 管理节点程序
- en: '![](336fig01_alt.jpg)'
  id: totrans-1543
  prefs: []
  type: TYPE_IMG
  zh: '![](336fig01_alt.jpg)'
- en: This configuration file tells Upstart to respawn the application ([http://upstart.ubuntu.com/wiki/Stanzas#respawn](http://upstart.ubuntu.com/wiki/Stanzas#respawn))
    if it dies for any reason. It sets up a `PATH` ![](1.jpg) that’s similar to the
    one you’ll see in your terminal if you type `echo $PATH`. Then it states the program
    should be run on run levels 2 and 3 ![](2.jpg)—run level 2 is usually when networking
    daemons are started.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件告诉Upstart，如果应用程序因任何原因而死亡，则重新启动应用程序 ([http://upstart.ubuntu.com/wiki/Stanzas#respawn](http://upstart.ubuntu.com/wiki/Stanzas#respawn))。它设置了一个类似于在终端中输入
    `echo $PATH` 时在您的终端中看到的 `PATH` ![1.jpg](1.jpg)。然后它声明程序应在运行级别2和3上运行 ![2.jpg](2.jpg)——运行级别2通常是网络守护进程启动时。
- en: '|  |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Run levels
  id: totrans-1546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行级别
- en: Unix systems handle run levels differently depending on the vendor. The Linux
    Standard Base specification describes run level 2 as multi-user mode, and 3 as
    multi-user mode with networking. In Debian, 2–5 are grouped as multi-user mode
    with console logins and the display manager. However, Ubuntu treats run level
    2 as graphical multi-user with networking, so you should check how your system
    implements run levels before using Upstart.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统根据供应商的不同，处理运行级别的策略也不同。Linux标准基规范将运行级别2描述为多用户模式，将3描述为具有网络的多用户模式。在Debian中，2-5被分组为具有控制台登录和显示管理器的多用户模式。然而，Ubuntu将运行级别2视为具有网络的可视化多用户模式，因此在使用Upstart之前，您应该检查您的系统如何实现运行级别。
- en: '|  |'
  id: totrans-1548
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Upstart `script` stanza allows you to include a short script, so this means
    you can do things like set `NODE_ENV` to `production`. The application itself
    is launched with the `exec` instruction. We’ve included some logging support by
    redirecting standard out and standard error to a log file ![](3.jpg).
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart 的 `script` 段落允许您包含一个简短的脚本，这意味着您可以执行诸如将 `NODE_ENV` 设置为 `production` 之类的操作。应用程序本身是通过
    `exec` 指令启动的。我们通过将标准输出和标准错误重定向到日志文件来提供了日志支持 ![3.jpg](3.jpg)。
- en: 'Upstart can be more work to set up than runit, but we’ve used it in production
    for three years now without any issues. Both are easier to set up and maintain
    than traditional stop/start init scripts, but there’s another technique you can
    use: Node programs that monitor other Node programs.'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 与runit相比，设置Upstart可能需要更多的工作，但我们已经连续三年在生产环境中使用它而没有遇到任何问题。两者都比传统的停止/启动初始化脚本更容易设置和维护，但您还可以使用另一种技术：监控其他节点程序的节点程序。
- en: Node process managers work by using a small program that ensures another program
    runs continuously. This program is simple and therefore less likely to crash than
    a more complex web application. One of the most popular modules for this is `forever`
    ([https://www.npmjs.org/package/forever](https://www.npmjs.org/package/forever)),
    which can be used as a command-line program or programmatically.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: Node 进程管理器通过使用一个小程序来确保另一个程序持续运行。这个程序很简单，因此比更复杂的 Web 应用程序更不容易崩溃。为此最流行的模块之一是 `forever`
    ([https://www.npmjs.org/package/forever](https://www.npmjs.org/package/forever))，它可以作为命令行程序或程序化使用。
- en: 'Most people use it through the command-line interface. The basic usage is `forever
    start app.js`, where app.js is your web application. It has lots of options beyond
    this, though: it can manage log files and even wrap your program so it behaves
    like a daemon.'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人通过命令行界面使用它。基本用法是 `forever start app.js`，其中 app.js 是你的 Web 应用程序。尽管如此，它还有很多其他选项：它可以管理日志文件，甚至可以将你的程序包装起来，使其表现得像守护进程。
- en: 'To start your program as a daemon, use the following options:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 要以守护进程的方式启动你的程序，请使用以下选项：
- en: '[PRE102]'
  id: totrans-1554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This will start app.js, creating some additional files: one to store the current
    PID of the active process, a log file, and an error log file. Once the program
    is running, you can stop it gracefully like this:'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动 app.js，并创建一些额外的文件：一个用于存储活动进程当前 PID 的文件，一个日志文件和一个错误日志文件。一旦程序开始运行，你可以像这样优雅地停止它：
- en: '[PRE103]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Forever can be used with any Node program, but it’s generally seen as a tool
    for keeping web applications running for a long time. The command-line interface
    makes it easy to use alongside other Unix programs.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '`forever` 可以与任何 Node 程序一起使用，但它通常被视为一个用于长时间运行 Web 应用的工具。命令行界面使其与其他 Unix 程序一起使用变得容易。'
- en: Deploying applications that use WebSockets can bring a set of unique requirements.
    It can be more difficult with PaaS providers, because they can kill requests that
    last for more than a certain number of seconds. If you’re using WebSockets, look
    through the next technique to make sure your setup will work in production.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 部署使用 WebSockets 的应用程序可能会带来一系列独特的要求。在使用 PaaS 提供商时可能会更困难，因为它们可以杀死持续时间超过一定秒数的请求。如果你使用
    WebSockets，请查看下一项技术，以确保你的设置可以在生产中工作。
- en: Technique 100 Using WebSockets in production
  id: totrans-1559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 100 在生产中使用 WebSockets
- en: Node is great for WebSockets—the same process can serve both standard HTTP requests
    and the newer WebSocket protocol. But how exactly do you deploy programs that
    use WebSockets in production? Read on to find out how to do this with web servers
    and cloud providers.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: Node 对 WebSockets 非常出色——同一个进程可以同时服务标准的 HTTP 请求和较新的 WebSocket 协议。但具体如何部署在生产中使用
    WebSockets 的程序呢？继续阅读以了解如何使用 Web 服务器和云提供商来完成这项任务。
- en: Problem
  id: totrans-1561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use WebSockets in production.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在生产中使用 WebSockets。
- en: Solution
  id: totrans-1563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Make sure the service provider or proxy you’re using supports HTTP `Upgrade`
    headers.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的服务提供商或代理支持 HTTP `Upgrade` 头。
- en: Discussion
  id: totrans-1565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: WebSockets are amazing, but are still treated almost like second-class citizens
    by hosting providers. Nodejitsu was the first PaaS provider to support WebSockets,
    and it uses `node-http-proxy` ([https://github.com/nodejitsu/node-http-proxy](https://github.com/nodejitsu/node-http-proxy))
    to do this. Almost all solutions involve a proxy. To understand why, you need
    to look at how WebSockets work.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 非常神奇，但仍然被托管提供商几乎当作二等公民对待。Nodejitsu 是第一个支持 WebSockets 的 PaaS 提供商，它使用
    `node-http-proxy` ([https://github.com/nodejitsu/node-http-proxy](https://github.com/nodejitsu/node-http-proxy))
    来实现这一点。几乎所有的解决方案都涉及代理。要了解原因，你需要看看 WebSockets 的工作方式。
- en: HTTP is essentially a stateless protocol, which means all interactions between
    a server and a client can be modeled with requests and responses that hold all
    of the required state. This level of encapsulation has led to the design of modern
    client/server web applications.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 实质上是一种无状态协议，这意味着服务器和客户端之间的所有交互都可以用包含所有所需状态的请求和响应来建模。这种封装级别导致了现代客户端/服务器
    Web 应用的设计。
- en: The downside of this is that the underlying protocol doesn’t support long-running
    full-duplex connections. There’s a wide class of applications that are built on
    TCP connections of this type; video streaming and conferencing, real-time messaging,
    and games are prominent examples. As web browsers have evolved to support richer,
    more sophisticated applications, we’re naturally left trying to simulate these
    types of applications using HTTP.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，底层协议不支持长时间运行的全双工连接。有许多基于此类TCP连接的应用程序；视频流和会议、实时消息和游戏是突出的例子。随着网络浏览器的发展，以支持更丰富、更复杂的应用程序，我们自然地试图使用HTTP来模拟这些类型的应用程序。
- en: The WebSocket protocol was developed to support long-lived TCP-like connections.
    It works by using a standard HTTP handshake where the client establishes whether
    the server supports WebSockets. The mechanism for this is a new header called
    `Upgrade`. As HTTP clients and servers are typically bombarded with a variety
    of nonstandard headers, servers that don’t support `Upgrade` should be fine—the
    client will just have to fall back to old-fashioned HTTP polling.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议是为了支持长连接而开发的，类似于TCP。它通过使用标准的HTTP握手来工作，客户端通过这个握手来确认服务器是否支持WebSockets。这个机制是通过一个名为`Upgrade`的新头来实现的。由于HTTP客户端和服务器通常会被各种非标准头信息轰炸，因此不支持`Upgrade`的服务器应该没问题——客户端只需回退到传统的HTTP轮询。
- en: Because servers have to handle WebSocket connections so differently, it makes
    sense to effectively run two servers. In a Node program, we typically have an
    `http.listen` for our standard HTTP requests, and another “internal” WebSocket
    server.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器必须以不同的方式处理WebSocket连接，因此实际上运行两个服务器是有意义的。在Node程序中，我们通常有一个`http.listen`用于我们的标准HTTP请求，还有一个“内部”WebSocket服务器。
- en: In [technique 97](#ch12lev2sec2), you saw how to use nginx with Node. The example
    used proxies to pass requests from nginx to your Node process, which meant the
    Node process could bind to a different port to 80\. By using the same technique,
    you can make nginx support WebSockets. A typical `nginx.conf` would look like
    the next listing.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 在[技术97](#ch12lev2sec2)中，您看到了如何使用nginx与Node结合。示例中使用了代理来将请求从nginx传递到您的Node进程，这意味着Node进程可以绑定到不同于80的端口。通过使用相同的技巧，您可以让nginx支持WebSockets。一个典型的`nginx.conf`配置可能如下所示。
- en: Listing 12.5\. Adding WebSocket support to nginx
  id: totrans-1572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. 向nginx添加WebSocket支持
- en: '![](338fig01_alt.jpg)'
  id: totrans-1573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](338fig01_alt.jpg)'
- en: Adding `proxy_http_version 1.1` and `proxy_set_header Upgrade` ![](1.jpg) enables
    nginx to filter WebSocket requests through to your Node process. This example
    will also skip caching for WebSocket requests.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`proxy_http_version 1.1`和`proxy_set_header Upgrade` ![图片](1.jpg)可以使nginx过滤WebSocket请求到您的Node进程。此示例还将跳过WebSocket请求的缓存。
- en: 'Since we mentioned Nodejitsu supports WebSockets, what about Heroku? Well,
    you currently need to enable it as an add-on, which means you need to run a `heroku`
    command:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了Nodejitsu支持WebSockets，那么Heroku呢？嗯，您目前需要将其作为附加组件启用，这意味着您需要运行一个`heroku`命令：
- en: '[PRE104]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Heroku’s web servers usually kill requests that take longer than around 75 seconds,
    but enabling this add-on means requests that originate with an `Upgrade` header
    should keep running for as long as the network allows.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku的Web服务器通常会在大约75秒后杀死请求，但启用此附加组件意味着带有`Upgrade`头的请求应该可以持续运行，直到网络允许。
- en: There are times when you might not be able to use WebSockets easily. One example
    is older versions of Apache, where the proxy module doesn’t support them. In cases
    like this, it can be better to use a proxy server that runs *before* everything
    else.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能无法轻松地使用WebSockets。一个例子是Apache的旧版本，其中代理模块不支持它们。在这种情况下，使用一个在所有其他内容之前运行的代理服务器可能更好。
- en: HAProxy ([http://haproxy.1wt.eu/](http://haproxy.1wt.eu/)) is a flexible proxy
    server. The usage is similar to nginx, and it’s also event-based, so it has been
    widely adopted in the Node community. If you’re using an old version of Apache,
    you can proxy web requests to Apache or Node, depending on various options like
    URL or headers.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy ([http://haproxy.1wt.eu/](http://haproxy.1wt.eu/))是一个灵活的代理服务器。其用法与nginx类似，也是基于事件的，因此在Node社区中得到了广泛的应用。如果您使用的是Apache的旧版本，您可以根据诸如URL或头信息等选项将Web请求代理到Apache或Node。
- en: If you want to install HAProxy in Debian or Ubuntu, you can do so with `sudo
    apt-get install haproxy`. Once it’s set up, you’ll need to edit /etc/default/haproxy
    and set `ENABLED=1`—this is just because it ships with a default configuration,
    so it’s disabled by default. [Listing 12.6](#ch12ex06) is a sample configuration
    that’s capable of routing requests to a Node web application that runs on port
    3000, but will be accessible using port 80 externally.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Debian 或 Ubuntu 上安装 HAProxy，可以使用 `sudo apt-get install haproxy`。一旦设置好，你需要编辑
    /etc/default/haproxy 并设置 `ENABLED=1`——这仅仅是因为它附带默认配置，所以默认情况下是禁用的。[列表 12.6](#ch12ex06)
    是一个示例配置，它可以将请求路由到运行在 3000 端口的 Node Web 应用程序，但可以从外部使用 80 端口访问。
- en: Listing 12.6\. Using HAProxy with a Node application
  id: totrans-1581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 使用 HAProxy 与 Node 应用程序
- en: '![](339fig01_alt.jpg)'
  id: totrans-1582
  prefs: []
  type: TYPE_IMG
  zh: '![339fig01_alt.jpg](339fig01_alt.jpg)'
- en: This should work with WebSockets, and we’ve used a long timeout so HAProxy doesn’t
    close WebSockets connections, which are typically long-lived ![](1.jpg). If you
    run a Node program that listens on port 3000, then after restarting HAProxy with
    `sudo/etc/init.d/haproxy restart`, your application should be accessible on port
    80.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与 WebSocket 一起工作，我们使用了较长的超时时间，这样 HAProxy 就不会关闭 WebSocket 连接，这些连接通常是长期存在的
    ![1.jpg](1.jpg)。如果你运行一个监听 3000 端口的 Node 程序，那么在用 `sudo /etc/init.d/haproxy restart`
    重启 HAProxy 后，你的应用程序应该可以通过 80 端口访问。
- en: You can use [table 12.2](#ch12table02) to find the web server that’s right for
    your application.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [表 12.2](#ch12table02) 来找到适合你应用程序的 Web 服务器。
- en: Table 12.2\. Comparing server options
  id: totrans-1585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 12.2\. 比较服务器选项
- en: '| Server | Features | Best for |'
  id: totrans-1586
  prefs: []
  type: TYPE_TB
  zh: '| 服务器 | 功能 | 适用于 |'
- en: '| --- | --- | --- |'
  id: totrans-1587
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Apache |'
  id: totrans-1588
  prefs: []
  type: TYPE_TB
  zh: '| Apache |'
- en: Fast asset serving
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的资产服务
- en: Works well with established web platforms (PHP, Ruby)
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有的 Web 平台（PHP、Ruby）配合良好
- en: Lots of modules for things like proxying, URL rewriting
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多模块，如代理、URL 重写
- en: Virtual hosts
  id: totrans-1592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟主机
- en: '| May already be on servers |'
  id: totrans-1593
  prefs: []
  type: TYPE_TB
  zh: '| 可能已经在服务器上 |'
- en: '| nginx |'
  id: totrans-1594
  prefs: []
  type: TYPE_TB
  zh: '| nginx |'
- en: Event-based architecture, very fast
  id: totrans-1595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的架构，非常快
- en: Easy to configure
  id: totrans-1596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于配置
- en: Proxy module works well with Node and WebSockets
  id: totrans-1597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模块与 Node 和 WebSocket 配合良好
- en: Virtual hosts
  id: totrans-1598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟主机
- en: '| Hosting Node applications when you also want to host static websites, but
    don’t yet have Apache or a legacy server set up |'
  id: totrans-1599
  prefs: []
  type: TYPE_TB
  zh: '| 在你想要托管 Node 应用程序的同时托管静态网站，但还没有设置 Apache 或旧服务器的情况下 |'
- en: '| HAProxy |'
  id: totrans-1600
  prefs: []
  type: TYPE_TB
  zh: '| HAProxy |'
- en: Event-based and fast
  id: totrans-1601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的，速度快
- en: Can route to other web servers on the same machine
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将路由到同一台机器上的其他 Web 服务器
- en: Works well with WebSockets.
  id: totrans-1603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 WebSocket 配合良好。
- en: '| Scaling up to a cluster for high-traffic sites, or complex heterogeneous
    setups |'
  id: totrans-1604
  prefs: []
  type: TYPE_TB
  zh: '| 扩展到集群以处理高流量网站，或复杂的异构设置 |'
- en: '| Native Node proxy |'
  id: totrans-1605
  prefs: []
  type: TYPE_TB
  zh: '| 原生 Node 代理 |'
- en: Reuse your Node programming knowledge
  id: totrans-1606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用你的 Node 编程知识
- en: Flexible
  id: totrans-1607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活
- en: '| Useful if you want to scale and have a team with excellent Node skills |'
  id: totrans-1608
  prefs: []
  type: TYPE_TB
  zh: '| 如果你想扩展并且有一个技术精湛的 Node 团队，那么很有用 |'
- en: '|  |'
  id: totrans-1609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Which server is right for me?**'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: '**哪个服务器适合我？**'
- en: This chapter doesn’t cover every server choice out there—we’ve mainly focused
    on Apache and nginx for Unix servers. Even so, it can be difficult to pick between
    these options. We’ve included [table 12.2](#ch12table02) so you can quickly compare
    each option.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有涵盖所有服务器选择——我们主要关注 Unix 服务器上的 Apache 和 nginx。即便如此，在这些选项之间做出选择可能仍然困难。我们包括了
    [表 12.2](#ch12table02)，这样你可以快速比较每个选项。
- en: '|  |'
  id: totrans-1612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Your HAProxy setup can be made aware of multiple “back ends” by naming them
    with the `backend` instruction. In [listing 12.7](#ch12ex07) we only have one—`node_backend`.
    It would be possible to also run Apache, and route certain requests to it based
    on the domain name:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `backend` 指令来给多个“后端”命名，让 HAProxy 了解它们。在 [列表 12.7](#ch12ex07) 中我们只有一个——`node_backend`。也可以运行
    Apache，并根据域名将某些请求路由到它：
- en: '[PRE105]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This works well if you have an existing set of Apache virtual hosts—perhaps
    serving things like static assets, blogs, and websites—and you want to add Node
    to the same server. Apache can be set up to listen on a different port so HAProxy
    can sit in front of it, and then route requests to Express on port 3000 and the
    existing Apache sites on port 8080\. Apache allows you to change the port by using
    the `Listen 8080` directive.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有现有的 Apache 虚拟主机——可能用于托管静态资产、博客和网站——并且你想要在同一台服务器上添加 Node，Apache 可以设置为监听不同的端口，这样
    HAProxy 就可以位于其前面，然后将请求路由到端口 3000 的 Express 和端口 8080 的现有 Apache 网站。Apache 允许你使用
    `Listen 8080` 指令更改端口。
- en: You can use the same `acl` option to route WebSockets based on URL. Let’s say
    you’ve mounted your WebSocket server on /chat in your Node application. You could
    have a specific instance of your server that just handles WebSockets, and route
    conditionally using HAProxy by using `path_beg`. The following listing shows how
    this works.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的 `acl` 选项根据URL路由WebSocket。假设您已经在Node应用程序中将WebSocket服务器挂载到 /chat。您可以有服务器的一个特定实例，专门处理WebSocket，并通过使用
    `path_beg` 条件路由。以下列表显示了这是如何工作的。
- en: Listing 12.7\. Using HAProxy with WebSockets
  id: totrans-1617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7. 使用HAProxy与WebSocket
- en: '![](341fig01_alt.jpg)'
  id: totrans-1618
  prefs: []
  type: TYPE_IMG
  zh: '![](341fig01_alt.jpg)'
- en: HAProxy can match requests based on lots of parameters. Here we’ve used `hdr(Upgrade)
    -i WebSocket` to test if an `Upgrade` header has been used ![](1.jpg). As you’ve
    already seen, that denotes a WebSocket handshake.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy可以根据许多参数匹配请求。这里我们使用了 `hdr(Upgrade) -i WebSocket` 来测试是否使用了 `Upgrade` 标头
    ![](1.jpg)。如您所见，这表示WebSocket握手。
- en: By using `path_beg` and marking matching routes with `acl is_websocket` ![](2.jpg),
    you can now route requests based on the prefix expression `if is_websocket`.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `path_beg` 并使用 `acl is_websocket` 标记匹配的路由 ![](2.jpg)，您现在可以根据前缀表达式 `if is_websocket`
    路由请求。
- en: All of these HAProxy options can be combined to route requests to your Node
    application, Apache server, and WebSocket-specific Node server. That means you
    can run your WebSockets off an entirely different process, or even another internal
    web server. HAProxy is a great choice for scaling up Node programs—you could run
    multiple instances of your application on multiple servers.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些HAProxy选项都可以组合起来路由请求到您的Node应用程序、Apache服务器和特定的WebSocket Node服务器。这意味着您可以在完全不同的进程中运行WebSocket，甚至另一个内部Web服务器。HAProxy是扩展Node程序的绝佳选择——您可以在多个服务器上运行应用程序的多个实例。
- en: HAProxy provides a `weight` option that allows you to implement *round-robin*
    load balancing by adding `balance roundrobin` to a `backend`.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy提供了一个 `weight` 选项，允许您通过在 `backend` 中添加 `balance roundrobin` 来实现 *轮询*
    负载均衡。
- en: You can initially deploy your application without nginx or HAProxy in front
    of it, but when you’re ready, you can scale up by using a proxy. If you don’t
    have performance issues right now, then it’s worth just being aware that proxies
    can do things like route WebSockets to different servers and handle round-robin
    load balancing. If you already have a server using Apache 2.2.x that isn’t compatible
    with proxying WebSockets, then you can drop HAProxy in front of Apache.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以最初部署应用程序，不需要nginx或HAProxy在前面，但一旦准备好，您可以通过使用代理来扩展。如果您目前没有性能问题，那么了解代理可以执行诸如将WebSocket路由到不同的服务器和处理轮询负载均衡等操作是有价值的。如果您已经有一个使用Apache
    2.2.x的服务器，它不兼容代理WebSocket，那么您可以在Apache前面放置HAProxy。
- en: If you’re using HAProxy, you’ll still have to manage your Node processes with
    a monitoring daemon like runit or Upstart, but it has proven to be an incredibly
    flexible solution.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用HAProxy，您仍然需要使用像runit或Upstart这样的监控守护进程来管理您的Node进程，但这已被证明是一个极其灵活的解决方案。
- en: Another approach that we haven’t discussed yet is to put your Node applications
    behind a lightweight Node program that acts as a proxy itself. This is actually
    used behind the scenes by PaaS providers like Nodejitsu.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的另一种方法是使用一个轻量级的Node程序作为代理本身。实际上，PaaS提供商如Nodejitsu在幕后就是这样做的。
- en: Selecting the right server architecture is just the first step to successfully
    deploying a Node application. You should also consider performance and scalability.
    The next three techniques include advice on caching and running clusters of Node
    programs.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的服务器架构只是成功部署Node应用程序的第一步。您还应该考虑性能和可扩展性。接下来的三个技巧包括关于缓存和运行Node程序集群的建议。
- en: 12.2\. Caching and scaling
  id: totrans-1627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2. 缓存和扩展
- en: This section is mainly about running multiple copies of Node applications at
    once, but we’ve also included a technique to give you details on caching. If you
    can make the client do more work, then why not?
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要关于同时运行多个Node应用程序，但我们还包含了一种提供缓存详细信息的技巧。如果您可以让客户端做更多的工作，为什么不呢？
- en: Technique 101 HTTP caching
  id: totrans-1629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 101：HTTP 缓存
- en: Even though Node is known for high-performance web applications, there are ways
    you can speed things up. Caching is the major technique, and you should consider
    caching before deploying your application. This technique introduces the concepts
    behind HTTP caching.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node以其高性能的Web应用程序而闻名，但您仍然有方法可以加快速度。缓存是主要的技巧，您在部署应用程序之前应该考虑缓存。本技巧介绍了HTTP缓存背后的概念。
- en: Problem
  id: totrans-1631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to reduce how long it takes to make requests to your application.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望减少向你的应用程序发送请求所需的时间。
- en: Solution
  id: totrans-1633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Check to ensure that you’re using HTTP caching correctly.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以确保你正确地使用了 HTTP 缓存。
- en: Discussion
  id: totrans-1635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Modern web applications can be huge: image assets, fonts, CSS, JavaScript,
    and HTML all add up to a formidable payload that’s spread across several HTTP
    requests. Even with the best minimizers and compression, downloads can still run
    into megabytes. To avoid requiring users to wait for every action they perform
    on your site, the best strategy can be to remove the need to download anything
    at all.'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用程序可能非常大：图像资源、字体、CSS、JavaScript 和 HTML 的总和构成了一个庞大的负载，分布在几个 HTTP 请求中。即使使用最佳的压缩工具，下载量仍然可能达到兆字节。为了避免要求用户等待他们在网站上进行的每个操作，最佳策略可能是完全消除下载的需求。
- en: Browsers cache content locally, and can look at the cache to determine if a
    resource needs to be downloaded. This process is controlled by *HTTP cache headers*
    and conditional requests. In this technique we’ll introduce cache headers and
    explain how they work, so when you watch your application serving responses in
    a debugging tool like WebKit Inspector, you’ll know what caching headers to expect.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会在本地缓存内容，并且可以查看缓存以确定资源是否需要下载。这个过程由 *HTTP 缓存头部* 和条件请求控制。在这个技术中，我们将介绍缓存头部并解释它们是如何工作的，这样当你在
    WebKit 检查器等调试工具中查看你的应用程序提供响应时，你就会知道预期的缓存头部。
- en: 'The main two headers are `Cache-Control` and `Expires`. The `Cache-Control`
    header allows the server to specify a directive that controls how a resource is
    cached. The basic directives are as follows:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的两个头部是 `Cache-Control` 和 `Expires`。`Cache-Control` 头部允许服务器指定一个指令来控制资源如何被缓存。基本指令如下：
- en: '***`public`*** —Allow caching in the browser and any intermediate proxies between
    the browser and server.'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`public`*** —允许在浏览器和服务器之间的任何中间代理中缓存。'
- en: '***`private`*** —Only allow the browser to cache the resource.'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`private`*** —仅允许浏览器缓存资源。'
- en: '***`no-store`*** —Don’t cache the resource (but some clients still cache under
    certain conditions).'
  id: totrans-1641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`no-store`*** —不要缓存资源（但某些客户端在特定条件下仍然会缓存）。'
- en: For a full list of `Cache-Control` directives, refer to the Hypertext Transfer
    Protocol 1.1 specification ([http://www.w3.org/Protocols/rfc2616/rfc2616.html](http://www.w3.org/Protocols/rfc2616/rfc2616.html)).
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `Cache-Control` 指令的完整列表，请参阅超文本传输协议 1.1 规范（[http://www.w3.org/Protocols/rfc2616/rfc2616.html](http://www.w3.org/Protocols/rfc2616/rfc2616.html)）。
- en: 'The `Expires` header tells the browser when to replace the local resource.
    The date should be in the RFC 1123 format: `Fri, 03 Apr 2014 19:06 BST`. The HTTP/1.1
    specification notes that dates over a year shouldn’t be used, so don’t set dates
    too far into the future because the behavior is undefined.'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expires` 头部告诉浏览器何时替换本地资源。日期应采用 RFC 1123 格式：`Fri, 03 Apr 2014 19:06 BST`。HTTP/1.1
    规范指出，不应使用超过一年的日期，因此不要设置过远的未来日期，因为其行为是未定义的。'
- en: 'These two headers allow the server to tell clients *when* a resource should
    be cached. Most Node frameworks like Express will set these headers for you—the
    static serving middleware that’s part of Connect, for example, will set `maxAge`
    to `0` to indicate cache revalidation should occur. If you watch the Network console
    in your browser’s debugging tools, you should see Express serving static assets
    with `Cache-Control: public, max-age=0`, and a `Last-Modified` dates based on
    the file date.'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '这两个头部允许服务器告诉客户端资源应该何时被缓存。大多数 Node 框架，如 Express，会为你设置这些头部——例如，Connect 部分的静态资源服务中间件会将
    `maxAge` 设置为 `0` 以指示应该进行缓存验证。如果你在浏览器的调试工具中的网络控制台查看，你应该看到 Express 正在以 `Cache-Control:
    public, max-age=0` 和基于文件日期的 `Last-Modified` 日期提供静态资源。'
- en: 'Connect’s `static` middleware, which is found in the `send` module, does this
    by using `stat.mtime.toUTCString` to get the date of the last file modification.
    The browser will make a standard HTTP `GET` request for the resource with two
    additional request headers: `If-Modified-Since` and `If-None-Match`. Connect will
    then check `If-Modified-Since` against the file modification date, and respond
    with an HTTP 304, depending on the modification date. A 304 response like this
    will have no body, so the browser can conditionally use local content instead
    of downloading the resource again.'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: Connect的`static`中间件，位于`send`模块中，通过使用`stat.mtime.toUTCString`获取最后文件修改的日期来实现这一点。浏览器将为资源发送一个标准的HTTP
    `GET`请求，并带有两个额外的请求头部：`If-Modified-Since`和`If-None-Match`。Connect将检查`If-Modified-Since`与文件修改日期，并根据修改日期响应HTTP
    304。这样的304响应将没有主体，因此浏览器可以条件性地使用本地内容而不是再次下载资源。
- en: '[Figure 12.7](#ch12fig07) shows a high-level overview of HTTP caching, from
    the browser’s perspective.'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.7](#ch12fig07) 从浏览器的角度展示了HTTP缓存的概览。'
- en: Figure 12.7\. Browsers either use the local cache or make a conditional request,
    based on the previous request’s headers.
  id: totrans-1647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7\. 浏览器要么使用本地缓存，要么根据前一个请求的头部信息进行条件请求。
- en: '![](12fig07.jpg)'
  id: totrans-1648
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig07.jpg)'
- en: Conditional caching is great for large assets that may change, like images,
    because it’s much cheaper to make a `GET` request to find out if a resource should
    be downloaded again. This is known as a *time-based conditional request*. There
    are also *content-based conditional* requests, where a digest of the resource
    is used to see if a resource has changed.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 条件缓存对于可能发生变化的大资产，如图片，非常适用，因为检查资源是否需要重新下载的`GET`请求成本要低得多。这被称为基于时间的条件请求。还有基于内容的条件请求，其中使用资源的摘要来查看资源是否已更改。
- en: 'Content-based conditional requests work using ETags. *ETag* is short for *entity
    tag*, and allows servers to validate resources in a cache based on their content.
    Connect’s static middleware generates ETags like this:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的条件请求使用ETag。*ETag*是*实体标签*的缩写，允许服务器根据其内容验证缓存中的资源。Connect的静态中间件生成ETag如下：
- en: '[PRE106]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now contrast this to how Express generates ETags for dynamic content—this is
    usually content sent with `res.send`, like a JavaScript object or a string:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对比一下Express如何为动态内容生成ETag——这通常是使用`res.send`发送的内容，如JavaScript对象或字符串：
- en: '[PRE107]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first example uses the file modification time and size to create a hash.
    The second uses a hashing function based on the content. Both techniques send
    the browser tags that are based on the content, but they’ve been optimized for
    performance based on the resource type.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用文件修改时间和大小来创建哈希。第二个使用基于内容的哈希函数。这两种技术都向浏览器发送基于内容的标签，但它们已经根据资源类型进行了性能优化。
- en: There’s pressure on developers of static servers to make them as fast as possible.
    If you were to use Node’s built-in `http` module, you’d have to take all of these
    caching headers into account, and then optimize things like ETag generation. That’s
    why it’s advisable to use a module like Express—it’ll handle the details of the
    required headers based on sensible default behavior, so you can focus on developing
    your application.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 静态服务器开发者面临压力，需要尽可能使服务器运行得更快。如果你使用Node的内置`http`模块，你必须考虑所有这些缓存头部信息，然后优化像ETag生成这样的东西。这就是为什么建议使用像Express这样的模块——它将根据合理的默认行为处理所需头部的细节，这样你就可以专注于开发你的应用程序。
- en: Caching is an elegant way of improving performance because it effectively allows
    you to reduce traffic by making clients do a bit more work. Another option is
    to use a Node-based HTTP proxy to route between a cluster of processes or servers.
    Read on to learn how to do this, or skip to [technique 103](#ch12lev2sec8) to
    see how to use Node’s cluster module to manage multiple Node processes.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种优雅的性能提升方式，因为它有效地允许你通过让客户端做更多工作来减少流量。另一种选择是使用基于Node的HTTP代理在进程或服务器集群之间进行路由。继续阅读以了解如何做到这一点，或者跳转到[技巧103](#ch12lev2sec8)以了解如何使用Node的cluster模块来管理多个Node进程。
- en: Technique 102 Using a Node proxy for routing and scaling
  id: totrans-1657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧102 使用Node代理进行路由和扩展
- en: Local development is simple because you generally run one Node application at
    a time. But a production server can host multiple applications, and run the same
    application on multiple CPU cores to improve performance. So far we’ve talked
    about web and proxy servers, but this technique focuses on pure Node servers.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 本地开发很简单，因为你通常一次只运行一个 Node 应用程序。但生产服务器可以托管多个应用程序，并在多个 CPU 核心上运行相同的应用程序以提高性能。到目前为止，我们已经讨论了网页和代理服务器，但这项技术专注于纯
    Node 服务器。
- en: Problem
  id: totrans-1659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use a pure Node solution to host multiple applications, or scale
    an application.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用纯 Node 解决方案来托管多个应用程序，或者扩展应用程序。
- en: Solution
  id: totrans-1661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a proxy server module like Nodejitsu’s `http-proxy`.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Nodejitsu 的 `http-proxy` 这样的代理服务器模块。
- en: Discussion
  id: totrans-1663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: This technique demonstrates how to use Node programs to route traffic. It’s
    similar to the proxy server examples in [technique 100](#ch12lev2sec5), so you
    can reapply these ideas to HAProxy or nginx. But there are times when it might
    be easier to express routing logic in code rather than using settings files.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了如何使用 Node 程序来路由流量。它与[技术 100](#ch12lev2sec5)中的代理服务器示例类似，因此你可以将这些想法重新应用于
    HAProxy 或 nginx。但有时在代码中表达路由逻辑可能比使用设置文件更容易。
- en: Also, as you’ve seen before in this book, Node programs run as a single process,
    which doesn’t usually take advantage of a modern server that may have multiple
    CPUs and CPU cores. Therefore, you can use the techniques here to route traffic
    based on your production needs, but also to run multiple instances of your application
    so it can better take advantage of your server’s resources, reducing response
    latency and hopefully keeping your customers happy.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如你在本书中之前所见，Node 程序作为一个单独的进程运行，通常不会充分利用可能具有多个 CPU 和 CPU 核心的现代服务器。因此，你可以使用这里的技术根据你的生产需求来路由流量，同时运行你应用程序的多个实例，以便更好地利用服务器的资源，减少响应延迟，并希望让你的客户满意。
- en: Nodejitsu’s `http-proxy` ([https://www.npmjs.org/package/http-proxy](https://www.npmjs.org/package/http-proxy))
    is a lightweight wrapper around Node’s built-in `http` core module that makes
    it easier to define proxies with code. The basic usage should be familiar to you
    if you’ve followed our chapter on Node web development. The following listing
    is a simple proxy that redirects traffic to another port.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: Nodejitsu 的 `http-proxy` ([https://www.npmjs.org/package/http-proxy](https://www.npmjs.org/package/http-proxy))
    是围绕 Node 内置的 `http` 核心模块的一个轻量级包装器，它使得通过代码定义代理变得更容易。如果你跟随了我们的 Node 网络开发章节，你应该对基本用法很熟悉。下面的列表是一个简单的代理，它将流量重定向到另一个端口。
- en: Listing 12.8\. Redirecting traffic to another port with `http-proxy`
  id: totrans-1667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 使用 `http-proxy` 将流量重定向到另一个端口
- en: '![](345fig01.jpg)'
  id: totrans-1668
  prefs: []
  type: TYPE_IMG
  zh: '![](345fig01.jpg)'
- en: This example redirects traffic to port 3000 by using `http-proxy`’s `target`
    option ![](1.jpg). This module is event-based, so errors can be handled by setting
    up an error listener ![](2.jpg). The proxy server itself is set to listen on port
    9000 ![](3.jpg), but we’ve just used that so you can run it easily—port 80 would
    be used in production.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过使用 `http-proxy` 的 `target` 选项将流量重定向到端口 3000 ![](1.jpg)。此模块是事件驱动的，因此可以通过设置错误监听器来处理错误
    ![](2.jpg)。代理服务器本身被设置为监听端口 9000 ![](3.jpg)，但我们只是使用它以便你可以轻松运行它——在生产中会使用端口 80。
- en: 'The options passed to `createProxyServer` can define other routing logic. If
    `ws: true` is set, then WebSockets will be routed separately. That means you can
    create a proxy server that routes WebSockets to one application, and standard
    requests elsewhere. Let’s look at that in a more detailed example. The next listing
    shows you how to route WebSocket requests to a separate application.'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '传递给 `createProxyServer` 的选项可以定义其他路由逻辑。如果设置了 `ws: true`，则 WebSocket 将单独路由。这意味着你可以创建一个代理服务器，将
    WebSocket 路由到某个应用程序，而将标准请求路由到其他地方。让我们通过一个更详细的示例来看看。下面的列表显示了如何将 WebSocket 请求路由到另一个应用程序。'
- en: Listing 12.9\. Routing WebSocket connections separately
  id: totrans-1671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 分别路由 WebSocket 连接
- en: '![](345fig02_alt.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
  zh: '![](345fig02_alt.jpg)'
- en: 'This example creates two proxy servers: one for web requests and the other
    for WebSockets ![](1.jpg). The main web-facing server emits `upgrade` events when
    a WebSocket is initiated, and this is intercepted so requests can be routed elsewhere
    ![](2.jpg).'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了两个代理服务器：一个用于网页请求，另一个用于 WebSocket ![](1.jpg)。主面向网页的服务器在 WebSocket 被初始化时发出
    `upgrade` 事件，并且这个事件被拦截，以便请求可以被路由到其他地方 ![](2.jpg)。
- en: This technique can be extended to route traffic according to any rules you like—if
    you can infer something from a `request` object, you can route traffic accordingly.
    The same idea can also be used to map traffic to multiple machines. This allows
    you to create a cluster of servers, which can help you scale up an application.
    The following listing could be used to proxy to several servers.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以扩展为根据任何你喜欢的规则路由流量——如果你能从`request`对象中推断出某些信息，你可以相应地路由流量。同样的想法也可以用来将流量映射到多台机器。这允许你创建一个服务器集群，这有助于你扩展应用程序。以下列表可以用来代理到多个服务器。
- en: Listing 12.10\. Scaling using multiple instances of a server
  id: totrans-1675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.10\. 使用服务器多个实例进行扩展
- en: '![](346fig01_alt.jpg)'
  id: totrans-1676
  prefs: []
  type: TYPE_IMG
  zh: '![图片](346fig01_alt.jpg)'
- en: This example uses an array that contains the options for each proxy server,
    and then creates an instance of proxy server for each one ![](1.jpg). Then all
    you need to do is create a standard HTTP server and map requests to each server
    ![](2.jpg). This example uses a basic round-robin implementation—after each request
    a counter is incremented, so the next request will be mapped to a different server.
    You could easily take this example and reconfigure it to map to any number of
    servers.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用一个包含每个代理服务器选项的数组，并为每个选项创建一个代理服务器实例！[图片](1.jpg)。然后你需要做的就是创建一个标准的HTTP服务器，并将请求映射到每个服务器！[图片](2.jpg)。此示例使用基本的轮询实现——在每个请求之后，计数器都会增加，所以下一个请求将被映射到不同的服务器。你可以轻松地将此示例重新配置为映射到任意数量的服务器。
- en: Mapping requests like this can be useful on a single server with multiple CPUs
    and CPU cores. If you run your application multiple times and set each instance
    to listen on a different port, then your operating system should run each Node
    process on a different CPU core. This example uses `localhost`, but you could
    use another server, thereby clustering the application across several servers.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个CPU和CPU核心的单个服务器上，映射此类请求可能很有用。如果你运行你的应用程序多次，并将每个实例设置为监听不同的端口，那么你的操作系统应该在每个不同的CPU核心上运行每个Node进程。此示例使用`localhost`，但你也可以使用另一个服务器，从而将应用程序在多个服务器之间进行集群。
- en: In contrast to this technique’s use of additional servers for scaling, the next
    technique uses Node’s built-in features to manage multiple copies of the same
    Node program.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 与此技术使用额外服务器进行扩展相比，下一个技术使用Node的内置功能来管理同一Node程序的多个副本。
- en: Technique 103 Scaling and resiliency with cluster
  id: totrans-1680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术103 使用集群进行扩展和弹性
- en: JavaScript programs are considered *single-threaded*. Whether they actually
    use a single thread or not is dependent on the platform, but conceptually they
    execute as a single thread. That means you may have to do additional work to scale
    your application to take advantage of multiple CPUs and cores.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript程序被认为是*单线程的*。它们实际上是否使用单线程取决于平台，但从概念上讲，它们作为单线程执行。这意味着你可能需要做额外的工作来扩展你的应用程序以利用多个CPU和核心。
- en: This technique demonstrates the core module `cluster`, and shows how it relates
    to scalability, resiliency, and your Node applications.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术演示了核心模块`cluster`，并展示了它与可扩展性、弹性和你的Node应用程序之间的关系。
- en: Problem
  id: totrans-1683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to improve your application’s response time, or increase its resiliency.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 你想提高你应用程序的响应时间，或者增加其弹性。
- en: Solution
  id: totrans-1685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `cluster` module.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cluster`模块。
- en: Discussion
  id: totrans-1687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In [technique 102](#ch12lev2sec7), we mentioned running multiple Node processes
    behind a proxy. In this technique we’ll explain how this works purely on the Node
    side. You can use the ideas in this technique with or without a proxy server to
    load balance. Either way, the goal is the same: to make better use of available
    processor resources.'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 在[技术102](#ch12lev2sec7)中，我们提到了在代理后面运行多个Node进程。在这个技术中，我们将解释这是如何在Node的一侧纯粹工作的。你可以使用这个技术中的想法，无论是否有代理服务器来负载均衡。无论如何，目标都是相同的：更好地利用可用的处理器资源。
- en: '[Figure 12.8](#ch12fig08) shows a system with two CPUs with four cores each.
    A Node program is running on the system, but only fully utilizing a single core.'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.8](#ch12fig08)显示了一个系统，该系统有两个CPU，每个CPU有四个核心。一个Node程序正在该系统上运行，但只完全利用了一个核心。'
- en: Figure 12.8\. A Node process running on a single core
  id: totrans-1690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.8\. 在单个核心上运行的Node进程
- en: '![](12fig08.jpg)'
  id: totrans-1691
  prefs: []
  type: TYPE_IMG
  zh: '![图片](12fig08.jpg)'
- en: There are reasons why [figure 12.8](#ch12fig08) isn’t entirely accurate. Depending
    on the operating system, the process might be moved around cores, and although
    it’s accurate to say a Node program is a single process, it still uses several
    threads. Let’s say you start up an Express application that uses a MySQL database,
    static file serving, user sessions, and so on. Even though it will run as a single
    process, it’ll still have eight separate threads.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 有原因使得[图12.8](#ch12fig08)并不完全准确。根据操作系统的不同，进程可能会在核心之间移动，尽管可以说Node程序是一个单独的进程，但它仍然使用多个线程。假设你启动了一个使用MySQL数据库、静态文件服务、用户会话等功能的Express应用程序。即使它将以单个进程运行，它仍然会有八个独立的线程。
- en: We’re trained to think of Node programs as single-threaded because JavaScript
    platforms are conceptually single-threaded, but behind the scenes, Node’s libraries
    like `libuv` will use threads to provide asynchronous APIs. That gives us the
    event-based programming style without having to worry about the complexity of
    threads.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被训练成将Node程序视为单线程的，因为JavaScript平台在概念上是单线程的，但幕后，Node的库如`libuv`将使用线程来提供异步API。这给了我们基于事件的编程风格，而无需担心线程的复杂性。
- en: If you’re deploying Node applications and want to get more performance out of
    your multicore, multi-CPU system, then you need to start thinking more about how
    Node works at this level. If you’re running a single application on a multicore
    system, you want something like the illustration in [figure 12.9](#ch12fig09).
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在部署Node应用程序，并想在多核、多CPU系统上获得更好的性能，那么你需要开始更多地思考Node在这一层面的工作方式。如果你在一个多核系统上运行单个应用程序，你希望得到[图12.9](#ch12fig09)中所示的效果。
- en: Figure 12.9\. Take advantage of more cores by running multiple processes.
  id: totrans-1695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.9。通过运行多个进程来利用更多核心。
- en: '![](12fig09.jpg)'
  id: totrans-1696
  prefs: []
  type: TYPE_IMG
  zh: '![](12fig09.jpg)'
- en: 'Here we’re running a Node program on all but one core, the idea being that
    a core is left free for the system. You can get the number of cores for a system
    with the `os` core module. On our system, running `require(''os'').cpus().length`
    returns 4—that’s the number of cores we have, rather than CPUs—Node’s API `cpus`
    method returns an array of objects that represent each core:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在除了一个核心之外的所有核心上运行Node程序，其想法是保留一个核心供系统使用。你可以使用`os`核心模块来获取系统的核心数。在我们的系统中，运行`require('os').cpus().length`返回4——这是我们的核心数，而不是CPU数——Node的API
    `cpus`方法返回一个表示每个核心的对象数组：
- en: '[PRE108]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'With this information, we can automatically tailor an application to scale
    to the target server. Next, we need a way of forking our application so it can
    run as multiple processes. Let’s say you have an Express web application: how
    do you safely scale it up without completely rewriting it? The main issue is communication:
    once you start running multiple instances of an application, how does it safely
    access shared resources like databases? There are platform-agnostic solutions
    to this that would require a big project rewrite—pub/sub servers, object brokers,
    distributed systems—but we’ll use Node’s `cluster` module.'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个信息，我们可以自动调整应用程序以扩展到目标服务器。接下来，我们需要一种方法来分叉我们的应用程序，使其可以以多个进程运行。假设你有一个Express网络应用程序：你如何安全地将其扩展，而无需完全重写它？主要问题是通信：一旦你开始运行应用程序的多个实例，它如何安全地访问共享资源，如数据库？对此有平台无关的解决方案，这需要一个大型的项目重写——pub/sub服务器、对象代理、分布式系统——但我们将使用Node的`cluster`模块。
- en: The `cluster` module provides a way of running multiple worker processes that
    share access to underlying file handles and sockets. That means you can wrap a
    Node application with a master process that works workers. Workers don’t need
    access to shared state if you’re doing things like accessing user sessions in
    a database; all the workers will have access to the database connection, so you
    shouldn’t need to set up any communication between workers.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster`模块提供了一种运行多个工作进程的方法，这些进程共享对底层文件句柄和套接字的访问。这意味着你可以用工作进程的工作主进程包装Node应用程序。如果你像在数据库中访问用户会话这样的操作，工作进程不需要访问共享状态；所有工作进程都将有权访问数据库连接，因此你不需要在进程之间设置任何通信。'
- en: '[Listing 12.11](#ch12ex11) is a basic example of using clustering with an Express
    application. We’ve just included the server.js file that loads the main Express
    application in app.js. This is our preferred method of structuring Node web applications—the
    part that sets up the server using `.listen(port)` is in a different file than
    the application itself. In this case, separating the server and application has
    the additional benefit of making it easier to add clustering to the project.'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.11](#ch12ex11)是使用Express应用程序进行集群的基本示例。我们只包含了加载主Express应用程序的server.js文件，即app.js。这是我们构建Node网络应用程序的首选方法——使用`.listen(port)`设置服务器的部分与应用程序本身位于不同的文件中。在这种情况下，将服务器和应用程序分开还有额外的优点，即更容易将集群添加到项目中。'
- en: Listing 12.11\. Clustering a Node web application
  id: totrans-1702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.11\. 集群化Node网络应用程序
- en: '![](349fig01_alt.jpg)'
  id: totrans-1703
  prefs: []
  type: TYPE_IMG
  zh: '![349fig01_alt.jpg](#)'
- en: The basic pattern is to load the `cluster` core module ![](1.jpg), and then
    determine how many cores should be used ![](2.jpg). The `cluster.isMaster` allows
    the code to branch if this is the first (or *master*) process, and then fork workers
    as needed with `cluster.fork` ![](3.jpg).
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 基本模式是加载`cluster`核心模块 ![1.jpg](#)，然后确定应该使用多少核心 ![2.jpg](#)。`cluster.isMaster`允许代码在这是第一个（或*主进程*）时分支，然后使用`cluster.fork`
    ![3.jpg](#)按需创建工人。
- en: Each worker will rerun this code, so when a worker hits the `else` branch, the
    server can run the code particular to the worker ![](4.jpg). In this example workers
    start listening for HTTP connections, thereby starting the Express application.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工人都会重新运行这段代码，因此当工人遇到`else`分支时，服务器可以运行特定于工人的代码 ![4.jpg](#)。在这个例子中，工人开始监听HTTP连接，从而启动Express应用程序。
- en: There’s a full example that includes this code in this book’s code samples,
    which can be found in production/inky-cluster.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码示例中包含了这个代码的完整示例，可以在production/inky-cluster中找到。
- en: If you’re a Unix hacker, this should all look suspiciously familiar. The semantics
    of `fork()` are well known to C programmers. The way it works is whenever the
    system call `fork()` is used, the current process is cloned. Child processes have
    access to open files, network connections, and data structures in memory. To avoid
    performance issues, a system called *copy on write* is used. This allows the same
    memory locations to be used until a write is attempted, at which point each forked
    process receives a copy of the original. After the processes are forked, they’re
    isolated.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个Unix黑客，这一切都应该看起来非常熟悉。`fork()`的语义对C程序员来说很熟悉。它的工作方式是，每当使用系统调用`fork()`时，当前进程就会被克隆。子进程可以访问打开的文件、网络连接和内存中的数据结构。为了避免性能问题，使用了一种称为*写时复制*的系统。这允许相同的内存位置被使用，直到尝试写入，此时每个被克隆的进程都会收到原始内容的副本。进程被克隆后，它们是隔离的。
- en: 'There’s an additional step to properly dealing with clustered applications:
    worker exit recovery. If one of your workers encounters an error and the process
    ends, then you’ll want to restart it. The cool thing about this is any other active
    workers can still serve requests, so clustering will not only improve request
    latency but also potentially uptime as well. The next listing is a modification
    of [listing 12.11](#ch12ex11), to recover from workers exiting.'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理集群应用程序还需要一个额外的步骤：工人退出恢复。如果你的某个工人遇到错误并且进程结束，那么你将想要重新启动它。关于这一点很酷的是，任何其他活跃的工人仍然可以处理请求，因此集群不仅可以提高请求延迟，还可能提高正常运行时间。下面的列表是对[列表12.11](#ch12ex11)的修改，以从工人退出中恢复。
- en: Listing 12.12\. Recovering from untimely worker death
  id: totrans-1709
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.12\. 从工人意外死亡中恢复
- en: '![](350fig01_alt.jpg)'
  id: totrans-1710
  prefs: []
  type: TYPE_IMG
  zh: '![350fig01_alt.jpg](#)'
- en: The `cluster` module is event-based, so the master can listen for events like
    `exit` ![](1.jpg), which denotes the worker died. The callback for this event
    gets a `worker` object, so you can get a limited amount of information about the
    worker. After that all you need to do is fork again ![](2.jpg), and you’ll be
    back to the full complement of workers.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster`模块是事件驱动的，因此主进程可以监听像`exit` ![1.jpg](#)这样的事件，表示工人已死亡。此事件的回调函数会接收到一个`worker`对象，因此你可以获取有关工人的有限信息。之后，你只需要再次`fork`
    ![2.jpg](#)，你将回到完整的工人数量。'
- en: '|  |'
  id: totrans-1712
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Recovering from a crash in the master process**'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '**从主进程崩溃中恢复**'
- en: You might be wondering what happens when the master process itself dies. Even
    though the master should be kept simple to make this unlikely, a crash is still
    of course possible. To minimize downtime, you should still manage your clustered
    applications with a process manager like the `forever` module or Upstart. Both
    of these solutions are explored in [technique 99](#ch12lev2sec4).
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道当主进程本身死亡时会发生什么。尽管主进程应该保持简单以降低这种情况发生的可能性，但崩溃仍然是可能的。为了最小化停机时间，你仍然应该使用像`forever`模块或Upstart这样的进程管理器来管理你的集群应用程序。这两种解决方案都在[技巧99](#ch12lev2sec4)中进行了探讨。
- en: '|  |'
  id: totrans-1715
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can run this example with an Express application, and then use `kill` to
    force workers to quit. The transcript of such a session should look something
    like this:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用Express应用程序运行这个示例，然后使用`kill`强制工作者退出。这样的会话记录应该看起来像这样：
- en: '[PRE109]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Three workers were running until `kill 58734` was issued, and then a new worker
    was forked and `58737` started.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 三个工作者在运行直到发出`kill 58734`命令，然后一个新的工作者被派生出来并启动了`58737`。
- en: 'Once you’ve got clustering set up, there’s one more thing to do: benchmark.
    We’ll use `ab` ([http://httpd.apache.org/docs/2.0/programs/ab.html](http://httpd.apache.org/docs/2.0/programs/ab.html)),
    the Apache benchmarking tool. It’s used like this:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了集群，还有一件事要做：基准测试。我们将使用`ab`（[http://httpd.apache.org/docs/2.0/programs/ab.html](http://httpd.apache.org/docs/2.0/programs/ab.html)），Apache基准测试工具。它的使用方式如下：
- en: '[PRE110]'
  id: totrans-1720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This makes 10,000 requests with 100 concurrent requests at any one time. Using
    three workers on our system gave 260 requests per second, whereas a single process
    version resulted in 171 requests per second. The cluster was definitely faster,
    but is this really working as well as our round-robin example with HAProxy or
    nginx?
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次使用100个并发请求发送了10,000个请求。在我们的系统上使用三个工作者每秒产生了260个请求，而单个进程版本每秒产生了171个请求。集群确实更快，但这真的像我们的HAProxy或nginx的轮询示例那样工作得一样好吗？
- en: The advantage of the `cluster` module is that you can script it with Node. That
    means your developers should be able to understand it rather than having to learn
    how HAProxy or nginx works for load balancing. Load balancing with an additional
    proxy server doesn’t have the same kind of interprocess communication options
    that `cluster` has—you can use `process.send` and `cluster.workers[id].on('message',
    fn)` to communicate between workers.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster`模块的优势在于你可以用Node脚本来脚本化它。这意味着你的开发者应该能够理解它，而不是必须学习HAProxy或nginx的工作原理来进行负载均衡。使用额外的代理服务器进行负载均衡没有`cluster`那样的进程间通信选项——你可以使用`process.send`和`cluster.workers[id].on(''message'',
    fn)`在工作者之间进行通信。'
- en: But proxies with dedicated load-balancing features have a wider choice of load-balancing
    algorithms. Like all things, it would be wise to invest time in testing HAProxy,
    nginx, and Node’s clustering module to see which works best for your application
    and your team.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 但是具有专用负载均衡功能的代理有更广泛的负载均衡算法选择。就像所有事情一样，明智的做法是在测试HAProxy、nginx和Node的集群模块上投入时间，看看哪个最适合你的应用程序和你的团队。
- en: Also, dedicated load-balancing servers can proxy requests to multiple servers—you
    could technically proxy from a central server to multiple Node application servers,
    each of which uses the `cluster` core module to take advantage of the server’s
    multicore CPU.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，专门的负载均衡服务器可以代理多个服务器的请求——你可以从中央服务器代理到多个使用`cluster`核心模块以利用服务器多核CPU的Node应用程序服务器，这在技术上是可以实现的。
- en: With heterogeneous setups like this, you’ll need to keep track of what instances
    of your application are doing. The next section is dedicated to maintaining production
    Node programs.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种异构设置中，你需要跟踪你的应用程序实例正在做什么。下一节专门介绍维护生产环境中的Node程序。
- en: 12.3\. Maintenance
  id: totrans-1726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 维护
- en: No matter how solid your server architecture is, you’re still going to have
    to maintain your production system. The techniques in this section are all about
    maintaining your Node program; first, package optimization with npm.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的服务器架构多么稳固，你仍然需要维护你的生产系统。本节中的技术都是关于维护你的Node程序；首先，使用npm进行包优化。
- en: Technique 104 Package optimization
  id: totrans-1728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧104：包优化
- en: This technique is all about npm and how it can make deployments more efficient.
    If you feel like your module folder might be getting a bit large, then read on
    for some ideas on how to fix it.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术完全是关于npm以及它如何使部署更高效。如果你觉得你的模块文件夹可能有点大，那么继续阅读以获取一些解决问题的想法。
- en: Problem
  id: totrans-1730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Your application seems larger than expected when it’s released to production.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序发布到生产环境时，它似乎比预期的要大。
- en: Solution
  id: totrans-1732
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Try out some of npm’s maintenance features, like `npm prune` and `npm shrinkwrap`.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一些 npm 的维护功能，如 `npm prune` 和 `npm shrinkwrap`。
- en: Discussion
  id: totrans-1734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Heroku makes your application’s size clear when you deploy: each release displays
    a *slug size* in megabytes, and the maximum size on Heroku is 300 MB. Slug size
    is closely related to dependencies, so as your application grows and new dependencies
    are added, you’ll notice that it can increase dramatically.'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Heroku 上部署应用程序时，它会清楚地显示应用程序的大小：每次发布都会显示以兆字节为单位的 *slug size*，Heroku 上的最大大小为
    300 MB。slug size 与依赖项密切相关，因此随着应用程序的增长和新依赖项的添加，你可能会注意到它会有显著的增加。
- en: Even if you’re not using Heroku, you should be aware of your application’s size.
    It will impact how quickly you can release new code, and releasing new code should
    be as fast as possible. When deployment is fast, then releasing bug fixes and
    new features becomes less of a chore and less risky.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不在 Heroku 上使用，你也应该意识到你的应用程序大小。它将影响你发布新代码的速度，而发布新代码应该尽可能快。当部署速度快时，发布错误修复和新功能就不再是那么繁琐，风险也更小。
- en: Once you’ve gone through your dependencies in package.json and weeded out any
    that aren’t necessary, there are some other tricks you can use to reduce your
    application’s size. The `npm prune` command removes packages that are no longer
    listed in your package.json, but it also applies to the dependencies themselves,
    so it can sometimes dramatically reduce your application’s storage footprint.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你检查了 package.json 中的依赖项并移除了不必要的依赖项，你还可以使用一些其他技巧来减小应用程序的大小。`npm prune` 命令会移除
    package.json 中不再列出的包，但它也适用于依赖项本身，因此有时可以显著减小应用程序的存储占用。
- en: You should also consider using `npm prune --production` to remove `devDependencies`
    from production releases. We’ve found test frameworks in our production releases
    that didn’t need to be there. If you have `./node_modules` checked into git, then
    Heroku will run `npm prune` for you, but it doesn’t currently run `npm prune --production`.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑使用 `npm prune --production` 来从生产版本中移除 `devDependencies`。我们发现生产版本中有不需要的测试框架。如果你已经将
    `./node_modules` 添加到 git 中，那么 Heroku 会为你运行 `npm prune`，但它目前不会运行 `npm prune --production`。
- en: '|  |'
  id: totrans-1739
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Why check in ./node_modules?**'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么检查 ./node_modules？**'
- en: It might be tempting to add `./node_modules` to `.gitignore`, but don’t! When
    you’re working on an application that will be deployed, then you should keep `./node_modules`
    in your repository. This will help other people to run your application, and make
    it easier to reproduce your local setup that passes tests and everything else
    on a production environment.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有诱惑将 `./node_modules` 添加到 `.gitignore` 中，但不要这样做！当你正在开发将要部署的应用程序时，你应该在存储库中保留
    `./node_modules`。这将帮助其他人运行你的应用程序，并使在生产环境中重现通过测试和所有其他内容的本地设置变得更加容易。
- en: Do not do this for modules you release through *npm*. Open source libraries
    should use *npm* to manage dependencies during installation.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对通过 *npm* 发布的模块这样做。开源库在安装期间应使用 *npm* 来管理依赖项。
- en: '|  |'
  id: totrans-1743
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Another command you can use to potentially improve deployment is `npm shrinkwrap`.
    This will create a file called npm-shrinkwrap.json that specifies the exact version
    of each of your dependencies, but it doesn’t stop there—it continues recursively
    to capture the version of each submodule as well. The npm-shrinkwrap.json file
    can be checked into your repository, and npm will use it during deployment to
    get the exact version of each package.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `npm shrinkwrap` 命令来潜在地改进部署。这将创建一个名为 npm-shrinkwrap.json 的文件，该文件指定了每个依赖项的确切版本，但它不仅仅如此——它还会递归地捕获每个子模块的版本。npm-shrinkwrap.json
    文件可以提交到你的存储库中，npm 在部署时会使用它来获取每个包的确切版本。
- en: '`shrinkwrap` is also useful for collaboration, because it means people can
    duplicate the modules you’ve had living on your computer during development. This
    helps when someone joins a project after you’ve been working solo for a few months.'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrinkwrap` 也可以用于协作，因为它意味着人们可以在开发过程中复制你电脑上已经存在的模块。当你独自工作了几个月后有人加入项目时，这会很有帮助。'
- en: 'Some PaaS providers have features for excluding files from deployment as well.
    For example, Heroku can accept a .slugignore file, which works like .gitignore—you
    could create one like this to ignore tests and local seed data:'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 PaaS 提供商也提供了排除文件从部署的功能。例如，Heroku 可以接受一个 .slugignore 文件，它就像 .gitignore 一样工作——你可以创建一个像这样的文件来忽略测试和本地种子数据：
- en: '[PRE111]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: By taking advantage of npm’s built-in features, you can create solid and maintainable
    packages, reduce deployment time, and improve deployment reliability.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 npm 内置的功能，你可以创建稳固且可维护的包，减少部署时间，并提高部署可靠性。
- en: Even with a well-configured, scalable, and carefully deployed application, you’ll
    still run into issues. When things go wrong, you need logs. Read on for techniques
    when dealing with log files and logging services.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有一个配置良好、可扩展且部署周到的应用程序，你仍然会遇到问题。当事情出错时，你需要日志。继续阅读以了解处理日志文件和日志服务的技巧。
- en: Technique 105 Logging and logging services
  id: totrans-1750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 105 记录和记录服务
- en: When things break—not if, but when—you’ll need logs to uncover what happened.
    On a typical server, logs are text files. But what about PaaS providers, like
    Heroku and Nodejitsu? For these platforms you’ll need logging services.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情出错时——不是“如果”，而是“当”——你需要日志来揭示发生了什么。在典型的服务器上，日志是文本文件。但对于像 Heroku 和 Nodejitsu
    这样的 PaaS 提供商呢？对于这些平台，你需要日志服务。
- en: Problem
  id: totrans-1752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to log messages from a Node application on your own server, or on a
    PaaS provider.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在自有的服务器上记录来自 Node 应用的日志，或者在 PaaS 提供商上。
- en: Solution
  id: totrans-1754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Either redirect logs to files and use `logrotate`, or use a third-party logging
    service.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 要么将日志重定向到文件并使用 `logrotate`，要么使用第三方日志服务。
- en: Discussion
  id: totrans-1756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'In Unix, everything is a file, and that partly dictates the way systems administrators
    and DevOps experts think about log files. Logs are just files: programs stream
    data into them, and we stream data out. This kind of setup is convenient for those
    of us that live in the command line—piping files through commands like `grep`,
    `sed`, and `awk` makes light work of even gigabyte-sized logs.'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 中，一切都是文件，这在很大程度上决定了系统管理员和 DevOps 专家对日志文件的看法。日志只是文件：程序将数据流进它们，我们将数据流出。这种设置对我们这些生活在命令行的人来说很方便——通过
    `grep`、`sed` 和 `awk` 等命令将文件管道化，即使是千兆大小的日志也能轻松处理。
- en: Therefore, whatever you do, you’ll want to correctly use `console.log` and `console.error`.
    It also doesn’t hurt to be aware of `err.stack`—instances of `Error` in Node get
    a `stack` property when they’re defined, which can be extremely helpful for debugging
    problems in production. For more on writing logs, take a look at [technique 6](kindle_split_011.html#ch02lev2sec6)
    in [chapter 2](kindle_split_011.html#ch02).
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你做什么，你都会想要正确使用 `console.log` 和 `console.error`。了解 `err.stack` 也不会有害——Node
    中的 `Error` 实例在定义时获得一个 `stack` 属性，这在调试生产中的问题时非常有帮助。有关编写日志的更多信息，请参阅第 2 章中的技巧 6（[technique
    6](kindle_split_011.html#ch02lev2sec6)）。
- en: 'The benefit of using `console.error` and `console.log` is that you can pipe
    output to different locations. The following command will redirect data from standard
    out (`console.log`) to `application.log`, and standard error (`console.error`)
    to `errors.log`:'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `console.error` 和 `console.log` 的好处是你可以将输出管道化到不同的位置。以下命令将数据从标准输出（`console.log`）重定向到
    `application.log`，并将标准错误（`console.error`）重定向到 `errors.log`：
- en: '[PRE112]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'All you need to remember is the greater-than symbol redirects output, and using
    a number specifies the output stream: 1 is standard out, and 2 is standard error.'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住的是大于符号用于重定向输出，使用数字指定输出流：1 是标准输出，2 是标准错误。
- en: After a while, your log files will get too large. Fortunately, modern Unix systems
    usually come with a log rotation package. This will split files up over time and
    optionally compress them. The `logrotate` package can be installed in Debian or
    Ubuntu with `apt-get install logrotate`. Once you’ve installed it, you’ll need
    a configuration file for each set of log files you want to rotate. The following
    listing shows an example configuration that you can tailor for your application.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，你的日志文件会变得很大。幸运的是，现代 Unix 系统通常自带日志轮转包。这将在一段时间内分割文件，并可选择压缩它们。`logrotate`
    包可以在 Debian 或 Ubuntu 中使用 `apt-get install logrotate` 安装。一旦安装了它，你将为想要轮转的每一组日志文件需要一个配置文件。以下列表显示了一个示例配置，你可以根据你的应用程序进行定制。
- en: Listing 12.13\. `logrotate` configuration
  id: totrans-1763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. `logrotate` 配置
- en: '![](354fig01_alt.jpg)'
  id: totrans-1764
  prefs: []
  type: TYPE_IMG
  zh: '![图片](354fig01_alt.jpg)'
- en: After listing the log files you want to rotate, you can list the options you
    want to use. `logrotate` has many options, and they’re documented in `man logrotate`.
    The first one here, `daily` ![](1.jpg), just states that we want to rotate files
    every day. The next line makes `logrotate` keep 20 files; after that files will
    be removed ![](2.jpg). The third option will make sure old log files are compressed
    so they don’t use up too much space ![](3.jpg).
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出你想要轮换的日志文件之后，你可以列出你想要使用的选项。`logrotate` 有许多选项，它们在 `man logrotate` 中有文档说明。这里列出的第一个选项
    `daily` ![1.jpg](1.jpg) 只表示我们希望每天轮换文件。下一行使 `logrotate` 保持 20 个文件；之后文件将被删除 ![2.jpg](2.jpg)。第三个选项将确保旧日志文件被压缩，这样它们就不会占用太多空间
    ![3.jpg](3.jpg)。
- en: The fourth option, `copytruncate` ![](4.jpg), is more important for an application
    that uses simple standard I/O-based logging. It makes `logrotate` copy and then
    truncate the current log file. That means that your application doesn’t need to
    close and re-open standard out—it should just work without any special configuration.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种选项，`copytruncate` ![4.jpg](4.jpg)，对于使用简单标准 I/O 基于日志的应用程序来说更为重要。它使 `logrotate`
    复制当前日志文件然后截断。这意味着你的应用程序不需要关闭和重新打开标准输出——它应该无需任何特殊配置就能正常工作。
- en: Using standard I/O and `logrotate` works well for a single server and a simple
    application, but if you’re running an application in a cluster, you might find
    it difficult to manage logging. There are Node modules that are dedicated to logging
    and provide cluster-specific options. Some people even prefer to use these modules
    because they generate output in standard log file formats.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准 I/O 和 `logrotate` 对于单个服务器和简单应用程序来说效果很好，但如果你在集群中运行应用程序，可能会发现管理日志很困难。有一些
    Node 模块专门用于日志记录，并提供针对集群的特定选项。有些人甚至更喜欢使用这些模块，因为它们以标准日志文件格式生成输出。
- en: Using the `log4node` module ([https://github.com/bpaquet/log4node](https://github.com/bpaquet/log4node))
    is similar to using `console.log`, but has features that make it easier for use
    in a cluster. It creates one log file for all workers, and listens for a USR2
    signal to determine when to re-open files. It supports configuration options,
    including log level and message prefix, so you can keep logs quiet during tests
    or increase the verbosity for critical production systems.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `log4node` 模块 ([https://github.com/bpaquet/log4node](https://github.com/bpaquet/log4node))
    与使用 `console.log` 类似，但它具有使其在集群中使用更方便的功能。它为所有工作进程创建一个日志文件，并监听 USR2 信号以确定何时重新打开文件。它支持配置选项，包括日志级别和信息前缀，因此你可以在测试期间保持日志安静或在关键的生产系统中增加详细程度。
- en: '`winston` ([https://github.com/flatiron/winston](https://github.com/flatiron/winston))
    is a logging module that supports multiple transports, including Cassandra, which
    allows you to cluster your log writes. That means that if you have an application
    that writes millions of log entries an hour, then you can use multiple servers
    to capture the logs in a more reliable manner.'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: '`winston` ([https://github.com/flatiron/winston](https://github.com/flatiron/winston))
    是一个支持多种传输方式的日志模块，包括 Cassandra，这允许你将日志写入进行集群化。这意味着如果你有一个每小时写入数百万条日志条目的应用程序，那么你可以使用多个服务器以更可靠的方式捕获日志。'
- en: '`winston` supports remote log services, including commercial ones like Papertrail.
    Papertrail and Loggly (see [figure 12.10](#ch12fig10)) are commercial services
    that you can pipe your logs to, typically using the syslogd protocol. They will
    also index logs, so searching gigabytes of logs is extremely fast, depending on
    the query.'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '`winston` 支持远程日志服务，包括商业服务如 Papertrail。Papertrail 和 Loggly（见 [图 12.10](#ch12fig10)）是商业服务，你可以将日志管道传输到这些服务，通常使用
    syslogd 协议。它们还会索引日志，因此根据查询，搜索千兆字节日志的速度非常快。'
- en: Figure 12.10\. Loggly’s dashboard
  id: totrans-1771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.10\. Loggly 的仪表板
- en: '![](12fig10_alt.jpg)'
  id: totrans-1772
  prefs: []
  type: TYPE_IMG
  zh: '![12fig10_alt.jpg](12fig10_alt.jpg)'
- en: A service like Loggly is absolutely critical for Heroku. Heroku only stores
    the last 5,000 log entries, which can be flooded off within minutes of running
    a typical application. If you’ve deployed a Node application to Heroku that uses
    `console.log`, `log4node`, or `winston`, then you’ll be able to redirect your
    logs just by enabling the add-on.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: Loggly 这样的服务对于 Heroku 来说是绝对关键的。Heroku 只存储最后 5,000 条日志条目，这些条目在运行典型应用程序的几分钟内可能会被淹没。如果你已将
    Node 应用程序部署到 Heroku，并使用 `console.log`、`log4node` 或 `winston`，那么你只需通过启用附加组件就能重定向你的日志。
- en: With Heroku, Loggly can be configured by selecting a plan name and running `heroku
    addons:add Loggly:PlanName` from your project’s directory. Typing `heroku addons:open
    loggly` will open the Loggly web interface, but there’s also a link in Heroku’s
    administration panel under *Resources*. Any logging you’ve done with standard
    I/O should be sent straight to Loggly.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Heroku，可以通过选择计划名称并从你的项目目录运行`heroku addons:add Loggly:PlanName`来配置Loggly。键入`heroku
    addons:open loggly`将打开Loggly的Web界面，但在Heroku的管理面板下的*资源*部分也有链接。使用标准I/O进行的任何日志记录都应该直接发送到Loggly。
- en: If you’re using `winston`, then there are transports available for Loggly. One
    is `winston-loggly` ([https://github.com/indexzero/winston-loggly](https://github.com/indexzero/winston-loggly)),
    which can be used for easy access to Loggly with non-Heroku services, or your
    own private servers.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`winston`，那么有可用的Loggly传输。一个是`winston-loggly`([https://github.com/indexzero/winston-loggly](https://github.com/indexzero/winston-loggly))，它可以用于通过非Heroku服务或你自己的私有服务器轻松访问Loggly。
- en: Because Winston transports can be changed by using `winston.add(winston .transports.Loggly,
    options)`, you don’t need to do anything special to support Loggly if you’re already
    using `winston`.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以使用`winston.add(winston.transports.Loggly, options)`更改Winston传输，所以如果你已经在使用`winston`，你不需要做任何特殊的事情来支持Loggly。
- en: 'There’s a standard for logging that you can use with your applications: The
    Syslog Protocol (RFC 5424). Syslog message packets have a standard format, so
    you won’t usually generate them by hand. Modules like `winston` typically support
    syslog, so you can use it with your Node application, but there are two main benefits
    to using it. The first is that messages have standardized log levels, so filtering
    logs is easier. Some examples include level 0, known as *Emergency*, and level
    4, which is *Warning*. The second is that the protocol defines how messages are
    sent over the network, which means you can make your Node application talk to
    a syslog daemon that runs on a remote server.'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与你的应用程序一起使用的日志记录标准：Syslog协议（RFC 5424）。Syslog消息包具有标准格式，所以你通常不会手动生成它们。像`winston`这样的模块通常支持syslog，所以你可以与你的Node应用程序一起使用它，但使用它的两个主要好处是：第一个是消息具有标准化的日志级别，因此过滤日志更容易。一些例子包括级别0，称为*紧急*，和级别4，这是*警告*。第二个好处是协议定义了消息如何在网络上发送，这意味着你可以让你的Node应用程序与运行在远程服务器上的syslog守护程序通信。
- en: Some log services like Loggly and Splunk can act as syslog servers; or, you
    could run your own daemon on dedicated hardware or a virtual machine. By using
    a standardized protocol like syslog, you can switch between log providers as your
    requirements change.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志服务，如Loggly和Splunk，可以充当syslog服务器；或者，你可以在专用硬件或虚拟机上运行自己的守护程序。通过使用标准化的协议如syslog，你可以根据需求变化在日志提供者之间切换。
- en: That’s the last technique on Node-specific production concerns. The next section
    outlines some additional issues relating to scaling and resiliency.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于Node特定生产问题的最后一个技术。下一节概述了一些与扩展性和弹性相关的问题。
- en: 12.4\. Further notes on scaling and resiliency
  id: totrans-1780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 关于扩展性和弹性的进一步说明
- en: In this chapter we’ve demonstrated how to use proxies and the `cluster` module
    to scale Node programs. One of the advantages we cited in `cluster`’s favor is
    easier interprocess communication. If you’re running an application on *separate
    servers*, how can Node processes communicate?
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何使用代理和`cluster`模块来扩展Node程序。我们提到`cluster`的一个优点是更易于进程间通信。如果你在*独立的服务器*上运行应用程序，Node进程如何进行通信？
- en: One simple answer might be HTTP—you could build an internal REST API for communication.
    You could even use WebSockets if messages need faster responses. When we were
    faced with this problem, we used RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)).
    This allowed instances of our Node application to message each other using a shared
    message bus, thereby distributing work throughout a cluster.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的答案可能是HTTP——你可以构建一个用于通信的内部REST API。如果你需要更快的信息响应，甚至可以使用WebSockets。当我们面临这个问题时，我们使用了RabbitMQ([https://www.rabbitmq.com/](https://www.rabbitmq.com/))。这允许我们的Node应用程序实例通过共享的消息总线相互发送消息，从而在整个集群中分配工作。
- en: The project was a search engine that used Node programs to download and scrape
    content. Work was classified into spidering, downloading, and scraping. Swarms
    of Node processes would take work from queues, and then push new jobs back to
    queues as well.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是一个使用Node程序下载和抓取内容的搜索引擎。工作被分类为爬虫、下载和抓取。Node进程的集群会从队列中获取工作，然后将新任务推回队列。
- en: There are several implementations of RabbitMQ clients on npm—we used amqplib
    ([https://www.npmjs.org/package/amqplib](https://www.npmjs.org/package/amqplib)).
    There are also competitors to RabbitMQ—zeromq ([http://zeromq.org/](http://zeromq.org/))
    is a highly focused and simple alternative.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: npm 上有几种 RabbitMQ 客户端的实现——我们使用了 amqplib ([https://www.npmjs.org/package/amqplib](https://www.npmjs.org/package/amqplib))。还有
    RabbitMQ 的竞争对手——zeromq ([http://zeromq.org/](http://zeromq.org/)) 是一个高度专注且简单的替代品。
- en: Another option is to use a hosted publish/subscribe service. One example of
    this is Pusher ([http://pusher.com/](http://pusher.com/)), which uses WebSockets
    to help scale applications. The advantage of this approach is that Pusher can
    message anything, including mobile clients. Rather than restricting messaging
    to your Node programs, you can create message channels that web, mobile, and even
    desktop clients can subscribe to.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用托管发布/订阅服务。一个例子是 Pusher ([http://pusher.com/](http://pusher.com/))，它使用
    WebSocket 来帮助扩展应用。这种方法的优点是 Pusher 可以发送任何消息，包括移动客户端。你不必将消息限制在 Node 程序中，可以创建消息通道，供网页、移动甚至桌面客户端订阅。
- en: Finally, if you’re using private servers, you’ll need to monitor resource usage.
    StrongLoop ([http://strongloop.com/](http://strongloop.com/)) offers monitoring
    and clustering tools for Node, and New Relic (New Relic) also now has Node-specific
    features. New Relic can help you break down where time is being spent in a live
    application, so you can use it to discover bottlenecks in database access, view
    rendering, and application logic.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你正在使用私有服务器，你需要监控资源使用情况。StrongLoop ([http://strongloop.com/](http://strongloop.com/))
    为 Node 提供了监控和集群工具，而 New Relic (New Relic) 也现在有了针对 Node 的特定功能。New Relic 可以帮助你分析实时应用中时间花费的地方，因此你可以用它来发现数据库访问、视图渲染和应用逻辑中的瓶颈。
- en: With service providers like Heroku, Nodejitsu, and Microsoft, and the tools
    provided by StrongLoop and New Relic, running Node software in production has
    rapidly matured and become entirely feasible.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 Heroku、Nodejitsu 和 Microsoft 这样的服务提供商，以及 StrongLoop 和 New Relic 提供的工具，运行
    Node 软件在生产环境中已经迅速成熟并变得完全可行。
- en: 12.5\. Summary
  id: totrans-1788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5. 摘要
- en: 'In this chapter you’ve seen how to run Node on PaaS providers, including Heroku,
    Nodejitsu, and Windows Azure. You’ve also learned about the issues of running
    Node on private servers: safely accessing port 80 ([technique 98](#ch12lev2sec3)),
    and how WebSockets relate to production requirements ([technique 100](#ch12lev2sec5)).'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何在 PaaS 提供商上运行 Node，包括 Heroku、Nodejitsu 和 Windows Azure。你还学习了在私有服务器上运行
    Node 的问题：安全访问端口 80（[技术 98](#ch12lev2sec3)）以及 WebSocket 如何与生产需求相关（[技术 100](#ch12lev2sec5)）。
- en: No matter how fast your code is, if your application is popular, then you may
    run into performance issues. In our section on scaling, you’ve learned all about
    caching ([technique 101](#ch12lev2sec6)), proxies ([technique 102](#ch12lev2sec7)),
    and scaling with `cluster` ([technique 103](#ch12lev2sec8)).
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的代码有多快，如果你的应用很受欢迎，那么你可能会遇到性能问题。在我们的扩展部分，你已经学习了所有关于缓存（[技术 101](#ch12lev2sec6)）、代理（[技术
    102](#ch12lev2sec7)）和用 `cluster` 扩展（[技术 103](#ch12lev2sec8)）的内容。
- en: To keep your application running solidly, we’ve included maintenance-related
    techniques on npm in production ([technique 104](#ch12lev2sec9)) and logging ([technique
    105](#ch12lev2sec10)). Now if anything goes wrong, you should have enough information
    to solve the problem.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的应用稳定运行，我们在 npm 上包含了与维护相关的技术（[技术 104](#ch12lev2sec9)）和日志记录（[技术 105](#ch12lev2sec10)）。现在，如果出现任何问题，你应该有足够的信息来解决它。
- en: Now you should know how to build Node web applications and release them in a
    maintainable and scalable state.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该知道如何构建 Node 网络应用并以可维护和可扩展的状态发布它们。
