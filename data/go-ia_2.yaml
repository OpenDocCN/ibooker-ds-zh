- en: Chapter 3\. Packaging and tooling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 打包和工具
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Understanding how Go code is organized
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Go 代码的组织方式
- en: Using the Go command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 命令
- en: Going farther with other Go developer tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步使用其他 Go 开发者工具
- en: Collaborating with other Go developers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他 Go 开发者协作
- en: In [chapter 2](kindle_split_010.html#ch02) you got an overview of the syntax
    and language structure of Go. Now you’ll dive deeper into how code is organized
    into packages and how you interact with those packages. Packages are a critical
    concept in Go. The idea is to separate semantic units of functionality into different
    packages. When you do this, you enable code reuse and control the use of the data
    inside each package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_010.html#ch02) 中，你了解了 Go 的语法和语言结构概述。现在，你将深入了解代码是如何组织成包以及如何与这些包交互的。包是
    Go 中的一个关键概念。想法是将功能语义单元分离到不同的包中。当你这样做时，你就可以实现代码重用并控制每个包内部数据的使用。
- en: Before we get into the particulars, you should already be familiar with the
    command prompt or system shell, and you should have Go installed according to
    the guidelines in the preface of this book. If you’re ready, let’s start by understanding
    what a package is and why it’s important in the Go ecosystem.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，你应该已经熟悉命令提示符或系统外壳，并且应该根据本书前言中的指南安装了 Go。如果你准备好了，让我们先了解什么是包以及为什么它在 Go
    生态系统中很重要。
- en: 3.1\. Packages
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 包
- en: 'All Go programs are organized into groups of files called *packages*, so that
    code has the ability to be included into other projects as smaller reusable pieces.
    Let’s look at the packages that make up Go’s `http` functionality in the standard
    library:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Go 程序都组织成称为 *包* 的文件组，这样代码就有能力作为更小的可重用部分被包含到其他项目中。让我们看看组成 Go 标准库中 `http` 功能的包：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These directories contain a series of related files with the .go extension,
    and provide clear separation of smaller units of code relating to the implementation
    of HTTP servers, clients, and utilities to test and profile them. For example,
    the `cookiejar` package contains code related to storing and retrieving cookies
    from a web session. Each package can be imported and used individually so that
    developers can import only the specific functionality that they need. If you’re
    implementing an HTTP client, you only need to import the `http` package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录包含一系列具有 .go 扩展名的相关文件，并为与 HTTP 服务器、客户端的实现以及测试和性能分析相关的较小代码单元提供了清晰的分离。例如，`cookiejar`
    包包含与从网络会话中存储和检索 Cookie 相关的代码。每个包都可以单独导入和使用，这样开发者就可以只导入他们需要的特定功能。如果你正在实现 HTTP 客户端，你只需要导入
    `http` 包。
- en: All .go files must declare the package that they belong to as the first line
    of the file excluding whitespace and comments. Packages are contained in a single
    directory. You may not have multiple packages in the same directory, nor may you
    split a package across multiple directories. This means that all .go files in
    a single directory must declare the same package name.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 .go 文件都必须在文件的第一行（不包括空白和注释）声明它们所属的包。包包含在单个目录中。你不可能在同一个目录中有多个包，也不能将一个包拆分到多个目录中。这意味着一个目录中的所有
    .go 文件都必须声明相同的包名。
- en: 3.1.1\. Package-naming conventions
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 包命名约定
- en: The convention for naming your package is to use the name of the directory containing
    it. This has the benefit of making it clear what the package name is when you
    import it. If we continue with our example from the `net/http` package, all the
    files contained within the `http` directory are a part of the `http` package.
    When naming your packages and their directories, you should use short, concise,
    lowercase names, because they will be typed often while you’re developing. The
    packages under `net/http` are great examples of concise names such as `cgi`, `httputil`,
    and `pprof`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的包命名时，应使用包含它的目录的名称。这样做的好处是，当你导入它时，可以清楚地知道包名。如果我们继续以 `net/http` 包为例，`http`
    目录中包含的所有文件都是 `http` 包的一部分。在命名你的包及其目录时，应使用简短、简洁的小写名称，因为你在开发过程中会经常输入它们。`net/http`
    下的包是简洁命名的好例子，如 `cgi`、`httputil` 和 `pprof`。
- en: Keep in mind that a unique name is not required, because you import the package
    using its full path. Your package name is used as the default name when your package
    is imported, but it can be overridden. This is beneficial when you need to import
    multiple packages with the same name. We’ll discuss how this is done in [section
    3.2](#ch03lev1sec2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不需要唯一的名称，因为你可以使用其完整路径来导入包。你的包名在导入包时用作默认名称，但可以被覆盖。当你需要导入具有相同名称的多个包时，这很有用。我们将在
    [3.2 节](#ch03lev1sec2) 中讨论如何实现这一点。
- en: 3.1.2\. Package main
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. main 包
- en: The package name `main` has special meaning in Go. It designates to the Go command
    that this package is intended to be compiled into a binary executable. All of
    the executable programs you build in Go must have a package called `main`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，包名 `main` 具有特殊含义。它指定了该包将被编译成二进制可执行文件的 Go 命令。你用 Go 语言构建的所有可执行程序都必须有一个名为
    `main` 的包。
- en: When the `main` package is encountered by the compiler, it must also find a
    function called `main()`; otherwise a binary executable won’t be created. The
    `main()` function is the entry point for the program, so without one, the program
    has no starting point. The name of the final binary will take the name of the
    directory the `main` package is declared in.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到 `main` 包时，它还必须找到一个名为 `main()` 的函数；否则不会创建二进制可执行文件。`main()` 函数是程序的入口点，所以如果没有它，程序就没有起始点。最终二进制文件的名字将采用声明
    `main` 包的目录的名称。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Commands and packages
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命令和包
- en: The Go documentation uses the term *command* frequently to refer to an executable
    program—like a command-line application. This can be confusing for new Go developers
    who are reading the documentation. Remember that in Go, a command is any executable
    program, in contrast to a package, which generally means an importable semantic
    unit of functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的文档经常使用术语 *命令* 来指代可执行程序——就像命令行应用程序。这对阅读文档的新 Go 开发者来说可能会有些困惑。记住，在 Go 语言中，命令是任何可执行程序，而与包相对，包通常意味着一个可导入的功能语义单元。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Go ahead and try it out. First start by creating a file called hello.go inside
    GOPATH/ src/hello/, and type the contents of [listing 3.1](#ch03ex01) into it.
    This is the traditional Hello World! application again, but as you look at it,
    pay attention to the package declaration and import statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。首先在 GOPATH/src/hello/ 目录下创建一个名为 hello.go 的文件，并将 [列表 3.1](#ch03ex01) 的内容输入进去。这是传统的
    Hello World! 应用程序，但当你查看它时，请注意包声明和导入语句。
- en: Listing 3.1\. Traditional Hello World! application
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 传统的 Hello World! 应用程序
- en: '![](041fig01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](041fig01_alt.jpg)'
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Getting package documentation
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取包文档
- en: Don’t forget that you can get more details on a package by visiting [http://golang.org/pkg/fmt/](http://golang.org/pkg/fmt/)
    or running `godoc fmt` from your terminal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以通过访问 [http://golang.org/pkg/fmt/](http://golang.org/pkg/fmt/) 或在终端运行
    `godoc fmt` 来获取有关包的更多详细信息。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once you’ve saved the file, you can run the command `go build` from within the
    GOPATH/src/hello/ directory. When it completes, you should see a binary file.
    On Unix, Linux, and Mac OS X this file will be named hello, whereas on Windows
    it will be called hello.exe. You can now run this application and see Hello World!
    printed to your console.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，你可以在 GOPATH/src/hello/ 目录下运行 `go build` 命令。完成之后，你应该会看到一个二进制文件。在 Unix、Linux
    和 Mac OS X 上，该文件将被命名为 hello，而在 Windows 上则会被命名为 hello.exe。现在你可以运行这个应用程序，并看到 Hello
    World! 打印到你的控制台。
- en: Had you named the package something other than `main`, like `hello` for instance,
    you’d have been telling the compiler this is just a package, not a command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将包命名为 `main` 以外的名称，比如 `hello`，那么你就是在告诉编译器这只是一个包，而不是一个命令。
- en: Listing 3.2\. Invalid Go program with `main` function
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 包含 `main` 函数的无效 Go 程序
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 3.2\. Imports
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 导入
- en: Now that we’ve looked at the organization of code into packages, we’ll take
    a look at how to import these individual packages so that you can access the code
    contained within them. The `import` statement tells the compiler where to look
    on disk to find the package you want to import. You import packages by using the
    keyword `import`, which tells the compiler that you want to reference the code
    contained within the package at that file location. If you need to import more
    than one package, the idiomatic way of doing so is to wrap the import statements
    in an import block, as demonstrated here.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了代码组织成包的方式，我们将看看如何导入这些单个包，这样你就可以访问它们包含的代码。`import`语句告诉编译器在哪里查找磁盘以找到你想要导入的包。你通过使用关键字`import`来导入包，这告诉编译器你想要引用该文件位置中包包含的代码。如果你需要导入多个包，按照惯例，你可以将导入语句包裹在一个导入块中，如下所示。
- en: Listing 3.3\. Import statement blocks
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 导入语句块
- en: '![](042fig01_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](042fig01_alt.jpg)'
- en: Packages are found on disk based on their relative path to the directories referenced
    by the Go environment. Packages in the standard library are found under where
    Go is installed on your computer. Packages that are created by you or other Go
    developers live inside the `GOPATH`, which is your own personal workspace for
    packages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 包是根据它们相对于Go环境引用的目录的相对路径在磁盘上找到的。标准库中的包可以在你的计算机上Go安装的位置找到。你或其他Go开发者创建的包位于`GOPATH`中，这是你自己的个人包工作区。
- en: 'Let’s take a look at an example. If Go was installed under /usr/local/go and
    your `GOPATH` was set to /home/myproject:/home/mylibraries, the compiler would
    look for the `net/http` package in the following order:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。如果Go安装在`/usr/local/go`下，你的`GOPATH`设置为`/home/myproject:/home/mylibraries`，编译器将按以下顺序寻找`net/http`包：
- en: '![](042fig02_alt.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](042fig02_alt.jpg)'
- en: The compiler will stop searching once it finds a package that satisfies the
    import statement. The important thing to remember is that the Go installation
    directory is the first place the compiler looks and then each directory listed
    in your `GOPATH` in the order that they’re listed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器一旦找到满足导入语句的包，就会停止搜索。重要的是要记住，Go安装目录是编译器首先搜索的地方，然后是按照列表顺序在你的`GOPATH`中列出的每个目录。
- en: If the compiler searches your `GOPATH` and never finds the package that you’ve
    referenced, you’ll get an error when you try to run or build your program. You’ll
    see how to use the `go get` command to fix those problems later in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器搜索你的`GOPATH`却找不到你引用的包，当你尝试运行或构建程序时，你会得到一个错误。你将在本章后面看到如何使用`go get`命令来解决这些问题。
- en: 3.2.1\. Remote imports
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 远程导入
- en: There’s a huge trend toward sharing code via distributed version control systems
    (DVCS) such as sharing sites like GitHub, Launchpad, and Bitbucket. The Go tooling
    has built-in support for fetching source code from these sites and others. The
    import path can be used by the Go tooling to determine where the code you need
    fetched is on the network.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分布式版本控制系统（DVCS）如GitHub、Launchpad和Bitbucket等共享代码的趋势正在迅速增长。Go工具集内置了对从这些站点和其他站点获取源代码的支持。导入路径可以被Go工具集用来确定需要从网络上获取的代码的位置。
- en: 'For example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you try to build a program with this import path, the `go build` command
    will search the `GOPATH` for this package location on disk. The fact that it represents
    a URL to a repository on GitHub is irrelevant as far as the `go build` command
    is concerned. When an import path contains a URL, the Go tooling can be used to
    fetch the package from the DVCS and place the code inside the `GOPATH` at the
    location that matches the URL. This fetching is done using the `go get` command.
    `go get` will fetch any specified URL or can be used to fetch the dependencies
    a package is importing that are go-gettable. Since `go get` is recursive, it can
    walk down the source tree for a package and fetch all the dependencies it finds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用这个导入路径构建程序时，`go build`命令将在磁盘上搜索这个包的位置。对于`go build`命令来说，它代表GitHub上的存储库的URL是不相关的。当一个导入路径包含URL时，可以使用Go工具从DVCS获取包，并将代码放置在`GOPATH`中与URL匹配的位置。这个获取操作是通过`go
    get`命令完成的。`go get`可以获取任何指定的URL，也可以用来获取包导入的依赖项，这些依赖项是可以通过`go get`获取的。由于`go get`是递归的，它可以遍历包的源代码树并获取它找到的所有依赖项。
- en: 3.2.2\. Named imports
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 命名导入
- en: What happens when you need to import multiple packages with the same name? For
    example, you could need a `network/convert` package for converting data that’s
    read from a network and a `file/convert` package for converting data read from
    text files. When this is the case, both of these packages can be imported by using
    *named imports*. This is performed by giving one of the packages a new name to
    the left of the `import` statement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要导入具有相同名称的多个包时会发生什么？例如，你可能需要一个`network/convert`包来转换从网络读取的数据，以及一个`file/convert`包来转换从文本文件读取的数据。在这种情况下，这两个包都可以通过使用*命名导入*来导入。这是通过在`import`语句左侧给其中一个包赋予一个新名称来实现的。
- en: As an example, let’s say you were already using the `fmt` package that comes
    as part of the standard library. Now you need to import a package named `fmt`
    that you had created as part of your own project. You can import your own `fmt`
    package by renaming the import, as demonstrated in the next listing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你已经使用了标准库中的`fmt`包。现在你需要导入一个名为`fmt`的包，它是你项目的一部分。你可以通过重命名导入来导入你自己的`fmt`包，如下一列表所示。
- en: Listing 3.4\. Renaming imports
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 重命名导入
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Go compiler will fail the build and output an error whenever you import
    a package that you don’t use. The Go team considers this a feature to eliminate
    code bloat from packages that are imported but not used. Although this feature
    is occasionally annoying, the Go team has put a great deal of effort into making
    decisions to prevent some of the problems that you encounter in other languages.
    You don’t want to have an unnecessarily large binary, filled with unused libraries,
    and they feel that if it’s worth the compiler telling you about, it’s worth failing
    the build. Anyone who has compiled a large C program knows just how hard it can
    be to pinpoint the things that matter in a sea of compiler warnings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个你未使用的包时，Go编译器将失败构建并输出错误。Go团队认为这是一个特性，用于消除未使用但导入的包中的代码膨胀。尽管这个特性有时会令人烦恼，但Go团队已经投入了大量精力来做出决策，以防止你在其他语言中遇到的一些问题。你不想有一个不必要的大的二进制文件，充满了未使用的库，他们认为如果编译器告诉你这一点，那么构建失败也是值得的。任何编译过大型C程序的人都知道，在编译器警告的海洋中确定重要的事情是多么困难。
- en: Sometimes you may need to import a package that you don’t need to reference
    identifiers from. You’ll see why this might be useful in the next section. When
    this is the case, you can use the blank identifier `_` to rename an import.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要导入一个你不需要引用标识符的包。你将在下一节中看到这可能会很有用。在这种情况下，你可以使用空白标识符`_`来重命名一个导入。
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Blank identifier
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 空白标识符
- en: The `_` (underscore character) is known as the *blank identifier* and has many
    uses within Go. It’s used when you want to throw away the assignment of a value,
    including the assignment of an import to its package name, or ignore return values
    from a function when you’re only interested in the others.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`（下划线字符）被称为*空白标识符*，在Go中有许多用途。当你想要丢弃一个值的赋值，包括将导入赋值给其包名，或者当你只对其他返回值感兴趣时忽略函数的返回值时，就会用到它。'
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3\. init
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 初始化
- en: Each package has the ability to provide as many `init` functions as necessary
    to be invoked at the beginning of execution time. All the `init` functions that
    are discovered by the compiler are scheduled to be executed prior to the `main`
    function being executed. The `init` functions are great for setting up packages,
    initializing variables, or performing any other bootstrapping you may need prior
    to the program running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都有能力提供必要的`init`函数，以便在执行时间开始时调用。编译器发现的所有的`init`函数都安排在`main`函数执行之前执行。`init`函数非常适合设置包、初始化变量或执行程序运行之前可能需要的任何其他引导操作。
- en: An example of this is database drivers. They register themselves with the `sql`
    package when their `init` function is executed at startup because the `sql` package
    can’t know about the drivers that exist when it’s compiled. Let’s look at an example
    of what an `init` function might do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个例子是数据库驱动程序。当它们的`init`函数在启动时执行时，它们会将自己注册到`sql`包中，因为`sql`包在编译时无法知道存在的驱动程序。让我们看看一个`init`函数可能执行的操作的例子。
- en: Listing 3.5\. `init` function usage
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.5\. `init`函数使用
- en: '![](044fig01_alt.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](044fig01_alt.jpg)'
- en: This code lives inside your pretend database driver for the PostgreSQL database.
    When a program imports this package, the `init` function will be called, causing
    the database driver to be registered with Go’s `sql` package as an available driver.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码位于你虚构的 PostgreSQL 数据库驱动程序内部。当程序导入这个包时，`init` 函数将被调用，导致数据库驱动程序在 Go 的 `sql`
    包中注册为可用驱动程序。
- en: In the program that we write using this new database driver, we’ll use the blank
    identifier to import the package so the new driver is included with the `sql`
    package. As stated earlier, you can’t import a package that you aren’t using,
    so renaming the import with the blank identifier allows the `init` function to
    be discovered and scheduled to run without the compiler issuing an error about
    unused imports.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用这个新数据库驱动程序编写的程序中，我们将使用空标识符来导入包，以便新驱动程序与 `sql` 包一起包含。如前所述，你不能导入你未使用的包，因此使用空标识符重命名导入允许
    `init` 函数被找到并安排运行，而不会导致编译器发出关于未使用导入的错误。
- en: Now we can tell the `sql.Open` method to use this driver.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以告诉 `sql.Open` 方法使用这个驱动程序。
- en: Listing 3.6\. Blank identifier import aliasing
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 空标识符导入别名
- en: '![](045fig01_alt.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](045fig01_alt.jpg)'
- en: 3.4\. Using Go tools
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 使用 Go 工具
- en: 'We’ve been working with the `go` tool for a few chapters now, but we haven’t
    explored all it can do. Let’s dive a little deeper into this diminutively named
    powerhouse and explore more of its capabilities. From a shell prompt, type the
    `go` command with no arguments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用 `go` 工具工作了几个章节，但我们还没有探索它所能做的所有事情。让我们更深入地研究这个名字简短的强大工具，并探索更多它的功能。从 shell
    提示符中，不带参数输入 `go` 命令：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in [figure 3.1](#ch03fig01), there are a lot of features buried
    in the `go` tooling.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 3.1](#ch03fig01) 所示，`go` 工具集中隐藏了很多功能。
- en: Figure 3.1\. Output of `go` command help text
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. `go` 命令帮助文本的输出
- en: '![](03fig01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig01.jpg)'
- en: 'Looking through the list, you can see that there really is a compiler in there;
    it’s used by the `build` command. The `build` and `clean` commands do exactly
    what you’d expect them to do. Try them now using the source code from [listing
    3.2](#ch03ex02):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表，你会发现其中确实有一个编译器；它被 `build` 命令所使用。`build` 和 `clean` 命令确实做了你期望它们做的事情。现在，请使用
    [列表 3.2](#ch03ex02) 中的源代码尝试它们：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You might not want that file hanging around when it’s time to check your code
    into source control. To get rid of it, use the `clean` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备将代码检查到源代码控制时，可能不希望那个文件还挂在那里。要删除它，请使用 `clean` 命令：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After calling `clean`, the executable program is gone. Let’s take a closer look
    at some of the features of the `go` tool, and ways that you can save time when
    you’re using it. For the next examples, we’ll use the sample code in the following
    listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `clean` 命令后，可执行程序将消失。让我们更深入地了解一下 `go` 工具的一些特性，以及在使用它时可以节省时间的方法。在接下来的示例中，我们将使用以下列表中的示例代码。
- en: Listing 3.7\. Working with the `io` package
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.7\. 使用 `io` 包
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’ve downloaded the source code for the book, this package should be at
    GOPATH/src/github.com/goinaction/code/chapter3/words. Make sure you have it there
    to follow along.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经下载了本书的源代码，这个包应该在 GOPATH/src/github.com/goinaction/code/chapter3/words。确保你已经在那里，以便跟随。
- en: 'Most of the commands that are part of the Go tooling take a package specifier
    as an argument. Look closer at the commands we’ve just used, and you’ll see one
    of the shortcuts built into the tooling. You can omit the filename of the source
    code file that you want to build, and the `go` tool will default to *the current
    package*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具集的大部分命令都接受包指定符作为参数。更仔细地看看我们刚刚使用的命令，你会发现工具集内置了一个快捷方式。你可以省略你想要构建的源代码文件的文件名，`go`
    工具将默认为 *当前包*：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Building a package is a common practice, and the package can also be specified
    directly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个包是一种常见的做法，你也可以直接指定包：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also specify wildcards in your package specifiers. Three periods in
    your package specifier indicate a pattern matching any string. For example, the
    following command will build every package under the `chapter3` directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的包指定符中指定通配符。在你的包指定符中有三个点表示匹配任何字符串的模式。例如，以下命令将构建 `chapter3` 目录下的所有包：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead of a package specifier, you can also use a path shortcut as an argument
    to most of the Go commands. For example, you could achieve the same effect with
    these two commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包指定符之外，你还可以使用路径快捷方式作为大多数 Go 命令的参数。例如，你可以使用这两个命令达到相同的效果：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To execute this program, you need to run the `wordcount` or `wordcount.exe`
    program that was created after the build. But there’s a different command that
    can perform both operations in a single call:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此程序，你需要运行在构建后创建的 `wordcount` 或 `wordcount.exe` 程序。但有一个不同的命令可以在单个调用中执行这两个操作：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `go run` command both builds and executes the program contained in `wordcount.go`,
    which saves a lot on typing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run` 命令既构建又执行 `wordcount.go` 中包含的程序，这大大减少了输入量。'
- en: You’ll use the `go build` and `go run` commands the most when you’re developing.
    Let’s take a look at a few of the other available commands and see what they can
    do.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发时，你将最频繁地使用 `go build` 和 `go run` 命令。让我们看看一些其他可用的命令，看看它们能做什么。
- en: 3.5\. Going farther with Go developer tools
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5\. 使用 Go 开发者工具进一步探索
- en: You’ve seen how to compile and run your Go programs using the convenient `go`
    tool. But that handy little developer tool has a lot of other tricks hidden inside.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用方便的 `go` 工具编译和运行你的 Go 程序。但这个小巧的开发者工具里面还隐藏着很多其他技巧。
- en: 3.5.1\. go vet
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1\. go vet
- en: 'It won’t write code for you, but once you’ve written some code, the `vet` command
    will check your code for common errors. Let’s look at the types of errors `vet`
    can catch:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会为你编写代码，但一旦你编写了一些代码，`vet` 命令将检查你的代码中的常见错误。让我们看看 `vet` 可以捕获的错误类型：
- en: Bad parameters in `Printf`-style function calls
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Printf` 风格函数调用中的参数错误'
- en: Method signature errors for common method definitions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见方法定义的方法签名错误
- en: Bad struct tags
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体标签错误
- en: Unkeyed composite literals
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未标记的复合字面量
- en: Let’s look at a mistake many new Go developers make. The `fmt.Printf` function
    is a great way to produce formatted output, but the function requires you to remember
    all the different format specifiers. The following listing is an example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看许多新 Go 开发者会犯的一个错误。`fmt.Printf` 函数是生成格式化输出的好方法，但该函数要求你记住所有不同的格式说明符。以下是一个示例。
- en: Listing 3.8\. Working with `go vet`
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 使用 `go vet`
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This program inserts the floating-point number 3.14, but there’s no placeholder
    in the formatted string. If you run `go vet` against this source code, you get
    the following message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序插入浮点数 3.14，但格式化字符串中没有占位符。如果你对此源代码运行 `go vet`，你会得到以下消息：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `go vet` tool won’t keep you from making huge errors in logic, or from creating
    buggy code. However, as you can see from the last example, it does catch some
    common errors quite nicely. It’s a great idea to get in the habit of running `go
    vet` on your code base before you commit it to a source repository.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`go vet` 工具不会阻止你在逻辑上犯大错误，或创建有缺陷的代码。然而，正如你从最后一个示例中看到的，它确实很好地捕获了一些常见错误。在你将代码提交到源代码库之前运行
    `go vet` 是一个好主意。'
- en: 3.5.2\. Go format
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. Go 格式
- en: 'The `fmt` command is a favorite in the Go community. Instead of arguing about
    where curly braces should go, or whether to use tabs or spaces when you indent,
    the `fmt` tool makes these decisions moot by applying a predetermined layout to
    Go source code. To invoke this code formatter, type `go fmt` followed by a file
    or package specification. The `fmt` command will automatically format the source
    code files you specify and save them. Here’s a before-and-after snapshot of a
    few lines of code run through `go fmt`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 命令是 Go 社区中的最爱。而不是争论花括号应该放在哪里，或者缩进时是使用制表符还是空格，`fmt` 工具通过应用预定的布局到 Go 源代码来使这些决定变得无关紧要。要调用此代码格式化工具，请输入
    `go fmt` 后跟文件或包规范。`fmt` 命令将自动格式化你指定的源代码文件并将它们保存。以下是经过 `go fmt` 处理的几行代码的前后快照：'
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running `go fmt` on this code, you’ll get the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在对此代码运行 `go fmt` 之后，你会得到以下结果：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many Go developers configure their development environment to perform a `go
    fmt` on save or before committing to a code repository. Do yourself a favor and
    configure this right now.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Go 开发者将他们的开发环境配置为在保存或提交到代码仓库之前执行 `go fmt`。现在就为自己做这件事吧。
- en: 3.5.3\. Go documentation
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.3\. Go 文档
- en: There’s another tool that will make your Go development process easier. Go has
    two ways to deliver documentation to developers. If you’re working at a command
    prompt, you can use the `go doc` command to print documentation directly to your
    terminal session. You can view a quick reference for a command or package without
    leaving your terminal. But if a browsable interface is more your speed, you can
    use the `godoc` program to start a web server with a clickable index of Go packages.
    The `godoc` web server gives you a fully navigable web version of the documentation
    for all the Go source code installed in your system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个工具可以使您的 Go 开发过程更加容易。Go 有两种方式将文档提供给开发者。如果您在命令提示符下工作，可以使用 `go doc` 命令直接将文档打印到您的终端会话。您可以在不离开终端的情况下查看命令或包的快速参考。但如果浏览界面更符合您的速度，您可以使用
    `godoc` 程序启动一个带有可点击索引的 Go 包的网络服务器。`godoc` 网络服务器为您提供系统上安装的所有 Go 源代码的文档的完全可导航的网页版本。
- en: Getting documentation at the command line
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在命令行中获取文档
- en: 'If you’re the kind of developer who has a text editor open and a terminal session
    open right next to it (or a text editor open in your terminal session), then `go
    doc` is going to be your tool of choice. The first time you need to read a Unix
    `tar` file from your Go application, you’ll be happy that you can access the documentation
    for the `archive/tar` package by simply typing this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是那种同时打开文本编辑器和终端会话（或在终端会话中打开文本编辑器）的开发者，那么 `go doc` 将是您首选的工具。当您第一次需要从您的 Go
    应用程序中读取 Unix `tar` 文件时，您会很高兴地发现，只需输入以下内容即可通过 `archive/tar` 包的文档：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this command produces the following output, directly to the terminal:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将在终端中直接产生以下输出：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can skim through the documentation and find the information you need without
    breaking your workflow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以浏览文档并找到所需的信息，而不会打断您的流程。
- en: Browsing the documentation
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浏览文档
- en: The Go documentation is also available in a browsable format. Sometimes it’s
    easier to get the whole picture of a package or function when you can click around
    and see all the related details. For those cases, you’ll want to use `godoc` as
    a web server. If you prefer to get your documentation from a web browser in a
    clickable format, then this will be your favorite way to get to the documentation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Go 文档也以可浏览的格式提供。有时，当您可以点击并查看所有相关细节时，更容易了解一个包或函数的全貌。在这种情况下，您会想使用 `godoc` 作为网络服务器。如果您更喜欢以可点击的格式从网页浏览器中获取文档，那么这将是最受您欢迎的获取文档的方式。
- en: 'To start your own documentation server, type the following command into a terminal
    session:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动自己的文档服务器，请在终端会话中输入以下命令：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command instructs `godoc` to start a web server on port 6060\. If you open
    your web browser and navigate to http://localhost:6060, you’ll see a web page
    with documentation for both the Go standard libraries and any Go source that lives
    in your `GOPATH`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令指示 `godoc` 在端口 6060 上启动一个网络服务器。如果您打开网页浏览器并导航到 http://localhost:6060，您将看到一个包含
    Go 标准库和您 `GOPATH` 中任何 Go 源代码的文档的网页。
- en: If the documentation in [figure 3.2](#ch03fig02) looks familiar to you, it’s
    because a slightly modified version of `godoc` is serving up the documentation
    for the Go website. To navigate to the documentation for a specific package, just
    click the Packages link at the top of the page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 [图 3.2](#ch03fig02) 中的文档对您来说很熟悉，那是因为 `godoc` 的一个略微修改的版本正在提供 Go 网站的文档。要导航到特定包的文档，只需点击页面顶部的“包”链接。
- en: Figure 3.2\. Local Go documentation
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 本地 Go 文档
- en: '![](03fig02_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![03fig02_alt.jpg](03fig02_alt.jpg)'
- en: The best part of Go’s documentation tool is that it works for your code, too.
    If you follow simple conventions while writing your code, it will automatically
    include your comments in the Go documentation generated by `godoc`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go 文档工具的最佳之处在于它也适用于您的代码。如果您在编写代码时遵循简单的约定，它将自动将您的注释包含在由 `godoc` 生成的 Go 文档中。
- en: To be included in the `godoc` generated documentation, your code needs to be
    documented by adding comments that follow a specific convention. We won’t go through
    the whole convention in this chapter, but we’ll hit the highlights.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含在 `godoc` 生成的文档中，您的代码需要通过添加遵循特定约定的注释来进行文档化。我们不会在本章中详细介绍整个约定，但我们会介绍要点。
- en: Start by adding comments directly above the identifiers you want to document.
    This works for packages, functions, types, and global variables. Comments can
    be started using either two slashes, or using the slash-asterisk style.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在你想记录的标识符上方添加注释。这适用于包、函数、类型和全局变量。注释可以使用两个斜杠或斜杠星号风格开始。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we show the idiomatic way to document a function in Go. The
    documentation for the function immediately precedes the function and is written
    in complete sentences. If you want to add a large body of text to document your
    package, include a file called doc.go that declares the same package as your project,
    and put your package introduction as a comment before the package declaration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了在 Go 中记录函数的惯用方法。函数的文档紧随函数之后，并以完整的句子书写。如果你想添加大量文本来记录你的包，请包含一个名为 doc.go
    的文件，该文件声明与你的项目相同的包，并在包声明之前将包介绍作为注释：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This package documentation will be shown before any type or function documentation
    is displayed for your package. It also demonstrates using the slash-asterisk type
    of comment. You can read more about creating good documentation for your code
    by searching for *golang documentation* in Google.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包的文档将在显示你的包的任何类型或函数文档之前显示。它还演示了使用斜杠星号类型的注释。你可以在 Google 中搜索 *golang documentation*
    来了解更多关于为你的代码创建良好文档的信息。
- en: 3.6\. Collaborating with other Go developers
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6. 与其他 Go 开发者协作
- en: Modern developers don’t code in a vacuum, and the Go tooling recognizes and
    embraces this fact. The concept of packages extends beyond your local development
    environment, thanks to the `go` tool. Let’s look at a few conventions to follow
    in order to be a good citizen in a distributed development environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发者不会在真空中编码，Go 工具承认并接受这一事实。由于 `go` 工具的存在，包的概念超越了你的本地开发环境。让我们看看在分布式开发环境中成为良好公民应遵循的一些约定。
- en: 3.6.1\. Creating repositories for sharing
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.6.1. 创建用于共享的仓库
- en: Once you start cranking out awesome Go code, you’re probably going to want to
    share that code with the rest of the Go community. It’s really easy as long as
    you follow a few simple steps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始编写出色的 Go 代码，你很可能会想要与 Go 社区分享这些代码。只要你遵循几个简单的步骤，这其实非常容易。
- en: Package should live at the root of the repository
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包应该位于仓库的根目录
- en: When you’re using `go get`, you specify the full path to the package that should
    be imported. This means that when you create a repository that you intend to share,
    the package name should be the repository name, and the package’s source should
    be in the root of the repository’s directory structure.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `go get` 时，你指定要导入的包的完整路径。这意味着当你创建一个打算共享的仓库时，包名应该是仓库名，并且包的源文件应该位于仓库目录结构的根目录中。
- en: A common mistake that new Go developers make is to create a `code` or `src`
    directory in their public repository. Doing so will make the package’s public
    import longer. Instead, just put the package source files at the root of the public
    repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Go 开发者常犯的一个错误是在他们的公共仓库中创建一个 `code` 或 `src` 目录。这样做会使包的公共导入路径更长。相反，只需将包源文件放在公共仓库的根目录下。
- en: Packages can be small
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包可以很小
- en: It’s common in Go to see packages that are relatively small by the standards
    of other programming languages. Don’t be afraid to make a package that has a small
    API or performs only a single task. That’s normal and expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，看到相对较小的包是很常见的，这在其他编程语言的标准下。不要害怕创建一个具有小型 API 或仅执行单个任务的包。这是正常且预期的。
- en: Run go fmt on the code
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在代码上运行 go fmt
- en: Just like any other open source repository, people will look at your code to
    gauge the quality of it before they try it out. You need to be running `go fmt`
    before checking anything in. It makes your code readable and puts everyone on
    the same page when reading source code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他开源仓库一样，人们在尝试之前会查看你的代码以评估其质量。在提交任何内容之前，你需要运行 `go fmt`。这使得代码可读，并在阅读源代码时使每个人都处于同一页面上。
- en: Document the code
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录代码
- en: Go developers use `godoc` to read documentation, and [http://godoc.org](http://godoc.org)
    to read documentation for open source packages. If you’ve followed `go doc` best
    practices in documenting your code, your packages will appear well documented
    when viewed locally or online, and people will find it easier to use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Go 开发者使用 `godoc` 来阅读文档，并通过 [http://godoc.org](http://godoc.org) 阅读开源包的文档。如果你已经遵循了
    `go doc` 的最佳实践来记录你的代码，你的包在本地或在线查看时将显示为良好文档化的，人们会发现它更容易使用。
- en: 3.7\. Dependency management
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. 依赖项管理
- en: The community has been hard at work since the release of Go 1.0 to provide Go
    tooling that makes life easier for developers. Many of these tools focus on helping
    with dependency management. The most popular tools today are *godep* by Keith
    Rarick, *vendor* by Daniel Theophanes, and a tool by Gustavo Niemeyer called *gopkg.in*,
    which helps package authors publish different versions of their packages.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Go 1.0 发布以来，社区一直在努力工作，提供使开发者生活更轻松的 Go 工具。其中许多工具专注于帮助依赖项管理。目前最受欢迎的工具是 Keith
    Rarick 的 *godep*，Daniel Theophanes 的 *vendor*，以及 Gustavo Niemeyer 开发的名为 *gopkg.in*
    的工具，该工具帮助包作者发布他们包的不同版本。
- en: As a call to action, with version 1.5 the Go language team started to experiment
    with new build options and features to provide better internal tooling support
    for dependency management. While we wait today to see where these experiments
    lead, there are existing tools that provide the ability to manage, build, and
    test Go code in a reproducible way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为行动号召，Go 语言团队从版本 1.5 开始尝试新的构建选项和功能，以提供更好的内部工具支持以进行依赖项管理。虽然我们现在还不知道这些实验将走向何方，但已有现有工具能够以可重复的方式管理、构建和测试
    Go 代码。
- en: 3.7.1\. Vendoring dependencies
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1\. 依赖项的 vendoring
- en: Community tools such as godep and vendor have solved the dependency problem
    by using a technique called *vendoring* and import path rewriting. The idea is
    to copy all the dependencies into a directory inside the project repo, and then
    rewrite any import paths that reference those dependencies by providing the location
    inside the project itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 社区工具如 godep 和 vendor 通过使用称为 *vendoring* 和导入路径重写的技巧解决了依赖项问题。其想法是将所有依赖项复制到项目仓库内的一个目录中，然后通过提供项目内部的位置来重写引用这些依赖项的任何导入路径。
- en: Listing 3.9\. Project using godep
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. 使用 godep 的项目
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Listing 3.9](#ch03ex09) shows a typical source tree when using `godep` to
    vendor the dependencies for a project. You can see how `godep` created a directory
    called `Godeps`. The source code for the dependencies that the tooling vendored
    is located inside another set of directories called `_workspace/src`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.9](#ch03ex09) 展示了使用 `godep` 为项目 vendoring 依赖项时的典型源代码树。您可以看到 `godep` 创建了一个名为
    `Godeps` 的目录。工具 vendored 的依赖项源代码位于另一组名为 `_workspace/src` 的目录中。'
- en: Next, if you look at the `import` statements that are declared inside of `main.go`
    for these dependencies, you’ll see that some things needed to change.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果您查看 `main.go` 中声明的这些依赖项的 `import` 语句，您会看到一些内容需要更改。
- en: Listing 3.10\. Before vendoring
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. vendoring 之前
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 3.11\. After vendoring
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. vendoring 之后
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before the dependencies were vendored, the `import` statements used the canonical
    path for the package. The code was physically located on disk within the scope
    of `GOPATH`. After vendoring, import path rewriting became necessary to reference
    the packages, which are now physically located on disk inside the project itself.
    You can see these imports are very large and tedious to use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖项 vendoring 之前，`import` 语句使用了包的规范路径。代码在 `GOPATH` 范围内磁盘上物理位置。在 vendoring 之后，导入路径重写变得必要，以引用现在物理上位于项目内部的包。您可以看到这些导入非常庞大且使用起来繁琐。
- en: With vendoring, you have the ability to create reproducible builds, since all
    the source code required to build the binary is housed inside the single project
    repo. One other benefit of vendoring and import path rewriting is that the project
    repo is still go-gettable. When `go get` is called against the project repo, the
    tooling can find each package and store the package exactly where it needs to
    be inside the project itself.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 vendoring，您能够创建可重复构建，因为构建二进制文件所需的所有源代码都存放在单个项目仓库中。vendoring 和导入路径重写的另一个好处是项目仓库仍然可以通过
    go-get 获取。当对项目仓库调用 `go get` 时，工具可以找到每个包并将包存储在项目内部所需的确切位置。
- en: 3.7.2\. Introducing gb
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2\. 介绍 gb
- en: Gb is a whole new class of build tool being developed by members of the Go community.
    Gb takes a different approach to solving the reproducible-build problem, which
    starts with the understanding that wrapping the Go tooling is not an option.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Gb 是由 Go 社区成员开发的一种全新的构建工具。Gb 采用不同的方法来解决可重复构建问题，其出发点是理解包装 Go 工具并不是一个可行的选择。
- en: The philosophy behind gb stems from the idea that Go doesn’t have reproducible
    builds because of the `import` statement. The `import` statement drives `go get`,
    but `import` doesn’t contain sufficient information to identify which revision
    of a package should be fetched any time `go get` is called. The possibility that
    `go get` can fetch a different version of code for any given package at any time
    makes supporting the Go tooling in any reproducible solution complicated and tedious
    at best. You saw some of this tediousness with the large import paths when using
    `godep`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Gb背后的哲学源于Go没有可重复构建的想法，因为`import`语句。`import`语句驱动`go get`，但`import`不包含足够的信息来识别在调用`go
    get`时应该获取哪个版本的包。`go get`可以在任何给定包上任何时间获取不同版本的代码的可能性，使得在任何可重复解决方案中支持Go工具集变得复杂且繁琐。你使用`godep`时看到的一些繁琐之处就是这种繁琐性的体现。
- en: This understanding resulted in the creation of the gb build tool. Gb doesn’t
    wrap the Go tooling, nor does it use `GOPATH`. Gb replaces the Go tooling workspace
    metaphor with a project-based approach. This has natively allowed vendoring without
    the need for rewriting import paths, which is mandated by `go get` and a `GOPATH`
    workspace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解导致了Gb构建工具的创建。Gb既不包装Go工具集，也不使用`GOPATH`。Gb用基于项目的方法替换了Go工具集的工作空间隐喻。这天然地允许供应商代码，无需重新编写导入路径，这是`go
    get`和`GOPATH`工作空间所要求的。
- en: Let’s look at how the last project could be converted into a gb project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将最后一个项目转换为Gb项目。
- en: Listing 3.12\. Example of a gb project
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.12\. Gb项目的示例
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A gb project is simply a directory on disk that contains a subdirectory named
    `src/`. The symbol `$PROJECT` refers to the root directory on disk where the `src/`
    directory is located and is only used as a shortcut for describing the location
    on disk for the project. `$PROJECT` is *not* an environmental variable that needs
    to be set. In fact, gb requires no environmental variables to be set at all.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Gb项目只是一个包含名为`src/`的子目录的磁盘目录。符号`$PROJECT`指的是`src/`目录所在的磁盘根目录，并且仅用作描述项目在磁盘上的位置的快捷方式。`$PROJECT`不是一个需要设置的环境变量。实际上，Gb根本不需要设置任何环境变量。
- en: Gb projects differentiate between the code you write and the code your code
    depends on. The code your code depends on is called *vendored code*. A gb project
    makes a clear distinction between your code and vendored code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Gb项目区分了你所编写的代码和你代码所依赖的代码。你所依赖的代码被称为*供应商代码*。Gb项目在你的代码和供应商代码之间做出了明确的区分。
- en: Listing 3.13\. The location for the code you write for the project
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.13\. 为项目编写的代码的位置
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 3.14\. The location of vendored code
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.14\. 供应商代码的位置
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One of the best things about gb is that there’s no need for import path rewriting.
    Look at the `import` statements that are declared inside of main.go—nothing needs
    to change to reference the vendored dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Gb最好的事情之一是无需重新编写导入路径。看看main.go内部声明的`import`语句——没有任何需要改变的内容来引用供应商依赖项。
- en: Listing 3.15\. Import paths for gb projects
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.15\. gb项目的导入路径
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The gb tool will look inside the `$PROJECT/vendor/src/` directory for these
    imports if they can’t be located inside the `$PROJECT/src/` directory first. The
    entire source code for the project is located within a single repo and directory
    on disk, split between the `src/` and `vendor/src/` subdirectories. This, in conjunction
    with no need to rewrite import paths and the freedom to place your project anywhere
    you wish on disk, makes gb a popular tool in the community to develop projects
    that require reproducible builds.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些导入项在`$PROJECT/src/`目录内找不到，Gb工具将查找`$PROJECT/vendor/src/`目录。整个项目的源代码位于磁盘上的单个仓库和目录中，分布在`src/`和`vendor/src/`子目录之间。这一点，结合无需重新编写导入路径和可以在磁盘上的任何位置放置项目的自由，使得Gb成为社区中开发需要可重复构建项目的流行工具。
- en: 'One thing to note: a gb project is not compatible with the Go tooling, including
    `go get`. Since there’s no need for `GOPATH`, and the Go tooling doesn’t understand
    the structure of a gb project, it can’t be used to build, test, or get. Building
    and testing a gb project requires navigating to the `$PROJECT` directory and using
    the gb tool.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是：Gb项目与Go工具集不兼容，包括`go get`。由于无需`GOPATH`，Go工具集也不理解Gb项目的结构，因此无法用于构建、测试或获取。构建和测试Gb项目需要导航到`$PROJECT`目录并使用gb工具。
- en: Listing 3.16\. Building a gb project
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.16\. 构建Gb项目
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Many of the same features that are supported by the Go tooling are supported
    in gb. Gb also has a plugin system to allow the community to extend support. One
    such plugin is called `vendor`, which provides conveniences to manage the dependencies
    in the `$PROJECT/vendor/src/` directory, something the Go tooling does not have
    today. To learn more about gb, check out the website: getgb.io.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具支持的大多数功能在 gb 中也得到了支持。Gb 还有一个插件系统，允许社区扩展支持。其中一个这样的插件叫做 `vendor`，它为管理 `$PROJECT/vendor/src/`
    目录中的依赖提供了便利，这是 Go 工具目前所不具备的。要了解更多关于 gb 的信息，请访问网站：getgb.io。
- en: 3.8\. Summary
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.8. 摘要
- en: Packages are the basic unit of code organization in Go.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包是 Go 中代码组织的基本单元。
- en: Your `GOPATH` determines on disk where Go source code is saved, compiled, and
    installed.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 `GOPATH` 决定了 Go 源代码在磁盘上的保存、编译和安装位置。
- en: You can set your `GOPATH` for each different project, keeping all of your source
    and dependencies separate.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个不同的项目设置你的 `GOPATH`，这样就可以将所有源代码和依赖项分开。
- en: The `go` tool is your best friend when working from the command line.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go` 工具是你在命令行工作时最好的朋友。'
- en: You can use packages created by other people by using `go get` to fetch and
    install them in your `GOPATH`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 `go get` 来获取并安装其他人创建的包到你的 `GOPATH` 中。
- en: It’s easy to create packages for others to use if you host them on a public
    source code repository and follow a few simple rules.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将它们托管在公共源代码仓库中并遵循一些简单的规则，那么很容易为他人创建可用的包。
- en: Go was designed with code sharing as a central driving feature of the language.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 语言的设计将代码共享作为语言的核心驱动功能。
- en: It’s recommended that you use vendoring to manage dependencies.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议你使用 vendoring 来管理依赖。
- en: There are several community-developed tools for dependency management such as
    godep, vendor, and gb.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几个社区开发的依赖管理工具，如 godep、vendor 和 gb。
