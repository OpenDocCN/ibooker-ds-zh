- en: 6 Sharing with the internet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 在互联网上分享
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: The project application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目应用
- en: What a web server does
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器的作用
- en: The Flask microframework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask微框架
- en: Running the server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务器
- en: We’ve covered a lot of material in the previous chapters about being a developer.
    Now we’re going to put that knowledge to work. Choosing an application to create
    is tricky because the possibilities are nearly endless. The project you’ll be
    creating is a small but well-featured blogging platform we’ll be referring to
    as MyBlog. The MyBlog application will be available as a web-based Python application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了很多关于成为一名开发者的内容。现在，我们将把这些知识付诸实践。选择要创建的应用程序是棘手的，因为可能性几乎是无限的。你将创建的项目是一个小型但功能齐全的博客平台，我们将称之为MyBlog。MyBlog应用程序将以基于Web的Python应用程序的形式提供。
- en: The MyBlog web application will provide tools with which users can join the
    blogging community and create blog posts. Registered users can post content using
    markdown for styling what they write. All users will be able to view the posted
    content, and registered users will be able to comment on it. Administrative users
    will be able to mark any content or comments active/inactive as they see fit.
    Registered users will be able to mark any content they’ve created as active/inactive.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog Web应用程序将为用户提供工具，使他们能够加入博客社区并创建博客文章。注册用户可以使用Markdown进行样式设置来发布内容。所有用户都将能够查看发布的内容，注册用户将能够对其进行评论。管理员用户将能够根据需要标记任何内容或评论为活动/非活动状态。注册用户将能够标记他们创建的任何内容为活动/非活动状态。
- en: 6.1 Sharing your work
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 分享你的工作
- en: The MyBlog web application is a way to not only share your thoughts, and the
    thoughts of the application’s users, but to share your work. The application serves
    a particular purpose with a host of features. The work involved to pull together
    the technologies to create the MyBlog features is a skill worth showing off.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog Web应用程序不仅是一种分享你的想法和应用程序用户的想法的方式，也是一种分享你工作的方式。该应用程序提供了一系列功能，服务于特定的目的。将技术整合在一起以创建MyBlog功能所涉及的工作是一项值得展示的技能。
- en: 6.1.1 Web application advantages
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 Web应用程序的优势
- en: The project choice to create a web application is based on a few considerations.
    First and foremost, creating a useful web application builds on the topics covered
    in previous chapters quite well. Pulling together the topics of development tools,
    naming and namespaces, API use and creation, and class design will play into the
    big picture of the application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Web应用程序的项目选择基于几个考虑因素。首先，创建一个有用的Web应用程序很好地建立在前面章节所涵盖的主题之上。将开发工具、命名和命名空间、API的使用和创建以及类设计等主题结合起来，将对应用程序的整体图景产生影响。
- en: Other types of applications also offer some of these opportunities to express
    what you’ve learned but can be challenging to share with others. For example,
    creating a desktop GUI application offers interesting challenges for a developer.
    However, distributing a GUI application for widespread use can be difficult. It’s
    certainly possible to do so with Python, but the steps necessary are outside of
    the scope of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的应用程序也提供了一些表达你所学知识的机会，但与他人分享可能具有挑战性。例如，创建桌面GUI应用程序对开发者来说提出了有趣的挑战。然而，广泛分发GUI应用程序可能很困难。当然，使用Python可以做到这一点，但必要的步骤超出了本书的范围。
- en: A web server has some advantages in terms of distributing an application. The
    web server itself and the features and services are centrally located and are
    not running on the many varied computer environments that users have. Having the
    server centralized like this means that changes and updates to the application
    happen in one place. Restarting the server, or pushing changes out interactively,
    makes the changes and updates available immediately to all users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发应用程序方面，Web服务器有一些优势。Web服务器本身以及其功能和服务的位置是集中的，并且不运行在用户所拥有的众多不同的计算机环境中。以这种方式集中服务器意味着应用程序的更改和更新发生在同一个地方。重新启动服务器或交互式推送更改，可以使更改和更新立即对所有用户可用。
- en: Another advantage of a web server–based application is making a user interface
    available. A web application takes advantage of something installed on just about
    every computer in existence, a web browser. Modern web browsers provide a powerful
    platform on which to build user interfaces. Data can be formatted and presented
    in almost infinite ways. Images and multimedia are also well supported. Users
    can interact with applications hosted on browsers using interface elements like
    buttons, lists, drop-down lists, and forms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络服务器的应用另一个优势是提供用户界面。网络应用利用了几乎所有计算机上安装的浏览器。现代网络浏览器提供了一个强大的平台，可以用来构建用户界面。数据可以以几乎无限的方式格式化和展示。图像和多媒体也得到了很好的支持。用户可以使用按钮、列表、下拉列表和表单等界面元素与托管在浏览器上的应用进行交互。
- en: 6.1.2 Web application challenges
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 网络应用挑战
- en: This isn’t to say using a web browser as an application platform isn’t without
    challenges. Creating a web application means you’ll be working in multiple technical
    domains. Along with Python, you’ll be creating HTML, CSS, and JavaScript code
    files. Additionally, desktop-based applications offer more direct access to the
    computer hardware and the tremendous computing power personal computers bring
    to bear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说使用网络浏览器作为应用平台没有挑战。创建网络应用意味着你将在多个技术领域工作。除了Python，你还将创建HTML、CSS和JavaScript代码文件。此外，基于桌面的应用提供了对计算机硬件的直接访问，以及个人计算机带来的巨大计算能力。
- en: However, with continuing advancements in browsers, new and expanding web technologies,
    and ever-increasing internet speed that’s widely available, the performance gap
    between desktop and web-based applications is narrowing. In addition, web-based
    systems have grown to have widespread acceptance as a method of delivering applications.
    This acceptance makes creating them a valid path for both personal and professional
    development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着浏览器、新兴和扩展的网络技术的持续进步，以及广泛可用的互联网速度的不断提高，桌面和基于网络的应用性能差距正在缩小。此外，基于网络的系统已经广泛接受为交付应用的方法。这种接受使得创建它们成为个人和职业发展的有效途径。
- en: tip It can’t be overstated how important and valuable web development skills
    are. As more and more users migrate from desktop devices to mobile ones that take
    advantage of the ubiquity of the internet, this will only become more valuable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：无法过分强调网络开发技能的重要性和价值。随着越来越多的用户从桌面设备迁移到利用互联网普遍性的移动设备，这将变得更加有价值。
- en: There are existing blogging platforms available to use or download that you
    can run on your own. The MyBlog application won’t be in competition with them,
    as its purpose is a useful teaching framework that gives the example code direction
    and goals.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已有可用的博客平台供您使用或下载，您可以在自己的计算机上运行。MyBlog应用不会与它们竞争，因为它的目的是提供一个有用的教学框架，为示例代码提供方向和目标。
- en: What the application offers isn’t groundbreaking features or technology; blogging
    software is well understood. This is one of MyBlog’s advantages, already knowing
    what a blog application is intended to supply. The goal isn’t to create a cutting-edge
    blog but to see the big picture of the application’s intent and think like a developer
    to pull the necessary parts together and paint that picture into existence.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog提供的应用并非具有突破性的功能或技术；博客软件已被广泛理解。这是MyBlog的一个优势，因为它已经知道博客应用旨在提供什么。目标不是创建一个前沿的博客，而是要看到应用意图的整体图景，并以开发者的思维方式将必要的部分组合在一起，将这幅图景变为现实。
- en: 6.2 Servers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 服务器
- en: The MyBlog web application is a subset of what a server application in general
    provides. One definition of a server is an application running on a computer,
    or computers, providing functionality to other applications across a network.
    This arrangement of multiple applications accessing the functionality of a central
    server is known as the client-server model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog网络应用是服务器应用一般提供的子集。服务器的定义之一是运行在计算机上，或多台计算机上，为网络上的其他应用提供功能。这种多个应用访问中心服务器功能安排的模型被称为客户端-服务器模型。
- en: As you build out the MyBlog application, you’ll be running it on your local
    computer, essentially turning it into a server. The software running on a computer
    is what makes it a server, not the computer hardware configuration. Commercial
    server hardware items are built to optimize the access that the server software
    needs to run well but are otherwise just computers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建MyBlog应用程序时，你将在本地计算机上运行它，本质上将其变成一个服务器。使计算机成为服务器的是运行在计算机上的软件，而不是计算机硬件配置。商业服务器硬件项目是为了优化服务器软件运行所需的访问而构建的，但除此之外，它们只是计算机。
- en: We all use social networks and work with the programs that run on our desktop
    or mobile devices. Those tools are client applications using the functionality
    of many servers. If you play any multiplayer games, the game applications use
    a server’s functionality to coordinate all the players’ actions in the game. Figure
    6.1 shows many kinds of devices connecting to a server across a network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都使用社交网络，并在我们的桌面或移动设备上运行程序。这些工具是使用许多服务器功能的客户端应用程序。如果你玩任何多人游戏，游戏应用程序将使用服务器的功能来协调游戏中所有玩家的动作。图6.1显示了多种设备通过网络连接到服务器。
- en: '![](../../OEBPS/Images/CH06_F01_Farrell.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Farrell.png)'
- en: Figure 6.1 Multiple devices connecting to the functionality provided by a server
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 多种设备连接到服务器提供的功能
- en: 6.2.1 Request-response model
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 请求-响应模型
- en: One common server implementation is the request-response model. The client application
    makes a request to the server, which processes the request and returns a response.
    In this kind of application, the server takes no action unless requested to do
    so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的服务器实现是请求-响应模型。客户端应用程序向服务器发送请求，服务器处理请求并返回响应。在这种类型的应用程序中，服务器除非被请求执行，否则不会采取任何行动。
- en: In a web application, the client browser makes an HTTP request to the server
    for a response. The response is very often a stream of text representing an HTML
    page. When the client browser receives the response, it will render the HTML to
    the browser window. Depending on the HTML code that creates the page, it might
    also make additional requests to the server for information like CSS (Cascading
    Style Sheet) and JavaScript files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，客户端浏览器向服务器发送HTTP请求以获取响应。响应通常是表示HTML页面的文本流。当客户端浏览器接收到响应时，它将在浏览器窗口中渲染HTML。根据创建页面的HTML代码，它可能还需要向服务器请求信息，如CSS（层叠样式表）和JavaScript文件。
- en: Figure 6.2 represents a simplified view of the request-response communication
    occurring between a client and server over time. Initially, the client makes a
    request to the server, which might need to retrieve data from a database to compose
    the response. When the response is created, it is transmitted back to the client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2表示了客户端和服务器之间随时间发生的请求-响应通信的简化视图。最初，客户端向服务器发送请求，服务器可能需要从数据库检索数据以组成响应。当响应创建完成后，它将被传回客户端。
- en: In this example, the response is an HTML page the client application will render
    in the browser window. Figure 6.2 shows the back-and-forth communication to render
    the HTML page. Part of the HTML code includes links to CSS and JavaScript files
    that generate additional requests to the server. The server retrieves the requested
    files from the server’s hard disk and sends them as a response to the client.
    The request-response model is the primary means that the MyBlog web application
    will use to get data from the server and build and present the application information
    to the users.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，响应是一个客户端应用程序将在浏览器窗口中渲染的HTML页面。图6.2展示了渲染HTML页面时的来回通信。HTML代码的一部分包括链接到CSS和JavaScript文件，这些文件会向服务器生成额外的请求。服务器从服务器的硬盘上检索请求的文件，并将它们作为响应发送给客户端。请求-响应模型是MyBlog网络应用程序获取数据的主要方式，用于构建并向用户展示应用程序信息。
- en: '![](../../OEBPS/Images/CH06_F02_Farrell.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F02_Farrell.png)'
- en: Figure 6.2 Client and web server interaction event flow to construct a web page
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2构建网页的客户端和Web服务器交互事件流
- en: 6.3 Web servers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 网络服务器
- en: A web server is an application responding to HTTP requests from a client application.
    A web browser is a client application that makes requests to the web server and
    interprets the responses and displays them on the screen. Often what’s sent to
    the client’s web browser are HTML documents the browser interprets and renders
    as web pages. HTML documents are the content the client requested.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器是一个响应来自客户端应用程序的 HTTP 请求的应用程序。网络浏览器是一个客户端应用程序，它向网络服务器发送请求并解释响应，并在屏幕上显示它们。通常发送到客户端网络浏览器的都是浏览器解释并渲染为网页的
    HTML 文档。HTML 文档是客户端请求的内容。
- en: There are many other interactions between a client’s browser and a web server.
    The browser can request that the server send pictures and audio and video content,
    even downloading other applications to the client’s computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端浏览器和网络服务器之间存在许多其他交互。浏览器可以请求服务器发送图片、音频和视频内容，甚至下载其他应用程序到客户端的计算机。
- en: HTML documents can contain links to CSS and JavaScript files. When the HTML
    received is rendered by the web browser, the embedded links to those files generate
    additional HTTP requests to the web server. The web server responds by sending
    the requested content.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文档可以包含指向 CSS 和 JavaScript 文件的链接。当 HTML 被网络浏览器渲染时，嵌入到这些文件的链接会生成对网络服务器的额外
    HTTP 请求。网络服务器通过发送请求的内容来响应。
- en: tip Modern web applications make many requests to one or more servers to provide
    the content and render the experience that the user expects from the web application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：现代网络应用程序会向一个或多个服务器发送许多请求，以提供内容并渲染用户从网络应用程序中期望的体验。
- en: CSS files contain styling information applied to the content in the HTML document
    displayed on the screen. The CSS code modifies a web page’s look and feel and
    is the presentation layer of the HTML’s content.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件包含应用于屏幕上显示的 HTML 文档中的内容样式信息。CSS 代码修改了网页的外观和感觉，是 HTML 内容的表现层。
- en: JavaScript files contain code that runs in the client’s browser. Once downloaded,
    the web browser will start to execute the JavaScript code. This code can be connected
    to onscreen button clicks and updates to the display, and just about any action
    the user can make on a web page can be handled by JavaScript code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件包含在客户端浏览器中运行的代码。一旦下载，网络浏览器将开始执行 JavaScript 代码。此代码可以连接到屏幕上的按钮点击和显示更新，以及用户在网页上可以进行的几乎所有操作都可以由
    JavaScript 代码处理。
- en: JavaScript code can also make HTTP requests to web servers for text and data.
    These requests can be initiated by user actions or programmatically and can change
    and update web pages dynamically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码也可以向网络服务器发送 HTTP 请求以获取文本和数据。这些请求可以由用户操作或编程方式启动，并可以动态更改和更新网页。
- en: HTTP requests
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求
- en: 'The HTTP protocol definition is not the intent of this book and is beyond its
    scope, but some basic information is useful. Here is an example HTTP request to
    a web server:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 协议定义不是本书的意图，也不在其范围之内，但一些基本信息是有用的。以下是一个向网络服务器发送的 HTTP 请求示例：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The line numbers in this example are not part of the request but were added
    to reference the lines in the explanation of the protocol:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的行号不是请求的一部分，但被添加以参考协议解释中的行：
- en: '`GET /path_part/index.xhtml HTTP/1.1`—This is the start of the request to the
    web server. The word `GET` indicates the HTTP method to use—in this case, to retrieve
    the document located at `/path_part/index.xhtml` using HTTP protocol version 1.1.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET /path_part/index.xhtml HTTP/1.1`—这是向网络服务器发送请求的开始。单词 `GET` 表示要使用的 HTTP
    方法——在这种情况下，使用 HTTP 协议版本 1.1 检索位于 `/path_part/index.xhtml` 的文档。'
- en: '`Host:` `fictional_website.com:80`—Indicates the domain, suffix, and port number
    where the request is sent. The port number (80) is optional and, if absent, defaults
    to 80.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Host:` `fictional_website.com:80`—表示请求发送的域名、后缀和端口号。端口号（80）是可选的，如果不存在，则默认为
    80。'
- en: The domain suffix is the text name of the server hosting the website. This name
    is translated by a DNS (domain name server) to an IP address so the network protocol
    can direct the request to the right server on the internet.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名后缀是托管网站的服务器的文本名称。此名称由 DNS（域名服务器）翻译为 IP 地址，以便网络协议可以将请求定向到互联网上的正确服务器。
- en: The suffix comes from a list of suffixes that help manage and differentiate
    domains on the internet. You’re probably already familiar with suffixes like “.com”
    and “.net,” but there are many others. This makes “myserver.com” and “myserver.net”
    two distinct names.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀来自一个帮助管理和区分互联网上域名的后缀列表。你可能已经熟悉像“ .com”和“ .net”这样的后缀，但还有很多其他的。这使得“myserver.com”和“myserver.net”成为两个不同的名称。
- en: Ethernet network cards can support 65,353 logical ports, with those from 0 to
    1023 reserved for well-known ports used by common applications. For example, web
    servers commonly use port 80, which is why it’s the default if not specified in
    the URL. However, a server, including web servers, can run on any port in the
    range that’s not already in use.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网网卡可以支持65,353个逻辑端口，其中从0到1023的端口被保留用于常见应用程序的已知端口。例如，Web服务器通常使用端口80，这也是为什么如果URL中没有指定，它就是默认端口。然而，服务器，包括Web服务器，可以在未使用的任何端口上运行。
- en: '`Accept:` `text/html,` `*/*`—This header information is optional. In this example,
    it indicates to the server the kinds of responses the client can accept. There
    can be many headers, each containing additional information from the client that
    can be useful to the web server.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Accept:` `text/html,` `*/*`—这个头部信息是可选的。在这个例子中，它向服务器指示客户端可以接受哪些类型的响应。可以有多个头部，每个头部都包含来自客户端的附加信息，这些信息对Web服务器可能很有用。'
- en: '`<CR-LF>`—Indicates carriage return/line feed characters or a blank line, which
    is a required part of the HTTP protocol that ends the list of headers and tells
    the server to start processing the request.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<CR-LF>`—表示回车/换行字符或空白行，这是HTTP协议的必要部分，它结束了头部列表并告诉服务器开始处理请求。'
- en: When I was first getting into web development, it surprised me that the small
    amount of text shown here, and broken out in figure 6.3, was literally what was
    sent across the network to the server. The first two lines of the request create
    a URL, or uniform resource locator, which uniquely identifies what the client
    is requesting.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始接触Web开发时，让我惊讶的是，这里显示的少量文本，以及图6.3中分列出来的内容，实际上就是通过网络发送到服务器的。请求的前两行创建了一个URL，即统一资源定位符，它唯一地标识了客户端请求的内容。
- en: '![](../../OEBPS/Images/CH06_F03_Farrell.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F03_Farrell.png)'
- en: Figure 6.3 The fully formed URL uniquely identifies the resource to retrieve.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 完整的URL唯一地标识了要检索的资源。
- en: 'The server receives this request and takes one of the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收到这个请求并采取以下步骤之一：
- en: Maps the request to a file in the server’s control and returns it to the client
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求映射到服务器控制下的文件，并将其返回给客户端
- en: Maps the request to a handler (program code) and returns the output of the handler
    to the client
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求映射到处理程序（程序代码），并将处理程序的输出返回给客户端
- en: Determines that the request can’t be answered and returns an error message
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定请求无法回答并返回错误消息
- en: The use of the slash character (`/`) is very much like the slash used as the
    path separator for directories and files on a file system. This pattern is a useful
    way to present a logical path hierarchy of the resources and content originating
    at the root domain `fictional_website.com`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用斜线字符（`/`）与文件系统上目录和文件的路径分隔符斜线用法非常相似。这种模式是展示从根域名`fictional_website.com`起源的资源内容的逻辑路径层次结构的有用方式。
- en: By allowing for multipart paths, a logical hierarchy is created. The hierarchy
    can be navigated by a browser application to access different parts of the web
    server. The endpoint of a URL can be an actual file resource the web server provides,
    but it doesn’t have to be. The logical path created can have no relation to the
    actual file path to a resource on the server’s file system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许多部分路径，创建了一个逻辑层次结构。浏览器应用程序可以通过这个层次结构导航，以访问Web服务器的不同部分。URL的端点可以是Web服务器提供的实际文件资源，但不必是。创建的逻辑路径可以与服务器文件系统上资源的实际文件路径没有关系。
- en: 6.4 Flask
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 Flask
- en: You’re going to build the MyBlog application using Flask, a lightweight web
    application framework for Python. Flask provides the mechanisms and plumbing necessary
    for Python to be used as a web application server to create useful applications
    that perform and scale well. Flask includes the ability to answer HTTP requests
    for URL resources and connect those requests to Python code that dynamically builds
    the response.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Flask构建MyBlog应用程序，Flask是一个用于Python的轻量级Web应用程序框架。Flask提供了必要的机制和基础设施，使Python能够作为Web应用程序服务器来创建性能良好且可扩展的应用程序。Flask包括处理URL资源的HTTP请求并连接到动态构建响应的Python代码的能力。
- en: Flask ([https://flask.palletsprojects.com/en/2.1.x/)](https://flask.palletsprojects.com/en/2.1.x/)
    is not part of the standard library modules that come with Python but is available
    as a third-party module hosted by the Python Package Index ([https://pypi.org/](https://pypi.org/)).
    Like other modules available to Python, this makes it installable using the pip
    utility.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Flask ([https://flask.palletsprojects.com/en/2.1.x/](https://flask.palletsprojects.com/en/2.1.x/))
    不是 Python 标准库模块的一部分，但作为 Python 包索引 ([https://pypi.org/](https://pypi.org/)) 上托管的一个第三方模块而可用。像其他可用的
    Python 模块一样，这使得它可以通过 pip 工具进行安装。
- en: 6.4.1 Why Flask?
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 为什么选择 Flask？
- en: Python is in the fortunate position of being popular as a language to build
    web applications. Because of this, many tools and frameworks exist that Python
    can use to create web applications, Flask being one of them. There’s also Django,
    Bottle, Pyramid, Turbogears, CherryPy, and more. All the frameworks are useful;
    some have a more particular use case than others, some are faster than others,
    and some are more specialized for creating certain kinds of web applications and
    services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 作为构建网络应用程序的语言非常受欢迎。正因为如此，存在许多工具和框架，Python 可以使用它们来创建网络应用程序，Flask 就是其中之一。还有
    Django、Bottle、Pyramid、Turbogears、CherryPy 等更多。所有框架都很有用；有些比其他框架有更特定的用例，有些比其他框架更快，有些则更专门用于创建某些类型的网络应用程序和服务。
- en: Flask lives in the middle ground and is popular because it’s small and has a
    minimal initial learning curve and is suitable as your skills and needs develop.
    Many modules are available that integrate with Flask that you’ll use as the MyBlog
    application grows. These modules will give the MyBlog application access to databases,
    authentication, authorization, and form creation. Part of the beauty of Flask
    is not having to learn or use these expanded capabilities until they’re needed
    and you’re ready to create new features with them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 位于中间地带，因其小巧且初始学习曲线最小而受到欢迎。随着你的技能和需求的发展，许多与 Flask 集成的模块可供使用。这些模块将为 MyBlog
    应用程序提供访问数据库、身份验证、授权和表单创建的能力。Flask 的美妙之处在于，你不必在需要时学习或使用这些扩展功能，直到你准备好使用它们来创建新功能。
- en: tip As a developer myself, I’ve worked with some of the other web application
    frameworks available to Python. Flask is the one I’ve used the most and with which
    I am most familiar. I chose to use Flask because I can write about it knowing
    that I can present Flask to your best advantage and not miss details I might otherwise
    miss if I were to choose a framework less familiar to me.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：作为一名开发者，我使用过一些其他适用于 Python 的网络应用程序框架。Flask 是我使用最多且最熟悉的一个。我选择使用 Flask，因为我可以写关于它，知道我可以将
    Flask 介绍给你，并且不会错过我如果选择一个我不太熟悉的框架可能会错过的细节。
- en: 6.4.2 Your first web server
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 你的第一个网络服务器
- en: 'Now that you know where you’re headed, let’s get started. The first server
    comes right from the Flask website quick-start example and is as good as anywhere
    to begin learning Flask. This is the classic `"Hello` `World"` example program
    expressed as a web application. The code for the server is available in the repository
    as `examples/CH_06/examples/01/app.py`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道你的目标在哪里了，让我们开始吧。第一个服务器直接来自 Flask 网站快速入门示例，是开始学习 Flask 的好地方。这是一个经典的 `"Hello`
    `World"` 示例程序，以网络应用程序的形式表达。服务器的代码存储在仓库中的 `examples/CH_06/examples/01/app.py`：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Imports the Flask system into the application
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 Flask 系统导入到应用程序中
- en: ② Creates a Flask instance object, passing it the name of the current file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 Flask 实例对象，传递当前文件的名称
- en: ③ This decorator connects the home function to the "/" application route.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 此装饰器将主页函数连接到 "/" 应用程序路由。
- en: ④ The home function will run when the user navigates to the "/" route.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 当用户导航到 "/" 路由时，将执行主页函数。
- en: 'After running the install steps for the chapter examples and starting your
    Python virtual environment, the application is run by opening a terminal window
    and navigating to the `examples/CH_06/examples/01` directory. Enter the following
    command for Mac and Linux:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本章示例的安装步骤并启动你的 Python 虚拟环境后，通过打开终端窗口并导航到 `examples/CH_06/examples/01` 目录来运行应用程序。对于
    Mac 和 Linux，请输入以下命令：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Windows users, enter the command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，请输入以下命令：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once done, enter the command `flask run`, and the application will output the
    following text to the terminal window:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，输入命令 `flask run`，应用程序将输出以下文本到终端窗口：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These messages might look ominous, but they are just informing you that the
    web server is running in development mode, which isn’t suitable for production.
    Production in this context means running the web server so it’s publicly available.
    The Flask built-in development server isn’t optimized or secure enough to be used
    out in the wild.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息可能看起来很可怕，但它们只是通知您，Web 服务器正在开发模式下运行，这不适合生产环境。在这个上下文中，生产意味着运行 Web 服务器使其公开可用。Flask
    内置的开发服务器没有优化或足够安全，不能在野外使用。
- en: You’ll also notice the line that informs you that to stop the application you’ll
    need to press the CTRL-C keys. Also notice that the terminal cursor doesn’t return,
    because the `flask run` command is running the `app` instance in an infinite loop,
    waiting to receive and process requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到一条通知您，要停止应用程序，您需要按 CTRL-C 键。注意，终端光标不会返回，因为 `flask run` 命令正在无限循环中运行 `app`
    实例，等待接收和处理请求。
- en: A server is intended to run long term and, in fact, would never stop unless
    instructed to do so. The server you’ve just started is in an idle state waiting
    to receive and process HTTP requests. The Flask development server defaults to
    running at IP address 127.0.0.1 on port 5000.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器旨在长期运行，实际上除非被指示停止，否则永远不会停止。您刚刚启动的服务器处于空闲状态，等待接收和处理 HTTP 请求。Flask 开发服务器默认在
    IP 地址 127.0.0.1 的 5000 端口上运行。
- en: The IP address 127.0.0.1 is known as localhost and is the loopback interface
    of your computer’s network interface. This means you can create servers on this
    address and access them even if you don’t have a network card installed on your
    computer. The port value of 5000 is just an unused port number out of the 65,535
    available on network interfaces. Both values can be configured, but the defaults
    are fine for now.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址 127.0.0.1 被称为 localhost，是您计算机网络接口的回环接口。这意味着即使您的计算机上没有安装网卡，您也可以在这个地址上创建服务器并访问它们。5000
    的端口号是网络接口上 65,535 个可用端口中的一个未使用端口。这两个值都可以配置，但现在默认值就足够了。
- en: To interact with the server, you need to open a web browser on your computer
    and navigate to `http:/./127.0.0.1:5000` as the URL and click enter. The browser
    will respond by printing `"Hello` `World!"` in the content window. You’ll also
    see a log message in the terminal window where the server is running indicating
    the request was received and processed correctly, as specified by the 200 at the
    end of the log message. The 200 value is the HTTP status code for “OK,” which
    means the request was handled successfully.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要与服务器交互，您需要在计算机上打开一个网页浏览器，并将 `http:/./127.0.0.1:5000` 作为网址导航，然后点击回车。浏览器将响应，在内容窗口中打印出
    `"Hello World!"`。您还会在运行服务器的终端窗口中看到一个日志消息，表明请求已被接收并正确处理，日志消息末尾的 200 表示 HTTP 状态码为“OK”，这意味着请求已成功处理。
- en: Connecting routes
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 连接路由
- en: One of the important things to notice about the application is how Python code
    is connected to a valid URL route to which the server will respond. The `@app.route
    (`"`/`"`)` line of code is a decorator provided by the Flask `app` instance and
    applied to the `home()` Python function. The decorator is how the `home()` function
    is registered with Flask and connected to the URL "`/`" route and will be called
    when a user browses to `http:127.0.0.1:5000`. Because the route is defined, the
    server will respond to the results of running the `home()` function, returning
    the `"Hello` `World"` string.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应用程序的一个重要注意事项是 Python 代码如何连接到一个有效的 URL 路由，服务器将对该路由做出响应。`@app.route ("`)"/`")`
    这行代码是 Flask `app` 实例提供的装饰器，应用于 `home()` Python 函数。装饰器是 `home()` 函数注册到 Flask 并连接到
    URL "`/`" 路由的方式，当用户浏览到 `http:127.0.0.1:5000` 时将被调用。因为路由已被定义，服务器将对 `home()` 函数的运行结果做出响应，返回
    `"Hello World"` 字符串。
- en: Serving forever
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 永久服务
- en: Once the server is running, it will continue responding to requests until it’s
    stopped, essentially running forever while waiting for HTTP requests. There is
    no explicit loop in the application code, so how is the server running forever?
    The loop is part of the functionality in the Flask `app` instance. When the `flask`
    `run` command is invoked at the terminal command line, it looks for an object
    named `app` and, if found, starts the server event loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，它将继续响应请求，直到停止，本质上是在等待 HTTP 请求的过程中无限期地运行。应用程序代码中没有显式的循环，那么服务器是如何无限期运行的？这个循环是
    Flask `app` 实例功能的一部分。当在终端命令行中调用 `flask run` 命令时，它会寻找名为 `app` 的对象，如果找到，则启动服务器事件循环。
- en: The event loop is where the server waits for events to process. The events are
    the data showing up on the network socket at port 5000\. For a web server, the
    events are HTTP requests arriving on the network port that the server is monitoring.
    Unlike what you might think of as an infinite loop in application code, the server
    is idle while waiting for events and uses very little CPU time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是服务器等待事件处理的地方。事件是在端口5000上的网络套接字上显示的数据。对于Web服务器来说，事件是到达服务器监控的网络端口的HTTP请求。与你在应用程序代码中可能想到的无穷循环不同，服务器在等待事件时是空闲的，并且使用的CPU时间非常少。
- en: Undefined routes
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义的路由
- en: If you go back to the browser and modify the URL to `http:/./127.0.0.1:5000/something`
    and click the enter key, the browser will respond with a `Not Found` error. Looking
    at the log messages in the terminal window, you’ll see a message that the request
    was received, but the server responded with a 404 status code. The HTTP protocol
    status code 404 essentially equates to `Page Not Found.`
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到浏览器并修改URL为`http:/./127.0.0.1:5000/something`并按回车键，浏览器将响应一个`Not Found`错误。查看终端窗口中的日志消息，你会看到一个消息表明请求已被接收，但服务器以404状态码响应。HTTP协议状态码404基本上等同于`页面未找到。`
- en: This makes sense if you look at your web server application code. At the moment,
    the only URL supported is the home route `"/"`; there is nothing defined to handle
    the `/something` route. The server didn’t crash because it didn’t have the route
    defined; instead, the server handled it as an error and informed the user about
    the error through the browser.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的Web服务器应用程序代码，这就有意义了。目前，唯一支持的URL是主页路由`"/"`；没有定义来处理`/something`路由。服务器没有崩溃，因为它没有定义路由；相反，服务器将其处理为一个错误，并通过浏览器通知用户关于错误的信息。
- en: The ability to handle errors and continue to function is an important part of
    the server’s design and implementation. As you develop the MyBlog application,
    you’ll use the errors handled and returned by the Flask server to help determine
    where problems exist in the application and where to resolve them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误并继续运行的能力是服务器设计和实现的重要部分。随着你开发MyBlog应用程序，你将使用Flask服务器处理并返回的错误来确定应用程序中存在的问题以及如何解决它们。
- en: 6.4.3 Serving content
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 服务器内容
- en: Getting your first web server coded and running is a big step. There’s a remarkable
    amount of functionality implemented and executed by the very small amount of code
    in `app.py`. The `home()` function shows how you can map a URL to Python code
    that the web server will support. You can add new functions and map them to additional
    routes, and the web server will provide additional URLs to which the browser can
    navigate.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的第一个Web服务器编码并运行是一个大步骤。在`app.py`中的非常少的代码实现了和执行了大量的功能。`home()`函数展示了你可以如何将URL映射到Web服务器将支持的Python代码。你可以添加新的函数并将它们映射到额外的路由，Web服务器将提供额外的URL，浏览器可以导航到这些URL。
- en: To create a proper web page, you can replace the `"Hello` `World!"` string returned
    by the `home()` function with a string containing HTML code. By doing this, the
    browser will receive the HTML and render it in the browser window.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个合适的网页，你可以用包含HTML代码的字符串替换`home()`函数返回的`"Hello World!"`字符串。通过这样做，浏览器将接收HTML并在浏览器窗口中渲染它。
- en: However, useful and well-designed web pages are created with HTML code that
    can be hundreds, even thousands, of lines of code. Embedding strings of HTML code
    directly into your web server will make it difficult to maintain and does not
    take advantage of features available to you through Flask. It’s better to keep
    HTML content and Python code separated and build HTML pages as distinct files,
    which is what we’ll do next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有用的和设计良好的网页是通过HTML代码创建的，这些代码可能有数百行，甚至数千行。直接将HTML代码嵌入到你的Web服务器中会使维护变得困难，并且没有充分利用Flask提供的功能。最好是将HTML内容和Python代码分开，并将HTML页面作为独立的文件构建，这是我们接下来要做的。
- en: Dynamic content
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内容
- en: The content served to the browser by the `home()` function is the string `"Hello
    World!"`, which is returned to the browser every time the page is accessed or
    refreshed. Because `home()` is a Python function, it could have returned anything,
    including information and data that is generated dynamically. The function could
    have returned the result of the `random()` function, and the browser would have
    rendered a random value every time the page was accessed. The `home()` function
    could have returned the results of a calculation, the data retrieved from a database,
    or the return value of some other HTTP web-based service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `home()` 函数提供给浏览器的内容是字符串 `"Hello World!"`，每次访问或刷新页面时都会返回给浏览器。因为 `home()`
    是一个 Python 函数，它可以返回任何内容，包括动态生成的信息和数据。该函数可以返回 `random()` 函数的结果，每次访问页面时浏览器都会渲染一个随机值。`home()`
    函数可以返回计算结果、从数据库检索的数据或某些其他基于 HTTP 的网络服务的返回值。
- en: Creating and returning dynamic information is one of the cornerstones of creating
    useful web applications, the MyBlog project being one of them. How do you merge
    dynamic information with HTML content that can be meaningfully rendered by browsers?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回动态信息是创建有用网络应用的基础之一，MyBlog 项目就是其中之一。你是如何将动态信息与浏览器可以有意义渲染的 HTML 内容合并的呢？
- en: 'Flask includes access to a template language called Jinja2\. A template can
    be thought of as a document that has placeholders for additional information.
    This template will be combined with data to produce a completed end-result document.
    Here’s an example using Python f-string formatting to illustrate the idea:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 包含了对名为 Jinja2 的模板语言的访问。可以将模板视为一个包含附加信息占位符的文档。这个模板将与数据结合，生成最终的完成文档。以下是一个使用
    Python f-string 格式化来阐述这个概念的示例：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the variable `name` is set to the string `"Joe"`, and the Python format
    string `f"My name` `is` `{name}"` acts as the template. The `result` variable
    is created and then printed, and `My` `name` `is` `Joe` is the output. Python’s
    f-string formatting is like a small templating language; it takes in data in the
    form of the `name` variable and creates the resulting string output. Jinja2 works
    much like this as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `name` 被设置为字符串 `"Joe"`，Python 格式化字符串 `f"My name is {name}"` 作为模板。创建并打印
    `result` 变量，输出为 `My name is Joe`。Python 的 f-string 格式化就像一个小型模板语言；它接收 `name` 变量的数据形式并创建结果字符串输出。Jinja2
    也与此类似。
- en: tip Keep in mind that once the server delivers content to the browser, there
    is no connection between them. For the MyBlog application, any dynamic content
    generated by the server has to be injected into the HTML content before it’s delivered
    to the browser.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：请记住，一旦服务器将内容发送到浏览器，它们之间就没有连接了。对于 MyBlog 应用程序，服务器生成的任何动态内容都必须在发送到浏览器之前注入到
    HTML 内容中。
- en: By using a templating language, you can place your HTML code in a separate template
    file and then have Jinja2 substitute your dynamic information and data into the
    right places in that template.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模板语言，你可以将 HTML 代码放在一个单独的模板文件中，然后让 Jinja2 将你的动态信息和数据替换到模板的正确位置。
- en: Using a template language
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板语言
- en: 'Let’s modify the previous web server code to use Jinja2 templates and pass
    dynamic data to the template to render in the browser window. The following modified
    code is found in `examples/CH_06/examples/02/app.py`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的网络服务器代码，以使用 Jinja2 模板并将动态数据传递给模板以在浏览器窗口中渲染。以下修改后的代码位于 `examples/CH_06/examples/02/app.py`：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Imports the Flask function render_template to use Jinja2
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 Flask 的 `render_template` 函数以使用 Jinja2
- en: ② Imports the datetime functionality to generate dynamic data
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ② 导入 datetime 功能以生成动态数据
- en: ③ Uses the render_template function to connect the index.xhtml template file
    with the now data element
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 `render_template` 函数将 index.xhtml 模板文件与 now 数据元素连接起来
- en: The first parameter to the `render_template` function is the string `index.xhtml`,
    which is the filename of a template file containing Jinja2 template instructions.
    Everything else passed to `render_template` is a named parameter. In the example,
    the named parameter is `now`, and it will be assigned the value returned by the
    code `datetime.now()`, the current timestamp.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_template` 函数的第一个参数是字符串 `index.xhtml`，这是包含 Jinja2 模板指令的模板文件的文件名。传递给
    `render_template` 的其他所有内容都是命名参数。在示例中，命名参数是 `now`，它将被分配给 `datetime.now()` 返回的当前时间戳的值。'
- en: By default, Flask initially searches for template files in a directory called
    `templates`. The template directory should exist in the same directory as the
    `app.py` file, so create that now.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask 首先在名为 `templates` 的目录中搜索模板文件。模板目录应该与 `app.py` 文件位于同一目录中，所以现在创建它。
- en: 'Inside the `templates` directory, you’ll need to create a file named `index.xhtml`.
    In the example application, the `index.xhtml` file looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `templates` 目录中，你需要创建一个名为 `index.xhtml` 的文件。在示例应用程序中，`index.xhtml` 文件看起来像这样：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① HTML 5 boilerplate code
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ① HTML 5 模板代码
- en: ② Inserts the current datetime in the {{now}} Jinja output expression
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在 {{now}} Jinja 输出表达式中插入当前日期和时间
- en: 'The HTML 5 code here presents a complete web page that the browser can render
    in its window. The interesting thing in the file is the `<h1>` headline tag inside
    the body of the document:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 HTML 5 代码是一个完整的网页，浏览器可以在其窗口中渲染。文件中有趣的是文档主体内的 `<h1>` 标题标签：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `{{now}}` part of the line is Jinja2 template syntax and will be replaced
    by the value of the `render_template` parameter `now,` which has a value of the
    current timestamp.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 行中的 `{{now}}` 部分是 Jinja2 模板语法，将被 `render_template` 参数 `now` 的值替换，该值是当前的时间戳。
- en: 'The `render_template` function uses the Jinja2 templating engine to parse the
    template file and substitute elements that follow the Jinja2 syntax rules with
    data. Jinja2 is also capable of doing much more processing than just substitution,
    and we’ll get to that shortly. Once you’ve created the `index.xhtml` file, the
    directory structure should look something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_template` 函数使用 Jinja2 模板引擎解析模板文件，并用数据替换遵循 Jinja2 语法规则的部分。Jinja2 还能够执行比简单替换更多的处理，我们很快就会看到。一旦创建了
    `index.xhtml` 文件，目录结构应该看起来像这样：'
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run the `app.py` file and navigate to the URL, the browser will render
    the output of the handler shown in figure 6.4\. Every time the page is refreshed,
    the timestamp will update. This demonstrates that the `home()` function is running
    and the `index.xhtml` template is being rendered with a new `datetime.now()` value
    every time the page is refreshed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `app.py` 文件并导航到该 URL，浏览器将渲染图 6.4 所示的处理程序的输出。每次刷新页面时，时间戳都会更新。这表明 `home()`
    函数正在运行，并且每次页面刷新时，`index.xhtml` 模板都会使用新的 `datetime.now()` 值进行渲染。
- en: '![](../../OEBPS/Images/CH06_F04_Farrell.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F04_Farrell.png)'
- en: Figure 6.4 Your first dynamically built web pages served from your Flask application
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 您的第一个由 Flask 应用程序动态构建的网页
- en: 6.4.4 More Jinja2 features
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 更多 Jinja2 功能
- en: The previous example is a functioning web application, but it only shows off
    a small portion of what Jinja2 can do. Let’s expand on the example web application
    to demonstrate more capabilities of Flask and Jinja2 that you can use in the MyBlog
    project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是一个功能性的网络应用程序，但它只展示了 Jinja2 可以做到的一小部分。让我们扩展这个示例网络应用程序，以展示 Flask 和 Jinja2
    的更多功能，这些功能你可以在 MyBlog 项目中使用。
- en: The updated web application will have a banner and a sticky footer. A sticky
    footer is information on a web page that “sticks” to the bottom of the page even
    if there is whitespace between it and the rest of the page content above it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的网络应用程序将有一个横幅和一个粘性页脚。粘性页脚是网页上的一种信息，即使它与页面上方的其余内容之间有空白，也会“粘”在页面的底部。
- en: Figure 6.5 is a screenshot showing the current time as it does now and a page-visits
    counter that will increment every time the page is refreshed. There will also
    be a list of different colors for the banner and a button that will change the
    banner background color randomly. The application supplies extra functionality
    to provide the random list of colors and the page-visits counter. The server also
    provides styling information to the browser in the form of CSS files and client-side
    (browser) interactivity as a JavaScript file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 是一个截图，显示了当前时间和一个页面访问计数器，该计数器每次刷新页面时都会增加。还将有一个不同颜色的横幅列表和一个随机更改横幅背景颜色的按钮。应用程序提供额外的功能来提供随机颜色列表和页面访问计数器。服务器还以
    CSS 文件的形式向浏览器提供样式信息，以及作为 JavaScript 文件的客户端（浏览器）交互性。
- en: '![](../../OEBPS/Images/CH06_F05_Farrell.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F05_Farrell.png)'
- en: Figure 6.5 The web page with more style and color and some interactivity
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 带有更多样式、颜色和一些交互性的网页
- en: 'The ability of the page-visits counter is provided by a Python class using
    a class-level variable. By using a class variable, the state of the page count
    is accessible by any instance of the class. Any change to the variable is visible
    to any instance that uses it. The `PageVisit` class has a simple purpose and interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 页面访问计数器的功能由一个使用类级变量的 Python 类提供。通过使用类变量，页面计数器的状态可以通过类的任何实例访问。对变量的任何更改都会对使用它的任何实例可见。`PageVisit`
    类具有简单的作用和接口：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `PageVisit` class maintains the availability of the class variable `COUNT`
    for all instances of the class. It also provides the `counts()` method to increment
    the value of `COUNT` and return it to the caller. Every invocation of the `counts()`
    method will increment the `COUNT` value by one. The `PageVisit` class exists because
    the web server can handle many users at once who might be making requests for
    the page, and a consistent value of `COUNT` has to be maintained across all of
    them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageVisit` 类维护类变量 `COUNT` 在所有类实例中的可用性。它还提供了一个 `counts()` 方法来增加 `COUNT` 的值并将其返回给调用者。每次调用
    `counts()` 方法都会将 `COUNT` 的值增加一。`PageVisit` 类的存在是因为 Web 服务器可以同时处理许多用户，他们可能会对页面发起请求，并且必须在所有这些请求中维护
    `COUNT` 的一个一致值。'
- en: tip The `PageVisit` class works for this use case because there is only a single
    instance of the web server running. All requests the server handles would each
    have an instance of `PageVisit`, but they would all reference the same `COUNT`
    class-level variable. This wouldn’t work if multiple web servers were running,
    as the `COUNT` class-level variable would no longer be shared across those multiple
    web server instances.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：`PageVisit` 类适用于此用例，因为只有一个 Web 服务器正在运行。服务器处理的每个请求都会有一个 `PageVisit` 实例，但它们都会引用相同的
    `COUNT` 类级变量。如果有多个 Web 服务器运行，则不会这样，因为 `COUNT` 类级变量将不再在多个 Web 服务器实例之间共享。
- en: The list of banner background colors is used by both the template file that
    renders the HTML of the page and the JavaScript functionality that changes the
    banner background colors on button clicks. Therefore, the colors list has to be
    made available to the template and the JavaScript engine running on the browser.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 标签页背景颜色的列表被用于渲染页面 HTML 的模板文件和按钮点击时更改标签页背景颜色的 JavaScript 功能。因此，颜色列表必须对模板和运行在浏览器上的
    JavaScript 引擎可用。
- en: 'To manage the list of colors, the class `BannerColors` is created. This class
    encapsulates the primary list of colors as a class-level variable and provides
    a method generating a random subset of those colors as a list to use. Like `PageVisit`,
    the class `BannerColors` has a simple purpose and interface:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理颜色列表，创建了 `BannerColors` 类。这个类将主要颜色列表封装为类级变量，并提供一个方法生成这些颜色作为列表的随机子集以供使用。像
    `PageVisit` 类一样，`BannerColors` 类具有简单的作用和接口：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `BannerColors` class maintains the class variable `COLORS` as a list of
    valid CSS color name strings. This creates the palette of banner colors that can
    be displayed on the page. The `get_colors()` method returns a random subset of
    five of those colors as a list using the `Random` module and its sample function
    from the Python standard library. Every time `get_colors()` is invoked, it returns
    a random subset of colors as a list from the `COLORS` class-variable list. The
    `PageVisit` and `BannerColors` classes are added to the `app.py` file in the `examples/CH_06/examples/03`
    directory and integrated into the `home()` function that renders the web page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`BannerColors` 类将类变量 `COLORS` 维护为有效 CSS 颜色名称字符串的列表。这创建了可以在页面上显示的标签页颜色调色板。`get_colors()`
    方法使用 `Random` 模块和 Python 标准库中的 sample 函数返回五个颜色的随机子集作为列表。每次调用 `get_colors()` 时，它都会从
    `COLORS` 类变量列表中返回一个颜色的随机子集作为列表。`PageVisit` 和 `BannerColors` 类被添加到 `examples/CH_06/examples/03`
    目录中的 `app.py` 文件，并集成到渲染网页的 `home()` 函数中：'
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Gets a random list of five colors and assigns it to the variable banner_colors
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取五个颜色的随机列表并将其分配给变量 banner_colors
- en: ② Creates a dictionary of information to pass to the template as the data-named
    variable
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个信息字典，作为数据命名的变量传递给模板
- en: The `BannerColors` class is instantiated right away, and the `get_colors()`
    method is called, storing the results in the variable `banner_colors`. This variable
    is used later to create the data that is passed to the template for rendering.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`BannerColors` 类立即实例化，并调用 `get_colors()` 方法，将结果存储在变量 `banner_colors` 中。这个变量后来用于创建传递给模板进行渲染的数据。'
- en: 'The `render_template` function is called with the name of the template to render,
    `index.xhtml`, and the `data` variable. The `data` variable is a dictionary containing
    key/value pairs to pass information used in the template:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`render_template`函数调用要渲染的模板名称`index.xhtml`和`data`变量。`data`变量是一个包含键/值对的字典，用于传递在模板中使用的信
- en: '`now`—The value returned by `datetime.now()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now`—`datetime.now()`返回的值'
- en: '`page_visit`—An instance of the `PageVisit` class'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page_visit`—`PageVisit`类的实例'
- en: '`banner_colors`—Another dictionary'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`banner_colors`—另一个字典'
- en: '`display`—The previous create `banner_colors` list variable'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display`—之前创建的`banner_colors`列表变量'
- en: '`js`—The result of JSON stringifying the `banner_colors` list'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js`—将`banner_colors`列表JSON序列化的结果'
- en: The `banner_colors` dictionary inside the `data` dictionary contains two variations
    of the `banner_colors` list variable. You’ll see how this is used when we review
    the updated `index.xhtml` template.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`字典内部的`banner_colors`字典包含`banner_colors`列表变量的两个变体。当你我们回顾更新的`index.xhtml`模板时，你会看到它是如何被使用的。'
- en: All the work to this point adds functionality to the home operation that’s run
    when a user browses to the home page of the application. This functionality passes
    new data to the `index.xhtml` template and is rendered as a complete HTML page
    by Jinja2.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有工作都是为了向用户浏览应用主页时运行的家操作添加功能。这个功能将新数据传递给`index.xhtml`模板，并由Jinja2渲染为完整的HTML页面。
- en: Template inheritance
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模板继承
- en: Before we review the updated `index.xhtml` template, take a look at the screenshot
    of the web application presented earlier in figure 6.5\. The page has a banner
    and a footer section. Very often these kinds of visual and informative features
    are common to every page of a web application. HTML boilerplate code is also common
    to every page.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回顾更新的`index.xhtml`模板之前，先看看之前在图6.5中展示的Web应用的截图。页面有一个横幅和页脚部分。这类视觉和信息特征通常在每个Web应用的页面上都是常见的。HTML样板代码也是每个页面共有的。
- en: Based on the “don’t repeat yourself” principle (DRY), it would be useful to
    pull the common elements of an HTML page together rather than copying those pieces
    to every page. Even worse would be maintaining all those copies of the common
    elements as the web application changes and evolves. The Jinja2 templating engine
    provides for this using template inheritance, which is conceptually similar to
    class inheritance in Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据“不要重复自己”（DRY）的原则，将HTML页面的公共元素集中起来，而不是将这些部分复制到每个页面中，这将非常有用。更糟糕的是，当Web应用发生变化和演变时，维护所有这些公共元素的副本。Jinja2模板引擎通过模板继承提供这种功能，这在概念上类似于Python中的类继承。
- en: Before using template inheritance, you’ll need to expand the directory structure
    of the web application. Because you’re going to be serving static CSS and JavaScript
    files to the application, those files need to live somewhere that the web server
    can access them. By default, Flask looks for static files in a directory named
    `static`, a sibling of the `templates` directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板继承之前，你需要扩展Web应用的目录结构。因为你将要为应用提供静态CSS和JavaScript文件，这些文件需要存储在Web服务器可以访问的地方。默认情况下，Flask在名为`static`的目录中查找静态文件，该目录是`templates`目录的兄弟目录。
- en: 'Create the `static` directory at the same level as the `templates` directory.
    To help keep the `static` directory organized, create `CSS` and `JS` subdirectories
    to place the CSS and JavaScript files into. These files will give the web application
    its presentation and interactivity. Your directory structure should look like
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`templates`目录同一级别的位置创建`static`目录。为了帮助保持`static`目录的有序性，创建`CSS`和`JS`子目录，将CSS和JavaScript文件放入其中。这些文件将为Web应用提供其表现力和交互性。你的目录结构应该看起来像这样：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Parent template
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 父模板
- en: 'Copy the `index.xhtml` file to create a new file named `base.xhtml` in the
    `templates` directory. This is now the parent template containing all the common
    features presented on the web pages of the application. Modify the new `base.xhtml`
    template file to look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`index.xhtml`文件复制到`templates`目录下创建一个名为`base.xhtml`的新文件。这个文件现在是包含应用网页上所有常见特征的父模板。修改新的`base.xhtml`模板文件，使其看起来像这样：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Creates a template section named head, which will be referred to by child
    templates
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个名为head的模板部分，将被子模板引用
- en: ② Creates an inner template section named styles, which will be referred to
    by child templates to insert CSS file references
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个名为styles的内部模板部分，将被子模板引用以插入CSS文件引用
- en: ③ Creates an empty template section named content, which contains the content
    of the page and is provided by the child templates
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个名为 `content` 的空模板部分，它包含页面的内容，并由子模板提供
- en: ④ Creates a template section named footer, which can be referred to by child
    templates
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个名为 `footer` 的模板部分，子模板可以引用它
- en: ⑤ Creates an empty template section named scripts, which child templates can
    use to insert JavaScript file references
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建一个名为 `scripts` 的空模板部分，子模板可以使用它来插入JavaScript文件引用
- en: This template includes HTML code you’ve seen before mixed with Jinja2 template
    code. The template code that begins with `{%` `block` `head` `%}` and ends with
    `{%` `endblock` `%}` creates a template section named `head` that can be referenced
    in a child template by referring to the block name. Blocks like this can even
    be referenced from other files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板包含您之前见过的HTML代码与Jinja2模板代码的混合。以 `{% block head %}` 开始并以 `{% endblock %}` 结束的模板代码创建了一个名为
    `head` 的模板部分，子模板可以通过引用块名称来引用它。这样的块甚至可以从其他文件中引用。
- en: The block named `styles` contains a stylesheet link. Inside the `href` portion
    of the link is another Jinja2 template construct, `{{url_for('static',` `filename
    ='css/blog.css')}}`. This expression substitution is executing the Python `url_
    for` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `styles` 的块包含一个样式表链接。在链接的 `href` 部分中，还有一个Jinja2模板构造，`{{url_for('static',
    filename='css/blog.css')}}`。这个表达式替换正在执行Python的 `url_for` 函数。
- en: It’s generally a bad idea to hardcode URL paths within a web application, and
    the `url_for` function helps avoid this. By passing a known URL endpoint as the
    first parameter and the relative file path as the second, the function can create
    a URL to the desired file that’s valid for the Flask application. When the template
    is rendered, a valid URL to the `blog.css` file will exist in the stylesheet link
    rendered by the browser.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中硬编码URL路径通常不是一个好主意，而 `url_for` 函数有助于避免这种情况。通过传递已知的URL端点作为第一个参数和相对文件路径作为第二个参数，该函数可以创建一个对Flask应用程序有效的目标文件的URL。当模板被渲染时，浏览器渲染的样式表中将存在一个指向
    `blog.css` 文件的合法URL。
- en: The empty block sections named `content` and `scripts`, respectively, create
    references that will be used by the `index.xhtml` file, inheriting from the `base.xhtml`
    template. The `index.xhtml` file will use the references to inject content into
    the page and include a page-specific JavaScript file named `index.js` containing
    client-side interactivity code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 分别名为 `content` 和 `scripts` 的空块部分创建引用，这些引用将由继承自 `base.xhtml` 模板的 `index.xhtml`
    文件使用。`index.xhtml` 文件将使用这些引用将内容注入页面，并包含一个名为 `index.js` 的页面特定JavaScript文件，其中包含客户端交互代码。
- en: Child template
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 子模板
- en: 'Now that you have a base template, it’s time to inherit from it by modifying
    the `index.xhtml` template:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了基础模板，是时候通过修改 `index.xhtml` 模板来继承它了：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Makes this child template inherit from the base.xhtml parent template
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使此子模板继承自基础模板 `base.xhtml`
- en: ② Creates the content to render to the page, which will replace the empty content
    block in the parent template
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建要渲染到页面上的内容，这将替换父模板中的空内容块
- en: ③ Adds specific CSS style information for this child template to the styles
    block. The {{ super() }} expression calls the parent styles block first and then
    adds the content of this block.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为此子模板添加特定的CSS样式信息到样式块中。`{{ super() }}` 表达式首先调用父样式块，然后添加此块的内容。
- en: ④ Adds specific JavaScript file references for this child template to the scripts
    block. The {{ super() }} expression calls the parent styles block first and then
    adds the content of this block.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为此子模板添加特定的JavaScript文件引用到脚本块中。`{{ super() }}` 表达式首先调用父样式块，然后添加此块的内容。
- en: Like Python classes, the child template references the parent template to inherit
    from by referring to it in the template code on the first line. The `{% extends
    base.xhtml%}` template code informs Jinja2 that `index.xhtml` is inheriting from
    `base.xhtml`. The template engine knows how to find the `base.xhtml` template
    file in the same way that it found the `index.xhtml` template, by looking in the
    `templates` directory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python类一样，子模板通过在模板代码的第一行引用父模板来继承它。`{% extends base.xhtml %}` 模板代码通知Jinja2 `index.xhtml`
    正在继承 `base.xhtml`。模板引擎知道如何以与找到 `index.xhtml` 模板相同的方式找到 `base.xhtml` 模板，即通过在 `templates`
    目录中查找。
- en: The content provided by the `index.xhtml` file begins with the `{%` `block`
    `content%}` start marker and ends with the `{%` `endblock` `%}` marker. When the
    complete page is rendered by Jinja2, the content will be placed on the HTML page
    at the position of the content block reference in the `base.xhtml` parent template
    file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由`index.xhtml`文件提供的内容从`{% block content %}`开始标记开始，以`{% endblock %}`标记结束。当Jinja2渲染完整页面时，内容将被放置在`base.xhtml`父模板文件中内容块引用的位置。
- en: The data that is passed to the template by the `render_template` function is
    used inside the content section. The `{{data["now"]}}` Jinja2 expression gets
    the current timestamp. The `{{data["page_visit"].counts()}}` expression gets the
    `PageVisit` instance and calls its `counts()` method to obtain the current page-visit
    counts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`render_template`函数传递给模板的数据在内容部分内部使用。`{{data["now"]}}` Jinja2表达式获取当前时间戳。`{{data["page_visit"].counts()}}`表达式获取`PageVisit`实例并调用其`counts()`方法以获取当前页面访问次数。
- en: The Jinja2 language provides a mechanism to create repeating data in the rendered
    template by using a `for` loop. Mimicking Python, the loop construct is a `For-In`
    loop iterating over the contents of the iterable `data["banner_ colors"]["display"]`
    list. Each item in the list is used to create an HTML list element with the code
    `<li>{{banner_color}}</li>`. The `for` loop ends with the `{% endfor %}` marker.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2语言通过使用`for`循环提供了一种在渲染的模板中创建重复数据的机制。模仿Python，循环结构是一个遍历可迭代对象`data["banner_colors"]["display"]`列表内容的`For-In`循环。列表中的每个项目都用于创建一个带有代码`<li>{{banner_color}}</li>`的HTML列表元素。`for`循环以`{%
    endfor %}`标记结束。
- en: The block named `styles` refers to the same block in the `base.xhtml` template.
    Recall that the stylesheet block in the parent template wasn’t empty; it had a
    stylesheet link to pull presentation information common to all web pages. The
    `{{super()}}` expression renders the parent stylesheet block before including
    the information defined in the child `index.xhtml` template.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`styles`的块引用了`base.xhtml`模板中的相同块。回想一下，父模板中的样式表块不为空；它有一个样式表链接来提取所有网页共有的展示信息。`{{super()}}`表达式在包含子`index.xhtml`模板中定义的信息之前渲染父样式表块。
- en: The block named `scripts` handles a couple of functions. It uses the `{{super()}}`
    expression to render anything defined by the parent template, which is nothing
    currently. It then builds some JavaScript code directly to define a variable called
    `banner_colors,` which is initialized with the JSON formatted string of banner
    colors supplied by `{{data["banner_colors"]["js"]` `|` `safe}}`. The `|` `safe`
    part of the syntax prevents Jinja2 from translating symbols that could be dangerous.
    It’s not necessary here because the data is coming from the application itself
    but is good to keep in mind.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`scripts`的块处理几个函数。它使用`{{super()}}`表达式渲染由父模板定义的内容，目前为空。然后直接构建一些JavaScript代码来定义一个名为`banner_colors`的变量，该变量使用由`{{data["banner_colors"]["js"]
    | safe}}`提供的JSON格式字符串初始化。语法中的`| safe`部分防止Jinja2翻译可能危险的符号。在这里不是必需的，因为数据来自应用程序本身，但值得记住。
- en: If the data had been supplied in a form by a user, the data could contain information
    that might be an XSS attack. An XSS attack can be JavaScript inserted into the
    data that was entered by a user, which could cause your site to take unintentional
    actions. Lastly, a script tag referencing an external JavaScript file using the
    same `url_for()` mechanism to create a valid relative URL for the web application
    is included.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是通过用户表单提供的，数据可能包含可能成为XSS攻击的信息。XSS攻击可以是插入到用户输入数据中的JavaScript，这可能导致您的网站执行非预期操作。最后，包含一个引用外部JavaScript文件的脚本标签，使用相同的`url_for()`机制为网络应用程序创建一个有效的相对URL。
- en: Presentation
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 展示
- en: 'The presentation of the web page is controlled by the `index.css` file, which
    contains CSS code that applies style information to the HTML elements created
    by the Flask `render_template` function as presented by the browser. There are
    two CSS files connected to the application—`myblog.css` and `index.css`. The `myblog.css`
    file applies to the parent template file `base.xhtml`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的展示由`index.css`文件控制，该文件包含应用于由Flask的`render_template`函数创建的HTML元素的CSS代码，这些元素由浏览器展示。应用程序连接了两个CSS文件——`myblog.css`和`index.css`。`myblog.css`文件应用于父模板文件`base.xhtml`：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Though this book isn’t about CSS, it’s worth reviewing some of the previous
    code to get a feel for how CSS code affects the presentation of a web page. Keep
    in mind that the spacing and indentation of the CSS code is a convention for readability
    and is not part of the required syntax.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书不是关于CSS的，但回顾一些之前的代码有助于了解CSS代码如何影响网页的展示。请注意，CSS代码的间距和缩进是可读性的约定，不是必需的语法的一部分。
- en: CSS code is about using and creating selectors to attach specific style information
    to HTML elements so the browser can render the HTML elements with the intended
    look and feel. For example, the code `#content` `h2` `{...}` attaches style rules
    to the HTML header `<h2>` element contained in the `<div` `id="content">` element.
    This selector narrows where the style will be applied on the page; in this case,
    only the `<h2>` tag within the `<div` `id="content">` tag will have a rounded
    border with an internal padding of 20 pixels. The header text will be centered
    and have a background color of `bisque`. The rest of the selectors apply style
    rules to other parts of the `base.xhtml` page.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: CSS代码是关于使用和创建选择器，将特定的样式信息附加到HTML元素上，以便浏览器可以按照预期的外观和感觉渲染HTML元素。例如，代码`#content
    h2 {...}`将样式规则附加到包含在`<div id="content">`元素中的HTML `<h2>`元素上。此选择器缩小了样式将在页面上应用的范围；在这种情况下，只有`<div
    id="content">`标签内的`<h2>`标签将具有20像素的内边距和圆角边框。标题文本将居中，并具有`bisque`背景色。其余的选择器将样式规则应用于`base.xhtml`页面的其他部分。
- en: 'These styles will be applied to every page that inherits from the `base.xhtml`
    parent template. The `index.css` file applies rules to the `index.xhtml` child
    template page:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式将应用于继承自`base.xhtml`父模板的每个页面。`index.css`文件将规则应用于`index.xhtml`子模板页面：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The selectors in this code apply styles to HTML elements that are created by
    the `index.xhtml` page, essentially giving some style and CSS interactivity to
    the color-change button.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的选择器应用于由`index.xhtml`页面创建的HTML元素，本质上为颜色变化按钮添加了一些样式和CSS交互性。
- en: Interactivity
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 交互性
- en: 'This book isn’t about JavaScript, and its use will be kept to a minimum, but
    most of the interesting web applications will include some JavaScript code. Once
    the HTML page is built by the server, it is sent to the browser as a response.
    The browser will then render the HTML visually in the browser window. It will
    also parse and compile the JavaScript sent in the response and pulled from the
    external file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是关于JavaScript的，其使用将保持在最低限度，但大多数有趣的网络应用程序都将包含一些JavaScript代码。一旦服务器构建了HTML页面，它就会被作为响应发送到浏览器。然后浏览器将在浏览器窗口中可视地渲染HTML。它还将解析和编译响应中发送的以及从外部文件中提取的JavaScript：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Waits for the page to be loaded before executing the nested code
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ① 在执行嵌套代码之前等待页面加载
- en: ② Gets a reference to the banner element
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取横幅元素的引用
- en: ③ Adds a click event handler for the banner color-changing button
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为横幅颜色变化按钮添加点击事件处理器
- en: ④ Checks to see if the click event originated from the button
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查点击事件是否来自按钮
- en: ⑤ Selects a random color from the banner_colors list
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 从banner_colors列表中随机选择颜色
- en: ⑥ Changes the banner background color
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 更改横幅背景颜色
- en: This is vanilla JavaScript code (no frameworks like jQuery involved) that adds
    an action if the displayed button is clicked. The code creates an anonymous function
    to run when the page is finished loading. The anonymous function creates a reference
    to the banner element and then adds another anonymous function to listen for the
    `click` event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段纯JavaScript代码（不涉及jQuery等框架），当显示的按钮被点击时，它会添加一个动作。代码创建了一个匿名函数，在页面加载完成后运行。匿名函数创建了对横幅元素的引用，然后添加另一个匿名函数来监听`click`事件。
- en: Inside the `click` event handler, a conditional statement checks if the event
    was generated by the button to change banner color. If so, a random color is selected
    from the `banner_colors` list and is used to change the background color of the
    banner.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`click`事件处理器内部，一个条件语句检查事件是否由更改横幅颜色的按钮生成。如果是这样，从`banner_colors`列表中随机选择一个颜色，并用于更改横幅的背景颜色。
- en: 6.5 Running the web server
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 运行网络服务器
- en: 'The updated app exists in `examples/CH_06/examples/03`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的应用程序位于`examples/CH_06/examples/03`：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the terminal, move to the directory and set the environment variable `FLASK_APP`
    to point to your application by entering the following in your command line for
    Mac and Linux:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，移动到目录并设置环境变量`FLASK_APP`以指向您的应用程序，在Mac和Linux的命令行中输入以下内容：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And this for Windows users:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户来说：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the web server by entering `flask run` at the terminal command line. You
    should see the server start up, and then you can navigate to `http:127.0.0.1:5000`
    to see the application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端命令行中输入`flask run`来运行Web服务器。你应该看到服务器启动，然后你可以导航到`http:127.0.0.1:5000`来查看应用程序。
- en: When you run the web application with the `flask run` command, the server starts
    and runs with the Flask built-in web server. The built-in web server is suitable
    for development and experimentation, but it is not suitable for production.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`flask run`命令运行Web应用程序时，服务器会启动并使用Flask内置的Web服务器运行。内置的Web服务器适合开发和实验，但不适合生产。
- en: For production, you’ll need to use a production-ready WSGI server, which stands
    for Web Server Gateway Interface. A WSGI server is an application that provides
    a simple calling convention to forward requests from a web server to a Python
    web application. The web server built into Flask is a WSGI server that provides
    this calling convention for development purposes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，你需要使用一个生产就绪的WSGI服务器，这代表Web服务器网关接口。WSGI服务器是一个提供简单调用约定以将请求从Web服务器转发到Python网络应用程序的应用程序。Flask内置的Web服务器是一个WSGI服务器，它为开发目的提供这种调用约定。
- en: The WSGI standard exists to abstract away the complexities of interfacing your
    Python web application with a web server and the world. As long as you’re building
    your application to the WSGI interface standard—which Flask and just about all
    other Python web frameworks do—your application can provide request-response handling
    accessible through the internet.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准的存在是为了抽象出将你的Python网络应用程序与Web服务器和世界交互的复杂性。只要你的应用程序是按照WSGI接口标准构建的——Flask和其他几乎所有Python网络框架都是这样做的——你的应用程序就可以通过互联网提供可访问的请求-响应处理。
- en: Two of the most common production-grade WSGI servers are uWSGI and Gunicorn.
    The uWSGI application is a popular, high-performance application written in C/C++.
    Gunicorn, short for Green Unicorn, is also a high-performance WSGI-compliant web
    server application. Both are production-ready.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最常见的生产级WSGI服务器是uWSGI和Gunicorn。uWSGI应用程序是一个用C/C++编写的流行、高性能应用程序。Gunicorn，简称绿色独角兽，也是一个高性能的符合WSGI规范的Web服务器应用程序。两者都适用于生产环境。
- en: 6.5.1 Gunicorn
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 Gunicorn
- en: 'To run your application using Gunicorn, you need to install it using the following
    command from your Python virtual environment:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gunicorn运行你的应用程序，你需要使用以下命令从你的Python虚拟环境中安装它：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In one of the example application directories, enter this command while in
    the terminal:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个示例应用程序目录中，在终端中输入以下命令：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This tells Gunicorn to start four worker instances of your application, which
    it finds with the `app:app` part of the command. The first part is the name of
    the Python file, `app.py`, and the second part, `:app`, refers to the Flask application
    instance created within the application by the `app` `=` `Flask(__name__)` part
    of the code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Gunicorn启动四个工作进程实例，它通过命令中的`app:app`部分找到你的应用程序。第一部分是Python文件名，`app.py`，第二部分`:app`指的是代码中通过`app
    = Flask(__name__)`部分在应用程序内部创建的Flask应用程序实例。
- en: Running multiple instances of the application with Gunicorn workers allows your
    application to scale up to handle hundreds, even thousands, of requests per second.
    The number of requests per second that the application can handle depends upon
    the workload each request makes on the application and how much time it takes
    before a response is generated.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gunicorn工作进程运行应用程序的多个实例可以让你的应用程序扩展到每秒处理数百甚至数千个请求。应用程序可以处理的每秒请求数量取决于每个请求对应用程序的工作负载以及生成响应所需的时间。
- en: According to the Gunicorn documentation, the recommended number of workers for
    an application running on a single production server is (2 × number_of_CPU cores)
    + 1\. The formula is loosely based on the idea that for any given CPU core, one
    worker will be performing IO (input/output) operations, and the other worker will
    be performing CPU operations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Gunicorn文档，在单个生产服务器上运行的应用程序推荐的工作进程数是`(2 × CPU核心数) + 1`。这个公式大致基于这样一个想法：对于任何给定的CPU核心，一个工作进程将执行IO（输入/输出）操作，而另一个工作进程将执行CPU操作。
- en: 6.5.2 Commercial hosting
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 商业托管
- en: When you want to make your web application available for public use, you need
    to do so using a hosting service. There are many services available to host your
    application. They will offer options like Apache or Nginx for web serving and
    uWSGI and Gunicorn for WSGI interfacing with your Python-based web application.
    It’s also possible to deploy your application using Docker containers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想让你的网络应用程序对公众可用时，你需要通过托管服务来实现。有许多服务可供托管你的应用程序。它们将提供诸如Apache或Nginx这样的选项用于Web服务，以及uWSGI和Gunicorn用于与基于Python的网络应用程序的WSGI接口。使用Docker容器部署你的应用程序也是可能的。
- en: tip Inside a Docker container, you would run a WSGI-compliant web server to
    interface with your contained Python application. You would connect to this WSGI-compliant
    web server (uWSGI, Gunicorn, and so on) by the host of the Docker container.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在Docker容器内部，你会运行一个符合WSGI规范的Web服务器来与你的容器内Python应用程序进行接口。你将通过Docker容器的宿主连接到这个符合WSGI规范的Web服务器（uWSGI、Gunicorn等）。
- en: I’m sure there are more options and configurations than I’ve listed here. The
    choice depends on you, your goals for the application, and the cost of those choices.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信这里列出的选项和配置比我所列出的要多。选择取决于你，你的应用程序目标以及这些选择的成本。
- en: 'Because of the wide array of options available and combinations afforded by
    those options, I’m not going to spend time defining how to deploy a Flask-based
    Python application to specific examples. My reasons are twofold:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可用的选项范围广泛，以及这些选项提供的组合，我不会花费时间定义如何将基于Flask的Python应用程序部署到特定的示例。我的理由有两个：
- en: It’s unlikely I would hit upon a combination of choices that would suit your
    deployment use case perfectly.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我不太可能找到一组完全适合你的部署用例的选择。
- en: Deploying an application is a topic worthy of its own book and doesn’t directly
    contribute to becoming a well-grounded Python developer.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序是一个值得单独成书的话题，并且并不直接有助于成为一个扎实的Python开发者。
- en: 6.6 Closing thoughts
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 总结
- en: The next chapter will begin to build the groundwork for the MyBlog application,
    which will grow throughout the book to become fully featured. Along the way, you’ll
    learn how to handle the development of a larger application and how to integrate
    it with a persistent database. What you’ve learned so far can make the project
    manageable to build and enjoyable to achieve.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将开始为MyBlog应用程序打下基础，这个应用程序将在整本书中逐渐发展成为一个功能齐全的应用程序。在这个过程中，你将学习如何处理大型应用程序的开发以及如何将其与持久数据库集成。你到目前为止所学的内容可以使项目易于构建并令人愉快地实现。
- en: You’ve brought ideas from your field of view into focus and can now see the
    direction to take and some of what we’ll learn along the way. We’ll continue along
    this path to consider development items in detail as we look at them more closely.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将你视野中的想法聚焦起来，现在可以看到前进的方向以及我们将要学习的一些内容。我们将沿着这条道路继续前进，在更仔细地观察它们时，我们将详细考虑开发项目。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Much of the internet world is available because of servers and, in particular,
    web servers. Knowing how to create server-based applications is a cornerstone
    skill of a well-grounded developer.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网世界的很大一部分都是由于服务器，尤其是Web服务器而得以存在的。了解如何创建基于服务器的应用程序是一个扎实开发者的基石技能。
- en: The Flask web application development framework is one of many such frameworks
    available to Python developers. It’s well-suited as the teaching framework to
    create the MyBlog web application that we’ll create as we move through the rest
    of the chapters in this book.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask网络应用程序开发框架是许多此类框架中的一种，对于Python开发者来说非常适合作为教学框架来创建我们将在本书的其余章节中创建的MyBlog网络应用程序。
- en: The Jinja2 template system included with Flask is a powerful way to create web
    pages that have common elements mixed with dynamically created ones. The content
    of dynamic elements in a template can come from any source—including databases,
    computations, and other servers. Almost anything you can access with your Python
    programs can be injected into a template through a dynamic element.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask附带包含的Jinja2模板系统是一种创建具有常见元素和动态创建元素混合的网页的强大方式。模板中动态元素的内容可以来自任何来源——包括数据库、计算和其他服务器。你可以用Python程序访问的几乎所有内容都可以通过动态元素注入到模板中。
- en: Jinja2 templates allow for inheritance, which means that a template containing
    common elements used throughout a website can be inherited from page-specific
    templates. Using this inheritance significantly lowers the workload for building
    a dynamic web application.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2 模板支持继承，这意味着一个包含整个网站中使用的通用元素的模板可以从页面特定的模板中继承。使用这种继承可以显著降低构建动态Web应用程序的工作量。
