- en: 14 Configuration and secrets management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 配置和秘密管理
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Configuring applications on Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上配置应用程序
- en: Using ConfigMaps and Secrets in Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用 ConfigMaps 和 Secrets
- en: Managing deployments and configuration with Kustomize
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kustomize 管理部署和配置
- en: 'Releasing applications to production involves two important aspects: an executable
    artifact and its configuration. The executable artifact could be a JAR file or
    a container image. The previous chapters covered several principles, patterns,
    and tools for building applications that are loosely coupled, resilient, scalable,
    secure, and observable. You saw how to package applications as executable JAR
    artifacts or container images. I also guided you through the implementation of
    the commit stage of a deployment pipeline, which ultimately produces a release
    candidate.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序发布到生产环境涉及两个重要方面：可执行工件及其配置。可执行工件可以是 JAR 文件或容器镜像。前几章涵盖了构建松散耦合、弹性、可扩展、安全且可观察的应用程序的原则、模式和工具。您看到了如何将应用程序打包为可执行
    JAR 工件或容器镜像。我还指导您实现了部署管道的提交阶段，这最终产生了一个发布候选。
- en: The other aspect of being ready for production is configuration. Chapter 4 introduced
    the importance of externalized configuration for cloud native applications and
    covered several techniques for configuring Spring Boot applications. This chapter
    will continue that discussion in preparation for deploying an entire cloud native
    system to a Kubernetes production environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 准备生产环境的其他方面是配置。第 4 章介绍了云原生应用程序外部化配置的重要性，并涵盖了配置 Spring Boot 应用程序的几种技术。本章将继续这一讨论，为将整个云原生系统部署到
    Kubernetes 生产环境做准备。
- en: First I’ll describe a few options for configuring Spring Boot applications on
    Kubernetes and describe what’s missing for using Spring Cloud Config in production.
    Then you’ll learn how to use ConfigMaps and Secrets, a native mechanism for handling
    configuration on Kubernetes. As part of the discussion, you’ll get to know Spring
    Cloud Kubernetes and its primary use cases. Finally, I’ll expand on configuration
    and secrets management for production workloads on Kubernetes, and you’ll learn
    how to implement that using Kustomize.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将描述一些在 Kubernetes 上配置 Spring Boot 应用程序的选择，并描述在生产环境中使用 Spring Cloud Config
    缺少的部分。然后，您将学习如何使用 ConfigMaps 和 Secrets，这是在 Kubernetes 上处理配置的原生机制。作为讨论的一部分，您将了解
    Spring Cloud Kubernetes 及其主要用例。最后，我将扩展 Kubernetes 上生产工作负载的配置和秘密管理，您将学习如何使用 Kustomize
    来实现这一点。
- en: Note The source code for the examples in this chapter is available in the Chapter14/14-begin
    and Chapter14/14-end folders, containing the initial and final states of the project
    ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在 Chapter14/14-begin 和 Chapter14/14-end 文件夹中找到，包含项目的初始状态和最终状态 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。
- en: 14.1 Configuring applications on Kubernetes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 在 Kubernetes 上配置应用程序
- en: 'According to the 15-Factor methodology, configuration is anything that changes
    between deployment environments. We started working with configuration in chapter
    4 and since then have used different configuration strategies:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 15-Factor 方法论，配置是部署环境之间发生变化的一切。我们从第 4 章开始处理配置，并自那时起使用了不同的配置策略：
- en: '*Property files packaged with the application*—These can act as specifications
    of what configuration data the application supports, and they are useful for defining
    sensible default values, mainly oriented to the development environment.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与应用程序打包的属性文件*—这些文件可以作为应用程序支持的配置数据的规范，它们对于定义合理的默认值非常有用，主要面向开发环境。'
- en: '*Environment variables*—These are supported by any operating system, so they
    are great for portability. They’re useful for defining configuration data depending
    on the infrastructure or platform where the application is deployed, such as active
    profiles, hostnames, service names, and port numbers. We used them in Docker and
    Kubernetes.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*环境变量*—任何操作系统都支持这些变量，因此它们非常适合便携性。它们对于根据应用程序部署的基础设施或平台定义配置数据非常有用，例如活动配置文件、主机名、服务名称和端口号。我们在
    Docker 和 Kubernetes 中使用了它们。'
- en: '*Configuration service*—This provides configuration data persistence, auditing,
    and accountability. It’s useful for defining configuration data specific to the
    application, such as feature flags, thread pools, connection pools, timeouts,
    and URLs for third-party services. We adopted this strategy with Spring Cloud
    Config.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置服务*——这提供了配置数据持久化、审计和问责制。它对于定义特定于应用程序的配置数据很有用，例如功能标志、线程池、连接池、超时和第三方服务的 URL。我们采用了
    Spring Cloud Config 的这种策略。'
- en: 'Those three strategies are generic enough that we can use them to configure
    applications for any cloud environment and service model (CaaS, PaaS, FaaS). When
    it comes to Kubernetes, there’s an additional configuration strategy that is provided
    natively by the platform: ConfigMaps and Secrets.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种策略足够通用，我们可以使用它们来配置任何云环境和服务模型（CaaS、PaaS、FaaS）中的应用程序。当涉及到 Kubernetes 时，平台还提供了一个额外的配置策略，这是平台原生提供的：ConfigMaps
    和 Secrets。
- en: 'These are a very convenient way to define configuration data that depends on
    the infrastructure and platform where the application is deployed: service names
    (defined by Kubernetes Service objects), credentials and certificates for accessing
    other services running on the platform, graceful shutdown, logging, and monitoring.
    You could use ConfigMaps and Secrets to complement or completely replace what
    a configuration service does. Which you choose depends on the context. In any
    case, Spring Boot provides native support for all those options.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常方便的方式来定义依赖于应用程序部署的基础设施和平台上的配置数据：服务名称（由 Kubernetes Service 对象定义）、访问平台上运行的其他服务的凭据和证书、优雅关闭、日志记录和监控。您可以使用
    ConfigMaps 和 Secrets 来补充或完全替代配置服务所做的工作。您选择哪种取决于上下文。在任何情况下，Spring Boot 都为所有这些选项提供了原生支持。
- en: For the Polar Bookshop system, we’ll use ConfigMaps and Secrets instead of the
    Config Service to configure applications in Kubernetes environments. Still, all
    the work we’ve done so far on Config Service would make including it in the overall
    deployment of Polar Bookshop on Kubernetes straightforward. In this section, I’ll
    share some final considerations for making Config Service production-ready, in
    case you’d like to expand on the examples and include it in the final deployment
    in production.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Polar Bookshop 系统，我们将使用 ConfigMaps 和 Secrets 而不是 Config Service 来配置 Kubernetes
    环境中的应用程序。尽管如此，我们迄今为止在 Config Service 上所做的工作将使得将其包含在 Polar Bookshop 在 Kubernetes
    上的整体部署中变得简单直接。在本节中，我将分享一些使 Config Service 适用于生产的最终考虑因素，以防您想扩展示例并将其包含在生产环境中的最终部署中。
- en: 14.1.1 Securing the configuration server with Spring Security
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 使用 Spring Security 保护配置服务器
- en: In previous chapters, we spent quite some time ensuring a high-security level
    for the Spring Boot applications in Polar Bookshop. However, Config Service was
    not one of them, and it’s still unprotected. Even if it’s a config server, it’s
    still a Spring Boot application at its heart. As such, we can secure it using
    any of the strategies provided by Spring Security.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们花费了大量时间确保 Polar Bookshop 中的 Spring Boot 应用程序具有高安全级别。然而，Config Service
    并不是其中之一，它仍然没有受到保护。即使它是一个配置服务器，本质上它仍然是一个 Spring Boot 应用程序。因此，我们可以使用 Spring Security
    提供的任何策略来保护它。
- en: Config Service is accessed over HTTP by the other Spring Boot applications in
    the architecture. Before using it in production, we must ensure that only authenticated
    and authorized parties can retrieve configuration data. One option would be to
    use the OAuth2 Client credentials flow to secure the interactions between Config
    Service and applications based on an Access Token. It’s an OAuth2 flow specific
    for protecting service-to-service interactions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Config Service 通过 HTTP 被架构中的其他 Spring Boot 应用程序访问。在生产中使用它之前，我们必须确保只有经过身份验证和授权的各方才能检索配置数据。一个选择是使用
    OAuth2 客户端凭据流来保护 Config Service 与应用程序之间的交互，基于访问令牌。这是一个专门用于保护服务间交互的 OAuth2 流程。
- en: 'Assuming that applications will communicate over HTTPS, the *HTTP Basic* authentication
    strategy would be another viable option. When using this strategy, applications
    can be configured with the username and password via the properties exposed by
    Spring Cloud Config Client: spring.cloud.config.username and spring.cloud.config.password.
    For more information, refer to the official documentation for Spring Security
    ([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security))
    and Spring Cloud Config ([https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config)).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用将通过HTTPS进行通信，*HTTP Basic*认证策略将是另一个可行的选项。当使用此策略时，可以通过Spring Cloud Config
    Client公开的属性配置用户名和密码：spring.cloud.config.username和spring.cloud.config.password。有关更多信息，请参阅Spring
    Security([https://spring.io/projects/spring-security](https://spring.io/projects/spring-security))和Spring
    Cloud Config([https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config))的官方文档。
- en: 14.1.2 Refreshing configuration at runtime with Spring Cloud Bus
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 使用Spring Cloud Bus在运行时刷新配置
- en: Imagine you have deployed your Spring Boot applications in a cloud environment
    like Kubernetes. During the startup phase, each application loaded its configuration
    from an external config server, but at some point you decide to make changes in
    the config repo. How can you make the applications aware of the configuration
    changes and have them reload it?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在Kubernetes这样的云环境中部署了Spring Boot应用。在启动阶段，每个应用都从外部配置服务器加载了配置，但在某个时候你决定在配置仓库中做出更改。你如何让应用意识到配置更改并重新加载它？
- en: In chapter 4, you learned that you could trigger a configuration refresh operation
    by sending a POST request to the /actuator/refresh endpoint provided by Spring
    Boot Actuator. A request to that endpoint results in a RefreshScopeRefreshedEvent
    event inside the application context. All beans marked with @ConfigurationProperties
    or @RefreshScope listen to that event and get reloaded when it happens.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章中，你了解到可以通过向Spring Boot Actuator提供的/actuator/refresh端点发送POST请求来触发配置刷新操作。对该端点的请求会在应用程序上下文中引发RefreshScopeRefreshedEvent事件。所有标记有@ConfigurationProperties或@RefreshScope的bean都会监听该事件，并在事件发生时重新加载。
- en: You tried the refresh mechanism on Catalog Service, and it worked fine, since
    it was just one application, and not even replicated. How about in production?
    Considering the distribution and scale of cloud native applications, sending an
    HTTP request to all the instances of each application might be a problem. Automation
    is a crucial part of any cloud native strategy, so we need a way to trigger a
    RefreshScopeRefreshedEvent event in all of them in one shot. There are a few viable
    solutions. Using Spring Cloud Bus is one of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你在目录服务上尝试了刷新机制，由于它只是一个应用，并且没有复制，所以它运行得很好。那么在生产环境中呢？考虑到云原生应用的分布和规模，向每个应用的每个实例发送HTTP请求可能是个问题。自动化是任何云原生策略的关键部分，因此我们需要一种方法，一次性触发所有应用的RefreshScopeRefreshedEvent事件。有几个可行的解决方案。使用Spring
    Cloud Bus就是其中之一。
- en: Spring Cloud Bus ([https://spring.io/projects/spring-cloud-bus](https://spring.io/projects/spring-cloud-bus))
    establishes a convenient communication channel for broadcasting events among all
    the application instances linked to it. It provides an implementation for AMQP
    brokers (like RabbitMQ) and Kafka, relying on the Spring Cloud Stream project
    you learned about in chapter 10.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus([https://spring.io/projects/spring-cloud-bus](https://spring.io/projects/spring-cloud-bus))为所有与其链接的应用实例之间广播事件提供了一个便捷的通信通道。它为AMQP代理（如RabbitMQ）和Kafka提供了实现，依赖于你在第十章中了解到的Spring
    Cloud Stream项目。
- en: Any configuration change consists of pushing a commit to the config repo. It
    would be convenient to set up some automation to make Config Service refresh the
    configuration when a new commit is pushed to the repository, completely removing
    the need for manual intervention. Spring Cloud Config provides a Monitor library
    that makes that possible. It exposes a /monitor endpoint that can trigger a configuration
    change event in Config Service, which then would send it over the Bus to all the
    listening applications. It also accepts arguments describing which files have
    been changed and supports receiving push notifications from the most common code
    repository providers like GitHub, GitLab, and Bitbucket. You can set up a webhook
    in those services to automatically send a POST request to Config Service after
    each new push to the config repo.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 任何配置更改都包括向配置仓库推送一个提交。当仓库中推送新的提交时，设置一些自动化来使配置服务刷新配置将非常方便，这样可以完全消除手动干预的需要。Spring
    Cloud Config提供了一个Monitor库，使其成为可能。它公开了一个/monitor端点，可以触发配置服务中的配置更改事件，然后将其通过总线发送到所有监听的应用程序。它还接受描述哪些文件已更改的参数，并支持从最常用的代码仓库提供商（如GitHub、GitLab和Bitbucket）接收推送通知。您可以在这些服务中设置webhook，在每次向配置仓库推送新内容后自动向配置服务发送POST请求。
- en: Spring Cloud Bus solves the problem of broadcasting a configuration change event
    to all connected applications. With Spring Cloud Config Monitor, we can further
    automate the refresh and make it happen after a configuration change is pushed
    to the repository backing the config server. This solution is illustrated in figure
    14.1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus解决了向所有连接的应用程序广播配置更改事件的问题。通过Spring Cloud Config Monitor，我们可以进一步自动化刷新，并在将配置更改推送到配置服务器背后的仓库后执行。这种解决方案在图14.1中得到了说明。
- en: '![14-01](../Images/14-01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![14-01](../Images/14-01.png)'
- en: Figure 14.1 Broadcasting configuration changes through Spring Cloud Bus after
    the Config Service receives push notifications on every config repo change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 在配置服务接收到每个配置仓库变更的推送通知后，通过Spring Cloud Bus广播配置更改。
- en: Note You can rely on Spring Cloud Bus to broadcast configuration changes even
    when you use other options like Consul (with Spring Cloud Consul), Azure Key Vault
    (Spring Cloud Azure), AWS Parameter Store or AWS Secrets Manager (Spring Cloud
    AWS), or Google Cloud Secret Manager (Spring Cloud GCP). Unlike Spring Cloud Config,
    they don’t have built-in push notification capabilities, so you need to trigger
    a configuration change or implement your monitor functionality manually.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：即使您使用其他选项，如Consul（与Spring Cloud Consul）、Azure Key Vault（Spring Cloud Azure）、AWS
    Parameter Store或AWS Secrets Manager（Spring Cloud AWS），或Google Cloud Secret Manager（Spring
    Cloud GCP），您也可以依赖Spring Cloud Bus来广播配置更改。与Spring Cloud Config不同，它们没有内置的推送通知功能，因此您需要手动触发配置更改或实现监控功能。
- en: 14.1.3 Managing secrets with Spring Cloud Config
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 使用Spring Cloud Config管理密钥
- en: Managing secrets is a critical task for any software system, and it’s dangerous
    when mistakes are made. So far, we have included passwords either in property
    files or environment variables, but they were unencrypted in both cases. One of
    the consequences of not encrypting them is that we can’t version-control them
    safely. We would like to keep everything under version control and use Git repositories
    as the single sources of truth, which is one of the principles behind the GitOps
    strategy I’ll cover in chapter 15.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何软件系统来说，管理密钥是一项关键任务，如果出错则非常危险。到目前为止，我们已经在属性文件或环境变量中包含了密码，但在两种情况下它们都是未加密的。未加密的一个后果是我们无法安全地对其进行版本控制。我们希望将所有内容都置于版本控制之下，并使用Git仓库作为单一的真实来源，这是我在第15章中将要介绍的GitOps策略背后的原则之一。
- en: The Spring Cloud Config project is well-equipped with features to handle configuration
    for cloud native applications, including secrets management. The main goal is
    to include secrets in the property files and put them under version control, which
    can only be done if they are encrypted.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config项目配备了处理云原生应用程序配置（包括密钥管理）的功能。主要目标是包括密钥在属性文件中，并将它们置于版本控制之下，这只有在它们被加密的情况下才能完成。
- en: 'Spring Cloud Config Server supports encryption and decryption and exposes two
    dedicated endpoints: /encrypt and /decrypt. Encryption can be based on a symmetric
    key or asymmetric key pair.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config服务器支持加密和解密，并公开了两个专用端点：/encrypt和/decrypt。加密可以基于对称密钥或非对称密钥对。
- en: When using a symmetric key, Spring Cloud Config Server decrypts secrets locally
    and sends them decrypted to the client applications. In production, all communications
    between applications will happen over HTTPS, so the response sent from Config
    Service will be encrypted even if the configuration property is not, making this
    approach secure enough for real-world usage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用对称密钥时，Spring Cloud Config 服务器会在本地解密密钥并将其解密后发送给客户端应用程序。在生产环境中，所有应用程序之间的通信都将通过
    HTTPS 进行，因此即使配置属性未加密，从配置服务发送的响应也将被加密，这使得这种方法对于实际使用足够安全。
- en: You also have the option to send property values encrypted and let the applications
    themselves decrypt them, but that will require you to configure the symmetric
    key for all applications. You should also consider that decryption is not a cheap
    operation to perform.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择发送加密的属性值，并让应用程序自行解密它们，但这将需要您为所有应用程序配置对称密钥。您还应考虑解密操作并不便宜。
- en: Spring Cloud Config also supports encryption and decryption through asymmetric
    keys. This option provides more robust security than the symmetric alternative
    but it also increases complexity and maintenance costs due to key management tasks.
    In that case, you might want to consider relying on a dedicated secrets management
    solution. For example, you can use one of those offered by cloud providers and
    rely on the Spring Boot integration implemented by Spring Cloud, such as Azure
    Key Vault (Spring Cloud Azure), AWS Parameter Store or AWS Secrets Manager (Spring
    Cloud AWS), or Google Cloud Secret Manager (Spring Cloud GCP).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config 还支持通过非对称密钥进行加密和解密。此选项比对称密钥提供更强大的安全性，但也会由于密钥管理任务而增加复杂性和维护成本。在这种情况下，您可能希望考虑依赖专门的密钥管理解决方案。例如，您可以使用云提供商提供的一种解决方案，并依赖
    Spring Cloud 实现的 Spring Boot 集成，如 Azure Key Vault（Spring Cloud Azure）、AWS Parameter
    Store 或 AWS Secrets Manager（Spring Cloud AWS），或 Google Cloud Secret Manager（Spring
    Cloud GCP）。
- en: Should you prefer an open source solution, HashiCorp Vault ([www.vaultproject.io](http://www.vaultproject.io))
    might be a good fit for you. It’s a tool you can use to manage all your credentials,
    tokens, and certificates, both from a CLI and from a convenient GUI. You can integrate
    it directly with your Spring Boot applications using the Spring Vault project
    or add it as an additional backend for Spring Cloud Config Server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢开源解决方案，HashiCorp Vault ([www.vaultproject.io](http://www.vaultproject.io))
    可能适合您。这是一个您可以使用它来管理所有凭证、令牌和证书的工具，无论是通过 CLI 还是方便的 GUI。您可以直接使用 Spring Vault 项目将其集成到
    Spring Boot 应用程序中，或者将其添加为 Spring Cloud Config 服务器的一个额外后端。
- en: For more information about secrets management in Spring, check out the official
    documentation for Spring Vault ([https://spring.io/projects/spring-vault](https://spring.io/projects/spring-vault))
    and Spring Cloud Config ([https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Spring 中密钥管理的更多信息，请参阅 Spring Vault 的官方文档（[https://spring.io/projects/spring-vault](https://spring.io/projects/spring-vault)）和
    Spring Cloud Config 的官方文档（[https://spring.io/projects/spring-cloud-config](https://spring.io/projects/spring-cloud-config)）。
- en: 14.1.4 Disabling Spring Cloud Config
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 禁用 Spring Cloud Config
- en: The next section will introduce a different way of configuring Spring Boot applications
    based on the native functionality provided by Kubernetes through ConfigMaps and
    Secrets. That’s what we’re going to use in production.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍一种不同的配置 Spring Boot 应用程序的方法，该方法基于 Kubernetes 通过 ConfigMaps 和 Secrets
    提供的本地功能。这就是我们在生产中将要使用的方法。
- en: Even if we’re not going to use Config Service anymore in the rest of the book,
    we’ll keep all the work we have done with it so far. However, to make things easier,
    we’ll turn the Spring Cloud Config Client integration off by default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在本书的其余部分不再使用配置服务，我们也会保留到目前为止所做的所有工作。然而，为了简化操作，我们将默认关闭 Spring Cloud Config
    客户端集成。
- en: Open your Catalog Service project (catalog-service), and update the application.yml
    file to stop importing configuration data from Config Service and disable the
    Spring Cloud Config Client integration. Everything else will stay the same. Whenever
    you want to use Spring Cloud Config again, you can enable it with ease (for example,
    when running the applications on Docker).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的目录服务项目（catalog-service），并更新 application.yml 文件以停止从配置服务导入配置数据并禁用 Spring Cloud
    Config 客户端集成。其他所有内容都将保持不变。无论何时您想再次使用 Spring Cloud Config，都可以轻松启用它（例如，在 Docker
    上运行应用程序时）。
- en: Listing 14.1 Disabling Spring Cloud Config in Catalog Service
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.1 在目录服务中禁用 Spring Cloud Config
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Stops importing configuration data from Config Service
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 停止从配置服务导入配置数据
- en: ❷ Disables the Spring Cloud Config Client integration
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 禁用 Spring Cloud Config Client 集成
- en: In the next section, you’ll use ConfigMaps and Secrets to configure Spring Boot
    applications instead of the Config Service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将使用 ConfigMaps 和 Secrets 来配置 Spring Boot 应用程序，而不是使用 Config Service。
- en: 14.2 Using ConfigMaps and Secrets in Kubernetes
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 在 Kubernetes 中使用 ConfigMaps 和 Secrets
- en: 'The 15-Factor methodology recommends keeping code, configuration, and credentials
    always separate. Kubernetes fully embraces that principle and defines two APIs
    to handle configuration and credentials independently: ConfigMaps and Secrets.
    This section will introduce this new configuration strategy, which is provided
    natively by Kubernetes.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 15-Factor 方法建议始终将代码、配置和凭证保持分离。Kubernetes 完全接受这一原则，并定义了两个 API 来独立处理配置和凭证：ConfigMaps
    和 Secrets。本节将介绍这种新的配置策略，这是 Kubernetes 本地提供的。
- en: Spring Boot provides native and flexible support for both ConfigMaps and Secrets.
    I’ll show you how to work with ConfigMaps and their relationships with environment
    variables, which are still a valid configuration option in Kubernetes. You’ll
    see that Secrets are not really secret, and you’ll learn what to do to make them
    really so. Finally, I’ll go through a few options for dealing with configuration
    changes and propagating them to applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 为 ConfigMaps 和 Secrets 提供了原生和灵活的支持。我将向您展示如何使用 ConfigMaps 以及它们与环境变量的关系，这些仍然是
    Kubernetes 中的一个有效配置选项。您将看到 Secrets 并非真正保密，您将学习如何使它们真正保密。最后，我将介绍一些处理配置更改并将其传播到应用程序的选项。
- en: 'Before moving on further, let’s set the scene and start a local Kubernetes
    cluster. Go to your Polar Deployment project (polar-deployment), navigate to the
    kubernetes/ platform/development folder, and run the following command to start
    a minikube cluster and deploy the backing services used by Polar Bookshop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们设定场景并启动一个本地 Kubernetes 集群。转到您的 Polar Deployment 项目（polar-deployment），导航到
    kubernetes/platform/development 文件夹，并运行以下命令以启动 minikube 集群并部署 Polar 书店使用的后端服务：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note If you haven’t followed along with the examples implemented in the previous
    chapters, you can refer to the repository accompanying the book ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))
    and use the projects in Chapter14/14-begin as a starting point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您没有跟随前几章中实现的示例，您可以参考书籍附带的存储库 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))，并以第
    14/14-begin 中的项目作为起点。
- en: 'The command will take a few minutes to complete. When it’s finished, you can
    verify that all the backing services are ready and available with the following
    command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将需要几分钟才能完成。完成后，您可以使用以下命令验证所有后端服务都已准备好并可用：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s start by introducing ConfigMaps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍 ConfigMaps。
- en: 14.2.1 Configuring Spring Boot with ConfigMaps
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 使用 ConfigMaps 配置 Spring Boot
- en: In chapter 7, we used environment variables to pass hardcoded configuration
    to containers running in Kubernetes, but they lack maintainability and structure.
    ConfigMaps let you store configuration data in a structured, maintainable way.
    They can be version-controlled together with the rest of your Kubernetes deployment
    manifests and have the same nice properties of a dedicated configuration repository,
    including data persistence, auditing, and accountability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 章，我们使用环境变量将硬编码的配置传递给在 Kubernetes 中运行的容器，但它们缺乏可维护性和结构。ConfigMaps 允许您以结构化、可维护的方式存储配置数据。它们可以与
    Kubernetes 部署清单的其他部分一起进行版本控制，并具有专用配置存储库的相同良好属性，包括数据持久性、审计和问责制。
- en: A *ConfigMap* is “an API object used to store non-confidential data in key-value
    pairs. Pods can consume ConfigMaps as environment variables, command-line arguments,
    or as configuration files in a volume” ([https://kubernetes.io/docs/concepts/configuration/configmap](https://kubernetes.io/docs/concepts/configuration/configmap)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*ConfigMap* 是一个“用于在键值对中存储非机密数据的 API 对象。Pod 可以将 ConfigMap 作为环境变量、命令行参数或作为卷中的配置文件来消费”
    ([https://kubernetes.io/docs/concepts/configuration/configmap](https://kubernetes.io/docs/concepts/configuration/configmap))。'
- en: You can build a ConfigMap starting with a literal key/value pair string, with
    a file (for example, .properties or .yml), or even with a binary object. When
    working with Spring Boot applications, the most straightforward way to build a
    ConfigMap is to start with a property file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从一个字面值键值对字符串、一个文件（例如，.properties 或 .yml）或甚至一个二进制对象开始构建 ConfigMap。当与 Spring
    Boot 应用程序一起工作时，构建 ConfigMap 最直接的方法是从属性文件开始。
- en: Let’s look at an example. In the previous chapters, we configured Catalog Service
    via environment variables. For better maintainability and structure, let’s store
    some of those values in a ConfigMap.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。在前几章中，我们通过环境变量配置了目录服务。为了更好的可维护性和结构，让我们将这些值存储在 ConfigMap 中。
- en: 'Open the Catalog Service project (catalog-service), and create a new configmap.yml
    file in the k8s folder. We’ll use it to apply the following configuration, which
    will overwrite the default values included in the application.yml file packaged
    with the application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开目录服务项目（catalog-service），在 k8s 文件夹中创建一个新的 configmap.yml 文件。我们将使用它应用以下配置，这将覆盖应用程序.yml
    文件中包含的默认值：
- en: Configure a custom greeting.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自定义问候语。
- en: Configure the URL for the PostgreSQL data source.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 PostgreSQL 数据源的 URL。
- en: Configure the URL for Keycloak.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Keycloak 的 URL。
- en: Listing 14.2 Defining a ConfigMap to configure Catalog Service
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.2 定义 ConfigMap 以配置目录服务
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The API version for ConfigMap objects
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ConfigMap 对象的 API 版本
- en: ❷ The type of object to create
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 要创建的对象类型
- en: ❸ The name of the ConfigMap
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ConfigMap 的名称
- en: ❹ A set of labels attached to the ConfigMap
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 附属于 ConfigMap 的一组标签
- en: ❺ Section containing the configuration data
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 包含配置数据的部分
- en: ❻ A key/value pair where the key is the name of a YAML configuration file and
    the value is its content
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 一个键/值对，其中键是 YAML 配置文件的名称，值是它的内容
- en: 'Like the other Kubernetes objects we have worked with so far, manifests for
    ConfigMaps can be applied to a cluster using the Kubernetes CLI. Open a Terminal
    window, navigate to your Catalog Service project (catalog-service), and run the
    following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止使用的其他 Kubernetes 对象类似，ConfigMap 的配置清单可以通过 Kubernetes CLI 应用到集群中。打开一个终端窗口，导航到您的目录服务项目（catalog-service），并运行以下命令：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can verify that the ConfigMap has been created correctly with this command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令验证 ConfigMap 是否已正确创建：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The values stored in a ConfigMap can be used to configure containers running
    in a few different ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 ConfigMap 中的值可以通过几种不同的方式用于配置运行在容器中的容器：
- en: Use a ConfigMap as a configuration data source to pass command-line arguments
    to the container.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMap 作为配置数据源，将命令行参数传递给容器。
- en: Use a ConfigMap as a configuration data source to populate environment variables
    for the container.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMap 作为配置数据源，为容器填充环境变量。
- en: Mount a ConfigMap as a volume in the container.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中挂载 ConfigMap 作为卷。
- en: As you learned in chapter 4 and practiced since then, Spring Boot supports externalized
    configuration in many ways, including via command-line arguments and environment
    variables. Passing configuration data as command-line arguments or environment
    variables to containers has its drawbacks, even if it is stored in a ConfigMap.
    For example, whenever you add a property to a ConfigMap, you must update the Deployment
    manifest. When a ConfigMap is changed, the Pod is not informed about it and must
    be re-created to read the new configuration. Both those issues are solved by mounting
    ConfigMaps as volumes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在第四章中学到的，并从那时起实践的那样，Spring Boot 支持多种外部化配置方式，包括通过命令行参数和环境变量。即使配置数据存储在 ConfigMap
    中，将配置数据作为命令行参数或环境变量传递给容器也有其缺点。例如，每次您向 ConfigMap 添加属性时，都必须更新 Deployment 清单。当 ConfigMap
    发生变化时，Pod 并未收到通知，必须重新创建以读取新的配置。这两个问题都通过将 ConfigMap 挂载为卷来解决。
- en: 'When a ConfigMap is mounted as a volume to a container, it generates two possible
    outcomes (figure 14.2):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ConfigMap 作为卷挂载到容器时，会产生两种可能的结果（图 14.2）：
- en: If the ConfigMap includes an *embedded property file*, mounting it as a volume
    results in the property file being created in the mounted path. Spring Boot automatically
    finds and includes any property files located in a /config folder either in the
    same root as the application executable or in a subdirectory, so it’s the perfect
    path for mounting a ConfigMap. You can also specify additional locations to search
    for property files via the spring.config.additional-location=<path> configuration
    property.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ConfigMap 包含一个 *内嵌属性文件*，将其作为卷挂载会导致属性文件在挂载路径中创建。Spring Boot 自动查找并包含位于与应用程序可执行文件相同的根目录或子目录中的
    /config 文件夹中的任何属性文件，因此这是挂载 ConfigMap 的完美路径。您还可以通过 spring.config.additional-location=<path>
    配置属性指定其他要搜索属性文件的位置。
- en: If the ConfigMap includes *key/value pairs*, mounting it as a volume results
    in a *config tree* being created in the mounted path. For each key/value pair,
    a file is created, named like the key and containing the value. Spring Boot supports
    reading configuration properties from a config tree. You can specify where the
    config tree should be loaded from via the spring.config.import=configtree:<path>
    property.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ConfigMap 包含 *键/值对*，将其挂载为卷会在挂载路径中创建一个 *配置树*。对于每个键/值对，会创建一个文件，文件名与键相同，并包含相应的值。Spring
    Boot 支持从配置树中读取配置属性。您可以通过指定 spring.config.import=configtree:<path> 属性来指定配置树应该从哪里加载。
- en: '![14-02](../Images/14-02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![14-02](../Images/14-02.png)'
- en: Figure 14.2 ConfigMaps mounted as volumes can be consumed by Spring Boot as
    property files or as config trees.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 将 ConfigMap 挂载为卷后，可以被 Spring Boot 作为属性文件或配置树使用。
- en: When configuring Spring Boot applications, the first option is the most convenient,
    since it uses the same property file format used for the default configuration
    inside the application. Let’s see how we can mount the ConfigMap created earlier
    into the Catalog Service container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置 Spring Boot 应用程序时，第一个选项是最方便的，因为它使用与应用程序内部默认配置相同的属性文件格式。让我们看看我们如何将之前创建的 ConfigMap
    挂载到 Catalog 服务容器中。
- en: 'Open the Catalog Service project (catalog-service), and go to the deployment.yml
    file in the k8s folder. We need to apply three changes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Catalog 服务项目（catalog-service），并转到 k8s 文件夹中的 deployment.yml 文件。我们需要进行三项更改：
- en: Remove the environment variables for the values we declared in the ConfigMap.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除我们在 ConfigMap 中声明的值的环境变量。
- en: Declare a volume generated from the catalog-config ConfigMap.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明由 catalog-config ConfigMap 生成的卷。
- en: Specify a volume mount for the catalog-service container to load the ConfigMap
    as an application.yml file from /workspace/config. The /workspace folder is created
    and used by Cloud Native Buildpacks to host the application executables, so Spring
    Boot will automatically look for a /config folder in the same path and load any
    property files contained within. There’s no need to configure additional locations.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 catalog-service 容器指定一个卷挂载，以便从 /workspace/config 加载 ConfigMap 作为 application.yml
    文件。/workspace 文件夹是由 Cloud Native Buildpacks 创建并用于托管应用程序可执行文件的，因此 Spring Boot 将自动在相同路径下查找
    /config 文件夹并加载其中包含的任何属性文件。无需配置其他位置。
- en: Listing 14.3 Mounting a ConfigMap as a volume to the application container
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.3 将 ConfigMap 作为卷挂载到应用程序容器
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ JVM threads and Spring profile are still configured via environment variables.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JVM 线程和 Spring 配置文件仍然通过环境变量进行配置。
- en: ❷ Mounts the ConfigMap in the container as a volume
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在容器中将 ConfigMap 挂载为卷
- en: ❸ Spring Boot will automatically find and include property files from this folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Spring Boot 将自动查找并包含此文件夹中的属性文件。
- en: ❹ Defines volumes for the Pod
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义 Pod 的卷
- en: ❺ The name of the volume
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 卷的名称
- en: ❻ The ConfigMap from which to create a volume
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 用于创建卷的 ConfigMap
- en: We previously applied the ConfigMap to the cluster. Let’s do the same for the
    Deployment and Service manifests so that we can verify whether Catalog Service
    is correctly reading configuration data from the ConfigMap.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已将 ConfigMap 应用到集群中。让我们对 Deployment 和 Service 清单做同样的操作，以便我们可以验证 Catalog
    服务是否正确地从 ConfigMap 中读取配置数据。
- en: 'First, we must package the application as a container image and load it into
    the cluster. Open a Terminal window, navigate to the root folder of your Catalog
    Service project (catalog-service), and run the following commands:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将应用程序打包成容器镜像并将其加载到集群中。打开一个终端窗口，导航到 Catalog 服务项目（catalog-service）的根文件夹，并运行以下命令：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we’re ready to deploy the application in the local cluster by applying
    the Deployment and Service manifests:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过应用 Deployment 和 Service 清单在本地集群中部署应用程序：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can verify when Catalog Service is available and ready to accept requests
    with this command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此命令验证 Catalog 服务是否可用并准备好接受请求：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Internally, Kubernetes uses the liveness and readiness probes we configured
    in the previous chapter to infer the application’s health.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Kubernetes 使用我们在上一章配置的存活性和就绪性探针来推断应用程序的健康状态。
- en: 'Next, forward traffic from your local machine to the Kubernetes cluster by
    running the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过运行以下命令将您本地机器的流量转发到 Kubernetes 集群：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note The process started by the kubectl port-forward command will keep running
    until you explicitly stop it with Ctrl-C.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：由 kubectl port-forward 命令启动的过程将一直运行，直到您使用 Ctrl-C 明确停止它。
- en: 'Now you can call Catalog Service from your local machine on port 9001, and
    the request will be forwarded to the Service object inside the Kubernetes cluster.
    Open a new Terminal window, and call the root endpoint exposed by the application
    to verify that the polar.greeting value specified in the ConfigMap is used instead
    of the default one:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从你的本地机器上通过端口9001调用目录服务，请求将被转发到Kubernetes集群内部的Service对象。打开一个新的终端窗口，调用应用程序公开的根端点以验证在ConfigMap中指定的polar.greeting值是否被使用而不是默认值：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Try also retrieving the books from the catalog to verify that the PostgreSQL
    URL specified in the ConfigMap is used correctly:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以尝试从目录中检索书籍以验证在ConfigMap中指定的PostgreSQL URL是否正确使用：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you’re done testing the application, stop the port-forward process (Ctrl-C)
    and delete the Kubernetes objects created so far. Open a Terminal window, navigate
    to your Catalog Service project (catalog-service), and run the following command,
    but keep the cluster running, since we’re going to use it again soon:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用程序的测试后，停止端口转发进程（Ctrl-C）并删除迄今为止创建的Kubernetes对象。打开一个终端窗口，导航到你的目录服务项目（catalog-service），并运行以下命令，但保持集群运行，因为我们很快还会使用它：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ConfigMaps are convenient for providing configuration data to applications running
    on Kubernetes. But what if we had to pass sensitive data? In the next section,
    you’ll see how to use Secrets in Kubernetes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps对于向在Kubernetes上运行的应用程序提供配置数据来说很方便。但如果我们不得不传递敏感数据怎么办？在下一节中，你将看到如何在Kubernetes中使用Secrets。
- en: 14.2.2 Storing sensitive information with Secrets (or not)
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 使用Secrets（或不是）存储敏感信息
- en: The most critical part of configuring applications is managing secret information
    like passwords, certificates, tokens, and keys. Kubernetes provides a Secret object
    to hold such data and pass it to containers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序最关键的部分是管理像密码、证书、令牌和密钥这样的机密信息。Kubernetes提供了一个Secret对象来存储此类数据并将其传递给容器。
- en: A *Secret* is an API object used to store and manage sensitive information,
    such as passwords, OAuth tokens, and ssh keys. Pods can consume Secrets as environment
    variables or configuration files in a volume ([https://kubernetes.io/docs/concepts/configuration/secret](https://kubernetes.io/docs/concepts/configuration/secret)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Secret* 是一个API对象，用于存储和管理敏感信息，例如密码、OAuth令牌和ssh密钥。Pod可以作为环境变量或卷中的配置文件来消费Secrets
    ([https://kubernetes.io/docs/concepts/configuration/secret](https://kubernetes.io/docs/concepts/configuration/secret))。'
- en: 'What makes this object *secret* is the process used to manage it. By themselves,
    Secrets are just like ConfigMaps. The only difference is that data in a Secret
    is usually Base64-encoded, a technical choice made to support binary files. Any
    Base64-encoded object can be decoded in a very straightforward way. It’s a common
    mistake to think that Base64 is a kind of encryption. If you remember only one
    thing about Secrets, make it the following: *Secrets are not secret!*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个对象成为“机密”的是管理它的过程。单独来看，Secrets就像ConfigMaps一样。唯一的区别是Secret中的数据通常是Base64编码的，这是一个为了支持二进制文件所做的技术选择。一个常见的错误是认为Base64是一种加密。如果你只记得关于Secrets的一件事，让它成为以下内容：*Secrets并不是秘密！*
- en: The configuration we have been using to run Polar Bookshop on a local Kubernetes
    cluster relies on the same default credentials used in development, so we won’t
    need Secrets yet. We’ll start using them in the next chapter when deploying applications
    in production. For now, I want to show you how to create Secrets. Then I’ll go
    through some options you have for ensuring that they are adequately protected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的配置，用于在本地Kubernetes集群上运行极地书店，依赖于开发中使用的相同默认凭据，所以我们暂时不需要Secrets。我们将在下一章中开始使用它们，当我们在生产中部署应用程序时。现在，我想向你展示如何创建Secrets。然后我会介绍一些你可以确保它们得到充分保护的选项。
- en: One way of creating a Secret is using the Kubernetes CLI with an imperative
    approach. Open a Terminal window and generate a test-credentials Secret object
    for some fictitious test credentials (user/password).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Secret的一种方式是使用Kubernetes CLI以命令式方法。打开一个终端窗口，为一些虚构的测试凭据（用户/密码）生成一个test-credentials
    Secret对象。
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a generic secret with Base64-encoded values
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个带有Base64编码值的通用Secret
- en: ❷ The name of the Secret
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Secret的名称
- en: ❸ Adds a secret value for the test username
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为测试用户名添加一个机密值
- en: ❹ Adds a secret value for the test password
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 为测试密码添加一个机密值
- en: 'We can verify that the Secret has been created successfully with the following
    command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令验证Secret是否已成功创建：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also retrieve the internal representation of the Secret in the familiar
    YAML format with the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令检索 Secret 的内部表示，以熟悉的 YAML 格式：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The API version for Secret objects
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Secret 对象的 API 版本
- en: ❷ The type of object to create
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 需要创建的对象类型
- en: ❸ The name of the Secret
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Secret 的名称
- en: ❹ Section containing the secret data with Base64-encoded values
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含 Base64 编码值的秘密数据部分
- en: Note that I rearranged the preceding YAML to increase its readability and omitted
    additional fields that are not relevant to our discussion.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经重新排列了前面的 YAML 以提高其可读性，并省略了与我们的讨论无关的额外字段。
- en: 'I want to repeat this: Secrets are not secret! I can decode the value stored
    in the test-credentials Secret with a simple command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我想重复一遍：Secrets 并非秘密！我可以使用简单的命令解码存储在 test-credentials Secret 中的值：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Like ConfigMaps, Secrets can be passed to a container as environment variables
    or through a volume mount. In the second case, you can mount them as property
    files or config trees. For example, the test-credentials Secret would be mounted
    as a config tree because it’s composed of key/value pairs rather than a file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ConfigMaps 类似，Secrets 可以作为环境变量传递给容器，或者通过卷挂载。在后一种情况下，您可以将它们挂载为属性文件或配置树。例如，test-credentials
    Secret 将作为配置树挂载，因为它由键/值对组成，而不是一个文件。
- en: Since Secrets are not encrypted, we can’t include them in a version control
    system. It’s up to the platform engineers to ensure that Secrets are adequately
    protected. For example, Kubernetes could be configured to store Secrets in its
    internal *etcd* storage encrypted. That would help ensure security at rest, but
    it doesn’t solve the problem of managing them in a version control system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Secrets 没有加密，我们无法将其包含在版本控制系统之中。确保 Secrets 获得充分保护的责任在于平台工程师。例如，Kubernetes
    可以配置为以加密的形式将其 Secrets 存储在其内部的 *etcd* 存储中。这将有助于确保静态安全，但它并不能解决在版本控制系统中管理它们的问题。
- en: Bitnami introduced a project called *Sealed Secrets* ([https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets)),
    aimed at encrypting Secrets and putting them under version control. First you
    would generate an encrypted SealedSecret object, starting from literal values,
    similar to what we did for the plain Secret. Then you would include that in your
    repository and safely put it under version control. When the SealedSecret manifest
    is applied to a Kubernetes cluster, the Sealed Secrets controller decrypts its
    content and generates a standard Secret object that can be used within a Pod.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami 推出了一个名为 *Sealed Secrets* 的项目 ([https://github.com/bitnami-labs/sealed-secrets](https://github.com/bitnami-labs/sealed-secrets))，旨在加密
    Secrets 并将其置于版本控制之下。首先，您将生成一个加密的 SealedSecret 对象，从字面值开始，类似于我们为普通 Secret 所做的操作。然后，您将将其包含在您的仓库中，并安全地将其置于版本控制之下。当
    SealedSecret 清单应用于 Kubernetes 集群时，Sealed Secrets 控制器会解密其内容，并生成一个标准 Secret 对象，该对象可以在
    Pod 内部使用。
- en: What if your secrets are stored in a dedicated backend like HashiCorp Vault
    or Azure Key Vault? In that case, you can use a project like *External Secrets*
    ([https://github.com/external-secrets/kubernetes-external-secrets](https://github.com/external-secrets/kubernetes-external-secrets)).
    As you can guess from its name, this project lets you generate a Secret from an
    external source. The ExternalSecret object would be safe to store in your repository
    and put under version control. When the ExternalSecret manifest is applied to
    a Kubernetes cluster, the External Secrets controller fetches the value from the
    configured external source and generates a standard Secret object that can be
    used within a Pod.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Secrets 存储在专门的后端，如 HashiCorp Vault 或 Azure Key Vault，怎么办？在这种情况下，您可以使用像
    *External Secrets* ([https://github.com/external-secrets/kubernetes-external-secrets](https://github.com/external-secrets/kubernetes-external-secrets))
    这样的项目。正如其名称所暗示的，该项目允许您从外部源生成一个 Secret。ExternalSecret 对象可以安全地存储在您的仓库中，并置于版本控制之下。当
    ExternalSecret 清单应用于 Kubernetes 集群时，External Secrets 控制器会从配置的外部源获取值，并生成一个标准 Secret
    对象，该对象可以在 Pod 内部使用。
- en: Note If you’re interested in learning more about how to secure Kubernetes Secrets,
    you can check out chapter 7 of *GitOps and Kubernetes* by Billy Yuen, Alexander
    Matyushentsev, Todd Ekenstam, and Jesse Suen (Manning, 2021) and *Kubernetes Secrets
    Management* by Alex Soto Bueno and Andrew Block (Manning, 2022). I won’t provide
    more information here, since this is usually a task for the platform team, not
    developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你对如何安全地管理 Kubernetes Secrets 感兴趣，可以查看 Billy Yuen、Alexander Matyushentsev、Todd
    Ekenstam 和 Jesse Suen 所著的 *GitOps 和 Kubernetes* 的第 7 章（Manning，2021）以及 Alex Soto
    Bueno 和 Andrew Block 所著的 *Kubernetes Secrets Management*（Manning，2022）。在此处我不会提供更多信息，因为这通常是一项平台团队的任务，而不是开发者的任务。
- en: When we start using ConfigMaps and Secrets, we must decide which policy to use
    to update configuration data and how to make applications use the new values.
    That’s the topic of the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 ConfigMaps 和 Secrets 时，我们必须决定使用哪种策略来更新配置数据以及如何使应用程序使用新值。这是下一节的主题。
- en: 14.2.3 Refreshing configuration at runtime with Spring Cloud Kubernetes
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 在运行时使用 Spring Cloud Kubernetes 刷新配置
- en: When using an external configuration service, you’ll probably want a mechanism
    to reload the applications when configuration changes. For example, when using
    Spring Cloud Config, we can implement such a mechanism with Spring Cloud Bus.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用外部配置服务时，你可能需要一个机制在配置更改时重新加载应用程序。例如，当使用 Spring Cloud Config 时，我们可以使用 Spring
    Cloud Bus 实现这样的机制。
- en: In Kubernetes, we need a different approach. When you update a ConfigMap or
    a Secret, Kubernetes takes care of providing containers with the new versions
    when they’re mounted as volumes. If you use environment variables, they will not
    be replaced with the new values. That’s why we usually prefer the volume solution.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，我们需要不同的方法。当你更新 ConfigMap 或 Secrets 时，Kubernetes 会负责在它们作为卷挂载时为容器提供新版本。如果你使用环境变量，它们不会被新值替换。这就是我们通常更喜欢卷解决方案的原因。
- en: 'The updated ConfigMaps or Secrets are provided to the Pod when they’re mounted
    as volumes, but it’s up to the specific application to refresh the configuration.
    By default, Spring Boot applications read configuration data only at startup time.
    There are three main options for refreshing configuration when it’s provided through
    ConfigMaps and Secrets:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ConfigMaps 或 Secrets 作为卷挂载时，它们被提供给 Pod，但具体应用程序负责刷新配置。默认情况下，Spring Boot 应用程序仅在启动时读取配置数据。当配置通过
    ConfigMaps 和 Secrets 提供时，有三种主要选项用于刷新配置：
- en: '*Rolling restart*—Changing a ConfigMap or a Secret can be followed by a rolling
    restart of all the Pods affected, making the applications reload all the configuration
    data. With this option, Kubernetes Pods would remain immutable.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*滚动重启*—更改 ConfigMap 或 Secrets 后，可以跟随所有受影响的 Pods 的滚动重启，使应用程序重新加载所有配置数据。使用此选项，Kubernetes
    Pods 将保持不可变。'
- en: '*Spring Cloud Kubernetes Configuration Watcher*—Spring Cloud Kubernetes provides
    a Kubernetes controller called Configuration Watcher that monitors ConfigMaps
    and Secrets mounted as volumes to Spring Boot applications. Leveraging the Spring
    Boot Actuator’s /actuator/refresh endpoint or Spring Cloud Bus, when any of the
    ConfigMaps or Secrets is updated, the Configuration Watcher will trigger a configuration
    refresh for the affected applications.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Cloud Kubernetes 配置监视器*—Spring Cloud Kubernetes 提供了一个名为配置监视器的 Kubernetes
    控制器，该控制器监视作为卷挂载到 Spring Boot 应用程序的 ConfigMaps 和 Secrets。利用 Spring Boot Actuator
    的 /actuator/refresh 端点或 Spring Cloud Bus，当任何 ConfigMaps 或 Secrets 被更新时，配置监视器将触发受影响应用程序的配置刷新。'
- en: '*Spring Cloud Kubernetes Config Server*—Spring Cloud Kubernetes provides a
    configuration server with support for using ConfigMaps and Secrets as one of the
    configuration data source options for Spring Cloud Config. You could use such
    a server to load configuration from both a Git repository and Kubernetes objects,
    with the possibility of using the same configuration refresh mechanism for both.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Cloud Kubernetes 配置服务器*—Spring Cloud Kubernetes 提供了一个配置服务器，支持将 ConfigMaps
    和 Secrets 作为 Spring Cloud Config 的配置数据源选项之一。你可以使用这样的服务器从 Git 仓库和 Kubernetes 对象中加载配置，并且可以使用相同的配置刷新机制来处理两者。'
- en: For Polar Bookshop, we’ll use the first option and rely on Kustomize to trigger
    a restart of the applications whenever a new change is applied to a ConfigMap
    or a Secret. I’ll describe that strategy further in the next section of the chapter.
    Here we’ll focus on the features offered by Spring Cloud Kubernetes and its subprojects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Polar Bookshop，我们将使用第一种选项，并依赖 Kustomize 在对 ConfigMap 或 Secret 应用新更改时触发应用的重启。我将在本章的下一节中进一步描述该策略。在这里，我们将关注
    Spring Cloud Kubernetes 和其子项目提供的功能。
- en: Spring Cloud Kubernetes ([https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes))
    is an exciting project that provides Spring Boot integration with the Kubernetes
    API. Its original goal was to make it easier to transition from a microservices
    architecture based on Spring Cloud to Kubernetes. It provides an implementation
    for standard Spring Cloud interfaces used for service discovery and load balancing
    to integrate with Kubernetes, and it adds support for loading configuration from
    ConfigMaps and Secrets.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Kubernetes ([https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes))
    是一个令人兴奋的项目，它提供了 Spring Boot 与 Kubernetes API 的集成。它的原始目标是使从基于 Spring Cloud 的微服务架构迁移到
    Kubernetes 更加容易。它为用于服务发现和负载均衡的标准 Spring Cloud 接口提供了实现，以便与 Kubernetes 集成，并增加了从
    ConfigMaps 和 Secrets 加载配置的支持。
- en: If you work on a greenfield project, you don’t need Spring Cloud Kubernetes.
    Kubernetes provides service discovery and load balancing natively, as you experienced
    in chapter 7\. Furthermore, Spring Boot supports configuration via ConfigMaps
    and Secrets natively, so there’s no need for Spring Cloud Kubernetes, even in
    this case.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个绿色地带项目中工作，你不需要 Spring Cloud Kubernetes。Kubernetes 本地提供服务发现和负载均衡，正如你在第
    7 章中所体验的那样。此外，Spring Boot 本地支持通过 ConfigMaps 和 Secrets 进行配置，因此在这种情况下也不需要 Spring
    Cloud Kubernetes。
- en: When migrating a brownfield project to Kubernetes, and it uses libraries like
    Spring Cloud Netflix Eureka for service discovery and Spring Cloud Netflix Ribbon
    or Spring Cloud Load Balancer for load balancing, you might use Spring Cloud Kubernetes
    for a smoother transition. However, I would recommend refactoring your code to
    leverage the native service discovery and load-balancing features from Kubernetes
    rather than adding Spring Cloud Kubernetes to your project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个棕色地带项目迁移到 Kubernetes 时，如果它使用像 Spring Cloud Netflix Eureka 这样的库进行服务发现，或者使用
    Spring Cloud Netflix Ribbon 或 Spring Cloud Load Balancer 进行负载均衡，你可能可以使用 Spring
    Cloud Kubernetes 来实现更平滑的过渡。然而，我建议重构你的代码以利用 Kubernetes 的原生服务发现和负载均衡功能，而不是将 Spring
    Cloud Kubernetes 添加到你的项目中。
- en: The main reason why I recommend not using Spring Cloud Kubernetes in standard
    applications is that it requires access to the Kubernetes API Server to manage
    Pods, Services, ConfigMaps, and Secrets. Besides the security concerns related
    to granting applications access to the Kubernetes internal objects, it would also
    couple the applications to Kubernetes unnecessarily and affect the maintainability
    of the solution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不在标准应用程序中使用 Spring Cloud Kubernetes 的主要原因是因为它需要访问 Kubernetes API 服务器来管理 Pods、Services、ConfigMaps
    和 Secrets。除了授予应用程序访问 Kubernetes 内部对象相关的安全顾虑之外，它还会不必要地将应用程序耦合到 Kubernetes 上，并影响解决方案的可维护性。
- en: When does it make sense to use Spring Cloud Kubernetes? As one example, Spring
    Cloud Gateway could be enhanced with Spring Cloud Kubernetes to get more control
    over service discovery and load balancing, including automatic registration of
    new routes based on Services metadata and the choice of load-balancing strategy.
    In this case, you could rely on the Spring Cloud Kubernetes Discovery Server component,
    limiting the need for Kubernetes API access to the discovery server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下使用 Spring Cloud Kubernetes 是合理的？以一个例子来说，Spring Cloud Gateway 可以通过 Spring
    Cloud Kubernetes 进行增强，以获得对服务发现和负载均衡的更多控制，包括基于服务元数据的自动注册新路由以及选择负载均衡策略。在这种情况下，你可以依赖
    Spring Cloud Kubernetes Discovery Server 组件，从而减少对发现服务器的 Kubernetes API 访问需求。
- en: 'Spring Cloud Kubernetes really shines when it comes to implementing Kubernetes
    controller applications to accomplish administrative tasks within the cluster.
    For example, you could implement a controller that monitors when ConfigMaps or
    Secrets change and then triggers a configuration refresh on the application using
    them. As a matter of fact, the Spring team used Spring Cloud Kubernetes to build
    a controller that does precisely that: the Configuration Watcher.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在集群内实现 Kubernetes 控制器应用程序以完成管理任务时，Spring Cloud Kubernetes 真正大放异彩。例如，您可以实现一个控制器，用于监控
    ConfigMaps 或 Secrets 的更改，然后触发使用它们的应用程序的配置刷新。事实上，Spring 团队就是使用 Spring Cloud Kubernetes
    构建了一个执行此精确操作的控制器：配置监视器。
- en: Note Spring Cloud Kubernetes Configuration Watcher is available as a container
    image on Docker Hub. If you’d like to know more about how it works and how to
    deploy it, you can refer to the official documentation ([https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Spring Cloud Kubernetes 配置监视器作为容器镜像可在 Docker Hub 上获取。如果您想了解更多关于其工作原理和部署方法的信息，请参阅官方文档（[https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes)）。
- en: Besides the Configuration Watcher, Spring Cloud Kubernetes provides other convenient
    off-the-shelf applications for addressing common concerns of distributed systems
    in Kubernetes. One of them is a configuration server built on top of Spring Cloud
    Config and extending its functionality to support reading configuration data from
    ConfigMaps and Secrets. It’s called Spring Cloud Kubernetes Config Server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置监视器，Spring Cloud Kubernetes 还提供了其他方便的现成应用程序，用于解决 Kubernetes 中分布式系统的常见问题。其中之一是基于
    Spring Cloud Config 构建的配置服务器，并扩展其功能以支持从 ConfigMaps 和 Secrets 读取配置数据。它被称为 Spring
    Cloud Kubernetes 配置服务器。
- en: You can use this application directly (the container image is published on Docker
    Hub) and deploy it on Kubernetes following the instructions provided in the official
    documentation ([https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接使用此应用程序（容器镜像已发布在 Docker Hub 上）并按照官方文档中提供的说明在 Kubernetes 上部署它（[https://spring.io/projects/spring-cloud-kubernetes](https://spring.io/projects/spring-cloud-kubernetes)）。
- en: As an alternative, you can use its source code on GitHub as a foundation to
    build your own Kubernetes-aware configuration server. For example, as I explained
    earlier in this chapter, you might want to protect it via HTTP Basic authentication.
    In that case, you could use your experience working with Spring Cloud Config and
    build an enhanced version of Config Service for Polar Bookshop on top of Spring
    Cloud Kubernetes Config Server.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，您可以使用其在 GitHub 上的源代码作为构建自己的 Kubernetes 感知配置服务器的基石。例如，正如我在本章前面所解释的，您可能希望通过
    HTTP Basic 认证来保护它。在这种情况下，您可以使用您与 Spring Cloud Config 的合作经验，并在 Spring Cloud Kubernetes
    配置服务器之上构建 Config 服务的增强版本。
- en: In the next section, I will introduce Kustomize for managing deployment configurations
    in Kubernetes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将介绍 Kustomize，用于管理 Kubernetes 中的部署配置。
- en: 14.3 Configuration management with Kustomize
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 使用 Kustomize 进行配置管理
- en: Kubernetes provides many useful features for running cloud native applications.
    Still, it requires writing several YAML manifests, which are sometimes redundant
    and not easy to manage in a real-world scenario. After collecting the multiple
    manifests needed to deploy an application, we are faced with additional challenges.
    How can we change the values in a ConfigMap depending on the environment? How
    can we change the container image version? What about Secrets and volumes? Is
    it possible to update the health probe’s configuration?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为运行云原生应用程序提供了许多有用的功能。然而，它需要编写多个 YAML 清单，这些清单有时是冗余的，并且在现实场景中不易管理。在收集部署应用程序所需的多个清单之后，我们面临额外的挑战。我们如何根据环境更改
    ConfigMap 中的值？我们如何更改容器镜像版本？关于 Secrets 和卷呢？是否可以更新健康检查的配置？
- en: Many tools have been introduced in the last few years to improve how we configure
    and deploy workloads in Kubernetes. For the Polar Bookshop system, we would like
    a tool that lets us handle multiple Kubernetes manifests as a single entity and
    customize parts of the configuration depending on the environment where the application
    is deployed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，已经推出了许多工具来改善我们在 Kubernetes 中配置和部署工作负载的方式。对于 Polar Bookshop 系统，我们希望有一个工具，允许我们将多个
    Kubernetes 清单作为一个单一实体来处理，并根据应用程序部署的环境定制配置的部分。
- en: Kustomize ([https://kustomize.io](https://kustomize.io)) is a declarative tool
    that helps configure deployments for different environments via a layering approach.
    It produces standard Kubernetes manifests, and it’s built natively in the Kubernetes
    CLI (kubectl), so you don’t need to install anything else.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize ([https://kustomize.io](https://kustomize.io)) 是一个声明式工具，它通过分层方法帮助配置不同环境下的部署。它生成标准的
    Kubernetes 清单，并且它是在 Kubernetes CLI（kubectl）中本地构建的，因此您不需要安装任何其他东西。
- en: Note Other popular options for managing deployment configuration in Kubernetes
    are ytt from the Carvel suite ([https://carvel.dev/ytt](https://carvel.dev/ytt))
    and Helm ([https://helm.sh](https://helm.sh)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Kubernetes 中管理部署配置的其他流行选项包括 Carvel 套件中的 ytt ([https://carvel.dev/ytt](https://carvel.dev/ytt))
    和 Helm ([https://helm.sh](https://helm.sh))。
- en: This section will show you the key features offered by Kustomize. First you’ll
    see how to *compose* related Kubernetes manifests and handle them as a single
    unit. Then I’ll show you how Kustomize can generate a ConfigMap for you from a
    property file. Finally, I’ll guide you through a series of customizations that
    we’ll apply to the base manifests before deploying workloads in a staging environment.
    The next chapter will expand on that and cover the production scenario.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示 Kustomize 提供的关键特性。首先，您将了解如何 *组合* 相关的 Kubernetes 清单并将其作为一个单一单元来处理。然后，我将向您展示
    Kustomize 如何从属性文件中为您生成 ConfigMap。最后，我将指导您通过一系列自定义操作，这些操作将在将工作负载部署到预发布环境中之前应用于基本清单。下一章将在此基础上扩展，并涵盖生产场景。
- en: Before moving on, make sure you still have your local minikube cluster up and
    running and that the Polar Bookshop backing services have been deployed correctly.
    If you don’t, run ./create-cluster.sh from polar-deployment/kubernetes/platform/
    development.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保您的本地 minikube 集群仍然运行，并且 Polar Bookshop 后端服务已经正确部署。如果没有，请从 polar-deployment/kubernetes/platform/development
    运行 ./create-cluster.sh。
- en: Note The platform services are exposed only within the cluster. If you want
    to access any of them from your local machine, you can use the port-forwarding
    feature you learned about in chapter 7\. You can either leverage the GUI provided
    by Octant or use the CLI (kubectl port-forward service/polar-postgres 5432:5432).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：平台服务仅在集群内部暴露。如果您想从您的本地机器访问其中任何一个，您可以使用在第 7 章中了解到的端口转发功能。您可以使用 Octant 提供的
    GUI，或者使用 CLI（kubectl port-forward service/polar-postgres 5432:5432）。
- en: Now that we have all the backing services available, let’s see how we can manage
    and configure a Spring Boot application using Kustomize.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有后端服务，让我们看看如何使用 Kustomize 来管理和配置 Spring Boot 应用程序。
- en: 14.3.1 Using Kustomize to manage and configure Spring Boot applications
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 使用 Kustomize 管理和配置 Spring Boot 应用程序
- en: So far, we’ve been deploying applications to Kubernetes by applying multiple
    Kubernetes manifests. For example, deploying Catalog Service requires applying
    the ConfigMap, Deployment, and Service manifests to the cluster. When using Kustomize,
    the first step is composing related manifests together so that we can handle them
    as a single unit. Kustomize does that via a Kustomization resource. In the end,
    we want to let Kustomize manage, process, and generate Kubernetes manifests for
    us.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是通过应用多个 Kubernetes 清单将应用程序部署到 Kubernetes。例如，部署目录服务需要将 ConfigMap、Deployment
    和 Service 清单应用到集群中。当使用 Kustomize 时，第一步是将相关的清单组合在一起，以便我们可以将它们作为一个单一单元来处理。Kustomize
    通过 Kustomization 资源来实现这一点。最终，我们希望让 Kustomize 为我们管理、处理和生成 Kubernetes 清单。
- en: Let’s see how it works. Open your Catalog Service project (catalog-service)
    and create a kustomization.yml file inside the k8s folder. It will be the entry
    point for Kustomize.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。打开您的目录服务项目（catalog-service），在 k8s 文件夹内创建一个 kustomization.yml 文件。它将是
    Kustomize 的入口点。
- en: We’ll first instruct Kustomize about which Kubernetes manifests it should use
    as a foundation for future customizations. For now, we’ll use the existing Deployment
    and Service manifests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将指导 Kustomize 使用哪些 Kubernetes 清单作为未来自定义的基础。目前，我们将使用现有的 Deployment 和 Service
    清单。
- en: Listing 14.4 Defining the base Kubernetes manifests for Kustomize
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.4 定义 Kustomize 的基本 Kubernetes 清单
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The API version for Kustomize
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Kustomize 的 API 版本
- en: ❷ The kind of resource defined by the manifest
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 清单定义的资源类型
- en: ❸ Kubernetes manifests that Kustomize should manage and process
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Kustomize 应该管理和处理的 Kubernetes 清单
- en: You might be wondering why we didn’t include the ConfigMap. I’m glad you asked!
    We could have included the configmap.yml file we created earlier in the chapter,
    but Kustomize offers a better way. Instead of referencing a ConfigMap directly,
    we can provide a property file and let Kustomize use it to generate a ConfigMap.
    Let’s see how it works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们没有包含 ConfigMap。我很高兴你问了！我们本来可以包含本章中创建的 configmap.yml 文件，但 Kustomize
    提供了一种更好的方法。我们不是直接引用 ConfigMap，而是可以提供一个属性文件，并让 Kustomize 使用它来生成 ConfigMap。让我们看看它是如何工作的。
- en: For starters, let’s move the body of the ConfigMap we created previously (configmap.yml)
    to a new application.yml file within the k8s folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将之前创建的 ConfigMap 的主体（configmap.yml）移动到 k8s 文件夹中的一个新的 application.yml 文件中。
- en: Listing 14.5 Configuration properties provided via a ConfigMap
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.5 通过 ConfigMap 提供的配置属性
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then delete the configmap.yml file. We won’t need it anymore. Finally, update
    the kustomization.yml file to generate a catalog-config ConfigMap starting from
    the application.yml file we just created.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，删除 configmap.yml 文件。我们不再需要它了。最后，更新 kustomization.yml 文件，从我们刚刚创建的应用程序.yml
    文件开始生成 catalog-config ConfigMap。
- en: Listing 14.6 Getting Kustomize to generate a ConfigMap from a property file
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.6 让 Kustomize 从属性文件生成 ConfigMap
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ The section containing information to generate ConfigMaps
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含生成 ConfigMap 所需信息的部分
- en: ❷ Uses a property file as the source for a ConfigMap
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用属性文件作为 ConfigMap 的源
- en: ❸ Defines the labels to assign to the generated ConfigMap
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义要分配给生成的 ConfigMap 的标签
- en: Note In a similar way, Kustomize can also generate Secrets starting with literal
    values or files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：以类似的方式，Kustomize 也可以从文本值或文件开始生成 Secrets。
- en: Let’s pause for a moment and verify that what we have done so far works correctly.
    Your local cluster should already have your Catalog Service container image from
    before. If that’s not the case, build the container image (./gradlew bootBuildImage),
    and load it into minikube (minikube image load catalog-service --profile polar).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，验证到目前为止我们所做的是否正确。您的本地集群应该已经包含了之前的目录服务容器镜像。如果不是这样，构建容器镜像（./gradlew bootBuildImage），并将其加载到
    minikube 中（minikube image load catalog-service --profile polar）。
- en: 'Next, open a Terminal window, navigate to your Catalog Service project (catalog-service),
    and deploy the application using the familiar Kubernetes CLI. When applying standard
    Kubernetes manifests, we use the -f flag. When applying a Kustomization, we use
    the -k flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开一个终端窗口，导航到您的目录服务项目（catalog-service），并使用熟悉的 Kubernetes CLI 部署应用程序。当应用标准
    Kubernetes 清单时，我们使用 -f 标志。当应用 Kustomization 时，我们使用 -k 标志：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The final result should be the same as we got earlier when applying the Kubernetes
    manifests directly, but this time Kustomize handled everything via a Kustomization
    resource.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该与我们之前直接应用 Kubernetes 清单时得到的结果相同，但这次 Kustomize 通过 Kustomization 资源处理了所有操作。
- en: 'To complete the verification, use the port-forwarding strategy to expose the
    Catalog Service application to your local machine (kubectl port-forward service/catalog-service
    9001:80). Then open a new Terminal window, and ensure that the root endpoint returns
    the message configured via the ConfigMap generated by Kustomize:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成验证，使用端口转发策略将目录服务应用程序暴露到您的本地机器（kubectl port-forward service/catalog-service
    9001:80）。然后打开一个新的终端窗口，并确保根端点返回通过 Kustomize 生成的 ConfigMap 配置的消息：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'ConfigMaps and Secrets generated by Kustomize are named with a unique suffix
    (a *hash*) when they’re deployed. You can verify the actual name assigned to the
    catalog-config ConfigMap with the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 生成的 ConfigMaps 和 Secrets 在部署时都会添加一个唯一的后缀（一个 *哈希值*）。您可以使用以下命令验证分配给
    catalog-config ConfigMap 的实际名称：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Every time you update the input to the generators, Kustomize creates a new manifest
    with a different hash, which triggers a *rolling restart* of the containers where
    the updated ConfigMaps or Secrets are mounted as volumes. That is a highly convenient
    way to achieve an automated configuration refresh without implementing or configuring
    any additional components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更新生成器的输入时，Kustomize 都会创建一个新的清单，具有不同的哈希值，这会触发将更新后的 ConfigMaps 或 Secrets 作为卷挂载的容器进行
    *滚动重启*。这是一个非常方便的方法，可以在不实现或配置任何附加组件的情况下实现自动配置刷新。
- en: Let’s verify that it’s true. First, update the value for the polar.greeting
    property in the application.yml file used by Kustomize to generate the ConfigMap.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来验证这是否正确。首先，更新用于由 Kustomize 生成 ConfigMap 的 application.yml 文件中 polar.greeting
    属性的值。
- en: Listing 14.7 Updating the configuration input to the ConfigMap generator
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.7 更新 ConfigMap 生成器的配置输入
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then apply the Kustomization again (kubectl apply -k k8s). Kustomize will generate
    a new ConfigMap with a different suffix hash, triggering a rolling restart of
    all the Catalog Service instances. In this case there’s only one instance running.
    In production there will be more. The fact that the instances are restarted one
    at a time means that the update happens with zero downtime, which is what we aim
    for in the cloud. The Catalog Service root endpoint should now return the new
    message:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次应用 Kustomization（kubectl apply -k k8s）。Kustomize 将生成一个新的 ConfigMap，具有不同的后缀哈希，触发所有
    Catalog Service 实例的滚动重启。在这种情况下只有一个实例正在运行。在生产环境中会有更多。实例逐个重启的事实意味着更新以零停机时间发生，这是我们云环境中的目标。现在
    Catalog Service 的根端点应该返回新的消息：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you’re curious, you could compare this result with what would happen when
    updating a ConfigMap without Kustomize. Kubernetes would update the volume mounted
    to the Catalog Service container, but the application would not be restarted and
    would still return the old value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，可以比较一下在没有 Kustomize 更新 ConfigMap 时会发生什么。Kubernetes 会更新挂载到 Catalog Service
    容器的卷，但应用程序不会重启，并且仍然会返回旧值。
- en: 'Note Depending on your requirements, you might need to avoid a rolling restart
    and have the applications reload their configuration at runtime. In that case,
    you can disable the hash suffix strategy with the disableNameSuffixHash: true
    generator option and perhaps rely on something like Spring Cloud Kubernetes Configuration
    Watcher to notify the applications whenever a ConfigMap or Secret is changed.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '注意：根据你的需求，你可能需要避免滚动重启，并在运行时让应用程序重新加载其配置。在这种情况下，你可以使用 disableNameSuffixHash:
    true 生成器选项禁用哈希后缀策略，并可能依赖于像 Spring Cloud Kubernetes Configuration Watcher 这样的工具，以便在
    ConfigMap 或 Secret 发生更改时通知应用程序。'
- en: When you’re done experimenting with the Kustomize setup, you can stop the port-forwarding
    process (Ctrl-C) and undeploy Catalog Service (kubectl delete -k k8s).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成对 Kustomize 设置的实验后，你可以停止端口转发过程（Ctrl-C）并卸载 Catalog Service（kubectl delete
    -k k8s）。
- en: Since we moved from plain Kubernetes manifests to Kustomize, we still need to
    update a couple of things. In chapter 7, we used Tilt to achieve a better development
    workflow when working locally on Kubernetes. Tilt supports Kustomize, so we can
    configure it to deploy applications via a Kustomization resource rather than via
    plain Kubernetes manifests. Go ahead and update the Tiltfile in your Catalog Service
    project as follows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从纯 Kubernetes 清单迁移到了 Kustomize，我们仍然需要更新一些内容。在第 7 章中，我们使用 Tilt 在本地使用 Kubernetes
    进行开发时实现了一个更好的开发工作流程。Tilt 支持 Kustomize，因此我们可以配置它通过 Kustomization 资源而不是通过纯 Kubernetes
    清单来部署应用程序。继续更新你的 Catalog Service 项目的 Tiltfile，如下所示。
- en: Listing 14.8 Configuring Tilt to deploy Catalog Service using Kustomize
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.8 配置 Tilt 使用 Kustomize 部署 Catalog Service
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Runs the application from the Kustomization located in the k8s folder
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从位于 k8s 文件夹中的 Kustomization 运行应用程序
- en: Finally, we need to update the manifest validation step in the commit stage
    workflow for Catalog Service, or it will fail the next time we push changes to
    GitHub. In your Catalog Service project, open the commit-stage.yml file (.github/workflows)
    and update it as follows.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新 Catalog Service 的提交阶段工作流程中的清单验证步骤，否则在下次我们将更改推送到 GitHub 时将会失败。在你的 Catalog
    Service 项目中，打开 commit-stage.yml 文件 (.github/workflows) 并按照以下方式更新。
- en: Listing 14.9 Using Kubeval to validate the manifests generated by Kustomize
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.9 使用 Kubeval 验证 Kustomize 生成的清单
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Uses Kustomize to generate the manifests and then validates them with Kubeval
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Kustomize 生成清单，然后使用 Kubeval 验证它们
- en: So far, the most significant benefit we got from Kustomize is the automatic
    rolling restart of applications when a ConfigMap or Secret is updated. In the
    next section, you’ll learn more about Kustomize and explore its powerful features
    for managing different Kubernetes configurations depending on the deployment environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们从 Kustomize 获得的最重要的好处是当 ConfigMap 或 Secret 更新时应用程序的自动滚动重启。在下一节中，你将了解更多关于
    Kustomize 的内容，并探索其强大的功能，以根据部署环境管理不同的 Kubernetes 配置。
- en: 14.3.2 Managing Kubernetes configuration for multiple environments with Kustomize
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 使用 Kustomize 管理多个环境下的 Kubernetes 配置
- en: During development we followed the 15-Factor methodology and externalized the
    configuration for each aspect of an application that could change between deployments
    in different environments. You saw how to use property files, environment variables,
    configuration services, and ConfigMaps. I also showed you how to use Spring profiles
    to customize the application configuration based on the deployment environment.
    Now we need to take a step further and define a strategy to customize the entire
    deployment configuration depending on where we deploy an application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们遵循了15-Factor方法论，并将应用程序的每个可能在不同环境部署中变化的方面的配置外部化。你看到了如何使用属性文件、环境变量、配置服务和ConfigMaps。我还向你展示了如何使用Spring配置文件根据部署环境来定制应用程序配置。现在我们需要进一步定义一个策略，根据我们部署应用程序的位置来定制整个部署配置。
- en: In the previous section, you learned how to compose and process Kubernetes manifests
    together via a Kustomization resource. For each environment, we can specify *patches*
    to apply changes or additional configurations on top of those basic manifests.
    All the customization steps you’ll see in this section will be applied without
    changing anything in the application source code but using the same release artifacts
    produced earlier. That’s quite a powerful concept and one of the main features
    of cloud native applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何通过Kustomization资源一起组合和处理Kubernetes清单。对于每个环境，我们可以指定*补丁*来应用更改或在这些基本清单之上添加额外的配置。本节中你将看到的所有定制步骤都将应用，而不会更改应用程序源代码中的任何内容，但使用之前产生的相同发布工件。这是一个相当强大的概念，也是云原生应用程序的主要特性之一。
- en: 'The Kustomize approach to configuration customization is based on the concepts
    of *bases* and *overlays*. The k8s folder we created in the Catalog Service project
    can be considered a *base* : a directory with a kustomization.yml file that combines
    Kubernetes manifests and customizations. An *overlay* is another directory with
    a kustomization.yml file. What makes it special is that it defines customizations
    in relation to one or more bases and combines them. Starting from the same base,
    you can specify an overlay for each deployment environment (such as development,
    test, staging, and production).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize配置定制的做法基于*基础*和*覆盖*的概念。我们在目录服务项目中创建的k8s文件夹可以被认为是一个*基础*：一个包含kustomization.yml文件的目录，该文件结合了Kubernetes清单和定制。*覆盖*是另一个包含kustomization.yml文件的目录。它之所以特殊，是因为它定义了与一个或多个基础相关的定制，并将它们组合起来。从同一个基础开始，你可以为每个部署环境（如开发、测试、预生产和生产）指定一个覆盖。
- en: As shown in figure 14.3, each Kustomization includes a kustomization.yml file.
    The one acting as the *base* composes together several Kubernetes resources like
    Deployments, Services, and ConfigMaps. Also, it’s not aware of the overlays, so
    it’s completely independent of them. The *overlays* use one or more *bases* as
    a foundation and provide additional configuration via patches.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如图14.3所示，每个Kustomization都包含一个kustomization.yml文件。作为*基础*的那个文件组合了多个Kubernetes资源，如Deployments、Services和ConfigMaps。它还不知道覆盖，因此与它们完全独立。*覆盖*使用一个或多个*基础*作为基础，并通过补丁提供额外的配置。
- en: '![14-03](../Images/14-03.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![14-03](../Images/14-03.png)'
- en: Figure 14.3 Kustomize bases can be used as the foundation for further customizations
    (overlays) depending on the deployment environment.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 Kustomize基础可以用来作为进一步定制（覆盖）的基础，具体取决于部署环境。
- en: 'Bases and overlays can be defined either in the same repository or different
    ones. For the Polar Bookshop system, we’ll use the k8s folder in each application
    project as a base and define overlays in the polar-deployment repository. Similar
    to what you learned in chapter 3 about application codebases, you can decide whether
    to keep your deployment configuration in the same repository as your application
    or not. I decided to go for a separate repository for a few reasons:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基础和覆盖可以在同一个仓库或不同的仓库中定义。对于极地书店系统，我们将使用每个应用程序项目的k8s文件夹作为基础，并在polar-deployment仓库中定义覆盖。类似于你在第3章中学到的关于应用程序代码库的内容，你可以决定是否将部署配置保存在与你的应用程序相同的仓库中。我决定使用单独的仓库，出于以下几个原因：
- en: It makes it possible to control the deployment of all the system components
    from a single place.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得从单一地点控制所有系统组件的部署成为可能。
- en: It allows focused version-control, auditing, and compliance checks before deploying
    anything to production.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在部署任何内容到生产之前进行集中的版本控制、审计和合规性检查。
- en: It fits the GitOps approach, where delivery and deployment tasks are decoupled.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它符合GitOps方法，其中交付和部署任务是解耦的。
- en: As an example, figure 14.4 shows how the Kustomize manifests could be structured
    in the case of Catalog Service, having bases and overlays in two separate repositories.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图14.4展示了在目录服务的情况下，Kustomize清单可以如何结构化，拥有基础和覆盖层在两个独立的仓库中。
- en: '![14-04](../Images/14-04.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![14-04](../Images/14-04.png)'
- en: Figure 14.4 Kustomize bases and overlays can be stored in the same repository
    or two separate ones. Overlays can be used to customize deployments for different
    environments.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 Kustomize的基础和覆盖层可以存储在同一个仓库中或两个独立的仓库中。覆盖层可以用来定制不同环境下的部署。
- en: Another decision to make is whether to keep the base Kubernetes manifests together
    with the application source code or move them to the deployment repository. I
    decided to go with the first approach for the Polar Bookshop example, similar
    to what we did with the default configuration properties. One of the benefits
    is that it makes it simple to run each application on a local Kubernetes cluster
    during development, either directly or using Tilt. Depending on your requirements,
    you might decide to use one approach or the other. Both are valid and used in
    real-world scenarios.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要做出的决定是是否将基Kubernetes清单与应用程序源代码一起保留，或者将它们移动到部署仓库中。对于Polar Bookshop示例，我决定采用第一种方法，类似于我们处理默认配置属性的方式。其中一个好处是它使得在开发期间在本地Kubernetes集群上运行每个应用程序变得简单，无论是直接运行还是使用Tilt。根据你的需求，你可能会决定使用其中一种方法。两种方法都是有效的，并且在现实场景中被使用。
- en: Patches vs. templates
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁与模板
- en: Kustomize’s approach to customizing configuration is based on applying patches.
    It’s quite the opposite of how Helm works ([https://helm.sh](https://helm.sh)).
    Helm requires you to template every part of a manifest that you would like to
    change (resulting in non-valid YAML). After that, you can provide different values
    for those templates in each environment. If a field is not templated, you can’t
    customize its value. For that reason, it’s not rare to use Helm and Kustomize
    in sequence, overcoming each other’s shortcomings. Both approaches have pros and
    cons.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize定制配置的方法是基于应用补丁。这与Helm的工作方式正好相反 ([https://helm.sh](https://helm.sh))。Helm要求你为想要更改的清单的每一部分进行模板化（导致非有效的YAML）。之后，你可以在每个环境中为这些模板提供不同的值。如果一个字段没有进行模板化，你无法自定义其值。因此，使用Helm和Kustomize的顺序使用并不罕见，以克服彼此的缺点。两种方法都有优点和缺点。
- en: In this book I decided to use Kustomize because it’s natively available in the
    Kubernetes CLI, it works with valid YAML files, and it’s purely declarative. Helm
    is more powerful and can also handle complex application rollouts and upgrades
    that Kubernetes doesn’t support natively. On the other hand, it has a steep learning
    curve, its templating solution has a few drawbacks, and it’s not declarative.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我决定使用Kustomize，因为它在Kubernetes CLI中是原生可用的，它与有效的YAML文件一起工作，并且它是纯声明式的。Helm功能更强大，也可以处理Kubernetes原生不支持的应用程序部署和升级。另一方面，它有一个陡峭的学习曲线，其模板解决方案有一些缺点，并且它不是声明式的。
- en: Another option is ytt from the Carvel suite ([https://carvel.dev/ytt](https://carvel.dev/ytt)).
    It provides a superior experience, with support for both patches and templates,
    it works with valid YAML files, and its templating strategy is more robust. It
    takes a bit more effort to get familiar with ytt than Kustomize, but it’s worth
    the effort. Because it treats YAML as a first-class citizen, ytt can be used to
    configure and customize any YAML file, even outside Kubernetes. Do you use GitHub
    Actions workflows? Ansible playbooks? Jenkins pipelines? You can use ytt in all
    those scenarios.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是来自Carvel套件的ytt ([https://carvel.dev/ytt](https://carvel.dev/ytt))。它提供了一种更优越的体验，支持补丁和模板，它适用于有效的YAML文件，并且其模板策略更加稳健。熟悉ytt比Kustomize需要更多的努力，但这是值得的。因为它将YAML视为一等公民，ytt可以用来配置和定制任何YAML文件，甚至是在Kubernetes之外。你使用GitHub
    Actions工作流吗？Ansible剧本？Jenkins管道？你可以在所有这些场景中使用ytt。
- en: Let’s consider Catalog Service. We already have the base deployment configuration
    composed with Kustomize. It’s located within the project repository in a dedicated
    folder (catalog-service/k8s). Now let’s define an overlay to customize the deployment
    for staging.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑目录服务。我们已经有了一个由Kustomize组成的基部署配置。它位于项目仓库中的一个专用文件夹中（catalog-service/k8s）。现在让我们定义一个覆盖层来定制用于预发布的部署。
- en: 14.3.3 Defining a configuration overlay for staging
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 定义预发布的配置覆盖
- en: In the previous sections, we used Kustomize to manage the configuration of Catalog
    Service in a local development environment. Those manifests will represent the
    *base* for multiple customizations applied for each environment as *overlays*.
    Since we’ll define overlays in the polar-deployment repository while the base
    is in the catalog-service repository, all the Catalog Service manifests must be
    available in the main remote branch. If you haven’t done so yet, push all the
    changes applied to your Catalog Service project so far to the remote repository
    on GitHub.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了 Kustomize 来管理本地开发环境中 Catalog Service 的配置。这些清单将代表 *基础*，为每个环境应用多个自定义设置作为
    *覆盖*。由于我们将在 polar-deployment 仓库中定义覆盖，而基础在 catalog-service 仓库中，因此所有 Catalog Service
    清单都必须在主远程分支中可用。如果您还没有这样做，请将您迄今为止应用到 Catalog Service 项目的所有更改推送到 GitHub 上的远程仓库。
- en: Note As I explained in chapter 2, I expect you have created a different repository
    on GitHub for each project in the Polar Bookshop system. In this chapter we’re
    working only with the polar-deployment and catalog-service repositories, but you
    should have also created repositories for edge-service, order-service, and dispatcher-service.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：正如我在第二章中解释的，我期望您为 Polar Bookshop 系统中的每个项目在 GitHub 上创建了一个不同的仓库。在本章中，我们只使用
    polar-deployment 和 catalog-service 仓库，但您也应该为 edge-service、order-service 和 dispatcher-service
    创建了仓库。
- en: As anticipated, we’ll store any configuration overlay in the polar-deployment
    repository. In this section and the following ones, we’ll define an overlay for
    the staging environment. The next chapter will cover production.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们将任何配置覆盖存储在 polar-deployment 仓库中。在本节和接下来的几节中，我们将定义一个用于预发布环境的覆盖。下一章将涵盖生产环境。
- en: Go ahead and create a new kubernetes/applications folder in your polar-deployment
    repository. We’ll use it to keep the customizations for all the applications in
    the Polar Bookshop system. In the newly created path, add a catalog-service folder
    that will contain any overlay for customizing the deployment of Catalog Service
    in different environments. In particular, we’ll want to prepare the deployment
    in staging, so create a “staging” folder for Catalog Service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 polar-deployment 仓库中创建一个新的 kubernetes/applications 文件夹。我们将使用它来保存 Polar Bookshop
    系统中所有应用程序的自定义设置。在新建的路径中，添加一个 catalog-service 文件夹，该文件夹将包含用于在不同环境中自定义 Catalog Service
    部署的任何覆盖。特别是，我们希望准备预发布环境的部署，因此为 Catalog Service 创建一个“staging”文件夹。
- en: Any customization (base or overlay) requires a kustomization.yml file. Let’s
    create one for the staging overlay of Catalog Service (polar-deployment/kubernetes/
    applications/catalog-service/staging). The first thing to configure is a reference
    to the base manifests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 任何自定义（基础或覆盖）都需要一个 kustomization.yml 文件。让我们为 Catalog Service 的预发布覆盖（polar-deployment/kubernetes/applications/catalog-service/staging）创建一个。首先需要配置的是对基础清单的引用。
- en: If you’ve followed along, you should have your Catalog Service source code tracked
    in a catalog-service repository on GitHub. A reference to a remote base needs
    to point to the folder containing the kustomization.yml file, which is k8s in
    our case. Also, we should refer to a specific tag or digest for the version we
    want to deploy. We’ll talk about release strategies and versioning in the next
    chapter, so we’ll simply point to the main branch for now. The final URL should
    be something like github .com/<your_github_username>/catalog-service/k8s?ref=main.
    For example, in my case, it would be github.com/polarbookshop/catalog-service/k8s?ref=main.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直跟随，您应该在 GitHub 上的 catalog-service 仓库中跟踪 Catalog Service 的源代码。对远程基础的引用需要指向包含
    kustomization.yml 文件的文件夹，在我们的例子中是 k8s。此外，我们应该引用我们想要部署的特定标签或摘要版本。我们将在下一章中讨论发布策略和版本控制，所以现在我们只需指向主分支即可。最终的
    URL 应该类似于 github.com/<你的 GitHub 用户名>/catalog-service/k8s?ref=main。例如，在我的情况下，它将是
    github.com/polarbookshop/catalog-service/k8s?ref=main。
- en: Listing 14.10 Defining an overlay for staging on top of a remote base
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.10 在远程基础之上定义预发布覆盖
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Uses the manifests in your Catalog Service repo on GitHub as the base for
    further customizations
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用您在 GitHub 上的 Catalog Service 仓库中的清单作为进一步自定义的基础
- en: Note I’ll assume that all the GitHub repositories you created for Polar Bookshop
    are publicly accessible. If that’s not the case, you can go to the specific repository
    page on GitHub and access the Settings section for that repository. Then scroll
    to the bottom of the settings page, and make the package public by clicking the
    Change Visibility button.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将假设您为 Polar Bookshop 创建的所有 GitHub 仓库都是公开可访问的。如果不是这样，您可以去 GitHub 上特定仓库的页面，并访问该仓库的设置部分。然后滚动到设置页面的底部，通过点击“更改可见性”按钮将包设置为公开。
- en: We could now deploy Catalog Service from the staging overlay using the Kubernetes
    CLI, but the result wouldn’t be different than using the base directly. Let’s
    start applying some customizations specifically for staging deployments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 Kubernetes CLI 从预发布覆盖部署目录服务，但结果与直接使用基础没有区别。让我们开始应用一些专门针对预发布部署的自定义设置。
- en: 14.3.4 Customizing environment variables
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4 自定义环境变量
- en: The first customization we could apply is an environment variable to activate
    the staging Spring profile for Catalog Service. Most customizations can be applied
    via patches following a merge strategy. Much like Git merges changes from different
    branches, Kustomize produces final Kubernetes manifests with changes coming from
    different Kustomization files (one or more bases and an overlay).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用的第一种自定义是设置一个环境变量以激活目录服务的预发布 Spring 配置文件。大多数自定义可以通过遵循合并策略的补丁来应用。与 Git 合并来自不同分支的更改类似，Kustomize
    生成最终 Kubernetes 清单，其中包含来自不同 Kustomization 文件（一个或多个基础和覆盖）的更改。
- en: A best practice when defining Kustomize patches is to keep them small and focused.
    To customize environment variables, create a patch-env.yml file within the staging
    overlay for Catalog Service (kubernetes/applications/catalog-service/staging).
    We need to specify some contextual information so Kustomize can figure out where
    to apply the patch and how to merge the changes. When the patch is for customizing
    a container, Kustomize requires us to specify the kind and name of the Kubernetes
    resource (that is, Deployment) and the name of the container. This customization
    option is called a *strategic merge patch*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Kustomize 补丁时的最佳实践是保持它们小而专注。要自定义环境变量，请在目录服务的预发布覆盖（kubernetes/applications/catalog-service/staging）中创建一个
    patch-env.yml 文件。我们需要指定一些上下文信息，以便 Kustomize 能够确定补丁的应用位置以及如何合并更改。当补丁用于自定义容器时，Kustomize
    要求我们指定 Kubernetes 资源（即 Deployment）的类型和名称以及容器的名称。这种自定义选项称为 *战略合并补丁*。
- en: Listing 14.11 A patch for customizing environment variables
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.11 自定义环境变量的补丁
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Defines which Spring profiles should be activated
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义应激活哪些 Spring 配置文件
- en: Next we need to instruct Kustomize to apply the patch. In the kustomization.yml
    file for the staging overlay of Catalog Service, list the patch-env.yml file as
    follows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指示 Kustomize 应用补丁。在目录服务的预发布覆盖的 kustomization.yml 文件中，按照以下方式列出 patch-env.yml
    文件。
- en: Listing 14.12 Getting Kustomize to apply the patch for environment variables
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.12 让 Kustomize 应用环境变量补丁
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Section containing the list of patches to apply to the base manifests according
    to the strategic merge strategy
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含要按照战略合并策略应用于基础清单的补丁列表
- en: ❷ The patch for customizing the environment variables passed to the Catalog
    Service container
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为自定义传递给目录服务容器的环境变量补丁
- en: You can use this same approach to customize many aspects of a Deployment, such
    as the number of replicas, liveness probe, readiness probe, graceful shutdown
    timeout, environment variables, volumes, and more. In the next section, I’ll show
    you how to customize ConfigMaps.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方法来自定义许多方面，例如 Deployment 的副本数量、存活探针、就绪探针、优雅关闭超时、环境变量、卷等。在下一节中，我将向您展示如何自定义
    ConfigMaps。
- en: 14.3.5 Customizing ConfigMaps
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.5 自定义 ConfigMaps
- en: 'The base Kustomization for Catalog Service instructs Kustomize to generate
    a catalog-config ConfigMap starting from an application.yml file. To customize
    the values in that ConfigMap, we have two main options: replace the entire ConfigMap
    or overwrite only the values that should be different in staging. In this second
    case, we could generally rely on some advanced Kustomize patching strategy to
    overwrite specific values in the ConfigMap.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 目录服务的基 Kustomization 指示 Kustomize 从 application.yml 文件开始生成一个 catalog-config
    ConfigMap。为了自定义该 ConfigMap 中的值，我们有两个主要选项：替换整个 ConfigMap 或仅覆盖在预发布阶段应该不同的值。在后一种情况下，我们可以一般地依赖于一些高级
    Kustomize 补丁策略来覆盖 ConfigMap 中的特定值。
- en: When working with Spring Boot, we can take advantage of the power of Spring
    profiles. Instead of updating values in the existing ConfigMap, we can add an
    application-staging.yml file, which we know takes precedence over application.yml
    when the staging profile is active. The final result will be a ConfigMap containing
    both files.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Boot时，我们可以利用Spring配置文件的力量。我们不必更新现有ConfigMap中的值，而是可以添加一个application-staging.yml文件，我们知道当staging配置文件激活时，该文件比application.yml具有优先级。最终结果将是一个包含两个文件的ConfigMap。
- en: First, let’s create an application-staging.yml file within the staging overlay
    for Catalog Service. We’ll use this property file to define a different value
    for the polar .greeting property. Since we’ll use the same minikube cluster from
    earlier as the staging environment, URLs to backing services and credentials will
    be the same as in the development environment. In a real-world scenario, this
    stage would involve more customizations.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在目录服务的staging overlay中创建一个application-staging.yml文件。我们将使用这个属性文件来定义polar
    .greeting属性的不同的值。由于我们将使用之前相同的minikube集群作为staging环境，因此支持服务的URL和凭证将与开发环境中的相同。在现实世界的场景中，这个阶段将涉及更多的定制。
- en: Listing 14.13 Staging-specific configuration for Catalog Service
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.13 目录服务的特定配置
- en: '[PRE31]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next we can rely on the ConfigMap Generator provided by Kustomize to combine
    the application-staging.yml file (defined in the staging overlay) with the application.yml
    file (defined in the base Kustomization) within the same catalog-config ConfigMap.
    Go ahead and update the kustomization.yml file for the staging overlay as follows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以依赖Kustomize提供的ConfigMap生成器，将定义在staging overlay中的应用程序-staging.yml文件（定义在基本Kustomization中）与同一catalog-config
    ConfigMap中的应用程序.yml文件合并。请更新staging overlay的kustomization.yml文件，如下所示。
- en: Listing 14.14 Merging property files within the same ConfigMap
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14.14 在同一ConfigMap中合并属性文件
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Merges this ConfigMap with the one defined in the base Kustomization
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将此ConfigMap与基本Kustomization中定义的ConfigMap合并
- en: ❷ The additional property file added to the ConfigMap
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加到ConfigMap中的附加属性文件
- en: ❸ The same ConfigMap name used in the base Kustomization
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在基本Kustomization中使用的相同ConfigMap名称
- en: That’s it for ConfigMaps. The following section will cover how you can configure
    which image name and version to deploy.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap的内容到此结束。下一节将介绍如何配置要部署的镜像名称和版本。
- en: 14.3.6 Customizing image name and version
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.6 自定义镜像名称和版本
- en: The base Deployment manifest defined in the Catalog Service repository (catalog-service/k8s/deployment.yml)
    is configured to use a local container image and doesn’t specify a version number
    (which means the latest tag is used). That’s convenient in the development phase,
    but it doesn’t work for other deployment environments.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录服务仓库（catalog-service/k8s/deployment.yml）中定义的基本部署清单配置为使用本地容器镜像，并且没有指定版本号（这意味着使用最新标签）。这在开发阶段很方便，但不适于其他部署环境。
- en: If you followed along, you should have your Catalog Service source code tracked
    in a catalog-service repository on GitHub and a ghcr.io/<your_github_username>/catalog-service:latest
    container image published to GitHub Container Registry (as per the Commit Stage
    workflow). The next chapter will cover release strategies and versioning. Until
    then, we’ll still use the latest tag. Regarding the image name, though, it’s time
    to start pulling container images from the registry rather than using the local
    ones.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟随，你应该已经在GitHub上的catalog-service仓库中跟踪了目录服务源代码，并且ghcr.io/<你的GitHub用户名>/catalog-service:latest容器镜像已发布到GitHub容器注册库（按照提交阶段工作流程）。下一章将涵盖发布策略和版本控制。在此之前，我们仍将使用最新标签。然而，关于镜像名称，现在是时候从注册库中拉取容器镜像，而不是使用本地镜像了。
- en: Note Images published to GitHub Container Registry will have the same visibility
    as the related GitHub code repository. I’ll assume that all the images we build
    for Polar Bookshop are publicly accessible via the GitHub Container Registry.
    If that’s not the case, you can go to the specific repository page on GitHub and
    access the Packages section for that repository. Then select Package Settings
    from the sidebar menu, scroll to the bottom of the settings page, and make the
    package public by clicking the Change Visibility button.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意发布到GitHub容器注册库的镜像将与相关的GitHub代码仓库具有相同的可见性。我将假设我们为Polar Bookshop构建的所有镜像都可通过GitHub容器注册库公开访问。如果不是这样，你可以访问GitHub上的特定仓库页面，并进入该仓库的“包”部分。然后从侧边栏菜单中选择“包设置”，滚动到设置页面的底部，通过点击“更改可见性”按钮将包设置为公开。
- en: Similar to what we’ve done for environment variables, we could use a patch to
    change the image that’s used by the Catalog Service Deployment resource. Since
    it’s a very common customization and would need to be changed every time we deliver
    a new version of our applications, however, Kustomize provides a more convenient
    way to declare which image name and version we want to use for each container.
    Furthermore, we can either update the kustomization.yml file directly or rely
    on the Kustomize CLI (installed as part of the Kubernetes CLI). Let’s try the
    latter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为环境变量所做的一样，我们可以使用补丁来更改 Catalog 服务部署资源所使用的镜像。然而，由于这是一个非常常见的定制化操作，并且每次我们交付新版本的应用程序时都需要更改，因此
    Kustomize 提供了一种更方便的方式来声明我们想要为每个容器使用哪个镜像名称和版本。此外，我们可以直接更新 kustomization.yml 文件，或者依赖于
    Kustomize CLI（作为 Kubernetes CLI 的一部分安装）。让我们尝试后者。
- en: 'Open a Terminal window, navigate to the staging overlay for Catalog Service
    (kubernetes/applications/catalog-service/staging), and run the following command
    to define which image and version to use for the catalog-service container. Remember
    to replace <your_github_username> with your GitHub username in lowercase:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到 Catalog 服务（kubernetes/applications/catalog-service/staging）的预发布覆盖，并运行以下命令来定义要用于
    catalog-service 容器的镜像和版本。请记住用你的 GitHub 用户名的小写形式替换 <your_github_username>：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command will automatically update the kustomization.yml file with the new
    configuration, as you can see in the following listing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将自动更新 kustomization.yml 文件，如以下列表所示。
- en: Listing 14.15 Configuring the image name and version for the container
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.15 配置容器的镜像名称和版本
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ The name of the container as defined in the Deployment manifest
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Deployment 清单中定义的容器名称
- en: ❷ The new image name for the container (with your GitHub username in lowercase)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 容器的新镜像名称（使用你的 GitHub 用户名的小写形式）
- en: ❸ The new tag for the container
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 容器的新标签
- en: In the next section, I’ll show you how to configure the number of replicas to
    deploy.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向你展示如何配置要部署的副本数量。
- en: 14.3.7 Customizing the number of replicas
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.7 自定义副本数量
- en: Cloud native applications should be highly available, and Catalog Service is
    not. So far we’ve been deploying a single application instance. What happens if
    it crashes or becomes momentarily unavailable due to a high workload? We would
    not be able to use the application anymore. Not very resilient, is it? Among other
    things, a staging environment is a good target for performance and availability
    tests. At a minimum, we should have two instances running. Kustomize provides
    a convenient way to update the number of replicas for a given Pod.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序应该具有高可用性，而 Catalog 服务则不是。到目前为止，我们一直在部署单个应用程序实例。如果它崩溃或由于高负载而暂时不可用，会发生什么？我们将无法再使用该应用程序。这不太具有弹性，对吧？除了其他方面，预发布环境是性能和可用性测试的良好目标。至少，我们应该有两个实例正在运行。Kustomize
    提供了一种方便的方式来更新特定 Pod 的副本数量。
- en: Open the kustomization.yml file in the staging overlay for Catalog Service (kubernetes/
    applications/catalog-service/staging) and configure two replicas for the application.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Catalog 服务（kubernetes/applications/catalog-service/staging）预发布覆盖中的 kustomization.yml
    文件，并配置应用程序的两个副本。
- en: Listing 14.16 Configuring replicas for the Catalog Service container
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.16 配置 Catalog 服务容器的副本
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ The name of the Deployment for which to define the number of replicas
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 要定义副本数量的 Deployment 的名称
- en: ❷ The number of replicas
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 副本数量
- en: It’s finally time to deploy Catalog Service and test the configuration provided
    by the staging overlay. For simplicity, we’ll use the same minikube local cluster
    we have been using so far as the staging environment. If you still have your minikube
    cluster up and running from before, you’re good to go. Otherwise, you can start
    it by running ./create-cluster.sh from polar-deployment/kubernetes/platform/development.
    The script will spin up a Kubernetes cluster and deploy the backing services required
    by Polar Bookshop.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 终于到了部署 Catalog 服务并测试由预发布覆盖提供的配置的时候了。为了简单起见，我们将使用迄今为止一直在使用的相同 minikube 本地集群作为预发布环境。如果你之前还有正在运行的
    minikube 集群，那么你可以直接开始。否则，你可以通过在 polar-deployment/kubernetes/platform/development
    中运行 ./create-cluster.sh 来启动它。该脚本将启动一个 Kubernetes 集群并部署 Polar 书店所需的底层服务。
- en: 'Then open a Terminal window, navigate to the staging overlay folder for Catalog
    Service (applications/catalog-service/staging), and run the following command
    to deploy the application via Kustomize:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开一个终端窗口，导航到 Catalog 服务（applications/catalog-service/staging）的预发布覆盖文件夹，并运行以下命令通过
    Kustomize 部署应用程序：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can monitor the operation’s result via the Kubernetes CLI (kubectl get
    pod -l app=catalog-service) or the Octant GUI (refer to chapter 7 for more information).
    Once the applications are available and ready, we can check the application logs
    using the CLI:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Kubernetes CLI（kubectl get pod -l app=catalog-service）或 Octant GUI（参考第
    7 章了解更多信息）监控操作结果。一旦应用可用并准备就绪，我们可以使用 CLI 检查应用日志：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: One of the first Spring Boot log events will tell you that the staging profile
    is enabled, just like we configured in the staging overlay via a patch.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 的第一个日志事件之一会告诉你预发布配置文件已启用，就像我们在预发布覆盖中通过补丁配置的那样。
- en: 'The application is not exposed outside the cluster, but you can use the port-forwarding
    functionality to forward traffic from your local environment on port 9001 to the
    Service running in the cluster on port 80:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 应用没有在集群外部暴露，但你可以使用端口转发功能将本地环境上的端口 9001 的流量转发到集群中运行的端口 80 的服务：
- en: '[PRE38]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, open a new Terminal window and call the application’s root endpoint:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开一个新的终端窗口并调用应用的根端点：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The result is the customized message we defined in the application-staging.yml
    file for the polar.greeting property. That’s exactly what we were expecting.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们定义在 application-staging.yml 文件中的自定义消息，用于 polar.greeting 属性。这正是我们预期的。
- en: Note It’s worth noticing that if you send a GET request to :9001/books, you’ll
    get an empty list. In staging, we haven’t enabled the testdata profile controlling
    the generation of books at startup time. We want that only in a development or
    test environment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得注意的是，如果你向 :9001/books 发送 GET 请求，你会得到一个空列表。在预发布环境中，我们还没有启用 testdata 配置文件，该配置文件控制启动时书籍的生成。我们希望在开发或测试环境中才启用。
- en: 'The last customization we applied to the staging overlay was the number of
    replicas to deploy. Let’s verify that with the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对预发布覆盖所做的最后一个自定义是部署副本的数量。让我们使用以下命令来验证：
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Kubernetes is designed to ensure the availability of each application. If enough
    resources are available, it will try to deploy the two replicas on two different
    nodes. If one node crashes, the application will still be available on the other
    one. At the same time, Kubernetes takes care of deploying the second instance
    somewhere else to ensure there are always two replicas up and running. You can
    check which node each Pod has been allocated on with kubectl get pod -o wide.
    In our case, the minikube cluster has only one node, so both instances will be
    deployed together.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 设计目的是确保每个应用的可用性。如果资源足够，它将尝试在两个不同的节点上部署两个副本。如果一个节点崩溃，应用仍然可以在另一个节点上可用。同时，Kubernetes
    会负责在其他地方部署第二个实例，以确保始终有两个副本在运行。你可以使用 kubectl get pod -o wide 检查每个 Pod 分配到了哪个节点。在我们的例子中，minikube
    集群只有一个节点，所以两个实例将一起部署。
- en: 'If you’re curious, you can also try to update the application-staging.yml file,
    apply the Kustomization to the cluster again (kubectl apply -k .), and see how
    the Catalog Service Pods are restarted one after the other (*rolling restarts*)
    to load the new ConfigMap with zero downtime. To visualize the sequence of events,
    you can either use Octant or launch this command on a separate Terminal window
    before applying the Kustomization: kubectl get pods -l app=catalog-service --watch.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇，你也可以尝试更新 application-staging.yml 文件，再次将 Kustomization 应用到集群中（kubectl apply
    -k .），并观察 Catalog Service Pods 是如何一个接一个地重启（*滚动重启*）以加载新的 ConfigMap，实现零停机时间。为了可视化事件序列，你可以使用
    Octant 或在应用 Kustomization 之前在另一个终端窗口中运行此命令：kubectl get pods -l app=catalog-service
    --watch。
- en: When you’re done testing the application, you can terminate the port-forwarding
    process with Ctrl-C and delete the cluster with ./destroy-cluster.sh from polar-deployment/kubernetes/platform/development.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成应用的测试后，你可以使用 Ctrl-C 终止端口转发过程，并从 polar-deployment/kubernetes/platform/development
    目录下使用 ./destroy-cluster.sh 删除集群。
- en: Now that you’ve learned the fundamentals of configuring and deploying Spring
    Boot applications in Kustomize, it’s time to go to production. That’s what the
    next chapter is all about.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了在 Kustomize 中配置和部署 Spring Boot 应用的基础知识，是时候进入生产环境了。这正是下一章要讲的内容。
- en: Polar Labs
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Polar Labs
- en: Feel free to apply what you’ve learned in this chapter to all the applications
    in the Polar Bookshop system. You’ll need these updated applications in the next
    chapter, where we’ll deploy everything in production.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将本章学到的知识应用到 Polar 书店系统中的所有应用。你将在下一章需要这些更新后的应用，我们将把所有内容部署到生产环境中。
- en: Disable the Spring Cloud Config client.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 Spring Cloud Config 客户端。
- en: Define a base Kustomization manifest, and update Tilt and the commit stage workflow.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个基本的 Kustomization 清单，并更新 Tilt 和提交阶段工作流程。
- en: Use Kustomize to generate a ConfigMap.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kustomize 生成 ConfigMap。
- en: Configure a staging overlay.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置预发布覆盖层。
- en: You can refer to the Chapter14/14-end folder in the code repository accompanying
    the book to check the final result ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action)).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考书中附带的代码存储库中的 Chapter14/14-end 文件夹来检查最终结果 ([https://github.com/ThomasVitale/cloud-native-spring-in-action](https://github.com/ThomasVitale/cloud-native-spring-in-action))。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A configuration server built with Spring Cloud Config Server can be protected
    with any of the features offered by Spring Security. For example, you can require
    a client to use HTTP Basic authentication to access the configuration endpoints
    exposed by the server.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Cloud Config Server 构建的配置服务器可以通过 Spring Security 提供的任何功能进行保护。例如，您可以要求客户端使用
    HTTP Basic 认证来访问服务器暴露的配置端点。
- en: Configuration data in a Spring Boot application can be reloaded by calling the
    /actuator/refresh endpoint exposed by Spring Boot Actuator.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 应用程序中的配置数据可以通过调用 Spring Boot Actuator 暴露的 /actuator/refresh 端点来重新加载。
- en: To propagate the config refresh operation to other applications in the system,
    you can use Spring Cloud Bus.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将配置刷新操作传播到系统中的其他应用程序，您可以使用 Spring Cloud Bus。
- en: Spring Cloud Config Server offers a Monitor module that exposes a /monitor endpoint
    that code repository providers can call through a webhook whenever a new change
    is pushed to the configuration repository. The result is that all the applications
    affected by the configuration change will be triggered by Spring Cloud Bus to
    reload the configuration. The whole process happens automatically.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server 提供了一个监控模块，该模块暴露了一个 /monitor 端点，代码存储库提供商可以通过 webhook
    在将新更改推送到配置存储库时调用该端点。结果是，所有受配置更改影响的应用程序都将由 Spring Cloud Bus 触发重新加载配置。整个过程是自动发生的。
- en: Managing secrets is a critical task of any software system, and it is dangerous
    when mistakes are made.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理秘密是任何软件系统的关键任务，出错时非常危险。
- en: Spring Cloud Config offers encryption and decryption features for handling secrets
    safely in the configuration repository, using either symmetric or asymmetric keys.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Config 提供了使用对称或非对称密钥对配置存储库中的秘密进行加密和解密的特性，以确保秘密的安全处理。
- en: You can also use secrets management solutions offered by cloud providers like
    Azure, AWS, and Google Cloud and leverage the integration with Spring Boot provided
    by Spring Cloud Azure, Spring Cloud AWS, and Spring Cloud GCP.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用云提供商（如 Azure、AWS 和 Google Cloud）提供的秘密管理解决方案，并利用 Spring Cloud Azure、Spring
    Cloud AWS 和 Spring Cloud GCP 提供的 Spring Boot 集成。
- en: HashiCorp Vault is another option. You can either use it to configure all Spring
    Boot applications directly through the Spring Vault project or make it a backend
    for Spring Cloud Config Server.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault 是另一个选择。您可以使用它通过 Spring Vault 项目直接配置所有 Spring Boot 应用程序，或者将其作为
    Spring Cloud Config Server 的后端。
- en: When Spring Boot applications are deployed to a Kubernetes cluster, you can
    also configure them through ConfigMaps (for non-sensitive configuration data)
    and Secrets (for sensitive configuration data).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 Spring Boot 应用程序部署到 Kubernetes 集群时，您还可以通过 ConfigMaps（用于非敏感配置数据）和 Secrets（用于敏感配置数据）来配置它们。
- en: You can use ConfigMaps and Secrets as a source of values for environment variables
    or mount them as volumes to the container. The latter approach is the preferred
    one and is supported by Spring Boot natively.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 ConfigMaps 和 Secrets 作为环境变量的值源，或将它们作为卷挂载到容器中。后一种方法更受欢迎，并且 Spring Boot
    本地支持。
- en: Secrets are not secret. The data contained within them is not encrypted by default,
    so you shouldn’t put them under version control and include them in your repository.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密并非真正保密。它们包含的数据默认情况下不会被加密，因此您不应将它们放入版本控制中，也不应包含在您的存储库中。
- en: The platform team is responsible for protecting secrets, such as by using the
    Sealed Secrets project to encrypt secrets and make it possible to put them under
    version control.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台团队负责保护秘密，例如，可以使用 Sealed Secrets 项目加密秘密，使其能够放入版本控制中。
- en: Managing several Kubernetes manifests to deploy an application is not very intuitive.
    Kustomize provides a convenient way to manage, deploy, configure, and upgrade
    an application in Kubernetes.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个 Kubernetes 清单以部署应用程序并不直观。Kustomize 提供了一种方便的方式来管理、部署、配置和升级 Kubernetes 中的应用程序。
- en: Among other things, Kustomize provides generators to build ConfigMaps and Secrets,
    and a way to trigger a rolling restart whenever they are updated.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他方面，Kustomize 提供了生成器来构建 ConfigMaps 和 Secrets，并在它们更新时触发滚动重启。
- en: The Kustomize approach to configuration customization is based on the concepts
    of bases and overlays.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize 的配置自定义方法基于基础和覆盖的概念。
- en: Overlays are built on top of base manifests, and any customization is applied
    via patches. You saw how to define patches for customizing environment variables,
    ConfigMaps, container images, and replicas.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Overlays 是基于基础清单构建的，任何自定义都是通过补丁来应用的。您已经看到了如何定义补丁以自定义环境变量、ConfigMaps、容器镜像和副本。
