- en: 19 You call this scripting?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 你这是在调用脚本吗？
- en: So far, you could’ve accomplished everything in this book by using PowerShell’s
    command-line interface. You haven’t had to write a single script. That’s a big
    deal for us, because we see a lot of administrators initially shying away from
    scripting, perceiving it (rightly) as a kind of programming, and feeling (correctly)
    that learning it can sometimes take more time than it’s worth. Hopefully, you’ve
    seen how much you can accomplish in PowerShell without having to become a programmer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以通过使用 PowerShell 的命令行界面完成这本书中的所有内容。您不需要编写任何脚本。这对我们来说是个大问题，因为我们看到很多管理员最初会回避脚本编写，正确地认为它是一种编程，并且正确地感觉到学习它有时可能比它的价值花费更多的时间。希望您已经看到了在
    PowerShell 中不成为程序员也能完成多少事情。
- en: But at this point, you may also be starting to feel that constantly retyping
    the same commands is going to become pretty tedious. You’re right, so in this
    chapter we’re going to dive into PowerShell scripting—but we’re still not going
    to be programming. Instead, we’re going to focus on scripts as little more than
    a way of saving our fingers from unnecessary retyping.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个时候，您可能也开始感觉到不断重新输入相同的命令将会变得相当乏味。您是对的，所以在本章中，我们将深入探讨 PowerShell 脚本编写——但我们仍然不会进行编程。相反，我们将专注于脚本，将其视为一种节省我们手指不必要的重复输入的方法。
- en: 19.1 Not programming, more like batch files
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 不是编程，更像是批处理文件
- en: Most system administrators have, at one point or another, created a command-line
    batch file (which usually has a .bat, .cmd, or .sh filename extension). These
    are nothing more than simple text files (that you can edit with a text editor,
    such as vi) containing a list of commands to be executed in a specific order.
    Technically, you call those commands a *script*, because like a Hollywood script,
    they tell the performer (your computer) exactly what to do and say, and in what
    order to do and say it. But batch files rarely look like programming, in part
    because the cmd.exe shell has a limited language that doesn’t permit incredibly
    complicated scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统管理员在某个时候都创建过命令行批处理文件（通常具有 .bat、.cmd 或 .sh 文件扩展名）。这些文件不过是简单的文本文件（您可以使用文本编辑器，如
    vi 进行编辑），其中包含要按特定顺序执行的命令列表。技术上，您将这些命令称为 *脚本*，因为就像好莱坞剧本一样，它们会告诉表演者（您的计算机）确切要做什么和说什么，以及按什么顺序做和说。但批处理文件很少看起来像编程，部分原因是因为
    cmd.exe 壳有有限的语言，不允许编写极其复杂的脚本。
- en: PowerShell scripts work similarly to Bash or sh scripts. List the commands that
    you want run, and the shell will execute those commands in the order specified.
    You can create a script by copying a command from the host window and pasting
    it into a text editor. We expect you’ll be happier writing scripts with the VS
    Code PowerShell extension, or with a third-party editor of your choice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 脚本的工作方式与 Bash 或 sh 脚本类似。列出您想要运行的命令，然后 shell 将按指定顺序执行这些命令。您可以通过从主机窗口复制命令并将其粘贴到文本编辑器中来创建脚本。我们预计您会更喜欢使用
    VS Code PowerShell 扩展或您选择的第三方编辑器编写脚本。
- en: VS Code, in fact, makes scripting practically indistinguishable from using the
    shell interactively. When using VS Code, you type the command or commands you
    want to run, and then click the Run button in the toolbar to execute those commands.
    Click Save, and you’ve created a script without having to copy and paste anything
    at all.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，VS Code 使脚本编写几乎与交互式使用 shell 无可区分。当使用 VS Code 时，您输入想要运行的命令或命令，然后点击工具栏中的运行按钮来执行这些命令。点击保存，您就创建了一个脚本，而无需复制和粘贴任何内容。
- en: Heads UP Just a reminder that this chapter is very Windows focused as far as
    the examples are concerned.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Heads UP 只是一个提醒，就示例而言，这一章非常侧重于 Windows 系统。
- en: 19.2 Making commands repeatable
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 使命令可重复
- en: The idea behind PowerShell scripts is, first and foremost, to make it easier
    to run a given command over and over, without having to manually retype it every
    time. That being the case, we need to come up with a command that you’ll want
    to run over and over again, and use that as an example throughout this chapter.
    We want to make this decently complex, so we’ll start with something from CIM
    and add in some filtering, sorting, and other stuff.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 脚本背后的理念首先是使重复运行给定命令变得更容易，而不必每次都手动重新输入。既然如此，我们需要想出一个您会想反复运行的命令，并在本章中用这个例子。我们希望使这个例子相当复杂，所以我们将从
    CIM 开始，然后添加一些过滤、排序和其他内容。
- en: 'At this point, we’re going to switch to using VS Code instead of the normal
    console window, because VS Code will make it easier for us to migrate our command
    into a script. Frankly, VS Code makes it easier to type complex commands, because
    you get a full-screen editor instead of working on a single line within the console
    host. Here’s our command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将切换到使用VS Code而不是正常的控制台窗口，因为VS Code将使我们更容易将我们的命令迁移到脚本中。坦白说，VS Code使得输入复杂的命令更容易，因为你得到的是一个全屏编辑器，而不是在控制台宿主中工作在单行内。这是我们的命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip Remember, you can use `name` instead of `label`, and either can be abbreviated
    to a single character, `n` or `l`. But it’s easy for a lowercase *L* to look like
    the number 1, so be careful!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 记住，你可以使用`name`代替`label`，两者都可以缩写为单个字符，`n`或`l`。但小写的*L*看起来可能像数字1，所以请小心！
- en: Figure 19.1 shows how we enter this into VS Code. Notice that we select the
    two-pane layout by using the toolbar button on the far right of the layout choices.
    Also notice that we format our command so that each physical line ends in either
    a pipe character or a comma. By doing so, we’re forcing the shell to recognize
    these multiple lines as a single, one-line command. You could do the same thing
    in the console host, but this formatting is especially effective because it makes
    the command a lot easier to read. Also notice that we use full cmdlet names and
    parameter names and that we specify every parameter name rather than using positional
    parameters. All of that will make our script easier to read and follow, either
    for someone else or in the future when we might have forgotten our original intent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1展示了我们如何在VS Code中输入这个命令。注意，我们通过使用布局选择最右侧的工具栏按钮来选择双栏布局。也请注意，我们格式化我们的命令，使得每行以管道字符或逗号结束。通过这样做，我们迫使shell将这些多行识别为单个单行命令。你可以在控制台宿主中做同样的事情，但这种格式化特别有效，因为它使得命令更容易阅读。也请注意，我们使用完整的cmdlet名称和参数名称，并且我们指定了每个参数名称而不是使用位置参数。所有这些都会使我们的脚本更容易阅读和跟踪，无论是对于别人还是在我们可能已经忘记了原始意图的将来。
- en: '![](Images/CH19_F01_Plunk.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH19_F01_Plunk.png)'
- en: Figure 19.1 Entering and running a command in VS Code using the two-pane layout
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1 在VS Code中使用双栏布局输入和运行命令
- en: 'We run the command by clicking the Run toolbar icon (you could also press F5)
    to test it, and our output shows that it’s working perfectly. Here’s a neat trick
    in VS Code: you can highlight a portion of your command and press F8 to run just
    the highlighted portion. Because we’ve formatted the command so that there’s one
    distinct command per physical line, that makes it easy for us to test our command
    bit by bit. We could highlight and run the first line independently. If we were
    satisfied with the output, we could highlight the first and second lines and run
    them. If that worked as expected, we could run the whole command.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过点击运行工具栏图标（你也可以按F5键）来运行命令进行测试，我们的输出显示它运行得非常完美。在VS Code中有一个小技巧：你可以突出显示命令的一部分并按F8键来只运行突出显示的部分。因为我们已经格式化命令，使得每行只有一个明确的命令，这使得我们可以逐个测试我们的命令。我们可以独立地突出显示并运行第一行。如果我们对输出满意，我们可以突出显示第一行和第二行并运行它们。如果一切按预期工作，我们可以运行整个命令。
- en: At this point, we can save the command—and we can start calling it a *script*
    now. We’ll save it as Get-DiskInventory.ps1\. We like giving scripts cmdlet-style
    verb-noun names. You can see how this script is starting to look and work a lot
    like a cmdlet, so it makes sense to give it a cmdlet-style name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以保存这个命令——现在我们可以开始称它为*脚本*了。我们将它保存为Get-DiskInventory.ps1。我们喜欢给脚本起类似于cmdlet风格的动词-名词名称。你可以看到这个脚本开始看起来和运行得越来越像cmdlet，所以给它一个cmdlet风格的名称是有意义的。
- en: 19.3 Parameterizing commands
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 命令参数化
- en: When you think about running a command over and over, you might realize that
    some portion of the command will have to change from time to time. For example,
    suppose you want to give Get-DiskInventory.ps1 to some of your colleagues, who
    might be less experienced in using PowerShell. It’s a complex, hard-to-type command,
    and they might appreciate having it bundled into an easier-to-run script. But,
    as written, the script runs only against the local computer. You can certainly
    imagine that some of your colleagues might want to get a disk inventory from one
    or more remote computers instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑反复运行一个命令时，你可能会意识到命令的一部分可能需要不时地更改。例如，假设你想将 Get-DiskInventory.ps1 分发给一些不太熟悉
    PowerShell 的同事。这是一个复杂且难以输入的命令，他们可能会欣赏将其打包到一个更容易运行的脚本中。但是，按照目前的编写方式，脚本只针对本地计算机运行。你可以想象，你的同事中有些人可能想要从一台或多台远程计算机获取磁盘库存。
- en: One option is to have them open the script and change the `-computername` parameter’s
    value. But it’s entirely possible that they wouldn’t be comfortable doing so,
    and there’s a chance they’ll change something else and break the script entirely.
    It would be better to provide a formal way for them to pass in a different computer
    name (or a set of names). At this stage, you need to identify the things that
    might need to change when the command is run, and replace those things with variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是让他们打开脚本并更改 `-computername` 参数的值。但是，他们可能完全不愿意这样做，而且有可能他们会更改其他内容，从而完全破坏脚本。更好的做法是提供一个正式的方式来让他们传递不同的计算机名称（或一组名称）。在这个阶段，你需要确定在运行命令时可能需要更改的事物，并将这些事物替换为变量。
- en: We’ll set the computer name variable to a static value for now so that we can
    still test the script. Here’s our revised script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将计算机名称变量设置为静态值，以便我们仍然可以测试脚本。以下是我们的修改后的脚本。
- en: Listing 19.1 Get-DiskInventory.ps1, with a parameterized command (Windows only)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.1 Get-DiskInventory.ps1，带有参数化命令（仅限 Windows）
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Sets a new variable
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置一个新变量
- en: ❷ Breaks the line with a backtick
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用反引号断行
- en: ❸ Uses a variable
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用变量
- en: 'We do three things here, two of which are functional and one of which is purely
    cosmetic:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了三件事，其中两件是功能性的，一件是纯粹的美观性的：
- en: We add a variable, `$computername`, and set it equal to `localhost`. We’ve noticed
    that most PowerShell commands that accept a computer name use the parameter name
    `-computername`, and we want to duplicate that convention, which is why we chose
    the variable name that we did.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个变量 `$computername`，并将其设置为 `localhost`。我们注意到大多数接受计算机名称的 PowerShell 命令使用参数名称
    `-computername`，我们希望重复使用这个约定，这就是我们选择这个变量名称的原因。
- en: We replace the value for the `-computername` parameter with our variable. Right
    now, the script should run exactly the same as it did before (and we tested to
    make sure it does), because we put `localhost` into the `$computername` variable.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `-computername` 参数的值替换为我们的变量。目前，脚本应该与之前完全相同（我们已经测试过以确保如此），因为我们把 `localhost`
    放入了 `$computername` 变量中。
- en: We add a backtick after the `-computername` parameter and its value. This escapes,
    or takes away, the special meaning of the carriage return at the end of the line.
    That tells PowerShell that the next physical line is part of this same command.
    You don’t need to do that when the line ends in a pipe character or a comma, but
    in order to fit the code within this book, we needed to break the line before
    the pipe character. This will work only if the backtick character is the last
    thing on the line!
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `-computername` 参数及其值之后添加了一个反引号。这会取消，或去除，行尾换行符的特殊含义。这告诉 PowerShell 下一个物理行是同一命令的一部分。当行以管道字符或逗号结束时，你不需要这样做，但为了将代码放入本书中，我们需要在管道字符之前断行。这将仅当反引号字符是行上的最后一个字符时才有效！
- en: Listing 19.2 Get-FilePath.ps1, with a parameterized command (cross-platform)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.2 Get-FilePath.ps1，带有参数化命令（跨平台）
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Sets a new variable
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置一个新变量
- en: ❷ Breaks the line after a pipe and uses a variable
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在管道符号后断行并使用变量
- en: 'We do three things here, two of which are functional and one of which is purely
    cosmetic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了三件事，其中两件是功能性的，一件是纯粹的美观性的：
- en: We add a variable, `$filepath`, and set it equal to `/usr/bin`. We’ve noticed
    that the `Get-ChildItem` command accepts a path parameter name `-path`, and we
    want to duplicate that convention, which is why we chose the variable name that
    we did.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个变量 `$filepath`，并将其设置为 `/usr/bin`。我们注意到 `Get-ChildItem` 命令接受一个路径参数名称 `-path`，我们希望重复使用这个约定，这就是我们选择这个变量名称的原因。
- en: We replace the value for the `-path` parameter with our variable. Right now,
    the script should run exactly the same as it did before (and we tested to make
    sure it does), because we left the `path` parameter blank, and it runs in the
    current working directory.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `-path` 参数的值替换为我们自己的变量。目前，脚本应该与之前运行完全相同（我们已经测试过以确保如此），因为我们留空了 `path` 参数，它将在当前工作目录中运行。
- en: If you need to break up your command into multiple lines, the best way to do
    this is to put a line break after the pipe symbol. PowerShell knows that if there
    is nothing next to the pipe symbol, then the next line of code will be a continuation
    of the previous line. This can be very helpful if you have a very long pipeline.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要将命令分成多行，最好的方法是在管道符号后放置一个换行符。PowerShell 知道，如果管道符号旁边没有内容，则下一行代码将是上一行的延续。如果您有一个非常长的管道，这可能会非常有帮助。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Shows our original command
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示我们的原始命令
- en: ❷ Breaks the command at a pipe
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在管道符号处中断命令
- en: ❸ Breaks the command with a backtick
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在反引号处中断命令
- en: TIP After you make any changes, run your script to validate it is still working.
    We always do that after making any kind of change to ensure we haven’t introduced
    a random typo or other error.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 在您做出任何更改后，运行您的脚本以验证它仍然可以正常工作。我们总是在做出任何类型的更改后这样做，以确保我们没有引入随机的打字错误或其他错误。
- en: 19.4 Creating a parameterized script
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4 创建参数化脚本
- en: Now that we’ve identified the elements of the script that might change from
    time to time, we need to provide a way for someone else to specify new values
    for those elements. We need to take that hardcoded `$computername` variable and
    turn it into an input parameter. PowerShell makes this easy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了脚本中可能随时间变化的部分，我们需要提供一个方法让其他人可以指定这些元素的新值。我们需要将硬编码的 `$computername` 变量转换为输入参数。PowerShell
    使这变得很容易。
- en: Listing 19.3 Get-DiskInventory.ps1, with an input parameter
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.3 Get-DiskInventory.ps1，带有输入参数
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Uses a param block
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 param 块
- en: All we did was add a `Param()` block around our variable declaration. This defines
    `$computername` as a parameter and specifies that `localhost` is the default value
    to be used if the script is run without a computer name being specified. You don’t
    have to provide a default value, but we like to do so when there’s a reasonable
    value that we can think of.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是在我们变量的声明周围添加了一个 `Param()` 块。这定义了 `$computername` 为一个参数，并指定如果脚本在没有指定计算机名称的情况下运行，则使用
    `localhost` 作为默认值。您不必提供默认值，但我们喜欢在可以想到合理值的情况下这样做。
- en: 'All parameters declared in this fashion are both named and positional, meaning
    that we can now run the script from the command line in any of these ways:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明的所有参数都是命名和位置参数，这意味着我们现在可以从命令行以以下任何一种方式运行脚本：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first instance, we use the parameter positionally, providing a value
    but not the parameter name. In the second and third instances, we specify the
    parameter name, but in the third instance we abbreviate that name in keeping with
    PowerShell’s normal rules for parameter name abbreviation. Note that in all three
    cases, we have to specify a path (`.\`, which is the current folder) to the script,
    because the shell won’t automatically search the current directory to find the
    script.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们以位置方式使用参数，提供了值但没有参数名称。在第二种和第三种情况下，我们指定了参数名称，但在第三种情况下，我们根据 PowerShell
    的正常参数名称缩写规则缩短了该名称。请注意，在这三种情况下，我们必须指定脚本的路径（`.\`，即当前文件夹），因为外壳不会自动搜索当前目录以查找脚本。
- en: You can specify as many parameters as you need to by separating them with commas.
    For example, suppose that we want to also parameterize the filter criteria. Right
    now, it’s retrieving only logical disks of type 3, which represents fixed disks.
    We could change that to a parameter, as in the following listing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过用逗号分隔来指定所需的所有参数。例如，假设我们还想参数化筛选条件。目前，它只检索类型为 3 的逻辑磁盘，这代表固定磁盘。我们可以将其更改为参数，如下所示。
- en: Listing 19.4 Get-DiskInventory.ps1, with an additional parameter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.4 Get-DiskInventory.ps1，带有附加参数
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Specifies an additional parameter
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定附加参数
- en: ❷ Uses a parameter
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用参数
- en: 'Notice that we take advantage of PowerShell’s ability to replace variables
    with their values inside double quotation marks (you learned about that trick
    in chapter 16). We can run this script in any of the three original ways, although
    we could also omit either parameter if we wanted to use the default value for
    it. Here are some permutations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们利用了 PowerShell 在双引号内替换变量的值的能力（你可以在第 16 章中了解到这个技巧）。我们可以用这三种原始方式中的任何一种来运行这个脚本，尽管我们也可以省略任何一个参数，如果我们想使用它的默认值。以下是一些排列组合：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first instance, we specify both parameters positionally, in the order
    in which they’re declared within the `Param()` block. In the second case, we specify
    abbreviated parameter names for both. The third time, we omit `-drivetype` entirely,
    using the default value of `3`. In the last instance, we leave off `-computername`,
    using the default value of `localhost`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们按参数在 `Param()` 块中声明的顺序位置指定了两个参数。在第二种情况下，我们为两个参数指定了缩写参数名称。第三次，我们完全省略了
    `-drivetype`，使用默认值 `3`。在最后一种情况下，我们省略了 `-computername`，使用默认值 `localhost`。
- en: 19.5 Documenting your script
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.5 记录你的脚本
- en: Only a truly mean person would create a useful script and not tell anyone how
    to use it. Fortunately, PowerShell makes it easy to add help into your script,
    using comments. You’re welcome to add typical programming-style comments to your
    scripts, but if you’re using full cmdlet and parameter names, sometimes your script’s
    operation will be obvious. By using a special comment syntax, however, you can
    provide help that mimics PowerShell’s own help files. This listing shows what
    we’ve added to our script.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只有真正自私的人才会创建一个有用的脚本却不告诉任何人如何使用它。幸运的是，PowerShell 通过使用注释使将帮助信息添加到脚本变得容易。你可以在脚本中添加典型的编程风格注释，但如果你使用完整的
    cmdlet 和参数名称，有时脚本的操作就会很明显。然而，通过使用特殊的注释语法，你可以提供类似于 PowerShell 自身帮助文件的帮助信息。以下列表显示了我们对脚本所做的添加。
- en: Listing 19.5 Adding help to Get-DiskInventory.ps1
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.5 向 Get-DiskInventory.ps1 添加帮助
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: PowerShell ignores anything on a line that follows a `#` symbol, meaning that
    `#` designates a line as a comment. We can also use the `<#` `#>` block comment
    syntax instead, because we have several lines of comments and want to avoid starting
    each line with a separate `#` character.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 忽略任何跟随 `#` 符号的行，这意味着 `#` 将一行标记为注释。我们还可以使用 `<#` `#>` 块注释语法，因为我们有多个注释行，并且想避免每行都使用单独的
    `#` 字符。
- en: Now we can drop to the normal console host and ask for help by running `help`
    `.\Get-DiskInventory.ps1` (again, you have to provide a path because this is a
    script and not a built-in cmdlet). Figure 19.2 shows the results, which proves
    that PowerShell is reading those comments and creating a standard help display.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以切换到正常的控制台宿主，并通过运行 `help` `.\Get-DiskInventory.ps1` 来请求帮助（再次提醒，你必须提供路径，因为这是一个脚本而不是内置的
    cmdlet）。图 19.2 展示了结果，这证明了 PowerShell 正在读取这些注释并创建标准的帮助显示。
- en: '![](Images/CH19_F02_Plunk.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH19_F02_Plunk.png)'
- en: Figure 19.2 Viewing the help by using the normal `help` command
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 使用正常的 `help` 命令查看帮助
- en: We can even run `help .\Get-DiskInventory` `-full` to get full help, including
    parameter information in our example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以运行 `help .\Get-DiskInventory` `-full` 来获取完整的帮助，包括我们示例中的参数信息。
- en: These special comments are called *comment-based help*. There are several keywords
    in addition to `.DESCRIPTION`, `.SYNOPSIS`, and the others we’ve used. For a full
    list, run `help about_comment_based_help` in PowerShell.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊的注释被称为 *基于注释的帮助*。除了 `.DESCRIPTION`、`.SYNOPSIS` 以及我们之前使用的其他关键字之外，还有一些其他关键字。要获取完整的列表，请在
    PowerShell 中运行 `help about_comment_based_help`。
- en: 19.6 One script, one pipeline
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.6 一个脚本，一个管道
- en: 'We normally tell folks that anything in a script will run exactly as if you
    manually typed it into the shell, or if you copied the script to the clipboard
    and pasted it into the shell. That’s not entirely true, though. Consider this
    simple script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常告诉人们，脚本中的任何内容都会像你手动输入到 shell 中一样运行，或者如果你将脚本复制到剪贴板并将其粘贴到 shell 中。但这并不完全正确。考虑这个简单的脚本：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just two commands. But what happens if you were to type those commands into
    the shell manually, pressing Enter after each?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只需两个命令。但如果你手动将这些命令输入到 shell 中，并在每个命令后按 Enter 键会发生什么？
- en: Try it Now Run these commands on your own to see the results. They create fairly
    long output that won’t fit well within this book or even in a screenshot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 在你的机器上运行这些命令以查看结果。它们会生成相当长的输出，不适合在这个书中展示，甚至不适合在屏幕截图上展示。
- en: 'When you run the commands individually, you’re creating a new pipeline for
    each command. At the end of each pipeline, PowerShell looks to see what needs
    to be formatted and creates the tables that you undoubtedly saw. The key here
    is that *each command runs in a separate pipeline*. Figure 19.3 illustrates this:
    two completely separate commands, two individual pipelines, two formatting processes,
    and two different-looking sets of results.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你单独运行命令时，你为每个命令创建一个新的管道。在每个管道的末尾，PowerShell会查看需要格式化的内容并创建你无疑已经看到的表格。关键是*每个命令都在单独的管道中运行*。图19.3说明了这一点：两个完全独立的命令、两个单独的管道、两个格式化过程和两组不同的结果。
- en: '![](Images/CH19_F03_Plunk.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH19_F03_Plunk.png)'
- en: Figure 19.3 Two commands, two pipelines, and two sets of output in a single
    console window
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3 单个控制窗口中的两个命令、两个管道和两组输出
- en: 'You may think we’re crazy for taking so much time to explain something that
    probably seems obvious, but it’s important. Here’s what happens when you run those
    two commands individually:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我们花这么多时间解释显然的事情很疯狂，但这是很重要的。当你单独运行这两个命令时，会发生以下情况：
- en: You run `Get-Process`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你运行`Get-Process`。
- en: The command places `Process` objects into the pipeline.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令将`Process`对象放入管道。
- en: The pipeline ends in `Out-Default`, which picks up the objects.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道以`Out-Default`结束，它拾取对象。
- en: '`Out-Default` passes the objects to `Out-Host`, which calls on the formatting
    system to produce text output (you learned about this in chapter 11).'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Default`将对象传递给`Out-Host`，它调用格式化系统以产生文本输出（你已在第11章中学过）。'
- en: The text output appears on the screen.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本输出显示在屏幕上。
- en: You run `Get-UpTime`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你运行`Get-UpTime`。
- en: The command places `TimeSpan` objects into the pipeline.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令将`TimeSpan`对象放入管道。
- en: The pipeline ends in `Out-Default`, which picks up the objects.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道以`Out-Default`结束，它拾取对象。
- en: '`Out-Default` passes the objects to `Out-Host`, which calls on the formatting
    system to produce text output.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Default`将对象传递给`Out-Host`，它调用格式化系统以产生文本输出。'
- en: The text output appears on the screen.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本输出显示在屏幕上。
- en: So you’re now looking at a screen that contains the results from two commands.
    We want you to put those two commands into a script file. Name it Test.ps1 or
    something simple. Before you run the script, though, copy those two commands onto
    the clipboard. In your editor, you can highlight both lines of text and press
    Ctrl-C to get them onto the clipboard.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你现在看到的是一个包含两个命令结果的屏幕。我们希望你将这两个命令放入一个脚本文件中。命名为Test.ps1或其他简单的名字。在你运行脚本之前，将这些两个命令复制到剪贴板。在你的编辑器中，你可以突出显示这两行文本并按Ctrl-C将它们复制到剪贴板。
- en: With those commands on the clipboard, go to the PowerShell console host and
    press Enter. That pastes the commands from the clipboard into the shell. They
    should execute exactly the same way, because the carriage returns also get pasted.
    Once again, you’re running two distinct commands in two separate pipelines.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在剪贴板上有了这些命令后，转到PowerShell控制台宿主并按Enter。这将从剪贴板粘贴命令到shell中。它们应该以完全相同的方式执行，因为换行符也被粘贴了。再次强调，你正在两个不同的管道中运行两个不同的命令。
- en: Now go back to your editor and run the script. Different results, right? Why
    is that?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到你的编辑器并运行脚本。结果不同，对吧？为什么？
- en: 'In PowerShell, every command executes within a single pipeline, and that includes
    scripts. Within a script, any command that produces pipeline output will be writing
    to a single pipeline: the one that the script itself is running in. Take a look
    at figure 19.4.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，每个命令都在单个管道中执行，包括脚本。在脚本内部，任何产生管道输出的命令都将写入单个管道：脚本本身运行的管道。看看图19.4。
- en: '![](Images/CH19_F04_Plunk.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH19_F04_Plunk.png)'
- en: Figure 19.4 All commands within a script run within that script’s single pipeline.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 脚本中的所有命令都在该脚本的单个管道中运行。
- en: 'We’ll try to explain what happens:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试解释发生了什么：
- en: The script runs `Get-Process`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本运行`Get-Process`。
- en: The command places `Process` objects into the pipeline.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令将`Process`对象放入管道。
- en: The script runs `Get-UpTime`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本运行`Get-UpTime`。
- en: The command places `TimeSpan` objects into the pipeline.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令将`TimeSpan`对象放入管道。
- en: The pipeline ends in `Out-Default`, which picks up both kinds of objects.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道以`Out-Default`结束，它拾取两种类型的对象。
- en: '`Out-Default` passes the objects to `Out-Host`, which calls on the formatting
    system to produce text output.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Out-Default`将对象传递给`Out-Host`，它调用格式化系统以产生文本输出。'
- en: Because the `Process` objects are first, the shell’s formatting system selects
    a format appropriate to processes. That’s why they look normal. But then the shell
    runs into the `TimeSpan` objects. It can’t produce a whole new table at this point,
    so it winds up producing a list.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `Process` 对象优先，shell 的格式化系统会选择适合进程的格式。这就是为什么它们看起来很正常。但随后 shell 遇到了 `TimeSpan`
    对象。此时它无法生成一个全新的表格，所以最终它生成了一个列表。
- en: The text output appears on the screen.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本输出会显示在屏幕上。
- en: 'This different output occurs because the script writes two kinds of objects
    to a single pipeline. This is the important difference between putting commands
    into a script and running them manually: within a script, you have only one pipeline
    to work with. Normally, your scripts should strive to output only one kind of
    object so that PowerShell can produce sensible text output.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不同的输出发生是因为脚本将两种类型的对象写入单个管道。这是将命令放入脚本和手动运行它们之间的重要区别：在脚本中，你只有一个管道可以操作。通常，你的脚本应该努力输出一种类型的对象，以便
    PowerShell 可以生成合理的文本输出。
- en: 19.7 A quick look at scope
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.7 快速了解作用域
- en: The last topic we need to visit is *scope*. Scopes are a form of container for
    certain types of PowerShell elements, primarily aliases, variables, and functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的最后一个主题是 *作用域*。作用域是某些 PowerShell 元素（主要是别名、变量和函数）的一种容器形式。
- en: The shell itself is the top-level scope and is called the *global scope*. When
    you run a script, a new scope is created around that script, and it’s called the
    *script scope*. The script scope is a subsidiary—or a *child—*of the global scope.
    Functions also get their own *private scope*, which we will cover later in the
    book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: shell 本身是顶级作用域，被称为 *全局作用域*。当你运行一个脚本时，会围绕该脚本创建一个新的作用域，这被称为 *脚本作用域*。脚本作用域是全局作用域的子级——或者称为
    *子作用域*。函数也有它们自己的 *私有作用域*，我们将在本书后面的章节中介绍。
- en: Figure 19.5 illustrates these scope relationships, with the global scope containing
    its children, and those containing their own children, and so forth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.5 展示了这些作用域关系，其中全局作用域包含其子级，这些子级又包含它们自己的子级，依此类推。
- en: '![](Images/CH19_F05_Plunk.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH19_F05_Plunk.png)'
- en: Figure 19.5 Global, script, and function (private) scopes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.5 全局、脚本和函数（私有）作用域
- en: 'A scope lasts only as long as needed to execute whatever is in the scope. The
    global scope exists only while PowerShell is running, a script scope exists only
    while that script is running, and so forth. When whatever it is stops running,
    the scope vanishes, taking everything inside with it. PowerShell has specific—and
    sometimes confusing—rules for scoped elements, such as aliases, variables, and
    functions, but the main rule is this: If you try to access a scoped element, PowerShell
    sees whether it exists within the current scope. If it doesn’t, PowerShell sees
    whether it exists in the current scope’s parent. It continues going up the relationship
    tree until it gets to the global scope.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域只存在于执行作用域内内容的需要时间内。全局作用域只存在于 PowerShell 运行期间，脚本作用域只存在于脚本运行期间，依此类推。当任何内容停止运行时，作用域就会消失，其中的一切也随之消失。PowerShell
    对作用域元素（如别名、变量和函数）有特定的——有时是令人困惑的——规则，但主要规则是这样的：如果你尝试访问一个作用域元素，PowerShell 会查看它是否存在于当前作用域中。如果不存在，PowerShell
    会查看它是否存在于当前作用域的父级中。它会继续向上遍历关系树，直到到达全局作用域。
- en: TIP To get the proper results, it’s important that you follow these steps carefully
    and precisely.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：为了获得正确的结果，仔细且精确地遵循这些步骤非常重要。
- en: 'Let’s see this in action. Follow these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作。按照以下步骤进行：
- en: Close any PowerShell or PowerShell editor windows you may have open so that
    you can start from scratch.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭你可能打开的任何 PowerShell 或 PowerShell 编辑器窗口，以便你可以从头开始。
- en: Open a new PowerShell window and a new VS Code window.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 PowerShell 窗口和一个新的 VS Code 窗口。
- en: 'In VS Code, create a script that contains one line: `Write` `$x`.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中创建一个包含一行代码的脚本：`Write` `$x`。
- en: Save the script as C:\Scope.ps1.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本保存为 C:\Scope.ps1。
- en: In the regular PowerShell window, run the script with C:\Scope.ps1\. You shouldn’t
    see any output. When the script runs, a new scope is created for it. The `$x`
    variable doesn’t exist in that scope, so PowerShell goes to the parent scope—the
    global scope—to see whether `$x` exists there. It doesn’t exist there, either,
    so PowerShell decides that `$x` is empty and writes that (meaning, nothing) as
    the output.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在常规 PowerShell 窗口中，运行脚本 C:\Scope.ps1。你不应该看到任何输出。当脚本运行时，会为它创建一个新的作用域。`$x` 变量在那个作用域中不存在，所以
    PowerShell 会去父级作用域——全局作用域——查看 `$x` 是否存在那里。它也不存在那里，所以 PowerShell 决定 `$x` 是空的，并将这个（意味着，没有内容）作为输出写入。
- en: In the normal PowerShell window, run `$x` `=` `4`. Then run C:\Scope.ps1 again.
    This time, you should see `4` as the output. The variable `$x` still isn’t defined
    in the script scope, but PowerShell is able to find it in the global scope, so
    the script uses that value.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正常的 PowerShell 窗口中，运行 `$x` `=` `4`。然后再次运行 C:\Scope.ps1。这次，你应该看到输出为 `4`。变量 `$x`
    仍然没有在脚本作用域中定义，但 PowerShell 能够在全球作用域中找到它，所以脚本使用了那个值。
- en: In VS Code, add `$x` `=` `10` to the top of the script (before the existing
    `Write` command), and save the script.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，将 `$x` `=` `10` 添加到脚本顶部（在现有的 `Write` 命令之前），并保存脚本。
- en: In the normal PowerShell window, run C:\Scope.ps1 again. This time, you’ll see
    `10` as the output. That’s because `$x` is defined within the script scope, and
    the shell doesn’t need to look in the global scope. Now run `$x` in the shell.
    You’ll see `4`, proving that the value of `$x` within the script scope doesn’t
    affect the value of `$x` within the global scope.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正常的 PowerShell 窗口中，再次运行 C:\Scope.ps1。这次，你会看到输出为 `10`。这是因为 `$x` 在脚本作用域内定义，shell
    不需要在全球作用域中查找。现在在 shell 中运行 `$x`。你会看到 `4`，这证明了脚本作用域内 `$x` 的值不会影响全局作用域内 `$x` 的值。
- en: One important concept here is that when a scope defines a variable, alias, or
    function, that scope loses access to any variables, aliases, or functions having
    the same name in a parent scope. The locally defined element will always be the
    one PowerShell uses. For example, if you put `New-Alias Dir` `Get-Service` into
    a script, then within that script the alias `Dir` will run `Get-Service` instead
    of the usual `Get-ChildItem`. (In reality, the shell probably won’t let you do
    that, because it protects the built-in aliases from being redefined.) By defining
    the alias within the script’s scope, you prevent the shell from going to the parent
    scope and finding the normal, default `Dir`. Of course, the script’s redefinition
    of `Dir` will last only for the execution of that script, and the default `Dir`
    defined in the global scope will remain unaffected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要概念是，当一个作用域定义了一个变量、别名或函数时，该作用域将失去对父作用域中具有相同名称的任何变量、别名或函数的访问。本地定义的元素总是
    PowerShell 使用的。例如，如果你在脚本中放入 `New-Alias Dir Get-Service`，那么在这个脚本中，别名 `Dir` 将运行
    `Get-Service` 而不是通常的 `Get-ChildItem`。（实际上，shell 可能不会让你这样做，因为它保护内置别名不被重新定义。）通过在脚本的作用域中定义别名，你防止
    shell 前往父作用域并找到正常的默认 `Dir`。当然，脚本对 `Dir` 的重新定义只会持续到该脚本的执行，全局作用域中定义的默认 `Dir` 将保持不受影响。
- en: It’s easy to let this scope stuff confuse you. You can avoid confusion by never
    relying on anything that’s in any scope other than the current one. So before
    you try to access a variable within a script, make sure you’ve already assigned
    it a value within that same scope. Parameters in a `Param()` block are one way
    to do that, and there are many other ways to put values and objects into a variable.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易让这种作用域的东西让你感到困惑。你可以通过从不依赖当前作用域之外的任何内容来避免困惑。所以在你尝试在脚本中访问一个变量之前，确保你已经在相同的作用域内给它赋了一个值。`Param()`
    块中的参数是这样做的一种方式，还有许多其他方式可以将值和对象放入变量中。
- en: 19.8 Lab
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.8 实验室
- en: Note For this lab, you need any computer running Windows 10 or Server 2019 with
    PowerShell v7 or later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验室，你需要任何运行 Windows 10 或 Server 2019 且具有 PowerShell v7 或更高版本的计算机。
- en: 'The following command is for you to add to a script. You should first identify
    any elements that should be parameterized, such as the computer name. Your final
    script should define the parameter, and you should create comment-based help within
    the script. Run your script to test it, and use the `Help` command to make sure
    your comment-based help works properly. Don’t forget to read the help files referenced
    within this chapter for more information. Here’s the command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令是你要添加到脚本中的。你应该首先确定任何应该参数化的元素，例如计算机名。你的最终脚本应该定义参数，并在脚本中创建基于注释的帮助。运行你的脚本以测试它，并使用
    `Help` 命令确保你的基于注释的帮助正常工作。不要忘记阅读本章中引用的帮助文件以获取更多信息。以下是命令：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s a hint: At least two pieces of information need to be parameterized.
    This command is intended to list all drives that have less than a given amount
    of free disk space. Obviously, you won’t always want to target `localhost` (we’re
    using the PowerShell equivalent of `%computername%` in our example), and you might
    not want 10% (that is, .1) to be your free-space threshold. You could also choose
    to parameterize the drive type (which is 3 here), but for this lab, leave that
    hardcoded with the value `3`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个提示：至少需要参数化两块信息。这个命令的目的是列出所有小于给定空闲磁盘空间的驱动器。显然，你并不总是想针对`localhost`（在我们的例子中，我们使用PowerShell的`%computername%`），你可能不想将10%（即.1）作为你的空闲空间阈值。你也可以选择参数化驱动器类型（在这里是3），但在这个实验中，请将其硬编码为值`3`。
- en: 19.9 Lab answer
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.9 实验室答案
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
