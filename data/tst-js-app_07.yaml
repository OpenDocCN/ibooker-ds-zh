- en: 5 Advanced backend testing techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 高级后端测试技术
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Eliminating nondeterminism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除非确定性
- en: Techniques to running backend tests concurrently
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行后端测试的并发技术
- en: How to reduce costs while preserving quality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在保持质量的同时降低成本
- en: Not even the most delectable cheesecake in the world is viable for a bakery
    if its margin profits are too small. If you’re making a cent on each slice, it
    will be challenging to have a successful business.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是世界上最美味的芝士蛋糕，如果其利润率太小，对面包店来说也是不可行的。如果你每片蛋糕只能赚一美分，那么经营成功将是一项挑战。
- en: Additionally, for you to build a successful bakery, you must be able to bake
    flawless recipes consistently. Otherwise, if half of your macaroon batches aren’t
    sellable, your only result will be a financial loss.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了建立一个成功的面包店，你必须能够持续地烘焙出无瑕疵的食谱。否则，如果你的杏仁小圆饼批次有一半无法出售，你唯一的结果就是经济损失。
- en: Similarly, if your tests’ costs are too high because they take too long to run
    or because they’re too difficult to maintain, it will be challenging to build
    a successful software company.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你的测试成本过高，因为它们运行时间过长或维护难度过大，那么建立一家成功的软件公司将会很具挑战性。
- en: Yet, for these quick and easy-to-update tests to be useful, they must be reliable
    and robust. **If you can’t trust your tests, it doesn’t matter how quickly they
    run or how easy to update they are.**
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这些快速且易于更新的测试变得有用，它们必须可靠且稳健。**如果你不能信任你的测试，那么它们运行得多快或更新得多容易都没有关系。**
- en: In this chapter, I’ll teach you testing techniques to help you make your backend
    tests quick, reliable, and easy to update while still preserving the quality of
    your bug-detection mechanisms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将教你测试技术，帮助你使你的后端测试快速、可靠且易于更新，同时仍然保持你的错误检测机制的质量。
- en: You’ll learn about these techniques by improving the tests you’ve built in the
    previous chapter. As I demonstrate *how* to apply these techniques, I’ll also
    explain *why* they’re important.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过改进上一章中构建的测试来了解这些技术。当我演示**如何**应用这些技术时，我还会解释**为什么**它们很重要。
- en: Because servers may depend on factors outside of your control, like asynchronicity,
    time, or parallelism and shared resources, this chapter’s first section focuses
    on how to make your tests deterministic. In this section, you’ll learn how to
    make your tests capable of running quickly and reliably everywhere, even when
    they depend on external resources, such as databases or time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为服务器可能依赖于你无法控制的因素，如异步性、时间或并行性以及共享资源，所以本章的第一部分重点介绍如何使你的测试具有确定性。在本节中，你将学习如何使你的测试能够在任何地方快速且可靠地运行，即使它们依赖于外部资源，如数据库或时间。
- en: Following a goal-oriented approach, in section 5.2, I’ll explain how you can
    reduce your test’s cost while preserving rigorous quality control. This section
    teaches you about the decisions you will have to make when choosing *what* to
    test and *how* to test it, considering your time and resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 采用目标导向的方法，在第5.2节中，我将解释你如何在保持严格的质量控制的同时降低测试的成本。本节教你关于你将不得不做出的决策，即选择**什么**要测试以及**如何**测试，考虑到你的时间和资源。
- en: 5.1 Eliminating nondeterminism
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 消除非确定性
- en: Because Louis put a lot of effort into perfecting each of his recipes, he wants
    everyone to follow them to the letter. He trained each of his pastry chefs to
    be as methodical as an airplane pilot. Louis knows that if every chef follows
    the same steps every time, each cake that comes out of the oven will be as tasty
    as the previous one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路易斯在完善每一道食谱上投入了大量的努力，所以他希望每个人都严格遵循这些食谱。他训练每位糕点师像飞机驾驶员一样一丝不苟。路易斯知道，如果每位厨师每次都遵循相同的步骤，从烤箱中出来的每一块蛋糕都会和之前的一样美味。
- en: Repeatable recipes are crucial for the success of his bakery in the same way
    that repeatable tests are crucial for the success of a project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可重复的食谱对于他面包店的成功至关重要，就像可重复的测试对于项目成功至关重要一样。
- en: Repeatable tests are said to be **deterministic**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可重复的测试被认为是**确定性的**。
- en: Deterministic tests Deterministic tests are the ones that, given the same input,
    always produce the same results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性测试 确定性测试是指在给定相同输入的情况下，总是产生相同结果的测试。
- en: In this section, I will talk about possible sources of nondeterministic behavior
    in tests and explore solutions to it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论测试中可能出现的非确定性行为的来源，并探讨解决方法。
- en: '**Tests should always be deterministic**. Otherwise, it will be hard for you
    to tell whether there’s a problem in your tests or in your application. They will
    gradually undermine the confidence you have in your test suite and allow bugs
    to slip in. Some people, like Martin Fowler, would go as far as saying that nondeterministic
    tests are *useless* ([https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试应该始终是确定的**。否则，你很难判断是测试中存在问题还是应用中存在问题。它们会逐渐削弱你对测试套件的信心，并允许错误悄悄溜入。有些人，比如马丁·福勒，甚至会说非确定性的测试是*无用的*([https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html))。'
- en: Deterministic tests increase your confidence and therefore make you progress
    faster. Confidence in your tests enables you to change bigger chunks of code at
    a time because you can trust that they will fail only when the application doesn’t
    work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性测试可以增强你的信心，因此让你进步更快。对测试的信心使你能够一次更改更大的代码块，因为你相信它们只有在应用程序不工作时才会失败。
- en: In the previous chapter, when we talked about how to deal with third-party API’s,
    for example, we were, essentially, making our tests deterministic. Because we
    eliminated the dependency on someone else’s service, we had full control over
    when our tests would pass. For those tests to work, you won’t depend on an internet
    connection or someone else’s service being available and providing consistent
    responses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们讨论如何处理第三方API时，我们实际上是在使我们的测试确定。因为我们消除了对他人服务的依赖，我们完全控制了测试何时通过。为了使这些测试工作，你不会依赖于互联网连接或他人的服务可用并提供一致的响应。
- en: But third-party APIs aren’t the only source of nondeterminism. You can often
    end up creating nondeterministic tests when running tests in parallel or dealing
    with shared resources, time-dependent code, and other factors that are out of
    your control. Especially when writing backend applications, you will often have
    to deal with these elements, and, therefore, you must be prepared to write deterministic
    tests covering them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但第三方API并不是非确定性的唯一来源。在并行运行测试或处理共享资源、时间依赖性代码和其他你无法控制的因素时，你经常会创建非确定性测试。特别是在编写后端应用程序时，你经常会不得不处理这些元素，因此你必须准备好编写覆盖它们的确定性测试。
- en: Often, the best solution is to create test doubles to make nondeterministic
    code deterministic. When interacting with Internet-of-Things (IoT) devices, for
    example, you don’t want your tests to depend on those devices being available.
    Instead, you should use Jest’s mocks to simulate responses those devices would
    yield. The same is valid for dealing with randomness. If you have to use a random-number
    generator, like `Math.random`, mock it so that you eliminate randomness at its
    source.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好的解决方案是创建测试替身来使非确定性代码变得确定性。例如，当与物联网（IoT）设备交互时，你不想你的测试依赖于这些设备可用。相反，你应该使用Jest的模拟来模拟这些设备会产生的响应。对于处理随机性也是如此。如果你必须使用随机数生成器，比如`Math.random`，就模拟它，以便从源头消除随机性。
- en: '**As a rule of thumb, you should mock everything you can’t control**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为一个经验法则，你应该模拟你无法控制的一切**。'
- en: Another technique we have previously used to make tests deterministic is to
    ensure that they all start from the same initial state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用来使测试确定的一种技术是确保它们都从相同的初始状态开始。
- en: '**For tests to be deterministic, they always need to be given the same initial
    state**. Otherwise, even if the unit under test operating over that state is deterministic,
    the final result will be different.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了使测试确定，它们始终需要给出相同的初始状态**。否则，即使正在操作该状态的单元测试是确定的，最终结果也会不同。'
- en: NOTE By state, I mean the state that is *relevant* to the unit under test. For
    example, a function that applies a 50% discount to a user’s cart won’t generate
    a different result when given users with different names. In the case of the discount
    function, when referring to the state given to it, I’m referring to a cart’s content,
    not a user’s name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：通过状态，我指的是与单元测试相关的状态。例如，对一个应用50%折扣的用户购物车函数，当给定的用户名不同时，不会生成不同的结果。在折扣函数的情况下，当提到给它的状态时，我指的是购物车的内容，而不是用户的名字。
- en: Mocking everything you can’t control and always providing tests with the same
    initial state should get you a long way, but a few exceptional cases have better
    solutions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟你无法控制的一切，并且始终提供具有相同初始状态的测试，这应该能让你走得很远，但一些特殊情况有更好的解决方案。
- en: When dealing with time-dependant code or simultaneous tests that can interfere
    in each other’s states, you don’t necessarily need to use Jest’s mocks. For those
    cases, I will go into detail on how to find a solution that yields better results
    with fewer compromises.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理依赖于时间的代码或可能相互干扰的并发测试时，你并不一定需要使用 Jest 的模拟。对于这些情况，我将详细介绍如何找到一个解决方案，它以更少的妥协带来更好的结果。
- en: 5.1.1 Parallelism and shared resources
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 并行性和共享资源
- en: Baking a carrot cake, macaroons, and bread in the same oven at the same time
    doesn’t seem like such a good idea. Because each kind of pastry needs to be baked
    at a different temperature for different lengths of time, Louis’s chefs either
    use different ovens for different recipes or bake one kind of dessert at a time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同时在同一个烤箱里烤胡萝卜蛋糕、马卡龙和面包似乎不是一个好主意。因为每种糕点都需要在不同的温度下烤不同长度的时间，所以路易斯的厨师要么为不同的食谱使用不同的烤箱，要么一次只烤一种甜点。
- en: Similarly, when you have simultaneous tests running against the same resources,
    the results can be disastrous.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你对相同的资源进行并发测试时，结果可能是灾难性的。
- en: In the previous section, you had to start running your tests sequentially by
    using the `--runInBand` option to avoid flakiness. Parallelization would cause
    those tests to become flaky because they were operating over the same database
    and would, therefore, interfere with one another.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你必须通过使用 `--runInBand` 选项来按顺序运行你的测试，以避免不可靠性。并行化会导致这些测试变得不可靠，因为它们正在操作相同的数据库，因此会相互干扰。
- en: Let’s use a simpler example to visualize exactly how this situation occurred
    and then see how we could solve it. Given that we could reproduce the problem
    accurately in the smaller sample, we could apply the same principles when dealing
    with a more complex application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个更简单的例子来可视化这种情况是如何发生的，然后看看我们如何能够解决它。鉴于我们可以在较小的样本中准确复制这个问题，我们可以在处理更复杂的应用时应用相同的原理。
- en: Instead of creating an entire backend that operates against a database, let’s
    create a small module that updates the contents of a file. Both work upon a resource
    shared by multiple parallel tests. Thus we could adapt the solutions for one problem
    to another.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不创建一个针对数据库操作的后端，而是创建一个小的模块，它更新文件的内容。这两个模块都在多个并行测试共享的资源上工作。因此，我们可以将一个问题的解决方案适应到另一个问题中。
- en: Start by writing a small program we’ll use as an example. Create a module that
    changes the contents of a file that contains a count.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编写一个小程序，我们将用它作为示例。创建一个模块，它改变包含计数的文件的内容。
- en: Listing 5.1 countModule.js
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 countModule.js
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Synchronously reads the count in the file, turning its content, which is originally
    a string, into a number
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 同步地从文件中读取计数，将原本是字符串的内容转换为数字
- en: ❷ Synchronously writes the passed argument to the file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 同步地将传递的参数写入文件
- en: ❸ Synchronously increments the file’s count
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同步地增加文件的计数
- en: ❹ Synchronously decrements the file’s count
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 同步地减少文件的计数
- en: 'To validate this module, write two tests: one to increment the file’s count
    and the other to decrement it. Separate each test into a file of its own so they
    can run in parallel. Each test should reset the count, manipulate it through the
    exposed functions, and check the final count.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个模块，编写两个测试：一个用于增加文件的计数，另一个用于减少它。将每个测试分别放入一个单独的文件中，以便它们可以并行运行。每个测试都应该重置计数，通过暴露的函数进行操作，并检查最终的计数。
- en: Listing 5.2 increment.test.js
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 increment.test.js
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ Arrange: sets the file’s contents to 0'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将文件的内容设置为 0
- en: '❷ Act: calls the increment function 10 times'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：调用 increment 函数 10 次
- en: '❸ Assert: expects the file’s contents to be 10'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：期望文件的内容为 10
- en: Listing 5.3 decrement.test.js
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 decrement.test.js
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '❶ Arrange: sets the file’s contents to 0'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将文件的 内容设置为 0
- en: '❷ Act: calls the decrement function 10 times'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：调用 decrement 函数 10 次
- en: '❸ Assert: expects the file’s contents to be –10'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：期望文件的内容为 -10
- en: Repeating these tests about 10 or 20 times should be enough for you to see them
    exhibit flaky behavior. Eventually, they will either find a count that’s different
    from what’s expected or run into problems while trying to read and write to `state.txt`
    at the same time, which will cause the module to write `NaN` to the file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重复进行大约 10 或 20 次这些测试应该足以让你看到它们表现出不可靠的行为。最终，它们要么找到一个与预期不同的计数，要么在尝试同时读取和写入 `state.txt`
    时遇到问题，这将导致模块将 `NaN` 写入文件。
- en: TIP If you’re using a UNIX system, you can use `while npm test; do :; done`
    to run these tests until Jest fails.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果您使用的是UNIX系统，可以使用`while npm test; do :; done`来运行这些测试，直到Jest失败。
- en: Tests that run in parallel but share the same underlying resource, like the
    test illustrated by figure 5.1, can find that resource in different states every
    time they run and, therefore, fail. In the previous example, we were using a file,
    but the same thing can happen when tests share the same database, as we’ve previously
    seen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行的测试，但共享相同的底层资源，如图5.1所示的测试，可能会发现每次运行时该资源处于不同的状态，因此失败。在先前的例子中，我们正在使用一个文件，但当我们看到测试共享相同的数据库时，同样的事情也可能发生。
- en: '![](../Images/CH05_F01_DaCosta.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_DaCosta.png)'
- en: Figure 5.1 Both tests using the same module and the same underlying resource
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 使用相同模块和相同底层资源的两个测试
- en: The most obvious solution to this problem is to run tests sequentially, as we’ve
    done before by using the `--runInBand` option. The problem with this solution
    is that it can make your tests take longer to run. Most of the time, running tests
    sequentially is a good enough solution for many projects. But, when dealing with
    enormous test suites, it can adversely affect a team’s speed and make the development
    process more cumbersome.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最明显的方法是按顺序运行测试，就像我们之前通过使用`--runInBand`选项所做的那样。这种解决方案的问题是它可能会使您的测试运行时间更长。大多数时候，对于许多项目来说，按顺序运行测试已经足够好了。但是，当处理庞大的测试套件时，它可能会对团队的速度产生不利影响，使开发过程更加繁琐。
- en: Instead of running tests sequentially, let’s explore a different solution so
    that we can still run them in parallel even though they share resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不按顺序运行测试，而是探索一个不同的解决方案，这样我们仍然可以在它们共享资源的情况下并行运行它们。
- en: A strategy I’d recommend is to run tests against different instances of your
    module, each one of them operating over a different resource.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐的一种策略是对您的模块的不同实例运行测试，每个实例都在不同的资源上操作。
- en: To implement this approach, update your module so that you can initialize multiple
    instances of `countModule` and tell them which file to use, as shown next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种方法，更新您的模块，以便您可以初始化多个`countModule`实例，并告诉它们使用哪个文件，如下所示。
- en: Listing 5.4 countModule.js
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 countModule.js
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Returns an object that has the same setState, increment, and decrement files,
    but, instead of always writing to the same file, these functions write to the
    path passed as an argument
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回一个具有相同的setState、increment和decrement文件的对象，但与始终写入同一文件不同，这些函数将写入作为参数传递的路径
- en: Then, create a file called `instancePool.js`, which is capable of giving a different
    instance of the module for each worker spawned by Jest depending on its `id`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`instancePool.js`的文件，该文件能够根据Jest为每个工作者生成的`id`提供模块的不同实例。
- en: Listing 5.5 instancePool.js
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 instancePool.js
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Given a worker’s ID, returns an instance of the countModule, which writes
    to a file that is used only by that specific worker
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 给定一个工作者的ID，返回一个仅写入该特定工作者使用的文件的countModule实例
- en: ❷ Creates a new instance of the countModule for the passed worker if that instance
    does not exist yet
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果该实例尚不存在，则为传递的工作者创建一个新的countModule实例
- en: ❸ Returns an instance of countModule, which will be used only by the passed
    worker
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个仅由传递的工作者使用的countModule实例
- en: Now, in each of your test files, you can obtain a module instance that is exclusive
    to that worker.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的每个测试文件中，您都可以获得一个仅对该工作者专用的模块实例。
- en: Use `process.env.JEST_WORKER_ID` to obtain the worker’s unique ID and pass it
    to `getInstance` so that it can give each worker a different resource.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`process.env.JEST_WORKER_ID`来获取工作者的唯一ID，并将其传递给`getInstance`，以便它可以给每个工作者提供不同的资源。
- en: Listing 5.6 increment.test.js and .decrement.test.js
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 increment.test.js和.decrement.test.js
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Causes each test file to obtain an instance of countModule that is exclusive
    to the worker that executes it
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使每个测试文件获得一个仅由执行它的工作者使用的countModule实例
- en: After these changes, each test will use a different instance of the `countModule`
    (figure 5.2), so you can safely run as many tests in parallel as you want.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，每个测试都将使用`countModule`的不同实例（图5.2），因此您可以安全地并行运行尽可能多的测试。
- en: '![](../Images/CH05_F02_DaCosta.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F02_DaCosta.png)'
- en: Figure 5.2 Each test obtains a different instance of the module through `getInstance`
    and checks a different underlying resource.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 每个测试通过`getInstance`获取模块的不同实例，并检查不同的底层资源。
- en: To keep the examples short, I’ve used a module that writes to a file, but the
    same principle applies for testing an application that uses a database. If you
    want to run tests in parallel for those kinds of applications, you can run different
    instances of your application on different ports, each one connecting to a separate
    database. You can then make your workers send requests to different ports to interact
    with distinct instances of your application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例简短，我使用了一个写入文件的模块，但对于使用数据库的应用程序测试，同样的原则适用。如果你想要为这类应用程序并行运行测试，你可以在不同的端口上运行应用程序的不同实例，每个实例连接到不同的数据库。然后你可以让工作进程向不同的端口发送请求，以与应用程序的不同实例进行交互。
- en: 5.1.2 Dealing with time
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 处理时间
- en: Unfortunately for Louis, many customers who add items to their carts never come
    back to check out. Because items are removed from the inventory when they’re added
    to someone’s cart, the bakery’s website often lists items as unavailable when
    they’re actually sitting in the bakery’s shelves waiting for a hungry customer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于路易斯来说，不幸的是，许多将商品添加到购物车的顾客从未回来结账。因为商品在添加到某人的购物车时就会从库存中移除，面包店的网站经常列出商品为不可用，而实际上它们正坐在面包店的货架上等待饥饿的顾客。
- en: In Louis’s bakery, the final destination of every cake should be a customer’s
    hands, not the garbage bin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在路易斯的面包店中，每一块蛋糕的最终目的地应该是顾客的手中，而不是垃圾桶。
- en: To solve this problem, Louis wants to delete items from users’ carts if they’ve
    been there for more than an hour and return them to the inventory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，路易斯想要删除那些在用户购物车中超过一小时的商品，并将它们返回到库存中。
- en: This feature will require a new column that indicates when a customer last added
    an item to their cart. To create this column, add a new migration by running `./node_
    modules/.bin/knex migrate:make --env development updatedAt_field`. Then, in the
    migration file that should’ve been created in the `migrations` folder, add an
    `updatedAt` column to the `carts_items` table.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能将需要一个新列来指示客户上次将商品添加到购物车的时间。为了创建这个列，通过运行 `./node_ modules/.bin/knex migrate:make
    --env development updatedAt_field` 添加一个新的迁移。然后，在 `migrations` 文件夹中应该创建的迁移文件中，向
    `carts_items` 表添加一个 `updatedAt` 列。
- en: Listing 5.7 DATESTRING_updatedAt_field.js
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 DATESTRING_updatedAt_field.js
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The exported up function migrates the database to the next state, adding an
    updatedAt column to the carts_items table.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导出的 `up` 函数将数据库迁移到下一个状态，在 `carts_items` 表中添加 `updatedAt` 列。
- en: ❷ The exported down function migrates the database to the previous state, deleting
    the updatedAt column from the carts_items table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出的 `down` 函数将数据库迁移到之前的状态，从 `carts_items` 表中删除 `updatedAt` 列。
- en: Now, update the `cartController` so that it updates the `updatedAt` field whenever
    adding an item to the cart.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新 `cartController` 以便在向购物车添加商品时更新 `updatedAt` 字段。
- en: Listing 5.8 cartController.js
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 cartController.js
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ When adding an item to the cart, if the cart already has an entry for it,
    updates its updatedAt column using the current time
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当向购物车添加商品时，如果购物车中已经存在该商品的条目，则使用当前时间更新其 `updatedAt` 列
- en: Finally, create a function that removes items added more than four hours ago,
    and use `setInterval` to schedule it to run every two hours.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个删除四小时前添加的商品的函数，并使用 `setInterval` 来安排每两小时运行一次。
- en: Listing 5.9 cartController.js
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 cartController.js
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a Date four hours behind the current time
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个比当前时间早四小时的日期
- en: ❷ Finds all cart items that have been updated more than four hours ago
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找所有四小时前已更新的购物车商品
- en: ❸ Puts the stale items back in the inventory
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将过期的商品放回库存中
- en: ❹ Deletes stale items from the carts
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从购物车中删除过期的商品
- en: ❺ When called, schedules the removeStaleItems function to run every two hours
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当被调用时，安排每两小时运行一次 `removeStaleItems` 函数
- en: Once you call `monitorStaleItems`, every two hours it will delete items that
    have been added to a cart more than four hours previously and put them back in
    the inventory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用 `monitorStaleItems`，每两小时它将删除那些四小时前添加到购物车的商品，并将它们放回库存中。
- en: Go ahead and add a naive test for `monitorStaleItems`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续为 `monitorStaleItems` 添加一个简单的测试。
- en: Insert an item in the inventory.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库存中插入一个商品。
- en: Add that item to a cart.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该商品添加到购物车中。
- en: Wait for the item to be old enough.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待商品足够陈旧。
- en: Start `monitorStaleItems`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `monitorStaleItems`。
- en: Wait for `monitorStaleItems` to run.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 `monitorStaleItems` 运行。
- en: Check whether `monitorStaleItems` added the old items back to the inventory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `monitorStaleItems` 是否将旧商品重新添加到库存中。
- en: Check whether `monitorStaleItems` removed the items from the cart.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `monitorStaleItems` 是否已从购物车中删除了商品。
- en: Stop `monitorStaleItems` so that tests won’t hang.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止 `monitorStaleItems` 以防止测试挂起。
- en: Your test should look something like this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试应该看起来像这样。
- en: Listing 5.10 cartController.test.js
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 cartController.test.js
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Returns a promise that will resolve after the passed number of milliseconds
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回一个在传递的毫秒数后解决的承诺
- en: ❷ After each test, if a timer exists, cancels it
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每次测试后，如果存在计时器，则取消它
- en: '❸ Arrange: inserts one cheesecake into the inventory'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 安排：将一个芝士蛋糕插入库存中
- en: '❹ Arrange: adds an item to the test user’s cart'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安排：向测试用户的购物车添加一个项目
- en: ❺ Waits for four hours so that the item becomes old enough
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 等待四小时，以便项目变得足够旧
- en: '❻ Act: calls monitorStaleItems to schedule the function that clears stale items'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 行动：调用 monitorStaleItems 以安排清除过时项目的函数
- en: ❼ Waits for two hours so that the timer runs
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 等待两小时，以便计时器运行
- en: '❽ Assert: expects the cart to be empty'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言：期望购物车为空
- en: '❾ Assert: expects the cheesecake that was previously in the cart to have been
    put back in the inventory'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 断言：期望之前在购物车中的芝士蛋糕已被放回库存中
- en: 'The problem with this test is that it takes at least six hours to finish: four
    for the item to be old enough, and two for the timer to run. Because Jest’s maximum
    timeout is five seconds by default, this test would not even terminate.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的问题在于它至少需要六小时才能完成：四小时用于项目变得足够旧，两小时用于计时器运行。因为 Jest 默认的最大超时时间是五秒，所以这个测试甚至不会终止。
- en: Even if you increased the test’s timeout, once it finishes, the test could still
    fail. It could be the case that the database took a few extra milliseconds to
    remove the stale items, and, therefore, these items were still there when the
    test ran its verifications. Nondeterminism, in this case, is making your test
    flaky **and** slow.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您增加了测试的超时时间，一旦测试完成，测试仍然可能失败。可能是数据库花费了额外的几毫秒来删除过时的项目，因此，当测试运行其验证时，这些项目仍然存在。在这种情况下，非确定性会使您的测试变得不可靠**并且**缓慢。
- en: Time, just like third-party APIs, is a factor that’s out of your control. Therefore,
    you should replace it with a deterministic alternative.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 时间，就像第三方 API 一样，是一个您无法控制的因素。因此，您应该用确定性替代方案来替换它。
- en: Now, you’re probably thinking about using Jest’s mocks, as we’ve previously
    done, but creating your own mocks wouldn’t be an easy job.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能正在考虑使用 Jest 的模拟，就像我们之前做的那样，但创建自己的模拟不会是一件容易的工作。
- en: Even if you mocked `setInterval`, that still wouldn’t be enough. Because your
    tests use `setTimeout` and the `addItemToCart` function uses `Date`, you’d have
    to mock those, too.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您模拟了 `setInterval`，这仍然不足以解决问题。因为您的测试使用 `setTimeout`，而 `addItemToCart` 函数使用
    `Date`，您也必须模拟这些。
- en: Then, after mocking all those different functions, you’d still have to ensure
    that they’d be in sync. Otherwise, you could have situations in which, for example,
    `setTimeout` is executed when advancing the clock, but `Date` is still in the
    past.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在模拟了所有这些不同的函数之后，您仍然需要确保它们保持同步。否则，您可能会遇到例如，在推进时钟时执行 `setTimeout`，但 `Date`
    仍然在过去的情形。
- en: To consistently mock all time-related functions, we will use `sinonjs/fake-timers`.
    **The `sinonjs/fake-timers` package allows you to mock all time-related functions
    and keep them in sync**. **With fake timers you can shift time forward or run
    any pending timers**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持续模拟所有与时间相关的函数，我们将使用 `sinonjs/fake-timers`。**`sinonjs/fake-timers` 包允许您模拟所有与时间相关的函数并保持它们同步**。**使用模拟计时器，您可以向前推进时间或运行任何挂起的计时器**。
- en: 'NOTE At the time of this writing, Jest has two fake timers implementations:
    `legacy`, which is the default, and `modern`, which uses the `sinonjs/fake-timers`
    package—formerly known as `lolex`—as the underlying implementation for fake timers.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：在撰写本文时，Jest 有两个模拟计时器的实现：`legacy`，这是默认的，和 `modern`，它使用 `sinonjs/fake-timers`
    包（以前称为 `lolex`）作为模拟计时器的底层实现。
- en: I’m using `sinonjs/fake-timers` directly in this book because it allows me to
    configure the fake timers I’m using. If you use this package through Jest, you
    can’t pass options to the fake timers you will install.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中直接使用 `sinonjs/fake-timers`，因为它允许我配置我使用的模拟计时器。如果您通过 Jest 使用此包，您不能向要安装的模拟计时器传递选项。
- en: By using this package directly, I have more control over the timers. For example,
    I can determine which timer functions to mock. If this feature is not essential
    for you, you can use Jest’s `useFakeTimers` method instead and avoid installing
    this extra package.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接使用此包，我对计时器有了更多的控制。例如，我可以确定要模拟哪些计时器函数。如果您认为此功能对您不是必需的，您可以使用 Jest 的 `useFakeTimers`
    方法代替，并避免安装此额外包。
- en: Install `sinonjs/fake-timers` as a dev dependency so that you can start making
    your test for `monitorStaleItems` deterministic.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `sinonjs/fake-timers` 作为开发依赖项安装，这样你就可以开始为 `monitorStaleItems` 创建确定性测试。
- en: Once you have it installed, import `sinonjs/fake-timers` into your test file
    and use its `install` method. This method will globally replace the real time-related
    functions with fake ones and return a `clock` object that you can use to control
    time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，将 `sinonjs/fake-timers` 导入到你的测试文件中，并使用它的 `install` 方法。此方法将全局替换真实的时间相关函数为模拟函数，并返回一个
    `clock` 对象，你可以用它来控制时间。
- en: Listing 5.11 cartController.test.js
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 cartController.test.js
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Before each test, replaces the original timer methods with fake timers, which
    you can control
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，用模拟计时器替换原始计时器方法，你可以控制这些模拟计时器
- en: ❷ After each test, restores the original timer methods
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试之后，恢复原始计时器方法
- en: Now, instead of waiting for time to elapse, you can shift the clock forward
    by calling its `tick` method. The `tick` method takes the number of milliseconds
    by which you want to advance the clock, as shown next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不再需要等待时间流逝，而是可以通过调用其 `tick` 方法来将时钟向前调整。`tick` 方法接受你想要时钟前进的毫秒数，如下所示。
- en: Listing 5.12 cartController.test.js
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 cartController.test.js
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Shifts the clock four hours forward so that items become old enough
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将时钟向前调整四小时，使项目变得足够旧
- en: ❷ Calls monitorStaleItems to schedule the function that clears stale items
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 monitorStaleItems 来安排清除过时项目的函数
- en: ❸ Shifts the clock two hours forward to trigger the scheduled removeStaleItems
    function, causing stale items to be removed from the carts
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将时钟向前调整两小时以触发计划中的 removeStaleItems 函数，从而从购物车中删除过时项目
- en: Even though you have already mocked all the necessary timers, the previous test
    may still fail. Although the scheduled `removeStaleItems` is called, sometimes
    it doesn’t run fast enough to update the database before the test checks its contents.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经模拟了所有必要的计时器，之前的测试仍然可能失败。尽管调用了计划中的 `removeStaleItems`，但有时它运行不够快，无法在测试检查内容之前更新数据库。
- en: Whenever you don’t have a promise to wait for, as in this case, in which the
    database updates happen inside of a timer, I’d recommend retrying your assertions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有等待承诺的情况时，例如在这个案例中，数据库更新发生在计时器内部，我建议你重试你的断言。
- en: 'When compared to waiting for a fixed time, retries offer two advantages: speed
    and robustness, described as follows.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与等待固定时间相比，重试提供了两个优势：速度和健壮性，如下所述。
- en: Retries make tests quicker because, instead of waiting for a fixed time window,
    they allow tests to proceed as soon as a specific condition is met.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试使测试更快，因为它们允许测试在满足特定条件后立即进行，而不是等待固定的时间窗口。
- en: Retries make tests more robust because they guarantee that they will still work
    regardless of how long an operation takes, as long as it doesn’t exceed the overall
    timeout for the test.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试使测试更加健壮，因为它们保证了无论操作持续多长时间，只要不超过测试的总超时时间，测试仍然会工作。
- en: To implement a retry mechanism, wrap into a function an assertion and the code
    that fetches the assertion subject. Then, make that function call itself whenever
    the assertion throws an error (fails).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现重试机制，将断言和获取断言主题的代码包装到一个函数中。然后，每当断言抛出错误（失败）时，让该函数调用自己。
- en: A test with retries looks like this.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 具有重试功能的测试看起来是这样的。
- en: Listing 5.13 cartController.test.js
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 cartController.test.js
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Keeps checking the final cart’s contents until the assertion within passes
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不断检查最终购物车的内容，直到断言通过
- en: ❷ Asserts that the cart is empty; if it isn’t, reruns the function that contains
    this assertion
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 断言购物车为空；如果不为空，则重新运行包含此断言的函数
- en: ❸ Keeps checking the inventory’s content until the assertion within passes
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 不断检查库存的内容，直到断言通过
- en: ❹ Asserts that the cheesecake has been put back in the inventory; if it hasn’t,
    reruns the function which contains this assertion
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言芝士蛋糕已放回库存中；如果没有，则重新运行包含此断言的函数
- en: To make it a bit prettier, you could extract the retry behavior into a separate
    function. You could create a `withRetries` function that takes the function it
    should retry and keeps rerunning it whenever it throws a `JestAssertionError`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它看起来更美观，你可以将重试行为提取到单独的函数中。你可以创建一个 `withRetries` 函数，它接受应该重试的函数，并在它抛出 `JestAssertionError`
    时不断重新运行它。
- en: Listing 5.14 cartController.test.js
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 cartController.test.js
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Captures the assertion error, which is not exported by Jest
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 捕获断言错误，Jest 没有导出这个错误
- en: ❷ Reruns the passed function until it doesn’t throw an assertion error anymore
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 重复执行传递的函数，直到它不再抛出断言错误
- en: Then, pass the functions you want to retry to `withRetries`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将你想要重试的函数传递给 `withRetries`。
- en: Listing 5.15 cartController.test.js
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 cartController.test.js
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Keeps checking the cart’s final contents until it’s empty
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 持续检查购物车的最终内容，直到它为空
- en: ❷ Keeps checking the inventory’s contents until the cheesecake is put back into
    it
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 持续检查库存内容，直到芝士蛋糕放回其中
- en: Now, what if you want to add an interval of a few milliseconds before each retry?
    Because the timers are mocked, using `setTimeout` to wait for a promise to resolve
    wouldn’t work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想在每次重试前添加几毫秒的间隔，因为计时器被模拟了，使用 `setTimeout` 来等待承诺解决就不会起作用。
- en: To avoid mocking the `setTimeout` function, you can specify which timers you’d
    like to mock when calling the fake timer’s `install` method, as shown here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免模拟 `setTimeout` 函数，你可以在调用模拟计时器的 `install` 方法时指定你想要模拟的计时器，如下所示。
- en: Listing 5.16 cartController.test.js
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 cartController.test.js
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Uses fake timers only for the Date and setInterval functions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅使用模拟计时器来处理 Date 和 setInterval 函数
- en: By specifying that you want to mock only `Date` and `setInterval`, you’re free
    to use the real `setTimeout` everywhere else, including within your `withRetries`
    function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定你只想模拟 `Date` 和 `setInterval`，你可以在其他任何地方使用真实的 `setTimeout`，包括在你的 `withRetries`
    函数内部。
- en: Listing 5.17 cartController.test.js
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 cartController.test.js
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Waits for 100 milliseconds before retrying
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在重试前等待 100 毫秒
- en: The test you’ve just built is now as deterministic as it can be.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚构建的测试现在尽可能的确定。
- en: Because time was out of your control, you replaced it with fake timers, which
    you can handle as you please. By shifting time forward, you can trigger scheduled
    timers and update the values generated by `Date`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间不再在你的控制之下，你用模拟计时器替换了它，你可以随意处理。通过推进时间，你可以触发计划好的计时器并更新由 `Date` 生成的值。
- en: With these fake timers, you don’t have to make your tests wait anymore. You’re
    in full control of what happens and when it happens. To avoid using scheduled
    operations to make the test fail because they take long to run, you also added
    a `retry` mechanism, so that you can rerun an assertion multiple times until the
    test itself times out.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模拟计时器，你不再需要让你的测试等待。你可以完全控制发生的事情以及何时发生。为了避免使用计划操作使测试失败，因为它们运行时间较长，你还添加了一个
    `retry` 机制，这样你就可以多次重新运行断言，直到测试本身超时。
- en: Warning Using these retry mechanisms makes tests take longer to fail. You should
    retry assertions only when strictly necessary. Otherwise, they may significantly
    impact the time it takes for your test suite to run.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 使用这些重试机制会使测试失败的时间变长。你应该仅在绝对必要时重试断言。否则，它们可能会显著影响你的测试套件运行的时间。
- en: As you will see in chapter 9, where we will talk about test-driven development,
    having tests that can run quickly is crucial to iterating efficiently.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 9 章中将要看到的，我们将讨论测试驱动开发，拥有可以快速运行的测试对于高效迭代至关重要。
- en: If you’re feeling adventurous, try writing a new feature that depends on `setInterval`
    or `setTimeout` and testing it. For example, you could try periodically sending
    emails to all users.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到好奇，可以尝试编写一个依赖于 `setInterval` 或 `setTimeout` 的新功能并进行测试。例如，你可以尝试定期向所有用户发送电子邮件。
- en: TIP The `@sinonjs/fake-timers` package can manipulate timers in many other useful
    ways besides using `tick` to shift time forward. For example, you can use `runNext`
    to run only the next timer scheduled or `runAll` to run all pending timers. Find
    the complete documentation for `@sinonjs/fake-timers` at [https://github.com/sinonjs/fake-timers](https://github.com/sinonjs/fake-timers).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 `@sinonjs/fake-timers` 包除了使用 `tick` 来推进时间之外，还可以以许多其他有用的方式操作计时器。例如，你可以使用 `runNext`
    来仅运行下一个计划好的计时器，或者使用 `runAll` 来运行所有挂起的计时器。有关 `@sinonjs/fake-timers` 的完整文档，请访问 [https://github.com/sinonjs/fake-timers](https://github.com/sinonjs/fake-timers)。
- en: 5.2 Reducing costs while preserving quality
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 在保持质量的同时降低成本
- en: Quickly baking a thousand terrible cakes is as bad as taking an entire day to
    cook a single sublime one. Louis’s bakery’s success depends not only on how tasty
    his desserts are, but also on how many items he can produce to cope with the astronomical
    demand. To produce tasty desserts in a short time, he had to figure out exactly
    which parts of the process needed to be done more carefully and which could run
    a bit more loosely.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 快速制作一千个糟糕的蛋糕和花一整天时间制作一个完美的蛋糕一样糟糕。路易斯的面包店的成功不仅取决于他的甜点有多美味，还取决于他能够生产多少产品来应对天文数字的需求。为了在短时间内制作美味的甜点，他必须弄清楚哪些过程的部分需要做得更仔细，哪些可以稍微宽松一些。
- en: Writing a backend application may not be as pleasing to the senses as baking
    cakes, but when it comes to quickly delivering software that works, reducing costs
    and maintaining quality are still crucial.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编写后台应用程序可能不如烘焙蛋糕那样令人愉悦，但说到快速交付工作的软件，降低成本和保持质量仍然至关重要。
- en: In this section, we will explore which details provide the most significant
    benefits and apply to the context of a backend application in a few of the concepts
    we have already learned.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨哪些细节提供了最大的好处，并将它们应用于我们已学到的几个概念在后台应用程序的上下文中。
- en: 'I have divided this section into the following three most relevant techniques
    for keeping and obtaining reliable quality guarantees with as little costs as
    possible:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我将本节分为以下三个最相关的技术，以尽可能少的成本保持和获得可靠的质量保证：
- en: Reducing overlap between tests
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少测试之间的重叠
- en: Creating transitive guarantees
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建传递性保证
- en: Turning assertions into preconditions
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将断言转换为前置条件
- en: I will cover each technique in detail and also talk about how you can adapt
    them to the context of your project, considering the time and resources you have
    available.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细介绍每种技术，并讨论如何根据你拥有的时间和资源，将这些技术适应到你的项目环境中。
- en: 5.2.1 Reducing overlap between tests
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 减少测试之间的重叠
- en: Tests overlap when they run the same pieces of code and repeat each other’s
    verifications. A test like the one in figure 5.3, for example, touches many parts
    of your application, so it might overlap with plenty of other tests. Even though
    your tests may interact with your application from different points of view, by
    eliminating this overlap, you can often reduce the amount of code you have to
    maintain. The tricky part of removing overlap is keeping the quality high while
    still deleting tests. More tests don’t necessarily imply more quality, but they
    definitely increase the amount of code you have to maintain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行相同的代码片段并重复彼此的验证时，测试会重叠。例如，图5.3中的测试触及了你的应用程序的许多部分，因此它可能与许多其他测试重叠。尽管你的测试可能从不同的角度与你的应用程序交互，但通过消除这种重叠，你通常可以减少你必须维护的代码量。删除重叠的棘手之处在于，在删除测试的同时保持高质量。更多的测试并不一定意味着更高的质量，但它们确实会增加你必须维护的代码量。
- en: '![](../Images/CH05_F03_DaCosta.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F03_DaCosta.png)'
- en: Figure 5.3 An end-to-end test that sends a request to this route will cause
    functions like `addItemTocart`, `compliesToItemLimit`, `removeFromInventory`,
    and `log` to be executed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 发送请求到该路由的端到端测试将导致`addItemToCart`、`compliesToItemLimit`、`removeFromInventory`和`log`等函数被执行。
- en: To decide which tests to write for a specific functionality, think about which
    parts of your application are executed for each test you run. As an example, let’s
    have a look at what happens when sending a request to the route that adds items
    to a cart.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定为特定功能编写哪些测试，考虑你运行每个测试时应用程序的哪些部分被执行。例如，让我们看看向添加到购物车路由发送请求时会发生什么。
- en: TIP It helps to visualize this as a tree of dependencies, with the topmost node
    being the `server.js` file that contains all routes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 将其视为一个依赖树，其中最顶层的节点是包含所有路由的`server.js`文件，这有助于可视化。
- en: Now, compare the previous end-to-end test’s reach with the reach of an integration
    test like the one shown in figure 5.4.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将之前端到端测试的范围与图5.4所示的集成测试的范围进行比较。
- en: Because the `addItemToCart` function has fewer nodes below it in its dependency
    tree, it executes less code than the previous end-to-end test. Therefore, even
    though its focus is different, its reach is smaller.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`addItemToCart`函数在其依赖树下的节点较少，因此它执行的代码比之前的端到端测试少。因此，尽管其焦点不同，但其范围较小。
- en: The integration test covers only the business logic within the controllers,
    whereas the end-to-end test covers everything from the middleware to the route
    specification itself. Even though both are capable of detecting whether the business
    logic has an error, only the end-to-end test can ensure that the application complies
    with the HTTP endpoints’ design.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试仅覆盖控制器内的业务逻辑，而端到端测试覆盖从中间件到路由规范本身的一切。尽管两者都能检测业务逻辑是否有错误，但只有端到端测试可以确保应用程序符合HTTP端点的设计。
- en: '![](../Images/CH05_F04_DaCosta.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F04_DaCosta.png)'
- en: Figure 5.4 An integration test for `addItemTocart` will also cause `compliesToItemLimit`,
    `removeFromInventory`, and `log` to be invoked.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 对`addItemToCart`的集成测试也将导致`compliesToItemLimit`、`removeFromInventory`和`log`被调用。
- en: Finally, let’s compare those two with a unit test that calls `compliesToItemLimit`
    directly, like the one shown in figure 5.5.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们比较这两个测试与直接调用`compliesToItemLimit`的单元测试，如图5.5所示。
- en: '![](../Images/CH05_F05_DaCosta.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F05_DaCosta.png)'
- en: Figure 5.5 A unit-test for `compliesToItemLimit` covers only that function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 对`compliesToItemLimit`的单元测试仅覆盖该函数。
- en: The previous tests could catch errors not only in `compliesToItemLimit` but
    also in other dependencies above it. Because `compliesToItemLimit` does not depend
    on any other pieces of software, testing it executes very few lines of code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试不仅可以捕获`compliesToItemLimit`中的错误，还可以捕获其上方的其他依赖项中的错误。因为`compliesToItemLimit`不依赖于任何其他软件组件，所以测试它执行非常少的代码行。
- en: Given that you have tight budgets and deadlines, how could you maximize the
    benefits of writing tests with as few tests as possible?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你预算紧张和截止日期紧迫，你如何以尽可能少的测试来最大化编写测试的好处？
- en: To answer that question, consider how much of your code you can cover with each
    test. Assuming that you want to assert on as many aspects as possible with as
    little effort as necessary, you should choose the test that runs the largest portion
    of your application with the least code. In this case, that would be the end-to-end
    test.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，考虑一下每次测试可以覆盖你代码的多少。假设你希望尽可能多地以尽可能少的努力断言，你应该选择运行你应用程序最大部分但代码最少的测试。在这种情况下，那将是端到端测试。
- en: NOTE Usually, end-to-end tests are the most time-consuming tests to write and
    the ones that take the longest to run. In most situations, you’d choose to implement
    an integration test, considering how much easier it would be. But, because testing
    Node.js backends is exceptionally quick and reasonably straightforward, it’s often
    better to go for an end-to-end test.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：通常，端到端测试是编写和运行时间最长的测试。在大多数情况下，你会选择实现集成测试，考虑到这将容易得多。但是，由于测试Node.js后端非常快速且相对直接，通常更好的选择是进行端到端测试。
- en: The problem with writing only a single test is that, by omitting the others,
    you could be missing essential assertions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只编写一个测试的问题在于，通过省略其他测试，你可能会错过关键的断言。
- en: Assume, for example, that your end-to-end test asserts only on the application’s
    response, whereas your integration test for `addItemToCart` also asserts on the
    database’s content. If you simply choose not to write the integration test, you
    could, for example, not know that your application inserted the wrong items on
    the database, even though it returned a valid response.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的端到端测试只断言应用程序的响应，而你的`addItemToCart`集成测试也断言数据库的内容。如果你简单地选择不编写集成测试，例如，你可能不知道你的应用程序在数据库中插入了错误的项目，即使它返回了有效的响应。
- en: To write less code but maintain the same guarantees, you should move up those
    assertions to your end-to-end test, which also covers `addItemToCart`. In this
    case, you still run the same verifications, but you centralize them in the tests
    whose entry point is the topmost nodes instead of spreading them across multiple
    tests, as shown in figure 5.6.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写更少的代码但保持相同的保证，你应该将这些断言移动到你的端到端测试中，该测试也覆盖`addItemToCart`。在这种情况下，你仍然运行相同的验证，但将它们集中在以最高节点为入口点的测试中，而不是像图5.6所示的那样分散在多个测试中。
- en: '![](../Images/CH05_F06_DaCosta.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_DaCosta.png)'
- en: Figure 5.6 When reducing the amount of testing code, centralize your assertions
    in the test that covers the topmost node.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 当减少测试代码量时，将断言集中在覆盖最高节点的测试中。
- en: The downside of this approach is that, sometimes, you won’t be able to cover
    certain edge cases. For example, you couldn’t pass a `null` value to `addItemToCart`,
    because the route parameter will always be a string. Therefore, it might be possible
    that `addItemToCart` will fail unexpectedly when passed `null` values. On the
    other hand, one might also argue that, if this function is never passed a `null`
    value, then it’s not worth testing this case.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，有时你将无法覆盖某些边缘情况。例如，你不能将`null`值传递给`addItemToCart`，因为路由参数始终是字符串。因此，`addItemToCart`在传递`null`值时可能会意外失败。另一方面，也有人可能会争辩说，如果这个函数从未传递`null`值，那么测试这个情况就没有价值。
- en: By writing coarser tests with more assertions, you are choosing to reduce your
    costs by eliminating duplication in exchange for less precise feedback.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写具有更多断言的更粗粒度的测试，你选择通过消除重复来降低成本，以换取更不精确的反馈。
- en: The more time and resources you have, the more you can distribute your assertions
    into more granular tests that exercise your application through different endpoints
    and generate more precise feedback. Remember that, when it comes to tests, there’s
    no one-size-fits-all approach. It *always* “depends.”
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有的时间和资源越多，你就可以将断言分配到更细粒度的测试中，通过不同的端点来锻炼你的应用程序，并生成更精确的反馈。记住，当涉及到测试时，没有一种适合所有情况的解决方案。它*总是*“取决于”。
- en: 5.2.2 Creating transitive guarantees
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 创建传递性保证
- en: The concept of a transitive guarantee introduced in chapter 3 can be especially
    useful when testing backend applications.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中引入的传递性保证的概念在测试后端应用程序时特别有用。
- en: Whenever it’s costly to assert on a particular aspect of your application, transitive
    guarantees help you reduce the amount of code necessary to obtain the same level
    of reliability.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对应用程序的某个特定方面进行断言的成本很高时，传递性保证可以帮助你减少获取相同可靠性所需的代码量。
- en: Take into account, for example, the tests for possible functions in `cartController`.
    Consider that these functions will do logging whenever you add or remove items
    from a card, regardless of whether these operations succeed. Because logging happens
    so frequently, you have to write plenty of repetitive assertions to cover it,
    as you can see in figure 5.7.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`cartController`中可能函数的测试。假设这些函数在你添加或从卡片中删除项目时都会进行日志记录，无论这些操作是否成功。因为日志记录发生得如此频繁，你必须编写大量的重复断言来覆盖它，如图5.7所示。
- en: '![](../Images/CH05_F07_DaCosta.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7](../Images/CH05_F07_DaCosta.png)'
- en: Figure 5.7 In each test that depends on the logger, you will repeat the same
    code to read the log file and perform similar assertions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 在每个依赖于日志记录器的测试中，你将重复相同的代码来读取日志文件并执行类似的断言。
- en: Repetitively asserting on the behavior of your logger is time-consuming and
    thus expensive. Whenever you have to assert on the logging aspect of a function,
    you must import the `fs` module, open the file, and assert on its contents. Between
    tests, you must also remember to clear the log file. If the logger adds extra
    metadata, like a timestamp, to the logged content, you must also take it into
    account when doing assertions. You will either have to ignore the timestamp or
    mock its source, which will add extra complexity to the test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重复断言你的日志记录器的行为是耗时的，因此成本高昂。每次你必须断言函数的日志方面时，你必须导入`fs`模块，打开文件，并断言其内容。在测试之间，你还必须记得清除日志文件。如果日志记录器将额外的元数据，如时间戳，添加到日志内容中，你必须在断言时考虑它。你可能必须忽略时间戳或模拟其来源，这将给测试增加额外的复杂性。
- en: To reduce duplication and still guarantee that your application does logging
    correctly, you can create a transitive guarantee. First, you will write a separate
    test for the `log` function, which ensures that the logger writes to the correct
    file and adds all the necessary metadata. Then, instead of repeating those expensive
    checks when testing each function that requires `logger`, you can simply verify
    whether `log` is called with the correct arguments because you already know it
    works.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少重复并确保你的应用程序正确地进行日志记录，你可以创建一个传递性保证。首先，你将为`log`函数编写一个单独的测试，确保记录器写入正确的文件并添加所有必要的元数据。然后，在测试每个需要`logger`的函数时，你不必重复那些昂贵的检查，只需验证`log`是否以正确的参数被调用，因为你已经知道它工作正常。
- en: Doing this is as if you were saying, “I already know that my logger works because
    I have tested it. Now, I just want to make sure it’s invoked with the correct
    arguments.” This approach is illustrated by figure 5.8.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做就像是在说，“我已经知道我的日志记录器工作正常，因为我已经测试过它了。现在，我只想确保它使用正确的参数被调用。”这种做法如图 5.8 所示。
- en: '![](../Images/CH05_F08_DaCosta.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F08_DaCosta.png)'
- en: Figure 5.8 The tests for the cart functions rely on the guarantees created by
    the tests for the logger.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 购物车功能的测试依赖于日志记录器测试创建的保证。
- en: Because backends often deal with many dependencies that are orthogonal to your
    application, like logging, expensive assertions are exceptionally frequent. Whenever
    that’s the case, encapsulate the tests for those dependencies and just check if
    they’re appropriately called.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于后端通常处理许多与应用程序正交的依赖项，如日志记录，昂贵的断言非常频繁。每当这种情况发生时，封装那些依赖项的测试，并仅检查它们是否被适当地调用。
- en: TIP Instead of writing functions to perform assertions, use transitive guarantees
    to encapsulate them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 相比于编写执行断言的函数，使用传递性保证来封装它们。
- en: 5.2.3 Turning assertions into preconditions
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 将断言转换为先决条件
- en: You can reduce the number of tests you write by turning assertions into preconditions.
    Instead of writing separate tests to check a specific behavior, you rely on that
    behavior for other tests to pass.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将断言转换为先决条件来减少您需要编写的测试数量。您不需要为特定的行为编写单独的测试，而是依赖于该行为使其他测试通过。
- en: Consider, for example, the authentication middleware you built for your application.
    We didn’t need to write a specific test for each route to check whether it allows
    authenticated requests to go through. Instead, we test other aspects of the route
    by sending authenticated requests. If the authentication middleware doesn’t let
    authenticated requests to pass through, those other tests will fail.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下您为应用程序构建的认证中间件。我们不需要为每个路由编写特定的测试来检查它是否允许经过身份验证的请求通过。相反，我们通过发送经过身份验证的请求来测试路由的其他方面。如果认证中间件不允许经过身份验证的请求通过，那么其他测试将失败。
- en: Because those other tests already depend on authentication, it’s as if you had
    embedded that assertion into how you exercise your application, as you can see
    in figure 5.9\. By writing your tests in this manner, for each route you have,
    you save yourself an extra test.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那些其他测试已经依赖于认证，这就像您已经将断言嵌入到您如何执行应用程序的方式中，如图 5.9 所示。通过以这种方式编写测试，对于您拥有的每个路由，您可以节省一个额外的测试。
- en: '![](../Images/CH05_F09_DaCosta.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F09_DaCosta.png)'
- en: Figure 5.9 By relying on a certain behavior to happen in other tests, you can
    avoid writing a specific test for it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 通过依赖于其他测试中发生的行为，您可以避免为它编写特定的测试。
- en: On the other hand, a test for the authentication middleware that you can’t avoid
    is one that guarantees that your application refuses unauthenticated requests.
    Because testing other functionality within the route requires you to pass valid
    authentication headers, you can’t embed this verification into other tests.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您无法避免的认证中间件测试是确保您的应用程序拒绝未经身份验证的请求的测试。因为测试路由内的其他功能需要您传递有效的身份验证头，所以您不能将此验证嵌入到其他测试中。
- en: Another common way to embed assertions in your tests is by changing the way
    you create your mocks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试中嵌入断言的另一种常见方式是通过改变创建模拟的方式。
- en: When we used `nock` to mock endpoints, for example, we essentially built assertions
    into those mocks. We conditioned those mocks to respond only to the correct requests
    and to fail whenever they hadn’t been called.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用 `nock` 来模拟端点时，我们实际上是在那些模拟中构建了断言。我们使那些模拟仅对正确的请求做出响应，并在它们未被调用时失败。
- en: Take the test we’ve written for the route that fetches inventory items and depends
    on a third-party API, for example. Thanks to `nock`, that test would pass only
    if the request is sent with the correct parameters to the correct URL. Therefore,
    you don’t need to assert on how the `fetch` function is used.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们为获取库存项的路由编写的测试为例，该测试依赖于第三方 API。多亏了 `nock`，该测试只有在请求以正确的参数发送到正确的 URL 时才会通过。因此，您不需要断言
    `fetch` 函数的使用方式。
- en: Whenever you condition your mocks to respond only to the desired arguments,
    you don’t need to assert on how that mock is called.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您使模拟仅对期望的参数做出响应时，您就不需要断言该模拟是如何被调用的。
- en: If you’re not dealing with endpoints, an alternative is to use `jest-when` to
    achieve the same goal.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不处理端点，另一种选择是使用 `jest-when` 来实现相同的目标。
- en: In this case, again, you are trading granular feedback for less duplication.
    When these tests fail, it will take longer to figure out the bug’s root cause,
    but you will also spend fewer resources on writing tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你又一次是在以更少的重复为代价换取更细粒度的反馈。当这些测试失败时，找出错误的根本原因将需要更长的时间，但你也会在编写测试上花费更少的资源。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Tests must always start from the same initial state. Otherwise, they may become
    flaky. Between each test, don’t forget to clean up every resource used. To define
    the hooks that will do this regular cleanup, you can use Jest’s `setupFilesAfterEnv`
    option.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试必须始终从相同的初始状态开始。否则，它们可能会变得不可靠。在每个测试之间，不要忘记清理使用的每个资源。为了定义将执行此定期清理的钩子，你可以使用Jest的`setupFilesAfterEnv`选项。
- en: When you depend on anything that’s not in your control, like time or a third-party
    API, you should stub it. Otherwise, your tests won’t be deterministic and, therefore,
    will undermine the confidence in your test suite and may become difficult to debug.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你依赖于任何不在你控制范围内的事物，如时间或第三方API时，你应该模拟它。否则，你的测试将不会是确定性的，因此会削弱你对测试套件的信心，并且可能变得难以调试。
- en: To mock third-party APIs you can use `nock`. It will enable you to specify an
    endpoint’s response rather than having to mock an HTTP library. Because `nock`
    can work with whichever request library you are using, it will make tests more
    decoupled and easier to read, write, and update.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要模拟第三方API，你可以使用`nock`。这将使你能够指定端点的响应，而不是必须模拟HTTP库。因为`nock`可以与任何你正在使用的请求库一起工作，这将使测试更加解耦，更容易阅读、编写和更新。
- en: Your tests should not depend on time. Whenever you rely on a date or on a timer
    to be triggered, use fake timers instead of waiting for a fixed amount of time.
    Fake timers enable you to trigger any timers and shift the clock forward, making
    tests faster, more robust, and deterministic.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的测试不应该依赖于时间。无论何时你依赖于日期或计时器被触发，请使用模拟计时器而不是等待固定的时间。模拟计时器使你能够触发任何计时器并向前移动时钟，使测试更快、更健壮和确定性更高。
- en: If you have tests that share resources, they may interfere with each other when
    running in parallel. To isolate your tests, you can run them against different
    instances of your application, with each one using a separate resource.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有的测试共享资源，当它们并行运行时可能会相互干扰。为了隔离你的测试，你可以针对你的应用程序的不同实例运行它们，每个实例使用单独的资源。
- en: By writing tests that execute a larger part of your application and moving your
    assertions up, you can reduce the number of tests you have to write, but you can
    still perform the same checks. Even though your feedback will be less granular,
    this strategy can help you reduce costs while preserving your tests’ thoroughness.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写执行你应用程序更大部分的测试并将断言向上移动，你可以减少需要编写的测试数量，但仍然可以执行相同的检查。即使你的反馈将不那么细粒度，这种策略可以帮助你在保持测试全面性的同时减少成本。
- en: To avoid repetitive assertions, you can create transitive guarantees. Instead
    of retesting a dependency in every test, you can ensure that dependency works
    separately, and then check only if it’s being used correctly. This technique is
    especially useful when writing backend applications, which tend to have a higher
    number of orthogonal dependencies.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免重复的断言，你可以创建传递性保证。而不是在每个测试中重新测试依赖项，你可以确保该依赖项独立工作，然后只检查它是否被正确使用。这种技术在编写后端应用程序时特别有用，因为后端应用程序往往具有更多的正交依赖项。
- en: You don’t always need a separate test to check a specific behavior. If other
    tests depend on that behavior to pass, you can already consider it covered.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你并不总是需要一个单独的测试来检查特定的行为。如果其他测试依赖于该行为通过，那么你就可以认为它已经被覆盖了。
