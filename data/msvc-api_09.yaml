- en: 7 Service implementation patterns for microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 微服务实现模式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: How hexagonal architecture helps us design loosely coupled services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构如何帮助我们设计松散耦合的服务
- en: Implementing the business layer for a microservice and implementing database
    models using SQLAlchemy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务实现业务层，并使用 SQLAlchemy 实现数据库模型
- en: Using the repository pattern to decouple the data layer from the business layer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用仓储模式将数据层从业务层解耦
- en: Using the unit of work pattern to ensure the atomicity of all transactions and
    using the dependency inversion principle to build software that is resilient to
    changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作单元模式确保所有事务的原子性，并使用依赖倒置原则构建对变化具有弹性的软件
- en: Using the inversion of control principle and the dependency injection pattern
    to decouple components that are dependent on each other
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制反转原则和依赖注入模式解耦相互依赖的组件
- en: In this chapter, we’ll learn how to implement the business layer of a microservice.
    In previous chapters, we learned how to design and implement REST APIs. In those
    implementations, we used an in-memory representation of the resources managed
    by the service. We took that approach to keep the implementation simple and allow
    ourselves to focus on the API layer of the service.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将学习如何实现微服务的业务层。在之前的章节中，我们学习了如何设计和实现 REST API。在这些实现中，我们使用了服务管理的资源的内存表示。我们采取这种方法是为了保持实现简单，并让我们能够专注于服务的
    API 层。 '
- en: In this chapter, we’ll complete our implementation of the orders service by
    adding a business layer and a data layer. The business layer will implement the
    capabilities of the orders service, such as taking orders, processing their payments,
    or scheduling them for production. For some of these tasks, the orders service
    requires the collaboration of other services, and we’ll learn useful patterns
    to handle those integrations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过添加业务层和数据层来完成订单服务的实现。业务层将实现订单服务的功能，例如接收订单、处理其支付或安排其生产。对于其中一些任务，订单服务需要与其他服务的协作，我们将学习处理这些集成模式的有用模式。
- en: The data layer will implement the data management capabilities of the service.
    The orders service owns and manages data about orders, so we’ll implement a persistent
    storage solution and an interface to it. However, as a gateway to users regarding
    the life cycle of an order, the orders service also needs to fetch data from other
    services—for example, to keep track of the order during production and delivery.
    We’ll also learn useful patterns to handle access to those services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层将实现服务的数据管理功能。订单服务拥有并管理订单数据，因此我们将实现一个持久化存储解决方案及其接口。然而，作为用户关于订单生命周期的网关，订单服务还需要从其他服务中获取数据——例如，在生产和交付过程中跟踪订单。我们还将学习处理对这些服务访问的有用模式。
- en: To articulate the implementation patterns of the service, we’ll also cover elements
    of the architectural layout required to keep all pieces of our microservices loosely
    coupled. Loose coupling will help us ensure that we can change the implementation
    of a specific component without having to make changes to other components that
    rely on it. It’ll also make our codebase generally more readable, maintainable,
    and testable. The code for this chapter is available in the ch07 directory in
    the repository provided with this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐述服务的实现模式，我们还将涵盖保持我们微服务各个部分松散耦合所需的架构布局元素。松散耦合将帮助我们确保我们可以在不修改依赖它的其他组件的情况下更改特定组件的实现。它还将使我们的代码库更易于阅读、维护和测试。本章的代码可在本书提供的存储库中的
    ch07 目录中找到。
- en: 7.1 Hexagonal architectures for microservices
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 微服务的六边形架构
- en: This chapter introduces the concept of hexagonal architecture and how we’ll
    apply it to the design of the orders service. In chapter 2, we introduced the
    three-tier architecture pattern to help us organize the components of our application
    in a modular and loosely coupled way. In this section, we’ll take this idea further
    by applying the concept of hexagonal architecture to our design.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了六边形架构的概念以及我们将如何将其应用于订单服务的开发。在第2章中，我们介绍了三层架构模式，以帮助我们以模块化和松散耦合的方式组织应用程序的组件。在本节中，我们将进一步应用六边形架构的概念来指导我们的设计。
- en: In 2005, Alistair Cockburn introduced the concept of *hexagonal architecture*,
    also called the architecture of *ports and adapters*, as a way to help software
    developers structure their code into loosely coupled components.[¹](#pgfId-1092720)
    As you can see in figure 7.1, the idea behind the hexagonal or ports-and-adapters
    architecture is that, in any application, there’s a core piece of logic that implements
    the capabilities of a service, and around that core we “attach” *adapters* that
    help the core communicate with external components. For example, a web API is
    an adapter that helps the core communicate with web clients over the internet.
    The same goes for a database, which is simply an external component that helps
    a service persist data. We should be able to swap the database if we want, and
    the service would still be the same. Therefore, the database is also an adapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2005年，Alistair Cockburn引入了*六边形架构*的概念，也称为*端口和适配器*架构，作为一种帮助软件开发者将代码结构化为松散耦合组件的方法。[¹](#pgfId-1092720)
    如图7.1所示，六边形或端口和适配器架构背后的思想是，在任何应用程序中，都有一个核心逻辑块实现了服务的功能，并且围绕这个核心，我们“附加”*适配器*以帮助核心与外部组件通信。例如，Web
    API是一个适配器，帮助核心通过互联网与Web客户端通信。数据库也是如此，它只是一个帮助服务持久化数据的简单外部组件。如果我们想更换数据库，服务仍然是一样的。因此，数据库也是一个适配器。
- en: '![](../Images/07-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1](../Images/07-01.png)'
- en: Figure 7.1 In hexagonal architecture, we distinguish a core layer in our application,
    the business layer, which implements the service’s capabilities. Other components,
    such as a web API interface or a database, are considered adapters that depend
    on the business layer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 在六边形架构中，我们在应用程序中区分一个核心层，即业务层，它实现了服务的功能。其他组件，如Web API接口或数据库，被认为是依赖于业务层的适配器。
- en: 'How does this help us build loosely coupled services? Hexagonal architecture
    requires that we keep the core logic of the service and the logic for the adapters
    strictly separated. In other words, the logic that implements our web API layer
    shouldn’t interfere with the implementation of the core business logic. And the
    same goes for the database: regardless of the technology we choose, and its design
    and idiosyncrasies, it shouldn’t interfere with the core business logic. How do
    we achieve that? By building ports between the core business layer and the adapters.
    *Ports* are technology-agnostic interfaces that connect the business layer with
    the adapters. Later in this chapter, we’ll learn some design patterns that will
    help us design those ports or interfaces.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助我们构建松散耦合的服务？六边形架构要求我们将服务的核心逻辑和适配器的逻辑严格分离。换句话说，实现我们的Web API层的逻辑不应该干扰核心业务逻辑的实现。同样，对于数据库也是如此：无论我们选择什么技术，以及其设计和特性，它都不应该干扰核心业务逻辑。我们如何实现这一点？通过在核心业务层和适配器之间构建端口。*端口*是技术无关的接口，用于连接业务层和适配器。在本章的后面部分，我们将学习一些设计模式，这些模式将帮助我们设计那些端口或接口。
- en: When working out the relationship between the core business logic and the adapters,
    we apply the dependency inversion principle, which states that (see figure 7.2
    for clarification)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当确定核心业务逻辑和适配器之间的关系时，我们应用依赖倒置原则，该原则指出（见图7.2以获得澄清）
- en: High-level modules shouldn’t depend on low-level details. Instead, both should
    depend on abstractions, such as interfaces. For example, when saving data, we
    want to do it through an interface that doesn’t require understanding of the specific
    implementation details of the database. Whether it’s an SQL or a NoSQL database
    or a cache store, the interface should be the same.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应该依赖于低级细节。相反，两者都应该依赖于抽象，例如接口。例如，在保存数据时，我们希望通过一个不需要了解数据库特定实现细节的接口来完成。无论是SQL数据库、NoSQL数据库还是缓存存储，接口应该是相同的。
- en: Abstractions shouldn’t depend on details. Instead, details should depend on
    abstractions.[²](#pgfId-1092733) For example, when designing the interface between
    the business layer and the data layer, we want to make sure that the interface
    doesn’t change based on the implementation details of the database. Instead, we
    make changes to the data layer to make it work with the interface. In other words,
    the data layer depends on the interface, not the other way around.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应该依赖于细节。相反，细节应该依赖于抽象。[²](#pgfId-1092733) 例如，在设计业务层和数据层之间的接口时，我们希望确保接口不会根据数据库的实现细节而改变。相反，我们修改数据层以使其与接口兼容。换句话说，数据层依赖于接口，而不是相反。
- en: '![](../Images/07-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-02.png)'
- en: Figure 7.2 We apply the dependency inversion principle to determine which components
    drive the changes. In hexagonal architecture, this means that our adapters will
    depend on the interface exposed by the core business layer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 我们应用依赖倒置原则来确定哪些组件驱动变化。在六边形架构中，这意味着我们的适配器将依赖于核心业务层公开的接口。
- en: DEFINITION The *dependency inversion principle* encourages us to design our
    software against interfaces and to make sure we don’t create dependencies between
    the low-level details of our components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*依赖倒置原则*鼓励我们针对接口设计我们的软件，并确保我们不会在组件的低级细节之间创建依赖。
- en: The concept of dependency inversion often appears with the concepts of inversion
    of control and dependency injection. These are related but different concepts.
    As we’ll see in section 7.5, the inversion of control principle consists of supplying
    code dependencies through the execution context (also called the inversion of
    control container). To supply such dependencies, we can use the dependency injection
    pattern, which we’ll describe in section 7.5.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置的概念经常与控制反转和控制注入的概念一起出现。这些是相关但不同的概念。正如我们在第7.5节中将要看到的，控制反转原则包括通过执行上下文（也称为控制反转容器）提供代码依赖。为了提供这样的依赖，我们可以使用依赖注入模式，我们将在第7.5节中描述它。
- en: 'What does this mean in practice? It means we should make the adapters depend
    on the interface exposed by the core business logic. That is, it’s okay for our
    API layer to know about the core business logic’s interface, but it’s not okay
    for our business logic to know specific details of our API layer or low-level
    details of the HTTP protocol. The same goes for the database: our data layer should
    know how the application works and how to accommodate the application’s needs
    to our choice of storage technology, but the core business layer should know nothing
    specific about the database. Our business layer will expose an interface, and
    all other components will be implemented against it.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中意味着我们应该让适配器依赖于核心业务逻辑公开的接口。也就是说，我们的API层了解核心业务逻辑的接口是可以的，但我们的业务逻辑了解API层的具体细节或HTTP协议的低级细节是不可以的。对于数据库也是如此：我们的数据层应该知道应用程序的工作方式以及如何适应我们选择的存储技术，但核心业务层对数据库的了解应该是具体的。我们的业务层将公开一个接口，所有其他组件都将针对它实现。
- en: What exactly are we inverting with the dependency inversion principle? This
    principle inverts the way we think about software. Instead of the more conventional
    approach of building the low-level details of our software first, and then building
    interfaces on top of them, the dependency inversion principle encourages us to
    think of the interfaces first and then build the low-level details against them.[³](#pgfId-1092747)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到底是通过依赖倒置原则来反转什么？这个原则反转了我们对软件的思考方式。不是先构建软件的低级细节，然后再在其上构建接口的更传统的方法，依赖倒置原则鼓励我们首先考虑接口，然后针对它们构建低级细节。[³](#pgfId-1092747)
- en: As you can see in figure 7.3, when it comes to the orders service, we’ll have
    a core package that implements the capabilities of the service. This includes
    the ability to process an order and its payment, to schedule its production, or
    to keep track of its progress. The core service package will expose interfaces
    for other components of the application. Another package implements the web API
    layer, and our API modules will use functions and classes from the business layer
    interface to serve the requests of our users. Another package implements the data
    layer, which knows how to interact with the database and return business objects
    for the core business layer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图7.3所示，当我们谈到订单服务时，我们将有一个核心包来实现服务的功能。这包括处理订单及其支付、安排其生产或跟踪其进度的能力。核心服务包将向应用程序的其他组件公开接口。另一个包实现了Web
    API层，我们的API模块将使用业务层接口中的函数和类来响应用户的请求。另一个包实现了数据层，它知道如何与数据库交互并返回业务对象供核心业务层使用。
- en: '![](../Images/07-03.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-03.png)'
- en: 'Figure 7.3 The orders service consist of three packages: the core business
    logic, which implements the capabilities of the service; an API layer, which allows
    clients to interact with the service over HTTP; and a data layer, which allows
    the service to interact with the database. The core business logic exposes interfaces
    against which the API layer and the data layer are implemented.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 订单服务由三个包组成：核心业务逻辑，它实现了服务的功能；API层，它允许客户端通过HTTP与服务交互；以及数据层，它允许服务与数据库交互。核心业务逻辑暴露了API层和数据层实现的接口。
- en: Now that we know how we are going to structure the application, it’s time to
    start implementing it! In the next section, we’ll set up the environment to start
    working on the service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们将如何构建应用程序的结构，是时候开始实现了！在下一节中，我们将设置环境以开始处理服务。
- en: 7.2 Setting up the environment and the project structure
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 设置环境和项目结构
- en: 'In this section, we set up the environment to work on the orders service and
    lay out the high-level structure of the project. As in previous chapters, we’ll
    use Pipenv to manage our dependencies. Run the following commands to set up a
    Pipenv environment and activate it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设置环境以处理订单服务并概述项目的高级结构。与前面的章节一样，我们将使用Pipenv来管理我们的依赖项。运行以下命令以设置Pipenv环境并激活它：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll install our dependencies as we need in the following sections. Or if you
    prefer, copy the Pipfile and Pipfile.lock files from the GitHub repository under
    the ch07 folder and run `pipenv` `install`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中按需安装我们的依赖项。或者，如果您愿意，从ch07文件夹下的GitHub仓库复制Pipfile和Pipfile.lock文件，然后运行`pipenv
    install`。
- en: Our service implementation will live under a folder named orders, so go ahead
    and create it. To reinforce the separation of concerns between the core business
    layer and the API and database adapters, we’ll implement each of them in different
    directories, as shown in figure 7.4\. The business layer will live under orders/orders_service.
    Since the API layer is a web component, it will live under orders/web, which contains
    web adapters for the orders service. In this case, we are only including one type
    of web adapter, namely, a REST API, but nothing prevents you from adding a web
    adapter that returns dynamically rendered content from the server, as you would
    in a more traditional Django application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务实现将位于名为orders的文件夹下，所以请创建它。为了加强核心业务层与API和数据库适配器之间的关注点分离，我们将它们各自实现于不同的目录中，如图7.4所示。业务层将位于orders/orders_service。由于API层是一个网络组件，它将位于orders/web，其中包含订单服务的网络适配器。在这种情况下，我们只包含一种类型的网络适配器，即REST
    API，但没有任何东西阻止您添加一个从服务器返回动态渲染内容的网络适配器，就像在更传统的Django应用程序中做的那样。
- en: '![](../Images/07-04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-04.png)'
- en: 'Figure 7.4 To reinforce the separation of concerns, we implement each layer
    of the application in different directories: orders_service for the core business
    layer; repository for the data layer; and web/api for the API layer.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 为了加强关注点分离，我们在不同的目录中实现应用程序的每一层：orders_service用于核心业务层；repository用于数据层；web/api用于API层。
- en: The data layer will live under orders/repository. “Repository” might look like
    an unlikely name for our data layer, but we’re choosing this name because we’ll
    implement the repository pattern to interface with our data. This concept will
    become clearer in section 7.4\. In chapters 2 and 6 we covered the implementation
    of the API layer, so go ahead and copy over the files from the GitHub repository
    under ch07/order/web into your local directory. Notice that the API implementation
    has been adapted for this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层将位于orders/repository。虽然“repository”这个名字对于我们的数据层来说可能看起来不太合适，但我们选择这个名字是因为我们将实现仓库模式来与我们的数据接口。这个概念将在7.4节中变得更加清晰。在第2章和第6章中，我们介绍了API层的实现，所以请将GitHub仓库下ch07/order/web中的文件复制到您的本地目录。请注意，API实现已经为本章进行了适配。
- en: Listing 7.1 High-level structure of the orders service
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 订单服务的高级结构
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Pipfile contains the list of dependencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ① Pipfile包含依赖项列表。
- en: ② The full implementation of the orders service
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ② 订单服务的完整实现
- en: ③ The business layer
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 业务层
- en: ④ The data layer
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 数据层
- en: ⑤ Web adapters
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 网络适配器
- en: ⑥ REST API implementation
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ REST API实现
- en: ⑦ This file contains the instance of our web server object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 此文件包含我们的网络服务器对象实例。
- en: Since the folder structure has changed, the path to our FastAPI application
    object has also changed location, and therefore the command to run the API server
    is now
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件夹结构已更改，我们的FastAPI应用程序对象的路径也发生了变化，因此现在运行API服务器的命令是
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Due to the new folder structure, a few import paths and file locations have
    also changed. For the full list of changes, please refer to the ch07 folder under
    the GitHub repository for this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件夹结构的变化，一些导入路径和文件位置也发生了变化。有关更改的完整列表，请参阅GitHub存储库中本书的ch07文件夹。
- en: Now that our project is set up and ready to go, it’s time to get on with the
    implementation. Move on to the next section to learn how to add database models
    to the service!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目并准备开始，是时候着手实现部分了。进入下一节，了解如何将数据库模型添加到服务中！
- en: 7.3 Implementing the database models
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 实现数据库模型
- en: 'In the previous section, we learned how we’ll structure our project into three
    different layers: the core business layer, the API layer, and the data layer.
    This structure reinforces the separation of concerns among each layer, as recommended
    by the hexagonal architecture pattern that we learned in section 7.1\. Now that
    we know how we’ll structure our code, it’s time to focus on the implementation.
    In this section, we’ll define the database models for the orders service; that
    is, we’ll design the database tables and their fields. We start our implementation
    from the database since it will facilitate the rest of the discussion in this
    chapter. In a real-world context, you might start with the business layer, mocking
    the data layer and iterating back and forth between each layer until you’re done
    with the implementation. Just bear in mind that the linear approach we take in
    this chapter is not meant to reflect the actual development process, but is instead
    intended to illustrate concepts that we want to explain.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将我们的项目结构划分为三个不同的层：核心业务层、API层和数据层。这种结构强化了每一层之间的关注点分离，正如我们在7.1节中学到的六边形架构模式所推荐的那样。现在我们知道了代码的结构，是时候专注于实现了。在本节中，我们将定义订单服务的数据库模型；也就是说，我们将设计数据库表及其字段。我们从数据库开始实现，因为它将有助于本章其余部分的讨论。在实际环境中，你可能会从业务层开始，模拟数据层，并在每个层之间迭代，直到完成实现。只需记住，本章中我们采取的线性方法并不是要反映实际的开发过程，而是旨在说明我们想要解释的概念。
- en: To keep things simple in this chapter, we’ll use SQLite as our database engine.
    SQLite is a file-based relational database system. To use it, we don’t need to
    set up and run a server, as we would with PostgreSQL or MySQL, and there’s no
    configuration needed to start using it. Python’s core library has built-in support
    for interfacing with SQLite, which makes it a suitable choice for quick prototyping
    and experimentation before we are ready to move on to a production-ready database
    system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章内容简单易懂，我们将使用SQLite作为我们的数据库引擎。SQLite是一个基于文件的数据库系统。使用它时，我们不需要设置和运行服务器，就像使用PostgreSQL或MySQL那样，也不需要配置即可开始使用。Python的核心库内置了对SQLite的支持，这使得它成为在准备迁移到生产就绪数据库系统之前进行快速原型设计和实验的合适选择。
- en: We won’t manage our connection to the database and our queries manually. That
    is, we won’t be writing our own SQL statements to interact with the database.
    Instead, we’ll use SQLAlchemy—by far the most popular ORM (object relational mapper)
    in the Python ecosystem. An ORM is a framework that implements the data mapper
    pattern, which allows us to map the tables in our database to objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会手动管理数据库连接和查询。也就是说，我们不会编写自己的SQL语句来与数据库交互。相反，我们将使用SQLAlchemy——在Python生态系统中最受欢迎的ORM（对象关系映射器）。ORM是一个实现数据映射模式的框架，它允许我们将数据库中的表映射到对象上。
- en: DEFINITION A *data mapper* is an object wrapper around database tables and rows.
    It encapsulates database operations in the form of class methods, and it allows
    us to access data fields through class attributes.[⁴](#pgfId-1092805)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个 *数据映射器* 是围绕数据库表和行的一个对象包装器。它以类方法的形式封装数据库操作，并允许我们通过类属性访问数据字段。[⁴](#pgfId-1092805)'
- en: As you can see in figure 7.5, using an ORM makes it easier to manage our data
    since it gives us a class interface to the tables in the database. This allows
    us to leverage the benefits of object-oriented programming, including the ability
    to add custom methods and properties to our database models that enhance their
    functionality and encapsulate their behavior.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 7.5 中所见，使用 ORM 可以使管理我们的数据更容易，因为它为我们提供了数据库表的一个类接口。这使我们能够利用面向对象编程的好处，包括向我们的数据库模型添加自定义方法和属性，以增强其功能并封装其行为。
- en: '![](../Images/07-05.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-05.png)'
- en: Figure 7.5 Using an ORM, we can implement our data models as classes that map
    to database tables. Since the models are classes, we can enhance them with custom
    methods to add new functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 使用 ORM，我们可以将数据模型实现为映射到数据库表的类。由于模型是类，我们可以通过添加自定义方法来增强它们，以添加新的功能。
- en: Over time, our database models will change, and we need to be able to keep track
    of those changes. Changing the schema of our database is called a *migration*.
    As our database evolves, we’ll accumulate more and more migrations. We need to
    keep track of our migrations, since they allow us to reliably replicate the database
    schema in different environments and to roll out database changes to production
    with confidence. To manage this complex task, we’ll use Alembic. Alembic is a
    schema migration library that integrates seamlessly with SQLAlchemy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们的数据库模型将会发生变化，我们需要能够跟踪这些变化。改变我们数据库的模式被称为*迁移*。随着数据库的发展，我们将积累越来越多的迁移。我们需要跟踪我们的迁移，因为它们允许我们在不同的环境中可靠地复制数据库模式，并且有信心地将数据库更改部署到生产环境中。为了管理这个复杂的任务，我们将使用
    Alembic。Alembic 是一个与 SQLAlchemy 无缝集成的模式迁移库。
- en: 'Let’s start by installing both libraries by running the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过运行以下命令来安装这两个库：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we start working on our database models, let’s set up Alembic. (For
    additional help, please check out my video tutorial about setting up Alembic with
    SQLAlchemy at [https://youtu.be/nt5sSr1A_qw](https://youtu.be/nt5sSr1A_qw).) Run
    the following command to create a migrations folder, which will contain the history
    of all migrations in our database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始工作于数据库模型之前，让我们设置 Alembic。（如需更多帮助，请查看我关于使用 SQLAlchemy 设置 Alembic 的视频教程，链接为
    [https://youtu.be/nt5sSr1A_qw](https://youtu.be/nt5sSr1A_qw)。）运行以下命令以创建一个包含我们数据库所有迁移历史的
    migrations 文件夹：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This creates a folder called migrations, which comes with a configuration file
    called env.py and a versions/ directory. The versions/ directory will contain
    the migration files. The setup command also creates a configuration file called
    alembic.ini. To make Alembic work with an SQLite database, open alembic.ini, find
    a line that contains a declaration for the `sqlalchemy.url` variable, and replace
    it with the following content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 migrations 的文件夹，其中包含一个名为 env.py 的配置文件和一个 versions/ 目录。versions/ 目录将包含迁移文件。设置命令还会创建一个名为
    alembic.ini 的配置文件。为了使 Alembic 能够与 SQLite 数据库一起工作，打开 alembic.ini，找到包含 `sqlalchemy.url`
    变量声明的行，并将其替换为以下内容：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Commit the files generated by alembic The migrations folder contains all the
    information required to manage our database schema changes, so you should commit
    this folder, as well as alembic.ini. This will allow you to replicate the database
    setup in new environments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提交 alembic 生成的文件迁移文件夹包含了管理我们数据库模式变化所需的所有信息，因此你应该提交这个文件夹，以及 alembic.ini。这将允许你在新的环境中复制数据库设置。
- en: In addition, open migrations/env.py and find the lines with this content:[⁵](#pgfId-1092825)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，打开 migrations/env.py 并找到包含以下内容的行：[⁵](#pgfId-1092825)
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace them with the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下内容：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By setting `target_metadata` to our `Base` model’s `metadata`, we make it possible
    for Alembic to load our SQLAlchemy models and generate database tables from them.
    Next, we’ll implement our database models. Before we jump into the implementation,
    let’s pause for a moment to think about how many models we’ll need and the properties
    we should expect each model to have. The core object of the orders service is
    the order. Users place, pay, update, or cancel orders. Orders have a life cycle,
    and we’ll keep track of it through a `status` property. We’ll use the following
    list of properties to define our order model:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`target_metadata`设置为我们的`Base`模型的`metadata`，我们使Alembic能够加载我们的SQLAlchemy模型并从它们生成数据库表。接下来，我们将实现我们的数据库模型。在我们跳入实现之前，让我们暂停一下，思考我们需要多少个模型以及每个模型应该具有哪些属性。订单服务的核心对象是订单。用户下单、支付、更新或取消订单。订单有一个生命周期，我们将通过`status`属性来跟踪它。我们将使用以下属性列表来定义我们的订单模型：
- en: '*ID*—Unique ID for the order. We’ll give it the format of a Universally Unique
    Identifier (UUID). Using UUIDs instead of incremental integers is quite common
    these days. UUIDs work well in distributed systems, and they help to hide information
    about the number of orders that exist in the database from our users.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ID*—订单的唯一标识符。我们将使用通用唯一识别码（UUID）的格式。如今，使用UUID而不是递增整数相当常见。UUID在分布式系统中表现良好，并且有助于隐藏数据库中存在的订单数量信息，从而保护用户。'
- en: '*Creation date*—When the order was placed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建日期*—订单下单的时间。'
- en: '*Items*—The list of items included in the order and the amount of each product.
    Since an order can have any number of items linked to it, we’ll use a different
    model for items, and we’ll create a one-to-many relationship between the order
    and the items.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目*—订单中包含的项目列表以及每种产品的数量。由于一个订单可以与任何数量的项目相关联，我们将使用不同的项目模型，并在订单和项目之间创建一对一的关系。'
- en: '*Status*—The status of the order throughout the system. An order can have the
    following statuses:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态*—订单在整个系统中的状态。订单可以有以下状态：'
- en: '*Created*—The order has been placed.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建*—订单已下单。'
- en: '*Paid*—The order has been successfully paid.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已支付*—订单已成功支付。'
- en: '*Progress*—The order is being produced in the kitchen.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进度*—订单正在厨房生产中。'
- en: '*Cancelled*—The order has been cancelled.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已取消*—订单已被取消。'
- en: '*Dispatched*—The order is being delivered to the user.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已派遣*—订单正在向用户配送。'
- en: '*Delivered*—The order has been delivered to the user.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已送达*—订单已送达用户。'
- en: '*Schedule ID*—The ID of the order in the kitchen service. This ID is created
    by the kitchen service after scheduling the order for production, and we’ll use
    it to keep track of its progress in the kitchen.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调度ID*—厨房服务中订单的ID。此ID由厨房服务在调度订单生产后创建，我们将使用它来跟踪其在厨房中的进度。'
- en: '*Delivery ID*—The ID of the order in the delivery service. This ID is created
    by the delivery service after scheduling it for dispatch, and we’ll use it to
    keep track of its progress during delivery.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配送ID*—配送服务中订单的ID。此ID由配送服务在调度发货后创建，我们将使用它来跟踪其在配送过程中的进度。'
- en: 'When users place an order, they add any number of items to the order. Each
    item contains information about the product selected by the user, the size of
    the product, and the amount of it that the user wishes to purchase. There’s a
    one-to-many relationship between orders and items, and therefore we’ll implement
    a model for items and link them with a foreign key relationship. The item model
    will have the following list of attributes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户下单时，他们可以将任何数量的项目添加到订单中。每个项目包含用户选择的产品信息、产品的尺寸以及用户希望购买的数量。订单和项目之间存在一对一的关系，因此我们将实现一个项目模型并将它们通过外键关系链接起来。项目模型将具有以下属性列表：
- en: '*ID*—A unique identifier for the item in UUID format.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ID*—以UUID格式表示的项目唯一标识符。'
- en: '*Order ID*—A foreign key representing the ID of the order the item belongs
    to. This is what allows us to connect items and orders that belong together.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*订单ID*—表示项目所属订单ID的外键。这正是我们能够连接属于同一订单的项目和订单的原因。'
- en: '*Product*—The product selected by the user.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*产品*—用户选择的产品。'
- en: '*Size*—The size of the product.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尺寸*—产品的尺寸。'
- en: '*Quantity*—The amount of the product that the user wishes to purchase.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数量*—用户希望购买的产品数量。'
- en: Our SQLAlchemy models will live under the orders/repository folder, which we
    created to encapsulate our data layer, in a file called orders/repository/models.py.
    We’ll use these classes to interface with the database and rely on SQLAlchemy
    to translate these models into their corresponding database tables behind the
    scenes. Listing 7.2 shows the definition of the database models for the orders
    service. First, we create a declarative base model by using SQLALchemy’s `declarative_base()`
    function. The declarative base model is a class that can map ORM classes to database
    tables and columns, and therefore all our database models must inherit from it.
    We map class attributes to specific database columns by setting them to instances
    of SQLAlchemy’s `Column` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将SQLAlchemy模型放在我们创建的orders/repository文件夹下，以封装我们的数据层，在名为orders/repository/models.py的文件中。我们将使用这些类与数据库接口，并依赖SQLAlchemy在幕后将这些模型转换为相应的数据库表。列表7.2显示了订单服务的数据库模型定义。首先，我们使用SQLAlchemy的`declarative_base()`函数创建一个声明性基模型。声明性基模型是一个可以将ORM类映射到数据库表和列的类，因此所有我们的数据库模型都必须继承自它。我们通过将它们设置为SQLAlchemy的`Column`类的实例来将类属性映射到特定的数据库列。
- en: To map an attribute to another model, we use SQLAlchemy’s `relationship()` function.
    In listing 7.2, we use `relationship()` to create a one-to-many relationship between
    `OrderModel`’s `items` attribute and the `OrderItemModel` model. This means that
    we can access the list of items in an order through `OrderModel`’s `items` attribute.
    Each item also maps to the order it belongs to through the `order_id` property,
    which is defined as a foreign key column. Furthermore, `relationship()`’s `backref`
    argument allows us to access the full order object from an item directly through
    a property called `order`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个属性映射到另一个模型，我们使用SQLAlchemy的`relationship()`函数。在列表7.2中，我们使用`relationship()`创建`OrderModel`的`items`属性与`OrderItemModel`模型之间的一对多关系。这意味着我们可以通过`OrderModel`的`items`属性访问订单中的项目列表。每个项目也通过`order_id`属性映射到它所属的订单，该属性被定义为外键列。此外，`relationship()`的`backref`参数允许我们通过一个名为`order`的属性直接从项目访问完整的订单对象。
- en: Since we want our IDs to be in UUID format, we create a function that SQLAlchemy
    can use to generate the value. If we later switch to a database engine with built-in
    support for generating UUID values, we’ll leave it to the database to generate
    the IDs. Each database model is enhanced with a `dict()` method, which allows
    us to output the properties of a record in dictionary format. Since we’ll use
    this method to translate database models to business objects, the `dict()` method
    only returns the properties relevant to the business layer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望我们的ID以UUID格式，我们创建了一个函数，SQLAlchemy可以使用它来生成值。如果我们后来切换到具有内置UUID值生成支持的数据库引擎，我们将让数据库生成ID。每个数据库模型都增强了`dict()`方法，允许我们以字典格式输出记录的属性。由于我们将使用此方法将数据库模型转换为业务对象，`dict()`方法仅返回与业务层相关的属性。
- en: Listing 7.2 SQLAlchemy models for the orders service
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 SQLAlchemy的订单服务模型
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① We create our declarative base model.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建我们的声明性基模型。
- en: ② Custom function to create random UUIDs for our models
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ② 自定义函数用于为我们的模型生成随机UUID
- en: ③ All our models must inherit from Base.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 所有我们的模型都必须继承自Base。
- en: ④ Name of the table that maps to this model
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 映射到此模型的表名
- en: ⑤ Every class property maps to a database column by using the Column class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 每个类属性都通过Column类映射到数据库列。
- en: ⑥ We use relationship() to create a one-to-many relationship with the OrderItemModel
    model.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们使用relationship()与OrderItemModel模型创建一对一关系。
- en: ⑦ Custom method to render our objects as Python dictionaries
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 自定义方法以将我们的对象渲染为Python字典
- en: ⑧ We call dict() on each item to get its dictionary representation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们对每个项目调用dict()以获取其字典表示形式。
- en: 'To apply the models to the database, run the following command from the ch07
    directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模型应用到数据库，请在ch07目录下运行以下命令：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create a migration file under migrations/versions. We set the `PYTHONPATH`
    environment variable to the current directory using the `pwd` command so that
    Python looks for our models relative to this directory. You should commit your
    migration files and keep them in your version control system (e.g., a Git repository)
    since they’ll allow you to re-create your database for different environments.
    You can look in those files to understand the database operations that SQLAlchemy
    will perform to apply the migrations. To apply the migrations and create the schemas
    for these models in the database, run the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 migrations/versions 下创建一个迁移文件。我们使用 `pwd` 命令将 `PYTHONPATH` 环境变量设置为当前目录，这样
    Python 就会相对于这个目录查找我们的模型。你应该提交你的迁移文件，并将它们保存在你的版本控制系统（例如，Git 仓库）中，因为它们将允许你在不同的环境中重新创建你的数据库。你可以查看这些文件来了解
    SQLAlchemy 将执行哪些数据库操作以应用迁移。要应用迁移并在数据库中为这些模型创建模式，请运行以下命令：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will create the desired schemas in our database. Now that our database
    models are implemented and our database contains the desired schemas, it’s time
    to move on to the next step. Go to the next section to learn about the repository
    pattern!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的数据库中创建所需的模式。现在，我们的数据库模型已经实现，我们的数据库包含所需的模式，是时候进行下一步了。前往下一节了解存储库模式！
- en: 7.4 Implementing the repository pattern for data access
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 实现数据访问的存储库模式
- en: In the previous section, we learned to design the database models for the orders
    service and to manage changes to the database schema through migrations. With
    our database models ready, we can interact with the database to create orders
    and manage them. Now we have to decide how we make the data accessible to the
    business layer. In this section, we’ll first discuss different strategies to connect
    the business layer with the data layer, and we’ll learn what the repository pattern
    is and how we can use it to create an interface between the business layer and
    the database. Then we’ll move on to implementing it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何为订单服务设计数据库模型，并通过迁移管理数据库模式的变化。随着我们的数据库模型准备就绪，我们可以与数据库交互以创建订单并管理它们。现在我们必须决定如何使数据对业务层可用。在本节中，我们将首先讨论将业务层与数据层连接的不同策略，我们将了解存储库模式是什么，以及我们如何使用它来在业务层和数据库之间创建接口。然后我们将继续实现它。
- en: '7.4.1 The case for the repository pattern: What is it, and why is it useful?'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 存储库模式的案例：它是什麼，为什么它有用？
- en: In this section, we discuss different strategies for interfacing with the database
    from the business layer, and we introduce the repository pattern as a strategy
    that helps us decouple the business layer from the implementation details of the
    database.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了从业务层与数据库交互的不同策略，并介绍了存储库模式作为一种策略，帮助我们解耦业务层与数据库实现细节。
- en: As shown in figure 7.6, a common strategy to enable interactions between the
    business layer and the database is to use the database models directly within
    the business layer. Our database models already contain data about the orders,
    so we could enhance them with methods that implement business capabilities. This
    is called the *active record pattern*, which represents objects that carry both
    data and domain logic.[⁶](#pgfId-1092953) This pattern is useful when we have
    one-to-one mapping between service capabilities and database operations, or when
    we don’t need the collaboration of multiple domains.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 7.6 所示，一种常见的实现业务层和数据库之间交互的策略是在业务层直接使用数据库模型。我们的数据库模型已经包含了关于订单的数据，因此我们可以通过实现业务功能的方法来增强它们。这被称为
    *活动记录模式*，它代表同时携带数据和领域逻辑的对象。[⁶](#pgfId-1092953) 当我们有一个服务能力和数据库操作之间的一对一映射，或者当我们不需要多个领域的协作时，这种模式是有用的。
- en: '![](../Images/07-06.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-06.png)'
- en: Figure 7.6 A common approach to enable interactions between the data layer and
    the business layer is by using the database models directly in the business layer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 一种常见的实现数据层和业务层之间交互的方法是直接在业务层使用数据库模型。
- en: This approach works for simple cases; however, it couples the implementation
    of the business layer to the database and to the ORM framework of choice. What
    happens if we want to change the ORM framework later on, or if we want to switch
    to a different data storage technology that doesn’t involve SQL? In those cases,
    we’d have to make changes to our business layer. This breaks the principles we
    introduced in section 7.1\. Remember, the database is an adapter that the orders
    service uses to persist data, and the implementation details of the database should
    not leak into the business logic. Instead, data access will be encapsulated by
    our data access layer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于简单情况；然而，它将业务层的实现与数据库和所选的ORM框架耦合在一起。如果我们想稍后更改ORM框架，或者如果我们想切换到不涉及SQL的不同数据存储技术，会发生什么？在这些情况下，我们不得不修改我们的业务层。这违反了我们第7.1节中介绍的原则。记住，数据库是订单服务用来持久化数据的一个适配器，数据库的实现细节不应该泄露到业务逻辑中。相反，数据访问将由我们的数据访问层封装。
- en: To decouple the business layer from the data layer, we’ll use the repository
    pattern. This pattern gives us an in-memory list interface of our data. This means
    that we can get, add, or delete orders from the list, and the repository will
    take care of translating these operations into database-specific commands. Using
    the repository pattern means the data layer exposes a consistent interface to
    the business layer to interact with the database, regardless of the database technology
    we use to store our data. Whether we use an SQL database such as PostgreSQL, a
    NoSQL database like MongoDB, or an in-memory cache such as Redis, the repository
    pattern’s interface will remain the same and will encapsulate whichever specific
    operations are required to interact with the database. Figure 7.7 illustrates
    how the repository pattern helps us invert the dependency between the data layer
    and the business layer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使业务层与数据层解耦，我们将使用仓库模式。这种模式为我们提供了数据的内存列表接口。这意味着我们可以从列表中获取、添加或删除订单，而仓库将负责将这些操作转换为数据库特定的命令。使用仓库模式意味着数据层向业务层提供了一个一致的接口，以便与数据库交互，无论我们使用哪种数据库技术来存储我们的数据。无论是使用SQL数据库如PostgreSQL，还是使用NoSQL数据库如MongoDB，或者使用内存缓存如Redis，仓库模式的接口都将保持不变，并将封装与数据库交互所需的任何特定操作。图7.7说明了仓库模式如何帮助我们反转数据层和业务层之间的依赖关系。
- en: '![](../Images/07-07.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7](../Images/07-07.png)'
- en: Figure 7.7 The repository pattern encapsulates the implementation details of
    the data layer by exposing an in-memory list interface to the business layer,
    and it translates database models to business objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 仓库模式通过向业务层公开内存列表接口来封装数据层的实现细节，并将数据库模型转换为业务对象。
- en: definition The *repository pattern* is a software development pattern that provides
    an in-memory list interface to our data store. This helps us decouple our components
    from the low-level implementation details of the database. The repository takes
    care of managing interactions with the database and provides a consistent interface
    to our components, regardless of the database technology used. This allows us
    to change the database system without having to change our core business logic.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 仓库模式是一种软件开发模式，它为我们提供数据存储的内存列表接口。这有助于我们使我们的组件与数据库的低级实现细节解耦。仓库负责管理与数据库的交互，并为我们的组件提供一个一致的接口，无论使用哪种数据库技术。这允许我们在不更改核心业务逻辑的情况下更改数据库系统。
- en: Now that we know how we can use the repository pattern to allow the business
    layer to interface with the database while decoupling its implementation from
    low-level details of the database, we’ll learn to implement the repository pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用仓库模式允许业务层与数据库接口，同时将其实现从数据库的低级细节中解耦，我们将学习如何实现仓库模式。
- en: 7.4.2 Implementing the repository pattern
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 实现仓库模式
- en: 'How do we implement the repository pattern? We can use different approaches
    to this as long as we meet the following constraint: none of the operations carried
    out by the repository can be committed by the repository. What does this mean?
    It means that when we add an order object to the repository, the repository will
    add the order to a database session, but it will not commit the changes. Instead,
    it will be the responsibility of the consumer of `OrdersService` (i.e., the API
    layer) to commit the changes. Figure 7.8 illustrates this process.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现仓储模式？只要我们满足以下约束条件，我们可以使用不同的方法来实现：仓储执行的操作不能由仓储本身提交。这意味着什么？这意味着当我们向仓储添加一个订单对象时，仓储会将订单添加到数据库会话中，但不会提交更改。相反，提交更改的责任将落在`OrdersService`的消费者（即API层）身上。图7.8展示了这个过程。
- en: '![](../Images/07-08.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8](../Images/07-08.png)'
- en: Figure 7.8 Using the repository pattern, the API layer uses the `place_order()`
    capability of `OrdersService` to place an order. To place the order, `OrdersService`
    interfaces with the orders repository to add the order to the database. Finally,
    the API layer must commit the changes to persist them in the database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8使用仓储模式，API层使用`OrdersService`的`place_order()`功能下单。为了下单，`OrdersService`与订单仓储接口将订单添加到数据库。最后，API层必须提交更改以在数据库中持久化。
- en: 'Why can’t we commit database changes within the repository? First, because
    the repository acts just like an in-memory list representation of our data, and
    as such it doesn’t have a concept of database sessions and transactions; second,
    because the repository is not the right place to execute a database transaction.
    Instead, the context in which the repository is invoked provides the right context
    for executing database transactions. In many cases, our applications will execute
    multiple operations that involve one or more repositories and also call to other
    services. For example, figure 7.9 shows the number of operations involved in processing
    a payment:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能在仓储内提交数据库更改？首先，因为仓储就像是我们数据在内存中的列表表示，因此它没有数据库会话和事务的概念；其次，因为仓储不是执行数据库事务的正确地方。相反，仓储被调用的上下文提供了执行数据库事务的正确上下文。在许多情况下，我们的应用程序将执行涉及一个或多个仓储以及调用其他服务的多个操作。例如，图7.9显示了处理支付所涉及的操作数量：
- en: The API layer receives the request from the user and uses the `OrdersService`’s
    `pay_order()` method to process the request.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API层接收用户的请求，并使用`OrdersService`的`pay_order()`方法处理请求。
- en: '`OrdersService` talks to the payments service to process the payment.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrdersService`与支付服务接口处理支付。'
- en: If the payment is successful, `OrdersService` schedules the order with the kitchen
    service.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果支付成功，`OrdersService`将与厨房服务安排订单。
- en: '`OrdersService` updates the state of the order in the database using the orders
    repository.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OrdersService`使用订单仓储更新数据库中订单的状态。'
- en: If all the previous operations were successful, the API layer commits the transaction
    in the database; otherwise, it rolls back the changes.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有之前的操作都成功，API层将在数据库中提交事务；否则，它将回滚更改。
- en: '![](../Images/07-09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9](../Images/07-09.png)'
- en: Figure 7.9 In some situations, `OrdersService` has to interface with multiple
    repositories or services to perform an operation. In this example, `OrdersService`
    interfaces with the payments service to process a payment, then with the kitchen
    service to schedule the order for production, and finally updates the status of
    the order through the orders repository. All these operations must succeed or
    fail together, and it’s the responsibility of the API layer to commit or rollback
    accordingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9在某些情况下，`OrdersService`必须与多个仓储或服务接口进行交互以执行操作。在这个例子中，`OrdersService`与支付服务接口以处理支付，然后与厨房服务接口安排订单生产，最后通过订单仓储更新订单的状态。所有这些操作必须同时成功或失败，相应地提交或回滚的责任落在API层。
- en: These steps can be taken synchronously, one after the other, or asynchronously,
    in no specific order, but regardless of the approach, all steps must succeed or
    fail all together. As the unit of execution context, it’s the responsibility of
    the API layer to ensure that all changes are committed or rolled back as required.
    In section 7.6, we’ll learn how exactly the API layer controls the database session
    and commits the transactions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以同步进行，一个接一个，也可以异步进行，没有特定的顺序，但无论采用哪种方法，所有步骤都必须全部成功或全部失败。作为执行上下文的单元，API层的责任是确保所有更改都按要求提交或回滚。在第7.6节中，我们将学习API层如何精确地控制数据库会话并提交事务。
- en: 'At a minimum, a repository pattern implementation consists of a class that
    exposes a `get()` and an `add()` method, respectively, to be able to retrieve
    and add objects to the repository. For our purposes, we’ll also implement the
    following methods: `update()`, `delete()`, and `list()`. This will simplify the
    CRUD interface of the repository.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，一个仓库模式实现包括一个类，该类分别暴露`get()`和`add()`方法，以便能够从仓库中检索和添加对象。为了我们的目的，我们还将实现以下方法：`update()`、`delete()`和`list()`。这将简化仓库的CRUD接口。
- en: 'The following question bears some consideration in this context: when we fetch
    data through the repository, what kind of object should the repository return?
    In many implementations, you’ll see repositories returning instances of the database
    models (i.e., the classes defined in orders/repository/models.py). We won’t do
    that in this chapter. Instead, we’ll return objects that represent orders from
    the business layer domain. Why is it a bad idea to return instances of the database
    models through the repository? Because it defeats the purpose of the repository,
    which is to decouple the business layer from the data layer. Remember, we may
    want to change our persistence storage technology or our ORM framework. If that
    happens, the database classes we implemented in section 7.2 will no longer exist,
    and there’s no guarantee that a new framework would allow us to return objects
    with the same interfaces. For this reason, we don’t want to couple our business
    layer with them. Figure 7.10 illustrates the relationship between the business
    layer and the orders repository.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，以下问题值得考虑：当我们通过仓库获取数据时，仓库应该返回什么类型的对象？在许多实现中，你会看到仓库返回数据库模型实例（即，在`orders/repository/models.py`中定义的类）。在本章中，我们不会这样做。相反，我们将返回代表业务层领域订单的对象。为什么通过仓库返回数据库模型实例是一个坏主意？因为它违背了仓库的目的，即解耦业务层和数据层。记住，我们可能想要改变我们的持久化存储技术或我们的ORM框架。如果发生这种情况，我们在第7.2节中实现的数据库类将不再存在，而且不能保证新的框架会允许我们返回具有相同接口的对象。因此，我们不希望将我们的业务层与它们耦合。图7.10说明了业务层和订单仓库之间的关系。
- en: '![](../Images/07-10.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-10.png)'
- en: Figure 7.10 The repository pattern encapsulates the implementation details of
    the persistent storage technology used to manage our data. Our business layer
    only ever deals with the repository, and therefore we are free to change our persistent
    storage solution to a different technology without affecting our core application
    implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 仓库模式封装了用于管理我们数据的持久化存储技术的实现细节。我们的业务层只与仓库打交道，因此我们可以自由地将我们的持久化存储解决方案更改为不同的技术，而不会影响我们的核心应用程序实现。
- en: Our orders repository implementation will live under orders/repository/orders_
    repository.py. Listing 7.3 shows the implementation of the orders repository.
    It takes one required argument that represents the database session. Objects are
    added and deleted from the database session. The `add()` and `update()` methods
    take payloads that represent orders in the form of a Python dictionary. Our payloads
    are fairly simple, so a dictionary is sufficient here, but if we have more complex
    payloads, we should consider using objects instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的订单仓库实现将位于`orders/repository/orders_repository.py`下。列表7.3显示了订单仓库的实现。它接受一个表示数据库会话的必需参数。对象被添加到或从数据库会话中删除。`add()`和`update()`方法接受表示订单的Python字典形式的负载。我们的负载相当简单，所以在这里字典就足够了，但如果我们有更复杂的负载，我们应该考虑使用对象。
- en: With the exception of the `delete()` method, all methods of the repository return
    `Order` objects from the business layer (see section 7.5 for `Order`’s implementation
    details). To create instances of `Order`, we pass dictionary representations of
    the SQLAlchemy models using our custom `dict()` method from listing 7.2\. In the
    `add()` method, we also include a pointer to the actual SQLAlchemy model through
    `Order`’s `order_` parameter. As we’ll see in section 7.5, this pointer will help
    us access the order’s ID after committing the database transaction.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`delete()`方法外，仓库的所有方法都从业务层返回`Order`对象（有关`Order`的实现细节，请参阅第7.5节）。要创建`Order`的实例，我们使用列表7.2中的自定义`dict()`方法传递SQLAlchemy模型的字典表示。在`add()`方法中，我们还通过`Order`的`order_`参数包含对实际SQLAlchemy模型的指针。正如我们将在第7.5节中看到的，这个指针将帮助我们提交数据库事务后访问订单的ID。
- en: '`OrdersRepository`’s `get()`, `update()`, and `delete()` methods use the same
    logic to pull a record before returning, updating, or deleting it, so we define
    a common `_get()` method that knows how to obtain a record given an ID and optional
    filters. We fetch the record using the `first()` method of SQLAlchemy’s query
    object. `first()` returns an instance of the record if it exists, and otherwise
    it returns `None`. Alternatively, it’s also possible to use the `one()` method,
    which raises an error if the record doesn’t exist. `_get()` returns a database
    record, so it’s not meant to be used by the service layer, and we signal that
    by prefixing the method’s name with an underscore.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrdersRepository`的`get()`、`update()`和`delete()`方法使用相同的逻辑在返回、更新或删除之前拉取记录，因此我们定义了一个通用的`_get()`方法，它知道如何根据ID和可选的过滤器获取记录。我们使用SQLAlchemy查询对象的`first()`方法获取记录。`first()`如果存在则返回记录的实例，否则返回`None`。或者，也可以使用`one()`方法，如果记录不存在则引发错误。`_get()`返回数据库记录，因此它不是为服务层设计的，我们通过在方法名前加下划线来表示这一点。'
- en: The `list()` method accepts a `limit` parameter and optional filters. We build
    our query dynamically using SQLAlchemy’s `query` object. We also leverage SQLAlchemy’s
    `filter_by()` method to include additional filters in the query as keyword arguments,
    and we limit the query results by adding the `limit` parameter. Finally, we transform
    the database records into `Order` objects for consumption by the business layer
    by using the `dict()` method we implemented in listing 7.2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`方法接受一个`limit`参数和可选的过滤器。我们使用SQLAlchemy的`query`对象动态构建我们的查询。我们还利用SQLAlchemy的`filter_by()`方法将额外的过滤器作为关键字参数包含在查询中，并通过添加`limit`参数来限制查询结果。最后，我们使用我们在列表7.2中实现的`dict()`方法将数据库记录转换为`Order`对象，以便业务层使用。'
- en: 'The repository implementation is tightly coupled to the methods of SQLAlchemy’s
    `Session` object, but it also encapsulates these details, and to the business
    layer the repository appears as an interface to which we submit IDs and payloads,
    and we get `Order` objects in return. This is the point of the repository: to
    encapsulate and hide the implementation details of the data layer from the business
    layer. This means that if we switch to a different ORM framework, or to a different
    database system, we only need to make changes to the repository.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库实现与SQLAlchemy的`Session`对象的方法紧密耦合，但它也封装了这些细节，并且对于业务层来说，仓库看起来是一个接口，我们向其提交ID和有效负载，并返回`Order`对象。这是仓库的目的：封装和隐藏数据层的实现细节，以便于业务层。这意味着如果我们切换到不同的ORM框架或不同的数据库系统，我们只需要修改仓库。
- en: Listing 7.3 Orders repository
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 订单仓库
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① The repository’s initializer method requires a session object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ① 仓库的初始化方法需要一个会话对象。
- en: ② When creating a record for an order, we also create a record for each item
    in the order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在创建订单记录时，我们也会为订单中的每个项目创建一个记录。
- en: ③ We add the record to the session object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们将记录添加到会话对象中。
- en: ④ We return an instance of the Order class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们返回`Order`类的一个实例。
- en: ⑤ Generic method to retrieve a record by ID
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 通过ID检索记录的通用方法
- en: ⑥ We fetch the record using SQLAlchemy’s first() method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们使用SQLAlchemy的first()方法获取记录。
- en: ⑦ We retrieve a record using _get().
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们使用_get()方法检索记录。
- en: ⑧ If the order exists, we return an Order object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果订单存在，我们返回一个`Order`对象。
- en: ⑨ list() accepts a limit parameter and other optional filters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ list()接受一个限制参数和其他可选过滤器。
- en: ⑩ We build our query dynamically.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 我们动态构建我们的查询。
- en: ⑪ We filter by whether an order is cancelled using the SQLAlchemy’s filter()
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 我们使用SQLAlchemy的filter()方法根据订单是否已取消进行过滤。
- en: ⑫ We return a list of Order objects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 我们返回一个`Order`对象的列表。
- en: ⑬ To update an order, we first delete the items linked to the order and then
    create new items from the supplied payload.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 要更新订单，我们首先删除与订单链接的项目，然后从提供的有效负载中创建新的项目。
- en: ⑭ We dynamically update the database object using the setattr() function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 我们使用setattr()函数动态更新数据库对象。
- en: ⑮ To delete a record, we call SQLAlchemy’s delete() method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 要删除记录，我们调用SQLAlchemy的delete()方法。
- en: This completes the implementation of our data layer. We have implemented a persistent
    storage solution with the help of SQLAlchemy, and we have encapsulated the details
    of this solution with the help of the repository pattern. It’s now time to work
    on the business layer and see how it will interact with the repository!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们数据层的实现。我们借助SQLAlchemy实现了持久化存储解决方案，并使用存储库模式封装了该解决方案的细节。现在是时候着手业务层，看看它将如何与存储库交互了！
- en: 7.5 Implementing the business layer
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 实现业务层
- en: We’ve done a lot of work designing the database models for the orders service
    and using the repository pattern to build the interface to the data. It’s now
    time to focus on the business layer! In this section, we’ll implement the business
    layer of the orders service. That’s the core of the hexagon we introduced in section
    7.1 and illustrated in figure 7.1, which is reproduced here as figure 7.11 for
    your convenience. The business layer implements the service’s capabilities. What
    are the business capabilities of the orders service? From the analysis in chapter
    3 (section 3.4.2), we know that the orders service allows users of the platform
    to place their orders and manage them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为订单服务设计了大量的数据库模型，并使用存储库模式来构建数据接口。现在是时候专注于业务层了！在本节中，我们将实现订单服务的业务层。这就是我们在7.1节中介绍并在图7.1中展示的六边形架构的核心，为了您的方便，这里以图7.11的形式重现。业务层实现了服务的功能。订单服务的业务能力有哪些？从第3章（3.4.2节）的分析中，我们知道订单服务允许平台用户下单并管理订单。
- en: '![](../Images/07-11.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-11.png)'
- en: Figure 7.11 In hexagonal architecture, we distinguish a core layer in our application,
    the business layer, which implements the service’s capabilities. Other components,
    such as a web API interface or a database, are considered adapters that depend
    on the business layer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 在六边形架构中，我们在应用程序中区分了一个核心层，即业务层，它实现了服务的功能。其他组件，如Web API接口或数据库，被视为依赖于业务层的适配器。
- en: 'As illustrated in figure 7.12, the orders service manages the life cycle of
    an order through integrations with other services. The following list describes
    the capabilities of the orders service and highlights integrations with other
    services (refer to figure 7.9 for further clarification):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '如图7.12所示，订单服务通过与其他服务的集成来管理订单的生命周期。以下列表描述了订单服务的功能，并突出了与其他服务的集成（有关进一步说明，请参阅图7.9）： '
- en: '*Place orders*—Creates a record of an order in the system. The order won’t
    be scheduled in the kitchen until the user pays for it.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*下单*——在系统中创建订单记录。用户支付之前，订单不会被安排到厨房。'
- en: '*Process payments*—Processes payment for an order with the help of the payments
    service. If the payments service confirms the payment is successful, the orders
    service schedules the order for production with the kitchen service.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理支付*——在支付服务的帮助下处理订单的支付。如果支付服务确认支付成功，订单服务将使用厨房服务安排订单的生产。'
- en: '*Update orders*—Users can update their order any time to add or remove items
    from it. To confirm a change, a new payment must be made and processed with the
    help of the payments service.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更新订单*——用户可以随时更新订单，添加或删除其中的项目。为了确认更改，必须进行新的支付，并使用支付服务进行处理。'
- en: '*Cancel orders*—Users can cancel their orders anytime. Depending on the status
    of the order, the orders service will communicate with the kitchen or the delivery
    service to cancel the order.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*取消订单*——用户可以随时取消他们的订单。根据订单的状态，订单服务将与厨房或配送服务通信以取消订单。'
- en: '*Schedule order for production in the kitchen*—After payment, the orders service
    schedules the order for production in the kitchen with the help of the kitchen
    service.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在厨房安排订单生产*——支付后，订单服务在厨房的帮助下安排订单的生产。'
- en: '*Keep track of orders’ progress*—Users can keep track of their orders’ status
    through the orders service. Depending on the status of the order, the orders service
    checks with the kitchen or the delivery service to get updated information about
    the state of the order.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跟踪订单进度*——用户可以通过订单服务跟踪其订单的状态。根据订单的状态，订单服务会与厨房或配送服务联系，以获取订单状态的最新信息。'
- en: '![](../Images/07-12.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片7-12](../Images/07-12.png)'
- en: Figure 7.12 In order to perform some of its functions, the orders service needs
    to interact with orders services. For example, to process payments, it must interact
    with the payments service, and to schedule an order for production, it must interact
    with the kitchen service.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 为了执行某些功能，订单服务需要与订单服务进行交互。例如，为了处理支付，它必须与支付服务交互，为了安排订单生产，它必须与厨房服务交互。
- en: 'What’s the best way to model these actions in our business layer? We can use
    different approaches, but to make it easy for other components to interact with
    the business layer, we’ll expose a single unified interface through a class called
    `OrdersService`. We’ll define this class under orders/orders_service/orders_service.py.
    To fulfill its duties, `OrdersService` uses the orders repository to interface
    with the database. We could let `OrdersService` import and initialize the orders
    repository as in the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在业务层中最好地建模这些操作？我们可以使用不同的方法，但为了使其他组件更容易与业务层交互，我们将通过一个名为`OrdersService`的类公开一个单一的统一接口。我们将在`orders/orders_service/orders_service.py`下定义这个类。为了履行其职责，`OrdersService`使用订单存储库与数据库进行接口。我们可以让`OrdersService`导入并初始化订单存储库，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, doing this would place too much responsibility on the orders service
    since it would need to know how to configure the orders repository. It would also
    tightly couple the implementation of the orders repository and the orders service,
    and we wouldn’t be able to use different repositories if we needed to. As you
    can see in figures 7.13 and 7.14, a better approach is to use dependency injection
    in combination with the inversion of control principle.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做会给订单服务带来过多的责任，因为它需要知道如何配置订单存储库。它还会使订单存储库的实现和订单服务紧密耦合，如果我们需要使用不同的存储库，我们就无法这样做。如图7.13和7.14所示，更好的方法是结合使用依赖注入和控制反转原则。
- en: '![](../Images/07-13.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片7-13](../Images/07-13.png)'
- en: Figure 7.13 In conventional software design, dependencies follow a linear relationship,
    and each component is responsible for instantiating and configuring its own dependencies.
    In many cases, this couples our components to low-level implementation details
    in their dependencies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 在传统的软件开发中，依赖关系遵循线性关系，每个组件负责实例化和配置其自身的依赖。在许多情况下，这会使我们的组件与其依赖的低级实现细节紧密耦合。
- en: '![](../Images/07-14.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片7-14](../Images/07-14.png)'
- en: Figure 7.14 With inversion of control, we decouple components from their dependencies
    by supplying them at runtime using methods such as dependency injection. In this
    approach, it’s the responsibility of the context to provide correctly configured
    instances of the dependencies. The solid lines show relationships of dependency,
    while the dotted lines show how dependencies are injected.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 在控制反转中，我们通过在运行时使用如依赖注入等方法提供依赖项来解耦组件和它们的依赖项。在这种方法中，提供正确配置的依赖项实例的责任在于上下文。实线显示依赖关系，而虚线显示依赖项是如何注入的。
- en: DEFINITION *Inversion of control* is a software development principle that encourages
    us to decouple our components from their dependencies by supplying them at runtime.
    This allows us to control how the dependencies are supplied. One popular pattern
    to accomplish this is dependency injection. The context in which the dependencies
    are instantiated and supplied is called an *inversion of control container*. In
    the orders service, a suitable inversion of control container is the request object
    since most operations are specific to the context of a request.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *控制反转* 是一种软件开发原则，它鼓励我们在运行时提供依赖项，从而解耦我们的组件和它们的依赖项。这使我们能够控制依赖项的提供方式。实现这一目标的一种流行模式是依赖注入。依赖项实例化和提供的上下文称为
    *控制反转容器*。在订单服务中，一个合适的控制反转容器是请求对象，因为大多数操作都是特定于请求上下文的。
- en: The inversion of control principle states that we should decouple the dependencies
    in our code by letting the execution context supply those dependencies at runtime.
    This means that, instead of letting the orders service import and instantiate
    the orders repository, we should supply the repository at runtime. How do we do
    that? We can use different patterns to supply dependencies to our code, but one
    of the most popular, due to its simplicity and effectiveness, is dependency injection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转原则指出，我们应该通过让执行上下文在运行时提供这些依赖项来解耦我们的代码中的依赖项。这意味着，而不是让订单服务导入和实例化订单存储库，我们应该在运行时提供存储库。我们如何做到这一点？我们可以使用不同的模式来向我们的代码提供依赖项，但最流行的一种，由于其简单性和有效性，是依赖注入。
- en: DEFINITION *Dependency injection* is a software development pattern whereby
    we supply code dependencies at runtime. This helps us decouple our components
    from the specific implementation details of the code they depend on, since they
    don’t need to know how to configure and instantiate their dependencies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *依赖注入* 是一种软件开发模式，其中我们在运行时提供代码依赖项。这有助于我们解耦我们的组件与它们所依赖的代码的特定实现细节，因为它们不需要知道如何配置和实例化它们的依赖项。
- en: 'To make the orders repository injectable into the orders service, we parameterize
    it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使订单存储库可注入到订单服务中，我们对其进行参数化：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s now the responsibility of the caller to instantiate and configure the
    orders repository correctly. As you can see in figure 7.11, this has a very desirable
    outcome: depending on the context, we can supply different implementations of
    the repository or add different configurations. This makes the orders service
    easier to use in different contexts.[⁷](#pgfId-1093145)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用者有责任正确地实例化和配置订单存储库。如图7.11所示，这有一个非常理想的结果：根据上下文，我们可以提供不同的存储库实现或添加不同的配置。这使得订单服务在不同上下文中更容易使用。[⁷](#pgfId-1093145)
- en: Listing 7.4 shows the interface exposed by `OrdersService`. The class initializer
    takes an instance of the orders repository as a parameter to make it injectable.
    As per the inversion of control principle, when we integrate `OrdersService` with
    the API layer, it will be the responsibility of the API to get a valid instance
    of the orders repository and pass it to `OrdersService`. This approach is convenient,
    since it allows us to swap repositories at will when necessary, and it’ll make
    it very easy to write our tests in the next chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4显示了`OrdersService`公开的接口。类的初始化器接受一个订单存储库的实例作为参数，使其可注入。根据控制反转原则，当我们将`OrdersService`与API层集成时，获取有效的订单存储库实例并将其传递给`OrdersService`的责任将属于API。这种方法很方便，因为它允许我们在必要时随意交换存储库，并且它将使我们在下一章编写测试变得非常容易。
- en: Listing 7.4 Interface of the `OrdersService` class
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 `OrdersService`类的接口
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some of the actions listed under `OrdersService`, such as payment or scheduling,
    take place at the level of individual orders. Since orders contain data, it will
    be useful to have a class that represents orders and has methods to perform tasks
    related to an order. Within the context of the orders service, an order is a core
    object of the orders domain. In domain-driven design (DDD), we call these objects
    *domain objects*. These are the objects returned by the orders repository. We’ll
    implement our `Order` class under orders/orders_service/orders.py. Listing 7.5
    shows a preliminary implementation of the `Order` class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OrdersService`下列出的某些操作，例如支付或调度，是在单个订单级别进行的。由于订单包含数据，因此拥有一个代表订单并具有执行与订单相关任务的类将是有用的。在订单服务上下文中，订单是订单域的核心对象。在领域驱动设计（DDD）中，我们称这些对象为*领域对象*。这些是订单存储库返回的对象。我们将在`orders/orders_service/orders.py`下实现我们的`Order`类。列表7.5显示了`Order`类的初步实现。
- en: In addition to the `Order` class, listing 7.5 also provides an `OrderItem` class
    that represents each of the items in an order. We’ll use the `Order` class to
    represent orders before and after saving them to the database. Some of the properties
    of an order, such as the creation time or its ID, are set by the data layer and
    can be known only after the changes to the database have been committed. As we
    explained in section 7.4, committing changes is out of the scope of a repository,
    which means that when we add an order to the repository, the returned object won’t
    have those properties. The order’s ID and its creation time become available through
    the order’s database record after committing the transaction. For this reason,
    `Order`’s initializer binds the order’s ID, creation time, and status as private
    properties with a leading underscore (like in `self._id`), and we use the `order_`
    parameter in the `Order` class to hold a pointer to the order’s database record.
    If we retrieve the details of an order already saved to the database, `_id`, `_created`,
    and `_status` will have their corresponding values in the initializer; otherwise,
    they’ll be `None` and we’ll pull their values from `order_`. That’s why we define
    `Order`’s `id`, `created`, and `status` properties using the `property()` decorator,
    since it allows us to resolve their value depending on the state of the object.
    This is the only degree of coupling we’ll allow between the business layer and
    the data layer. And to make sure this dependency can be easily removed if we ever
    have to, we’re setting `order_` to `None` by default.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Order`类之外，列表7.5还提供了一个`OrderItem`类，它代表订单中的每个项目。我们将使用`Order`类来表示在保存到数据库之前和之后的订单。订单的一些属性，如创建时间或其ID，由数据层设置，并且只能在数据库更改提交后才能知道。正如我们在第7.4节中解释的，提交更改超出了存储库的范围，这意味着当我们向存储库添加订单时，返回的对象将不会有这些属性。订单的ID和创建时间在提交事务后通过订单的数据库记录变得可用。因此，`Order`的初始化方法将订单的ID、创建时间和状态绑定为带前导下划线的私有属性（如`self._id`），我们在`Order`类中使用`order_`参数来持有订单的数据库记录的指针。如果我们检索已保存到数据库的订单的详细信息，`_id`、`_created`和`_status`将在初始化器中具有相应的值；否则，它们将是`None`，我们将从`order_`中拉取它们的值。这就是为什么我们使用`property()`装饰器定义`Order`的`id`、`created`和`status`属性，因为它允许我们根据对象的状态来解析它们的值。这是我们将在业务层和数据层之间允许的唯一耦合程度。并且为了确保如果需要的话，这个依赖关系可以轻松移除，我们将`order_`默认设置为`None`。
- en: Listing 7.5 Implementation of the `Order` business object class
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 `Order`业务对象类的实现
- en: '[PRE15]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Business object that represents an order item
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 代表订单项的业务对象
- en: ② We declare the parameters of OrderItem’s initializer method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们声明了`OrderItem`初始化方法的参数。
- en: ③ The order_ parameter represents a database model instance.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `order_`参数代表一个数据库模型实例。
- en: ④ Since we resolve the ID dynamically, we store the provided ID as a private
    property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 由于我们动态解析ID，我们将提供的ID存储为私有属性。
- en: ⑤ We build an OrderItem object for each order item.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们为每个订单项构建一个`OrderItem`对象。
- en: ⑥ We resolve the ID dynamically using the property() decorator.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们使用`property()`装饰器动态解析ID。
- en: In addition to holding data about an order, the `Order` class also needs to
    handle tasks such as cancelling, paying, and scheduling an order. To fulfill those
    tasks, we must interface with external dependencies, such as the kitchen and payments
    services. As we explained in section 7.1, the goal of hexagonal architecture is
    to encapsulate access to external dependencies through adapters. However, to keep
    things simple in this chapter, we’ll implement the external API calls within the
    `Order` class. A good adapter pattern for encapsulating external API calls is
    the *facade pattern*.[⁸](#pgfId-1093223) Before we proceed with the implementation,
    we should know what those API calls look like.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了持有订单的数据之外，`Order`类还需要处理诸如取消、支付和安排订单等任务。为了完成这些任务，我们必须与外部依赖项接口，例如厨房和支付服务。正如我们在第7.1节中解释的，六边形架构的目标是通过适配器封装对外部依赖项的访问。然而，为了使本章的内容简单，我们将在`Order`类中实现外部API调用。封装外部API调用的良好适配器模式是*外观模式*。[⁸](#pgfId-1093223)在我们继续实施之前，我们应该知道这些API调用看起来是什么样子。
- en: 'To build the integration between the orders service and the kitchen and payments
    services, we’d want to run the kitchen and payments services and see how they
    work. However, we don’t need to run the actual services. The folder for this chapter
    in the GitHub repository for this book contains three OpenAPI files: one for the
    orders API (ch07/oas.yaml), one for the kitchen API (ch07/kitchen.yaml), and one
    for the payments API (ch07/payments.yaml). kitchen.yaml and payments.yaml tell
    us how the kitchen and payments APIs work, and that’s all the information we need
    to build our integration. Make sure to pull the kitchen.yaml and payments.yaml
    files from GitHub to be able to work with the following examples.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建订单服务与厨房和支付服务之间的集成，我们希望运行厨房和支付服务，看看它们是如何工作的。然而，我们不需要运行实际的服务。本书GitHub仓库中这一章的文件夹包含三个OpenAPI文件：一个用于订单API（ch07/oas.yaml），一个用于厨房API（ch07/kitchen.yaml），还有一个用于支付API（ch07/payments.yaml）。kitchen.yaml和payments.yaml告诉我们厨房和支付API是如何工作的，这就是我们构建集成所需的所有信息。确保从GitHub拉取kitchen.yaml和payments.yaml文件，以便能够使用以下示例。
- en: 'As it turns out, we can also use the kitchen and payments API specifications
    to simulate their behavior using mock servers. API mock servers replicate the
    server behind the APIs, validating our requests and returning valid responses.
    We’ll use Prism CLI ([https://github.com/stoplightio/prism](https://github.com/stoplightio/prism)),
    a library built and maintained by Stoplight, to mock the API server for the kitchen
    and payments services. Prism is a Node.js library, but don’t worry, it’s just
    a CLI tool; you don’t need to know any JavaScript to use it. To install the library,
    run the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们还可以使用厨房和支付API规范，通过模拟服务器来模拟它们的行为。API模拟服务器复制API背后的服务器，验证我们的请求并返回有效的响应。我们将使用由Stoplight构建和维护的Prism
    CLI（[https://github.com/stoplightio/prism](https://github.com/stoplightio/prism)），来模拟厨房和支付服务的API服务器。Prism是一个Node.js库，但不用担心，它只是一个命令行工具；你不需要了解任何JavaScript就能使用它。要安装这个库，运行以下命令：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: dealing with errors running prism You may run into errors when running Prism.
    A common error is not having a compatible version of Node.js. I recommend you
    install nvm to manage your Node versions and use the latest stable version of
    Node to run Prism. Also, make sure the port you select to run Prism is available.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Prism时处理错误你可能会在运行Prism时遇到错误。一个常见错误是没有兼容版本的Node.js。我建议你安装nvm来管理你的Node版本，并使用Node的最新稳定版本来运行Prism。此外，确保你选择的运行Prism的端口是可用的。
- en: This command will create a node_modules/ folder within your application folder,
    where Prism and all its dependencies will be installed. You don’t want to commit
    this folder, so make sure you add it to your .gitignore file. You’ll also see
    a new file called package.json, and another one called yarn.lock within your application
    directory. These are the files you want to commit since they’ll allow you to re-create
    the same node_modules/ directory in any other environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在你的应用程序文件夹内创建一个node_modules/文件夹，其中将安装Prism及其所有依赖项。你不希望提交这个文件夹，所以请确保将其添加到你的.gitignore文件中。你还会看到一个新的文件叫做package.json，以及另一个文件叫做yarn.lock在你的应用程序目录中。这些是你想要提交的文件，因为它们将允许你在任何其他环境中重新创建相同的node_modules/文件夹。
- en: 'To see Prism in action with the kitchen API, run the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Prism与厨房API的实际应用，运行以下命令：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will start a server on port 3000 that runs a mock service for the kitchen
    API. To get a taste of what we can do with it, run the following command to hit
    the GET `/kitchen/schedules` endpoint, which returns a list of schedules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在3000端口上启动一个服务器，该服务器运行厨房API的模拟服务。为了体验我们可以用它做什么，运行以下命令来调用GET `/kitchen/schedules`端点，该端点返回一个日程表列表：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Display json in the terminal like a pro with jq When outputting JSON to the
    terminal, either using cURL to interact with an API or catting a JSON file, I
    recommend you use JQ—a command-line utility that parses the JSON and produces
    a beautiful display. You can use JQ like this: `curl` `http://localhost: 3000/kitchen/schedules`
    `|` `jq`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '使用jq在终端中像专业人士一样显示json当你在终端输出JSON时，无论是使用cURL与API交互还是使用cat查看JSON文件，我建议你使用JQ——这是一个命令行实用工具，它可以解析JSON并产生美观的显示。你可以这样使用JQ：`curl`
    `http://localhost: 3000/kitchen/schedules` `|` `jq`。'
- en: 'You’ll see that the mock server started by Prism is able to return a perfectly
    valid payload representing a list of schedules. Impressive, to say the least!
    Now that we know how to run mock servers for the kitchen and payments APIs, let’s
    analyze the requirements of the API integrations with them:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到由 Prism 启动的模拟服务器能够返回一个表示调度列表的完全有效的有效负载。至少可以说，这是令人印象深刻的！现在我们知道了如何为厨房和支付 API
    运行模拟服务器，让我们分析与它们的 API 集成的需求：
- en: '*Kitchen service* *(kitchen.yaml)*—To schedule an order with the kitchen service,
    we must call the POST `/kitchen/schedules` endpoint with a payload containing
    the list of items in the order. In the response to this call, we’ll find the `schedule_id`,
    which we can use to keep track of the state of the order.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*厨房服务* *(kitchen.yaml)*—为了通过厨房服务安排订单，我们必须调用 POST `/kitchen/schedules` 端点，并带有包含订单中项目列表的有效负载。在这个调用的响应中，我们将找到
    `schedule_id`，我们可以用它来跟踪订单的状态。'
- en: '*Payments service* *(payments.yaml)*—To process the payment for an order, we
    must call the POST `/payments` endpoint with a payload containing the ID of the
    order. This is a mock endpoint for integration testing purposes.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*支付服务* *(payments.yaml)*—为了处理订单的支付，我们必须调用 POST `/payments` 端点，并带有包含订单 ID 的有效负载。这是一个用于集成测试的模拟端点。'
- en: Before we can cancel an order, we need to check its status. If the order is
    scheduled for production, we must hit the POST `/kitchen/schedules/{schedule_id}/cancel`
    endpoint to cancel the schedule. If the order is out for delivery, we won’t allow
    users to cancel the order, and therefore we raise an exception.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够取消订单之前，我们需要检查其状态。如果订单已安排生产，我们必须调用 POST `/kitchen/schedules/{schedule_id}/cancel`
    端点来取消调度。如果订单正在配送，我们不允许用户取消订单，因此我们将引发异常。
- en: 'To implement the API integrations, we’ll use the popular Python `requests`
    library. Run the following command to install the library with `pipenv`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 API 集成，我们将使用流行的 Python `requests` 库。运行以下命令使用 `pipenv` 安装库：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7.6 extends the implementation of the `Order` class by adding methods
    that implement API calls to the kitchen and payment services. For testing purposes,
    we’re expecting the kitchen API to run on port 3001 and the payments service to
    run on port 3000\. You can accomplish this by running the following commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 通过添加实现厨房和支付服务 API 调用的方法扩展了 `Order` 类的实现。为了测试目的，我们期望厨房 API 在端口 3001 上运行，支付服务在端口
    3000 上运行。你可以通过运行以下命令来完成此操作：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In each API call, we check that the response contains the expected status code,
    and if it doesn’t, we raise a custom `APIIntegrationError` exception. Also, if
    a user tries to perform an invalid action, such as cancelling an order when it’s
    already out for delivery, we raise an `InvalidActionError` exception.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次 API 调用中，我们检查响应是否包含预期的状态码，如果不包含，我们将引发自定义的 `APIIntegrationError` 异常。此外，如果用户尝试执行无效的操作，例如在订单已经发货时取消订单，我们将引发
    `InvalidActionError` 异常。
- en: Listing 7.6 Encapsulating per-order capabilities within the `Order` class
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 在 `Order` 类中封装每个订单的功能
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① If an order is in progress, we cancel its schedule by calling the kitchen
    API.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果订单正在进行中，我们将通过调用厨房 API 来取消其调度。
- en: ② If the response from the kitchen service is successful, we return.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果厨房服务的响应成功，我们将返回。
- en: ③ Otherwise, we raise an APIIntegrationError.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 否则，我们将引发 APIIntegrationError 异常。
- en: ④ We don’t allow orders that are being delivered to be cancelled.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们不允许取消正在配送的订单。
- en: ⑤ We process a payment by calling the payments API.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们通过调用支付 API 来处理支付。
- en: ⑥ We schedule an order for production by calling the kitchen API.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们通过调用厨房 API 来安排订单进行生产。
- en: ⑦ If the response from the kitchen service is successful, we return the schedule
    ID.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果厨房服务的响应成功，我们将返回调度 ID。
- en: Listing 7.7 contains the implementation of the custom exceptions we use in the
    order service to signal that something has gone wrong. We’ll use `OrderNotFoundError`
    in the `OrdersService` class when a user tries to fetch the details of an order
    that doesn’t exist.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 包含了我们用于订单服务以表示出现问题的自定义异常的实现。当用户尝试获取一个不存在的订单的详细信息时，我们将在 `OrdersService`
    类中使用 `OrderNotFoundError`。
- en: Listing 7.7 Orders service custom exceptions
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 订单服务自定义异常
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Exception to signal that an order doesn’t exist
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ① 异常用于表示订单不存在
- en: ② Exception to signal that an API integration error has taken place
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ② 异常用于表示发生了 API 集成错误
- en: ③ Exception to signal that the action being performed is invalid
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 异常用于表示正在执行的操作无效
- en: As we mentioned earlier, the API module won’t use the `Order` class directly.
    Instead, it will use a unified interface to all our adapters through the `OrdersService`
    class, whose interface we showed in listing 7.4\. `OrdersService` encapsulates
    the capabilities of the orders domain, and it takes care of using the orders repository
    to get orders objects and perform actions on them. Listing 7.8 shows the implementation
    of the `OrdersService` class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，API模块不会直接使用`Order`类。相反，它将通过`OrdersService`类使用所有适配器的统一接口，我们在第7.4节中展示了该接口。`OrdersService`封装了订单域的能力，并负责使用订单仓库获取订单对象并对它们执行操作。第7.8节展示了`OrdersService`类的实现。
- en: To instantiate the `OrdersService` class, we require an orders repository object
    that we can use to add or delete orders from our records. To place an order, we
    create a database record using the orders repository, and to retrieve the details
    of an order, we fetch the corresponding record from the database. If the requested
    order isn’t found, we raise an `OrderNotFoundError` exception. The `list_orders()`
    method accepts filters in the form of a dictionary. To get a list of orders, the
    orders repository forces us to pass a specific value for the `limit` argument,
    and therefore we extract its value from the `filters` dictionary by using the
    `pop()` method, which allows us to set a default value and also removes the key
    from the dictionary. In the `pay_order()` method, we process the payment using
    the payments API, and if the payment is successful, we schedule the order by calling
    the kitchen API. After scheduling the order, we update the order record by setting
    its `schedule_id` attribute to the schedule ID returned by the kitchen API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化`OrdersService`类，我们需要一个订单仓库对象，我们可以用它来添加或删除我们的记录中的订单。为了下订单，我们使用订单仓库创建一个数据库记录，为了获取订单的详细信息，我们从数据库中检索相应的记录。如果请求的订单未找到，我们抛出`OrderNotFoundError`异常。`list_orders()`方法接受字典形式的过滤器。为了获取订单列表，订单仓库强制我们为`limit`参数传递一个特定的值，因此我们使用`pop()`方法从`filters`字典中提取其值，这允许我们设置一个默认值，同时也从字典中删除了该键。在`pay_order()`方法中，我们使用支付API处理支付，如果支付成功，我们通过调用厨房API来安排订单。在安排订单后，我们通过将`schedule_id`属性设置为厨房API返回的安排ID来更新订单记录。
- en: Listing 7.8 Implementation of the `OrdersService`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 `OrdersService`实现
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① To instantiate the OrdersService class, we require an instance of the orders
    repository.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ① 要实例化`OrdersService`类，我们需要订单仓库的一个实例。
- en: ② We place an order by creating a database record.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们通过创建数据库记录来下订单。
- en: ③ We get the details of an order using the orders repository and passing in
    the requested ID.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们通过使用订单仓库并传入请求的ID来获取订单的详细信息。
- en: ④ If the order doesn’t exist, we raise an OrderNotFoundError exception.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果订单不存在，我们抛出`OrderNotFoundError`异常。
- en: ⑤ We capture filters as a dictionary by using keyword arguments.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们通过使用关键字参数将过滤器捕获为字典。
- en: ⑥ After scheduling the order, we update its schedule_id attribute.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 在安排订单后，我们更新其`schedule_id`属性。
- en: The orders service is ready to be used in our API module. However, before we
    continue with this integration, there’s one more piece in this puzzle that we
    need to solve. As we mentioned in section 7.4, the orders repository doesn’t commit
    any actions to the database. It’s the responsibility of the API, as the consumer
    of the `OrdersService`, to ensure that everything is committed at the end of an
    operation. How exactly does that work? Move on to section 7.6 to learn how!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 订单服务已准备好在我们的API模块中使用。然而，在我们继续进行此集成之前，这个谜题中还有一个部分需要我们解决。正如我们在第7.4节中提到的，订单仓库不会将任何操作提交到数据库。作为`OrdersService`的消费者，API的责任确保在操作结束时一切都被提交。这究竟是如何工作的？继续阅读第7.6节来了解详情！
- en: 7.6 Implementing the unit of work pattern
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 实现工作单元模式
- en: In this section, we’ll learn to handle database commits and rollbacks when interacting
    with the `OrdersService`. As you can see in figure 7.15, when we use the `OrdersService`
    class to access any of its capabilities, we must inject an instance of the `OrdersRepository`
    class. We must also open an SQLAlchemy session before we perform any actions,
    and we must commit any changes to our data to persist them in the database.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在交互`OrdersService`时处理数据库提交和回滚。正如你在图7.15中看到的，当我们使用`OrdersService`类访问其任何功能时，我们必须注入`OrdersRepository`类的实例。我们必须在执行任何操作之前打开一个SQLAlchemy会话，并且我们必须提交对数据的任何更改以将它们持久化到数据库中。
- en: '![](../Images/07-15.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07-15.png)'
- en: Figure 7.15 To persist our changes to the database, we could simply make the
    API layer use the SQLAlchemy session object to commit the transaction. In this
    figure, the solid lines represent calls, while the dashed lines represent injections
    of dependencies.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 为了将我们的更改持久化到数据库中，我们可以简单地让API层使用SQLAlchemy会话对象来提交事务。在这个图中，实线代表调用，而虚线代表依赖注入。
- en: What’s the best way to orchestrate these operations? We can use different approaches
    for this implementation. We could simply use SQLAlchemy session objects to wrap
    our calls to `OrdersService`, and once our operations succeed, use the session
    to commit, or roll back otherwise. This would work if `OrdersService` only ever
    had to deal with a single SQL database. However, what if we had to interact with
    a different type of database at the same time? We’d need to open a new session
    for it as well. What if we also had to handle integrations with other microservices
    within the same operation, and ensure we make the right API calls at the end of
    the transaction in case we had to roll back? Again, we could just add special
    clauses and guards to our code. The same code would have to be repeated in every
    API function that interacts with the `OrdersService`, so wouldn’t it be nice if
    there was pattern that can help us put it all together in a single place? Enter
    the unit of work pattern.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的操作编排方式是什么？我们可以使用不同的方法来实现这一点。我们可以简单地使用SQLAlchemy会话对象来包装我们对 `OrdersService`
    的调用，一旦我们的操作成功，就使用会话来提交，否则回滚。如果 `OrdersService` 只需要处理单个SQL数据库，这将有效。然而，如果我们同时需要与不同类型的数据库交互呢？我们需要为它打开一个新的会话。如果我们还必须在同一操作中处理与其他微服务的集成，并确保在事务结束时正确调用API，以防需要回滚，又会怎样呢？我们还可以在代码中添加特殊的子句和守卫。相同的代码必须在每个与
    `OrdersService` 交互的API函数中重复，所以如果有一个模式可以帮助我们将所有这些内容集中在一个地方，那岂不是很好？这就是工作单元模式的作用。
- en: DEfinition The *unit of work* is a design pattern that guarantees the atomicity
    of our business transactions, ensuring that all transactions are committed at
    once, or rolled back if any of them fails.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *工作单元* 是一种设计模式，保证了我们业务事务的原子性，确保所有事务一次性提交，或者如果有任何事务失败，则回滚。
- en: The unit of work is a pattern that ensures that all objects of a business transaction
    are changed together, and if something fails, it ensures none of them changes.[⁹](#pgfId-1093398)
    The notion comes from the world of databases, where database transactions are
    implemented as units of work which ensure that every transaction is
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元是一种模式，确保业务事务中的所有对象都一起更改，如果出现错误，则确保它们中没有任何一个发生变化。[⁹](#pgfId-1093398) 这个概念来自数据库领域，其中数据库事务作为工作单元实现，确保每个事务都是
- en: '*Atomic*—The whole transaction either succeeds or fails.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原子性*——整个事务要么成功，要么失败。'
- en: '*Consistent*—It conforms to the constrains of the database.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*——它符合数据库的约束。'
- en: '*Isolated*—It doesn’t interfere with other transactions.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隔离*——它不会干扰其他事务。'
- en: '*Durable*—It’s written to persistent storage.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久性*——它被写入持久存储。'
- en: These properties are known as the *ACID principles* in the world of databases
    ([https://en.wikipedia.org/wiki/Database_transaction](https://en.wikipedia.org/wiki/Database_transaction)).
    When it comes to services, the unit of work pattern helps us apply these principles
    in our operations. SQLAlchemy’s `Session` object already implements the unit of
    work pattern for database transactions ([http://mng.bz/jA5z](http://mng.bz/jA5z)).
    This means that we can add as many changes as we need to the same session and
    commit them all together. If something goes wrong, we can call the `rollback`
    method to undo any changes. In Python, we can orchestrate these steps with context
    managers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性在数据库领域被称为 *ACID原则* ([https://en.wikipedia.org/wiki/Database_transaction](https://en.wikipedia.org/wiki/Database_transaction))。当涉及到服务时，工作单元模式帮助我们将这些原则应用于我们的操作。SQLAlchemy的
    `Session` 对象已经实现了数据库事务的工作单元模式([http://mng.bz/jA5z](http://mng.bz/jA5z))。这意味着我们可以将所需的所有更改添加到同一个会话中，并一起提交。如果出现问题，我们可以调用
    `rollback` 方法来撤销任何更改。在Python中，我们可以使用上下文管理器来协调这些步骤。
- en: As you can see in figure 7.16, a context manager is a pattern that allows us
    to lock a resource during an operation, ensure that any necessary cleanup jobs
    are undertaken in case anything goes wrong, and finally release the lock once
    the operation is finished. The key syntactical feature of a context manager is
    the use of the `with` statement, as illustrated in figure 7.16\. As you can see
    in the illustration, context managers can return objects, which we can capture
    by using Python’s `as` clause. This is useful if the context manager is creating
    access to a resource, such as a file, on which we want to operate.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 7.16 所示，上下文管理器是一种允许我们在操作期间锁定资源、确保在出现任何错误时执行必要的清理工作，并在操作完成后最终释放锁的模式。上下文管理器的关键语法特性是使用
    `with` 语句，如图 7.16 所示。如图所示，上下文管理器可以返回对象，我们可以通过使用 Python 的 `as` 子句来捕获这些对象。如果上下文管理器正在创建对资源（例如文件）的访问，我们希望对其进行操作，这非常有用。
- en: '![](../Images/07-16.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16](../Images/07-16.png)'
- en: Figure 7.16 A class-based context manager has an `__init__()`, an `__enter__()`,
    and an `__exit__()` method. `__init__()` is triggered when we initialize the context
    manager. The `__enter__` method allows us to enter the context, and it’s called
    when we use the `with` statement. Using an `as` statement within the same line
    allows us to bind the return value of the `__enter__()` method to a variable (`unit_of_work`
    in this case). Finally, when we exit the context manager, the `__exit__()` method
    is triggered.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 基于类的上下文管理器具有 `__init__()`、`__enter__()` 和 `__exit__()` 方法。`__init__()`
    在初始化上下文管理器时触发。`__enter__()` 方法允许我们进入上下文，并在使用 `with` 语句时被调用。在同一行内使用 `as` 语句允许我们将
    `__enter__()` 方法的返回值绑定到一个变量（在本例中为 `unit_of_work`）。最后，当我们退出上下文管理器时，`__exit__()`
    方法被触发。
- en: 'In Python, we can implement context managers in multiple ways, including as
    a class or using the `contextmanager()` decorator from the `contextlib` module.[^(10)](#pgfId-1093426)
    In this section, we’ll implement our unit of work context manager as a class.
    A context manager class must implement at least the two following special methods:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以以多种方式实现上下文管理器，包括作为类或使用 `contextlib` 模块中的 `contextmanager()` 装饰器。[^(10)](#pgfId-1093426)
    在本节中，我们将以类的方式实现我们的工作单元上下文管理器。上下文管理器类必须实现至少以下两个特殊方法：
- en: '`__enter__``()`—Defines the operations that must be undertaken upon entering
    the context, such as creating a session or opening a file. If we need to perform
    actions on any of the objects created within the `__enter__()` method, we can
    return the object and capture its value through an `as` clause, as illustrated
    in figure 7.16.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__enter__()` — 定义进入上下文时必须执行的操作，例如创建会话或打开文件。如果我们需要在 `__enter__()` 方法创建的任何对象上执行操作，我们可以返回该对象，并通过
    `as` 子句捕获其值，如图 7.16 所示。'
- en: '`__exit__()`—Defines the operations that must be undertaken upon exiting the
    context, for example, closing a file or a session. The `__exit__()` method captures
    any exceptions raised during the execution of the context through three parameters
    in its method signature:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__exit__()` — 定义退出上下文时必须执行的操作，例如关闭文件或会话。`__exit__()` 方法通过其方法签名中的三个参数捕获在上下文执行过程中抛出的任何异常：'
- en: '`exc_type`—Captures the type of exception raised'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exc_type` — 捕获抛出的异常类型'
- en: '`exc_value`—Captures the value bound to the exception, typically the error
    message'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exc_value` — 捕获绑定到异常的值，通常是错误消息'
- en: '`traceback`—A traceback object that can be used to pinpoint the exact place
    where the exception took place'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceback` — 一个可以用来确定异常发生确切位置的回溯对象'
- en: If no exceptions are raised, the value of these three parameters will be `None`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有抛出异常，这三个参数的值将为 `None`。
- en: Listing 7.9 shows the implementation of the unit of work pattern as a context
    manager for the orders service. In the initializer method, we obtain a session
    factory object using SQLAlchemy’s `sessionmaker()` function, which requires a
    connection object that we produce with the help of SQLAlchemy’s `create_engine(`)
    function. To keep the example simple, we’re hardcoding the database connection
    string to point to our local SQLite database. In chapter 13, you’ll learn to parameterize
    this value and pull it from the environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 展示了将工作单元模式作为订单服务的上下文管理器的实现。在初始化方法中，我们使用 SQLAlchemy 的 `sessionmaker()`
    函数获取一个会话工厂对象，该函数需要一个连接对象，我们通过 SQLAlchemy 的 `create_engine()` 函数生成这个连接对象。为了简化示例，我们将数据库连接字符串硬编码为指向我们的本地
    SQLite 数据库。在第 13 章中，你将学习如何参数化此值并从环境中获取它。
- en: When we enter the context, we create a new database session, and we bind it
    to the `UnitOfWork` instance so that we can access it in other methods. We also
    return the context manager object itself so that the caller can access any of
    its attributes, such as the `session` object or the `commit()` method. On exiting
    the context, we check whether any exceptions were raised while adding or removing
    objects to the session, and if that’s the case, we roll back the changes to avoid
    leaving the database in an inconsistent state. We have access to the exception’s
    type (`exc_type`) and value (`exc_val`), and the traceback (`traceback`) context,
    which we can use to log the details of the error. If no exception took place,
    all three parameters will be set to `None`. Finally, we close the database session
    to release database resources and to end the scope of the transaction. We also
    add wrappers around SQLAlchemy’s `commit``()` and `rollback()` methods to avoid
    exposing database internals to the business layer.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入上下文时，我们创建一个新的数据库会话，并将其绑定到`UnitOfWork`实例，以便我们可以在其他方法中访问它。我们还返回上下文管理器对象本身，以便调用者可以访问其任何属性，例如`session`对象或`commit()`方法。在退出上下文时，我们检查在向会话添加或删除对象时是否抛出了任何异常，如果是这样，我们将回滚更改以避免使数据库处于不一致的状态。我们可以访问异常的类型（`exc_type`）、值（`exc_val`）和跟踪信息（`traceback`），我们可以使用这些信息来记录错误的详细信息。如果没有发生异常，所有三个参数都将设置为`None`。最后，我们关闭数据库会话以释放数据库资源并结束事务的作用域。我们还添加了`commit()`和`rollback()`方法的包装器，以避免将数据库内部暴露给业务层。
- en: Listing 7.9 Unit of work pattern as a context manager
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 将工作单元模式作为上下文管理器
- en: '[PRE24]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① We obtain a session factory object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们获取一个会话工厂对象。
- en: ② We open a new database session.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们打开一个新的数据库会话。
- en: ③ We return an instance of the unit of work object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们返回工作单元对象的实例。
- en: ④ On existing the context, we have access to any exceptions raised during the
    context’s execution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在上下文退出时，我们可以访问上下文执行期间抛出的任何异常。
- en: ⑤ We check whether an exception took place.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们检查是否发生了异常。
- en: ⑥ If an exception took place, roll back the transaction.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果发生异常，回滚事务。
- en: ⑦ We close the database session.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们关闭数据库会话。
- en: ⑧ Wrapper around SQLAlchemy’s commit() method
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ SQLAlchemy的`commit()`方法的包装器
- en: ⑨ Wrapper around SQLAlchemy’s rollback() method
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ SQLAlchemy的`rollback()`方法的包装器
- en: This is all very good, but how exactly are we supposed to use the `UnitOfWork`
    in combination with the orders repository and the `OrdersService`? In the next
    section, we’ll delve more into the details of this, but before we do that, listing
    7.10 gives you a template for how to use all these components together. We enter
    the unit of work context with Python’s syntax for context managers using a `with`
    statement. We also use an `as` statement to bind the return value of `UnitOfWork`’s
    `__enter__()` method to the `unit_of_work` variable. Then we get an instance of
    the orders repository passing in the `UnitOfWork`’s database session object, and
    an instance of the `OrdersService` class passing in the orders repository object.
    Then we use the orders service object to place an order, and we commit the transaction
    using `UnitOfWork`’s `commit()` method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很不错，但我们究竟应该如何使用`UnitOfWork`与订单存储库和`OrdersService`结合使用呢？在下一节中，我们将更深入地探讨这个细节，但在我们这样做之前，列表7.10为你提供了一个如何将这些组件一起使用的模板。我们使用Python的上下文管理器语法中的`with`语句进入工作单元上下文。我们还使用`as`语句将`UnitOfWork`的`__enter__()`方法的返回值绑定到`unit_of_work`变量。然后我们通过传递`UnitOfWork`的数据库会话对象获取订单存储库的实例，并通过传递订单存储库对象获取`OrdersService`类的实例。然后我们使用订单服务对象下订单，并使用`UnitOfWork`的`commit()`方法提交事务。
- en: Listing 7.10 Template pattern for using the unit of work and the repository
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 使用工作单元和存储库的模板模式
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① We enter the unit of work context.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们进入工作单元上下文。
- en: ② We get an instance of the orders repository passing in the UnitOfWork’s session.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们通过传递`UnitOfWork`的会话获取订单存储库的实例。
- en: ③ We get an instance of the OrdersService class passing in the orders repository
    object.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们通过传递订单存储库对象来获取`OrdersService`类的实例。
- en: ④ We place an order.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们下订单。
- en: ⑤ We commit the transaction.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们提交事务。
- en: Now that we have a unit of work that we can use to commit our transactions,
    let’s see how we put this all together by integrating the API layer with the service
    layer! Move on to section 7.7 to learn how we do that.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以使用来提交事务的工作单元，让我们看看如何通过将API层与服务层集成来将这些全部组合起来！继续阅读第7.7节，了解我们是如何做到这一点的。
- en: 7.7 Integrating the API layer and the service layer
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 集成API层和服务层
- en: In this section, we put everything we have learned in this chapter together
    to integrate the service layer with the API layer. We’ll make use of the template
    pattern we showed in listing 7.10 to use the `UnitOfWork` class in combination
    with `OrdersRepository` and `OrdersService`. When a user tries to perform an action
    on an order, we make sure we have checks in place to verify that the order exists
    in the first place; otherwise, we return a 404 (Not Found) error response.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将本章所学的一切整合起来，将服务层与 API 层集成。我们将利用列表 7.10 中展示的模板模式，结合使用 `UnitOfWork` 类和
    `OrdersRepository` 以及 `OrdersService`。当用户尝试对订单执行操作时，我们确保我们设置了检查来验证订单是否首先存在；否则，我们返回
    404（未找到）错误响应。
- en: Listing 7.11 shows the new version of the orders/web/api/api.py module. The
    first thing we do in every function is enter the context of `UnitOfWork`, making
    sure we bind the context object to a variable, `unit_of_work`. Then we create
    an instance of `OrdersRepository` using the session object from the `UnitOfWork`
    context object. Once we have an instance of the repository, we inject it into
    `OrdersService` as we create an instance of the service. Then we use the service
    to perform the operations required in each endpoint. In endpoints that perform
    actions on a specific order, we guard against the possibility of an `OrderNotFoundError`
    being raised by `OrdersService` if the requested order doesn’t exist.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 显示了 orders/web/api/api.py 模块的新版本。在每一个函数中，我们首先进入 `UnitOfWork` 的上下文，确保我们将上下文对象绑定到一个变量
    `unit_of_work` 上。然后我们使用 `UnitOfWork` 上下文对象中的会话对象创建一个 `OrdersRepository` 的实例。一旦我们有了仓库的实例，我们就在创建服务实例时将其注入到
    `OrdersService` 中。然后我们使用服务在每个端点执行所需的操作。在执行对特定订单的操作的端点中，我们防范 `OrdersService` 如果请求的订单不存在而抛出
    `OrderNotFoundError` 的可能性。
- en: In the `create_order()` function, we retrieve the dictionary representation
    of the order using `order.dict()` before we exit the `UnitOfWork` context so that
    we can access properties generated by the database during the commit process,
    such as the order’s ID. Remember that the order ID doesn’t exist until the changes
    are committed to the database, and therefore it’s only accessible within the scope
    of the database session. In our implementation, that means that we must access
    the ID before we exit the `UnitOfWork` context, since the database session closes
    right before exiting the context. Figure 7.17 illustrates this process.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create_order()` 函数中，我们在退出 `UnitOfWork` 上下文之前使用 `order.dict()` 获取订单的字典表示形式，以便我们可以访问在提交过程中由数据库生成的属性，例如订单的
    ID。请记住，订单 ID 在更改提交到数据库之前不存在，因此它只能在数据库会话的作用域内访问。在我们的实现中，这意味着我们必须在退出 `UnitOfWork`
    上下文之前访问 ID，因为数据库会话在退出上下文之前关闭。图 7.17 说明了这个过程。
- en: '![](../Images/07-17.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07-17.png)'
- en: Figure 7.17 When we place an order, the object returned by the orders repository
    doesn’t contain an ID. The ID will be available once we commit the database transaction
    through the `OrderModel` instance. Therefore, we bind an instance of the model
    to the `Order` object so that it can pull the ID from the model after the commit.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 当我们下订单时，订单仓库返回的对象不包含 ID。一旦我们通过 `OrderModel` 实例提交数据库事务，ID 就会可用。因此，我们将模型实例绑定到
    `Order` 对象上，以便在提交后从模型中提取 ID。记住，订单 ID 在提交到数据库之前不存在，因此它只能在数据库会话的作用域内访问。在我们的实现中，这意味着我们必须在退出
    `UnitOfWork` 上下文之前访问 ID，因为数据库会话在退出上下文之前关闭。图 7.17 说明了这个过程。
- en: Listing 7.11 Integration between API layer and service layer
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 API 层与服务层之间的集成
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① We enter the unit of work context.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们进入工作单元上下文。
- en: ② We place an order.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们下订单。
- en: ③ We access the order’s dictionary representation before exiting the unit of
    work context.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在退出工作单元上下文之前，我们访问订单的字典表示形式。
- en: ④ We use a try/except block to catch the OrderNotFoundError exception.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们使用 try/except 块来捕获 OrderNotFoundError 异常。
- en: This concludes our journey through the implementation of the service layer for
    the orders service. The patterns we learned in this chapter are not only applicable
    to the world of APIs and microservices, but to all application models generally.
    In particular, the repository pattern will always help you ensure that you keep
    your data access layer fully decoupled from the business layer, and the unit of
    work pattern will help you ensure that all transactions of a business operation
    are handled atomically and consistently.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们完成对订单服务服务层实现的旅程。在本章中我们学到的模式不仅适用于 API 和微服务的世界，而且适用于所有通用应用程序模型。特别是，仓库模式将始终帮助您确保您的数据访问层与业务层完全解耦，而工作单元模式将帮助您确保业务操作的所有事务都是原子性和一致性地处理的。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Hexagonal architecture, or architecture of ports and adapters, is a software
    architectural pattern that encourages us to decouple the business layer from the
    implementation details of the database and the application interface.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构，或称为端口和适配器架构，是一种软件架构模式，它鼓励我们将业务层与数据库实现细节和应用接口的实现细节解耦。
- en: The dependency inversion principle teaches us that the implementation details
    of our application components should depend on interfaces. This helps us decouple
    our components from the implementation details of their dependencies.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则教导我们，我们应用程序组件的实现细节应该依赖于接口。这有助于我们解耦我们的组件与其依赖的实现细节。
- en: To interface with the database, you can use an ORM library such as SQLAlchemy,
    which can translate database tables and rows into classes and objects. This provides
    the possibility of enhancing our database models with useful functionality for
    our application needs.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与数据库接口，你可以使用如SQLAlchemy这样的ORM库，它可以将数据库表和行转换为类和对象。这为我们提供了增强数据库模型以适应应用程序需求的有用功能的可能性。
- en: Repository is a software development pattern that helps to decouple the data
    layer from the business layer by adding an abstraction layer, which exposes an
    in-memory list interface of the data. Regardless of the database engine we use,
    the business layer will always receive the same objects from the repository.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库是一种软件开发模式，通过添加一个抽象层来帮助解耦数据层和业务层，该抽象层暴露了数据的内存列表接口。无论我们使用哪种数据库引擎，业务层都将始终从仓库接收相同的对象。
- en: The unit of work pattern helps ensure that all the business transactions that
    are part of an application operation succeed or fail together. If one of the transactions
    fails, the unit of work pattern ensures that all changes are rolled back. This
    mechanism ensures that data is never left in an inconsistent state.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作单元模式有助于确保所有作为应用程序操作一部分的业务事务要么全部成功，要么全部失败。如果其中一项事务失败，工作单元模式将确保所有更改都被回滚。这种机制确保数据永远不会处于不一致的状态。
- en: '* * *'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ Alistair Cockburn, “Hexagonal Architecture,” [https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/).
    You may be wondering why hexagonal and not pentagonal or heptagonal. As Alistair
    points out, it “is not a hexagon because the number six is important,” but because
    it helps to visually highlight the idea of a core application communicating with
    external components through ports (the sides of the hexagon), and it allows us
    to represent the two main sides of an application: the public-facing side (web
    components, APIs, etc.) and the internal side (databases, third-party integrations,
    etc.).'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ Alistair Cockburn，“六边形架构”，[https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)。你可能想知道为什么是六边形而不是五边形或七边形。正如Alistair所指出的，它“不是六边形不是因为数字六很重要”，而是因为它有助于从视觉上突出核心应用程序通过端口（六边形的边）与外部组件通信的概念，并允许我们表示应用程序的两个主要方面：面向公众的方面（Web组件、API等）和内部方面（数据库、第三方集成等）。
- en: ² Robert C. Martin, *Agile Software Development, Principles, Patterns, and Practices*
    (Prentice Hall, 2003), pp. 127–131.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ² Robert C. Martin，《敏捷软件开发：原则、模式和实践》（Prentice Hall，2003年），第127-131页。
- en: ³ For an excellent introduction to the dependency inversion principle, see Eric
    Freeman, Elizabeth Robson, Kathy Sierra, and Bert Bates, *Head First Design Patterns*
    (O’Reilly, 2014), pp. 141–143.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 关于依赖倒置原则的出色介绍，请参阅Eric Freeman、Elizabeth Robson、Kathy Sierra和Bert Bates合著的《Head
    First Design Patterns》（O’Reilly，2014年），第141-143页。
- en: ⁴ Martin Fowler, *Patterns of Enterprise Architecture* (Addison-Wesley, 2003),
    pp. 165–181.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ Martin Fowler，《企业架构模式》（Addison-Wesley，2003年），第165-181页。
- en: ⁵ The shape and format of this file may change over time, but for reference,
    at the time of this writing, those lines are 18–20.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 这个文件的形状和格式可能会随时间而改变，但为了参考，在撰写本文时，这些行是第18-20行。
- en: ⁶ Fowler, *Patterns of Enterprise Architecture*, pp. 160–164.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ Fowler，《企业架构模式》，第160-164页。
- en: ⁷ For more details on the inversion of control principle and the dependency
    injection pattern, see Martin Fowler, “Inversion of Control Containers and the
    Dependency Injection pattern,” [https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 关于控制反转原则和依赖注入模式的更多细节，请参阅Martin Fowler的“控制反转容器和依赖注入模式”，[https://martinfowler.com/articles/injection.html](https://martinfowler.com/articles/injection.html)。
- en: ⁸ Erich Gamma, Richard Helm, Ralph Johnsohn, and John Vlissides, *Design Patterns*
    (Addison-Wesley, 1995), pp. 185–193.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ⁸ Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides, *《设计模式》* (Addison-Wesley,
    1995), 第185–193页。
- en: ⁹ Fowler, *Patterns of Enterprise Architecture* (pp. 184–194).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ⁹ Fowler, *《企业架构模式》* (第184–194页)。
- en: ^(10) Ramalho, *Fluent Python* (O’Reilly, 2015), pp. 463–478.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: (10) Ramalho, *《流畅的Python》* (O’Reilly, 2015), 第463–478页。
