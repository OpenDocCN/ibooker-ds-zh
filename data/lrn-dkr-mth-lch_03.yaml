- en: 3 Building your own Docker images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 构建自己的 Docker 镜像
- en: You ran some containers in the last chapter and used Docker to manage them.
    Containers provide a consistent experience across applications, no matter what
    technology stack the app uses. Up till now you’ve used Docker images that I’ve
    built and shared; in this chapter you’ll see how to build your own images. This
    is where you’ll learn about the Dockerfile syntax, and some of the key patterns
    you will always use when you containerize your own apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经运行了一些容器并使用 Docker 来管理它们。容器无论应用程序使用什么技术栈，都能提供一致的应用体验。到目前为止，你使用的是我构建和分享的
    Docker 镜像；在本章中，你将了解如何构建自己的镜像。这里你将学习 Dockerfile 语法，以及你在容器化自己的应用程序时始终会使用的某些关键模式。
- en: 3.1 Using a container image from Docker Hub
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 从 Docker Hub 使用容器镜像
- en: We’ll start with the finished version of the image you’ll build in this chapter,
    so you can see how it’s been designed to work well with Docker. The try-it-now
    exercises all use a simple application called web-ping, which checks if a website
    is up. The app will run in a container and make HTTP requests to the URL for my
    blog every three seconds until the container is stopped.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从本章中构建的镜像的最终版本开始，这样你可以看到它是如何设计得与 Docker 一起良好工作的。现在试试看的练习都使用一个名为 web-ping
    的简单应用程序，该应用程序检查网站是否运行。该应用程序将在容器中运行，并每三秒向我的博客的 URL 发送 HTTP 请求，直到容器停止。
- en: You know from chapter 2 that `docker` `container` `run` will download the container
    image locally if it isn’t already on your machine. That’s because software distribution
    is built into the Docker platform. You can leave Docker to manage this for you,
    so it pulls images when they’re needed, or you can explicitly pull images using
    the Docker CLI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从第二章了解到，如果容器镜像尚未在您的机器上，`docker container run` 会本地下载该镜像。这是因为软件分发已经内置到 Docker
    平台中。你可以让 Docker 为你管理这些，当需要时它会拉取镜像，或者你可以使用 Docker CLI 明确地拉取镜像。
- en: 'Try it now Pull the container image for the web-ping application:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 拉取 web-ping 应用程序的容器镜像：
- en: '`docker image pull diamol/ch03-web-ping`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image pull diamol/ch03-web-ping`'
- en: You’ll see output similar to mine in figure 3.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似于图 3.1 中的我的输出。
- en: '![](../Images/3-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-1.jpg)'
- en: Figure 3.1 Pulling an image from Docker Hub
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 从 Docker Hub 拉取镜像
- en: The image name is `diamol/ch03-web-ping` , and it’s stored on Docker Hub, which
    is the default location where Docker looks for images. Image servers are called
    registries, and Docker Hub is a public registry you can use for free. Docker Hub
    also has a web interface, and you’ll find details about this image at *[https://hub.docker.com/r/
    diamol/ch03-web-ping](https://hub.docker.com/r/diamol/ch03-web-ping)* .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像名称是 `diamol/ch03-web-ping`，它存储在 Docker Hub 上，这是 Docker 默认查找镜像的位置。镜像服务器被称为注册表，Docker
    Hub 是一个你可以免费使用的公共注册表。Docker Hub 还有一个网页界面，你可以在 *[https://hub.docker.com/r/diamol/ch03-web-ping](https://hub.docker.com/r/diamol/ch03-web-ping)*
    找到关于这个镜像的详细信息。
- en: There’s some interesting output from the `docker` `image` `pull` command, which
    shows you how images are stored. A Docker image is logically one thing--you can
    think of it as a big zip file that contains the whole application stack. This
    image has the Node.js runtime together with my application code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image pull` 命令有一些有趣的输出，它显示了镜像是如何存储的。Docker 镜像在逻辑上是一件事——你可以把它想象成一个包含整个应用程序堆栈的大
    zip 文件。这个镜像包含了 Node.js 运行时以及我的应用程序代码。'
- en: During the pull you don’t see one single file downloaded; you see lots of downloads
    in progress. Those are called image layers. A Docker image is physically stored
    as lots of small files, and Docker assembles them together to create the container’s
    filesystem. When all the layers have been pulled, the full image is available
    to use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取过程中，你不会看到单个文件被下载；你会看到许多正在进行的下载。这些被称为镜像层。Docker 镜像在物理上存储为许多小文件，Docker 将它们组装在一起以创建容器的文件系统。当所有层都被拉取后，完整的镜像就可以使用了。
- en: 'Try it now Let’s run a container from the image and see what the app does:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 让我们从这个镜像中运行一个容器，看看应用程序做了什么：
- en: '`docker container run -d --name web-ping diamol/ch03-web-ping`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run -d --name web-ping diamol/ch03-web-ping`'
- en: The `-d` flag is a short form of `--detach`, so this container will run in the
    background. The application runs like a batch job with no user interface. Unlike
    the website container we ran detached in chapter 2, this one doesn’t accept incoming
    traffic, so you don’t need to publish any ports.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 标志是 `--detach` 的简写，因此这个容器将在后台运行。应用程序像批处理作业一样运行，没有用户界面。与第二章中我们运行的分离的网站容器不同，这个容器不接受传入流量，因此你不需要发布任何端口。'
- en: There’s one new flag in this command, which is `--name`. You know that you can
    work with containers using the ID that Docker generates, but you can also give
    them a friendly name. This container is called `web-ping`, and you can use that
    name to refer to the container instead of using the random ID.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中有一个新的标志，就是`--name`。你知道你可以使用Docker生成的ID来处理容器，但你也可以给它们一个友好的名称。这个容器被称为`web-ping`，你可以使用这个名字来引用容器而不是使用随机的ID。
- en: My blog is getting pinged by the app running in your container now. The app
    runs in an endless loop, and you can see what it’s doing using the same `docker`
    `container` commands you’re familiar with from chapter 2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我的博客现在正被你容器中运行的应用程序ping。该应用程序在一个无限循环中运行，你可以使用与第2章中熟悉相同的`docker` `container`命令来查看它在做什么。
- en: 'Try it now Have a look at the logs from the application, which are being collected
    by Docker:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 查看应用程序的日志，这些日志正在由Docker收集：
- en: '`docker container logs web-ping`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container logs web-ping`'
- en: You’ll see output like that in figure 3.2, showing the app making HTTP requests
    to *[blog.sixeyed.com](http://blog.sixeyed.com)* .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到图3.2中的输出，显示应用程序正在向*[blog.sixeyed.com](http://blog.sixeyed.com)* 发送HTTP请求。
- en: '![](../Images/3-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-2.jpg)'
- en: Figure 3.2 The web-ping container in action, sending constant traffic to my
    blog
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 网络ping容器正在运行，向我的博客发送持续流量
- en: An app that makes web requests and logs how long the response took is fairly
    useful--you could use it as the basis for monitoring the uptime of a website.
    But this application looks like it’s hardcoded to use my blog, so it’s pretty
    useless to anyone but me.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个能够发送网络请求并记录响应时间的应用程序非常有用——你可以将其用作监控网站运行时间的依据。但这个应用程序看起来是硬编码来使用我的博客，所以除了我之外对任何人来说都几乎毫无用处。
- en: Except that it isn’t. The application can actually be configured to use a different
    URL, a different interval between requests, and even a different type of HTTP
    call. This app reads the configuration values it should use from the system’s
    environment variables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它不是之外。该应用程序实际上可以被配置为使用不同的URL，请求之间的不同间隔，甚至是不同类型的HTTP调用。这个应用程序从系统的环境变量中读取它应该使用的配置值。
- en: Environment variables are just key/value pairs that the operating system provides.
    They work in the same way on Windows and Linux, and they’re a very simple way
    to store small pieces of data. Docker containers also have environment variables,
    but instead of coming from the computer’s operating system, they’re set up by
    Docker in the same way that Docker creates a hostname and IP address for the container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是操作系统提供的关键/值对。在Windows和Linux上它们以相同的方式工作，并且是存储小块数据的非常简单的方式。Docker容器也有环境变量，但它们不是来自计算机的操作系统，而是由Docker以创建容器的主机名和IP地址相同的方式设置。
- en: The web-ping image has some default values set for environment variables. When
    you run a container, those environment variables are populated by Docker, and
    that’s what the app uses to configure the website’s URL. You can specify different
    values for environment variables when you create the container, and that will
    change the behavior of the app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: web-ping镜像为环境变量设置了一些默认值。当你运行一个容器时，Docker会填充这些环境变量，这就是应用程序用来配置网站URL的方式。你可以在创建容器时指定不同的环境变量值，这将改变应用程序的行为。
- en: 'Try it now Remove the existing container, and run a new one with a value specified
    for the `TARGET` environment variable:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 移除现有的容器，并运行一个新的容器，为`TARGET`环境变量指定一个值：
- en: '` docker rm -f web-ping` ` docker container run --env TARGET=google.com diamol/ch03-web-ping`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker rm -f web-ping` ` docker container run --env TARGET=google.com diamol/ch03-web-ping`'
- en: Your output this time will look like mine in figure 3.3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你这次的输出将看起来像图3.3中的我的输出。
- en: '![](../Images/3-3.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-3.jpg)'
- en: Figure 3.3 A container from the same image, sending traffic to Google
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 来自同一镜像的容器，向Google发送流量
- en: This container is doing something different. First, it’s running interactively
    because you didn’t use the `--detach` flag, so the output from the app is shown
    on your console. The container will keep running until you end the app by pressing
    Ctrl-C. Second, it’s pinging google.com now instead of blog.sixeyed.com.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器正在做不同的事情。首先，它正在交互式运行，因为你没有使用`--detach`标志，所以应用程序的输出显示在你的控制台上。容器将继续运行，直到你通过按Ctrl-C结束应用程序。其次，它现在正在ping
    google.com而不是blog.sixeyed.com。
- en: This is going to be one of your major takeaways from this chapter--Docker images
    may be packaged with a default set of configuration values for the application,
    but you should be able to provide different configuration settings when you run
    a container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是本章中你将获得的主要收获之一--Docker 镜像可能包含应用程序的默认配置值集，但你应该能够在运行容器时提供不同的配置设置。
- en: Environment variables are a very simple way to achieve that. The web-ping application
    code looks for an environment variable with the key `TARGET` . That key is set
    with a value of `blog.sixeyed.com` in the image, but you can provide a different
    value with the `docker` `container` `run` command by using the `--env` flag. Figure
    3.4 shows how containers have their own settings, different from each other and
    from the image.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是一种非常简单的方式来实现这一点。web-ping 应用程序代码会查找一个键为 `TARGET` 的环境变量。该键在镜像中设置为 `blog.sixeyed.com`
    的值，但你可以通过使用 `docker container run` 命令中的 `--env` 标志来提供不同的值。图 3.4 显示了容器有自己的设置，彼此不同，也与镜像不同。
- en: The host computer has its own set of environment variables too, but they’re
    separate from the containers. Each container only has the environment variables
    that Docker populates. The important thing in figure 3.4 is that the web-ping
    applications are the same in each container--they use the same image, so the app
    is running the exact same set of binaries, but the behavior is different because
    of the configuration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主机计算机也有它自己的环境变量集，但它们与容器是分开的。每个容器只包含 Docker 填充的环境变量。图 3.4 中的重要之处在于，每个容器中的 web-ping
    应用程序是相同的--它们使用相同的镜像，因此应用程序运行的是完全相同的二进制文件集，但由于配置不同，行为不同。
- en: '![](../Images/3-4.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 3-4](../Images/3-4.jpg)'
- en: Figure 3.4 Environment variables in Docker images and containers
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 Docker 镜像和容器中的环境变量
- en: It’s down to the author of the Docker image to provide that flexibility, and
    you’re going to see how to do that now, as you build your first Docker image from
    a Dockerfile.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提供这种灵活性的责任在于 Docker 镜像的作者，你现在将看到如何做到这一点，因为你将从一个 Dockerfile 构建你的第一个 Docker 镜像。
- en: 3.2 Writing your first Dockerfile
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写你的第一个 Dockerfile
- en: The Dockerfile is a simple script you write to package up an application--it’s
    a set of instructions, and a Docker image is the output. Dockerfile syntax is
    simple to learn, and you can package up any kind of app using a Dockerfile. As
    scripting languages go, it is very flexible. Common tasks have their own commands,
    and for anything custom you need to do, you can use standard shell commands (Bash
    on Linux or PowerShell on Windows). Listing 3.1 shows the full Dockerfile to package
    up the web-ping application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是你编写的一个简单的脚本，用于打包应用程序--它是一组指令，Docker 镜像是输出结果。Dockerfile 语法易于学习，你可以使用
    Dockerfile 打包任何类型的应用程序。就脚本语言而言，它非常灵活。常见任务有自己的命令，而对于任何需要定制的任务，你可以使用标准 shell 命令（Linux
    上的 Bash 或 Windows 上的 PowerShell）。列表 3.1 展示了打包 web-ping 应用程序的完整 Dockerfile。
- en: Listing 3.1 The web-ping Dockerfile
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 web-ping Dockerfile
- en: '` FROM diamol/node` ` ENV TARGET="blog.sixeyed.com"` ` ENV METHOD="HEAD"` ` ENV
    INTERVAL="3000"` ` WORKDIR /web-ping` ` COPY app.js .` ` CMD ["node", "/web-ping/app.js"]`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/node` ` ENV TARGET="blog.sixeyed.com"` ` ENV METHOD="HEAD"` ` ENV
    INTERVAL="3000"` ` WORKDIR /web-ping` ` COPY app.js .` ` CMD ["node", "/web-ping/app.js"]`'
- en: 'Even if this is the first Dockerfile you’ve ever seen, you can probably take
    a good guess about what’s happening here. The Dockerfile instructions are `FROM`
    , `ENV` , `WORKDIR` , `COPY` , and `CMD` ; they’re in capitals, but that’s a convention,
    not a requirement. Here’s the breakdown for each instruction:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这是你第一次看到 Dockerfile，你也许可以很好地猜测这里发生了什么。Dockerfile 指令是 `FROM`、`ENV`、`WORKDIR`、`COPY`
    和 `CMD`；它们是大写字母，但这是一种约定，不是必需的。以下是每个指令的分解：
- en: '`FROM` --Every image has to start from another image. In this case, the `web-ping`
    image will use the `diamol/node` image as its starting point. That image has Node.js
    installed, which is everything the web-ping application needs to run.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM` --每个镜像都必须从一个镜像开始。在这种情况下，`web-ping` 镜像将使用 `diamol/node` 镜像作为其起点。该镜像已安装
    Node.js，这是 web-ping 应用程序运行所需的一切。'
- en: '`ENV` --Sets values for environment variables. The syntax is `[key]="[value]"`
    , and there are three `ENV` instructions here, setting up three different environment
    variables.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV` -- 设置环境变量的值。语法是 `[key]="[value]"`，这里有三个 `ENV` 指令，分别设置三个不同的环境变量。'
- en: '`WORKDIR` --Creates a directory in the container image filesystem, and sets
    that to be the current working directory. The forward-slash syntax works for Linux
    and Windows containers, so this will create `/web-ping` on Linux and `C:\web-ping`
    on Windows.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR` -- 在容器镜像文件系统中创建一个目录，并将其设置为当前工作目录。正斜杠语法适用于 Linux 和 Windows 容器，因此这将在
    Linux 上创建 `/web-ping`，在 Windows 上创建 `C:\web-ping`。'
- en: '`COPY` --Copies files or directories from the local filesystem into the container
    image. The syntax is `[source` `path]` `[target` `path]` --in this case, I’m copying
    app.js from my local machine into the working directory in the image.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY` -- 从本地文件系统复制文件或目录到容器镜像。语法是 `[source path] [target path]` -- 在这种情况下，我正在将
    app.js 从我的本地机器复制到镜像中的工作目录。'
- en: '`CMD` --Specifies the command to run when Docker starts a container from the
    image. This runs Node.js, starting the application code in app.js.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD` -- 指定在 Docker 从镜像启动容器时要运行的命令。这会运行 Node.js，启动 app.js 中的应用程序代码。'
- en: That’s it. Those instructions are pretty much all you need to package your own
    applications in Docker, and in those five lines there are already some good practices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这些指令几乎就是您在 Docker 中打包自己的应用程序所需的所有内容，并且在这五行中已经包含了一些良好的实践。
- en: 'Try it now You don’t need to copy and paste this Dockerfile; it’s all there
    in the book’s source code, which you cloned or downloaded in chapter 1\. Navigate
    to where you downloaded it, and check that you have all the files to build this
    image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。您不需要复制和粘贴这个 Dockerfile；它都在本书的源代码中，您在第一章中克隆或下载了它。导航到您下载它的位置，并检查您是否拥有构建此镜像所需的所有文件：
- en: '` cd ch03/exercises/web-ping` ` ls`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd ch03/exercises/web-ping` `ls`'
- en: 'You should see that you have three files:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到您有三个文件：
- en: Dockerfile (no file extension), which has the same content as listing 3.1
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile（没有文件扩展名），其内容与列表 3.1 相同
- en: app.js, which has the Node.js code for the web-ping application
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js，其中包含 web-ping 应用的 Node.js 代码
- en: README.md, which is just documentation for using the image
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: README.md，它只是使用镜像的文档
- en: You can see these in figure 3.5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图 3.5 中看到这些内容。
- en: You don’t need any understanding of Node.js or JavaScript to package this app
    and run it in Docker. If you do look at the code in app.js, you’ll see that it’s
    pretty basic, and it uses standard Node.js libraries to make the HTTP calls and
    to get configuration values from environment variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要了解 Node.js 或 JavaScript 就可以打包此应用并在 Docker 中运行它。如果您查看 app.js 中的代码，您会看到它相当基础，并且它使用标准的
    Node.js 库来执行 HTTP 调用并从环境变量中获取配置值。
- en: In this directory you have everything you need to build your own image for the
    web-ping application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，您拥有构建 web-ping 应用程序镜像所需的一切。
- en: '![](../Images/3-5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-5.jpg)'
- en: Figure 3.5 The content you need to build the Docker image
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 构建Docker镜像所需的内容
- en: 3.3 Building your own container image
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 构建自己的容器镜像
- en: Docker needs to know a few things before it can build an image from a Dockerfile.
    It needs a name for the image, and it needs to know the location for all the files
    that it’s going to package into the image. You already have a terminal open in
    the right directory, so you’re ready to go.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在从 Dockerfile 构建镜像之前需要知道一些事情。它需要一个镜像的名称，并且它需要知道所有将要打包到镜像中的文件的存储位置。您已经在正确的目录中打开了一个终端，所以您已经准备好了。
- en: 'Try it now Turn this Dockerfile into a Docker image by running `docker` `image`
    `build` :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。通过运行 `docker image build` 将这个 Dockerfile 转换为 Docker 镜像：
- en: '`docker image build --tag web-ping .`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build --tag web-ping .`'
- en: The `--tag` argument is the name for the image, and the final argument is the
    directory where the Dockerfile and related files are. Docker calls this directory
    the “context,” and the period means “use the current directory.” You’ll see output
    from the `build` command, executing all the instructions in the Dockerfile. My
    build is shown in figure 3.6.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`--tag` 参数是镜像的名称，最后一个参数是 Dockerfile 和相关文件所在的目录。Docker 将此目录称为“上下文”，点号表示“使用当前目录”。您将看到
    `build` 命令的输出，执行 Dockerfile 中的所有指令。我的构建过程如图 3.6 所示。'
- en: If you get any errors from the `build` command, you’ll first need to check that
    the Docker Engine is started. You need the Docker Desktop app to be running on
    Windows or Mac (check for the whale icon in your taskbar). Then check that you’re
    in the right directory. You should be in the `ch03-web-ping` directory where the
    Dockerfile and the app.js files are. Lastly, check that you’ve entered the `build`
    command correctly--the period at the end of the command is required to tell Docker
    that the build context is the current directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从`build`命令收到了任何错误，你首先需要检查Docker Engine是否已启动。你需要确保Windows或Mac上的Docker Desktop应用程序正在运行（检查任务栏中的鲸鱼图标）。然后检查你是否在正确的目录中。你应该在`ch03-web-ping`目录中，那里有Dockerfile和app.js文件。最后，检查你是否正确输入了`build`命令--命令末尾的点号是必需的，它告诉Docker构建上下文是当前目录。
- en: '![](../Images/3-6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-6.jpg)'
- en: Figure 3.6 Output from building the web-ping Docker image
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 构建web-ping Docker镜像的输出
- en: If you get a warning during the build about file permissions, that’s because
    you’re using the Docker command line on Windows to build Linux containers, thanks
    to Docker Desktop’s Linux container mode. Windows doesn’t record file permissions
    in the same way that Linux does, so the warning is telling you that all the files
    copied from your Windows machine are set with full read and write permissions
    in the Linux Docker image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建过程中收到关于文件权限的警告，那是因为你正在使用Windows上的Docker命令行来构建Linux容器，这是由于Docker Desktop的Linux容器模式所致。Windows不会像Linux那样记录文件权限，所以这个警告是在告诉你，从你的Windows机器复制过来的所有文件在Linux
    Docker镜像中都被设置为具有完全的读写权限。
- en: When you see the “successfully built” and “successfully tagged” messages in
    the output, your image is built. It’s stored locally in your image cache, and
    you can see it with the Docker command to list images.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在输出中看到“成功构建”和“成功标记”的消息时，你的镜像就构建完成了。它存储在本地镜像缓存中，你可以使用Docker命令来列出镜像。
- en: 'TRY IT NOW List all the images where the tag name starts with “w”:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: TRY IT NOW 列出所有以“w”开头的标签名的镜像：
- en: '`docker image ls ''w*''`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image ls ''w*''`'
- en: 'You’ll see your web-ping image listed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你的web-ping镜像被列出：
- en: '` > docker image ls w*` ` REPOSITORY TAG    IMAGE ID     CREATED        SIZE`
    ` web-ping   latest f2a5c430ab2a 14 minutes ago 75.3MB`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '` > docker image ls w*` ` REPOSITORY TAG    IMAGE ID     CREATED        SIZE`
    ` web-ping   latest f2a5c430ab2a 14 minutes ago 75.3MB`'
- en: You can use this image in exactly the same way as the one you downloaded from
    Docker Hub. The contents of the app are the same, and the configuration settings
    can be applied with environment variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个镜像，就像你从Docker Hub下载的那个一样。应用程序的内容是相同的，配置设置可以通过环境变量应用。
- en: 'Try it now Run a container from your own image to ping Docker’s website every
    five seconds:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '现在试试 Run a container from your own image to ping Docker’s website every five
    seconds:'
- en: '`docker container run -e TARGET=docker.com -e INTERVAL=5000 web-ping`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run -e TARGET=docker.com -e INTERVAL=5000 web-ping`'
- en: Your output will be like mine in figure 3.7, with the first log line confirming
    that the target web URL is docker.com and the ping interval is 5000 milliseconds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将像我图3.7中的那样，第一条日志确认目标Web URL是docker.com，ping间隔是5000毫秒。
- en: '![](../Images/3-7.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-7.jpg)'
- en: Figure 3.7 Running the web-ping container from your own image
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 从你的镜像运行web-ping容器
- en: That container is running in the foreground, so you’ll need to stop it with
    Ctrl-C. That ends the application, and the container will go into the exited state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器正在前台运行，所以你需要使用Ctrl-C来停止它。这会结束应用程序，容器将进入退出状态。
- en: You’ve packaged a simple application to run in Docker, and the process is exactly
    the same for more complicated apps. You write the Dockerfile with all the steps
    to package your app, collect the resources that need to go into the Docker image,
    and decide how you want users of your image to configure the behavior of the app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经打包了一个简单的应用程序，使其在Docker中运行，对于更复杂的应用程序，这个过程也是完全相同的。你编写Dockerfile，包含所有打包应用程序的步骤，收集需要放入Docker镜像中的资源，并决定你希望你的镜像用户如何配置应用程序的行为。
- en: 3.4 Understanding Docker images and image layers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 理解Docker镜像和镜像层
- en: You’ll be building plenty more images as you work through this book. For this
    chapter we’ll stick with this simple one and use it to get a better understanding
    of how images work, and the relationship between images and containers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在阅读这本书的过程中构建很多镜像。对于本章，我们将坚持使用这个简单的镜像，并使用它来更好地理解镜像的工作原理，以及镜像和容器之间的关系。
- en: The Docker image contains all the files you packaged, which become the container’s
    filesystem, and it also contains a lot of metadata about the image itself. That
    includes a brief history of how the image was built. You can use that to see each
    layer of the image and the command that built the layer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像包含你打包的所有文件，这些文件成为容器的文件系统，它还包含关于镜像本身的许多元数据。这包括镜像构建的简要历史。你可以用它来查看镜像的每一层以及构建层的命令。
- en: 'TRY IT NOW Check the history for your web-ping image:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。检查你的web-ping镜像的历史：
- en: '`docker image history web-ping`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image history web-ping`'
- en: 'You’ll see an output line for each image layer; these are the first few (abbreviated)
    lines from my image:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到每个镜像层的输出行；这些是我镜像的前几行（缩略）：
- en: '` > docker image history web-ping` ` IMAGE        CREATED      CREATED BY`
    ` 47eeeb7cd600 30 hours ago /bin/sh -c #(nop) CMD ["node" "/web-ping/ap...` ` <missing>
       30 hours ago /bin/sh -c #(nop) COPY file:a7cae366c9996502...` ` <missing>  
     30 hours ago /bin/sh -c #(nop) WORKDIR /web-ping`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '` > docker image history web-ping` ` IMAGE        CREATED      CREATED BY`
    ` 47eeeb7cd600 30 hours ago /bin/sh -c #(nop) CMD ["node" "/web-ping/ap...` ` <missing>
       30 hours ago /bin/sh -c #(nop) COPY file:a7cae366c9996502...` ` <missing>  
     30 hours ago /bin/sh -c #(nop) WORKDIR /web-ping`'
- en: The `CREATED` `BY` commands are the Dockerfile instructions--there’s a one-to-one
    relationship, so each line in the Dockerfile creates an image layer. We’re going
    to dip into a little more theory here, because understanding image layers is your
    key to making the most efficient use of Docker.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATED` 和 `BY` 命令是Dockerfile指令——存在一对一的关系，所以Dockerfile中的每一行都创建一个镜像层。我们将深入一点理论，因为理解镜像层是您高效使用Docker的关键。'
- en: 'A Docker image is a logical collection of image layers. Layers are the files
    that are physically stored in the Docker Engine’s cache. Here’s why that’s important:
    image layers can be shared between different images and different containers.
    If you have lots of containers all running Node.js apps, they will all share the
    same set of image layers that contain the Node.js runtime. Figure 3.8 shows how
    that works.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是一组逻辑上的镜像层。层是物理存储在Docker Engine缓存中的文件。这为什么很重要：镜像层可以在不同的镜像和不同的容器之间共享。如果你有很多运行Node.js应用的容器，它们将共享包含Node.js运行时的同一组镜像层。图3.8展示了这是如何工作的。
- en: '![](../Images/3-8.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-8.jpg)'
- en: Figure 3.8 How image layers are logically built into Docker images
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 镜像层如何逻辑地构建到Docker镜像中
- en: The `diamol/node` image has a slim operating system layer, and then the Node.js
    runtime. The Linux image takes up about 75 MB of disk (the base OS layer for Windows
    containers is larger, so the Windows version of the image uses closer to 300 MB).
    Your `web-ping` image is based on `diamol/node` , so it starts with all the layers
    from that image--that’s what the `FROM` instruction in the Dockerfile gives you.
    The `app.js` file you package on top of the base image is only a few kilobytes
    in size, so how big is the `web-ping` image in total?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`diamol/node` 镜像有一个精简的操作系统层，然后是Node.js运行时。Linux镜像占用大约75 MB的磁盘空间（Windows容器的基OS层更大，所以镜像的Windows版本使用接近300
    MB）。你的`web-ping`镜像基于`diamol/node`，所以它从该镜像的所有层开始——这就是Dockerfile中的`FROM`指令给你提供的。你打包在基础镜像之上的`app.js`文件只有几KB大小，所以`web-ping`镜像的总大小是多少？'
- en: 'Try it now You can list images with `docker` `image` `ls` , which also shows
    the size of the image. If you don’t include a filter in the command, you’ll see
    all images:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。你可以使用 `docker image ls` 来列出镜像，这也会显示镜像的大小。如果你在命令中不包含过滤器，你会看到所有镜像：
- en: '`docker image ls`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image ls`'
- en: Your output will be like mine in figure 3.9.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将像我图3.9中展示的那样。
- en: '![](../Images/3-9.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-9.jpg)'
- en: Figure 3.9 Listing images to see their sizes
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 列出镜像以查看它们的大小
- en: 'It looks like all the Node.js images take up the same amount of space--75 MB
    each on Linux. There are three of those: `diamol/node` , the original sample app
    you pulled from Docker Hub in `diamol/ch03-web-ping` , and the version you built
    yourself in `web-ping` . They should be sharing the base image layers, but the
    output from `docker` `image` `ls` suggests they’re each 75 MB in size, so that’s
    75 * 3 = 225 MB in total.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来所有的Node.js镜像占用的空间相同——Linux上每个75 MB。有三个这样的镜像：`diamol/node`，这是你在`diamol/ch03-web-ping`从Docker
    Hub拉取的原始示例应用，以及你在`web-ping`中自己构建的版本。它们应该共享基础镜像层，但`docker image ls`的输出表明它们每个都是75
    MB大小，所以总共是75 * 3 = 225 MB。
- en: But not exactly. The size column you see is the logical size of the image--that’s
    how much disk space the image would use if you didn’t have any other images on
    your system. If you do have other images that share layers, the disk space Docker
    uses is much smaller. You can’t see that from the image list, but there are Docker
    system commands that tell you more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不完全是这样。你看到的尺寸列是镜像的逻辑大小——这是如果没有其他镜像在你的系统上，该镜像将使用的磁盘空间量。如果你有其他共享层的镜像，Docker使用的磁盘空间要小得多。你无法从镜像列表中看到这一点，但有一些Docker系统命令可以告诉你更多信息。
- en: 'Try it now My image list shows a total of 363.96 MB of images, but that’s the
    total logical size. The `system` `df` command shows exactly how much disk space
    Docker is using:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试。我的镜像列表显示总共有363.96 MB的镜像，但这只是逻辑大小。`system df`命令显示了Docker实际使用的磁盘空间：
- en: '`docker system df`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker system df`'
- en: You can see in figure 3.10 that my image cache is actually using 202.2 MB, meaning
    163 MB of image layers are being shared between images, a 45% saving on disk space.
    The amount of disk space you save through reuse is typically much larger when
    you have a large number of application images all sharing the same base layers
    for the runtime. Those base layers might have Java, .NET Core, PHP--whatever technology
    stack you use, Docker’s behavior is the same.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图3.10中看到，我的镜像缓存实际上使用了202.2 MB，这意味着163 MB的镜像层在镜像之间被共享，节省了45%的磁盘空间。当你有大量应用程序镜像都共享相同的运行时基础层时，通过重用节省的磁盘空间量通常要大得多。这些基础层可能有Java、.NET
    Core、PHP——无论你使用什么技术栈，Docker的行为都是相同的。
- en: '![](../Images/3-10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-10.jpg)'
- en: Figure 3.10 Checking Docker’s disk space usage
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 检查Docker的磁盘空间使用情况
- en: One last piece of theory. If image layers are shared around, they can’t be edited--otherwise
    a change in one image would cascade to all the other images that share the changed
    layer. Docker enforces that by making image layers read-only. Once you create
    a layer by building an image, that layer can be shared by other images, but it
    can’t be changed. You can take advantage of that to make your Docker images smaller
    and your builds faster by optimizing your Dockerfiles.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点理论。如果镜像层被共享，它们不能被编辑——否则一个镜像的变化会级联到所有共享更改层的其他镜像。Docker通过使镜像层只读来强制执行这一点。一旦通过构建镜像创建了一个层，该层就可以被其他镜像共享，但不能被更改。你可以通过优化你的Dockerfile来利用这一点，使你的Docker镜像更小，构建更快。
- en: 3.5 Optimizing Dockerfiles to use the image layer cache
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 优化Dockerfile以使用镜像层缓存
- en: There’s a layer of your `web-ping` image that contains the application’s JavaScript
    file. If you make a change to that file and rebuild your image, you’ll get a new
    image layer. Docker assumes the layers in a Docker image follow a defined sequence,
    so if you change a layer in the middle of that sequence, Docker doesn’t assume
    it can reuse the later layers in the sequence.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`web-ping`镜像中有一层包含应用程序的JavaScript文件。如果你修改了该文件并重新构建你的镜像，你将得到一个新的镜像层。Docker假设Docker镜像中的层按照一个定义的顺序排列，所以如果你在序列中间修改了一个层，Docker不会假设它可以重用序列中的后续层。
- en: 'Try it now Make a change to the `app.js` file in the `ch03-web-ping` directory.
    It doesn’t have to be a code change; just adding a new empty line at the end of
    the file will do. Then build a new version of your Docker image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试。修改`ch03-web-ping`目录中的`app.js`文件。不需要是代码更改；只需在文件末尾添加一个新空行即可。然后构建你Docker镜像的新版本：
- en: '`docker image build -t web-ping:v2 .`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build -t web-ping:v2 .`'
- en: You’ll see the same output as mine in figure 3.11\. Steps 2 through 5 of the
    build use layers from the cache, and steps 6 and 7 generate new layers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与我图3.11中相同的输出。构建步骤2到5使用缓存中的层，步骤6和7生成新的层。
- en: '![](../Images/3-11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-11.jpg)'
- en: Figure 3.11 Building an image where layers can be used from the cache
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 构建可以使用缓存的层的镜像
- en: Every Dockerfile instruction results in an image layer, but if the instruction
    doesn’t change between builds, and the content going into the instruction is the
    same, Docker knows it can use the previous layer in the cache. That saves executing
    the Dockerfile instruction again and generating a duplicate layer. The input is
    the same, so the output will be the same, so Docker can use what’s already there
    in the cache.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile指令都会生成一个镜像层，但如果指令在构建之间没有变化，并且进入指令的内容相同，Docker知道它可以使用缓存中的先前层。这样可以节省再次执行Dockerfile指令并生成重复层。输入是相同的，所以输出也将是相同的，因此Docker可以使用缓存中已有的内容。
- en: Docker calculates whether the input has a match in the cache by generating a
    hash, which is like a digital fingerprint representing the input. The hash is
    made from the Dockerfile instruction and the contents of any files being copied.
    If there’s no match for the hash in the existing image layers, Docker executes
    the instruction, and that breaks the cache. As soon as the cache is broken, Docker
    executes all the instructions that follow, even if they haven’t changed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过生成一个哈希值来判断输入是否与缓存中的内容匹配，这个哈希值就像输入的数字指纹。哈希值是由Dockerfile指令和任何被复制的文件的内容生成的。如果现有镜像层中没有与该哈希值匹配的内容，Docker将执行指令，这会破坏缓存。一旦缓存被破坏，Docker将执行后续的所有指令，即使它们没有发生变化。
- en: That has an impact even in this small example image. The `app.js` file has changed
    since the last build, so the `COPY` instruction in step 6 needs to run. The `CMD`
    instruction in step 7 is the same as the last build, but because the cache was
    broken at step 6, that instruction runs as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个小示例镜像中，这也产生了影响。`app.js`文件自上次构建以来已更改，因此步骤6中的`COPY`指令需要运行。步骤7中的`CMD`指令与上次构建相同，但由于步骤6中缓存被破坏，该指令也会运行。
- en: Any Dockerfile you write should be optimized so that the instructions are ordered
    by how frequently they change--with instructions that are unlikely to change at
    the start of the Dockerfile, and instructions most likely to change at the end.
    The goal is for most builds to only need to execute the last instruction, using
    the cache for everything else. That saves time, disk space, and network bandwidth
    when you start sharing your images.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的任何Dockerfile都应该进行优化，以便指令按照它们变化的频率进行排序——在Dockerfile的开始处放置不太可能改变的指令，在末尾放置最可能改变的指令。目标是让大多数构建只需要执行最后的指令，其他所有内容都使用缓存。当你开始共享你的镜像时，这可以节省时间、磁盘空间和网络带宽。
- en: There are only seven instructions in the web-ping Dockerfile, but it can still
    be optimized. The `CMD` instruction doesn’t need to be at the end of the Dockerfile;
    it can be anywhere after the `FROM` instruction and still have the same result.
    It’s unlikely to change, so you can move it nearer the top. And one `ENV` instruction
    can be used to set multiple environment variables, so the three separate `ENV`
    instructions can be combined. The optimized Dockerfile is shown in listing 3.2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: web-ping Dockerfile中只有七个指令，但它仍然可以进行优化。`CMD`指令不需要放在Dockerfile的末尾；它可以在`FROM`指令之后任何位置，并且仍然会产生相同的结果。由于它不太可能改变，所以你可以将它移动到更靠近顶部的地方。并且可以使用一个`ENV`指令来设置多个环境变量，所以三个单独的`ENV`指令可以合并。优化后的Dockerfile显示在列表3.2中。
- en: Listing 3.2 The optimized web-ping Dockerfile
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 优化后的web-ping Dockerfile
- en: '` FROM diamol/node` ` CMD ["node", "/web-ping/app.js"]` ` ENV TARGET="blog.sixeyed.com"
    \` `       METHOD="HEAD" \` `       INTERVAL="3000"` ` WORKDIR /web-ping` ` COPY
    app.js .`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/node` ` CMD ["node", "/web-ping/app.js"]` ` ENV TARGET="blog.sixeyed.com"
    \` `       METHOD="HEAD" \` `       INTERVAL="3000"` ` WORKDIR /web-ping` ` COPY
    app.js .`'
- en: 'Try it now The optimized Dockerfile is in the source code for this chapter
    too. Switch to the `web-ping-optimized` folder and build the image from the new
    Dockerfile:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 优化后的Dockerfile也包含在本章的源代码中。切换到`web-ping-optimized`文件夹，并从新的Dockerfile构建镜像：
- en: '` cd ../web-ping-optimized` ` docker image build -t web-ping:v3 .`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ../web-ping-optimized` ` docker image build -t web-ping:v3 .`'
- en: You won’t notice too much difference from the previous build. There are now
    five steps instead of seven, but the end result is the same--you can run a container
    from this image, and it behaves just like the other versions. But now if you change
    the application code in `app.js` and rebuild, all the steps come from the cache
    except the final one, which is exactly what you want, because that’s all you’ve
    changed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的构建相比，你不会注意到太大的差异。现在有五个步骤而不是七个，但最终结果是一样的——你可以从这个镜像运行容器，它的行为就像其他版本一样。但现在，如果你更改了`app.js`中的应用程序代码并重新构建，除了最后的步骤之外，所有步骤都来自缓存，这正是你想要的，因为这就是你更改的全部内容。
- en: That’s all for building images in this chapter. You’ve seen the Dockerfile syntax
    and the key instructions you need to know, and you’ve learned how to build and
    work with images from the Docker CLI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于构建镜像的内容到此结束。你已经看到了Dockerfile的语法和需要了解的关键指令，并且学习了如何从Docker CLI构建和使用镜像。
- en: 'There are two more important things to take from this chapter, which will be
    of good service to you in every image you build: optimize your Dockerfiles, and
    make sure your image is portable so you use the same image when you deploy to
    different environments. That really just means you should take care how you structure
    your Dockerfile instructions, and make sure the application can read configuration
    values from the container. It means you can build images quickly, and when you
    deploy to production you’re using the exact same image that was quality-approved
    in your test environments.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中还可以提取两个重要的事项，这些事项将有助于您构建的每一个镜像：优化您的 Dockerfile，并确保您的镜像具有可移植性，以便在部署到不同环境时使用相同的镜像。这实际上意味着您应该注意如何结构化您的
    Dockerfile 指令，并确保应用程序可以从容器中读取配置值。这意味着您可以快速构建镜像，并且在部署到生产环境时，您使用的是在测试环境中经过质量审核的完全相同的镜像。
- en: 3.6 Lab
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 实验室
- en: 'Okay, it’s lab time. The goal here is to answer this question: how do you produce
    a Docker image without a Dockerfile? The Dockerfile is there to automate the deployment
    of your app, but you can’t always automate everything. Sometimes you need to run
    the application and finish off some steps manually, and those steps can’t be scripted.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是实验室时间。这里的目的是回答这个问题：如何在没有 Dockerfile 的情况下创建 Docker 镜像？Dockerfile 用于自动化应用程序的部署，但您并不总是能够自动化一切。有时您需要手动运行应用程序并完成一些步骤，而这些步骤无法被脚本化。
- en: 'This lab is a much simpler version of that. You’re going to start with an image
    on Docker Hub: `diamol/ch03-lab` . That image has a file at the path `/diamol/ch03.txt`
    . You need to update that text file and add your name at the end. Then produce
    your own image with your changed file. You’re not allowed to use a Dockerfile.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验室是这个更简单版本的。您将从一个 Docker Hub 上的镜像开始：`diamol/ch03-lab`。这个镜像在路径 `/diamol/ch03.txt`
    处有一个文件。您需要更新这个文本文件并在末尾添加您的名字。然后使用您更改的文件创建自己的镜像。不允许使用 Dockerfile。
- en: 'There’s a sample solution on the book’s GitHub repository if you need it. You’ll
    find it here: *[https://github.com/sixeyed/diamol/tree/master/ch03/lab](https://github.com/sixeyed/diamol/tree/master/ch03/lab)*
    .'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以在本书的 GitHub 仓库中找到示例解决方案。您可以在以下链接找到它：*[https://github.com/sixeyed/diamol/tree/master/ch03/lab](https://github.com/sixeyed/diamol/tree/master/ch03/lab)*。
- en: 'Here are some hints to get you going:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示来帮助您开始：
- en: Remember that the `-it` flags let you run to a container interactively.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住 `-it` 标志可以让您以交互方式运行到容器中。
- en: The filesystem for a container still exists when it is exited.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的文件系统在退出时仍然存在。
- en: There are lots of commands you haven’t used yet. `docker` `container` `--help`
    will show you two that could help you solve the lab.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有许多您尚未使用的命令。`docker container --help` 将显示两个可能帮助您解决实验室问题的命令。
