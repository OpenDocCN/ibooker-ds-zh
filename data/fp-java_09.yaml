- en: Chapter 10\. More data handling with trees
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 使用树进行更多数据处理
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Understanding the relationships between size, height, and depth in a tree structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解树结构中大小、高度和深度的关系
- en: Understanding the relationship between insertion order and the binary search
    tree structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解插入顺序与二叉搜索树结构之间的关系
- en: Traversing trees in various orders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同顺序遍历树
- en: Implementing the binary search tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现二叉搜索树
- en: Merging, folding, and balancing trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并、折叠和平衡树
- en: 'In [chapter 5](kindle_split_012.xhtml#ch05), you learned about the singly linked
    list, which is probably the most widely used data structure in functional programming.
    Although the list is a very efficient data structure for many operations, it has
    some limitations, the main one being that the complexity of accessing elements
    grows proportionally with the number of elements. For example, searching for a
    particular element may necessitate examining all elements if it happens that the
    searched-for element is the last in the list. Among other less efficient operations
    are sorting, accessing elements by their index, and finding the maximal or minimal
    element. Obviously, to find the maximal (or minimal) element in a list, one has
    to traverse the whole list. In this chapter, you’ll learn about a data structure
    that solves these problems: binary trees.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_012.xhtml#ch05)中，你学习了单链表，这可能是函数式编程中最广泛使用的数据结构。尽管列表对于许多操作来说是一个非常高效的数据结构，但它有一些局限性，主要的一个是访问元素的复杂度与元素数量成比例增长。例如，如果搜索的元素恰好是列表中的最后一个，那么搜索特定元素可能需要检查所有元素。其他效率较低的操作包括排序、通过索引访问元素以及找到最大或最小元素。显然，要找到列表中的最大（或最小）元素，必须遍历整个列表。在本章中，你将了解一种解决这些问题的数据结构：二叉树。
- en: 10.1\. The binary tree
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 二叉树
- en: Data trees are structures in which, unlike lists, each element is linked to
    more than one element. In some trees, an element (sometimes called a *node*) may
    be linked to a variable number of other elements. Most often, though, elements
    are linked to a fixed number of elements. In binary trees, as the same suggests,
    each element is linked to two elements. Those links are called *branches*. In
    binary trees, we talk about left and right branches. [Figure 10.1](#ch10fig01)
    shows an example of a binary tree.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据树是结构，与列表不同，每个元素都链接到多个元素。在某些树中，一个元素（有时称为*节点*）可能链接到可变数量的其他元素。然而，通常元素链接到固定数量的元素。在二叉树中，正如其名所示，每个元素链接到两个元素。这些链接称为*分支*。在二叉树中，我们谈论左分支和右分支。[图10.1](#ch10fig01)显示了二叉树的一个示例。
- en: Figure 10.1\. A binary tree is a recursive structure composed of a root and
    two branches. The left branch is a link to the left subtree, and the right branch
    is a link to the right subtree. Terminal elements have empty branches (not represented
    in the figure) and are called leaves.
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1. 二叉树是一个由根和两个分支组成的递归结构。左分支是左子树的链接，右分支是右子树的链接。终端元素具有空分支（图中未表示）并称为叶子。
- en: '![](Images/10fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig01.jpg)'
- en: 'The tree represented in [figure 10.1](#ch10fig01) isn’t very common because
    its elements are of different types. In other words, it’s a tree of objects. Most
    often, you’ll deal with trees of a more specific type, such as trees of integers.
    In the figure, you can see that a tree is a recursive structure. Each branch leads
    to a new tree (sometimes called a *subtree*). You can also see that some branches
    lead to a single element. This isn’t a problem, because a single element is in
    fact a tree with empty branches. Also note the `T` element: it has a left branch,
    but no right one.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10.1](#ch10fig01)中表示的树并不常见，因为它的元素类型不同。换句话说，它是一个对象树。你通常会处理更具体类型的树，例如整数树。在图中，你可以看到树是一个递归结构。每个分支都指向一个新的树（有时称为*子树*）。你也可以看到一些分支指向单个元素。这并不是问题，因为单个元素实际上是一个带有空分支的树。还要注意`T`元素：它有一个左分支，但没有右分支。
- en: 'From this, you can infer the definition of a binary tree. A tree is one of
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义中，你可以推断出二叉树的定义。树是以下之一：
- en: A single element
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个元素
- en: An element with one branch (right or left)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有一个分支（右或左）的元素
- en: An element with two branches (right and left)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有两个分支（右和左）的元素
- en: Each branch holds a (sub)tree. A tree in which all elements have either two
    branches or zero branches is called a *full* tree. The tree in [figure 10.1](#ch10fig01)
    isn’t full, but the left subtree is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分支都持有（子）树。所有元素要么有两个分支要么没有分支的树称为 *满* 树。[图 10.1](#ch10fig01) 中的树不是满的，但左子树是。
- en: 10.1.1\. Balanced and unbalanced trees
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 平衡和不平衡树
- en: Binary trees may be more or less balanced. A perfectly balanced tree is a tree
    in which the two branches of all subtrees contain the same number of elements.
    [Figure 10.2](#ch10fig02) shows three examples of trees with the same elements.
    The first tree is perfectly balanced and the last tree is totally unbalanced.
    Perfectly balanced binary trees are sometimes called *perfect* trees.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树可能更或更平衡。完全平衡的树是所有子树的两个分支包含相同数量元素的树。[图 10.2](#ch10fig02) 展示了具有相同元素的三棵树的例子。第一棵树是完全平衡的，最后一棵树是完全不平衡的。完全平衡的二叉树有时被称为
    *完美* 树。
- en: Figure 10.2\. Trees can be more or less balanced.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. 树可以更或更不平衡。
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02_alt.jpg)'
- en: In [figure 10.2](#ch10fig02), the tree on the right is in fact a singly linked
    list. A singly linked list can be seen as a special case of a totally unbalanced
    tree.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 10.2](#ch10fig02) 中，右边的树实际上是一个单链表。单链表可以看作是完全不平衡树的特例。
- en: 10.1.2\. Size, height, and depth
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 大小、高度和深度
- en: A tree can be characterized by the number of elements it contains and the number
    of levels on which these elements are located. The number of elements is called
    the *size*, and the number of levels, not counting the root, is called the *height*.
    In [figure 10.2](#ch10fig02), all three trees have a size of 7\. The first (perfectly
    balanced) tree has a height of 2, the second a height of 3, and the third a height
    of 6.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 树可以通过它包含的元素数量以及这些元素所在的层数来描述。元素的数量称为 *大小*，不包括根的层数称为 *高度*。在 [图 10.2](#ch10fig02)
    中，所有三棵树的大小都是 7。第一棵（完全平衡）树的高度为 2，第二棵高度为 3，第三棵高度为 6。
- en: The word *height* is also used to characterize individual elements, and it refers
    to the length of the longest path from an element to a leaf. The height of the
    root is the height of the tree, and the height of an element is the height of
    the subtree having this element as its root.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “高度”这个词也用来描述单个元素，它指的是从元素到叶子的最长路径的长度。根的高度是树的高度，元素的高度是以该元素为根的子树的高度。
- en: The *depth* of an element is the length of the path from the root to the element.
    The first element, also called the *root*, has a depth of 0\. In the perfectly
    balanced tree in [figure 10.2](#ch10fig02), 5 and 4 have a depth of 1; and 2,
    8, 7, and 3 have a depth of 2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的 *深度* 是从根到元素路径的长度。第一个元素，也称为 *根*，深度为 0。在 [图 10.2](#ch10fig02) 中的完全平衡树中，5 和
    4 的深度为 1；而 2、8、7 和 3 的深度为 2。
- en: By convention, the height and depth of an empty tree are equal to -1\. You’ll
    see that this is necessary for some operations, such as balancing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，空树的高度和深度等于 -1。你会看到这对于某些操作是必要的，例如平衡。
- en: 10.1.3\. Leafy trees
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 叶子树
- en: Binary trees are sometimes represented in a different way, as shown in [figure
    10.3](#ch10fig03). In this representation, a tree is represented by branches that
    don’t hold values. Only the terminal nodes hold values. Terminal nodes are called
    *leaves*; hence, the name *leafy trees*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树有时以不同的方式表示，如 [图 10.3](#ch10fig03) 所示。在这种表示中，树由不持有值的分支表示。只有终端节点持有值。终端节点被称为
    *叶子*；因此，得名 *叶子树*。
- en: Figure 10.3\. A leafy tree holds values only in the leaves.
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. 叶子树只持有叶子中的值。
- en: '![](Images/10fig03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig03.jpg)'
- en: The leafy tree representation is sometimes preferred because it makes implementing
    some functions easier. In this book, we’ll consider only “classic” trees and not
    leafy trees.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子树表示法有时更受欢迎，因为它使得实现某些函数更容易。在这本书中，我们将只考虑“经典”树，而不是叶子树。
- en: 10.1.4\. Ordered binary trees or binary search trees (BST)
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4\. 有序二叉树或二叉搜索树（BST）
- en: An ordered binary tree, also called a *binary search tree* (BST), is a tree
    containing elements that can be ordered, and where all elements in one branch
    have a lower value than the root element, while all elements in the other branch
    have a higher value than the root. The same condition holds for all subtrees.
    By convention, elements with lower values than the root are on the left branch,
    and elements with higher values are on the right branch. [Figure 10.4](#ch10fig04)
    shows an example of an ordered tree.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有序二叉树，也称为*二叉搜索树*（BST），是一种包含可以排序的元素的树，其中某一分支的所有元素值都低于根元素，而另一分支的所有元素值都高于根元素。这个条件对所有子树都成立。按照惯例，值低于根的元素位于左分支，而值高于根的元素位于右分支。[图10.4](#ch10fig04)展示了有序树的一个示例。
- en: Figure 10.4\. An example of an ordered tree, or binary search tree (BST)
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 有序树或二叉搜索树（BST）的示例
- en: '![](Images/10fig04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig04.jpg)'
- en: One very important consequence of the definition of ordered binary trees is
    that they can never contain duplicates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有序二叉树的定义的一个重要后果是它们永远不会包含重复项。
- en: 'Ordered trees are particularly interesting because they allow fast retrieval
    of elements. To find out whether an element is contained in the tree, you follow
    these steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有序树特别有趣，因为它们允许快速检索元素。要找出一个元素是否包含在树中，你应遵循以下步骤：
- en: Compare the searched-for element with the root. If they are equal, you’re done.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要搜索的元素与根节点进行比较。如果它们相等，则完成。
- en: If the searched-for element is lower than the root, proceed recursively with
    the left branch.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要搜索的元素低于根节点，则递归地使用左分支进行操作。
- en: If the searched-for element is higher than the root, proceed recursively with
    the right branch.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要搜索的元素高于根节点，则递归地使用右分支进行操作。
- en: Compared to a search in a singly linked list, you can see that searching a perfectly
    balanced ordered binary tree will take an amount of time proportional to the height
    of the tree, which means that it will take a time proportional to log2(*n*), with
    *n* being the size (number of elements) of the tree. By contrast, the search time
    in a singly linked list is proportional to the number of elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表的搜索相比，你可以看到在完美平衡的有序二叉树中进行搜索所需的时间与树的高度成正比，这意味着它将花费与log2(*n*)成正比的时间，其中*n*是树的大小（元素数量）。相比之下，单链表中的搜索时间与元素数量成正比。
- en: A direct consequence of this is that a recursive search in a perfectly balanced
    binary tree will never overflow the stack. As you saw in [chapter 4](kindle_split_011.xhtml#ch04),
    the standard stack size allows for 1,000 to 3,000 recursive steps. Because a perfectly
    balanced binary tree of height 1,000 contains 2^(1,000) elements, you’ll never
    have enough main memory for such a tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这的直接后果是，在完美平衡的二叉树中进行递归搜索永远不会溢出栈。正如你在[第4章](kindle_split_011.xhtml#ch04)中看到的，标准栈大小允许1,000到3,000次递归步骤。因为高度为1,000的完美平衡二叉树包含2^(1,000)个元素，你永远不会有足够的主内存来容纳这样的树。
- en: This is good news. But the bad news is that not all binary trees are perfectly
    balanced. Because the totally unbalanced binary tree is in fact a singly linked
    list, it will have the same performance and the same problem for recursion as
    the list. This means that to get the most from trees, you’ll have to find a way
    to balance them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好消息。但坏消息是并非所有二叉树都是完美平衡的。因为完全不平衡的二叉树实际上是一个单链表，它将具有与列表相同的性能和递归问题。这意味着要充分利用树，你将不得不找到一种方法来平衡它们。
- en: 10.1.5\. Insertion order
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.5. 插入顺序
- en: 'The structure of a tree (meaning how well balanced it is) depends on the insertion
    order of its elements. Insertion is done in the same way as searching:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 树的结构（即其平衡程度）取决于其元素的插入顺序。插入的方式与搜索相同：
- en: Compare the element to be inserted with the root. If they’re equal, you’re done.
    There’s nothing to insert because you can only insert an element lower or higher
    than the root. Note, however, that the reality will sometimes be different. If
    the objects inserted into the tree may be equal from the tree-ordering point of
    view but different based on other criteria, you’ll probably want to replace the
    root with the element you’re inserting. This will be the most frequent case, as
    you’ll see.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要插入的元素与根节点进行比较。如果它们相等，则完成。因为你可以只插入比根节点低或高的元素，所以没有东西可以插入。然而，请注意，实际情况有时会不同。如果插入树中的对象在树排序的角度上可能相等，但根据其他标准不同，你可能希望用你要插入的元素替换根节点。这将是最常见的案例，正如你将看到的。
- en: If the element to be inserted is lower than the root, insert it recursively
    into the left branch.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要插入的元素低于根节点，则递归地将其插入到左分支。
- en: If the element to be inserted is higher than the root, insert it recursively
    into the right branch.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要插入的元素高于根节点，则递归地将其插入到右分支。
- en: 'This process leads to a very interesting observation: the balance of the tree
    depends on the order in which elements are inserted. It’s obvious that inserting
    ordered elements will produce a totally unbalanced tree. On the other hand, many
    insertion orders will produce identical trees. [Figure 10.5](#ch10fig05) shows
    the possible insertion orders that will result in the same tree.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程导致一个非常有趣的观察：树的平衡取决于元素插入的顺序。显然，插入有序元素将产生一个完全不平衡的树。另一方面，许多插入顺序会产生相同的树。[图10.5](#ch10fig05)显示了可能导致相同树的可能的插入顺序。
- en: Figure 10.5\. Many different insertion orders can produce the same tree.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 许多不同的插入顺序可以产生相同的树。
- en: '![](Images/10fig05.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig05.jpg)'
- en: A set of 10 elements can be inserted into a tree in 3,628,800 distinct orders,
    but this will only produce 16,796 distinct trees. These trees will range from
    perfectly balanced to totally unbalanced. From a more pragmatic point of view,
    ordered trees are very efficient for storing and retrieving random data, but they’re
    very bad for storing and retrieving preordered data. You’ll soon learn how to
    solve this problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 10个元素可以以3,628,800种不同的顺序插入到树中，但这只会产生16,796种不同的树。这些树将从完全平衡到完全不平衡。从更实际的角度来看，有序树在存储和检索随机数据时非常高效，但在存储和检索预序数据时非常糟糕。你很快就会学到如何解决这个问题。
- en: 10.1.6\. Tree traversal order
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.6\. 树遍历顺序
- en: 'Given a specific tree as represented in [figure 10.5](#ch10fig05), one common
    use case is to traverse it, visiting all elements one after the other. This is
    typically the case when mapping or folding trees, and to a lesser extent when
    searching a tree for a particular value. When we studied lists, you learned that
    there are two ways to traverse them: from left to right or from right to left.
    Trees offer many more approaches, and among them we’ll make a distinction between
    recursive and nonrecursive ones.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个如图[图10.5](#ch10fig05)所示的特定树，一个常见的用例是遍历它，依次访问所有元素。这通常是映射或折叠树的情况，以及在某种程度上搜索树以查找特定值的情况。当我们研究列表时，你了解到有两种方式可以遍历它们：从左到右或从右到左。树提供了许多更多的方法，其中我们将区分递归和非递归方法。
- en: Recursive traversal orders
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 递归遍历顺序
- en: 'Consider the left branch of the tree in [figure 10.5](#ch10fig05). This branch
    is itself a tree composed of the root 1, the left branch 0, and the right branch
    2\. You can traverse this tree in six orders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图10.5](#ch10fig05)中的树的左分支。这个分支本身是一个由根节点1、左分支0和右分支2组成的树。你可以用六种顺序遍历这个树：
- en: 1, 0, 2
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 0, 2
- en: 1, 2, 0
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1, 2, 0
- en: 0, 1, 2
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0, 1, 2
- en: 2, 1, 0
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2, 1, 0
- en: 0, 2, 1
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0, 2, 1
- en: 2, 0, 1
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2, 0, 1
- en: 'You can see that three of these orders are symmetric with the other three.
    1, 0, 2 and 1, 2, 0 are symmetric. You start from the root and then visit the
    two branches, from left to right or from right to left. The same holds for 0,
    1, 2 and 2, 1, 0, which differ only by the order of the branches, and again for
    0, 2, 1 and 2, 0, 1\. You’ll only consider the left to right direction (because
    the other direction is exactly the same, as if it were seen in a mirror), so you’re
    left with three orders, which are named after the position of the root:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这三个顺序与另外三个顺序是对称的。1, 0, 2 和 1, 2, 0 是对称的。你从根节点开始，然后访问两个分支，从左到右或从右到左。同样，0,
    1, 2 和 2, 1, 0 也一样，它们只是分支的顺序不同，以及 0, 2, 1 和 2, 0, 1 也一样。你只会考虑从左到右的方向（因为另一个方向正好相同，就像在镜子中看到的一样），所以你只剩下三个顺序，这些顺序是以根节点的位置命名的：
- en: Pre order (1 0 2 or 1 2 0)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预序（1 0 2 或 1 2 0）
- en: In order (0 1 2 or 2 1 0)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序（0 1 2 或 2 1 0）
- en: Post order (0 2 1 or 2 0 1)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序（0 2 1 或 2 0 1）
- en: 'These terms are coined after the operator position in an operation. To better
    see the analogy, imagine the root (1) replaced with a plus (+) sign, producing
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些术语是根据操作中的操作符位置提出的。为了更好地看到类比，想象将根（1）替换为加号（+），产生如下：
- en: Prefix (+ 0 2 or + 2 0)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序（+ 0 2 或 + 2 0）
- en: Infix (0 + 2 or 2 + 0)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中序（0 + 2 或 2 + 0）
- en: Postfix (0 2 + or 2 0 +)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀（0 2 + 或 2 0 +）
- en: Applied recursively to the whole tree, these orders result in traversing the
    tree while giving priority to height, leading to the traversal paths shown in
    [figure 10.6](#ch10fig06). Note that this type of traversal is generally called
    *depth first* instead of the more logical *height first*. When talking about the
    whole tree, height and depth refer to the height of the root and depth of the
    deepest leaf. These two values are equal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些顺序递归应用于整个树，会导致在优先考虑高度的同时遍历树，导致 [图 10.6](#ch10fig06) 中显示的遍历路径。请注意，这种遍历通常被称为
    *深度优先* 而不是更合理的 *高度优先*。当谈论整个树时，高度和深度指的是根的高度和最深叶子的深度。这两个值是相等的。
- en: Figure 10.6\. Depth-first traversal consists in traversing the tree while giving
    priority to height. There are three main orders in which this may be applied.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 深度优先遍历是指在遍历树时优先考虑高度。这可以应用在三种主要顺序中。
- en: '![](Images/10fig06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig06.jpg)'
- en: Nonrecursive traversal orders
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非递归遍历顺序
- en: Another way to traverse a tree is to first visit a complete level and then go
    to the next level. Again, this can be done from left to right or from right to
    left. This kind of traversal is called *level-order traversal*, or *breadth-first
    search*; one example is shown in [figure 10.7](#ch10fig07).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树的另一种方式是首先访问一个完整的层，然后转到下一层。同样，这可以从左到右或从右到左进行。这种遍历称为 *层序遍历*，或 *广度优先搜索*；一个例子在
    [图 10.7](#ch10fig07) 中展示。
- en: Figure 10.7\. Level-order traversal consists in visiting all the elements of
    a given level before going to the next level.
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. 层序遍历是指在访问给定层的所有元素之后，再访问下一层。
- en: '![](Images/10fig07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig07.jpg)'
- en: 10.2\. Implementing the binary search tree
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 实现二叉搜索树
- en: In this book, we’ll consider traditional binary trees and not leafy trees. A
    binary tree is implemented the same way as a singly linked list, with a head (called
    `value`) and two tails (the branches, called `left` and `right`). You’ll define
    an abstract `Tree` class with two subclasses named `T` and `Empty`. `T` represents
    a non-empty tree, whereas `Empty`, unsurprisingly, represents the empty tree.
    The following listing represents the minimal `Tree` implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将考虑传统的二叉树而不是叶树。二叉树以与单链表相同的方式实现，有一个头（称为 `value`）和两个尾（分支，称为 `left` 和 `right`）。你将定义一个抽象的
    `Tree` 类，有两个子类分别命名为 `T` 和 `Empty`。`T` 代表非空树，而 `Empty`（不出所料）代表空树。以下列表表示 `Tree`
    的最小实现。
- en: Listing 10.1\. The `Tree` implementation
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. `Tree` 的实现
- en: '![](Images/ch10ex01-0.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch10ex01-0.jpg)'
- en: '![](Images/ch10ex01-1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch10ex01-1.jpg)'
- en: This class is quite simple, but it’s useless as long as you have no way to construct
    a real tree.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类相当简单，但如果你没有构建真实树的方法，它就毫无用处。
- en: Exercise 10.1
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.1
- en: Define an `insert` method to insert a value into a tree. The name of the method,
    `insert`, isn’t very well chosen, because nothing should really be inserted. As
    usual, the `Tree` structure is immutable and persistent, so a new tree with the
    inserted value must be constructed, leaving the original tree untouched. But it’s
    standard to call this method `insert` because it has the same function as insertion
    in traditional programming.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `insert` 方法将值插入到树中。这个方法的名字 `insert` 并不是很好选择，因为没有真正需要插入的东西。像往常一样，`Tree`
    结构是不可变的和持久的，所以必须构建一个新的包含插入值的树，而原始树保持不变。但通常称之为 `insert` 方法，因为它与传统编程中的插入功能相同。
- en: 'If the value is equal to the root, you must return a new tree with the inserted
    value as the root and the two original branches left unchanged. Otherwise, a value
    lower than the root is inserted in the left branch, and a value higher than the
    root is inserted in the right branch. Declare the method in the parent `Tree`
    class, and implement it in both subclasses. This is the method signature:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值等于根，你必须返回一个新的树，其中插入的值作为根，两个原始分支保持不变。否则，小于根的值插入到左分支，大于根的值插入到右分支。在父 `Tree`
    类中声明此方法，并在两个子类中实现它。这是方法签名：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Solution 10.1
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.1
- en: 'The `Empty` implementation constructs a new `T` with the inserted value as
    the root and two empty trees as the branches:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 的实现构建一个新的 `T`，其中插入的值作为根，两个空树作为分支：'
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `T` implementation is a bit more complex. First, it compares the inserted
    value with the root. If it’s lower, it constructs a new `T` with the current root
    and the current right branch. The left branch is the result of recursively inserting
    the value into the original left branch.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`的实现稍微复杂一些。首先，它比较插入值与根节点。如果它更低，它将使用当前根节点和当前右分支构建一个新的`T`。左分支是递归将值插入原始左分支的结果。'
- en: If the value is higher than the root, it constructs a new `T` with the current
    root and the current left branch. The right branch is the result of recursively
    inserting the value into the original right branch.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值高于根节点，它将使用当前根节点和当前左分支构建一个新的`T`。右分支是递归将值插入原始右分支的结果。
- en: 'Finally, if the value is equal to the root, you return a new tree composed
    of the inserted value as the root and the two original branches left untouched:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果值等于根节点，你将返回一个由插入值作为根节点和两个未更改的原始分支组成的新树：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this is different from what happens in a Java `TreeSet`, which is
    unchanged if you try to insert an element that’s equal to an element already in
    the set. Although this behavior might be acceptable for mutable elements, it’s
    not acceptable when elements are immutable. You may think that it’s a waste of
    time and memory space to construct a new instance of `T` with the same left branch,
    the same right branch, and a root equal to the current root, because you could
    simply return `this`. Returning `this` would be equivalent to returning
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与Java `TreeSet`中的情况不同，如果你尝试插入一个等于集合中已有元素的元素，`TreeSet`不会改变。尽管这种行为对于可变元素可能是可接受的，但当元素不可变时，这是不可接受的。你可能认为，使用具有相同左分支、相同右分支和等于当前根节点的根节点构建一个新的`T`实例是浪费时间和内存空间，因为你可以直接返回`this`。返回`this`将等同于返回
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If this was what you intended, returning `this` would be a good optimization.
    This would work, but it would be tedious to obtain the same result as mutating
    a tree element. You’d have to remove the element before inserting an equal element
    with some changed properties. You’ll encounter this use case when implementing
    a map in [chapter 11](kindle_split_018.xhtml#ch11).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你的意图，返回`this`将是一个好的优化。这会起作用，但与通过修改树元素来获得相同结果相比，会显得繁琐。你必须在插入具有一些更改属性的相等元素之前删除元素。当你实现第11章中的映射时，你会遇到这种情况。
- en: You may be wondering whether you should implement stack-safe recursion, since
    the `insert` method is recursive. As I said previously, there’s no need to do
    so with a balanced tree, because the height (which determines the maximum number
    of recursion steps), is generally much lower than the size. But you’ve seen that
    this isn’t always the case, particularly if the elements to be inserted are ordered.
    This could eventually result in a tree with only one branch, which would have
    its height equal to its size (minus 1) and would overflow the stack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道是否应该实现栈安全递归，因为`insert`方法本身就是递归的。正如我之前所说的，在平衡树中这样做是没有必要的，因为树的高度（决定最大递归步骤数）通常远低于树的大小。但你已经看到，这并不总是成立，尤其是当要插入的元素是有序的时候。这最终可能导致只有一个分支的树，其高度等于其大小（减1），从而溢出栈。
- en: For now, though, you won’t bother with this problem. Rather than implementing
    stack-safe recursive operations, you’ll find a way to automatically balance trees.
    The simple tree you’re working on is only for learning. It will never be used
    in production. But balanced trees are more complex to implement, so you’ll start
    with simple unbalanced trees.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前你不必担心这个问题。与其实现栈安全递归操作，你将找到一种自动平衡树的方法。你正在工作的简单树只是为了学习，它永远不会在生产中使用。但平衡树的实现更复杂，所以你将从简单的未平衡树开始。
- en: Exercise 10.2
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.2
- en: 'One operation often used on trees consists of checking whether a specific element
    is present in the tree. Implement a `member` method that performs this check.
    Here’s its signature:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 树上常用的一个操作是检查特定元素是否存在于树中。实现一个`member`方法来执行这个检查。以下是它的签名：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hint
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Implement this as an abstract method in the `Tree` parent class with a specific
    implementation in each subclass.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tree`父类中实现这个作为抽象方法，并在每个子类中具体实现。
- en: Solution 10.2
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.2
- en: 'Let’s start with the `T` subclass implementation. You have to compare the parameter
    with the tree `value` (which means the value at the root of the tree). If the
    parameter is lower, recursively apply the comparison to the left branch. If it’s
    higher, recursively apply the comparison to the right branch. If the `value` and
    the parameter are equal, simply return `true`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `T` 子类实现开始。你必须将参数与树 `value`（这意味着树的根值）进行比较。如果参数较低，递归地将比较应用于左分支。如果它较高，递归地将比较应用于右分支。如果
    `value` 和参数相等，则简单地返回 `true`：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that this code can be simplified into the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码可以被简化成以下形式：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But you may find the first version clearer. Of course, the `Empty` implementation
    returns `false`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能觉得第一个版本更清晰。当然，`Empty` 实现返回 `false`。
- en: Exercise 10.3
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3 练习
- en: 'To simplify tree creation, write a static method that takes a vararg argument
    and inserts all elements into an empty tree. Here’s its signature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化树创建，编写一个静态方法，它接受可变参数并插入所有元素到一个空树中。这是它的签名：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hint
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Start by implementing a method that takes a list as its argument. Then define
    the vararg method in terms of the `list` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现一个接受列表作为参数的方法。然后根据 `list` 方法定义可变参数方法。
- en: Solution 10.3
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3 解决方案
- en: 'This is more an exercise about lists than about trees! Here’s the solution:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是一个关于列表的练习，而不是关于树的！下面是解决方案：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exercise 10.4
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4 练习
- en: 'Write methods to compute the `size` and `height` of a tree. Here are their
    signatures in the `Tree` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编写计算树的大小和高度的方法。以下是 `Tree` 类中它们的签名：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Solution 10.4
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4 解决方案
- en: 'Of course, the `Empty` implementation of `size` returns `0`. And as I said
    previously, the `Empty` implementation of the `height` method returns `-1`. The
    implementation of the `size` method in the `T` class returns 1 plus the size of
    each branch. The implementation of the `height` method returns 1 plus the maximum
    `height` of the two branches:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Empty` 实现的 `size` 方法返回 `0`。正如我之前所说的，`Empty` 实现的 `height` 方法返回 `-1`。`T` 类中
    `size` 方法的实现返回每个分支的大小加 1。`height` 方法的实现返回两个分支的最大 `height` 加 1：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Based on this, you can see why the height of an empty tree needs to be equal
    to -1\. If it were 0, the height would be equal to the number of elements in the
    path, instead of the number of segments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，你可以看到为什么空树的高度需要等于 `-1`。如果它是 `0`，则高度将等于路径中的元素数量，而不是段的数量。
- en: Note that these methods are just for illustration. In reality, you’d memoize
    the height and size as you did for `length` in `List`. Look at the code accompanying
    this book for a reminder of how this is done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法只是为了说明。在现实中，你会像在 `List` 中的 `length` 一样缓存高度和大小。看看这本书的代码，以提醒你如何做到这一点。
- en: Exercise 10.5
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5 练习
- en: Write `max` and `min` methods to compute the maximum and minimum values contained
    in a tree.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `max` 和 `min` 方法来计算树中包含的最大和最小值。
- en: Hint
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Think of what the methods should return in the `Empty` class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在 `Empty` 类中这些方法应该返回什么。
- en: Solution 10.5
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5 解决方案
- en: 'Of course, there are no minimum or maximum values in an empty tree. The solution
    is to return a `Result<A>`, and the `Empty` implementations will return `Result.empty()`.
    The implementation for the `T` class is a bit tricky. For the `max` method, the
    solution is to return the `max` of the right branch. If the right branch isn’t
    empty, this will be a recursive call. If the right branch is empty, you’ll get
    `Result.Empty`. You then know that the `max` value is the value of the current
    tree, so you can simply call the `orElse` method on the return value of the `right.max()`
    method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，空树中没有最小或最大值。解决方案是返回一个 `Result<A>`，`Empty` 实现将返回 `Result.empty()`。`T` 类的实现稍微有些棘手。对于
    `max` 方法，解决方案是返回右分支的最大值。如果右分支不为空，这将是一个递归调用。如果右分支为空，你会得到 `Result.Empty`。然后你知道最大值是当前树中的值，所以你可以简单地调用
    `right.max()` 方法的返回值上的 `orElse` 方法：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Recall that the `orElse` method evaluates its argument lazily, which means
    it takes a `Supplier<Result<A>>`. Of course, the `min` method is completely symmetrical:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`orElse` 方法是惰性评估其参数的，这意味着它接受一个 `Supplier<Result<A>>`。当然，`min` 方法是完全对称的：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 10.3\. Removing elements from trees
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 从树中删除元素
- en: Unlike singly linked lists, trees allow you to retrieve a specific element,
    as you saw when you developed the `member` method in exercise 10.2\. This should
    also make it possible to remove a specific element from a tree.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表不同，树允许你检索特定元素，正如你在练习 10.2 中开发 `member` 方法时所看到的。这也应该使得从树中删除特定元素成为可能。
- en: Exercise 10.6
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.6
- en: Write a `remove` method that removes an element from a tree. This method will
    take an element as its parameter. If this element is present in the tree, it will
    be removed, and the method will return a new tree without this element. Of course,
    this new tree will respect the requirements that all elements on a left branch
    will be lower than the root, and all elements on the right branch will be higher
    than the root. If the element isn’t in the tree, the method will return the tree
    unchanged. The method signature will be
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `remove` 方法，从树中移除一个元素。此方法将一个元素作为其参数。如果此元素存在于树中，它将被移除，并且该方法将返回一个不包含此元素的新树。当然，这个新树将遵守所有左分支上的元素都低于根，所有右分支上的元素都高于根的要求。如果元素不在树中，则方法将返回未更改的树。方法签名将是
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hint
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll need to define a method to merge two trees with the particularity that
    all elements of one are either greater or smaller than all elements of the other.
    You’ll also need an `isEmpty` method that returns `true` in the `Empty` class
    and `false` in the `T` class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要定义一个方法来合并两个树，其特殊性在于一个树的所有元素要么大于另一个树的所有元素，要么小于另一个树的所有元素。你还需要一个 `isEmpty` 方法，在
    `Empty` 类中返回 `true`，在 `T` 类中返回 `false`。
- en: Solution 10.6
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.6
- en: 'Of course, the `Empty` implementation can’t remove anything and will simply
    return `this`. For the `T` subclass implementation, here’s the algorithm you’ll
    need to implement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Empty` 实现不能移除任何内容，将简单地返回 `this`。对于 `T` 子类实现，以下是你需要实现的算法：
- en: If `a` < `this`, remove from left.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` < `this`，则从左侧移除。
- en: If `a` > `this`, remove from right.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `a` > `this`，则从右侧移除。
- en: Else, the root is to be removed. Merge the left and right branches, discarding
    the root, and return the result.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，需要移除根节点。合并左右分支，丢弃根节点，并返回结果。
- en: The merge is a simplified merge because you know that all elements in the left
    branch are lower than all elements of the right branch.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 合并是一个简化的合并，因为你知道左分支的所有元素都低于右分支的所有元素。
- en: 'First you must define the `merge` method. Define an abstract method in the
    `Tree` class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须定义 `merge` 方法。在 `Tree` 类中定义一个抽象方法：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementation in the `Empty` class simply returns the parameter unchanged,
    because merging `ta` with an empty tree results in `ta`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 类的实现简单地返回未更改的参数，因为将 `ta` 与空树合并的结果是 `ta`：'
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `T` implementation uses the following algorithm:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 实现使用以下算法：'
- en: If `ta` is empty, return `this` (`this` can’t be empty).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `ta` 为空，则返回 `this`（`this` 不能为空）。
- en: If `ta` < `this`, merge `ta` in the left branch.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `ta` < `this`，则在左分支中合并 `ta`。
- en: If `ta` > `this`, merge `ta` in the right branch.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `ta` > `this`，则在右分支中合并 `ta`。
- en: 'Here’s the implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是其实施：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the method throws an exception if the roots of the two trees are equal,
    which should never happen because the two trees to be merged are supposed to be
    the left and right branches of the same original tree.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果两个树的根相等，该方法会抛出异常，这不应该发生，因为要合并的两个树应该是同一原始树的左右分支。
- en: 'Now you can write the `remove` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以编写 `remove` 方法：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 10.4\. Merging arbitrary trees
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 合并任意树
- en: In the previous section, you used a restricted merging method that could only
    merge trees where all values in one tree were lower than all values of the other
    tree. Merging for trees is the equivalent of concatenation for lists. You need
    a more general method to handle merging for arbitrary trees.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你使用了一种限制合并方法，该方法只能合并所有值在一个树中低于另一个树所有值的树。对于树的合并相当于列表的连接。你需要一个更通用的方法来处理任意树的合并。
- en: Exercise 10.7 (hard)
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.7（困难）
- en: So far, you’ve only merged trees in which all elements in one tree were greater
    than all elements of the other. Write a `merge` method that merges arbitrary trees.
    Its signature will be
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只合并了所有元素在一个树中大于另一个树所有元素的树。编写一个 `merge` 方法来合并任意树。它的签名将是
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Solution 10.7
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.7
- en: 'The `Empty` implementation will simply return its parameter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 实现将简单地返回其参数：'
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `T` subclass implementation will use the following algorithm, in which
    *this* means the tree in which the method is defined:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`T` 子类实现将使用以下算法，其中 *this* 表示定义该方法时的树：'
- en: If the parameter tree is empty, return `this`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数树为空，则返回 `this`。
- en: If the root of the parameter is higher than this root, remove the left branch
    of the parameter tree and merge the result with `this` right branch. Then merge
    the result with the parameter’s left branch.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数的根高于`this`根，则移除参数树的左侧分支，并将结果与`this`右侧分支合并。然后，将结果与参数的左侧分支合并。
- en: If the root of the parameter is lower than `this` root, remove the right branch
    of the parameter tree and merge the result with `this` left branch. Then merge
    the result with the parameter’s right branch.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数的根小于`this`根，则移除参数树右侧的分支，并将结果与`this`左侧分支合并。然后，将结果与参数的右侧分支合并。
- en: If the root of the parameter is equal to `this` root, merge the left branch
    of the parameter with `this` left branch and merge the right branch of the parameter
    with `this` right branch.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数的根等于`this`根，则将参数的左侧分支与`this`左侧分支合并，并将参数的右侧分支与`this`右侧分支合并。
- en: 'Here’s the implementation of this algorithm:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个算法的实现：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This algorithm is illustrated by [figures 10.8](#ch10fig08) through [10.17](#ch10fig17).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法通过[图10.8](#ch10fig08)到[10.17](#ch10fig17)的图例来说明。
- en: Figure 10.8\. The two trees to be merged. On the left is `this` tree, and on
    the right is the parameter tree.
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8。要合并的两个树。左侧是`this`树，右侧是参数树。
- en: '![](Images/10fig08_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig08_alt.jpg)'
- en: Figure 10.9\. The root of the parameter tree is higher than the root of `this`
    tree. Merge the right branch of `this` tree with the parameter tree with its left
    branch removed. (The merging operation is represented by the dotted box.)
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.9。参数树的根高于`this`树的根。将`this`树的右侧分支与移除左侧分支的参数树合并。（合并操作用虚线框表示。）
- en: '![](Images/10fig09_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig09_alt.jpg)'
- en: Figure 10.10\. The roots of each tree to be merged being equal, you use `this`
    value for the result of the merge. The left branch will be the result of merging
    the two left branches, and the right branch will be the result of merging the
    two right branches.
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.10。要合并的每个树的根相等，你使用`this`值作为合并的结果。左侧分支将是两个左侧分支合并的结果，右侧分支将是两个右侧分支合并的结果。
- en: '![](Images/10fig10_alt.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig10_alt.jpg)'
- en: Figure 10.11\. For the left branch, merging with an empty tree is trivial and
    just returns the original tree (root 4 and two empty branches). For the right
    branch, the first tree has empty branches and 6 as its root, and the second tree
    has 7 as its root, so you remove the left branch of the 7 rooted tree and use
    the result to merge with the empty right branch of the 6 rooted tree. The removed
    left branch will be merged with the result of the previous merge. Note that the
    6 rooted tree on the right comes from the 7 rooted tree, where it has been replaced
    by an empty tree.
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对于左侧分支，与空树合并是平凡的，只需返回原始树（根4和两个空分支）。对于右侧分支，第一个树有两个空分支和根6，第二个树的根是7，因此你移除根为7的树的左侧分支，并将其结果与根为6的树的空右侧分支合并。移除的左侧分支将与前一次合并的结果合并。请注意，右侧的根为6的树来自根为7的树，其中它已被空树替换。
- en: '![](Images/10fig11_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig11_alt.jpg)'
- en: Figure 10.12\. The two trees to be merged have equal roots (6) so you merge
    the branches (left with left and right with right). Because the tree to be merged
    has both branches empty, there is in fact nothing to do.
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.12。要合并的两个树的根相等（6），因此合并分支（左侧与左侧合并，右侧与右侧合并）。因为要合并的树两个分支都为空，实际上没有需要做的事情。
- en: '![](Images/10fig12_alt.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig12_alt.jpg)'
- en: Figure 10.13\. Merging an empty tree simply results in the tree to be merged.
    You’re left with two trees with the same root to merge.
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.13。合并一个空树简单地得到要合并的树。你将剩下两个具有相同根的树需要合并。
- en: '![](Images/10fig13.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig13.jpg)'
- en: 'Figure 10.14\. Merging two trees with the same root is simple: just merge right
    with right and left with left, and use the results as the new branches.'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.14。合并具有相同根的两个树很简单：只需将右侧与右侧合并，左侧与左侧合并，并使用结果作为新分支。
- en: '![](Images/10fig14_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig14_alt.jpg)'
- en: Figure 10.15\. The left merge is trivial because the roots are equal and both
    branches of the tree to be merged are empty. On the right side, the tree to be
    merged has a lower root (4), so you remove the right branch (E) and merge what
    remains with the left branch of the original tree.
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.15。左侧合并是平凡的，因为根相等，要合并的树的两个分支都为空。在右侧，要合并的树的根较低（4），因此你移除右侧分支（E），并将剩余部分与原始树的左侧分支合并。
- en: '![](Images/10fig15_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig15_alt.jpg)'
- en: You can see in these figures that merging two trees gives a tree with a size
    (number of elements) that can be smaller than the sum of the sizes of the original
    trees, because duplicate elements are automatically removed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这些图中看到，合并两个树可以得到一个大小（元素数量）小于原始树大小之和的树，因为重复的元素会自动删除。
- en: On the other hand, the height of the result is higher than you might expect.
    Merging two trees of height 3 can lead to a resulting tree of height 5\. It’s
    easy to see that the optimal height shouldn’t be higher than log2(size). In other
    words, the optimal height is the smallest power of 2 higher than the resulting
    size. In this example, the sizes of the two original trees were 7 and their heights
    were 3\. The size of the merged tree is 9, and the optimal height would be 4 instead
    of 5\. In such a small example, this might not be a problem. But when you’re merging
    big trees, you could end up with badly balanced trees, resulting in suboptimal
    performance, and even possibly a stack overflow when using recursive methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，结果的高度可能比你预期的要高。合并高度为3的两棵树可能导致高度为5的结果树。很容易看出，最佳高度不应该高于log2(size)。换句话说，最佳高度是大于结果大小的最小2的幂。在这个例子中，两棵原始树的大小是7，高度是3。合并树的大小是9，最佳高度应该是4而不是5。在这样一个小的例子中，这可能不是问题。但当你合并大树时，你可能会得到不平衡的树，导致性能不佳，甚至可能在使用递归方法时出现栈溢出。
- en: Figure 10.16\. Merging two identical trees doesn’t need any explanation.
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.16. 合并两个相同的树不需要任何解释。
- en: '![](Images/10fig16_alt.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig16_alt.jpg)'
- en: Figure 10.17\. The final result after merging the last empty tree
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.17. 合并最后一个空树后的最终结果
- en: '![](Images/10fig17_alt.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig17_alt.jpg)'
- en: 10.5\. Folding trees
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5. 折叠树
- en: No, this isn’t a section about origami. Folding a tree is similar to folding
    a list; it consists of transforming a tree into a single value. For example, in
    a tree of numerical values, computing the sum of all elements can be represented
    through a fold. But folding a tree is more complicated than folding a list.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是关于折纸的章节。折叠一棵树类似于折叠一个列表；它包括将树转换成一个单一值。例如，在一个数值树中，计算所有元素的总和可以通过折叠来表示。但折叠树比折叠列表更复杂。
- en: 'Computing the sum of the elements in a tree of integers is trivial because
    the addition is associative in both directions and commutative. In other words,
    the following expressions have the same values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 计算整数树中元素的总和是微不足道的，因为加法在两个方向上都是结合的，并且是交换的。换句话说，以下表达式具有相同的值：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Examining these expressions, you can see that they represent some possible
    results of folding the following tree using addition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这些表达式，你可以看到它们代表使用加法折叠以下树的某些可能结果：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Considering only the order in which the elements are processed, you can recognize
    the following orders:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 仅考虑处理元素的顺序，你可以识别以下顺序：
- en: Post order left
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序左
- en: Pre order left
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序左
- en: Post order right
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序右
- en: Pre order right
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序右
- en: In order left
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按序左
- en: In order right
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按序右
- en: 'Note that *left* and *right* mean *starting from the left* and *starting from
    the right*. You can verify this by computing the result for each expression. For
    example, the first expression can be reduced as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*左*和*右*意味着*从左开始*和*从右开始*。你可以通过计算每个表达式的结果来验证这一点。例如，第一个表达式可以简化如下：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are other possibilities, but these six are the most interesting. Although
    they’re equivalent for addition, they may not be for other operations, such as
    adding characters to strings or adding elements to lists.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可能性，但其中这六个是最有趣的。虽然它们对于加法是等价的，但对于其他操作，例如向字符串添加字符或向列表添加元素，可能不是等价的。
- en: 10.5.1\. Folding with two functions
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.1. 使用两个函数进行折叠
- en: The problem when folding a tree is that the recursive approach will in fact
    be bi-recursive. You can fold each branch with the given operation, but you need
    a way to combine the two results into one. Does this remind you of list-folding
    parallelization? Yes, you need an additional operation. If the operation needed
    to fold `Tree<A>` is a function from `B` to `A` to `B`, you need an additional
    function from `B` to `B` to `B` to merge the left and right results.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当折叠一棵树时，问题在于递归方法实际上将是双向递归的。你可以用给定的操作折叠每个分支，但你需要一种方法将两个结果合并成一个。这让你想起了列表折叠并行化吗？是的，你需要一个额外的操作。如果折叠`Tree<A>`所需的操作是从`B`到`A`再到`B`的函数，你需要一个额外的从`B`到`B`到`B`的函数来合并左右结果。
- en: Exercise 10.8
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习10.8
- en: 'Write a `foldLeft` method that folds a tree, given the two functions just described.
    Its signature in the `Tree` class will be as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `foldLeft` 方法，用于折叠一棵树，给定上述两个函数。在 `Tree` 类中的签名如下：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Solution 10.8
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.8
- en: 'The implementation in the `Empty` subclass is straightforward and will simply
    return the `identity` element. The `T` subclass implementation is a bit more difficult.
    What you need to do is recursively compute the fold for each branch, and then
    combine the results with the root. The problem is that each branch fold returns
    a `B`, but the root is an `A`, and you have no function from `A` to `B` at your
    disposal. The solution might be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 子类的实现很简单，它将简单地返回 `identity` 元素。`T` 子类的实现稍微复杂一些。你需要递归地计算每个分支的折叠，然后将结果与根结合。问题是每个分支折叠返回一个
    `B`，但根是一个 `A`，而你没有任何从 `A` 到 `B` 的函数可用。解决方案可能如下：'
- en: Recursively fold the left branch and the right branch, giving two `B` values.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归折叠左分支和右分支，给出两个 `B` 值。
- en: Combine these two `B` values with the `g` function, and then combine the result
    with the root and return the result.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这两个 `B` 值与 `g` 函数结合，然后将结果与根结合并返回结果。
- en: 'This could be one solution:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个解决方案：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Simple? Not so. The problem is that the `g` function is a function from `B`
    to `B` to `B`, so you could easily swap the arguments:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？并不简单。问题是 `g` 函数是一个从 `B` 到 `B` 到 `B` 的函数，所以你可以很容易地交换参数：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Is this a problem? Yes, it is. If you fold a list with an operation that’s commutative,
    like addition, the result won’t change. But if you use an operation that isn’t
    commutative, you’re in trouble. The end result is that the two solutions will
    give you different results. For example, the following function,
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不是一个问题？是的，是。如果你用一个交换律的操作（如加法）折叠一个列表，结果不会改变。但如果你使用一个非交换律的操作，你就有麻烦了。最终结果是，两种解决方案会给出不同的结果。例如，以下函数，
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: will produce the following result with the first solution,
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生以下结果（第一个解决方案），
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'and the following result with the second solution:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以及第二个解决方案的以下结果：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Which is the right result? You can find the original result by switching the
    arguments of the second function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的结果是什么？你可以通过交换第二个函数的参数来找到原始结果：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In fact, both lists, although in different orders, represent the same tree.
    [Figure 10.18](#ch10fig18) represents the two cases.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个列表，尽管顺序不同，但代表的是同一棵树。[图 10.18](#ch10fig18) 表示这两种情况。
- en: Figure 10.18\. Reading the tree from left to right and from right to left
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.18\. 从左到右和从右到左读取树
- en: '![](Images/10fig18_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18](Images/10fig18_alt.jpg)'
- en: 'In the code accompanying this book, you’ll find these two examples. Be aware
    that this isn’t a comparable difference as `foldLeft` and `foldRight` for the
    `List` class. Folding from right to left is in fact a left fold of the reversed
    list. A right fold would look like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的配套代码中，你可以找到这两个例子。请注意，这与 `List` 类的 `foldLeft` 和 `foldRight` 的可比较差异不同。从右到左的折叠实际上是反转列表的左折叠。右折叠看起来像这样：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because there are many traversal orders, there are many possible implementations
    that will give different results with noncommutative operations. You’ll find examples
    in the comments in the code accompanying this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有多个遍历顺序，所以有多个可能的实现，这些实现会在非交换律操作中给出不同的结果。你可以在本书配套代码的注释中找到示例。
- en: 10.5.2\. Folding with a single function
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.2\. 使用单个函数进行折叠
- en: It’s also possible to fold with a single function taking an additional parameter,
    which means, for example, a function from `B` to `A` to `B` to `B`. Once again,
    there will be many possible implementations, depending upon the traversal order.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用一个带有额外参数的单个函数进行折叠，这意味着，例如，一个从 `B` 到 `A` 到 `B` 到 `B` 的函数。再次强调，将会有许多可能的实现，这取决于遍历顺序。
- en: Exercise 10.9
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.9
- en: 'Write three methods to fold a tree: `foldInOrder`, `foldPreOrder`, and `foldPostOrder`.
    Applied to the tree in [figure 10.18](#ch10fig18), the elements should be processed
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编写三个方法来折叠一棵树：`foldInOrder`、`foldPreOrder` 和 `foldPostOrder`。应用于 [图 10.18](#ch10fig18)
    中的树，元素应按以下方式处理：
- en: 'In order: 1 2 3 4 5 6 7'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序：1 2 3 4 5 6 7
- en: 'Pre order: 4 2 1 3 6 5 7'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前序：4 2 1 3 6 5 7
- en: 'Post order: 1 3 2 5 7 6 4'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后序：1 3 2 5 7 6 4
- en: 'Here are the method signatures:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是方法签名：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Solution 10.9
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.9
- en: 'Here are the solutions. The `Empty` implementations all return `identity`.
    The implementations in the `T` class are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案。`Empty` 实现都返回 `identity`。`T` 类的实现如下：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 10.5.3\. Which fold implementation to choose
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.5.3\. 选择哪种折叠实现
- en: You’ve now written five different fold methods. Which one should you choose?
    To answer this question, let’s consider what properties a fold method should have.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经编写了五种不同的折叠方法。你应该选择哪一个？为了回答这个问题，让我们考虑一个折叠方法应该具有哪些属性。
- en: 'There’s a relationship between the way a data structure is folded and the way
    it’s constructed. You can construct a data structure by starting with an empty
    element and adding elements one by one. This is the reverse of folding. Ideally,
    you should be able to fold a structure using specific parameters that allow you
    to turn the fold into an identity function. For a list, this would be as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构折叠的方式与其构建方式之间存在关系。你可以从空元素开始，逐个添加元素来构建数据结构。这与折叠相反。理想情况下，你应该能够使用特定的参数折叠结构，使其成为恒等函数。对于一个列表，这将是以下这样：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You could also use `foldLeft`, but the function would be slightly more complex:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`foldLeft`，但函数会稍微复杂一些：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (This isn’t surprising; if you look at the `foldRight` implementation, you’ll
    see that it internally uses `foldLeft` and `reverse`.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: （这并不令人惊讶；如果你查看`foldRight`的实现，你会看到它内部使用`foldLeft`和`reverse`。）
- en: Can you do the same with tree folding? To achieve this, you’ll need a new way
    to build trees by assembling a left tree, a root, and a right tree. That way,
    you’ll be able to use any of the three fold methods taking only one function parameter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否用树折叠做到同样的事情？为了实现这一点，你需要一种新的构建树的方法，通过组装左树、根和右树。这样，你将能够使用仅需要一个函数参数的任何三种折叠方法。
- en: Exercise 10.10 (hard)
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.10（困难）
- en: Create a method that combines two trees and a root to create a new tree. Its
    signature will be
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法，将两个树和一个根组合成一个新的树。它的签名将是
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method should allow you to reconstruct a tree identical to the original
    tree using any of these three folding methods: `foldPreOrder`, `foldInOrder`,
    and `foldPostOrder`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应允许你使用以下三种折叠方法中的任何一种重建与原始树相同的树：`foldPreOrder`、`foldInOrder`和`foldPostOrder`。
- en: Hint
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll have to handle the two cases differently. If the trees to be merged are
    ordered, which means that the maximum value of the first one is lower than the
    root, and the minimum value of the second one is higher than the root, you can
    simply assemble the three using the `T` constructor. Otherwise, you should fall
    back to another way of constructing the result.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不以不同的方式处理这两种情况。如果要合并的树是有序的，这意味着第一个树的最大值低于根，第二个树的最小值高于根，你可以简单地使用`T`构造函数组装这三个元素。否则，你应该回退到另一种构建结果的方法。
- en: Solution 10.10
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.10
- en: 'There are several ways to implement this method. One is to first define a method
    that tests the two trees to check whether they’re ordered. For this, you can first
    define methods to return the result of the value comparison:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此方法有几种方式。一种是在首先定义一个方法来测试两个树是否排序。为此，你可以首先定义方法来返回值比较的结果：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then you can define the ordered method that implements the tree comparison:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以定义一个有序方法来实现树比较：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first test (before the first `||` operator) returns `true` if both trees
    are not empty and the left `max`, `a`, and the right `min` are ordered. The second
    and third tests handle the cases where the left or the right tree is empty (but
    not both). Note that the `Result.mapEmpty` method returns `Success<Nothing>` if
    the `Result` is `Empty`, and a failure otherwise.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试（在第一个`||`运算符之前）如果两个树都不为空，并且左`max`、`a`和右`min`是有序的，则返回`true`。第二个和第三个测试处理左树或右树为空的情况（但不是两者都为空）。请注意，`Result.mapEmpty`方法如果`Result`是`Empty`，则返回`Success<Nothing>`，否则返回失败。
- en: 'Using this method, writing the `tree` method is very simple:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，编写`tree`方法非常简单：
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that if the trees aren’t ordered, you test the inverse order before falling
    back to the normal insert/merge algorithm.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果树没有排序，你将先测试逆序，然后再回退到正常的插入/合并算法。
- en: 'Now you can fold a tree and obtain the same tree as the original one (provided
    you use the correct function). You’ll find the following examples in the test
    code accompanying this book:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以折叠一棵树并得到与原始树相同的树（前提是你使用了正确的函数）。你将在随本书附带的测试代码中找到以下示例：
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You could also define a fold method that takes only one function with two parameters,
    as you did for `List`. The trick is to first transform the tree into a list, as
    shown in this example of `foldLeft`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义一个只接受一个具有两个参数的函数的折叠方法，就像你在`List`中做的那样。诀窍是首先将树转换成列表，如下面的`foldLeft`示例所示：
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This might not be the fastest implementation, but it might still be useful.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是最快的实现方式，但它可能仍然很有用。
- en: 10.6\. Mapping trees
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6\. 树的映射
- en: Like lists, trees can be mapped, but mapping trees is a bit more complicated.
    Applying a function to each element of a tree may seem trivial, but it’s not.
    The problem is that not all functions will preserve ordering. Adding a given value
    to all elements of a tree of integers will be fine, but using the function f(x)
    = x * x will be much more complicated if the tree might contain negative values,
    because simply applying the function “in place” will not result in a binary search
    tree.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，树也可以进行映射，但映射树要复杂一些。将函数应用于树的每个元素可能看起来很 trivial，但实际上并非如此。问题是并非所有函数都会保持排序。将给定值添加到整数的树的所有元素中是可以的，但如果树可能包含负值，使用函数
    f(x) = x * x 将会复杂得多，因为简单地“就地”应用该函数不会得到二叉搜索树。
- en: Exercise 10.11
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习10.11
- en: Define a `map` method for trees. Try to preserve the tree structure if possible.
    For example, mapping a tree of integers by squaring values might produce a tree
    with a different structure, but mapping by adding a constant should not.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为树定义一个`map`方法。如果可能的话，尽量保留树结构。例如，通过平方值映射整数树可能会产生具有不同结构的树，但通过添加常数映射则不应。
- en: Solution 10.11
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案10.11
- en: 'Using one of the fold methods makes it very straightforward. There are several
    possible implementations using the various fold methods. Here’s an example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其中一种折叠方法会使它非常简单直接。有几种可能的实现方式，使用各种折叠方法。以下是一个示例：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Of course, the `Empty` implementation returns `empty()` (not `this`, because
    the type would be invalid).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Empty`实现返回`empty()`（而不是`this`，因为类型将无效）。
- en: 10.7\. Balancing trees
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7\. 平衡树
- en: As I said earlier, trees will work well if they’re balanced, which means that
    all paths from the root to a leaf element have nearly the same length. In a perfectly
    balanced tree, the difference in lengths will not exceed 1, which happens if the
    deeper level isn’t full. (Only perfectly balanced trees of size 2*n* + 1 have
    all paths from the root to a leaf element of the same length.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，如果树是平衡的，它们将工作得很好，这意味着从根到叶元素的路径长度几乎相同。在完全平衡的树中，长度的差异不会超过1，这发生在较深的层级不是满的情况下。（只有大小为2*n*
    + 1的完全平衡树的所有根到叶元素的路径长度才相同。）
- en: 'Using unbalanced trees may lead to bad performance, because operations could
    need an amount of time proportional to the size of the tree instead of to log2(size).
    More dramatically, unbalanced trees can cause a stack overflow when using recursive
    operations. There are two ways to avoid this problem:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不平衡的树可能会导致性能不佳，因为操作可能需要的时间与树的大小成比例，而不是与 log2(size) 成比例。更严重的是，不平衡的树在使用递归操作时可能会导致栈溢出。有两种方法可以避免这个问题：
- en: Balance the unbalanced trees.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡不平衡的树。
- en: Use self-balancing trees.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自平衡树。
- en: Once you have a way to balance trees, it’s easy to make trees self-balancing
    by automatically launching the balancing process after each operation that could
    potentially change the tree structure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一种平衡树的方法，就很容易通过在每次可能改变树结构的操作后自动启动平衡过程来使树自平衡。
- en: 10.7.1\. Rotating trees
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.1\. 旋转树
- en: Before you can balance trees, you need to know how to incrementally change the
    structure of a tree. The technique used is called *rotating* the tree, and it’s
    illustrated in [figures 10.19](#ch10fig19) and [10.20](#ch10fig20).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够平衡树之前，你需要知道如何增量地改变树的结构。所使用的技术称为*旋转*树，并在[图10.19](#ch10fig19)和[10.20](#ch10fig20)中进行了说明。
- en: Figure 10.19\. Rotating a tree to the right. During the rotation, the line between
    2 and 3 is replaced with a line between 2 and 4, so element 3 is moved to become
    the left element of 4.
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.19\. 向右旋转树。在旋转过程中，2和3之间的线被替换为2和4之间的线，因此元素3被移动到成为4的左元素。
- en: '![](Images/10fig19.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig19.jpg)'
- en: Figure 10.20\. Rotating a tree to the left. The left element of 6 becomes 4
    (formerly the parent of 6) so the 5 is moved to become the right element of 4.
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.20\. 向左旋转树。6的左元素变为4（之前是6的父元素），因此5被移动到成为4的右元素。
- en: '![](Images/10fig20.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig20.jpg)'
- en: Exercise 10.12
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习10.12
- en: 'Write `rotateRight` and `rotateLeft` methods to rotate a tree in both directions.
    Be careful to preserve the branch order. Left elements must always be lower than
    the root, and right elements must always be higher than the root. Declare abstract
    methods in the parent class. Make them protected, because they’ll only be used
    from inside the `Tree` class. Here are the signatures in the parent class:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `rotateRight` 和 `rotateLeft` 方法以在两个方向上旋转树。注意保留分支顺序。左元素必须始终低于根节点，右元素必须始终高于根节点。在父类中声明抽象方法。使它们为受保护的，因为它们只会在
    `Tree` 类内部使用。以下是父类中的签名：
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Solution 10.12
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.12
- en: 'The `Empty` implementations simply return `this`. In the `T` class, these are
    the steps for the right rotation:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty` 实现简单地返回 `this`。在 `T` 类中，这些是右旋转的步骤：'
- en: Test the left branch for emptiness.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试左分支是否为空。
- en: If the left branch is empty, just return `this`, because rotating right consists
    of promoting the left element to root. (You can’t promote an empty tree.)
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果左分支为空，则直接返回 `this`，因为右旋转包括将左元素提升为根节点。（你不能提升一个空树。）
- en: If the left element isn’t empty, it becomes the root, so a new `T` is created
    with `left.value` as the root. The left branch of the left element becomes the
    left branch of the new tree. For the right branch, you construct a new tree with
    the original root as the root, the right branch of the original left as the left
    branch, and the original right as the right branch.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果左元素不为空，它成为根节点，因此创建一个新的 `T`，其根值为 `left.value`。左元素的左分支成为新树的左分支。对于右分支，你使用原始根作为根，原始左分支的右分支作为左分支，原始右分支作为右分支来构建一个新的树。
- en: 'The left rotation is symmetrical:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 左旋转是对称的：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The explanation seems complex, but it’s really very simple. Just compare the
    code with the figures to see what’s happening.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解释似乎很复杂，但实际上非常简单。只需将代码与图进行比较，看看发生了什么。
- en: If you try to rotate a tree several times, you’ll arrive at a point where one
    branch is empty, and the tree can’t be rotated any longer in the same direction.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试多次旋转树，你会到达一个点，其中一个分支为空，树不能在相同方向上继续旋转。
- en: Exercise 10.13
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 10.13
- en: To balance the tree, you’ll also need methods to transform a tree into an ordered
    list. Write a method to change a tree into an in-order list from right to left
    (which means in descending order). If you want to try more exercises, don’t hesitate
    to define a method for in-order left to right, as well as methods for pre order
    and post order.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡树，你还需要将树转换为有序列表的方法。编写一个将树转换为从右到左的有序列表（即降序）的方法。如果你想尝试更多练习，不要犹豫，定义从左到右的有序列表方法，以及前序和后序的方法。
- en: 'Here’s the signature for the `toListInOrderRight` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `toListInOrderRight` 方法的签名：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Solution 10.13
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 10.13
- en: 'This is very simple and is more related to lists than to trees. `Empty` implementations
    simply return an empty list. You might think of the following implementation:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，并且与列表比与树更相关。`Empty` 实现简单地返回一个空列表。你可能认为以下实现：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Unfortunately, this method will overflow the stack if the tree is very badly
    balanced. You need this method to balance a tree, so it would be sad if it couldn’t
    work with an unbalanced tree!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果树非常不平衡，这种方法会导致栈溢出。你需要这种方法来平衡树，所以如果它不能与不平衡的树一起工作，那就太遗憾了！
- en: 'Here’s a stack-safe recursive version:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安全的递归版本：
- en: '![](Images/285fig01_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/285fig01_alt.jpg)'
- en: The `unBalanceRight` method simply rotates the tree to the right until the left
    branch is empty ![](Images/num-02.jpg). Then it calls itself recursively to do
    the same thing to all the right subtrees, after having added the tree value to
    the accumulator list ![](Images/num-01.jpg). Eventually the tree parameter is
    found empty and the method returns the list accumulator.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`unBalanceRight` 方法简单地旋转树直到左分支为空 ![](Images/num-02.jpg)。然后它递归地调用自身，对所有的右子树执行相同操作，在将树值添加到累加列表
    ![](Images/num-01.jpg) 之后。最终找到空的树参数，方法返回累加列表。'
- en: 10.7.2\. Balancing trees using the Day-Stout-Warren algorithm
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.2\. 使用 Day-Stout-Warren 算法平衡树
- en: The Day-Stout-Warren algorithm is simple. First, transform the tree into a totally
    unbalanced tree. Then apply rotations until the tree is fully balanced. Transforming
    the tree into a totally unbalanced one is a simple matter of making an in-order
    list and creating a new tree from it. Because you want to create the tree in ascending
    order, you’ll have to create a list in descending order and then start to rotate
    the result left. Of course, you can choose the symmetric case.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Day-Stout-Warren算法很简单。首先，将树转换成完全不平衡的树。然后应用旋转直到树完全平衡。将树转换成完全不平衡的树是一个简单的过程，即创建一个有序列表，然后从它创建一个新的树。因为你想要按升序创建树，所以你必须创建一个降序列表，然后开始旋转结果向左。当然，你也可以选择对称的情况。
- en: 'Here’s the algorithm for obtaining a fully balanced tree:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获得完全平衡树的算法：
- en: Rotate the tree left until the result has branches as equal as possible. This
    means that the branch sizes will be equal if the total size is odd, and will differ
    by 1 if the total size is even. The result will be a tree with two totally unbalanced
    branches of near to equal size.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树向左旋转，直到结果分支尽可能相等。这意味着如果总大小是奇数，则分支大小将相等；如果总大小是偶数，则分支大小将相差1。结果将是一个具有两个几乎相等大小的完全不平衡分支的树。
- en: Apply the same process recursively to the right branch. Apply the symmetric
    process (rotating right) to the left branch.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相同的进程递归地应用于右分支。对左分支应用对称的过程（向右旋转）。
- en: 'Stop when the height of the result is equal to log2(size). For this you’ll
    need the following helper method:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当结果的高度等于log2(size)时停止。为此，你需要以下辅助方法：
- en: '[PRE47]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exercise 10.14
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习10.14
- en: Implement the `balance` method to fully balance any tree. This will be a static
    method taking the tree to be balanced as its parameter.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`balance`方法来完全平衡任何树。这将是一个接受要平衡的树作为参数的静态方法。
- en: Hint
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'This implementation will be based on several helper methods: A front method
    will create the totally unbalanced tree by calling the `toListInOrderRight` method.
    The resulting list will be folded left into a (totally unbalanced) tree, which
    will then be easier to balance.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现将基于几个辅助方法：一个前方法将通过调用`toListInOrderRight`方法创建完全不平衡的树。结果列表将折叠成（完全不平衡的）树，然后更容易平衡。
- en: 'You’ll also need a method to test whether a tree is fully balanced or not,
    and one to recursively rotate a tree. Here’s the method for rotating a tree:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个方法来测试树是否完全平衡，以及一个递归旋转树的方法。以下是旋转树的方法：
- en: '[PRE48]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This method is called `unfold` by analogy to `List.unfold` or `Stream.unfold`.
    It does the same job (except that the result type of the function is the same
    as its input type), but it forgets the results, keeping only the two last ones,
    so it’s faster and uses less memory.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法被称为`unfold`，是类比于`List.unfold`或`Stream.unfold`。它执行相同的任务（除了函数的结果类型与其输入类型相同），但它忘记了结果，只保留最后两个，因此它更快且占用更少的内存。
- en: Solution 10.14
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案10.14
- en: 'First, you define the utility method that tests whether a tree is unbalanced.
    For it to be balanced, the difference between the heights of both branches must
    be 0 if the total size of branches is even, and 1 if the size is odd:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义一个实用方法来测试树是否不平衡。为了使其平衡，如果分支的总大小是偶数，则两个分支的高度差必须为0；如果大小是奇数，则高度差为1：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then you can write the main balancing methods:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以编写主要平衡方法：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 10.7.3\. Automatically balancing trees
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.3\. 自动平衡树
- en: Although the `balance` method is designed to avoid stack overflow when handling
    big, unbalanced trees, you can’t use it on such trees because it would itself
    overflow the stack during the balancing process. This can be seen in the tests.
    Testing the `balance` method with a fully unbalanced tree of more than 15,000
    elements is impossible.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`balance`方法旨在处理大而不平衡的树时避免栈溢出，但你不能在这样的大树上使用它，因为在平衡过程中它本身可能会溢出栈。这一点可以在测试中看到。用超过15,000个元素的完全不平衡的树测试`balance`方法是不可行的。
- en: The solution is to use `balance` only on small fully unbalanced trees and on
    partially balanced trees of any size. This means that you must balance a tree
    before it becomes too big. The question is whether you can make the balancing
    automatic after each modification.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是只在小型完全不平衡树和任何大小的部分平衡树上使用`balance`。这意味着你必须在大树变得太大之前对其进行平衡。问题是是否可以在每次修改后自动进行平衡。
- en: Exercise 10.15
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习10.15
- en: Transform the tree you’ve developed to make it auto-balancing on insertions,
    merges, and removals.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将你开发的树转换，使其在插入、合并和删除时自动平衡。
- en: Solution 10.15
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案10.15
- en: 'The obvious solution is to call `balance` after each operation that modifies
    the tree, as in the following code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 显然的方法是在每次修改树的操作后调用`balance`，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will work for small trees (that, in fact, don’t need to be balanced),
    but it won’t work for large ones because it would be much too slow. One solution
    is to only partially balance trees. For example, you could run the balancing method
    only when the height is 20 times the ideal height of a fully balanced tree:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于小树（实际上不需要平衡）是有效的，但对于大树则不适用，因为它会非常慢。一个解决方案是仅部分平衡树。例如，你可以在高度是完全平衡树理想高度的20倍时运行平衡方法：
- en: '[PRE52]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 10.7.4\. Solving the right problem
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.7.4. 解决正确的问题
- en: The performance of the balancing solution may seem far from optimal, but it’s
    a compromise. Creating a tree from an ordered list of 100,000 elements would take
    7.5 seconds and produce a tree of height 59, compared with the ideal height of
    16\. Replacing the value 20 with 10 in the `insert` method will double the time
    with no benefit, because the resulting tree will have a height of 159\. Note that
    the resulting height isn’t proportional to the value you use. It’s much better
    if the tree is balanced close to the last insertion, so it’s better to use a high
    value, just to avoid stack overflow, and to explicitly balance the tree before
    using it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡解决方案的性能可能看起来远非最佳，但这是一种折衷方案。从有序列表中创建包含100,000个元素的树将需要7.5秒，并且生成的树的高度为59，与理想高度16相比。在`insert`方法中将值20替换为10将使时间加倍，而没有任何好处，因为生成的树的高度将为159。请注意，生成的高度并不与您使用的值成比例。如果树在最后插入时接近平衡，那就更好了，因此最好使用一个较高的值，仅为了避免栈溢出，并在使用之前显式地平衡树。
- en: 'But the real question is, what problem are you trying to solve? In fact, there
    are at least two very different requirements:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正的问题是，你试图解决什么问题？实际上，至少有两个非常不同的要求：
- en: You must be able to create a tree from a huge quantity of elements in any order
    without the risk of overflowing the stack.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须能够从任意顺序的大量元素中创建一个树，而不会出现栈溢出的风险。
- en: You must make the tree as well balanced as possible, because this minimizes
    the height, and the time needed for a search is proportional to the height.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须尽可能使树平衡，因为这最小化了高度，而搜索所需的时间与高度成正比。
- en: For the first requirement, you don’t need to make the tree perfectly balanced.
    A height of 2,000 is acceptable because this will not overflow the stack. You
    could simply balance the tree each time 2,000 elements have been inserted. You
    would then balance the tree again when the construction is finished.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个要求，你不需要使树完全平衡。高度为2,000是可以接受的，因为这样不会溢出栈。你可以在插入2,000个元素后简单地平衡树。然后，在构建完成后再次平衡树。
- en: The second requirement is a different story, and the use cases may vary. Some
    trees are almost never updated, whereas others change continuously. In the first
    case, it may be OK to balance the tree after each change. In the second, it’s
    probably better to update only after a certain number of changes. Either way,
    an optimization would be to batch the tree modifications and balance only after
    each batch. You’ll learn more about this in [chapter 11](kindle_split_018.xhtml#ch11).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求是另一个故事，用例可能不同。有些树几乎从不更新，而有些则持续变化。在第一种情况下，在每次更改后平衡树可能是可以的。在第二种情况下，可能更好的是在一定数量的更改后更新。无论如何，一个优化是在每个批次后批量修改树并仅在批次后平衡。你将在第11章中了解更多关于这方面的内容。
- en: 10.8\. Summary
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8. 概述
- en: Trees are recursive data structures in which one element is linked to one or
    several subtrees.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树是递归数据结构，其中一个元素与一个或多个子树链接。
- en: Binary search trees allow much faster retrieval of comparable elements.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树允许更快地检索可比元素。
- en: Trees may be more or less balanced. Fully balanced trees provide the best performance,
    whereas totally unbalanced trees have the same performance as lists.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树可能更平衡或不平衡。完全平衡的树提供最佳性能，而完全不平衡的树与列表具有相同性能。
- en: The size of a tree is the number of elements it contains; its height is the
    longest path in the tree.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的大小是它包含的元素数量；它的高度是树中最长的路径。
- en: The tree structure depends on the order of insertion of the tree elements.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树结构取决于树元素的插入顺序。
- en: Trees can be traversed in many different orders (pre order, in order, or post
    order), and in both directions (left to right, or right to left).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树可以以许多不同的顺序（前序、中序或后序）遍历，并且可以双向（从左到右或从右到左）遍历。
- en: Trees can be easily merged without traversing them.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树可以轻松合并，而无需遍历它们。
- en: Trees can be mapped or rotated as well as folded in many ways.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树还可以以多种方式映射、旋转以及折叠。
- en: Trees can be balanced for better performance and to avoid stack overflows in
    recursive operations.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树可以通过平衡来提高性能并避免递归操作中的栈溢出。
