- en: Chapter 9\. Change detection and component lifecycle
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 变化检测和组件生命周期
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How Angular knows that a UI update is needed
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular如何知道需要UI更新
- en: Reviewing the milestones in the life of a component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查组件生命周期中的里程碑
- en: Writing code in component lifecycle hooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件生命周期钩子中编写代码
- en: All the apps you’ve developed so far have been properly updating the UI when
    the user or program updates the properties of your components. How does Angular
    know when to update the UI? In this chapter, we’ll discuss the change detection
    (CD) mechanism that monitors the asynchronous events of your app and decides whether
    the UI should be updated or not.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止开发的全部应用程序在用户或程序更新组件属性时都正确地更新了UI。Angular是如何知道何时更新UI的？在本章中，我们将讨论变化检测（CD）机制，该机制监控你的应用程序的异步事件并决定是否更新UI。
- en: We’ll also discuss the lifecycle of an Angular component and the callback method
    hooks you can use to provide application-specific code that intercepts important
    events during a component’s creation, lifespan, and destruction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论Angular组件的生命周期以及你可以使用的回调方法钩子，以提供特定于应用程序的代码，在组件创建、生命周期和销毁期间拦截重要事件。
- en: Finally, we’ll continue working on ngAuction. This time, you’ll add the view
    that displays product details.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将继续在ngAuction上工作。这次，你将添加显示产品详情的视图。
- en: 9.1\. A high-level overview of change detection
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 变化检测的高级概述
- en: As the user works with your app, things change and the values of component properties
    (the model) get modified. Most of the changes happen asynchronously—for example,
    the user clicks a button, data is received from a server, an observable starts
    emitting values, a script invokes the `setTimeout()` function, and so on. Angular
    needs to know when the result of an asynchronous operation becomes available,
    to update the UI accordingly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用你的应用程序时，事情会发生变化，组件属性的值（模型）会得到修改。大多数变化都是异步发生的——例如，用户点击按钮，从服务器接收数据，可观察者开始发出值，脚本调用`setTimeout()`函数，等等。Angular需要知道异步操作的结果何时可用，以便相应地更新UI。
- en: For automatic CD, Angular uses the library zone.js (the Zone). Angular subscribes
    to Zone events to trigger CD, which keeps the component’s model and UI in sync.
    The CD cycle is initiated by any asynchronous event that happens in the browser.
    The change detector keeps track of all async calls made in components, services,
    and so forth; and when they complete, it makes a single pass from top to bottom
    of the component tree to see whether the UI of any component has to be updated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动CD，Angular使用zone.js（Zone）库。Angular订阅Zone事件以触发CD，从而保持组件的模型和UI同步。CD周期由浏览器中发生的任何异步事件启动。变化检测器跟踪组件、服务等中做出的所有异步调用；当它们完成时，它会从上到下遍历组件树，以查看任何组件的UI是否需要更新。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The CD mechanism applies changes in the component’s properties to its UI. CD
    never changes the value of the component’s property.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CD机制将组件属性的变化应用到其UI上。CD永远不会更改组件属性的值。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The zone.js library is one of the dependencies in your Angular project. It
    spares you from manually writing code to update UI, but starting with Angular
    5, using the Zone is optional. To illustrate the role of zone.js, let’s do an
    experiment: you’ll create a simple project managed by the Zone first, and then
    you’ll turn the Zone off. This project includes the `AppComponent` shown in the
    following listing.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: zone.js库是Angular项目中依赖之一。它让你免于手动编写代码来更新UI，但从Angular 5开始，使用Zone是可选的。为了说明zone.js的作用，让我们做一个实验：你将首先创建一个由Zone管理的简单项目，然后你将关闭Zone。该项目包括以下列表中所示的`AppComponent`。
- en: Listing 9.1\. The Zone is on
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. Zone处于开启状态
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Invokes the code asynchronously so the Zone will update the UI in five
    seconds**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 异步调用代码，以便Zone在五秒后更新UI**'
- en: 'Running this app renders “Welcome to app!” Five seconds later, the message
    changes to “Welcome to Angular 5!” Let’s change the app bootstrap code in the
    main.ts file to use the empty Zone object `noop`, introduced in Angular 5:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将渲染“欢迎使用app！”五秒后，消息更改为“欢迎使用Angular 5！”让我们将main.ts文件中的应用程序引导代码更改为使用Angular
    5中引入的空Zone对象`noop`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now running the same app will render “Welcome to app!” and this message will
    never change. You just turned off the Zone, and the app didn’t update the UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行相同的应用程序将渲染“欢迎使用app！”并且这条消息将永远不会改变。你刚刚关闭了Zone，应用程序没有更新UI。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can still initiate CD by injecting the `ApplicationRef` servicer in the
    app constructor and invoking its `tick()` method after updating the value of the
    `title` property.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以通过在应用程序构造函数中注入`ApplicationRef`服务并在更新`title`属性值后调用其`tick()`方法来启动CD。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An Angular application is structured as a tree of views (components), with the
    root component at the top of the tree. When Angular compiles component templates,
    each component gets its own change detector. When CD is initiated by the Zone,
    it makes a single pass, starting from the root down to the leaf components, checking
    to see whether the UI of each component needs to be updated (see the sidebar “[Lifecycle
    hooks, change detection, and production mode](#ch09sb02)” at the end of [section
    9.2](#ch09lev1sec2) about CD in dev versus production). Is there a way to instruct
    the change detector not to visit each and every component upon every async property
    change?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序的结构是一个视图（组件）的树，根组件位于树的顶部。当Angular编译组件模板时，每个组件都会获得自己的变更检测器。当Zone启动CD时，它进行单次遍历，从根到叶组件，检查每个组件的UI是否需要更新（有关CD在开发与生产模式下的差异，请参阅[9.2节](#ch09lev1sec2)末尾的侧边栏“[生命周期钩子、变更检测和生产模式](#ch09sb02)”）。在每次异步属性更改时，有没有一种方法可以指示变更检测器不要访问每个组件？
- en: 9.1.1\. Change detection strategies
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 变更检测策略
- en: 'For UI updates, Angular offers two CD strategies: `Default` and `OnPush`. If
    all components use the `Default` strategy, the Zone checks the entire component
    tree, regardless of where the change happened.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UI更新，Angular提供了两种CD策略：`Default`和`OnPush`。如果所有组件都使用`Default`策略，则无论更改发生在何处，Zone都会检查整个组件树。
- en: If a particular component declares the `OnPush` strategy, the Zone checks this
    component and its children only if the bindings to the component’s input properties
    have changed, or if the component uses `AsyncPipe`, and the corresponding observable
    started emitting values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定组件声明了`OnPush`策略，则只有在组件的输入属性绑定发生变化，或者组件使用`AsyncPipe`且相应的可观察对象开始发出值时，Zone才会检查该组件及其子组件。
- en: 'If a component that has the `OnPush` strategy changes a value of one of its
    properties bound to its template, the change detection cycle won’t be initiated.
    To declare the `OnPush` strategy, add the following line to the `@Component()`
    decorator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个采用`OnPush`策略的组件更改了其模板中绑定的一个属性值，则不会启动变更检测周期。要声明`OnPush`策略，请将以下行添加到`@Component()`装饰器中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 9.1](#ch09fig01) illustrates the effect of the `OnPush` strategy using
    three components: the parent, a child, and a grandchild. Let’s say a property
    of the parent was modified. CD will begin checking the component and all of its
    descendants.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1](#ch09fig01)展示了使用三个组件（父组件、子组件和孙组件）的`OnPush`策略的效果。假设父组件的一个属性被修改了。CD将从检查该组件及其所有后代开始。'
- en: Figure 9.1\. Change detection strategies
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1\. 变更检测策略
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: 'The left side of [figure 9.1](#ch09fig01) illustrates the default CD strategy:
    all three components are checked for changes. The right side of [figure 9.1](#ch09fig01)
    illustrates what happens when the child component has the `OnPush` CD strategy.
    CD starts from the top, but it sees that the child component has declared the
    `OnPush` strategy. If no bindings to the input properties have changed and no
    observable with `AsyncPipe` emits values (for example, via the `ActivatedRoute`
    parameters), CD doesn’t check either the child or the grandchild.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](#ch09fig01)的左侧展示了默认CD策略：检查所有三个组件是否有更改。右侧展示了当子组件具有`OnPush` CD策略时会发生什么。CD从顶部开始，但看到子组件已声明`OnPush`策略。如果没有输入属性的绑定发生变化，并且没有使用`AsyncPipe`的可观察对象发出值（例如，通过`ActivatedRoute`参数），则CD不会检查子组件或孙组件。'
- en: '[Figure 9.1](#ch09fig01) shows a small application with only three components,
    but real-world apps can have hundreds of components. With the `OnPush` strategy,
    you can opt out of CD for specific branches of the tree.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](#ch09fig01)展示了一个只有三个组件的小型应用程序，但现实世界的应用程序可以有数百个组件。使用`OnPush`策略，您可以选择不针对树中的特定分支进行CD。'
- en: '[Figure 9.2](#ch09fig02) shows a CD cycle caused by an event in the GrandChild1
    component. Even though this event happened in the bottom-left leaf component,
    the CD cycle starts from the top; it’s performed on each branch except the branches
    that originate from a component with the `OnPush` CD strategy and have no changes
    in the bindings to this component’s input properties. Components excluded from
    this CD cycle are shown on a white background.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.2](#ch09fig02) 展示了由GrandChild1组件中的事件引起的CD周期。尽管这个事件发生在左下角的叶子组件中，但CD周期是从顶部开始的；它对每个分支都进行了执行，除了那些从具有`OnPush`
    CD策略的组件起源且对此组件输入属性没有变化的分支。从CD周期中排除的组件显示在白色背景上。'
- en: Figure 9.2\. Excluding a branch from a CD cycle
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 从CD周期中排除一个分支
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片9.2的替代文本](Images/09fig02_alt.jpg)'
- en: This has been a brief overview of the CD mechanism. You should learn about CD
    in depth if you need to work on performance tuning of a UI-intensive application,
    such as a data grid containing hundreds of cells with constantly changing values.
    For in-depth coverage of change detection, see the article “Everything you need
    to know about change detection in Angular” by Maxim Koretskyi at [http://mng.bz/0YqE](http://mng.bz/0YqE).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于CD机制的简要概述。如果你需要调整UI密集型应用程序的性能，例如包含数百个不断变化值的网格数据，你应该深入了解CD。关于更改检测的深入覆盖，请参阅Maxim
    Koretskyi在[http://mng.bz/0YqE](http://mng.bz/0YqE)上发表的文章“关于Angular中更改检测你需要知道的一切”。
- en: In general, it’s a good idea to make `OnPush` a default CD strategy for each
    component. If you see that the UI of a component doesn’t get updated as expected,
    review the code and either switch back to the `Default` change detection strategy
    or manually initiate the CD pass by injecting the `ChangeDetectorRef` object and
    using its API (see [https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将`OnPush`作为每个组件的默认CD策略是个好主意。如果你发现某个组件的UI没有按预期更新，请检查代码，要么切换回`Default`更改检测策略，要么通过注入`ChangeDetectorRef`对象并使用其API手动启动CD遍历（见[https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef)）。
- en: What if you have a slow-running component with lots of changing template elements?
    Could multiple passes of the change detector contribute to this slowness?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个运行缓慢且有很多变化模板元素的组件，多次更改检测的遍历是否会导致这种缓慢？
- en: 9.1.2\. Profiling change detection
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 配置更改检测
- en: '[Listing 9.2](#ch09ex02) shows you how to profile change detection by enabling
    Angular debug tools. Change the app bootstrap code in main.ts to look like the
    following.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.2](#ch09ex02) 展示了如何通过启用Angular调试工具来配置更改检测。将main.ts中的应用程序启动代码更改为以下内容。'
- en: Listing 9.2\. Enabling Angular debug tools
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 启用Angular调试工具
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Gets a reference to the bootstrapped app**'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取启动应用程序的引用**'
- en: '***2* Gets a reference to the app’s top-level component**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取应用程序顶层组件的引用**'
- en: '***3* Enables Angular debug tools**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 启用Angular调试工具**'
- en: 'Launch your app, and in the browser console, enter the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的应用程序，然后在浏览器控制台中输入以下命令：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now your app will start reporting the time spent on each CD cycle, as shown
    in [figure 9.3](#ch09fig03).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的应用程序将开始报告每个CD周期所花费的时间，如图9.3所示。
- en: Figure 9.3\. Profiling change detection
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 配置更改检测
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片9.3的替代文本](Images/09fig03_alt.jpg)'
- en: We’ve covered change detection, so now let’s get familiar with the private life
    of a component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了更改检测，现在让我们熟悉组件的私有生活。
- en: 9.2\. Component lifecycle
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 组件生命周期
- en: 'Various events happen during the lifecycle of an Angular component: it gets
    created, reacts to different events, and gets destroyed. As explained in the last
    section, when a component is created, the CD mechanism begins monitoring it. The
    component is initialized, added to the DOM, and rendered by the browser. After
    that, the state of the component (the values of its properties) may change, causing
    rerendering of the UI, and, finally, the component is destroyed.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular组件的生命周期中会发生各种事件：它被创建、响应不同的事件，并被销毁。正如上一节所述，当组件被创建时，CD机制开始监控它。组件被初始化、添加到DOM中并由浏览器渲染。之后，组件的状态（其属性值）可能会改变，导致UI的重渲染，最终组件被销毁。
- en: '[Figure 9.4](#ch09fig04) shows the lifecycle hooks (methods) where you can
    add custom code to intercept the lifecycle event and add your code there. If Angular
    sees any of these methods implemented in your app, it’ll invoke them.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.4](#ch09fig04) 显示了你可以添加自定义代码以拦截生命周期事件的方法（方法）。如果 Angular 在你的应用程序中看到任何这些方法被实现，它将调用它们。'
- en: Figure 9.4\. A component’s lifecycle hooks
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 组件的生命周期钩子
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: The callbacks shown on the light-gray background will be invoked only once,
    and those on the darker background can be invoked multiple times during the component
    life span. The user sees the component after the initialization phase is complete.
    Then the change detection mechanism ensures that the component’s properties stay
    in sync with its UI. If the component is removed from the DOM tree as a result
    of the router’s navigation or a structural directive (such as `*ngIf`), Angular
    initiates the destroy phase.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在浅灰色背景上显示的回调函数只会被调用一次，而在深色背景上的回调函数可以在组件的生命周期内被多次调用。用户在初始化阶段完成后看到组件。然后变更检测机制确保组件的属性与其
    UI 保持同步。如果组件由于路由导航或结构指令（如 `*ngIf`）从 DOM 树中移除，Angular 将启动销毁阶段。
- en: 'The constructor is invoked first when the instance of the component is being
    created, but the component’s properties aren’t initialized yet in the constructor.
    After the constructor’s code is complete, Angular will invoke the following callbacks
    *if you implemented them*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件实例正在创建时，构造函数首先被调用，但在构造函数中组件的属性尚未初始化。构造函数的代码完成后，Angular 将调用以下回调 *如果你实现了它们*：
- en: '**`ngOnChanges()`—** Called when a parent component modifies (or initializes)
    the values bound to the input properties of a child. If the component has no input
    properties, `ngOnChanges()` isn’t invoked.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngOnChanges()`—** 当父组件修改（或初始化）绑定到子组件输入属性的值时被调用。如果组件没有输入属性，则不会调用 `ngOnChanges()`。'
- en: '**`ngOnInit()`—** Invoked after the first invocation of `ngOnChanges()`, if
    any. Although you might initialize some component variables in the constructor,
    the properties of the component aren’t ready yet. By the time `ngOnInit()` is
    invoked, the component properties will have been initialized, which is why this
    method is mainly used for the initial data fetch.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngOnInit()`—** 在第一次调用 `ngOnChanges()` 之后被调用，如果有的话。尽管你可能在构造函数中初始化一些组件变量，但组件的属性尚未准备好。当
    `ngOnInit()` 被调用时，组件属性已经被初始化，这就是为什么这个方法主要用于初始数据获取。'
- en: '**`ngDoCheck()`—** Called on each pass of the change detector. If you want
    to implement a custom change detection algorithm or add some debug code, write
    it in `ngDoCheck()`. But keep in mind that placing any code in the `ngDoCheck()`
    method can affect the performance of your app because this method is invoked on
    each and every pass of the change detection cycle.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngDoCheck()`—** 在变更检测器的每次遍历中调用。如果你想实现一个自定义的变更检测算法或添加一些调试代码，请在 `ngDoCheck()`
    中编写它。但请注意，在 `ngDoCheck()` 方法中放置任何代码都可能影响你应用程序的性能，因为此方法在变更检测周期的每次遍历中都会被调用。'
- en: '**`ngAfterContentInit()`—** Invoked when the child component’s state is initialized
    and the projection completes. This method is called only if you used `<ng-content>`
    in your component’s template.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngAfterContentInit()`—** 当子组件的状态初始化并且投影完成时被调用。只有在你组件的模板中使用了 `<ng-content>`
    时，这个方法才会被调用。'
- en: '**`ngAfterContentChecked()`—** During the change detection cycle, this method
    is invoked on the component that has `<ng-content>` after it gets the updated
    content from the parent if the bindings used in the projected content change.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngAfterContentChecked()`—** 在变更检测周期中，如果用于投影内容的绑定发生变化，并且组件从父组件获取了更新后的内容，则在此方法上调用该组件。'
- en: '**`ngAfterViewInit()`—** Invoked after a component’s view has been fully initialized.
    We used it in [section 8.4](kindle_split_017.xhtml#ch08lev1sec4) in [chapter 8](kindle_split_017.xhtml#ch08).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngAfterViewInit()`—** 在组件的视图完全初始化后调用。我们在第 8 章的 [8.4 节](kindle_split_017.xhtml#ch08lev1sec4)
    中使用了它。'
- en: '**`ngAfterViewChecked()`—** Invoked when the change detection mechanism checks
    whether there are any changes in the component template’s bindings. This callback
    may be called more than once as the result of modifications in this or other components.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngAfterViewChecked()`—** 当变更检测机制检查组件模板的绑定是否有任何更改时被调用。由于在此或其他组件中的修改，此回调可能被多次调用。'
- en: '**`ngOnDestroy()`—** Invoked when the component is being destroyed. Use this
    callback to clean unneeded resources, for example, to unsubscribe from explicitly
    created subscriptions or remove timers.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ngOnDestroy()`—** 当组件正在销毁时被调用。使用此回调来清理不需要的资源，例如，取消显式创建的订阅或移除计时器。'
- en: Each lifecycle callback is declared in the interface with a name that matches
    the name of the callback without the prefix `ng`. For example, if you’re planning
    to implement functionality in the `ngOnChanges()` callback, add `implements OnChanges`
    to your class declaration.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生命周期回调都在接口中以不带前缀 `ng` 的回调名称声明。例如，如果你计划在 `ngOnChanges()` 回调中实现功能，请将 `implements
    OnChanges` 添加到你的类声明中。
- en: Let’s consider some code samples illustrating the use of lifecycle hooks. The
    following code listing illustrates the use of `ngOnInit()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些代码示例，以说明生命周期钩子的使用。以下代码列表说明了 `ngOnInit()` 的使用。
- en: Listing 9.3\. Fetching data in `ngOnInit()`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 在 `ngOnInit()` 中获取数据
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Declares an input property**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明输入属性**'
- en: '***2* Injects a service, but doesn’t use it in the constructor**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入服务，但在构造函数中不使用它**'
- en: '***3* Uses the service in ngOnInit() to ensure that the productId is already
    initialized**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 ngOnInit() 中使用服务以确保 productId 已初始化**'
- en: This code uses the value of the input property `productId` as an argument of
    the `getProductById()` method. If you’d invoked `getProductById()` in the constructor,
    the `productId` property wouldn’t be initialized yet. By the time `ngOnInit()`
    is invoked, `productId` is initialized, and you can safely invoke `getProductById()`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用输入属性 `productId` 的值作为 `getProductById()` 方法的参数。如果你在构造函数中调用了 `getProductById()`，则
    `productId` 属性尚未初始化。到 `ngOnInit()` 被调用时，`productId` 已初始化，你可以安全地调用 `getProductById()`。
- en: The `ngOnDestroy()` hook is invoked when a component gets destroyed. For example,
    when you use the router to navigate from component A to component B, component
    A gets destroyed, and component B is created. If you created an explicit subscription
    in component A, don’t forget to unsubscribe in `ngOnDestroy()`. This hook is also
    supported by Angular services.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被销毁时，会调用 `ngOnDestroy()` 钩子。例如，当你使用路由器从组件 A 导航到组件 B 时，组件 A 会被销毁，而组件 B 被创建。如果你在组件
    A 中创建了一个显式的订阅，别忘了在 `ngOnDestroy()` 中取消订阅。此钩子也由 Angular 服务支持。
- en: 9.2.1\. Catching changes in the ngOnChanges hook
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 在 `ngOnChanges` 钩子中捕获更改
- en: 'Now let’s write a small app that uses `ngOnChanges()` and illustrates the different
    effects of bindings on primitive values versus object values. This app will include
    parent and child components, and the latter will have two input properties: `greeting`
    and `user`. The first property is a `string`, and the second is an `Object` with
    one property: `name`. To understand why the `ngOnChanges()` callback may or may
    not be invoked, you need to become familiar with the concept of mutable versus
    immutable values.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个小型应用程序，它使用 `ngOnChanges()` 并说明了绑定对原始值与对象值的不同影响。此应用程序将包括父组件和子组件，后者将有两个输入属性：`greeting`
    和 `user`。第一个属性是 `string` 类型，第二个属性是一个具有一个属性 `name` 的 `Object`。要理解 `ngOnChanges()`
    回调可能或可能不被调用，你需要熟悉可变与不可变值的概念。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mutable vs. immutable values**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变与不可变值**'
- en: 'JavaScript strings are primitives, which are *immutable*—when a string value
    is created at a certain location in memory, you can’t change it there. Consider
    the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 字符串是原始数据类型，它们是 *不可变的*—当字符串值在内存的某个位置创建时，你无法在那里更改它。考虑以下代码片段：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line creates the value `Hello` in memory. The second line doesn’t
    change the value at that address but creates the new string `Hello Mary` at a
    different memory location. Now you have two strings in memory, and each of them
    is immutable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在内存中创建值 `Hello`。第二行不会改变该地址的值，而是在不同的内存位置创建新的字符串 `Hello Mary`。现在你有两个字符串在内存中，每个都是不可变的。
- en: If the `greeting` variable was bound to an input property of a component, then
    its binding changed, because the value of this variable was initially at one memory
    location, and then the address changed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `greeting` 变量绑定到组件的输入属性，那么其绑定已更改，因为此变量的值最初在内存的一个位置，然后地址发生了变化。
- en: 'JavaScript objects (as well as functions and arrays) are *mutable* and are
    stored in heap memory, and only references to objects are stored on the stack.
    After the object instance is created at a certain memory location, the reference
    to this object on the stack doesn’t change when the values of the object’s properties
    change in the heap memory. Consider the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象（以及函数和数组）是*可变的*，并且存储在堆内存中，而对象引用仅存储在栈上。在某个内存位置创建对象实例后，当堆内存中对象属性的值发生变化时，栈上对此对象的引用不会改变。考虑以下代码：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the first line, the object is created, and the reference to the instance
    of the `user` object is stored in stack memory and points at a certain memory
    location. The string `"John"` has been created at another memory location, and
    the `user.name` variable knows where it’s located in memory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行之后，对象被创建，`user` 对象实例的引用存储在栈内存中，并指向某个内存位置。字符串 `"John"` 在另一个内存位置创建，`user.name`
    变量知道它在内存中的位置。
- en: After the second line of the preceding code snippet is executed, the new string
    `"Mary"` is created at another location. But the reference variable `user` is
    still stored in the same location on the stack. In other words, you mutated the
    content of the object but didn’t change the value of the reference variable that
    points at this object. To make an object immutable, you need to create a new instance
    of the object whenever any of its properties changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段的第二行执行后，新的字符串 `"Mary"` 在另一个位置创建。但引用变量 `user` 仍然存储在栈上的相同位置。换句话说，您修改了对象的内容，但没有改变指向此对象的引用变量的值。要使对象不可变，每当任何属性发生变化时，都需要创建对象的新实例。
- en: '|  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can read more about JavaScript data types and data structures at [http://mng.bz/bzL4](http://mng.bz/bzL4).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [http://mng.bz/bzL4](http://mng.bz/bzL4) 上了解更多关于 JavaScript 数据类型和数据结构的信息。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s add the `ngOnChanges()` hook to the child component to demonstrate how
    it intercepts modifications of the input properties. This application has parent
    and child components. The child has two input properties (`greeting` and `user`).
    The parent component has two input fields, and the user can modify their values,
    which are bound to the input properties of the child. Let’s see if `ngOnChanges()`
    will be invoked and which values it’s going to get. The code of the parent component
    is shown in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在子组件中添加 `ngOnChanges()` 钩子来演示它是如何拦截输入属性修改的。此应用程序具有父组件和子组件。子组件有两个输入属性（`greeting`
    和 `user`）。父组件有两个输入字段，用户可以修改它们的值，这些值绑定到子组件的输入属性。让我们看看 `ngOnChanges()` 是否会被调用以及它将获取哪些值。父组件的代码如下所示。
- en: Listing 9.4\. app.component.ts
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. app.component.ts
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Uses two-way binding to synchronize entered greeting and myGreeting**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用双向绑定同步输入问候语和 myGreeting**'
- en: '***2* Uses two-way binding to synchronize entered username and myUser.name**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用双向绑定同步输入用户名和 myUser.name**'
- en: '***3* Binds myGreeting to child’s input property greeting**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 myGreeting 绑定到子组件的输入属性 greeting**'
- en: '***4* Binds myUser to child’s input property user**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 myUser 绑定到子组件的输入属性 user**'
- en: The child component receives the values from the parent component via its input
    variables. This component implements the `OnChanges` interface. In the `ngOnChanges()`
    method, you print the received data as soon as the binding to any of the input
    variable changes, as shown in the following listing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 子组件通过其输入变量从父组件接收值。该组件实现了 `OnChanges` 接口。在 `ngOnChanges()` 方法中，每当任何输入变量的绑定发生变化时，立即打印接收到的数据，如下所示。
- en: Listing 9.5\. child.component.ts
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. child.component.ts
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Implements the OnChanges interface**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实现了 OnChanges 接口**'
- en: '***2* Angular invokes ngOnChanges() when the bindings to input properties change.**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当输入属性的绑定发生变化时，Angular 会调用 ngOnChanges()**'
- en: When Angular invokes `ngOnChanges()`, it provides a `SimpleChange` object containing
    the old and new values of the modified input property and the flag indicating
    whether this is the first binding change. You use `JSON.stringify()` to pretty-print
    the received values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 调用 `ngOnChanges()` 时，它提供一个包含修改后的输入属性旧值和新值以及表示这是否是第一次绑定更改的标志的 `SimpleChange`
    对象。您使用 `JSON.stringify()` 来美化打印接收到的值。
- en: Let’s see if changing `greeting` and `user.name` in the UI results in the invocation
    of `ngOnChanges()` on the child component. We ran this app, deleted the last letter
    in the word *Hello*, and changed the name of the user from John to John Smith,
    as shown in [figure 9.5](#ch09fig05).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 UI 中更改 `greeting` 和 `user.name` 是否会导致子组件上调用 `ngOnChanges()`。我们运行了此应用程序，删除了单词
    *Hello* 的最后一个字母，并将用户名从 John 更改为 John Smith，如图 [图 9.5](#ch09fig05) 所示。
- en: Figure 9.5\. `ngOnChanges()` is invoked after the greeting change
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.5\. `ngOnChanges()` 在问候语更改后调用
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig05_alt.jpg)'
- en: 'Initially, `ngOnChanges()` was invoked for both properties. Note the `"firstChange":
    true`—this was the very first change in bindings. After we deleted the letter
    *o* in the greeting *Hello*, `ngOnChanges()` was invoked again, and the `firstChange`
    flag became `false`. But changing the username from *John* to *John Smith* didn’t
    invoke `ngOnChanges()`, because the binding of the mutable object `myUser` didn’t
    change.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '初始时，`ngOnChanges()` 对两个属性都进行了调用。注意 `"firstChange": true`——这是绑定中的第一次更改。在我们删除问候语
    *Hello* 中的字母 *o* 之后，`ngOnChanges()` 再次被调用，并且 `firstChange` 标志变为 `false`。但是，将用户名从
    *John* 更改为 *John Smith* 并没有调用 `ngOnChanges()`，因为可变对象 `myUser` 的绑定没有改变。'
- en: 'To see this app in action, run `npm install` in the project lifecycle, and
    then run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请在项目生命周期中运行 `npm install`，然后运行以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Angular doesn’t update bindings to input properties if only the object properties
    change, and that’s why the `ngOnChanges()` on the child wasn’t invoked. But the
    change detection mechanism still catches the change. That’s why `"John Smith"`,
    the new value of the property `user.name`, has been rendered in the child component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅对象属性更改时，Angular 不会更新输入属性的绑定，这就是为什么子组件上的 `ngOnChanges()` 没有被调用。但是，更改检测机制仍然捕获了更改。这就是为什么属性
    `user.name` 的新值 `"John Smith"` 已经在子组件中渲染的原因。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'Add `changeDetection: ChangeDetectionStrategy.OnPush` to the template of `ChildComponent`,
    and its UI won’t reflect changes in the parent’s username. The binding to the
    child’s `user` property doesn’t change; hence, the change detector won’t even
    visit the child for UI updates.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `changeDetection: ChangeDetectionStrategy.OnPush` 添加到 `ChildComponent` 的模板中，并且其
    UI 不会反映父组件用户名的更改。绑定到子组件的 `user` 属性没有改变；因此，更改检测器甚至不会访问子组件以进行 UI 更新。'
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You probably appreciate the change detector for properly updating the UI, but
    what if you still need to programmatically catch the moment when the username
    changes and implement some code that handles this change?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能赞赏更改检测器正确更新 UI，但您仍然需要以编程方式捕获用户名更改的瞬间并实现一些处理此更改的代码？
- en: 9.2.2\. Catching changes in the ngDoCheck hook
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 在 ngDoCheck 钩子中捕获更改
- en: 'Suppose you want to catch the moment when a JavaScript object gets mutated.
    Let’s rewrite the child component from the preceding section to use the `ngDoCheck()`
    callback instead of `ngOnChanges()`. The goals are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想捕获 JavaScript 对象发生变异的瞬间。让我们将前述部分的子组件重写为使用 `ngDoCheck()` 回调而不是 `ngOnChanges()`。目标如下：
- en: Catch the moment when the object bound to an `Input()` property mutates.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获绑定到 `Input()` 属性的对象发生变异的瞬间。
- en: Find out which property of the bound object changed.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出绑定对象的哪个属性发生了变化。
- en: Get the previous value of the changed property.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取更改属性的旧值。
- en: Get the new value of this property.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取此属性的新的值。
- en: To achieve these goals, you’ll implement the `DoCheck` interface and use Angular’s
    `KeyValueDiffers`, `KeyValueChangeRecord`, and `KeyValueDiffer`. You want to monitor
    the `user` object and its properties.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，您将实现 `DoCheck` 接口并使用 Angular 的 `KeyValueDiffers`、`KeyValueChangeRecord`
    和 `KeyValueDiffer`。您想监控 `user` 对象及其属性。
- en: First, you’ll inject the `KeyValueDiffers` service, which implements diffing
    strategies for various Angular artifacts. Second, you need to create an object
    of type `KeyValueDiffer` that will specifically monitor `user` object changes.
    When a change happens, you’ll get an object of type `KeyValueChangeRecord` containing
    the properties `key`, `previousValue`, and `currentValue`. The code of the new
    child component is shown in the following listing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将注入 `KeyValueDiffers` 服务，该服务实现了各种 Angular 艺术品的差异策略。其次，您需要创建一个 `KeyValueDiffer`
    类型的对象，该对象将专门监控 `user` 对象的更改。当发生更改时，您将获得一个包含 `key`、`previousValue` 和 `currentValue`
    属性的 `KeyValueChangeRecord` 类型的对象。新的子组件代码如下所示。
- en: Listing 9.6\. child.component-docheck.ts
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. child.component-docheck.ts
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Declares a variable for storing differences**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个用于存储差异的变量**'
- en: '***2* Injects the service for monitoring changes**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入用于监控更改的服务**'
- en: '***3* Initializes the differ variable for storing differences in the user object**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 初始化用于存储用户对象差异的差异变量**'
- en: '***4* Implements the callback ngDoCheck()**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实现回调 ngDoCheck()**'
- en: '***5* Checks whether the properties of the user object changed**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查用户对象属性是否已更改**'
- en: '***6* Gets the record of changes for each user property**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 获取每个用户属性的更改记录**'
- en: '***7* Prints the changes on the console**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在控制台打印更改**'
- en: The `diff()` method returns a `KeyValueChanges` object that includes the record
    about the change and offers such methods as `forEachAddedItem()`, `forEachChangedItem()`,
    `forEachRemovedItem()`, and more. In your component, you’re interested only in
    catching changes, so you use `forEachChangedItem()`, which returns the `KeyValueChangeRecord`
    for each changed property.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff()`方法返回一个包含更改记录的`KeyValueChanges`对象，并提供诸如`forEachAddedItem()`、`forEachChangedItem()`、`forEachRemovedItem()`等方法。在你的组件中，你只对捕获更改感兴趣，因此你使用`forEachChangedItem()`，它返回每个更改属性的`KeyValueChangeRecord`。'
- en: The `KeyValueChangeRecord` interface defines the properties `key`, `currentValue`,
    and `previousValue`, which you print on the console. [Figure 9.6](#ch09fig06)
    shows what happens after you delete the letter *n* in the User name input field,
    which was *John* originally.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyValueChangeRecord`接口定义了`key`、`currentValue`和`previousValue`属性，你可以在控制台打印这些属性。[图9.6](#ch09fig06)显示了在用户名输入字段中删除原始的*John*字母*n*之后发生的情况。'
- en: Figure 9.6\. `ngDoCheck()` is invoked after each pass of the change detector.
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. `ngDoCheck()`在变更检测器的每次遍历之后被调用。
- en: '![](Images/09fig06_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig06_alt.jpg)'
- en: Catching the username changes doesn’t seem to be a practical use case, but some
    applications do need to invoke specific business logic whenever the value of a
    property changes. For example, financial applications may need to log each of
    a trader’s steps. If a trader places a buy order at $101 and then immediately
    changes the price to $100, that must be tracked in a log file. This may be a good
    use case for catching such a change and adding logging in the `DoCheck()` callback.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获用户名更改似乎不是一个实用的用例，但某些应用程序确实需要在属性值更改时调用特定的业务逻辑。例如，金融应用程序可能需要记录交易员每一步的操作。如果交易员在$101的价格下下了一个买单，然后立即将价格更改为$100，那么这必须在日志文件中跟踪。这可能是一个捕获此类更改并在`DoCheck()`回调中添加日志的好用例。
- en: 'To see this app in action, in the lifecycle/app.module.ts file, modify the
    import statement for the child component to `import {ChildComponent} from "./child.
    component-docheck";` and run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，在生命周期/app.module.ts文件中，将子组件的导入语句修改为`import {ChildComponent}
    from "./child.component-docheck";`并运行以下命令：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Caution
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: 'We want to warn you once again: use `ngDoCheck()` only if you can’t find another
    way of intercepting data changes, because it may affect the performance of your
    app.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次提醒您：只有在找不到其他拦截数据更改的方法时才使用`ngDoCheck()`，因为它可能会影响您应用程序的性能。
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lifecycle hooks, change detection, and production mode**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期钩子、变更检测和生产模式**'
- en: At the beginning of the chapter, we stated that the change detector makes one
    pass from top to bottom of the components tree to see if the component’s UI should
    be updated. This is correct if your app runs in production mode, but in development
    mode (default), change detector makes two passes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们提到变更检测器从组件树顶部到底部进行一次遍历，以查看组件的UI是否需要更新。如果你的应用程序以生产模式运行，这是正确的，但在开发模式（默认）下，变更检测器进行两次遍历。
- en: If you open the browser’s console while running most of the apps from this book,
    you’ll see a message stating that Angular is running in development mode, which
    performs assertions and other checks within the framework. One such assertion
    verifies that a change detection pass doesn’t result in additional changes to
    any bindings (for example, your code doesn’t modify the UI in the component lifecycle
    callbacks during the CD cycle). If your code tries to change the UI from one of
    the lifecycle callbacks, Angular will throw an exception.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行本书中的大多数应用程序时打开浏览器的控制台，你会看到一个消息，表明Angular正在开发模式下运行，该模式在框架内执行断言和其他检查。其中一种断言验证变更检测遍历不会导致任何绑定（例如，你的代码在组件生命周期回调期间不会在CD周期中修改UI）。如果你的代码试图在生命周期回调中从UI更改UI，Angular将抛出异常。
- en: When you’re ready to make a production build, turn on production mode so the
    change detector will make only one pass and won’t perform the additional bindings
    check. To enable production mode, invoke `enableProdMode()` in your app before
    invoking the `bootstrap()` method. Enabling production mode will also result in
    better app performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好进行生产构建时，请开启生产模式，这样变更检测器只会进行一次遍历，并且不会执行额外的绑定检查。要启用生产模式，请在调用`bootstrap()`方法之前在你的应用中调用`enableProdMode()`。启用生产模式还将导致应用性能更好。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that we’ve covered all the important parts of the component’s life, let’s
    continue working on ngAuction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了组件生命周期的所有重要部分，让我们继续在ngAuction上工作。
- en: '9.3\. Hands-on: Adding the product view to ngAuction'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 实践：将产品视图添加到ngAuction
- en: In [chapter 7](kindle_split_016.xhtml#ch07), you created the home page of ngAuction.
    In this section, you’ll create the product view, which will be rendered when the
    user clicks one of the product tiles in the home view. [Figure 9.7](#ch09fig07)
    shows how the product view will look if the user selects Vintage Bluetooth Radio.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_016.xhtml#ch07)中，你创建了ngAuction的首页。在本节中，你将创建产品视图，它将在用户点击首页中产品瓷砖之一时渲染。[图9.7](#ch09fig07)显示了如果用户选择复古蓝牙收音机，产品视图将如何显示。
- en: Figure 9.7\. The product view
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7. 产品视图
- en: '![](Images/09fig07_alt.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig07_alt.jpg)'
- en: Besides information about the radio on the right, on the left are other suggested
    products that you want the user to consider. Amazon uses the same marketing technique
    while showing a product description. You’ve probably seen “More items to consider”
    or “Frequently bought together” sections on Amazon’s product pages. Depending
    on the viewport size, suggested products can be rendered either on the left or
    at the bottom of the product view.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了右侧收音机的信息外，左侧还有其他推荐的产品，你希望用户考虑。当展示产品描述时，亚马逊使用相同的营销技术。你可能已经在亚马逊的产品页面上看到过“更多考虑的商品”或“经常一起购买”的部分。根据视口大小，推荐产品可以在产品视图的左侧或底部渲染。
- en: 'The view shown in [figure 9.7](#ch09fig07) will be implemented as `ProductComponent`,
    which will include two child components: `ProductDetailComponent` and `ProductSuggestionComponent`.
    In the product view, you’ll use the Flex Layout library so that the UI layout
    will adjust to the available width of the viewport on the user’s device.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.7](#ch09fig07) 中显示的视图将实现为`ProductComponent`，它将包括两个子组件：`ProductDetailComponent`和`ProductSuggestionComponent`。在产品视图中，你将使用Flex布局库，以便UI布局能够调整到用户设备视口的可用宽度。'
- en: 'One more thing: your product view will be implemented as a lazy-loaded feature
    module, explained in section 4.3 in [chapter 4](kindle_split_013.xhtml#ch04).
    Let’s begin.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：你的产品视图将作为一个懒加载的功能模块来实现，这在第4章的4.3节中有详细解释。[第4章](kindle_split_013.xhtml#ch04)。让我们开始吧。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you created this version of ngAuction by following the explanations and instructions
    from the hands-on section in [chapter 7](kindle_split_016.xhtml#ch07), you can
    continue working on this app. You’ll find the completed version of ngAuction with
    the implemented product view in the folder chapter9/ng-auction.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过第7章中实践部分的解释和说明创建了ngAuction的这个版本，你可以继续在这个应用上工作。你将在chapter9/ng-auction文件夹中找到实现了产品视图的ngAuction的完整版本。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.3.1\. Creating product components and the module
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 创建产品组件和模块
- en: 'You’ll start with generating a `ProductModule` feature module by running the
    following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先通过运行以下命令生成一个`ProductModule`功能模块：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command will create the product folder with the product.module.ts file.
    Because you’ll use the Flex Layout library on the product view, add `FlexLayoutModule`
    to the `imports` property of the `@NgModule()` decorator, as shown in the following
    listing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将创建包含product.module.ts文件的product文件夹。因为你将在产品视图中使用Flex布局库，所以将`FlexLayoutModule`添加到`@NgModule()`装饰器的`imports`属性中，如下所示。
- en: Listing 9.7\. product.module.ts
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7. product.module.ts
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This feature module will contain three components: `ProductComponent`, `ProductDetailComponent`,
    and `ProductSuggestionComponent`. The latter two will be subcomponents, and you
    want them to be located in separate subfolder under the product folder. You generate
    these components with the following commands:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能模块将包含三个组件：`ProductComponent`、`ProductDetailComponent`和`ProductSuggestionComponent`。后两个将是子组件，你希望它们位于产品文件夹下的单独子文件夹中。你将使用以下命令生成这些组件：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands will generate three components and will add their names to the
    `declarations` property of the product module. You’re going to lazy load the `ProductModule`
    when the user clicks a particular product tile in the home component. To do that,
    you’ll configure an additional route for the `products/:productId` path, so the
    app.component.ts file will look like the following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将生成三个组件，并将它们的名称添加到产品模块的 `declarations` 属性中。当用户在主页组件中点击特定的产品瓷砖时，您将懒加载 `ProductModule`。为此，您将为
    `products/:productId` 路径配置一个额外的路由，因此 `app.component.ts` 文件将如下所示。
- en: Listing 9.8\. app.routing.ts
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. app.routing.ts
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now you can proceed with implementing the components supporting the product
    view.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以继续实现支持产品视图的组件。
- en: 9.3.2\. Implementing the product component
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 实现产品组件
- en: 'Your `ProductComponent` will serve as a wrapper for two child components: `ProductDetailComponent`
    and `ProductSuggestionComponent`. The product component implements the following
    functionality:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `ProductComponent` 将作为两个子组件 `ProductDetailComponent` 和 `ProductSuggestionComponent`
    的包装器。产品组件实现了以下功能：
- en: It should be a default route of the product module.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是产品模块的默认路由。
- en: It should receive the product ID passed from the home component.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该接收从主页组件传递的产品ID。
- en: It should get a reference to the `ProductService` object to receive product
    details.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该获取 `ProductService` 对象的引用以接收产品详情。
- en: It should manage the layout of its children based on the viewport width.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应根据视口宽度管理其子元素的布局。
- en: To render the `ProductComponent` when the user navigates to the product view,
    you need to add the following listing to the `ProductModule`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用户导航到产品视图时渲染 `ProductComponent`，您需要将以下内容添加到 `ProductModule` 中。
- en: Listing 9.9\. product.module.ts
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. product.module.ts
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding section, you configured the route for the path `'products/:productId'`
    in the root module, which means `ProductComponent` has to receive the requested
    product ID. You also need to inject `ProductService` in the constructor of `ProductComponent`,
    as shown in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您在根模块中配置了路径 `'products/:productId'` 的路由，这意味着 `ProductComponent` 必须接收请求的产品ID。您还需要在
    `ProductComponent` 的构造函数中注入 `ProductService`，如下所示。
- en: Listing 9.10\. product.component.ts
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. product.component.ts
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Gets the product ID**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取产品ID**'
- en: '***2* Ensures that product ID is a valid number**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保产品ID是一个有效的数字**'
- en: '***3* Switches to the observable that retrieves details for the specified product**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 切换到检索指定产品详细信息的观察者**'
- en: '***4* Initializes the observable for populating the suggested products**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 初始化用于填充建议产品的观察者**'
- en: This component receives the product ID from the `ActivatedRoute` object. In
    [section 6.6](kindle_split_015.xhtml#ch06lev1sec6) of [chapter 6](kindle_split_015.xhtml#ch06),
    you saw the code that directly subscribes to the `paramMap`. In this case, you
    don’t explicitly invoke the `subscribe()` method but will use the `async` pipe
    in the template. That’s why you convert the given parameter from a string to a
    number with `parseInt()` in the `map` operator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件从 `ActivatedRoute` 对象接收产品ID。在 [第6章](kindle_split_015.xhtml#ch06lev1sec6)
    的 [第6.6节](kindle_split_015.xhtml#ch06) 中，您看到了直接订阅 `paramMap` 的代码。在这种情况下，您没有显式调用
    `subscribe()` 方法，但将在模板中使用 `async` 管道。这就是为什么您在 `map` 操作符中使用 `parseInt()` 将给定的参数从字符串转换为数字的原因。
- en: 'What if the user enters alpha characters in the URL instead of the product
    ID, such as http://localhost:4200/products/abc? In this case, `parseInt()` returns
    `NaN`, which you’ll catch in the `filter` operator using double-bang syntax: `!!productId`.
    Non-alpha characters won’t get through the `filter` operator.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在URL中输入字母字符而不是产品ID，例如 http://localhost:4200/products/abc？在这种情况下，`parseInt()`
    返回 `NaN`，您将在 `filter` 操作符中使用双感叹号语法 `!!productId` 来捕获它。非字母字符不会通过 `filter` 操作符。
- en: The numeric product IDs will be given to the `switchMap` operator that switches
    over to the observable returned by the `getById()` method. To get the suggested
    products, you invoke the `getAll()` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 数字产品ID将被提供给 `switchMap` 操作符，该操作符切换到由 `getById()` 方法返回的观察者。要获取建议的产品，您将调用 `getAll()`
    方法。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier, we stated that `ngOnInit()` is the right place for fetching data, but
    in this code sample, you do it in the constructor. Would it cause problems? Not
    in this case, because neither `getById()` nor `getAll()` uses component properties
    that would be initialized in the constructor.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到`ngOnInit()`是获取数据的正确位置，但在这个代码示例中，你在构造函数中这样做。这会造成问题吗？在这个情况下不会，因为`getById()`和`getAll()`都没有使用在构造函数中初始化的组件属性。
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Homework**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**作业**'
- en: The code for `ProductComponent` could use a couple of improvements, and we want
    you to implement them on your own.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductComponent`的代码可以进行一些改进，我们希望您自己实现它们。'
- en: Your product component invokes `productService.getAll()` to retrieve suggested
    products. This isn’t exactly right. Say you select sunglasses. The product-detail
    component will show the description of the sunglasses, and the sunglasses will
    be also included as a suggested product. See if you can modify the implementation
    of the product component so it won’t suggest the product that is already selected
    by the user.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您的产品组件调用`productService.getAll()`来检索推荐产品。这并不完全正确。假设您选择了太阳镜。产品详情组件将显示太阳镜的描述，并且太阳镜也将作为推荐产品显示。看看您能否修改产品组件的实现，使其不会推荐用户已经选择的产品。
- en: If you enter an invalid product ID in the browser (such as http://localhost:4200/products/abc)
    on the product page, you won’t see any errors because the `filter()` operator
    will ignore this request, but the page will render only suggested products. To
    handle this scenario in a user-friendly manner, create a resolve guard, which
    will cancel the navigation if the service doesn’t find the product with the provided
    ID and notify the user about it. For example, you can use the Angular Material
    snack-bar component for notifications (see [http://mng.bz/1hx1](http://mng.bz/1hx1)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在产品页面上浏览器中输入无效的产品ID（例如http://localhost:4200/products/abc），您将看不到任何错误，因为`filter()`运算符将忽略此请求，但页面将只渲染推荐产品。为了以用户友好的方式处理这种情况，创建一个解析守卫，如果服务找不到提供ID的产品，则取消导航并通知用户。例如，您可以使用Angular
    Material snack-bar组件进行通知（见[http://mng.bz/1hx1](http://mng.bz/1hx1))。
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The template of the product component will be implemented in the product .component.html
    file. It’ll host `<nga-product-detail>` and `<nga-product-suggestion>` components
    and pass them the product(s) data to render, as shown in the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 产品组件的模板将在product.component.html文件中实现。它将托管`<nga-product-detail>`和`<nga-product-suggestion>`组件，并将产品数据传递给它们以进行渲染，如下所示列表所示。
- en: Listing 9.11\. product.component.html
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11\. product.component.html
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* On larger than medium viewports, shows product detail on the right and
    suggested products on the left**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在大于中等视口的屏幕上，在右侧显示产品详情，在左侧显示推荐产品**'
- en: '***2* Takes enough space to render this component but not more**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 足够的空间来渲染此组件，但不要更多**'
- en: '***3* If product$ emitted a value, puts it in the local template variable product**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果产品生成了一个值，将其放入局部模板变量product中**'
- en: '***4* Passes the product object to <nga-product-detail> for rendering**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将产品对象传递给<nga-product-detail>进行渲染**'
- en: '***5* If suggestedProducts$ emitted a value, puts it in the local template
    variable products**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果suggestedProducts$生成了一个值，将其放入局部模板变量products中**'
- en: '***6* Passes products to <nga-product-suggestion> for rendering.**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将产品传递给<nga-product-suggestion>进行渲染。**'
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Best practice**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: '[Listing 9.11](#ch09ex11) uses the `async as` syntax for subscription. `async
    as product` means “define the local template variable `product`, and store the
    emitted value there.” This syntax is useful when you need to reference the emitted
    object multiple times. Without the `async as` syntax, it could be written like
    this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.11](#ch09ex11) 使用了`async as`语法进行订阅。`async as product`意味着“定义局部模板变量`product`，并将发射的值存储在那里。”这种语法在您需要多次引用发射对象时很有用。如果没有`async
    as`语法，它可以写成这样：'
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That would create two subscriptions instead of one, which you want to avoid,
    especially if a subscription triggers side effects like an HTTP request or some
    additional processing like filtering or sorting a large set of data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会创建两个订阅而不是一个，您想要避免这种情况，尤其是如果订阅会触发副作用，如HTTP请求或一些额外的处理，如过滤或排序大量数据。
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, to save space in this book, we won’t include the content of the
    .scss files that contain styles of the ngAuction components. Please refer to the
    code samples that come with the book, found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，为了节省本书的空间，我们不会包括包含 ngAuction 组件样式的 .scss 文件的内容。请参考本书附带代码示例，可在 [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    和 [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)
    找到。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.3.3\. Implementing the product-detail component
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 实现产品详情组件
- en: The `ProductDetailComponent` is a presentation component that contains no business
    logic and renders the product provided via its input property. It’s a child of
    the `ProductComponent`, as shown in the following listing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 是一个展示组件，其中不包含业务逻辑，并通过其输入属性渲染提供的产品。它是 `ProductComponent`
    的子组件，如下面的列表所示。'
- en: Listing 9.12\. product-detail.component.ts
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. product-detail.component.ts
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The template of this component is shown in the next listing. It supports responsive
    web design (RWD) using the directives from the Flex Layout library.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的模板如下所示。它使用 Flex Layout 库的指令支持响应式网页设计（RWD）。
- en: Listing 9.13\. product-detail.component.html
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.13\. product-detail.component.html
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Centers the content of the children both horizontally and vertically**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在水平和垂直方向上居中子组件的内容**'
- en: '***2* Half of the viewport is given to the product image.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 视口的一半用于产品图片。**'
- en: '***3* Half of the viewport is given to the title, description, and bidding
    controls.**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 视口的一半用于标题、描述和竞标控制。**'
- en: '***4* The last bid amount**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 最后的竞标金额**'
- en: '***5* Uses the button from Angular Material**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 Angular Material 的按钮**'
- en: '***6* The user can place bids in $5 increments.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 用户可以以 $5 的增量进行竞标。**'
- en: In this version of the auction, you don’t implement the bidding functionality.
    You’ll do that in the hands-on section in [chapter 13](kindle_split_022.xhtml#ch13).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的拍卖中，你不需要实现竞标功能。你将在第 13 章（kindle_split_022.xhtml#ch13）的手动操作部分完成这项工作。
- en: Because you use `mat-raised-button` from the Angular Material library, add the
    `MatButtonModule` to the product module
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了 Angular Material 库中的 `mat-raised-button`，请将 `MatButtonModule` 添加到产品模块
- en: Listing 9.14\. product.module.ts
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. product.module.ts
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 9.3.4\. Implementing the product-suggestion component
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 实现产品推荐组件
- en: In real-world online stores or auctions, the product-suggestion component shows
    similar products from the same category that the user may consider buying. In
    this version of ngAuction, you’ll show all your products (you have only a dozen
    of them) under the caption “More items to consider,” as you saw on the left in
    [figure 9.7](#ch09fig07).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的在线商店或拍卖中，产品推荐组件会显示用户可能考虑购买的同类别相似产品。在这个版本的 ngAuction 中，你将在“更多考虑项目”的标题下显示所有你的产品（你只有十几个），就像你在图
    9.7 左侧看到的那样[图 9.7](#ch09fig07)。
- en: '`ProductSuggestionComponent` is the second child of `ProductComponent`, and
    the content of the product-suggestion.component.ts file is shown in the following
    listing.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductSuggestionComponent` 是 `ProductComponent` 的第二个子组件，`product-suggestion.component.ts`
    文件的内容如下所示。'
- en: Listing 9.15\. product-suggestion.component.ts
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. product-suggestion.component.ts
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Sets the number of grid columns for different viewport sizes**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为不同视口大小设置网格列数**'
- en: '***2* Injects the ObservableMedia service from the Flex Layout library**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 Flex Layout 库注入 ObservableMedia 服务**'
- en: '***3* Gets the number of grid columns based on the media query alias**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 根据媒体查询别名获取网格列数**'
- en: The code for `ProductSuggestionComponent` is similar to the code for the `HomeComponent`
    developed for ngAuction in the hands-on section in [chapter 7](kindle_split_016.xhtml#ch07).
    In this case, you use different numbers of grid columns based on the viewport
    size, taking into account that a large portion of the screen will be occupied
    by the `ProductDetailComponent`. The template of the product suggestions component
    is shown in the following listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductSuggestionComponent` 的代码与在第 7 章（kindle_split_016.xhtml#ch07）的手动操作部分为
    ngAuction 开发的 `HomeComponent` 的代码类似。在这种情况下，你根据视口大小使用不同的网格列数，考虑到屏幕的大部分将被 `ProductDetailComponent`
    占用。产品推荐组件的模板如下所示。'
- en: Listing 9.16\. product-suggestion.component.html
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16\. product-suggestion.component.html
- en: '[PRE25]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Subscribes to columns$ using the async pipe**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用异步管道订阅列**'
- en: '***2* For each product, renders a tile that wraps product info in the anchor
    tag**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于每个产品，渲染一个包含产品信息的锚标签中的瓷砖**'
- en: '***3* Shows another product info if the user clicks the tile**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果用户点击瓷砖，则显示另一个产品信息**'
- en: Because you use `<mat-grid-list>` from the Angular Material library, add the
    `MatGridListModule` to the product module.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用了Angular Material库中的`<mat-grid-list>`，请将`MatGridListModule`添加到产品模块中。
- en: Listing 9.17\. product.module.ts
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17\. product.module.ts
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To run this version of ngAuction that implements routing and the product view,
    use the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行实现路由和产品视图的ngAuction版本，请使用以下命令：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Open the Network tab in Chrome Dev Tools and click one of the products. You’ll
    see that the code and resources of the product module were lazy loaded.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome Dev Tools中打开网络标签页，点击其中一个产品。你会看到产品模块的代码和资源是懒加载的。
- en: In the hands-on section of [chapter 11](kindle_split_020.xhtml#ch11), you’ll
    add search functionality and category tabs for easily filtering products by category.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章（[kindle_split_020.xhtml#ch11](https://kindle_split_020.xhtml#ch11)）的动手实践部分，你将添加搜索功能和类别标签，以便轻松按类别过滤产品。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The change detection mechanism automatically monitors changes to components’
    properties and updates the UI accordingly.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更检测机制自动监控组件属性的变化，并相应地更新UI。
- en: You can mark selected branches of your app component tree to be excluded from
    the change detection process.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以标记应用程序组件树中选定的分支，使其排除在变更检测过程之外。
- en: Writing the application code in the component lifecycle hook ensures that this
    code is executed in sync with UI updates.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件生命周期钩子中编写应用程序代码，确保此代码与UI更新同步执行。
