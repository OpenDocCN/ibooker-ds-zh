- en: Part 2\. Building a product with software and statistics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 使用软件和统计学构建产品
- en: The main object of any data science project is to produce something that helps
    solve problems and achieve goals. This might take the form of a software product,
    report, or set of insights or answers to important questions. The key tool sets
    for producing any of these are software and statistics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据科学项目的核心目标是产生有助于解决问题和实现目标的东西。这可能以软件产品、报告或一组见解或对重要问题的答案的形式出现。生产这些任何一种的关键工具集是软件和统计学。
- en: '[Part 2](#part02) of this book begins with a chapter on developing a plan for
    achieving goals based on what you learned from the exploration and assessment
    covered in [part 1](kindle_split_009.xhtml#part01). Then [chapter 7](kindle_split_017_split_000.xhtml#ch07)
    takes a detour into the field of statistics, introducing a wide variety of important
    concepts, tools, and methods, focusing on their principal capabilities and how
    they can help achieve project goals. [Chapter 8](kindle_split_018_split_000.xhtml#ch08)
    does the same for statistical software; the chapter is intended to arm you with
    enough knowledge to make informed software choices for your project. [Chapter
    9](kindle_split_019_split_000.xhtml#ch09) then gives a high-level overview of
    some popular software tools that are not specifically statistical but that might
    make building and using your product easier or more efficient. Finally, [chapter
    10](kindle_split_020_split_000.xhtml#ch10) brings all these chapters together
    by considering some hard-to-foresee nuances of executing your project plan given
    the knowledge gained from the previous detours into statistics and software, as
    well as the many pitfalls of dealing with data, statistics, and software.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二部分](#part02) 的本书从一篇关于基于在第一部分（[part 1](kindle_split_009.xhtml#part01) 中涵盖的探索和评估所学的制定目标计划的章节开始。然后[第7章](kindle_split_017_split_000.xhtml#ch07)
    转向统计学领域，介绍了一系列重要的概念、工具和方法，重点关注它们的主体能力和如何帮助实现项目目标。[第8章](kindle_split_018_split_000.xhtml#ch08)
    以同样的方式介绍了统计软件；本章旨在为你提供足够的知识，以便为你的项目做出明智的软件选择。[第9章](kindle_split_019_split_000.xhtml#ch09)
    然后对一些流行的非统计软件工具进行了高级概述，这些工具可能使构建和使用你的产品更容易或更有效率。最后，[第10章](kindle_split_020_split_000.xhtml#ch10)
    通过考虑在统计学和软件方面的先前偏离所获得的知识以及处理数据、统计和软件的许多陷阱，将所有这些章节汇集在一起。'
- en: Chapter 6\. Developing a plan
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 制定计划
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Assessing what you’ve learned in the preliminary phases of the project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估在项目初步阶段学到的内容
- en: Revising the goals of the project based on new information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据新信息修订项目目标
- en: Realizing when you should redo prior work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到何时应该重做先前工作
- en: Communicating new information to the customer and getting feedback
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户传达新信息并获得反馈
- en: Developing a plan for the execution phase
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定执行阶段的计划
- en: '[Figure 6.1](kindle_split_016_split_000.xhtml#ch06fig01) shows where we are
    in the data science process: beginning the build phase by formal planning. Throughout
    this book, I’ve stressed that uncertainty is one of the principle characteristics
    of data science work. If nothing were uncertain, a data scientist wouldn’t have
    to explore, hypothesize, assess, discover, or otherwise apply scientific methods
    to solve problems. Nor would a data scientist need to apply statistics—a field
    founded on uncertainty—in projects consisting only of absolute certainties. Because
    of this, every data science project comprises a series of open questions that
    are subsequently answered—partially or wholly—via a scientific process.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](kindle_split_016_split_000.xhtml#ch06fig01) 展示了我们在数据科学流程中的位置：通过正式规划开始构建阶段。在本书中，我一直强调不确定性是数据科学工作的主要特征之一。如果没有任何不确定性，数据科学家就不需要探索、假设、评估、发现或以其他方式应用科学方法来解决问题。同样，数据科学家也不需要在只有绝对确定性构成的项目中应用统计学——一个建立在不确定性基础上的领域。正因为如此，每个数据科学项目都包含一系列开放性问题，这些问题随后通过科学过程部分或全部得到解答。'
- en: 'Figure 6.1\. The first step of the build phase of the data science process:
    planning'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 数据科学流程构建阶段的第一步：规划
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: It would be a mistake not to consider these new answers as they arrive. That
    would be comparable to continuing to drive along a specific road even after you’ve
    been informed that the road is closed ahead and the best detour requires you to
    turn. Within the past decade, internet-connected navigation devices, most often
    smartphones, have become ubiquitous. These devices are constantly being updated
    with new information, notably traffic and accident information, and they use this
    information to try to optimize the route suggested to the driver. This is also
    what a data scientist needs to do as uncertainties fade or disappear.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些新答案出现时不考虑它们将是一个错误。这就像在你被告知前方道路关闭，最佳绕行路线需要你转弯后，仍然继续沿着这条特定的道路行驶。在过去的十年里，互联网连接的导航设备，通常是智能手机，已经变得无处不在。这些设备不断更新新的信息，特别是交通和事故信息，并使用这些信息来尝试优化提供给驾驶员的路线。这也是数据科学家在不确定性消失或减少时需要做的事情。
- en: I like to stop periodically throughout a project, take stock of everything that
    I’ve learned, and consider it in the larger context of the major goals, similar
    to how I described the formulation of good questions and goals in [chapter 2](kindle_split_011_split_000.xhtml#ch02).
    But each time I do this, new information arises that can influence decisions.
    It may not be necessary to pause a project deliberately and formally consider
    all new information, but it’s often useful, because many people have a tendency
    to plow ahead with a prior plan that may no longer be the best plan. This relates
    to the concept of awareness, which I emphasize that every data scientist should
    maintain, and a formal periodic review of new knowledge can help share this awareness
    with a team if you’re working on one. Even when working by yourself, a somewhat
    formal review can be helpful for organization as well as for communicating progress
    to customers or other stakeholders of the project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在项目过程中定期停下来，总结我所学到的所有内容，并在更大的目标背景下考虑它们，就像我在[第2章](kindle_split_011_split_000.xhtml#ch02)中描述的如何制定好的问题和目标一样。但每次我这样做时，都会出现新的信息，这些信息可能会影响决策。可能没有必要故意暂停项目并正式考虑所有新的信息，但通常是有用的，因为许多人倾向于继续按照之前可能不再是最佳计划的计划前进。这与意识的概念有关，我强调每个数据科学家都应该保持这种意识，正式的定期审查新知识可以帮助在团队中分享这种意识。即使你独自工作，稍微正式的审查对于组织以及向客户或其他项目利益相关者传达进度也是有帮助的。
- en: The types of progress assessment and planning described in this chapter can
    also be done continually or periodically instead of all at once, and this is preferred
    in some cases. But it should absolutely be performed sometime between the preliminary
    phases of the project, which I’ve covered in previous chapters, and what I call
    the *execution phase*, which I’ll discuss beginning in the next chapter, and which
    includes most of a typical project’s formal statistical modeling and software
    development time and effort. Because the execution phase is labor intensive, you
    want to make sure the plan is good and will address the major goals of the project.
    You don’t want to have to redo the execution phase.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的进度评估和规划类型也可以持续进行或定期进行，而不是一次性完成，在某些情况下这是首选。但绝对应该在项目的前期阶段（我在前几章中已经介绍过）和我所称的*执行阶段*之间进行，我将在下一章开始讨论这个阶段，它包括典型项目的大部分正式统计建模和软件开发时间和精力。因为执行阶段劳动密集，你想要确保计划是好的，并且将解决项目的重大目标。你不想不得不重新执行执行阶段。
- en: 6.1\. What have you learned?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. 你学到了什么？
- en: After asking some questions and setting some goals in [chapter 2](kindle_split_011_split_000.xhtml#ch02),
    you surveyed the world of data in [chapter 3](kindle_split_012_split_000.xhtml#ch03),
    wrangled some specific data in [chapter 4](kindle_split_013_split_000.xhtml#ch04),
    and got to know that data in [chapter 5](kindle_split_014_split_000.xhtml#ch05).
    In each step, you learned something, and now you may already be able to answer
    some of the questions that you posed at the beginning of the project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_011_split_000.xhtml#ch02)中提出一些问题和设定一些目标后，你在[第3章](kindle_split_012_split_000.xhtml#ch03)中调查了数据的世界，在[第4章](kindle_split_013_split_000.xhtml#ch04)中整理了一些具体的数据，并在[第5章](kindle_split_014_split_000.xhtml#ch05)中了解了这些数据。在每一步中，你都学到了一些东西，现在你可能已经能够回答你在项目开始时提出的一些问题。
- en: For instance, while searching for data, did you find everything you needed,
    or is a critical chunk of data still missing? After assessing the data, did it
    contain everything you expected it to? Did the descriptive statistics you calculated
    turn out as expected, or were there any surprises?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在搜索数据时，你是否找到了你需要的一切，或者是否还有关键数据块缺失？在评估数据后，它是否包含了你预期的所有内容？你计算出的描述性统计结果是否如预期，或者有任何意外？
- en: 6.1.1\. Examples
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. 例子
- en: Because the answers to each of these questions will depend greatly on the details
    of the project, it’s difficult for me to formalize the process of asking and answering
    them. Instead I’ll consider the examples I’ve already presented in this book and
    describe some of my experiences at this stage of those projects. Later in this
    chapter, I’ll return to these examples and discuss how I used the new information
    to make subsequent decisions about the projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个问题的答案都将极大地取决于项目的具体细节，因此对我来说很难将提问和回答的过程形式化。相反，我将考虑在这本书中已经展示的例子，并描述我在这些项目这一阶段的某些经验。在本章的后面部分，我将回到这些例子，并讨论我是如何利用新信息来对项目做出后续决定的。
- en: Beer recommendation algorithm
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 啤酒推荐算法
- en: In [chapter 2](kindle_split_011_split_000.xhtml#ch02), I briefly described a
    hypothetical project whose goal was to recommend beers to users of a beer website
    based on ratings that those users provided for other beers. Because it’s a hypothetical
    project that I’ve never undertaken (though lots of others have), I can take some
    liberties in answering “what have I learned?” from the preliminary stages of the
    project, but I think it’s illustrative nonetheless.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章（[kindle_split_011_split_000.xhtml#ch02](kindle_split_011_split_000.xhtml#ch02)）中，我简要描述了一个假设的项目，其目标是根据用户为其他啤酒提供的评分来向啤酒网站的用户推荐啤酒。因为这个项目是一个我从未承担过的假设项目（尽管很多人都有），我可以从项目的初步阶段回答“我学到了什么？”这个问题，但我认为它仍然具有说明性。
- en: In particular, I mentioned that the data set we started with, a CSV file containing
    users’ beer ratings, didn’t contain the specific type of beer as one of the columns.
    This was a problem because the type or style of beer is usually informative in
    determining whether a person will like it or not. Knowing that the types are missing,
    my initial plan was either to find a data set containing the data types or infer
    the types from the name of the beer. If neither of these was possible, I would
    have to do the project without the types. There were, then, three different paths
    for analyzing and recommending beers, and determining the optimal path required
    some preliminary data science.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是提到，我们最初开始的数据集，一个包含用户啤酒评分的CSV文件，并没有将啤酒的具体类型作为其中一列。这是一个问题，因为啤酒的类型或风格通常在确定一个人是否会喜欢它时很有信息量。知道类型缺失后，我的初步计划是要么找到一个包含数据类型的数据集，要么从啤酒的名称中推断类型。如果这两者都不可能，我就不得不在没有类型的情况下完成项目。因此，有三种不同的路径来分析和推荐啤酒，确定最佳路径需要一些初步的数据科学。
- en: In surveying the world of data, as in [chapter 2](kindle_split_011_split_000.xhtml#ch02),
    I may have found a list of beers matched with their types. If I did, then that
    particular uncertainty would become a certainty (if I trusted it), and I would
    make use of the given beer types in my recommendation algorithm. If I didn’t find
    that list of beer types, then, as I was assessing my data as described in [chapter
    4](kindle_split_013_split_000.xhtml#ch04), I may have written a script, hopefully
    quickly, designed to parse the name of each beer and determine which style it
    is. If it seemed to work well, I would have made a plan to tweak it to improve
    it as much as possible, and that particular path would have been realized.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视数据世界时，就像在第2章（[kindle_split_011_split_000.xhtml#ch02](kindle_split_011_split_000.xhtml#ch02)）中描述的那样，我可能找到了一个与啤酒类型匹配的啤酒列表。如果找到了，那么这个特定的不确定性就会变成确定性（如果我相信它），我会在我的推荐算法中使用给定的啤酒类型。如果没有找到那个啤酒类型的列表，那么，正如我在第4章（[kindle_split_013_split_000.xhtml#ch04](kindle_split_013_split_000.xhtml#ch04)）中描述的那样评估我的数据时，我可能编写了一个脚本，希望它能快速地解析每个啤酒的名称并确定它的风格。如果它看起来工作得很好，我会制定一个计划来尽可能改进它，并且那条特定的路径就会实现。
- en: 'If I couldn’t find a data set with beer types and I also couldn’t manage to
    write a script that successfully inferred the beer types, then only one possible
    path would be left: I’d have to go without. Without knowing the beer types, the
    statistical challenge would be significantly greater but not impossible, and so
    I’d have to develop a plan with that in mind.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我找不到包含啤酒类型的数据库，而且我也无法编写一个成功推断啤酒类型的脚本，那么只剩下一条可能的路径：我不得不放弃。不知道啤酒类型，统计挑战将大大增加，但并非不可能，因此我必须制定一个考虑到这一点的计划。
- en: In all three cases I’ve described, I’ve gained new knowledge from the process
    of searching for data, wrangling it, and then assessing it. This new knowledge
    influences the optimal plan for continuing along in the project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述的所有三种情况下，我从搜索数据、处理数据和评估数据的过程中获得了新的知识。这种新知识影响了继续进行项目的最佳计划。
- en: Bioinformatics and gene expression
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生物信息学和基因表达
- en: In [chapter 3](kindle_split_012_split_000.xhtml#ch03), I introduced a project
    I worked on as part of my PhD research, which involved analyzing the relationship
    between the expression of specific microRNAs and individual genes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_012_split_000.xhtml#ch03)中，我介绍了我作为博士研究的一部分所参与的一个项目，该项目涉及分析特定miRNA的表达与单个基因之间的关系。
- en: While searching for more data and information that could be useful in public
    bioinformatics data repositories and publications, I found a few databases containing
    algorithmic predictions of which microRNAs (miRs) are expected to regulate the
    expression of certain genes. I also found some other analytic tools that achieved
    some of the same goals that I pursued but in a different way from that which I
    intended.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找更多可能有助于公共生物信息学数据仓库和出版物中的数据和信息的搜索过程中，我发现了一些包含预期调节某些基因表达的miRNA（miRs）的算法预测的数据库。我还发现了一些其他分析工具，它们以与我追求的不同方式实现了我追求的一些相同目标。
- en: For each data set of algorithmic predictions, which were based solely on RNA
    sequences, I would have to decide if they could be helpful to my project and also
    if that helpfulness justified the work required to take advantage of the data.
    Each new data set would require some amount of effort to access, parse, and transform
    the data into a useful form. In two cases, I decided to put in the work to take
    advantage of these predictions to inform my statistical models, which I had not
    yet built.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个基于RNA序列的算法预测数据集，我必须决定它们是否对我的项目有帮助，以及这种帮助是否足以证明利用这些数据所需的工作。每个新的数据集都需要一定程度的努力来获取、解析并将数据转换成有用的形式。在两种情况下，我决定投入工作来利用这些预测，以指导我尚未构建的统计模型。
- en: But while wrangling and assessing the data, I realized that the names of the
    miRs and the genes didn’t match exactly with the ones in my main data set, which
    was microarray expression data. Different scientific organizations have developed
    different naming schemes for genes based on particular needs, and they haven’t
    yet been unified, but name-conversion tools do exist. If I hoped to take advantage
    of these prediction data sets, I’d have to include in my plan something that would
    convert names from one scheme into another so I could match predictions with specific
    values in the microarray data that are, in some sense, realizations of the results
    that are predicted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在处理和评估数据的过程中，我意识到miR和基因的名称与我的主要数据集（微阵列表达数据）中的名称不完全匹配。不同的科学组织根据特定需求为基因开发了不同的命名方案，并且尚未统一，但存在名称转换工具。如果我希望利用这些预测数据集，我必须在计划中包括将一个方案中的名称转换为另一个方案的内容，以便我可以将预测与微阵列数据中的特定值相匹配，这些值在某种程度上是预测结果的实现。
- en: In addition to that new knowledge concerning naming schemes, in assessing the
    data I learned something about the distributions of the microarray expression
    data. Because I used replicate microarrays of most of the biological samples—I
    put the same biological RNA sample onto multiple microarrays—I could calculate
    what’s called a technical variance. A *technical variance* is the variance induced
    solely by the technology (a microarray) and that has nothing to do with biological
    processes. What I found was that in a majority of the 10,000 or so genes, the
    technical variance was greater than the biological variance. This meant that in
    those cases the measured expression level of the gene had more to do with the
    randomness of measuring a microscopic chemical compound than it did with biological
    effects. I had to decide whether I wanted to include those high-technical-variance
    (or low-biological-variance) genes in my analysis or to ignore them. Some statistical
    methods don’t handle variance well, and others do, so I would have to choose wisely.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于命名方案的新知识外，在评估数据时，我还了解了一些关于微阵列表达数据分布的情况。因为我使用了大多数生物样本的重复微阵列——我把相同的生物RNA样本放在多个微阵列上——我可以计算出所谓的“技术方差”。技术方差是由技术（微阵列）引起的方差，与生物过程无关。我发现，在10,000个左右的基因中，技术方差大于生物方差。这意味着在这些情况下，基因的测量表达水平与测量微观化学物质的随机性比与生物效应更多。我必须决定是否要在我的分析中包括这些高技术方差（或低生物方差）的基因，或者忽略它们。一些统计方法处理方差不好，而另一些则可以，所以我必须明智地选择。
- en: Top performances in track and field
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 田径和田径的顶级表现
- en: In [chapter 4](kindle_split_013_split_000.xhtml#ch04), I discussed how I once
    analyzed lists of best-ever performances in track and field to score and compare
    marks across events for both men and women. In particular, I wanted to compare
    the world records for all events and find out which one was the best.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_013_split_000.xhtml#ch04)中，我讨论了我如何分析田径历史上最佳表现列表，以评分和比较男女各项目的成绩。特别是，我想比较所有项目的世界纪录，找出哪一个是最好的。
- en: One of the first choices I had to make in this project was whether I wanted
    to use the best available no-cost data set, at [www.alltime-athletics.com](http://www.alltime-athletics.com),
    or pay for what is, supposedly, a more complete data set on another website. I’m
    a fan of open-access data, so I opted for the free data set, but if I had later
    realized that I didn’t have enough data to inform my statistical models, I would
    have had to reconsider my choice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我必须做出的第一个选择是，我是否想要使用可用的最佳免费数据集，在[www.alltime-athletics.com](http://www.alltime-athletics.com)，还是为另一个网站上声称的更完整的数据集付费。我是一个开放获取数据的粉丝，所以我选择了免费数据集，但如果我后来意识到我没有足够的数据来告知我的统计模型，我就不得不重新考虑我的选择。
- en: While examining my data set, I checked the lengths of each of the performance
    lists, finding that some events, such as the women’s one-mile run, contained only
    a couple hundred performances, whereas other events, such as the women’s steeplechase,
    were on the order of 10,000 entries in length. It wasn’t immediately clear whether
    this vast difference in performance list lengths would cause a problem, but it
    was definitely new information that I’d have to consider while planning.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我的数据集时，我检查了每个表现列表的长度，发现有些项目，如女子一英里赛跑，只包含几百次表现，而其他项目，如女子障碍赛，长度达到10,000条记录。这种表现列表长度的巨大差异是否会导致问题并不立即明朗，但这是我在规划时必须考虑的新信息。
- en: Another bit of information that I hadn’t foreseen was that some events, such
    as high jump, pole vault, and the 100 m and 200 m dashes, produced performance
    values that were more discrete values than continuous ones. In the high jump and
    pole vault, the bar is raised progressively to higher heights, and the athletes
    either jump that high or they don’t, meaning that on each day many athletes have
    the same performance. On the list of best-ever high jump performances, more than
    10 are tied at 2.40 m, more than 30 at 2.37 m, and at lower heights the numbers
    are larger. Looking at a distribution of performances, such as in a histogram
    or something comparable, a good argument can be made that a continuous distribution
    such as the log-normal distribution may not be the best choice. While planning,
    I’d have to decide whether and how I could compare these events to the others,
    such as the distance-running events, that produce marks that are obviously continuous
    because almost no one on the best all-time list is tied with anyone else.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我没有预料到的情况是，一些事件，如跳高、撑杆跳和100米和200米短跑，产生的性能值是离散值而不是连续值。在跳高和撑杆跳中，横杆逐渐升高，运动员要么跳过这个高度，要么跳不过，这意味着在每一天，许多运动员都有相同的成绩。在最佳跳高成绩列表中，超过10人的成绩是2.40米，超过30人的成绩是2.37米，在更低的高度上，数字更大。观察成绩分布，如直方图或类似的东西，可以很好地论证，连续分布，如对数正态分布，可能不是最佳选择。在规划时，我必须决定是否以及如何将这些事件与其他事件进行比较，例如长跑项目，这些项目的成绩显然是连续的，因为几乎没有人能在最佳历史记录名单上与其他人并列。
- en: Enron email analysis
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安然电子邮件分析
- en: In [chapter 5](kindle_split_014_split_000.xhtml#ch05), I talked about the set
    of Enron emails that have been made public and how I, along with my colleagues
    at the time, was using social network analysis techniques to try to detect suspicious
    behavior.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_014_split_000.xhtml#ch05)中，我谈到了已经公开的安然电子邮件集合，以及我以及当时在同事是如何使用社交网络分析技术来尝试检测可疑行为的。
- en: This was an open-ended project. We knew that some bad, criminal things happened
    at Enron, but we didn’t know how they would manifest themselves in the data, if
    they did at all. We did know that we wanted to treat the email data as a set of
    communications across a social network, and so the first step to any analysis
    would be to enable the construction of a social network from the data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放性的项目。我们知道在安然公司发生了一些不好的、犯罪的事情，但我们不知道这些事情会在数据中如何体现，如果确实存在的话。我们知道我们希望将电子邮件数据视为一个社交网络中的通信集合，因此分析的第一步就是从数据中构建一个社交网络。
- en: One of the first surprising and disappointing realizations was that, across
    the 100+ PST files containing the emails, the same email sender (or recipient)
    could be represented in many different ways. For instance, one of the most prolific
    emailers in the data set, Jeff Dasovich, might appear in the email’s Sender field
    as Jeff Dasovich, Jeffrey Dasovich, *jeff.dasovich@enron.com*, or even DASOVICH,
    and those are only a few of the many possibilities. This may not seem like a big
    problem at first glance, but it was. Dasovich himself wasn’t tough to recognize,
    but there were multiple people named Davis, Thomas, and so on that weren’t so
    easy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个令人惊讶和失望的发现之一是，在包含电子邮件的100多个PST文件中，同一个电子邮件发送者（或接收者）可以用许多不同的方式表示。例如，数据集中最活跃的电子邮件发送者之一，Jeff
    Dasovich，可能在电子邮件的“发送者”字段中显示为Jeff Dasovich、Jeffrey Dasovich、*jeff.dasovich@enron.com*，甚至DASOVICH，而这些只是众多可能性中的一小部分。乍一看，这似乎不是一个大问题，但实际上却是。Dasovich本人并不难识别，但还有多个名叫Davis、Thomas等的人并不容易区分。
- en: As part of the data-wrangling process, I ended up writing a script that would
    try to parse whatever name appeared and determine whether the name had already
    been encountered, with preference for nicely formatted names and email addresses,
    but the script was by no means perfect. In some cases, we had two or more different
    people in the constructed social network who were, in fact, the same person, but
    we had failed to combine them because the script hadn’t recognized the names as
    matching each other. We had checked the most prolific senders and recipients manually,
    but past the top 100 or 200 people, there were no guarantees that the script had
    matched names correctly. In planning, we had to take into account this uncertainty
    in the matching of emails with named senders and recipients.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据处理过程的一部分，我最终编写了一个脚本，该脚本会尝试解析出现的任何名称，并确定该名称是否已经被遇到，优先考虑格式良好的名称和电子邮件地址，但这个脚本远非完美。在某些情况下，我们在构建的社会网络中有两个人或更多人实际上是同一个人，但我们未能将他们合并，因为脚本没有识别出这些名称彼此匹配。我们手动检查了最活跃的发送者和接收者，但在前100或200人之后，我们无法保证脚本正确地匹配了名称。在规划中，我们必须考虑到电子邮件与命名发送者和接收者匹配的不确定性。
- en: Needless to say, at the beginning of the project we didn’t know that matching
    names to one another would be one of the biggest challenges that we faced. The
    task of writing a reasonably successful script consumed a larger portion of my
    effort than any other aspect of the project, if I recall correctly. The uncertainty
    of the task and awareness of the complexity of the problem were crucial to the
    assessment and planning for the execution phase of the project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，在项目开始时，我们并不知道将名称相互匹配将是我们面临的最大挑战之一。如果我记得正确的话，编写一个相当成功的脚本的任务消耗了我比项目其他任何方面更多的精力。任务的不可确定性和对问题复杂性的认识对于项目的执行阶段的评估和规划至关重要。
- en: After we had a reasonable solution to the name-matching problem, we ran some
    descriptive statistics on the Enron data set. Surprising or not, we quickly realized
    that certain people, such as Jeff Dasovich, had sent several thousand emails over
    the course of a couple of years, whereas key executives such as Ken Lay had sent
    almost none. Clearly, personal behavior, at least as it relates to email, would
    have to be considered in our statistical models. We had made an implicit assumption
    that all significant employees at Enron wrote enough emails for us to model their
    behavior, but clearly this wasn’t true. Whatever analyses we did later would have
    to allow for vastly differing general behaviors while still detecting specific
    behaviors that were anomalous in some sort of criminal sense. This was no small
    problem and yet was another thing to consider during planning.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们找到了解决名称匹配问题的合理方案之后，我们对安然数据集进行了一些描述性统计分析。出人意料还是不出所料，我们很快意识到某些人，比如Jeff Dasovich，在几年时间里发送了几千封电子邮件，而像Ken
    Lay这样的关键高管几乎一封都没有发送。显然，个人行为，至少就电子邮件而言，必须在我们的统计模型中予以考虑。我们隐含地假设安然的所有重要员工都写了足够的电子邮件，以便我们能够模拟他们的行为，但显然这并不正确。我们后来进行的任何分析都必须允许存在极大的行为差异，同时仍然能够检测到某些在某种犯罪意义上的异常行为。这并非小问题，而且在规划过程中还要考虑的另一件事。
- en: 6.1.2\. Evaluating what you’ve learned
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 评估你所学的
- en: I’ve provided examples but little concrete guidance regarding what you may have
    learned on your specific project. Concrete guidance would be hard to come by,
    because every project is different, and it also doesn’t seem possible to group
    projects into types that will generally produce the same types of lessons and
    new information. This evaluative phase embodies the uncertainty of data science
    projects and emphasizes how and why data scientists need to be—first and foremost—always
    aware, technology-enabled problem solvers. For the real problems in data science,
    there are no canned solutions. The only solutions are awareness and creativity
    while applying tools, off-the-shelf or custom, and intelligent interpretation
    of results. During the preliminary phases of any data science project, you learn
    some things, and you should take these as seriously as any other information,
    particularly because they precede and are in a position to inform the main execution
    phase of the project, and because they are the most project-specific information
    you have. Because of the possible significance of this new information, performing
    the evaluation phase described in this chapter can be helpful.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提供了例子，但关于你在特定项目中可能学到的具体指导很少。具体的指导很难找到，因为每个项目都是不同的，而且似乎也不可能将项目分组为将产生相同类型教训和新信息的类型。这个评估阶段体现了数据科学项目的不可确定性，并强调了数据科学家为什么需要首先始终保持警觉，成为技术驱动的解决问题者。对于数据科学中的实际问题，没有现成的解决方案。唯一的解决方案是在应用工具（无论是现成的还是定制的）时保持警觉和创造力，以及智能地解释结果。在数据科学项目的初步阶段，你会学到一些东西，你应该像对待任何其他信息一样认真对待这些信息，尤其是因为它们在项目的主要执行阶段之前，并且因为它们是你拥有的最具体的项目信息。由于这一新信息的可能重要性，执行本章中描述的评估阶段可能会有所帮助。
- en: This evaluation phase is a retrospective phase of the project. If you’re someone
    who takes copious notes, remembering what you’ve done and what the results were
    won’t be a problem, but if you’re like me and you rarely take notes on your own
    work, the task of remembering might be more difficult. I’ve begun to tend toward
    technologies that automatically record my work. Git, in yet another use it wasn’t
    explicitly designed for, provides some functionality that can help me remember
    what has happened in the recent history of my project. If my commit messages are
    informative, sometimes I can reconstruct a project history from them, but this
    is clearly not ideal. An email trail can also be a memory aid. For that reason,
    I also now tend toward more wordy emails and Git commit messages; I never know
    when I’m going to need to remember something and which specific details will be
    helpful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个评估阶段是项目的一个回顾阶段。如果你是一个喜欢做大量笔记的人，记住你所做的工作和结果不会是问题，但如果你像我一样，很少对自己的工作做笔记，那么记住的任务可能会更困难。我开始倾向于使用那些能自动记录我工作技术的工具。Git，在它未被明确设计用于的另一个用途中，提供了一些可以帮助我记住项目近期历史的功能。如果我的提交信息是有信息的，有时我可以从它们中重建项目历史，但这显然不是理想的。电子邮件记录也可以作为记忆辅助。因此，我现在也更倾向于使用更冗长的电子邮件和Git提交信息；我永远不知道我什么时候需要记住某件事，以及哪些具体细节会有帮助。
- en: 'In any case, if you’re able to collect and summarize what you’ve learned since
    the beginning of the project, you’re in good shape. People often begin projects
    with unrealistic expectations and define their goals in accordance with these
    expectations, but then they wait too long to readjust their expectations based
    on new information that proves them unreasonable. That’s the point of this section:
    every data scientist should pause sometimes and consider whether any new information
    changes the fundamental expectations and assumptions that underlie the goals that
    had been formulated when far less project-specific information was available.
    Reconsidering goals and expectations in light of this new information is the topic
    of the next section.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果你能收集和总结自项目开始以来所学到的内容，你就处于良好的状态。人们常常带着不切实际的期望开始项目，并根据自己的期望来设定目标，但随后他们等待太久，没有根据新的信息调整自己的期望，而这些新信息证明他们的期望是不合理的。这就是本节的意义所在：每个数据科学家都应该时不时地停下来，考虑是否有任何新的信息改变了在项目具体信息较少时制定的目标和假设的基本期望和假设。根据这一新信息重新考虑目标和期望是下一节的主题。
- en: 6.2\. Reconsidering expectations and goals
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 重新考虑期望和目标
- en: The summary of new information that we’ve collected according to the previous
    section could be substantial, insignificant, unsurprising, transformative, bad,
    good, or of any other description you might care to think up. But you won’t know
    how to describe the new information until you have it. Principally, however, the
    new information possesses some quality that colors how you think about the project,
    its progress, its usefulness, and so on, even if that quality is to confirm some
    things that you previously believed to be true. As I discussed in [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    confirmation of assumptions is important, and the same is true here for the project’s
    expectations. It may feel like little progress has been made if you’ve done considerable
    work only to have your expectations unchanged, but in fact progress was made in
    the removal of uncertainty. Removal of uncertainty is a form of strengthening
    the foundation of the project, upon which other more deliberate progress is built.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一节收集的新信息总结可能很大、无关紧要、不出所料、具有变革性、不好、好，或者任何你可能会想到的描述。但直到你拥有这些信息，你才知道如何描述它们。然而，主要的是，新信息具有某种特质，这种特质会改变你对项目、其进展、其有用性等方面的看法，即使这种特质是确认你之前认为正确的事情。正如我在[第5章](kindle_split_014_split_000.xhtml#ch05)中讨论的那样，假设的确认很重要，对于项目的期望也是如此。如果你做了大量工作，但期望没有改变，可能会觉得进展很小，但实际上，在消除不确定性方面已经取得了进展。消除不确定性是加强项目基础的一种形式，其他更深思熟虑的进步都是在此基础上建立的。
- en: On the other hand, if your expectations weren’t fulfilled by the project’s new
    information, then you’re in a different boat entirely. Some folks are emboldened
    by having their expectations confirmed, whereas others prefer the opposite—they
    enjoy having their expectations challenged, because it means they’re learning
    and discovering new things. In the case where the expectations for your project
    are challenged, or even disproved entirely, it’s an opportunity to put various
    data science skills to use at once.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的期望没有通过项目的新信息得到满足，那么你完全处于不同的境地。有些人因为他们的期望得到确认而变得自信，而有些人则相反——他们喜欢挑战自己的期望，因为这意味着他们在学习和发现新事物。在你项目的期望受到挑战，甚至完全被推翻的情况下，这是一个同时运用各种数据科学技能的机会。
- en: 6.2.1\. Unexpected new information
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1. 意外的新的信息
- en: Discovering something new during the preliminary stages of a data science project
    isn’t unusual, and you might be tempted to think, “Of course! Given new information,
    I obviously will take it in stride and make full use of it from then on.” But
    it’s often not that simple.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学项目的初步阶段发现新事物并不罕见，你可能会想，“当然！有了新信息，我显然会从容应对，并从那时起充分利用它。”但事情往往并不那么简单。
- en: Sometimes people so desperately want something to be true that they continue
    believing it even after it has been proven false. I found that the field of bioinformatics
    had many such hopefuls (that’s not to say there’s anything wrong with the field
    as a whole). It must be something about the nexus of two different types of cutting-edge
    technologies—machines that can extract and measure molecular-biological activity
    on a cellular level, as well as some of the most sophisticated statistical methods
    in existence—that makes some people believe that one can save the other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们如此渴望某件事是真的，以至于即使它已经被证明是假的，他们仍然继续相信它。我发现生物信息学领域有许多这样的乐观者（这并不意味着整个领域有问题）。这一定与两种不同类型的尖端技术的交汇有关——能够在细胞水平上提取和测量分子生物活性的机器，以及现存的最复杂的统计方法——这使得一些人相信，一种可以拯救另一种。
- en: 'More than once in the course of my work, I have been presented with a data
    set produced by a laboratory experiment that took days or even weeks to prepare,
    and at some point during my analysis I came to the realization that the data was
    of low quality. This happens sometimes in bioinformatics; even the smallest contamination
    or slip of the hand can ruin a droplet of dissolved RNA that’s the entire basis
    for the experiment. Understandably, though, given the large amount of laboratory
    work involved in creating some data sets, biologists are reluctant to discard
    them. In one case, I found that the technical variance of a microarray data set
    was far larger than the biological variance, meaning that the measurements more
    closely resembled a random number generator than meaningful gene expression values.
    In another case, we used a time-intensive process that’s considered the gold standard
    in measuring the expression of individual genes, and the resulting data set was
    self-contradictory. In both of these cases, in my estimation, the data had been
    proven virtually worthless, and the experiments would need to be redone (this
    happens all the time in bioinformatics, which is why it’s important to check the
    data quality). But in both cases, someone involved with the project wasn’t able
    to admit that fact and spent a week or more trying to figure out how to salvage
    the data or how to analyze it in a clever way so that the shortcomings didn’t
    matter. This, to me, is irrational. It was the scientific equivalent of a sunk
    cost from financial accounting terminology: the experiment is done and it ended
    up being a bad investment. Instead of worrying about the money, time, and effort
    wasted, researchers should find a way to move forward that maximizes the chance
    of getting good results later. That isn’t to say there aren’t lessons to learn
    in failures—figuring out why it happened is usually helpful—but the main goal
    is to optimize the future, not justify the past.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作中，不止一次遇到了由实验室实验产生的数据集，这些实验的准备可能需要几天甚至几周的时间。在分析过程中，我意识到数据质量很低。在生物信息学中，这种情况有时会发生；即使是微小的污染或手部失误也可能破坏整个实验基础的溶解RNA滴。然而，考虑到创建某些数据集所涉及的实验室工作量大，生物学家们往往不愿意丢弃这些数据。在一个案例中，我发现一个微阵列数据集的技术差异远大于生物差异，这意味着测量结果更接近随机数生成器，而不是有意义的基因表达值。在另一个案例中，我们使用了一种耗时且被认为是测量单个基因表达的金标准的过程，但得到的数据集自相矛盾。在这两个案例中，据我所知，数据几乎毫无价值，实验需要重新进行（在生物信息学中这种情况经常发生，这就是为什么检查数据质量很重要的原因）。但在两种情况下，与项目有关的人员都无法承认这一事实，他们花费了一周或更长时间试图找出如何挽救数据或以巧妙的方式分析数据，以便缺点不会产生影响。对我来说，这是不理性的。这在科学上等同于财务会计术语中的沉没成本：实验已经完成，最终成为了一个坏的投资。研究人员不应该担心浪费的钱、时间和精力，而应该找到一种方法，最大限度地提高以后获得好结果的机会。这并不是说在失败中没有可以吸取的教训——弄清楚为什么会发生通常是有所帮助的——但主要目标是优化未来，而不是为过去辩护。
- en: In cases where new information runs contrary to expectations, though uncertainty
    is reduced, it isn’t reduced in the way expected, so it could feel like uncertainty
    is added, because those involved probably haven’t yet thought through all implications.
    Consider a close battle for an election in which a huge underdog has only recently
    made it into widespread attention. If the underdog wins, all the uncertainty is
    removed in the moment the result is announced. But because that result was not
    expected, it feels less certain than the case where the expected candidate wins,
    because most people would have been mentally prepared for the expected win of
    the heavy favorite and many of its implications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在新信息与预期相矛盾的情况下，尽管不确定性有所减少，但它并不是以预期的那种方式减少的，因此可能会感觉不确定性增加了，因为相关人员可能还没有充分考虑所有的影响。考虑一下选举中一场激烈的战斗，其中一位巨大的落后者最近才进入广泛关注。如果落后者获胜，一旦结果公布，所有的不确定性都会消除。但由于这个结果并不被预期，它感觉比预期候选人获胜的情况更不确定，因为大多数人已经为这位热门候选人的预期胜利及其许多影响做好了心理准备。
- en: This may not seem like data science, but this line of thinking has certainly
    played a role in my work. When I deal with expectations—and with them being proven
    right, wrong, or somewhere in between—feelings often get involved. Feelings are
    not data science, but if feelings affect how I react to new information, they
    become relevant. Although handling uncertainty is one of the principal skills
    of a data scientist, it’s human to react emotionally to uncertainty and to being
    right or wrong. Data scientists are, after all, only human.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不像数据科学，但这种思维方式确实在我的工作中发挥了作用。当我处理期望——以及它们被证明是正确、错误或介于两者之间时——情感往往会介入。情感不是数据科学，但如果情感影响我对新信息的反应，它们就变得相关。尽管处理不确定性是数据科学家的主要技能之一，但人类在不确定性以及正确或错误面前产生情感反应是正常的。毕竟，数据科学家也是人。
- en: 'The solution to all of this, if there is one, is to do everything to take all
    emotion out of the decision-making process. This is easier said than done, for
    me as well as almost everyone I’ve ever worked with. Everyone enjoys being right,
    and few data scientists or software engineers enjoy changing a plan midway through,
    in particular for large projects. Here are a few strategies for eliminating emotion
    from data science decision making:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有解决方案的话，解决所有这些问题的方法就是尽可能地将所有情感从决策过程中排除出去。这比说起来容易做起来难，对我来说也是如此，以及我几乎与所有人合作过。每个人都喜欢正确，而很少有数据科学家或软件工程师喜欢在中途改变计划，尤其是对于大型项目。以下是一些消除数据科学决策中情感的方法：
- en: '***Formality—*** Make lists, create flow charts, or write logical if-then statements
    showing the new information directly affecting future results. The most important
    task is to write these down so that you have a permanent record of why you chose
    a certain new path based on this new information.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***正式性—*** 制作列表、创建流程图或编写逻辑的if-then语句，直接展示新信息对未来结果的影响。最重要的任务是把这些写下来，以便你有一个永久记录，说明你基于这些新信息选择特定新路径的原因。'
- en: '***Consult a colleague—*** A colleague who isn’t invested in the project might
    be best, but certainly consult others on the project as well. Talking the new
    information through often helps, but having an outsider who listens well think
    through your new information and your plans to handle it can be invaluable.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***咨询同事—*** 一个对项目没有投入的同事可能最好，但肯定也要咨询项目中的其他人。讨论新信息通常有帮助，但有一个善于倾听的外部人士思考你的新信息和处理它的计划可能非常有价值。'
- en: '***Search the internet—*** This may not apply in some cases, but the world’s
    data scientists and statisticians have seen a *lot* of unexpected results. If
    you’re clever with a search engine and can whittle your result and pending decision
    into somewhat generic terms, the internet can be a big help.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***搜索互联网—*** 在某些情况下，这可能不适用，但世界各地的数据科学家和统计学家已经看到了很多意外结果。如果你擅长使用搜索引擎，并且能够将你的结果和待决决策简化为某些通用术语，互联网可以提供很大帮助。'
- en: Once you’ve reduced the problem to its core facts, including all the new information
    that you have and all the work you’ve done so far, making any new goals or adjusting
    any old goals based on the new information is a rational process that has no emotional
    penalties for ditching prior work that ended up being worthless.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将问题简化为其核心事实，包括你拥有的所有新信息和迄今为止所做的一切工作，基于新信息制定任何新目标或调整任何旧目标是一个理性的过程，这个过程没有因放弃最终无用的前期工作而产生的情感惩罚。
- en: 6.2.2\. Adjusting goals
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 调整目标
- en: 'Regardless of whether your expectations were met or whether you were completely
    surprised by preliminary results, it’s often worthwhile to evaluate and possibly
    adjust your project’s goals. [Chapter 2](kindle_split_011_split_000.xhtml#ch02)
    described a process for gathering initial information, asking good questions,
    and planning some ways to answer those questions that lead to fulfillment of the
    project’s goals. You want to revisit that same process here, in the presence of
    the new information you have as a result of the early exploratory stages of the
    project, to answer these questions again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的期望是否得到满足，或者你是否完全被初步结果所震惊，评估并可能调整你的项目目标通常都是值得的。[第二章](kindle_split_011_split_000.xhtml#ch02)描述了一个收集初始信息、提出好问题以及规划一些回答这些问题的方法，这些方法有助于实现项目目标。你现在需要回顾这个过程，结合项目早期探索阶段获得的新信息，再次回答以下问题：
- en: What is possible?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是可能的？
- en: What is valuable?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是有价值的？
- en: What is efficient?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是高效的？
- en: The practical limit of “What is possible?” is the counterbalance of the business-oriented
    daydreamer’s question “What is valuable?” and both are extremes that frame the
    pragmatic inquiry “What is efficient?” which ends up possibly being an important
    amalgam of the prior two.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “可能实现什么？”的实践限制是面向商业的空想家的问题“什么是有价值的？”的平衡，两者都是界定实用探究“什么是有效的？”的极端，最终可能成为前两个的重要混合体。
- en: What is possible?
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是可能的？
- en: 'While asking yourself what is possible at this stage of the project, you should
    consider the same things you did at the beginning of the project: data, software,
    obstacles, and many others. But because you know more now than you did then, some
    things that seemed impossible earlier may seem possible now, and some things that
    you thought would be possible may now appear quite the opposite.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在问自己在这个项目阶段可能实现什么时，你应该考虑你在项目开始时考虑过的同样的事情：数据、软件、障碍等等。但是因为你现在比当时知道得更多，一些之前看似不可能的事情现在可能看起来可行，而一些你认为可能实现的事情现在可能看起来正好相反。
- en: Usually at this point, it’s the data sets that make things seem less possible.
    There’s a tendency to be overly optimistic about the capability and content of
    data before you dig in and explore a little. By now you know a lot more and can
    draw far more informed conclusions about possibility.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在这个时候，是数据集使得事情看起来不太可能。在深入挖掘和探索之前，人们往往对数据和内容的能力和内容过于乐观。现在你已经知道得更多，可以得出更多关于可能性的更明智的结论。
- en: What is valuable?
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是有价值的？
- en: Most likely, the values of the goals of the project haven’t changed much, but
    it’s often worth considering them again for reference. On the other hand, in some
    fast-moving industries, the value estimates of various goals may indeed have changed.
    In those cases, it’s probably best to go through the list of goals with the customer
    to see what has changed and how.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，项目的目标价值并没有太大变化，但再次考虑它们作为参考通常是值得的。另一方面，在一些快速发展的行业中，各种目标的价值估计确实可能发生了变化。在这些情况下，最好与客户一起审查目标列表，看看有什么变化以及如何变化。
- en: What is efficient?
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是有效的？
- en: Data and software details in particular might have made some paths and goals
    seem easier or harder, more or less resource intensive, or otherwise different
    from before. Running the numbers again conceptually can help you reoptimize the
    plans to get the most benefit from the resources you have.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是数据和软件的细节可能使得某些路径和目标看起来更容易或更难，资源消耗更多或更少，或者与之前有所不同。再次从概念上运行这些数字可以帮助你重新优化计划，以从你拥有的资源中获得最大利益。
- en: 6.2.3\. Consider more exploratory work
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 考虑更多探索性工作
- en: Sometimes during this evaluative stage, it becomes obvious that you haven’t
    learned as much as you would have liked from the earlier exploratory phase. But
    you may have more informed ideas about what specific exploration would have led
    to more and better knowledge.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在这个评估阶段，很明显，你没有从早期的探索阶段学到你希望学到的那么多。但你可能对哪些具体的探索会带来更多和更好的知识有更明智的想法。
- en: For example, consider the beer recommendation algorithm project I’ve already
    discussed. Perhaps during the exploratory phase you wrote a script that tried
    to infer the beer type from the name of the beer, a possible tactic I discussed
    earlier in this chapter. The script seemed to work pretty well, but someone asks
    you, “How good is it?” and you realize you didn’t explicitly evaluate the script’s
    performance. In this case, it would be good to measure the performance in an objective
    way, so you can be reasonably sure it works well. A decent strategy for measuring
    performance is to spot-check a bunch of beer types that were inferred by the script.
    Randomly picking 20, 50, or even 100 beers and checking the inferred type against,
    say, the brewer’s web page would be a reliable way to get a statistic—probably
    the percentage of correctly inferred types—that tells you how well your script
    is doing. A good statistic can lend a lot of credibility to what you’ve done,
    and a bad one means you might have to improve the script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下我之前讨论过的啤酒推荐算法项目。也许在探索阶段，你编写了一个尝试从啤酒名称中推断啤酒类型的脚本，这是我在本章前面讨论过的一种可能的策略。这个脚本看起来工作得相当不错，但有人问你，“它有多好？”而你意识到你没有明确评估脚本的性能。在这种情况下，以客观的方式衡量性能会很好，这样你就可以有理由相信它工作得很好。衡量性能的一个不错的策略是抽查脚本推断出的几种啤酒类型。随机挑选20、50甚至100种啤酒，并将推断出的类型与，比如说，酿酒商的网页进行对比，这将是获得统计数据的可靠方法——可能是一个正确推断类型的百分比，这会告诉你你的脚本表现如何。一个好的统计数据可以给你的工作增添很多可信度，而一个差的统计数据意味着你可能需要改进脚本。
- en: Similarly, questions and concerns during this evaluative and planning stage
    can often indicate the usefulness of other exploratory work that you haven’t done
    yet. It’s OK—and sometimes good—to go back and do more exploring if it seems like
    it will be beneficial.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在这个评估和规划阶段出现的问题和担忧往往可以表明你尚未进行的其他探索性工作的有用性。如果觉得这样做会有益，回头去做更多的探索是完全可以的——有时甚至是有益的。
- en: 6.3\. Planning
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 规划
- en: As in [chapter 2](kindle_split_011_split_000.xhtml#ch02), evaluating and setting
    goals immediately precedes creating a plan. Some folks might like to do them at
    the same time, but I like to separate them, at least conceptually, because planning
    involves a lot of details—specifics about time, resources, people, schedules,
    monetary costs, for example—that aren’t usually directly relevant to the setting
    of goals. Which team member will be working on which aspect of the project and
    when shouldn’t play a large role in setting the principal goals of the project.
    But that does have a role in planning.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第2章](kindle_split_011_split_000.xhtml#ch02)中所述，评估和设定目标紧接着创建计划。有些人可能喜欢同时进行这两项工作，但我喜欢将它们分开，至少在概念上是如此，因为规划涉及许多细节——例如时间、资源、人员、日程安排、货币成本的具体细节——这些通常与设定目标没有直接关系。哪个团队成员将在何时负责项目的哪个方面不应该在设定项目主要目标时扮演重要角色。但在规划中，这确实有作用。
- en: As in the earlier planning phase, uncertainties and flexible paths should be
    in the forefront of your mind. You know more about your project now, so some of
    the uncertainties that were present before are no longer there, but certain new
    ones have popped up.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如早期规划阶段一样，不确定性和灵活的路径应该放在你的脑海中。你现在对你的项目了解更多，所以之前存在的一些不确定性已经不再存在，但某些新的不确定性已经出现。
- en: Think of your plan as a tentative route through a city with streets that are
    constantly under construction. You know where you’d like to go and a few ways
    to get there, but at every intersection there might be a road closed, bad traffic,
    or pavement that’s pocked and crumbling. You’ll have to make decisions as you
    arrive at these obstacles, but for now it’s enough to have a backup plan or two.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的计划想象成穿过一个城市，街道一直在施工的试探性路线。你知道你想去哪里，以及一些到达那里的方法，但在每个路口，可能会有道路关闭、交通拥堵或路面坑洼破碎。你将在到达这些障碍时做出决定，但现在有一个备用计划或两个就足够了。
- en: 6.3.1\. Examples
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 示例
- en: Earlier, I discussed four projects and some specific things that I learned or
    might have learned from them during their prior exploratory phases. I’d like to
    discuss them again now within the context of setting goals and planning. As with
    lessons learned, the processes of setting goals and planning are project specific
    and don’t lend themselves well to concrete if-then statements, so examples can
    be illustrative and invaluable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我讨论了四个项目，以及我在它们之前的探索阶段学到的一些具体事情。现在，我想在设定目标和规划的大背景下再次讨论它们。与学到的经验教训一样，设定目标和规划的过程是项目特定的，并且不适合具体的如果-那么陈述，因此例子可以说明问题，并且非常有价值。
- en: Beer recommendation algorithm
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 啤酒推荐算法
- en: 'The goal of a beer recommendation algorithm is possibly singular: make good
    beer recommendations. But you probably want to be more specific than that. Do
    you want to make a top-10 list of beers for each user, or do you want to have
    the user select a beer or a style before recommending something similar that the
    user would like? This is one case where the job of a data scientist wanders into
    the typical duties of a product designer. Think back to [chapter 2](kindle_split_011_split_000.xhtml#ch02)’s
    discussion of listening to and understanding the customer: what will the customer
    be doing with the product of your project? Let’s assume that—after much deliberation
    and consulting both the project team and some prospective users—a goal should
    be to make a top-10 list of beers that each user should try.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 啤酒推荐算法的目标可能很单一：提供好的啤酒推荐。但你可能希望更加具体。你是想为每个用户制作一个啤酒的前十名列表，还是希望在推荐类似用户可能会喜欢的啤酒之前，让用户先选择一种啤酒或风格？这是一个数据科学家的工作可能会涉及到产品设计师典型职责的案例。回想一下[第2章](kindle_split_011_split_000.xhtml#ch02)中关于倾听和理解客户的讨论：客户将如何使用你项目的产品？让我们假设——经过深思熟虑，并咨询了项目团队和一些潜在用户——目标应该是为每个用户制作一个他们应该尝试的啤酒前十名列表。
- en: 'Let’s go back to the goal-setting filter I proposed: possible, valuable, and
    efficient. Making such a top-10 list is possible; depending on the quality of
    the statistical methods employed, the list could range from good to bad, but regardless
    of that, making a list is certainly possible. The list is also valuable in some
    sense; the project is predicated on the fact that someone somewhere wants to discover
    some new beers that they would like, so let’s assume that it’s valuable; otherwise,
    the project itself is not valuable. The goal seems efficient; it seems 100% possible,
    and it’s difficult to think of a related goal that provides more value for less
    effort. In terms of possibility, value, and efficiency, this goal is straightforward:
    alternatives can be considered, but few arguments can be made against a top-10
    list.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我提出的设定目标过滤器：可能、有价值、有效。制作这样一个前十名列表是可能的；根据所采用的统计方法的质量，列表可能从好到坏不等，但无论如何，制作列表肯定是可能的。从某种意义上说，这个列表也是有价值的；项目基于这样一个事实，即某个地方有人想要发现一些他们可能会喜欢的啤酒，所以让我们假设它是有价值的；否则，项目本身就没有价值。目标看起来很有效；它似乎100%可能，而且很难想到一个相关目标，它以更少的努力提供更多的价值。在可能性、价值和效率方面，这个目标很简单：可以考虑替代方案，但很少有反对前十名列表的论点。
- en: 'That’s the main goal, then: a list of beers that a user will probably like
    if they try them. What about a plan? I’ve talked about a *plan* as a set of contingencies
    intertwined with a set of uncertainties. The uncertainties of building a beer
    recommendation algorithm lie mainly in the statistical methods as well as in the
    data set’s ability to support those methods. Even the best statistical methods
    won’t give good results when the data set is too small or unreliable. Therefore,
    the largest uncertainty in the project is the quality of the output of the algorithm
    itself. You don’t know the probability that a user of the algorithm will like
    a beer that’s recommended.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，主要目标就是：一个用户尝试后可能会喜欢的啤酒列表。关于计划呢？我之前提到过，计划是一系列与一系列不确定性交织在一起的应急措施。构建啤酒推荐算法的不确定性主要在于统计方法以及数据集支持这些方法的能力。即使是最优秀的统计方法，当数据集太小或不可靠时，也不会给出好的结果。因此，项目中的最大不确定性就是算法输出的质量。你不知道算法用户喜欢推荐啤酒的概率。
- en: A good plan would consider that the algorithm might not be as good as you hope
    it will be. If you have a perfect algorithm, all users will love the beers that
    are recommended, but if the algorithm gets some of them wrong, what should you
    do? As a statistician, I would first suggest that you diagnose some of the bad
    recommendations and modify the algorithm to account for these. A few iterations
    of this might solve the problem, or it might not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的计划应该考虑到算法可能不会像你希望的那样好。如果你有一个完美的算法，所有用户都会喜欢推荐的啤酒，但如果算法推荐错了其中一些，你应该怎么办？作为一个统计学家，我首先建议你诊断一些不良推荐并修改算法以考虑这些因素。这样几次迭代可能解决问题，也可能不会。
- en: Another alternative is to develop a product that is error friendly. Depending
    on how the users interact with the algorithm, they may be expecting perfect beer
    recommendations, or they may fully understand that mistakes can be made. A scoring
    system is a possible solution that comes more from a product design perspective
    than an analytic one. If the algorithm makes mistakes, but it gives a recommendation
    score that indicates how reliable the recommendation is (and this score is itself
    reliable), then the users would tolerate some erroneous recommendations in the
    interest of taking a risk for finding a good beer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是开发一个对错误友好的产品。根据用户如何与算法互动，他们可能期望得到完美的啤酒推荐，或者他们可能完全理解错误是可能发生的。评分系统是一个可能的解决方案，它更多地来自产品设计角度而不是分析角度。如果算法出错，但它给出了一个推荐分数，表明推荐的可靠性（并且这个分数本身是可靠的），那么用户可能会容忍一些错误的推荐，以寻找好啤酒的风险。
- en: With those two alternatives, a good plan is forming. If the algorithm produces
    reliable results, then you can trust the top-10 lists, and you can feel assured
    in presenting the lists to users. But if the lists aren’t that reliable, you should
    either revise the statistical methods to make the lists more reliable or generate
    a recommendation reliability score that conveys to users that not every recommendation
    is guaranteed to be enjoyed. Therefore, in the future, there are two possible
    paths and a choice to make. But how will you make that choice? The process of
    making the choice should also be included in the plan, insofar as it is possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有这两个替代方案，一个好的计划正在形成。如果算法产生可靠的结果，那么你可以信任前10名列表，并且可以向用户展示列表时感到自信。但如果列表并不那么可靠，你应该要么修订统计方法使列表更可靠，要么生成一个推荐可靠性分数，向用户传达并非每个推荐都能保证被喜欢。因此，未来有两种可能的路径和选择。但你怎么做出选择？做出选择的过程也应该包含在计划中，只要可能的话。
- en: In this case, in the future, the choice between the two paths depends on the
    reliability of the recommendations generated by the algorithm, so you need a way
    to evaluate the reliability of recommendations, and you need to include this in
    the plan. I’ll discuss these statistical methods in more detail in later chapters,
    but a good way to check the accuracy of predictions from a statistical algorithm
    is to withhold some of the data set from the algorithm while it is training or
    learning and then test the algorithm by checking to see whether it predicts that
    data correctly. In this project, you would probably withhold a few beer recommendations
    for each user during training of the statistical methods and then check to see
    if the beers that were highly rated by a user but withheld during training were
    indeed recommended by the algorithm. Likewise, you can check to see if low-rated
    beers were kept off the recommendation lists. In any case, recommendations by
    the algorithm should corroborate the user ratings that were withheld; if they
    don’t, then the algorithm isn’t that good, and you’ll need to choose one of the
    remedial paths just mentioned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，未来选择这两条路径取决于算法生成的推荐的可靠性，因此你需要一种方法来评估推荐的可靠性，并且你需要将这一点纳入计划。我将在后面的章节中更详细地讨论这些统计方法，但检查统计算法预测准确性的一个好方法是，在算法训练或学习时保留部分数据集，然后通过检查它是否正确预测这些数据来测试算法。在这个项目中，你可能会在训练统计方法时为每个用户保留一些啤酒推荐，然后检查在训练期间被保留但用户高度评价的啤酒是否确实被算法推荐。同样，你可以检查低评价的啤酒是否被排除在推荐列表之外。无论如何，算法的推荐应该与被保留的用户评分相印证；如果不一致，那么算法并不好，你需要选择前面提到的补救措施之一。
- en: That, in aggregate, is a good if basic plan. [Figure 6.2](kindle_split_016_split_003.xhtml#ch06fig02)
    shows the plan in the form of a flow chart. Notice that this plan consists of
    a set of steps that are to be followed, but also there is a major uncertainty
    regarding the algorithm performance. Depending on the outcome of the performance
    evaluation, different paths can be taken. Acknowledging beforehand that this uncertainty
    exists and that it plays a major role in determining what happens next is hugely
    informative during this planning phase, both for you as a data scientist as well
    as the customers who are depending on you. I discuss communicating revised goals
    and plans to your customers in the next section, after I’ve covered the rest of
    the examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这是一个好的基本计划。[图6.2](kindle_split_016_split_003.xhtml#ch06fig02)以流程图的形式展示了该计划。请注意，这个计划包括一系列需要遵循的步骤，但同时也存在一个关于算法性能的主要不确定性。根据性能评估的结果，可以采取不同的路径。在规划阶段提前承认这种不确定性及其在决定下一步发生什么方面发挥的主要作用，对于你作为数据科学家以及依赖你的客户来说，都是非常有信息的。我将在下一节讨论如何向客户传达修订后的目标和计划，在我介绍完其他示例之后。
- en: Figure 6.2\. A flowchart showing a possible plan for developing a beer recommendation
    application
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 一个展示开发啤酒推荐应用可能计划的流程图
- en: '![](Images/06fig02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02.jpg)'
- en: Bioinformatics and gene expression
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生物信息学和基因表达
- en: 'The purpose of this project, in general, was to figure out whether miRs affected
    the expression levels of genes, specifically within the context of stem cell development
    in mice. Possible goals included the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的目的，总的来说，是弄清楚miR是否影响了基因的表达水平，具体是在小鼠干细胞发育的背景下。可能的目标包括以下内容：
- en: Discovery of miR–gene pairs that are most likely to interact with each other
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现最有可能相互作用的miR-基因对
- en: Discovery of miRs that regulate stem cell development
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现调控干细胞发育的miR
- en: Discovery of pathways (sequences of causes and effects) among miRs and genes
    affecting stem cell development and regulation
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发现影响干细胞发育和调控的miR和基因之间的途径（原因和效果序列）
- en: Goal 1 included a statistical analysis of specific correlations between miRs
    and genes within the time-series data that I already had. There were no guarantees
    of how reliable the results would be, but the analysis was certainly possible.
    Likewise, goal 2 required a statistical analysis of the expression levels of miRs
    throughout the stages of stem cell development. Again, this was entirely possible,
    though it wasn’t certain that the results of the statistical methods would be
    correct in terms of functional biology. Goal 3 was a bit more complicated. Pathways
    involve more than two miRs or genes, and so discovering a single pathway required
    proving multiple correlations among the three-plus constituents, plus the added
    work of showing that the multiple correlations were connected by more than coincidence.
    A biological scientific journal would expect substantial evidence of the connections
    between the individual parts before it would publish my article on the discovery
    of pathways. Goal 3, though possible, was far more complicated and harder to justify
    than the other two possible goals. Also, the work required to analyze a pathway
    statistically is greater than a simple miR–gene interaction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目标1包括对miR和基因在时间序列数据中的特定相关性进行统计分析。无法保证结果有多可靠，但分析肯定是可能的。同样，目标2需要分析miR在整个干细胞发育阶段的表达水平。这同样是完全可能的，尽管在功能生物学方面，统计方法的结果是否正确并不确定。目标3要复杂一些。途径涉及不止两个miR或基因，因此发现单一途径需要证明三个以上组成部分之间的多个相关性，以及证明这些多个相关性不仅仅是通过巧合连接起来的额外工作。生物科学期刊在发表我关于发现途径的文章之前，会期望有大量关于各个部分之间联系的证据。尽管目标3是可能的，但它比其他两个可能的目标要复杂得多，也难以证明。此外，分析途径所需的统计工作比简单的miR-基因相互作用要多。
- en: The value of each of these goals was somewhat uncertain. Definitely, discoveries
    of new miR–gene interactions, miRs that regulate stem cell development, or stem
    cell pathways are all valuable, but the value of each would depend on the genes
    involved and how strongly I could justify the results. If I discovered a novel
    interaction or pathway that could be related, convincingly, to a popular biological
    phenomenon such as genetic disease or sexual differentiation, then I would have
    a much better chance of publishing the research in a high-impact journal. But
    all three goals had approximately the same chance of giving such valuable results,
    so I considered the value of each to be equal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标中每一个的价值都有些不确定。毫无疑问，发现新的miR-基因相互作用、调控干细胞发育的miR或干细胞通路都是很有价值的，但每个目标的价值将取决于涉及的基因以及我能够多么有力地证明结果。如果我发现了一个可以令人信服地与流行生物学现象（如遗传疾病或性别分化）相关的新相互作用或通路，那么我在高影响力期刊上发表这项研究的机会就会大得多。但所有三个目标实现这样有价值结果的可能性大致相同，因此我认为每个目标的价值是相等的。
- en: While evaluating the efficiency of the goals, it was immediately obvious that
    goal 3, being more complicated, would require vastly more work than the others.
    Goals 1 and 2 demanded roughly the same amount of work and were also roughly equal
    in their chance of giving meaningful results. The only tiebreaker between those
    two goals was that determining specific miRs that interacted with specific genes
    seemed to be slightly more interesting to the scientific community than discovering
    stem cells that could only generally be associated with stem cell development.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估目标效率时，很明显，目标3由于更加复杂，将需要比其他目标多得多的工作。目标1和2需要大致相同的工作量，并且实现有意义结果的机会也大致相等。这两个目标之间的唯一决定性因素是，确定与特定基因相互作用的特定miR似乎比发现只能与干细胞发育一般相关联的干细胞对科学界来说更有趣。
- en: So with goal 1 being slightly more valuable and efficient than goal 2, I chose
    goal 1 as my main goal, with goal 2 a close second and goal 3 a distant third,
    to be done only if I had plenty of extra time after achieving the first two.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于目标1比目标2稍微更有价值和效率，我选择了目标1作为我的主要目标，目标2紧随其后，目标3则排在第三位，只有在完成前两个目标后有大量额外时间时才会进行。
- en: Given these goals, the plan would necessarily include developing statistical
    methods that aimed to discover the miR–gene pairs of goal 1 while possibly taking
    into account the regulating miRs of goal 2\. The correlations discovered in trying
    to achieve those two goals might then be assembled in such a way as to construct
    plausible pathways as in goal 3.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些目标，计划必然包括开发旨在发现目标1的miR-基因对的统计方法，同时可能考虑到目标2中的调控miR。在尝试实现这两个目标的过程中发现的关联可以组装起来，以构建类似于目标3的合理通路。
- en: 'A flow chart describing my plan appears in [figure 6.3](kindle_split_016_split_003.xhtml#ch06fig03).
    As you can see, this plan is fairly straightforward. Scientific research tends
    toward this structure: you work on improving methods and results until you have
    a result that the scientific community will appreciate, at which point you write
    an article about your research and then submit it for publication. This contrasts
    with typical business projects, in which stricter constraints on time usually,
    to some extent, require data scientists to compromise the quality of results in
    order to meet a deadline. On the other hand, although academic researchers don’t
    usually have a strong time constraint other than conference application deadlines,
    they’re usually held to a higher standard of statistical rigor and significance
    of discovery than in industry. An academic data scientist’s plan will probably
    look different from the plan of a data scientist in a comparable private industry,
    which is another factor in settling on a specific plan for your particular project.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 描述我的计划的流程图出现在[图6.3](kindle_split_016_split_003.xhtml#ch06fig03)中。正如您所看到的，这个计划相当直接。科学研究往往趋向于这种结构：你致力于改进方法和结果，直到你有一个科学界会欣赏的结果，然后你写一篇关于你的研究的文章，然后提交给期刊发表。这与典型的商业项目形成对比，在商业项目中，通常对时间有更严格的限制，这在某种程度上要求数据科学家为了满足截止日期而妥协结果的质量。另一方面，尽管学术研究人员通常没有强烈的时间限制，除了会议申请截止日期外，他们通常被要求比工业界更高的统计严谨性和发现的重要性标准。一个学术数据科学家的计划可能看起来与一个在可比私营行业中的数据科学家的计划不同，这也是确定特定项目具体计划的因素之一。
- en: Figure 6.3\. A flowchart showing the basic plan for my gene interaction project
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3. 显示我的基因相互作用项目基本计划的流程图
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig03_alt.jpg)'
- en: Top performances in track and field
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 田径和田径的顶尖表现
- en: In [chapter 4](kindle_split_013_split_000.xhtml#ch04), I discussed one of my
    projects in which I analyzed lists of best-ever performances in the various events
    of track and field. As I mentioned earlier in this chapter, two of the main uncertainties
    remaining in the project concerned the quality and completeness of the data as
    related to the power of the statistical methods I applied to them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](kindle_split_013_split_000.xhtml#ch04)中，我讨论了我的一个项目，该项目分析了田径各种项目的最佳表现列表。正如我在本章前面提到的，该项目中剩余的两个主要不确定性涉及数据的质和完整性，以及我应用于它们的统计方法的有效性。
- en: 'The first uncertainty could be stated: is there enough data? Because I had
    lists of the best performances by elite athletes and not complete lists of all
    performances ever, I would be looking only at data from the tail of the statistical
    distributions, which makes estimating parameters even more difficult. To determine
    whether there is enough data—something I’ll cover in more depth in later chapters—I
    check to see if the estimation variance of the estimated parameters is small enough,
    and I also check the estimation variance of predictions generated by the model
    to make sure that it’s not making predictions that vary wildly with only small
    changes of the inputs. Most important, I wouldn’t know if I had enough data until
    I wrote the code that applies the statistical model to the data and generates
    estimates. If I didn’t have enough data, I would have to consider purchasing more
    data from another website (though I’m not sure how much more data it would have,
    if any) or, possibly, making the model simpler so that it requires less data.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不确定性可以这样表述：是否有足够的数据？因为我只有精英运动员的最佳表现列表，而没有所有表现的完整列表，所以我只能查看统计分布尾部的数据，这使得估计参数变得更加困难。为了确定是否有足够的数据——这一点我将在后面的章节中更深入地讨论——我会检查估计参数的估计方差是否足够小，同时也会检查模型生成的预测的估计方差，以确保它不会因为输入的微小变化而做出剧烈变化的预测。最重要的是，直到我编写将统计模型应用于数据并生成估计值的代码，我才知道是否有足够的数据。如果没有足够的数据，我可能需要考虑从另一个网站购买更多数据（尽管我不确定它会有多少数据，如果有）或者，可能的话，简化模型以便它需要更少的数据。
- en: The second main uncertainty concerned the statistical distribution I would use.
    I wanted to use a log-normal distribution within the statistical model, but before
    writing the statistical code, I couldn’t know for sure whether the distribution
    was appropriate. During the exploratory phase described in [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    I did generate some histograms of the data, and the histograms seemed to follow
    the tail of a bell curve like the normal curve, but it wasn’t until later that
    I wrote the code that estimated optimal parameters for such a curve and compared
    them to the data, so, for our purposes in this section, that uncertainty still
    exists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要不确定性涉及我将使用的统计分布。我想在统计模型中使用对数正态分布，但在编写统计代码之前，我无法确定这种分布是否合适。在[第5章](kindle_split_014_split_000.xhtml#ch05)中描述的探索阶段，我确实生成了一些数据的直方图，这些直方图似乎遵循类似于正态曲线的钟形曲线的尾部，但直到我后来编写了估计此类曲线最佳参数的代码并将其与数据比较，这个不确定性才得到解决。因此，在本节的目的上，这个不确定性仍然存在。
- en: 'Finally, there’s the uncertainty that’s ever present in statistical challenges:
    will the results be good enough? There’s almost never a guarantee that you’ll
    get good results, and this project was no exception. For academic purposes—and
    this was an academic project I intended to publish in a scientific journal—”good
    enough” usually implies “better than the next guy.” By that I mean that I would
    have to demonstrate that the scoring system I developed was more reliable, in
    some sense, than other existing methods that were designed for the same purpose.
    My principal competitor was the set of IAAF Scoring Tables of Athletics. I chose
    to compare predictions that are implied by their scoring tables and my scoring
    tables to see which ones predicted better. If I fell short, then I pretty much
    had nothing I could publish. I would have to improve the model and the predictions
    or—keep in mind this is the shady, no-good, Evil Statistician way of doing it—I’d
    change the way I compare the two scoring systems to work in my favor. I mention
    the second, very, very bad way of improving results not because I would suggest
    it, but because people do that, and anyone who is reading a comparison of statistical
    methods should keep that in mind!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有统计挑战中始终存在的确定性：结果是否足够好？几乎从未有保证你会得到好的结果，这个项目也不例外。出于学术目的——这是一个我打算在科学期刊上发表的学术项目——“足够好”通常意味着“比其他人更好”。我的主要竞争对手是国际田联的田径评分表。我选择比较他们评分表所隐含的预测和我的评分表，看看哪个预测得更准确。如果我未能达到预期，那么我几乎没有什么可以发表的。我必须改进模型和预测，或者——记住，这是阴暗的、无耻的、邪恶的统计学家做法——我改变比较两个评分系统的方式，使其对我有利。我提到第二种非常、非常糟糕的改进结果的方法，并不是因为我建议这样做，而是因为人们确实会这样做，任何阅读统计方法比较的人都应该记住这一点！
- en: Given these three uncertainties, I made the plan that appears in [figure 6.4](kindle_split_016_split_003.xhtml#ch06fig04).
    There are two checkpoints—data fitting the distribution and then the quality of
    the predictions—and if I didn’t get to the checkpoints without problems, I had
    one or two possible solutions for each. At the distribution checkpoint, if something
    looked wrong, I would find a better distribution, and at the quality of predictions
    checkpoint I could optionally get more data or improve the model, whichever seemed
    more reasonable to me at the time. If I had wanted to write an even more thorough
    plan, I could include specific criteria that would convince me to take the data
    route over the model quality route, or vice versa.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这三个不确定性，我制定了[图6.4](kindle_split_016_split_003.xhtml#ch06fig04)中出现的计划。有两个检查点——数据是否符合分布以及预测的质量——如果我没有遇到问题就到达了检查点，我针对每个检查点有一到两个可能的解决方案。在分布检查点，如果看起来有问题，我会找到一个更好的分布，而在预测质量检查点，我可以选择获取更多数据或改进模型，这取决于当时我认为哪个更合理。如果我想写一个更详尽的计划，我可以包括一些具体的标准，这些标准将使我决定选择数据路线而不是模型质量路线，或者反之亦然。
- en: Figure 6.4\. A flowchart showing the basic plan for my project involving the
    analysis of track and field performances
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 展示我的项目基本计划的流程图，该项目涉及对田径表现的分析
- en: '![](Images/06fig04_alt.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig04_alt.jpg)'
- en: By now you’ve probably noticed that the primary sources of uncertainty are closely
    related to data and statistics. This is usually true, and it’s true for me because
    I’m more of a statistician than a software developer, and wherever there is a
    statistical model, uncertainty is guaranteed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到，不确定性的主要来源与数据和统计学密切相关。这通常是真的，对我而言也是如此，因为我更倾向于统计学家而非软件开发者，只要有统计模型存在，不确定性就不可避免。
- en: Enron email analysis
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安然电子邮件分析
- en: In [chapter 5](kindle_split_014_split_000.xhtml#ch05), I introduced a project
    that was intended to find and analyze criminal, suspicious, or negligent behavior
    within the public set of Enron emails and to apply concepts from the field of
    social network analysis to describe them. Nearly everything about the project
    was an uncertainty. Not only did we have the data challenges I mentioned near
    the beginning of this chapter, but we also did not know of any specific examples
    of criminal or suspicious behavior within the data set itself. We mostly assumed
    they were there somewhere—a lot of bad stuff went on at Enron—but with more than
    100,000 emails, it would be hard to find them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_014_split_000.xhtml#ch05)中，我介绍了一个旨在寻找和分析公共恩隆电子邮件集中犯罪、可疑或疏忽行为的计划，并应用来自社会网络分析领域的概念来描述它们。关于这个项目的几乎所有事情都充满了不确定性。我们不仅面临我在本章开头提到的数据挑战，而且我们也不知道数据集中有任何具体的犯罪或可疑行为例子。我们大多数情况下假设它们确实存在——在恩隆发生了很多坏事——但是面对超过10万封电子邮件，找到它们将非常困难。
- en: Because we had plenty of news stories and research about the Enron scandal,
    and we had on hand a few experts in the area of corporate fraud, we thought it
    might be a reasonable idea to develop a few coarse statistical analyses to filter
    the data, after which we could read through the top-scoring 100 emails or so,
    looking for good examples of suspicious behavior. If we did this a few times,
    it might be more efficient than trying to read all the emails until we found some
    that were suspicious.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有很多关于恩隆丑闻的新闻报道和研究，并且我们有几位在商业欺诈领域的专家，我们认为开发一些粗略的统计分析来过滤数据可能是一个合理的想法，之后我们可以阅读得分最高的100封左右的电子邮件，寻找可疑行为的良好例子。如果我们这样做几次，可能比试图阅读所有电子邮件直到找到可疑的邮件更有效率。
- en: Another suggestion was to build a full-fledged statistical model of social network
    behavior and try to use it to find suspicious behavior. This, to me, seemed like
    putting the cart before the horse. Or at the least it would leave us open to some
    serious confirmation bias in the event that we happened to find some interesting
    emails—did the methods work, or did we stumble into the results we were looking
    for?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个建议是构建一个完整的社会网络行为统计模型，并尝试用它来寻找可疑行为。对我来说，这似乎是本末倒置。或者至少，如果我们偶然发现了一些有趣的电子邮件，这会让我们容易受到一些严重的确认偏差的影响——方法是有效的，还是我们偶然找到了我们寻找的结果？
- en: Because almost nothing was concrete or guaranteed about this project, our plan
    would be more concerned with time and resource management than with a specific
    set of steps. Given that we had a deadline, even though it was a fuzzy one, we
    had to keep in mind that we needed to produce *some* results by the end of the
    project. We couldn’t use the academic strategy of working until there are good
    results and then submitting them, so we used a strategy that some people call
    *time boxing*. It’s not as exciting as it sounds—sorry. It’s placing a somewhat-arbitrary
    time limit on an open-ended task to remind yourself that you have to move on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目几乎没有什么具体或保证的事情，我们的计划将更多地关注时间和资源管理，而不是具体的步骤。鉴于我们有截止日期，即使它是一个模糊的截止日期，我们必须记住，我们需要在项目结束时产生*一些*结果。我们不能使用学术策略，即一直工作直到有好的结果然后提交，所以我们使用了一些人称之为*时间盒*的策略。它并不像听起来那么令人兴奋——抱歉。这是对一个开放性任务设定一个相对随意的截止时间，以提醒自己你必须继续前进。
- en: For a 10-day project time line, our loosely defined plan looked something like
    the flow chart that appears in [figure 6.5](kindle_split_016_split_003.xhtml#ch06fig05).
    It’s definitely a fuzzy plan, but at least it’s something to start from, and it
    makes sure the whole team knows how you expect the time line to work out, even
    if it doesn’t work out exactly that way. Even the plan itself can change, given
    new information or other changes to the goals, priorities, or other aspects of
    the situation. The most notable characteristic of this example, when compared
    to the others, is that it shows how to create a schedule even in the face of near-absolute
    uncertainty, wide-open goals, and a deadline.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于10天的项目时间表，我们松散的计划看起来就像[图6.5](kindle_split_016_split_003.xhtml#ch06fig05)中出现的流程图。这确实是一个模糊的计划，但至少它是一个起点，并确保整个团队知道你期望时间表如何运作，即使它不会完全按照这种方式运作。即使计划本身也可能随着新信息或其他对目标、优先级或情况其他方面的变化而改变。与其他例子相比，这个例子最显著的特点是它展示了即使在几乎绝对的未知、开放的目标和截止日期的情况下，如何创建一个时间表。
- en: Figure 6.5\. A flowchart showing the basic plan for the Enron project
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5. 展示Enron项目基本计划的流程图
- en: '![](Images/06fig05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig05.jpg)'
- en: 6.4\. Communicating new goals
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4. 传达新的目标
- en: Plans and goals can change at any moment, given new information or new constraints
    or for any other reason. You must communicate significant changes to everyone
    involved with the project, including the customer. The project’s customer obviously
    has a vested interest in what the final product of the project should be—otherwise
    the project wouldn’t exist—so the customer should be made aware of any changes
    to the goals. Because most customers like to be kept informed, it’s often advisable
    to inform them of your plans, new or old, for how you will achieve those goals.
    A customer might also be interested in a progress report including what preliminary
    results you have so far and how you got them, but these are of the lowest priority.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 计划和目标可能会在任何时候因新的信息、新的限制或其他任何原因而改变。你必须向所有参与项目的人传达重大变化，包括客户。显然，项目的客户对项目的最终产品有直接利益——否则项目就不会存在——因此客户应该了解任何目标的变化。由于大多数客户喜欢保持知情，因此通常建议你通知他们你如何实现这些目标的计划，无论是新的还是旧的。客户也可能对进度报告感兴趣，包括迄今为止的初步结果以及你是如何得到它们的，但这些是最低优先级的。
- en: I mention priority in this context because what’s often interesting or important
    to a data scientist isn’t interesting or important to a customer who is not a
    data scientist. For example, I’ve been to many talks at biological conferences
    in which the presenter seems more interested in telling the story of how they
    got their results than in presenting the results themselves and their impact.
    For a data scientist, the story of the project—typically including every twist,
    turn, and obstacle—represents the intrigue of the work that has been done, the
    difficulty, and the ultimate victory. But non–data scientists are most interested
    in whether you got good results and whether they can trust that your good results
    weren’t a fluke. Explaining that data wrangling took a full week, for example,
    serves only to say, “My job can be tough at times,” and might justify a missed
    deadline but little else.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提到优先级，因为对数据科学家来说有趣或重要的事情，对非数据科学家的客户来说可能并不有趣或不重要。例如，我参加过许多生物会议上的演讲，演讲者似乎更感兴趣于讲述他们如何得到结果的故事，而不是展示结果本身及其影响。对数据科学家来说，项目的整个故事——通常包括每一个转折、曲折和障碍——代表了已完成工作的吸引力、难度和最终胜利。但非数据科学家最感兴趣的是你是否得到了好的结果，以及他们是否可以信任你的好结果不是偶然的。例如，解释数据整理花了整整一周时间，这仅仅是为了说，“我的工作有时可能很艰难”，并且可能为错过截止日期提供理由，但除此之外几乎没有其他作用。
- en: 'Focus on what the customer cares about: progress has been made, and the current
    expected, achievable goals are X, Y, and Z. They may have questions, which is
    great, and they may be interested in hearing about all aspects of your project,
    but in my experience most are not. My one and only must-have conclusion for a
    meeting with the customer at this stage is that I communicate clearly what the
    new goals are and that they approve them. Everything else is optional.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于客户关心的问题：已经取得的进展，以及当前预期可实现的X、Y和Z目标。他们可能会有问题，这很好，他们可能对了解你项目的各个方面感兴趣，但根据我的经验，大多数人并不感兴趣。在这个阶段与客户会面时，我唯一必须得出的结论是，我清楚地传达了新的目标，并且他们批准了这些目标。其他一切都是可选的。
- en: You may consider communicating your basic plan to the customer, particularly
    if you’re using any of their resources to complete the project. They may have
    suggestions, advice, or other domain knowledge that you haven’t experienced yet.
    If their resources are involved, such as databases, computers, other employees,
    then they will certainly be interested in hearing how and how much you’ll be making
    use of them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑向客户传达你的基本计划，尤其是如果你在完成项目时使用了他们的任何资源。他们可能会有建议、建议或其他领域知识，这些你还没有经历过。如果他们的资源涉及其中，例如数据库、计算机、其他员工，那么他们当然会对了解你将如何以及将如何充分利用它们感兴趣。
- en: 'Finally, as I mentioned, preliminary results and the story of how you got them
    are of the lowest priority. In my experience, sharing these can be helpful, but
    only for a few reasons, such as when doing so serves the following purposes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我提到的，初步结果以及你是如何得到它们的故事是最低优先级的。根据我的经验，分享这些信息可能会有所帮助，但只有出于以下原因：
- en: To bolster the customer’s confidence in the case of promising preliminary results
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了增强客户对有希望初步结果的信心
- en: To gain the customer’s trust by showing that your methods are sound
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过展示你的方法是可靠的来赢得客户的信任
- en: To make the customer feel like a data scientist on the team in the case of a
    good story that the customer can understand
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个好的故事中，让客户感觉像团队中的数据科学家，这个故事客户能够理解
- en: 'All of these can be desirable under various circumstances, but in communication
    with the customer it’s best to ensure that you don’t lose sight of the main intersection
    between your project role and theirs: the goals.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些在某种情况下可能是可取的，但在与客户的沟通中，最好确保你不失去你项目角色和他们的主要交叉点：目标。
- en: Exercises
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Continuing with the Filthy Money Forecasting personal finance app scenario
    first described in [chapter 2](kindle_split_011_split_000.xhtml#ch02) and relating
    to previous chapters’ exercises, try these:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用在[第2章](kindle_split_011_split_000.xhtml#ch02)中首次描述的 Filthy Money Forecasting
    个人理财应用场景，并关联到前几章的练习，尝试以下内容：
- en: '**1\.**'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.'
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose that your preliminary analyses and descriptive statistics from the previous
    chapter lead you to believe that you can probably generate some reliable forecasts
    for active users with financial accounts that have many transactions, but you
    don’t think you can do the same for users and accounts with relatively few transactions.
    Translate this finding into the “What is possible? What is valuable? What is efficient?”
    framework for adjusting goals.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你从上一章的初步分析和描述性统计中得出结论，认为你可能为拥有大量交易的财务账户的活跃用户生成一些可靠的预测，但你认为对于交易相对较少的用户和账户则不能做到同样的事情。将这一发现转化为“可能做什么？什么是宝贵的？什么是有效的？”的调整目标框架。
- en: '**2\.**'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.'
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on your answer to the previous question, describe a general plan for generating
    forecasts within the app.
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据你对上一个问题的回答，描述一个在应用内生成预测的一般计划。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: An explicit and formal evaluation phase such as I suggest here can help you
    organize your progress, your goals, your plan, and your knowledge of the project.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我建议的明确和正式的评估阶段可以帮助你组织你的进度、目标、计划和项目知识。
- en: Before proceeding, ask, “What have I learned?”
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续之前，问自己，“我学到了什么？”
- en: Adjust expectations and goals based on preliminary findings.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据初步发现调整期望和目标。
- en: Make a plan based on any new information and new goals, while taking into account
    the inevitable uncertainties.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据任何新的信息和新的目标制定计划，同时考虑到不可避免的不确定性。
- en: Communicate to the customer the new goals, plans, and progress.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户传达新的目标、计划和进度。
- en: 'Chapter 7\. Statistics and modeling: concepts and foundations'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章. 统计与建模：概念与基础
- en: '*This chapter covers*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Statistical modeling as a core concept in data science
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计建模作为数据科学的核心概念
- en: Mathematics as a foundation of statistics
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学作为统计的基础
- en: Other useful statistical methods such as clustering and machine learning
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他有用的统计方法，如聚类和机器学习
- en: '[Figure 7.1](kindle_split_017_split_000.xhtml#ch07fig01) shows where we are
    in the data science process: statistical analysis of data. Statistical methods
    are often considered as nearly one half, or at least one third, of the skills
    and knowledge needed for doing good data science. The other large piece is software
    development and/or application, and the remaining, smaller piece is subject matter
    or domain expertise. Statistical theory and methods are hugely important to data
    science, but I’ve said relatively little about them so far in this book. In this
    chapter, I attempt to present a grand overview.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](kindle_split_017_split_000.xhtml#ch07fig01) 展示了我们在数据科学过程中的位置：数据统计分析。统计方法通常被认为几乎占了一半，或者至少占三分之一的数据科学所需技能和知识。另一大部分是软件开发和/或应用，剩下的小部分是主题或领域专业知识。统计理论和方法是数据科学中极其重要的，但我在本书中至今对此说的相对较少。在本章中，我试图提供一个全面的概述。'
- en: 'Figure 7.1\. An important aspect of the build phase of the data science process:
    statistical data analysis'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1. 数据科学过程构建阶段的一个重要方面：统计数据分析
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: Statistics is a big field. I wouldn’t presume to be able to cover all of statistics
    in one book, let alone one chapter. Hundreds of textbooks, thousands of journal
    articles, and even more web pages have been written on the subject, so you’ll
    find plenty of references if you have specific questions. What I haven’t yet seen
    in another written work, however, is a conceptual description of statistics and
    its most important ideas that provides a solid theoretical foundation for someone
    aspiring to data science who doesn’t have formal statistical training or education.
    In this chapter I’ll introduce the field of statistics as a collection of related
    tools, each with pros and cons, for accomplishing the goals of data science. The
    aim of such an introduction is to enable you to begin to consider the range of
    possible statistical methods that might be applied in a project, to the point
    where you’re able to feel comfortable seeking more specific information from more
    detailed, technical references.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学是一个庞大的领域。我不敢奢望在一本书中涵盖所有的统计学，更不用说在一章中。关于这个主题已经写了几百本教科书，几千篇期刊文章，甚至更多的网页。所以如果你有具体问题，你会找到很多参考资料。然而，我尚未在其他书面作品中看到对统计学及其最重要的概念的概述，为那些没有正式统计学培训或教育背景的数据科学爱好者提供了一个坚实的理论基础。在本章中，我将介绍统计学领域作为一个相关工具的集合，每个工具都有其优缺点，以实现数据科学的目标。这种介绍的目的是让你开始考虑在项目中可能应用的统计方法的范围，直到你能够感到舒适地从更详细、更技术性的参考资料中寻求更具体的信息。
- en: 7.1\. How I think about statistics
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 我对统计学的思考
- en: You may already feel comfortable with statistics and technical references describing
    how to apply its complex techniques, and in that case this chapter may seem unnecessary.
    But unless you’ve had much formal statistical education, there are likely many
    areas that you haven’t yet seen. Or you may not be familiar with how various statistical
    areas are related to each other. I do feel that even experienced data scientists
    can benefit from thinking about the field of statistics as a whole, how its components
    relate to each other, and how the methods of statistics are distinct from both
    the software that performs them and the data upon which they’re used. I don’t
    intend to present a definitive description of any of these concepts, but I do
    intend to initiate a discussion of these concepts, how they relate to each other,
    and how each can be important.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经对描述如何应用其复杂技术的统计学和技术参考感到很自在，在这种情况下，这一章可能看起来是不必要的。但除非你接受过大量的正式统计学教育，否则你很可能还有许多尚未见过的领域。或者你可能不熟悉各个统计学领域之间是如何相互关联的。我确实认为，即使是经验丰富的数据科学家，从整体上思考统计学领域，了解其组成部分之间的关系，以及统计学方法与执行它们的软件以及它们所使用的数据之间的区别，也能从中受益。我不打算提供任何这些概念的最终描述，但我确实打算开始对这些概念、它们之间的关系以及每个概念的重要性进行讨论。
- en: Throughout this chapter, I’ll continue to emphasize the distinctness of the
    methods, the software, and the data. Using a machine learning library isn’t the
    same thing as applying a type of machine learning to your data set. One is a tool;
    the other is an action. Likewise, a database isn’t the same thing as the data
    contained within it, no matter how intertwined they may be. Therefore, because
    I want to focus on statistical methods in this chapter, I’ll often mention software
    and data only abstractly, though I will refer to concrete examples at times when
    it seems appropriate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将继续强调方法、软件和数据之间的独特性。使用机器学习库并不等同于将一种机器学习类型应用于你的数据集。一个是工具；另一个是行动。同样，数据库并不等同于其中包含的数据，无论它们可能多么交织在一起。因此，因为我想要在本章中专注于统计学方法，所以我通常会抽象地提及软件和数据，尽管在适当的时候我会引用具体的例子。
- en: Finally, before we dive in, I’d like to say that I think and write conceptually
    about the world of statistical methods. I imagine scenarios in which I’m grabbing
    data with my hands and stuffing it into the pipes of a machine that will somehow
    learn about this data, and my job is to tweak the pipes and the dials of the machine
    so that good, useful information comes out the other end. Or in the case of classifying
    data points, I picture myself drawing a line with chalk that best divides the
    red points from the blue points and then considering how I might draw another
    line to correct for some of the red points that fell on the blue side and vice
    versa. I think in that way, and I’m warning you in case you were expecting a chapter
    filled with differential equations and correlation coefficients. To the contrary,
    it’s going to be a big-picture chapter with lots of conceptual and imaginative
    passages. I like thinking about this stuff, so I hope I can present it in a way
    that’s fun for you, too.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们深入探讨之前，我想说的是，我认为并从概念上思考统计方法的世界。我设想了一些场景，其中我用手抓取数据，将其塞入某种方式能够学习这些数据的机器的管道中，我的工作是调整管道和机器的旋钮，以便从另一端输出好的、有用的信息。或者，在分类数据点的情况下，我想象自己用粉笔画一条线，最好地将红色点与蓝色点分开，然后考虑如何画另一条线来纠正一些落在蓝色一侧的红色点，反之亦然。我就是这样思考的，我在这里提醒你，以防你期待的是一本充满微分方程和相关性系数的章节。相反，这将是一个宏观的章节，充满了许多概念性和富有想象力的段落。我喜欢思考这些事情，所以我希望我能以一种对你来说也很有趣的方式呈现它们。
- en: '7.2\. Statistics: the field as it relates to data science'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 统计学：与数据科学相关的领域
- en: '*The Oxford Dictionary of Statistical Terms* (OUP, 2006) describes statistics
    as “the study of the collection, analysis, interpretation, presentation, and organization
    of data.” For our purposes in this chapter, we’re going to skip the collection,
    presentation, and organization and focus on the analysis and interpretation. I’ll
    assume that you’ve already collected and organized your data, as described in
    previous chapters, and I’ll discuss presentation in a later chapter.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*《牛津统计学词汇词典》*（OUP，2006年）将统计学描述为“对数据的收集、分析、解释、展示和组织的研究。”在本章的目的上，我们将跳过收集、展示和组织，而专注于分析和解释。我假设你已经根据前几章的描述收集并组织好了你的数据，我将在稍后的章节中讨论展示。'
- en: Analysis and interpretation, from my perspective, are the scientific aspects
    of statistics. They’re concerned with wringing knowledge from data and recognizing
    whether there’s enough evidence to support a given hypothesis or putative conclusion.
    In the face of much uncertainty—which is always the case for highly statistical
    projects in data science—good analysis and interpretation are important, and so
    I’d like to dedicate most of this chapter to discussing some of the methods by
    which statistics helps to achieve them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，分析和解释是统计学的科学方面。它们关注从数据中提取知识，并识别是否有足够的证据来支持一个给定假设或推论。面对许多不确定性——这在数据科学中高度统计的项目中总是如此——良好的分析和解释非常重要，因此我愿意在本章的大部分内容中讨论一些统计学帮助实现这些目标的方法。
- en: 7.2.1\. What statistics is
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 统计学是什么
- en: Statistics lies between the theoretical field of mathematics and the reality
    of observable data. Mathematics, surprisingly to most people, has little if anything
    to do with data. Despite this, it has much to do with data science. Data scientists
    need mathematics in order to do meaningful statistical analyses, so I’d be remiss
    if I didn’t begin a discussion about statistics in data science with a discussion
    of mathematics. In the next section, I’ll write about mathematics, the main concepts
    it depends on, and how it’s useful in real-world applications.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学位于数学理论领域和可观察数据现实之间。出人意料的是，对大多数人来说，数学与数据几乎没有关系。尽管如此，它与数据科学有着密切的联系。数据科学家需要数学来进行有意义的统计分析，因此，如果我不开始讨论数据科学中的统计学，我将感到疏忽。在下一节中，我将撰写关于数学的内容，它所依赖的主要概念，以及它在现实世界中的应用中的有用性。
- en: On the one side of statistics is mathematics, and on the other side is data.
    Mathematics—particularly, *applied mathematics*—provides statistics with a set
    of tools that enables the analysis and interpretation that are the main focus
    of this chapter. In addition to mathematics, statistics possesses its own set
    of techniques that are primarily data centric.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学的一边是数学，另一边是数据。数学——尤其是*应用数学*——为统计学提供了一套工具，这些工具使得分析和解释成为本章的主要焦点。除了数学之外，统计学还拥有自己的一套以数据为中心的技术。
- en: Descriptive statistics, introduced in [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    is a generally intuitive or simple kind of statistics that can provide a good
    overview of the data without being overly complex or difficult to understand.
    Descriptive statistics usually stays close to the data, in a sense.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计，如第5章[第5章](kindle_split_014_split_000.xhtml#ch05)中所述，是一种通常直观或简单的统计方法，可以在不过度复杂或难以理解的情况下提供数据的良好概述。在某种意义上，描述性统计通常紧贴数据。
- en: Inferential statistics is inherently one or more steps removed from the data.
    *Inference* is the process of estimating unknown quantities based on measurable,
    related quantities. Typically, inferential statistics involves a statistical model
    that defines quantities, measurable and unmeasurable, and their relationships
    to each other. Methods from inferential statistics can range from quite simple
    to wildly complex, varying also in their precision, abstractness, and interpretability.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 推断统计本质上与数据有一或多个步骤的距离。*推断*是根据可测量的、相关的数量估计未知数量的过程。通常，推断统计涉及一个统计模型，该模型定义了数量，包括可测量和不可测量的，以及它们之间的关系。推断统计的方法可以从非常简单到极其复杂，其精确度、抽象性和可解释性也各不相同。
- en: '*Statistical modeling* is the general practice of describing a system using
    statistical constructs and then using that model to aid in analysis and interpretation
    of data related to the system. Both descriptive and inferential statistics rely
    on statistical models, but in some cases an explicit construction and interpretation
    of the model itself plays a secondary role. With statistical modeling, the primary
    focus is on understanding the model and the underlying system that it describes.
    Mathematical modeling is a related concept that places more emphasis on model
    construction and interpretation than on its relationship to data. Statistical
    modeling focuses on the model’s relationship to data.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*统计建模*是使用统计结构描述系统的一般实践，然后使用该模型来帮助分析和解释与系统相关的数据。描述性和推断性统计都依赖于统计模型，但在某些情况下，对模型本身的明确构建和解释起着次要作用。在统计建模中，主要关注的是理解模型及其所描述的底层系统。数学建模是一个相关的概念，它更强调模型构建和解释，而不是它与数据的关系。统计建模侧重于模型与数据的关系。'
- en: Farthest from the raw data is a set of statistical techniques that are often
    called, for better or worse, black box methods. The term *black box* refers to
    the idea that some statistical methods have so many moving pieces with complex
    relationships to each other that it would be nearly impossible to dissect the
    method itself because it was applied to specific data within a specific context.
    Many methods from machine learning and artificial intelligence fit this description.
    If you attempt to classify individuals appearing in a data set into one of several
    categories, and you apply a machine learning technique such as a random forest
    or neural network, it will often be difficult to say, after the fact, why a certain
    individual was classified in a certain way. Data goes into the black box, a classification
    comes out, and you’re not usually certain what exactly happened in between. I’ll
    discuss this concept more later in this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最远离原始数据的是一套通常被称为（无论好坏）黑盒方法的统计技术。*黑盒*这一术语指的是某些统计方法具有许多相互之间关系复杂的移动部件，以至于在特定数据、特定背景下应用该方法时，几乎不可能剖析该方法本身。许多来自机器学习和人工智能的方法都符合这一描述。如果你试图将数据集中出现的个体分类到几个类别之一，并且应用了随机森林或神经网络等机器学习技术，那么在事后往往很难解释为什么某个个体被以某种方式分类。数据进入黑盒，输出一个分类，而你通常不确定中间到底发生了什么。我将在本章后面更详细地讨论这一概念。
- en: In the following sections, I’ll cover the various concepts in statistics in
    more detail. I’ll usually favor high-level descriptions over specific applications
    so as to be widely applicable in many cases, but I’ll use illustrative examples
    when they seem helpful. There are many excellent technical resources that can
    provide more detail about each particular topic, and I’ll try to provide enough
    detail, including key words and common method names, so that you’re able to find
    additional resources quickly, on the internet or elsewhere.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将更详细地介绍统计学中的各种概念。我通常会倾向于使用高级描述而不是具体应用，以便在许多情况下具有广泛的适用性，但当我认为有帮助时，我会使用说明性示例。有许多优秀的资源可以提供关于每个特定主题的更多细节，我会尽量提供足够的细节，包括关键词和常见方法名称，以便您能够快速找到互联网或其他地方的相关资源。
- en: 7.2.2\. What statistics is not
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 统计学不是什么
- en: The most common misconception about what I do as a data scientist usually appears
    when I talk to a recruiter or other hiring agent for a company or institution.
    On occasion, the misconception appears later, after I’ve already taken a job and
    I’m midway through a project. The misconception is that I, as a data scientist,
    can set up, load, and administer a number of data stores serving a large number
    of people in various ways. I’ve explained many times to many people that data
    science is not data management, and it is definitely not database administration.
    There’s absolutely nothing wrong with those two roles—in fact, I am forever thankful
    when I get the chance to work with a highly competent database administrator (DBA)—but
    those roles are quite the opposite of scientific.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我作为数据科学家所做的工作最常见的误解通常出现在我与其他公司或机构的招聘人员或招聘代理交谈时。有时，这种误解在我已经接受工作并正在进行项目中途出现。这种误解是，作为数据科学家，我可以以各种方式为大量人群设置、加载和管理多个数据存储。我已多次向许多人解释，数据科学不是数据管理，也绝对不是数据库管理。这两个角色没有任何问题——事实上，当我有机会与一个高度胜任的数据库管理员（DBA）合作时，我永远都会感到感激——但这些角色与科学正好相反。
- en: Science is the endeavor to discover the unknown. Moving data around and improving
    reliability and query speed is an incredibly important job that has nothing to
    do with discovering the unknown. I’m not sure why, exactly, some people confuse
    these two data-oriented jobs, but it’s happened to me on more than one occasion.
    It’s particularly funny to me when someone asks me to set up a database for a
    large organization, because, of all of the most common data science tasks, database
    administration is probably the one in which I have the least experience. I can
    set up a database that serves me well, but I definitely wouldn’t count on myself
    to build a data management solution for a large organization.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 科学是探索未知的事业。移动数据并提高可靠性和查询速度是一项极其重要的工作，但这与发现未知无关。我不确定为什么，确切地说，有些人会混淆这两个以数据为导向的工作，但这已经发生在我身上不止一次了。当有人要求我为一个大组织设置数据库时，这尤其让我觉得好笑，因为，在所有最常见的数据科学任务中，数据库管理可能是我最不擅长的一项。我可以设置一个对我很有用的数据库，但我肯定不会依赖自己为一个大组织构建数据管理解决方案。
- en: Maybe it’s because I’m a mathematician, but I consider data management among
    those skills that are useful to me but that are peripheral to the main task. I
    want to get to the analysis. Anything that enables good data analysis is undeniably
    good, but I’ll suffer passable database performance for a long time before I feel
    the need to take control of it—and all of its administrative headaches—in the
    name of optimal performance. I’m all about the statistics, however long they take.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是因为我是一个数学家，但我认为数据管理是我有用的技能之一，但它是次要任务。我想进行数据分析。任何能够促进良好数据分析的东西无疑是好的，但在我感到需要为了最佳性能而控制它及其所有管理难题之前，我会忍受可接受的数据库性能很长时间。然而，我专注于统计学，无论它们需要多长时间。
- en: 'Data management is to statistics as a food supplier is to a chef: statistics
    is an art that depends deeply on reliable data management, as a restaurant famous
    for their bacon-encrusted salmon relies heavily on timely, high-quality raw materials
    from local pig and salmon farms. (Apologies to my vegetarian readers and fans
    of wild salmon.) To me, statistics *is* the job; everything else is only helping.
    Restaurant-goers want, first and foremost, good food with good ingredients; secondarily,
    they might want to know that the source of their food was reliable and fast. Consumers
    of statistical analysis—the customers of data science projects—want to know that
    they’ve gleaned reliable information in some way. Then and only then would they
    care if the data store, software, and workflow that uses both are reliable and
    fast. Statistical analysis is the product, and data management is a necessary
    part of the process.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数据管理对于统计学，就像食品供应商对于厨师一样：统计学是一门深深依赖可靠数据管理的艺术，正如以熏肉包裹的鲑鱼闻名的餐厅，严重依赖于来自当地猪场和鲑鱼养殖场的及时、高质量的原料。（向我的素食读者和野生鲑鱼爱好者致歉。）对我来说，统计学**就是**我的工作；其他的一切只是辅助。餐厅顾客首先想要的是用优质原料做的美食；其次，他们可能还想知道他们食物的来源是可靠且快速的。统计分析的消费者——数据科学项目的客户——希望知道他们以某种方式获得了可靠的信息。然后，只有那时，他们才会关心使用这些数据的存储、软件和工作流程是否可靠且快速。统计分析是产品，数据管理是这个过程的一个必要部分。
- en: The role that statistics plays in data science is not a secondary, peripheral
    function of dealing with data. Statistics is the slice of data science that provides
    the insights. All of the software development and database administration that
    data scientists do contribute to their ability to do statistics. Web development
    and user interface design—two other tasks that might be asked of a data scientist—help
    deliver statistical analysis to the customer. As a mathematician and statistician,
    I might be biased, but I think statistics is the most intellectually challenging
    part of a data scientist’s job.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学在数据科学中的作用不是处理数据的次要、外围功能。统计学是提供洞察力的数据科学的一部分。数据科学家所做的所有软件开发和数据库管理都促进了他们进行统计分析的能力。网站开发和用户界面设计——这两项可能要求数据科学家完成的任务——有助于将统计分析交付给客户。作为一个数学家和统计学家，我可能有所偏见，但我认为统计学是数据科学家工作中最具智力挑战性的部分。
- en: On the other hand, some of the biggest challenges I’ve dealt with in data science
    involve getting various software components to play nicely with one another, so
    I may be underestimating software engineering. It all depends on where you stand,
    I suppose. The next chapter will cover the basics of software, so I’ll put off
    further discussion of it until then.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我在数据科学中处理的一些最大挑战涉及让各种软件组件相互友好地协作，所以我可能低估了软件工程。这都取决于你站在哪里，我想。下一章将涵盖软件的基础知识，所以我将推迟对它的进一步讨论，直到那时。
- en: 7.3\. Mathematics
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 数学
- en: The field of mathematics, though its exact boundaries are disputed, is based
    wholly on logic. Specifically, every mathematical concept can be deconstructed
    into a series of if-then statements plus a set of assumptions. Yes, even long
    division and finding the circumference of a circle can be boiled down to purely
    logical steps that follow from assumptions. It so happens that people have been
    doing math for so long that there are innumerable logical steps and assumptions
    that have been in common use for so long that we often take some of them for granted.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数学的确切边界存在争议，但这个领域完全基于逻辑。具体来说，每个数学概念都可以分解成一系列的“如果-那么”陈述加上一组假设。是的，即使是长除法和求圆周长也可以简化为纯粹逻辑步骤，这些步骤遵循假设。碰巧的是，人们已经做了这么长时间的数学，有无数逻辑步骤和假设已经长期普遍使用，以至于我们常常认为其中一些是理所当然的。
- en: '7.3.1\. Example: long division'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 示例：长除法
- en: Long division—or plain division—as you learned it in elementary school, is an
    operation between two numbers that comes with a lot of assumptions. It’s likely
    that everyone reading this book learned how to do long division as a set of steps,
    a sort of algorithm that takes as input two numbers, the dividend and divisor,
    and gives a result called the quotient. Long division can be quite useful (more
    so in the absence of a calculator or computer) in everyday life when, for example,
    you want to divide a restaurant bill equally among several people or share a few
    dozen cupcakes with friends.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 长除法——或者说是你小学时学到的普通除法——是一种两个数之间的运算，它伴随着许多假设。对于阅读这本书的每个人来说，很可能都是以一系列步骤学习如何进行长除法，这是一种算法，它接受两个数作为输入，被除数和除数，并给出一个称为商的结果。长除法在日常生活中的确很有用（在没有计算器或电脑的情况下更有用），例如，当你想要将餐厅账单平均分给几个人或者与朋友们分享几十个纸杯蛋糕时。
- en: Many people think the field of mathematics is composed of numerous such moderately
    useful algorithms for calculating things, and these people wouldn’t be entirely
    wrong. But far more important than mathematical algorithms are the assumptions
    and logical steps that can be assembled into a proof that something is true or
    false. In fact, every mathematical algorithm is constructed from a series of logical
    statements that can end up proving that the algorithm itself does what it is supposed
    to do, given the required assumptions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为数学领域由许多这样的适度有用的计算算法组成，这些人并不完全错误。但比数学算法更重要的是那些可以组装成证明某事物为真或为假的假设和逻辑步骤。事实上，每个数学算法都是由一系列逻辑陈述构成的，这些陈述最终可以证明算法在给定必要的假设下确实做了它应该做的事情。
- en: 'Take, for instance, three logical statements X, Y, and Z, each of which could
    be either true or false under various circumstances, as well as the following
    statements:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以三个逻辑陈述 X、Y 和 Z 为例，每个陈述在各种情况下都可能为真或为假，以及以下陈述：
- en: If X is true, then Y must be false.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 X 是真的，那么 Y 必须是假的。
- en: If Y is false, then Z is true.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Y 是假的，那么 Z 就是真的。
- en: This is obviously an arbitrary set of statements that could be straight out
    of a logic text, but such statements lie at the heart of mathematics.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一组任意的陈述，可能直接来自逻辑学教材，但这样的陈述是数学的核心。
- en: 'Given these statements, let’s say that you find out that X is true. It follows
    that Y is false and also that Z is true. That’s logic, and it doesn’t seem exciting.
    But what if I put real-life meaning into X, Y, and Z in an example that includes
    a visitor, or potential customer, to a retail website:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些陈述，假设你发现 X 是真的。那么 Y 就是假的，同时 Z 也是真的。这就是逻辑，看起来并不激动人心。但如果我们给 X、Y 和 Z 赋予现实生活中的意义，在一个包括零售网站访客或潜在顾客的例子中：
- en: '***Statement X—*** The potential customer put more than two items into their
    online shopping cart.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***陈述 X—*** 潜在的顾客将超过两个商品放入他们的在线购物车中。'
- en: '***Statement Y—*** The customer is only browsing.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***陈述 Y—*** 顾客只是在浏览。'
- en: '***Statement Z—*** The potential customer will buy something.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***陈述 Z—*** 潜在的顾客将会购买某物。'
- en: Those statements are all meaningful to an online retailer. And you know that
    the statement “Z is true” is exciting to any retailer that’s trying to make money,
    so the logical statements shown previously imply that the statement “X is true”
    should also be exciting to the retailer. More practically, it might imply that
    if the retailer is able to get a potential customer to put more than two items
    into the shopping cart, then they will make a sale. This might be a viable marketing
    strategy on the website if other paths to making a sale are more difficult. Obviously,
    real life is rarely this purely logical, but if you make all of the statements
    fuzzier such that “is true” becomes “probably is true” and likewise for “is false,”
    then this scenario might indeed be a realistic one in which a data scientist could
    help increase sales for the retailer. Such fuzzy statements are often best handled
    using statements of probability, which I cover later in this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些陈述对在线零售商来说都是有意义的。你知道，对于任何试图赚钱的零售商来说，“Z 是真的”这个陈述都是令人兴奋的，所以前面展示的逻辑陈述意味着“X 是真的”这个陈述也应该让零售商感到兴奋。更实际地说，这可能意味着如果零售商能够让潜在顾客将超过两个商品放入购物车，那么他们就会做成一笔交易。这可能是在网站上实施的一种可行的营销策略，如果其他做成交易的方法更困难的话。显然，现实生活中很少如此纯粹地逻辑化，但如果你将所有陈述都变得模糊一些，使得“是真的”变成“可能是真的”，同样地，“是假的”也是如此，那么这种场景确实可能是一个数据科学家可以帮助零售商增加销售额的现实场景。这种模糊的陈述通常最好使用概率陈述来处理，我将在本章后面介绍。
- en: 'Back to the example of long division: even the algorithms of basic arithmetic
    (as you probably learned in school) are predicated on assumptions and logical
    statements. Before getting into those, instead of boring you with a description
    of how I do long division, let’s assume that you have a favorite way to do long
    division—correctly—with pencil and paper, and we’ll refer to that way as *The
    Algorithm* hereafter in this example. The Algorithm must be the kind that gives
    decimal results and not the kind of long division that gives an almost answer
    plus a remainder. (You’ll understand why in a few minutes.) Furthermore, let’s
    assume that The Algorithm was originally developed by a mathematician and that
    this mathematician has already proven that The Algorithm results in correct answers
    under the appropriate conditions. Now let’s explore some of the conditions that
    the mathematician requires in order for you to use The Algorithm properly.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 回到长除法的例子：即使是基本算术的算法（你可能在学校学过）也是基于假设和逻辑陈述的。在深入探讨这些之前，为了避免用我如何进行长除法的描述让你感到无聊，让我们假设你有一种你喜欢的正确使用铅笔和纸进行长除法的方式——我们将这种方式称为“算法”在此例中。算法必须是给出小数结果的那种，而不是给出一个几乎正确答案加上余数的长除法。（你将在几分钟内理解原因。）此外，让我们假设这个算法最初是由一位数学家开发的，并且这位数学家已经证明，在适当的条件下，算法会得到正确答案。现在让我们探讨一下数学家要求你正确使用算法的一些条件。
- en: First, you have to assume that the dividend, divisor, and quotient are elements
    of a set called the real numbers. The set of *real numbers* includes all the decimal
    and whole numbers you’re used to but not others, such as the imaginary numbers
    you might get if, for example, you tried to take the square root of a negative
    number. There are all sorts of other sets of non-real numbers as well as sets
    not containing numbers at all, but I’ll leave that to mathematics textbooks to
    discuss.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须假设被除数、除数和商是称为实数集的集合的元素。实数集包括你习惯的所有小数和整数，但不包括其他数字，例如，如果你尝试对负数开平方可能会得到的虚数。还有各种其他非实数集以及不包含数字的集合，但我将把那留给数学教科书去讨论。
- en: In addition to the assumption that you’re dealing with the set of real numbers,
    you also assume that this particular set of real numbers is also a specific type
    of set called a field. A *field*, a central concept in abstract algebra, is a
    set that’s defined by a number of properties, among which are the existence of
    two operations, commonly called addition and multiplication, which in an abstract
    sense are not guaranteed to work in the way they do in common arithmetic. You
    do know that these two operations in fields always operate on two elements of
    the field in certain specific ways, but the fact that addition and multiplication
    work in this one specific way is another assumption you have to make when doing
    long division. For more on fields, consult a reference on abstract algebra.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了假设你处理的是实数集之外，你还假设这个特定的实数集也是一个称为域的特殊类型的集合。域是抽象代数中的一个中心概念，它是由一系列性质定义的集合，其中包含两种常见的运算，即加法和乘法，在抽象意义上并不保证以它们在普通算术中工作的方式工作。你知道，在域中，这两种运算总是以某种特定方式作用于域的两个元素，但加法和乘法以这种方式工作的事实，是你进行长除法时必须做出的另一个假设。有关域的更多信息，请参考抽象代数的参考资料。
- en: You’re assuming you have a field composed of real numbers and that you have
    the operations addition and multiplication that work in the specific ways you
    learned in school. As part of the definition of a field, these two operations
    must both have *inverses*. As you can probably guess, you often call the inverse
    of addition *subtraction* and the inverse of multiplication *division*. The inverse
    of any operation must undo what the operation does. A number *A multiplied by
    B* gives a result *C* such that *C divided by B* gives the number *A* again. Division
    is defined to be the inverse of multiplication as you know it. That’s not an assumption;
    it follows from the other assumptions and the definition of a field.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你假设你有一个由实数组成的域，并且你拥有加法和乘法这两种运算，它们以你在学校学到的方式工作。作为一个域的定义的一部分，这两种运算都必须有**逆运算**。你可能已经猜到了，你通常把加法的逆运算称为**减法**，乘法的逆运算称为**除法**。任何运算的逆运算都必须撤销该运算所做的操作。一个数
    *A 乘以 B* 得到一个结果 *C*，使得 *C 除以 B* 再次得到数 *A*。除法定义为已知乘法的逆运算。这不仅仅是一个假设；它是由其他假设和域的定义推导出来的。
- en: 'To summarize, here’s what you have on long division:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是关于长除法的假设：
- en: 'Assumptions:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设：
- en: You have the set of real numbers.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你拥有实数集。
- en: You have a field over the set of real numbers.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一个在实数集上的域。
- en: The field operations addition and multiplication work as in arithmetic.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场运算加法和乘法与算术中的运算方式相同。
- en: 'Statements:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈述：
- en: 'If you have a field, then addition and multiplication have inverses: subtraction
    and division, respectively.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个域，那么加法和乘法有逆元：分别是减法和除法。
- en: If the field operations addition and multiplication work as in arithmetic, then
    subtraction and division also work as in arithmetic.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果域运算加法和乘法与算术中的运算方式相同，那么减法和除法也以算术中的方式工作。
- en: If division works as in arithmetic, then The Algorithm will give correct answers.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果除法与算术中的运算方式相同，那么该算法将给出正确答案。
- en: 'Putting together these assumptions with these statements yields the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些假设与这些陈述结合起来，得到以下结论：
- en: Assumptions 1 and 2 together with statement 1 imply that the operations subtraction
    and division exist.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设1和2与陈述1一起意味着减法和除法运算存在。
- en: Assumption 3 and statement 2 imply that subtraction and division work as in
    arithmetic.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设3和陈述2意味着减法和除法与算术中的运算方式相同。
- en: The previous two statements together with statement 3 imply that The Algorithm
    will give correct answers.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个陈述与陈述3一起意味着该算法将给出正确答案。
- en: That example may seem trivial, and in some ways it is, but I think it’s illustrative
    of the way that our knowledge of the world, in particular on quantitative topics,
    is built on specific instances of mathematical constructs. If the system of real
    numbers didn’t apply for some reason, then long division with decimal results
    wouldn’t work. If instead you were using the set of whole numbers or the integers,
    then a different algorithm for long division would be appropriate, possibly one
    that resulted in a sort of quotient plus a remainder. The reason long division
    can’t work the same on whole numbers or integers as it does with the real numbers
    is that neither set—whole numbers or integers—forms a field. Knowledge of the
    underlying mathematics, such as when you have a field and when you don’t, is the
    only definitive way to determine when The Algorithm is appropriate and when it
    is not. Extending that idea, knowledge of mathematics can be useful in choosing
    analytical methods for data science projects and in diagnosing eventual problems
    with those methods and their results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子可能看起来很 trivial，从某些方面来看确实如此，但我认为它说明了我们对世界的认识，特别是在定量问题上，是基于数学结构的特定实例构建的。如果由于某种原因实数系统不适用，那么带有小数结果的长期除法将无法工作。如果你使用的是整数集或整数，那么可能需要不同的长除法算法，可能是一个结果为某种商加上余数的算法。长除法不能在整数或整数上以与实数相同的方式工作，原因在于这两个集合——整数或整数——都不构成域。对基础数学的了解，例如当你有一个域或没有域时，是确定算法何时适用以及何时不适用的唯一确定方法。扩展这个想法，数学知识在为数据科学项目选择分析方法以及在诊断这些方法及其结果可能存在的问题时非常有用。
- en: 7.3.2\. Mathematical models
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 数学模型
- en: A *model* is a description of a system and how it works. A mathematical model
    describes a system using equations, variables, constants, and other concepts from
    mathematics. If you’re trying to describe a system that exists in the real world,
    then you’re venturing into *applied mathematics*, a phrase that generally implies
    that the work done can be applied to something outside mathematics, such as physics,
    linguistics, or data science. Applied mathematics is certainly often close to
    statistics, and I won’t attempt to make a clear distinction between the two. But,
    generally speaking, applied math focuses on improving models and techniques, possibly
    without any data at all, whereas statistics concentrates on learning from data
    using mathematical models and techniques. The fields of mathematical modeling
    and applied mathematics are likewise not clearly distinguishable; the former focuses
    on the models, and the latter on some kind of real-world applications, but neither
    does so exclusively. The concept and use of mathematical models aren’t intuitive
    to everyone, so I’ll discuss them briefly here.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *模型* 是对系统及其工作方式的描述。一个数学模型使用方程、变量、常数以及来自数学的其他概念来描述系统。如果你试图描述存在于现实世界中的系统，那么你就是在进入
    *应用数学* 的领域，这个短语通常意味着所做的工作可以应用于数学之外的事物，例如物理学、语言学或数据科学。应用数学当然通常与统计学紧密相关，我不会尝试在这两者之间做出明确的区分。但是，一般来说，应用数学侧重于改进模型和技术，可能根本不需要任何数据，而统计学则侧重于使用数学模型和技术从数据中学习。数学建模和应用数学这两个领域同样没有明确的界限；前者侧重于模型，而后者侧重于某种现实世界的应用，但两者都不是专门如此。数学模型的概念和使用并不对每个人都直观，所以我会在这里简要地讨论它们。
- en: One of the simplest and most commonly used mathematical models is the linear
    model. A *linear model* is merely a line, described by a linear equation, that’s
    intended to represent the relationship between two or more variables. When the
    relationship is linear, it’s equivalent to saying that the variables are directly
    proportional, terminology that’s used more often in some fields. A linear equation
    describing a linear model in two dimensions (two variables) can be written in
    slope-intercept form (remember from school!) as
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最常用的数学模型之一是线性模型。一个 *线性模型* 只是一个直线，由线性方程描述，旨在表示两个或更多变量之间的关系。当这种关系是线性的，它等同于说变量是直接成比例的，这种术语在某些领域中更为常用。描述二维（两个变量）线性模型的线性方程可以写成斜截式（记得从学校学过的！）：
- en: y = Mx + B
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = Mx + B
- en: where M is the slope and B is the y-intercept.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 M 是斜率，B 是 y 轴截距。
- en: Linear models are used in many applications because they’re easy to work with
    and also because many natural quantities can be reasonably expected to follow
    an approximately linear relationship with each other. The relationship between
    distance driven in a car and the amount of gasoline used is a good example. The
    farther you drive, the more gasoline you burn. Exactly how much gasoline was used
    depends on other factors as well, such as the type of car, how fast you were driving,
    and traffic and weather conditions. Therefore, although you can reasonably assume
    that distance and gasoline usage are approximately linearly related, other somewhat
    random variables cause variations in gasoline usage from trip to trip.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型在许多应用中被使用，因为它们易于处理，也因为许多自然量可以合理地预期彼此之间大约呈线性关系。汽车行驶的距离与使用的汽油量之间的关系是一个很好的例子。你行驶得越远，消耗的汽油就越多。使用的确切汽油量还取决于其他因素，例如汽车类型、你的驾驶速度以及交通和天气条件。因此，尽管你可以合理地假设距离和汽油消耗量大约呈线性关系，但其他一些随机变量会导致每次旅行中汽油消耗量的变化。
- en: Models are often used to make predictions. If you had a linear model for gasoline
    usage based on distance traveled, you could predict the amount of gasoline you’d
    use on your next trip by putting the distance of the trip into the linear equation
    that describes your model. If you used the linear model
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通常用于做出预测。如果你有一个基于行驶距离的汽油消耗的线性模型，你可以通过将旅行的距离放入描述你模型的线性方程中来预测你下一次旅行将使用的汽油量。如果你使用了线性模型
- en: y = 0.032x + 0.0027
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = 0.032x + 0.0027
- en: where y is the amount of gasoline (in liters) needed and x is the distance traveled
    (in kilometers), then the slope of the line, 0.032, implies that trips in your
    data set required on average 0.032 liters of gasoline per kilometer traveled.
    In addition to that, there appears to be an additional 0.0027 liters of gasoline
    used per trip, regardless of distance traveled. This might account for the energy
    needed to start the car and idle for a few moments before beginning the trip.
    Regardless, using this model, you can predict the gasoline usage for an upcoming
    trip of, say, 100 km by setting x = 100 and calculating y. The prediction according
    to the model would be y = 3.2027 liters. This is a basic example of how a linear
    model might be used to make predictions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中y是需要汽油的量（以升为单位），x是行驶的距离（以公里为单位），那么线的斜率0.032意味着你的数据集中的行程平均每公里需要0.032升汽油。除此之外，似乎每次行程都会额外使用0.0027升汽油，无论行驶的距离如何。这可能会解释启动汽车和开始行程前几分钟怠速所需的能量。无论如何，使用这个模型，你可以通过设置x
    = 100并计算y来预测即将到来的100公里行程的汽油使用量。根据模型的预测，y将是3.2027升。这是一个线性模型如何用于预测的基本例子。
- en: '[Figure 7.2](kindle_split_017_split_003.xhtml#ch07fig02) shows a graphical
    representation of a linear model without any axis labels or other context. I’ve
    included this graph without context because I’d like to focus on the purely conceptual
    aspects of the model and the mathematics, and the context can sometimes distract
    from those. In the graph, the line is the model, and the dots represent data that
    the line is attempting to model. The y-intercept seems to be approximately 5.0,
    the slope is about 0.25, and the line seems to follow the data reasonably well.
    But notice the dispersion of the data around the line. If, for example, you wanted
    to predict a y-value from a given x-value, the model probably wouldn’t give a
    perfect prediction, and there would be some error. Based on the dots, the predictions
    of y-values appear to be within about three or four units of the linear model,
    which may be good or not, depending on the goals of the project. I’ll discuss
    fitting models to data later, in the section on statistical modeling. The main
    idea here is the conceptual relationship between a model and data. Having an image
    such as this one in your mind—and the conceptual understanding it brings—while
    modeling data increases awareness and improves decision making throughout your
    analyses.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.2](kindle_split_017_split_003.xhtml#ch07fig02) 展示了一个没有轴标签或其他上下文的线性模型的图形表示。我包含了这个图表而没有上下文，因为我希望专注于模型的纯粹概念方面和数学，而上下文有时可能会分散对这些方面的注意力。在图中，线代表模型，点代表模型试图模拟的数据。y轴截距似乎约为5.0，斜率约为0.25，线似乎合理地遵循数据。但请注意数据点围绕线的分散情况。例如，如果你想要从一个给定的x值预测一个y值，模型可能不会给出完美的预测，并且会有一些误差。根据点，y值的预测似乎在线性模型的三到四个单位之内，这可能是好是坏，取决于项目的目标。我将在统计建模部分讨论如何将模型拟合到数据。这里的主要思想是模型与数据之间的概念关系。在建模数据时，在脑海中保留这样的图像——以及它带来的概念理解——可以增加意识并提高分析过程中的决策能力。'
- en: Figure 7.2\. A representation of a linear model (line) and some data (dots)
    that the model attempts to describe. The line is a mathematical model, and its
    optimal parameters—slope and intercept—can be found using statistical modeling
    techniques.^([[1](kindle_split_017_split_003.xhtml#ch07fn01)])
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2。一个线性模型（线）和模型试图描述的一些数据（点）的表示。线是一个数学模型，其最佳参数——斜率和截距——可以使用统计建模技术找到。[^([1](kindle_split_017_split_003.xhtml#ch07fn01))]
- en: ¹
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From [https://en.wikipedia.org/wiki/Linear_regression](https://en.wikipedia.org/wiki/Linear_regression),
    in the public domain.
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来自 [https://en.wikipedia.org/wiki/Linear_regression](https://en.wikipedia.org/wiki/Linear_regression)，公有领域。
- en: '![](Images/07fig02.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02.jpg)'
- en: It’s important to emphasize that mathematical models are fabricated things that
    don’t have any inherent connection to the real-life system. Models are descriptions
    of what you think happens in those systems, and there’s no guarantee that they
    work well. It’s the responsibility of the data scientist (or mathematician or
    statistician) to find a model that’s good enough to suit the purposes of the project
    and apply it correctly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 强调数学模型是人为构建的事物，它们与现实生活中的系统没有固有的联系是很重要的。模型是对你认为那些系统中发生的事情的描述，并且不能保证它们有效。找到适合项目目的并且正确应用的模型是数据科学家（或数学家或统计学家）的责任。
- en: '|  |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Examples of mathematical models**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学模型的例子**'
- en: Einstein’s model of gravity, as described in his theory of general relativity,
    famously supplanted Newton’s model of gravity. Newton’s model is a simple equation
    that describes the forces of gravity quite accurately at normal masses and distances,
    but Einstein’s model, which uses a mathematical model based on metric tensors
    (a sort of higher-order object describing linear relationships), is far more accurate
    at extreme scales.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 爱因斯坦的引力模型，正如他在广义相对论中所描述的那样，著名地取代了牛顿的引力模型。牛顿的模型是一个简单的方程，它能够相当准确地描述在正常质量和距离下的引力作用力，但爱因斯坦的模型，它使用基于度规张量（一种描述线性关系的更高阶对象）的数学模型，在极端尺度上要准确得多。
- en: The current Standard Model of particle physics, finalized in the 1970s, is a
    mathematical model based on quantum field theory that theorizes how physical forces
    and subatomic particles behave. It has survived a few experimental tests of its
    applicability as a model, most recently during the process of confirming the existence
    of the Higgs boson. The Higgs boson is an elementary particle predicted by the
    Standard Model for which, prior to 2012, there was little experimental proof of
    existence. Since then, experiments at the Large Hadron Collider at CERN have confirmed
    the existence of a particle consistent with the Higgs boson. Like any good scientist,
    the researchers at CERN won’t say with certainty that they found the Higgs boson
    and only the Higgs boson, because some properties of the particle are still unknown,
    but they do say with certainty that nothing in the Standard Model has yet been
    contradicted by experimental evidence.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现今的粒子物理标准模型，在20世纪70年代最终确定，是一个基于量子场论的数学模型，该模型理论化了物理力和亚原子粒子的行为。它已经经受了几次对其适用性作为模型的实验测试，最近是在确认希格斯玻色子存在的过程中。希格斯玻色子是标准模型预测的一种基本粒子，在2012年之前，关于其存在几乎没有实验证据。从那时起，在CERN的大型强子对撞机上的实验已经确认了一个与希格斯玻色子一致的粒子的存在。像任何优秀的科学家一样，CERN的研究人员不会肯定地说他们只发现了希格斯玻色子，因为该粒子的某些性质仍然未知，但他们确实肯定地说，标准模型中的任何内容至今尚未被实验证据所反驳。
- en: From my own experience, some of the more interesting applications of mathematical
    models happen in social network analysis. Social networks are composed of individuals
    and connections between them, making graph theory an excellent mathematical field
    in which to look for applicable models. Theories of connectedness, centrality,
    and inbetweenness, among others, can be nearly directly applied to real-life scenarios
    in which groups of people interact in various ways. Graph theory has numerous
    other applications, and frankly it has some quite interesting purely mathematical
    (nonapplied) problems as well, but the recent advent of social networks on the
    internet provides a wealth of new phenomena to model as well as data to support
    it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从我自己的经验来看，数学模型的一些更有趣的应用发生在社交网络分析中。社交网络由个体及其之间的连接组成，这使得图论成为寻找适用模型的一个极好的数学领域。连通性、中心性和介于两者之间的理论，以及其他理论，可以几乎直接应用于现实生活中人们以各种方式互动的实际情况。图论还有许多其他应用，而且坦白地说，它还有一些相当有趣的纯粹数学（非应用）问题，但互联网上社交网络的最近出现为建模提供了丰富的新的现象以及支持它的数据。
- en: The geometric equivalent of a linear model is the concept of Euclidean geometry,
    which is the normal concept of how three-dimensional space works—length, height,
    width, all lines can extend to infinity without intersecting—extended to any number
    of dimensions. But other geometries exist, and these can be useful in modeling
    certain systems. Spherical geometry is the geometry that exists on the surface
    of a sphere. If you’re standing on the Earth, a sphere (approximately), and you
    walk in a straight line, ignoring bodies of water, you’ll arrive back where you
    started some time later. This doesn’t happen in Euclidean geometry—where you’d
    be walking into infinity—and it’s a property that can come in handy when modeling
    certain processes. Certainly, any model of airplane traffic could benefit from
    a spherical geometry, and I’m sure there are many more uses, such as manufacturing
    engineering, where precision milling a ball joint or other curved surface might
    need a model of a spherical geometry to get the shape exactly right.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型的几何等价物是欧几里得几何的概念，这是三维空间正常运作的概念——长度、高度、宽度，所有线条都可以无限延伸而不相交——扩展到任意多个维度。但存在其他几何，这些几何在建模某些系统时可能是有用的。球面几何是存在于球面上的几何。如果你站在地球（一个球体，大约）上，沿着直线行走，忽略水体，你会在一段时间后回到起点。在欧几里得几何中不会发生这种情况——你会走进无限——这是一个在建模某些过程时可能很有用的属性。当然，任何飞机交通模型都可以从球面几何中受益，我相信还有更多用途，例如在制造工程中，精确铣削球节或其他曲面可能需要一个球面几何模型来得到完全正确的形状。
- en: Mathematical models are used in every quantitative field, explicitly or implicitly.
    Like some of the logical statements and assumptions that we must make in everyday
    arithmetic, some mathematical models are used so often for a given purpose that
    they’re taken for granted. For example, surveys, democratic election polling,
    and medical testing make use of correlations between variables to draw informative
    conclusions. The common concept of correlation—specifically the Pearson correlation
    coefficient—assumes a linear model, but that fact is often taken for granted,
    or at least it’s not common knowledge. The next time you’re reading a forecast
    for an upcoming election, know that the predictions as well as the margins of
    error are based on a linear model.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 数学模型在每一个定量领域都被使用，无论是明确还是隐含地。就像我们在日常算术中必须做出的某些逻辑陈述和假设一样，一些数学模型在特定目的上被频繁使用，以至于它们被视为理所当然。例如，调查、民主选举民意调查和医学测试都利用变量之间的相关性来得出有信息量的结论。常见的相关性概念——特别是皮尔逊相关系数——假设线性模型，但这一事实往往被视为理所当然，或者至少不是众所周知。下次你阅读即将到来的选举的预测时，要知道预测以及误差范围都是基于线性模型的。
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.3\. Mathematics vs. statistics
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 数学与统计学
- en: Real math is made up of assumptions and logical statements, and only in specific
    instances does it involve numeric quantities. In that way, among all the topics
    that are taught in high school math classes in the United States, geometry—with
    its proofs of triangle congruence and parallelity of lines—comes the closest to
    the heart of mathematics. But everyday life obviously deals in numeric quantities
    quite often, so we tend to focus on the branches of mathematics that deal with
    quantities. Data science does this quite often, but it has also been known to
    bleed into not-so-quantitative, or pure, branches of mathematics such as group
    theory, non-Euclidean geometry, and topology, if they seem useful. In that way,
    knowledge of some pure mathematical topics can prove useful to a data scientist.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的数学由假设和逻辑陈述组成，并且仅在特定情况下才涉及数值量。因此，在美国高中数学课程中教授的所有主题中，几何——包括三角形全等和直线平行的证明——最接近数学的核心。但日常生活显然经常涉及数值量，所以我们往往关注处理数量的数学分支。数据科学经常这样做，但它也已被知会渗透到不那么数量化的，或纯，的数学分支，如群论、非欧几里得几何和拓扑学，如果它们看起来有用的话。因此，对某些纯数学主题的了解可能对数据科学家是有用的。
- en: In any case, mathematics generally doesn’t touch the real world. Based wholly
    on logic and always—always—starting with a set of assumptions, mathematics must
    first assume a world it can describe before it begins to describe it. Every mathematical
    statement can be formulated to start with an *if* (*if* the assumptions are true),
    and this *if* lifts the statement and its conclusion into abstractness. That is
    not to say that mathematics isn’t useful in the real world; quite the contrary.
    Mathematics, rather than being a science, is more of a vocabulary with which we
    can describe things. Some of these things might be in the real world. As with
    vocabularies and the words they contain, rarely is a description perfectly correct.
    The goal is to get as close to correct as possible. The mathematician and statistician
    George Box famously wrote, “Essentially, all models are wrong, but some are useful.”
    Indeed, if a model is reasonably close to correct, it can be useful.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，数学通常并不涉及现实世界。完全基于逻辑，并且始终——始终——从一个假设集合开始，数学必须首先假设一个可以描述的世界，然后才开始描述它。每个数学陈述都可以用“如果”（如果假设是真实的）来表述，而这个“如果”将陈述及其结论提升到抽象层面。这并不是说数学在现实世界中没有用处；恰恰相反。数学与其说是一门科学，不如说是一种我们可以用其描述事物的词汇。其中一些事物可能存在于现实世界中。就像词汇和它们包含的单词一样，很少有一个描述是完全正确的。目标是尽可能地接近正确。数学家和统计学家乔治·博克斯（George
    Box）曾著名地写道：“本质上，所有模型都是错误的，但有些是有用的。”确实，如果一个模型与正确性相当接近，那么它是有用的。
- en: The field of statistics shares these concerns about the correctness of models,
    but instead of being a vocabulary and a system of logic, statistics is a lens
    through which to see the world. Statistics begins with data, and though statistical
    models are mostly indistinguishable from mathematical models, the intent is quite
    different. Instead of seeking to describe a system from the inside out, a statistical
    model observes a system from the outside in by aggregating and manipulating relevant
    observable data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学领域对模型的正确性也有这些担忧，但统计学并非是一种词汇和逻辑体系，而是一扇观察世界的窗口。统计学从数据开始，尽管统计模型在大多数情况下与数学模型难以区分，但其意图却大相径庭。统计模型不是从内部描述系统，而是通过汇总和操作相关可观察数据，从外部观察系统。
- en: Mathematics does, however, provide much of the heavy machinery that statistics
    uses. Statistical distributions are often described by complex equations with
    roots that are meaningful in a practical, scientific sense. Fitting statistical
    models often makes use of mathematical optimization techniques. Even the space
    in which a project’s data is assumed to lie must be described mathematically,
    even if the description is merely “N-dimensional Euclidean space.” Although the
    boundary is a bit blurry, I like to say that the point at which mathematics ends
    and statistics begins is the point at which real data enters an equation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数学确实为统计学提供了大量的重型机械。统计分布通常由具有实际、科学意义的根的复杂方程描述。拟合统计模型通常使用数学优化技术。即使是一个项目数据假设所在的空间也必须用数学来描述，即使这个描述仅仅是“N维欧几里得空间”。尽管边界有些模糊，但我喜欢说数学结束和统计学开始的地方是真实数据进入方程的地方。
- en: 7.4\. Statistical modeling and inference
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 统计建模与推断
- en: In [chapter 5](kindle_split_014_split_000.xhtml#ch05), I mentioned statistical
    inference in the context of the rough statistical analysis I suggested as a part
    of data assessment. *Inference* is the task of estimating the value of a quantity
    you’re not able to measure directly. Because you don’t have direct measurements
    of the quantity, it’s necessary to construct a model that, at the least, describes
    the relationship between the quantity you want and the measurements you have.
    Because of the existence of a model in inference, I’ve lumped statistical modeling
    and inference together in this section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_014_split_000.xhtml#ch05)中，我提到了在数据评估建议的粗略统计分析背景下统计推断。*推断*是估计无法直接测量的量值的任务。因为你没有直接测量这个量值，所以有必要构建一个模型，至少描述你想要的量和已有的测量之间的关系。由于推断中存在模型，我在本节中将统计建模和推断合并在一起。
- en: 'A statistical model is not that different from a mathematical model, which
    I’ve already covered in this chapter. As I’ve written, the difference is mainly
    the focus: mathematical modeling focuses on the model and its inherent properties,
    but statistical modeling focuses on the model’s relationship to data. In both
    cases, the model is a set of variables whose relationships are described by equations
    and other mathematical relations. A linear model—which I’ve already introduced—between
    the quantities x and y might look like'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模型与数学模型并没有太大的不同，我在本章中已经介绍过。正如我写的，区别主要在于焦点：数学建模侧重于模型及其固有属性，而统计建模侧重于模型与数据的关系。在两种情况下，模型都是一组变量，其关系由方程和其他数学关系描述。我已经介绍过的x和y之间的线性模型可能看起来像
- en: y = Mx + B
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = Mx + B
- en: whereas an exponential model might look like
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 而指数模型可能看起来像
- en: y = Ae^x
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y = Ae^x
- en: where e is the exponential constant, also known as Euler’s number. The model
    parameter values M, B, and A are probably unknown until they’re estimated via
    some statistical inference technique.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 其中e是指数常数，也称为欧拉数。模型参数值M、B和A可能直到通过某种统计推断技术估计之前都是未知的。
- en: Each of these two models is a description of how x and y might be related to
    one another. In the first case, the linear model, it is assumed that as x goes
    up a certain amount, y goes up (or down, depending on the value of M) the same
    amount no matter how large x gets. In the second case, the exponential one, if
    x increases a certain amount, then y will increase an amount that depends on the
    size of x; if x is larger, then an increase in x will increase y an even bigger
    amount than if x was smaller. In short, if x gets bigger, then bigger again, the
    second movement will cause a greater increase in y than the first.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模型中的每一个都是描述x和y之间可能存在的关系。在第一种情况下，线性模型，假设当x增加一定量时，y也会增加（或减少，取决于M的值）相同的量，无论x有多大。在第二种情况下，指数模型，如果x增加一定量，那么y的增加量将取决于x的大小；如果x更大，那么x的增加将导致y增加的量比x更小时要大。简而言之，如果x变大，那么第二次移动将导致y比第一次移动增加得更多。
- en: A common example of exponential growth is unconstrained population growth. If
    resources aren’t scarce, then populations—bacteria, plants, animals, even people—sometimes
    grow exponentially. The growth rate might be 5%, 20%, or larger, but the term
    *exponential* implies that percentages (or proportions), and not scalar numbers,
    describe the growth. For example, if a population has 100 individuals and is growing
    at a rate of 20% per year, then after one year the population will contain 120
    individuals. After two years, you expect to have 20% more than 120, which adds
    24 individuals to the total, bringing it to 144\. As you can see, the rate of
    increase grows as the population grows. That’s one of the characteristics of an
    exponential growth model.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 指数增长的常见例子是不受限制的人口增长。如果资源不稀缺，那么人口——细菌、植物、动物，甚至人类——有时会呈指数增长。增长率可能是5%，20%或更大，但“指数”这个词意味着百分比（或比例），而不是标量数字，描述了增长。例如，如果一个人口有100个个体，并且每年以20%的速度增长，那么一年后人口将包含120个个体。两年后，你预计比120多20%，这将增加24个个体，总数达到144。正如你所看到的，增长速度随着人口的增加而增长。这是指数增长模型的一个特征。
- en: Both of these models, linear and exponential, can be described by a single equation.
    If you use one of these models in a project, the challenge is to find estimates
    of the parameters M, B, and/or A that represent the data well and can provide
    insight into the system you’re modeling. But models can extend far beyond a single
    equation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模型，线性模型和指数模型，都可以用一个单一方程来描述。如果你在一个项目中使用这些模型，挑战就是找到代表数据的参数M、B和/或A的估计值，这些估计值可以提供对所建模系统的洞察。但模型可以远远超出一个单一方程。
- en: Now that you’ve seen a couple of simple examples, let’s have a look at what
    statistical models are in general.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了几个简单的例子，让我们来看看统计模型在一般情况下是什么。
- en: 7.4.1\. Defining a statistical model
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1. 定义统计模型
- en: A *statistical model* is a description of a set of quantities or variables that
    are involved in a system and also a description of the mathematical relationships
    between those quantities. So far, you’ve seen a linear model as well as an exponential
    one, both of which pertain only to two variables, x and y, whatever those quantities
    are. Models can be far more complex, consisting of variables of many dimensions
    as well as requiring many equations of various types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *统计模型* 是对系统中涉及的量或变量的描述，也是对这些量之间的数学关系的描述。到目前为止，你已经看到了一个线性模型以及一个指数模型，这两个模型都只涉及两个变量
    x 和 y，无论这些量是什么。模型可以更加复杂，包括许多维度的变量以及需要许多不同类型的方程。
- en: 'Beyond linear and exponential equations, all sorts of function types are used
    in statistical modeling: polynomial, piecewise polynomial (spline), differential
    equations, nonlinear equations of various types, and many others. Some equation
    or function types have more variables (moving parts) than others, which affect
    the complexity of the model description as well as the difficulty of estimating
    all the model parameters.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线性方程和指数方程之外，在统计建模中使用了各种函数类型：多项式、分段多项式（样条）、微分方程、各种类型的非线性方程等等。某些方程或函数类型比其他类型有更多的变量（运动部分），这影响了模型描述的复杂性和估计所有模型参数的难度。
- en: Beyond these mathematical descriptions of models, a statistical model should
    have some explicit relationship to data that’s relevant to the system being modeled.
    Usually, this means that the values for which data exists are included explicitly
    as variables in the model. For instance, if you consider the population growth
    example from the previous section, and your data set includes several measurements
    of population size over time, then you’ll want to include the population size
    in your model as well as a variable for time. In this case, it can be straightforward,
    such as using the model equation
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些模型的数学描述之外，统计模型应该与被建模系统的相关数据有某种明确的关系。通常这意味着，存在数据的值被明确地包括在模型中的变量。例如，如果你考虑上一节中的人口增长示例，并且你的数据集包括随时间变化的人口规模的几个测量值，那么你将希望在你的模型中包括人口规模以及一个时间变量。在这种情况下，这可以很简单，例如使用模型方程
- en: P = P[0]e^(rt)
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: P = P[0]e^(rt)
- en: where P is the population at time t, P[0] is the population at time zero—you
    can choose when time zero is, and then all other times are relative to that t
    = 0 point—and r is the growth rate parameter (e is still the exponential constant).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 P 表示时间 t 的人口数量，P[0] 表示初始时刻的人口数量——你可以选择时间零的具体时刻，然后所有其他时间都是相对于这个 t = 0 点的——r
    是增长率参数（e 仍然是指数常数）。
- en: Presumably, one of the goals of modeling this data is that you’d like to be
    able to predict the population at some time in the future. The data set that you
    have, a set of population sizes over time, is a collection of value pairs for
    P and t. The task is then to use these past values to find good model parameters
    that help you make good predictions about the population in the future. In this
    model, P[0] is defined to be the population when t = 0, so the only remaining,
    unknown model parameter is r. Estimating a good value for r is one of the primary
    tasks of statistical modeling in this hypothetical project.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，建模这些数据的一个目标是你希望能够预测未来某个时间点的人口数量。你所拥有的数据集，即随时间变化的人口规模集合，是 P 和 t 的值对的集合。那么任务就是使用这些过去的值来找到好的模型参数，帮助你对未来的人口做出良好的预测。在这个模型中，P[0]
    被定义为 t = 0 时刻的人口数量，因此唯一剩下的未知模型参数是 r。在这个假设项目中，估计 r 的一个良好值是统计建模的主要任务之一。
- en: 'Once you have a good estimate of the model parameter r, and given that you
    would know the value for P[0] because it’s defined by the data and the chosen
    definition for the time variable t, you’d then have a usable model of the growth
    of the population you’re studying. You can then use it to make conclusions and
    predictions about the past, present, and future state of the population. That’s
    the purpose of statistical modeling: to draw meaningful conclusions about the
    system you’re studying based on a model of that system and some data.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对模型参数 r 有了一个良好的估计，并且由于 P[0] 的值是由数据以及选择的时间变量 t 的定义所确定的，那么你将拥有一个可用的模型来描述你所研究的人口增长。然后你可以用它来对过去、现在和未来的人口状态做出结论和预测。这就是统计模型的目的：基于该系统的模型和某些数据，对该系统做出有意义的结论。
- en: In order to draw meaningful conclusions about a system via statistical modeling,
    the model has to be good, the data has to be good, and the relationship between
    them also has to be good. That’s far easier said than done. Complex systems—and
    most real-life systems are quite complex—require special care in order to make
    sure that the model and its relationship to the data are good enough to draw those
    meaningful conclusions you seek. You often have to take into account many unknowns
    and moving parts in the system. Some unknowns can be included explicitly in the
    model, such as the growth rate in the exponential population model. These are
    called *latent variables* and are described in the next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过统计模型对系统得出有意义的结论，模型必须良好，数据必须良好，它们之间的关系也必须良好。这说起来容易做起来难。复杂系统——大多数现实生活中的系统都非常复杂——需要特别注意，以确保模型及其与数据的关系足够好，以便得出你所寻求的有意义的结论。你通常必须考虑系统中的许多未知因素和变动部分。一些未知因素可以明确地包含在模型中，例如指数人口模型中的增长率。这些被称为*潜在变量*，将在下一节中描述。
- en: 7.4.2\. Latent variables
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. 潜在变量
- en: When you create a model of a system, there are some quantities that you can
    measure and some you can’t. Even among the measurable quantities, there are some
    for which you already have measurements in your data and others for which you
    don’t. In the exponential growth model, it’s fairly obvious that the growth rate
    is a quantity that exists, regardless of whether you can measure it. Even if you
    wanted to use a different model, such as a linear one, there would probably still
    be at least one variable or parameter that represents the rate of growth of the
    population. In any case, this growth parameter is probably not measurable. There
    might be some rare cases in which you could keep track of the new members of the
    population, and in that case you might be able to measure the population growth
    rate directly, but this seems unlikely. Let’s assume that the growth rate isn’t
    directly measurable or at least that you don’t have direct measurements of it
    in the data. Whenever you know a variable or parameter exists but you don’t have
    measurements of it, you call it a latent variable.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个系统的模型时，有些量是可以测量的，有些则不能。即使在可测量的量中，也有一些你在数据中已经有了测量值，而另一些则没有。在指数增长模型中，很明显，增长率是一个存在的量，无论你是否能测量它。即使你想使用不同的模型，比如线性模型，可能仍然至少有一个变量或参数代表人口的增长率。在任何情况下，这个增长参数可能不是可测量的。可能会有一些罕见的情况，你可以追踪人口的新成员，在这种情况下，你可能能够直接测量人口增长率，但这似乎不太可能。让我们假设增长率不是直接可测量的，或者至少你在数据中没有直接的测量值。每次当你知道一个变量或参数存在但你没有测量值时，你就可以称之为潜在变量。
- en: '*Latent variables*, as in the case of the growth rate parameter in an exponential
    population growth model, are often based on an intuitive concept of how a system
    works. If you know that a population is growing, you know there must be a growth
    rate, and so creating a variable for that growth rate is an intuitive thing to
    do that helps explain your system and how other variables are related. Furthermore,
    if you can draw conclusions about that growth rate, then that might be helpful
    to your project’s goals. Those are the two most common reasons to include a latent
    variable in a statistical model:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜在变量*，例如指数人口增长模型中的增长率参数，通常基于对系统如何工作的直观概念。如果你知道人口在增长，你就知道必须有一个增长率，因此为那个增长率创建一个变量是一种直观的做法，这有助于解释你的系统以及其他变量之间的关系。此外，如果你可以对该增长率得出结论，那么这可能对你的项目目标有所帮助。这是在统计模型中包含潜在变量的两个最常见原因：'
- en: The variable plays an intuitive role in how the system works.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该变量在系统如何工作方面起着直观的作用。
- en: You’d like to draw statistical conclusions about this particular variable.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望对这个特定变量得出统计结论。
- en: In either case, latent variables represent variables or quantities of which
    you’d like to know the value but can’t measure or haven’t measured for one reason
    or another. In order to use them, you have to infer them from what you know about
    other, related variables.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，潜在变量代表的是你希望知道其值但无法测量或由于某种原因尚未测量的变量或数量。为了使用它们，你必须从你对其他相关变量的了解中推断它们。
- en: In the exponential population growth model, if you know about the population
    size P at multiple time points, then it’s reasonably easy to get some idea of
    the rate of change of that population. One way would be to take the differences/changes
    in population between consecutive time points, which is pretty close to a direct
    measurement but not quite. Then the question is whether the absolute differences
    are constant over time, implying linear growth, or if they grow as the population
    grows, implying an exponential growth or something similar. If the population
    seems to be growing by a constant number every time period (for example, year,
    month, day), then linear seems better suited, but if the population seems to be
    growing by a certain percentage every time period, then an exponential model probably
    suits the system better.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在指数人口增长模型中，如果你知道在多个时间点的种群大小 P，那么了解该种群的变化率相对容易。一种方法就是计算连续时间点之间种群的变化/差异，这几乎等同于直接测量，但并不完全准确。那么问题是，这些绝对差异是否随时间保持恒定，这意味着线性增长，或者它们随着种群的增长而增长，这意味着指数增长或类似情况。如果种群似乎在每个时间段内以恒定的数量增长（例如，每年、每月、每天），那么线性模型似乎更合适，但如果种群似乎在每个时间段内以一定的百分比增长，那么指数模型可能更适合该系统。
- en: I’ll discuss model comparison later in this chapter—finding a good statistical
    model is important—but for now I’ll focus on the fact that the nature of a quantity
    that seems intuitive—the population growth rate in our example—depends heavily
    on the choice of model. It’s tempting to think that the population growth rate
    is directly measurable, but in reality, even if you could measure it, you’d still
    have to make at least the decision about whether the population grows by an absolute
    number each time period or whether it grows by a percentage each time period.
    In addition, many, many other models are also possible; linear (absolute) and
    exponential (percentage) are only the two most commonly used for population growth.
    The choice of model and the nature of its latent variables are closely related.
    Both are highly influenced by how the system works, intuitively, as well as the
    system’s relationship to the data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面讨论模型比较——找到一个好的统计模型很重要——但现在我将专注于这样一个事实：一个看似直观的数量的性质——例如，我们例子中的种群增长率——在很大程度上取决于模型的选择。人们可能会认为种群增长率是可以直接测量的，但事实上，即使可以测量，你仍然至少需要决定种群是每次以绝对数量增长还是以百分比增长。此外，还有许多其他模型也是可能的；线性（绝对）和指数（百分比）只是用于人口增长的两种最常用的模型。模型的选择及其潜在变量的性质密切相关。两者都高度受到系统如何工作的直观影响，以及系统与数据的关系。
- en: '7.4.3\. Quantifying uncertainty: randomness, variance, and error terms'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3. 量化不确定性：随机性、方差和误差项
- en: There’s always uncertainty in the estimated values of latent variables if you
    can’t measure them directly, but also even if you can. Getting near-exact values
    for latent variables and model parameters is difficult, so it’s often useful to
    explicitly include some variance and error terms in your model, which are typically
    represented by the notion of a probability distribution of values.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法直接测量潜在变量，那么对潜在变量的估计值总是存在不确定性，即使可以测量也是如此。获取潜在变量和模型参数的近似精确值是困难的，因此通常在模型中明确包含一些方差和误差项是有用的，这些项通常由值的概率分布的概念来表示。
- en: Using probability distributions in statistical models
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在统计模型中使用概率分布
- en: If a quantity described by your model has an expected value—estimated by some
    statistical method—then the variance of that quantity describes how far from the
    expected value an individual instance of that quantity might be. For example,
    if you’re modeling the height of human beings, you might find the average height
    of men to be 179.0 cm. But each individual differs from that expected value by
    some amount; each man is probably a few centimeters taller or shorter than that,
    with some men almost exactly 179.0 cm tall, and then there are the extremely tall
    and extremely short, who are 20 or 30 cm taller or shorter. This concept of the
    dispersion of values around an expected value naturally evokes the idea of a bell
    curve, or normal distribution, with which most people are familiar.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你模型描述的量有一个期望值——通过某种统计方法估计——那么该量的方差描述了该量的单个实例可能偏离期望值的程度。例如，如果你正在建模人类的身高，你可能会发现男性的平均身高为179.0厘米。但每个个体都会以某种程度偏离这个期望值；每个男人可能比这个高度高几厘米或矮几厘米，有些男人几乎正好是179.0厘米高，然后是那些极高和极矮的人，他们可能比这个高度高20或30厘米，或者矮20或30厘米。围绕期望值的价值分散的概念自然地唤起了人们熟悉的钟形曲线或正态分布的想法。
- en: Probability distributions, in general, describe precisely the dispersion of
    random values, across a range of possible values, that you’d get from a random
    process if you took a sample from it. If you observed values that are generated
    by a random process, the probability distribution for that process would tell
    you how often you’d expect to see certain values. Most people know how the normal
    distribution is shaped, and they might be able to say what percentage of values
    generated by a normally distributed random process would be above or below certain
    marks. Although the normal distribution is the most popular probability distribution,
    there are distributions of all shapes, continuous and discrete, and each of these
    carries with it a set of assumptions. The normal distribution in particular doesn’t
    deal well with outliers, so in the presence of outliers, a more robust distribution
    or method might be better. Each specific distribution has its own advantages and
    caveats, and choosing an appropriate one can have significant implications for
    your results. All randomness is not created equal, so it’s best do to a little
    investigation before settling on a particular distribution. Plenty of statistics
    literature exists for this purpose.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 概率分布通常精确地描述了从随机过程中获取的随机值的分散情况，这些随机值跨越了一组可能值。如果你观察到了由随机过程生成的值，该过程的概率分布会告诉你期望看到某些值的频率。大多数人知道正态分布的形状，他们可能能够说出由正态分布的随机过程生成的值中有多少百分比会高于或低于某些标记。尽管正态分布是最受欢迎的概率分布，但存在各种形状的分布，包括连续和离散的分布，每个分布都附带一组假设。特别是，正态分布处理异常值的能力不强，因此在存在异常值的情况下，更稳健的分布或方法可能更好。每个特定的分布都有其自身的优点和注意事项，选择一个合适的分布对你的结果可能具有重大影响。所有随机性并不相等，因此在确定特定的分布之前进行一些调查是最好的。为此目的，存在大量的统计学文献。
- en: 'The normal distribution is a probability distribution with two parameters:
    mean and variance. In the case of modeling a single quantity like human height,
    the normal distribution could describe the entire model. In that case, the system
    you’re modeling is, in some sense, a system that produces human beings of various
    heights. The mean parameter represents the height that the system is aiming for
    when it makes each human, and the variance represents how far from that mean height
    the system usually is.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正态分布是一种具有两个参数的概率分布：均值和方差。在建模单个量，例如人类身高的情况下，正态分布可以描述整个模型。在这种情况下，你正在建模的系统在某种意义上是一个产生各种身高的人的系统。均值参数代表系统在制造每个人类时追求的身高，而方差参数代表系统通常偏离该平均身高的程度。
- en: Aiming for a value and missing it by some amount is the core idea of error terms
    in statistical models. An *error* in this sense is how far off the mark the instance
    (or measurement) of the quantity is. Conceptually, this implies that every man
    should be 179.0 cm tall, but that some error in the system caused some men to
    be taller and some shorter. In statistical models, these errors are generally
    considered as unexplainable noise, and the principal concern becomes making sure
    that all the errors across all the measurements are normally distributed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 试图达到一个值，但以某种数量错过它，是统计模型中误差项的核心思想。在这个意义上，“误差”是指数量（或测量）的实例（或测量）偏离目标有多远。从概念上讲，这意味着每个男人都应该身高
    179.0 厘米，但由于系统中的一些误差，一些男人更高，一些更矮。在统计模型中，这些误差通常被视为不可解释的噪声，主要关注的是确保所有测量中的误差都是正态分布的。
- en: Formulating a statistical model with uncertainty
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 建立具有不确定性的统计模型
- en: A possible version of the human height model involving an error term is the
    equation
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及误差项的人类身高模型的一个可能版本是以下方程
- en: h[i] = h[p] + ε[i]
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: h[i] = h[p] + ε[i]
- en: where h[p] is the expected height of the human-producing system, and h[i] is
    the height of the individual with the label *i*. The error terms are represented
    by the variables ε[i], which are assumed to be normally distributed with mean
    zero and independent of each other. The Greek letter epsilon is the favored symbol
    for errors and other arbitrarily small quantities. Note that the subscript *i*
    indicates that there’s a different error for each individual. If you have a good
    estimate for h[p] and the variance for ε[i], then you have a reliable model of
    male human height. This isn’t the only way to model male human height.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 h[p] 是人类生产系统的期望身高，h[i] 是标签为 *i* 的个体的身高。误差项由变量 ε[i] 表示，这些变量被假定为具有均值为零且相互独立的高斯分布。希腊字母
    epsilon 是表示误差和其他任意小量的首选符号。请注意，下标 *i* 表示每个个体都有一个不同的误差。如果你对 h[p] 有一个好的估计，并且对 ε[i]
    的方差有了解，那么你就有了男性人类身高的可靠模型。这并不是建模男性人类身高的唯一方法。
- en: 'Because you know from experience that the height of human males varies among
    individuals, you might consider the conceptual difference between the expected
    height within a human population and the heights of the individuals. Individuals
    can be considered different instances of the same quantity or set of quantities.
    There are two conceptual reasons why different instances of the same quantity
    might vary:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因为根据经验，你了解到人类男性的身高在个体之间存在差异，你可能会考虑人类群体中期望身高与个体身高之间的概念差异。个体可以被视为相同数量或数量集的不同实例。存在两个概念上的原因，使得相同数量的不同实例可能会发生变化：
- en: The system or the measurement process is noisy.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统或测量过程是嘈杂的。
- en: The quantity itself can vary from one instance to another.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数量本身可能从一个实例变化到另一个实例。
- en: Note a subtle difference between these two reasons. The first reason is embodied
    by the notion of error terms. The second corresponds to the notion of a random
    variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这两个原因之间的微妙差异。第一个原因体现在误差项的概念中。第二个对应于随机变量的概念。
- en: Random variables possess their own inherent randomness that generally wouldn’t
    be considered noise. In the human height example, rather than calling the system
    noisy, you could assume that the system itself picks a height at random and then
    produces a human of that height, nearly exactly. This conceptual distinction does
    have benefits, particularly in more complex models. This version of the model
    might be described by
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随机变量具有它们自己的固有随机性，这通常不会被考虑为噪声。在人类身高示例中，你与其称系统是嘈杂的，不如假设系统本身随机选择一个身高，然后生产一个几乎正好是这个身高的个体。这种概念上的区分确实有好处，尤其是在更复杂的模型中。这个模型版本可能被描述为
- en: h[i] ~ N( h[p] , σ² )
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: h[i] ~ N( h[p] , σ² )
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: m[i] = h[i] + ε[i]
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: m[i] = h[i] + ε[i]
- en: where the first statement indicates that the height h[i] of individual *i* is
    generated by a random process using a normal distribution with mean h[p] and variance
    σ². The second statement indicates that the measurement of h[i] is a noisy process
    resulting in a measurement m[i]. In this case, the error term ε[i] corresponds
    only to the real-life measurement process and so would probably be only a fraction
    of a centimeter.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个陈述表明，个体 *i* 的身高 h[i] 是通过使用均值为 h[p] 和方差 σ² 的正态分布的随机过程生成的。第二个陈述表明，h[i] 的测量是一个嘈杂的过程，导致测量值为
    m[i]。在这种情况下，误差项 ε[i] 仅对应于现实生活中的测量过程，因此可能只有几厘米。
- en: It’s probably bad form to mix probability distribution notation with error term
    notation in the same model description, because they describe practically the
    same random process, but I think it’s illustrative of the conceptual difference
    between inherently random variables that are important to the model and the presumed-unexplained
    error term.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一模型描述中将概率分布符号与误差项符号混合可能是不恰当的，因为它们实际上描述的是同一个随机过程，但我认为这可以说明模型中内在随机变量（对模型很重要）和假设未解释的误差项之间的概念差异。
- en: A good example of an inherently random variable that isn’t an error term would
    appear if you were to generalize your model of male human height to also include
    women. Males around the world are consistently taller than local women, so it
    would likely be a mistake to lump men and women together in a model of human height.
    Let’s say that one of the goals of the modeling task is to be able to generate
    predictions about the height of a randomly chosen human, regardless of whether
    they are male, female, or otherwise. You could construct a model for males, as
    you did previously, and a corresponding one for females. But if you’re generating
    a prediction for the height of a randomly chosen human, you wouldn’t know definitively
    which model is more applicable, so you should include a random variable representing
    the sex of the individual. It could be a binary variable that you assume gets
    chosen first, before you make a prediction about the height from the normally
    distributed height model appropriate for that sex. This model might be described
    by the equations
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要将你的关于男性人类身高的模型推广到也包括女性，那么一个内在随机变量不是误差项的好例子就会出现。全世界男性普遍比当地女性高，所以在人类身高的模型中将男性和女性合并可能是错误的。假设建模任务的一个目标是有能力生成关于随机选择的人类身高的预测，无论他们是男性、女性还是其他性别。你可以构建一个与之前相同的男性模型，以及相应的女性模型。但如果你要生成一个关于随机选择的人类身高的预测，你将无法确定哪个模型更适用，因此你应该包括一个表示个体性别的随机变量。这可能是一个二进制变量，你假设在从适合该性别的正态分布身高模型中进行预测之前首先选择。这个模型可能可以用以下方程描述
- en: s[i] ~ B( 1, p )
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: s[i] ~ B( 1, p )
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: h[i] ~ N( h[p](s[i]), σ²(s[i]) )
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: h[i] ~ N( h[p](s[i]), σ²(s[i]) )
- en: where s[i] is the sex of the individual, which according to the first statement
    is chosen randomly from a Bernoulli distribution (a common distribution with two
    possible outcomes), where the probability of choosing female is assumed to be
    p (for two sexes, the probability of male is assumed to be 1–p). Given the individual’s
    sex s[i], the term h[p](s[i]) is intended to represent the mean height of the
    population of people matching the sex s[i], and σ²(s[i]) is the variance for people
    matching the sex s[i]. The second statement, in summary, describes how the predicted
    height is generated from a normal distribution with parameters that are determined
    by an individual’s sex, which was randomly chosen from the Bernoulli distribution.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 s[i] 表示个体的性别，根据第一条陈述，性别是从伯努利分布（一个具有两种可能结果的常见分布）中随机选择的，假设选择女性的概率为 p（对于两种性别，男性的概率假设为
    1–p）。给定个体的性别 s[i]，术语 h[p](s[i]) 的目的是表示与性别 s[i] 匹配的人群的平均身高，σ²(s[i]) 是与性别 s[i] 匹配的人的方差。第二条陈述概括地描述了如何从由个体的性别（该性别是从伯努利分布中随机选择的）确定的参数的正态分布中生成预测身高。
- en: Drawing conclusions from models involving uncertainty
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从涉及不确定性的模型中得出结论
- en: Assuming that you’ve found some good estimates for the parameters in this model,
    you can predict heights of randomly chosen individuals. Such prediction is useful
    in analysis of small sample sizes; if you, for example, chose randomly a group
    of 10 people, and you found that they averaged 161 cm in height, you might want
    to know if you didn’t have a sample that’s representative of the whole population.
    By generating height predictions from your model, in groups of 10, you can see
    how often you’d get such a small average height. If it’s a rare occurrence, then
    that would be evidence that your sample isn’t representative of the whole population,
    and you might want to take action to improve your sample in some way.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经找到了这个模型中参数的一些良好估计，你可以预测随机选择个体的身高。这种预测在分析小样本量时很有用；例如，如果你随机选择了一组 10 个人，并且他们平均身高为
    161 厘米，你可能想知道你是否没有获得一个代表整个群体的样本。通过从你的模型中生成身高预测，以 10 人为一组，你可以看到你得到如此小的平均身高的频率。如果这种情况很少发生，那么这将是你的样本不代表整个群体的证据，你可能需要采取某种措施来改善你的样本。
- en: Random variables can be helpful in statistical modeling for a number of reasons,
    not the least of which is that many real-life systems contain randomness. In describing
    such a system using a model, it’s important never to confuse the expectations
    of the model with the distributions that the model relies on. For instance, even
    though the model of human male height expects individuals to be 179.0 cm tall,
    it doesn’t mean that every human male is 179.0 cm. This may seem obvious, but
    I’ve seen many academic papers confuse the two and take a statistical shortcut
    because it would be convenient to assume that everyone is of average height. Sometimes
    it may not matter much, but sometimes it might, and it pays to figure out which
    situation you’re in. If you’re an architect or a builder, you certainly wouldn’t
    want to build doorways that are 180 cm tall; probably 40% or more of the population
    would have to duck their head to walk through, even though the average man wouldn’t.
    If you’re going to make important decisions based on your project’s conclusions,
    it’s often best to admit uncertainty at various stages, including in the statistical
    model.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 随机变量在统计建模中有许多用途，其中最不重要的是许多现实生活中的系统包含随机性。在用模型描述这样一个系统时，重要的是永远不要混淆模型的期望与模型所依赖的分布。例如，尽管人类男性身高的模型期望个体身高为179.0厘米，但这并不意味着每个男性都是179.0厘米。这看起来可能很明显，但我见过许多学术论文混淆了这两者，并采取统计捷径，因为假设每个人都具有平均身高会方便得多。有时这可能无关紧要，但有时可能很重要，弄清楚你处于哪种情况是有益的。如果你是建筑师或建筑工人，你当然不希望建造180厘米高的门廊；可能40%或更多的民众需要低头才能通过，尽管平均身高的人不需要。如果你要根据你项目的结论做出重要决策，通常最好在各个阶段承认不确定性，包括在统计模型中。
- en: I hope that this discussion of random variables, variance, and error terms has
    been illustrative of how uncertainty—which is so pervasive in all of data science—also
    works its way into statistical models. That might be an understatement; in fact,
    I consider reducing uncertainty to be the primary job of statistics. But sometimes
    in order to reduce uncertainty in the way you want, you have to admit that uncertainty
    exists within the various pieces of the model. Treating uncertainties—randomness,
    variance, or error—as certainties can lead you to overly confident results or
    even false conclusions. Both of these are uncertainties themselves, but the bad
    kind—the kind you can’t explain in a rigorous and useful manner. For that reason,
    I tend to treat every quantity as a random variable at first, only replacing it
    with a certain, fixed value after I’ve managed to convince myself rigorously that
    it’s appropriate to do so.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望关于随机变量、方差和误差项的讨论能够说明不确定性——这在整个数据科学中无处不在——是如何在统计模型中体现的。这可能是一种低估；事实上，我认为减少不确定性是统计学的首要任务。但有时为了以你想要的方式减少不确定性，你必须承认模型各个部分中存在不确定性。将不确定性——随机性、方差或误差——视为确定性可能会导致你得出过于自信的结果，甚至得出错误的结论。这两种情况本身也是不确定性，但是不良的不确定性——那种你不能以严谨和有用的方式解释的不确定性。因此，我倾向于首先将每个量视为一个随机变量，只有在严格说服自己这样做是适当的情况下，才将其替换为确定的、固定的值。
- en: 7.4.4\. Fitting a model
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.4\. 拟合模型
- en: So far, I’ve discussed models in a mostly abstract sense, without saying much
    about the relationship between the model and the data. This was intentional, because
    I believe that it’s beneficial to think about the system I intend to model and
    decide how I think the model should work before I try to apply it to data. *Fitting*
    a model to a data set is the process of taking the model that you’ve designed
    and finding the parameter values that describe the data the best. The phrase “fit
    a model” is synonymous with estimating values for a model’s parameters.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我主要是在抽象的意义上讨论模型，没有过多地谈论模型与数据之间的关系。这是故意的，因为我相信在尝试将模型应用于数据之前，考虑我打算建模的系统并决定我认为模型应该如何工作是有益的。*拟合*模型到数据集是这样一个过程：你设计了一个模型，然后找到描述数据的最佳参数值。短语“拟合模型”与估计模型参数的值同义。
- en: Model fitting is optimization, among all possible combinations of parameter
    values, of a goodness-of-fit function. *Goodness of fit* can be defined in many
    ways. If your model is intended to be predictive, then its predictions should
    be close to the eventual outcome, so you could define a closeness-of-prediction
    function. If the model is supposed to represent a population, as in the model
    of human height discussed earlier in this chapter, then you might want random
    samples from the model to look similar to the population you’re modeling. There
    can be many ways to imagine your model being close to representing the data you
    have.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 模型拟合是在所有可能的参数值组合中，对拟合优度函数进行优化。*拟合优度*可以以多种方式定义。如果你的模型旨在进行预测，那么它的预测应该接近最终结果，因此你可以定义一个预测接近度函数。如果模型旨在代表一个总体，例如在本章前面讨论的人类身高模型，那么你可能希望从模型中抽取的随机样本与你要模拟的总体相似。想象你的模型接近代表你所拥有的数据的方式可能有多种。
- en: Because there are many possible ways to define goodness of fit, deciding which
    one is best for your purposes can be confusing. But a few common functions are
    suitable for a large number of applications. One of the most common is called
    the *likelihood*, and in fact this type of function is so common and well studied
    that I recommend using it as your goodness-of-fit function unless you have a compelling
    reason not to do so. One such compelling reason is that likelihood functions are
    applicable only to models that are specified by probability distributions, so
    if you have a model that isn’t based on probability, you can’t use the likelihood.
    In that case, it would be best to check some statistical literature on model fitting
    for some more appropriate goodness-of-fit function for your model.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定义拟合优度的可能方式有很多，决定哪种最适合你的目的可能会令人困惑。但有一些常见的函数适用于大量应用。其中最常见的一种被称为*似然性*，实际上这种类型的函数非常常见且研究得很好，我建议将其作为你的拟合优度函数，除非你有充分的理由不这样做。这样的充分理由之一是，似然函数仅适用于由概率分布指定的模型，所以如果你的模型不是基于概率的，你就不能使用似然性。在这种情况下，最好查阅一些关于模型拟合的统计文献，以找到更适合你模型的拟合优度函数。
- en: The likelihood function
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 似然函数
- en: The word *likelihood* is used commonly in the English language, but it has a
    special meaning in statistics. It’s much like probability but in reverse, in a
    way.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，“似然性”这个词被广泛使用，但在统计学中它有特殊的意义。它类似于概率，但方向相反。
- en: 'When you have a model with known parameter values, you can choose a possible
    outcome arbitrarily and calculate the probability (or probability density) of
    that outcome. That’s evaluating the probability density function. If you have
    data and a model but you don’t know the parameter values for the model, you can
    sort of do the same thing in reverse: use the same probability function and calculate
    the joint probability (or probability density) for all points in the data set
    but do so over a range of model parameter values. The input to a likelihood function
    is a set of parameter values, and the output is a single number, the likelihood,
    which could also be called (somewhat improperly) the *joint probability* of the
    data. As you move the input parameter values around, you get different values
    for the likelihood of the data.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个具有已知参数值的模型时，你可以任意选择一个可能的输出结果并计算该结果的概率（或概率密度）。这就是评估概率密度函数。如果你有数据和模型，但不知道模型的参数值，你可以以相反的方式做同样的事情：使用相同的概率函数并计算数据集中所有点的联合概率（或概率密度），但这样做是在模型参数值的一定范围内。似然函数的输入是一组参数值，输出是一个单一数值，即似然性，这也可以（不完全正确地）称为数据的*联合概率*。当你移动输入参数值时，你会得到数据似然性的不同值。
- en: Probability is a function of outcomes that’s based on known parameters, and
    likelihood is a function of parameter values that’s based on known outcomes in
    a data set.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 概率是基于已知参数的输出结果的函数，而似然性是参数值函数，它基于数据集中已知的输出结果。
- en: Maximum likelihood estimation
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最大似然估计
- en: 'The *maximum likelihood* solution for a model with respect to a data set is
    exactly what it sounds like: the model parameter set that produces the highest
    value from the likelihood function, given the data. The task of *maximum likelihood
    estimation* (MLE) is to find that optimal parameter set.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据集而言，模型的*最大似然性*解正是其名称所暗示的：产生似然函数最高值的模型参数集。*最大似然估计*（MLE）的任务是找到这个最优参数集。
- en: For linear models with normally distributed error terms, MLE has a quick and
    easy mathematical solution. But that’s not the case for all models. Optimization
    is notoriously hard for large and complex parameter spaces. MLE and other methods
    that depend on optimization are searching for the highest point along a complex,
    multidimensional surface. I always picture it as a mountain-climbing expedition
    to find the highest peak in a large area that no one has ever explored. If no
    one has been to the area, and no aerial photos are available, then it’s difficult
    to find the highest peak. From the ground, you probably can see the closest peaks
    but not much farther, and if you head to the one that looks the tallest, you’ll
    usually see one that looks taller from where you are. Even worse, optimization
    is usually more akin to no-visibility mountain climbing. Along the mathematical
    surface that you’re trying to optimize, there’s usually no way to see beyond the
    immediate surroundings. Usually you know how high you are and maybe which direction
    the ground is sloping, but you can’t see far enough to find a higher point.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有正态分布误差项的线性模型，MLE有一个快速且简单的数学解决方案。但并非所有模型都如此。对于大型和复杂的参数空间，优化是出了名的困难。MLE和其他依赖于优化的方法正在寻找复杂、多维表面上最高点。我总是把它想象成一次登山探险，寻找一个大型区域中最高峰，而这个区域没有人探索过。如果没有人去过这个区域，也没有空中照片可用，那么找到最高峰就很困难。从地面上看，你可能只能看到最近的峰值，但看不到更远的地方，如果你走向看起来最高的那个，你通常会看到从你所在位置看起来更高的一个。更糟糕的是，优化通常更像是无视野的登山。在试图优化的数学表面上，通常无法看到超出直接周围的环境。通常你知道自己有多高，也许知道地面倾斜的方向，但你无法看得足够远以找到更高的点。
- en: Numerous optimization algorithms can help the situation. The simplest strategy
    is always to walk uphill; that’s called a greedy algorithm and it doesn’t work
    well unless you can guarantee that there’s only one peak in the area. Other strategies
    incorporate some randomness and use some intelligent strategies that tentatively
    head in one direction before retracing their steps if it doesn’t turn out as well
    as they hoped.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 许多优化算法可以帮助改善这种情况。最简单的策略就是一直向上走；这被称为贪婪算法，除非你能保证该区域只有一个峰值，否则它通常效果不佳。其他策略则结合了一些随机性，并使用一些智能策略，在尝试一个方向后，如果结果不如预期，就会重新调整方向。
- en: In any case, MLE tries to find the highest peak in the space of all possible
    parameter values. It’s great if you know that the highest peak is what you want.
    But in some cases it might be better to find the highest plateau that has several
    very high peaks, or you might want to get a general idea of what the whole area
    looks like before you make a decision. You can use other model-fitting methods
    to accomplish that.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，MLE试图在所有可能的参数值空间中找到最高的峰值。如果你知道最高的峰值是你想要的，那就太好了。但在某些情况下，找到有几个非常高的峰值的最高高原可能更好，或者在你做出决定之前，你可能想对整个区域有一个大致的了解。你可以使用其他模型拟合方法来完成这个任务。
- en: Maximum a posteriori estimation
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最大后验估计
- en: Maximum likelihood estimation searches for the highest peak along the surface
    of all possible model parameter values. This might not be ideal for the purposes
    of your project. Sometimes you might be more interested in finding the highest
    collection of peaks than in finding the absolute highest one.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最大似然估计在所有可能的模型参数值表面上寻找最高的峰值。这可能并不适合你项目的目的。有时你可能更感兴趣的是找到最高的峰值集合，而不是寻找绝对最高的一个。
- en: Take, for example, the Enron email data discussed at length in prior chapters
    and the project involving modeling behavior of the Enron employees based on social
    network analysis. Because social network analysis is based on a range of human
    behaviors that are, at best, fuzzy descriptions of tendencies of people to interact
    in certain ways with other people, I tend not to rely too much on any single behavior
    when making conclusions that are meaningful to the project. I would rather draw
    conclusions based on collections of behaviors, any of which could explain whatever
    phenomenon I’m looking at. Because of this, I’m also skeptical of quirky behavioral
    explanations that seem to be the best explanation of what has happened in the
    social network, when in fact if any aspect of the explanation wasn’t true, even
    a little bit, then the whole explanation and conclusion would fall apart. Finding
    a collection of pretty-good explanations would be better than finding one seemingly
    very good but potentially vulnerable explanation.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以前几章详细讨论的安然电子邮件数据为例，以及基于社会网络分析建模安然员工行为的项目。由于社会网络分析基于一系列人类行为，这些行为至多是对人们以某种方式与其他人互动的趋势的模糊描述，因此我在做出对项目有意义的结论时，往往不会过于依赖任何单一的行为。我更愿意基于行为集合得出结论，其中任何一个都可以解释我所观察到的任何现象。正因为如此，我对那些看似是社交网络中发生事件的最佳解释的奇特行为解释持怀疑态度，实际上，如果解释中的任何方面哪怕只有一点不真实，那么整个解释和结论就会崩溃。找到一系列相当不错的解释，比找到一个看似非常好但可能脆弱的解释要好。
- en: If you’re looking to find a collection of high peaks and not only the highest
    overall, then *maximum a posteriori* (MAP) methods can help. MAP methods are related
    to MLE methods, but by utilizing some values from Bayesian statistics (discussed
    later in this chapter), specifically the concept of prior distributions on variables
    of interest, MAP methods can help find a location in the model parameter space
    that’s surrounded by points that fit the data well, though not quite as well as
    the single highest peak. The choice depends on your goals and assumptions.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要找到一系列高峰值，而不仅仅是最高整体峰值，那么*最大后验概率*（MAP）方法可以帮助你。MAP方法与MLE方法相关，但通过利用贝叶斯统计（本章后面将讨论）的一些值，特别是对感兴趣变量的先验分布的概念，MAP方法可以帮助找到模型参数空间中的一个位置，该位置被拟合数据的点包围，尽管不如单个最高峰值拟合得那么好。选择取决于你的目标和假设。
- en: Expected maximization and variational Bayes
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预期最大化与变分贝叶斯
- en: Whereas both MLE and MAP methods result in point estimates of parameter values,
    both *expectation maximization* (EM) and *variational Bayes* (VB) methods find
    optimal distributions of those parameter values. I lean pretty heavily toward
    Bayesian statistics rather than frequentist statistics (discussed later in this
    chapter, in case you’re not familiar), and so methods like EM and VB appeal to
    me. Similar to how I like to treat every quantity as a random variable until I
    convince myself otherwise, I like to carry variance and uncertainty through all
    steps of modeling, including the estimated parameters and final results, if possible.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与MLE和MAP方法都导致参数值的点估计不同，*预期最大化*（EM）和*变分贝叶斯*（VB）方法找到这些参数值的最佳分布。我相当倾向于贝叶斯统计，而不是频率统计（本章后面将讨论，如果你不熟悉的话），因此EM和VB这样的方法对我有吸引力。类似于我喜欢将每个量都视为随机变量，直到我确信否则，我也喜欢在建模的所有步骤中携带方差和不确定性，包括估计的参数和最终结果，如果可能的话。
- en: Both EM and VB are distribution centric in that they try to find the best probability
    distribution for each random variable in the model, with respect to describing
    the data. If MLE finds the highest peak, and MAP finds a point surrounded by many
    high areas, then EM and VB each find an area around which you can explore in every
    direction and always be in an area of fairly high altitude. In addition to that,
    EM and VB can tell you how far you can wander before you’re in a much lower area.
    In a sense, they’re the random variable versions of MAP—but they don’t come for
    free. They can be computationally intensive and difficult to formulate mathematically.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 两者EM和VB都是基于分布的，因为它们试图为模型中的每个随机变量找到最佳概率分布，以描述数据。如果MLE找到最高的峰值，而MAP找到一个被许多高区域包围的点，那么EM和VB各自找到一个你可以从每个方向探索的区域，并且始终处于一个相对较高的海拔区域。除此之外，EM和VB还可以告诉你，在你进入一个低得多区域之前，你可以走多远。从某种意义上说，它们是MAP的随机变量版本——但它们并非免费提供。它们可能计算密集，且在数学上难以表达。
- en: The specific difference between EM and VB lies mainly in the algorithm used
    to optimize the latent variable distributions in the model. When optimizing the
    distribution of one variable, EM makes more simplifications to the assumptions
    about the other variables in the model, so EM can sometimes be less complicated
    than VB in terms of both the mathematics involved and the computational needs.
    VB considers the full estimated distributions of all random variables at all times,
    taking no shortcuts in that realm, but it does make some of the other assumptions
    that EM also does, such as independence of most variables from each other.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: EM和VB之间的具体区别主要在于优化模型中潜在变量分布所使用的算法。当优化一个变量的分布时，EM对模型中其他变量的假设进行了更多的简化，因此，在涉及到的数学和计算需求方面，EM有时可能比VB更简单。VB始终考虑所有随机变量的完整估计分布，在这个领域没有走捷径，但它也做出了EM也做出的某些假设，例如大多数变量之间的独立性。
- en: Like MLE and MAP, EM and VB are focused on finding areas within the parameter
    space that have high likelihood. The main differences are in their sensitivity
    to changes. Whereas MLE might walk off a cliff, MAP probably won’t, but it can’t
    make many guarantees beyond a single location. EM understands the surrounding
    area, and in addition to that, VB pays a little more attention to how walking
    in one direction affects the landscape in other directions. That’s the hierarchy
    of some common parameter optimization methods in a nutshell.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与MLE和MAP类似，EM和VB都专注于在参数空间中寻找具有高似然性的区域。它们的主要区别在于对变化的敏感性。MLE可能会走到悬崖边，而MAP可能不会，但它不能对单个位置之外的很多情况做出保证。EM理解周围区域，而且除此之外，VB还会稍微更多地关注向一个方向行进如何影响其他方向的地形。这就是一些常见参数优化方法的层次结构的精髓。
- en: Markov chain Monte Carlo
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 马尔可夫链蒙特卡洛
- en: Whereas MLE, MAP, EM, and VB are all optimizations methods that focus on finding
    a point or an area in the parameter space that explains the data well, *Markov
    chain Monte Carlo* (MCMC) methods are designed to explore and document the entire
    space of possible parameter values in a clever way, so that you have a topographical
    map of the whole space and can draw conclusions or explore further based on that
    map.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MLE、MAP、EM和VB都是优化方法，它们都专注于在参数空间中找到一个或一个区域来很好地解释数据，但*马尔可夫链蒙特卡洛*（MCMC）方法旨在以巧妙的方式探索和记录所有可能的参数值的空间，这样你就可以得到整个空间的地形图，并可以根据这张地图得出结论或进一步探索。
- en: Without getting into too much detail—you can find a considerable amount of literature
    on its behaviors and properties—a single MCMC sampler begins at a certain point
    in the parameter space. It then chooses at random a direction and a distance in
    which to step. Typically, the step should be small enough that the sampler doesn’t
    step over important contours, such as an entire peak, and the step should be large
    enough that the sampler could theoretically traverse (usually within a few million
    steps, at the most) the whole region of the parameter space containing reasonable
    parameter values. MCMC samplers are clever in that they tend to step into areas
    of higher likelihood, but they don’t always do so. After selecting a tentative
    place to step, they make a random decision based on the likelihood at the current
    location and the likelihood at the new, tentative location. Because they’re clever,
    if a particular region of the parameter space has about twice the likelihood of
    another region, the MCMC sampler will tend to be located in that region about
    twice as often as in the other region, as it continues to traverse the space.
    A well-tuned MCMC sampler therefore finds itself in each region of the parameter
    space approximately as often as the likelihood function would predict. This means
    that the set of step locations (samples) is a good empirical representation of
    the optimal probability distributions of the model parameters.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节——你可以找到大量关于其行为和特性的文献——单个MCMC采样器从参数空间的一个特定点开始。然后它随机选择一个方向和距离来移动。通常，步长应该足够小，以至于采样器不会跨越重要的轮廓，例如整个峰值，并且步长应该足够大，以至于采样器理论上可以穿越（通常最多几百万步）包含合理参数值的整个参数空间区域。MCMC采样器很聪明，它们倾向于进入似然性更高的区域，但并不总是这样做。在选择一个暂定的步点后，它们根据当前位置和新的暂定位置的似然性做出随机决策。由于它们很聪明，如果参数空间的一个特定区域比另一个区域的似然性高约两倍，那么MCMC采样器在继续穿越空间时，位于该区域的频率大约是另一个区域的两倍。因此，调整良好的MCMC采样器发现自己位于参数空间的每个区域中的频率大约与似然函数预测的频率相同。这意味着步长位置（样本）集合是对模型参数最优概率分布的良好经验表示。
- en: To make sure that the set of samples does represent the distributions well,
    it’s usually best to start several MCMC samplers—ideally many of them—in different
    locations around the parameter space and then watch to see if they all, after
    some number of steps, tend to give the same picture of the landscape based on
    their step locations. If all the samplers tend to be mingling around the same
    areas repeatedly and in the same proportions, then the MCMC samplers are said
    to have *converged*. Some heuristic convergence diagnostics have been developed
    specifically for judging whether convergence has occurred in a meaningful sense.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保样本集能够很好地代表分布，通常最好在参数空间的不同位置启动几个MCMC采样器——理想情况下是很多个——然后观察它们在经过一定步骤后是否都会给出基于它们步骤位置的相同景观图。如果所有采样器都倾向于反复在相同区域以相同比例混合，那么这些MCMC采样器就被说成是*收敛了*。已经开发了一些启发式收敛诊断方法，专门用于判断是否在有意义的意义上发生了收敛。
- en: On the one hand, MCMC usually requires less software development than the other
    methods, because all you need is the goodness-of-fit function and a statistical
    software package that has MCMC implemented (of which there are many). The other
    model-fitting algorithms I’ve mentioned often require manipulations of the goodness-of-fit
    function and various other model-specific optimization functions in order to find
    their solution, but not MCMC. MCMC can be off and running as long as you have
    a model specified mathematically and a data set to operate on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，MCMC通常比其他方法需要的软件开发工作要少，因为你只需要一个拟合优度函数和一个实现了MCMC的统计软件包（这样的软件包有很多）。我提到的其他模型拟合算法通常需要操作拟合优度函数和各种其他特定于模型的优化函数，以便找到它们的解，但MCMC不需要。只要指定了数学模型并有一个数据集可以操作，MCMC就可以立即开始运行。
- en: On the downside, MCMC generally needs considerably more computational power
    than the others, because it explores the model parameter space randomly—albeit
    cleverly—and evaluates the altitude at every point at which it lands. It tends
    to stick around higher peaks but doesn’t stay there exclusively and commonly roves
    far enough to find another good peak. Another drawback of MCMC is that whether
    it is exploring the space cleverly or not is usually determined by a set of tuning
    parameters for the algorithm itself. If the tuning parameters aren’t set correctly,
    you can get poor results, so MCMC needs some babysitting. On a brighter note,
    some good evaluation heuristics have been implemented in common software packages
    that can quickly give you a good idea about whether your tuning parameters are
    set adequately.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在缺点方面，MCMC通常需要比其他方法多得多的计算能力，因为它随机地探索模型参数空间——尽管是巧妙地——并在它落下的每一个点上评估高度。它倾向于停留在更高的山峰周围，但并不总是停留在这里，并且通常会足够远地漫游以找到另一个好的山峰。MCMC的另一个缺点是，它是否巧妙地探索空间通常是由算法本身的调整参数集决定的。如果调整参数设置不正确，你可能会得到较差的结果，因此MCMC需要一些监护。然而，从另一个角度来看，一些好的评估启发式方法已经集成到常见的软件包中，这些方法可以快速让你了解你的调整参数是否设置得当。
- en: In general, MCMC is a great technique for fitting models that don’t have another
    obviously better choice for fitting them. On the one hand, MCMC should be able
    to fit almost any model, at the cost of increased computation time as well as
    the babysitting and checking of evaluative heuristics. To be fair, other model-fitting
    methods also require some babysitting and evaluative heuristics but probably not
    quite as much as MCMC.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，MCMC是一种非常适合拟合没有其他明显更好的选择来拟合的模型的优秀技术。一方面，MCMC应该能够拟合几乎任何模型，代价是增加的计算时间以及监护和评估启发式方法的检查。公平地说，其他模型拟合方法也要求一些监护和评估启发式方法，但可能没有MCMC那么多。
- en: Over-fitting
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过度拟合
- en: Over-fitting is not a method of fitting a model, but it’s related; it’s something
    bad that can happen inadvertently while fitting a model. *Over-fitting* is the
    term most commonly used to refer to the idea that a model might seem to fit the
    data well, but if you get some new data that should be consistent with the old
    data, the model doesn’t fit that data well at all.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 过度拟合不是拟合模型的方法，但它与之相关；这是在拟合模型时可能意外发生的一些不好的事情。“过度拟合”是最常用来指代这样一个观点：一个模型可能看起来很好地拟合数据，但如果你得到一些应该与旧数据一致的新数据，模型根本不适合那些数据。
- en: This is a common occurrence in modeling the stock market, for example. It seems
    that right when someone finds a pattern in stock prices, that pattern ceases.
    The stock market is a complex environment that produces a ton of data, so if you
    take a thousand or a million specific price patterns and check to see whether
    they fit the data, at least one of them will seem to fit. This is especially true
    if you tune the parameters of the pattern (for example, “This stock price usually
    goes up for four days and then down for two days”) to best explain past data.
    This is over-fitting. The pattern and the model might fit the data that you have,
    but they probably won’t fit the data that comes in next.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在股票市场建模中，这是一个常见的现象。似乎就在有人发现股票价格模式的时候，那个模式就消失了。股票市场是一个复杂的环境，产生了大量的数据，所以如果你检查一千或一百万个特定的价格模式，看看它们是否与数据相符，至少有一个看起来是相符的。这尤其适用于你调整模式参数（例如，“这种股票价格通常上涨四天，然后下跌两天”）以最好地解释过去的数据。这是过度拟合。模式和模型可能适合你有的数据，但它们可能不适合接下来进入的数据。
- en: Certainly, the model should fit the data well, but that’s not the most important
    thing. The most important thing is that the model serves the purposes and goals
    of the project. To that end, I like to have a general idea of how a model should
    look and which aspects of it are indispensable to my project before I begin applying
    it to data. Using previous exploratory data assessment to inform model design
    is a good idea, but letting the data design your model for you is probably not.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模型应该很好地拟合数据，但这不是最重要的。最重要的是，模型应该服务于项目的目的和目标。为此，我在开始将模型应用于数据之前，喜欢对模型的外观有一个大致的了解，以及它哪些方面对我的项目是不可或缺的。使用先前的探索性数据评估来指导模型设计是一个好主意，但让数据为你设计模型可能不是。
- en: Over-fitting can happen for a few reasons. If you have too many parameters in
    your model, then the model’s parameter values, after they’ve already explained
    the real phenomena in your data, will begin to explain fake phenomena that don’t
    exist, such as peculiarities in your data set. Over-fitting can also happen when
    your data has some serious peculiarities that aren’t present in most of the data
    you could expect to receive in the future. If you’re modeling written language,
    then having a corpus full of Enron emails or children’s books will result in models
    that fit your data set well but don’t fit the entire body of the written English
    language well.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 过拟合可能由几个原因引起。如果你的模型中有太多参数，那么在模型参数值已经解释了你的数据中的真实现象之后，它们将开始解释不存在于数据集中的虚假现象，例如数据集中的异常。当你的数据有一些严重的异常，而这些异常在你可以预期在未来收到的数据中大部分都不存在时，也可能发生过拟合。如果你正在模拟书面语言，那么一个充满安然电子邮件或儿童书籍的语料库将导致模型很好地拟合你的数据集，但并不很好地拟合整个书面英语语言。
- en: Two techniques that are valuable in checking for over-fitting of your model
    are train-test separation and cross-validation. In *train-test separation*, you
    train (fit) your model based on some of your data, the training data, and then
    you test your model on the rest of the data, the test data. If you’re over-fitting
    your model to the training data, it should be pretty obvious when you make predictions
    about your test data that you’re way off.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查模型过拟合方面，两种有价值的技术是训练-测试分离和交叉验证。在*训练-测试分离*中，你根据你的一些数据，即训练数据，来训练（拟合）你的模型，然后你在剩下的数据，即测试数据上测试你的模型。如果你过度拟合了训练数据，那么当你对测试数据进行预测时，你应该很明显地发现你偏离得很远。
- en: Likewise, *cross-validation* refers to the process of doing repeated train-test-separated
    evaluations based on different (often random) partitions of the data. If the predictions
    made based on training data match the outcomes on the test data in several replicates
    of cross-validation, you can be reasonably sure that your model will generalize
    to similar data. On the other hand, there can be many reasons why new data will
    be different from old data, and if you’ve cross-validated only on old data, you
    have no guarantee that new data will also fit the model. That’s the curse of the
    stock market, among other systems, and it can be circumvented only by careful
    application and testing of models and understanding of data.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，*交叉验证*指的是基于数据的不同（通常是随机）分区进行重复的训练-测试分离评估的过程。如果基于训练数据做出的预测在交叉验证的几个重复中与测试数据的输出相匹配，你可以合理地确信你的模型将泛化到类似的数据。另一方面，新数据可能不同于旧数据的原因有很多，如果你只在旧数据上进行了交叉验证，你就无法保证新数据也会适合模型。这就是股市等系统中的诅咒，只能通过仔细应用和测试模型以及理解数据来规避。
- en: 7.4.5\. Bayesian vs. frequentist statistics
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.5. 贝叶斯统计与频率统计
- en: Although both have existed since at least the eighteenth century, frequentist
    statistics were far more popular than Bayesian statistics for most of the twentieth
    century. Over the last few decades, there has been a debate—I’ll stop short of
    saying *feud*—over the merits of one versus the other. I don’t want to fan the
    flames of the debate, but the two schools of statistics are mentioned in conversation
    and in literature often enough that it’s helpful to have a decent idea of what
    they’re about.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两者至少自18世纪以来就存在，但在20世纪的大部分时间里，频率统计比贝叶斯统计更受欢迎。在过去的几十年里，关于两者优缺点的争论一直存在——我甚至不敢说成是*纷争*——但我不会煽动这场争论的火焰。我不想加剧争论，但这两派统计学在对话和文献中经常被提及，因此了解它们的内容是有帮助的。
- en: The primary difference between the two is a theoretically interpretive one that
    does have an impact on how some statistical models work. In *frequentist* statistics,
    the concept of confidence in a result is a measure of how often you’d expect to
    get the same result if you repeated the experiment and analysis many times. A
    95% confidence indicates that in 95% of the replicates of the experiment, you’d
    draw the same conclusion. The term *frequentist* stems from the notion that statistical
    conclusions are made based on the expected frequency, out of many repetitions,
    of a particular event happening.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别是一个理论上的解释性区别，这确实对某些统计模型的工作方式有影响。在*频率统计*中，结果置信度的概念是衡量你重复实验和分析多次时预期得到相同结果的频率。95%的置信度表示在实验的95%重复中，你会得出相同的结论。*频率统计*这个术语来源于这样一个观点，即统计结论是基于许多重复中某个事件发生的预期频率得出的。
- en: '*Bayesian* statistics holds more closely to the concept of probability. Results
    from Bayesian statistical inference, instead of having a frequentist confidence,
    are usually described using probability distributions. In addition, Bayesian probabilities
    can be described intuitively as a degree of belief that a random event is going
    to happen. This is in contrast with frequentist probability, which describes probability
    as a relative frequency of certain random events happening in an infinite series
    of such events.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*贝叶斯*统计学更紧密地遵循概率的概念。贝叶斯统计推断的结果，而不是具有频率主义的置信度，通常使用概率分布来描述。此外，贝叶斯概率可以直观地描述为对随机事件将要发生的信念程度。这与频率主义概率形成对比，频率主义概率描述概率为在无限系列的事件中某些随机事件发生的相对频率。'
- en: To be honest, for many statistical tasks it doesn’t make a difference whether
    you use a frequentist or Bayesian approach. Common linear regression is one of
    them. Both approaches give the same result if you apply them in the most common
    way. But there are some differences between the two approaches that result in
    some practical differences, and I’ll discuss those here.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，对于许多统计任务来说，你使用频率主义还是贝叶斯方法并没有太大区别。常见的线性回归就是其中之一。如果你以最常见的方式应用它们，两种方法都会给出相同的结果。但两种方法之间有一些差异，这些差异导致了实际上的差异，我将在下面讨论。
- en: 'Disclaimer: I’m primarily a Bayesian, but I’m not so one-sided as to say that
    frequentist approaches are bad or inferior. Mainly I feel that the most important
    factor in deciding on an approach is understanding what assumptions each of them
    carries implicitly. As long as you understand the assumptions and feel they’re
    suitable, either approach can be useful.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 声明：我主要是一个贝叶斯主义者，但我不至于偏颇到说频率主义方法不好或低劣。主要我觉得决定采用哪种方法最重要的因素是理解它们各自隐含的假设。只要你能理解这些假设并觉得它们是合适的，两种方法都可以是有用的。
- en: Prior distributions
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 先验分布
- en: Bayesian statistics and inference require that you hold a prior belief about
    the values of the model parameters. This prior belief should technically be formulated
    before you begin analyzing your main data set. But basing your prior belief on
    your data is part of a technique called *empirical Bayes*, which can be useful
    but is frowned on in some circles.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 贝叶斯统计学和推断要求你对模型参数的值持有先验信念。从技术上讲，你应该在开始分析主要数据集之前制定这种先验信念。但基于你的数据来建立先验信念是称为*经验贝叶斯*的技术的一部分，这可能是有用的，但在某些圈子中不受欢迎。
- en: A prior belief can be as simple as “I think this parameter is pretty close to
    zero, give or take one or two,” which can be translated formally into a normal
    distribution or another appropriate distribution. In most cases, it’s possible
    to create non-informative (or *flat*) priors, which are designed to tell your
    statistical model “I don’t know,” in a rigorous sense. In any case, a prior belief
    must be codified into a probability distribution that becomes part of the statistical
    model. In the microarray protocol comparison example from earlier in this chapter,
    the hyper-parameters that I described are the parameters of the prior distributions
    for some of the model parameters.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 先验信念可能很简单，比如“我认为这个参数接近于零，上下浮动一两个单位”，这可以正式地转化为正态分布或其他适当的分布。在大多数情况下，可以创建非信息性（或*平坦*）的先验，这些先验被设计用来告诉你的统计模型“我不知道”，在严谨的意义上。无论如何，先验信念必须被编码成一个概率分布，成为统计模型的一部分。在本章前面提到的微阵列协议比较示例中，我描述的超参数是某些模型参数的先验分布的参数。
- en: Some frequentist statisticians take exception to the necessity of formulating
    such a prior distribution. Apparently they think that you shouldn’t have to formulate
    a prior belief if you know absolutely nothing about the model’s parameter values
    prior to seeing the data. I’m tempted to agree with them, but the existence in
    most cases of non-informative prior distributions allows Bayesians to sidestep
    the requirement for a prior distribution by making it irrelevant. In addition,
    the frequentist statistics concept of having no prior belief, if you attempted
    to formalize it, would look a lot like a non-informative prior in Bayesian statistics.
    You might conclude that frequentist methods often have an implied prior distribution
    that isn’t denoted explicitly. With this, I don’t mean to say that frequentists
    are wrong and that Bayesian methods are better; instead, I intend to illustrate
    how the two approaches can be quite similar and to debunk the notion that the
    requirement of having a prior belief is somehow a disadvantage.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一些频率统计学家反对制定这样的先验分布的必要性。显然他们认为，如果你在看到数据之前对模型的参数值一无所知，你不需要制定先验信念。我倾向于同意他们的观点，但在大多数情况下，非信息先验分布的存在使得贝叶斯统计学家可以通过使其无关紧要来规避先验分布的要求。此外，如果你试图形式化频率统计学的无先验信念概念，它将非常类似于贝叶斯统计学中的非信息先验。你可能会得出结论，频率统计方法通常有一个隐含的先验分布，而这个先验分布并没有明确表示。我并不是说频率统计学家是错误的，贝叶斯方法是更好的；相反，我旨在说明这两种方法可以非常相似，并驳斥先验信念要求的必要性是一种劣势的观点。
- en: Updating with new data
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用新数据更新
- en: I’ve explained how the existence of a prior distribution in Bayesian statistics
    isn’t a disadvantage, because most of the time you can use a non-informative prior.
    Now I’ll explain how priors are not only not bad but also good.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经解释了贝叶斯统计中先验分布的存在并不是一个缺点，因为大多数情况下你可以使用非信息先验。现在我将解释先验不仅不是坏事，而且是好事。
- en: One of most commonly cited differences between frequentist and Bayesian statistics,
    along with “You have to have a prior,” is “You can update your models with new
    data without having to include the old data as well.” The way to accomplish this
    is quite simple in a Bayesian framework.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最常引用的频率统计和贝叶斯统计之间的差异之一，除了“你必须有一个先验”之外，还有“你可以用新数据更新你的模型，而无需包括旧数据。”在贝叶斯框架中实现这一点非常简单。
- en: Let’s assume that a while back you had a statistical model, and you received
    your first batch of data. You did a Bayesian statistical analysis and fit your
    model using non-informative priors. The result of fitting a Bayesian model is
    a set of parameter distributions called *posterior distributions* because they’re
    formed after the data has been incorporated into the model. Prior distributions
    represent what you believe before you let the model see the data, and posterior
    distributions are the new beliefs based on your prior beliefs, plus the data that
    the model saw.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你之前有一个统计模型，并且收到了第一批数据。你使用非信息先验进行了贝叶斯统计分析，并拟合了你的模型。拟合贝叶斯模型的结果是一组参数分布，称为*后验分布*，因为它们是在数据被纳入模型之后形成的。先验分布代表你在让模型查看数据之前所相信的，而后验分布是基于你的先验信念以及模型所看到的数据形成的新信念。
- en: Now you’re getting more data. Instead of digging up the old data and refitting
    the model to all the data at once, using the old non-informative priors you can
    take the posterior distributions based on the first set of data and use those
    as your prior distributions for fitting the model to the second set of data. If
    the size of your data sets or computational power is a concern, then this technique
    of Bayesian updating can save considerable time and effort.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在获取更多数据。你不需要挖掘旧数据，一次性将模型拟合到所有数据上，使用旧的非信息先验，你可以根据第一批数据取后验分布，并将其作为拟合第二批数据的先验分布。如果你的数据集大小或计算能力是一个问题，那么这种贝叶斯更新技术可以节省相当多的时间和精力。
- en: Today, with so many real-time analytics services under development, Bayesian
    updating provides a way to analyze large quantities of data on the fly, without
    having to go back and reexamine all the past data every time you want a new set
    of results.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着许多实时分析服务的开发，贝叶斯更新提供了一种方法，可以在不重新检查所有过去数据的情况下，即时分析大量数据。
- en: Propagating uncertainty
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传播不确定性
- en: Of all the differences between frequentist and Bayesian statistics, I like this
    one the most, though I haven’t heard it mentioned that often. In short, because
    Bayesian statistics holds close the notion of probability—it begins with a prior
    probability distribution and ends with a posterior probability distribution—it
    allows uncertainty to propagate through quantities in the model, from old data
    sets into new ones and from data sets all the way into conclusions.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在频率统计和贝叶斯统计之间的所有差异中，我最喜欢这个，尽管我很少听到有人提到它。简而言之，因为贝叶斯统计紧紧抓住概率这一概念——它从先验概率分布开始，以后验概率分布结束——它允许不确定性在模型中的数量中传播，从旧数据集传播到新数据集，并从数据集一直传播到结论。
- en: I’ve mentioned several times in this book that I’m a big fan of admitting when
    uncertainty exists and keeping track of it. By promoting probability distributions
    to first-class citizens, as Bayesian statistics does, each piece of the model
    can carry its own uncertainty with it, and if you continue to use it properly,
    you won’t find yourself being overconfident in the results and therefore drawing
    false conclusions.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我多次提到我是一个承认存在不确定性并跟踪它的忠实粉丝。通过将概率分布提升为第一类公民，正如贝叶斯统计所做的那样，模型的每一部分都可以携带自己的不确定性，如果你继续正确地使用它，你就不会发现自己对结果过于自信，从而得出错误的结论。
- en: My favorite of the few academic papers that I published in the field of bioinformatics
    emphasizes this exact concept. The main finding of that paper, called “Improved
    Inference of Gene Regulatory Networks through Integrated Bayesian Clustering and
    Dynamic Modeling of Time-Course Expression Data” (PloS ONE, 2013)—the title rolls
    off the tongue, doesn’t it?—showed how high technical variances in gene expression
    measurements can be propagated from the data, through the Bayesian model, and
    into the results, giving a more accurate characterization of which genes interact
    with which others. Most prior work on the same topic completely ignored the technical
    variances and assumed that each gene’s expression level was merely the average
    of the values from the technical replicates. Frankly, I found this absurd, and
    so I set out to rectify it. I may not quite have succeeded in that goal, as implied
    by the paper having so few citations, but I think it’s a perfect, real-life example
    of how admitting and propagating uncertainty in statistical analysis leads to
    better results. Also, I named the algorithm I presented in the paper *BAyesian
    Clustering Over Networks*, also known as BACON, so I have that going for me.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我在生物信息学领域发表的几篇学术论文中，我最喜欢的就是强调这个确切的概念。那篇论文的主要发现，称为“通过综合贝叶斯聚类和时间序列表达数据的动态建模改进基因调控网络推断”（PloS
    ONE，2013）——标题听起来怎么样？——展示了基因表达测量中的高技术差异是如何从数据传播到贝叶斯模型，再传播到结果中，从而更准确地描述了哪些基因与哪些其他基因相互作用。在相同主题的先前工作中，大多数研究完全忽略了技术差异，并假设每个基因的表达水平仅仅是技术重复值平均的结果。坦白说，我觉得这很荒谬，所以我着手纠正它。正如论文引用次数如此之少所暗示的，我可能并没有完全达到那个目标，但我认为这是一个完美的、现实生活中的例子，说明了在统计分析中承认和传播不确定性如何导致更好的结果。此外，我在论文中提出的算法命名为*BAyesian
    Clustering Over Networks*，也称为BACON，所以我有这个优势。
- en: 7.4.6\. Drawing conclusions from models
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.6. 从模型中得出结论
- en: 'With all this talk about designing models, building models, and fitting models,
    I feel I’ve almost lost track of the real purpose of statistical modeling: to
    learn about the system you’re studying.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于设计模型、构建模型和拟合模型的讨论中，我感觉我几乎失去了统计建模的真正目的：了解你正在研究的系统。
- en: A good statistical model contains all of the system’s variables and quantities
    that you’re interested in. If you’re interested in the worldwide average female
    height, that should be a variable in your model. If you’re interested in the gene-expression
    differences between male and female fruit flies, that should be in your model.
    If it’s important to you and your project to know about the responsiveness of
    Enron employees to incoming emails, you should have a variable that represents
    responsiveness in your model. Then the process of fitting the model, using whichever
    methods you choose, results in estimates for those variables. In the case of latent
    model parameters, fitting the model produces parameter estimates directly. In
    the case of predictive modeling, in which a prediction is a latent variable in
    the future (from the future?), the fitted model can generate an estimated value,
    or prediction.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的统计模型应包含你感兴趣的系统中所有变量和数量。如果你对全球女性的平均身高感兴趣，那么这应该成为你模型中的一个变量。如果你对雄性和雌性果蝇的基因表达差异感兴趣，那么这也应该包含在你的模型中。如果你和你项目的重要部分是了解恩隆员工对收到的电子邮件的反应性，那么你应该有一个代表反应性的变量在你的模型中。然后，使用你选择的方法拟合模型的过程，将产生这些变量的估计值。在潜在模型参数的情况下，拟合模型直接产生参数估计。在预测建模的情况下，其中预测是未来的一个潜在变量（从未来？），拟合的模型可以生成估计值或预测。
- en: Drawing conclusions based on your fitted model comes in many forms. First, you
    have to figure out what questions you want to ask of it. Consult the list of questions
    you generated during the planning phase of your project, discussed in the early
    chapters of this book. Which ones can the model help answer? A well-designed model,
    for the purposes of your project, should be able to answer many if not all of
    the project’s questions regarding the system in question. If it can’t, you may
    have to create a new model that can. It would be a shame to have to rebuild a
    model, but it’s better than using a bad or unhelpful model. You can avoid this
    type of situation by maintaining awareness of the project’s goals at all times,
    specifically the aspects of the project that this statistical model was intended
    to address.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你的拟合模型得出结论的形式有很多种。首先，你必须弄清楚你想向它提出哪些问题。参考你在项目规划阶段生成的列表，这些列表在本书的前几章中讨论过。模型能帮助回答哪些问题？为了你的项目目的，一个设计良好的模型应该能够回答关于所讨论系统的许多问题，如果不是所有问题。如果它做不到，你可能需要创建一个新的模型。重建模型虽然令人遗憾，但比使用一个糟糕或无用的模型要好。你可以通过始终保持对项目目标的意识来避免这种情况，特别是这个统计模型旨在解决的项目方面。
- en: 'Let’s say that many of the questions from the project’s planning phase involve
    variables and quantities that are represented in your model. For each of these
    variables, the model-fitting process has produced value estimates or probability
    distributions. You can ask two main types of questions of these estimates:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 假设项目规划阶段提出的问题中涉及许多变量和数量，这些变量和数量在你的模型中都有所表示。对于这些变量中的每一个，模型拟合过程都产生了价值估计或概率分布。你可以对这些估计提出两种主要类型的问题：
- en: What is the value of the variable, approximately?
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个变量的值大约是多少？
- en: Is this variable greater/less than X?
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个变量是否大于/小于X？
- en: I’ll cover the techniques to address each of these questions in their own subsections.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在各自的子节中介绍解决这些问题的技术。
- en: What’s the value? Estimates, standard error, and confidence intervals
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 值是多少？估计值、标准误差和置信区间
- en: All the model-fitting methods I described earlier produce best guesses—called
    *point estimates*—of variables and parameters in a model. Most but not all of
    them also give some measure of uncertainty of that value. Depending on which specific
    algorithm you’re using, MLE may not produce such a measure of uncertainty automatically,
    so if you need it, you may have to find an algorithm that produces one. All the
    other model-fitting methods give the uncertainty as an inherent output of the
    model-fitting process.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前描述的所有模型拟合方法都产生了模型中变量和参数的最佳猜测，称为*点估计*。大多数但并非所有这些方法也给出了一些关于该值不确定性的度量。根据你使用的特定算法，最大似然估计（MLE）可能不会自动产生这种不确定性的度量，所以如果你需要它，你可能需要找到一个产生这种度量的算法。所有其他模型拟合方法都将不确定性作为模型拟合过程的固有输出。
- en: If all you need is a point estimate, then you’re good to go. But if, as is usually
    the case, you want some sort of guarantee that the value is approximately what
    you think it is, then you’ll need either a probability distribution or a standard
    error. A *standard error* for a parameter estimate is the frequentist equivalent
    of a standard deviation (square root of variance) of a probability distribution.
    In short, you can be 95% confident that a parameter is within two standard errors
    of its point estimate or 99.7% confident that it’s within three standard errors.
    These are *confidence intervals*, and if the standard error is relatively small,
    then the confidence intervals will be narrow, and you can be reasonably (whichever
    percentage you choose) sure that the true value falls within the interval.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个点估计值，那么你就可以继续了。但如果你通常想要某种保证，即该值大约是你所认为的那样，那么你需要一个概率分布或标准误差。参数估计的标准误差是频率派标准差（方差的平方根）的概率分布的等价物。简而言之，你可以有95%的信心认为参数在其点估计值的两倍标准误差内，或者有99.7%的信心认为它在三倍标准误差内。这些都是**置信区间**，如果标准误差相对较小，那么置信区间将较窄，你可以合理地（无论你选择多少百分比）确信真实值落在区间内。
- en: The Bayesian equivalents of standard error and confidence intervals are *variance*
    and *credible intervals*, respectively. They work almost exactly the same but,
    as usual, differ on philosophical grounds. Given that a Bayesian parameter estimate
    is a probability distribution, you can naturally extract the variance and create
    credible intervals such that for a normal distribution, the probability is 95%
    that the true value is within two standard deviations of the mean, and 99.7% that
    it’s within three standard deviations.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 标准误差和置信区间的贝叶斯等价物分别是**方差**和**可信区间**。它们几乎以完全相同的方式工作，但正如通常那样，它们在哲学基础上有所不同。鉴于贝叶斯参数估计是一个概率分布，你可以自然地提取方差并创建可信区间，对于正态分布，真实值在均值两倍标准差内的概率是95%，在均值三倍标准差内的概率是99.7%。
- en: Sometimes reporting a value or an interval addresses one of the goals of your
    project. But other times you might want to know a little more—for example, whether
    the variable possesses a specific property, such as being greater or less than
    a certain amount. For this you need hypothesis testing.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有时报告一个值或一个区间可以解决你项目的一个目标。但有时你可能想了解更多——例如，变量是否具有特定的属性，比如是否大于或小于某个特定数量。为此，你需要假设检验。
- en: Is this variable _______? Hypothesis testing
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 这个变量 _______？ 假设检验
- en: 'Often you need to know more about a variable than merely a point estimate or
    a range of values that probably contain the true value. Sometimes it’s important
    to know whether a variable possesses a certain property or not, such as these:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要了解一个变量比仅仅是一个点估计值或可能包含真实值的值域更多。有时，了解变量是否具有某些属性很重要，比如这些：
- en: Is the variable X greater than 10?
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量X是否大于10？
- en: Is the variable X less than 5?
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量X是否小于5？
- en: Is the variable X non-zero?
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量X是否为零？
- en: Is the variable X substantially different from another variable Y?
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量X是否与另一个变量Y有显著差异？
- en: Each of these questions can be answered by a hypothesis test. A *hypothesis
    test* consists of a null hypothesis, an alternative hypothesis, and then a statistical
    test that fits the two hypotheses.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题中的每一个都可以通过假设检验来回答。一个**假设检验**包括一个零假设，一个备择假设，然后是一个适合这两个假设的统计检验。
- en: 'A *null* hypothesis is kind of the status quo. If this hypothesis was true,
    it would be kind of boring. An alternative hypothesis is a hypothesis that, if
    true, would be exciting. For instance, let’s say you think that the variable X
    is greater than 10, and if this was true, it would have cool implications for
    the project (maybe X is the number of song downloads, in millions, that are expected
    to happen next week). “X is greater than 10” is a good alternative hypothesis.
    The null hypothesis would be the inverse: “X is not greater than 10.” Now, because
    you want the alternative hypothesis to be true, you need to show beyond a reasonable
    doubt that the null hypothesis is not true. In statistics, you generally never
    prove that something is true so much as show that the other possibility, the null
    hypothesis, is almost certainly not true. It’s a subtle distinction, linguistically,
    that has a fairly large impact mathematically.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**零假设**就像是现状。如果这个假设是真的，那就会显得有些无聊。备择假设是一种假设，如果它是真的，那就会令人兴奋。例如，假设你认为变量X大于10，如果这是真的，那么它将对项目产生一些有趣的影响（比如X可能是下周预期下载的百万级歌曲数量）。“X大于10”是一个好的备择假设。零假设则是其对立面：“X不大于10。”现在，因为你希望备择假设是真的，所以你需要证明零假设不是真的，并且要有合理的怀疑。在统计学中，你通常不是证明某事是真的，而是证明另一种可能性，即零假设，几乎肯定不是真的。在语言上这是一个细微的差别，但在数学上却有着相当大的影响。'
- en: To test the null and alternative hypotheses in the example and to reject the
    null, as they say, you need to show that the value of X almost certainly wouldn’t
    venture below 10\. Let’s say that the posterior probability distribution for X
    based on your model is normally distributed with a mean of 16 and a standard deviation
    of 1.5\. It’s important to note that this is a one-sided hypothesis test, because
    you care only if X is too low (below 10) and not if it’s too high. Choosing the
    correct version of the test (one-sided or two-sided) can make a difference in
    the significance of your results.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试零假设和备择假设，并拒绝零假设，正如他们所说，你需要证明X的值几乎肯定不会低于10。假设基于你的模型，X的后验概率分布是正态分布，均值为16，标准差为1.5。重要的是要注意，这是一个单侧假设检验，因为你只关心X是否太低（低于10），而不关心它是否太高。选择正确的检验版本（单侧或双侧）可能会影响你结果的显著性。
- en: You need to check whether 10 is beyond a reasonable threshold of how low X might
    be. Let’s choose a significance of 99% because you want to be sure that X isn’t
    below 10\. Consulting a reference for a one-sided test, the 99% threshold is 2.33
    standard deviations. You’ll notice that the estimate of 16 is 4.0 standard deviations
    above 10, meaning that you can be almost certain, and definitely more than 99%
    certain, that the value of X is above 10.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要检查10是否超出了X可能有多低的合理阈值。让我们选择99%的显著性水平，因为你想要确保X不会低于10。参考单侧检验的参考数据，99%的阈值是2.33个标准差。你会注意到16的估计值比10高4.0个标准差，这意味着你可以几乎肯定，并且肯定超过99%的把握，X的值是高于10的。
- en: I could hardly talk about hypothesis testing without at least mentioning p-values.
    You can find much more thorough explanations elsewhere, but a *p-value* is the
    inverse of confidence (1 minus confidence, or 99% confidence, corresponds to p<0.01)
    and represents the frequentist concept of the chance that a hypothesis test ended
    up giving you an incorrect answer. It’s important not to treat a p-value in frequentist
    statistics like a probability in Bayesian statistics. P-values should be used
    for thresholding of hypothesis test results and nothing else.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎不能不提到p值就谈论假设检验。你可以在其他地方找到更详尽的解释，但**p值**是置信度的倒数（1减去置信度，或99%的置信度对应于p<0.01），它代表了频率主义中假设检验最终给出错误答案的概率。在频率主义统计学中，不要将p值视为贝叶斯统计学中的概率。p值应该用于假设检验结果的阈值，而不应该用于其他目的。
- en: Another concept and potential pitfall happens when you run many hypothesis tests
    on the same data or the same model. Running a few might be OK, but if you run
    hundreds or more hypothesis tests, then you’re bound to find at least one test
    that passes. For example, if you do 100 hypothesis tests, all at the 99% significance
    level, you’d still expect at least one test to pass (a null hypothesis getting
    rejected) even if none of them should. If you must perform many hypothesis tests,
    it’s best to do *multiple testing correction*, in which the significance of the
    results is adjusted to compensate for the fact that some true null hypotheses
    will be rejected by random chance otherwise. There are a few different methods
    for multiple testing correction, and the differences between them are too nuanced
    to discuss in detail here, so I’ll skip them. Yet again, consult a good statistical
    reference if you’re interested!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个概念和潜在陷阱发生在你对相同的数据或相同的模型运行许多假设检验时。运行几个可能没问题，但如果你运行了数百或更多的假设检验，那么你肯定能找到至少一个通过的检验。例如，如果你做了100个假设检验，所有都在99%的显著性水平上，即使没有一个应该通过（零假设被拒绝），你仍然期望至少有一个检验通过。如果你必须执行许多假设检验，最好是进行*多重检验校正*，其中结果的显著性被调整以补偿这样的事实：否则，一些真正的零假设将被随机机会拒绝。有多重检验校正的几种不同方法，它们之间的差异太微妙，无法在此详细讨论，所以我会跳过它们。再次提醒，如果你对此感兴趣，请查阅良好的统计参考书籍！
- en: 7.5\. Miscellaneous statistical methods
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. 杂项统计方法
- en: Statistical modeling is an explicit attempt to describe a system using mathematical
    and statistical concepts, with the aim of understanding how a system works inside
    and out. It’s a holistic process, and I feel that understanding a system holistically—along
    with the project’s data-to-goals process—is important, regardless of whether you
    end up implementing a statistical model in the strict sense. Many other statistical
    techniques fall at least partially outside my definition of a statistical model,
    and these can help inform your understanding of the system and possibly even be
    used in place of a formal model.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 统计建模是一个明确的尝试，使用数学和统计概念来描述一个系统，目的是理解系统内部和外部是如何工作的。这是一个整体过程，我认为无论你是否最终在严格意义上实现统计模型，理解系统整体——以及项目的数据到目标过程——都是重要的。许多其他统计技术至少部分地超出了我对统计模型的定义，这些可以帮助你了解系统，甚至可能被用来代替正式模型。
- en: I’ve discussed descriptive statistics, inference, and other techniques that
    might be called *atomic statistics*—by that, I mean they form some of the core
    concepts and building blocks of statistics. If you move up the ladder of complexity,
    you can find statistical methods and algorithms that can’t be said to be atomic—they
    have too many moving pieces—but they’re so popular and often so useful that they
    should be mentioned in any overview of statistical analysis techniques. In the
    following subsections I’ll give brief descriptions of a few such higher-complexity
    techniques, when they might be used effectively, and what to watch out for when
    using them.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讨论了描述性统计、推断以及其他可能被称为*原子统计*的技术——通过这个，我的意思是它们构成了统计学的一些核心概念和构建块。如果你沿着复杂性的阶梯向上移动，你会发现一些统计方法和算法不能说是原子的——它们有太多的移动部件，但它们如此受欢迎，并且通常非常有用，因此在任何统计分析技术概述中都应提及。在接下来的小节中，我将简要描述一些这样的高复杂度技术，它们何时可能有效，以及使用它们时应注意什么。
- en: 7.5.1\. Clustering
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1. 聚类
- en: Sometimes you have a bunch of data points, and you know some patterns are in
    there, but you’re not sure where they are exactly, so you can group the data points
    into clusters of generally similar data points in order to get the broad strokes
    of what’s going on in the data. In that way, *clustering*, if it didn’t usually
    have so many moving pieces that are somewhat hard to dissect and diagnose, could
    make a good technique for descriptive statistics.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你有一堆数据点，你知道其中有一些模式，但你不确定它们的确切位置，因此你可以将数据点分组为一般相似的数据点集群，以获得数据中发生的事情的大致轮廓。这样，*聚类*，如果它通常没有那么多难以分解和诊断的移动部件，可以成为描述性统计的一个很好的技术。
- en: Clustering can also be an integral part of a statistical model. I used clustering
    as a major aspect of the model of gene interactions—which I named BACON—mentioned
    earlier. The *C* in BACON stands for *clustering*. The full name is BAyesian Clustering
    Over Networks. In that model, I assumed that the expressions of some genes moved
    together in unison because they were involved in some of the same high-level processes.
    Much scientific literature supports this concept. I didn’t specify beforehand
    which genes’ expression moved together (literature is not often conclusive on
    this), but instead I incorporated a clustering algorithm into my model that allowed
    genes with similar expression movement to come together on their own, as the model
    was fit. Given that there were thousands of genes, clustering served to reduce
    the number of moving parts (called *dimensionality reduction*), which can be a
    goal unto itself, but in this particular case, academic literature provided some
    justification for the practice, and more importantly I found that the clustered
    model made better predictions than the unclustered model.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类也可以是统计模型的一个组成部分。我之前提到的基因相互作用模型（我将其命名为BACON）的主要方面就是聚类。在BACON中，“C”代表聚类。全称是BAyesian
    Clustering Over Networks。在这个模型中，我假设某些基因的表达是一起移动的，因为它们参与了某些相同的高级过程。大量的科学文献支持这个概念。我没有事先指定哪些基因的表达会一起移动（文献通常在这个问题上并不具有结论性），而是将一个聚类算法纳入我的模型中，允许具有相似表达移动的基因在模型拟合过程中自行聚集。鉴于有数千个基因，聚类有助于减少移动部件的数量（称为*降维*），这本身可以是一个目标，但在这种特定情况下，学术文献为这种做法提供了一些依据，更重要的是，我发现聚类模型比未聚类模型有更好的预测能力。
- en: How it works
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: There are many different clustering algorithms—k-means, Gaussian mixture models,
    hierarchical—but all of them traverse the space of data points (all continuous
    numeric values) and group data points that are close to each other in some sense
    into the same cluster.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的聚类算法——k-means、高斯混合模型、层次聚类等——但它们都遍历数据点的空间（所有连续的数值），并将以某种方式彼此接近的数据点分组到同一个聚类中。
- en: Both k-means and Gaussian mixture models are *centroid-based* clustering algorithms,
    meaning that each cluster has something like a center that generally represents
    the members of the cluster. In each of these algorithms, whichever cluster centroid
    a data point is closer to, roughly speaking, that cluster can be said to contain
    the data point. Clusters can be fuzzy or probabilistic, meaning that a data point
    can partially belong to one cluster and partially to others. Usually you have
    to define a fixed number of clusters before running the algorithm, but there are
    alternatives to this.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: k-means和高斯混合模型都是*基于质心*的聚类算法，这意味着每个聚类都有一个类似于中心的点，通常代表该聚类的成员。在这些算法中的每一个，数据点距离哪个聚类质心更近，粗略地说，这个聚类就可以说包含了该数据点。聚类可以是模糊的或概率性的，这意味着一个数据点可以部分属于一个聚类，部分属于其他聚类。通常在运行算法之前，你必须定义一个固定的聚类数量，但也有一些替代方案。
- en: '*Hierarchical* clustering is a bit different. It focuses on individual data
    points and their proximity to one another. To put it simplistically, hierarchical
    clustering looks for the two data points that are closest together and joins them
    into a cluster. Then it looks for the two data points (including the ones in the
    new cluster) that are the closest two yet-unjoined points, and it joins those
    two together. The process continues until all data points are joined together
    into a single mega-cluster. The result is a tree (most statistical software packages
    will gladly draw one of these for you) organized with close data points close
    to each other along the structure of the tree’s branches. This is helpful for
    seeing which data points are close to which other data points. If you want multiple
    clusters instead of one big (tree) cluster, you can cut the tree at a depth that
    gives the number of (branch) clusters that you want—cutting the tree in this sense
    means separating the trunk and the largest limbs, at a certain height, from the
    smaller branches, each of which would remain a unified cluster.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*层次*聚类略有不同。它关注单个数据点及其彼此之间的接近程度。简单来说，层次聚类寻找最接近的两个数据点并将它们合并成一个聚类。然后它寻找包括新聚类在内的两个最接近的尚未合并的数据点，并将这两个点合并。这个过程一直持续到所有数据点都合并成一个单一的大聚类。结果是树状图（大多数统计软件包都会乐意为你绘制这样的图），在树的分支结构上，接近的数据点彼此靠近。这有助于看到哪些数据点接近哪些其他数据点。如果你想要多个聚类而不是一个大（树状）聚类，你可以在树的一定深度处切割，以得到你想要的（分支）聚类数量——在这个意义上切割树意味着在某个高度上，将树干和最大的树枝与较小的树枝分开，每个较小的树枝都会保持为一个统一的聚类。'
- en: When to use it
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时使用它
- en: If you want to put your data points (or other variables) into groups for any
    reason, consider clustering. If you want to be able to describe the properties
    of each of the groups and what a typical cluster member looks like, try a centroid-based
    algorithm like k-means or a Gaussian mixture model. If you’d like to get an idea
    of which of your data points is closest to which other ones, and you don’t care
    that much how close that is—if closer is more important than close in an absolute
    sense—then hierarchical clustering might be a good choice.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将你的数据点（或其他变量）出于任何原因分组，考虑聚类。如果你想能够描述每个组的特性以及典型的聚类成员看起来像什么，尝试使用基于质心的算法，如k-means或高斯混合模型。如果你想要了解你的数据点中哪一个最接近哪一个，而你并不太关心这个接近程度——如果接近在绝对意义上比接近更重要——那么层次聚类可能是一个不错的选择。
- en: What to watch out for
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意事项
- en: With clustering algorithms, there are usually many parameters to tweak. You
    usually have no guarantees that all designated members of each cluster are represented
    well by each cluster or that significant clusters even exist. If dimensions (aspects,
    fields) of your data points are highly correlated, that can be problematic. To
    help with all this, most software tools have many diagnostic tools for checking
    how well the clustering algorithm performed. Use them, and clustering in general,
    with great care.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚类算法中，通常有很多参数可以调整。你通常不能保证每个聚类中指定的所有成员都很好地由每个聚类代表，或者重要的聚类甚至存在。如果你的数据点的维度（方面、领域）高度相关，那可能会成问题。为了帮助解决所有这些问题，大多数软件工具都有许多诊断工具来检查聚类算法的性能如何。请谨慎使用它们，以及聚类算法。
- en: 7.5.2\. Component analysis
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2. 组件分析
- en: It can be difficult to make sense of data that has many dimensions. Clustering
    puts data points together into similarity groups in order to reduce the number
    of entities under scrutiny or analysis. Methods of *component analysis*—of which
    *principal component analysis* (PCA) and *independent component analysis* (ICA)
    are the most popular—do something similar, but they group together the dimensions
    of the data instead of data points, and they rank the groupings in order of how
    much of the data’s variance they explain. In a sense, component analysis reduces
    the dimensionality of the data directly, and by ranking and evaluating the new
    dimensions that are built out of the old ones, you may be able to explain each
    data point in terms of only a few of those dimensions.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 理解具有许多维度的数据可能很困难。聚类将数据点组合成相似性组，以减少需要审查或分析的对象数量。*成分分析*的方法——其中*主成分分析*（PCA）和*独立成分分析*（ICA）是最受欢迎的——做的是类似的事情，但它们将数据的维度而不是数据点组合在一起，并且按照它们解释数据方差的大小对分组进行排序。从某种意义上说，成分分析直接减少了数据的维度性，通过排序和评估由旧维度构建的新维度，你可能能够仅用少数几个维度来解释每个数据点。
- en: For example, let’s say you’re analyzing gasoline usage during car trips. In
    each data point, the fields include distance traveled, duration of the trip, type
    of car, age of the car, and a few others, and also the amount of gasoline used
    during the trip. If you were trying to explain gasoline usage using all of the
    other variables, there’s a good chance that both the distance traveled and the
    trip duration could help explain how much gasoline was used. Neither is a perfect
    predictor, but they both can contribute largely, and in fact they’re highly correlated.
    You’d have to be careful building a model that predicts gasoline usage with both
    of these variables in the face of high correlation; many models would confuse
    such highly correlated variables with one another. Component analysis manipulates
    dimensions—mixing them, combining them, and ranking them—to minimize correlations,
    loosely speaking. A model that was predicting gasoline usage based on dimensions
    generated by component analysis usually wouldn’t confuse any of the dimensions.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在分析汽车旅行中的汽油使用情况。在每一个数据点中，字段包括行驶距离、行程时长、车型、车龄以及其他一些信息，还包括旅行中使用的汽油量。如果你试图用所有其他变量来解释汽油使用情况，那么行驶距离和行程时长很可能有助于解释使用了多少汽油。它们都不是完美的预测因子，但它们都可以在很大程度上做出贡献，实际上它们高度相关。在面临高度相关的情况下，构建一个同时使用这两个变量的汽油使用预测模型时，你必须非常小心；许多模型会将这些高度相关的变量相互混淆。成分分析通过操纵维度——混合、组合和排序它们——来最小化相关性，从广义上讲。一个基于成分分析生成的维度来预测汽油使用的模型通常不会混淆任何维度。
- en: The notion that distance traveled and trip duration are highly correlated is
    probably obvious, but imagine that you’re working with a less-familiar system
    that you’re studying, and you have dozens, hundreds, or even thousands of data
    dimensions. You know that some of the dimensions are probably correlated, but
    you don’t know exactly which ones, and you also know that it would be generally
    beneficial to reduce the total number of dimensions in a clever way. That’s what
    component analysis is good at.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 行驶距离和行程时长高度相关的观点可能很明显，但想象一下你正在处理一个不太熟悉的研究系统，并且你有数十、数百甚至数千个数据维度。你知道一些维度可能是相关的，但你不知道具体是哪些，你也知道以巧妙的方式减少维度总数通常是有益的。这正是成分分析擅长的地方。
- en: How it works
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Component analysis generally examines the data set as a sort of data cloud in
    many dimensions and then finds the component or angle along which the length of
    the data cloud is the longest. By *component* or *angle*, I mean a combination
    of dimensions, so that the dimension chosen might be diagonal, in some sense,
    when compared to the original dimensions. After the first component is chosen,
    that dimension is collapsed or disregarded in a clever way, and a second component
    is then selected, with the goal of finding the longest or widest component that
    has nothing in common with the first component. The process continues, finding
    as many components, in order of importance, as you’d like.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 成分分析通常将数据集视为一个在多个维度上的数据云，然后找到数据云长度最长的成分或角度。这里的“成分”或“角度”是指维度的组合，因此所选的维度与原始维度相比可能是对角线。选择第一个成分后，这个维度以一种巧妙的方式被折叠或忽略，然后选择第二个成分，目标是找到与第一个成分没有任何共同点的最长或最宽的成分。这个过程会继续进行，按照重要性顺序找到你想要的那么多成分。
- en: When to use it
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时使用它
- en: If you have numerous dimensions in your data and you want fewer, component analysis
    is probably the best way to reduce the number of dimensions, and in addition to
    that, the resulting dimensions usually have some nice properties. But if you need
    the dimensions to be interpretable, you’ll have to be careful.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你数据中有许多维度，而你又想减少维度数量，成分分析可能是减少维度数量的最佳方法，而且结果维度通常具有一些良好的特性。但如果你需要维度具有可解释性，你必须小心行事。
- en: What to watch out for
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 需要留意的事项
- en: PCA, the most popular type of component analysis, is sensitive to the relative
    scale of the values along various dimensions of the data set. If you rescale a
    particular field in the data—say, you switch from kilometers to miles—then that
    will have a significant effect on the components that are generated by PCA. It’s
    not only that rescaling can be a problem, but that the original (or any) scales
    of the variables can be problematic as well. Each of the dimensions should be
    scaled such that the same size change in any of them would be, in some sense,
    equally notable. It’s probably best to consult a good reference before trying
    any stunts with component analysis.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 主成分分析（PCA），这种最流行的成分分析方法，对数据集中各个维度的值相对尺度很敏感。如果你对数据中的某个特定字段进行缩放——比如说，你从千米换算成英里——那么这将对PCA生成的成分产生重大影响。问题不仅在于缩放可能成为问题，原始（或任何）变量的尺度也可能成为问题。每个维度都应该进行缩放，使得其中任何一个维度的相同大小变化在某种程度上都是同样显著的。在尝试任何成分分析的特技之前，最好先咨询一下好的参考资料。
- en: 7.5.3\. Machine learning and black box methods
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3. 机器学习和黑盒方法
- en: 'In the world of analytic software development, machine learning is all the
    rage these days. Not that it hasn’t been popular for a long time now, but in the
    last few years I’ve seen the first few products come to market that claim to “bring
    machine learning to the masses,” or something like that. It sounds great on some
    level, but on another level it sounds like they’re asking for trouble. I don’t
    think most people know how machine learning works or how to notice if it has gone
    wrong. If you’re new to machine learning, I’d like to emphasize that machine learning,
    in most of its forms, is a tricky tool that shouldn’t be considered a magic solution
    to anything. There’s a reason why it takes years or decades of academic research
    to develop a completely new machine learning technique, and it’s the same reason
    why most people wouldn’t yet understand how to operate it: machine learning is
    extremely complex.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析软件开发的世界里，机器学习如今正风靡一时。并不是说它之前没有流行过，但最近几年，我看到了一些最初的产品进入市场，声称要“将机器学习带给大众”，或者类似的说法。这在某种程度上听起来很棒，但在另一个层面上，它听起来像是在自找麻烦。我认为大多数人并不了解机器学习是如何工作的，或者如何察觉它是否出了问题。如果你是机器学习的新手，我想强调的是，在大多数形式中，机器学习是一个棘手的工具，不应该被视为任何问题的魔法解决方案。为什么需要花费数年或数十年的学术研究来开发一种全新的机器学习技术，原因就在于此，同样也是为什么大多数人还不懂得如何操作它：机器学习极其复杂。
- en: The term *machine learning* is used in many contexts and has a somewhat fluid
    meaning. Some people use it to refer to any statistical methods that can draw
    conclusions from data, but that’s not the meaning I use. I use the term *machine
    learning* to refer to the classes of somewhat abstract algorithms that can make
    conclusions from data but whose models—if you want to call them that—are difficult
    to dissect and understand. In that sense, only the machine can understand its
    own model, in a way. Sure, with most machine learning methods, you can dig into
    the innards of the machine’s generated model and learn about which variables are
    most important and how they relate to each other, but in that way the machine’s
    model begins to feel like a data set unto itself—without reasonably sophisticated
    statistical analysis, it’s tough to get a handle on how the machine’s model even
    works. That’s why many machine learning tools are called black box methods.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: “机器学习”这个术语在许多语境中使用，并且具有某种流动的含义。有些人用它来指代任何可以从数据中得出结论的统计方法，但那并不是我使用的含义。我使用“机器学习”这个术语来指代那些可以从数据中得出结论但模型（如果你愿意这样称呼它们）难以剖析和理解的算法类别。从这个意义上说，只有机器本身才能以某种方式理解其模型。当然，对于大多数机器学习方法，你可以深入了解机器生成的模型内部，了解哪些变量最重要以及它们是如何相互关联的，但以这种方式，机器的模型开始感觉像是一个数据集——如果没有相当复杂的统计分析，很难把握机器模型的工作方式。这就是为什么许多机器学习工具被称为黑盒方法。
- en: There’s nothing wrong with having a black box that takes in data and produces
    correct answers. But it can be challenging to produce such a box and confirm that
    its answers continue to be correct, and it’s nearly impossible to look inside
    the box after you’ve finished and debug. Machine learning is great, but probably
    more than any other class of statistical methods, it requires great care to use
    successfully.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个接收数据并产生正确答案的黑盒并没有什么不妥。但是，制作这样一个盒子并确认其答案持续正确可能会很具挑战性，而且在调试完成后几乎不可能查看盒子的内部。机器学习很棒，但可能比其他任何统计方法类别都需要更加小心地使用才能成功。
- en: I’ll stop short of giving lengthy explanations of machine learning concepts,
    because countless good references are available both on the internet and in print.
    I will, however, give some brief explanations of some of the key concepts to put
    them in context.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细解释机器学习概念，因为互联网和印刷品上都有无数优秀的参考资料。然而，我会简要解释一些关键概念，以便将其置于适当的背景中。
- en: '*Feature extraction* is a process by which you convert your data points into
    more informative versions of themselves. To get the best results, it’s crucial
    to extract good features every time you do machine learning—except, maybe, when
    doing deep learning. Each feature of a data point should be showing its best side(s)
    to a machine learning algorithm if it hopes to be classified or predicted correctly
    in the future. For example, in credit card fraud detection, one possible feature
    to add to a credit card transaction is the amount by which the transaction is
    above the normal transaction amount for the card; alternatively, the feature could
    be the percentile of the transaction size compared to all recent transactions.
    Likewise, good features are those that common sense would tell you might be informative
    in differentiating good from bad or any two classes from one another. There are
    also many valuable features that don’t make common sense, but you always have
    to be careful in determining whether these are truly valuable or if they’re artifacts
    of the training data set.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*特征提取*是一个将你的数据点转换为更信息丰富的版本的过程。为了获得最佳结果，每次进行机器学习时提取良好的特征至关重要——除非是进行深度学习。数据点的每个特征都应该向机器学习算法展示其最佳的一面，如果它希望在将来被正确分类或预测。例如，在信用卡欺诈检测中，可以添加到信用卡交易中的一个可能特征是交易金额超出卡正常交易金额的程度；或者，该特征可以是交易规模在所有最近交易中的百分位数。同样，好的特征是那些常识会告诉你可能有助于区分好与坏或任何两个类别之间的特征。还有一些不常见的特征可能没有常识，但你总是必须小心判断这些特征是否真正有价值，或者它们是否是训练数据集的副产品。'
- en: 'Here are a few of the most popular machine learning algorithms that you would
    apply to the feature values you extracted from your data points:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些最流行的机器学习算法，你将把它们应用到从数据点中提取的特征值上：
- en: '***Random forest—*** This is a funny name for a useful method. A decision tree
    is a series of yes/no questions that ends in a decision. A random forest is a
    collection of randomly generated decision trees that favors trees and branches
    that correctly classify data points. This is my go-to machine learning method
    when I know I want machine learning but I don’t have a good reason to choose a
    different one. It’s versatile and not too difficult to diagnose problems.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Random forest—*** 这是一个有趣的名字，对应一个有用的方法。决策树是一系列以决策结束的yes/no问题。随机森林是一系列随机生成的决策树，它倾向于那些能够正确分类数据点的树和分支。当我知道我想要机器学习，但没有充分的理由选择其他方法时，这是我的首选机器学习方法。它非常灵活，而且不容易诊断问题。'
- en: '***Support vector machine (SVM)—*** This was quite popular a few years ago,
    and now it has settled into the niches where it’s particularly useful as the next
    machine learning fads pass through. SVMs are designed to classify data points
    into one of two classes. They manipulate the data space, turning it and warping
    it in order to drive a wedge between two sets of data points that are known to
    belong to the two different classifications. SVMs focus on the boundary between
    the two classes, so if you have two classes of data points, with each class tending
    to stick together in the data space, and you’re looking for a method to divide
    the two classes with maximal separation (if possible), then an SVM is for you.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Support vector machine (SVM)—*** 几年前这相当流行，现在它已经进入了一个特别有用的领域，随着下一个机器学习潮流的到来，它已经稳定下来。支持向量机（SVM）被设计用来将数据点分类到两个类别之一。它们操作数据空间，将其扭曲和变形，以便在两个已知属于不同分类的数据点之间打入楔子。SVM专注于两个类别之间的边界，所以如果你有两个数据点类别，每个类别在数据空间中倾向于聚集在一起，而你正在寻找一种方法来以最大分离度（如果可能的话）划分这两个类别，那么SVM就是为你准备的。'
- en: '***Boosting—*** This is a tricky one to explain, and my limited experience
    doesn’t provide all the insights I probably need. But I know that boosting was
    a big step forward in machine learning of certain types. If you have a bunch of
    so-so machine learning models (*weak learners*), boosting might be able to combine
    them intelligently to result in a good machine learning model (a *strong learner*).
    Because boosting combines the outputs of other machine learning methods, it’s
    often called a *meta-algorithm*. It’s not for the faint of heart.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Boosting—*** 这一点解释起来有些棘手，我的有限经验也无法提供所有可能需要的洞察。但我知道，提升（Boosting）在特定类型的机器学习中是一个重大的进步。如果你有一堆平庸的机器学习模型（*弱学习器*），提升可能能够智能地组合它们，从而得到一个优秀的机器学习模型（*强学习器*）。因为提升结合了其他机器学习方法的输出，所以它通常被称为*元算法*。这可不是一件容易的事情。'
- en: '***Neural network—*** The heyday for the neural network seemed to be the last
    decades of the twentieth century, until the advent of deep learning. In their
    earlier popular incarnation, *artificial neural networks* (the more formal name)
    were perhaps the blackest of black boxes. They seemed to be designed not to be
    understood. But they worked well, in some cases at least. Neural networks consist
    of layers upon layers of one-way valves (or neurons), each of which transforms
    the inputs in some arbitrary way. The neurons are connected to each other in a
    large network that leads from the input data to the output prediction or classification,
    and all of the computational work for fitting the model involved weighting and
    reweighting each of the neurons in clever ways to optimize results.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Neural network—*** 神经网络的全盛时期似乎是在20世纪最后几十年，直到深度学习的出现。在其早期的流行版本中，*人工神经网络*（更正式的名字）可能是最黑的黑盒子。它们似乎是为了不被理解而设计的。但它们在某些情况下工作得很好。神经网络由一层又一层的单向阀门（或神经元）组成，每个神经元都以某种任意的方式转换输入。这些神经元在一个大网络中相互连接，从输入数据到输出预测或分类，所有的计算工作都涉及以巧妙的方式对每个神经元进行加权和重新加权，以优化结果。'
- en: '***Deep learning—*** This is a new development in this millennium. Loosely
    speaking, deep learning refers to the idea that you might not need to worry much
    about feature extraction because, with enough computational power, the algorithm
    might be able to find its own good features and then use them to learn. More specifically,
    deep learning techniques are layered machine learning methods that, on a low level,
    do the same types of learning that other methods do, but then, on a higher level,
    they generate abstractions that can be applied generally to recognize important
    patterns in many forms. Today, the most popular deep learning methods are based
    on neural networks, causing a sort of revival in the latter.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度学习——** 这是本世纪的一项新进展。粗略地说，深度学习指的是你可能不必太担心特征提取的想法，因为有了足够的计算能力，算法可能能够找到它自己的良好特征，然后使用它们来学习。更具体地说，深度学习技术是分层机器学习方法，在低层次上执行与其他方法相同的学习类型，但在高层次上，它们生成可以普遍应用于识别许多形式中重要模式的抽象。今天，最流行的深度学习方法基于神经网络，导致后者的一种复兴。'
- en: '***Artificial intelligence—*** I’m including this term because it’s often conflated
    with machine learning and rightly so. There’s no fundamental difference between
    machine learning and artificial intelligence, but with artificial intelligence
    comes the connotation that the machine is approaching the intellectual capabilities
    of a human. In some cases, computers have already surpassed humans in specific
    tasks—famously, chess or *Jeopardy!*, for instance—but they’re nowhere near the
    general intelligence of an average human on a wide variety of day-to-day tasks.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人工智能——** 我包括这个术语，因为它经常与机器学习混淆，这是有道理的。机器学习和人工智能之间没有根本的区别，但人工智能带来了这样的含义，即机器正在接近人类的智力水平。在某些情况下，计算机已经在特定任务上超越了人类——例如著名的国际象棋或*危险边缘！*——但他们远远达不到普通人类在广泛日常任务中的普遍智力水平。'
- en: How it works
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Each specific machine learning algorithm is different. Data goes in, answers
    come out; you have to do much work to confirm that you didn’t make any mistakes,
    that you didn’t over-fit, that the data was properly train-test separated, and
    that your predictions, classifications, or other conclusions are still valid when
    brand-new data comes in.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定的机器学习算法都是不同的。数据输入，答案输出；你必须做很多工作来确认你没有犯任何错误，你没有过度拟合，数据已经被正确地分为训练集和测试集，以及当全新的数据到来时，你的预测、分类或其他结论仍然有效。
- en: When to use it
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 何时使用
- en: Machine learning, in general, can do things that no other statistical methods
    can do. I prefer to try a statistical model first in order to get an understanding
    of the system and its relationship to the data, but if the model falls short in
    terms of results, then I begin to think about ways to apply machine learning techniques
    without giving up too much of the awareness that I had with the statistical model.
    I wouldn’t say that machine learning is my last resort, but I do usually favor
    the intuitiveness and insight of a well-formed statistical model until I find
    it lacking. Head straight for machine learning if you know what you’re doing and
    you have a complex problem that’s nowhere near linear, quadratic, or any of the
    other common variable relationships in statistical models.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习通常可以做到其他统计方法做不到的事情。我更喜欢首先尝试统计模型，以便了解系统和其与数据的关系，但如果模型在结果方面不足，那么我开始考虑应用机器学习技术的方法，同时不放弃太多与统计模型相关的意识。我不会说我最后的选择是机器学习，但通常我更喜欢一个良好形成的统计模型的直观性和洞察力，直到我发现它不足。如果你知道自己在做什么，并且有一个复杂的问题，它远远不是线性的、二次的或统计模型中其他常见的变量关系，那么直接转向机器学习。
- en: What to watch out for
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意事项
- en: Don’t trust the machine’s model or its results until you’ve verified them—completely
    independently of the machine learning implementation—with test-train separation
    as well as some completely new data that you and the machine have never seen before.
    *Data snooping*—the practice of looking at data before you formally analyze it
    and using what you see to bias how you analyze—can be a problem if you didn’t
    already do test-train separation before you snooped.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在你用测试-训练分离以及一些你和你机器之前从未见过的完全新的数据完全独立地验证它们之前，不要相信机器的模型或其结果——与机器学习实现完全无关。*数据挖掘*——在正式分析数据之前查看数据，并使用你所看到的内容来偏袒你的分析——如果你在挖掘之前没有进行测试-训练分离，可能会成为一个问题。
- en: Exercises
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Continuing with the Filthy Money Forecasting personal finance app scenario
    first described in [chapter 2](kindle_split_011_split_000.xhtml#ch02), and relating
    to previous chapters’ exercises, try these:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用在[第2章](kindle_split_011_split_000.xhtml#ch02)中首先描述的“脏钱预测”个人财务应用场景，并关联到之前章节的练习，尝试以下内容：
- en: '**1\.**'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.'
- en: ''
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Describe two different statistical models you might use to make forecasts of
    personal financial accounts. For each, give at least one potential weakness or
    disadvantage.
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 描述两种你可能用来预测个人财务账户的统计模型。对于每种模型，至少给出一个潜在的弱点或劣势。
- en: '**2\.**'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.'
- en: ''
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume you’ve been successful in creating a classifier that can accurately put
    transactions into the categories *regular*, *one time*, and any other reasonable
    categories you’ve thought of. Describe a statistical model for forecasting that
    makes use of these classifications to improve accuracy.
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你已经成功创建了一个可以将交易准确分类到“常规”、“一次性”和其他你想到的任何合理分类的分类器。描述一个利用这些分类来提高预测准确性的统计模型。
- en: Summary
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: It’s worthwhile to think about a project and a problem theoretically before
    you start into a software-building or full-analysis phase. There’s much to be
    learned, in data science and elsewhere, by stopping and thinking about the problem
    for a while.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始软件构建或全面分析阶段之前，从理论上考虑一个项目和问题是有价值的。通过停下来思考问题一段时间，可以在数据科学和其他领域学到很多东西。
- en: Mathematics is a vocabulary and framework for describing how a system works.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学是一种描述系统如何工作的词汇和框架。
- en: Statistical modeling is a process of describing a system and connecting it to
    data.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计建模是一个描述系统并将其与数据连接的过程。
- en: A vast range of analytic methods and software that implements them is available;
    choosing from among them can be daunting, but it shouldn’t be overwhelming.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的分析方法和实现它们的软件范围很广；从中选择可能会令人感到畏惧，但不应感到压倒。
- en: Machine learning and other complex statistical methods can be good tools for
    accomplishing the otherwise impossible, but only if you’re careful with them.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习和其他复杂的统计方法可以作为实现其他情况下不可能实现的目标的好工具，但只有在你小心使用它们的情况下。
- en: 'Chapter 8\. Software: statistics in action'
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 软件：统计学的实践
- en: '*This chapter covers*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The basics of some statistical software applications
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些统计软件应用的基本知识
- en: Introductions to a few useful programming languages
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些有用的编程语言
- en: Choosing the appropriate software to use or build
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的软件使用或构建
- en: How to think about getting statistics into your software
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何考虑将统计学融入你的软件中
- en: '[Figure 8.1](kindle_split_018_split_000.xhtml#ch08fig01) shows where we are
    in the data science process: building statistical software. In the last chapter,
    I introduced statistics as one of the two core concepts of data science. Knowledge
    of software development and application is the other. If statistics is the framework
    for analyzing and drawing conclusions from data, then software is the tool that
    puts this framework into action. In few cases would a data scientist be able to
    go without software during a project, but I suppose it’s possible when the data
    set is very small.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.1](kindle_split_018_split_000.xhtml#ch08fig01)显示了我们在数据科学过程中的位置：构建统计软件。在上一个章节中，我将统计学作为数据科学两个核心概念之一进行了介绍。软件开发和应用知识是另一个核心。在少数情况下，数据科学家在项目过程中可能不需要软件，但我想，当数据集非常小的时候，这是可能的。'
- en: 'Figure 8.1\. An important aspect of the build phase of the data science process:
    statistical software and engineering'
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 数据科学过程构建阶段的一个重要方面：统计软件和工程
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig01_alt.jpg)'
- en: Beyond going without, a data scientist must make many software choices for any
    project. If you have a favorite program, that’s often a good choice, if for no
    other reason than your familiarity with it. But there can be good reasons to pick
    something else. Or if you’re new to data science or statistical software, it can
    be hard to find a place to start. Therefore, in this chapter I give a broad overview
    of different types of software that might be used in data science before providing
    some guidelines for choosing from among them for a project. As in [chapter 7](kindle_split_017_split_000.xhtml#ch07),
    I intend to provide only a high-level description of relevant concepts plus some
    examples.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不使用之外，数据科学家必须为任何项目做出许多软件选择。如果你有一个喜欢的程序，那通常是一个不错的选择，至少是因为你对它的熟悉。但选择其他东西也可能有很好的理由。或者如果你是数据科学或统计软件的新手，可能很难找到一个起点。因此，在本章中，我在提供一些选择指南之前，给出了数据科学中可能使用的不同类型软件的广泛概述。正如[第7章](kindle_split_017_split_000.xhtml#ch07)中所述，我打算只提供相关概念的高级描述和一些示例。
- en: Experienced software developers probably won’t like this chapter much, but if
    you’re a statistician or a beginner with software, I think these high-level descriptions
    are a good way to start. For more information on any specific topic, many in-depth
    references are available both on the internet and in print.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的软件开发者可能不会太喜欢这一章，但如果你是统计学家或软件新手，我认为这些高级描述是一个不错的开始方式。关于任何特定主题的更多信息，互联网和印刷品中都有许多深入的参考资料。
- en: 8.1\. Spreadsheets and GUI-based applications
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 电子表格和基于GUI的应用程序
- en: To anyone who has spent significant time using Microsoft Excel or another spreadsheet
    application, this is often the first choice for performing any sort of data analysis.
    Particularly if the data is in a tabular form, such as CSV, and there’s not too
    much of it, getting started with analysis in a spreadsheet can be easy. Furthermore,
    if the calculations you need to do aren’t complex, a spreadsheet might even be
    able to cover all the software needs for the project.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些在Microsoft Excel或其他电子表格应用程序上花费了大量时间的人来说，这通常是进行任何类型数据分析的首选。特别是如果数据以表格形式存在，如CSV，并且数据量不是很大，那么在电子表格中开始分析可以很容易。此外，如果你需要的计算不是太复杂，电子表格甚至可能覆盖项目所需的全部软件需求。
- en: 8.1.1\. Spreadsheets
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 电子表格
- en: For the few who may be uninitiated, a *spreadsheet* is a piece of software that
    represents data in a row-and-column tabular format. It typically allows analysis
    of that data via sets of functions—such as average, median, sum—that can operate
    on the data and answer some questions. Microsoft Excel, OpenOffice and LibreOffice
    Calc, and Google Sheets are popular examples of spreadsheet applications.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少数可能不太了解的人来说，**电子表格**是一种软件，它以行和列的表格格式表示数据。它通常允许通过一系列函数（如平均值、中位数、总和）来分析这些数据，这些函数可以对数据进行操作并回答一些问题。Microsoft
    Excel、OpenOffice和LibreOffice Calc以及Google Sheets是流行的电子表格应用程序的例子。
- en: Spreadsheets can be quite complex when they contain multiple sheets, cross-references,
    table lookups, and functions/formulas. The most sophisticated spreadsheet I ever
    made was for a college finance class on the topic of real estate. As part of the
    class, we participated in a simulation of a real estate market in which each student
    owned an apartment building, which required decisions regarding financing and
    insurance, among other things. During the simulation, there would be random events
    such as disasters that might cause damage to the building, as well as operating
    costs, vacancies, and interest rate fluctuation. The goal within the simulation
    was to have the highest rate of return on the initial cash paid for the apartment
    building, assuming we then sold the building after five years.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当电子表格包含多个工作表、交叉引用、表格查找和函数/公式时，它们可以相当复杂。我制作的最复杂的电子表格是为一个关于房地产的大学财务课程。作为课程的一部分，我们参与了一个模拟房地产市场的活动，其中每个学生都拥有一座公寓楼，这需要关于融资和保险等方面的决策。在模拟过程中，会有随机事件，如灾害，可能会对建筑物造成损害，以及运营成本、空置和利率波动。模拟的目标是在五年后出售建筑物后，从为公寓楼支付的初始现金中获得最高的回报率。
- en: By far, the most important decision was the specific choice of mortgage used
    to finance the purchase of the building. We were given a choice of eight mortgage
    structures that differed in their term/duration, fixed or variable interest rates
    and their margins, points paid at purchase, and temporary teaser rates. There
    was a stated purchase price for the apartment building, but as in real life, we
    had a choice about how much money we’d like to borrow for the purchase. The amount
    we didn’t borrow via the mortgage was the cash outlay on which we’d be calculating
    the rate of return that measured our success.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最重要的决定是具体选择哪种抵押贷款来为购买建筑提供资金。我们被提供了八种不同的抵押贷款结构选择，这些结构在期限/持续时间、固定或浮动利率以及它们的利差、购买时支付的点数和临时促销利率方面有所不同。公寓楼有一个明确的购买价格，但就像现实生活中一样，我们有权选择我们想要为购买借多少钱。我们没有通过抵押贷款借到的金额是我们将用来计算回报率的现金支出，这个回报率衡量了我们的成功。
- en: With all the variables, random or chosen, included in the simulation, it was
    obvious that running through some calculations would be of great benefit when
    making decisions, particularly regarding financing. At the time, I had written
    programs only on my graphing calculator, and none of those analyzed data. Short
    of learning another tool for the purpose, using Microsoft Excel was my only choice.
    I have a mild dislike for Excel, as do many, but it got the job done.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟中包含了所有变量，无论是随机选择还是人为选择，很明显，在做出决策时进行一些计算将非常有帮助，尤其是在融资方面。当时，我只在我的图形计算器上编写程序，而且没有一个程序分析数据。除了学习另一种工具之外，使用微软Excel成了我唯一的选择。虽然我和许多人一样对Excel有些轻微的厌恶，但它完成了工作。
- en: For each of the 8 mortgage structures and 12 different possible amounts to borrow,
    I calculated cash flows for each of the 5 years of the simulation, and from these
    cash flows I also calculated an expected rate of return. I made use of several
    of Excel’s formulas, including the standard `SUM` formula for addition, the `PMT`
    formula for calculating a mortgage payment, and the `IRR` formula for calculating
    an internal rate of return for cash flows. At that point, I could see the rates
    of return for all possibilities under the expected conditions. As I mentioned,
    though, there would be random events during each year of the simulation, and so
    the expected outcomes almost certainly wouldn’t be the ones observed. To account
    for this, I added to the spreadsheet some values representing simulated disasters,
    interest rate fluctuations, and vacancies, among others. I then was able to enter
    some possible random outcomes and see how they affected the rates of return and
    the optimal choices.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于8种抵押贷款结构和12种不同的借款可能金额，我计算了模拟的5年期间每年的现金流量，并从这些现金流量中计算了预期的回报率。我使用了Excel的几个公式，包括标准的`SUM`公式用于加法，`PMT`公式用于计算抵押贷款还款，以及`IRR`公式用于计算现金流量的内部回报率。到那时，我可以看到在预期条件下所有可能性的回报率。然而，正如我提到的，模拟的每年都会有随机事件发生，因此预期的结果几乎肯定不会是观察到的结果。为了解决这个问题，我在电子表格中添加了一些代表模拟灾难、利率波动和空置率等值的数值。然后，我能够输入一些可能的随机结果，并查看它们如何影响回报率和最佳选择。
- en: Ultimately, my spreadsheet contained two sheets, one that did the heavy calculation
    and one that summarized results (shown in [figure 8.2](kindle_split_018_split_001.xhtml#ch08fig02)),
    random variables and their fluctuations, and the decisions that needed to be made.
    The sheet with the heavy calculations contained 96 different statements of cash
    flow, one for each of the eight mortgage types for 12 different amounts borrowed.
    Each statement of cash flow used the random variable values from the summary sheet
    to calculate five years of cash flows from several types of income and expenses
    based on that particular mortgage’s parameters. Each cash flow calculation resulted
    in a rate of return figure that the summary sheet then referenced. Looking at
    all 96 rates of return—using Excel’s conditional formatting option to highlight
    the highest among them—and how each of them changed if the random variables turned
    out differently, I then felt confident in choosing a mortgage that would result
    in not only one of the highest expected rates of return but that also wouldn’t
    be too risky if a disaster hit.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我的电子表格包含了两张工作表，一张用于进行繁重的计算，另一张用于总结结果（如图8.2所示 [figure 8.2](kindle_split_018_split_001.xhtml#ch08fig02)），随机变量及其波动，以及需要做出的决策。进行繁重计算的工作表包含了96种不同的现金流陈述，每种陈述对应于12种不同借款金额的8种不同抵押类型。每个现金流陈述都使用总结工作表中的随机变量值来计算基于特定抵押参数的几种收入和支出的五年现金流。每个现金流计算的结果产生了一个回报率数字，总结工作表随后引用这个数字。当我查看所有96个回报率——使用Excel的条件格式选项突出显示其中最高的一个——以及如果随机变量结果不同，每个回报率如何变化时，我对选择一个不仅预期回报率最高的抵押贷款，而且在发生灾难时风险也不会太大的抵押贷款感到自信。
- en: Figure 8.2\. First page of the spreadsheet I used to simulate the management
    of an apartment building in my college finance class
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 我在大学金融课程中用来模拟管理公寓楼的工作表的第一页
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig02_alt.jpg)'
- en: 'I don’t think my classmates spent as much time analyzing choices as I did.
    I don’t believe any of them created a spreadsheet, either. I ended up winning
    the contest by more than a full percentage point, which the financially inclined
    among you will recognize as quite a large margin of victory. If I recall correctly,
    I earned over 9% on my initial investment, when everyone else earned less than
    8%—a figure that would have amounted to several thousand dollars had the money
    been real. I did win real money also from the contest: $200 cash as the first
    prize, which, though not the thousands of dollars I earned on the fictional apartment
    building, was no small sum for me as a college student.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我的同学们并没有花像我一样多的时间分析选择。我不相信他们中的任何一个人创建了电子表格。我最终以超过一个百分点的优势赢得了比赛，这在有金融倾向的人看来是一个相当大的胜利。如果我记得正确的话，我的初始投资回报率超过了9%，而其他人则不到8%——如果这笔钱是真的，这个数字将相当于几千美元。我还从比赛中赢得了真正的钱：作为一等奖的200美元现金，尽管这比我在虚构的公寓楼中赚到的几千美元要少，但对于我这样一个大学生来说，这笔钱也不是小数目。
- en: 'I probably learned more about spreadsheets during that single finance project
    than in the rest of my whole life. One advantage of spreadsheets, particularly
    Excel, became obvious: the number of built-in formulas is astronomical. For nearly
    any static calculation that you might care to apply to your data in a spreadsheet,
    there is a formula or a combination thereof that can accomplish it for you. Here,
    I use the word *static* to refer to calculations that happen in one step, without
    iteration or complex interdependency between values.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能在那次单独的金融项目中学到了比整个一生中更多的关于电子表格的知识。电子表格的一个优点，尤其是Excel，变得很明显：内置公式的数量是天文数字的。对于你可能在电子表格中应用到的几乎任何静态计算，都有一个公式或其组合可以为你完成这项任务。在这里，我用“静态”一词来指代一步完成的计算，没有迭代或值之间的复杂相互依赖。
- en: 'One major disadvantage of spreadsheets is that even moderately complex formulas
    might look something like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格的一个主要缺点是，即使是中等复杂的公式也可能看起来像这样：
- en: '[PRE0]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Or worse. I took that one directly from my real estate simulation spreadsheet,
    though it’s not immediately clear exactly how—even to me—this formula was once
    intended to calculate the interest expense for one year of the cash flow statement
    for one of the mortgages. Needless to say, this formula is difficult to read and
    understand—and it’s nowhere near the worst that I’ve seen or written—mostly because
    the entire formula is on a single line, and all the variables are referenced by
    unhelpful combinations of letters and numbers. Don’t get me started on the parentheses.
    Readability of such calculations can be a serious concern. Frankly, I’m not surprised
    that Excel formula errors have been implicated in many missteps by big banking
    organizations, such as the 2013 London Whale case at JP Morgan, in which, apparently,
    an Excel formula error caused dramatic underestimation of the risk of a particular
    investment portfolio, ultimately resulting in a $6 billion loss. That’s an expensive
    mistake and a compelling reason to use a statistical tool with readable calculation
    instructions.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更糟。我从我的房地产模拟电子表格中直接取了那个例子，尽管即使对我来说也不太清楚这个公式最初是如何打算用来计算现金流量表中某项抵押贷款一年内利息支出的。不用说，这个公式难以阅读和理解——而且它远非我所见或编写过的最糟糕的公式——主要是因为整个公式都在一行上，所有的变量都通过无用的字母和数字组合来引用。更别提括号了。这种计算的易读性可能是一个严重的问题。坦白说，我并不惊讶Excel公式错误被卷入许多大型银行机构的失误中，比如2013年摩根大通“伦敦鲸”案件，其中显然一个Excel公式错误导致了对特定投资组合风险的严重低估，最终导致60亿美元的损失。这是一个代价高昂的错误，也是使用具有可读计算说明的统计工具的充分理由。
- en: Spreadsheets aren’t limited to rows, columns, and formulas. One other feature
    of note is the solver in Excel, a tool that can help you find the optimal solution
    for a complex equation or optimize parameters to meet some objective goal. To
    use it, you must tell the solver which values are allowed to change, and you also
    have to tell it which value is the objective that is to be maximized or minimized;
    the solver then uses optimization techniques to find the best solution. I used
    the solver, for example, during another college project in which I was trying
    to maximize the number of people a set of elevators could transport to their desired
    floors on a busy day. The optimal solution that I found involved limiting the
    floors that each elevator would visit; for example, one elevator would service
    floors 1–10 and another 10–15\. By letting Excel’s solver change the floors that
    each elevator might visit, it found a solution that maximized the total number
    of people transported.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格不仅限于行、列和公式。Excel中另一个值得注意的功能是求解器，这是一个可以帮助你找到复杂方程的优化解或优化参数以实现某些目标的功能的工具。要使用它，你必须告诉求解器哪些值可以改变，你还得告诉它哪个值是要最大化或最小化的目标值；然后求解器使用优化技术来找到最佳解。例如，我在另一个大学项目中使用了求解器，当时我试图在繁忙的一天内最大化一组电梯将乘客运送至他们希望到达的楼层的人数。我找到的优化解涉及限制每部电梯访问的楼层；例如，一部电梯负责1-10层，另一部负责10-15层。通过让Excel的求解器改变每部电梯可能访问的楼层，它找到了一个最大化总运输人数的解决方案。
- en: Another significant feature of most spreadsheet applications is the macro. *Macros*,
    in applications like Excel, are mini-programs that users can write themselves.
    In Excel, macros are written in Visual Basic for Applications (VBA) and can generally
    accomplish anything that can be accomplished in Excel. Instead of pointing and
    clicking to do something, you could theoretically write a macro that does the
    same thing. This can be helpful if you typically do that thing many times. Running
    one macro can be much faster and easier than doing a set of steps manually, depending
    on the complexity of those steps. I created a macro for my real estate spreadsheet,
    one that copied changes that I had made to the first cash flow statement and pasted
    them into all of the 95 other cash flow statements. Notably, I didn’t write the
    macro in VBA, but instead Excel was able to record me performing the manual steps
    of copying and pasting and then convert that recording into a macro I could use.
    This is a handy feature of Excel if you do a specific thing often, you want to
    create a macro for it, and you don’t want to write code in VBA.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数电子表格应用的一个显著特点是宏。*宏*，在像Excel这样的应用中，是用户可以自己编写的迷你程序。在Excel中，宏是用Visual Basic
    for Applications (VBA)编写的，通常可以完成Excel中可以完成的所有事情。你不必通过点击和指向来执行某个操作，理论上你可以编写一个执行相同操作的宏。如果你经常做同样的事情，这可能会很有帮助。运行一个宏可能比手动执行一系列步骤要快得多，也容易得多，这取决于这些步骤的复杂性。我为我的房地产电子表格创建了一个宏，这个宏将我已更改的第一个现金流量表中的更改复制到所有其他95个现金流量表中。值得注意的是，我没有用VBA编写宏，而是Excel能够记录我执行复制和粘贴的手动步骤，然后将这个记录转换成我可以使用的宏。如果你经常做特定的事情，你想为它创建一个宏，但又不想在VBA中编写代码，这是一个Excel的便捷功能。
- en: 8.1.2\. Other GUI-based statistical applications
  id: totrans-468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2. 其他基于GUI的统计应用
- en: I consider spreadsheet applications like Excel to be level 1 software for data
    analysis; even beginners aren’t truly afraid to open a spreadsheet and poke around
    a little bit. Level 10 is writing your own flawless software from scratch; it’s
    not for the faint of heart. The levels in between are populated by any number
    of software applications that possess varying amounts of ease of use, like spreadsheets,
    and versatility, like programming. If you’re finding your favorite spreadsheet
    application lacking in sophistication, but you’re not ready to jump head first
    into a programming language, then some in-between solutions might work for you.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为像Excel这样的电子表格应用是数据分析的第一级软件；即使是初学者也不害怕打开电子表格随意探索一下。第十级是从零开始编写自己完美无缺的软件；这对胆小的人来说不是一件容易的事情。介于两者之间的级别被各种软件应用所占据，这些应用具有不同的易用性和多功能性，如电子表格和编程。如果你觉得你最喜欢的电子表格应用在复杂性方面有所欠缺，但你又不想一头扎进编程语言，那么一些中间解决方案可能适合你。
- en: I was at a big statistics conference recently and was surprised by the number
    of vendors offering mid-level statistical applications. I saw booths for SPSS,
    Stata, SAS (and its JMP product), and Minitab, among others. Each of these applications
    is popular in some circles, and I’d used three out of those four at some point
    in my life. I decided to play a bit of a game by visiting a couple of the booths
    when they weren’t busy and asking each company’s representatives to explain to
    me why their software product is better than the others. It was an honest question,
    more than anything, but I also thought it funny to ask the representatives, mostly
    statisticians themselves, so directly to disparage the competition. One rep was
    kind enough to admit straight away that the companies were all producing roughly
    equivalent products. That is not to say that they are equal, but only that none
    is vastly or definitely better than the others. Preference for one or the other
    is a matter of specific use and personal taste.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 最近我参加了一个大型统计学会议，并对提供中级统计应用软件的供应商数量感到惊讶。我看到了SPSS、Stata、SAS（及其JMP产品）和Minitab等展位。这些应用软件在某个圈子里都很受欢迎，我在生命中的某个阶段使用过其中的三个。我决定玩一个小游戏，在展位不忙的时候去参观，并请每个公司的代表向我解释为什么他们的软件产品比其他产品更好。这是一个诚实的问题，更多的是一种幽默，因为我觉得直接问这些代表，他们大多是统计学家，贬低竞争对手很有趣。一位代表很友好地立刻承认，这些公司都在生产大致相当的产品。这并不是说它们是相等的，只是说没有一个比其他产品明显或绝对更好。对某一产品或另一产品的偏好是一个具体用途和个人喜好的问题。
- en: 'What unites the various companies’ core products is a similar experience in
    doing statistical analysis. It seemed to me that the graphical user interface
    (GUI) of each application was based on that of a spreadsheet. If you take a typical
    spreadsheet application and divide the screen into panels, with one panel showing
    the data, one displaying some graph or visualization of the data, and one describing
    the results of a regression or component analysis, that’s the basic experience
    of these mid-level statistical applications. I know I sound dismissive in my description,
    so please don’t infer that I think these applications aren’t worthwhile—quite
    the contrary. In fact, everything I know about them tells me that they’re incredibly
    useful. But software companies, as companies will, sometimes use hyperbole to
    make you think that their product is head and shoulders above the competitors’
    and that it will solve your data problems in a jiffy. This is almost never true,
    though I’ll admit we’re doing much better in the current decade than in decades
    past. One thing does remain true: to use a statistical application successfully,
    you have to understand statistics, at least a little. None of these applications
    will teach you statistics, so approach them with a cool head and a discerning
    eye. Often the best choice, if you want to choose one, is the one that your friends
    use, because they can help you if you run into questions. Following the crowd
    here can be a good thing.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 各家公司核心产品的共同之处在于进行统计分析时具有相似的用户体验。在我看来，每个应用的图形用户界面（GUI）都是基于电子表格的。如果你将典型的电子表格应用屏幕分成几个面板，其中一个面板显示数据，一个显示某些图表或数据的可视化，另一个描述回归分析或成分分析的结果，这就是这些中级统计应用的基本体验。我知道我的描述听起来有些轻视，所以请不要误解，我认为这些应用没有价值——恰恰相反。事实上，我所知道的一切都告诉我，它们非常有用。但软件公司，作为公司，有时会使用夸张的言辞让你认为他们的产品比竞争对手的产品高出一头，并且能迅速解决你的数据问题。尽管我承认我们在当前十年比过去几十年做得好得多，但这几乎从未成真。有一点是真实的：要成功使用统计应用，你必须至少对统计学有所了解。这些应用中没有一个会教你统计学，所以用冷静的头脑和敏锐的眼光去接近它们。通常，如果你想要选择一个，最好的选择就是你的朋友使用的那个，因为如果你遇到问题，他们可以帮你。跟随大众在这里可以是一件好事。
- en: These mid-level statistical applications do much more than look like a spreadsheet
    with panels. Their facilities for performing many different statistical analyses
    are generally far greater than Excel or any other spreadsheet program. It’s my
    impression that these software tools were built specifically to enable point-and-click
    data analysis with a level of sophistication that spreadsheets can’t approach.
    If you want to use a statistical technique that you can’t find in Excel’s menus,
    then you may want to level up to one of the aforementioned applications. Regression,
    optimization, component analysis, factor analysis, ANOVA (analysis of variance),
    and any number of other statistical methods are often done far better in a mid-level
    tool than in a spreadsheet, if it’s even possible in the latter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中级统计应用的功能远不止于看起来像带有面板的电子表格。它们执行多种不同统计分析的能力通常远超过Excel或其他任何电子表格程序。我的印象是，这些软件工具是专门为了实现具有高级复杂度的点选数据分析而构建的，这是电子表格所无法比拟的。如果你想要使用在Excel菜单中找不到的统计技术，那么你可能需要升级到上述提到的某个应用。回归分析、优化、成分分析、因子分析、方差分析（ANOVA）以及其他众多统计方法，在中级工具中通常比在电子表格中做得更好，如果后者甚至能实现的话。
- en: Beyond point-and-click statistical methods, these mid-level tools offer far
    greater versatility through their associated programming languages. Each of the
    proprietary tools I’ve mentioned has its own language for performing statistical
    analysis, which can be superior to point and click in both versatility and repeatability.
    With a programming language, you can do more than with clicking, and you can also
    save the code for future use, so you know exactly what you’ve done and can repeat
    it or modify it as necessary. A file containing a sequence of commands that can
    be run is generally called a *script* and is a common concept in programming.
    Not all languages can do this. Scripting languages are particularly useful in
    data science because data science is a process consisting of *steps*, actions
    performed on the data and models.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 除了点击式统计方法之外，这些中级工具通过其关联的编程语言提供了更大的多功能性。我提到的每个专有工具都有自己的语言来进行统计分析，这可以在灵活性和可重复性方面优于点击式操作。有了编程语言，你可以做更多的事情，你还可以保存代码以供将来使用，这样你就可以确切地知道你做了什么，并且可以根据需要重复或修改它。一个包含可运行命令序列的文件通常被称为*脚本*，这是编程中的一个常见概念。并非所有语言都能做到这一点。脚本语言在数据科学中特别有用，因为数据科学是一个由*步骤*组成的过程，是对数据进行操作和执行的动作。
- en: Learning the programming language of one of these mid-level tools can be a good
    step toward learning a real programming language, if that’s a goal of yours. These
    languages can be quite useful on their own. SAS, in particular, has a wide following
    in statistical industries, and learning its language is a reasonable goal unto
    itself.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些中级工具之一的编程语言，如果这是你的目标，那么这可以是一个很好的步骤，朝着学习真正的编程语言迈进。这些语言本身就可以非常实用。特别是SAS，在统计行业中拥有广泛的追随者，学习其语言本身就是一个合理的目标。
- en: 8.1.3\. Data science for the masses
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 适用于大众的数据科学
- en: Recent years have seen much ado about bringing data science to the *analyst*,
    the person who can directly use the intelligence gleaned from the data science
    itself. I’m wholly in favor of enabling everyone to gain insight from data, but
    I’m still not convinced that folks not trained in statistics should be applying
    them. Perhaps it’s the bias of a statistician’s ego, but in the face of uncertainty—as
    always in data science—recognizing that something in the analysis is going wrong
    takes training and experience.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，关于将数据科学带到*分析师*那里的话题引起了很大的关注，分析师是能够直接使用从数据科学本身获得智能的人。我完全支持让每个人都能从数据中获得洞察力，但我仍然不认为没有受过统计学训练的人应该应用它们。或许这是统计学家自我偏见的体现，但在面对不确定性的情况下——正如数据科学中始终如此——认识到分析中存在问题需要培训和经验。
- en: With that said, in this age of information, data, and software startups, it
    seems that someone is constantly claiming they make data science and analysis
    easy for everyone, even for beginners, and so you probably don’t need to hire
    a data scientist. To me, this is akin to saying that a web compendium of medical
    information can take the place of all medical professionals. Sure, in many cases,
    the web compendium or the new data science product can give equal or even superior
    results to those of the professionals, but only the professionals have the knowledge
    and experience to check the necessary conditions and recognize when a particular
    strategy goes wrong. I’ve emphasized in this book that awareness of possibilities
    in the face of uncertainty is a key aspect of data science, and I don’t think
    this will ever change. When the stakes matter, experience is incredibly important.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在这个信息、数据和软件创业公司盛行的时代，似乎总有人声称他们使数据科学和分析对每个人来说都变得简单，甚至对初学者也是如此，因此你可能不需要雇佣数据科学家。对我来说，这就像说一个包含医学信息的网络汇编可以取代所有医疗专业人员一样。当然，在许多情况下，网络汇编或新的数据科学产品可以提供与专业人员相当甚至更好的结果，但只有专业人员才有知识和经验来检查必要条件，并在特定策略出错时识别出来。我在这本书中强调，面对不确定性时的可能性意识是数据科学的关键方面，我认为这一点永远不会改变。当风险很大时，经验至关重要。
- en: 'It’s tempting to list a few of the new additions to the buffet of statistical
    applications in order to illustrate what I mean. But I’m not confident that most
    of them will be around in a few years, and besides that, the names don’t matter.
    In the past decade, data science has become big business and a highly sought-after
    skill. Whenever a skill makes news and money is spent acquiring it, there are
    always companies that claim to make it easy, with varying degrees of success.
    I challenge you, as a data scientist, to challenge newcomers to the software product
    industry who claim to trivialize our work. I write while trying to transcend my
    own ego: do they think they can accomplish with software what we can, maybe, accomplish
    only with careful consideration of the needs and wants of the project at hand,
    plus software and statistics?'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 很有诱惑力，想要列举一些新增加的统计应用来展示我的意思。但是，我不确定其中大部分在几年后是否仍然存在，而且除此之外，名字并不重要。在过去十年中，数据科学已经成为一个大生意，并且是一项非常受欢迎的技能。每当一项技能成为新闻，并且有人花钱去获取它时，总会有公司声称能够使它变得容易，成功率各不相同。我挑战你，作为一个数据科学家，去挑战那些声称简化我们工作的软件产品行业的新手。我在写作时试图超越自己的自我：他们是否认为他们可以用软件完成我们可能只能通过仔细考虑手头项目的需求和愿望，再加上软件和统计才能完成的事情？
- en: I digress, but I do want to share my (healthy, I think) skepticism for the analytic
    software industry. If anyone claims to have a magic pill for a seriously challenging
    task, please be skeptical. There are many good statistical software applications
    out there; it’s extremely unlikely that a new one can gain a huge advantage, but
    hey, I’ve been proven wrong before. New products are almost always variations
    on an old theme or purpose-built tools that are very good at one thing. Both can
    be useful, but figuring out the true range of applicability of something new can
    take some effort.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我虽然跑题了，但确实想分享我对分析软件行业的（我认为是健康的）怀疑态度。如果有人声称有一个针对严重挑战任务的神奇药丸，请保持怀疑态度。现在有许多好的统计软件应用；一个新应用获得巨大优势的可能性极低，但嘿，我之前已经被证明是错的。新产品几乎总是旧主题或目的性很强的工具的变体，它们在某一件事上非常出色。两者都可以是有用的，但确定新事物的真正适用范围可能需要一些努力。
- en: 8.2\. Programming
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 编程
- en: When an out-of-the-box software tool can’t—or doesn’t—cut it, you need to make
    your own. I mentioned in the previous section that the most popular mid-level
    statistical applications possess their own programming languages that can be used
    to extend functionality arbitrarily. With the possible exception of SAS and its
    tool set, none of these programming languages is usually considered as a language
    independent of its parent application—the language exists because of and in tandem
    with the application.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 当现成的软件工具无法或不能胜任时，你需要自己动手制作。我在上一节提到，最受欢迎的中级统计应用都有自己的编程语言，可以用来任意扩展功能。除了SAS及其工具集之外，这些编程语言通常不被视为与其母应用程序无关的语言——这种语言的存在是因为并且与该应用程序并行。
- en: There also exists a converse to this—otherwise standalone programming languages
    for which a GUI-based statistical application has been built. Both iPython for
    Python and RStudio for R are popular examples. The market of statistical applications
    can get a little confusing; I often see internet forum posts asking whether, for
    example, SPSS or R is better to learn. I can see how, maybe, the RStudio GUI and
    the SPSS GUI can seem roughly equivalent, but the real functionality of those
    two tools is vastly different. The choice between the two—or any mid-level statistical
    tool and a programming language—boils down to your desire to learn and use a programming
    language. If you don’t want to write any code, don’t choose any tool based on
    R or any other programming language.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也存在相反的情况——为某些独立编程语言构建了基于GUI的统计应用。Python的iPython和R的RStudio都是流行的例子。统计应用的市场可能会有些混乱；我经常看到互联网论坛帖子询问，例如，SPSS或R哪个更好学习。我可以理解，也许RStudio的GUI和SPSS的GUI看起来大致相同，但这两个工具的实际功能却大相径庭。两者之间的选择——或者任何中级统计工具和编程语言之间的选择——归结为你是否想要学习和使用编程语言。如果你不想编写任何代码，不要基于R或其他编程语言选择任何工具。
- en: Programming languages are far more versatile than mid-level statistical applications.
    Code in any popular language has the potential to do most anything. These languages
    can execute any number of instructions on any machine, can interact with other
    software services via APIs, and can be included in scripts and other pieces of
    software. A language that’s tied to its parent application is severely limited
    in these capacities.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言比中级统计应用要灵活得多。任何流行语言的代码都有可能做任何事情。这些语言可以在任何机器上执行任何数量的指令，可以通过API与其他软件服务交互，并且可以包含在脚本和其他软件组件中。与父应用程序绑定的语言在这些能力上受到严重限制。
- en: If you’re intimidated by code, programming isn’t as difficult as it might seem.
    Other than some short programs on my graphing calculator in high school, I didn’t
    write any code until a summer internship during college, and I didn’t begin in
    earnest until grad school. I sometimes wish I had begun earlier, but the fact
    remains that it isn’t hard to pick up some programming skills if you’re diligent.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被代码吓到了，编程并没有你想象的那么困难。除了我在高中图形计算器上写的几个简短程序外，我在大学期间的暑期实习之前没有写过任何代码，直到研究生阶段才开始认真编程。我有时希望我早点开始，但事实是，如果你勤奋，掌握一些编程技能并不难。
- en: 8.2.1\. Getting started with programming
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 编程入门
- en: I wrote my first programs on a graphing calculator during high school, but they
    weren’t sophisticated. The only programming course I took in college was called
    Object-Oriented Programming; I did fine in the course, but for some reason I didn’t
    program much at all until a summer internship at the Department of Defense, where
    I used MATLAB to analyze some image data. Between then and graduate school, during
    which I used R and MATLAB in bioinformatics applications, I slowly learned about
    these languages and programming in general. It’s not as if there was one point
    in my life when I decided to learn how to program, but rather I learned various
    aspects of programming as I needed them for various projects.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我在高中的时候就在图形计算器上编写了我的第一个程序，但它们并不复杂。我在大学里唯一上的编程课程叫做面向对象编程；我在这门课程中表现不错，但不知何故，直到在国防部的一个暑期实习期间，我使用MATLAB分析了一些图像数据之前，我几乎没有编程。在那之后到研究生期间，我在生物信息学应用中使用R和MATLAB，我逐渐了解了这些语言和编程。我的生活中并没有一个决定学习编程的时刻，而是随着各种项目需要，我学习了编程的各个方面。
- en: I don’t necessarily recommend this method of learning. In fact, there were plenty
    of times in which my lack of formal training led me to reinvent the wheel, as
    they say. It certainly helps to know what languages, tools, conventions, and resources
    are available for you to use before you begin. But there’s so much available that
    it can be hard to know where to start if you know little about software engineering
    in general.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不一定推荐这种方法来学习。事实上，有很多时候，我缺乏正规训练导致我不得不重新发明轮子，正如人们所说。在开始之前了解可用的语言、工具、规范和资源当然有帮助。但可供选择的东西太多了，如果你对软件工程知之甚少，可能会很难知道从哪里开始。
- en: It was only after graduate school, when I started working at a software company,
    that I gained valuable experience with Java, object-oriented programming, several
    different types of databases, REST APIs, and various useful coding conventions
    and good practices that most software developers probably already know and that
    I’ve found helpful. And all of it was real-life data science in the wild, so to
    speak, so it was doubly helpful for me to learn. For those who were like me a
    few years ago and don’t have much pure software development experience, I’ll share
    the things that I wish I had known as I was getting started. Hopefully, this section
    will help beginning programmers understand how certain aspects of programming
    relate to others and feel more comfortable using them, discussing them, and searching
    for more information about them.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 直到研究生毕业后，我开始在一家软件公司工作，才获得了宝贵的Java、面向对象编程、几种不同类型的数据库、REST API以及大多数软件开发者可能已经知道且我发现有用的各种有用的编码规范和良好实践的经验。所有这些都是所谓的现实生活中的数据科学，因此对我学习来说非常有帮助。对于那些几年前像我一样，没有太多纯软件开发经验的人，我会分享我在起步时希望知道的事情。希望这一部分能帮助初学者了解编程的某些方面如何与其他方面相关联，并使他们在使用、讨论和搜索更多相关信息时感到更加自在。
- en: Scripting
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脚本
- en: 'A program can be as simple as a list of commands to be executed in order. Such
    a list of commands is usually called a *script*, and the act of writing one is
    called *scripting*. In MATLAB (or the open-source clone GNU Octave), a script
    can be as simple as this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可以简单到只是一系列按顺序执行的命令。这样的一组命令通常被称为*脚本*，编写它的行为*脚本编写*。在MATLAB（或开源克隆GNU Octave）中，一个脚本可以像这样简单：
- en: '[PRE1]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The lines of this script set a variable named `filename` to the value `"timeseries.tsv"`,
    load the file whose name is contained in `filename` into the variable named `data-Matrix`,
    and then print on the screen the value contained in the second row and third column
    of `dataMatrix`. After installing MATLAB or Octave, there’s very little preventing
    a beginning programmer from writing a simple script like this. The file timeseries.tsv
    needs to be in a particular format—in this case, tab-separated values (TSV)—in
    order for the built-in function `dlmread` to be able to read it properly. And
    you’d have to know about `dlmread` and a little about the syntax of the language,
    but it’s easy to find good examples online and elsewhere.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中的行将一个名为`filename`的变量设置为`"timeseries.tsv"`的值，将包含在`filename`中的文件加载到名为`data-Matrix`的变量中，然后在屏幕上打印`dataMatrix`的第二行和第三列的值。安装MATLAB或Octave后，初学者编写这样一个简单的脚本几乎没有障碍。timeseries.tsv文件需要以特定的格式存在——在这种情况下，为制表符分隔值（TSV），以便内置函数`dlmread`能够正确读取它。您还需要了解`dlmread`以及语言语法的一些知识，但很容易在网上和其他地方找到好的例子。
- en: My main point in showing this extremely simple example is that it’s not that
    hard to get started with programming. If you have a spreadsheet, you can export
    a sheet of numeric values to TSV or CSV format and load the data as I’ve shown
    here, and you can immediately interact with the data via such a script, adding
    or removing commands to accomplish what you want.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示这个极其简单的例子的主要观点是，开始编程并不那么困难。如果您有一个电子表格，您可以将其数值表导出为TSV或CSV格式，并像我展示的那样加载数据，然后您可以通过这样的脚本立即与数据交互，添加或删除命令以完成您想要的工作。
- en: An important thing to note is that the commands of such a script can be run
    in both an interactive language shell as well as an operating system’s shell.
    That means you have a choice of writing a script and then telling your OS (how
    exactly depends on your OS) to run the whole script, or opening the interactive
    language shell and entering the commands directly within that shell. The OS method
    of running the script is generally more portable, and the interactive shell has
    the advantage of allowing line-by-line execution interspersed with other commands,
    edits, and checks that you might find helpful. For example, let’s say you forgot
    what’s in the file timeseries.tsv. In the interactive shell (to get to the interactive
    shell, open MATLAB, and the shell prompt appears immediately on the screen) you
    could run the first two lines of the previous script to load the file and then
    you could type `dataMatrix` at the prompt and press Enter to display the contents
    of that variable, which were loaded from timeseries.tsv. For a small file, this
    can be handy. An alternative is to open the file in Excel and look at the values
    there, which for some people is at least as appealing. But let’s say you wanted
    to see the two-millionth line of a table contained in a CSV. Excel would probably
    have serious trouble loading the file; as of this writing, no version of Excel
    can handle files with two million lines. But MATLAB would have no problem with
    it. To inspect the two-millionth line, load the file as shown earlier, and enter
    `dataMatrix(2000000,:)` on the interactive shell prompt.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，此类脚本的命令既可以在交互式语言壳中运行，也可以在操作系统的壳中运行。这意味着您可以选择编写一个脚本，然后告诉您的操作系统（具体方法取决于您的操作系统）运行整个脚本，或者打开交互式语言壳，并在该壳中直接输入命令。运行脚本的操作方法通常更便携，而交互式壳的优势在于允许在执行其他命令、编辑和检查时逐行执行，这可能对您有所帮助。例如，假设您忘记了文件timeseries.tsv的内容。在交互式壳中（要进入交互式壳，请打开MATLAB，壳提示立即出现在屏幕上），您可以运行前两条命令来加载文件，然后您可以在提示符下输入`dataMatrix`并按Enter键显示该变量的内容，这些内容是从timeseries.tsv加载的。对于小文件，这可能会很方便。另一种选择是在Excel中打开文件并查看那里的值，这对某些人来说至少同样吸引人。但假设您想查看包含在CSV中的表格的第二百万行。Excel可能很难加载该文件；截至本文撰写时，没有任何版本的Excel可以处理包含两百万行的文件。但MATLAB不会有任何问题。要检查第二百万行，请按照前面所示加载文件，然后在交互式壳提示符下输入`dataMatrix(2000000,:)`。
- en: 'I spent most of my early programming years on the interactive shells of MATLAB
    and R. My typical workflow would be this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大部分早期编程岁月都花在了MATLAB和R的交互式壳上。我的典型工作流程是这样的：
- en: Load some data into a variable in the interactive environment.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一些数据加载到交互式环境中的一个变量中。
- en: Play around with the data, inspecting and calculating some results.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据上玩弄，检查并计算一些结果。
- en: Copy the useful commands from step 2 into a file (script) for reuse later.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将步骤2中有用的命令复制到文件（脚本）中，以便以后重用。
- en: As my commands became more complex, the script file became longer and more complex.
    Most days, as I was analyzing data, and particularly in an exploratory phase,
    I would end up with a script containing exactly the commands that could return
    me to the state I was in so that I could continue my work on a later date. The
    script would load into the interactive environment whatever data sets I needed,
    make data transformations or calculations, and generate graphs and results.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我的命令变得越来越复杂，脚本文件也变得越来越长和复杂。大多数日子里，当我分析数据，尤其是在探索阶段，我最终会得到一个脚本，其中包含恰好能够让我回到当时状态的命令，这样我就可以在以后的日期继续我的工作了。这个脚本会加载到交互式环境中我需要的任何数据集，进行数据转换或计算，并生成图表和结果。
- en: 'For years this is the way I wrote programs: scripts that were created almost
    as a side effect of poking and prodding at data in an interactive shell environment.
    This haphazard way of writing software isn’t ideal—I’ll come back to some good
    coding conventions later in this section. But I do still encourage beginners to
    use it, at least at first, because it’s so easy to get started this way, and you
    can learn a lot about a language by trying various commands from an interactive
    shell.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，这就是我编写程序的方式：几乎作为在交互式壳环境中摆弄数据的副作用而创建的脚本。这种随意的编写软件方式并不理想——我将在本节的后面部分回到一些好的编码约定。但我仍然鼓励初学者使用它，至少一开始是这样，因为这种方式很容易开始，而且你可以通过尝试交互式壳中的各种命令来学习很多关于一种语言的知识。
- en: I still use scripts quite often, but they have their limits and disadvantages.
    If you find yourself not being able to read and comprehend your own scripts because
    they’re too long or complex, it may be time to use other styles or conventions.
    Likewise, if you’re copying and pasting a section of a script into another script,
    you should probably look for an alternative—what happens when you make a change
    to a copied section of one script but forget to change the other scripts in the
    same section? If a script or set of scripts seem complex or difficult to manage,
    it’s probably time to consider using functions or objects in your code; I’ll discuss
    those later in this section.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然经常使用脚本，但它们有其局限性和缺点。如果你发现自己无法阅读和理解自己的脚本，因为它们太长或太复杂，那么可能需要使用其他风格或约定。同样，如果你正在将脚本的一部分复制粘贴到另一个脚本中，你可能应该寻找替代方案——当你改变一个脚本中复制部分的某个部分时，但忘记改变同一部分的其他脚本会发生什么？如果一个脚本或一组脚本看起来很复杂或难以管理，那么可能是时候考虑在你的代码中使用函数或对象了；我将在本节的后面部分讨论这些。
- en: Switching from spreadsheets to scripts
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从电子表格切换到脚本
- en: The most common functionality of Excel and other spreadsheets can be replicated
    in scripting languages by using built-in commands such as `sum` and `sort` (versions
    of these are in every language) as well as using logical constructs involving
    `if` and `else` to check data for certain conditions. Beyond these, each language
    has thousands of functions (just like in Excel) that you can use in your commands.
    It’s a matter of figuring out which function does what you want and how it works.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: Excel和其他电子表格最常见的功能可以通过使用内置命令如`sum`和`sort`（这些命令的版本在每个语言中都有）以及使用涉及`if`和`else`的逻辑结构来检查数据是否符合某些条件来在脚本语言中复制。除此之外，每种语言都有数千个函数（就像在Excel中一样），你可以在你的命令中使用这些函数。这是一个找出哪个函数能做什么以及它是如何工作的过程。
- en: 'There’s one basic type of command that programming languages handle well and
    spreadsheets don’t: iteration. *Iteration* is repetition of a set of steps, possibly
    using different values each time. Let’s say that timeseries.tsv is a table of
    numeric values, where each row represents the purchase of some items from a store.
    The first column gives the item number, ranging from 1 to some number *n*, which
    uniquely identifies which item was purchased. The second column gives the quantity
    of the item purchased, and the third column gives the total amount paid. The file
    might look like this:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言处理得很好，而电子表格处理得不好的基本命令类型之一是迭代。*迭代*是一组步骤的重复，每次可能使用不同的值。假设 timeseries.tsv 是一个数值表，其中每一行代表商店购买的一些物品。第一列给出了项目编号，范围从
    1 到某个数字 *n*，它唯一地标识了购买的是哪个项目。第二列给出了购买物品的数量，第三列给出了支付的总金额。文件可能看起来像这样：
- en: '[PRE2]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But it’s probably longer if the store is successful.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果商店经营成功，可能更长。
- en: Let’s assume you want the total quantity sold of item 12, and the file has thousands
    of rows. In Excel, you could sort by item number, scroll to the rows for item
    12, and then use the `SUM` formula to add up the quantities. That might be quickest,
    but it’s a decent amount of manual work (sorting, scrolling, and summing), particularly
    if you expect to do this with other items as well, after item 12\. Another option
    in Excel is to create a new fourth column and use the `IF` formula in each cell
    of that column to test the first column for being equal to 12, giving 1 or 0 as
    a result (for true or false), multiplying the second and fourth columns row by
    row, and then adding up all the row products. This is also a fairly fast option,
    but if you want to see the sums for other items as well, you have to be clever
    about what formula you use and make sure you put the item number in a cell by
    itself—and refer to it in each of column 4’s formulas—so that you can change the
    item number only in one place in order to get its total quantity.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想获取项目 12 的总销售数量，而文件有数千行。在 Excel 中，您可以按项目编号排序，滚动到项目 12 的行，然后使用 `SUM` 公式将数量相加。这可能是最快的方法，但需要相当多的手动工作（排序、滚动和求和），尤其是如果您还预计要对项目
    12 之后的其它项目也这样做。在 Excel 中还有另一种选择，即创建一个新的第四列，并在该列的每个单元格中使用 `IF` 公式来测试第一列是否等于 12，结果为
    1 或 0（对于真或假），然后逐行乘以第二列和第四列，最后将所有行乘积相加。这也是一个相当快速的选择，但如果您还想查看其他项目的总和，您必须巧妙地使用公式，并确保将项目编号放在一个单独的单元格中——并在第四列的每个公式中引用它——这样您就只需在一个地方更改项目编号，以获取其总数量。
- en: 'Either of those Excel solutions can work if you want the quantity for only
    one or a few items, but what if you wanted total quantities for all item numbers?
    The sorting strategy would get quite tedious, as would the creating of extra columns,
    regardless of whether you created one extra column and then changed the item number
    or you created a new column for each item number. There’s probably a better solution
    in Excel involving conditional lookups or searching for values, but I can’t come
    up with it offhand. If you know Excel inside and out, you probably know much better
    than I do how to solve this problem. The point I’m trying to make is that this
    type of problem is easy to do in most programming languages. In MATLAB, for example,
    after reading the file into the variable `dataMatrix` as shown earlier, you need
    only write the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想获取一个或几个项目的数量，那么上述任何一种 Excel 解决方案都可以工作，但如果您需要所有项目编号的总数量呢？排序策略会变得相当繁琐，创建额外列也是如此，无论您是创建了一个额外的列然后更改项目编号，还是为每个项目编号创建了一个新列。在
    Excel 中，可能有一个更好的解决方案，涉及条件查找或搜索值，但我一时想不出来。如果您对 Excel 非常熟悉，您可能比我更清楚如何解决这个问题。我试图说明的是，这种类型的问题在大多数编程语言中都很容易解决。例如，在
    MATLAB 中，在将文件读取到前面显示的变量 `dataMatrix` 之后，您只需编写以下代码：
- en: '[PRE3]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code first finds the number of rows, `nrows`, in `dataMatrix` and then
    initializes a vector `totalQuantities` of 1000 values, starting at zero, to which
    the quantities will be added. The k^(th) entry in `totalQuantities`, accessed
    by the command `total-Quantities(k)`, will give the total quantity sold of item
    k. If item numbers are above 1000, you’d need to make this vector longer. The
    `for` loop, which is the common name for the type of code structure between `for`
    and `end`, iterates through the rows of `dataMatrix` (in each iteration, the current
    row is given by the variable `i`) adding the value contained in row i, column
    2 of `dataMatrix` to its proper place in `totalQuantities`, which is given by
    the value in row i, column 1 of `dataMatrix`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先找到`dataMatrix`中的行数`nrows`，然后初始化一个包含1000个值的向量`totalQuantities`，从零开始，将数量添加到这个向量中。通过命令`total-Quantities(k)`访问`totalQuantities`中的第k个条目，将给出第k个商品的总销售量。如果商品编号超过1000，你需要使这个向量更长。`for`循环，通常称为`for`和`end`之间的代码结构类型，遍历`dataMatrix`的行（在每次迭代中，当前行由变量`i`给出），将`dataMatrix`中第i行第2列的值添加到`totalQuantities`中适当的位置，该位置由`dataMatrix`中第i行第1列的值给出。
- en: To some people who haven’t written code before, this example may seem more complicated
    than using Excel or some other tool they know. But I think it should be clear
    that almost anyone can get started with a scripting language and interactive shell
    and be producing results with only a bit of knowledge.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些之前没有编写过代码的人来说，这个例子可能比使用Excel或其他他们所知道的工具要复杂。但我认为应该很清楚，几乎任何人都可以通过脚本语言和交互式shell开始，并且只需要一点知识就能产生结果。
- en: Functions
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数
- en: I mentioned previously that scripts can sometimes grow long, complicated, and
    difficult to manage. You might also end up with multiple scripts that have some
    common steps or commands—if, for example, different scripts need data loaded in
    the same way, or different scripts load different data but process the data sets
    in the same way. If you find yourself copying and pasting code from one file to
    another and you intend to continue using both, it’s time to think about creating
    a function.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，脚本有时可能会变得很长、复杂，难以管理。你也可能拥有多个包含一些共同步骤或命令的脚本——例如，如果不同的脚本需要以相同的方式加载数据，或者不同的脚本加载数据但以相同的方式处理数据集。如果你发现自己正在从一个文件复制粘贴代码到另一个文件，并且打算继续使用这两个文件，那么是时候考虑创建一个函数了。
- en: 'Let’s say you need to use the previous data file, timeseries.tsv, in multiple
    scripts. You can create a function in MATLAB by creating a file called loadData.m
    with the following contents:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要将之前的数据文件timeseries.tsv用于多个脚本。你可以在MATLAB中通过创建一个名为loadData.m的文件并包含以下内容来创建一个函数：
- en: '[PRE4]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And then you can include the following line in a script
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在脚本中包含以下行
- en: '[PRE5]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: in order to load the data from timeseries.tsv into the variable `dataMatrix`
    as before. In my scripts, I’ve merely replaced two lines with one, but if you
    change the filename or its location, among other things, now you’ll have to do
    that only in the function and not in various scripts. This also becomes more useful
    when you have more than two lines of code that you’re sharing between scripts.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据从timeseries.tsv加载到变量`dataMatrix`中，就像之前一样。在我的脚本中，我只是将两行替换为一行，但如果你更改文件名或其位置等其他事情，现在你只需要在函数中做，而不是在多个脚本中做。当你有超过两行代码需要在脚本之间共享时，这也变得更有用。
- en: Functions, by design and like mathematical functions, can take inputs and give
    outputs. In the previous case, there are no inputs, but there is an output, the
    variable `data`; it’s specified as the output on the first line of the function
    file. Within a script, functions also don’t change any variables except the one
    to which the function output is assigned—in this case, `dataMatrix`. In that way,
    using functions is a good way to isolate code for the purpose of reuse between
    scripts.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，按照设计，就像数学函数一样，可以接受输入并给出输出。在前面的例子中，没有输入，但有一个输出，变量`data`；它在函数文件的第一行指定为输出。在脚本内部，函数也不会改变任何变量，除了函数输出分配到的变量之外——在这个例子中是`dataMatrix`。因此，使用函数是隔离代码以在脚本之间重用的一种好方法。
- en: Functions are also good for understanding what code does. Within your script,
    it’s easy to read and understand the function call `loadData()` when most of the
    time you probably don’t care how exactly the data is loaded, as long as it’s working
    correctly. If loading data consisted of many steps, pushing those steps into a
    function would greatly improve the readability of that part of the script. If
    you have many chunks in your script that work together for a single purpose, like
    loading data, then you might want to push each of them into its own function and
    turn your script into a sequence of well-named function calls. Doing so is usually
    much easier on the eyes.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对于理解代码的功能也是很好的。在你的脚本中，当你大多数时间并不关心数据是如何被加载的，只要它能正确工作，阅读和理解函数调用`loadData()`就很容易。如果加载数据包含许多步骤，将这些步骤推入函数将大大提高脚本该部分的可读性。如果你脚本中有许多块代码协同工作以实现单一目的，比如加载数据，那么你可能希望将每个块推入它自己的函数，并将你的脚本转换为一串命名良好的函数调用。这样做通常对眼睛来说更容易。
- en: For your reference, functional programming is a somewhat popular programming
    paradigm—in contrast to object-oriented programming—in which functions are first-class
    citizens; functional programs emphasize the creation and manipulation of functions,
    even to the point of having anonymous functions and treating functions as variables.
    The main thing to know about functional programming is that, under the strict
    paradigm, functions have no side effects. If you call a function, there are inputs
    and there are outputs, and no other variables from the calling environment are
    affected. It’s as if the inner workings of a function occur somewhere else, in
    a completely separate environment, until the function returns its output.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，函数式编程是一种相对流行的编程范式——与面向对象编程相对——其中函数是一等公民；函数式程序强调函数的创建和操作，甚至包括匿名函数和将函数视为变量的处理。关于函数式编程，你需要知道的主要一点是，在严格的范式下，函数没有副作用。如果你调用一个函数，有输入和输出，并且不会影响调用环境的其他变量。就像函数的内部工作发生在某个完全独立的环境中一样，直到函数返回其输出。
- en: Whether or not you care about the specifics of the functional paradigm and its
    theoretical implications, functions themselves are useful for encapsulating generally
    cohesive blocks of code.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否关心函数式范式的具体细节及其理论影响，函数本身对于封装通常连贯的代码块是有用的。
- en: Object-oriented programming
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Functions and functional programming can be said to be concerned with *action*,
    whereas object-oriented programming can be said to be concerned with *things*,
    but those things can also perform actions. In object-oriented programming, *objects*
    are entities that may contain data as well as their own function-like instructions
    called *methods*. An object usually has a cohesive purpose, much like a function
    would, but it behaves differently.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和函数式编程可以说关注的是*动作*，而面向对象编程可以说关注的是*事物*，但这些事物也可以执行动作。在面向对象编程中，*对象*是可能包含数据和自身类似函数的指令，即*方法*的实体。一个对象通常有一个连贯的目的，就像函数一样，但它的行为却不同。
- en: 'For example, you could create an object class called `DataLoader` and use it
    to load your data. I haven’t used much object-oriented functionality in MATLAB,
    so I’m going to switch to Python here; more on Python later in this chapter. In
    Python, the class file named dataLoader.py might look like this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个名为`DataLoader`的对象类，并使用它来加载数据。我在MATLAB中并没有使用很多面向对象的功能，所以在这里我将切换到Python；本章后面会详细介绍Python。在Python中，名为dataLoader.py的类文件可能看起来像这样：
- en: '[PRE6]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line imports the `csv` package that’s used to load the data from the
    file. After that, you see the word `class` and the name of the class, `DataLoader`.
    Inside the class, indented, are three method definitions.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入了用于从文件加载数据的`csv`包。之后，你看到单词`class`和类的名称`DataLoader`。在类内部，缩进处有三个方法定义。
- en: The first input for each of the methods is the variable `self`, which represents
    this instance of the `DataLoader` object itself. The methods need to be able to
    refer to the object itself because methods are able to set and change the object’s
    attributes, or *state*, which is an important aspect of object-oriented programming,
    as I’ll illustrate.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的第一个输入是变量`self`，它代表`DataLoader`对象本身的这个实例。方法需要能够引用对象本身，因为方法能够设置和改变对象的属性，或*状态*，这是面向对象编程的一个重要方面，我将举例说明。
- en: The first method defined, `__init__`, is the one that’s called when the object
    is created, or instantiated. Any object attributes that are essential to the existence
    and functionality of the object should be set here. In the case of `DataLoader`,
    the `__init__` method takes a parameter called `filename`, which is the filename
    from which the object will load the data. When a `DataLoader` object is instantiated
    in a script via a command such as
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的第一个方法 `__init__` 是在创建对象或实例化时被调用的方法。任何对于对象存在和功能至关重要的属性都应该在这里设置。在 `DataLoader`
    的情况下，`__init__` 方法接受一个名为 `filename` 的参数，这是对象将从其中加载数据的文件名。当在脚本中通过命令如
- en: '[PRE7]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: the single input parameter is passed to the `__init__` method for use by the
    object. The definition of `__init__` shows that `__init__` assigns this input
    parameter to the object attribute `self.filename`. Object attributes are set and
    accessed this way in Python. After instantiating the object via the `__init__`
    method, the object, which is now called `dl` in the script (or interactive shell
    environment), has its `self.filename` attribute set to timeseries.tsv, but the
    object contains no data.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 单个输入参数被传递给 `__init__` 方法供对象使用。`__init__` 的定义显示 `__init__` 将这个输入参数分配给对象属性 `self.filename`。在
    Python 中，就是这样设置和访问对象属性的。通过 `__init__` 方法实例化对象后，现在在脚本中被称为 `dl` 的对象（或在交互式外壳环境中），其
    `self.filename` 属性被设置为 timeseries.tsv，但对象中不包含任何数据。
- en: To load data from the named file into the object, you must use the `load` method
    via the command
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命名的文件中加载数据到对象中，你必须使用 `load` 方法通过命令
- en: '[PRE8]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: which, according to the method definition, creates an attribute for the data
    as an empty list, `self.data`, opens the file named by self.filename, and then
    loads the data line by line into `self.data`. After this method is executed, all
    data from the file has now been loaded into the `self.data` attribute of the `DataLoader`
    object called `dl`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 根据方法定义，这将为数据创建一个空列表属性 `self.data`，打开名为 self.filename 的文件，然后将数据逐行加载到 `self.data`
    中。在此方法执行后，现在所有数据都已加载到名为 `dl` 的 `DataLoader` 对象的 `self.data` 属性中。
- en: If you want to then access and work with the data, you can use the third method
    defined, `getData`, which uses a `return` statement to pass the data as output
    to the calling script, much like a function.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问并处理数据，可以使用定义的第三个方法 `getData`，它使用 `return` 语句将数据作为输出传递给调用脚本，就像一个函数一样。
- en: 'Given the object class definition, a script that loads and gets the data for
    use might look like the following:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象类定义，一个加载并获取数据以供使用的脚本可能看起来如下：
- en: '[PRE9]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though this accomplishes the same thing as my original script in MATLAB
    or one that uses functions, the way in which things are accomplished in this script,
    which uses an object, is fundamentally different. The first thing that happens
    after importing the class definition is the creation of a `DataLoader` object
    called `dl`. Inside `dl` is a separate environment where the object’s attributes
    are preserved, conceptually out of sight of the main script. Functions don’t have
    attributes and are therefore stateless, whereas an object’s attributes—its state—can
    be used during method calls to affect the results or output of the method. Objects
    and their methods can have side effects.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这实现了与我在 MATLAB 或使用函数的原脚本相同的功能，但在这个脚本中，使用对象实现的方式在本质上是有区别的。在导入类定义之后发生的第一件事是创建一个名为
    `dl` 的 `DataLoader` 对象。在 `dl` 中有一个独立的环境，其中保存了对象的属性，从概念上讲，这些属性在主脚本之外。函数没有属性，因此是无状态的，而对象的属性——其状态——可以在方法调用期间被用来影响方法的结果或输出。对象及其方法可以有副作用。
- en: Side effects and preserving state attributes can have big advantages, but they
    can also be dangerous if you’re not careful. Functions, strictly speaking, should
    never change the value of an input variable, but objects and their methods can
    do so. On some occasions, I’ve constructed objects with methods that manipulated
    their input variables in some way that was convenient for calculating the method’s
    output. Several times in my life, before I learned to be more careful, I didn’t
    realize that in manipulating the values of the input within a method I was also
    affecting their values outside the method and object, in the calling script or
    environment. Mathematicians and other functionally minded people don’t always
    consider that type of unintended side effect at first.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用和保留状态属性可能具有很大的优势，但如果不小心，也可能很危险。严格来说，函数不应该改变输入变量的值，但对象及其方法可以这样做。在某些情况下，我构建了具有以某种方便计算方法输出的方式操作输入变量的方法的对象。在我学会更加小心之前，我多次没有意识到，在方法内部操作输入值时，我实际上也在影响方法或对象之外，在调用脚本或环境中的值。数学家和其他具有函数性思维的人并不总是首先考虑那种意外的副作用。
- en: One big advantage of using an object is that objects offer a good way to gather
    a bunch of closely related data and functions into a single self-contained entity.
    In the case of loading data, the main script probably doesn’t care where the data
    is coming from or how it’s being loaded. In this scenario, in which certain groups
    of variables or values never interact directly with one another, according to
    the object-oriented paradigm they should probably be sequestered from each other
    in some way, and containing them within their own objects can be a good option
    to accomplish this. Likewise, any functions that deal almost exclusively with
    such a group of variables should probably be converted into object methods in
    the object that contains those variables.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象的一个重大优势是，对象提供了一种很好的方式，将大量紧密相关的数据和函数聚集到一个单一的自包含实体中。在加载数据的情况下，主脚本可能并不关心数据来自哪里或如何加载。在这种情况下，当某些变量或值组之间从未直接交互时，根据面向对象范式，它们可能应该以某种方式相互隔离，并将它们包含在自己的对象中可能是一个实现这一目标的良好选择。同样，任何几乎仅与这样一组变量打交道的函数可能都应该转换为包含这些变量的对象中的对象方法。
- en: The main advantages of separating program data, attributes, functions, and methods
    into purposefully cohesive objects are primarily in readability, extensibility,
    and maintenance. As with well-written functions, well-constructed objects allow
    code to be more easily understood, more easily expanded or modified, and more
    easily debugged.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序数据、属性、函数和方法有意地分离成目的性统一的对象的主要优势主要在于可读性、可扩展性和可维护性。就像编写良好的函数一样，构建良好的对象使得代码更容易理解，更容易扩展或修改，也更容易调试。
- en: Between functional and object-oriented programming, neither is absolutely better
    than the other. Each has advantages and disadvantages, and you can often borrow
    from both paradigms to write code that works best for your purposes. It’s important,
    however, to be careful with the states of your objects, because if you’re mixing
    functions and objects, it might be easy to treat an object method like a function
    when it has side effects.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程和面向对象编程之间，没有一个绝对优于另一个。每个都有其优点和缺点，你通常可以从这两个范式中学到东西，以编写最适合你目的的代码。然而，重要的是要小心处理对象的状态，因为如果你混合了函数和对象，可能会很容易将对象方法当作函数来处理，而它具有副作用。
- en: 'One thing I’d like to note: throughout this section, I talk about a calling
    script or main script as if there is always one master script that makes use of
    a set of functions and objects. This is not always the case. I wrote that way
    for clarity for beginners, but in practice functions can call functions and use
    objects, objects can call functions and use objects, and there might not even
    be a script at all, which is the topic of the next section.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要指出的一点是：在本节中，我谈论调用脚本或主脚本时，好像总有一个主脚本在使用一组函数和对象。这并不总是情况。我这样写是为了初学者的清晰，但在实践中，函数可以调用函数并使用对象，对象可以调用函数并使用对象，甚至可能根本不存在脚本，这是下一节的主题。
- en: Applications
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用
- en: In this context, I use the term *application* in contrast with *script*. A *script*,
    as I’ve discussed, is a sequence of commands to be executed. I use the word *application*
    to mean something that, when started or opened, becomes ready for use and to perform
    some task or action for the user. In that way, an application is conceptually
    similar to an object in programming, because an object can be created and then
    used in various ways by whatever created it. A script, on the other hand, is more
    similar to a function, because it merely completes a sequence of actions in a
    straightforward fashion.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我使用术语*应用程序*与*脚本*相对。正如我之前讨论的，*脚本*是一系列要执行的命令。我使用“应用程序”一词来表示当启动或打开时，可以准备就绪并执行某些任务或动作以供用户使用的东西。从这种意义上说，应用程序在概念上与编程中的对象相似，因为对象可以被创建，然后由创建它的任何东西以各种方式使用。另一方面，脚本更类似于函数，因为它只是以直接的方式完成一系列动作。
- en: Spreadsheets are applications, as are websites and apps on mobile devices. They’re
    all applications in the sense I described earlier, because when they’re started,
    they initialize but might not do much until the user interacts with them. It’s
    primarily in this interaction with the user that applications are useful, unlike
    scripts, which generally produce a tangible result that provides some usefulness.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格是应用程序，网站和移动设备上的应用程序也是如此。它们都是我之前描述的那种应用程序，因为当它们启动时，它们会初始化，但可能不会做很多事情，直到用户与之交互。应用程序的主要用途在于与用户的这种交互，与脚本不同，脚本通常会产生一个有形的结果，提供一些实用性。
- en: It would be hard to provide enough useful information here to get you started
    into application development. It’s somewhat more complicated than scripting, so
    I’ll point out a few concepts that might be useful to a data scientist. For more
    information, you’ll find plenty of references and examples on the internet.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提供足够的信息以帮助您开始应用程序开发可能会有点困难。它比脚本编写稍微复杂一些，所以我将指出一些可能对数据科学家有用的概念。更多信息，您可以在互联网上找到大量的参考资料和示例。
- en: The main reason application development has become useful for data scientists
    is that sometimes delivering a static report to your customer isn’t enough. I’ve
    often delivered to a customer reports that I feel are quite thorough, only to
    be asked for more detail on certain points. Sure, I could provide the customer
    with more detail in specific areas, maybe in an additional report, but only after
    going back to the data myself and extracting those details. I might have been
    better off delivering a piece of software that allowed my customer to delve deeper
    into each aspect of the report that they found interesting. I could have accomplished
    this perhaps by setting up a database and a web application that allowed the customer
    to click around through nice representations of the results and data in a standard
    web browser. This is precisely how most analytic software companies are delivering
    their product these days. All the analytics are behind the scenes, whereas a web
    application delivers the results in a way that’s friendlier and more useful than
    a report.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发对数据科学家变得有用的主要原因有时向客户交付静态报告是不够的。我经常向客户交付我认为相当详尽的报告，但客户却要求在某些点上提供更多细节。当然，我可以向客户提供特定领域的更多细节，也许在额外的报告中，但必须在我自己回到数据中提取这些细节之后。我可能做得更好，提供一段软件，让客户能够深入探究他们感兴趣的每个报告方面。我可能通过设置数据库和Web应用程序来实现这一点，允许客户通过标准Web浏览器点击浏览结果和数据的良好表示。这正是大多数分析软件公司今天交付产品的方式。所有分析都在幕后进行，而Web应用程序以比报告更友好、更有用的方式交付结果。
- en: Data scientists also create applications that consume and analyze data in real
    time or otherwise interactively. Google, Twitter, Facebook, and many other websites
    use fairly complex analytic methods that are continually delivered to the web
    via applications. Trending topics, top stories, and search results are all the
    product of data-science-heavy applications.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家还创建应用程序，这些应用程序可以实时或以其他方式交互式地消耗和分析数据。Google、Twitter、Facebook以及许多其他网站使用相当复杂的方法进行数据分析，这些方法通过应用程序持续地发送到网络上。热门话题、头条新闻和搜索结果都是数据科学密集型应用程序的产物。
- en: 'But, as I said, creating an application isn’t as straightforward as writing
    a script, so I’ll save the space, skip the detail here, and suggest that you consult
    references written by someone far better informed than I am. But if you’re interested
    and you already have some experience with a programming language, have a look
    at these frameworks for building web applications in data-friendly languages:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我所说的，创建一个应用程序并不像编写脚本那样简单，所以我会节省空间，在这里跳过细节，并建议你查阅比我更有信息的人写的参考资料。但是，如果你对此感兴趣并且已经有一些编程语言的经验，可以查看这些在数据友好型语言中构建
    Web 应用程序的开源框架：
- en: Flask for Python
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask for Python
- en: Shiny for R
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shiny for R
- en: Node.js for JavaScript, plus D3.js for awesome data-driven graphics
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js for JavaScript，加上 D3.js 用于惊人的数据驱动图形
- en: 8.2.2\. Languages
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 语言
- en: I’ll now introduce three scripting languages that I’ve used for data science
    and related programming tasks, to compare and contrast them, not to describe them
    in great detail. The languages are GNU Octave (an open-source clone of MATLAB),
    R, and Python. For these languages, I give example code, in each case using the
    item sales quantity example from [section 8.2.1](kindle_split_018_split_002.xhtml#ch08lev2sec4),
    and a timeseries.tsv data file in the same format I described. I define one function
    for loading the data, and then the scripts tally the quantities sold for all items
    (up to 1000 of them) and print to the screen the total quantity sold of item 12.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将介绍三种我用于数据科学和相关编程任务的脚本语言，以便比较和对比它们，而不是详细描述它们。这些语言是 GNU Octave（MATLAB 的开源克隆）、R
    和 Python。对于这些语言，我给出示例代码，每个案例都使用 [8.2.1 节](kindle_split_018_split_002.xhtml#ch08lev2sec4)
    中的商品销售数量示例以及我描述的相同格式的 timeseries.tsv 数据文件。我定义了一个用于加载数据的函数，然后脚本统计所有商品（最多 1000 件）的销售数量，并将商品
    12 的总销售数量打印到屏幕上。
- en: After discussing the three scripting languages, I talk a little about a language
    that isn’t a scripting language (so an example script isn’t possible) but that
    is important enough to software development in general and data science as well
    that I feel I should mention it. This language is Java.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了三种脚本语言之后，我简要地谈到了一种不是脚本语言的语言（因此不可能提供一个示例脚本），但它在软件开发和数据分析方面都足够重要，我认为我应该提到它。这种语言是
    Java。
- en: MATLAB and Octave
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MATLAB 和 Octave
- en: MATLAB is a proprietary software environment and programming language that’s
    good at working with matrices. MATLAB costs quite a bit—over $2000 for a single
    software license as of this writing—but there are significant discounts for students
    and other university-affiliated people. Some folks decided to replicate it in
    an open-source project called Octave. As Octave has matured, it has become closer
    and closer to MATLAB in available functionality and capability. Excepting code
    that uses add-on packages (a.k.a. toolboxes), the vast majority of code written
    in MATLAB will work in Octave and vice versa, which is nice if you find yourself
    with some MATLAB code but no license. In my experience, you’ll most likely need
    to change some function calls for compatibility but not necessarily many. I once
    got several hundred lines of my own MATLAB code running in Octave after finding
    approximately 10 lines of code containing incompatibilities.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB 是一种专有软件环境和编程语言，擅长处理矩阵运算。根据本文写作时的价格，MATLAB 的成本相当高——单软件许可证就超过 2000 美元——但对于学生和其他大学相关人士有显著的折扣。有些人决定在一个名为
    Octave 的开源项目中复制它。随着 Octave 的成熟，它在可用功能和能力上越来越接近 MATLAB。除了使用附加包（即工具箱）的代码外，大多数用 MATLAB
    编写的代码在 Octave 中也能运行，反之亦然，这对于那些拥有 MATLAB 代码但没有许可证的人来说是个好消息。根据我的经验，你可能需要更改一些函数调用以实现兼容性，但不必很多。我曾经在我的
    MATLAB 代码中找到大约 10 行存在不兼容性的代码后，让几百行代码在 Octave 中运行。
- en: The near-total mutual compatibility, when not using add-on packages, is great,
    but Octave falls short in performance as well. From what I can gather from the
    internet, MATLAB can be two or three times faster than Octave for numerical operations,
    which sounds about right from my own experience, though I haven’t done a direct
    comparison. Because both MATLAB and Octave are designed for matrix and vector
    operations, you have to write vectorized code if you want to take full advantage
    of the languages’ efficiencies. Apparently, if you have code that isn’t vectorized
    but should be, such as using `for` loops to multiply matrices, MATLAB is better
    at recognizing what’s happening and compiling the code so that it’s almost as
    fast as if it was explicitly vectorized. Octave might not be able to do this yet.
    In any case, making use of the efficiencies of vectorized code when working with
    vectors and matrices will always make your code faster, sometimes dramatically.
    This is true in MATLAB, Octave, R, and Python, among others.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 当不使用附加包时，几乎完全兼容性非常好，但Octave在性能方面有所不足。从我在互联网上收集的信息来看，MATLAB在数值运算方面可能比Octave快两到三倍，这从我自己的经验来看似乎是合理的，尽管我没有进行过直接比较。因为MATLAB和Octave都是为了矩阵和向量运算而设计的，所以如果你想充分利用语言的效率，你必须编写向量化的代码。显然，如果你有应该向量化但未向量化的代码，例如使用`for`循环来乘矩阵，MATLAB在识别正在发生的事情并编译代码方面做得更好，这样代码的执行速度几乎与显式向量化一样快。Octave可能还做不到这一点。无论如何，利用向量化代码的效率来处理向量和矩阵始终会使你的代码更快，有时甚至非常显著。这在MATLAB、Octave、R和Python等其他语言中都是如此。
- en: Writing vectorized code in MATLAB and Octave is extremely easy for anyone familiar
    with matrix operations, because the code looks exactly like the equivalent mathematical
    expression. This isn’t true for the other languages I discuss here. For example,
    if you have two matrices, `A` and `B`, of compatible dimensions, multiplying them
    in the standard sense (not entry-wise) can be accomplished by writing
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在MATLAB和Octave中编写向量化的代码对于熟悉矩阵运算的人来说非常容易，因为代码看起来与等价的数学表达式完全一样。这在其他我讨论的语言中并不成立。例如，如果你有两个兼容维度的矩阵`A`和`B`，按照标准方式（非逐元素）相乘可以通过编写以下代码来完成
- en: '[PRE10]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: whereas an entry-wise product for matrices `A` and `B` of identical dimensions
    is performed via
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于维度相同的矩阵`A`和`B`的逐元素乘积是通过以下方式实现的
- en: '[PRE11]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both of these operations are vectorized. Note that if the mathematical expression
    calls for transposing a matrix or vector, you likewise have to transpose it in
    the code or you may get an error or an incorrect result. The transpose operator
    is a single quote following the matrix, as in `A'`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作都是向量化的。请注意，如果数学表达式需要转置矩阵或向量，你同样需要在代码中转置它，否则可能会得到错误或错误的结果。转置运算符是矩阵后面的单个引号，如`A'`。
- en: For reference, non-vectorized equivalents of these, matrix multiplication would
    probably involve at least two nested `for` loops over the rows and columns of
    the matrices. The vectorized versions are both easier to write and faster to execute,
    so it’s best to vectorize whenever possible. Both R and Python can use vectorization
    as well, but multiplying matrices in those languages defaults to the entry-wise
    version of multiplication, though alternatives are provided for standard matrix
    multiplication.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，这些非向量化的等价操作，矩阵乘法可能至少涉及两个嵌套的`for`循环，遍历矩阵的行和列。向量化的版本既容易编写，执行速度也更快，因此尽可能进行向量化是最佳选择。R和Python也可以使用向量化，但那些语言中矩阵乘法的默认方式是逐元素版本，尽管提供了标准矩阵乘法的替代方案。
- en: 'As a slightly more informative introduction to MATLAB and Octave syntax, you
    can implement the item sales quantity example by creating a file named loadData.m
    containing the function `loadData` by writing the following lines:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对MATLAB和Octave语法的稍作介绍，你可以通过创建一个名为loadData.m的文件并编写以下行来实现项目销售数量的示例：
- en: '[PRE12]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the same directory, create a script file named itemSalesScript.m containing
    the following lines:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，创建一个名为itemSalesScript.m的脚本文件，包含以下行：
- en: '[PRE13]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can run this script in Octave from a Unix/Linux/Mac OS command line via
    the command
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令在Unix/Linux/Mac OS命令行中从Octave运行此脚本
- en: '[PRE14]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: and the output written to the command line should be the total quantity sold
    of item 12 appearing in your data file. To run the same code at the MATLAB or
    Octave prompt, copy and paste the contents of itemSalesScript.m to the prompt
    and press Enter.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到命令行的结果应该是你数据文件中出现的项目12的总销售量。要在MATLAB或Octave提示符下运行相同的代码，请将itemSalesScript.m文件的内容复制并粘贴到提示符中，然后按Enter键。
- en: 'I would use MATLAB or Octave in the following situations:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，我会使用 MATLAB 或 Octave：
- en: If I’m working with large matrices or large numbers of matrices.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在处理大型矩阵或大量矩阵。
- en: If I know that a particular add-on package, particularly in MATLAB, will be
    greatly useful.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我知道某个特定的附加包，特别是在 MATLAB 中，将会非常有用。
- en: If I have a MATLAB license and I like the matrix-friendly syntax.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我有 MATLAB 许可证并且喜欢矩阵友好的语法。
- en: 'I would not use MATLAB or Octave in these circumstances:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，我不会使用 MATLAB 或 Octave：
- en: If I have data that isn’t well represented by tables or matrices.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我的数据不适合用表格或矩阵表示。
- en: If I want my code to integrate with other software; it can be difficult and
    complicated because of MATLAB’s relatively narrow set of intended applications,
    though many types of integrations are possible.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想让我的代码与其他软件集成；由于 MATLAB 的应用范围相对较窄，这可能会很困难且复杂，尽管许多类型的集成都是可能的。
- en: If I want to include my code in a software product to be sold. MATLAB’s license
    in particular can make this difficult legally.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想将我的代码包含在要出售的软件产品中。特别是 MATLAB 的许可证可能会在法律上使这变得困难。
- en: Overall, MATLAB and Octave are great for engineers (in particular electrical)
    who work with large matrices in signal processing, communications, image processing,
    and optimization, among others.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，MATLAB 和 Octave 对于工程师（尤其是电气工程师）来说非常出色，他们需要在信号处理、通信、图像处理和优化等领域处理大型矩阵。
- en: For a look at some of my Octave code (ported from MATLAB once upon a time) from
    a few years ago, see my bioinformatics project on gene interaction on GitHub at
    [https://github.com/briangodsey/bacon-for-gene-networks](https://github.com/briangodsey/bacon-for-gene-networks).
    The code is pretty messy, but please don’t fault me for past sins. In a way, that
    code and that of my other bioinformatics projects represent a kind of snapshot
    of my hybrid scripts-and-functions coding style at the time.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我几年前的一些 Octave 代码（曾经从 MATLAB 转移过来），请参阅我在 GitHub 上的生物信息学项目，关于基因互作的项目[https://github.com/briangodsey/bacon-for-gene-networks](https://github.com/briangodsey/bacon-for-gene-networks)。代码相当杂乱，但请不要因为过去的错误而责怪我。从某种意义上说，那段代码以及我的其他生物信息学项目代表了我当时混合脚本和函数编码风格的一种快照。
- en: R
  id: totrans-583
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: R
- en: 'My first note about R: if you want to search for help on the internet, putting
    the letter *R* in the search box can lead you to some funny places, though search
    engines are getting smarter every day. If you have trouble getting good search
    results, try putting the acronym *CRAN* in the box as well; CRAN is the Comprehensive
    R Archive Network and can help Google (and other search engines) direct you to
    appropriate sites.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 R 的第一个笔记：如果你想在网上搜索帮助，在搜索框中输入字母 *R* 可能会带你到一些有趣的地方，尽管搜索引擎每天都在变得更聪明。如果你难以获得良好的搜索结果，试着在框中也输入缩写
    *CRAN*；CRAN 是综合 R 存档网络，可以帮助 Google（和其他搜索引擎）将你引导到适当的网站。
- en: R is based on the S programming language that was created at Bell Labs. It’s
    open source, but its license is somewhat more restrictive than some other popular
    languages like Python and Java, particularly if you’re building a commercial software
    product.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: R 基于在贝尔实验室创建的 S 编程语言。它是开源的，但其许可证比 Python 和 Java 等一些其他流行语言更为严格，尤其是如果你正在构建商业软件产品的话。
- en: R has some idiosyncrasies and differences from the other languages I present.
    It typically uses the symbol `<-` to assign a value to a variable, though the
    equals sign, `=`, was later added as an alternative for the convenience of people
    who preferred it. In contrast to MATLAB, R uses square brackets instead of parentheses
    for indexing lists or matrices, but MATLAB is the weird one there; most languages
    use square brackets for indexing. Whereas both MATLAB and Python allow the creation
    of objects like lists, vectors, or matrices beginning with a square bracket, R
    does not. For example, in both MATLAB and Python, you can use the assignment `A
    = [ 2 3 ]` to create a vector/list containing a 2 and a 3, but in R, you’d need
    to use `A <- c(2,3)` to accomplish something similar. It’s not a huge difference,
    but it’s something I forget if I’ve been away from R for a while.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: R 与我介绍的其它语言有一些独特之处和差异。它通常使用符号 `<-` 来给变量赋值，尽管后来添加了等号 `=` 作为替代，以方便那些更喜欢它的用户。与
    MATLAB 相比，R 使用方括号而不是圆括号来索引列表或矩阵，但 MATLAB 在这里是个例外；大多数语言使用方括号进行索引。而 MATLAB 和 Python
    都允许创建以方括号开始的列表、向量或矩阵等对象，但 R 不允许这样做。例如，在 MATLAB 和 Python 中，你可以使用赋值 `A = [ 2 3 ]`
    来创建包含数字 2 和 3 的向量/列表，但在 R 中，你需要使用 `A <- c(2,3)` 来完成类似的事情。这不是一个很大的差异，但如果我有一段时间没有使用
    R，我可能会忘记这一点。
- en: Compared to MATLAB, in R it’s easier to load and handle different types of data.
    MATLAB is good at handling tabular data but, generally speaking, R is better with
    tables with headers, mixed column types (integer, decimal, strings, and so on),
    JSON, and database queries. I’m not saying that MATLAB can’t handle these but
    that it’s generally more limited or difficult in implementation. In addition,
    when reading tabular data, R tends to default to returning an object of the type
    data frame. *Data frames* are versatile objects containing data in columns, where
    each column can be of a different data type—for example, numeric, string, or even
    matrix—but all entries in each column must be the same. Working with data frames
    can be confusing at first, but their versatility and power are certainly evident
    after a while.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 与MATLAB相比，在R中加载和处理不同类型的数据更容易。MATLAB擅长处理表格数据，但一般来说，R在处理带有标题的表格、混合列类型（整数、小数、字符串等）、JSON和数据库查询方面表现更佳。我并不是说MATLAB不能处理这些，但它在实现上通常更为有限或困难。此外，在读取表格数据时，R通常会默认返回一个数据框对象。*数据框*是包含列数据的灵活对象，其中每一列可以具有不同的数据类型——例如，数值、字符串，甚至是矩阵——但每一列中的所有条目必须是相同的。一开始使用数据框可能会感到困惑，但它们的灵活性和强大功能在一段时间后就会变得明显。
- en: One of the advantages of R being open source is that it’s far easier for developers
    to contribute to language and package development wherever they see fit. These
    open-source contributions have helped R grow immensely and expand its compatibility
    with other software tools. Thousands of packages are available for R from the
    CRAN website. I think this is the single greatest strength of the R language;
    chances are you can find a package that helps you perform the type of analysis
    you’d like to do, so some of the work has been done for you. MATLAB also has packages,
    but not nearly as many, though they’re usually very good. R has good ones and
    bad ones and everything in between. You’ll also find tons of R code that’s freely
    available in public repos but that might not have made it to official package
    status.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: R作为开源软件的一个优点是，开发者可以在他们认为合适的地方更容易地贡献于语言和包的开发。这些开源贡献极大地帮助了R的成长并扩展了它与其它软件工具的兼容性。CRAN网站上提供了数千个R包。我认为这是R语言最伟大的单一优势；你很可能找到一个包来帮助你执行你想要进行的分析，这样一些工作就已经为你完成了。MATLAB也有包，但数量远不及R，尽管它们通常非常好。R有好的也有不好的，以及介于两者之间的。你还会在公共仓库中找到大量的R代码，这些代码可能尚未成为官方包，但它们是免费可用的。
- en: During my years of bioinformatics research, R was the most commonly used language
    by my colleagues and our peers at other institutions. Most research groups developing
    new statistical methods for bioinformatics create an R package or at least make
    their code available somewhere, as I have for one of my projects, an algorithm
    called PEACOAT, on GitHub at [https://github.com/briangodsey/peacoat](https://github.com/briangodsey/peacoat).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在我多年的生物信息学研究生涯中，R是我同事以及我们所在其他机构的同行最常用的语言。大多数开发新生物信息学统计方法的科研团队都会创建一个R包，或者至少将他们的代码放在某个地方，就像我在我的一个项目PEACOAT中做的那样，该项目在GitHub上[https://github.com/briangodsey/peacoat](https://github.com/briangodsey/peacoat)。
- en: 'You can implement the item sales quantity example in R by creating the file
    itemSalesScript.R containing the following code:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建包含以下代码的文件itemSalesScript.R在R中实现商品销售数量示例：
- en: '[PRE15]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can run this script in R from a Unix/Linux/Mac OS command line via this
    command:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令在Unix/Linux/Mac OS命令行中运行此脚本：
- en: '[PRE16]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Or from the shell prompt in an R environment, copy and paste the contents of
    itemSalesScript.R into the shell and press Enter.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从R环境的shell提示符中，将itemSalesScript.R的内容复制并粘贴到shell中，然后按Enter键。
- en: Besides syntax and function name changes between MATLAB and R, you may notice
    that the basic structure is the same. R uses curly braces, `{}`, for function
    definitions and `for` loops, compared to MATLAB’s use of an `end` command to denote
    the end of the code block. The function also uses an explicit `return` statement,
    which isn’t present in MATLAB.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 除了MATLAB和R之间的语法和函数名变化之外，你可能会注意到它们的基本结构是相同的。R使用花括号`{}`来定义函数和`for`循环，而MATLAB则使用`end`命令来表示代码块的结束。函数还使用显式的`return`语句，这在MATLAB中是不存在的。
- en: 'I would use R in these situations:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在以下情况下使用R：
- en: If I’m working in a field for which there are many R packages.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在一个有很多R包的领域工作。
- en: If I’m working in academia, particularly bioinformatics or social sciences.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在学术界工作，尤其是生物信息学或社会科学领域。
- en: If I’d like to load, parse, and manipulate varied data sets quickly.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想快速加载、解析和处理各种数据集。
- en: 'I would not use R in these circumstances:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我不会使用 R：
- en: If I’m creating production software.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在创建生产软件。
- en: If I’m creating software to be sold. The GPL license has implications.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在创建要出售的软件。GPL 许可证有影响。
- en: If I’d like to integrate my code into software in other languages.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想将我的代码集成到其他语言的软件中。
- en: If I’d like to use object-oriented architecture. It’s not great in R.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想使用面向对象架构。在 R 中这并不出色。
- en: Overall, R is a good choice for statisticians and others who pursue data-heavy,
    exploratory work more than they build production software in, for example, the
    analytic software industry.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，R 是统计学家和其他那些更倾向于进行数据密集型、探索性工作而不是构建生产软件（例如，在分析软件行业中）的人的好选择。
- en: Python
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python
- en: First and foremost, Python is the only one of the three scripting languages
    I present here that wasn’t intended to be primarily a statistical language. In
    that way, it lends itself more naturally to non-statistical tasks like integrating
    with other software services, creating APIs and web services, and building applications.
    Python is also the only language of the three that I’d seriously consider using
    for creating production software, though in that respect Python still falls short
    of Java, which I’ll discuss next.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 首先也是最重要的，Python 是这三种脚本语言中唯一一个不是旨在主要作为统计语言的。在这方面，它更自然地适用于非统计任务，如与其他软件服务的集成、创建
    API 和网络服务以及构建应用程序。Python 也是这三种语言中唯一一个我会认真考虑用于创建生产软件的语言，尽管在这方面 Python 仍然不及 Java，我将在下一部分讨论这一点。
- en: Python, like any language, has its idiosyncrasies. The most obvious one is its
    lack of braces to denote code blocks, with not even an `end` command like MATLAB
    to say when a `for` loop or function definition has ended. Python uses indentation
    to denote such code blocks, to the eternal chagrin of many programmers everywhere.
    It’s common convention to indent such code blocks, but Python is one of the only
    languages that forces you to do so, and it’s certainly the most popular among
    them. The gist is that if you want such a code block to end, instead of typing
    `end` like in MATLAB or using a close brace, `}`, like in R, Java, and many others,
    you stop indenting your code. Likewise, you must indent your code immediately
    following a `for` command or a function definition line containing `def`. You’ll
    get an error during execution otherwise.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Python，像任何语言一样，有其独特之处。最明显的一点是它没有大括号来表示代码块，甚至没有像 MATLAB 中的 `end` 命令来表示 `for`
    循环或函数定义何时结束。Python 使用缩进来表示这样的代码块，这对许多程序员来说是一种永恒的痛苦。通常，这样的代码块会缩进，但 Python 是唯一一个强制你这样做，并且在其中它是最受欢迎的。简而言之，如果你想结束这样的代码块，而不是像在
    MATLAB 中那样输入 `end`，或者像 R、Java 和许多其他语言那样使用闭合大括号 `}`，你只需停止缩进你的代码。同样，你必须立即在 `for`
    命令或包含 `def` 的函数定义行之后缩进你的代码。否则，在执行过程中你会得到错误。
- en: Likely because Python was originally a general-purpose programming language,
    it has a robust framework for object-oriented design. By contrast, the object-oriented
    features of R and MATLAB seem like an afterthought. I’ve grown to like object-oriented
    design, even for simple tasks, so I use this feature quite often because Python
    has become my primary programming language in the last few years.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能是因为 Python 最初是一种通用编程语言，它拥有一个强大的面向对象设计的框架。相比之下，R 和 MATLAB 的面向对象特性似乎是一种事后补充。我已经开始喜欢面向对象设计，即使是对于简单的任务，因此我经常使用这个特性，因为
    Python 在过去几年中已经成为我的主要编程语言。
- en: Although Python wasn’t originally intended to be a heavily statistical language,
    several packages have been developed for Python that elevate it to compete with
    R and MATLAB. The `numpy` package for numerical methods is indispensable when
    working with vectors, arrays, and matrices. The packages `scipy` and `scikit-learn`
    add functionality in optimization, integration, clustering, regression, classification,
    and machine learning, among other techniques. With those three packages, Python
    rivals the core functionality of both R and MATLAB, and in some areas, such as
    machine learning, Python seems to be more popular among data scientists.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 最初并不是一个旨在高度统计的语言，但已经为 Python 开发了几个包，使其能够与 R 和 MATLAB 竞争。在处理向量、数组和矩阵时，`numpy`
    包对于数值方法来说是必不可少的。`scipy` 和 `scikit-learn` 包在优化、积分、聚类、回归、分类和机器学习等其他技术中增加了功能。有了这三个包，Python
    在核心功能上与 R 和 MATLAB 相当，在某些领域，如机器学习，Python 似乎在数据科学家中更为流行。
- en: For data handling, the package `pandas` has become incredibly popular. It’s
    influenced somewhat by the notion of a data frame in R but has since surpassed
    that in functionality. Admittedly, I had some trouble figuring out how to make
    profitable use of `pandas` when I first tried it, but after some practice it was
    very handy. It’s my impression that `pandas` data frames work as in-memory, in-Python
    optimized data stores. If your data set is big enough to slow down calculations
    but small enough to fit in your computer’s memory, then `pandas` might be for
    you.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据处理，`pandas` 包已经变得极其流行。它在某种程度上受到了 R 中的数据框概念的影响，但在功能上已经超越了它。诚然，我在第一次尝试 `pandas`
    时有些困难，但经过一些练习，它变得非常方便。我的印象是，`pandas` 数据框作为内存中、Python 优化的数据存储。如果你的数据集足够大以至于会减慢计算速度，但足够小以至于可以适应你的计算机内存，那么
    `pandas` 可能适合你。
- en: One of the most notable Python packages in data science, however, is the Natural
    Language Toolkit (`NLTK`). It’s easily the most popular and most robust tool for
    natural language processing (NLP). These days, if someone is parsing and analyzing
    text from Twitter, newsfeeds, the Enron email corpus, or somewhere else, it’s
    likely that they’ve used `NLTK` to do so. It makes use of other NLP tools such
    as WordNet and various methods of tokenization and stemming to offer the most
    comprehensive set of NLP capabilities found in one place.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在数据科学中最著名的 Python 包之一是自然语言工具包（`NLTK`）。它无疑是自然语言处理（NLP）中最受欢迎和最健壮的工具。如今，如果有人从
    Twitter、新闻源、Enron 邮件语料库或其他地方解析和分析文本，他们很可能会使用 `NLTK` 来这样做。它利用其他 NLP 工具，如 WordNet
    和各种标记化和词干提取方法，提供了一站式解决方案，集成了最全面的 NLP 功能。
- en: 'As for core functionality, the item sales quantity example written in Python
    in a file called itemSalesScript.py might look like this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 对于核心功能，一个名为 itemSalesScript.py 的文件中用 Python 编写的商品销售数量示例可能看起来像这样：
- en: '[PRE17]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can run this script in Python from a Unix/Linux/Mac OS command line via
    the command
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 Unix/Linux/Mac OS 命令行中的命令运行此脚本
- en: '[PRE18]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: or copy and paste the contents of the file to a Python prompt and press Enter.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将文件内容复制粘贴到 Python 提示符中并按 Enter 键。
- en: Note how indentation is used to denote the end of the function definition and
    `for` loop. Also notice that, like R, Python uses square brackets to select items
    from lists/vectors, but that Python uses a zero-based indexing system. To get
    the first item in a list called `dataList` in Python, you’d use `dataList[0]`
    instead of `dataList[1]` that you’d use in R or the `dataList(1)` that you’d use
    in MATLAB. That tripped me up a few times when I was learning Python, so watch
    out for it. Then again, most software developers are used to zero-based indexing
    in languages like Java and C, so they’d be more likely to be tripped up by R and
    MATLAB than by Python.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缩进是如何用来表示函数定义和 `for` 循环的结束。还要注意，像 R 一样，Python 使用方括号从列表/向量中选择项目，但 Python 使用基于零的索引系统。要在
    Python 中获取名为 `dataList` 的列表中的第一个项目，您将使用 `dataList[0]` 而不是在 R 或 MATLAB 中使用的 `dataList[1]`
    或 `dataList(1)`。这在我学习 Python 时让我困惑了好几次，所以请注意这一点。然而，大多数软件开发人员已经习惯了 Java 和 C 等语言中的基于零的索引，所以他们更有可能被
    R 和 MATLAB 而不是 Python 搅乱。
- en: 'One final note about the code example: in two places I had to use the `int`
    function to coerce the given value from a string to an integer. This is because
    the `csv` package defaults to considering all values as strings unless told otherwise.
    There are surely better ways to handle this than the one I’ve used here, not the
    least of which is to convert the data to arrays using the `numpy` package, which
    is what I’d do anyway if I was working more intensely with the data, but I left
    it out for clarity of the example.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码示例的最后一句话：在两个地方我不得不使用 `int` 函数将给定的字符串值强制转换为整数。这是因为 `csv` 包默认将所有值视为字符串，除非告知否则。当然，肯定有比我在这里使用的方法更好的处理方式，其中之一就是使用
    `numpy` 包将数据转换为数组，如果我在更深入地处理数据时，我通常会这样做，但为了示例的清晰性，我将其省略了。
- en: 'I would use Python in these situations:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在以下情况下使用 Python：
- en: If I’m creating an analytic software application, prototype, or maybe production
    software.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在创建分析软件应用、原型或可能的生产软件。
- en: If I’m doing machine learning or NLP.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在做机器学习或自然语言处理（NLP）。
- en: If I’m integrating with another software service or application.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我要与其他软件服务或应用集成。
- en: If I’m doing a lot of non-statistical programming.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在做大量的非统计编程。
- en: 'I wouldn’t use Python in these circumstances:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我不会使用 Python：
- en: If I worked in a field where most people use another language and share their
    code.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在一个大多数人使用其他语言并共享其代码的领域工作。
- en: If Python’s packages in my field were inferior to those of another language,
    like R.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我的领域中的 Python 包不如其他语言，如 R。
- en: If I wanted to generate graphs and plots quickly and easily. R’s plotting packages
    are significantly better.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我想快速轻松地生成图表和绘图。R 的绘图包要好得多。
- en: I’ve mentioned that Python is now my language of choice, after switching from
    R a few years ago. I made the switch because I’ve been programming production
    proprietary software, and that involves a lot of non-statistical code, for which
    I find Python vastly better. Python’s licenses freely allow sale of your software
    without having to provide the source code. Overall, I recommend Python for people
    who want to do some data science as well as some other pure, non-statistical software
    development. It’s the only popular, robust language I know of that can do both
    well.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，Python 现在我的首选语言，这是在我几年前从 R 转换过来之后。我做出这个转换是因为我一直在编写生产专有软件，这涉及到大量的非统计代码，对于这些代码，我发现
    Python 非常出色。Python 的许可证允许自由销售软件，无需提供源代码。总的来说，我推荐 Python 给那些想要进行一些数据科学以及一些其他纯非统计软件开发的人。它是唯一我知道的既流行又健壮的语言，可以很好地完成这两项任务。
- en: Java
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java
- en: Though not a scripting language and as such not well suited for exploratory
    data science, Java is one of the most prominent languages for software application
    development, and because of this it’s used often in analytic application development.
    Many of the same reasons that make Java bad for exploratory data science make
    it good for application development.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java不是脚本语言，因此不适合探索性数据分析，但它是最突出的软件开发语言之一，因此它经常用于分析应用程序开发。使 Java 对探索性数据分析不利的许多原因也使其适用于应用程序开发。
- en: For one, Java has strong, static variable typing, which means that you have
    to declare what type of object a variable is when you create it, and it can never
    change. Java objects also have many different types of methods—public, private,
    static, final, and so on—and choosing the appropriate type can ensure that the
    method gets used correctly and only at suitable times. Variable scope and object
    inheritance rules are also quite strict, at least compared to Python and R. All
    these strict rules make writing code slower, but the resulting application is
    typically more robust and far less prone to error. I sometimes wish I could impose
    some of these restrictions on my Python code, because every so often a particularly
    nasty bug can be traced back to a dumb thing I did that could have been prevented
    by one of Java’s strict rules.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Java 具有强大的静态变量类型，这意味着在创建变量时你必须声明该变量的类型，并且它永远不能改变。Java 对象也有许多不同类型的方法——公共的、私有的、静态的、最终的等等——选择适当类型可以确保方法被正确且仅在合适的时间使用。变量作用域和对象继承规则也非常严格，至少与
    Python 和 R 相比是这样。所有这些严格的规则使得编写代码的速度变慢，但结果的应用程序通常更加健壮，并且远少出错。我有时希望我能对我的 Python
    代码施加一些这些限制，因为每隔一段时间，一个特别棘手的错误就可以追溯到我所做的一个愚蠢的事情，而这本可以通过 Java 的严格规则来预防。
- en: Java isn’t great for exploratory data science, but it can be great for large-scale
    or production code based on data science. Java has many statistical libraries
    for doing everything from optimization to machine learning. Many of these are
    provided and supported by the Apache Software Foundation.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Java 对于探索性数据分析来说并不出色，但它可以非常适合基于数据科学的大规模或生产代码。Java 拥有众多统计库，可以用于从优化到机器学习的各种操作。其中许多都是由
    Apache 软件基金会提供和支持的。
- en: 'I would use Java in the following situations:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，我会使用 Java：
- en: If I’m creating an application that needs to be very robust and portable.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我正在创建一个需要非常健壮和可移植的应用程序。
- en: If, being already familiar with Java, I know it has the capabilities I need.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我已经熟悉 Java，并且知道它具有我需要的功能。
- en: If I’m working on a team that uses mainly Java, and using another language would
    be a hardship for the overall development effort.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我正在一个主要使用 Java 的团队中工作，使用其他语言会对整体开发工作造成困难。
- en: 'I wouldn’t use Java in the following circumstances:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，我不会使用 Java：
- en: If I’m doing a lot of exploratory data science.
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我正在做大量的探索性数据分析。
- en: If I didn’t know much about Java.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我对 Java 不太了解。
- en: If I don’t need a truly robust, portable application.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我不需要一个真正健壮且可移植的应用程序。
- en: Though I haven’t provided much detail about Java, I do want to convey the popularity
    of this language in data science–related applications and also say that, for most
    experienced developers I know, it would be their first choice for attempting to
    build a bulletproof piece of analytic software.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我没有提供很多关于Java的细节，但我确实想传达这种语言在数据科学相关应用中的流行度，并且可以说，对于我所知道的绝大多数经验丰富的开发者来说，它将是他们尝试构建一个坚不可摧的分析软件的首选。
- en: '[Table 8.1](kindle_split_018_split_002.xhtml#ch08table01) summarizes when I’d
    use each programming language for projects in data science.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[表8.1](kindle_split_018_split_002.xhtml#ch08table01)总结了我在数据科学项目中使用每种编程语言的情况。'
- en: Table 8.1\. A summary of when I would use each programming language for projects
    in data science
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表8.1. 总结了我在数据科学项目中使用每种编程语言的情况
- en: '| Language | When I would use it | When I would not use it |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 我会使用它的时候 | 我不会使用它的时候 |'
- en: '| --- | --- | --- |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| MATLAB/Octave | If I’m working with large matrices or large numbers of matrices.
    If I know that a particular add-on package, particularly in MATLAB, will be greatly
    useful. If I have a MATLAB license and I like the matrix-friendly syntax. | If
    I have data that isn’t well represented by tables or matrices. If I want my code
    to integrate with other software; it can be difficult and complicated, though
    there are various options. If I want to include my code in a software product
    to be sold. MATLAB’s license in particular can make this difficult legally. |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB/Octave | 如果我在处理大型矩阵或大量矩阵时。如果我知道某个特定的附加包，尤其是在MATLAB中，将非常有用。如果我有MATLAB许可证，并且我喜欢矩阵友好的语法。
    | 如果我的数据不适合用表格或矩阵表示。如果我想让我的代码与其他软件集成；这可能很困难且复杂，尽管有各种选项。如果我想将我的代码包含在要出售的软件产品中。MATLAB的许可证在法律上可能会使这变得困难。
    |'
- en: '| R | If I’m working in a field for which there are many R packages. If I’m
    working in academia, particularly bioinformatics or social sciences. If I’d like
    to load, parse, and manipulate varied data sets quickly. | If I am creating production
    software. If I’m creating software to be sold. The GPL license has implications.
    If I’d like to integrate my code into software in other languages. If I’d like
    to use object-oriented architecture. It’s not great in R. |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| R | 如果我在一个有很多R包的领域工作。如果我在学术界工作，尤其是生物信息学或社会科学。如果我想快速加载、解析和操作各种数据集。 | 如果我在创建生产软件。如果我在创建要出售的软件。GPL许可证有影响。如果我想将我的代码集成到其他语言的软件中。如果我想使用面向对象架构。在R中并不出色。
    |'
- en: '| Python | If I’m creating an analytic software application, prototype, or
    maybe production software. If I’m doing machine learning or NLP. If I’m integrating
    with another software service or application. If I’m doing a lot of non-statistical
    programming. | If I worked in a field where most people use another language and
    share their code. If Python’s packages in my field are inferior to those of another
    language, like R. If I want to generate graphs and plots quickly and easily. R’s
    plotting packages are significantly better. |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| Python | 如果我在创建一个分析软件应用程序、原型或可能的生产软件时。如果我在进行机器学习或NLP。如果我要与其他软件服务或应用程序集成。如果我在进行大量的非统计编程。
    | 如果我在一个大多数人使用另一种语言并共享他们的代码的领域工作。如果Python在我的领域中的包不如R等其他语言中的包。如果我想快速轻松地生成图表和绘图。R的绘图包要好得多。
    |'
- en: '| Java | If I’m creating an application that needs to be very robust and portable.
    If, being already familiar with Java, I know it has the capabilities I need. If
    I am working on a team that uses mainly Java, and using another language would
    be a hardship for the overall development effort. | If I’m doing a lot of exploratory
    data science. If I didn’t know much about Java. If I don’t need a truly robust,
    portable application. |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| Java | 如果我在创建一个需要非常健壮和可移植的应用程序时。如果我已经熟悉Java，我知道它具有我需要的功能。如果我在一个主要使用Java的团队中工作，使用另一种语言会对整体开发工作造成困难。
    | 如果我在进行大量的探索性数据科学。如果我对Java不太了解。如果我不需要一个真正健壮、可移植的应用程序。 |'
- en: 8.3\. Choosing statistical software tools
  id: totrans-651
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3. 选择统计软件工具
- en: So far in this chapter I’ve talked about the basics of some statistical applications
    and programming and hopefully I’ve given you a good idea of the range of tools
    available for implementing the statistical methods that were discussed in the
    last chapter. If that chapter served its purpose, you’ve related your project
    and your data to some appropriate mathematical or statistical methods or models.
    If so, you can compare those methods or models with the software options available
    to implement them, arriving at a good option or two. In choosing software tools,
    there are various things to consider and some general rules to follow. I’ll outline
    those here.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我已经讨论了一些统计应用和编程的基础知识，并希望我已经给你一个关于可用于实现上一章所讨论的统计方法的工具范围的清晰概念。如果那一章达到了其目的，你将你的项目和你的数据与一些适当的数学或统计方法或模型相关联。如果是这样，你可以将这些方法或模型与可用于实现它们的软件选项进行比较，从而得出一个或两个好的选择。在选择软件工具时，有许多事情需要考虑，以及一些一般规则需要遵循。我将在下面概述这些内容。
- en: 8.3.1\. Does the tool have an implementation of the methods?
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1. 工具是否有这些方法的实现？
- en: Sure, you can always code the methods yourself, but if you’re using a fairly
    common method, then many tools probably already have an implementation, and it’s
    probably better to use one of those. Code that’s been used by many people already
    is usually relatively error free compared to some code that you wrote in a day
    and used only once or twice.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以自己编写这些方法，但如果你使用的是一个相当常见的方法，那么许多工具可能已经实现了这些方法，使用其中之一可能更好。已经被许多人使用过的代码通常比你在一天内编写的只使用一次或两次的代码相对较少错误。
- en: Depending on your ability to program and your familiarity with various statistical
    tools, you may have a readily available implementation in one of your favorite
    tools that you could put to use quickly. If Excel has it, then most likely every
    other tool does too. If Excel doesn’t, then maybe the mid-level tools do, and
    if they don’t, then you’re probably going to have to write a program. Otherwise,
    the only remaining option is to choose a different statistical method.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你编程的能力以及你对各种统计工具的熟悉程度，你可能在你的一个喜欢的工具中已经有一个现成的实现，可以快速投入使用。如果Excel有，那么其他大多数工具也可能有。如果Excel没有，那么可能是中级工具有，如果没有，那么你可能需要编写一个程序。否则，唯一剩下的选择是选择不同的统计方法。
- en: If you do decide to go with a programming language, remember that not all packages
    or libraries are created equal, so make sure the programming language and the
    package that you intend to use can do exactly what you want. It might be helpful
    to read the documentation or some examples that are relatively similar to the
    analysis you want to do.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用编程语言，请记住，并非所有包或库都是平等的，所以请确保你打算使用的编程语言和包可以做到你想要的一切。阅读文档或一些与你想要进行的分析相对相似的示例可能会有所帮助。
- en: 8.3.2\. Flexibility is good
  id: totrans-657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2. 灵活性是好的。
- en: In addition to being able to perform the main statistical analysis that you
    want, it’s often helpful if a statistical tool can perform some related methods.
    Often you’ll find that the method you chose doesn’t quite work as well as you
    had hoped, and what you’ve learned in the process leads you to believe that a
    different method might work better. If your software tool doesn’t have any alternatives,
    then you’re either stuck with the first choice or you’ll have to switch to another
    tool.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够执行你想要的主要统计分析之外，如果统计工具能够执行一些相关方法，这通常是有帮助的。通常你会发现，你选择的方法并不像你希望的那样有效，你在过程中学到的知识让你相信另一种方法可能效果更好。如果你的软件工具没有其他替代方案，那么你可能只能坚持第一个选择，或者你必须切换到另一个工具。
- en: For example, if you have a statistical model and you want to find the optimal
    parameter values, you’ll be using a likelihood function and an optimization technique.
    In [chapter 7](kindle_split_017_split_000.xhtml#ch07), I outlined a few types
    of methods for finding optimal parameters from a likelihood function, including
    maximum likelihood (ML), maximum a posteriori (MAP), expectation-maximization
    (EM), and variational Bayes (VB). Although Excel has a few different specific
    optimization algorithms, they’re all ML methods, so if you think you can get away
    with ML but you’re not sure, you may want to level up to a more sophisticated
    statistical tool that has more options for optimization.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个统计模型并且想要找到最优的参数值，你将使用似然函数和优化技术。在[第7章](kindle_split_017_split_000.xhtml#ch07)中，我概述了几种从似然函数中寻找最优参数的方法，包括最大似然（ML）、最大后验（MAP）、期望最大化（EM）和变分贝叶斯（VB）。尽管Excel有一些不同的特定优化算法，但它们都是ML方法，所以如果你认为你可以用ML解决问题但又不确定，你可能想要升级到一个更复杂的统计工具，它有更多的优化选项。
- en: There are multiple types of regression, clustering, component analysis, and
    machine learning, among others, and some tools may offer one or more of those
    methods. I tend to favor those statistical tools that offer a few from each of
    these method categories in case I need to switch or to try another.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在回归、聚类、成分分析、机器学习等多种类型中，有些工具可能提供其中一种或多种方法。我倾向于偏好那些提供每个方法类别中几种统计工具的工具，以防我需要切换或尝试另一种。
- en: 8.3.3\. Informative is good
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 信息丰富是好的
- en: I’ve stressed that awareness in the face of uncertainty is a primary aspect
    of data science; this carries over into selection of statistical software tools.
    Some tools might give good results but don’t provide insight into how and why
    those results were reached. On one hand, it’s good to be able to deconstruct the
    methods and the model so that you understand the model and the system better.
    On the other hand, if your methods make a mistake in some way, and you find yourself
    looking at a weird, unexpected result, then more information about the method
    and its application to your data can help you diagnose the specific problem.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我强调，面对不确定性时的意识是数据科学的一个主要方面；这一点也体现在统计软件工具的选择上。有些工具可能给出好的结果，但并不提供关于如何以及为什么得到这些结果的认识。一方面，能够分解方法和模型以便更好地理解模型和系统是很好的。另一方面，如果你的方法在某些方面犯了错误，而你发现自己面对一个奇怪、意外的结果，那么关于方法和其在你数据中的应用的更多信息可以帮助你诊断具体问题。
- en: Some statistical tools, particularly higher-level ones like statistical programming
    languages, offer the capability to see inside nearly every statistical method
    and result, even black box methods like machine learning. These insides aren’t
    always user friendly, but at least they’re available. It’s my experience that
    spreadsheets like Excel don’t offer much insight into their methods, and so it’s
    difficult to deconstruct or diagnose problems for statistical models that are
    more complicated than, say, linear regression.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 一些统计工具，尤其是像统计编程语言这样的高级工具，提供了查看几乎所有统计方法和结果的能力，甚至包括像机器学习这样的黑盒方法。这些内部信息并不总是用户友好的，但至少是可用的。我的经验是，像Excel这样的电子表格软件并不提供对其方法的太多洞察，因此很难分解或诊断比线性回归更复杂的统计模型的问题。
- en: 8.3.4\. Common is good
  id: totrans-664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 常见是好的
- en: With many things in life—music, television, film, news articles—popularity doesn’t
    always indicate quality, and in fact it often does the contrary. With software,
    more people using a tool means more people have tried it, gotten results, examined
    the results, and probably reported the problems they had, if any. In that way,
    software, notably open-source software, has a feedback loop that fixes mistakes
    and problems in a reasonably timely fashion. The more people participating in
    this feedback loop, the more likely it is that a piece of software is relatively
    bug free and otherwise robust.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在生活中，许多事物——如音乐、电视、电影、新闻文章——的流行并不总是意味着质量，实际上往往相反。在软件领域，使用软件的人数越多，意味着尝试过它的人越多，得到了结果，检查了结果，并且可能报告了他们遇到的问题（如果有的话）。以这种方式，软件，尤其是开源软件，有一个反馈循环，可以合理及时地修复错误和问题。参与这个反馈循环的人越多，软件相对无错误和稳健的可能性就越大。
- en: This is not to say that the most popular thing *right now* is the best. Software
    goes through trends and fads like everything else. I tend to look at popularity
    over the past few years of use by people who are in a similar situation to me.
    In a general popularity contest of statistical tools, Excel would obviously win.
    But if you consider only data scientists, and maybe only data scientists in a
    particular field—excluding accountants, finance professionals, and other semi-statistical
    users—you’d probably see its popularity fade in favor of the more serious statistical
    tools.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说现在最受欢迎的东西就是最好的。软件就像其他一切一样，会经历趋势和时尚。我倾向于查看过去几年与我处于相似情况的人的使用流行度。在统计工具的一般流行度竞赛中，Excel显然会获胜。但如果你只考虑数据科学家，也许只考虑特定领域的数据科学家——排除会计、金融专业人士和其他半统计用户——你可能会看到它的流行度在更严肃的统计工具面前减弱。
- en: 'A tool must meet these criteria if I’m going to use it:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我要使用一个工具，它必须满足以下标准：
- en: The tool must be at least a few years old.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具至少要有几年的历史。
- en: The tool must maintained by a reputable organization.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具必须由一个信誉良好的组织维护。
- en: Forums, blogs, and literature must show that many people have been using the
    tool for quite some time and without many significant problems recently.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论坛、博客和文献必须表明很多人已经使用这个工具很长时间，并且最近没有遇到很多重大问题。
- en: 8.3.5\. Well documented is good
  id: totrans-671
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. 文档详尽是好事
- en: In addition to being in common use, a statistical software tool should have
    comprehensive and helpful documentation. It’s very frustrating when I’m trying
    to use a piece of software and I have a question that I feel should have a straightforward
    answer, but I can’t find that answer anywhere.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普遍使用外，一个统计软件工具应该有全面且有帮助的文档。当我试图使用某个软件时，如果遇到一个我觉得应该有直接答案的问题，但找不到答案，这非常令人沮丧。
- en: It’s a bad sign if you can’t find answers to some big questions, such as how
    to configure inputs for doing linear regression or how to format the features
    for machine learning. If the answers to big questions aren’t in the documentation,
    then it’s going to be even harder to find answers to the more particular questions
    that you’ll inevitably run into later.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找不到一些重要问题的答案，比如如何配置输入进行线性回归或如何格式化特征以进行机器学习，那么这可不是什么好兆头。如果重要问题的答案不在文档中，那么你以后遇到更具体的问题时找到答案将会更加困难。
- en: Documentation is usually a function of the age and popularity of the software.
    The official documentation for the tool should be on the maintaining organization’s
    web page, and it should contain informative instructions and specifications in
    plain language that you can understand. It’s funny to me how many software organizations
    don’t use plain language in their documentation or make their examples overly
    complicated. Perhaps it’s my aversion to unnecessary jargon, but I shy away from
    using software that has documentation I don’t readily understand.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 文档通常是软件的年龄和流行度的函数。工具的官方文档应该放在维护组织的网页上，并且应该包含用通俗易懂的语言编写的说明和规范。对我来说，很多软件组织在文档中不使用通俗易懂的语言或使示例过于复杂，这很有趣。也许是我对不必要的术语的反感，但我避开使用那些文档我不容易理解的软件。
- en: Along with determining whether a tool is common enough, I also check forums
    and blog posts to determine whether there are sufficient examples and questions
    with answers that support the official documentation. No matter how good the documentation
    is, it almost certainly has gaps and ambiguities somewhere, so it’s helpful to
    have informal documentation as a backup.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确定工具是否足够普遍外，我还检查论坛和博客帖子，以确定是否有足够的示例和有答案的问题来支持官方文档。不管文档有多好，它几乎肯定存在某些空白和模糊不清的地方，因此拥有非正式文档作为备份是很有帮助的。
- en: 8.3.6\. Purpose-built is good
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.6\. 定制开发是好事
- en: Some software tools or their packages were built for a specific purpose, and
    then other functionality was added on later. For example, the matrix algebra routines
    in MATLAB and R were of primary concern when the languages were built, so it’s
    safe to assume that they’re comprehensive and robust. In contrast, matrix algebra
    wasn’t of primary concern in the initial versions of Python and Java, and so these
    capabilities were added later in the form of packages and libraries. This isn’t
    necessarily bad; Python and Java happen to have robust matrix functionality now,
    but the same can’t be said for every language that claims to be able to handle
    matrices efficiently.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件工具或它们的包是为了特定目的而构建的，后来又添加了其他功能。例如，MATLAB和R中的矩阵代数例程在构建这些语言时是首要关注的问题，因此可以安全地假设它们是全面且稳健的。相比之下，矩阵代数在Python和Java的初始版本中并不是首要关注的问题，因此这些功能是以包和库的形式后来添加的。这并不一定不好；Python和Java现在恰好拥有稳健的矩阵功能，但并非每个声称能够高效处理矩阵的语言都如此。
- en: 'In cases where the statistical methods I want to use are a package, library,
    or add-on to the software tool that I want to use, I place the same scrutiny on
    that package that I would on the tool itself: is it flexible, informative, commonly
    used, well documented, and otherwise robust?'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在我想要使用的统计方法是一个包、库或是我想要使用的软件工具的附加组件的情况下，我对这个包的审查与对工具本身的审查相同：它是否灵活、信息丰富、常用、文档齐全，以及在其他方面是否稳健？
- en: 8.3.7\. Interoperability is good
  id: totrans-679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.7. 兼容性是好的
- en: Interoperability is a sort of converse of being purpose-built, but they’re not
    mutually exclusive. Some software tools play well with others, and in these you
    can expect to be able to integrate functionalities, import data, and export results,
    all in generally accepted formats. This is helpful in projects where other software
    is being used for related tasks.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性是针对特定目的构建的一种逆过程，但它们并不是相互排斥的。一些软件工具与其他工具配合良好，在这些工具中，你可以期待能够集成功能、导入数据以及以通常接受的格式导出结果。这在使用其他软件进行相关任务的项目中很有帮助。
- en: If you’re working with a database, it can be helpful to use a tool that can
    interact with the database directly. If you’re going to build a web application
    based on your results, you might want to choose a tool that supports web frameworks—or
    at least one that can export data in JSON or some other web-friendly format. Or
    if you’ll use your statistical tool on various types of computers, then you’ll
    want the software to be able to run on the various operating systems. It’s not
    uncommon to integrate a statistical software method into a completely different
    language or tool. If this is the case, then it’s good to check whether, for example,
    you can call Python functions from Java (you can, with some effort).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与数据库一起工作，使用一个可以直接与数据库交互的工具可能会有所帮助。如果你打算基于你的结果构建一个Web应用程序，你可能想要选择一个支持Web框架的工具——或者至少一个能够以JSON或其他Web友好格式导出数据的工具。或者，如果你将在各种类型的计算机上使用你的统计工具，那么你希望软件能够在各种操作系统上运行。将统计软件方法集成到完全不同的语言或工具中并不罕见。如果这种情况发生，那么检查你是否可以调用Python函数从Java中（经过一些努力，你可以做到）是一个好主意。
- en: R was purpose-built for statistics, and interoperability was something of an
    afterthought, although there’s a vast ecosystem of packages supporting integration
    with other software. Python was built as a general programming language and statistics
    was an afterthought, but as I said, the statistical packages for Python are some
    of the best available. Choosing between them and others is a matter of vetting
    all languages, applications, and packages you intend to use.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: R是为了统计而专门构建的，兼容性只是事后考虑的事情，尽管有一个庞大的生态系统支持与其他软件的集成。Python被构建为一个通用编程语言，统计只是事后考虑的，但正如我所说，Python的统计包是其中最好的。在它们和其他工具之间进行选择是一个审查你打算使用的所有语言、应用程序和包的问题。
- en: 8.3.8\. Permissive licenses are good
  id: totrans-683
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.8. 开放式许可协议是好的
- en: Most software has a license, either explicit or implied, that states what restrictions
    or permissions exist on the use of the software. Proprietary software licenses
    are usually pretty obvious, but open-source licenses usually aren’t quite as clear.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件都有一个许可，无论是明确的还是隐含的，它声明了软件使用的限制或权限。专有软件许可通常很明显，但开源许可通常并不那么清晰。
- en: If you’re using commercial software for commercial purposes, it can be legally
    risky to be doing so with an academic or student license. It can also be dangerous
    to sell commercial software, modified or not, to someone else without confirming
    that the license doesn’t prohibit this.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用商业软件进行商业用途，使用学术或学生许可证这样做在法律上可能存在风险。如果没有确认许可证不禁止这样做，将修改后的商业软件或未修改的商业软件卖给他人也可能很危险。
- en: When I do data science using an open-source tool, the main question I have is
    can I create software using this tool and sell it to someone without divulging
    the source code? Some open-source licenses allow this, and some don’t. It’s my
    understanding (though I’m not a lawyer) that I can’t sell to someone an application
    that I’ve written in R without also providing the source code; in Python and Java,
    doing so is generally permitted, and this is one reason why production applications
    are not generally built in R and languages with similar licenses. There are usually
    legal paths around this, such as hosting the R code yourself and providing its
    functionality as a web service or something similar. In any case, it’s best to
    check the license and consult a legal expert if you suspect you might violate
    a software license.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用开源工具进行数据科学时，我主要的问题是能否使用这个工具创建软件并将其卖给某人而不泄露源代码？一些开源许可证允许这样做，而一些则不允许。据我所知（尽管我不是律师），我不能在没有提供源代码的情况下将我编写的R应用程序卖给某人；在Python和Java中，这样做通常是允许的，这也是为什么生产应用程序通常不是在R和具有类似许可证的语言中构建的原因。通常有法律途径可以解决这个问题，例如自己托管R代码，并将其功能作为网络服务或类似的服务提供。无论如何，最好检查许可证，并在怀疑可能违反软件许可证的情况下咨询法律专家。
- en: 8.3.9\. Knowledge and familiarity are good
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.9\. 知识和熟悉度是好的
- en: 'I put this general rule last, though I suspect that most people, me included,
    consider it first. I’ll admit: I tend to use what I know. There might be nothing
    wrong with using the tool you know best, as long as it works reasonably well with
    the previous rules. Python and R, for example, are pretty good at almost everything
    in data science, and if you know one better than the other, by all means use that
    one again.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我怀疑包括我在内的大多数人首先考虑的是这一点，但我还是把这个一般规则放在最后。我必须承认：我倾向于使用我所知道的。只要它能够合理地与之前的规则一起工作，使用你最擅长的工具可能并没有什么问题。例如，Python和R在数据科学中的几乎所有事情上都做得很好，如果你对其中一个比另一个更熟悉，那么当然可以使用它。
- en: On the other hand, many tools out there aren’t the right tool for the job. Trying
    to use Excel for machine learning, for example, isn’t usually the best idea, though
    I hear this is changing as Microsoft expands its offerings. In cases like this
    one, where you *might* be able to get by with a tool that you know, it’s definitely
    worth considering learning one that’s more appropriate for your project.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，许多工具并不是完成这项工作的正确工具。例如，尝试使用Excel进行机器学习通常并不是最好的主意，尽管我听说随着微软扩展其产品，这种情况正在改变。在这种情况下，如果你*可能*能够使用你熟悉的工具应付，那么考虑学习一个更适合你项目的工具绝对是值得的。
- en: In the end, it’s a matter of balancing the time you’ll save by using a tool
    you know against the time and quality of results you’ll lose by using a tool that
    isn’t appropriate. The time constraints and requirements of your project are often
    the deciding factors here.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个权衡使用你熟悉的工具节省的时间与使用不合适的工具所损失的时间和结果质量的问题。你的项目的时间和需求通常是这里的决定因素。
- en: 8.4\. Translating statistics into software
  id: totrans-691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 将统计学转化为软件
- en: Putting math into your code is no small task. Many people seem to think that
    doing math on data is as easy as importing a statistics library and clicking Go.
    Maybe if they’re lucky, it’ll work, but only until the uncertainty sneaks up on
    them and their lack of awareness of what’s going on in the statistical methods
    and code fails to prevent a problem of some kind. I know this is a contrived scenario,
    but I concoct such a heinous straw man to stress the importance of understanding
    the statistical methods that you’ve chosen and how they relate to the software
    that you’re using or creating.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 将数学融入你的代码并非易事。许多人似乎认为在数据上做数学运算就像导入一个统计库然后点击运行一样简单。也许如果他们运气好，它可能会工作，但直到不确定性悄悄地降临到他们身上，他们对统计方法和代码中发生的事情缺乏意识，未能防止某种类型的问题。我知道这是一个人为的场景，但我故意构建这样一个卑鄙的稻草人来强调理解你所选择的统计方法以及它们与你正在使用或创建的软件之间关系的重要性。
- en: 8.4.1\. Using built-in methods
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 使用内置方法
- en: Any of the mid-level statistical tools should have proper instructions for how
    to apply their various statistical methods to your data. Although I don’t have
    much recent experience, I expect that either the in-application guidance or documentation
    available online should suffice for anyone to figure out how to apply a standard
    statistical method.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 任何中级统计工具都应该有适当的说明，说明如何将它们的各种统计方法应用于你的数据。尽管我没有多少最近的经验，但我预计应用程序内的指导或在线可用的文档应该足以让任何人了解如何应用标准统计方法。
- en: Programming languages are usually a bit more complicated, and I’ve found that
    it’s often quite hard to find bare-basics instructions and examples on how to
    implement and perform even the simplest statistical analyses. It’s my impression
    that most documentation assumes a fair amount of knowledge of the language, which
    can make it confusing for beginners. Therefore, I’ll present two examples here
    that illustrate how linear regression can be applied, one in R, and one in Python.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言通常要复杂一些，我发现找到关于如何实现和执行甚至最简单的统计分析的基本指令和示例往往相当困难。我的印象是，大多数文档都假设对语言有一定的了解，这可能会让初学者感到困惑。因此，我将在这里提供两个示例，说明如何应用线性回归，一个在R中，一个在Python中。
- en: Linear regression in R
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: R中的线性回归
- en: 'R typically uses a functional style, as in this example:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: R通常使用函数式风格，就像这个例子一样：
- en: '[PRE19]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, this script creates a data frame object containing three variables, `X1`,
    `X2`, and `y`. A data frame is an object, but here it’s constructed by a function
    called `data.frame`, which returns a data frame object that’s stored in the variable
    `data`.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个脚本创建了一个包含三个变量`X1`、`X2`和`y`的数据框对象。数据框是一个对象，但在这里它是通过一个名为`data.frame`的函数构建的，该函数返回一个存储在变量`data`中的数据框对象。
- en: The assumed task here is that you want to perform linear regression such that
    `X1` and `X2` are inputs, and `y` is the output. You want to be able to use `X1`
    and `X2` to predict `y`, and you want to find a good linear model that can do
    this. The second command in the script specifies that you want to create a linear
    model via the function `lm` whose parameters are, first, a formula, `y ~ X1 +
    X2`, and second, a data frame, `data`, containing the data. Formulas are curious
    but useful constructs in R that I’ve hardly seen anywhere else. They’re intended
    to represent a sort of mathematical relation between the variables. As you can
    probably guess, this formula tells the `lm` function that you want to predict
    `y` using `X1` and `X2`. The intercept (y-value when all input variables are zero)
    is also automatically added, unless you explicitly remove it. You can add more
    input variables to the formula or add combinations of variables, such as the product
    of two variables, the square of a variable, and so on. You have numerous possibilities
    for constructing a formula in R, and it can get quite complicated, so I suggest
    consulting the documentation before you write your own.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里假设的任务是，你想要执行线性回归，使得`X1`和`X2`是输入，而`y`是输出。你希望能够使用`X1`和`X2`来预测`y`，并且你想要找到一个好的线性模型来完成这个任务。脚本中的第二个命令指定了你想通过`lm`函数创建一个线性模型，其参数首先是公式，`y
    ~ X1 + X2`，其次是包含数据的`data`数据框。公式是R中一种奇特但有用的结构，我在其他地方几乎没见过。它们旨在表示变量之间的一种数学关系。正如你可能猜到的，这个公式告诉`lm`函数，你想使用`X1`和`X2`来预测`y`。截距（所有输入变量为零时的y值）也会自动添加，除非你明确地移除它。你可以在公式中添加更多的输入变量，或者添加变量的组合，例如两个变量的乘积、一个变量的平方等。在R中构建公式的可能性有很多，而且可能会变得相当复杂，所以我建议在编写自己的公式之前先查阅文档。
- en: 'The variables named in the formula must match some variables included in the
    data frame passed to `lm`. The `lm` function itself performs the regression and
    returns a fitted linear model, which is stored in the variable `linearModel`.
    It’s important to note that I created the data in this example to give expected
    regression results. Each of the four data points has a value for `X1`, `X2`, and
    `y`. The data frame data looks like this (the `>` is the R prompt):'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 公式中命名的变量必须与传递给`lm`的数据框中包含的一些变量匹配。`lm`函数本身执行回归，并返回一个拟合的线性模型，该模型存储在变量`linearModel`中。重要的是要注意，我在这个例子中创建的数据是为了给出预期的回归结果。每个四个数据点都有`X1`、`X2`和`y`的值。数据框数据看起来像这样（`>`是R的提示符）：
- en: '[PRE20]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you study the numbers closely, you may notice that in each row the y-value
    is pretty close to the corresponding result of `2*X1+1`, and the `X2` values don’t
    contribute much information about what the value of `y` will be. You say that
    `X1` is predictive of `y`, but `X2` is not, so you expect your regression results
    to be very nearly that. You’d expect the results of linear regression to indicate
    this.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细研究这些数字，可能会注意到，在每一行中，y值都相当接近`2*X1+1`的对应结果，而`X2`的值对`y`的值的信息贡献不大。你说`X1`可以预测`y`，但`X2`不能，所以你预期你的回归结果几乎是这样。你预期线性回归的结果会表明这一点。
- en: 'The command `summary(linearModel)` prints output to the screen, giving information
    about the linear model that was fit to the data, which can be seen here:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`summary(linearModel)`将输出打印到屏幕上，提供了有关拟合数据的线性模型的信息，如下所示：
- en: '[PRE21]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see in this output that the coefficient estimate for `X1` is very nearly
    2, that for `X2` is almost zero, and that of the intercept is above 1, so the
    results meet your expectations.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个输出中看到，`X1`的系数估计值非常接近2，`X2`的几乎为零，截距的值在1以上，所以结果符合你的预期。
- en: The rest of the output—standard errors, p-values, R-squared, and so on—give
    the goodness of fit, significance of coefficients, and other statistics about
    the model that indicate whether it’s a good model or not.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的输出——标准误差、p值、R平方等——给出了拟合优度、系数的显著性以及其他关于模型的统计信息，这些信息表明它是一个好模型还是不好。
- en: 'The final line of the script predicts y-values for the data points provided
    in the input data frame, which in this case is the same as the data with which
    you trained the model. The `predict` function takes the variables `X1` and `X2`
    in `data` and outputs y-values according to the model in `linearModel`. Here’s
    the printed output:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一行预测了输入数据框中提供的数据点的y值，在这种情况下，它与训练模型的数据相同。`predict`函数接受`data`中的变量`X1`和`X2`，并根据`linearModel`中的模型输出y值。以下是打印的输出：
- en: '[PRE22]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each of these four values is the prediction of the model for each of the data
    points (rows) in `data`. As you can see, the values are pretty close to the y-values
    on which the model was trained.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个值中的每一个都是模型对`data`中每个数据点（行）的预测。正如你所看到的，这些值与模型训练时的y值非常接近。
- en: Linear regression in Python
  id: totrans-711
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python中的线性回归
- en: Python has multiple packages that offer linear regression methods, and it provides
    a good example of having to balance the general rules for choosing software I
    outlined previously. From what I’ve gathered, the `LinearRegression` object in
    the `sklearn` package might be the most popular, but the summary of the fit model
    isn’t nearly as informative as the output from the function used in R. But the
    `linear_model` object in the package `statsmodels` does easily provide informative
    output, so I use that here.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: Python有多个提供线性回归方法的软件包，它提供了一个很好的例子，说明了在之前概述的选择软件的一般规则之间需要权衡。据我所知，`sklearn`包中的`LinearRegression`对象可能是最受欢迎的，但拟合模型的总结并不像R中使用的函数输出那样信息丰富。但`statsmodels`包中的`linear_model`对象可以轻松提供信息丰富的输出，所以我在这里使用它。
- en: 'The following code uses an object-oriented style, and the two main objects
    created are the linear model, which I called `linearModel` in the script, and
    a results object, which I called `results`. Methods of those objects are called
    to create the model, fit the model, summarize results, and make the same predictions
    you made in the R script. If you’re not familiar with object-oriented coding,
    it can seem a bit weird at first:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用面向对象风格，创建了两个主要对象：线性模型，我在脚本中将其称为`linearModel`，以及一个结果对象，我将其称为`results`。调用这些对象的方法来创建模型、拟合模型、总结结果，以及做出与R脚本中相同的预测。如果你不熟悉面向对象编程，一开始可能会觉得有点奇怪：
- en: '[PRE23]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how I created the variables `X` and `y`. They’re lists of values that,
    when fitting the model, are coerced into the appropriate array/matrix form. Data
    frames from the package `pandas` can also be used, but I elected not to use them
    here. I also added a column of 1s to the right of the `X` data because the model
    doesn’t automatically add an intercept value. There are other, more elegant ways
    to add an intercept, but I didn’t use them for the sake of clarity.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我是如何创建变量`X`和`y`的。它们是值的列表，在拟合模型时，被强制转换为适当的数组/矩阵形式。`pandas`包的数据框也可以使用，但我选择在这里不使用它们。我还向`X`数据右侧添加了一个1列，因为模型不会自动添加截距值。还有其他更优雅的方法来添加截距，但我没有使用它们，以保持清晰。
- en: 'After creating the data objects, the script performs the same steps that the
    R script does: create the model, using the `OLS` class in the `statsmodels` package;
    fit the model, using the object method call `linearModel.fit()`; print a summary
    of results; and predict `y` values from the original `X` values.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据对象后，脚本执行与R脚本相同的步骤：创建模型，使用`statsmodels`包中的`OLS`类；拟合模型，使用对象方法调用`linearModel.fit()`；打印结果摘要；并从原始`X`值预测`y`值。
- en: 'The printed output from the method call `results.summary()` is shown here:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用`results.summary()`的打印输出如下所示：
- en: '[PRE24]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It shows many of the same statistics as the summary in R plus some others. More
    importantly, it gives identical results.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了与R中总结相同的许多统计数据，还有一些其他的。更重要的是，它给出了相同的结果。
- en: 8.4.2\. Writing your own methods
  id: totrans-720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2. 编写自己的方法
- en: As a researcher in academia, I mostly developed algorithms for analyzing various
    systems and data in the field of bioinformatics. Because they were new, I didn’t
    have the luxury of applying a method in a software package, though in some cases
    I used some available methods to aid in things like optimization and model fitting.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名学术研究者，我主要开发了用于分析生物信息学领域各种系统和数据的算法。因为它们是新的，所以我无法享受在软件包中应用方法的奢侈，尽管在某些情况下，我使用了一些可用的方法来帮助进行优化和模型拟合。
- en: 'Creating new statistical methods can be time consuming, and I don’t recommend
    doing it unless you know what you’re doing or it’s your job. But if you must,
    it helps to know where to start. Generally speaking, I begin with the mathematical
    specification of the statistical model, which might look something like the model
    I described in the last chapter, which contained several specifications of the
    probability distributions of model parameters, such as this:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的统计方法可能耗时，除非你清楚自己在做什么或者这是你的工作职责，否则我不建议这么做。但如果你必须这么做，了解从哪里开始是很重要的。一般来说，我会从统计模型的数学规范开始，这可能看起来像我在上一章中描述的模型，其中包含了对模型参数概率分布的几个规范，例如：
- en: x[n,g] ~ N( μ[g] , 1/λ )
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x[n,g] ~ N( μ[g] , 1/λ )
- en: If the model and all of its parameters and variables have been specified like
    that, then you need to convert the specification into a likelihood function that
    you can use to find optimal parameter values or distributions.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型及其所有参数和变量都像那样被指定，那么你需要将这些规范转换成一个似然函数，你可以使用它来找到最优的参数值或分布。
- en: To get a likelihood function, which is a function of the parameter values based
    on the data values, you use the mathematical specification of the probability
    distribution functions for each individual data point and multiply them together.
    Or because probability densities are usually pretty small, and multiplying them
    together only makes for a very small number, it’s usually better to take the logarithm
    of the likelihood functions for each data point and then add them together. Because
    the logarithm of a function has its maximum at the same point as the function
    itself, maximizing the sum of the log-likelihoods is equivalent to maximizing
    the product of likelihoods. In fact, most software and algorithms designed for
    working with probabilities and likelihoods use the advantages of taking the logarithm.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到似然函数，这是一个基于数据值的参数值的函数，你需要使用每个单独数据点的概率分布函数的数学规范并将它们相乘。或者因为概率密度通常很小，相乘只会得到一个非常小的数，所以通常更好的做法是取每个数据点的似然函数的对数并将它们相加。因为函数的对数在其本身的最大值处达到最大，最大化对数似然的总和等同于最大化似然率的乘积。实际上，大多数用于处理概率和似然率的软件和算法都利用了对数取值的优势。
- en: Once you have the mathematical specification of the joint likelihood and log-likelihood,
    you can convert this directly into software by using whatever mathematics libraries
    the language offers. It should be straightforward to write a software function
    that takes as input the parameter values and gives as output a log-likelihood
    based on the data. This function should do in software exactly what the log-likelihood
    function would do in mathematics.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了联合似然和联合对数似然的数学规范，你就可以直接使用该语言提供的任何数学库将它们转换为软件。编写一个软件函数应该很简单，该函数接受参数值作为输入，并根据数据给出对数似然作为输出。这个函数应该在软件中执行与数学中对数似然函数相同的功能。
- en: 'Now that you have a software version of the joint likelihood function, you
    need to find optimal parameter values or distributions using one of the algorithms
    discussed in [chapter 7](kindle_split_017_split_000.xhtml#ch07): maximum likelihood
    estimation (MLE), maximum a posteriori (MAP), expectation-maximization (EM), variational
    Bayes (VB), or Markov chain Monte Carlo (MCMC). Most statistics software has methods
    for MLE, which would entail maximizing your joint likelihood function using an
    optimization routine. This can be easy for simple models but tricky for complex
    ones.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了联合似然函数的软件版本，你需要使用第7章中讨论的算法之一来找到最优的参数值或分布：最大似然估计（MLE）、最大后验（MAP）、期望最大化（EM）、变分贝叶斯（VB）或马尔可夫链蒙特卡洛（MCMC）。大多数统计软件都有MLE的方法，这涉及到使用优化程序来最大化你的联合似然函数。对于简单模型来说这可能很容易，但对于复杂模型来说可能很棘手。
- en: Using MAP methods would mean you’d have to go back to your model equations and
    calculate mathematically a specification of a posterior distribution of the parameter
    likelihood. Then you could maximize this posterior distribution in much the same
    way as you would for MLE. Formulating a posterior distribution isn’t trivial,
    so you may want to consult a reference on Bayesian models before trying it.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MAP方法意味着你将不得不回到你的模型方程，并从数学上计算参数似然的后验分布的指定。然后你可以像对MLE那样最大化这个后验分布。制定后验分布并不简单，所以在尝试之前你可能想查阅有关贝叶斯模型的参考资料。
- en: EM, VB, and MCMC also typically depend on the same posterior distribution that
    MAP does. Many software tools have an implementation of MCMC, so you might be
    able to apply those directly to get an estimate of the parameter posterior distribution,
    but with EM and VB, you usually have to code the model-fitting algorithm yourself,
    though there have been efforts to create software that simplifies the process.
    The difficulty of developing algorithms like EM and VB is probably one of the
    main reasons why MCMC is so popular. It can be tricky to get MCMC to work, but
    once it does, it lets raw computational power take the place of the human programming
    required for the other two algorithms.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: EM、VB和MCMC通常也依赖于与MAP相同的后验分布。许多软件工具都有MCMC的实现，所以你可能能够直接应用这些工具来估计参数后验分布，但对于EM和VB，你通常必须自己编写模型拟合算法，尽管已经有人努力创建简化这一过程的软件。开发像EM和VB这样的算法的难度可能是MCMC如此受欢迎的主要原因之一。让MCMC工作可能很棘手，但一旦它工作起来，它就让原始的计算能力取代了其他两种算法所需的人类编程。
- en: Exercises
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Continuing with the Filthy Money Forecasting personal finance app scenario
    first described in [chapter 2](kindle_split_011_split_000.xhtml#ch02), and relating
    to previous chapters’ exercises, try the following:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中首先描述的Filthy Money Forecasting个人财务应用场景的基础上，并关联到前几章的练习，尝试以下内容：
- en: '**1\.**'
  id: totrans-732
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1\.**'
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are your two top choices of software for performing the calculations necessary
    for forecasting in this project and why? What’s a disadvantage for each of these?
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你在这个项目中执行预测计算时，最常选择的两种软件是什么？为什么？这些软件的缺点是什么？
- en: '**2\.**'
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2\.**'
- en: ''
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do your two choices in question 1 have built-in functions for linear regression
    or other methods for time-series forecasting? What are they?
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在问题1中提到的两个选择是否具有内置的线性回归或其他时间序列预测方法？它们是什么？
- en: Summary
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Statistical software is an implementation of theoretical statistical models;
    understanding the relationship between the two is important for awareness of your
    project.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计软件是理论统计模型的实现；了解两者之间的关系对于了解你的项目很重要。
- en: A wide range of software is available for doing data science, from spreadsheets
    to mid-level statistical tools to statistical programming languages and libraries.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于进行数据科学的软件范围很广，从电子表格到中级统计工具，再到统计编程语言和库。
- en: Sometimes even spreadsheets can be useful to data scientists, for simpler tasks.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，即使是电子表格对数据科学家来说也可能很有用，用于简单的任务。
- en: Several good mid-level statistical tools are on the market, each with strengths
    and limitations.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市面上有几种很好的中级统计工具，每种都有其优势和局限性。
- en: Programming isn’t that hard, but it does take some time to learn, and it offers
    maximum flexibility in doing statistics on your data.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程并不那么难，但学习它需要一些时间，并且它为你进行数据统计提供了最大的灵活性。
- en: 'Chapter 9\. Supplementary software: bigger, faster, more efficient'
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 补充软件：更大、更快、更高效
- en: '*This chapter covers*'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Non-statistical software that can help you do statistics more efficiently
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以帮助你更高效地进行统计的非统计软件
- en: Some popular and ubiquitous software concepts related to analytic software
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与分析软件相关的流行且普遍的软件概念
- en: Basic guidelines for using supplementary software
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用补充软件的基本指南
- en: '[Figure 9.1](kindle_split_019_split_000.xhtml#ch09fig01) shows where we are
    in the data science process: optimizing a product with supplementary software.
    The software tools covered in [chapter 8](kindle_split_018_split_000.xhtml#ch08)
    can be very versatile, but there I focused mainly on the statistical nature of
    each. Software can do much more than statistics. In particular, many tools are
    available that are designed to store, manage, and move data efficiently. Some
    can make almost every aspect of calculation and analysis faster and easier to
    manage. In this chapter I’ll introduce some of the most popular and most beneficial
    software for making your life and work as a data scientist easier.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](kindle_split_019_split_000.xhtml#ch09fig01)显示了我们在数据科学流程中的位置：使用补充软件优化产品。第8章中涵盖的软件工具非常灵活，但我在那里主要关注了每个软件的统计特性。软件可以做的不仅仅是统计。特别是，有许多工具被设计用来高效地存储、管理和移动数据。一些工具可以使几乎每个计算和分析的方面都更快、更容易管理。在本章中，我将介绍一些最受欢迎且最有益的软件，这些软件可以使数据科学家的生活和工作更加轻松。'
- en: 'Figure 9.1\. An important aspect of the build phase of the data science process:
    using supplementary software to optimize the product'
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 数据科学流程构建阶段的一个重要方面：使用补充软件优化产品
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig01_alt.jpg)'
- en: 9.1\. Databases
  id: totrans-752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 数据库
- en: I discussed the concept of a database in [chapter 3](kindle_split_012_split_000.xhtml#ch03)
    as one form of data source. Databases are common, and your chances of running
    across one during a project are fairly high, particularly if you’re going to be
    using data that’s used by others quite often. But instead of merely running into
    one as a matter of course, it might be worthwhile to set up a database yourself
    to aid you in your project.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第3章](kindle_split_012_split_000.xhtml#ch03)中讨论了数据库的概念，将其视为一种数据源的形式。数据库很常见，你在项目中进行时遇到数据库的机会相当高，尤其是如果你经常使用他人使用的数据。但与其仅仅顺其自然地遇到一个数据库，不如自己建立一个数据库来帮助你完成项目。
- en: 9.1.1\. Types of databases
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 数据库类型
- en: Many types of databases exist, each designed to store data and provide access
    to it in its own way. But all databases are designed to be more efficient than
    standard file-based storage, at least for some applications.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多类型的数据库，每种数据库都设计用来以自己的方式存储数据并提供访问。但所有数据库都旨在比标准基于文件存储更高效，至少对于某些应用来说是这样。
- en: More types (and subtypes) exist, but the two most common categories of databases
    today are *relational* and *document-oriented*. Though I’m certainly not an expert
    in database models and theory, I will attempt to describe the two types as I see
    them from the perspective of how I typically think about them conceptually and
    interact with them.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 存在更多类型（和子类型），但今天最常见的两种数据库类型是*关系型*和*文档型*。尽管我当然不是数据库模型和理论的专家，但我将尝试从通常从概念上思考它们以及如何与之交互的角度来描述这两种类型。
- en: Relational
  id: totrans-757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关系型
- en: '*Relational* databases are all about tables. A *table* in a relational database
    can usually be visualized as a two-dimensional sheet such as those found in spreadsheets:
    the sheet contains rows and columns, with data elements in the cells.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系型*数据库全都是关于表格的。关系型数据库中的一个*表格*通常可以想象成类似于电子表格中的二维表格：该表格包含行和列，单元格中包含数据元素。'
- en: The powerful thing about relational databases is that they can hold many tables
    and can, behind the scenes, relate the tables to each other in clever ways. This
    way, even the most complicated queries from multiple tables and data types can
    be executed in an optimal way, often saving enormous amounts of time when compared
    with a primitive scan-the-tables approach to find data that matches a query.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库的强大之处在于它们可以存储许多表格，并且可以在幕后以巧妙的方式将表格相互关联。这样，即使是来自多个表格和数据类型的复杂查询也可以以最佳方式执行，与原始的扫描表格方法相比，通常可以节省大量时间。
- en: 'Among relational databases, which have been popular for decades, one dominant
    language has emerged for formulating queries: *structured query language* (SQL,
    usually pronounced “sequel”). SQL is practically ubiquitous, though other query
    languages for relational databases do exist. In short, you can use SQL to query
    many different kinds/brands/subtypes of relational databases; so if you’re familiar
    with SQL, you can begin to work with an unfamiliar database without learning a
    new query syntax. On the other hand, not all SQL-based databases use exactly the
    same syntax, so some relatively minor adaptations to a specific query may be necessary
    for it to work on a new database.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 在流行了几十年的关系型数据库中，一种主导语言已经出现，用于制定查询：*结构化查询语言*（SQL，通常发音为“sequel”）。SQL实际上无处不在，尽管关系型数据库还有其他查询语言。简而言之，你可以使用SQL查询许多不同种类/品牌/子类型的数据库；所以如果你熟悉SQL，你就可以开始使用一个不熟悉的数据库，而无需学习新的查询语法。另一方面，并非所有基于SQL的数据库都使用完全相同的语法，因此可能需要对特定查询进行一些相对较小的调整，以便它在新的数据库上工作。
- en: Document-oriented
  id: totrans-761
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文档型
- en: In some sense, *document-oriented* databases are the antithesis to relational
    databases. Whereas relational databases have tables, document-oriented databases
    have, well, documents. No surprise there.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，文档型数据库是关系型数据库的对立面。关系型数据库有表，而文档型数据库有，嗯，文档。这并不奇怪。
- en: A *document* in this case can be a set of so-called *unstructured* data, like
    the text of an email, along with a set of structured identifying information,
    such as an email’s sender and time sent. It’s closely related to the *key-value*
    concept of data storage, wherein data is stored and catalogued for easy retrieval
    according to a set of a few keys. *Keys* are usually chosen to be the fields of
    a data point by which you would find it when querying—for example, ID, name, address,
    date, and so on. The *values* of a data point can be thought of as a sort of payload
    that’s stored alongside the keys but that generally isn’t used to find the data
    point in a query. It can be a messy pile of data if you want because you’re not
    usually querying the data using the value (for a notable exception, keep reading).
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，“文档”可以是一组所谓的*非结构化*数据，如电子邮件的文本，以及一组结构化标识信息，例如电子邮件的发送者和发送时间。它与数据存储的*键值*概念密切相关，其中数据根据一组少量键进行存储和编目，以便于检索。*键*通常选择为数据点的字段，通过这些字段在查询时可以找到它——例如，ID、姓名、地址、日期等等。数据点的*值*可以被视为与键一起存储的某种有效载荷，但在查询中通常不用于查找数据点。如果你愿意，它可能是一堆混乱的数据，因为你通常不会使用值来查询数据（对于明显的例外，请继续阅读）。
- en: Things like raw text, lists of unknown length, JSON objects, or other data that
    doesn’t seem well suited for fitting into a table can usually fit easily into
    a document-oriented database. For efficient querying, each piece of unstructured
    data (a possible value) would ideally be matched with a few bits of structured
    identifying information (potential keys), because almost without exception databases
    handle structured data much more efficiently than unstructured.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 原始文本、未知长度的列表、JSON对象或其他似乎不适合放入表格中的数据通常可以轻松地适应文档型数据库。为了高效查询，每一条非结构化数据（一个可能的值）理想情况下都应与少量结构化标识信息（潜在的键）相匹配，因为几乎无一例外，数据库在处理结构化数据方面比非结构化数据要高效得多。
- en: Because document-oriented databases are a sort of antithesis of relational databases
    and tables, the term *NoSQL* is often applied to them. You’ll find other types
    of NoSQL databases, but document-oriented is the largest subclass.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档型数据库是关系型数据库和表格的对立面，因此术语*NoSQL*经常被应用于它们。你将发现其他类型的NoSQL数据库，但文档型是最大的子类。
- en: Besides being generally more flexible and probably less efficient than relational
    databases, document-oriented databases can have their own strengths. An example
    of such a strength can be seen in the popular Elasticsearch data store. Elasticsearch
    is an open-source document-oriented database built on top of the (also open-source)
    Apache Lucene text search engine. Lucene and Elasticsearch are good at parsing
    text, finding certain words and word combinations, and generating statistics about
    the occurrences of those words. Therefore, if you’re working with a large number
    of text documents, and you’ll be studying the occurrence of words and phrases,
    few if any databases (relational or not) will be as efficient as Elasticsearch.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常比关系数据库更灵活且可能效率更低之外，面向文档的数据库还可以有自己的优势。这种优势的一个例子可以在流行的 Elasticsearch 数据存储中看到。Elasticsearch
    是一个基于（也是开源的）Apache Lucene 文本搜索引擎的开源面向文档的数据库。Lucene 和 Elasticsearch 都擅长解析文本、查找特定的单词和单词组合，并生成这些单词出现次数的统计数据。因此，如果你正在处理大量文本文档，并且将研究单词和短语的出现情况，那么几乎没有（如果有的话）数据库（无论是关系型还是非关系型）会比
    Elasticsearch 更有效率。
- en: Querying an Elasticsearch (or similar) database by raw text is a notable exception
    to the general rule that you should query by key and not by value. Because Lucene
    does such a good job of indexing text, querying by terms in the text behaves more
    like searching by key than in most other databases.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 通过原始文本查询 Elasticsearch（或类似）数据库是通常规则的一个显著例外，即你应该通过键而不是值进行查询。由于 Lucene 在索引文本方面做得很好，因此通过文本中的术语进行查询的行为在大多数其他数据库中更像是通过键进行搜索。
- en: Other database types
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他数据库类型
- en: If you’re working with a specific type of data that can’t be represented easily
    as a set of tables or documents—and so isn’t ideal for either a relational or
    document-oriented database—it might be worth searching for a database that suits
    that data type. For instance, graph data such as I’ve used in social-network analysis
    projects can often benefit from the efficiencies of a graph database. Neo4j is
    a popular *graph database* that represents connections between things (such as
    people in a social network) in a way that makes storage, querying, and analysis
    of graph data easier. There are many other examples of databases that cater to
    very specific data types, but I won’t attempt to survey them here. A quick online
    search should lead you in the right direction.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理一种无法轻易表示为一系列表格或文档的数据类型，那么它可能不适合关系型或面向文档的数据库，在这种情况下，寻找适合该数据类型的数据库可能是有价值的。例如，我在社交网络分析项目中使用的图数据通常可以从图数据库的效率中受益。Neo4j
    是一个流行的 *图数据库*，它以使存储、查询和分析图数据更简单的方式表示事物（如社交网络中的人）之间的连接。有许多其他数据库的例子，它们针对非常具体的数据类型，但在这里我不会尝试对这些数据库进行概述。快速在线搜索应该能引导你找到正确的方向。
- en: 9.1.2\. Benefits of databases
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 数据库的优点
- en: Databases and other related types of data stores can have a number of advantages
    over storing your data on a computer’s file system. Mostly, databases can provide
    arbitrary access to your data—via queries—more quickly than the file system can,
    and they can also scale to large sizes, with redundancy, in convenient ways that
    can be superior to file system scaling. Here I give brief descriptions of some
    of the major advantages that databases can offer.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 与存储在计算机文件系统上的数据相比，数据库和其他相关类型的数据存储可以具有许多优势。主要的是，数据库可以通过查询提供对数据的任意访问，比文件系统更快，并且它们还可以以方便的方式扩展到大型规模，具有冗余性，这可以优于文件系统的扩展。在这里，我简要描述了数据库可以提供的一些主要优点。
- en: Indexing
  id: totrans-772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 索引
- en: A database *index* is a set of software tricks that generate a sort of map of
    all the data so that anything can be found quickly and easily. *Indexing* is the
    process of building such a map. Often indexing makes efficient use of hardware—disk
    and memory—to improve overall efficiency.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库 *索引* 是一系列软件技巧，它们生成所有数据的某种映射，以便任何内容都可以快速轻松地找到。*索引* 是构建此类映射的过程。通常，索引会有效地利用硬件（磁盘和内存）来提高整体效率。
- en: The price of having an index (versus no index) is some disk and memory space,
    because the index itself takes up room. Usually you have a choice of creating
    a very efficient index that takes up more space or a less efficient index that
    takes up less space. The optimal choice depends on what you’re trying to accomplish.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有索引（与没有索引相比）的代价是占用一些磁盘和内存空间，因为索引本身需要占用空间。通常，你可以选择创建一个非常高效的索引，它占用更多空间，或者创建一个效率较低的索引，它占用较少空间。最佳选择取决于你试图实现的目标。
- en: Caching
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缓存
- en: '*Caching*, in the general sense, is the holding aside of certain data that’s
    accessed very often with the goal of gaining efficiency overall because that often-used
    data is readily available in a special location. When certain bits of data are
    accessed often, you can decrease the overall average access time by holding the
    often-used data close at hand in some sense (various aspects of system architecture
    make this possible). If the often-used data has very short access times, it doesn’t
    matter if the occasional rarely accessed data takes a bit longer to find. Databases
    often try to recognize the data that’s used most often and hold it close instead
    of putting it back among the rest of the data. Like indexing, caching takes up
    space, but you usually have a choice of how much space you’d like to dedicate
    to the cache, which in turn determines how effective it is.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在广义上，*缓存*是指将某些经常访问的数据保留在一边，目的是为了提高整体效率，因为经常使用的数据在特殊位置可以快速获取。当某些数据被频繁访问时，你可以在某种程度上将经常使用的数据放在手边，从而减少整体平均访问时间（系统架构的各个方面使得这一点成为可能）。如果经常使用的数据访问时间非常短，偶尔很少访问的数据查找时间稍长一些并不重要。数据库通常会尝试识别最常用的数据并将其保留在附近，而不是将其放回其他数据中。与索引一样，缓存会占用空间，但你通常可以选择你希望分配给缓存的空间量，这反过来又决定了其有效性。
- en: Scaling
  id: totrans-777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规模化
- en: Many types of databases in existence today can be distributed over many machines.
    Obviously, this isn’t a direct advantage over storing your data in files on a
    disk, because if you have access to many machines, you have access to many disks.
    The advantage, then, of a distributed database over a distributed file system
    is the coordination.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当今存在的许多类型的数据库可以分布到许多机器上。显然，这并不是将你的数据存储在磁盘上的文件上的直接优势，因为如果你可以访问许多机器，你就可以访问许多磁盘。那么，分布式数据库相对于分布式文件系统的优势在于协调。
- en: If you have data on many disks on many machines, you have to keep track of what
    you’re keeping where. Distributed databases are designed to do this automatically.
    Distributed databases typically consist of *shards*, or chunks of data that each
    exist in a single location. A central server (or multiple servers) manages access
    and transfer between shards. Additional shards can be used to increase the potential
    size of the database or to replicate data that exists elsewhere, according to
    the chosen database configuration.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有许多机器上的多个磁盘上的数据，你必须跟踪你将数据保存在哪里。分布式数据库旨在自动执行此操作。分布式数据库通常由*分片*组成，即每个分片的数据都存在于单个位置。一个中央服务器（或多个服务器）管理分片之间的访问和传输。可以根据选择的数据库配置使用额外的分片来增加数据库的潜在大小或复制其他地方存在的数据。
- en: Concurrency
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并发
- en: If two different computer processes try to change the same data point at the
    same time, the changes are said to be *concurrent*, and the issue of finding the
    proper final state is generally referred to as *concurrency*. Databases generally
    handle this better than the file system. Specifically, if two different processes
    are trying to create or edit the same file at the same time, any number of errors
    may occur, or none at all, which is sometimes a bigger problem. Generally speaking,
    you want to avoid concurrency at all costs on a file system, but certain types
    of databases provide convenient solutions for resolving any conflicts.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个不同的计算机进程试图同时更改相同的数据点，这些更改被称为*并发*，而找到适当最终状态的问题通常被称为*并发问题*。数据库通常比文件系统更好地处理这个问题。具体来说，如果两个不同的进程试图同时创建或编辑相同的文件，可能会发生任何数量的错误，或者根本不会发生错误，这有时可能是一个更大的问题。一般来说，你希望在文件系统上不惜一切代价避免并发，但某些类型的数据库提供了方便的解决方案来解决任何冲突。
- en: Aggregations
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚合
- en: A database’s index can be applied in tasks other than finding data matching
    a query. Often databases provide functionality for performing *aggregations* of
    the data matching a query or all data. A database might be able to add up, multiply,
    or summarize data much faster than your code would, and so it could be helpful
    to push this summarization to the database and increase overall efficiency.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的索引可以应用于除了查找与查询匹配的数据之外的任务。通常，数据库提供执行匹配查询或所有数据的*聚合*功能。数据库可能能够比你的代码更快地累加、乘法或汇总数据，因此将这种汇总推送到数据库并提高整体效率可能是有帮助的。
- en: For example, Elasticsearch makes it easy to calculate the frequency of certain
    search terms within a database. If Elasticsearch didn’t provide this functionality,
    you’d have to query for all occurrences of the term, count the number of occurrences,
    and divide by the total number of documents. That may not seem like a problem,
    but if you’re doing this thousands or millions of times, allowing the database
    to calculate the frequencies in an optimized, efficient way can save a considerable
    amount of time.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Elasticsearch 使得在数据库中计算特定搜索词的频率变得容易。如果 Elasticsearch 没有提供这项功能，你就必须查询该词的所有出现，计算出现次数，然后除以总文档数。这看起来可能不是问题，但如果你这样做成千上万次，让数据库以优化、高效的方式计算频率可以节省大量时间。
- en: Abstracted query language
  id: totrans-785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象查询语言
- en: Querying a database for certain data involves formulating the query in a query
    language, such as SQL, that the database understands. Although it can be annoying
    to have to learn a new query language for a new database, these languages offer
    abstraction from the search algorithm that underlies the query. If your data was
    stored in files on the file system and you weren’t using a database, every time
    you wanted to search for data points meeting certain criteria, you’d have to write
    an algorithm that goes through all your files—all the data points—and checks to
    see if they meet your criteria. With a database, you don’t have to worry about
    the specific search algorithm because the database handles it. The query language
    provides a concise, often readable description of what you’re looking for, and
    the database finds it for you.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库以获取特定数据涉及使用数据库理解的查询语言，例如 SQL。虽然学习一种新的查询语言以适应新的数据库可能会让人感到烦恼，但这些语言提供了对查询背后搜索算法的抽象。如果你的数据存储在文件系统上的文件中，并且你没有使用数据库，那么每次你想搜索满足某些标准的数据点时，你都必须编写一个算法，遍历所有文件——所有数据点——并检查它们是否满足你的标准。使用数据库时，你不必担心特定的搜索算法，因为数据库会处理它。查询语言提供了关于你正在寻找内容的简洁、通常可读的描述，并且数据库会为你找到它。
- en: 9.1.3\. How to use databases
  id: totrans-787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 如何使用数据库
- en: 'Most software tools, Excel included, can interface with databases, but some
    are better at it than others. The most popular programming languages all have
    libraries or packages for accessing all the most popular databases. Learning how
    it’s done is a matter of checking the documentation. Generally speaking, you’ll
    have to know how to do the following:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件工具，包括 Excel，都可以与数据库接口，但有些做得比其他更好。所有最流行的编程语言都有访问所有最流行数据库的库或包。了解如何操作只需查看文档即可。一般来说，你需要知道以下内容：
- en: Create the database.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库。
- en: Load your data into the database.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的数据加载到数据库中。
- en: Configure and index the database.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和索引数据库。
- en: Query the data from your statistical software tool.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从你的统计软件工具查询数据。
- en: Each database is a bit different, but once you get used to a couple of them,
    you’ll see similarities and learn more of them quickly. It seems that today there’s
    a book in publication for every type of database out there, so it’s a matter of
    finding it and putting it to use. For NoSQL databases, the offerings can be particularly
    broad, diverse, and overwhelming, so a book like *Making Sense of NoSQL* (McCreary
    and Kelly, Manning, 2013) can help you sort through all the capabilities and options.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都有一些不同，但一旦你习惯了其中几个，你就会看到相似之处，并快速学会更多。似乎现在每类数据库都有相应的书籍出版，所以这是一个找到它并投入使用的问题。对于
    NoSQL 数据库，提供的选项尤其广泛、多样且令人眼花缭乱，因此像《理解 NoSQL》（McCreary 和 Kelly，Manning，2013）这样的书籍可以帮助你梳理所有功能和选项。
- en: 9.1.4\. When to use databases
  id: totrans-794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 何时使用数据库
- en: If accessing your data from the file system is slow and awkward, it’s probably
    time to try a database. It can also depend on how you’re accessing your data.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从文件系统访问数据既慢又麻烦，那么可能是时候尝试使用数据库了。这也可能取决于你如何访问数据。
- en: If your code is often searching for specific data—thousands or millions of times—a
    database can greatly speed up access times and the overall execution time of your
    code. Sometimes code can become orders of magnitude faster upon switching from
    file system storage to a database. One of my projects once sped up by 1000 times
    when I first made the switch.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码经常搜索特定数据——数千或数百万次——数据库可以大大加快访问时间和代码的整体执行时间。有时，代码在从文件系统存储切换到数据库后可以快几个数量级。我的一个项目在第一次切换时速度提高了1000倍。
- en: If you have data on the file system and you mostly proceed through it top to
    bottom, or if you don’t search often, then a database might not help you much.
    Databases are best for finding on-demand data that matches specific criteria,
    and so if you don’t need to query, search, or jump around in the data, the file
    system might be the best choice.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你文件系统中的数据你通常是从上到下处理，或者如果你不经常搜索，那么数据库可能对你帮助不大。数据库最适合查找符合特定标准的需求数据，因此如果你不需要查询、搜索或跳转数据，文件系统可能是最佳选择。
- en: One reason why I sometimes resist using a database is that it adds some complexity
    to the software and the project. Having a live, running database adds at least
    one more moving part to all the things you need to keep your eye on. If you need
    to transport your data to multiple machines or locations, or if you worry that
    you don’t have the time to configure, manage, and debug yet another piece of software,
    then maybe creating a database isn’t the best idea. It certainly requires at least
    a little maintenance work.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 我有时抵制使用数据库的一个原因是因为它给软件和项目增加了一些复杂性。拥有一个实时运行的数据库至少会给所有你需要关注的事物增加一个动态部分。如果你需要将数据传输到多台机器或多个位置，或者如果你担心你没有时间配置、管理和调试另一件软件，那么创建数据库可能不是最好的主意。这肯定需要至少一点维护工作。
- en: 9.2\. High-performance computing
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 高性能计算
- en: '*High-performance computing* (HPC) is the general term applied to cases where
    there’s a lot of computing to do and you want to do it as fast as possible. In
    some cases you need a fast computer, and in others you can split up the work and
    use many computers to tackle the many individual tasks. There is also some middle
    ground between these two.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*高性能计算*（HPC）是一般术语，用于描述有很多计算要做，并且你希望尽可能快地完成的情况。在某些情况下，你需要一台快速的计算机，而在其他情况下，你可以将工作拆分，使用多台计算机来处理多个单独的任务。这两种方法之间也存在某种中间地带。'
- en: 9.2.1\. Types of HPC
  id: totrans-801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. HPC 类型
- en: Beyond the question of having one computer or many, you may also consider using
    computers that are good at certain tasks or compute clusters that are configured
    and organized in particularly useful ways. I describe a few of the options here.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是拥有一台还是多台计算机，你可能还会考虑使用擅长特定任务的计算机，或者配置和组织得特别有用的计算集群。我在这里描述了一些选项。
- en: Supercomputers
  id: totrans-803
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 超级计算机
- en: A *supercomputer* is an extremely fast computer. There’s something of a worldwide
    competition for the fastest supercomputer, a title that carries more prestige
    than anything else. But the technological challenges for taking the title are
    not small, and neither are the results.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '*超级计算机*是一台非常快的计算机。全球范围内存在一场关于最快超级计算机的竞争，这个头衔比其他任何东西都更有声望。但是，获得这个头衔的技术挑战并不小，结果也是如此。'
- en: A new supercomputer is millions of times faster than a standard personal computer
    — it could probably compute your results millions of times faster than your PC.
    If you have access to one—and not many people have such access—it might be worth
    considering.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 新型超级计算机比标准个人计算机快数百万倍——它可能比你的PC快数百万倍来计算结果。如果你能访问到——而且不是很多人有这样的访问权限——那么考虑它可能是有价值的。
- en: Most universities and large, data-oriented organizations with an IT department
    may not have a supercomputer, but they have a powerful computer somewhere. Computing
    your results 100x or 1000x faster might be possible, if only you ask the right
    people for access.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数大学和拥有 IT 部门的大型、数据导向的组织可能没有超级计算机，但它们某处有一台功能强大的计算机。如果你向正确的人请求访问权限，计算结果可能比标准个人计算机快
    100 倍或 1000 倍。
- en: Computer clusters
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算机集群
- en: A *computer cluster* is a bunch of computers that are connected with each other,
    usually over a local network, and configured to work well with each other in performing
    computing tasks. More so than with a supercomputer, computing tasks may need to
    be explicitly parallelized or otherwise split into separate tasks so that each
    computer in the cluster can perform some part of the work.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机集群*是一组相互连接的计算机，通常通过本地网络连接，配置得可以很好地协同完成计算任务。与超级计算机相比，计算任务可能需要显式并行化或以其他方式拆分成单独的任务，以便集群中的每台计算机都能完成部分工作。'
- en: Depending on the cluster, the various computers and the tasks they’re executing
    may be able to communicate with each other efficiently, or they may not. Some
    types of commodity computer clusters (HTCondor is a popular software framework
    for unifying them) focus less on optimizing the individual machines and more on
    maximizing the total amount of work the cluster can do. Other cluster types are
    highly optimized for performance that, in aggregate, resembles a supercomputer.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群的不同，各种计算机及其执行的任务可能能够高效地相互通信，也可能不能。一些类型的通用计算机集群（例如，HTCondor是一个流行的软件框架，用于统一它们）更少关注优化单个机器，而是更多地关注最大化集群可以完成的总工作量。其他类型的集群高度优化性能，总体上类似于超级计算机。
- en: One shortcoming of a cluster when compared to a supercomputer is usually the
    available memory. In a supercomputer, there’s usually one giant pool of available
    memory, and so extremely large and complex structures can be held in memory —
    which is much, much faster than trying to store that structure on a disk or in
    a database. In a cluster, each computer has only its own available memory, so
    it might be able to load only a small piece of a complex structure at one time.
    Writing and reading to disk can cost time and overall performance, but it depends
    highly on the specific calculations that are being done. Highly parallel calculations
    are more suitable for clusters.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 与超级计算机相比，集群的一个缺点通常是可用的内存。在超级计算机中，通常有一个巨大的可用内存池，因此可以存储极其庞大和复杂的结构——这比尝试将结构存储在磁盘或数据库中要快得多。在集群中，每台计算机只有自己的可用内存，因此它可能一次只能加载复杂结构的一小部分。写入和读取磁盘可能会花费时间并影响整体性能，但这取决于正在进行的特定计算。高度并行的计算更适合集群。
- en: GPUs
  id: totrans-811
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GPU
- en: '*Graphics processing units* (GPUs) are circuits that are designed to process
    and manipulate video images on a computer screen. The video card on every computing
    device with a screen has a GPU.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '*图形处理单元*（GPU）是设计用于在计算机屏幕上处理和操纵视频图像的电路。每个带有屏幕的计算设备上的显卡都有一个GPU。'
- en: The nature of video manipulation has resulted in GPU designs that are very good
    at performing highly parallelizable calculations. In fact, some GPUs are so good
    at certain types of calculations that they’re preferred over standard CPUs. For
    a while, several years ago, researchers were buying and building clusters out
    of video game systems such as the Sony PlayStation because the computing power
    available from the systems’ GPUs was greater than that of other computers of similar
    price.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 视频处理的特点导致了GPU设计非常适合执行高度可并行化的计算。事实上，一些GPU在特定类型的计算上非常出色，以至于它们被优先考虑于标准CPU。几年前，研究人员购买并构建了由视频游戏系统（如索尼PlayStation）组成的集群，因为这些系统GPU的计算能力超过了价格相似的其它计算机。
- en: 9.2.2\. Benefits of HPC
  id: totrans-814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. HPC的好处
- en: 'The one and only benefit of HPC is quite simple to state: speed. HPC can do
    your computing faster than standard computing, also known as low-performance computing.
    If you have access—and this is a big *if*—then HPC is a good alternative to waiting
    for your PC to calculate all the things that need to be calculated. *Cloud computing*,
    which I discuss later in this chapter, makes HPC available to everyone—for a price.
    The benefit of using a cloud HPC offering—and some pretty powerful machines are
    available—must be weighed against the monetary cost before you opt in.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能计算（HPC）的唯一好处非常简单明了：速度。HPC可以比标准计算（也称为低性能计算）更快地完成计算。如果你有访问权限——这是一个很大的“如果”——那么HPC是等待你的PC计算所有需要计算的事情的一个好选择。我将在本章后面讨论的*云计算*使HPC对每个人开放——但需要付费。在决定加入之前，必须权衡使用云HPC服务的好处——一些非常强大的机器可供选择——以及其货币成本。
- en: 9.2.3\. How to use HPC
  id: totrans-816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 如何使用HPC
- en: Using a supercomputer, computer cluster, or GPU can be quite similar to using
    your own personal computer, assuming you know how to make use of multiple cores
    of your machine. The statistical software tools and languages that you’re using
    typically have a method to use multiple cores of a personal computer, and these
    methods usually transfer nicely to HPC.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超级计算机、计算机集群或GPU与使用你自己的个人计算机相当相似，前提是你知道如何利用你机器的多核。你使用的统计软件工具和语言通常有使用个人计算机多核的方法，并且这些方法通常很好地转移到高性能计算（HPC）上。
- en: In the R language, I used to use the `multicore` package for parallelizing my
    code and using multiple cores. In Python, I use the `multiprocessing` package
    for the same purpose. With each of these, I can specify the number of cores I’d
    like to use, and each has some notion of sharing objects and information between
    the processes running on the various cores. Sharing objects and information between
    processes can be tricky, so you, particularly as a beginner, should shy away from
    doing it. Purely parallel is much easier on the code and on the brain, if you’re
    able to implement your algorithm that way.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 在R语言中，我过去使用`multicore`包来并行化我的代码并使用多个核心。在Python中，我使用`multiprocessing`包来达到同样的目的。在这些包中，我可以指定我想要使用的核心数量，每个包都有一些在各个核心上运行的过程之间共享对象和信息的方法。在进程之间共享对象和信息可能很棘手，所以，尤其是作为一个初学者，你应该避免这样做。如果你能够以这种方式实现你的算法，纯并行对代码和大脑来说都更容易一些。
- en: In my experience, submitting my code to a computer cluster was similar to running
    it on my own machine. I asked my colleagues at the university where I was working
    what the basic command was for submitting a job to the cluster queue, and then
    I adapted my code to conform. I could specify the number of computer cores I would
    like as well as the amount of memory, both of which affected my status in the
    queue. The cluster at this particular university, as at most, was in high demand,
    and queuing was both a necessity and a bit of a game.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的经验中，将我的代码提交到计算机集群与在我的机器上运行它类似。我向我在工作的大学里的同事们询问了提交作业到集群队列的基本命令，然后我调整了我的代码以符合要求。我可以指定我想要的计算机核心数量以及内存量，这两者都会影响我在队列中的状态。这个特定大学的集群，就像大多数集群一样，需求很高，排队既是必需的，也像是一种游戏。
- en: Sometimes, particularly with GPUs, it’s necessary to modify your code to make
    explicit use of special hardware capabilities. It’s usually best to consult an
    expert or wade through the documentation.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，尤其是与GPU一起使用时，有必要修改你的代码以明确使用特殊硬件功能。通常最好是咨询专家或查阅文档。
- en: 9.2.4\. When to use HPC
  id: totrans-821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4\. 何时使用HPC
- en: 'Because HPC is faster than the alternative, the rule is: if you have access,
    use it. If there’s no cost to you, and you don’t have to change your code much
    to take advantage of it, the question is a no-brainer. But it isn’t always that
    simple. If I have the option of using some HPC solution, I think first about the
    code changes and other legwork I’ll have to do in order to use HPC and then I
    compare that to the computing time I’ll save. Sometimes, if you’re not in a hurry,
    HPC isn’t worth it. Other times, it can give you results in an hour that would
    have otherwise taken a week or longer.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HPC比替代方案更快，规则是：如果你有权限使用，就使用它。如果没有成本，而且你不需要对代码进行太多修改就能利用它，那么这个问题就一目了然。但事情并不总是那么简单。如果我有使用某些HPC解决方案的选择，我会首先考虑为了使用HPC我必须进行的代码更改和其他准备工作，然后我会将这个与我会节省的计算时间进行比较。有时，如果你不急于求成，HPC可能不值得。其他时候，它可以在一小时内给你结果，而这在其他情况下可能需要一周或更长时间。
- en: 9.3\. Cloud services
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 云服务
- en: '*Cloud services* were all the rage a few years ago. They’re still very popular,
    but they’re growing more mature and becoming less of a novel technology. It’s
    safe to say, however, that they’re here to stay. In short, cloud services provide,
    rentable by the hour, the capabilities you could otherwise get only by buying
    and managing a rack of servers yourself.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '*云服务*几年前非常流行。它们仍然非常受欢迎，但它们正在变得更加成熟，不再是新颖的技术。然而，可以肯定的是，它们会留下来。简而言之，云服务按小时出租，提供你通常只能通过购买和管理自己的服务器才能获得的性能。'
- en: The largest providers of cloud services are mostly large technology companies
    whose core business is something else. Companies like Amazon, Google, and Microsoft
    already had vast amounts of computing and storage resources before they opened
    them up to the public. But they weren’t always using the resources to their maximum
    capacity, and so they decided both to rent out excess capacity and to expand their
    total capacity, in what has turned out to be a series of lucrative business decisions.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务的主要提供商大多是大型科技公司，它们的主营业务是其他事情。像亚马逊、谷歌和微软这样的公司，在向公众开放之前，就已经拥有大量的计算和存储资源。但它们并不总是充分利用这些资源，因此它们决定既出租多余的容量，也扩大总容量，这最终证明是一系列有利可图的商业决策。
- en: 9.3.1\. Types of cloud services
  id: totrans-826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 云服务的类型
- en: Services offered are usually roughly equivalent to the functionality of a personal
    computer, computer cluster, or local network. All are available in geographic
    regions around the world, accessible via an online connection and standard connection
    protocols, as well as, usually, a web browser interface.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的服务通常大致相当于个人计算机、计算机集群或本地网络的功能。所有这些都在全球的地理区域内可用，通过在线连接和标准连接协议以及通常的网页浏览器界面访问。
- en: Storage
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 存储
- en: All the major cloud providers offer file-storage services, usually paid per
    gigabyte per month. There are often also various tiers for storage, and you may
    pay more if you want faster reading or writing of your files.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的云服务提供商都提供文件存储服务，通常按每月每千兆字节付费。通常还有各种存储层，如果你想要更快的读取或写入文件，你可能需要支付更多费用。
- en: Computers
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算机
- en: 'This is probably the most straightforward of cloud offerings: you can pay by
    the hour for access to a computer with given specifications. You can choose the
    number of cores, the amount of machine memory, and the size of the hard disk.
    You can rent a big one, fire it up, and treat it like your supercomputer for a
    day or a week. Better computers cost more, naturally, but the prices are falling
    every year.'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是云服务中最直接的一种：你可以按小时支付访问具有特定规格的计算机的费用。你可以选择核心数量、机器内存量和硬盘大小。你可以租用一个大的，启动它，并将其作为你的超级计算机使用一天或一周。当然，更好的计算机价格更高，但价格每年都在下降。
- en: Databases
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据库
- en: As an extension to the storage offered by cloud providers, there are also cloud-native
    database offerings. This means you can create and configure databases without
    ever having a sense of which computers or disks the database is running on.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 作为云服务提供商提供的存储的扩展，还有云原生数据库服务。这意味着你可以创建和配置数据库，而无需知道数据库运行在哪些计算机或磁盘上。
- en: This machine agnosticism can save some headaches when maintaining your databases,
    because you don’t have to worry about configuring and maintaining the hardware
    as well. In addition, the databases can scale almost infinitely; the cloud provider
    is the one that has to worry about how many machines and how many shards are involved.
    The price, a literal one, is that you will often be charged for each access to
    the database—reads and writes—as well as for the volume of data stored.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机器无关性在维护数据库时可以节省一些麻烦，因为你不必担心配置和维护硬件。此外，数据库可以几乎无限扩展；云服务提供商需要担心的是涉及多少机器和多少分片。代价，字面上的代价，是你将经常为每次访问数据库——读取和写入——以及存储的数据量付费。
- en: Web hosting
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络托管
- en: Web hosting is like renting a computer and then deploying a web server to it,
    but it comes with a few more bells and whistles. If you want to deploy a website
    or other web server, cloud services can help you do so without worrying much about
    the individual computers and machine configurations. They typically offer platforms
    under which, if you conform to their requirements and standards, your web server
    will run and scale with usage without much hassle. For example, Amazon Web Services
    has platforms for deploying web servers using Python’s Django framework as well
    as the Node.js framework.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 网络托管就像租用一台计算机并在其上部署一个网络服务器，但它附带了一些额外的功能。如果你想部署一个网站或其他网络服务器，云服务可以帮助你这样做，而不必过多担心单个计算机和机器配置。它们通常提供平台，在这些平台上，如果你符合它们的要求和标准，你的网络服务器将运行并随着使用量扩展，而不会遇到太多麻烦。例如，亚马逊网络服务提供了使用Python的Django框架以及Node.js框架部署网络服务器的平台。
- en: 9.3.2\. Benefits of cloud services
  id: totrans-837
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 云服务的好处
- en: There are two major benefits of using cloud services, as compared to using your
    own resources, particularly if you’d have to purchase the local resources. First,
    cloud resources require zero commitment. You can pay only for the amount that
    you use them, which can save tons of money if you’re not sure yet how much capacity
    you’ll need. Second, cloud services have a far greater capacity than anything
    you might buy yourself, unless you’re a Fortune 500 corporation. If you’re not
    yet sure about the size of your project, cloud services can give you extreme flexibility
    in the amount of storage and computer power, among other things, that you can
    access at a moment’s notice.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用自己的资源相比，使用云服务有两个主要好处，尤其是如果你需要购买本地资源。首先，云资源不需要任何承诺。你只需为使用的量付费，如果你还不确定你需要多少容量，这可以节省大量资金。其次，云服务的容量远远大于你可能会购买的东西，除非你是财富500强公司。如果你还不确定项目的规模，云服务可以在存储和计算能力等方面为你提供极大的灵活性，你可以在任何时候立即访问。
- en: 9.3.3\. How to use cloud services
  id: totrans-839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3. 如何使用云服务
- en: With an incredible variety of cloud services, you have almost unlimited combinations
    of ways you might use them together. The first step is always to create an account
    with the provider and then to try out the basic level of the service, which is
    usually offered for free. If you find it useful, then scaling up is a matter of
    using it more and paying the bill. Note that it’s often worth comparing similar
    services before diving in.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云服务的种类繁多，你可以几乎无限地组合使用它们的方式。第一步始终是创建一个服务提供商的账户，然后尝试使用服务的基本级别，这通常免费提供。如果你觉得它有用，那么扩大规模就是更多地使用它并支付账单的问题。请注意，在深入之前，通常值得比较类似的服务。
- en: 9.3.4\. When to use cloud services
  id: totrans-841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4. 何时使用云服务
- en: If you don’t own enough resources to adequately address your data science needs,
    it’s worth considering a cloud service. If you’re working with an organization
    that has its own resources, it may be cheaper to exhaust the local options before
    paying for the cloud. On the other hand, even if you have considerable resources
    locally, the cloud certainly has more; if you continually run into local resource
    limits, remember that the cloud provides virtually limitless capacity.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有足够的资源来充分满足你的数据科学需求，考虑使用云服务是值得的。如果你在与拥有自身资源的组织合作，在支付云服务费用之前耗尽本地选项可能更便宜。另一方面，即使你在本地拥有相当多的资源，云服务肯定有更多；如果你不断遇到本地资源限制，请记住云服务提供了几乎无限的容量。
- en: 9.4\. Big data technologies
  id: totrans-843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 大数据技术
- en: If, in the analytic software industry, there was a phrase more often spoken
    than *cloud computing* in the last 10 years, it was *big data*. It’s a shame that
    the phrase and the technologies it describes were understood far less often than
    the phrase was spoken.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在过去10年中，在分析软件行业中，比*云计算*更常说的短语是*大数据*。遗憾的是，这个短语及其描述的技术被理解得远不如这个短语被说的那么频繁。
- en: I’m going to take some liberties in talking about big data because I don’t feel
    that it ever possessed anything resembling a concrete definition. Everyone in
    the software industry from developers to salespeople used the phrase to pump up
    the impression of the software they were building or peddling, and not all the
    usages agreed with each other. I’m going to describe here not what I think every
    single person means when they use the phrase *big data* but what I mean when I
    say it. I think my own meaning is important because I tried to distill the concept
    down to the core ideas and technologies that were somewhat revolutionary when
    they came to market in the mid-2000s.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论大数据时，我将采取一些自由度，因为我感觉它从未拥有过任何类似的具体定义。软件行业的每个人，从开发人员到销售人员，都使用这个短语来夸大他们正在构建或推销的软件的印象，而且并不是所有的用法都相互一致。在这里，我将描述的不是我认为每个人在说*大数据*时都意味着什么，而是我说这个词时我意味着什么。我认为我的个人意义很重要，因为我试图将这个概念提炼到核心思想和技术上，这些思想和技术在2005年中期上市时具有一定的革命性。
- en: I don’t use *big data* to mean “lots of data.” Such a usage is doomed to become
    obsolete, and quickly, as we argue about what *lots* means. In my personal experience,
    10 years ago 100 gigabytes was a lot of data; now 100 terabytes is routine. The
    point is that the word *big* will always be relative, and so any definition I
    concoct for *big data* must likewise be relative.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 我不使用*大数据*来表示“大量数据”。这种用法注定会变得过时，而且会很快，因为我们争论“大量”意味着什么。根据我的个人经验，10年前100吉字节是大量数据；现在100太字节是常规的。重点是，单词*大*总是相对的，因此我为*大数据*制定的任何定义也必须是相对的。
- en: 'Therefore, my own personal definition of *big data* is based on technologies,
    not necessarily the size of data sets: *big data* is a set of software tools and
    techniques that was designed to address cases in which data transfer was the limiting
    factor in computational tasks. Whenever the data set is too big to move, in some
    sense, and special software is used to avoid the necessity of such data movement,
    the phrase *big data* is applicable.'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我对自己个人对*大数据*的定义是基于技术，而不是数据集的大小：*大数据*是一套软件工具和技术，旨在解决数据传输是计算任务限制因素的情况。每当数据集太大而无法移动时，在某种程度上，并使用特殊软件来避免这种数据移动的必要性，就可以适用*大数据*这个术语。
- en: 'Perhaps an example can illustrate the concept best. Google, arguably one of
    the first forces behind big data technologies, processes a tremendous amount of
    data on a regular basis in order to support its main business: a search engine
    that’s supposed to find anything on the internet, which is obviously a vast place,
    and systems that place advertisements intelligently onto web pages. Maintaining
    the best search results involves analyzing the number and strength of links from
    all pages on the internet to all other pages. I don’t know how big this data is
    right now, but I know it’s not small. Certainly, the data is spread across many
    servers, probably in many different geographic locations. Analyzing all the data
    in order to generate a basis for internet-wide search results is a task of complex
    coordination among all the data servers and data centers, involving a huge amount
    of data transfer.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个例子可以最好地说明这个概念。谷歌可以说是大数据技术背后的第一批力量之一，它定期处理大量的数据，以支持其主营业务：一个旨在找到互联网上任何东西的搜索引擎，这显然是一个广阔的地方，以及将广告智能地放置在网页上的系统。保持最佳搜索结果需要分析来自互联网上所有页面到所有其他页面的链接数量和强度。我不知道现在这个数据有多大，但我知道它不是小数据。当然，数据分布在许多服务器上，可能位于许多不同的地理位置。为了生成互联网搜索结果的基础，分析所有这些数据是一项涉及所有数据服务器和数据中心的复杂协调任务，涉及大量的数据传输。
- en: Google, being smart, realized that data transfer was a major issue that was
    slowing down its calculations considerably. It figured minimizing such transfer
    was probably a good idea. How to minimize it, however, was a different question.
    The following explanation of what Google did, and most of the preceding description
    as well, is what I’ve inferred from Google’s release, years ago, of information
    regarding its MapReduce technology and other technologies it inspired, such as
    Hadoop. I don’t know what happened at Google, and I can’t claim to have read all
    papers and articles that have been published on the topic, but I do think the
    following hypothetical explanation is enlightening for anyone wondering how big
    data technologies work. It definitely would have been enlightening to me a few
    years ago.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: Google，作为一个聪明的公司，意识到数据传输是一个严重的问题，它极大地减缓了其计算速度。它认为最小化这种传输可能是个好主意。然而，如何最小化它却是一个不同的问题。以下关于谷歌所做之事以及之前描述的大多数内容，是我从多年前谷歌发布的关于其MapReduce技术和它所启发的其他技术（如Hadoop）的信息中推断出来的。我不知道谷歌发生了什么，也无法声称我已经阅读了所有关于这个主题发表的论文和文章，但我确实认为以下假设性的解释对于任何想知道大数据技术是如何工作的人来说都是启发性的。对于几年前的我来说，这肯定是有启发性的。
- en: In retrospect, what I would have done, had I worked at Google when it realized
    data transfer was killing analytic efficiency, was design a three-stage algorithm
    with the goal of minimizing data transfer while still performing all the calculations
    I wanted to perform.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾起来，如果我在谷歌意识到数据传输正在扼杀分析效率的时候在那里工作，我会设计一个三阶段算法，目标是尽量减少数据传输，同时仍然执行我想执行的所有计算。
- en: The first step in the algorithm was to perform an initial calculation on each
    of the data points on the servers local to each of the databases. This local calculation
    resulted in, among other things, an attribute that indicated to which group of
    data points this particular data point belonged. In online search terms, this
    attribute corresponded to the corner of the internet in which this data point,
    probably a web page, would be found. Web pages tend to link to other pages within
    the same corner and not as much to pages in other corners of the internet. For
    each data point, once attributes specifying the corner(s) of the internet were
    determined, Google’s algorithm proceeded to the second step. Within the MapReduce
    framework, this is the *map* step.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一步是在每个数据库本地服务器上的每个数据点上执行初步计算。这种本地计算产生了许多结果，其中包括一个属性，该属性指示这个特定的数据点属于哪个数据点组。在在线搜索术语中，这个属性对应于这个数据点（可能是一个网页）可能被找到的互联网角落。网页往往链接到同一角落内的其他页面，而不是互联网其他角落的页面。对于每个数据点，一旦确定了指定互联网角落的属性，谷歌的算法就会进入第二步。在MapReduce框架中，这是*映射*步骤。
- en: Step two surveyed the new attributes for the data points and minimized the transfer
    of data from one geographical place to another. If most of Corner X’s data was
    on Server Y, step two would send all Corner X data to Server Y, so only a fraction
    of Corner X data would need to be transferred at all; most of the data was already
    there. This step is colloquially referred to as the *shuffle* step and, if done
    cleverly, provides one of the major advantages of using the most popular big data
    technologies.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步调查了数据点的新的属性，并最小化了从一个地理位置到另一个地理位置的数据传输。如果Corner X的大部分数据都在Server Y上，第二步将发送所有Corner
    X数据到Server Y，因此只需要传输Corner X数据的一小部分；大部分数据已经在那里。这一步骤通常被称为*洗牌*步骤，如果做得巧妙，将提供使用最流行的大数据技术的最大优势之一。
- en: Step three, then, is to take all the data points with a common attribute and
    analyze them all at once, generating some common results and/or some individual
    results that take into account the other data with the same attribute. This step
    analyzes all the web pages in Corner X and gives results not only about Corner
    X but also about all the pages in Corner X and how they relate to each other.
    This is called the *reduce* step.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个步骤，然后，就是将具有共同属性的所有数据点一次性分析，生成一些共同的结果和/或考虑其他具有相同属性的数据的个别结果。这一步骤分析了Corner X中的所有网页，不仅给出了关于Corner
    X的结果，还给出了Corner X中所有页面及其相互关系的结果。这被称为*减少*步骤。
- en: 'The general summary of the three steps is this: some calculations are done
    locally on each data point, and data is mapped to an attribute; for each attribute,
    all data points are collected, while data transfer/shuffling is minimized; finally,
    all data points for each attribute are reduced to a set of useful results. Conceptually,
    the MapReduce paradigm, which is the basis for many other big data technologies,
    but certainly doesn’t include all of them.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 三步的一般总结是这样的：在每个数据点上本地执行一些计算，并将数据映射到属性上；对于每个属性，收集所有数据点，同时尽量减少数据传输/洗牌；最后，将每个属性的所有数据点减少到一组有用的结果。从概念上讲，MapReduce范式是许多其他大数据技术的基础，但当然并不包括所有这些技术。
- en: 9.4.1\. Types of big data technologies
  id: totrans-855
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 大数据技术类型
- en: Hadoop is an open-source implementation of the MapReduce paradigm. It has been
    very popular but seems to have lost steam in the last couple of years. Hadoop
    was originally a tool for batch processing, and since its maturity other big data
    software tools that claim to be real time have begun to supplant it. They all
    have in common the notion that too much data transfer is detrimental to the process,
    so data local computation should be favored whenever possible.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: Hadoop是MapReduce范式的开源实现。它曾经非常流行，但似乎在最近几年失去了势头。Hadoop最初是一个批处理工具，自从成熟以来，其他声称是实时的大数据软件工具已经开始取代它。它们都有一个共同的观点，即过多的数据传输对过程有害，因此应尽可能优先考虑本地数据计算。
- en: Some big data concepts have led to the development of databases that make explicit
    use of the MapReduce paradigm and its implementations like Hadoop. The Apache
    Software Foundation’s open-source projects HBase and Hive, among others, rely
    explicitly on Hadoop to power databases that are designed to function well at
    extremely large scales, whatever that means to you in whatever year you’re reading
    this.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一些大数据概念导致了数据库的发展，这些数据库明确使用了MapReduce范式及其实现，如Hadoop。Apache软件基金会的开源项目HBase和Hive等，明确依赖于Hadoop来驱动设计用于在极大规模上良好运行的数据库，无论这对你在阅读此内容的任何一年意味着什么。
- en: 9.4.2\. Benefits of big data technologies
  id: totrans-858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 大数据技术的益处
- en: Big data technologies are designed not to move data around much. This saves
    time and money when the data sets are on the very large scales for which the technologies
    were designed.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 大数据技术的设计目的是尽量减少数据移动。当数据集规模非常大时，这可以节省时间和金钱。
- en: 9.4.3\. How to use big data technologies
  id: totrans-860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3\. 如何使用大数据技术
- en: This varies greatly depending on the technology. But they generally mimic the
    non–big data versions, at least at small scales. You can get started with a big
    data database much as you would a standard database, but perhaps with a bit more
    configuration.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于技术。但它们通常模仿非大数据版本，至少在小规模上是这样。你可以像使用标准数据库一样开始使用大数据数据库，但可能需要更多的配置。
- en: Other technologies, including Hadoop in particular, require a little more effort.
    Hadoop and other implementations of MapReduce require specifications for mappers
    in step one and reducers in step two. Experienced software developers won’t have
    a problem coding basic versions of these, but some tricky peculiarities in implementation
    and configuration might cause problems, so take some care.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 其他技术，特别是包括Hadoop在内，需要付出更多的努力。Hadoop和其他MapReduce的实现需要在第一步指定mapper，在第二步指定reducer。经验丰富的软件开发者不会在编写这些基本版本时遇到问题，但实现和配置中的一些棘手特性可能会引起问题，所以需要小心。
- en: 9.4.4\. When to use big data technologies
  id: totrans-863
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.4\. 何时使用大数据技术
- en: Whenever computational tasks are data-transfer bound, big data can give you
    a boost in efficiency. But more so than the other technologies described in this
    chapter, big data software takes some effort to get running with your software.
    You should make the leap only if you have the time and resources to fiddle with
    the software and its configurations and if you’re nearly certain that you’ll reap
    considerable benefits from it.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算任务受数据传输限制时，大数据可以提高你的效率。但比本章中描述的其他技术，大数据软件在运行时需要更多的努力。只有当你有时间和资源去调整软件及其配置，并且你几乎可以确定你会从中获得相当大的好处时，你才应该采取这一步。
- en: 9.5\. Anything as a service
  id: totrans-865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 任何作为服务的
- en: This obviously isn’t a real thing, but I often feel that it is. It’s sometimes
    hard to read software descriptions without coming across the phrase *software
    as a service* (SaaS), *platform as a service* (PaaS), *infrastructure as a service*
    (IaaS), or any other *something* as a service. Though I make fun of it, it’s very
    much a boon to the software industry that so many things are offered as a service.
    The purpose of services for hire is to replace the things that we would do ourselves,
    and it’s our hope that the service provided is better or more efficient than what
    we would have done ourselves.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是一件真实的事情，但我经常觉得它是。有时候很难阅读软件描述而不遇到“软件即服务”（SaaS）、“平台即服务”（PaaS）、“基础设施即服务”（IaaS）或其他任何“某物即服务”的短语。虽然我对此进行嘲笑，但许多事物以服务的形式提供对软件行业来说是非常有益的。雇佣服务的目的是替代我们自己会做的事情，我们希望提供的服务比我们自己做的更好或更有效率。
- en: I’m a big fan of letting other people do any standard task that I don’t want
    to do myself, in real life as well as in software. An increasing number of such
    tasks are available as a service in today’s internet-connected economy, and I
    see no reason to expect that trend to slow down any time soon. Though I won’t
    discuss any specific technologies in this section, I emphasize that you may be
    able to simplify greatly your software development and maintenance tasks by hiring
    out some of its more common aspects. From hardware maintenance to data management,
    application deployment, software interoperability, and even machine learning,
    it’s possible to let someone else handle some of the less-concerning aspects of
    whatever you’re building. The caveat is that you should trust those you hire to
    do a good job, and that trust may take some effort to build. A simple online search
    can provide some worthwhile candidates for offloading some of your work.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢让别人做我不愿意亲自做的任何标准任务，无论是在现实生活中还是在软件中。在当今的互联网经济中，越来越多的这类任务可以作为服务提供，我看不出有任何理由预期这种趋势会很快放缓。虽然我不会在本节讨论任何具体的技术，但我强调，通过外包一些更常见的方面，你可能会极大地简化你的软件开发和维护任务。需要注意的是，你应该信任你雇佣的人能够做好工作，而建立这种信任可能需要一些努力。简单的在线搜索可以提供一些值得考虑的候选人，以分担你的一些工作。
- en: Exercises
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Continuing with the Filthy Money Forecasting personal finance app scenario
    first described in [chapter 2](kindle_split_011_split_000.xhtml#ch02), and relating
    to previous chapters’ exercises, try these:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用在第二章中首先描述的“脏钱预测”个人理财应用场景，并关联到前几章的练习，尝试以下内容：
- en: '**1\.**'
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1\.**'
- en: ''
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are three supplementary (not strictly statistical) software products that
    might be used during this project, and why?
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个项目中，可能会使用哪些三个补充的（不是严格意义上的统计）软件产品，以及为什么？
- en: '**2\.**'
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2\.**'
- en: ''
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose that FMI’s internal relational database is hosted on a single server,
    which is backed up every night to a server at an offsite location. Give a reason
    why this could be a good architecture and one reason why it might be bad.
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设FMI的内部关系数据库托管在单个服务器上，每晚都会备份到异地的一个服务器。给出这可能是良好架构的一个原因以及它可能不好的一个原因。
- en: Summary
  id: totrans-876
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Some technologies don’t fall under the category of statistical software, but
    they’re useful in making statistical software faster, scalable, and more efficient.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些技术不属于统计软件类别，但它们在使统计软件更快、可扩展和更高效方面很有用。
- en: Well-configured databases, high-performance computing, cloud services, and big
    data technologies, all have their place in the industry of analytical software,
    and each has its own advantages and disadvantages.
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置良好的数据库、高性能计算、云服务和大数据技术，在分析软件行业中都有其位置，并且每种技术都有其优势和劣势。
- en: 'When deciding whether to begin using any of these auxiliary technologies, it’s
    usually best to ask the question: are there any gross inefficiencies or limitations
    in my current software technologies?'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在决定是否开始使用这些辅助技术中的任何一种时，通常最好问自己：我的当前软件技术中是否存在明显的低效或限制？
- en: It takes time and effort to migrate to a new technology, but it can be worth
    it if you have a compelling reason.
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到新技术需要时间和努力，但如果你有充分的理由，这可能值得。
- en: There’s been a lot of hype surrounding cloud services and big data technologies;
    they can be extremely useful but not in every project.
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务和大数据技术围绕了很多炒作；它们可以非常有用，但并非每个项目都需要。
- en: 'Chapter 10\. Plan execution: putting it all together'
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 计划执行：整合一切
- en: '*This chapter covers*'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Tips for putting your statistics ([chapter 7](kindle_split_017_split_000.xhtml#ch07))
    and software ([chapters 8](kindle_split_018_split_000.xhtml#ch08)–[9](kindle_split_019_split_000.xhtml#ch09))
    into action
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的统计（[第7章](kindle_split_017_split_000.xhtml#ch07)）和软件（[第8章](kindle_split_018_split_000.xhtml#ch08)–[第9章](kindle_split_019_split_000.xhtml#ch09)）付诸实践的技巧
- en: When to modify the plan (formulated as in [chapter 6](kindle_split_016_split_000.xhtml#ch06))
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时修改计划（如第6章中所述）
- en: Understanding the significance of results and how it relates to practical usefulness
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解结果的重要性及其与实际用途的关系
- en: '[Figure 10.1](kindle_split_020_split_000.xhtml#ch10fig01) shows where we are
    in the data science process: executing the build plan for the product. In the
    last three chapters, I covered statistics, statistical software, and some supplemental
    software. Those chapters provide a survey of technical options available to data
    scientists in the course of their projects, but they don’t continue along the
    data science process from the previous chapters. Because of this, in this chapter
    I bring you back to that process by illustrating how you can go from the formulation
    of a plan ([chapter 6](kindle_split_016_split_000.xhtml#ch06)) to applying statistics
    ([chapter 7](kindle_split_017_split_000.xhtml#ch07)) and software ([chapters 8](kindle_split_018_split_000.xhtml#ch08)
    and [9](kindle_split_019_split_000.xhtml#ch09)) in order to achieve good results.
    I point out some helpful strategies as well as some potential pitfalls, and I
    discuss what it might mean to have good results. Finally, I give a thorough case
    study from a project early in my career, with a focus on applying ideas from the
    current chapter as well as the previous few.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](kindle_split_020_split_000.xhtml#ch10fig01) 展示了我们在数据科学流程中的位置：执行产品的构建计划。在前三章中，我介绍了统计学、统计软件和一些补充软件。这些章节提供了数据科学家在其项目过程中可用的技术选项的概述，但它们并没有从上一章继续沿着数据科学流程。正因为如此，在这一章中，我通过说明如何从计划的制定（[第6章](kindle_split_016_split_000.xhtml#ch06)）到应用统计学（[第7章](kindle_split_017_split_000.xhtml#ch07)）和软件（[第8章](kindle_split_018_split_000.xhtml#ch08)和[第9章](kindle_split_019_split_000.xhtml#ch09)）以实现良好结果的过程，将你带回到那个流程中。我还指出了一些有用的策略和一些潜在的陷阱，并讨论了良好结果可能意味着什么。最后，我给出了一份关于我职业生涯早期一个项目的详细案例研究，重点关注应用本章以及前几章中的想法。'
- en: 'Figure 10.1\. The final step of the build phase of the data science process:
    executing the plan efficiently and carefully'
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1. 数据科学流程构建阶段的最后一步：高效且细致地执行计划
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1的替代文本](Images/10fig01_alt.jpg)'
- en: 10.1\. Tips for executing the plan
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 执行计划的技巧
- en: In [chapters 8](kindle_split_018_split_000.xhtml#ch08) and [9](kindle_split_019_split_000.xhtml#ch09),
    I discussed various software related to statistical applications, when and where
    different types might be best used, and how to think about ways that the software
    relates to the statistics that you intend to do. But the process of building that
    software is another story. Even if you know exactly what you want to build and
    how you want the result to look, the act of creating it can be fraught with obstacles
    and setbacks, particularly the more complicated the tool that you’re trying to
    build.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_018_split_000.xhtml#ch08)和[第9章](kindle_split_019_split_000.xhtml#ch09)中，我讨论了与统计应用相关的各种软件，何时何地使用不同类型的软件最合适，以及如何思考软件与你要进行的统计之间的关联。但构建该软件的过程又是另一回事。即使你确切知道你想要构建什么以及你想要的结果是什么，创建它的过程可能会充满障碍和挫折，尤其是当你试图构建的工具越复杂时。
- en: Most software engineers are probably familiar with the trials and tribulations
    of building a complicated piece of software, but they may not be familiar with
    the difficulty of building software that deals with data of dubious quality. Statisticians,
    on the other hand, know what it’s like to have dirty data but may have little
    experience with building higher-quality software. Likewise, individuals in different
    roles relating to the project, each of whom might possess various experiences
    and training, will expect and prepare for different things. As part of the project
    awareness that I’ve emphasized throughout this book, I’ll consider briefly the
    types of experiences and difficulties that different people might have and a few
    ways that problems can be prevented. I don’t presume to know what others are thinking,
    but in my experience people with similar backgrounds tend to make similar mistakes,
    and I’ll describe those here with the hope that they’re helpful to you.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件工程师可能都熟悉构建复杂软件的艰辛和挑战，但他们可能不熟悉构建处理质量可疑数据的软件的困难。另一方面，统计学家知道脏数据是什么样的，但在构建更高品质的软件方面可能经验不足。同样，与项目相关的不同角色的人，每个人可能都有各种经验和培训，他们会期待并准备不同的事情。作为我在本书中强调的项目意识的一部分，我将简要考虑不同人可能遇到的经验和困难，以及一些可以预防问题的方法。我不敢断定其他人都在想什么，但根据我的经验，背景相似的人往往会犯类似的错误，我将在这里描述这些错误，希望对你们有所帮助。
- en: 10.1.1\. If you’re a statistician
  id: totrans-893
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 如果你是一名统计学家
- en: If you’re a statistician, you know dirty data, and you know about bias and overstating
    the significance of results. These things are familiar to you, so you innately
    watch out for them. On the other hand, you may not have much experience building
    software for business, particularly *production* software—by which I mean software
    that’s used directly by a customer to gain insight into their data. Many things
    can go wrong with production software.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名统计学家，你就知道脏数据，也知道关于偏差和过度强调结果显著性的问题。这些对你来说都很熟悉，所以你天生就会警惕它们。另一方面，你可能没有太多为商业软件构建软件的经验，尤其是*生产*软件——我的意思是直接由客户使用来深入了解其数据的软件。生产软件可能会出现很多问题。
- en: Consult a software engineer
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 咨询一名软件工程师
- en: Statisticians are smart people; they can learn and apply a lot of knowledge
    in a short time. To every smart person, it can be tempting to learn a new technology
    as you need it and to trust your own ability to use it properly. This is great
    if you’re creating something that you’ll use yourself or that’s primarily a prototype.
    But in cases where bugs and mistakes will have a significant negative impact for
    your project and your team, it’s best to at least consult a software engineer
    before, during, and after building an analytic software tool. If nothing else,
    the software engineer will give you a thumbs-up and tell you your design or your
    software is great. More likely—if the engineer is paying attention—they’ll be
    able to point out a few areas where you can improve in order to make your software
    tool more robust and less likely to fail for unknown reasons. If you’re not a
    software engineer, building a piece of production software yourself is like building
    a deck for your house when you have no training in carpentry or construction.
    You can learn most of what you need to know from books and other references, in
    theory, but putting the wood and the nails and the joints together can get a little
    messy. It can be very helpful to ask someone who has some hands-on experience,
    to make sure.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学家是聪明人；他们可以在短时间内学习和应用大量知识。对于每一个聪明人来说，在学习新技术时按需学习并相信自己的能力能够正确使用它是很有吸引力的。如果你正在创建自己会使用或主要是原型的东西，这很好。但在错误和错误会对你的项目和团队产生重大负面影响的情况下，最好至少在构建分析软件工具之前、期间和之后咨询软件工程师。如果没有其他的话，软件工程师会给你点赞，并告诉你你的设计或软件很棒。更有可能的是——如果工程师在关注的话——他们能够指出一些你可以改进的地方，以使你的软件工具更加健壮，并减少因未知原因而失败的可能性。如果你不是软件工程师，自己构建一个生产软件就像你在没有木工或建筑培训的情况下为你的房子建造露台一样。理论上，你可以从书籍和其他参考资料中学习你需要知道的大部分知识，但将木材、钉子和接缝组合在一起可能会有些混乱。向有实际经验的人求助可能会有很大帮助。
- en: Have someone test your software thoroughly
  id: totrans-897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 让某人彻底测试你的软件
- en: If you plan on handing software to a customer and letting them use it directly,
    you can bet they’ll find a dozen ways to break it. It’s difficult to eliminate
    all bugs and handle all possible edge-case outcomes in a nice way, but you can
    find the most obvious bugs and problems if you give the software to a co-worker—ideally
    one who has a background similar to the customer’s—and tell them to use all aspects
    of the tool and to try to break it. Better still, give the software to several
    people and have them all use it and try to break it. This is often called a *bug
    bash*, but it can extend beyond bugs into the realm of user experience as well
    as the general usefulness of the tool. Feedback here should not be taken lightly,
    because if your co-workers can find a bug in a few hours, I can almost guarantee
    that the customers will find it twice as fast, and that can cost you time, money,
    and reputation.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将软件交给客户并让他们直接使用，你可以肯定他们会找到 dozen 种方法来破坏它。完全消除所有错误并优雅地处理所有可能的边缘情况是很困难的，但如果你将软件交给同事——理想情况下是背景与客户相似的人——并告诉他们使用工具的所有方面，尝试破坏它，那么你可以找到最明显的错误和问题。更好的做法是将软件分发给几个人，让他们都使用并尝试破坏它。这通常被称为*虫子大战*，但它可以扩展到用户体验领域以及工具的通用实用性。这里的反馈不应被轻视，因为如果你的同事几个小时就能找到错误，我几乎可以保证客户会更快地找到它，这可能会让你损失时间、金钱和声誉。
- en: Customers take a lot of time
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 客户需要花费很多时间
- en: If you’ve never delivered software to a customer before, it may come as a surprise
    that an astonishingly large number of customers won’t use your software without
    significant prompting—and customers who *do* use your software will bombard you
    with questions, problems, and insinuations that you did everything wrong.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未向客户交付过软件，可能会惊讶地发现，大量客户在没有显著提示的情况下不会使用你的软件——而那些*确实*使用你的软件的客户会向你提出大量问题、问题和暗示，认为你做错了所有事情。
- en: Presuming that you want people to use your software, it can be worth spending
    time with customers to make sure that they’re comfortable with using the software
    and that they’re using it correctly. This means you may need to send some emails,
    make phone calls, or show up in person, depending on your situation. Projects
    in data science often depend on successfully using this new piece of software,
    and in the common case where the customer may not fully understand what the future
    impact is of your new data-centric solution, you may have to guide them down the
    right path.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望人们使用你的软件，花时间与客户交流，确保他们使用软件感到舒适，并且使用正确，这可能值得。这意味着你可能需要发送一些电子邮件，打电话，或者根据你的情况亲自出现。数据科学项目通常依赖于成功使用这一新软件，在常见的情况下，客户可能不完全理解你新的以数据为中心的解决方案对未来影响，你可能需要引导他们走上正确的道路。
- en: Customers bombarding you is a good sign. It means they’re already engaged and
    they really want the software to work. The downside is that either there are many
    problems with it or they don’t know how to use it properly. Both of these can
    presumably be fixed by you or others on your team. Be aware ahead of time that
    customers can require maintenance at least as much as the software.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 客户不断向你施压是一个好兆头。这意味着他们已经参与其中，并且非常希望软件能够正常工作。但不利的一面是，要么软件存在很多问题，要么他们不知道如何正确使用它。这两者都可以假设通过你或你团队的其他人得到解决。提前意识到客户可能需要的维护至少和软件本身一样多。
- en: 10.1.2\. If you’re a software engineer
  id: totrans-903
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 如果你是一名软件工程师
- en: If you’re a software engineer, you know what a development lifecycle looks like,
    and you know how to test software before deployment and delivery. But you may
    not know about data and all the ways it can break your beautiful piece of programmed
    machinery. As I’ve mentioned before, uncertainty is the absolute enemy of the
    software engineer, yet uncertainty is inevitable in data science. No matter how
    good you are at software design and development, data will eventually break your
    application in ways that had never occurred to you. This requires new patterns
    of thought when building software and a new level of tolerance for errors and
    bugs because they’ll happen that much more often.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名软件工程师，你知道软件开发的生命周期是什么样的，也知道如何在部署和交付之前测试软件。但你可能不知道数据以及它如何破坏你精心设计的编程机器。正如我之前提到的，不确定性是软件工程师的绝对敌人，但在数据科学中，不确定性是不可避免的。无论你在软件设计和开发方面多么出色，数据最终都会以你从未想到的方式破坏你的应用程序。这要求在构建软件时采用新的思维模式，并提高对错误和缺陷的容忍度，因为它们会频繁发生。
- en: Consult a statistician
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 咨询统计学家
- en: Software engineers are smart people; they can follow the flow of logic and information
    through complex structures. Data and statistics, though, introduce a level of
    uncertainty that logic and rigid structure don’t handle well innately. Statisticians
    are well versed in foreseeing and handling problematic data such as outliers,
    missing values, and corrupted values. It can be helpful to have a conversation
    with a statistician, focusing on the sources of your data and what you intend
    to do with it. A statistician might be able to provide some insight into the types
    of problems and edge cases that may occur once you get your software up and running.
    Without consulting a statistician or a statistics-oriented data scientist, you
    run the risk of having overlooked a potentially significant special case that
    can break your software or otherwise cause problems for it.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师是聪明的人；他们可以跟随逻辑和信息在复杂结构中的流动。然而，数据和统计学引入了一种不确定性，这是逻辑和刚性结构天生处理不好的。统计学家在预见和处理问题数据方面经验丰富，如异常值、缺失值和损坏值。与统计学家进行一次对话可能会有所帮助，关注数据的来源以及你打算如何使用它。统计学家可能能够提供一些见解，了解一旦你的软件上线可能会出现的各种问题和边缘情况。如果没有咨询统计学家或以统计为导向的数据科学家，你可能会忽视一个可能非常重要的特殊情况，这可能会破坏你的软件或给它带来其他问题。
- en: Data can break your software
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据可以破坏你的软件
- en: Software engineers are good at connecting disparate systems and making them
    work together. A critical part of getting two software systems to work together
    is the agreement, or contract, between the two systems that states how they communicate
    with one another. If one of those systems is a statistical system, the output
    or state often can’t be guaranteed to meet a specific set of contractual guidelines.
    Special and edge cases of data values can make statistical systems do weird things,
    and when software components are asked to do weird things, they often break. When
    dealing with data and statistics, it’s best to forgive them in advance. Consider
    the broadest possible set of outcomes or states, and plan for that. If you’re
    feeling particularly magnanimous, you may want to enclose statistical statements
    in try-catch blocks (or similar) such that nothing breaks in the strict sense,
    and then weird or unacceptable outcomes can be handled, logged, reported, or raised
    as an exception, whatever seems appropriate.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师擅长连接不同的系统并使它们协同工作。使两个软件系统协同工作的关键部分是两个系统之间的协议或合同，它规定了它们如何相互通信。如果其中一个系统是统计系统，其输出或状态通常无法保证符合特定的合同指南。特殊和边缘的数据值可能会使统计系统做出奇怪的行为，当软件组件被要求做出奇怪的行为时，它们通常会崩溃。在处理数据和统计时，最好提前原谅它们。考虑最广泛的可能结果或状态集，并为此做好准备。如果你特别慷慨，你可能希望将统计声明放在try-catch块（或类似结构）中，这样在严格意义上就不会有任何东西崩溃，并且可以处理、记录、报告或引发异常，无论什么看起来都合适。
- en: Check the final results
  id: totrans-909
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查最终结果
- en: This may seem obvious to most of you, but in a shortage of time it’s incredible
    how often this step gets skipped. I suggest to statisticians that they ask some
    people to try to break their software, and I strongly suggest to software engineers
    that they run through a few full examples of whatever data they’re analyzing and
    make sure the results are 100% correct. (Really, everyone should do this, but
    I hope that statisticians are trained well enough to do this by default.) It can
    be a tedious process to begin with a small amount of raw data and trace it all
    the way through to an outcome, but without doing an end-to-end correctness test,
    there’s no way to guarantee that your software is doing what it’s supposed to
    do. Even performing a few such tests doesn’t guarantee perfect software, but at
    least you know that you’re getting *some* correct answers. If you want to take
    your testing to the next level, translate your end-to-end tests into formal integration
    tests so that if you make changes to your software in the future, you’ll know
    immediately if you’ve made a mistake, because the integration test will fail.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你们大多数人来说，这可能是显而易见的，但在时间紧迫的情况下，这一步骤被跳过的频率令人难以置信。我建议统计学家让一些人尝试破坏他们的软件，并且我强烈建议软件工程师运行他们正在分析的数据的几个完整示例，并确保结果是100%正确的。（真的，每个人都应该这样做，但我希望统计学家已经足够训练有素，能够默认这样做。）从少量原始数据开始，一直追踪到结果，可能是一个繁琐的过程，但如果不进行端到端正确性测试，就无法保证你的软件正在做它应该做的事情。即使进行一些这样的测试也不能保证软件完美，但至少你知道你得到了*一些*正确的答案。如果你想将测试提升到下一个水平，将你的端到端测试转换为正式的集成测试，这样如果你将来对软件进行更改，你将立即知道你是否犯了一个错误，因为集成测试将失败。
- en: 10.1.3\. If you’re a beginner
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 如果你是一个初学者
- en: If you’re starting out in data science, without much experience in statistics
    or software engineering, first of all, good for you! It’s a big step into a broad
    field, and you need a good amount of courage to take it. Second, be careful. You
    can make many mistakes if you go in without the awareness I’ve emphasized throughout
    this book. The good news is that there are many people around who can help you;
    if they’re not at your company, find them elsewhere, such as at other similar
    companies, local technology organizations, or anywhere on the internet. For some
    reason, people in the software industry love to help others out. Anyone with some
    experience can probably give you some solid advice if you can explain your project
    and your goals to them. More specifically, though, it’s best to follow the advice
    I give in this chapter to both statisticians and software engineers. As a beginner,
    you have double duty at this stage of the process to make up for lack of experience.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始从事数据科学，在统计学或软件工程方面没有太多经验，首先，恭喜你！这是进入一个广阔领域的一大步，你需要有足够的勇气去迈出这一步。其次，要小心。如果你没有意识到我在这本书中强调的意识，你可能会犯很多错误。好消息是，周围有很多可以帮助你的人；如果他们不在你的公司，你可以在其他类似的公司、当地的技术组织或互联网上的任何地方找到他们。出于某种原因，软件行业的人喜欢帮助他人。如果你能向他们解释你的项目和目标，任何有经验的人都可以给你一些切实的建议。不过，更具体地说，最好遵循我在本章为统计学家和软件工程师提供的建议。作为一个初学者，在这个过程的这个阶段，你需要承担双重责任来弥补经验的不足。
- en: 10.1.4\. If you’re a member of a team
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4. 如果你是一个团队成员
- en: If you’re merely one member of a team for the purposes of this project, communication
    and coordination are paramount. It isn’t necessary that you know everything that’s
    going on within the team, but it *is* necessary that goals and expectations are
    clear and that someone is managing the team as a whole.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是这个项目的一个团队成员，那么沟通和协调至关重要。你不需要了解团队内部的所有情况，但目标和期望必须明确，并且必须有人负责整个团队的管理。
- en: Make sure someone is managing
  id: totrans-915
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确保有人负责管理
- en: I’ve seen some odd cases in which a team had no manager or leader. On exceptional
    teams, this can work. Sometimes everyone understands the problem, handles their
    part, and gets the job done. This is rare. But even in these rare cases, it’s
    usually inefficient if everyone on the team is keeping track of everything everyone
    else is doing. It’s usually better if one person is keeping track of all of the
    things that are happening, and this person can answer any questions about the
    status of the project that may come from anyone on the team or someone outside
    the team—for instance, a customer. It’s not necessary, but it’s usually advisable
    to have a team member designated as the one who keeps track of all things related
    to project status. This role may be as simple as taking notes, or it may be as
    complex as an official manager who holds formal meetings and sets deadlines. As
    a member of the team, you should know who this person is and the extent of their
    management role. If some aspect of management is lacking, you may want to bring
    it up with your own boss or another person of authority.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过一些奇怪的情况，其中团队没有经理或领导者。在特例团队中，这可能行得通。有时每个人都理解问题，处理自己的部分，并完成工作。这种情况很少见。但即使在这些罕见的情况下，如果团队中的每个人都跟踪每个人的工作，通常效率很低。通常最好有一个人跟踪所有发生的事情，这个人可以回答来自团队内部或外部（例如，客户）的任何关于项目状态的问题。这不是必需的，但通常建议指定一个团队成员负责跟踪与项目状态相关的所有事情。这个角色可能只是简单地做笔记，也可能是一个复杂的正式经理，他举行正式会议并设定最后期限。作为团队成员，你应该知道这个人是谁以及他们的管理职责范围。如果管理方面存在某些不足，你可能想向自己的老板或其他有权威的人提出。
- en: Make sure there’s a plan
  id: totrans-917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确保有一个计划
- en: Everyone who has held more than a couple jobs has most likely had a boss who
    didn’t do a good job. Some bosses are nice but not effective, and some are the
    opposite. In [chapter 6](kindle_split_016_split_000.xhtml#ch06), I discussed how
    to make a plan for your project; if you’re working on a team, you probably didn’t
    make the plan yourself, but you probably participated in a discussion of what
    should be done, when, and by whom. This should have resulted in some sort of plan,
    and you should know who is keeping track of this plan. If that’s not the case,
    there may be a problem. Probably the group leader or manager has a plan, and that
    person should be able to describe or outline it on demand; if this plan is nonexistent,
    incoherent, or bad, you may want to start a serious and probably difficult conversation
    with team leadership. It may not be your personal responsibility to manage the
    plan, but it benefits the whole group to make sure that someone is handling it
    in a reasonable way.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数做过几个工作的人可能都遇到过一些工作做得不好的上司。有些上司可能很好但不够有效，有些则相反。在第6章（[kindle_split_016_split_000.xhtml#ch06](kindle_split_016_split_000.xhtml#ch06)）中，我讨论了如何为你的项目制定计划；如果你在一个团队中工作，你可能没有自己制定计划，但你可能参与了关于应该做什么、什么时候做以及由谁做的讨论。这应该导致某种计划，你应该知道谁在跟踪这个计划。如果不是这样，可能存在问题。可能小组领导或经理有一个计划，这个人应该能够随时描述或概述它；如果这个计划不存在、不连贯或不好，你可能需要与团队领导进行严肃且可能困难的对话。管理计划可能不是你的个人责任，但确保有人以合理的方式处理它对整个团队都有好处。
- en: Be specific about expectations
  id: totrans-919
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 明确期望
- en: Personnel issues aside, there’s almost nothing worse when working on a team
    than having unclear direction with your own work. If you don’t know exactly what
    you’re supposed to be doing and what the expectations are for your results, it’s
    tough to do a good job. On the other hand, it’s OK to have some open-ended goals
    as long as everyone is aware of that. In any case, if your part of the project
    isn’t quite clear to you, make sure to ask someone (or everyone) in order to get
    the issue settled.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 人员问题暂且不谈，但在团队工作中，没有明确的工作方向儿乎是最糟糕的事情之一。如果你不知道自己应该做什么，以及对你结果的期望是什么，那么做好工作会很困难。另一方面，只要每个人都清楚这一点，有一些开放式目标是可以接受的。无论如何，如果你的项目部分对你来说并不清晰，确保询问某人（或所有人），以便解决问题。
- en: 10.1.5\. If you’re leading a team
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.5. 如果你在领导一个团队
- en: If, as in the previous section, you’re part of a team that’s taking on a data
    science project, all of those suggestions still apply. But if in addition to that
    you have a position of leadership, there are a few more to add.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，像上一节中提到的，你是一个承担数据科学项目的团队的一员，那么这些建议仍然适用。但如果你除了这个角色之外还有领导职位，还有一些额外的建议需要补充。
- en: Make sure you know what everyone is doing
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确保你知道每个人在做什么
- en: A team is nothing if it doesn’t know what it’s doing, cohesively. Not everyone
    needs to know everything, but at least one person should know almost everything
    that’s going on, and if you’re the team leader, that person should be you. I’m
    not suggesting that you be a micromanager, but I am suggesting that you take an
    active interest in the status of each part of the project. This active interest
    should result in an awareness of the team and project status such that you can
    answer most general questions about the project status without consulting anyone
    else. If you can’t answer questions about project timelines and whether you think
    you’ll meet certain deadlines, your interest in team activities probably isn’t
    active enough. For more specific questions, such as implementation details, it’s
    probably OK to ask the relevant team member. If you’re the team leader and manager,
    it’s part of your job to be the representative of the team in front of non–team
    members, such as customers.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个团队不知道自己在做什么，那么它就什么也不是，不能团结一致。并不是每个人都必须知道所有的事情，但至少应该有一个人几乎知道所有正在发生的事情，如果你是团队领导，那个人应该是你。我并不是建议你成为一个微观管理者，但我确实建议你对每个项目部分的状态保持积极关注。这种积极关注应该使你对团队和项目状态有足够的了解，以至于你可以在不咨询任何人的情况下回答关于项目状态的大部分一般性问题。如果你无法回答关于项目时间表和你是否认为会错过某些截止日期的问题，那么你对团队活动的兴趣可能还不够积极。对于更具体的问题，例如实施细节，询问相关团队成员可能是可以的。如果你是团队领导和经理，那么在非团队成员面前代表团队是你的工作的一部分，比如客户。
- en: Be the keeper of the plan
  id: totrans-925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 成为计划的守护者
- en: In [chapter 6](kindle_split_016_split_000.xhtml#ch06), I discussed the process
    of making a plan for your project, with different paths and alternatives for different
    intermediate outcomes. If you have a reasonably sophisticated project, you probably
    have developed a plan that takes some time to understand. It would likely be inefficient
    if everyone on the team took the time to consult and understand the plan every
    time they had to make a decision. It’s a good idea, as team leader, to take responsibility
    for the plan and field all questions related to the plan over the course of the
    project. That is not to say that the plan belongs to you and you alone; quite
    the contrary. The plan should have been developed with the input of the whole
    group, and certain aspects of the plan might still be owned by the most appropriate
    members of the group. But it might be a good idea that you, as the team leader,
    are the only one who is thoroughly familiar with the plan as a whole, as well
    as the team’s status within it. If a customer asks, “Where are you in the development
    process?” you should be able to explain the plan summary to them and then say
    where the team is within the framework of the plan.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_016_split_000.xhtml#ch06)中，我讨论了为你的项目制定计划的过程，包括针对不同中间结果的多种路径和替代方案。如果你有一个相当复杂的项目，你可能已经制定了一个需要花费一些时间才能理解的计划。如果团队中的每个人都必须做出决定时都花费时间去咨询和理解这个计划，那么这可能会效率低下。作为团队领导，负责计划并在整个项目过程中处理所有与计划相关的问题是一个好主意。这并不是说计划只属于你一个人；恰恰相反。计划应该是整个团队参与制定的，并且计划的某些方面可能仍然属于最合适的团队成员。但可能是一个好主意，即作为团队领导，你是唯一一个对整个计划以及团队在其中的地位都了如指掌的人。如果一个客户问：“你们在开发过程中处于什么位置？”你应该能够向他们解释计划摘要，然后说明团队在计划框架内的位置。
- en: Delegate wisely
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 智慧地委派任务
- en: Beyond having a plan, a team that’s taking on a data science project needs to
    work together in such a way that work is distributed relatively evenly and to
    the people who are best suited to the given tasks. Software engineers should handle
    the more programming- and architecture-oriented aspects, data scientists should
    be concerning themselves more with data and statistics, subject matter experts
    should be handling anything related directly to the project domain, and anyone
    else with a certain set of skills should be handling the tasks most relevant to
    those skills. I don’t suggest that anyone should be pigeonholed based merely on
    what they’re good at, but each team member’s expertise and limitations are relevant
    to the division of tasks. I’ve worked on teams where the few data scientists were
    treated like the many software engineers, and the results were not positive. Considering
    the people on the team against the tasks to be done should be enough.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有一个计划之外，承担数据科学项目的团队需要以一种方式合作，使得工作相对均匀地分配给最适合给定任务的人。软件工程师应该处理更多编程和架构方面的内容，数据科学家应该更多地关注数据和统计学，领域专家应该处理与项目领域直接相关的内容，而任何拥有一定技能的人应该处理与这些技能最相关的任务。我不建议任何人仅仅基于他们擅长什么就被归类，但每个团队成员的专业知识和局限性都与任务的分配相关。我在一些团队中工作过，其中少数数据科学家被当作许多软件工程师对待，结果并不理想。考虑团队成员与要完成的任务之间的关系应该足够了。
- en: 10.2\. Modifying the plan in progress
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 在进行中修改计划
- en: In [chapter 6](kindle_split_016_split_000.xhtml#ch06), I discussed formulating
    a plan for completing your data science project. The plan should contain multiple
    paths and options, all depending on the outcomes, goals, and deadlines of the
    project. No matter how good a plan is, there’s always a chance that it should
    be revised as the project progresses. Even if you thought of all uncertainties
    and were aware of every possible outcome, things outside the scope of the plan
    may change. The most common reason for a plan needing to change is that new information
    comes to light, from a source external to the project, and either one or more
    of the plan’s paths change or the goals themselves change. I’ll briefly discuss
    these possibilities here.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_016_split_000.xhtml#ch06)中，我讨论了制定完成数据科学项目计划的方法。该计划应包含多个路径和选项，所有这些都取决于项目的结果、目标和截止日期。不管计划有多好，在项目进展过程中，它总是有可能需要修改。即使你认为考虑到了所有不确定性并且对每个可能的后果都有所了解，计划范围之外的事情也可能发生变化。计划需要修改的最常见原因是新信息出现，这些信息来自项目外部，导致计划的一条或多条路径发生变化，或者目标本身发生变化。我将在下面简要讨论这些可能性。
- en: 10.2.1\. Sometimes the goals change
  id: totrans-931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 有时目标会发生变化
- en: When the goals of the project change, it can have large implications for the
    plan. Usually goals change because the customers have either changed their mind
    about something or they’ve communicated information that they didn’t mention before
    for one reason or another. It’s a common phenomenon—discussed in [chapter 2](kindle_split_011_split_000.xhtml#ch02)—that
    customers may not know which information is important to you, a data scientist,
    so information gathering and goal setting can seem more like elicitation than
    business. If you’ve done a good job asking the customer the right questions along
    the way, you probably aren’t far from a good, useful set of goals. But if new
    information enters the picture, changing the plan may be necessary.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目目标发生变化时，它可能会对计划产生重大影响。通常目标变化是因为客户对某些事情改变了主意，或者出于某种原因，他们传达了之前未提及的信息。这是一个常见的现象——在[第2章](kindle_split_011_split_000.xhtml#ch02)中讨论过——客户可能不知道哪些信息对你这个数据科学家来说很重要，因此信息收集和目标设定可能更像是一种启发式方法而不是商业行为。如果你在过程中已经很好地询问了客户正确的问题，那么你可能已经接近一个良好、有用的目标集合。但是，如果出现了新的信息，改变计划可能是必要的。
- en: 'Because you’re already part of the way through the original plan, you probably
    have something to show for it: preliminary results, some software components,
    and the like. If the change in goals is dramatic, these things may no longer be
    as useful as they were, and it can be hard to convince yourself to jettison them.
    But the previous costs of having built something should not inherently be considered
    in making decisions for the future; in the finance industry, this is called a
    *sunk cost*, and it’s a cost you can’t recover; it’s lost forever, no refunds.
    Because the money and time have already been spent, any new plan (for the future)
    shouldn’t consider them. But whatever you’ve already produced can certainly be
    useful, and so that definitely should be taken into account when formulating a
    new plan. For example, if you’ve already built a system to load and format the
    raw data you intend to use, this system is probably going to be useful no matter
    what the new goals are. On the other hand, if you’ve built a statistical model
    that answers questions that are particular to the original goals but not the new
    ones, you might want to throw out that model and start over.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经在原始计划中走了一半的路，你可能已经有所成果：初步结果、一些软件组件等等。如果目标变化很大，这些成果可能不再像以前那样有用，而且可能很难说服自己放弃它们。但是，之前为构建某事物所付出的成本在做出未来决策时不应被视为内在因素；在金融行业中，这被称为*沉没成本*，这是一种无法收回的成本；它永远失去了，无法退款。因为金钱和时间已经花费，任何新的计划（针对未来）都不应考虑它们。但是，你已经生产出来的任何东西肯定是有用的，因此在制定新计划时，这肯定应该被考虑进去。例如，如果你已经构建了一个用于加载和格式化你打算使用的原始数据的系统，那么无论新的目标是什么，这个系统都可能是有用的。另一方面，如果你构建了一个针对原始目标但不是新目标的特定问题的统计模型，你可能想要丢弃该模型并重新开始。
- en: The main focus when goals change is to go through the process of making a plan
    again, like in [chapter 6](kindle_split_016_split_000.xhtml#ch06), but this time
    around you have some additional resources—whatever you’ve already produced from
    the completed part of the original plan—and you have to be very careful not to
    let sunk costs and other inertia prevent you from making the right choices. It’s
    usually worth it to formally run through the planning process again and make sure
    that every ongoing aspect of the project is in the best interest of the goals
    and the new plan that you formulate.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标发生变化时，主要关注的是再次经历制定计划的过程，就像在[第6章](kindle_split_016_split_000.xhtml#ch06)中那样，但这次你有一些额外的资源——原始计划已完成部分所产生的一切——你必须非常小心，不要让沉没成本和其他惯性阻止你做出正确的选择。再次正式运行规划过程通常是有价值的，并确保项目的每个持续方面都符合目标和制定的新计划的最佳利益。
- en: 10.2.2\. Something might be more difficult than you thought
  id: totrans-935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 某些事情可能比你想象的更难
- en: This happens to me a lot. I remember setting out in 2008 to use MapReduce on
    Amazon Web Services (AWS) to compute the results of a rather hefty algorithm for
    bioinformatics that I had written in R. Documentation, tutorials, and simple tools
    for AWS were rather sparse back then, and the same was true for the MapReduce-related
    packages in R. I was also rather naïve, I must confess. To make a long story short,
    many hours later, I knew neither how to set up a cluster on AWS nor how to use
    one with R. Needless to say, I changed my plan.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说经常发生。我记得2008年我计划在亚马逊网络服务（AWS）上使用MapReduce来计算我使用R编写的生物信息学算法的结果。当时，AWS的文档、教程和简单工具相当稀少，R中与MapReduce相关的包也是如此。我必须承认，我那时相当天真。简而言之，经过许多小时后，我既不知道如何在AWS上设置集群，也不知道如何使用R来操作它。不用说，我改变了我的计划。
- en: When a step within your plan that you thought would be reasonably simple turns
    into a nightmare, that’s a good reason to change the plan. This doesn’t usually
    have as large of an impact on the overall plan as a change in goals would, but
    it can still be significant. Sometimes you might be able to swap out the difficult
    thing for an easier one. For instance, if you can’t figure out how to use MapReduce,
    you might gain access to a compute cluster and do your analysis there. Or if a
    piece of analytic software is overly complex, you might trade it for a simpler
    one.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计划中的一个你认为会相对简单的步骤变成了噩梦时，这是一个改变计划的好理由。这通常对整体计划的影响不如目标变化那么大，但它仍然可能很重要。有时你可能能够用一个更容易的事情来替换困难的事情。例如，如果你不知道如何使用MapReduce，你可能会获得访问一个计算集群并在那里进行分析。或者如果某个分析软件过于复杂，你可能会用更简单的一个来替换它。
- en: If the difficult thing isn’t easily avoided—such as when there’s no comparable
    software tool to replace the one that has proven difficult to use—you may have
    to change the plan entirely based on the fact that a particular step must either
    be left out or changed. The key to making this decision is recognizing early—and
    correctly—that figuring out how to do the difficult thing is much more costly
    than doing something else.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 如果困难的事情不容易避免——例如，当没有可比较的软件工具来替换难以使用的工具时——你可能必须完全根据特定步骤必须被省略或改变的事实来改变计划。做出这个决定的关键是及早并且正确地认识到，弄清楚如何做困难的事情的成本要比做其他事情的成本高得多。
- en: 10.2.3\. Sometimes you realize you made a bad choice
  id: totrans-939
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 有时你会意识到你做出了错误的选择
- en: I do this a lot, too. There are any number of reasons why a plan that seemed
    good when you made it would begin to seem less good as you make some progress.
    You might not have been aware of certain software tools or statistical methods,
    for example, and you realize that those are better choices. Or after beginning
    to use a certain tool, you realize that it has a limitation that you weren’t aware
    of before. Another possibility is that you had incorrect assumptions or got bad
    advice about which tools to use.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 我也经常这样做。有许多原因说明，当你制定计划时，看起来不错的计划在你取得一些进展后可能会开始显得不那么好了。例如，你可能没有意识到某些软件工具或统计方法，后来你意识到那些是更好的选择。或者在你开始使用某个工具后，你意识到它有一个你之前没有意识到的限制。另一种可能性是，你有一些错误的假设，或者得到了关于使用哪些工具的糟糕建议。
- en: In any case, if you start to realize that a previous choice, and its inclusion
    in the plan, was a bad idea, it’s never too late to reevaluate the situation and
    reformulate a plan based on the most current information. It’s advisable to take
    into account all the progress up to that point, ignoring purely sunk costs.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，如果你开始意识到之前的某个选择以及将其纳入计划是一个糟糕的想法，那么重新评估情况并基于最新的信息重新制定计划永远不会太晚。建议考虑到目前为止的所有进展，忽略纯粹沉没成本。
- en: '10.3\. Results: knowing when they’re good enough'
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 结果：知道何时足够好
- en: As a project progresses, you usually see more and more results accumulate, giving
    you a chance to make sure they meet your expectations. Generally speaking, in
    a data science project involving statistics, expectations are based either on
    a notion of statistical significance or on some other concept of the practical
    usefulness or applicability of those results or both. Statistical significance
    and practical usefulness are often closely related and are certainly not mutually
    exclusive. I’ll briefly discuss the virtues of each and their relationship with
    one another.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的进展，你通常会看到越来越多的结果累积，这给了你一个机会来确保它们符合你的预期。一般来说，在涉及统计学的数据科学项目中，预期要么基于统计显著性的概念，要么基于这些结果的实际有用性或适用性的其他概念，或者两者兼而有之。统计显著性和实际有用性通常密切相关，并且肯定不是相互排斥的。我将简要讨论每个概念的优点以及它们之间的关系。
- en: Note that throughout this section, I use the term *statistical significance*
    loosely to mean the general levels of accuracy or precision, ranging from the
    concept of p-values to Bayesian probabilities to out-of-sample accuracies of machine
    learning methods.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本节中，我使用“**统计显著性**”这一术语较为宽松，指的是准确度或精度的总体水平，从p值的概念到贝叶斯概率，再到机器学习方法的样本外准确性。
- en: 10.3.1\. Statistical significance
  id: totrans-945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1. 统计显著性
- en: I mentioned statistical significance in [chapter 7](kindle_split_017_split_000.xhtml#ch07)
    but provided relatively little guidance about choosing a particular significance
    level. That’s because the appropriate level of significance depends greatly on
    the purpose of the project. In sociological and biological research, for example,
    significance levels of 95% or 99% are common. In particle physics, though, researchers
    typically require a 5-sigma level of significance before accepting results as
    significant; for reference, 5-sigma (five standard deviations from the mean) is
    approximately 99.99997% significance.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第7章](kindle_split_017_split_000.xhtml#ch07)中提到了统计显著性，但提供了相对较少的关于选择特定显著性水平的指导。这是因为适当的显著性水平在很大程度上取决于项目的目的。例如，在社会学和生物研究中，95%或99%的显著性水平很常见。然而，在粒子物理学中，研究人员通常在将结果视为显著之前需要5个标准差的显著性水平；为了参考，5个标准差（即平均值的五个标准差）大约是99.99997%的显著性。
- en: Depending on the type of statistical model you’re using and the statistical
    approach, there are different formal notions of significance, ranging from *confidence*
    to *credibility* to *probability*. I don’t want to discuss the nuances of each
    of these here, but I will highlight that significance can take many forms, though
    all of them indicate that if you repeat the analysis or gather more data that’s
    similar, you’ll see the same results with a certainty level matching the significance
    level. If you use a 95% significance level, 19 out of 20 comparable analyses would
    be expected to give the same result. This interpretation doesn’t formally match
    every type of statistical analysis, but it’s close enough for the discussion here.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的统计模型和统计方法，存在不同的显著性正式概念，从**置信度**到**可信度**再到**概率**。我不想在这里讨论每个概念的细微差别，但我要强调的是，显著性可以采取多种形式，尽管所有这些形式都表明，如果你重复分析或收集更多类似的数据，你将看到相同的结果，其确定性水平与显著性水平相匹配。如果你使用95%的显著性水平，预计有19个20个可比较的分析会给出相同的结果。这种解释并不正式地符合每种类型的统计分析，但对于这里的讨论来说已经足够接近了。
- en: Let’s say you’re doing a project in genomics, and you’re trying to find genes
    that are related to metabolism. Given a good statistical model that you developed
    for this project, and using the previous notion of repeated analyses with a 95%
    significance level, you’d expect that any gene that meets this significance level
    would also meet that significance level in 19 out of 20 repeated experiments.
    That clearly leaves one experiment in which it wouldn’t meet the significance
    level. Assuming that the gene truly is involved with metabolism, this one non-significant
    result would be considered a *false negative*, meaning that the result was negative
    (not significant) but it shouldn’t have been. If you analyzed data from thousands
    of genes, you’d expect to see many false negatives.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在进行一个基因组学项目，并且你正在尝试找到与代谢相关的基因。给定你为这个项目开发的良好统计模型，并使用之前提到的95%显著性水平的重复分析概念，你预计任何达到这个显著性水平的基因在20次重复实验中的19次也会达到这个显著性水平。这显然留下了一次实验，其中它不会达到显著性水平。假设这个基因确实与代谢有关，这个非显著的结果将被视为一个**假阴性**，这意味着结果是负面的（不显著），但它本不应该如此。如果你分析了成千上万的基因数据，你预计会看到许多假阴性。
- en: On the other hand, because you did only one experiment and subsequent analysis
    for each gene, surely there are some genes that are not involved in metabolism
    but that met the 95% significance level. In theory, these genes should most of
    the time not give significant results, but you were lucky enough to conduct one
    of the rare experiments whose data makes them significant. These are called *false
    positives*.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，因为你只对每个基因进行了一次实验和随后的分析，所以肯定有一些基因不参与代谢，但达到了95%的显著性水平。从理论上讲，这些基因大多数时候不应该给出显著结果，但你足够幸运，进行了一次罕见实验，其数据使它们变得显著。这些被称为*假阳性*。
- en: In practice, choosing a significance level means choosing the right balance
    between false negatives and false positives. If you absolutely need almost all
    of your positives to be true, then you need a very high significance level. If
    you’re more concerned with capturing nearly all of the true things (for example,
    all true metabolism-related genes) in your set of positives, then a lower significance
    level is more appropriate. This is the essence of statistical significance.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，选择显著性水平意味着在假阴性和假阳性之间选择正确的平衡。如果你绝对需要几乎所有的阳性结果都是真实的，那么你需要一个非常高的显著性水平。如果你更关心捕捉你正集中精力捕捉的所有真实事物（例如，所有真实的代谢相关基因），那么较低的显著性水平更为合适。这就是统计显著性的本质。
- en: 10.3.2\. Practical usefulness
  id: totrans-951
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 实用性
- en: What I’m calling *practical usefulness* is very much like statistical significance
    as I’ve described it, but with more of a focus on what you intend to do with the
    results instead of a purely statistical notion of confidence. What you plan to
    do next with the results should play a large role in how significant you need
    them to be.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的*实用性*与我所描述的统计显著性非常相似，但更侧重于你打算如何使用结果，而不是纯粹的统计置信度。你计划如何使用结果应该在决定你需要它们有多重要中扮演重要角色。
- en: In the example of metabolism-related genes, a possible next step would be to
    take the set of significant genes and to run a specific experiment on each of
    those genes in order to verify at a much higher level of precision whether they’re
    truly involved with metabolism. If these experiments are costly in terms of time
    and/or money, then you’ll probably want to use a high level of significance in
    your analyses so that you perform relatively few of these follow-up experiments,
    only on the genes that you’re certain about.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在代谢相关基因的例子中，可能的下一步是选取一组显著基因，并对每个基因进行特定的实验，以在更高的精度水平上验证它们是否真正与代谢有关。如果这些实验在时间和/或金钱上成本高昂，那么你可能希望在分析中使用较高的显著性水平，这样你就可以相对较少地进行这些后续实验，只针对你确信的基因。
- en: In some cases, possibly even this example, the specific level of significance
    is almost irrelevant because you know that you want to take some fixed number
    of the most significant results. You could, for example, take the 10 most significance
    genes and perform the follow-up experiment on them. It might not matter whether
    you make the cutoff 99% or 99.9% if you’re not going to take more than 10 anyway.
    A significance level of less than 95%, though, is probably not advisable, and
    if there aren’t 10 genes meeting that level, it might be best to focus only on
    the ones that have statistical evidence in their favor, that meet at least a minimal
    level of significance.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，甚至可能是这个例子，具体的显著性水平几乎无关紧要，因为你知道你想要取一些固定数量的最显著结果。例如，你可以选择10个最显著的基因，并对它们进行后续实验。如果你本来就不打算超过10个，那么你将99%或99.9%作为截止点可能并不重要。然而，显著性水平低于95%可能不太可取，如果没有10个基因达到那个水平，可能最好只关注那些有统计证据支持、至少达到最低显著性水平的基因。
- en: 'You can begin to decide on a significance level by first asking yourself the
    question, what am I going to do next with the significant results? Considering
    the specific things you intend to do next with the set of significant results,
    answer these questions:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先问自己一个问题来开始决定显著性水平：我将如何使用这些显著结果？考虑到你打算对一组显著结果采取的具体行动，回答这些问题：
- en: How many significant results do you want or need?
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要或需要多少个显著结果？
- en: How many significant results can you handle?
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能处理多少个显著结果？
- en: What is your tolerance for false negatives?
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对假阴性的容忍度是多少？
- en: What is your tolerance for false positives?
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对假阳性的容忍度是多少？
- en: By answering these questions and combining the answers with your knowledge of
    statistical significance, it should be possible to select a set of significant
    results from your analyses that will serve the purposes of your project.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答这些问题，并将答案与你的统计显著性知识相结合，你应该能够从你的分析中选择出一组显著结果，这些结果将服务于你的项目目的。
- en: 10.3.3\. Reevaluating your original accuracy and significance goals
  id: totrans-961
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 重新评估你的原始准确性和显著性目标
- en: As part of your plan for the project, you probably included a goal of achieving
    some accuracy or significance in the results of your statistical analyses. Meeting
    these goals would be considered a success for the project. In light of the previous
    section on statistical significance and practical usefulness, it’s worth reconsidering
    the desired level of significance of the results at this stage of the process,
    for a few reasons that I outline here.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你项目计划的一部分，你可能包括了一个目标，即在你的统计分析结果中实现一定的准确度或显著性。达到这些目标将被视为项目的成功。鉴于上一节关于统计显著性和实际有用性的讨论，在处理过程的这个阶段，重新考虑结果的期望显著性水平是值得的，以下是我概述的几个原因。
- en: You have more information now
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你现在拥有更多信息
- en: You didn’t have as much information when you began the project as you do now.
    The desired accuracy or significance may have been dictated to you by the customer,
    or you may have chosen it yourself. But in either case, now that you’re getting
    to the end of the project and you have some real results, you’re arriving at a
    position from which you can better determine whether that level of significance
    is the most effective.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始项目时，你拥有的信息没有现在这么多。所需的准确度或显著性可能是由客户规定的，或者你可能自己选择了它。但在任何情况下，现在你到了项目的尾声，并且有一些实际的结果，你到达了一个更好的位置，可以更好地确定那个显著性水平是否是最有效的。
- en: 'Now that you have some results, you can ask yourself these questions:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些结果了，你可以问自己这些问题：
- en: If I give a sample of results to the customer, do they seem pleased or excited?
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我向客户展示一些结果样本，他们看起来是否满意或兴奋？
- en: Do these results answer an important question that was posed at the beginning
    of the project?
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些结果是否回答了项目开始时提出的重要问题？
- en: Could I—or the customer—act on these results?
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我或者客户能否根据这些结果采取行动？
- en: If you can answer yes to these questions, then you’re in good shape; maybe you
    don’t need to adjust your significance levels. If you can’t answer yes, it would
    be helpful to reconsider your thresholds and other aspects of how you select important
    results.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些问题的回答都是肯定的，那么你处于良好状态；可能你不需要调整你的显著性水平。如果你不能肯定回答，那么重新考虑你的阈值和其他选择重要结果的方式将是有帮助的。
- en: The number of results might not be what you want
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果的数量可能不是你想要的
- en: No matter how you chose your significance levels previously, you might end up
    with more significant results than you can handle or too few results for them
    to be useful. The solution to too many results is to raise the threshold for significance,
    and for too few results, the solution might be to lower the threshold. But you
    should be careful of a few things.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你之前如何选择显著性水平，你可能会得到比你能够处理更多的显著结果，或者结果太少以至于没有用处。对于结果过多的情况，解决方案是提高显著性阈值，而对于结果过少的情况，解决方案可能是降低阈值。但你应该注意以下几点。
- en: Raising or lowering the threshold because you’d like more or fewer results can
    be a good idea as long as this doesn’t violate any assumptions or goals of your
    project. For example, if you’re working on a project involving the classification
    of documents as either relevant or not relevant to a legal case, it’s important
    that you have few false negatives. Classifying an important document as not relevant
    can be a big problem. If you happen to realize that your classification algorithm
    missed an important document or two, lowering the significance threshold of the
    algorithm to include these documents will indeed lower the number of false negatives.
    But it will also presumably increase the number of false positives, which in turn
    will require more time to subsequently review all the positive results manually.
    Here, decreasing the level of significance directly increases the amount of manual
    work that needs to be performed later, which can be costly in legal contexts.
    Rather than merely change the threshold, it might be better to go back to the
    algorithm and model and see if you can make them better for the task at hand.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 提高或降低阈值，因为你希望得到更多或更少的结果，只要这不会违反你项目的任何假设或目标，这可能是一个好主意。例如，如果你正在从事一个涉及将文件分类为与法律案件相关或不相关的项目，那么你拥有很少的误判是重要的。将一份重要文件错误地分类为不相关可能会造成大问题。如果你偶然发现你的分类算法遗漏了一份或两份重要文件，降低算法的重要性阈值以包含这些文件确实会减少误判的数量。但这也可能增加误判的数量，这反过来又需要更多的时间来手动审查所有阳性结果。在这里，直接降低显著性水平直接增加了后来需要执行的手动工作数量，这在法律环境中可能是昂贵的。与其仅仅改变阈值，不如回到算法和模型，看看你是否可以针对当前任务使它们变得更好。
- en: The main point is that it can be a good idea to increase or decrease significance
    thresholds in order to decrease or increase arbitrarily the number of significant
    results, but only if it doesn’t adversely affect the project’s other assumptions
    and goals. It’s good to think through all possible implications of a threshold
    change so that you can avoid problems.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 主要观点是，为了减少或增加任意数量的显著性结果，提高或降低显著性阈值可能是一个好主意，但前提是不影响项目的其他假设和目标。思考阈值变化的全部可能影响是好的，这样你可以避免问题。
- en: The results might not be quite what you expected
  id: totrans-974
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果可能并不完全符合你的预期
- en: Sometimes, despite all your best intentions, and after considering all the uncertainties,
    you end up with results that don’t seem like what you’d expect. You might have
    a set of significant results that, generally speaking, don’t seem to be what you’re
    looking for. This is obviously a problem.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，尽管你尽了一切努力，在考虑了所有不确定性之后，你得到的结果似乎并不是你所期待的。你可能有一组重要的结果，从一般意义上讲，似乎并不是你想要寻找的。这显然是一个问题。
- en: One potential solution is to raise the significance threshold and make sure
    the most significant results, the very top, do indeed meet your expectations.
    If they look good, then you can possibly use the new threshold as long as the
    change doesn’t adversely affect anything else in the project. If they don’t look
    good, you likely have a bigger problem than significance. You may have to go back
    to the statistical model and try to diagnose the problem.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的解决方案是提高显著性阈值，并确保最显著的结果，即最顶尖的结果，确实符合你的预期。如果它们看起来不错，那么只要变化不会对项目中的其他方面产生不利影响，你就可以使用新的阈值。如果它们看起来不好，那么你可能面临的问题比显著性更大。你可能需要回到统计模型，并尝试诊断问题。
- en: Generally speaking, as you increase the threshold for the level of significance,
    the better your set of results should match what you expect. For example, documents
    should be more relevant in the legal example, genes should be more obviously related
    to metabolism in the genomics example, and so on. If this isn’t the case, it would
    be best to investigate the cause.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，随着显著性水平的阈值提高，你的结果集应该更符合你的预期。例如，在法律案例中，文件应该更有相关性；在基因组学案例中，基因应该更明显地与代谢相关，等等。如果情况并非如此，那么最好调查原因。
- en: '10.4\. Case study: protocols for measurement of gene activity'
  id: totrans-978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 案例研究：基因活动测量的协议
- en: I’ll illustrate the concepts from this and the previous few chapters by giving
    an in-depth explanation of a project from early in my career. With a master’s
    degree and two years of work experience, I decided to go back to school to get
    a PhD. I soon joined a research group in Vienna whose focus was the development
    of effective statistical methods for applications in bioinformatics.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过深入解释我职业生涯早期的一个项目来阐述本章节和前几章节的概念。在获得硕士学位和两年工作经验后，我决定回到学校攻读博士学位。我很快加入了一个在维也纳的研究小组，该小组专注于开发有效的统计方法，用于生物信息学的应用。
- en: I hadn’t worked in bioinformatics before, but I’d long had an interest in the
    primary language of biology—DNA sequences—and so I was looking forward to the
    challenge. I would have to learn about bioinformatics and relevant biology as
    well as some software and programming tools because my prior programming experience
    consisted mainly of MATLAB and a little C. But I had the support of two advisers
    and a small group of other researchers working in my lab, each with varied experience
    in bioinformatics, statistics, and programming.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有在生物信息学领域工作过，但我对生物学的原始语言——DNA序列——一直很感兴趣，所以我期待着这个挑战。我必须学习生物信息学以及相关的生物学知识，以及一些软件和编程工具，因为我的先前编程经验主要是由MATLAB和一点C组成。但我有两个导师和一个小团队的支持，他们在生物信息学、统计学和编程方面都有不同的经验。
- en: Soon after getting settled at my new desk, one of my advisers came to me with
    a prospective first project and asked me to have a look. The general idea was
    to compare laboratory protocols for microarrays in a rigorously statistical manner.
    My adviser had already considered the experimental setup as well as a possible
    mathematical model that could be applied to the resulting data, so the first step
    had already been taken, which was probably good for me as a beginner. As the outcome
    of the project, we wanted to know which lab protocol was the best, and we intended
    to publish the result in a scientific journal not only for the laboratory implications
    but also for the statistical ones.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的新办公桌安顿下来不久后，我的一个导师带着一个潜在的首个项目来找我，并让我看一下。大致的想法是以严格统计的方式比较微阵列的实验室方案。我的导师已经考虑了实验设置以及可以应用于结果数据的可能数学模型，所以第一步已经完成，这对作为初学者的我来说可能是个好事。作为项目的成果，我们想要知道哪个实验室方案是最好的，我们打算在科学期刊上发表结果，不仅因为实验室的意义，也因为统计学的意义。
- en: As I worked on this project, I learned a lot about bioinformatics, mathematics,
    statistics, and software, all of which, when put together, fit squarely in the
    field we now know as data science. In the rest of this section, I describe this
    project in terms of concepts from preceding chapters in this book, with the hope
    that this case study illuminates how they might work in practice.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 在我着手这个项目的过程中，我学到了很多关于生物信息学、数学、统计学和软件的知识，所有这些知识综合起来，正好符合我们现在所知道的数据科学领域。在本节的剩余部分，我将使用本书前几章的概念来描述这个项目，希望这个案例研究能够阐明它们在实际中的应用。
- en: 10.4.1\. The project
  id: totrans-983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 项目
- en: The goal of the project was to evaluate and compare the reliability and accuracy
    of several laboratory protocols for measuring gene expression. Each protocol is
    a chemical process by which RNA extracted from biological samples can be prepared
    for application to a microarray. Microarray technologies, which in the last decade
    have largely been replaced by high-throughput genetic sequencing, can measure
    the expression level (or activity level) of tens of thousands of genes in an RNA
    sample. The protocols that prepared the RNA for microarrays varied in their complexity
    as well as the required amount of RNA input needed for each microarray. The amount
    of RNA input needed for the protocols ranged from about a microgram down to a
    few nanograms, according to the developers of the protocols, which were often
    private companies that probably had reasons to mislead researchers about the reliability
    of their protocols in order to sell more of the required kits. Nonetheless, it
    would be beneficial to be able to use less RNA per microarray, because maintaining
    and extracting biological samples can be expensive. We wanted to hold a head-to-head
    competition between the protocols as they’d be used in the lab to see if any of
    the promises held up and in order to get the most out of our limited lab budgets.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的目标是评估和比较几种实验室协议在测量基因表达方面的可靠性和准确性。每种协议都是一种化学过程，通过这个过程可以从生物样本中提取的RNA被制备用于微阵列的应用。微阵列技术，在过去十年中已被高通量基因测序大量取代，可以测量RNA样本中成千上万个基因的表达水平（或活性水平）。为微阵列制备RNA的协议在复杂性和每个微阵列所需的RNA输入量方面有所不同。根据协议的开发者，这些开发者通常是私营公司，他们可能有一些理由误导研究人员关于其协议的可靠性，以便销售更多的所需套件。尽管如此，能够使用每个微阵列更少的RNA将是有益的，因为维护和提取生物样本可能很昂贵。我们希望将协议在实验室中的使用进行面对面竞争，以查看是否任何承诺都得到了兑现，并为了从我们有限的实验室预算中获得最大效益。
- en: We had four protocols in total, and one of them was well known to be quite reliable,
    so it was the closest thing to a gold standard that we had. For each protocol,
    we would run four microarrays whose putative experimental goal was to compare
    gene expression between male and female fruit flies—*Drosophila melanogaster*,
    a common model organism that’s better understood than most organisms. There are
    some large differences between expression in male and female flies in some genes,
    particularly those known to be associated with sexual development and function,
    and in other genes there shouldn’t be much of a difference. Each set of four microarrays
    would be run in a *dye-swap* configuration, which means that male RNA is dyed
    with the green radioactive dye on two arrays and with the red radioactive dye
    on the other two arrays; female RNA is dyed in the opposite color on each array.
    In the end, each microarray, for each of about 10,000 genes, gives a measurement
    of the ratio of gene expression in males to that in females.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共有四种协议，其中一种非常可靠，因此可以说是我们拥有的最接近黄金标准的协议。对于每一种协议，我们会运行四个微阵列，其假定的实验目标是比较雄性和雌性果蝇的基因表达——*黑腹果蝇*，这是一种比大多数生物更易于理解的常见模式生物。在某些基因中，雄性和雌性果蝇的表达存在一些较大差异，尤其是那些已知与性发育和功能相关的基因，而在其他基因中则不应有太大差异。每组四个微阵列将以*染色交换*配置运行，这意味着雄性RNA在两个阵列上用绿色放射性染料染色，而在另外两个阵列上用红色放射性染料染色；雌性RNA在每个阵列上以相反的颜色染色。最终，每个微阵列，对于大约10,000个基因中的每一个，都会给出雄性基因表达与雌性基因表达比率的测量值。
- en: Because we were using one of the protocols as a sort of gold standard, we ran
    two sets of four microarrays using it. Beyond having two sets of a reliable protocol
    available for comparison with other protocols, we could compare the two sets with
    each other to get an idea of the reliability of this protocol. If the two sets
    gave widely differing results, that would be evidence that even this gold standard
    protocol wasn’t reliable.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用其中一种协议作为某种黄金标准，所以我们使用它运行了两套四个微阵列。除了有两套可靠的协议可用于与其他协议进行比较之外，我们还可以比较这两套协议，以了解这种协议的可靠性。如果这两套协议给出了广泛不同的结果，那么这将证明即使是这种黄金标准协议也不是可靠的。
- en: In addition to all of that, for two of the four protocols we ran experiments
    using less RNA than what the protocol usually requires, so that we could compare
    these protocols with other protocols that typically require less RNA, in a sort
    of fair-fight scenario. A set of microarrays, one for each protocol, for four
    protocols, plus an extra set of the gold standard and two sets for the two low-RNA
    versions give 28 microarrays in total. This was the entire data set we would be
    using.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在四个实验方案中，我们使用了比方案通常要求的更少的RNA，这样我们就可以在一种公平竞争的场景下将这些方案与其他通常需要较少RNA的方案进行比较。一套微阵列，每个方案一套，四个方案，加上一套金标准微阵列和两套用于两个低RNA版本的微阵列，总共28套微阵列。这是我们将会使用的整个数据集。
- en: 10.4.2\. What I knew
  id: totrans-988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. 我所知道的内容
- en: Upon starting this project, I knew mathematics and statistics—at least to the
    master’s degree level—and a fair amount of MATLAB. I knew the basics of DNA and
    RNA transcription and the general principles about how genes are translated and
    expressed within cells. In a relatively short time, I also learned the basics
    regarding the project description, including the foundations of how microarrays
    work and how the experiments are configured.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个项目时，我知道数学和统计学——至少是硕士水平——以及相当多的MATLAB知识。我知道DNA和RNA转录的基础知识以及基因如何在细胞内翻译和表达的一般原则。在相对较短的时间内，我还学习了关于项目描述的基础知识，包括微阵列的工作原理和实验配置的通用原则。
- en: 10.4.3\. What I needed to learn
  id: totrans-990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3\. 我需要学习的内容
- en: I had a lot to learn about bioinformatics, but strangely that wasn’t the bulk
    of what I had to learn. It seemed like I learned the relevant knowledge about
    genes and microarrays in a relatively short time, but there were specific aspects
    of the mathematics and statistics that I hadn’t seen before, and I also didn’t
    know R, which was the preferred programming language of the lab because of its
    strengths specific to bioinformatics.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 我在生物信息学方面有很多东西要学，但奇怪的是，这并不是我需要学习的主要内容。似乎我在相对较短的时间内就学会了关于基因和微阵列的相关知识，但有一些数学和统计学的特定方面是我之前没有见过的，而且我还不知道R语言，这是实验室首选的编程语言，因为它在生物信息学方面有特定的优势。
- en: On the mathematics side, although I was very familiar with probability and statistics,
    I hadn’t ever formulated and applied a mathematical model to data. I was a Bayesian-leaning
    mathematician with a fully Bayesian adviser, and so I needed to commit to learning
    all the implications of formulating and applying a Bayesian model.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学方面，尽管我对概率和统计学非常熟悉，但我从未对数据进行过数学模型的构建和应用。我是一个倾向于贝叶斯理论的数学家，拥有一个完全贝叶斯理论的导师，因此我需要承诺学习构建和应用贝叶斯模型的所有相关含义。
- en: On the programming side, I was a complete beginner with R, but on the advice
    of my advisers, that’s the language I would use. The R libraries for loading microarray
    data are very good, and the statistical libraries are comprehensive as well, so
    I’d need to learn a lot of R in order to use it on this project.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程方面，我对R语言一无所知，但在导师的建议下，我将使用这种语言。用于加载微阵列数据的R库非常好，统计库也非常全面，因此我需要学习大量的R语言知识才能在这个项目中使用它。
- en: 10.4.4\. The resources
  id: totrans-994
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.4\. 资源
- en: Beyond my two advisers, I had several colleagues with varied experience in bioinformatics,
    mathematics, and programming in R. I was definitely in a good environment in which
    to learn R. When I encountered a problem or a weird error, I had to ask aloud,
    “Has anyone had this problem before?” and someone usually had a helpful comment
    or even a solution to my problem. My colleagues were certainly helpful. I tried
    to pay back my knowledge debt by telling the rest of the group whenever I discovered
    a programming trick that I thought they might not have seen before.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我的两位导师外，我还拥有几位在生物信息学、数学和R语言编程方面经验丰富的同事。我确实处于一个很好的环境中学习R。当我遇到问题或奇怪的错误时，我不得不大声问，“以前有人遇到过这个问题吗？”通常有人会给出有用的评论，甚至解决我的问题。我的同事们确实很有帮助。当我发现一些他们认为可能之前没见过的编程技巧时，我试图通过告诉小组的其他成员来偿还我的知识债务。
- en: Beyond human resources, we also had some technological ones. Most important,
    my group had a lab capable of performing microarray experiments from beginning
    to end. Though microarrays aren’t cheap, if it seemed prudent we could create
    any amount of data that we wanted for the analysis.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 除了人力资源之外，我们还有一些技术资源。最重要的是，我的小组有一个能够从头到尾进行微阵列实验的实验室。尽管微阵列并不便宜，但如果我们认为这样做是谨慎的，我们可以为分析创建我们想要的任何数量的数据。
- en: On the computational side, I had access to two university-owned servers, each
    of which had many computing cores and therefore could compute results several
    times faster than I could on my local machine. I kept this in mind while writing
    my code and made sure that everything I did could run in parallel on multiple
    cores.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算方面，我有权访问两个大学拥有的服务器，每个服务器都有许多计算核心，因此可以比我在本地机器上快几倍地计算结果。我在编写代码时考虑到这一点，并确保我做的所有事情都可以在多个核心上并行运行。
- en: 10.4.5\. The statistical model
  id: totrans-998
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.5\. 统计模型
- en: Quite a few variables might come into play in this project. First and foremost
    among them was true gene expression. The main goal of the project was to evaluate
    how closely the measurements for each protocol matched the true gene expression
    level. We would want a variable in the model representing the true gene expression.
    We didn’t have any perfect measurements of this—the best we had was the gold standard
    protocol that we knew was less than perfect—so this true gene expression variable
    would have to be a latent one. In addition to the true gene expression, we would
    need variables representing the measurements that the protocols produced. These
    are obviously measured quantities because we had the data for them, and there
    might be an associated error term because measurements on a genetic level are
    often noisy.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，可能会有很多变量发挥作用。其中最重要的是真实的基因表达。项目的主要目标是评估每个协议的测量值与真实基因表达水平之间的匹配程度。我们希望在模型中有一个代表真实基因表达的变量。我们没有这个变量的完美测量值——我们最好的是金标准协议，我们知道它并不完美——因此，这个真实基因表达变量必须是一个潜在变量。除了真实基因表达之外，我们还需要代表协议产生的测量值的变量。这些显然是测量量，因为我们有它们的数据，并且可能存在一个相关的误差项，因为基因水平的测量通常很嘈杂。
- en: 'In addition to the true gene expression values and their various measurements,
    several types of variance were involved. Usually, we’d be looking at RNA samples
    from various individual flies, and there would be a variance between individuals
    depending on their own genetic composition. But in this case we mixed all the
    samples of female flies together, and likewise for the males, so there would be
    no biological variance among individuals. Microarrays notoriously don’t produce
    the same results every time you run one with the same biological sample. That’s
    why we were running four microarrays per protocol: to get an estimate of the technical
    variance resulting from each of the protocols. Lower technical variance is generally
    better, because it means that multiple measurements of the same thing will give
    results that are close to each other. On the other hand, lower technical variance
    isn’t always better; a protocol that totally fails and always reports a measurement
    of zero for every gene will have perfect technical variance of zero but would
    be completely useless. We would want a notion of technical variance somewhere
    in our model as well.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 除了真实基因表达值及其各种测量值之外，还涉及几种类型的方差。通常，我们会查看来自各种个体的RNA样本，并且个体之间会有基于他们自身遗传组成的方差。但在这个案例中，我们将雌性果蝇的所有样本混合在一起，同样对于雄性也是如此，因此个体之间不会有生物方差。微阵列臭名昭著的是，每次用相同的生物样本运行时都不会产生相同的结果。这就是为什么我们为每个协议运行四个微阵列的原因：为了估计每个协议产生的技术方差。较低的技术方差通常更好，因为它意味着对同一事物的多次测量将给出接近的结果。另一方面，较低的技术方差并不总是更好的；一个完全失败并总是为每个基因报告零测量值的协议将具有完美的零技术方差，但将完全无用。我们希望在模型中有一个关于技术方差的概念。
- en: 'The model formulation that we ultimately settled on assumed that the measurements
    reported by the microarrays for each protocol were normally distributed random
    variables based on the true gene expression values. Specifically, for each gene
    *g*, the measurement x[n,g] indicates the gene expression value reported by microarray
    *n* from the gold standard protocol, and y[m,g] represents the expression value
    reported by microarray *m* from another protocol. The formulation is as follows:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终确定的模型假设，每个协议报告的微阵列测量值是基于真实基因表达值的正态分布随机变量。具体来说，对于每个基因 *g*，测量值 x[n,g] 表示微阵列
    *n* 从金标准协议报告的基因表达值，而 y[m,g] 代表微阵列 *m* 从另一个协议报告的表达值。公式如下：
- en: x[n,g] ~ N( μ[g] , 1/λ )
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: x[n,g] ~ N( μ[g] , 1/λ )
- en: ''
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: y[m,g] ~ N( μ[g] + β, 1/(αλ) )
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: y[m,g] ~ N( μ[g] + β, 1/(αλ) )
- en: Here μ[g] is the true gene expression value of gene *g*, λ is the technical
    precision (inverse variance) of the gold standard protocol. The variables β and
    α represent inherent differences between a protocol and the gold standard. β allows
    for a possible rescaling of expression values; in case one protocol tends to have
    lower or higher values across all genes, we wanted to allow for that (and not
    penalize) because it doesn’t directly imply that the rescaled numbers are wrong.
    Lastly, α represents the protocol’s technical variance relative to the gold standard’s.
    A higher α means that protocol’s technical variance is lower.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，μ[g]是基因g的真实基因表达值，λ是金标准协议的技术精度（逆方差）。变量β和α代表协议与金标准之间的固有差异。β允许对表达值进行可能的缩放；如果某个协议在所有基因中倾向于具有较低或较高的值，我们希望允许这一点（而不是惩罚），因为这并不直接意味着缩放后的数字是错误的。最后，α代表协议相对于金标准的技术方差。α值越高，表示该协议的技术方差越低。
- en: 'I’ve mentioned that I like to consider every variable a random variable until
    I’ve convinced myself that I’m allowed to fix the values in place. Therefore,
    parameters in the aforementioned probability distributions need to have their
    distributions specified as well, as in the following:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到我喜欢将每一个变量都视为随机变量，直到我确信自己可以固定这些变量的值。因此，上述概率分布中的参数也需要指定它们的分布，如下所示：
- en: μ[g] ~ N( 0, 1/(γλ) )
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: μ[g] ~ N( 0, 1/(γλ) )
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: β ~ N( 0, 1/(νλ) )
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: β ~ N( 0, 1/(νλ) )
- en: ''
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: λ ~ Gamma( φ, κ )
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: λ ~ Gamma( φ, κ )
- en: A gamma distribution is related to the normal distribution in such a way that
    makes it useful and convenient to use for variance parameters of normal distributions.
    The rest of the yet-undiscussed model parameters appearing in the equations—γ,
    ν, φ, and κ—I didn’t treat as random variables, but I was careful about it.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯分布与正态分布相关联，这种关联使得它在作为正态分布的方差参数时既有用又方便。方程中出现的其余尚未讨论的模型参数——γ、ν、φ和κ——我没有将它们视为随机变量，但我对此非常小心。
- en: Each of these model parameters is at least two steps away from the data—by that,
    I mean that none of them appears directly in one of the equations describing the
    observed data, x[n,g] or y[m,g]. Because of this removal, such parameters are
    often called hyper-parameters. In addition, these parameters can be used in a
    non-informative fashion—meaning that their values can be chosen so as not to exert
    too much influence on the rest of the model. I attempted to make the hyper-parameters
    almost irrelevant to the rest of the model, but I checked to make sure this was
    the case. After finding the optimal parameter values (see the section on model
    fitting in this chapter), checking to make sure that the value of a hyper-parameter
    is almost irrelevant to the model and the results involved a sort of sensitivity
    analysis wherein I changed the values of the parameters dramatically and looked
    to see if the results changed at all. In this case, the hyper-parameters, even
    if I multiplied them by 10 or 1000, didn’t affect the conclusions in a significant
    way.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型参数至少与数据有两步之遥——这里的含义是，它们中的任何一个都没有直接出现在描述观测数据x[n,g]或y[m,g]的方程中。由于这种移除，这些参数通常被称为超参数。此外，这些参数可以以非信息性方式使用——这意味着它们的值可以被选择，以便不会对模型的其他部分产生过多的影响。我试图使超参数几乎与模型的其他部分无关，但我检查以确保这一点。在找到最佳参数值（见本章关于模型拟合的部分）之后，检查以确保超参数的值几乎与模型和涉及的结果无关，进行了一种敏感性分析，其中我大幅改变了参数的值，并观察结果是否有所变化。在这种情况下，即使我将超参数乘以10或1000，它们对结论的影响也不显著。
- en: I’ve described a fairly complex model with several paragraphs and equations,
    but I’m a visual person, so I like to make diagrams of models. A good visual representation
    of a mathematical or statistical model comes in the form of a *directed acyclic
    graph* (DAG). [Figure 10.2](kindle_split_020_split_004.xhtml#ch10fig02) shows
    the DAG for the model of multi-protocol measurement of gene expression. In the
    DAG, you can see all of the variables and parameters that I’ve discussed, each
    inside its own circle. The gray shaded circles are observed variables, whereas
    the unshaded circles are latent variables. An arrow from one variable to another
    indicates that the origin/first variable appears as a parameter in the distribution
    of the target/second variable. The rectangles, or sheets, in the background show
    that there are multiple genes *g* and microarray replicates *n* and *m*, each
    of which possesses a different instance of each of the variables contained in
    the sheet. For example, for each gene *g*, there is a different true gene expression
    value μ[g] as well as a set of gold standard measurements x[n,g] and a set of
    measurements by another protocol y[m,g]. Such a visual representation helps me
    keep all the variables straight.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用几段文字和方程式描述了一个相当复杂的模型，但我是一个视觉型的人，所以我喜欢制作模型的图表。数学或统计模型的良好视觉表示形式是*有向无环图*（DAG）。[图10.2](kindle_split_020_split_004.xhtml#ch10fig02)展示了多协议测量基因表达模型的DAG。在DAG中，你可以看到我讨论的所有变量和参数，每个都在自己的圆圈中。灰色阴影的圆圈是观测变量，而未阴影的圆圈是潜在变量。从一个变量到另一个变量的箭头表示起源/第一个变量作为参数出现在目标/第二个变量的分布中。背景中的矩形或纸张表示存在多个基因*g*和微阵列重复*n*和*m*，每个都拥有纸张中包含的每个变量的不同实例。例如，对于每个基因*g*，都有一个不同的真实基因表达值μ[g]，以及一组金标准测量值x[n,g]和另一组测量值y[m,g]。这种视觉表示帮助我理清所有变量。
- en: Figure 10.2\. A directed acyclic graph (DAG) representing a model of the comparison
    of gene expression measurements based on different laboratory techniques
  id: totrans-1015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. 表示基于不同实验室技术比较基因表达测量值的模型的有向无环图（DAG）
- en: '![](Images/10fig02.jpg)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02.jpg)'
- en: 10.4.6\. The software
  id: totrans-1017
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.6. 软件
- en: 'I was learning and using the R language while working on this project. R has
    a bunch of great bioinformatics packages, but I used only the `limma` package,
    which is handy for loading and manipulating microarray data, among other things.
    Being a beginner with R, I decided to use it only to manipulate the data into
    a familiar format: a tab-separated file containing gene expression values.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 我在完成这个项目的同时学习并使用R语言。R有一系列优秀的生物信息学包，但我只使用了`limma`包，它非常适合加载和操作微阵列数据等。作为一个R语言的初学者，我决定只使用它来将数据转换成熟悉的格式：一个包含基因表达值的制表符分隔文件。
- en: After manipulating and formatting the raw data in R, I wrote the code that fit
    the statistical model in MATLAB, a language that was more familiar to me and one
    that is very good at performing operations on large matrices, an important computational
    aspect of my code.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 在用R处理和格式化原始数据后，我编写了在MATLAB中拟合统计模型的代码，MATLAB是我更熟悉的一种语言，而且非常适合对大型矩阵进行操作，这是我的代码的一个重要计算方面。
- en: I had R code that processed and reformatted the microarray data into a familiar
    format, and then I had a considerable amount of MATLAB code that loaded the processed
    data and applied the statistical model to the data. At this point in my career,
    this was the most complex piece of software I had written.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一段R代码，用于处理和重新格式化微阵列数据，使其成为熟悉的格式，然后我还有相当多的MATLAB代码，用于加载处理后的数据并将统计模型应用于数据。在我职业生涯的这个阶段，这是我编写过的最复杂的软件。
- en: 10.4.7\. The plan
  id: totrans-1021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.7. 计划
- en: Academic timelines are usually rather slow. There was no real deadline for this
    project, except for an upcoming conference for which I might apply to give a talk.
    The conference application deadline was a few months away, so I had a good amount
    of time to make sure everything was in order before submitting.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 学术时间线通常相当缓慢。这个项目没有真正的截止日期，除了我可能申请发表演讲的即将到来的会议。会议申请截止日期还有几个月，所以我有很多时间确保一切就绪后再提交。
- en: The main goal of the project, as with most academic projects, was to have a
    paper accepted into a good scientific journal. In order to have a paper accepted,
    the research must be original, meaning it contains something no one has done before,
    and it must be rigorous, meaning the paper shows that the author didn’t make any
    mistakes or fallacies.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的主要目标，就像大多数学术项目一样，是将论文发表在一家好的科学期刊上。为了使论文被接受，研究必须是原创的，这意味着它包含了一些以前没有人做过的事情，并且它必须是严谨的，这意味着论文表明作者没有犯任何错误或谬误。
- en: Therefore, my first primary goal was to make sure that the main scientific results
    were rock solid. The next goal was to compile additional statistics and supporting
    evidence that the methods used in the project were consistent with the common
    knowledge and methods of bioinformatics. Finally, I would write a compelling scientific
    paper based on the research and submit it to the conference and/or a good scientific
    journal.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的首要目标是确保主要科学结果是坚如磐石的。下一个目标是编制额外的统计数据和辅助证据，证明项目中使用的方法与生物信息学的常识和方法一致。最后，我会基于研究写一篇引人入胜的科学论文，并将其提交给会议和/或一家好的科学期刊。
- en: 'My plan, therefore, was a relatively simple one. Given my level of knowledge
    at the time, the plan was approximately the following:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的计划相对简单。考虑到我当时的知识水平，计划大致如下：
- en: Learn R and use it to manipulate the data into a familiar format.
  id: totrans-1026
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习R语言，并使用它来将数据转换成熟悉的格式。
- en: Write the statistical methods in MATLAB and apply them to the data using one
    of the university’s high-powered computing servers.
  id: totrans-1027
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MATLAB中编写统计方法，并使用大学的高性能计算服务器之一将其应用于数据。
- en: Compile a set of known statistics measuring microarray data quality and compare
    them to the results from the main statistical model. Reconcile any discrepancies
    as necessary.
  id: totrans-1028
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编制一套衡量微阵列数据质量的已知统计数据，并将它们与主要统计模型的结果进行比较。如有必要，解决任何差异。
- en: Write a compelling paper.
  id: totrans-1029
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一篇引人入胜的论文。
- en: Show the paper to my adviser, and go around and around editing and improving
    it. Some iterations may require additional analysis.
  id: totrans-1030
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我的导师展示论文，并反复编辑和改进它。某些迭代可能需要额外的分析。
- en: Once the paper is good enough, submit it to the conference and/or a journal.
  id: totrans-1031
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦论文足够好，就提交给会议和/或期刊。
- en: If rejected, edit the paper based on feedback from journal reviewers and submit
    again.
  id: totrans-1032
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果被拒绝，根据期刊审稿人的反馈编辑论文并再次提交。
- en: This was a fairly straightforward plan, without too many competing interests
    or potential roadblocks. The most time was spent on developing the sophisticated
    statistical model, building the software, and iteratively checking and improving
    various aspects of the analysis.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的计划，没有太多相互竞争的利益或潜在的障碍。大部分时间都花在了开发复杂的统计模型、构建软件以及迭代检查和改进分析的各个方面。
- en: One problem that we did run into during the course of this project was that
    the data quality seemed very poor for one of the microarray protocols. After weeks
    of investigation, our laboratory researchers figured out that one of the chemical
    reagents used in the protocol expired much sooner than expected. It became ineffective
    after only a few months, and we hadn’t realized that—probably because we weren’t
    using the original packaging and were sharing the reagents with nearby labs. Once
    we figured that out, we ordered some new reagent and reran the affected microarray
    experiments, with better results.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的进行过程中，我们确实遇到了一个问题，那就是其中一个微阵列协议的数据质量似乎非常差。经过几周的调查，我们的实验室研究人员发现，该协议中使用的其中一种化学试剂的保质期比预期的要短得多。它只在几个月后就变得无效了，而我们没有意识到这一点——可能是因为我们没有使用原始包装，并且与附近的实验室共享试剂。一旦我们弄清楚这一点，我们就订购了一些新的试剂，并重新进行了受影响的微阵列实验，结果更好。
- en: Other than the reagent snafu, there were no major issues, and everything ran
    according to plan. The biggest uncertainty at the beginning was in how good the
    results would be. Once I had calculated them and compared them to the known statistics
    for microarray data quality, that obstacle had largely been overcome. On the other
    hand, there was considerable discussion between my advisers and me about what
    exactly constitutes good results and what additional work, if any, would improve
    them.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 除了试剂问题之外，没有出现重大问题，一切按计划进行。开始时最大的不确定性在于结果会好到什么程度。一旦我计算了它们，并将它们与已知的微阵列数据质量统计数据进行了比较，这个障碍就基本克服了。另一方面，我的导师和我之间就什么构成了好的结果以及是否需要做额外的工作进行了相当多的讨论。
- en: 10.4.8\. The results
  id: totrans-1036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.8. 结果
- en: The purpose of this project was to compare objectively the fidelity of several
    microarray protocols in the laboratory and to decide which protocols and which
    amounts of RNA are required to produce reliable results. The main results were
    from the statistical model described earlier, but as in most bioinformatic analyses,
    no one trusts a novel statistical model unless one can prove that it doesn’t contradict
    known applicable models. I calculated four other statistics that measured the
    different aspects of the fidelity that we intended to measure with the main statistical
    model. If these other statistics generally supported the main statistical model,
    other researchers might be convinced that the model is a good one.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目的是客观比较实验室中几个微阵列协议的忠实度，并决定需要哪些协议以及多少RNA才能产生可靠的结果。主要结果来自前面描述的统计模型，但正如大多数生物信息学分析一样，除非能够证明它不与已知的适用模型相矛盾，否则没有人会信任一个新颖的统计模型。我计算了四个其他统计量，这些统计量测量了我们打算用主要统计模型测量的忠实度的不同方面。如果这些其他统计量通常支持主要统计模型，其他研究人员可能会被说服这个模型是好的。
- en: The results table excerpted from a draft of the scientific paper can be seen
    in [figure 10.3](kindle_split_020_split_004.xhtml#ch10fig03). The descriptions
    of the other statistics are given in the original, clipped caption, but the specifics
    aren’t important here. What is important is that in the combination of the four
    other statistics—technical variance (TV), correlation coefficient (CC), gene list
    overlap (GLO), and the number of significant genes (Sig. Genes)—there was ample
    evidence that the log marginal likelihood from our statistical model (log ML)
    was a reliable measure of protocol fidelity. These supplementary statistics and
    analyses functioned like descriptive statistics—they’re much closer to the data—and
    provided easy-to-interpret results that are hard to doubt. And because they generally
    supported the results from the statistical model, I was confident that others
    would see the value in a statistical model that considers all of these valuable
    aspects of fidelity at once.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 从科学论文草案中摘录的结果表可以在[图10.3](kindle_split_020_split_004.xhtml#ch10fig03)中看到。其他统计学的描述在原始的剪裁标题中给出，但具体细节在这里并不重要。重要的是，在四个其他统计学的组合中——技术变异性（TV）、相关系数（CC）、基因列表重叠（GLO）和显著基因数量（Sig.
    Genes）——有充分的证据表明，我们统计模型的对数边际似然（log ML）是协议忠实度的可靠度量。这些补充统计和分析就像描述性统计一样——它们与数据更接近——提供了易于解释的结果，难以质疑。而且因为它们通常支持统计模型的结果，所以我确信其他人也会看到同时考虑所有这些忠实度宝贵方面的统计模型的价值。
- en: Figure 10.3\. The main table of results for the microarray protocol comparison
    project, as clipped from a draft submitted to a scientific journal
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3. 从提交给科学期刊的草案中剪裁出的微阵列协议比较项目的主要结果表
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-1040
  prefs: []
  type: TYPE_IMG
  zh: '![图片10fig03_alt](Images/10fig03_alt.jpg)'
- en: 10.4.9\. Submitting for publication and feedback
  id: totrans-1041
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.9. 提交出版和反馈
- en: In scientific research, as in data science in industry, what you know to be
    true because you’ve proven it through rigorous research may not be accepted by
    the community at large. It takes most people some time to accept new knowledge
    into their canon, and so it’s rarely surprising to experience some resistance
    from people whom you think would know better.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学研究，以及在工业中的数据科学中，你通过严格的研究证明为真的知识可能不会被整个社区接受。大多数人需要一些时间才能将新知识纳入他们的教条，因此，经历一些来自你认为应该知道得更好的人的阻力并不罕见。
- en: A few weeks after submitting a version of my research paper to the bioinformatics
    conference, I received an email informing me that it was not accepted to be the
    topic of a talk at the conference. I was disappointed—but not too disappointed—because
    the acceptance rate at this particular conference was known to be well under 50%,
    and a first-year PhD student is probably at a distinct disadvantage.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我的研究论文版本提交给生物信息学会议几周后，我收到了一封电子邮件通知我，它没有被接受作为会议演讲的主题。我感到失望——但并不太失望——因为众所周知，这个特定会议的接受率远低于50%，而且作为一名一年级博士生，可能处于明显的劣势。
- en: The rejection letter came with minimal feedback from scientists who had read
    my paper and had judged its worthiness. From what I could tell, no one had questioned
    the rigor of the paper, but they thought it was boring. Exciting science definitely
    gets more attention and press, but someone does need to do the boring stuff, which
    I fully acknowledge I was doing.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝信中只有少数几位阅读了我的论文并评判其价值的科学家的反馈。据我所知，没有人质疑论文的严谨性，但他们认为它很无聊。激动人心的科学确实会得到更多的关注和媒体报道，但有人确实需要做那些无聊的事情，我完全承认我就是在做这些事情。
- en: After the rejection, I went back to the later steps in my plan, focusing on
    how to make the paper more compelling (and exciting, if possible) before submitting
    the paper again to a scientific journal.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 在被拒绝后，我回到了计划中的后续步骤，专注于在再次将论文提交给科学期刊之前，如何使论文更具吸引力（如果可能的话，还要更激动人心）。
- en: 10.4.10\. How it ended
  id: totrans-1046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.10\. 它是如何结束的
- en: Not every data science project ends well. The initial rejection by the conference
    was the beginning of an extended phase of redefining the exact goals of the paper
    that we would resubmit to a scientific journal. From shortly before the initial
    submission until the end of the project (well over a year later), some of the
    goals of the project and paper were continually moving. In that way, this academic
    experience was a lot like my later experiences at software companies. In both
    cases, goals rarely stayed in one place throughout a project. In software and
    data science, business leadership and customers often modify the goals for business
    reasons. In my microarray protocol project, the goals were changing because of
    our impression of what good results might mean to potential paper reviewers.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个数据科学项目都能有一个好的结局。会议最初的拒绝是我们重新定义将重新提交给科学期刊的论文确切目标的一个长期阶段的开始。从最初提交的前不久到项目结束（一年多以后），项目的一些目标和论文的目标一直在变动。因此，这种学术经历在很大程度上类似于我在后来的软件公司的工作经历。在这两种情况下，目标在整个项目过程中很少保持不变。在软件和数据科学中，商业领导和客户经常出于商业原因修改目标。在我的微阵列协议项目中，目标变动是因为我们对良好结果可能对潜在的论文审稿人意味着什么的印象。
- en: Because the end goal of the project was to get a paper published in a scientific
    journal, we needed to be aware of what the journal’s reviewers might say. Each
    step of the way, we looked for holes in our own arguments and gaps in the evidence
    that our research provided. In addition to that, we needed to take into consideration
    feedback from other researchers who weren’t involved in our project, because these
    researchers are peers of those who would eventually become our reviewers.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目的最终目标是让论文在科学期刊上发表，我们需要意识到期刊审稿人可能会说什么。在每一步中，我们都寻找我们自己论点的漏洞和我们所提供证据中的空白。除此之外，我们还需要考虑那些未参与我们项目的其他研究者的反馈，因为这些研究者是最终将成为我们审稿人的同侪。
- en: It can be frustrating to have goals that move constantly. Thankfully, there
    were no large goal changes, but there certainly were dozens of small ones. Because
    of the goal changes, progress through the project was riddled with small plan
    changes, and I spent several months juggling and prioritizing the changes that
    might have the most significant impact on our chances of acceptance into a good
    journal.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不断变动可能会让人感到沮丧。幸运的是，没有出现大的目标变动，但确实有数十个小变动。由于目标变动，项目进展中充满了小的计划调整，我花了数个月的时间在可能对我们被好期刊接受的机会产生最大影响的变动之间权衡和优先排序。
- en: Ultimately, no paper based on this research was ever published. The project
    leadership was quite fickle and couldn’t settle on a single set of goals, and
    they were never satisfied with the state of the research and paper no matter how
    many modifications they or I made. I was also rather inexperienced in working
    with a research team and publishing an academic paper, and no matter how much
    I pushed for it, without the approval of all authors, a paper generally can’t
    be published at all.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，基于这项研究没有任何论文被发表。项目领导非常反复无常，无法就单一的目标集达成一致，无论他们或我做了多少修改，他们对研究和论文的状态始终不满意。我在与研究团队合作和发表学术论文方面也相当缺乏经验，无论我多么努力推动，如果没有所有作者的批准，论文通常根本无法发表。
- en: This is certainly not a tale of happily ever after, but I think the project
    as a whole provides examples of both good and bad things that can happen during
    a data science project. Things were going rather well until the later stages of
    the project—I think the analysis and results of the project were good—but I was
    forced to make some tough decisions when put in a difficult spot, and the plan
    was modified several times before being thrown out the window. Data science is
    not, as the press sometimes seems to believe, always sunshine and rainbows, but
    it can help solve many problems. Don’t let the possibility of failure prevent
    you from doing good work, but be aware of signs indicating that the plan and the
    project might be running off track; catching it early can give you the opportunity
    to correct the problems.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然不是一个永远幸福的童话故事，但我认为整个项目提供了在数据科学项目中可能发生的好与坏的事例。事情在项目后期进行得相当顺利——我认为项目的分析和结果是好的——但是当我处于困境中时，被迫做出一些艰难的决定，计划在多次修改后被彻底放弃。数据科学并非像媒体有时似乎相信的那样总是阳光明媚，但它可以帮助解决许多问题。不要让失败的可能性阻止你做好工作，但要注意计划项目和项目可能偏离轨道的迹象；及早发现可以给你纠正问题的机会。
- en: Exercises
  id: totrans-1052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: 'Continuing with the Filthy Money Forecasting personal finance app scenario
    first described in [chapter 2](kindle_split_011_split_000.xhtml#ch02), and relating
    to previous chapters’ exercises, try these:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_011_split_000.xhtml#ch02)中首先描述的 Filthy Money Forecasting
    个人财务应用场景继续进行，并关联到前几章的练习，尝试以下操作：
- en: '**1\.**'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.'
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List three people (by role or expertise) at FMI with whom you will probably
    be talking the most while executing your project plan and briefly state why you
    will probably talk to them so much.
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出三个（按角色或专长）在 FMI 与你执行项目计划时最可能交谈的人，并简要说明你为什么可能这么频繁地与他们交谈。
- en: '**2\.**'
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.'
- en: ''
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose that the product designer has spoken with the management team, and they
    all agree that your statistical application must generate a forecast for all user
    accounts, including ones with extremely sparse data. Priorities have shifted from
    making sure the forecasts are good to making sure that every forecast exists.
    What would you do to address that?
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设产品设计师已经与管理团队交谈过，他们一致认为你的统计应用必须为所有用户账户生成预测，包括那些数据极其稀疏的账户。优先级已经从确保预测是好的转变为确保每个预测都存在。你会如何解决这个问题？
- en: Summary
  id: totrans-1060
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: A project plan can unfold in a number of ways; maintaining an awareness of outcomes
    as they occur can mitigate risk and problems.
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目计划可以以多种方式展开；在结果发生时保持对结果的意识可以减轻风险和问题。
- en: If you’re a software engineer, be careful with statistics.
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一名软件工程师，小心使用统计学。
- en: If you’re a statistician, be careful with software.
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一名统计学家，小心使用软件。
- en: If you’re a member of a team, do your part to make a plan and track its progress.
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是一名团队成员，尽你的一份力来制定计划并跟踪其进展。
- en: Modifying a plan in progress is an option when new, external information becomes
    available, but make modifications deliberately and with care.
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的外部信息可用时，修改正在进行中的计划是一个选项，但应谨慎且故意地进行修改。
- en: Good project results are good because they’re useful in some way, and statistical
    significance might be a part of that.
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀的项目结果之所以好，是因为它们在某种程度上是有用的，统计显著性可能就是其中一部分。
