- en: Chapter 13\. Securing cluster nodes and the network
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第 13 章. 保护集群节点和网络
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the node’s default Linux namespaces in pods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Pod 中使用节点的默认 Linux 命名空间
- en: Running containers as different users
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同用户运行容器
- en: Running privileged containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行特权容器
- en: Adding or dropping a container’s kernel capabilities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或删除容器的内核能力
- en: Defining security policies to limit what pods can do
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义安全策略以限制 Pod 可以做什么
- en: Securing the pod network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Pod 网络
- en: In the previous chapter, we talked about securing the API server. If an attacker
    gets access to the API server, they can run whatever they like by packaging their
    code into a container image and running it in a pod. But can they do any real
    damage? Aren’t containers isolated from other containers and from the node they’re
    running on?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了保护 API 服务器。如果一个攻击者获得了对 API 服务器的访问权限，他们可以通过将他们的代码打包成容器镜像并在 Pod 中运行它来执行任何他们喜欢的事情。但他们能造成真正的损害吗？容器不是与其他容器以及它们运行的节点隔离的吗？
- en: Not necessarily. In this chapter, you’ll learn how to allow pods to access the
    resources of the node they’re running on. You’ll also learn how to configure the
    cluster so users aren’t able to do whatever they want with their pods. Then, in
    the last part of the chapter, you’ll also learn how to secure the network the
    pods use to communicate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定。在本章中，你将学习如何允许 Pod 访问它们运行的节点上的资源。你还将学习如何配置集群，使用户无法随意使用他们的 Pod。然后，在章节的最后部分，你还将学习如何保护
    Pod 用于通信的网络。
- en: 13.1\. Using the host node’s namespaces in a pod
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 13.1\. 在 Pod 中使用主机节点的命名空间
- en: Containers in a pod usually run under separate Linux namespaces, which isolate
    their processes from processes running in other containers or in the node’s default
    namespaces.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 中的容器通常在单独的 Linux 命名空间中运行，这使它们的进程与其他容器或节点默认命名空间中运行的进程隔离。
- en: For example, we learned that each pod gets its own IP and port space, because
    it uses its own network namespace. Likewise, each pod has its own process tree,
    because it has its own PID namespace, and it also uses its own IPC namespace,
    allowing only processes in the same pod to communicate with each other through
    the Inter-Process Communication mechanism (IPC).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们了解到每个 Pod 都有自己的 IP 和端口空间，因为它使用自己的网络命名空间。同样，每个 Pod 都有自己的进程树，因为它有自己的 PID
    命名空间，它还使用自己的 IPC 命名空间，只允许同一 Pod 中的进程通过进程间通信机制（IPC）相互通信。
- en: 13.1.1\. Using the node’s network namespace in a pod
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 13.1.1\. 在 Pod 中使用节点的网络命名空间
- en: Certain pods (usually system pods) need to operate in the host’s default namespaces,
    allowing them to see and manipulate node-level resources and devices. For example,
    a pod may need to use the node’s network adapters instead of its own virtual network
    adapters. This can be achieved by setting the `hostNetwork` property in the pod
    spec to `true`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 Pod（通常是系统 Pod）需要在主机的默认命名空间中运行，这样它们就可以查看和操作节点级别的资源和设备。例如，一个 Pod 可能需要使用节点的网络适配器而不是自己的虚拟网络适配器。这可以通过将
    Pod 规范中的 `hostNetwork` 属性设置为 `true` 来实现。
- en: In that case, the pod gets to use the node’s network interfaces instead of having
    its own set, as shown in [figure 13.1](#filepos1235237). This means the pod doesn’t
    get its own IP address and if it runs a process that binds to a port, the process
    will be bound to the node’s port.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Pod 可以使用节点的网络接口，而不是拥有自己的集合，如图 13.1 所示。这意味着 Pod 没有自己的 IP 地址，如果它运行一个绑定到端口的进程，该进程将绑定到节点的端口。
- en: 'Figure 13.1\. A pod with `hostNetwork: true` uses the node’s network interfaces
    instead of its own.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '图 13.1\. `hostNetwork: true` 的 Pod 使用节点的网络接口而不是自己的。'
- en: '![](images/00184.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00184.jpg)'
- en: You can try running such a pod. The next listing shows an example pod manifest.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试运行这样的 Pod。下面的列表显示了一个示例 Pod 清单。
- en: 'Listing 13.1\. A pod using the node’s network namespace: pod-with-host-network.yaml'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1\. 使用节点网络命名空间的 Pod：pod-with-host-network.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-host-network spec:   hostNetwork:
    true` `1` `containers:   - name: main     image: alpine     command: ["/bin/sleep",
    "999999"]`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-host-network spec:   hostNetwork:
    true` `1` `containers:   - name: main     image: alpine     command: ["/bin/sleep",
    "999999"]`'
- en: 1 Using the host node’s network namespace
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用主机节点的网络命名空间
- en: After you run the pod, you can use the following command to see that it’s indeed
    using the host’s network namespace (it sees all the host’s network adapters, for
    example).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行 Pod 之后，你可以使用以下命令来查看它确实使用了主机的网络命名空间（例如，它可以看到所有主机的网络适配器）。
- en: Listing 13.2\. Network interfaces in a pod using the host’s network namespace
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2\. 使用主机网络命名空间的 pod 中的网络接口
- en: '`$ kubectl exec pod-with-host-network ifconfig` `docker0   Link encap:Ethernet 
    HWaddr 02:42:14:08:23:47           inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
              ...  eth0      Link encap:Ethernet  HWaddr 08:00:27:F8:FA:4E          
    inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0           ...  lo       
    Link encap:Local Loopback           inet addr:127.0.0.1  Mask:255.0.0.0          
    ...  veth1178d4f Link encap:Ethernet  HWaddr 1E:03:8D:D6:E1:2C           inet6
    addr: fe80::1c03:8dff:fed6:e12c/64 Scope:Link           UP BROADCAST RUNNING MULTICAST 
    MTU:1500  Metric:1 ...`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-with-host-network ifconfig` `docker0   链路封装:以太网  硬件地址 02:42:14:08:23:47        
    inet 地址:172.17.0.1  广播:0.0.0.0  子网掩码:255.255.0.0         ...  eth0      链路封装:以太网 
    硬件地址 08:00:27:F8:FA:4E         inet 地址:10.0.2.15  广播:10.0.2.255  子网掩码:255.255.255.0        
    ...  lo        链路封装:本地回环         inet 地址:127.0.0.1  子网掩码:255.0.0.0         ...  veth1178d4f
    链路封装:以太网  硬件地址 1E:03:8D:D6:E1:2C         inet6 地址: fe80::1c03:8dff:fed6:e12c/64
    范围:链路         UP 广播 运行 多播  MTU:1500  度量:1 ...`'
- en: When the Kubernetes Control Plane components are deployed as pods (such as when
    you deploy your cluster with `kubeadm`, as explained in [appendix B](index_split_138.html#filepos1737471)),
    you’ll find that those pods use the `hostNetwork` option, effectively making them
    behave as if they weren’t running inside a pod.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 控制平面组件作为 pod 部署时（例如，当您使用 `kubeadm` 部署您的集群，如附录 B 所解释的那样），您会发现这些
    pod 使用 `hostNetwork` 选项，实际上使它们表现得好像它们没有在 pod 内运行。
- en: 13.1.2\. Binding to a host port without using the host’s network namespace
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 13.1.2\. 不使用主机网络命名空间绑定到主机端口
- en: A related feature allows pods to bind to a port in the node’s default namespace,
    but still have their own network namespace. This is done by using the `hostPort`
    property in one of the container’s ports defined in the `spec.containers.ports`
    field.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的功能允许 pod 绑定到节点默认命名空间中的端口，但仍然有自己的网络命名空间。这是通过在 `spec.containers.ports` 字段中定义的容器端口之一使用
    `hostPort` 属性来实现的。
- en: Don’t confuse pods using `hostPort` with pods exposed through a `NodePort` service.
    They’re two different things, as explained in [figure 13.2](#filepos1238595).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆使用 `hostPort` 的 pod 与通过 `NodePort` 服务暴露的 pod。它们是两件不同的事情，如图 13.2 所解释的那样。
- en: Figure 13.2\. Difference between pods using a `hostPort` and pods behind a `NodePort`
    service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2\. 使用 `hostPort` 的 pod 与位于 `NodePort` 服务后面的 pod 之间的区别。
- en: '![](images/00004.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00004.jpg)'
- en: The first thing you’ll notice in the figure is that when a pod is using a `hostPort`,
    a connection to the node’s port is forwarded directly to the pod running on that
    node, whereas with a `NodePort` service, a connection to the node’s port is forwarded
    to a randomly selected pod (possibly on another node). The other difference is
    that with pods using a `hostPort`, the node’s port is only bound on nodes that
    run such pods, whereas `NodePort` services bind the port on all nodes, even on
    those that don’t run such a pod (as on node 3 in the figure).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，您首先会注意到，当一个 pod 使用 `hostPort` 时，节点端口的连接会直接转发到该节点上运行的 pod，而使用 `NodePort`
    服务时，节点端口的连接会转发到随机选择的 pod（可能在另一个节点上）。另一个区别是，使用 `hostPort` 的 pod，节点端口仅在运行此类 pod
    的节点上绑定，而 `NodePort` 服务将端口绑定到所有节点，即使在那些没有运行此类 pod 的节点上（如图中的节点 3）。
- en: It’s important to understand that if a pod is using a specific host port, only
    one instance of the pod can be scheduled to each node, because two processes can’t
    bind to the same host port. The Scheduler takes this into account when scheduling
    pods, so it doesn’t schedule multiple pods to the same node, as shown in [figure
    13.3](#filepos1240127). If you have three nodes and want to deploy four pod replicas,
    only three will be scheduled (one pod will remain Pending).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，如果一个 pod 使用特定的主机端口，则每个节点只能调度一个 pod 实例，因为两个进程不能绑定到同一个主机端口。调度器在调度 pod
    时会考虑这一点，因此不会将多个 pod 调度到同一个节点，如图 13.3 所示。如果您有三个节点并想部署四个 pod 副本，则只有三个会被调度（一个 pod
    将保持挂起状态）。
- en: Figure 13.3\. If a host port is used, only a single pod instance can be scheduled
    to a node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3\. 如果使用主机端口，则只能将单个 pod 实例调度到节点。
- en: '![](images/00022.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00022.jpg)'
- en: Let’s see how to define the `hostPort` in a pod’s YAML definition. The following
    listing shows the YAML to run your `kubia` pod and bind it to the node’s port
    9000\.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 pod 的 YAML 定义中定义 `hostPort`。以下列表显示了运行您的 `kubia` pod 并将其绑定到节点端口 9000
    的 YAML。
- en: 'Listing 13.3\. Binding a pod to a port in the node’s port space: kubia-hostport.yaml'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3\. 将 pod 绑定到节点端口空间中的端口：kubia-hostport.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: kubia-hostport spec:   containers:
      - image: luksa/kubia     name: kubia     ports:     - containerPort: 8080` `1`
    `hostPort: 9000` `2` `protocol: TCP`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: kubia-hostport spec:   containers:
      - image: luksa/kubia     name: kubia     ports:     - containerPort: 8080` `1`
    `hostPort: 9000` `2` `protocol: TCP`'
- en: 1 The container can be reached on port 8080 of the pod’s IP.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 容器可以通过pod的IP地址的8080端口访问。
- en: 2 It can also be reached on port 9000 of the node it’s deployed on.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它也可以通过其部署的节点的9000端口访问。
- en: After you create this pod, you can access it through port 9000 of the node it’s
    scheduled to. If you have multiple nodes, you’ll see you can’t access the pod
    through that port on the other nodes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建这个pod之后，你可以通过它被调度到的节点的9000端口访问它。如果你有多个节点，你会看到你不能通过其他节点的该端口访问pod。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re trying this on GKE, you need to configure the firewall properly using
    `gcloud compute firewall-rules`, the way you did in [chapter 5](index_split_046.html#filepos469093).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在GKE上尝试此操作，你需要使用`gcloud compute firewall-rules`正确配置防火墙，就像你在第5章中做的那样[章节 5](index_split_046.html#filepos469093)。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `hostPort` feature is primarily used for exposing system services, which
    are deployed to every node using DaemonSets. Initially, people also used it to
    ensure two replicas of the same pod were never scheduled to the same node, but
    now you have a better way of achieving this—it’s explained in [chapter 16](index_split_118.html#filepos1486732).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPort`功能主要用于暴露系统服务，这些服务使用DaemonSets部署到每个节点。最初，人们也用它来确保同一pod的两个副本永远不会调度到同一节点，但现在你有更好的方法来实现这一点——它将在第16章中解释[章节
    16](index_split_118.html#filepos1486732)。'
- en: 13.1.3\. Using the node’s PID and IPC namespaces
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 13.1.3\. 使用节点的PID和IPC命名空间
- en: Similar to the `hostNetwork` option are the `hostPID` and `hostIPC` pod spec
    properties. When you set them to `true`, the pod’s containers will use the node’s
    PID and IPC namespaces, allowing processes running in the containers to see all
    the other processes on the node or communicate with them through IPC, respectively.
    See the following listing for an example.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与`hostNetwork`选项类似的是`hostPID`和`hostIPC` pod规范属性。当你将它们设置为`true`时，pod的容器将使用节点的PID和IPC命名空间，允许在容器中运行的进程看到节点上的所有其他进程或通过IPC与它们通信。以下列表提供了一个示例。
- en: 'Listing 13.4\. Using the host’s PID and IPC namespaces: pod-with-host-pid-and-ipc.yaml'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.4\. 使用主机的PID和IPC命名空间：pod-with-host-pid-and-ipc.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-host-pid-and-ipc spec:
      hostPID: true` `1` `hostIPC: true` `2` `containers:   - name: main     image:
    alpine     command: ["/bin/sleep", "999999"]`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-host-pid-and-ipc spec:
      hostPID: true` `1` `hostIPC: true` `2` `containers:   - name: main     image:
    alpine     command: ["/bin/sleep", "999999"]`'
- en: 1 You want the pod to use the host’s PID namespace.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你希望pod使用主机的PID命名空间。
- en: 2 You also want the pod to use the host’s IPC namespace.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 你还希望pod使用主机的IPC命名空间。
- en: You’ll remember that pods usually see only their own processes, but if you run
    this pod and then list the processes from within its container, you’ll see all
    the processes running on the host node, not only the ones running in the container,
    as shown in the following listing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，pods通常只能看到它们自己的进程，但如果你运行这个pod然后从其容器中列出进程，你会看到在主机节点上运行的所有进程，而不仅仅是容器中运行的进程，如下面的列表所示。
- en: 'Listing 13.5\. Processes visible in a pod with `hostPID: true`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 13.5\. `hostPID: true`的pod中可见的进程'
- en: '`$ kubectl exec pod-with-host-pid-and-ipc ps aux` `PID   USER     TIME   COMMAND
        1 root       0:01 /usr/lib/systemd/systemd --switched-root --system ...    
    2 root       0:00 [kthreadd]     3 root       0:00 [ksoftirqd/0]     5 root      
    0:00 [kworker/0:0H]     6 root       0:00 [kworker/u2:0]     7 root       0:00
    [migration/0]     8 root       0:00 [rcu_bh]     9 root       0:00 [rcu_sched]
       10 root       0:00 [watchdog/0] ...`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-with-host-pid-and-ipc ps aux` `PID   USER     TIME   COMMAND
        1 root       0:01 /usr/lib/systemd/systemd --switched-root --system ...    
    2 root       0:00 [kthreadd]     3 root       0:00 [ksoftirqd/0]     5 root      
    0:00 [kworker/0:0H]     6 root       0:00 [kworker/u2:0]     7 root       0:00
    [migration/0]     8 root       0:00 [rcu_bh]     9 root       0:00 [rcu_sched]
       10 root       0:00 [watchdog/0] ...`'
- en: By setting the `hostIPC` property to `true`, processes in the pod’s containers
    can also communicate with all the other processes running on the node, through
    Inter-Process Communication.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`hostIPC`属性设置为`true`，pod中的容器进程也可以通过进程间通信（Inter-Process Communication）与节点上运行的所有其他进程进行通信。
- en: 13.2\. Configuring the container’s security context
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2\. 配置容器的安全上下文
- en: Besides allowing the pod to use the host’s Linux namespaces, other security-related
    features can also be configured on the pod and its container through the `security-Context`
    properties, which can be specified under the pod spec directly and inside the
    spec of individual containers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许 Pod 使用主机的 Linux 命名空间外，还可以通过 `security-Context` 属性在 Pod 及其容器上配置其他安全相关功能，这些属性可以直接在
    Pod 规范下以及单个容器的规范内部指定。
- en: Understanding what’s configurable in the security context
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 理解安全上下文中可配置的内容
- en: 'Configuring the security context allows you to do various things:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 配置安全上下文允许你执行各种操作：
- en: Specify the user (the user’s ID) under which the process in the container will
    run.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定容器中进程将运行的用户（用户的ID）。
- en: Prevent the container from running as root (the default user a container runs
    as is usually defined in the container image itself, so you may want to prevent
    containers from running as root).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止容器以 root（容器默认运行的默认用户通常在容器镜像本身中定义，因此你可能希望防止容器以 root 运行）运行。
- en: Run the container in privileged mode, giving it full access to the node’s kernel.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以特权模式运行容器，使其能够完全访问节点的内核。
- en: Configure fine-grained privileges, by adding or dropping capabilities—in contrast
    to giving the container all possible permissions by running it in privileged mode.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加或删除能力来配置细粒度的权限，这与在特权模式下运行容器以授予所有可能的权限形成对比。
- en: Set SELinux (Security Enhanced Linux) options to strongly lock down a container.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 SELinux（安全增强型 Linux）选项设置为强锁定容器。
- en: Prevent the process from writing to the container’s filesystem.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止进程向容器的文件系统写入。
- en: We’ll explore these options next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探讨这些选项。
- en: Running a pod without specifying a security context
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不指定安全上下文运行 Pod
- en: 'First, run a pod with the default security context options (by not specifying
    them at all), so you can see how it behaves compared to pods with a custom security
    context:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行具有默认安全上下文选项的 Pod（通过完全不指定它们），这样你可以看到它与具有自定义安全上下文的 Pod 的行为有何不同：
- en: '`$ kubectl run pod-with-defaults --image alpine --restart Never`![](images/00006.jpg)`--
    /bin/sleep 999999` `pod "pod-with-defaults" created`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl run pod-with-defaults --image alpine --restart Never`![](images/00006.jpg)`--
    /bin/sleep 999999` `pod "pod-with-defaults" created`'
- en: 'Let’s see what user and group ID the container is running as, and which groups
    it belongs to. You can see this by running the `id` command inside the container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看容器运行的用户和组ID，以及它属于哪些组。你可以通过在容器内部运行 `id` 命令来查看：
- en: '`$ kubectl exec pod-with-defaults id` `uid=0(root) gid=0(root) groups=0(root),
    1(bin), 2(daemon), 3(sys), 4(adm), 6(disk), 10(wheel), 11(floppy), 20(dialout),
    26(tape), 27(video)`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-with-defaults id` `uid=0(root) gid=0(root) groups=0(root),
    1(bin), 2(daemon), 3(sys), 4(adm), 6(disk), 10(wheel), 11(floppy), 20(dialout),
    26(tape), 27(video)`'
- en: The container is running as user ID (`uid`) `0`, which is `root`, and group
    ID (`gid`) `0` (also `root`). It’s also a member of multiple other groups.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器以用户ID (`uid`) `0` 运行，即 `root`，并且以组ID (`gid`) `0`（也是 `root`）运行。它也是多个其他组的成员。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: What user the container runs as is specified in the container image. In a Dockerfile,
    this is done using the `USER` directive. If omitted, the container runs as root.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行的用户由容器镜像指定。在 Dockerfile 中，这是通过使用 `USER` 指令来完成的。如果省略，容器将以 root 运行。
- en: '|  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now, you’ll run a pod where the container runs as a different user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将运行一个容器以不同用户运行的 Pod。
- en: 13.2.1\. Running a container as a specific user
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.1\. 以特定用户运行容器
- en: To run a pod under a different user ID than the one that’s baked into the container
    image, you’ll need to set the pod’s `securityContext.runAsUser` property. You’ll
    make the container run as user `guest`, whose user ID in the alpine container
    image is `405`, as shown in the following listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同于容器镜像中内置的用户ID下运行 Pod，你需要设置 Pod 的 `securityContext.runAsUser` 属性。你将使容器以用户
    `guest` 运行，其用户ID在 alpine 容器镜像中为 `405`，如下所示。
- en: 'Listing 13.6\. Running containers as a specific user: pod-as-user-guest.yaml'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6\. 以特定用户运行容器：pod-as-user-guest.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-as-user-guest spec:   containers:
      - name: main     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:
          runAsUser: 405` `1`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-as-user-guest spec:   containers:
      - name: main     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:
          runAsUser: 405` `1`'
- en: 1 You need to specify a user ID, not a username (id 405 corresponds to the guest
    user).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你需要指定用户ID，而不是用户名（ID 405 对应于 guest 用户）。
- en: 'Now, to see the effect of the `runAsUser` property, run the `id` command in
    this new pod, the way you did before:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到 `runAsUser` 属性的效果，像之前一样在这个新 pod 中运行 `id` 命令：
- en: '`$ kubectl exec pod-as-user-guest id` `uid=405(guest) gid=100(users)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-as-user-guest id` `uid=405(guest) gid=100(users)`'
- en: As requested, the container is running as the `guest` user.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如请求，容器正在以 `guest` 用户运行。
- en: 13.2.2\. Preventing a container from running as root
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.2\. 防止容器以 root 用户运行
- en: What if you don’t care what user the container runs as, but you still want to
    prevent it from running as root?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎容器运行的用户是谁，但仍然想防止它以 root 用户运行，会怎样？
- en: Imagine having a pod deployed with a container image that was built with a `USER
    daemon` directive in the Dockerfile, which makes the container run under the `daemon`
    user. What if an attacker gets access to your image registry and pushes a different
    image under the same tag? The attacker’s image is configured to run as the root
    user. When Kubernetes schedules a new instance of your pod, the Kubelet will download
    the attacker’s image and run whatever code they put into it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，部署了一个使用 Dockerfile 中的 `USER daemon` 指令构建的容器镜像，该指令使得容器以 `daemon` 用户运行。如果攻击者获取了对你的镜像仓库的访问权限，并在相同的标签下推送了不同的镜像，会怎样？攻击者的镜像被配置为以
    root 用户运行。当 Kubernetes 调度你的 pod 的新实例时，Kubelet 将下载攻击者的镜像并运行其中放入的任何代码。
- en: Although containers are mostly isolated from the host system, running their
    processes as root is still considered a bad practice. For example, when a host
    directory is mounted into the container, if the process running in the container
    is running as root, it has full access to the mounted directory, whereas if it’s
    running as non-root, it won’t.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器大多数情况下与主机系统隔离，但以 root 用户运行它们的进程仍然被认为是一种不良做法。例如，当主机目录被挂载到容器中时，如果容器中运行的过程是以
    root 运行的，它将完全访问挂载的目录，而如果它是以非 root 运行的，则不会。
- en: To prevent the attack scenario described previously, you can specify that the
    pod’s container needs to run as a non-root user, as shown in the following listing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止之前描述的攻击场景，你可以指定 pod 的容器需要以非 root 用户运行，如下面的列表所示。
- en: 'Listing 13.7\. Preventing containers from running as root: pod-run-as-non-root.yaml'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7\. 防止容器以 root 用户运行：pod-run-as-non-root.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-run-as-non-root spec:   containers:
      - name: main     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:`
    `1` `runAsNonRoot: true` `1`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata: name: pod-run-as-non-root spec: containers:
    - name: main image: alpine command: ["/bin/sleep", "999999"] securityContext:
    runAsNonRoot: true`'
- en: 1 This container will only be allowed to run as a non-root user.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这个容器只允许以非 root 用户运行。
- en: 'If you deploy this pod, it gets scheduled, but is not allowed to run:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你部署了这个 pod，它会被调度，但不会被允许运行：
- en: '`$ kubectl get po pod-run-as-non-root` `NAME                 READY  STATUS
    pod-run-as-non-root  0/1    container has runAsNonRoot and image will run` ![](images/00006.jpg)` 
    as root`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po pod-run-as-non-root` `NAME                 READY  STATUS
    pod-run-as-non-root  0/1    container has runAsNonRoot and image will run` ![images/00006.jpg](images/00006.jpg)
    as root`'
- en: Now, if anyone tampers with your container images, they won’t get far.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人篡改你的容器镜像，他们也不会走得太远。
- en: 13.2.3\. Running pods in privileged mode
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.3\. 以特权模式运行 pod
- en: Sometimes pods need to do everything that the node they’re running on can do,
    such as use protected system devices or other kernel features, which aren’t accessible
    to regular containers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 pod 需要做它在运行的节点上能做的一切，比如使用受保护的系统设备或其他内核功能，这些功能对常规容器是不可访问的。
- en: An example of such a pod is the kube-proxy pod, which needs to modify the node’s
    `iptables` rules to make services work, as was explained in [chapter 11](index_split_087.html#filepos1036287).
    If you follow the instructions in [appendix B](index_split_138.html#filepos1737471)
    and deploy a cluster with `kubeadm`, you’ll see every cluster node runs a kube-proxy
    pod and you can examine its YAML specification to see all the special features
    it’s using.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 pod 的一个例子是 kube-proxy pod，它需要修改节点的 `iptables` 规则以使服务工作，正如在第 11 章中解释的那样。[第
    11 章](index_split_087.html#filepos1036287)。如果你遵循附录 B 中的说明并使用 `kubeadm` 部署集群，你会看到每个集群节点都运行一个
    kube-proxy pod，你可以检查其 YAML 规范以查看它使用的所有特殊功能。
- en: To get full access to the node’s kernel, the pod’s container runs in privileged
    mode. This is achieved by setting the `privileged` property in the container’s
    `security-Context` property to `true`. You’ll create a privileged pod from the
    YAML in the following listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全访问节点的内核，pod 的容器以特权模式运行。这是通过将容器 `security-Context` 属性中的 `privileged` 属性设置为
    `true` 来实现的。您将从以下列表中的 YAML 创建一个特权 pod。
- en: 'Listing 13.8\. A pod with a privileged container: pod-privileged.yaml'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.8\. 带有特权容器的 pod：pod-privileged.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-privileged spec:   containers:
      - name: main     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:
          privileged: true` `1`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-privileged spec:   containers:
      - name: main     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:
          privileged: true` `1`'
- en: 1 This container will run in privileged mode
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此容器将以特权模式运行
- en: Go ahead and deploy this pod, so you can compare it with the non-privileged
    pod you ran earlier.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 继续部署此 pod，以便您可以将其与您之前运行的非特权 pod 进行比较。
- en: If you’re familiar with Linux, you may know it has a special file directory
    called /dev, which contains device files for all the devices on the system. These
    aren’t regular files on disk, but are special files used to communicate with devices.
    Let’s see what devices are visible in the non-privileged container you deployed
    earlier (the `pod-with-defaults` pod), by listing files in its /dev directory,
    as shown in the following listing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉 Linux，您可能知道它有一个特殊的文件目录，称为 /dev，其中包含系统上所有设备的设备文件。这些不是磁盘上的常规文件，而是用于与设备通信的特殊文件。让我们看看您之前部署的非特权容器（`pod-with-defaults`
    pod）中可见的设备，如下所示，通过列出其 /dev 目录中的文件。
- en: Listing 13.9\. List of available devices in a non-privileged pod
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9\. 非特权 pod 中可用的设备列表
- en: '`$ kubectl exec -it pod-with-defaults ls /dev` `core             null            
    stderr           urandom fd               ptmx             stdin            zero
    full             pts              stdout fuse             random           termination-log
    mqueue           shm              tty`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-with-defaults ls /dev` `core             null            
    stderr           urandom fd               ptmx             stdin            zero
    full             pts              stdout fuse             random           termination-log
    mqueue           shm              tty`'
- en: The listing shows all the devices. The list is fairly short. Now, compare this
    with the following listing, which shows the device files your privileged pod can
    see.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示了所有设备。列表相当短。现在，将此与以下列表进行比较，该列表显示了您的特权 pod 可以看到的设备文件。
- en: Listing 13.10\. List of available devices in a privileged pod
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.10\. 特权 pod 中可用的设备列表
- en: '`$ kubectl exec -it pod-privileged ls /dev` `autofs              snd                
    tty46 bsg                 sr0                 tty47 btrfs-control       stderr             
    tty48 core                stdin               tty49 cpu                 stdout             
    tty5 cpu_dma_latency     termination-log     tty50 fd                  tty                
    tty51 full                tty0                tty52 fuse                tty1               
    tty53 hpet                tty10               tty54 hwrng               tty11              
    tty55 ...                 ...                 ...`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-privileged ls /dev` `autofs              snd                
    tty46 bsg                 sr0                 tty47 btrfs-control       stderr             
    tty48 core                stdin               tty49 cpu                 stdout             
    tty5 cpu_dma_latency     termination-log     tty50 fd                  tty                
    tty51 ...                 ...                 ...`'
- en: I haven’t included the whole list, because it’s too long for the book, but it’s
    evident that the device list is much longer than before. In fact, the privileged
    container sees all the host node’s devices. This means it can use any device freely.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有包括整个列表，因为列表太长，不适合本书，但很明显，设备列表比之前长得多。实际上，特权容器可以看到宿主节点上的所有设备。这意味着它可以自由使用任何设备。
- en: For example, I had to use privileged mode like this when I wanted a pod running
    on a Raspberry Pi to control LEDs connected it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我想要在运行在树莓派上的 pod 中控制连接到它的 LED 时，我必须使用类似这样的特权模式。
- en: 13.2.4\. Adding individual kernel capabilities to a container
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.4\. 向容器添加单个内核功能
- en: In the previous section, you saw one way of giving a container unlimited power.
    In the old days, traditional UNIX implementations only distinguished between privileged
    and unprivileged processes, but for many years, Linux has supported a much more
    fine-grained permission system through kernel capabilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您看到了赋予容器无限权力的方法之一。在过去的岁月里，传统的 UNIX 实现只区分特权和非特权进程，但多年来，Linux 通过内核能力支持了一个更细粒度的权限系统。
- en: Instead of making a container privileged and giving it unlimited permissions,
    a much safer method (from a security perspective) is to give it access only to
    the kernel features it really requires. Kubernetes allows you to add capabilities
    to each container or drop part of them, which allows you to fine-tune the container’s
    permissions and limit the impact of a potential intrusion by an attacker.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与将容器设置为特权并赋予它无限权限相比，一种更安全的方法（从安全角度考虑）是只给它提供它真正需要的内核功能访问权限。Kubernetes 允许您为每个容器添加能力或删除其中的一部分，这允许您微调容器的权限并限制攻击者潜在入侵的影响。
- en: 'For example, a container usually isn’t allowed to change the system time (the
    hardware clock’s time). You can confirm this by trying to set the time in your
    `pod-with-defaults` pod:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，容器通常不允许更改系统时间（硬件时钟的时间）。您可以通过尝试在您的 `pod-with-defaults` pod 中设置时间来确认这一点：
- en: '`$ kubectl exec -it pod-with-defaults -- date +%T -s "12:00:00"` `date: can''t
    set date: Operation not permitted`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-with-defaults -- date +%T -s "12:00:00"` `date: can''t
    set date: Operation not permitted`'
- en: If you want to allow the container to change the system time, you can `add`
    a capability called `CAP_SYS_TIME` to the container’s `capabilities` list, as
    shown in the following listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想允许容器更改系统时间，您可以将名为 `CAP_SYS_TIME` 的能力添加到容器的 `capabilities` 列表中，如下所示。
- en: 'Listing 13.11\. Adding the `CAP_SYS_TIME` capability: pod-add-settime-capability.yaml'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.11 添加 `CAP_SYS_TIME` 能力：pod-add-settime-capability.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-add-settime-capability spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:` `1` `capabilities:` `1` `add:` `2` `- SYS_TIME` `2`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-add-settime-capability spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:` `1` `capabilities:` `1` `add:` `2` `- SYS_TIME` `2`'
- en: 1 Capabilities are added or dropped under the securityContext property.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 能力是在 securityContext 属性下添加或删除的。
- en: 2 You’re adding the SYS_TIME capability.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 您正在添加 SYS_TIME 能力。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Linux kernel capabilities are usually prefixed with `CAP_.` But when specifying
    them in a pod spec, you must leave out the prefix.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核能力通常以 `CAP_.` 为前缀。但在 pod 规范中指定它们时，必须省略前缀。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you run the same command in this new pod’s container, the system time is
    changed successfully:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这个新 pod 的容器中运行相同的命令，系统时间将成功更改：
- en: '`$ kubectl exec -it pod-add-settime-capability -- date +%T -s "12:00:00"` `12:00:00`
    `$ kubectl exec -it pod-add-settime-capability -- date` `Sun May  7 12:00:03 UTC
    2017`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-add-settime-capability -- date +%T -s "12:00:00"` `12:00:00`
    `$ kubectl exec -it pod-add-settime-capability -- date` `Sun May  7 12:00:03 UTC
    2017`'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If you try this yourself, be aware that it may cause your worker node to become
    unusable. In Minikube, although the system time was automatically reset back by
    the Network Time Protocol (NTP) daemon, I had to reboot the VM to schedule new
    pods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您亲自尝试，请注意这可能会使您的工作节点变得不可用。在 Minikube 中，尽管系统时间被网络时间协议（NTP）守护进程自动重置，但我不得不重新启动虚拟机来调度新的
    pod。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can confirm the node’s time has been changed by checking the time on the
    node running the pod. In my case, I’m using Minikube, so I have only one node
    and I can get its time like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查运行 pod 的节点上的时间来确认节点的时间已更改。在我的情况下，我使用 Minikube，所以我只有一个节点，我可以这样获取它的时间：
- en: '`$ minikube ssh date` `Sun May  7 12:00:07 UTC 2017`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube ssh date` `Sun May  7 12:00:07 UTC 2017`'
- en: 'Adding capabilities like this is a much better way than giving a container
    full privileges with `privileged: true`. Admittedly, it does require you to know
    and understand what each capability does.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '以这种方式添加能力比使用 `privileged: true` 给容器赋予全部权限要好得多。诚然，这需要您了解并理解每个能力的作用。'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You’ll find the list of Linux kernel capabilities in the Linux man pages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Linux man 页面中找到 Linux 内核能力的列表。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.2.5\. Dropping capabilities from a container
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.5 从容器中删除能力
- en: You’ve seen how to add capabilities, but you can also drop capabilities that
    may otherwise be available to the container. For example, the default capabilities
    given to a container include the `CAP_CHOWN` capability, which allows processes
    to change the ownership of files in the filesystem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何添加能力，但你也可以移除容器可能拥有的能力。例如，默认授予容器的能力包括`CAP_CHOWN`能力，它允许进程更改文件系统中的文件所有权。
- en: 'You can see that’s the case by changing the ownership of the /tmp directory
    in your `pod-with-defaults` pod to the `guest` user, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`pod-with-defaults` pod中的/tmp目录的所有权更改为`guest`用户来验证这一点，例如：
- en: '`$ kubectl exec pod-with-defaults chown guest /tmp``$ kubectl exec pod-with-defaults
    -- ls -la / | grep tmp` `drwxrwxrwt    2 guest    root             6 May 25 15:18
    tmp`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-with-defaults chown guest /tmp``$ kubectl exec pod-with-defaults
    -- ls -la / | grep tmp` `drwxrwxrwt    2 guest    root             6 May 25 15:18
    tmp`'
- en: To prevent the container from doing that, you need to drop the capability by
    listing it under the container’s `securityContext.capabilities.drop` property,
    as shown in the following listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止容器执行此操作，你需要通过在容器的`securityContext.capabilities.drop`属性下列出它来移除能力，如下面的列表所示。
- en: 'Listing 13.12\. Dropping a capability from a container: pod-drop-chown-capability.yaml'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.12\. 从容器中移除能力：pod-drop-chown-capability.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-drop-chown-capability spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:       capabilities:         drop:` `1` `- CHOWN` `1`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-drop-chown-capability spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:       capabilities:         drop:` `1` `- CHOWN` `1`'
- en: 1 You’re not allowing this container to change file ownership.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 你没有允许这个容器更改文件所有权。
- en: 'By dropping the `CHOWN` capability, you’re not allowed to change the owner
    of the /tmp directory in this pod:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除`CHOWN`能力，你将不允许在这个pod中更改/tmp目录的所有权：
- en: '`$ kubectl exec pod-drop-chown-capability chown guest /tmp` `chown: /tmp: Operation
    not permitted`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec pod-drop-chown-capability chown guest /tmp` `chown: /tmp: Operation
    not permitted`'
- en: You’re almost done exploring the container’s security context options. Let’s
    look at one more.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎完成了对容器安全上下文选项的探索。让我们再看一个。
- en: 13.2.6\. Preventing processes from writing to the container’s filesystem
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.6\. 防止进程向容器的文件系统写入
- en: You may want to prevent the processes running in the container from writing
    to the container’s filesystem, and only allow them to write to mounted volumes.
    You’d want to do that mostly for security reasons.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望防止在容器中运行的进程向容器的文件系统写入，而只允许它们写入挂载的卷。你主要会出于安全原因这样做。
- en: Let’s imagine you’re running a PHP application with a hidden vulnerability,
    allowing an attacker to write to the filesystem. The PHP files are added to the
    container image at build time and are served from the container’s filesystem.
    Because of the vulnerability, the attacker can modify those files and inject them
    with malicious code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你正在运行一个具有隐藏漏洞的PHP应用程序，这个漏洞允许攻击者向文件系统写入。PHP文件在构建时被添加到容器镜像中，并从容器的文件系统中提供服务。由于这个漏洞，攻击者可以修改这些文件并向其中注入恶意代码。
- en: These types of attacks can be thwarted by preventing the container from writing
    to its filesystem, where the app’s executable code is normally stored. This is
    done by setting the container’s `securityContext.readOnlyRootFilesystem` property
    to `true`, as shown in the following listing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的攻击可以通过防止容器向其文件系统写入来阻止，通常应用程序的可执行代码存储在该文件系统中。这是通过将容器的`securityContext.readOnlyRootFilesystem`属性设置为`true`来实现的，如下面的列表所示。
- en: 'Listing 13.13\. A container with a read-only filesystem: pod-with-readonly-filesystem.yaml'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.13\. 具有只读文件系统的容器：pod-with-readonly-filesystem.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-readonly-filesystem spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:` `1` `readOnlyRootFilesystem: true` `1` `volumeMounts:` `2`
    `- name: my-volume` `2` `mountPath: /volume` `2` `readOnly: false` `2` `volumes:
      - name: my-volume     emptyDir:`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-readonly-filesystem spec:
      containers:   - name: main     image: alpine     command: ["/bin/sleep", "999999"]
        securityContext:` `1` `readOnlyRootFilesystem: true` `1` `volumeMounts:` `2`
    `- name: my-volume` `2` `mountPath: /volume` `2` `readOnly: false` `2` `volumes:
      - name: my-volume     emptyDir:`'
- en: 1 This container’s filesystem can’t be written to...
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这个容器的文件系统无法写入...
- en: 2 ...but writing to /volume is allowed, becase a volume is mounted there.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 ...但是写入/volume是被允许的，因为在那里挂载了一个卷。
- en: 'When you deploy this pod, the container is running as root, which has write
    permissions to the `/` directory, but trying to write a file there fails:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你部署这个Pod时，容器以root用户身份运行，对`/`目录有写权限，但尝试在那里写入文件会失败：
- en: '`$ kubectl exec -it pod-with-readonly-filesystem touch /new-file` `touch: /new-file:
    Read-only file system`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-with-readonly-filesystem touch /new-file` `touch: /new-file:
    Read-only file system`'
- en: 'On the other hand, writing to the mounted volume is allowed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，写入挂载的卷是允许的：
- en: '`$ kubectl exec -it pod-with-readonly-filesystem touch /volume/newfile``$ kubectl
    exec -it pod-with-readonly-filesystem -- ls -la /volume/newfile` `-rw-r--r--   
    1 root     root       0 May  7 19:11 /mountedVolume/newfile`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-with-readonly-filesystem touch /volume/newfile``$ kubectl
    exec -it pod-with-readonly-filesystem -- ls -la /volume/newfile` `-rw-r--r--   
    1 root     root       0 May  7 19:11 /mountedVolume/newfile`'
- en: As shown in the example, when you make the container’s filesystem read-only,
    you’ll probably want to mount a volume in every directory the application writes
    to (for example, logs, on-disk caches, and so on).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，当你将容器的文件系统设置为只读时，你可能希望在每个应用程序写入的目录中挂载一个卷（例如，日志、磁盘缓存等）。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To increase security, when running pods in production, set their container’s
    `readOnlyRootFilesystem` property to `true`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高安全性，在生产环境中运行Pod时，将它们的容器`readOnlyRootFilesystem`属性设置为`true`。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Setting security context options at the pod level
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod级别设置安全上下文选项
- en: In all these examples, you’ve set the security context of an individual container.
    Several of these options can also be set at the pod level (through the `pod.spec.security-Context`
    property). They serve as a default for all the pod’s containers but can be overridden
    at the container level. The pod-level security context also allows you to set
    additional properties, which we’ll explain next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子中，你都设置了单个容器的安全上下文。这些选项中的几个也可以在Pod级别设置（通过`pod.spec.security-Context`属性）。它们作为Pod中所有容器的默认值，但可以在容器级别被覆盖。Pod级别的安全上下文还允许你设置额外的属性，我们将在下一节中解释。
- en: 13.2.7\. Sharing volumes when containers run as different users
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 13.2.7. 当容器以不同用户运行时共享卷
- en: In [chapter 6](index_split_055.html#filepos588298), we explained how volumes
    are used to share data between the pod’s containers. You had no trouble writing
    files in one container and reading them in the other.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](index_split_055.html#filepos588298)中，我们解释了如何使用卷在Pod的容器之间共享数据。你在一个容器中写入文件并在另一个容器中读取它们时没有遇到任何麻烦。
- en: But this was only because both containers were running as root, giving them
    full access to all the files in the volume. Now imagine using the `runAsUser`
    option we explained earlier. You may need to run the two containers as two different
    users (perhaps you’re using two third-party container images, where each one runs
    its process under its own specific user). If those two containers use a volume
    to share files, they may not necessarily be able to read or write files of one
    another.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仅仅是因为两个容器都以root用户身份运行，从而能够访问卷中的所有文件。现在想象一下使用我们之前解释的`runAsUser`选项。你可能需要以两个不同的用户运行这两个容器（也许你正在使用两个第三方容器镜像，每个镜像在其自己的特定用户下运行其进程）。如果这两个容器使用卷来共享文件，它们可能不一定能够读取或写入对方的文件。
- en: 'That’s why Kubernetes allows you to specify supplemental groups for all the
    pods running in the container, allowing them to share files, regardless of the
    user IDs they’re running as. This is done using the following two properties:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Kubernetes允许你为在容器中运行的所有Pod指定补充组，无论它们以什么用户ID运行，都可以共享文件。这是通过以下两个属性完成的：
- en: '`fsGroup`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsGroup`'
- en: '`supplementalGroups`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supplementalGroups`'
- en: What they do is best explained in an example, so let’s see how to use them in
    a pod and then see what their effect is. The next listing describes a pod with
    two containers sharing the same volume.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所做的事情最好通过一个例子来解释，所以让我们看看如何在Pod中使用它们，然后看看它们的效果。接下来的列表描述了一个包含两个容器共享相同空间的Pod。
- en: 'Listing 13.14\. `fsGroup` & `supplementalGroups`: pod-with-shared-volume-fsgroup.yaml'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '列表13.14. `fsGroup` & `supplementalGroups`: pod-with-shared-volume-fsgroup.yaml'
- en: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-shared-volume-fsgroup
    spec:   securityContext:` `1` `fsGroup: 555` `1` `supplementalGroups: [666, 777]`
    `1` `containers:   - name: first     image: alpine     command: ["/bin/sleep",
    "999999"]     securityContext:` `2` `runAsUser: 1111` `2` `volumeMounts:` `3`
    `- name: shared-volume` `3` `mountPath: /volume       readOnly: false   - name:
    second     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:`
    `4` `runAsUser: 2222` `4` `volumeMounts:` `3` `- name: shared-volume` `3` `mountPath:
    /volume       readOnly: false   volumes:` `3` `- name: shared-volume` `3` `emptyDir:`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: pod-with-shared-volume-fsgroup
    spec:   securityContext:` `1` `fsGroup: 555` `1` `supplementalGroups: [666, 777]`
    `1` `containers:   - name: first     image: alpine     command: ["/bin/sleep",
    "999999"]     securityContext:` `2` `runAsUser: 1111` `2` `volumeMounts:` `3`
    `- name: shared-volume` `3` `mountPath: /volume       readOnly: false   - name:
    second     image: alpine     command: ["/bin/sleep", "999999"]     securityContext:`
    `4` `runAsUser: 2222` `4` `volumeMounts:` `3` `- name: shared-volume` `3` `mountPath:
    /volume       readOnly: false   volumes:` `3` `- name: shared-volume` `3` `emptyDir:`'
- en: 1 The fsGroup and supplementalGroups are defined in the security context at
    the pod level.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 fsGroup 和 supplementalGroups 在 Pod 级别的安全上下文中定义。
- en: 2 The first container runs as user ID 1111.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 第一个容器以用户ID 1111 运行。
- en: 3 Both containers use the same volume
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 两个容器使用相同的卷
- en: 4 The second container runs as user ID 2222.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 第二个容器以用户ID 2222 运行。
- en: 'After you create this pod, run a shell in its first container and see what
    user and group IDs the container is running as:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此Pod之后，在其第一个容器中运行一个shell，查看容器运行时的用户和组ID：
- en: '`$ kubectl exec -it pod-with-shared-volume-fsgroup -c first sh``/ $ id` `uid=1111
    gid=0(root) groups=555,666,777`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it pod-with-shared-volume-fsgroup -c first sh``/ $ id` `uid=1111
    gid=0(root) groups=555,666,777`'
- en: The `id` command shows the container is running with user ID `1111`, as specified
    in the pod definition. The effective group ID is `0(root)`, but group IDs `555`,
    `666`, and `777` are also associated with the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 命令显示容器正在以用户ID `1111` 运行，正如Pod定义中所指定。实际组ID是 `0(root)`，但组ID `555`、`666`
    和 `777` 也与用户相关联。'
- en: 'In the pod definition, you set `fsGroup` to `555`. Because of this, the mounted
    volume will be owned by group ID `555`, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod定义中，您将 `fsGroup` 设置为 `555`。因此，挂载的卷将由组ID `555` 拥有，如下所示：
- en: '`/ $ ls -l / | grep volume` `drwxrwsrwx    2 root     555              6 May
    29 12:23 volume`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ $ ls -l / | grep volume` `drwxrwsrwx    2 root     555              6 May
    29 12:23 volume`'
- en: 'If you create a file in the mounted volume’s directory, the file is owned by
    user ID `1111` (that’s the user ID the container is running as) and by group ID
    `555`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在挂载卷的目录中创建文件，该文件将由用户ID `1111`（这是容器运行时的用户ID）和组ID `555` 所拥有：
- en: '`/ $ echo foo > /volume/foo``/ $ ls -l /volume` `total 4 -rw-r--r--    1` `1111    
    555``              4 May 29 12:25 foo`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ $ echo foo > /volume/foo``/ $ ls -l /volume` `total 4 -rw-r--r--    1` `1111    
    555``              4 May 29 12:25 foo`'
- en: 'This is different from how ownership is otherwise set up for newly created
    files. Usually, the user’s effective group ID, which is `0` in your case, is used
    when a user creates files. You can see this by creating a file in the container’s
    filesystem instead of in the volume:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这与为新创建的文件设置所有权的常规方式不同。通常，用户的实际组ID（在你的情况下是`0`）在用户创建文件时使用。您可以通过在容器的文件系统中创建文件而不是在卷中创建文件来查看这一点：
- en: '`/ $ echo foo > /tmp/foo``/ $ ls -l /tmp` `total 4 -rw-r--r--    1 1111` `root``            
    4 May 29 12:41 foo`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ $ echo foo > /tmp/foo``/ $ ls -l /tmp` `total 4 -rw-r--r--    1 1111` `root``            
    4 May 29 12:41 foo`'
- en: As you can see, the `fsGroup` security context property is used when the process
    creates files in a volume (but this depends on the volume plugin used), whereas
    the `supplementalGroups` property defines a list of additional group IDs the user
    is associated with.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当进程在卷中创建文件时使用`fsGroup`安全上下文属性（但这取决于所使用的卷插件），而`supplementalGroups`属性定义了与用户关联的附加组ID列表。
- en: This concludes this section about the configuration of the container’s security
    context. Next, we’ll see how a cluster administrator can restrict users from doing
    so.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分关于容器安全上下文配置的内容到此结束。接下来，我们将看到集群管理员如何限制用户进行此类操作。
- en: 13.3\. Restricting the use of security-related features in pods
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3. 限制 Pod 中安全相关功能的用法
- en: The examples in the previous sections have shown how a person deploying pods
    can do whatever they want on any cluster node, by deploying a privileged pod to
    the node, for example. Obviously, a mechanism must prevent users from doing part
    or all of what’s been explained. The cluster admin can restrict the use of the
    previously described security-related features by creating one or more PodSecurityPolicy
    resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的示例展示了部署 pod 的人如何通过在节点上部署一个特权 pod 等方式，在任意集群节点上做他们想做的事情。显然，必须有一种机制来防止用户执行所解释的部分或全部操作。集群管理员可以通过创建一个或多个
    PodSecurityPolicy 资源来限制之前描述的安全相关功能的使用。
- en: 13.3.1\. Introducing the PodSecurityPolicy resource
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3.1. PodSecurityPolicy 资源介绍
- en: PodSecurityPolicy is a cluster-level (non-namespaced) resource, which defines
    what security-related features users can or can’t use in their pods. The job of
    upholding the policies configured in PodSecurityPolicy resources is performed
    by the PodSecurity-Policy admission control plugin running in the API server (we
    explained admission control plugins in [chapter 11](index_split_087.html#filepos1036287)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy 是一个集群级别的（非命名空间）资源，它定义了用户可以在他们的 pod 中使用或不能使用的与安全相关的功能。维护 PodSecurityPolicy
    资源中配置的策略的任务由运行在 API 服务器上的 PodSecurity-Policy 接受控制插件执行（我们在第 11 章中解释了接受控制插件[章节 11](index_split_087.html#filepos1036287)）。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The PodSecurityPolicy admission control plugin may not be enabled in your cluster.
    Before running the following examples, ensure it’s enabled. If you’re using Minikube,
    refer to the next sidebar.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy 接受控制插件可能未在您的集群中启用。在运行以下示例之前，请确保它已启用。如果您使用 Minikube，请参考下一侧边栏。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When someone posts a pod resource to the API server, the PodSecurityPolicy admission
    control plugin validates the pod definition against the configured PodSecurityPolicies.
    If the pod conforms to the cluster’s policies, it’s accepted and stored into etcd;
    otherwise it’s rejected immediately. The plugin may also modify the pod resource
    according to defaults configured in the policy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人将 pod 资源发布到 API 服务器时，PodSecurityPolicy 接受控制插件会根据配置的 PodSecurityPolicies 验证
    pod 定义。如果 pod 符合集群的策略，它将被接受并存储到 etcd 中；否则，它将被立即拒绝。插件还可以根据策略中配置的默认值修改 pod 资源。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Enabling RBAC and PodSecurityPolicy admission control in Minikube
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Minikube 中启用 RBAC 和 PodSecurityPolicy 接受控制
- en: I’m using Minikube version v0.19.0 to run these examples. That version doesn’t
    enable either the PodSecurityPolicy admission control plugin or RBAC authorization,
    which is required in part of the exercises. One exercise also requires authenticating
    as a different user, so you’ll also need to enable the basic authentication plugin
    where users are defined in a file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Minikube 版本 v0.19.0 来运行这些示例。该版本既没有启用 PodSecurityPolicy 接受控制插件，也没有启用 RBAC
    授权，这在部分练习中是必需的。一项练习还需要以不同的用户身份进行身份验证，因此您还需要在定义在文件中的用户处启用基本身份验证插件。
- en: 'To run Minikube with all these plugins enabled, you may need to use this (or
    a similar) command, depending on the version you’re using:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行所有这些插件都启用的 Minikube，您可能需要使用此（或类似）命令，具体取决于您使用的版本：
- en: '`$ minikube start --extra-config apiserver.Authentication.PasswordFile.` ![](images/00006.jpg)
    `BasicAuthFile=/etc/kubernetes/passwd --extra-config=apiserver.` ![](images/00006.jpg)
    `Authorization.Mode=RBAC --extra-config=apiserver.GenericServerRun` ![](images/00006.jpg)
    `Options.AdmissionControl=NamespaceLifecycle,LimitRanger,Service` ![](images/00006.jpg)
    `Account,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,` ![](images/00006.jpg)
    `DefaultTolerationSeconds,PodSecurityPolicy`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube start --extra-config apiserver.Authentication.PasswordFile.` ![图片
    6](images/00006.jpg) `BasicAuthFile=/etc/kubernetes/passwd --extra-config=apiserver.`
    ![图片 6](images/00006.jpg) `Authorization.Mode=RBAC --extra-config=apiserver.GenericServerRun`
    ![图片 6](images/00006.jpg) `Options.AdmissionControl=NamespaceLifecycle,LimitRanger,Service`
    ![图片 6](images/00006.jpg) `Account,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,`
    ![图片 6](images/00006.jpg) `DefaultTolerationSeconds,PodSecurityPolicy`'
- en: 'The API server won’t start up until you create the password file you specified
    in the command line options. This is how to create the file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在命令行选项中指定的密码文件创建之前，API 服务器不会启动。以下是创建文件的方法：
- en: '`$ cat <<EOF | minikube ssh sudo tee /etc/kubernetes/passwd password,alice,1000,basic-user
    password,bob,2000,privileged-user EOF`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cat <<EOF | minikube ssh sudo tee /etc/kubernetes/passwd password,alice,1000,basic-user
    password,bob,2000,privileged-user EOF`'
- en: You’ll find a shell script that runs both commands in the book’s code archive
    in Chapter13/minikube-with-rbac-and-psp-enabled.sh.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第 13 章的代码存档 Chapter13/minikube-with-rbac-and-psp-enabled.sh 中找到一个运行这两个命令的
    shell 脚本。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Understanding what a PodSecurityPolicy can do
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 PodSecurityPolicy 可以做什么
- en: 'A PodSecurityPolicy resource defines things like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy 资源定义了如下内容：
- en: Whether a pod can use the host’s IPC, PID, or Network namespaces
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 pod 是否可以使用主机的 IPC、PID 或网络命名空间
- en: Which host ports a pod can bind to
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pod 可以绑定到哪些主机端口
- en: What user IDs a container can run as
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以运行哪些用户 ID
- en: Whether a pod with privileged containers can be created
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以创建具有特权容器的 pod
- en: Which kernel capabilities are allowed, which are added by default and which
    are always dropped
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些内核能力是被允许的，哪些是默认添加的，哪些总是被丢弃
- en: What SELinux labels a container can use
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以使用哪些 SELinux 标签
- en: Whether a container can use a writable root filesystem or not
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是否可以使用可写根文件系统
- en: Which filesystem groups the container can run as
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以运行在哪些文件系统组中
- en: Which volume types a pod can use
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pod 可以使用哪些卷类型
- en: If you’ve read this chapter up to this point, everything but the last item in
    the previous list should be familiar. The last item should also be fairly clear.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读到本章的这一部分，那么前一个列表中的所有内容都应该熟悉。最后一个条目也应该相当清晰。
- en: Examining a sample PodSecurityPolicy
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个示例 PodSecurityPolicy
- en: The following listing shows a sample PodSecurityPolicy, which prevents pods
    from using the host’s IPC, PID, and Network namespaces, and prevents running privileged
    containers and the use of most host ports (except ports from 10000-11000 and 13000-14000).
    The policy doesn’t set any constraints on what users, groups, or SELinux groups
    the container can run as.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个示例 PodSecurityPolicy，它阻止 pod 使用主机的 IPC、PID 和网络命名空间，并阻止运行特权容器以及使用大多数主机端口（除了
    10000-11000 和 13000-14000 的端口）。该策略不对容器可以运行的用户、组或 SELinux 组设置任何约束。
- en: 'Listing 13.15\. An example PodSecurityPolicy: pod-security-policy.yaml'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.15\. 一个示例 PodSecurityPolicy：pod-security-policy.yaml
- en: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy metadata:   name: default
    spec:   hostIPC: false` `1` `hostPID: false` `1` `hostNetwork: false` `1` `hostPorts:`
    `2` `- min: 10000` `2` `max: 11000` `2` `- min: 13000` `2` `max: 14000` `2` `privileged:
    false` `3` `readOnlyRootFilesystem: true` `4` `runAsUser:` `5` `rule: RunAsAny`
    `5` `fsGroup:` `5` `rule: RunAsAny` `5` `supplementalGroups:` `5` `rule: RunAsAny`
    `5` `seLinux:` `6` `rule: RunAsAny` `6` `volumes:` `7` `- ''*''` `7`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy metadata:   name: default
    spec:   hostIPC: false` `1` `hostPID: false` `1` `hostNetwork: false` `1` `hostPorts:`
    `2` `- min: 10000` `2` `max: 11000` `2` `- min: 13000` `2` `max: 14000` `2` `privileged:
    false` `3` `readOnlyRootFilesystem: true` `4` `runAsUser:` `5` `rule: RunAsAny`
    `5` `fsGroup:` `5` `rule: RunAsAny` `5` `supplementalGroups:` `5` `rule: RunAsAny`
    `5` `seLinux:` `6` `rule: RunAsAny` `6` `volumes:` `7` `- ''*''` `7`'
- en: 1 Containers aren’t allowed to use the host’s IPC, PID, or network namespace.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 容器不允许使用主机的 IPC、PID 或网络命名空间。
- en: 2 They can only bind to host ports 10000 to 11000 (inclusive) or host ports
    13000 to 14000.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它们只能绑定到主机端口 10000 到 11000（包含）或主机端口 13000 到 14000。
- en: 3 Containers cannot run in privileged mode.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 容器不能以特权模式运行。
- en: 4 Containers are forced to run with a read-only root filesystem.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 容器被强制以只读根文件系统运行。
- en: 5 Containers can run as any user and any group.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 容器可以以任何用户和任何组运行。
- en: 6 They can also use any SELinux groups they want.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 它们还可以使用它们想要的任何 SELinux 组。
- en: 7 All volume types can be used in pods.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 所有卷类型都可以在 pod 中使用。
- en: Most of the options specified in the example should be self-explanatory, especially
    if you’ve read the previous sections. After this PodSecurityPolicy resource is
    posted to the cluster, the API server will no longer allow you to deploy the privileged
    pod used earlier. For example
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中指定的大多数选项应该是自解释的，尤其是如果你已经阅读了前面的章节。在此 PodSecurityPolicy 资源发布到集群之后，API 服务器将不再允许你部署之前使用的特权
    pod。例如
- en: '`$ kubectl create -f pod-privileged.yaml` `Error from server (Forbidden): error
    when creating "pod-privileged.yaml": pods "pod-privileged" is forbidden: unable
    to validate against any pod security policy: [spec.containers[0].securityContext.privileged:
    Invalid value: true: Privileged containers are not allowed]`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f pod-privileged.yaml` `Error from server (Forbidden): error
    when creating "pod-privileged.yaml": pods "pod-privileged" is forbidden: unable
    to validate against any pod security policy: [spec.containers[0].securityContext.privileged:
    Invalid value: true: Privileged containers are not allowed]`'
- en: Likewise, you can no longer deploy pods that want to use the host’s PID, IPC,
    or Network namespace. Also, because you set `readOnlyRootFilesystem` to `true`
    in the policy, the container filesystems in all pods will be read-only (containers
    can only write to volumes).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你不能再部署想要使用主机 PID、IPC 或网络命名空间的 pod。此外，因为你将策略中的 `readOnlyRootFilesystem` 设置为
    `true`，所以所有 pod 中的容器文件系统都将为只读（容器只能写入卷）。
- en: 13.3.2\. Understanding runAsUser, fsGroup, and supplementalGroups policies
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3.2\. 理解 runAsUser、fsGroup 和 supplementalGroups 策略
- en: The policy in the previous example doesn’t impose any limits on which users
    and groups containers can run as, because you’ve used the `RunAsAny` rule for
    the `run-As-User`, `fsGroup`, and `supplementalGroups` fields. If you want to
    constrain the list of allowed user or group IDs, you change the rule to `MustRunAs`
    and specify the range of allowed IDs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的策略没有对容器可以运行的哪些用户和组施加任何限制，因为你在 `run-As-User`、`fsGroup` 和 `supplementalGroups`
    字段中使用了 `RunAsAny` 规则。如果你想限制允许的用户或组 ID 列表，请将规则更改为 `MustRunAs` 并指定允许的 ID 范围。
- en: Using the MustRunAs rule
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MustRunAs 规则
- en: Let’s look at an example. To only allow containers to run as user ID `2` and
    constrain the default filesystem group and supplemental group IDs to be anything
    from `2–10` or `20–30` (all inclusive), you’d include the following snippet in
    the PodSecurityPolicy resource.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。为了仅允许容器以用户 ID `2` 运行，并将默认文件系统组 ID 和补充组 ID 限制在 `2–10` 或 `20–30`（全部包含），你需要在
    PodSecurityPolicy 资源中包含以下片段。
- en: 'Listing 13.16\. Specifying IDs containers must run as: psp-must-run-as.yaml'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.16\. 指定容器必须运行的 ID：psp-must-run-as.yaml
- en: '`runAsUser:     rule: MustRunAs     ranges:     - min: 2` `1` `max: 2` `1`
    `fsGroup:     rule: MustRunAs     ranges:     - min: 2` `2` `max: 10` `2` `- min:
    20` `2` `max: 30` `2` `supplementalGroups:     rule: MustRunAs     ranges:    
    - min: 2` `2` `max: 10` `2` `- min: 20` `2` `max: 30` `2`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`runAsUser:     rule: MustRunAs     ranges:     - min: 2` `1` `max: 2` `1`
    `fsGroup:     rule: MustRunAs     ranges:     - min: 2` `2` `max: 10` `2` `- min:
    20` `2` `max: 30` `2` `supplementalGroups:     rule: MustRunAs     ranges:    
    - min: 2` `2` `max: 10` `2` `- min: 20` `2` `max: 30` `2`'
- en: 1 Add a single range with min equal to max to set one specific ID.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 添加一个范围，最小值等于最大值，以设置一个特定的 ID。
- en: 2 Multiple ranges are supported—here, group IDs can be 2–10 or 20–30 (inclusive).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 支持多个范围——在这里，组 ID 可以是 2–10 或 20–30（包含）。
- en: If the pod spec tries to set either of those fields to a value outside of these
    ranges, the pod will not be accepted by the API server. To try this, delete the
    previous PodSecurity-Policy and create the new one from the psp-must-run-as.yaml
    file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pod 规范尝试将其中任何一个字段设置为这些范围之外的值，则 API 服务器将不接受该 pod。要尝试此操作，请删除之前的 PodSecurity-Policy
    并从 psp-must-run-as.yaml 文件创建新的一个。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Changing the policy has no effect on existing pods, because Pod-Security-Policies
    are enforced only when creating or updating pods.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更改策略对现有 pod 没有影响，因为 Pod-Security-Policies 仅在创建或更新 pod 时强制执行。
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Deploying a pod with runAsUser outside of the policy’s range
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略范围之外部署具有 runAsUser 的 pod
- en: 'If you try deploying the pod-as-user-guest.yaml file from earlier, which says
    the container should run as user ID `405`, the API server rejects the pod:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试部署之前提到的 pod-as-user-guest.yaml 文件，其中指定容器应以用户 ID `405` 运行，API 服务器将拒绝该 pod：
- en: '`$ kubectl create -f pod-as-user-guest.yaml` `Error from server (Forbidden):
    error when creating "pod-as-user-guest.yaml" : pods "pod-as-user-guest" is forbidden:
    unable to validate against any pod security policy: [securityContext.runAsUser:
    Invalid value: 405: UID on container main does not match required range.  Found
    405, allowed: [{2 2}]]`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f pod-as-user-guest.yaml` `错误来自服务器（禁止）：创建 "pod-as-user-guest.yaml"
    时出错：pods "pod-as-user-guest" 被禁止：无法验证任何 pod 安全策略：[securityContext.runAsUser: 无效值：405：容器
    main 上的 UID 不符合所需范围。找到 405，允许：[{2 2}]]`'
- en: Okay, that was obvious. But what happens if you deploy a pod without setting
    the `runAs-User` property, but the user ID is baked into the container image (using
    the `USER` directive in the Dockerfile)?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是显而易见的。但是，如果你部署了一个没有设置 `runAs-User` 属性的 pod，但用户 ID 已嵌入到容器镜像中（使用 Dockerfile
    中的 `USER` 指令），会发生什么？
- en: Deploying a pod with a container image with an out-of-range user id
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用超出范围的用户 ID 部署容器镜像的 pod
- en: I’ve created an alternative image for the Node.js app you’ve used throughout
    the book. The image is configured so that the container will run as user ID 5\.
    The Dockerfile for the image is shown in the following listing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我为书中使用的 Node.js 应用程序创建了一个替代镜像。该镜像配置为容器将以用户 ID 5 运行。该镜像的 Dockerfile 如下所示。
- en: 'Listing 13.17\. Dockerfile with a USER directive: kubia-run-as-user-5/Dockerfile'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.17\. 包含 USER 指令的 Dockerfile：kubia-run-as-user-5/Dockerfile
- en: '`FROM node:7 ADD app.js /app.js USER 5` `1` `ENTRYPOINT ["node", "app.js"]`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM node:7 ADD app.js /app.js USER 5` `1` `ENTRYPOINT ["node", "app.js"]`'
- en: 1 Containers run from this image will run as user ID 5.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 从此镜像运行的容器将以用户 ID 5 运行。
- en: 'I pushed the image to Docker Hub as `luksa/kubia-run-as-user-5`. If I deploy
    a pod with that image, the API server doesn’t reject it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我将镜像推送到Docker Hub，命名为`luksa/kubia-run-as-user-5`。如果我用这个镜像部署一个Pod，API服务器不会拒绝它：
- en: '`$ kubectl run run-as-5 --image luksa/kubia-run-as-user-5 --restart Never`
    `pod "run-as-5" created`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl run run-as-5 --image luksa/kubia-run-as-user-5 --restart Never`
    `pod "run-as-5" created`'
- en: 'Unlike before, the API server accepted the pod and the Kubelet has run its
    container. Let’s see what user ID the container is running as:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前不同，API服务器接受了Pod，并且Kubelet已经运行了其容器。让我们看看容器正在以哪个用户ID运行：
- en: '`$ kubectl exec run-as-5 -- id` `uid=2(bin) gid=2(bin) groups=2(bin)`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec run-as-5 -- id` `uid=2(bin) gid=2(bin) groups=2(bin)`'
- en: As you can see, the container is running as user ID `2`, which is the ID you
    specified in the PodSecurityPolicy. The PodSecurityPolicy can be used to override
    the user ID hardcoded into a container image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，容器正在以用户ID `2` 运行，这是你在PodSecurityPolicy中指定的ID。PodSecurityPolicy可以用来覆盖容器镜像中硬编码的用户ID。
- en: Using the MustRunAsNonRoot rule in the runAsUser field
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在runAsUser字段中使用MustRunAsNonRoot规则
- en: 'For the `runAsUser` field an additional rule can be used: `MustRunAsNonRoot`.
    As the name suggests, it prevents users from deploying containers that run as
    root. Either the container spec must specify a `runAsUser` field, which can’t
    be zero (zero is the root user’s ID), or the container image itself must run as
    a non-zero user ID. We explained why this is a good thing earlier.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`runAsUser`字段，可以使用一个额外的规则：`MustRunAsNonRoot`。正如其名所示，它阻止用户部署以root身份运行的容器。要么容器规范必须指定一个`runAsUser`字段，该字段不能为零（零是root用户的ID），要么容器镜像本身必须以非零用户ID运行。我们之前解释了为什么这是好事。
- en: 13.3.3\. Configuring allowed, default, and disallowed capabilities
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3.3\. 配置允许、默认和禁止的能力
- en: 'As you learned, containers can run in privileged mode or not, and you can define
    a more fine-grained permission configuration by adding or dropping Linux kernel
    capabilities in each container. Three fields influence which capabilities containers
    can or cannot use:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，容器可以以特权模式或非特权模式运行，你可以通过在每个容器中添加或删除Linux内核能力来定义更细粒度的权限配置。有三个字段影响容器可以使用或不能使用的功能：
- en: '`allowedCapabilities`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedCapabilities`'
- en: '`defaultAddCapabilities`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultAddCapabilities`'
- en: '`requiredDropCapabilities`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requiredDropCapabilities`'
- en: We’ll look at an example first, and then discuss what each of the three fields
    does. The following listing shows a snippet of a PodSecurityPolicy resource defining
    three fields related to capabilities.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一个例子，然后讨论这三个字段各自的作用。下面的列表显示了一个PodSecurityPolicy资源片段，定义了与能力相关的三个字段。
- en: 'Listing 13.18\. Specifying capabilities in a PodSecurityPolicy: psp-capabilities.yaml'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.18\. 在PodSecurityPolicy中指定能力：psp-capabilities.yaml
- en: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy spec:   allowedCapabilities:`
    `1` `- SYS_TIME` `1` `defaultAddCapabilities:` `2` `- CHOWN` `2` `requiredDropCapabilities:`
    `3` `- SYS_ADMIN` `3` `- SYS_MODULE` `3` `...`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy spec:   allowedCapabilities:`
    `1` `- SYS_TIME` `1` `defaultAddCapabilities:` `2` `- CHOWN` `2` `requiredDropCapabilities:`
    `3` `- SYS_ADMIN` `3` `- SYS_MODULE` `3` `...`'
- en: 1 Allow containers to add the SYS_TIME capability.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 允许容器添加`SYS_TIME`能力。
- en: 2 Automatically add the CHOWN capability to every container.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 自动将`CHOWN`能力添加到每个容器。
- en: 3 Require containers to drop the SYS_ADMIN and SYS_MODULE capabilities.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 要求容器放弃`SYS_ADMIN`和`SYS_MODULE`能力。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `SYS_ADMIN` capability allows a range of administrative operations, and
    the `SYS_MODULE` capability allows loading and unloading of Linux kernel modules.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYS_ADMIN`能力允许一系列管理操作，而`SYS_MODULE`能力允许加载和卸载Linux内核模块。'
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Specifying which capabilities can be added to a container
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 指定可以添加到容器中的能力
- en: The `allowedCapabilities` field is used to specify which capabilities pod authors
    can add in the `securityContext.capabilities` field in the container spec. In
    one of the previous examples, you added the `SYS_TIME` capability to your container.
    If the Pod-Security-Policy admission control plugin had been enabled, you wouldn’t
    have been able to add that capability, unless it was specified in the PodSecurityPolicy
    as shown in [listing 13.18](#filepos1294518).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowedCapabilities`字段用于指定Pod作者可以在容器规范中的`securityContext.capabilities`字段中添加哪些能力。在先前的某个例子中，你向你的容器添加了`SYS_TIME`能力。如果Pod-Security-Policy准入控制插件已被启用，你将无法添加该能力，除非它在PodSecurityPolicy中指定，如[列表13.18](#filepos1294518)所示。'
- en: Adding capabilities to all containers
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 向所有容器添加能力
- en: All capabilities listed under the `defaultAddCapabilities` field will be added
    to every deployed pod’s containers. If a user doesn’t want certain containers
    to have those capabilities, they need to explicitly drop them in the specs of
    those containers.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`defaultAddCapabilities`字段下列出的所有功能都将添加到每个部署Pod的容器中。如果用户不希望某些容器具有这些功能，他们需要在那些容器的规范中明确删除它们。
- en: The example in [listing 13.18](#filepos1294518) enables the automatic addition
    of the `CAP_CHOWN` capability to every container, thus allowing processes running
    in the container to change the ownership of files in the container (with the `chown`
    command, for example).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13.18](#filepos1294518)中的示例启用了将`CAP_CHOWN`功能自动添加到每个容器的功能，从而允许在容器中运行的进程更改容器中文件的拥有权（例如，使用`chown`命令）。'
- en: Dropping capabilities from a container
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器中删除功能
- en: The final field in this example is `requiredDropCapabilities`. I must admit,
    this was a somewhat strange name for me at first, but it’s not that complicated.
    The capabilities listed in this field are dropped automatically from every container
    (the PodSecurityPolicy Admission Control plugin will add them to every container’s
    `security-Context.capabilities.drop` field).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的最后一个字段是`requiredDropCapabilities`。我必须承认，一开始这个名称对我来说有些奇怪，但它并不复杂。该字段中列出的功能将自动从每个容器中删除（PodSecurityPolicy准入控制插件将它们添加到每个容器的`security-Context.capabilities.drop`字段）。
- en: 'If a user tries to create a pod where they explicitly add one of the capabilities
    listed in the policy’s `requiredDropCapabilities` field, the pod is rejected:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尝试创建一个Pod，并明确添加策略`requiredDropCapabilities`字段中列出的功能之一，Pod将被拒绝：
- en: '`$ kubectl create -f pod-add-sysadmin-capability.yaml` `Error from server (Forbidden):
    error when creating "pod-add-sysadmin- capability.yaml": pods "pod-add-sysadmin-capability"
    is forbidden: unable to validate against any pod security policy: [capabilities.add:
    Invalid value:` `"SYS_ADMIN": capability may not be added]`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f pod-add-sysadmin-capability.yaml` `Error from server (Forbidden):
    error when creating "pod-add-sysadmin-capability.yaml": pods "pod-add-sysadmin-capability"
    is forbidden: unable to validate against any pod security policy: [capabilities.add:
    Invalid value: "SYS_ADMIN": capability may not be added]`'
- en: 13.3.4\. Constraining the types of volumes pods can use
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3.4\. 限制Pod可以使用的卷类型
- en: The last thing a PodSecurityPolicy resource can do is define which volume types
    users can add to their pods. At the minimum, a PodSecurityPolicy should allow
    using at least the `emptyDir`, `configMap`, `secret`, `downwardAPI`, and the `persistentVolumeClaim`
    volumes. The pertinent part of such a PodSecurityPolicy resource is shown in the
    following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy资源可以做的最后一件事是定义用户可以向其Pod添加哪些卷类型。至少，PodSecurityPolicy应该允许使用至少`emptyDir`、`configMap`、`secret`、`downwardAPI`和`persistentVolumeClaim`卷。此类PodSecurityPolicy资源的相关部分如下所示。
- en: 'Listing 13.19\. A PSP snippet allowing the use of only certain volume types:
    psp-volumes.yaml'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.19\. 允许仅使用特定卷类型的PSP片段：psp-volumes.yaml
- en: '`kind: PodSecurityPolicy spec:   volumes:   - emptyDir   - configMap   - secret
      - downwardAPI   - persistentVolumeClaim`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind: PodSecurityPolicy spec:    volumes:    - emptyDir    - configMap    -
    secret    - downwardAPI    - persistentVolumeClaim`'
- en: If multiple PodSecurityPolicy resources are in place, pods can use any volume
    type defined in any of the policies (the union of all `volumes` lists is used).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个PodSecurityPolicy资源，Pod可以使用任何策略中定义的卷类型（使用所有`volumes`列表的并集）。
- en: 13.3.5\. Assigning different PodSecurityPolicies to different users and groups
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 13.3.5\. 为不同的用户和组分配不同的PodSecurityPolicies
- en: We mentioned that a PodSecurityPolicy is a cluster-level resource, which means
    it can’t be stored in and applied to a specific namespace. Does that mean it always
    applies across all namespaces? No, because that would make them relatively unusable.
    After all, system pods must often be allowed to do things that regular pods shouldn’t.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到PodSecurityPolicy是一个集群级别的资源，这意味着它不能存储并应用于特定的命名空间。这意味着它总是应用于所有命名空间吗？不，因为那样会使它们相对不可用。毕竟，系统Pod通常需要执行常规Pod不应执行的操作。
- en: Assigning different policies to different users is done through the RBAC mechanism
    described in the previous chapter. The idea is to create as many policies as you
    need and make them available to individual users or groups by creating ClusterRole
    resources and pointing them to the individual policies by name. By binding those
    ClusterRoles to specific users or groups with ClusterRoleBindings, when the PodSecurityPolicy
    Admission Control plugin needs to decide whether to admit a pod definition or
    not, it will only consider the policies accessible to the user creating the pod.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 RBAC 机制将不同的策略分配给不同的用户是上一章中描述的。想法是创建尽可能多的策略，并通过创建 ClusterRole 资源并按名称指向它们，使它们对单个用户或组可用。通过将那些
    ClusterRoles 绑定到特定的用户或组（使用 ClusterRoleBindings），当 PodSecurityPolicy 接受控制插件需要决定是否接受
    pod 定义时，它将只考虑创建 pod 的用户可访问的策略。
- en: You’ll see how to do this in the next exercise. You’ll start by creating an
    additional PodSecurityPolicy.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一节练习中看到如何做到这一点。你将首先创建一个额外的 PodSecurityPolicy。
- en: Creating a PodSecurityPolicy allowing privileged containers to be deployed
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建允许部署具有特权容器的 PodSecurityPolicy
- en: You’ll create a special PodSecurityPolicy that will allow privileged users to
    create pods with privileged containers. The following listing shows the policy’s
    definition.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个特殊的 PodSecurityPolicy，它将允许特权用户创建具有特权容器的 pod。以下列表显示了策略的定义。
- en: 'Listing 13.20\. A PodSecurityPolicy for privileged users: psp-privileged.yaml'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.20\. 为特权用户创建的 PodSecurityPolicy：psp-privileged.yaml
- en: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy metadata:   name: privileged`
    `1` `spec:   privileged: true` `2` `runAsUser:     rule: RunAsAny   fsGroup:    
    rule: RunAsAny   supplementalGroups:     rule: RunAsAny   seLinux:     rule: RunAsAny
      volumes:   - ''*''`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: extensions/v1beta1 kind: PodSecurityPolicy metadata:   name: privileged`
    `1` `spec:   privileged: true` `2` `runAsUser:     rule: RunAsAny   fsGroup:    
    rule: RunAsAny   supplementalGroups:     rule: RunAsAny   seLinux:     rule: RunAsAny
      volumes:   - ''*''`'
- en: 1 The name of this policy is “privileged.”
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 该策略的名称是“privileged。”
- en: 2 It allows running privileged containers.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它允许运行特权容器。
- en: 'After you post this policy to the API server, you have two policies in the
    cluster:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此策略发布到 API 服务器后，集群中就有两个策略：
- en: '`$ kubectl get psp` `NAME         PRIV    CAPS   SELINUX    RUNASUSER   FSGROUP   
    ... default      false   []     RunAsAny   RunAsAny    RunAsAny   ... privileged  
    true    []     RunAsAny   RunAsAny    RunAsAny   ...`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get psp` `NAME         PRIV    CAPS   SELINUX    RUNASUSER   FSGROUP   
    ... default      false   []     RunAsAny   RunAsAny    RunAsAny   ... privileged  
    true    []     RunAsAny   RunAsAny    RunAsAny   ...`'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The shorthand for `PodSecurityPolicy` is `psp`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`PodSecurityPolicy` 的缩写是 `psp`。'
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you can see in the `PRIV` column, the `default` policy doesn’t allow running
    privileged containers, whereas the `privileged` policy does. Because you’re currently
    logged in as a cluster-admin, you can see all the policies. When creating pods,
    if any policy allows you to deploy a pod with certain features, the API server
    will accept your pod.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 `PRIV` 列中看到的，`default` 策略不允许运行特权容器，而 `privileged` 策略则允许。因为你目前以集群管理员身份登录，所以你可以看到所有策略。当创建
    pod 时，如果任何策略允许你部署具有特定功能的 pod，API 服务器将接受你的 pod。
- en: 'Now imagine two additional users are using your cluster: Alice and Bob. You
    want Alice to only deploy restricted (non-privileged) pods, but you want to allow
    Bob to also deploy privileged pod`s`. You do this by making sure Alice can only
    use the default PodSecurityPolicy, while allowing Bob to use both.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象有两个额外的用户正在使用你的集群：Alice 和 Bob。你希望 Alice 只能部署受限（非特权）的 pod，但你希望允许 Bob 也能部署特权
    pod`s`。你可以通过确保 Alice 只能使用默认的 PodSecurityPolicy，同时允许 Bob 使用两者来实现这一点。
- en: Using RBAC to assign different PodSecurityPolicies to different users
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RBAC 为不同的用户分配不同的 PodSecurityPolicies
- en: In the previous chapter, you used RBAC to grant users access to only certain
    resource types, but I mentioned that access can be granted to specific resource
    instances by referencing them by name. That’s what you’ll use to make users use
    different PodSecurityPolicy resources.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用了 RBAC 来授予用户访问特定资源类型的权限，但我提到可以通过引用它们的名称来授予对特定资源实例的访问权限。这就是你将用来让用户使用不同的
    PodSecurityPolicy 资源的方法。
- en: 'First, you’ll create two ClusterRoles, each allowing the use of one of the
    policies. You’ll call the first one `psp-default` and in it allow the `use` of
    the `default` PodSecurityPolicy resource. You can use `kubectl create clusterrole`
    to do that:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将创建两个 ClusterRoles，每个 ClusterRole 允许使用一个策略。你将第一个命名为 `psp-default`，并在其中允许使用
    `default` PodSecurityPolicy 资源。你可以使用 `kubectl create clusterrole` 来完成这个任务：
- en: '`$ kubectl create clusterrole psp-default --verb=use`![](images/00006.jpg)`--resource=podsecuritypolicies
    --resource-name=default` `clusterrole "psp-default" created`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrole psp-default --verb=use`![](images/00006.jpg)`--resource=podsecuritypolicies
    --resource-name=default` `clusterrole "psp-default" created`'
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’re using the special verb `use` instead of `get`, `list`, `watch`, or similar.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用特殊的动词`use`而不是`get`、`list`、`watch`或类似的。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As you can see, you’re referring to a specific instance of a PodSecurityPolicy
    resource by using the `--resource-name` option. Now, create another ClusterRole
    called `psp-privileged`, pointing to the `privileged` policy:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你通过使用`--resource-name`选项来引用PodSecurityPolicy资源的特定实例。现在，创建另一个名为`psp-privileged`的ClusterRole，指向`privileged`策略：
- en: '`$ kubectl create clusterrole psp-privileged --verb=use`![](images/00006.jpg)`--resource=podsecuritypolicies
    --resource-name=privileged` `clusterrole "psp-privileged" created`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrole psp-privileged --verb=use`![](images/00006.jpg)`--resource=podsecuritypolicies
    --resource-name=privileged` `clusterrole "psp-privileged" created`'
- en: Now, you need to bind these two policies to users. As you may remember from
    the previous chapter, if you’re binding a ClusterRole that grants access to cluster-level
    resources (which is what PodSecurityPolicy resources are), you need to use a Cluster-RoleBinding
    instead of a (namespaced) RoleBinding.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要将这些策略绑定到用户。如你可能在上一章中记得的，如果你绑定一个授予对集群级资源访问权限的ClusterRole（PodSecurityPolicy资源就是这样的），你需要使用Cluster-RoleBinding而不是（命名空间级别的）RoleBinding。
- en: 'You’re going to bind the `psp-default` ClusterRole to all authenticated users,
    not only to Alice. This is necessary because otherwise no one could create any
    pods, because the Admission Control plugin would complain that no policy is in
    place. Authenticated users all belong to the `system:authenticated` group, so
    you’ll bind the ClusterRole to the group:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把`psp-default` ClusterRole 绑定到所有已认证用户，而不仅仅是Alice。这是必要的，因为否则没有人可以创建任何pods，因为Admission
    Control插件会抱怨没有设置策略。所有已认证用户都属于`system:authenticated`组，所以你需要将ClusterRole绑定到该组：
- en: '`$ kubectl create clusterrolebinding psp-all-users`![](images/00006.jpg)`--clusterrole=psp-default
    --group=system:authenticated` `clusterrolebinding "psp-all-users" created`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrolebinding psp-all-users`![](images/00006.jpg)`--clusterrole=psp-default
    --group=system:authenticated` `clusterrolebinding "psp-all-users" created`'
- en: 'You’ll bind the `psp-privileged` ClusterRole only to Bob:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你将只将`psp-privileged` ClusterRole 绑定到Bob：
- en: '`$ kubectl create clusterrolebinding psp-bob`![](images/00006.jpg)`--clusterrole=psp-privileged
    --user=bob` `clusterrolebinding "psp-bob" created`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrolebinding psp-bob`![](images/00006.jpg)`--clusterrole=psp-privileged
    --user=bob` `clusterrolebinding "psp-bob" created`'
- en: As an authenticated user, Alice should now have access to the `default` PodSecurityPolicy,
    whereas Bob should have access to both the `default` and the `privileged` PodSecurityPolicies.
    Alice shouldn’t be able to create privileged pods, whereas Bob should. Let’s see
    if that’s true.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为已认证用户，Alice现在应该能够访问`default` PodSecurityPolicy，而Bob应该能够访问`default`和`privileged`
    PodSecurityPolicies。Alice不应该能够创建特权pods，而Bob应该可以。让我们看看这是否正确。
- en: Creating additional users for kubectl
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为kubectl创建额外用户
- en: But how do you authenticate as Alice or Bob instead of whatever you’re authenticated
    as currently? The book’s [appendix A](index_split_135.html#filepos1721130) explains
    how `kubectl` can be used with multiple clusters, but also with multiple contexts.
    A context includes the user credentials used for talking to a cluster. Turn to
    [appendix A](index_split_135.html#filepos1721130) to find out more. Here we’ll
    show the bare commands enabling you to use `kubectl` as Alice or Bob.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 但你如何以Alice或Bob的身份进行认证，而不是当前认证的身份？本书的[附录A](index_split_135.html#filepos1721130)解释了如何使用`kubectl`与多个集群以及多个上下文一起使用。一个上下文包括用于与集群通信的用户凭据。转向[附录A](index_split_135.html#filepos1721130)以了解更多信息。在这里，我们将展示允许你以Alice或Bob身份使用`kubectl`的基本命令。
- en: 'First, you’ll create two new users in `kubectl`’s config with the following
    two commands-:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将在`kubectl`的配置中创建两个新用户，使用以下两个命令：
- en: '`$ kubectl config set-credentials alice --username=alice --password=password`
    `User "alice" set.` `$ kubectl config set-credentials bob --username=bob --password=password`
    `User "bob" set.`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl config set-credentials alice --username=alice --password=password`
    `User "alice" set.` `$ kubectl config set-credentials bob --username=bob --password=password`
    `User "bob" set.`'
- en: It should be obvious what the commands do. Because you’re setting username and
    password credentials, `kubectl` will use basic HTTP authentication for these two
    users (other authentication methods include tokens, client certificates, and so
    on).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的作用应该是显而易见的。因为你正在设置用户名和密码凭证，`kubectl`将为这两个用户使用基本HTTP认证（其他认证方法包括令牌、客户端证书等）。
- en: Creating pods as a different user
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以不同用户创建Pod
- en: 'You can now try creating a privileged pod while authenticating as Alice. You
    can tell `kubectl` which user credentials to use by using the `--user` option:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试以Alice的身份认证创建一个特权Pod。你可以通过使用`--user`选项来告诉`kubectl`使用哪个用户的凭证：
- en: '`$ kubectl --user alice create -f pod-privileged.yaml` `Error from server (Forbidden):
    error when creating "pod-privileged.yaml":      pods "pod-privileged" is forbidden:
    unable to validate against any pod      security policy: [spec.containers[0].securityContext.privileged:
    Invalid      value: true: Privileged containers are not allowed]`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl --user alice create -f pod-privileged.yaml` `Error from server (Forbidden):
    error when creating "pod-privileged.yaml": pods "pod-privileged" is forbidden:
    unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged:
    Invalid value: true: Privileged containers are not allowed]`'
- en: 'As expected, the API server doesn’t allow Alice to create privileged pods.
    Now, let’s see if it allows Bob to do that:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，API服务器不允许Alice创建特权Pod。现在，让我们看看它是否允许Bob这样做：
- en: '`$ kubectl --user bob create -f pod-privileged.yaml` `pod "pod-privileged"
    created`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl --user bob create -f pod-privileged.yaml` `pod "pod-privileged"
    created`'
- en: And there you go. You’ve successfully used RBAC to make the Admission Control
    plugin use different PodSecurityPolicy resources for different users.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你就成功了。你已经成功使用RBAC使Admission Control插件为不同的用户使用不同的PodSecurityPolicy资源。
- en: 13.4\. Isolating the pod network
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4. 独立Pod网络
- en: Up to now in this chapter, we’ve explored many security-related configuration
    options that apply to individual pods and their containers. In the remainder of
    this chapter, we’ll look at how the network between pods can be secured by limiting
    which pods can talk to which pods.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经探讨了适用于单个Pod及其容器的许多安全相关配置选项。在本章的剩余部分，我们将探讨如何通过限制哪些Pod可以与哪些Pod通信来保护Pod之间的网络。
- en: Whether this is configurable or not depends on which container networking plugin
    is used in the cluster. If the networking plugin supports it, you can configure
    network isolation by creating NetworkPolicy resources.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否可配置取决于集群中使用的容器网络插件。如果网络插件支持，你可以通过创建NetworkPolicy资源来配置网络隔离。
- en: A NetworkPolicy applies to pods that match its label selector and specifies
    either which sources can access the matched pods or which destinations can be
    accessed from the matched pods. This is configured through ingress and egress
    rules, respectively. Both types of rules can match only the pods that match a
    pod selector, all pods in a namespace whose labels match a namespace selector,
    or a network IP block specified using Classless Inter-Domain Routing (CIDR) notation
    (for example, 192.168.1.0/24).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkPolicy应用于匹配其标签选择器的Pod，并指定哪些源可以访问匹配的Pod或从匹配的Pod可以访问哪些目标。这是通过入口和出口规则分别配置的。这两种类型的规则只能匹配匹配Pod选择器的Pod、标签匹配命名空间选择器的命名空间中的所有Pod，或使用无类别域间路由（CIDR）表示法指定的网络IP块（例如，192.168.1.0/24）。
- en: We’ll look at both ingress and egress rules and all three matching options.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看入口和出口规则以及所有三个匹配选项。
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ingress rules in a NetworkPolicy have nothing to do with the Ingress resource
    discussed in [chapter 5](index_split_046.html#filepos469093).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkPolicy中的入口规则与第5章中讨论的入口资源（[chapter 5](index_split_046.html#filepos469093)）无关。
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.4.1\. Enabling network isolation in a namespace
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4.1. 在命名空间中启用网络隔离
- en: By default, pods in a given namespace can be accessed by anyone. First, you’ll
    need to change that. You’ll create a `default-deny` NetworkPolicy, which will
    prevent all clients from connecting to any pod in your namespace. The NetworkPolicy
    definition is shown in the following listing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，给定命名空间中的Pod可以被任何人访问。首先，你需要改变这一点。你将创建一个`default-deny` NetworkPolicy，这将阻止所有客户端连接到你的命名空间中的任何Pod。NetworkPolicy的定义如下所示。
- en: 'Listing 13.21\. A `default-deny` NetworkPolicy: network-policy-default-deny.yaml'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '列表13.21. 一个`default-deny` NetworkPolicy: network-policy-default-deny.yaml'
- en: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: default-deny
    spec:   podSelector:` `1`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: default-deny
    spec: podSelector: 1`'
- en: 1 Empty pod selector matches all pods in the same namespace
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 空Pod选择器匹配同一命名空间中的所有Pod
- en: When you create this NetworkPolicy in a certain namespace, no one can connect
    to any pod in that namespace.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在某个命名空间中创建此NetworkPolicy时，没有人可以连接到该命名空间中的任何Pod。
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The CNI plugin or other type of networking solution used in the cluster must
    support NetworkPolicy, or else there will be no effect on inter-pod connectivity.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中使用的CNI插件或其他类型的网络解决方案必须支持NetworkPolicy，否则将对Pod之间的连接没有影响。
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.4.2\. Allowing only some pods in the namespace to connect to a server pod
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4.2. 允许命名空间中的一些Pod连接到服务器Pod
- en: To let clients connect to the pods in the namespace, you must now explicitly
    say who can connect to the pods. By who I mean which pods. Let’s explore how to
    do this through an example.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端连接到命名空间中的Pod，你现在必须明确指出谁可以连接到Pod。通过“谁”我指的是哪些Pod。让我们通过一个例子来探讨如何做到这一点。
- en: Imagine having a PostgreSQL database pod running in namespace `foo` and a web-server
    pod that uses the database. Other pods are also in the namespace, and you don’t
    want to allow them to connect to the database. To secure the network, you need
    to create the NetworkPolicy resource shown in the following listing in the same
    namespace as the database pod.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有一个运行在`foo`命名空间中的PostgreSQL数据库Pod和一个使用数据库的web-server Pod。其他Pod也位于该命名空间中，你不希望允许它们连接到数据库。为了保护网络，你需要在数据库Pod相同的命名空间中创建以下列表中所示的NetworkPolicy资源。
- en: 'Listing 13.22\. A NetworkPolicy for the Postgres pod: network-policy-postgres.yaml'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.22. Postgres Pod的NetworkPolicy：network-policy-postgres.yaml
- en: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: postgres-netpolicy
    spec:   podSelector:` `1` `matchLabels:` `1` `app: database` `1` `ingress:` `2`
    `- from:` `2` `- podSelector:` `2` `matchLabels:` `2` `app: webserver` `2` `ports:`
    `3` `- port: 5432` `3`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: postgres-netpolicy
    spec: podSelector: matchLabels: app: database ingress: - from: podSelector: matchLabels:
    app: webserver ports: - port: 5432`'
- en: 1 This policy secures access to pods with app=database label.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此策略保护了带有app=database标签的Pod的访问。
- en: 2 It allows incoming connections only from pods with the app=webserver label.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它只允许来自带有app=webserver标签的Pod的入站连接。
- en: 3 Connections to this port are allowed.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 允许连接到此端口的连接。
- en: The example NetworkPolicy allows pods with the `app=webserver` label to connect
    to pods with the `app=database` label, and only on port 5432\. Other pods can’t
    connect to the database pods, and no one (not even the webserver pods) can connect
    to anything other than port 5432 of the database pods. This is shown in [figure
    13.4](#filepos1316597).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 示例NetworkPolicy允许带有`app=webserver`标签的Pod连接到带有`app=database`标签的Pod，并且仅在端口5432上。其他Pod不能连接到数据库Pod，而且没有人（甚至不是webserver
    Pods）可以连接到数据库Pod的其他端口。这如图[图13.4](#filepos1316597)所示。
- en: Figure 13.4\. A NetworkPolicy allowing only some pods to access other pods and
    only on a specific port
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4. 只允许某些Pod在特定端口上访问其他Pod的NetworkPolicy
- en: '![](images/00043.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00043.jpg)'
- en: Client pods usually connect to server pods through a Service instead of directly
    to the pod, but that doesn’t change anything. The NetworkPolicy is enforced when
    connecting through a Service, as well.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端Pod通常通过Service而不是直接连接到Pod来连接到服务器Pod，但这不会改变任何事情。当通过Service连接时，也会强制执行NetworkPolicy。
- en: 13.4.3\. Isolating the network between Kubernetes namespaces
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4.3. 在Kubernetes命名空间之间隔离网络
- en: 'Now let’s look at another example, where multiple tenants are using the same
    Kubernetes cluster. Each tenant can use multiple namespaces, and each namespace
    has a label specifying the tenant it belongs to. For example, one of those tenants
    is Manning. All their namespaces have been labeled with `tenant: manning`. In
    one of their namespaces, they run a Shopping Cart microservice that needs to be
    available to all pods running in any of their namespaces. Obviously, they don’t
    want any other tenants to access their microservice.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '现在让我们看看另一个例子，其中多个租户正在使用同一个Kubernetes集群。每个租户可以使用多个命名空间，每个命名空间都有一个标签指定它所属的租户。例如，其中一个是Manning。他们所有的命名空间都被标记为`tenant:
    manning`。在他们其中一个命名空间中，他们运行了一个需要对其所有命名空间中运行的任何Pod都可见的购物车微服务。显然，他们不希望其他租户访问他们的微服务。'
- en: To secure their microservice, they create the NetworkPolicy resource shown in
    the following listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护他们的微服务，他们创建了以下列表中所示的NetworkPolicy资源。
- en: 'Listing 13.23\. NetworkPolicy for the shopping cart pod(s): network-policy-cart.yaml'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.23. 购物车Pod的NetworkPolicy：network-policy-cart.yaml
- en: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: shoppingcart-netpolicy
    spec:   podSelector:` `1` `matchLabels:` `1` `app: shopping-cart` `1` `ingress:
      - from:     - namespaceSelector:` `2` `matchLabels:` `2` `tenant: manning` `2`
    `ports:     - port: 80`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata:   name: shoppingcart-netpolicy
    spec:   podSelector:` `1` `matchLabels:` `1` `app: shopping-cart` `1` `ingress:
      - from:     - namespaceSelector:` `2` `matchLabels:` `2` `tenant: manning` `2`
    `ports:     - port: 80`'
- en: 1 This policy applies to pods labeled as microservice= shopping-cart.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此策略适用于标记为microservice= shopping-cart的Pod。
- en: 2 Only pods running in namespaces labeled as tenant=manning are allowed to access
    the microservice.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 只有在标记为tenant=manning的命名空间中运行的Pod才允许访问微服务。
- en: 'This NetworkPolicy ensures only pods running in namespaces labeled as `tenant:
    manning` can access their Shopping Cart microservice, as shown in [figure 13.5](#filepos1319490).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '此NetworkPolicy确保只有标记为`tenant: manning`的命名空间中运行的Pod可以访问其购物车微服务，如图13.5所示[figure
    13.5](#filepos1319490)。'
- en: Figure 13.5\. A NetworkPolicy only allowing pods in namespaces matching a `namespaceSelector`
    to access a specific pod.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5\. 只允许匹配`namespaceSelector`的命名空间中的Pod访问特定Pod的NetworkPolicy。
- en: '![](images/00061.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00061.jpg)'
- en: If the shopping cart provider also wants to give access to other tenants (perhaps
    to one of their partner companies), they can either create an additional NetworkPolicy
    resource or add an additional ingress rule to their existing NetworkPolicy.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车提供商也希望允许其他租户（或许是其合作伙伴公司之一）访问，他们可以创建一个额外的NetworkPolicy资源，或者向现有的NetworkPolicy添加一个额外的入口规则。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a multi-tenant Kubernetes cluster, tenants usually can’t add labels (or annotations)
    to their namespaces themselves. If they could, they’d be able to circumvent the
    `namespaceSelector`-based ingress rules.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户Kubernetes集群中，租户通常不能自己向他们的命名空间添加标签（或注释）。如果他们可以，他们就能绕过基于`namespaceSelector`的入口规则。
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.4.4\. Isolating using CIDR notation
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4.4\. 使用CIDR表示法进行隔离
- en: Instead of specifying a pod- or namespace selector to define who can access
    the pods targeted in the NetworkPolicy, you can also specify an IP block in CIDR
    notation. For example, to allow the `shopping-cart` pods from the previous section
    to only be accessible from IPs in the 192.168.1.1 to .255 range, you’d specify
    the ingress rule in the next listing.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定Pod或命名空间选择器来定义谁可以访问NetworkPolicy中指定的目标Pod外，还可以指定CIDR表示法中的IP块。例如，要允许上一节中的`shopping-cart`
    Pod只能从192.168.1.1到.255范围内的IP访问，你将在下一列表中指定入口规则。
- en: 'Listing 13.24\. Specifying an IP block in an ingress rule: network-policy-cidr.yaml'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.24\. 在入口规则中指定IP块：network-policy-cidr.yaml
- en: '`ingress:   - from:     - ipBlock:` `1` `cidr: 192.168.1.0/24` `1`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress:   - from:     - ipBlock:` `1` `cidr: 192.168.1.0/24` `1`'
- en: 1 This ingress rule only allows traffic from clients in the 192.168.1.0/24 IP
    block.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此入口规则仅允许来自192.168.1.0/24 IP块的客户端流量。
- en: 13.4.5\. Limiting the outbound traffic of a set of pods
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 13.4.5\. 限制一组Pod的出站流量
- en: In all previous examples, you’ve been limiting the inbound traffic to the pods
    that match the NetworkPolicy’s pod selector using ingress rules, but you can also
    limit their outbound traffic through egress rules. An example is shown in the
    next listing.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的示例中，你都是通过入口规则限制匹配NetworkPolicy的Pod选择器的Pod的入站流量，但你也可以通过出口规则限制它们的出站流量。下一个列表中展示了示例。
- en: 'Listing 13.25\. Using egress rules in a NetworkPolicy: network-policy-egress.yaml'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.25\. 在NetworkPolicy中使用出口规则：network-policy-egress.yaml
- en: '`spec:   podSelector:` `1` `matchLabels:` `1` `app: webserver` `1` `egress:`
    `2` `- to:` `3` `- podSelector:` `3` `matchLabels:` `3` `app: database` `3`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec:   podSelector:` `1` `matchLabels:` `1` `app: webserver` `1` `egress:`
    `2` `- to:` `3` `- podSelector:` `3` `matchLabels:` `3` `app: database` `3`'
- en: 1 This policy applies to pods with the app=webserver label.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此策略适用于带有app=webserver标签的Pod。
- en: 2 It limits the pods’ outbound traffic.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它限制了Pod的出站流量。
- en: 3 Webserver pods may only connect to pods with the app=database label.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 Webserver Pods只能连接到带有app=database标签的Pod。
- en: The NetworkPolicy in the previous listing allows pods that have the `app=webserver`
    label to only access pods that have the `app=database` label and nothing else
    (neither other pods, nor any other IP, regardless of whether it’s internal or
    external to the cluster).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的NetworkPolicy允许带有`app=webserver`标签的Pod只能访问带有`app=database`标签的Pod，其他什么都不能访问（无论是其他Pod，还是任何其他IP，无论它是在集群内部还是外部）。
- en: 13.5\. Summary
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 13.5\. 摘要
- en: In this chapter, you learned about securing cluster nodes from pods and pods
    from other pods. You learned that
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从Pod保护集群节点，以及从其他Pod保护Pod。你了解到
- en: Pods can use the node’s Linux namespaces instead of using their own.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods可以使用节点的Linux命名空间，而不是使用它们自己的。
- en: Containers can be configured to run as a different user and/or group than the
    one defined in the container image.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以被配置为以不同于容器镜像中定义的用户和/或组运行。
- en: Containers can also run in privileged mode, allowing them to access the node’s
    devices that are otherwise not exposed to pods.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器还可以以特权模式运行，允许它们访问节点上其他情况下不对Pod暴露的设备。
- en: Containers can be run as read-only, preventing processes from writing to the
    container’s filesystem (and only allowing them to write to mounted volumes).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以以只读模式运行，防止进程向容器的文件系统写入（并且只允许它们写入挂载的卷）。
- en: Cluster-level PodSecurityPolicy resources can be created to prevent users from
    creating pods that could compromise a node.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以创建集群级别的PodSecurityPolicy资源，以防止用户创建可能危害节点的Pod。
- en: PodSecurityPolicy resources can be associated with specific users using RBAC’s
    ClusterRoles and ClusterRoleBindings.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PodSecurityPolicy资源可以通过RBAC的ClusterRoles和ClusterRoleBindings与特定用户关联。
- en: NetworkPolicy resources are used to limit a pod’s inbound and/or outbound traffic.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetworkPolicy资源用于限制Pod的入站和/或出站流量。
- en: In the next chapter, you’ll learn how computational resources available to pods
    can be constrained and how a pod’s quality of service is configured.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何限制Pod可用的计算资源，以及如何配置Pod的服务质量。
