- en: 12  Best practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 最佳实践
- en: It's time to bring this book to a close.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候结束这本书了。
- en: 'If this book were a tragedy, we''d probably end with a dramatic death. If it
    were a comedy, we might have a romantic wedding. Unfortunately, this is a book
    about Express, a topic not known for its drama and romance. The best we''ll get
    is this: a set of best practices for large Express applications. I''ll do my best
    to make it romantic and dramatic.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这本书是一部悲剧，我们可能以一个戏剧性的死亡结束。如果它是一部喜剧，我们可能有一个浪漫的婚礼。不幸的是，这本书是关于Express的，这个话题并不以戏剧性和浪漫性著称。我们能得到的最好的结果就是：一套针对大型Express应用程序的最佳实践。我将尽力让它变得浪漫和戏剧化。
- en: With small applications, organization doesn't matter much. You can fit your
    app in a single file or a handful of small files. But as your apps become larger,
    these considerations become more important. How should you organize your files
    so that your codebase is easy to work with? What kind of conventions should you
    adhere to in order to best support a team of developers?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型应用程序，组织并不重要。你可以将你的应用程序放入一个文件或几个小文件中。但随着你的应用程序变得更大，这些考虑变得更加重要。你应该如何组织你的文件，以便你的代码库易于工作？你应该遵守什么样的约定，以最好地支持一个开发团队？
- en: 'In this final chapter, I''ll do my best to share my experience. Very little
    of this chapter will be strictly factual; I''ll do my best to lend opinions to
    the unopinionated philosophy of Express with respect to what it takes to build
    a medium-to-large application with it. We''ll see:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后一部分，我将尽力分享我的经验。这一章中几乎没有严格的事实；我将尽力向Express的无意见哲学提供意见，关于用它来构建中型到大型应用程序需要什么。我们将看到：
- en: ·  High-level goals of simplicity
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  高层次的简单目标
- en: ·  Folder and file structures for your applications
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  应用程序的文件夹和文件结构
- en: ·  Locking down dependency versions for maximum reliability
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  锁定依赖项版本以实现最大可靠性
- en: ·  Installing dependencies locally and using npm scripts
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ·  在本地安装依赖项并使用npm脚本
- en: I'll make sure to repeat this disclaimer, but remember: this chapter is mostly
    opinions and conventions I've found. You may disagree or find that your application
    doesn't fit into these moulds. That's the beauty of Express—you have a lot of
    flexibility.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我会确保重复这个免责声明，但请记住：这一章主要是我找到的意见和约定。你可能不同意，或者发现你的应用程序不适合这些模式。这就是Express的美妙之处——你有很多灵活性。
- en: This might not be as emotional as a comedy or a tragedy, but I'll do my best.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不如喜剧或悲剧那样充满情感，但我将尽力而为。
- en: 12.1  Simplicity
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 简单性
- en: In this chapter of my opinions, let me offer an overarching one before we delve
    into specifics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我意见的这一章节中，在我们深入具体细节之前，让我先提出一个总的观点。
- en: There are lots of best practices for maintaining large codebases, but I think
    they all boil down to one thing: simplicity. More explicitly, your code should
    be easy for other developers to follow and you should minimize how much context
    a person has to keep in their head.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 维护大型代码库有很多最佳实践，但我认为它们都归结为一点：简单。更具体地说，你的代码应该易于其他开发者理解，你应该尽量减少一个人需要记住的上下文。
- en: In order to understand an Express application, you already have to know a lot.
    You have to be reasonably proficient in the JavaScript programming language in
    order to read the code; you have to understand how HTTP works in order to understand
    routing; you have to understand Node and its evented I/O; and then you have to
    understand all of Express's features like routing, middleware, views, and more.
    Each of these things took a long time to learn and likely builds on experience
    from earlier in your career. It's a huge pile of stuff to keep in your head!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解一个Express应用程序，你已经有相当多的知识了。你必须对JavaScript编程语言有相当熟练的掌握才能阅读代码；你必须理解HTTP的工作原理才能理解路由；你必须理解Node及其事件驱动I/O；然后你必须理解Express的所有功能，如路由、中间件、视图等。这些都需要很长时间来学习，并且很可能是基于你职业生涯早期经验的积累。这是一大堆需要记住的东西！
- en: Your applications should try to add to that massive pile of required knowledge
    as little as possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该尽量少地向这庞大的知识堆中添加内容。
- en: I think we've all written code (I certainly have) that's an intertwined mess
    that only we can hope to understand. I like to imagine one of those corkboards
    covered with pictures, all interconnected in a web of red string. Here are a couple
    of ways to see how deep the rabbit hole of your code goes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们都有过编写代码的经历（我肯定有），这些代码是错综复杂的，只有我们自己才能希望理解。我喜欢想象那些覆盖着图片的软木塞板，所有图片都通过红色丝线相互连接。这里有几种方法可以看到你的代码深度的“兔子洞”。
- en: ·  Look at a piece of your code—maybe it's a route handler or a middleware function—and
    ask yourself how many other things you'd need to know in order to understand it.
    Does it depend on a middleware earlier in the stack? How many different database
    models does it depend on? How many routers deep are you? How many files have you
    looked at to get to this point?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ·  看看您的一段代码——可能是一个路由处理程序或中间件函数——然后问问自己，为了理解它，您还需要了解多少其他内容。它是否依赖于堆栈中的早期中间件？它依赖于多少个不同的数据库模型？您有多少层路由？您查看了多少个文件才到达这个点？
- en: ·  How confused is your fellow developer? How quickly could they add a feature
    to your app? If they're confused and unable to work quickly, that might mean that
    your code is too intertwined.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ·  您的同事有多困惑？他们能多快地为您的应用程序添加功能？如果他们困惑且无法快速工作，这可能意味着您的代码过于复杂。
- en: You have to be pretty rigorous about simplicity, especially because Express
    is so flexible and unopinionated. We'll talk about some of these methods (and
    others) in this chapter, but a lot of it is more nebulous, so keep this in mind!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须对简单性非常严格，尤其是因为 Express 非常灵活且没有偏见。我们将在本章中讨论一些这些方法（以及其他方法），但其中很多都是模糊的，所以请记住这一点！
- en: Alright, enough with this abstract stuff! Let's talk about specifics.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于这些抽象的东西就到这里吧！让我们谈谈具体的事情。
- en: 12.2  File structure pattern
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 文件结构模式
- en: Express applications can be organized however you please. You could put everything
    into one giant file if you wanted to. As you might imagine, this might not make
    for an easily-maintainable application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Express 应用程序可以按照您喜欢的任何方式组织。如果您愿意，可以将所有内容放入一个巨大的文件中。正如您可能想象的那样，这可能不会使应用程序易于维护。
- en: Despite the fact that it's unopinionated, most Express applications I've worked
    with have a similar structure to the one in figure 12-1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有偏见，但我所使用的绝大多数 Express 应用程序的结构都与图 12-1 中的结构相似。
- en: '![](../Images/12_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_01.png)'
- en: Figure 12-1 A common folder structure for Express applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1 Express 应用程序的一个常见文件夹结构。
- en: 'Here are all of the common files in an Express application of this structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个结构中 Express 应用程序的所有常见文件：
- en: ·  `package.json` should come as no surprise—it's present in every Node project. This
    will have all of the app's dependencies as well as all of your npm scripts. We've
    seen different incarnations of this file all throughout the book and it's not
    different in a "big" app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `package.json` 文件并不令人意外——它在每个 Node 项目中都有。这个文件将包含应用程序的所有依赖项以及您的所有 npm 脚本。我们在整本书中都看到了这个文件的不同版本，而且在“大型”应用程序中也没有什么不同。
- en: ·  `app.js` is the main application code—the entry point. This is where you
    actually call `express()` to instantiate a new Express application. This is where
    you put middleware that's common to all routes, like security or static file middleware.
    This file doesn't start the app, as we'll see—it assigns the app to `module.exports`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `app.js` 是主要的应用程序代码——入口点。这是您实际调用 `express()` 来实例化新的 Express 应用程序的地方。这是您放置对所有路由都通用的中间件的地方，如安全或静态文件中间件。正如我们将看到的，这个文件不会启动应用程序——它将应用程序分配给
    `module.exports`。
- en: ·  `bin/` is a folder that holds executable scripts relevant to your application.
    There is often just one (listed below), but sometimes there are more that are
    required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `bin/` 是一个包含与您的应用程序相关的可执行脚本的文件夹。通常只有一个（如下所示），但有时可能需要更多。
- en: ·  `bin/www` is an executable Node script that `require`s your app (from `app.js` above)
    and starts it. Calling `npm start` runs this script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `bin/www` 是一个可执行的 Node 脚本，它 `require`s 您的应用程序（从上面的 `app.js`）并启动它。调用 `npm
    start` 将运行此脚本。
- en: ·  `config/` is a folder that'll hold any configuration for your app. It's often
    full of JSON files that specify things like default port numbers or localization
    strings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `config/` 是一个包含您应用程序配置的文件夹。它通常充满了指定默认端口号或本地化字符串等的 JSON 文件。
- en: ·  `public/` is a folder that's served by static file middleware. It'll have
    any static files inside – HTML pages, text files, images, videos etc. The HTML5
    Boilerplate at [https://html5boilerplate.com/](https://html5boilerplate.com/) for
    example presents a good selection of common static files you might add here.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `public/` 是一个由静态文件中间件提供的文件夹。它将包含任何静态文件——HTML 页面、文本文件、图像、视频等。例如，[https://html5boilerplate.com/](https://html5boilerplate.com/)
    上的 HTML5 Boilerplate 提供了一些您可能想添加到这里的常见静态文件。
- en: ·  `routes/` is a folder that holds a bunch of JavaScript files, each one exporting
    an Express Router. You might have a router for all URLs that start with `/users` and
    another for all that start with `/photos`. Chapter 5 has all the details about
    routers and routing—check out section 5.3 for examples of how this works.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `routes/` 是一个包含多个 JavaScript 文件的文件夹，每个文件都导出一个 Express 路由器。你可能有一个路由器用于所有以 `/users` 开头的
    URL，另一个用于所有以 `/photos` 开头的 URL。第 5 章详细介绍了路由和路由配置——查看第 5.3 节以了解如何实现此功能。
- en: ·  `test/` is a folder that holds all of your test code. Chapter 9 has all the
    juicy details about this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `test/` 是一个包含所有测试代码的文件夹。第 9 章详细介绍了这方面的内容。
- en: ·  `views/` is a folder that holds all of your views. Typically they are written
    in EJS or Jade as shown in Chapter 7 but there are many other templating languages
    you can use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `views/` 是一个包含所有视图的文件夹。通常，它们是用 EJS 或 Jade 编写的，如第 7 章所示，但你可以使用许多其他模板语言。
- en: The best way to see an app that has most of these conventions is by using the
    official Express application generator. You can install this with `npm install
    -g express-generator`. Once it's installed, you can run `express my-new-app`and
    it'll create a folder called `my-new-app` with a skeleton app set up, as shown
    in figure 12-1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看具有大多数这些约定的应用程序，最佳方式是使用官方的 Express 应用程序生成器。你可以使用 `npm install -g express-generator` 来安装它。安装完成后，你可以运行 `express
    my-new-app`，它将创建一个名为 `my-new-app` 的文件夹，并设置一个基本应用程序框架，如图 12-1 所示。
- en: While these are just patterns and conventions, patterns like this tend to emerge
    in Express applications I have seen.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些只是模式和约定，但我在看到的 Express 应用程序中经常出现这样的模式。
- en: 12.3  Locking down dependency versions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 锁定依赖版本
- en: 'Node has far and away the best dependency system I''ve used. A coworker of
    mine said the following to me about Node and npm: "They nailed it."'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Node 拥有我使用过的最好的依赖系统。我的一个同事对我说了以下关于 Node 和 npm 的话：“他们做到了。”
- en: 'npm uses something called Semantic Versioning (sometimes shortened to Semver)
    for all of its packages. Versions are broken up into three numbers: major, minor,
    and patch. For example, version 1.2.3 is major version 1, minor version 2, and
    patch version 3.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: npm 使用一种称为语义版本控制（有时简称为 Semver）的机制为其所有包进行版本管理。版本被分为三个数字：主版本、次版本和补丁版本。例如，版本 1.2.3
    的主版本是 1，次版本是 2，补丁版本是 3。
- en: In the rules of Semantic Versioning, a major version upgrade can have a change
    that is considered "breaking". A breaking change is one where old code wouldn't
    be compatible with new code. For example, code that worked in Express major version
    3 doesn't necessarily work with major version 4\. Minor version changes are, by
    contrast, not breaking. They generally mean a new feature that doesn't break existing
    code. Patch versions are for, well, patches--they're reserved for bug fixes and
    performance enhancements. Patches shouldn't break your code; they should generally
    make things better.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本控制的规则中，主版本升级可能包含被认为是“破坏性”的更改。破坏性更改是指旧代码与新代码不兼容的情况。例如，在 Express 主版本 3 中工作的代码不一定与主版本
    4 兼容。相比之下，次版本更改不是破坏性的。它们通常意味着一个不会破坏现有代码的新功能。补丁版本用于修复——它们保留用于错误修复和性能提升。补丁不应该破坏你的代码；它们通常会使事情变得更好。
- en: 'MAJOR VERSION ZERO There''s one asterisk to this: basically anything goes if
    the major version is 0\. The whole package is considered to be unstable at that
    point.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 主版本号为零 有一个需要注意的地方：如果主版本号为 0，那么基本上任何东西都可以。在那个阶段，整个包都被视为不稳定。
- en: By default, when you `npm install --save` a package, it downloads the latest
    version from the npm registry and then puts an "optimistic" version number in
    your `package.json` file. That means that if someone else on your team runs `npm
    install` in the project (or if you are reinstalling), they might get a newer version
    that the one you originally downloaded. That new version can have a higher minor
    version or higher patch version, but it can't have a higher major version. That
    means that it doesn't download the absolute latest version of a package; it downloads
    the latest version that should still be compatible. Figure 12-2 expands on this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你使用 `npm install --save` 安装一个包时，它会从 npm 仓库下载最新版本，然后在你的 `package.json` 文件中放置一个“乐观”的版本号。这意味着如果项目中的其他成员运行 `npm
    install` （或者如果你正在重新安装），他们可能会得到一个比你最初下载的新版本。这个新版本可能有更高的次版本号或补丁版本号，但不能有更高的主版本号。这意味着它不会下载包的绝对最新版本；它会下载仍然兼容的最新版本。图
    12-2 展示了这一点。
- en: '![](../Images/12_02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_02.png)'
- en: Figure 12-2 How optimistic versioning looks in package.json.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2 在 package.json 中乐观版本控制的外观。
- en: All good, right? If all packages adhere to Semantic Versioning, you should always
    want to get the latest compatible version so that you have all the latest features
    and have all the newest bug fixes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，对吧？如果所有包都遵循语义版本控制，你应该总是想要获取最新兼容版本，以便你拥有所有最新功能和所有最新的错误修复。
- en: 'But here''s the rub: not all packages adhere perfectly to Semantic Versioning.
    Usually, it''s because people use packages in ways the original developers don''t
    intend. Perhaps you''re relying on an untested feature or weird quirk in the library
    that is overlooked by the developers. You can''t really blame these people--no
    programmer has a clean, bug-free track record, especially when other developers
    are using their code in unexpected ways.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这里有个问题：并非所有包都完美遵循语义版本控制。通常，这是因为人们以原始开发者不期望的方式使用包。也许你依赖于一个未经测试的功能或库中的奇怪特性，这些特性被开发者忽略了。你真的不能责怪这些人——没有程序员有干净、无错误的记录，尤其是在其他开发者以意想不到的方式使用他们的代码时。
- en: I find that 99% of the time, this isn't an issue. The modules I use tend to
    be good about Semantic Versioning and npm's optimistic versioning works well.
    But when I'm deploying a business-critical application into production (also known
    as "the real world"), I like to lock down my dependency versions to minimize any
    potential hiccups. I don't want things to break with a new version of a package!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现99%的情况下，这并不是一个问题。我使用的模块通常很好地遵循语义版本控制，npm的乐观版本控制也运行良好。但是，当我将业务关键应用程序部署到生产环境（也称为“现实世界”）时，我喜欢锁定依赖项版本以最大限度地减少任何潜在的问题。我不想因为包的新版本而导致东西损坏！
- en: 'There are two ways to lock versions down: one is simple but less thorough and
    the other is very thorough.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定版本有两种方法：一种简单但不够彻底，另一种非常彻底。
- en: '12.3.1   The simple way: eschewing optimistic versioning'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1   简单方法：避免乐观版本控制
- en: A quick way to solve this problem is by obliterating optimistic versioning in
    your `package.json`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的快速方法是彻底消除你的`package.json`中的乐观版本控制。
- en: 'Optimistic versioning in your `package.json` file might look something like
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`package.json`文件中的乐观版本控制可能看起来像这样：
- en: Listing 12.1 Example of optimistic versioning in your package.json
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1：在package.json中的乐观版本控制示例
- en: '`// ...` `"dependencies": {` `  "express": "^4.12.4" #A` `}``// ...`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`// ...` `"dependencies": {` `  "express": "^4.12.4" #A` `}``// ...`'
- en: '#A The ^ character indicates optimistic versioning is allowed.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#A ^字符表示允许乐观版本控制。'
- en: 'If you are going back and editing your `package.json`, you can simply specify
    the dependency to an exact version. The example above would look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在回退并编辑你的`package.json`，你可以简单地指定依赖项的确切版本。上面的例子将看起来像这样：
- en: Listing 12.2 Example of omitting optimistic versioning in a package.json
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2：在package.json中省略乐观版本控制的示例
- en: '`// ...` `"dependencies": {` `  "express": "4.12.4"  #A` `}``// ...`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`// ...` `"dependencies": {` `  "express": "4.12.4"  #A` `}``// ...`'
- en: '#A Removing the ^ character from the version number indicates only that specific
    version of the package should be downloaded and used.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 从版本号中移除^字符仅表示应下载和使用该特定版本的包。'
- en: These edits are relatively easy to do and can lock a package down to a specific
    version.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编辑相对容易完成，可以将包锁定到特定版本。
- en: If you're installing new packages, you can turn off npm's optimistic versioning
    by changing the `--save` flag to `–save-exact`. For example, `npm install --save
    express` becomes `npm install --save-exact express`. This will install the latest
    version of Express, just like always, but it won't mark it optimistically in your `package.json`—it'll
    specify an exact version.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在安装新的包，你可以通过将`--save`标志更改为`–save-exact`来关闭npm的乐观版本控制。例如，`npm install --save
    express`变为`npm install --save-exact express`。这将安装Express的最新版本，就像以前一样，但它不会在你的`package.json`中乐观地标记它——它将指定一个确切版本。
- en: 'This simple solution has a drawback: it doesn''t pin down the version of sub-dependencies
    (the dependencies of your dependencies). Listing 12.3 shows the dependency tree
    of Express:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单解决方案的缺点是：它没有锁定子依赖项（你的依赖项的依赖项）的版本。列表12.3显示了Express的依赖项树：
- en: Listing 12.3 Express's dependency tree
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3：Express的依赖项树
- en: '`your-express-app@0.0.0` `└─┬ express@4.12.4` `  ├─┬ accepts@1.2.9` `  │ ├─┬
    mime-types@2.1.1` `  │ │ └── mime-db@1.13.0` `  │ └── negotiator@0.5.3` `  ├──
    content-disposition@0.5.0` `  ├── content-type@1.0.1` `  ├── cookie@0.1.2` ` 
    ├── cookie-signature@1.0.6` `  ├─┬ debug@2.2.0` `  │ └── ms@0.7.1` `  ├── depd@1.0.1`
    `  ├── escape-html@1.0.1` `  ├─┬ etag@1.6.0` `  │ └── crc@3.2.1` `  ├── finalhandler@0.3.6`
    `  ├── fresh@0.2.4` `  ├── merge-descriptors@1.0.0` `  ├── methods@1.1.1` `  ├─┬
    on-finished@2.2.1` `  │ └── ee-first@1.1.0` `  ├── parseurl@1.3.0` `  ├── path-to-regexp@0.1.3`
    `  ├─┬ proxy-addr@1.0.8` `  │ ├── forwarded@0.1.0` `  │ └── ipaddr.js@1.0.1` ` 
    ├── qs@2.4.2` `  ├── range-parser@1.0.2` `  ├─┬ send@0.12.3` `  │ ├── destroy@1.0.3`
    `  │ ├── mime@1.3.4` `  │ └── ms@0.7.1` `  ├── serve-static@1.9.3` `  ├─┬ type-is@1.6.3`
    `  │ ├── media-typer@0.3.0` `  │ └─┬ mime-types@2.1.1` `  │   └── mime-db@1.13.0`
    `  ├── utils-merge@1.0.0``  └── vary@1.0.0`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`your-express-app@0.0.0` `└─┬ express@4.12.4` `  ├─┬ accepts@1.2.9` `  │ ├─┬
    mime-types@2.1.1` `  │ │ └── mime-db@1.13.0` `  │ └── negotiator@0.5.3` `  ├──
    content-disposition@0.5.0` `  ├── content-type@1.0.1` `  ├── cookie@0.1.2` ` 
    ├── cookie-signature@1.0.6` `  ├─┬ debug@2.2.0` `  │ └── ms@0.7.1` `  ├── depd@1.0.1`
    `  ├── escape-html@1.0.1` `  ├─┬ etag@1.6.0` `  │ └── crc@3.2.1` `  ├── finalhandler@0.3.6`
    `  ├── fresh@0.2.4` `  ├── merge-descriptors@1.0.0` `  ├── methods@1.1.1` `  ├─┬
    on-finished@2.2.1` `  │ └── ee-first@1.1.0` `  ├── parseurl@1.3.0` `  ├── path-to-regexp@0.1.3`
    `  ├─┬ proxy-addr@1.0.8` `  │ ├── forwarded@0.1.0` `  │ └── ipaddr.js@1.0.1` ` 
    ├── qs@2.4.2` `  ├── range-parser@1.0.2` `  ├─┬ send@0.12.3` `  │ ├── destroy@1.0.3`
    `  │ ├── mime@1.3.4` `  │ └── ms@0.7.1` `  ├── serve-static@1.9.3` `  ├─┬ type-is@1.6.3`
    `  │ ├── media-typer@0.3.0` `  │ └─┬ mime-types@2.1.1` `  │   └── mime-db@1.13.0`
    `  ├── utils-merge@1.0.0` `  └── vary@1.0.0`'
- en: 'For example, I ran into a problem when trying to use the Backbone.js library.
    I wanted to pin to an exact version of Backbone, which was easy: I just specified
    the version. But in Backbone''s `package.json`—which is out of my control!—it
    specified a version of Underscore.js that was optimistically versioned. That means
    that I could get a new version of Underscore if I reinstalled my packages, and
    more dangerously, I could get a new version of Underscore when deploying my code
    to the real world. For example, your dependency tree could look like this one
    day:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在尝试使用Backbone.js库时遇到了问题。我想将Backbone固定到确切的一个版本，这很简单：我只需指定版本即可。但在Backbone的`package.json`中——这超出了我的控制！——它指定了一个乐观版本的Underscore.js。这意味着如果重新安装我的包，我可能会得到Underscore的新版本，更危险的是，当我的代码部署到现实世界时，我也可能会得到Underscore的新版本。例如，您的依赖项树可能看起来像这样的一天：
- en: '`your-express-app@0.0.0` `└─┬ backbone@1.2.3``  └── underscore@1.0.0`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`your-express-app@0.0.0` `└─┬ backbone@1.2.3` `  └── underscore@1.0.0`'
- en: 'But if Underscore updated, it could look like this on another day:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果Underscore更新了，另一天它可能看起来像这样：
- en: '`your-express-app@0.0.0` `└─┬ backbone@1.2.3``  └── underscore@1.1.0`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`your-express-app@0.0.0` `└─┬ backbone@1.2.3` `  └── underscore@1.1.0`'
- en: Note the difference in Underscore's version here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里Underscore版本的区别。
- en: With this method, there is no way to ensure that the versions of your sub-dependencies
    (or sub-sub-dependencies, and so on) are pinned down. This might be okay, or it
    might not be. If it's not, you can use a nice feature of npm called "shrinkwrap".
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，无法确保您的子依赖项（或子子依赖项，等等）的版本被固定。这可能是可以接受的，也可能不是。如果不行，您可以使用npm的一个叫作“shrinkwrap”的不错功能。
- en: '12.3.2   The thorough way: npm''s "shrinkwrap" command'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2   彻底的方法：npm的“shrinkwrap”命令
- en: The problem with the previous solution is that it doesn't lock down sub-dependency
    versions. npm has a subcommand called `shrinkwrap` that solves this problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前解决方案的问题在于它没有锁定子依赖项的版本。npm有一个名为`shrinkwrap`的子命令，可以解决这个问题。
- en: 'Let''s say you''ve run `npm install` and everything works just fine. You''re
    at a state where you want to lock down your dependencies. At this point, run a
    single command from somewhere in your project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经运行了`npm install`并且一切正常。您现在处于想要锁定依赖项的状态。此时，在您的项目中的某个位置运行一个命令：
- en: '`npm shrinkwrap`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm shrinkwrap`'
- en: You can run this in any Node project that has a `package.json` file and dependencies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何具有`package.json`文件和依赖项的Node项目中运行此命令。
- en: 'If all goes well, there will be a single line of output: "wrote npm-shrinkwrap.json".
    (If it failed, it''s likely because you''re executing this from a non-project
    directory or are missing a `package.json` file).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，将只有一行输出：“wrote npm-shrinkwrap.json”。（如果失败了，很可能是您从非项目目录执行此命令或缺少`package.json`文件）。
- en: 'Take a look at this file. You''ll see that it''s got a list of dependencies,
    their versions, and then those dependencies'' dependencies, and so on. Here''s
    a snippet of a project that just has Express installed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个文件。您会看到它列出了依赖项、它们的版本，以及这些依赖项的依赖项，依此类推。以下是一个只安装了Express的项目片段：
- en: Listing 12.4 Snippet of an example npm-shrinkwrap.json file
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 示例 npm-shrinkwrap.json 文件片段
- en: '`{` `  "dependencies": {` `    "express": {` `      "version": "4.12.4",` `     
    // ...` `      "dependencies": {` `        "accepts": {` `          "version":
    "1.2.2",` `          // ...` `          "dependencies": {` `            "mime-types":
    {` `              "version": "2.0.7",` `              // ...` `              "dependencies":
    {` `                "mime-db": {` `                  "version": "1.5.0",` `                 
    // ...` `                }` `              }` `            },` `            "negotiator":
    {` `              "version": "0.5.0",` `              // ...` `            }`
    `          }` `        },``        // ...`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "dependencies": {` `    "express": {` `      "version": "4.12.4",` `     
    // ...` `      "dependencies": {` `        "accepts": {` `          "version":
    "1.2.2",` `          // ...` `          "dependencies": {` `            "mime-types":
    {` `              "version": "2.0.7",` `              // ...` `              "dependencies":
    {` `                "mime-db": {` `                  "version": "1.5.0",` `                 
    // ...` `                }` `              }` `            },` `            "negotiator":
    {` `              "version": "0.5.0",` `              // ...` `            }`
    `          }` `        },``        // ...`'
- en: The main thing to notice is that the whole dependency tree is specified, not
    just the top layer like in `package.json`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要是，整个依赖树都被指定了，而不仅仅是 `package.json` 中的顶层。
- en: The next time you `npm install`, it won't look at the packages in `package.json`—it'll
    look at the files in `npm-shrinkwrap.json` and install from there. Every time `npm
    install` runs, it looks for the shrinkwrap file and tries to install from there.
    If you don't have one (as we haven't for the rest of this book), it'll look at `package.json`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你运行 `npm install` 时，它不会查看 `package.json` 中的包——它会查看 `npm-shrinkwrap.json` 中的文件并从那里安装。每次运行
    `npm install` 时，它都会查找 shrinkwrap 文件并尝试从那里安装。如果你没有（如本书的其余部分所示），它会查看 `package.json`。
- en: Like `package.json`, you typically check `npm-shrinkwrap.json` into version
    control. This allows all developers on the project to keep the same package versions,
    which is the whole point of shrinkwrapping!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `package.json` 类似，你通常会将 `npm-shrinkwrap.json` 检入版本控制。这允许项目上的所有开发者保持相同的包版本，这正是
    shrinkwrapping 的全部意义！
- en: UPGRADING DEPENDENCIES
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 升级依赖项
- en: This is all good once you've locked your dependencies in, but you probably don't
    want to freeze all of your dependencies forever! You might want to get bugfixes
    or patches or new features—you just want it to happen on your terms.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你锁定了依赖项，这一切都很好，但你可能不想永远冻结所有的依赖项！你可能想要获取错误修复或补丁或新功能——你只是希望按照你的意愿进行。
- en: To update or add a dependency, you'll need to run `npm install` with a package
    name and a package version. For example, if you're updating Express from 4.12.0
    to 4.12.1, you'll run `npm install express@4.12.1`. This will update the version
    in your `node_modules` folder, and you can start testing. Once it all looks good
    to you, you can run `npm shrinkwrap` again to lock in that dependency version.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新或添加依赖项，你需要运行带有包名和包版本的 `npm install`。例如，如果你要将 Express 从 4.12.0 更新到 4.12.1，你将运行
    `npm install express@4.12.1`。这将更新 `node_modules` 文件夹中的版本，然后你可以开始测试。一旦一切看起来都很好，你可以再次运行
    `npm shrinkwrap` 来锁定该依赖项版本。
- en: Sometimes, shrinkwrapping isn't for you. You might want to get all of the latest
    and greatest features and patches without having to update manually. Sometimes,
    though, you want the security of having the same dependencies across all installations
    of your project.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，shrinkwrapping 并不适合你。你可能想要获取所有最新的功能和补丁，而无需手动更新。有时，尽管如此，你希望在整个项目的所有安装中拥有相同的依赖项。
- en: 12.4  Localized dependencies
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 本地化依赖
- en: Let's keep talking about dependencies, but with a different angle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论依赖项，但从一个不同的角度。
- en: npm allows you to install packages globally on your system that execute as commands.
    There are a few "famous" ones, like Bower, Grunt, Mocha, and more. There's nothing
    wrong with doing this; there are a lot of tools that you need to install globally
    on your system. This means that, to run the Grunt command, you can type `grunt` from
    anywhere on your computer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: npm 允许你在系统上全局安装执行为命令的包。其中有一些“著名”的，如 Bower、Grunt、Mocha 等。这样做并没有什么问题；你需要安装到系统上的工具有很多。这意味着，要运行
    Grunt 命令，你可以在电脑的任何位置输入 `grunt`。
- en: 'However, you can encounter some drawbacks when someone new comes into your
    project. For example, take Grunt. Two problems can occur when installing Grunt
    globally:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当新成员加入你的项目时，你可能会遇到一些缺点。例如，以 Grunt 为例，在全局安装 Grunt 时可能会出现两个问题：
- en: 1.  The new developer doesn't have Grunt installed on their system at all. This
    means that you'll have to tell them to install it in your Readme or in some other
    documentation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 新的开发者根本没有在他们的系统上安装Grunt。这意味着你必须在你的Readme或其他文档中告诉他们安装它。
- en: 2.  The second is related to the conversation in the previous section. What
    if they have Grunt installed but it's the wrong version? You could imagine them
    having a version of Grunt that's either too old or too new, which could lead to
    weird errors that might be tough to track down.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 第二个问题与上一节中的对话相关。如果他们安装了Grunt，但版本不正确怎么办？你可以想象他们可能安装了一个过旧或过新的Grunt版本，这可能会导致一些奇怪的错误，可能很难追踪。
- en: 'There''s a pretty easy solution to these two problems: install it as a dependency
    of your project, not globally.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个问题有一个相当简单的解决方案：将其作为项目的依赖项安装，而不是全局安装。
- en: In Chapter 9, we used Mocha to use as a test framework. We could've installed
    this globally, but we didn't—we installed it locally to our project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章中，我们使用了Mocha作为测试框架。我们本可以全局安装它，但我们没有——我们将其本地安装到我们的项目中。
- en: 'When you install Mocha, it installs the `mocha` executable command into `node_modules/.bin/mocha`.
    You can get at it in one of two ways: by executing it directly or by putting it
    inside an npm script.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Mocha时，它会将`mocha`可执行命令安装到`node_modules/.bin/mocha`中。你可以通过以下两种方式访问它：直接执行或将其放入npm脚本中。
- en: INVOKING COMMANDS DIRECTLY
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用命令
- en: The simplest way is just to invoke these commands directly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法就是直接调用这些命令。
- en: 'This is pretty darn easy, although it''s a bit of typing: type the path to
    the command. If you''re trying to run Mocha, just run `node_modules/.bin/mocha`.
    If you''re trying to run Bower, just run `node_modules/.bin/bower`. (On Windows,
    running Mocha would be `node_modules\.bin\mocha`.)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，尽管需要一点输入：输入命令的路径。如果你要运行Mocha，只需运行`node_modules/.bin/mocha`。如果你要运行Bower，只需运行`node_modules/.bin/bower`。（在Windows上，运行Mocha将是`node_modules\.bin\mocha`。）
- en: There's not much to this conceptually!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，这并没有什么。
- en: EXECUTING COMMANDS FROM NPM SCRIPTS
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从npm脚本执行命令
- en: The other way to do this is by adding the command as an npm script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是添加命令作为npm脚本。
- en: 'Once again, let''s say that you want to run Mocha. Here''s how you''d specify
    that as an npm script:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设你想运行Mocha。以下是将其指定为npm脚本的方法：
- en: Listing 12.5 Specifying Mocha as an npm script
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 指定Mocha为npm脚本
- en: '`// …` `"scripts": {` `  "test": "mocha"` `},``// …`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `"scripts": {` `  "test": "mocha"` `},``// …`'
- en: 'When you type `npm test`, the `mocha` command is magically run. Let''s resurface
    a diagram from Chapter 9 that explains how this works:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入`npm test`时，`mocha`命令会神奇地运行。让我们再次引用第9章中的一个图表，解释它是如何工作的：
- en: '![](../Images/12_03.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12_03.png)'
- en: Figure 12-3 Typing npm test flows through a few steps before executing the command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3 打开npm test命令执行前需要经过几个步骤。
- en: This is generally useful when you want to run the same kind of command over
    and over. It also keeps dependencies out of your global list!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在你想要反复运行相同类型的命令时很有用。它还能将依赖项排除在你的全局列表之外！
- en: 12.5  Summary
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 摘要
- en: 'In this final chapter, we:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们：
- en: ·  Learned about simplicity and the benefits of un-interleaving your code
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: · 了解简单性和不交错代码的好处
- en: '·  A convention to structure your app''s files: a folder for routes, a folder
    for public files, a folder for views, a folder for common library-like functionality,
    and a folder for executables'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: · 一种结构化应用程序文件的约定：一个用于路由的文件夹，一个用于公共文件的文件夹，一个用于视图的文件夹，一个用于类似库的功能的文件夹，以及一个用于可执行文件的文件夹
- en: ·  Using the `npm shrinkwrap` command to lock down dependency versions for reliability
    (and the benefits of doing so)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: · 使用`npm shrinkwrap`命令锁定依赖项版本以实现可靠性（以及这样做的好处）
- en: ·  How to avoid installing modules globally
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: · 如何避免全局安装模块
- en: That's the end of this chapter and this book! Go out and build cool things with
    Express.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章和本书的结束！走出去，用Express构建酷炫的东西吧。
