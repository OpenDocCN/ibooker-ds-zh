- en: 4 Content-based recommendations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 基于内容的推荐
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Designing proper graph models for a content-based recommendation engine
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于内容的推荐引擎设计合适的图模型
- en: Importing existing (nongraph) datasets into the designed graph models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的（非图）数据集导入设计的图模型
- en: Implementing working content-based recommendation engines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现工作的基于内容的推荐引擎
- en: 'Suppose you would like to build a movie recommender system for your local video
    rental store. Old-fashioned Blockbuster-style rental shops have largely been put
    out of business by new streaming platforms such as Netflix ([http://mng.bz/0rBx](https://shortener.manning.com/0rBx)),
    but some still exist here and there. There’s one in my town. Back when I was at
    university (a long time ago), I used to go there with my brother every Sunday
    to rent some action movies. (Keep this preference in mind; it will be useful later!)
    The important fact here is that this scenario inherently has a lot in common with
    more-complex online recommender systems, including the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想为你的本地视频租赁店构建一个电影推荐系统。老式的Blockbuster风格的租赁店大多已被新的流媒体平台如Netflix（[http://mng.bz/0rBx](https://shortener.manning.com/0rBx)）所取代，但还有一些仍然存在。在我的镇上就有一个。在我上大学的时候（很久以前），我经常和哥哥每个星期天去那里租一些动作电影。（记住这个偏好；它以后会很有用！）这里的一个重要事实是，这个场景本质上与更复杂的在线推荐系统有很多共同之处，包括以下内容：
- en: '*A small user community*—The number of users or customers is quite small. Most
    recommendation engines, as we’ll discuss later, require a lot of active users
    (in terms of number of interactions, such as views, clicks, or buys) to be effective.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个小型的用户群体*—用户或客户数量相当少。大多数推荐引擎，如我们稍后将要讨论的，需要大量的活跃用户（从交互次数的角度来看，如查看、点击或购买）才能有效。'
- en: '*A limited set of well-curated items*—Each item (in this case, a movie) can
    have a lot of associated details. For movies, these details might include plot
    description, keywords, genres, and actors. These details are not always available
    in other scenarios, such as one in which the item has only an identifier.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一组精心挑选的项目*—每个项目（在这种情况下，是一部电影）可以有很多相关的细节。对于电影，这些细节可能包括剧情描述、关键词、类型和演员。在其他场景中，这些细节并不总是可用，例如，当项目只有一个标识符时。'
- en: '*Knowledge of user preferences*—The owner or shop assistant knows the preferences
    of almost all the customers, even if they’ve rented only a few movies or games.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解用户偏好*—店主或店员几乎知道几乎所有客户的偏好，即使他们只租赁过几部电影或游戏。'
- en: Before we move on to discuss technicalities and algorithms, take a moment to
    think about the brick-and-mortar shop. Think about the owner or clerks and what
    they do to succeed. They make an effort to get to know their customers by analyzing
    their previous rental habits and remembering conversations with them. They try
    to create a profile for each customer, containing details on their tastes (horror
    and action movies rather than romcoms), habits (renting generally on the weekend
    or during the week), item preferences (movies rather than video games), and so
    on. They collect information over time to build up this profile and use the mental
    models they create to welcome each customer in an effective way, suggesting something
    that could be of interest to them, or perhaps sending them a message when a tempting
    new movie becomes available in the shop.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论技术细节和算法之前，花一点时间思考一下实体店铺。想想店主或店员为了成功都做了些什么。他们通过分析客户的先前租赁习惯和记住与他们交谈的内容来努力了解他们的客户。他们试图为每位客户创建一个档案，包含他们的品味（恐怖和动作电影而不是浪漫喜剧）、习惯（通常在周末或工作日租赁）、项目偏好（电影而不是电子游戏）等详细信息。他们随着时间的推移收集信息来建立这个档案，并使用他们创建的心理模型以有效的方式欢迎每位客户，建议可能对他们感兴趣的东西，或者当商店有吸引人的新电影时，也许会给他们发一条消息。
- en: Now consider a virtual shop assistant that welcomes a site’s users, suggesting
    movies or games to rent or sending them an email when something new that might
    be of interest comes into stock. The conditions described earlier preclude some
    approaches to recommendations because they require more data. In the case we’re
    considering (both the real and the simplified virtual shop), a valuable solution
    is a *content-based recommender system (CBRS)*. CBRSs rely on item and user descriptions
    (content) to build item representations (or item profiles) and user profiles to
    suggest items similar to those a target user liked in the past. (These types of
    recommender systems are also known as *semantic-aware CBRSs*.) This approach allows
    the system to provide recommendations even when the amount of data available is
    quite small (that is, a limited number of users, items, or interactions).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个虚拟店员，它欢迎网站的访客，建议他们租借电影或游戏，或者当有新商品上架可能引起兴趣时发送电子邮件。前面描述的条件排除了某些推荐方法，因为它们需要更多的数据。在我们考虑的情况中（无论是真实还是简化的虚拟商店），一个有价值的解决方案是*基于内容的推荐系统（CBRS）*。CBRSs依赖于项目描述（内容）来构建项目表示（或项目档案）和用户档案，以建议与目标用户过去喜欢的项目相似的项目。（这类推荐系统也被称为*语义感知CBRSs*。）这种方法允许系统在可用的数据量相当小的情况下提供推荐（即，有限数量的用户、项目或交互）。
- en: The basic process of producing content-based recommendations consists of matching
    the attributes of the target user profile, in which preferences and interests
    are modeled, with the attributes of the items to find items similar to what the
    user liked in the past. The result is a relevance score that predicts the target
    user’s level of interest in those items. Usually, attributes for describing an
    item are features extracted from metadata associated with that item or textual
    features somehow related to the item—descriptions, comments, keywords, and so
    on. These content-rich items contain a great deal of information by themselves
    that can be used for making comparisons or inferring a user’s interests based
    on the list of items they’ve interacted with. For these reasons, CBRSs don’t require
    a lot of data to be effective.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 生成基于内容的推荐的基本过程包括匹配目标用户档案中的属性，其中建模了偏好和兴趣，与项目的属性，以找到与用户过去喜欢的项目相似的项目。结果是相关性分数，它预测目标用户对那些项目的兴趣水平。通常，用于描述项目的属性是从与该项目相关的元数据中提取的特征或与项目相关的文本特征——描述、评论、关键词等。这些内容丰富的项目本身就包含大量信息，可用于比较或根据用户与之交互的项目列表推断用户的兴趣。因此，CBRSs不需要大量数据就能有效。
- en: Figure 4.1 shows the high-level architecture of a CBRS, one of many possible
    architectures and the one used in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1显示了CBRS的高级架构，这是许多可能架构之一，也是本节中使用的架构。
- en: '![CH04_F01_Negro](../Images/CH04_F01_Negro.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Negro](../Images/CH04_F01_Negro.png)'
- en: Figure 4.1 High-level architecture of a CBRS
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 CBRS的高级架构
- en: 'This figure decomposes the recommendation process into three main components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此图将推荐过程分解为三个主要组成部分：
- en: '*Item analyzer*—The main purpose of this component is to analyze items, extract
    or identify relevant features, and represent the items in a form suitable for
    the next processing steps. It takes as input the item content (such as the contents
    of a book or a product description) and meta information (such as a book’s author,
    the actors in a movie, or movie genres) from one or more information sources and
    converts them to an item model that is used later to provide recommendations.
    In the approach described here, this conversion produces graph models, which can
    be of different types. This graph representation is used to feed the recommendation
    process.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目分析器*——此组件的主要目的是分析项目，提取或识别相关特征，并以适合后续处理步骤的形式表示项目。它从一个或多个信息源中获取项目内容（如书籍或产品描述的内容）和元信息（如书籍的作者、电影中的演员或电影类型），并将它们转换为用于后续提供推荐的项模型。在本节中描述的方法中，这种转换产生图模型，可以是不同类型的。这种图表示用于向推荐过程提供数据。'
- en: '*User profile builder*—This process collects data representative of user preferences
    and infers user profiles. This information set may include explicit user preferences
    gathered by asking users about their interests or implicit feedback collected
    by observing and storing user behavior. The result is a model—specifically, a
    graph model—that represents user interest in some item, item feature, or both.
    In the architecture shown in figure 4.1, the item profiles (created during the
    item analysis stage) and user profiles (created during this stage) converge in
    the same database. Moreover, because both processes return a graph model, their
    outputs can be combined into a single connected, easy-to-access graph model to
    be used as the input of the next phase.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户资料构建器*—此过程收集代表用户偏好的数据并推断用户资料。此信息集可能包括通过询问用户关于他们的兴趣收集到的显式用户偏好或通过观察和存储用户行为收集到的隐式反馈。结果是模型——具体来说，是表示用户对某些项目、项目特征或两者的兴趣的图模型。在图4.1所示的架构中，项目资料（在项目分析阶段创建）和用户资料（在此阶段创建）在同一个数据库中汇聚。此外，由于这两个过程都返回图模型，它们的输出可以组合成一个单一的、易于访问的图模型，用作下一阶段的输入。'
- en: '*Recommendation engine*—This module exploits the user profiles and item representations
    to suggest relevant items by matching user interests with item features. In this
    phase, you build a prediction model and use it to create a relevancy score for
    each item for each user. This score is used to rank and order the items to suggest
    to the user. Some recommendation algorithms precompute relevant values, such as
    item similarities, to make the prediction phase faster. In the approach proposed
    here, such new values are stored back in the graph, which is in this way enriched
    with other data inferred from the item profiles.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推荐引擎*—此模块通过匹配用户兴趣与项目特征来利用用户资料和项目表示，建议相关项目。在这个阶段，你构建一个预测模型并使用它为每个用户创建每个项目的相关性得分。这个得分用于对项目进行排序和排序，以向用户推荐。一些推荐算法预先计算相关值，例如项目相似度，以使预测阶段更快。在本方法中，这些新值被存储回图中，从而通过从项目资料中推断出的其他数据丰富了图。'
- en: In section 4.1, each module is described in greater detail. Specifically, I
    describe how a graph model can be used to represent the item and user profiles
    that are the outputs of the item analysis and profile-building stages, respectively.
    Such an approach simplifies the recommendation phase.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.1节中，每个模块都进行了更详细的描述。具体来说，我描述了如何使用图模型来表示项目分析和资料构建阶段输出的项目和用户资料。这种方法简化了推荐阶段。
- en: As in the rest of the chapter and most of the book from now on, real examples
    are presented, using publicly available datasets and data sources. The MovieLens
    dataset ([https://grouplens.org/datasets/movielens](https://grouplens.org/datasets/movielens))
    contains ratings of movies provided by real users and is a standard dataset for
    recommendation engine tests. This dataset doesn’t contain a lot of information
    about the movies, however, and a content-based recommender requires content to
    work. This is why in our examples, it is used in combination with data available
    from the Internet Movie Database (IMDb),[¹](#pgfId-1011867) such as plot descriptions,
    keywords, genres, actors, directors, and writers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章的其余部分以及从现在开始的大多数书籍一样，将展示真实示例，使用公开可用的数据集和数据源。MovieLens数据集([https://grouplens.org/datasets/movielens](https://grouplens.org/datasets/movielens))包含真实用户提供的电影评分，是推荐引擎测试的标准数据集。然而，这个数据集并没有包含很多关于电影的信息，并且基于内容的推荐器需要内容才能工作。这就是为什么在我们的示例中，它与来自互联网电影数据库（IMDb）的数据结合使用，例如故事梗概、关键词、类型、演员、导演和编剧。
- en: 4.1 Representing item features
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 表示项目特征
- en: In the content-based approach to recommendation, an item can be represented
    by a set of features. *Features* (also called *properties* or *attributes*) are
    important or relevant characteristics of that item. In simple cases, such characteristics
    are easy to discover, extract, or gather. In the movie recommendation example,
    each movie can be described by using
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于内容的推荐方法中，一个项目可以通过一组特征来表示。*特征*（也称为*属性*或*属性*）是该项目的具有重要性或相关性的特征。在简单的情况下，这些特征很容易发现、提取或收集。在电影推荐示例中，每部电影都可以通过使用以下特征来描述
- en: Genres or categories (horror, action, cartoon, drama, and so on)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型或类别（恐怖、动作、卡通、戏剧等）
- en: Plot description
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事梗概
- en: Actors
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员
- en: Tags or keywords manually (or automatically) assigned to the movie
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动（或自动）分配给电影的标签或关键词
- en: Year of production
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作年份
- en: Director
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导演
- en: Writer(s)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编剧
- en: Producer(s)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作人
- en: 'Consider the information presented in table 4.1 (source: IMDb).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表 4.1 中提供的信息（来源：IMDb）。
- en: Table 4.1 Examples of movie-related data
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 电影相关数据示例
- en: '| Title | Genre | Director | Writers | Actors |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 标题 | 类型 | 导演 | 编剧 | 演员 |'
- en: '| Pulp Fiction | Action, Crime, Thriller | Quentin Tarantino | Quentin Tarantino,
    Roger Avary | John Travolta, Samuel Jackson, Bruce Willis, Uma Thurman |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 低俗小说 | 动作，犯罪，惊悚 | 昆汀·塔伦蒂诺 | 昆汀·塔伦蒂诺，罗杰·阿维里 | 约翰·特拉沃尔塔，塞缪尔·杰克逊，布鲁斯·威利斯，乌玛·瑟曼
    |'
- en: '| The Punisher (2004) | Action, Adventure, Crime, Drama, Thriller | Jonathan
    Hensleigh | Jonathan Hensleigh, Michael France | Thomas Jane, John Travolta, Samantha
    Mathis |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 惩罚者（2004） | 动作，冒险，犯罪，剧情，惊悚 | 乔纳森·亨谢利 | 乔纳森·亨谢利，迈克尔·弗朗斯 | 托马斯·简，约翰·特拉沃尔塔，萨曼莎·玛瑟斯
    |'
- en: '| Kill Bill: Volume 1 | Action, Crime, Thriller | Quentin Tarantino | Quentin
    Tarantino, Uma Thurman | Uma Thurman, Lucy Liu, Vivica A. Fox |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 杀戮比尔：第一卷 | 动作，犯罪，惊悚 | 昆汀·塔伦蒂诺 | 昆汀·塔伦蒂诺，乌玛·瑟曼 | 乌玛·瑟曼，刘玉玲，薇薇卡·A·福克斯 |'
- en: Such features are defined generally as *meta information* because they are not
    actually the content of the item. Unfortunately, there are classes of items for
    which it is not so easy to find or identify features, such as document collections,
    email messages, news articles, and images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征通常被定义为 *元信息*，因为它们实际上不是项目的内 容。不幸的是，有一些项目的类别，找到或识别特征并不容易，例如文档集合、电子邮件消息、新闻文章和图像。
- en: Text-based items do not tend to have readily available sets of features. Nonetheless,
    their content can be represented by identifying a set of features that describe
    them. A common approach is the identification of words that characterize the topic.
    Different techniques exist for accomplishing this task, some of which are described
    in section 12.4.2; the result is a list of features (keywords, tags, relevant
    words) that describe the content of the item. These features can be used to represent
    a text-based item in exactly the same way as the meta information here, so the
    approach described from now on can be applied when meta information features are
    easily accessible or when features have to be extracted from content. Extracting
    tags or features from images is out of the scope of this book, but when those
    features have been extracted, the approach is exactly the same as that discussed
    in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 文本型项目通常没有现成的特征集。尽管如此，它们的内容可以通过识别描述它们的特征集来表示。一种常见的方法是识别表征主题的单词。存在不同的技术来完成这项任务，其中一些在
    12.4.2 节中有所描述；结果是特征列表（关键词、标签、相关单词），这些特征描述了项目的内 容。这些特征可以用来以与这里元信息相同的方式表示文本型项目，因此从现在开始描述的方法可以在元信息特征易于访问或需要从内容中提取特征时应用。从图像中提取标签或特征超出了本书的范围，但一旦提取了这些特征，方法与本章讨论的方法完全相同。
- en: Although representing such a list of features in a graph—more precisely, a *property
    graph*[²](#pgfId-1011891)—is straightforward, you should take into account some
    modeling best practices while designing the item model. Consider, as a simplistic
    example, the graph model in figure 4.2 of the movies in table 4.1 with their related
    features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在图中表示这样的特征列表——更确切地说，是一个 *属性图*²(#pgfId-1011891)——是直 接的，但在设计项目模型时，你应该考虑一些建模最佳实践。以一个简化的例子来说，考虑表
    4.1 中电影的图模型，如图 4.2 所示，以及它们相关的特征。
- en: '![CH04_F02_Negro](../Images/CH04_F02_Negro.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Negro](../Images/CH04_F02_Negro.png)'
- en: Figure 4.2 Basic graph-based item representation
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 基于图的项目基本表示
- en: In this figure, the simplest possible representation of the item is used, with
    the related list of attributes. For each item, a single node is created, and the
    features are modeled as properties of the node. Listing 4.1 shows the Cypher queries
    used to create the three movies. (Run the queries one at a time). Please refer
    to appendix B for basic information on Neo4j, guidance on the installation, and
    a quick intro to Cypher. You’ll learn the rest throughout the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，使用了可能的最简单表示方式，包括相关的属性列表。对于每个项目，创建一个单独的节点，并将特征建模为节点的属性。列表 4.1 展示了用于创建三个电影的
    Cypher 查询。（逐个运行查询）。请参考附录 B 获取关于 Neo4j 的基本信息、安装指南以及 Cypher 的快速介绍。你将在本书的其余部分学习到其他内容。
- en: Listing 4.1 Queries to create a basic model for movie representation
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 创建电影表示基本模型的查询
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Each CREATE statement creates a new node with Movie as the label.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每个 CREATE 语句创建一个带有 Movie 标签的新节点。
- en: ❷ The curly braces define the list of key/value properties of the node, beginning
    with title.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 大括号定义了节点的键/值属性列表，从标题开始。
- en: '❸ Properties can be of different types: strings, arrays, integers, doubles,
    and so on.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 属性可以是不同类型：字符串、数组、整数、双精度浮点数等。
- en: ❹ The parentheses define the boundaries of the created node instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 括号定义了创建的节点实例的边界。
- en: In the Cypher queries, CREATE allows you to create a new node (or relationship).
    The parentheses define the boundaries of the created node instances, which in
    these cases are identified by p, t, and k, and a specific label, Movie, is assigned
    to each new node. The label specifies the type of a node or the role the node
    is playing in the graph. Using labels is not mandatory, but it is a common and
    useful practice for organizing nodes in a graph (and is more performant than assigning
    a type property to each node). Labels are a bit like tables in an old-fashioned
    relational database, identifying classes of nodes, but in a property graph database,
    there are no constraints on the list of attributes (as there are for columns in
    the relational model). Each node, regardless of the label assigned to it, can
    contain any set of properties or even no properties. Furthermore, a node can have
    multiple labels. These two features of the property graph database—no constraints
    on the list of attributes and multiple labels—make the resulting model quite flexible.
    Finally, a set of comma-separated properties is specified inside the curly braces.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cypher查询中，CREATE允许你创建一个新的节点（或关系）。括号定义了创建的节点实例的边界，在这些情况下由p、t和k标识，并且每个新节点都被分配了一个特定的标签，即Movie。标签指定了节点的类型或节点在图中所扮演的角色。使用标签不是强制性的，但它是组织图中节点的一种常见且有用的做法（并且比为每个节点分配类型属性更高效）。标签有点像旧式关系数据库中的表，标识节点类别，但在属性图数据库中，对属性列表没有约束（如关系模型中的列那样）。每个节点，无论分配给它什么标签，都可以包含任何一组属性或甚至没有任何属性。此外，一个节点可以有多个标签。属性图数据库的这两个特性——对属性列表没有约束和多个标签——使得结果模型非常灵活。最后，在花括号内指定了一组以逗号分隔的属性。
- en: The single-node design approach has the advantage of a one-to-one mapping between
    the node and the item with all the relevant attributes. With an effective index
    configuration, retrieving movies by feature values is fast. The Cypher query to
    retrieve all the movies directed by Quentin Tarantino, for example, looks like
    the following listing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单节点设计方法的优势在于节点与具有所有相关属性的项目之间的一对一映射。通过有效的索引配置，通过特征值检索电影非常快。例如，检索由Quentin Tarantino执导的所有电影的Cypher查询看起来如下所示。
- en: Listing 4.2 Query to search for all the movies directed by Quentin Tarantino
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 查询以搜索由Quentin Tarantino执导的所有电影
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '❶ The MATCH clause defines the graph pattern to match: a node with the label
    Movie in this case.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ MATCH子句定义了要匹配的图模式：在这种情况下是带有标签Movie的节点。
- en: ❷ The WHERE clause defines the filter conditions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ WHERE子句定义了过滤条件。
- en: ❸ The RETURN clause specifies the list of elements to return.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ RETURN子句指定了要返回的元素列表。
- en: In this query, the MATCH clause is used to define the graph pattern to match.
    Here, we are looking for all the Movie nodes. The WHERE clause is part of MATCH
    and adds constraints—filters—to it, as in relational SQL. In this example, the
    query is filtering by the director’s name. The RETURN clause specifies what to
    return. Figure 4.3 shows the result of running this query from the Neo4j browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，MATCH子句用于定义要匹配的图模式。在这里，我们正在寻找所有的Movie节点。WHERE子句是MATCH的一部分，并添加了约束——过滤器，就像关系SQL中的那样。在这个例子中，查询是通过导演的名字进行过滤的。RETURN子句指定了要返回的内容。图4.3显示了从Neo4j浏览器运行此查询的结果。
- en: '![CH04_F03_Negro](../Images/CH04_F03_Negro.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Negro](../Images/CH04_F03_Negro.png)'
- en: Figure 4.3 Query results from the Neo4j browser for the simple model
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 Neo4j浏览器对简单模型的查询结果
- en: 'The simple model has multiple drawbacks, including the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 简单模型存在多个缺点，包括以下内容：
- en: '*Data duplication*—In each property, data is duplicated. The director name,
    for example, is duplicated in all the movies with the same director, and the same
    is true for authors, genres, and so on. Data duplication is an issue in terms
    of the disk space required by the database and data consistency (how can we know
    whether "Q. Tarantino" is the same as "Quentin Tarantino"?), and it makes change
    difficult.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据重复*—在每个属性中，数据都是重复的。例如，导演的名字在所有由同一导演执导的电影中都是重复的，对于作者、类型等也是如此。数据重复在数据库所需的磁盘空间和数据一致性（我们如何知道“Q.
    Tarantino”和“Quentin Tarantino”是否相同？）方面是一个问题，并且它使得更改变得困难。'
- en: '*Error proneness*—Particularly during data ingestion, this simple model is
    subject to issues such as misspelled values and property names. These errors are
    difficult to identify if the data is isolated in each node.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易出错性*—尤其是在数据导入期间，此简单模型容易受到诸如拼写错误和属性名称等问题的影响。如果数据在每个节点中是孤立的，这些错误很难识别。'
- en: '*Difficult to extend/enrich*—If, during the life of the model, an extension
    is required, such as grouping genres to improve search capabilities or provide
    semantic analysis, these features are hard to provide.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*难以扩展/丰富*—如果在模型的生命周期中需要扩展，例如分组流派以改进搜索能力或提供语义分析，这些功能很难提供。'
- en: '*Navigation complexity*—Any access or search is based on value comparison or,
    worse, string comparison. Such a model doesn’t use the real power of graphs, which
    enable efficient navigation of relationships and nodes.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*导航复杂性*—任何访问或搜索都是基于值比较，或者更糟糕的是，基于字符串比较。这种模型没有使用图的真实力量，图能够有效地导航关系和节点。'
- en: To better understand why such a model is poor in terms of navigation and access
    patterns, suppose that you wanted to query for “Actors who worked together in
    the same movie.” Such a query can be written as shown in listing 4.3.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解为什么这种模型在导航和访问模式方面表现不佳，假设你想查询“在同一部电影中共同工作的演员”。此类查询可以写成如图表4.3所示。
- en: Listing 4.3 Query to find the actors who worked together (simple model)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3查询以找到共同工作的演员（简单模型）。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Searches for all the movies
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 搜索所有电影。
- en: ❷ Forwards the actors list to the next step
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将演员列表传递到下一步。
- en: ❸ This UNWIND converts the actors list to multiple rows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此UNWIND将演员列表转换为多行。
- en: ❹ This second MATCH with the WHERE filter searches for all the movies each actor
    acted in.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此第二个MATCH与WHERE过滤器搜索每个演员参演的所有电影。
- en: ❺ Forwards the actor, the list of actors in each movie that actor acted in (coactors
    in the same movie), and the title
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将演员列表、该演员参演的每部电影中的演员列表（同电影中的合演者）以及电影标题传递。
- en: ❻ Converts the list of other actors to multiple rows
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将其他演员的列表转换为多行。
- en: ❼ Forwards the pair of actors and the title of the movie in which they coacted
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将演员对和共同参演的电影的标题传递。
- en: ❽ Filters out the pair in which the actor is paired with himself or herself
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 过滤掉演员与自己配对的配对。
- en: ❾ Orders the result by the name of the first actor in the pair
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 按对中第一个演员的姓名排序结果。
- en: 'This query works as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的工作方式如下：
- en: The first MATCH searches for all the movies.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个MATCH搜索所有电影。
- en: WITH is used to forward the results to the next step. The first one forwards
    only the actors list.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WITH用于将结果传递到下一步。第一个WITH仅传递演员列表。
- en: With UNWIND, you can transform any list back to individual rows. The list of
    actors in each movie is converted to a sequence of actors.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用UNWIND，你可以将任何列表转换回单独的行。每部电影中的演员列表被转换成一系列演员。
- en: For each actor, the next MATCH with the WHERE condition finds all the movies
    they acted in.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个演员，下一个MATCH与WHERE条件一起找到他们参演的所有电影。
- en: The second WITH forwards the actor considered in this iteration, the list of
    actors in each movie they acted in, and the movie title.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个WITH传递本次迭代中考虑的演员、他们参演的每部电影中的演员列表以及电影标题。
- en: The second UNWIND transforms the list of other actors and forwards the actor-other
    actor pair along with the title of the film they acted in together.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个UNWIND将其他演员的列表转换，并将演员-其他演员对以及他们共同参演的电影的标题一起传递。
- en: The last WHERE filters out pairs in which the actor is paired with their own
    self.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的WHERE过滤器过滤掉演员与自己配对的配对。
- en: The query returns the names in each pair and the title of the movie in which
    both acted.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询返回每对中的姓名以及他们共同参演的电影的标题。
- en: The results are sorted, with the clause ORDER BY, by the name of the first actor
    in the pair.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果按ORDER BY子句排序，即按对中第一个演员的姓名排序。
- en: In such a query, all the comparisons are based on string matches, so if there
    is a misspelling or a different format ("U. Thurman" instead of "Uma Thurman",
    for example), the results will be incorrect or incomplete. Figure 4.4 shows the
    result of running this query on the graph database we created.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类查询中，所有比较都是基于字符串匹配，因此如果存在拼写错误或不同的格式（例如，“U. Thurman”而不是“Uma Thurman”），结果将是不正确或不完整的。图4.4显示了在我们创建的图数据库上运行此查询的结果。
- en: '![CH04_F04_Negro](../Images/CH04_F04_Negro.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Negro](../Images/CH04_F04_Negro.png)'
- en: Figure 4.4 Results from the query with the sample database we created
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4使用我们创建的示例数据库查询的结果。
- en: A more advanced model for representing items, which is even more useful and
    powerful for these specific purposes, exposes recurring properties as nodes. In
    this model, each entity, such as an actor, a director, or a genre, has its own
    representation—its own node. The relationships among such entities are represented
    by edges in the graph. The edge can also contain some properties to further characterize
    the relationship. Figure 4.5 shows what the new model looks like for the movie
    scenario.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更高级的表示物品的模型，对于这些特定目的来说更加有用和强大，它将重复出现的属性作为节点暴露出来。在这个模型中，每个实体，如演员、导演或类型，都有自己的表示——自己的节点。这些实体之间的关系由图中的边表示。边也可以包含一些属性来进一步描述关系。图4.5显示了新模型在电影场景中的样子。
- en: '![CH04_F05_Negro](../Images/CH04_F05_Negro.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Negro](../Images/CH04_F05_Negro.png)'
- en: Figure 4.5 Advanced graph-based item representation
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 基于图的高级物品表示
- en: New nodes appear in the advanced model to represent each feature value, and
    the feature types are specified by labels such as Genre, Actor, Director, and
    Writer. Some nodes can have multiple labels, because they can have multiple roles
    in the same or different movies. Each node has some properties that describe it,
    such as name for actors and directors and genre for genres. Now the movies have
    only the title property because this property is specific to the item itself;
    there’s no reason to extract it and represent it as a separate node. The queries
    to create this new graph model for the movie example are shown in the following
    listing.[³](#pgfId-1011913)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级模型中，新节点出现以表示每个特征值，特征类型由标签如类型、演员、导演和编剧指定。某些节点可以有多个标签，因为它们可以在同一部电影或不同电影中扮演多个角色。每个节点都有一些属性来描述它，例如演员和导演的名字以及类型的类型。现在电影只有标题属性，因为这个属性是针对项目本身的特定属性；没有理由提取它并将其表示为单独的节点。创建此新图模型的电影示例的查询如下所示。[³](#pgfId-1011913)
- en: Listing 4.4 Queries to create an advanced model for movie representation
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 创建电影表示的高级模型的查询
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Each of these statements creates a unique constraint in the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些语句中的每一个都在数据库中创建一个唯一约束。
- en: ❷ Each CREATE creates the movie with only the title as a property.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个CREATE语句都只使用标题属性创建电影。
- en: ❸ FOREACH loops over a list and executes the MERGE for each element.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ FOREACH循环遍历一个列表并对每个元素执行MERGE操作。
- en: ❹ MERGE first checks whether the node already exists, using the uniqueness of
    the director name in this case; if not, it creates the node.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ MERGE首先检查节点是否已经存在，在这种情况下使用导演名字的唯一性；如果不存在，则创建该节点。
- en: Although graph databases are generally referred to as schemaless, in Neo4j it
    is possible to define some constraints in the database. In this case, the first
    three queries create three constraints on the uniqueness of the title in a Movie,
    the value of a Genre, and the name of a Person, respectively, which will prevent,
    for example, having the same person (actor, director, or writer) appear several
    times in the database. As described previously, in the new model the idea is to
    have a single entity represented by a single node in the database. The constraints
    help enforce this modeling decision.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图数据库通常被称为无模式，但在Neo4j中可以在数据库中定义一些约束。在这种情况下，前三个查询分别创建三个约束，分别针对电影标题的唯一性、类型的值和人物的名字，从而防止例如同一个人（演员、导演或编剧）在数据库中多次出现。如前所述，在新模型中，想法是数据库中只有一个节点代表一个单一实体。这些约束有助于强制执行这种建模决策。
- en: After the constraint creation, the CREATE clause (repeated three times, once
    for each movie in the example) works as before to create each new Movie with the
    title as a property. Then the FOREACH clauses loop over directors, actors, writers,
    and genres, respectively, and for each element, they search for a node to connect
    to the Movie node, creating a new node if necessary. In the case of actors, writers,
    and directors, a generic node with the label Person is created by means of a MERGE
    clause. MERGE ensures that the supplied pattern exists in the graph, either by
    reusing existing nodes and relationships that match the supplied predicates or
    by creating new nodes and relationships. The SET clause in this case assigns a
    new specific label to the node, depending on needs. The MERGE in the FOREACH checks
    for (and creates if necessary) the relationship between the Person and the Movie.
    A similar approach is used for genres. The overall result is shown in figure 4.6.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建约束之后，CREATE子句（在示例中重复三次，每次针对一部电影）像以前一样工作，以创建每个新的电影，并将标题作为属性。然后FOREACH子句分别遍历导演、演员、编剧和类型，对于每个元素，它们搜索与电影节点连接的节点，如果需要则创建新的节点。在演员、编剧和导演的情况下，通过MERGE子句创建一个具有标签Person的通用节点。MERGE确保提供的模式存在于图中，要么通过重用与提供的谓词匹配的现有节点和关系，要么通过创建新的节点和关系。在这种情况下，SET子句根据需要为节点分配一个新的特定标签。FOREACH中的MERGE检查（并在必要时创建）人与电影之间的关系。对于类型也采用类似的方法。整体结果如图4.6所示。
- en: Modeling pro tip
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模型技巧
- en: You can use multiple labels for the same node. In this case, this approach is
    both useful and necessary because, in the model, we would like to have each person
    represented uniquely regardless of the role they play in the movie (actor, writer,
    or director). For this reason, we opt for MERGE instead of CREATE and use a common
    label for all of them. At the same time, the graph model assigns a specific label
    for each role the person has. After it is assigned, a label becomes assigned to
    the node, so it will be easier and more performant to run queries such as "Find
    me all the producers who..."
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为同一个节点使用多个标签。在这种情况下，这种方法既有用又必要，因为在模型中，我们希望每个人都能被独特地表示，无论他们在电影中扮演什么角色（演员、编剧或导演）。因此，我们选择使用MERGE而不是CREATE，并为所有人使用一个共同的标签。同时，图模型为每个人扮演的每个角色分配一个特定的标签。一旦分配，标签就会分配给节点，这样运行查询如“找到所有制片人...”将会更容易和更高效。
- en: '![CH04_F06_Negro](../Images/CH04_F06_Negro.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F06_Negro](../Images/CH04_F06_Negro.png)'
- en: Figure 4.6 Advanced graph-based item representation for the three movies
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 三部电影的高级基于图的项表示
- en: 'The new descriptive model not only solves all the issues described earlier,
    but also provides multiple advantages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 新的描述性模型不仅解决了之前描述的所有问题，还提供了多个优势：
- en: '*No data duplication*—Mapping each relevant entity (person, genre, and so on)
    to a specific node prevents data duplication. The same entity can play different
    roles and have different relationships. (Uma Thurman is not only an actress in
    *Kill Bill: Volume I*, but also one of the writers.) Moreover, for each item a
    list of alternative forms or aliases can be stored ("Q. Tarantino", "Director
    Tarantino", "Quentin Tarantino"). This approach helps with searches and prevents
    the same concept from being represented in multiple nodes.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无数据重复*—将每个相关实体（人物、类型等）映射到特定的节点可以防止数据重复。同一个实体可以扮演不同的角色并具有不同的关系。（乌玛·瑟曼不仅在《杀死比尔：卷一》中是女演员，还是编剧之一。）此外，对于每个项目，可以存储一个包含替代形式或别名的列表（“Q.
    Tarantino”，“Tarantino导演”，“Quentin Tarantino”）。这种方法有助于搜索并防止同一概念在多个节点中表示。'
- en: '*Error tolerance*—Preventing data duplication guarantees better tolerance to
    errors in the values. Unlike in the previous model, in which a misspelled value
    is hard to spot because it is distributed among all the nodes as a property, here
    the information is centralized in isolated and nonreplicated entities, making
    errors easy to identify.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误容错性*—防止数据重复保证了更好的对值错误的容错性。与之前模型不同，在之前的模型中，由于拼写错误作为属性分布在所有节点之间，很难被发现，这里信息集中在隔离且非重复的实体中，使得错误容易识别。'
- en: '*Easy to extend/enrich*—Entities can be grouped by using a common label or
    creating a new node and connecting it to the related nodes. This approach can
    improve the query performance or style. We can connect multiple genres, such as
    Crime and Thriller, under a common Drama node.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易于扩展/丰富*—可以使用共同的标签或创建一个新的节点并将其连接到相关节点来对实体进行分组。这种方法可以提高查询性能或风格。我们可以在一个共同的戏剧节点下连接多个类型，如犯罪和惊悚。'
- en: '*Easy to navigate*—Each node and even each relationship can be the entry point
    of the navigation (actors, genres, directors, and so on), whereas in the previous
    schema, the only available entry points were the features in the nodes. This approach
    enables multiple and more efficient access patterns to the data.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*易于导航*——每个节点甚至每个关系都可以作为导航的入口点（演员、类型、导演等等），而在先前的模式中，唯一的入口点是节点中的特征。这种方法使得对数据的访问模式更加多样化和高效。'
- en: Consider again the query for “Actors who worked together in the same movie.”
    In the new model, constructing this query is much easier, as you can see in the
    following listing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑“在同一部电影中共同工作的演员”的查询。在新模型中，构建此查询要容易得多，如下列所示。
- en: Listing 4.5 Query to find all the actors who worked together (advanced model)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 查询以找到所有共同工作的演员（高级模型）
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ In this case, the MATCH clause specifies a more complex graph pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这种情况下，MATCH子句指定了一个更复杂的图模式。
- en: ❷ The identity pair is removed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标识对被移除。
- en: Listing 4.5 produces exactly the same result as listing 4.4, but it’s much simpler,
    clearer, and even faster—evidently a better use of the MATCH clause. Here, instead
    of describing a single node, the query describes the entire graph pattern we are
    looking for; we’re looking for two actors who worked on the same movie, movie,
    and the WHERE filters out the original actor. The result is shown in figure 4.7.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5产生的结果与列表4.4完全相同，但它更简单、更清晰，甚至更快——显然是更好地使用了MATCH子句。在这里，查询描述的不是单个节点，而是我们正在寻找的整个图模式；我们正在寻找两位共同出演过同一部电影的电影演员，WHERE子句过滤掉了原始演员。结果如图4.7所示。
- en: '![CH04_F07_Negro](../Images/CH04_F07_Negro.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F07_Negro](../Images/CH04_F07_Negro.png)'
- en: Figure 4.7 Results from listing 4.5 with the sample database created
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 列表4.5的样本数据库创建结果
- en: It is worth noting that there is no string comparison. Furthermore, the query
    is much simpler, and on a bigger database, it will execute faster. If you recall
    our discussion of the native graph database (section 2.3.4) and how Neo4j implements
    adjacency-free indexes for node relationships (appendix B), it will be much faster
    than the index lookups on strings that are necessary in listing 4.3.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这里没有字符串比较。此外，查询要简单得多，在一个更大的数据库中，它将执行得更快。如果您还记得我们关于原生图数据库（第2.3.4节）的讨论以及Neo4j如何实现节点关系的无邻接索引（附录B），它将比列表4.3中必要的字符串索引查找要快得多。
- en: 'We’ve designed our final graph-based model for representing items. In a real
    machine learning project, the next step would be creating the database, importing
    data from one or more sources. As stated at the beginning of this section, the
    MovieLens dataset was selected as a testing dataset. You can download the dataset
    from GroupLens ([https://grouplens.org/datasets/movielens](https://grouplens.org/datasets/movielens)).
    The code repository contains the instructions and the procedures to download in
    the right directories and set the code to run properly. Depending on how long
    you’re willing to wait to see a first graph database, you can choose a suitable
    dataset size. (If you’re impatient, choose the smallest.) The dataset contains
    only a little information about each movie, such as the title and a list of genres,
    but it also contains a reference to IMDb, where it is possible to access all sorts
    of details about the movie: plot, directors, actors, writers, and so on. This
    data is exactly what we need.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设计了我们用于表示项目的最终图模型。在一个真实的机器学习项目中，下一步将是创建数据库，从一个或多个来源导入数据。如本节开头所述，MovieLens数据集被选为测试数据集。您可以从GroupLens（[https://grouplens.org/datasets/movielens](https://grouplens.org/datasets/movielens)）下载该数据集。代码仓库包含了在正确的目录下下载的说明和步骤，以及设置代码正确运行的流程。根据您愿意等待多长时间来查看第一个图数据库，您可以选择合适的数据集大小。（如果您不耐烦，请选择最小的。）数据集只包含关于每部电影的一点点信息，例如标题和一系列类型，但它还包含一个指向IMDb的引用，在那里可以访问有关电影的各类详细信息：剧情、导演、演员、编剧等等。这些数据正是我们所需要的。
- en: Listings 4.6 and 4.7 contain the Python code necessary for reading the data
    from the MovieLens dataset, storing the first nodes in the graph, and then enriching
    them by using the information available on IMDb. (You should tidy your database,
    but doing so is not mandatory.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6和4.7包含了从MovieLens数据集中读取数据、在图中存储第一个节点以及使用IMDb上可用的信息来丰富它们的Python代码。（您应该整理您的数据库，但这不是强制性的。）
- en: Listing 4.6 Importing basic movie information from MovieLens
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 从MovieLens导入基本电影信息
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Reads the values from a CSV file (movies.csv)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从CSV文件（movies.csv）读取值
- en: ❷ Starts a new session connecting to Neo4j
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 启动一个新的会话连接到 Neo4j
- en: ❸ Creates constraints to guarantee the uniqueness of people and genres. The
    function executeNoException wraps the exception generated if the constraint already
    exists.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为保证人和类型的唯一性创建约束。函数 executeNoException 包装了如果约束已存在时生成的异常。
- en: ❹ Begins a new transaction, which will allow the atomicity (all in or all out)
    of the operations on the database
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 开始一个新的事务，这将允许数据库操作的原子性（全部进入或全部退出）
- en: ❺ Creates the movie and the genres (the MERGE prevents creating the same genre
    multiple times) and connects them
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建电影和类型（MERGE 防止多次创建相同的类型）并将它们连接起来
- en: '❻ Pro tip: To avoid a huge commit at the end, this check ensures that the commit
    to the database happens for every 1,000 lines processed.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 高级技巧：为了避免在最后进行大量提交，此检查确保每处理 1,000 行数据就向数据库提交一次。
- en: Listing 4.7 Enriching the database with details available on IMDb
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 使用 IMDb 上可用的详细信息丰富数据库
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a new constraint to make people unique
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的约束以使人物唯一
- en: ❷ Gets movie details from IMDb
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 IMDb 获取电影详情
- en: ❸ Processes information from IMDb and stores it in the graph
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理来自 IMDb 的信息并将其存储在图中
- en: ❹ Same as listing 4.4 except that the movie already exists
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 与列表 4.4 相同，但电影已经存在
- en: ❺ Takes the plot value from the movie info to create a plot property on the
    node
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从电影信息中提取剧情值以在节点上创建剧情属性
- en: This code is oversimplified, and it takes ages to complete because accessing
    and parsing IMDb pages require time. In the book’s code repository, in addition
    to the complete implementation of the code, there is a parallel version of the
    function import_movie_details, in which multiple threads are created to download
    and process several IMDb pages at the same time. After it completes, the resulting
    graph has the structure described in figure 4.6.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码过于简化，需要花费很长时间才能完成，因为访问和解析 IMDb 页面需要时间。在本书的代码仓库中，除了完整的代码实现外，还有一个并行版本的函数 import_movie_details，其中创建了多个线程同时下载和处理多个
    IMDb 页面。完成后，生成的图具有图 4.6 所描述的结构。
- en: Exercises
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Play with the newly created database and write queries to do the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的数据库中玩耍，并编写查询来完成以下操作：
- en: Search for pairs of actors who worked on the same movie.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索在相同电影中工作的演员对。
- en: TIP Use listing 4.3 but add LIMIT 50 at the end of the query; otherwise, the
    query will produce a lot of results.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TIP 使用列表 4.3，但在查询末尾添加 LIMIT 50；否则，查询将产生大量结果。
- en: Count, for each actor, how many movies they acted in.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统计每个演员出演了多少部电影。
- en: Get a movie (by movieId), and list all the features.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一部电影（通过 movieId），并列出所有特性。
- en: The items (movies, in this scenario) are properly modeled and stored in a real
    graph database. In section 4.2, we are going to model the users.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本场景中，项目（电影）被正确建模并存储在真实的图数据库中。在第 4.2 节中，我们将对用户进行建模。
- en: 4.2 User modeling
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 用户建模
- en: In a CBRS, several methods exist for gathering and modeling user profiles. The
    selected design model will vary according to how the preferences are collected
    (implicitly or explicitly) and the type of filtering strategy or recommendation
    approach. A straightforward way to collect user preferences is to ask the user.
    The user might express interest in specific genres or keywords, or in particular
    actors or directors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CBRS 中，存在多种方法用于收集和建模用户配置文件。所选的设计模型将根据偏好的收集方式（隐式或显式）以及过滤策略或推荐方法的类型而有所不同。收集用户偏好的直接方法是询问用户。用户可能对特定类型或关键词、特定演员或导演感兴趣。
- en: From a high-level perspective, the purpose of the user profile and the defined
    model is to help the recommendation engine assign a score to each item or item
    feature. The score helps rank the items suggested to the specific user, ordered
    from high to low. For this reason, recommender systems belong to the area of machine
    learning called *learning to rank*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次的角度来看，用户配置文件和定义的模型的目的在于帮助推荐引擎为每个项目或项目特性分配一个分数。这个分数有助于按从高到低的顺序对建议给特定用户的项目进行排序。因此，推荐系统属于机器学习领域中的“学习排序”领域。
- en: We can add preferences or interests to the model we are designing by adding
    nodes for users and connecting them to the features of interest. The resulting
    schema will look like figure 4.8.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为用户添加节点并将它们连接到感兴趣的特性来向正在设计的模型添加偏好或兴趣。生成的模式将类似于图 4.8。
- en: '![CH04_F08_Negro](../Images/CH04_F08_Negro.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F08_Negro](../Images/CH04_F08_Negro.png)'
- en: Figure 4.8 Graph model with user interests pointing to meta information
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 具有用户兴趣指向元信息的图模型
- en: The graph model defined for modeling user preferences extends the model previously
    described for the items, adding a new node for each user and connecting it to
    the features of interest to the user.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用于建模用户偏好的图模型扩展了之前为物品描述的模型，为每个用户添加了一个新节点，并将其连接到用户感兴趣的特征。
- en: Modeling note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 建模笔记
- en: The advanced model designed for items fits better in this scenario because the
    features are nodes in the graph and so can be connected to the users by edges-another
    advantage of such a model in comparison with the simpler one, in which modeling
    interests would have been much harder and more painful.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为物品设计的先进模型更适合这种场景，因为特征是图中的节点，因此可以通过边连接到用户——与更简单的模型相比，这种模型的另一个优点是，建模兴趣会困难得多，也更痛苦。
- en: Alternatively, the system can explicitly ask the user to rate some items. The
    optimal approach is to select items that will help us understand, in the broadest
    sense, the user’s tastes. The resulting graph model looks like figure 4.9.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，系统可以明确要求用户对某些物品进行评分。最佳方法是选择那些能帮助我们最广泛地了解用户品味的物品。生成的图模型看起来像图4.9。
- en: '![CH04_F09_Negro](../Images/CH04_F09_Negro.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F09_Negro](../Images/CH04_F09_Negro.png)'
- en: Figure 4.9 Graph model with users’ explicit item ratings
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 带有用户显式物品评分的图模型
- en: In this case, the user nodes are connected to the movies. The ratings are stored
    on the edges as a property. These approaches are called *explicit* because the
    system asks the users to manifest their own tastes and preferences.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户节点连接到电影。评分作为属性存储在边上。这些方法被称为*显式*，因为系统要求用户表达自己的品味和偏好。
- en: At the other end of the spectrum, another approach is to infer the users’ interests,
    tastes, and preferences *implicitly* by considering the interactions each user
    has with items. If I buy soy milk, for example, it is highly probable that I’m
    interested in similar products, such as soy yogurt. Soy in this case is the relevant
    feature. Similarly, if a user watches the first episode of The *Lord of the Rings*
    trilogy, it is highly probable that they’ll be interested in the other two episodes
    or in other movies of the same fantasy-action genre. The resulting model looks
    like figure 4.10\. This model is the same as the one in figure 4.9; the only difference
    is that the system in figure 4.10 collects and stores data on user behavior to
    infer users’ interests implicitly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，另一种方法是通过对每个用户与物品的交互进行隐式地推断用户的兴趣、品味和偏好。例如，如果我买了大豆奶，那么我可能对类似的产品，如大豆酸奶，感兴趣。在这种情况下，大豆是相关特征。同样，如果一个用户观看了《指环王》三部曲的第一集，那么他们很可能对其他两集或同一奇幻动作类型的其他电影感兴趣。生成的模型看起来像图4.10。这个模型与图4.9中的模型相同；唯一的区别是图4.10中的系统收集并存储用户行为数据，以隐式地推断用户的兴趣。
- en: '![CH04_F10_Negro](../Images/CH04_F10_Negro.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F10_Negro](../Images/CH04_F10_Negro.png)'
- en: Figure 4.10 Graph model with user-item interactions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 带有用户-物品交互的图模型
- en: It’s worth noting that when the system models relationships between users and
    items, regardless of whether information on users’ interests is collected implicitly
    or explicitly, it is possible to infer the users’ interests in specific item features
    by using different approaches. Starting from the graph depicted in figures 4.9
    and 4.10, the Cypher query in listing 4.8 computes new relationships between users
    and features and then *materializes* them (stores as new relationships to improve
    access performance) by creating new edges in the graph.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当系统建模用户和物品之间的关系时，无论是否收集用户兴趣的信息是隐式还是显式，都可以通过不同的方法推断用户对特定物品特征的兴趣。从图4.9和4.10所示图中，列表4.8中的Cypher查询计算用户和特征之间新的关系，并通过在图中创建新的边来*物化*它们（存储为新关系以提高访问性能）。
- en: Listing 4.8 Query for computing relationships between users and item features^([4](#pgfId-1011929))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 查询计算用户和物品特征之间的关系^([4](#pgfId-1011929))
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ The | allows you to specify multiple relationship types in the MATCH pattern.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ | 允许你在MATCH模式中指定多个关系类型。
- en: ❷ The WITH clause aggregates users and features, counting the occurrences.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ WITH子句聚合用户和特征，计算出现的次数。
- en: ❸ This WHERE clause allows you to consider only features that occur in at least
    three movies the user watched.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这个WHERE子句允许你只考虑用户观看过的至少三部电影中出现的特征。
- en: ❹ Creates the relationship. Using MERGE instead of CREATE prevents multiple
    relationships between the same pairs of nodes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建关系。使用MERGE而不是CREATE可以防止同一对节点之间有多个关系。
- en: This query searches for all the graph patterns ((u:User)-[:WATCHED|RATED]->
    (m:Movie)) that represent all the movies watched or rated by the user. It identifies
    the features with
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询搜索所有表示用户观看或评分的所有电影的图模式（(u:User)-[:WATCHED|RATED]-> (m:Movie)）。它识别出用户和特征。
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For each user-feature couple, the output of WITH also indicates how often a
    user watched a movie with that specific feature (which could be an actor, a director,
    a genre, and so on). The WHERE clause filters out all the features that appear
    fewer than three times, to keep only the most relevant and not fill the graph
    with useless relationships. Finally, the MERGE clause creates the relationships,
    preventing storing multiple relationships between the same pairs of nodes (which
    would happen if you used CREATE instead). The resulting model looks like figure
    4.11.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个用户-特征对，WITH的输出还表明用户观看具有该特定特征的电影的频率（该特征可能是演员、导演、类型等）。WHERE子句过滤掉出现次数少于三次的所有特征，以保留最相关的特征，避免在图中填充无用的关系。最后，MERGE子句创建关系，防止在相同的节点对之间存储多个关系（如果使用CREATE会发生这种情况）。生成的模型看起来像图4.11。
- en: '![CH04_F11_Negro](../Images/CH04_F11_Negro.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F11_Negro](../Images/CH04_F11_Negro.png)'
- en: Figure 4.11 The graph model after inferring relationships INTERESTED_IN
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 推断关系INTERESTED_IN后的图模型
- en: The model depicted in figure 4.11 contains relationships between
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11中展示的模型包含以下关系之间的
- en: Users and items. (In the modeling example, we used explicit watched relationships,
    but the same would have held for explicit ratings.)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和项目。（在建模示例中，我们使用了显式的观看关系，但同样适用于显式的评分。）
- en: Users and features.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和特征。
- en: The second type was computed starting from the first, using a simple query.
    This example shows another possible extension of the starting model. In this case,
    instead of using an external source of knowledge, the model infers the new information
    from the graph itself. In this specific case, a graph query is used to distill
    the knowledge and convert it to a new relationship for better navigation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型是从第一种类型开始计算的，使用一个简单的查询。这个例子展示了起始模型的另一种可能的扩展。在这种情况下，不是使用外部知识源，而是从图中本身推断新的信息。在这个特定的情况下，使用图查询来提炼知识并将其转换为新的关系，以实现更好的导航。
- en: The MovieLens dataset contains explicit user-item pairings based on the users’
    ratings. (The pairings are considered to be explicit because the users decided
    to rate the items.) In listing 4.9, the ratings are used to build a graph as modeled
    in figure 4.10, with the only difference being that WATCHED is replaced by RATED
    because it represents what the user explicitly rated. The function reads from
    a CSV file, creates users, and connects them to the movies they rated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MovieLens数据集包含基于用户评分的显式用户-项目对。（这些配对被认为是显式的，因为用户决定对项目进行评分。）在列表4.9中，使用评分来构建一个图，如图4.10所示，唯一的区别是WATCHED被RATED替换，因为它代表用户明确评分的内容。该函数从CSV文件中读取，创建用户，并将它们连接到他们评分的电影。
- en: Listing 4.9 Importing user-item pairings from MovieLens
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 从MovieLens导入用户-项目对
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Creates a constraint to guarantee User uniqueness
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建约束以保证用户唯一性
- en: ❷ The query searches for a Movie by movieId and then creates the User if it
    does not exist and connects them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查询通过movieId搜索电影，如果不存在则创建用户，并将它们连接起来。
- en: At this point, the graph model we’ve designed is capable of representing both
    items and users properly and also accommodating several variations or extensions,
    such as semantic analysis and implicit or explicit information. We’ve created
    and filled a real graph database, using data obtained by combining the MovieLens
    dataset and information from the IMDb.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们设计的图模型能够正确地表示项目和用户，并且能够适应多种变化或扩展，例如语义分析和隐式或显式信息。我们创建并填充了一个真实的图数据库，使用的是通过结合MovieLens数据集和IMDb信息获得的数据。
- en: Exercises
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Play with the database and write queries to do the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中玩耍，并编写查询来完成以下操作：
- en: Get a user (by userId), and list all the features that user is interested in.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个用户（通过userId），并列出该用户感兴趣的所有特征。
- en: Find pairs of users who have common interests.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找具有共同兴趣的用户对。
- en: Section 4.3 discusses how to use this model to deliver recommendations to the
    end users in the movie rental scenario we’re considering.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第4.3节讨论了如何使用此模型在考虑的电影租赁场景中向最终用户提供推荐。
- en: 4.3 Providing recommendations
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 提供推荐
- en: During the recommendation phase, a CBRS uses user profiles to match users with
    the items that are most likely to be of interest to them. Depending on the information
    available and the models defined for both users and items, different algorithms
    or techniques can be used for this purpose. Starting from the models described
    previously, this section describes several techniques for predicting user interests
    and providing recommendations, presented in increasing order of complexity and
    accuracy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐阶段，CBRS使用用户档案来匹配用户与最有可能引起他们兴趣的物品。根据可用信息和为用户和物品定义的模型，可以为此目的使用不同的算法或技术。从之前描述的模型开始，本节描述了预测用户兴趣和提供推荐的几种技术，按复杂性和准确性的增加顺序呈现。
- en: The first approach is based on the model presented in figure 4.12, in which
    users are explicitly asked to indicate their interest in features or interest
    is inferred from user-item interactions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法基于图4.12中展示的模型，其中明确要求用户指出他们对特征的兴趣，或者从用户与物品的交互中推断出兴趣。
- en: '![CH04_F12_Negro](../Images/CH04_F12_Negro.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F12_Negro](../Images/CH04_F12_Negro.png)'
- en: Figure 4.12 Graph model with user interests pointing to meta information
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 用户兴趣指向元信息的图模型
- en: This approach is applicable when
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当适用时，这种方法是：
- en: The *items* are represented by a list of *features* that are related to the
    items, such as tags, keywords, genres, and actors. Such features may be curated
    by users manually (tags) or professionals (keywords), or generated automatically
    through some extraction process.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*物品*通过一个与物品相关的特征列表来表示，例如标签、关键词、类型和演员。这些特征可能是由用户手动（标签）或专业人士（关键词）创建的，或者通过某些提取过程自动生成。'
- en: 'The *user profiles* are represented by connecting the users to features that
    are of interest to them. These connections are described in a binary form: *like*
    (in the graph, represented with an edge between the user and the feature) and
    *don’t like/unknown* (represented by no edge between the user and the feature).
    When explicit information about user interests is not available, interests can
    be inferred from other sources (explicit or implicit), as described previously,
    using a graph query.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户档案*通过将用户连接到他们感兴趣的特征来表示。这些连接以二进制形式描述：*喜欢*（在图中，用用户和特征之间的边表示）和*不喜欢/未知*（表示为用户和特征之间没有边）。当没有关于用户兴趣的明确信息时，可以从其他来源（明确或隐式）推断兴趣，如前所述，使用图查询。'
- en: This approach is highly relevant for scenarios such as the movie rental example,
    in which meta information is available and better describes the items themselves.
    The entire recommendation process in this scenario can be summarized as illustrated
    in figure 4.13.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于电影租赁等场景非常相关，其中元信息可用且更好地描述了物品本身。在这个场景中的整个推荐过程可以总结如图4.13所示。
- en: '![CH04_F13_Negro](../Images/CH04_F13_Negro.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F13_Negro](../Images/CH04_F13_Negro.png)'
- en: Figure 4.13 Recommendation process for the first scenario in content-based recommenders
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 基于内容推荐器中第一个场景的推荐过程
- en: 'This high-level diagram highlights how the entire process can be based on graphs.
    This approach doesn’t require complex or fancy algorithms to provide recommendations.
    With a proper graph model, a simple query can do the job. The data already contains
    enough information, and the graph structure helps compute the score and returns
    the ordered list to the user with no need to prebuild any model: *the description
    and prediction models overlap*. This pure graph-based approach is simple but has
    a lot of advantages:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这张高级图表突出了整个过程可以基于图来构建。这种方法不需要复杂或花哨的算法来提供推荐。有了合适的图模型，一个简单的查询就能完成任务。数据已经包含了足够的信息，图结构有助于计算分数并返回给用户排序后的列表，无需预先构建任何模型：*描述和预测模型重叠*。这种纯图基方法简单但有很多优点：
- en: '*It produces good results*. The quality of the recommendations is quite high,
    considering the limited effort required by this method.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它产生良好的结果*。考虑到这种方法所需的努力有限，推荐的品质相当高。'
- en: '*It’s simple*. It doesn’t require complex computations or complex code that
    reads and preprocesses the data before providing recommendations. If the data
    is modeled properly in the graph, as shown previously, it is possible to perform
    the queries and reply to users in real time.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*它很简单*。它不需要复杂的计算或复杂的代码，在提供推荐之前读取和预处理数据。如果数据在图中建模得当，如前所述，就可以实时执行查询并响应用户。'
- en: '*It’s extensible*. The graph can contain other information that can be useful
    for refining the results according to other data sources or contextual information.
    The queries can easily be changed to take new aspects into account.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*. 图可以包含其他信息，这些信息对于根据其他数据源或上下文信息细化结果可能很有用。查询可以轻松地更改以考虑新的方面。'
- en: The task of providing recommendations is accomplished by means of queries like
    the one in listing 4.10.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像列表 4.10 中的查询这样的方式完成提供推荐的任务。
- en: Listing 4.10 Query for providing recommendations to a user
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 为用户提供推荐查询
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Starting from a user, the MATCH clause searches for all the movies that have
    features of interest for that user.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从一个用户开始，MATCH 子句搜索所有对该用户感兴趣的电影。
- en: ❷ The NOT exists() filters out all the movies already WATCHED or RATED by the
    user.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ NOT EXISTS() 过滤出用户已经观看或评分的所有电影。
- en: ❸ Sorting in reverse order helps bring to the top the movies shared more with
    the selected user.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 逆序排序有助于将共享给选定用户的电影推到顶部。
- en: 'This query starts from the user (the WHERE clause specifies a userId as string),
    identifies all the features of interest to the user, and finds all the movies
    that contain them. For each movie, the query counts the overlapping features and
    orders the movies according to this value: the higher the number of overlapping
    features, the higher the likelihood is that the item might be of interest to the
    user.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询从用户（WHERE 子句指定一个字符串形式的 userId）开始，识别用户感兴趣的所有特征，并找到包含这些特征的 所有电影。对于每部电影，查询计算重叠特征的数量，并根据这个值对电影进行排序：重叠特征的数量越多，项目可能对用户感兴趣的可能性就越高。
- en: This approach can be applied to the database we created earlier. The MovieLens
    dataset contains connections among users and items but no relationships between
    users and features of interest for the users; these features are not available
    in the dataset. We enriched the dataset by using IMDb as a source of knowledge
    for movie features, and by applying listing 4.8, it is possible to compute the
    missing relationships between users and item features. Use the code and the queries
    to play with the graph database and provide recommendations. It will not be fast,
    but it will work properly. Figure 4.14 shows the result of running listing 4.7
    on the imported database. It’s worth noting that user 598 in the example shown
    here had already rated *Shrek* and *Shrek 2*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以应用于我们之前创建的数据库。MovieLens 数据集包含用户和项目之间的连接，但没有用户与其感兴趣的特征之间的关系；这些特征在数据集中不可用。我们通过使用
    IMDb 作为电影特征的知识来源，并应用列表 4.8，来丰富数据集，从而可以计算用户和项目特征之间缺失的关系。使用代码和查询来玩转图数据库并提供推荐。它可能不会很快，但会正常工作。图
    4.14 显示了在导入的数据库上运行列表 4.7 的结果。值得注意的是，这里显示的示例中用户 598 已经对 *Shrek* 和 *Shrek 2* 进行了评分。
- en: '![CH04_F14_Negro](../Images/CH04_F14_Negro.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F14_Negro](../Images/CH04_F14_Negro.png)'
- en: Figure 4.14 The result of running listing 4.10 on the imported MovieLens database
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 在导入的 MovieLens 数据库上运行列表 4.10 的结果
- en: Later in this chapter and book, different techniques and methods for improving
    performance are described; here, the focus is on different graph modeling techniques
    and design options.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书的后续部分，描述了提高性能的不同技术和方法；在这里，重点是不同的图建模技术和设计选项。
- en: Exercise
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Rewrite listing 4.10 to consider only movies of a specific genre or from a specific
    year.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表 4.10 重写为仅考虑特定类型或特定年份的电影。
- en: Tip Add a condition to the WHERE clause by using EXISTS.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：通过使用 EXISTS 添加条件到 WHERE 子句。
- en: 'This approach works well and is simple, but with a small amount of effort,
    it can be greatly improved. The second approach extends the previous one by considering
    two main aspects that can be improved:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法效果良好且简单，但通过一点努力，它可以得到极大的改进。第二种方法通过考虑两个主要方面来扩展前一种方法，这两个方面可以改进：
- en: In the user profile, interest in an item feature is represented by a Boolean
    value. This value is *binary*, representing only the fact that the user is interested
    in the feature. It doesn’t ascribe any weight to this relationship.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户配置文件中，对项目特征的兴趣由一个布尔值表示。这个值是 *二进制* 的，仅表示用户对特征感兴趣。它不赋予这种关系任何权重。
- en: Counting the overlapping features between user profiles and items is not enough.
    We need a function that computes the similarity or commonalities between user
    interests and items.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算用户配置文件和项目之间的重叠特征是不够的。我们需要一个函数来计算用户兴趣和项目之间的相似性或共同点。
- en: Regarding the first point, as is stated often in this book, models are representations
    of reality, and the reality is that we are modeling a user who is likely to be
    interested more in some features than others (likes action movies but loves movies
    with Jason Statham, for example). This information can improve the quality of
    the recommendations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一点，正如本书中经常提到的，模型是现实的表示，现实是我们在模拟一个可能对某些特征比对其他特征更感兴趣的（例如喜欢动作电影但喜欢杰森·斯坦森的电影）。这些信息可以提高推荐的质量。
- en: Regarding the second point, instead of counting the overlapping features, a
    better method of finding interesting items for a specific user consists of measuring
    the similarity between the user profile and the item’s features—the closer, the
    better. This approach requires
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二点，与其计算重叠特征的数量，不如通过测量用户资料与项目特征之间的相似度来找到特定用户感兴趣的项目——越接近越好。这种方法需要
- en: A *function* that measures the similarity
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*函数*，用于测量相似度
- en: A *common representation* for both items and user profiles so that the similarity
    is measurable
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*共同表示*，以便可以测量项目和用户资料的相似度
- en: 'The selected function defines the required representation for items and user
    profiles. Different functions are available. One of the most accurate functions
    is *cosine similarity*, introduced in chapter 3:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的函数定义了项目和个人资料所需的表示形式。有多种函数可供选择。其中最精确的函数之一是*余弦相似度*，在第 3 章中介绍：
- en: '![CH04_F15_EQ01_Negro](../Images/CH04_F15_EQ01_Negro.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F15_EQ01_Negro](../Images/CH04_F15_EQ01_Negro.png)'
- en: Like most of the common similarity functions, this function requires that each
    item and each user profile be projected into a common *vector space model (VSM**)*,
    which means that each element has to be represented by a fixed-dimension vector.
    The entire recommendation process in this second scenario can be summarized by
    the high-level diagram in figure 4.15.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数常见的相似度函数一样，此函数要求每个项目和每个用户资料被投影到共同的*向量空间模型 (VSM)*中，这意味着每个元素都必须由一个固定维度的向量表示。在这种情况下，整个推荐过程可以总结为图
    4.15 中的高级图。
- en: '![CH04_F15_Negro](../Images/CH04_F15_Negro.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F15_Negro](../Images/CH04_F15_Negro.png)'
- en: Figure 4.15 Recommendation process for the second scenario in content-based
    recommenders
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 基于内容的推荐器第二场景的推荐过程
- en: Compared with the previous approach, in this case an intermediate step before
    the recommendation process projects the items, and user profiles are projected
    into the VSM. To describe this process of converting items and user profiles to
    their representations in the VSM, let’s consider our movie recommendation scenario.
    Suppose that our movie dataset is as represented in figure 4.16.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的方法相比，在这种情况下，在推荐过程之前有一个中间步骤将项目投影，并将用户资料投影到 VSM 中。为了描述将项目和用户资料转换为 VSM 中的表示的过程，让我们考虑我们的电影推荐场景。假设我们的电影数据集如图
    4.16 所示。
- en: '![CH04_F16_Negro](../Images/CH04_F16_Negro.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F16_Negro](../Images/CH04_F16_Negro.png)'
- en: Figure 4.16 Movie advanced model
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 电影高级模型
- en: Each item can be represented as a vector considering meta information such as
    the genres and director. (We could use all the meta information available, but
    the next table would be too big.) The dimensions of each vector in this case are
    defined by the list of all possible values for genres and directors. Table 4.2
    shows what these vectors look like for the simple dataset we created manually.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到元信息，如类型和导演，每个项目都可以表示为一个向量。（我们可以使用所有可用的元信息，但下一个表会太大。）在这种情况下，每个向量的维度由类型和导演的所有可能值的列表定义。表
    4.2 显示了我们手动创建的简单数据集中这些向量的样子。
- en: Table 4.2 Converting items to vectors
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 将项目转换为向量
- en: '|  | Action | Drama | Crime | Thriller | Adventure | Quentin Tarantino | Jonathan
    Hensleigh |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  | 动作 | 剧情 | 犯罪 | 惊悚 | 冒险 | 昆汀·塔伦蒂诺 | 乔纳森·亨斯莱 |'
- en: '| Pulp Fiction | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 低俗小说 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
- en: '| The Punisher | 1 | 1 | 1 | 1 | 1 | 0 | 1 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 惩罚者 | 1 | 1 | 1 | 1 | 1 | 0 | 1 |'
- en: '| Kill Bill: Vol I | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 杀死比尔：第一卷 | 1 | 0 | 1 | 1 | 0 | 1 | 0 |'
- en: These vectors are Boolean vectors because the values can be only 0, which means
    absence, and 1, which means presence. The vectors representing the three movies
    are
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些向量是布尔向量，因为值只能是 0，表示不存在，或者 1，表示存在。代表三部电影的向量是
- en: '*Vector(Pulp Fiction)* = [1, 0, 1, 1, 0, 1, 0]'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(低俗小说)* = [1, 0, 1, 1, 0, 1, 0]'
- en: '*Vector(The Punisher)* = [1, 1, 1, 1, 1, 0, 1]'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(惩罚者)* = [1, 1, 1, 1, 1, 0, 1]'
- en: '*Vector(Kill Bill:Volume 1)* = [1, 0, 1, 1, 0, 1, 0]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(杀死比尔：第一卷)* = [1, 0, 1, 1, 0, 1, 0]'
- en: These binary vectors can be extracted from the graph model in figure 4.16 through
    the following query.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二进制向量可以通过图4.16中的图模型通过以下查询提取。
- en: Listing 4.11 Extracting Boolean vectors for movies
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 提取电影的布尔向量
- en: '[PRE11]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Searches for all the features that are Director or Genre, using the labels
    function to get the list of labels assigned to a node
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用labels函数获取分配给节点的标签列表，搜索所有类型为导演或类型的特征。
- en: ❷ Searches for the movie Pulp Fiction. Using STARTS WITH is preferable to an
    exact string comparison because the movies generally have the year in the title.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 搜索电影《低俗小说》。使用STARTS WITH比精确字符串比较更可取，因为电影通常在标题中有年份。
- en: ❸ OPTIONAL MATCH allows us to consider all the features, even if they are not
    related to the movie selected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 可选的MATCH允许我们考虑所有特征，即使它们与所选电影无关。
- en: ❹ This CASE clause returns 0 if no relationship exists and 1 otherwise.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果不存在关系，则此CASE子句返回0，否则返回1。
- en: ❺ This CASE clause returns the name of the director or the genre.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这个CASE子句返回导演或类型的名称。
- en: The query starts by looking for all the nodes that represent genres or directors,
    and it returns all of them ordered by node identifier. The order is important
    because in each vector, the specific genre or director must be represented in
    the same position. Then the query searches for a specific movie by title, and
    OPTIONAL MATCH checks whether the movie is connected to the feature. Unlike MATCH,
    which filters out the nonmatching elements, OPTIONAL MATCH returns null if the
    relationship doesn’t exist. In the RETURN, the first CASE clause returns 0 if
    no relationship exists and 1 otherwise; the second returns the name of the director
    or the genre. Figure 4.17 shows the result of the query run against the database
    imported from MovieLens.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 查询首先寻找代表类型或导演的所有节点，并按节点标识符顺序返回它们。顺序很重要，因为在每个向量中，特定的类型或导演必须在相同的位置表示。然后查询通过标题查找特定电影，并使用可选的MATCH检查电影是否与特征相关联。与MATCH不同，MATCH会过滤掉不匹配的元素，而可选的MATCH如果不存在关系则返回null。在RETURN中，第一个CASE子句如果不存在关系则返回0，否则返回1；第二个返回导演或类型的名称。图4.17显示了针对从MovieLens导入的数据库运行的查询结果。
- en: As is evident from the screenshot in figure 4.17, the real vectors are large
    because there are a lot of possible dimensions. Although this full representation
    is manageable by the implementation discussed here, chapter 5 introduces a better
    way to represent such long vectors.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如图4.17中的截图所示，实际向量很大，因为有很多可能的维度。尽管这种完整表示可以通过这里讨论的实现来管理，但第5章介绍了一种表示这样长向量的更好方法。
- en: '![CH04_F17_Negro](../Images/CH04_F17_Negro.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F17_Negro](../Images/CH04_F17_Negro.png)'
- en: Figure 4.17 Result of running listing 4.11 on the MovieLens dataset
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 运行列表4.11在MovieLens数据集上的结果
- en: Adding an index
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 添加索引
- en: 'Running this query on the MovieLens database can take a long time. The time
    is spent in the filter condition, movie.title STARTS WITH "Pulp Fiction". Adding
    an index can greatly improve performance. Run the following command and then try
    the query again:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在MovieLens数据库上运行此查询可能需要很长时间。时间花费在过滤条件上，即movie.title以"Pulp Fiction"开头。添加索引可以大大提高性能。运行以下命令后，再尝试查询：
- en: '[PRE12]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Much faster, isn't it?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是快得多吗？
- en: It is possible to generalize this vector approach to all sorts of features,
    including those that have numerical values, such as the average ratings in our
    movie scenario.[⁵](#pgfId-1011954) In the vector representation, the related components
    hold the exact values of these features. In our example, the vector representations
    for the three movies become
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这种向量方法推广到各种特征，包括具有数值的特征，例如我们电影场景中的平均评分。[⁵](#pgfId-1011954)在向量表示中，相关组件包含这些特征的精确值。在我们的例子中，三部电影的向量表示如下：
- en: '*Vector(Pulp Fiction)* = [1, 0, 1, 1, 0, 1, 0, 4]'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*《低俗小说》向量* = [1, 0, 1, 1, 0, 1, 0, 4]'
- en: '*Vector(The Punisher)* = [1, 1, 1, 1, 1, 0, 1, 3.5]'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*《惩罚者》向量* = [1, 1, 1, 1, 1, 0, 1, 3.5]'
- en: '*Vector(Kill Bill:Volume 1)* = [1, 0, 1, 1, 0, 1, 0, 3.9]'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*《杀死比尔：卷一》向量* = [1, 0, 1, 1, 0, 1, 0, 3.9]'
- en: 'The last element represents the average rating. It doesn’t matter whether some
    components of the vectors are Boolean and others are real-valued or integer-valued
    [Ullman and Rajaraman, 2011]. It is still possible to compute the cosine distance
    between vectors, although if we do so, we should consider some appropriate scaling
    of the non-Boolean components so that they neither dominate the calculation nor
    are irrelevant. To do so, we multiply the values by a scaling factor:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个元素代表平均评分。向量中的一些分量是布尔值，而其他分量是实数值或整数值，这并不重要 [Ullman and Rajaraman, 2011]。仍然可以计算向量之间的余弦距离，尽管如果我们这样做，我们应该考虑对非布尔分量进行适当的缩放，以便它们既不主导计算，也不无关紧要。为此，我们将值乘以一个缩放因子：
- en: '*Vector(Pulp Fiction)* = [1, 0, 1, 1, 0, 1, 0, 4α]'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(低俗小说)* = [1, 0, 1, 1, 0, 1, 0, 4α]'
- en: '*Vector(The Punisher)* = [1, 1, 1, 1, 1, 0, 13.5α]'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(惩罚者)* = [1, 1, 1, 1, 1, 0, 13.5α]'
- en: '*Vector(Kill Bill:Volume 1)* = [1, 0, 1, 1, 0, 1, 0, 3.9α]'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量(杀死比尔：第一卷)* = [1, 0, 1, 1, 0, 1, 0, 3.9α]'
- en: In this representation, if α is set to 1, the average rating will dominate the
    value of the similarity; if it is set to 0.5, the effect will be reduced by half.
    The scaling factor can be different for each numerical feature and depends on
    the weight assigned to that feature in the resulting similarity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示中，如果α设置为1，平均评分将主导相似度的值；如果设置为0.5，效果将减半。缩放因子可以针对每个数值特征不同，并取决于该特征在结果相似度中的权重。
- en: With the proper vector representation of the items in hand, we need to project
    the user profile into the same VSM, which means that we need to create vectors
    with the same components in the same order as in the item vectors that describe
    the user’s preferences. As described in section 4.2.2, the information available
    in the content-based case regarding user preferences or tastes can be a user-item
    pair or a user-feature pair. Both pairs can be collected implicitly or explicitly.
    Because the vector space has the feature values as dimensions, the first step
    in the projection is to migrate the user-item matrix to the user-feature space
    (unless it is already available). Different techniques can be used for this conversion,
    including aggregating by counting the occurrences of each feature in a user’s
    list of previously liked[⁶](#pgfId-1011966) items. This option works well for
    Boolean values; another option is to compute the average values for numerical
    features. In the movie scenario, each user profile can be represented as shown
    in table 4.3.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有了物品的正确向量表示后，我们需要将用户配置文件投影到相同的VSM中，这意味着我们需要创建具有与物品向量相同的分量和顺序的向量，这些向量描述了用户的偏好。如第4.2.2节所述，在基于内容的案例中，有关用户偏好或喜好的信息可以是用户-物品对或用户-特征对。这两对都可以隐式或显式地收集。因为向量空间以特征值作为维度，投影的第一步是将用户-物品矩阵迁移到用户-特征空间（除非它已经可用）。可以使用不同的技术进行此转换，包括通过计算用户之前喜欢列表中每个特征的出现次数进行聚合[⁶](#pgfId-1011966)。此选项对于布尔值效果良好；另一种选项是计算数值特征的平均值。在电影场景中，每个用户配置文件可以表示如表4.3所示。
- en: Table 4.3 User profiles represented in the same vector space as movies
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 与电影相同的向量空间表示的用户配置文件
- en: '|  | Action | Drama | Crime | Thriller | Adventure | Quentin Tarantino | Jonathan
    Hensleigh | Total |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  | 动作 | 剧情 | 犯罪 | 惊悚 | 冒险 | 昆汀·塔伦蒂诺 | 约翰·亨谢利 | 总计 |'
- en: '| User A | 3 | 1 | 4 | 5 | 1 | 3 | 1 | 9 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 3 | 1 | 4 | 5 | 1 | 3 | 1 | 9 |'
- en: '| User B | 0 | 10 | 1 | 2 | 3 | 0 | 1 | 15 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 0 | 10 | 1 | 2 | 3 | 0 | 1 | 15 |'
- en: '| User C | 1 | 0 | 3 | 1 | 0 | 1 | 0 | 5 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 1 | 0 | 3 | 1 | 0 | 1 | 0 | 5 |'
- en: Each cell represents how many movies the user watched that have that specific
    feature. User A has watched three movies directed by Quentin Tarantino, for example,
    but User B hasn’t watched any movies he directed. The table also contains a new
    column representing the total number of movies watched by each user; this value
    will be useful in the creation of the vectors to normalize the values.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格表示用户观看具有该特定特征的电影数量。例如，用户A观看了三部昆汀·塔伦蒂诺执导的电影，但用户B没有观看他执导的任何电影。表中还包含一个新列，表示每个用户观看的电影总数；此值将在创建用于归一化值的向量时很有用。
- en: These user-feature pairs with related counts are easy to obtain from the graph
    model we’ve been using so far for representing user-item interactions. To simplify
    the next steps, I recommend materializing these values by storing them properly
    in the graph itself. In a property graph database, the weight representing how
    much the user is interested in a specific item feature can be modeled with a property
    on the relationship between the user and the feature. Modifying listing 4.8, used
    earlier for inferring the relationship between users and features, it is possible
    to extract this information, create new relationships, and add these weights to
    the edges. The new query looks like the following listing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用户-特征对及其相关计数很容易从我们迄今为止用于表示用户-项目交互的图模型中获得。为了简化下一步，我建议通过在图中正确存储这些值来实际化这些值。在一个属性图数据库中，表示用户对特定项目特征的兴趣程度的权重可以通过用户和特征之间的关系属性来建模。修改之前用于推断用户和特征之间关系的列表4.8，可以提取此信息，创建新的关系，并将这些权重添加到边中。新的查询如下所示。
- en: Listing 4.12 Query for extracting weighted relationships between users and features
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 查询提取用户和特征之间的加权关系
- en: '[PRE13]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ SET adds or modifies the weight property on the INTERESTED_IN relationship.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ SET在INTERESTED_IN关系上添加或修改权重属性。
- en: In this version, occurrence is stored as a property on the relationship INTERESTED_IN,
    whereas in listing 4.8, it was used only as a filter. Figure 4.18 shows the resulting
    model.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，发生情况被存储为INTERESTED_IN关系上的一个属性，而在列表4.8中，它仅被用作过滤器。图4.18显示了结果模型。
- en: '![CH04_F18_Negro](../Images/CH04_F18_Negro.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F18_Negro](../Images/CH04_F18_Negro.png)'
- en: Figure 4.18 The graph model after inferring INTERESTED_IN relationships with
    the weights
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 推断INTERESTED_IN关系后的图模型
- en: On their own, the numbers in the table could lead to incorrect computations
    of the similarities between the user profile vector and the item vector. They
    have to be normalized to better represent the real interest of a user in a specific
    feature. If a user has watched 50 movies and only 5 are dramas, for example, we
    might conclude that user is less interested in this genre than a user who watched
    3 dramas in a total of 10 movies, even though the first user watched more total
    movies of this type.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭表中的数字可能导致用户配置文件向量和项目向量之间相似性的错误计算。它们必须被归一化以更好地表示用户对特定特征的真正兴趣。例如，如果一个用户观看了50部电影，其中只有5部是剧情片，我们可能会得出结论，该用户对这个类型不如一个在总共10部电影中观看了3部剧情片的用户感兴趣，尽管第一个用户观看了更多类型的电影。
- en: If we *normalize* each value in table 4.3 with the total number of movies watched,
    we see that the first user has 0.1 interest in the drama genre, whereas the second
    has 0.6\. Table 4.4 shows the normalized user profiles.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将表4.3中的每个值与用户观看的电影总数进行归一化，我们会看到第一个用户对剧情类型的兴趣为0.1，而第二个为0.6。表4.4显示了归一化的用户配置文件。
- en: Table 4.4 Normalized version of table 4.3
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4 表4.3的归一化版本
- en: '|  | Action | Drama | Crime | Thriller | Adventure | Quentin Tarantino | Jonathan
    Hensleigh |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  | 动作 | 剧情 | 犯罪 | 惊悚 | 冒险 | 昆汀·塔伦蒂诺 | 约翰·亨谢利 |'
- en: '| User A | 0.33 | 0.11 | 0.44 | 0.55 | 0.11 | 0.33 | 0.11 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 用户A | 0.33 | 0.11 | 0.44 | 0.55 | 0.11 | 0.33 | 0.11 |'
- en: '| User B | 0 | 0.66 | 0.06 | 0.13 | 0.2 | 0 | 0.06 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 用户B | 0 | 0.66 | 0.06 | 0.13 | 0.2 | 0 | 0.06 |'
- en: '| User C | 0.2 | 0 | 0.6 | 0.2 | 0 | 0.2 | 0 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 用户C | 0.2 | 0 | 0.6 | 0.2 | 0 | 0.2 | 0 |'
- en: Modeling pro tip
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 建模技巧
- en: I do not recommend storing the results of the normalization process as weights
    in the graph, because these results are affected by the total number of movies
    watched by the user. Storing such values would require us to recompute each weight
    every time a user watched a new movie. If we store only the counts as weights,
    when a user watches a new movie, only the affected features have to be updated.
    If a user watches an adventure movie, for example, only the count for that genre
    has to be updated.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议将归一化过程的结果作为图中的权重存储，因为这些结果受到用户观看电影总数的影响。存储这些值将需要我们每次用户观看一部新电影时都重新计算每个权重。如果我们只将计数作为权重存储，当用户观看一部新电影时，只需更新受影响的功能。例如，如果用户观看了一部冒险电影，那么只需更新该类型的计数。
- en: In the explicit scenario, this weight information can be collected by asking
    the user to assign rates to a set of possible item features. The related values
    can be stored in the weight property on the edges between users and features.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式场景中，可以通过要求用户为一系列可能的项目特征分配评分来收集此权重信息。相关值可以存储在用户和特征之间的边上的权重属性上。
- en: At the end of this process, we have both items and user profiles represented
    in a common and comparable way. We can accomplish the recommendation task for
    each user by computing the similarities between the user profile vector representation
    and each not-yet-seen movie, ordering them from highest to lowest and returning
    the top N, where N can be 1, 10, or whatever the application requires. In this
    scenario, the recommendation task requires complex operations that cannot be accomplished
    by a query because they require complex computations, looping, transformation,
    and so on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程结束时，我们以共同和可比的方式表示了项目和用户档案。我们可以通过计算用户档案向量表示与每部尚未观看的电影之间的相似度来完成每个用户的推荐任务，从高到低排序，并返回前N个，其中N可以是1、10或应用所需的任何数字。在这种情况下，推荐任务需要复杂的操作，这些操作不能通过查询完成，因为它们需要复杂的计算、循环、转换等。
- en: Listing 4.13 shows how to provide recommendations when the data is stored as
    depicted in figure 4.18\. The full code is available in the code repository as
    ch04/recommendation/content_based_recommendation_second_approach.py.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13展示了如何以图4.18所示的方式存储数据时提供推荐。完整的代码可在代码存储库中的ch04/recommendation/content_based_recommendation_second_approach.py找到。
- en: Listing 4.13 Method to provide recommendations using the second approach
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.13 使用第二种方法提供推荐的方法
- en: '[PRE14]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ This function provides recommendations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个函数提供推荐。
- en: ❷ This function computes the similarities between the user profile vector and
    the movie vectors, and gets back the top k movies that best match the user profile.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个函数计算用户档案向量和电影向量之间的相似度，并返回与用户档案最匹配的前k部电影。
- en: ❸ We use the cosine_similarity function provided by scikit-learn.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们使用scikit-learn提供的cosine_similarity函数。
- en: ❹ This function creates the user profile; note how it is provided with a single
    query and mapped with a vector.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 这个函数创建用户档案；注意它如何通过单个查询提供并映射到向量。
- en: ❺ The order is critical because it allows us to have comparable vectors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 排序至关重要，因为它允许我们拥有可比的向量。
- en: ❻ This function provides the movie vectors.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这个函数提供了电影向量。
- en: ❼ This query gets only relevant not-seen-yet movies for the user, which speeds
    the process.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 这个查询只为用户获取相关且尚未观看的电影，这加快了处理过程。
- en: ❽ This query creates the movie vectors.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 这个查询创建电影向量。
- en: If you run this code for user 598 (the same user as in the previous scenario),
    you will see that the list of recommended movies is not that different from the
    results obtained in the previous case, but these new results should be better
    in terms of prediction accuracy. Thanks to the graph, it is possible to easily
    get movies that contain at least five features in common with the user profile.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为用户598（与上一个场景中的用户相同）运行此代码，你会看到推荐的电影列表与上一个案例的结果没有太大不同，但就预测准确性而言，这些新结果应该更好。多亏了图表，可以轻松找到至少与用户档案有五个共同特征的电影。
- en: Also be aware that this recommendation process takes a while to produce results.
    Don’t be worried; the goal here is to show the concepts in the simplest way, and
    various optimization techniques are discussed later in the book. If you’re interested,
    in the code repository you’ll find an optimized version of this code that uses
    a different approach to vector creation and similarity computation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个推荐过程需要一段时间才能产生结果。不要担心；这里的目的是以最简单的方式展示概念，书中稍后讨论了各种优化技术。如果你感兴趣，在代码存储库中你可以找到一个使用不同方法创建向量和计算相似度的优化版本的代码。
- en: Exercises
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Considering the code in listing 4.13,
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到4.13列表中的代码，
- en: Rewrite the code to use a different similarity function, such as the Pearson
    correlation ([https://libguides.library.kent.edu/SPSS/PearsonCorr](https://libguides.library.kent.edu/SPSS/PearsonCorr)),
    instead of cosine similarity.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码重写为使用不同的相似度函数，例如皮尔逊相关系数（[https://libguides.library.kent.edu/SPSS/PearsonCorr](https://libguides.library.kent.edu/SPSS/PearsonCorr)），而不是余弦相似度。
- en: Tip Search for a Python implementation, and replace the cosine_similarity function.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士：搜索Python实现，并用余弦相似度函数替换。
- en: Look at the optimized implementation in the code repository, and figure out
    how the new vectors are created. How much faster is it now? Chapter 5 introduces
    the concept of sparse vectors.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看代码存储库中的优化实现，并找出新向量是如何创建的。现在它有多快？第五章介绍了稀疏向量的概念。
- en: The third approach we will consider for content-based recommendations can be
    described as “Recommend items that are similar to those the user liked in the
    past” [Jannach et al., 2010]. This approach works well in general and is the only
    option when it is possible to compute relevant similarities between items but
    difficult or not relevant to represent user profiles in the same way.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的基于内容的第三种推荐方法可以描述为“推荐与用户过去喜欢的项目相似的项目” [Jannach et al., 2010]。这种方法在一般情况下效果良好，并且当可以计算项目之间的相关相似度，但难以或不适当地以相同方式表示用户档案时，它是唯一的选择。
- en: 'Consider our training dataset, as represented in figures 4.9 and figure 4.10\.
    The user preferences are modeled by connecting users to items instead of users
    to items’ meta information. This approach could be necessary when meta information
    for each item is not available, limited, or not relevant, so it is not possible
    (or necessary) to extract data on the users’ interest in some features. Nonetheless,
    the content or content description related to each item is somehow available;
    otherwise, the content-based approach would not be applicable. Even when meta
    information is available, this third approach greatly outperforms the previous
    one in terms of recommendation accuracy. This technique, known as the *similarity-based
    retrieval* approach, is a valuable approach to cover for several reasons:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的训练数据集，如图4.9和图4.10所示。用户偏好是通过将用户与项目连接而不是与项目的元信息连接来建模的。当每个项目的元信息不可用、有限或不相关时，这种方法可能是必要的，因此无法（或没有必要）提取关于用户对某些特征兴趣的数据。尽管如此，与每个项目相关的内容或内容描述以某种方式是可用的；否则，基于内容的方法将不适用。即使元信息可用，这种第三种方法在推荐准确性方面也大大优于前一种方法。这种被称为*基于相似度的检索*的技术，由于以下几个原因，是一种有价值的解决方案：
- en: It was introduced in chapter 3\. Here, different item representations are used
    for computing similarities.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在第3章中介绍。在这里，使用不同的项目表示来计算相似度。
- en: Similarities are easy to store back in the graph as relationships between items.
    This example represents a perfect use case for graph modeling, and navigating
    similarity relationships provides for fast recommendations.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相似度很容易存储在图中作为项目之间的关系。这个例子代表了一个完美的图建模用例，通过导航相似度关系可以提供快速推荐。
- en: It is one of the most common and powerful approaches to CBRSs.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是最常见且最强大的CBRSs（内容基础推荐系统）方法之一。
- en: It is flexible and general enough to be used in many scenarios, regardless of
    the type of data/information available for each item.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它足够灵活和通用，可以在许多场景中使用，无论每个项目可用的数据/信息类型如何。
- en: The entire recommendation process in this scenario can be summarized by the
    high-level diagram in figure 4.19.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种场景中的整个推荐过程可以总结为图4.19中的高级示意图。
- en: '![CH04_F19_Negro](../Images/CH04_F19_Negro.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F19_Negro](../Images/CH04_F19_Negro.png)'
- en: Figure 4.19 Recommendation process for the third approach in content-based recommenders
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 基于内容推荐器的第三种方法的推荐过程
- en: It’s worth noting here, because this is the biggest difference with the collaborative
    filtering approach described in chapter 5, that the similarities between items
    are computed only by using the item-related data, whatever that is. The user-item
    interaction is used only during the recommendation phase.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这与第5章中描述的协同过滤方法的最大区别在于，项目之间的相似度仅通过使用与项目相关的数据进行计算，无论是什么。用户-项目交互仅在推荐阶段使用。
- en: 'According to figure 4.19, three key elements are necessary in this scenario:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图4.19，在这个场景中需要三个关键元素：
- en: '*User profile*—The user profile is represented by modeling the interactions
    the user has with items, such as rated, bought, or watched. In the graph, these
    interactions are represented as relationships between the user and the items.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户档案*——用户档案通过建模用户与项目之间的交互来表示，例如评分、购买或观看。在图中，这些交互表示为用户与项目之间的关系。'
- en: '*Item representation/description*—To compute similarities between items, it
    is necessary to represent each item in a measurable way. How this is done depends
    on the function selected for measuring similarities.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目表示/描述*——为了计算项目之间的相似度，有必要以可测量的方式表示每个项目。如何进行取决于用于测量相似度的函数选择。'
- en: '*Similarity function*—We need a function that, given two item representations,
    computes the similarity between them. We described applying the cosine similarity
    metric from chapter 3 to a simplified example of collaborative filtering. Here,
    different techniques are described in more detail, applied to content-based recommendations.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相似度函数*—我们需要一个函数，给定两个项目表示，计算它们之间的相似度。我们在第三章中描述了将余弦相似度指标应用于协同过滤的简化示例。在这里，更详细地描述了不同的技术，应用于基于内容的推荐。'
- en: As in the second approach, the first two elements listed are strictly related
    because each similarity formula requires a specific item representation. Conversely,
    according to the data available for each item, some functions can be applied,
    and others cannot.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与第二种方法一样，列出的前两个元素是严格相关的，因为每个相似度公式都需要特定的项目表示。相反，根据每个项目的可用数据，某些函数可以应用，而其他则不能。
- en: A typical similarity metric, which is suitable for multivalued characteristics,
    is the Dice coefficient [Dice, 1945]. It works as follows. Each item I[i] is described
    by a set of features *features*(I[i])—a set of keywords, for example. The Dice
    coefficient measures the similarity between items I[i] and I[j] as
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的相似度指标，适用于多值特性，是Dice系数 [Dice, 1945]。它的工作原理如下。每个项目I[i]由一组特征 *features*(I[i])
    描述——例如，一组关键词。Dice系数衡量项目I[i]和I[j]之间的相似度如下
- en: '![CH04_F20_EQ02_Negro](../Images/CH04_F20_EQ02_Negro.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F20_EQ02_Negro](../Images/CH04_F20_EQ02_Negro.png)'
- en: In this formula, keywords returns the list of keywords that describe the item.
    In the numerator, the formula computes the number of overlapping/intersecting
    keywords and multiplies the result by 2\. In the denominator, it sums the number
    of keywords in each item. This formula is a simple one, in which keywords can
    be replaced by anything—in our movie example, genres, actors, and so on (see figure
    4.20). When the similarities are computed, they can be stored back in the graph,
    as shown in figure 4.21.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，关键词返回描述项目的关键词列表。在分子中，公式计算重叠/交集的关键词数量，并将结果乘以2。在分母中，它计算每个项目中的关键词数量。这是一个简单的公式，其中关键词可以被任何东西替换——在我们的电影示例中，类型、演员等等（见图4.20）。当计算相似度时，它们可以存储回图中，如图4.21所示。
- en: '![CH04_F20_Negro](../Images/CH04_F20_Negro.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F20_Negro](../Images/CH04_F20_Negro.png)'
- en: Figure 4.20 The graph model for representing keywords
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![CH04_F20_EQ02_Negro](../Images/CH04_F20_EQ02_Negro.png)'
- en: '![CH04_F21_Negro](../Images/CH04_F21_Negro.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F21_Negro](../Images/CH04_F21_Negro.png)'
- en: Figure 4.21 Storing similarities back in the graph
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 将相似度存储回图中
- en: It is not necessary to store the neighbor relationships between each pair of
    nodes (although it is necessary to compute all of them). Generally, only a small
    number is stored. You can define a minimum similarity threshold, or you can define
    a k value and keep only the k topmost similar items. For this reason, the methods
    described in this approach are known as k-*nearest neighbor* (k-*NN**)* methods
    regardless of the similarity function selected.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要存储每对节点之间的邻居关系（尽管需要计算所有这些关系）。通常，只存储少量。你可以定义一个最小相似度阈值，或者你可以定义一个k值，只保留最相似的k个项目。因此，这种方法中描述的方法被称为k-*最近邻*
    (k-*NN**) 方法，无论选择的相似度函数如何。
- en: The k -NN methods are used in a lot of machine learning tasks, from recommendations
    to classifications. They are flexible in terms of data types and can be applied
    to textual data as well as structured data. In the recommendations, k -NN methods
    have the advantage of being relatively simple to implement—even though we need
    to take into account the time required to compute the similarities (a problem
    that we will address in sections 6.3 and 9.2)—and adapt quickly to recent changes
    in the dataset.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: k-NN方法在许多机器学习任务中使用，从推荐到分类。它们在数据类型方面具有灵活性，可以应用于文本数据以及结构化数据。在推荐中，k-NN方法的优势在于相对简单易实现——尽管我们需要考虑计算相似度所需的时间（我们将在第6.3节和第9.2节中解决这个问题）——并且能够快速适应数据集的最新变化。
- en: These techniques play an important role across the entire book, not only for
    the broad adoption in the machine learning space, but also because they fit well
    in the graph space—as a common pattern that has several uses in machine learning
    tasks, many of which are presented in this book. The rest of the chapters in this
    part address the advantages of nearest neighbor approaches to the recommendation
    tasks. In chapter 9, similar methods are applied to fraud detection.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术在整本书中都发挥着重要作用，不仅因为它们在机器学习领域的广泛应用，还因为它们很好地适应了图空间——作为一个在机器学习任务中有多种用途的常见模式，其中许多在本书中都有介绍。本部分的其余章节讨论了最近邻方法在推荐任务中的优势。在第9章中，类似的方法应用于欺诈检测。
- en: In all these applications, graphs provide a suitable data model for storing
    the k most relevant neighbor. Such a graph is called a k-nearest neighbor graph
    (or network), and k-NN techniques are used as network formation methods in many
    contexts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些应用中，图提供了一个合适的数据模型来存储k个最相关的邻居。这样的图被称为k-最近邻图（或网络），k-NN技术在许多场景中用作网络形成方法。
- en: From a formal point of view, this graph is one in which an edge from v[i] and
    v[j] is created if v[j] is among the k most similar elements to v[i]. The k-NN
    network is in general a directed network because v[j] can be one of the k-nearest
    neighbors of v[i], but the reverse could not be true. (Node v[j] could have a
    different set of neighbors.) A k-NN network is accessed during the prediction
    or the analysis phase.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上看，这个图是在v[i]和v[j]之间创建一条边，如果v[j]是v[i]的k个最相似元素之一。k-NN网络通常是一个有向网络，因为v[j]可以是v[i]的k个最近邻之一，但反之则不成立。（节点v[j]可能有一组不同的邻居。）在预测或分析阶段会访问k-NN网络。
- en: Take another look at figure 4.21\. When for each relevant node, the k topmost
    similar nodes (such as items in a recommendation engine or transactions in an
    antifraud system) have been identified, they can be connected by using a proper
    relationship type. The relative similarity values are stored as properties on
    the relationship. The resulting graph is used during the recommendation phase.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看图4.21。当为每个相关节点确定了k个最相似的节点（例如推荐引擎中的项目或反欺诈系统中的交易）时，可以使用适当的关系类型将它们连接起来。相对相似度值存储在关系属性上。在推荐阶段使用生成的图。
- en: The Dice coefficient is simple, but the quality of the resulting recommendations
    is poor because it uses a small amount of information to compute the similarities.
    A much more powerful method for computing the similarities between items is based
    on cosine similarity. The items can be represented exactly as in the second approach.
    The difference is that instead of computing cosine similarities between user profiles
    and items, the cosine function computes similarities between items. This similarity
    is computed for each pair of items; then the top k matches for each item are stored
    back in the graph as similarity relationships. Consider the similarities listed
    in table 4.5.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Dice系数很简单，但由于它使用少量信息来计算相似度，因此生成的推荐质量较差。计算项目之间相似度的一个更强大的方法是基于余弦相似度。项目可以精确地表示为第二种方法中的那样。区别在于，不是在用户配置文件和项目之间计算余弦相似度，而是余弦函数计算项目之间的相似度。这种相似度是对每一对项目进行计算的；然后，每个项目的top
    k匹配作为相似关系存储在图中。考虑表4.5中列出的相似度。
- en: Table 4.5 Cosine similarities between movies
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5 电影之间的余弦相似度
- en: '|  | Pulp Fiction | The Punisher | Kill Bill: Volume I |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  | 低俗小说 | 惩罚者 | 杀戮比尔：第一卷 |'
- en: '| Pulp Fiction | 1 | 0.612 | 1 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 低俗小说 | 1 | 0.612 | 1 |'
- en: '| The Punisher | 0.612 | 1 | 0.612 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 惩罚者 | 0.612 | 1 | 0.612 |'
- en: '| Kill Bill: Volume I | 1 | 0.612 | 1 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 杀戮比尔：第一卷 | 1 | 0.612 | 1 |'
- en: 'The table’s contents can be stored in the graph as shown in figure 4.21\. It
    is important to note that unlike in the first and second approaches, in which
    the recommendation process uses the data as it is, the recommendation process
    here requires an intermediate step: this k-NN computation and storing. In this
    case, the descriptive model and the prediction model don’t match.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 表的内容可以像图4.21所示的那样存储在图中。需要注意的是，与第一种和第二种方法不同，其中推荐过程使用原始数据，这里的推荐过程需要一个中间步骤：这个k-NN计算和存储。在这种情况下，描述性模型和预测模型不匹配。
- en: Listing 4.14 shows a Python script for computing k-NN and storing this data
    back in the graph. It works on the graph database we imported from the MovieLens
    dataset.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14显示了一个用于计算k-NN并将这些数据存储回图中的Python脚本。它适用于我们从MovieLens数据集导入的图数据库。
- en: Listing 4.14 Code for creating the k-NN network
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 创建k-NN网络的代码
- en: '[PRE15]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Overall function that performs all the tasks for all the movies
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行所有电影任务的整体函数
- en: ❷ This function projects each movie in the VSM.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此函数将VSM中的每部电影进行投影。
- en: ❸ This function computes the k-NN for each movie.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此函数计算每部电影的k-NN。
- en: ❹ Here, it uses the cosine_similarity available in scikit.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这里，它使用了scikit中可用的cosine_similarity。
- en: ❺ This function stores the k-NN on the graph database.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此函数将k-NN存储在图数据库中。
- en: ❻ Before storing the new similarity, deletes the old
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在存储新的相似性之前删除旧的
- en: This code may take a while to complete. Here, I am presenting the basic ideas;
    in sections 6.3 and 9.2, I discuss several optimization techniques for real projects.
    Moreover, I would like to mention that Neo4j provides a plugin for data science
    called Graph Data Science Library[⁷](#pgfId-1011982) (GDS), which contains many
    similarity algorithms. If you are using Neo4j, I recommend using this library.
    The preceding code is more generic and can be used in any circumstance.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可能需要一段时间才能完成。在这里，我展示了基本思想；在第6.3节和第9.2节中，我讨论了真实项目中的一些优化技术。此外，我想提到Neo4j提供了一个名为Graph
    Data Science Library[⁷](#pgfId-1011982)（GDS）的数据科学插件，其中包含许多相似性算法。如果您使用Neo4j，我建议使用这个库。前面的代码更通用，可以在任何情况下使用。
- en: Exercises
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'When the k-NN has been computed via the code in listing 4.14, write a query
    to do the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过列表4.14中的代码计算了k-NN后，编写一个查询来完成以下操作：
- en: Get a movie (by movieId), and get the list of the 10 most similar items.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一部电影（通过movieId），并获取最相似的10个物品列表。
- en: Search for the 10 most similar pairs of items.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索最相似的10对物品。
- en: The next step in the recommendation process for this third approach, as depicted
    in figure 4.19, consists of making the recommendations, which we do by drawing
    on the k-NN network and the user’s implicit/explicit preferences for items. The
    goal is to predict those not-yet-seen/bought/clicked items that could be of interest
    to a user.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在此第三种推荐流程的下一步，如图4.19所示，包括生成推荐，我们通过利用k-NN网络和用户对物品的隐式/显式偏好来实现这一点。目标是预测那些尚未看到/购买/点击的、可能对用户感兴趣的物品。
- en: This task can be accomplished in different ways. In the simplest approach [Allan,
    1998], the prediction for a not-yet-seen item d for a user >u is based on a voting
    mechanism considering the k most similar items (in our scenario, movies) to the
    item >d. Each of these similar items “expresses” a vote for d if the user u watched
    or rated it. If the current user liked 4 out of k = 5 of the items most similar
    to d, for example, the system may guess that the chance that the user will also
    like d is relatively high.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可以通过不同的方式完成。在最简单的方法[Allan, 1998]中，对于用户>u尚未看到的物品d的预测基于一个投票机制，考虑与物品>d最相似的k个物品（在我们的场景中是电影）。如果用户u观看了或评价了这些最相似的k=5个物品中的4个，例如，系统可能会猜测用户也会喜欢d的机会相对较高。
- en: 'Another, more-accurate approach is inspired by collaborative filtering, specifically
    by item-based collaborative filtering recommendations [Sarwar et al., 2001, and
    Deshpande and Karypis, 2004]. This approach involves predicting the interest of
    a user in a specific item by considering the sum of all the similarities of the
    target item to the other items the user interacted with before:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更精确的方法是受协同过滤的启发，特别是受基于物品的协同过滤推荐[Sarwar et al., 2001, and Deshpande and Karypis,
    2004]。这种方法涉及通过考虑目标物品与其他用户之前互动过的物品的所有相似性之和来预测用户对特定物品的兴趣：
- en: '![CH04_F21_Negro_EQ03](../Images/CH04_F21_Negro_EQ03.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F21_Negro_EQ03](../Images/CH04_F21_Negro_EQ03.png)'
- en: 'Here, *Items(u)* returns all the items the user has interacted with (liked,
    watched, bought, clicked). The returned value can be used to rank all the not-yet-seen
    items and return the top k to the user as recommendations. The following listing
    implements the final step: providing recommendations for this third scenario.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*Items(u)* 返回用户已与之互动的所有物品（喜欢、观看、购买、点击）。返回的值可用于对所有尚未看到的物品进行排名，并将前k个推荐给用户。以下列表实现了最后一步：为这种第三种场景提供推荐。
- en: Listing 4.15 Code for getting a ranked list of items for the user
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 获取用户物品排名列表的代码
- en: '[PRE16]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ This function provides the recommendations to the user.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此函数向用户提供推荐。
- en: ❷ This query returns the recommendations; it requires the model built previously.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此查询返回推荐；它需要之前构建的模型。
- en: When you run this code, you’ll notice that it is fast. When the model is created,
    providing recommendations takes only a few milliseconds.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会注意到它运行得很快。当模型创建后，提供推荐只需几毫秒。
- en: Other approaches can also be used, but they are out of the scope of this chapter
    and this book. The main purpose here is to show how, when you’ve defined a proper
    model for items, users, and the interaction between them, you can use multiple
    approaches to provide recommendations without changing the base graph model defined.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用其他方法，但它们超出了本章和本书的范围。这里的主要目的是展示，当你为物品、用户及其交互定义了适当的模型后，你可以使用多种方法来提供推荐，而无需更改定义的基本图模型。
- en: Exercise
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Rewrite the method that computes the similarity between items to use a different
    function from cosine similarity, such as the Jaccard index ([http://mng.bz/qePA](http://mng.bz/qePA)),
    Dice coefficient, or Euclidian distance ([http://mng.bz/7jmm](http://mng.bz/7jmm)).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写计算物品之间相似度的方法，使用与余弦相似度不同的函数，例如Jaccard指数([http://mng.bz/qePA](http://mng.bz/qePA))、Dice系数或欧几里得距离([http://mng.bz/7jmm](http://mng.bz/7jmm))。
- en: 4.4 Advantages of the graph approach
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 图方法的优势
- en: In this chapter, we discussed how to create a CBRS by using graphs and graph
    models for storing different types of information that are useful as input and
    output for several steps of the recommendation process. Specifically, the main
    aspects and advantages of the graph-based approach to content-based recommendations
    are
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用图和图模型创建CBRS，用于存储在推荐过程的不同步骤中作为输入和输出的不同类型的信息。特别是，基于图的内容推荐方法的主要方面和优势是
- en: Meaningful information must be stored as unique node entities in the graph so
    that these entities can be shared across items and users.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有意义的信息必须作为唯一的节点实体存储在图中，以便这些实体可以在物品和用户之间共享。
- en: Converting user-item data to user-feature data is a trivial task when the meta
    information is available and is meaningful; you need a query to compute and materialize
    it.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当元信息可用且有意义时，将用户-物品数据转换为用户-特征数据是一项简单的任务；你需要一个查询来计算和实现它。
- en: It is possible to extract several vector representations for both items and
    user profiles from the same graph model. The capability to extract several types
    of vectors easily improves the feature selection because it reduces the effort
    required to try different approaches.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从同一个图模型中可以提取物品和用户配置文件的好几个向量表示。轻松提取多种类型的向量可以改善特征选择，因为它减少了尝试不同方法所需的努力。
- en: It is possible to store different similarity values computed with different
    functions and use them in combination.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的函数计算不同的相似度值，并将它们组合使用是可能的。
- en: The code showed how easy it is to switch among different models or even combine
    them if they are described by a proper graph model.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码展示了在不同模型之间切换或甚至将它们结合起来的简便性，前提是它们由适当的图模型描述。
- en: The great advantage is the flexibility provided by the graph representation
    of the information, enabling the same data model to serve many use cases and scenarios
    with small adaptations. Furthermore, all the scenarios can coexist in the same
    database, which frees data scientists and data engineers from having to deal with
    multiple representations of the same information. These advantages are shared
    by all the recommendation methods described in the following chapters.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势是信息图表示的灵活性，它使得相同的数据模型可以通过小的调整服务于许多用例和场景。此外，所有场景都可以存在于同一个数据库中，这使数据科学家和数据工程师免于处理相同信息的多个表示。以下章节中描述的所有推荐方法都共享这些优势。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to graph-based data modeling techniques. In this
    first chapter on the topic, we focused on recommendation engines, exploring how
    to model data sources used for training, how to store the resulting model, and
    how to access it to make predictions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了基于图的建模技术。在本主题的第一章中，我们专注于推荐引擎，探讨了如何建模用于训练的数据源，如何存储生成的模型，以及如何访问它以进行预测。
- en: In this chapter, you learned
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: How to design a graph model for a user-item as well as a user-feature dataset
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计用于用户-物品以及用户-特征数据集的图模型
- en: How to import data from the original format into the graph model you’ve designed
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将数据从原始格式导入到您设计的图模型中
- en: How to project user profile and item data and metadata into a vector space model
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将用户配置文件和物品数据以及元数据投影到向量空间模型中
- en: How to compute similarities between user and item profiles and among pairs of
    items by using cosine similarity and other functions
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过余弦相似度和其他函数计算用户和项目配置文件之间的相似度以及项目对之间的相似度
- en: How to store item similarities in the graph model
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在图模型中存储项目相似度
- en: How to query the resulting model to perform predictions and recommendations
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询生成的模型以执行预测和推荐
- en: How to design and implement a graph-powered recommendation engine from end to
    end, using different approaches of increasing complexity
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从头到尾设计和实现一个由图驱动的推荐引擎，使用不同复杂度的方法
- en: The role of k-NN and k-NN networks in machine learning in general and in graph-based
    machine learning
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k-NN和k-NN网络在机器学习（一般）和基于图机器学习中的作用
- en: References
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[Allan, 1998] Allan, James. “Topic Detection and Tracking Pilot Study Final
    Report.” *Proceedings of the DARPA Broadcast News Transcription and Understanding
    Workshop* (1998): 194-218.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[Allan, 1998] Allan, James. “主题检测与跟踪试点研究最终报告。” *DARPA广播新闻转录和理解研讨会论文集* (1998):
    194-218.'
- en: '[Deshpande and Karypis, 2004] Deshpande, Mukund, and George Karypis. “Item-Based
    Top-*N* Recommendation Algorithms.” *ACM Transactions on Information Systems*
    22:1 (2004): 143-177\. DOI: [http://mng.bz/jB6x](http://mng.bz/jB6x).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[Deshpande and Karypis, 2004] Deshpande, Mukund, 和 George Karypis. “基于项目的Top-*N*推荐算法。”
    *ACM信息系统交易* 22:1 (2004): 143-177\. DOI: [http://mng.bz/jB6x](http://mng.bz/jB6x).'
- en: '[Dice, 1945] Dice, Lee Raymond. “Measures of the Amount of Ecologic Association
    Between Species.” *Ecology* 26:3 (1945): 297-302\. DOI: [http://mng.bz/9N8l](http://mng.bz/9N8l).
    JSTOR 1932409.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dice, 1945] Dice, Lee Raymond. “物种之间生态关联量的度量。” *生态学* 26:3 (1945): 297-302\.
    DOI: [http://mng.bz/9N8l](http://mng.bz/9N8l). JSTOR 1932409.'
- en: '[Jannach et al., 2010] Jannach, Dietmar, Markus Zanker, Alexander Felfernig,
    and Gerhard Friedrich. *Recommender Systems: An Introduction*. Cambridge, UK:
    Cambridge University Press, 2010\. DOI: [http://mng.bz/K4dK](http://mng.bz/K4dK).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jannach et al., 2010] Jannach, Dietmar, Markus Zanker, Alexander Felfernig,
    和 Gerhard Friedrich. *推荐系统：导论*. 英国剑桥：剑桥大学出版社，2010年\. DOI: [http://mng.bz/K4dK](http://mng.bz/K4dK).'
- en: '[Sarwar et al., 2001] Sarwar, Badrul, George Karypis, Joseph Konstan, and John
    Riedl. “Item-Based Collaborative Filtering Recommendation Algorithms.” *Proceedings
    of the 10th International World Wide Web Conference* (2001): 285-295\. [http://mng.bz/Wrm0](http://mng.bz/Wrm0).'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[Sarwar et al., 2001] Sarwar, Badrul, George Karypis, Joseph Konstan, 和 John
    Riedl. “基于项目的协同过滤推荐算法。” *第10届国际万维网会议论文集* (2001): 285-295\. [http://mng.bz/Wrm0](http://mng.bz/Wrm0).'
- en: '[Ullman and Rajaraman, 2011], Ullman, Jeffrey David, and Anand Rajaraman. *Mining
    of Massive Datasets*. New York: Cambridge University Press, 2011.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ullman and Rajaraman, 2011], Ullman, Jeffrey David, 和 Anand Rajaraman. *大规模数据集挖掘*.
    纽约：剑桥大学出版社，2011年。'
- en: '* * *'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)IMDb (https://www.imdb.com) is an online database of information related
    to films, television programs, home videos, video games, and internet streams,
    including details on the cast and production crew, plot summaries, trivia, and
    fan reviews and ratings.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: ^（1）IMDb (https://www.imdb.com) 是一个包含与电影、电视节目、家庭录像、视频游戏和互联网流相关的信息的在线数据库，包括演员和制作团队、剧情简介、趣味知识和粉丝评论和评分的详细信息。
- en: ^(2.)The property graph, introduced in chapter 2, organizes data as nodes, relationships,
    and properties (data stored on the nodes or relationships).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ^（2）第2章中引入的属性图将数据组织为节点、关系和属性（存储在节点或关系上的数据）。
- en: ^(3.)Please tidy your database with MATCH (n) DETACH DELETE n.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ^（3）请使用MATCH (n) DETACH DELETE n.整理您的数据库。
- en: ^(4.)This query can be executed only after the import of the user rating has
    been done as shown in listing 4.9.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ^（4）此查询只能在用户评分导入完成后执行，如列表4.9所示。
- en: ^(5.)The average rating is not a valuable feature, but it will serve the purpose
    in our example.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ^（5）平均评分不是一个有价值的特征，但在我们的例子中它将起到作用。
- en: '^(6.)*Liked* here means any kind of interaction between user and item: watched,
    rated, and so on.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ^（6）*点赞*在这里意味着用户和项目之间的任何互动：观看、评分等。
- en: ^(7.)[https://neo4j.com/product/graph-data-science-library/](https://neo4j.com/product/graph-data-science-library/).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ^（7）[https://neo4j.com/product/graph-data-science-library/](https://neo4j.com/product/graph-data-science-library/).
