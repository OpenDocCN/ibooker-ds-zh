- en: Chapter 15\. Maintaining app state with ngrx
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章\. 使用ngrx维护应用状态
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: A brief introduction to the Redux data flow
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux数据流的简要介绍
- en: Maintaining your app state using the ngrx library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ngrx库维护你的应用状态
- en: Exploring another implementation of the Mediator design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索中介设计模式的另一种实现
- en: Implementing state management in ngAuction with ngrx
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ngAuction中使用ngrx实现状态管理
- en: You’ve made it to the last chapter, and you’re almost ready to join an Angular
    project. The previous chapter was easy reading, but this chapter will require
    your full attention; the material we’re about to present has many moving parts,
    and you’ll need to have a good understanding of how they play together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经到达了最后一章，你几乎准备好加入一个Angular项目了。上一章内容容易阅读，但这一章将需要你全神贯注；我们即将呈现的材料有很多动态部分，你需要很好地理解它们是如何协同工作的。
- en: ngrx is a library that can be used for managing state in Angular apps (see [https://github.com/ngrx](https://github.com/ngrx)).
    It’s built using the principles of Redux (another popular library for managing
    state), but the notification layer is implemented using RxJS. Although Angular
    has other means for managing app state, ngrx is gaining traction in mid- and large-size
    apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ngrx是一个可用于在Angular应用中管理状态的库（见[https://github.com/ngrx](https://github.com/ngrx)）。它是基于Redux的原则构建的（另一个流行的状态管理库），但通知层是使用RxJS实现的。尽管Angular有其他管理应用状态的方法，但ngrx在中型和大型应用中越来越受欢迎。
- en: Is it worth using the ngrx library for managing state in your app? It certainly
    has benefits, but they don’t come free. The complexity of your app can increase,
    and the code will become more difficult to understand by any new person who joins
    the project. In this chapter, we cover the ngrx library so you’ll be able to decide
    whether it’s the right choice for managing the state of your app. In the hands-on
    section, we do a detailed code overview of yet another version of ngAuction that
    uses ngrx for state management.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中使用ngrx库来管理状态值得吗？它确实有好处，但它们不是免费的。你应用的复杂性可能会增加，代码也会变得更加难以理解，对于任何新加入项目的人来说。在这一章中，我们介绍了ngrx库，这样你就可以决定它是否是你管理应用状态的正确选择。在实践部分，我们对使用ngrx进行状态管理的ngAuction的另一个版本进行了详细的代码概述。
- en: 15.1\. From a convenience store to Redux architecture
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1\. 从便利商店到Redux架构
- en: Imagine that you’re a proud owner of a convenience store that sells various
    products. Remember how you started? You rented an empty place (the store was in
    its *initial state*). Then you purchased shelves and ordered products. After that,
    multiple vendors started delivering those products. You hired employees who arranged
    these products on the shelves in a certain order, changing the state of the store.
    Then you put out the Grand Opening sign and festooned the place with lots of colorful
    balloons. Customers started visiting your store to buy products.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一家便利商店的骄傲所有者，该商店销售各种产品。你还记得你是如何开始的吗？你租了一个空地（商店处于*初始状态*）。然后你购买了货架并订购了产品。之后，多个供应商开始运送这些产品。你雇佣了员工，他们按照一定的顺序将这些产品摆放在货架上，改变了商店的状态。然后你挂出了盛大开幕的标志，并用许多五彩缤纷的气球装饰了地方。顾客开始光顾你的商店购买产品。
- en: When the store is open, some products lay on the shelves, and some are in shopping
    carts of customers. Some customers are waiting in lines at cash registers, where
    there are store employees. You can say that at any given moment, your store has
    the *current state*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当商店开业时，一些产品放在货架上，一些在顾客的购物车中。一些顾客在收银台排队，那里有商店员工。可以说，在任意时刻，你的商店都有*当前状态*。
- en: If a customer takes an *action*, such as buying five bottles of water, the cashier
    scans the barcode, and this *reduces* the number of bottles in the inventory—it
    updates the state. If a vendor delivers new products, your clerk updates the inventory
    (state) accordingly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顾客采取*行动*，例如购买五瓶水，收银员扫描条形码，这会*减少*库存中瓶子的数量——它会更新状态。如果供应商运送新产品，你的店员会相应地更新库存（状态）。
- en: Your web app can also maintain a store that holds the state of your app. Like
    a real store, at any given time your app’s *store* has a current *state*. Some
    data collections have specific data retrieved from the server and possibly modified
    by a user. Some radio buttons are checked, and a user selects some products and
    navigates to some routes represented by a specific URL.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Web应用程序也可以维护一个存储应用程序状态的商店。就像一个真正的商店，在任何给定时间，你的应用程序的*store*都有一个当前的*state*。一些数据集合可能包含从服务器检索的特定数据，并且可能被用户修改。一些单选按钮被选中，用户选择了一些产品并导航到由特定URL表示的一些路由。
- en: If a user interacts with the UI, or the server sends new data, these *actions*
    should ask the store object to update the state. To keep track of state changes,
    the current state object is never updated, but a new instance of the state object
    is created.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户与UI交互，或者服务器发送新数据，这些*actions*应该要求商店对象更新状态。为了跟踪状态变化，当前状态对象永远不会更新，而是创建状态对象的新实例。
- en: 15.1.1\. What’s Redux?
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1\. 什么是Redux？
- en: '*Redux* is an open source JavaScript library that offers a state container
    for JavaScript apps (see [http://mng.bz/005X](http://mng.bz/005X)). It was created
    at Facebook as an implementation of the Flux architecture (see [http://mng.bz/jrXy](http://mng.bz/jrXy)).
    Initially, the developers working with the React framework made Redux popular,
    but as it’s a JavaScript library, it can be used in any JavaScript app.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redux* 是一个开源的JavaScript库，为JavaScript应用程序提供了一个状态容器（见[http://mng.bz/005X](http://mng.bz/005X)）。它是在Facebook上创建的，作为Flux架构的实现（见[http://mng.bz/jrXy](http://mng.bz/jrXy)）。最初，与React框架一起工作的开发者使Redux变得流行，但由于它是一个JavaScript库，因此可以在任何JavaScript应用程序中使用。'
- en: 'Redux is based on the following three principles:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Redux基于以下三个原则：
- en: '***There’s a single source of truth.*** There’s a single store where your app
    contains the state that can be represented by an object tree.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***存在单一真相来源。*** 存储在单个商店中，你的应用程序包含可以表示为对象树的状态。'
- en: '***State is read-only.*** When an action is emitted, the reducer function doesn’t
    update but clones the current state and updates the cloned object based on the
    action.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***状态是只读的。*** 当发出一个动作时，reducer函数不会更新，而是克隆当前状态并根据动作更新克隆的对象。'
- en: '***State changes are made with pure functions.*** You write the reducer function(s)
    that take an action and the current state object and return a new state.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***状态变化是通过纯函数进行的。*** 你编写reducer函数（s），它接受一个动作和当前状态对象，并返回一个新的状态。'
- en: 'In Redux, the data flow is unidirectional:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux中，数据流是单向的：
- en: '**1**.  The app component dispatches the action on the store.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  应用组件在商店上派发动作。'
- en: '**2**.  The reducer (a pure function) takes the current state object and then
    clones, updates, and returns it.'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  reducer（一个纯函数）接收当前状态对象，然后克隆、更新并返回它。'
- en: '**3**.  The app component subscribes to the store, receives the new state object,
    and updates the UI accordingly.'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  应用组件订阅商店，接收新的状态对象，并相应地更新UI。'
- en: '[Figure 15.1](#ch15fig01) shows the unidirectional Redux data flow.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.1](#ch15fig01) 展示了单向Redux数据流。'
- en: Figure 15.1\. The Redux data flow
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1\. Redux数据流
- en: '![](Images/15fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig01_alt.jpg)'
- en: An *action* is a JavaScript object that has a `type` property describing what
    happens in your app, such as a user wants to buy IBM stock. Besides the `type`
    property, an action object can optionally have another property with a payload
    of data that should change the app state in some fashion. An example is shown
    in the following listing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*action*是一个JavaScript对象，它有一个`type`属性，描述了在应用程序中发生的事情，例如用户想要购买IBM股票。除了`type`属性外，动作对象还可以有一个可选的属性，包含应该以某种方式更改应用程序状态的数据有效载荷。以下列表显示了示例。
- en: Listing 15.1\. An action to buy IBM stock
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. 购买IBM股票的动作
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The type of action**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 动作类型**'
- en: '***2* The action payload**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 动作有效载荷**'
- en: This object only describes the action and provides the payload. It doesn’t know
    how the state should be changed. Who does? The reducer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象仅描述动作并提供有效载荷。它不知道状态应该如何改变。谁知道？reducer。
- en: A *reducer* is a *pure function* that specifies how the state should be changed.
    The reducer never changes the current state, but creates a new (and updated) version
    of it. The state object is immutable. The reducer creates a copy of the state
    object and returns a new reference to it. From an Angular perspective, it’s a
    binding change event, and all interested parties will immediately know that the
    state has changed without requiring expensive value checking in the entire state
    tree.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *reducer* 是一个 *纯函数*，它指定了状态应该如何改变。reducer 从不改变当前状态，而是创建一个新的（并且更新过的）状态版本。状态对象是不可变的。reducer
    创建状态对象的副本并返回一个新的引用。从 Angular 的角度来看，这是一个绑定变更事件，所有相关方将立即知道状态已更改，而无需在整个状态树中进行昂贵的值检查。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Your state object can contain dozens of properties and nested objects. Cloning
    the state object creates a shallow copy without copying each unmodified state
    property in memory, so memory consumption is minimal and it doesn’t take much
    time. You can read about the rationale for creating shallow state copies at [http://mng.bz/3271](http://mng.bz/3271).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的状态对象可以包含数十个属性和嵌套对象。克隆状态对象创建了一个浅拷贝，而不在内存中复制每个未修改的状态属性，因此内存消耗最小，并且不需要花费太多时间。您可以在[http://mng.bz/3271](http://mng.bz/3271)上了解创建浅状态拷贝的理由。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A reducer function has the signature shown in the following listing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个reducer函数具有以下列表中所示的签名。
- en: Listing 15.2\. A reducer signature
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.2\. 一个reducer签名
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* A reducer function returns a new state.**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个reducer函数返回一个新的状态。**'
- en: Should the reducer function implement app functionality like placing an order,
    which requires work with external services? No, because reducers are meant for
    updating and returning the app state—for example, the stock to buy is `"IBM"`.
    Implementing app logic would require interaction with the environment external
    to the reducer; it would cause *side effects*, and pure functions can’t have side
    effects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该让reducer函数实现像放置订单这样的应用功能，这需要与外部服务交互？不，因为reducer是用来更新和返回应用状态的——例如，要购买的股票是
    `"IBM"`。实现应用逻辑需要与reducer外部环境交互；它会导致 *副作用*，而纯函数不能有副作用。
- en: The reducer can implement minimal app logic related to state change. For example,
    suppose a user decides to cancel an order, which requires a reset of certain fields
    on the state object. The main app logic remains in your application code (for
    example, in services) unless a concrete implementation of the Redux-inspired library
    offers a special place meant for code with side effects. In this chapter, we use
    the ngrx library, which suggests using Angular services combined with so-called
    *effects* that live outside of the store and that can aggregate Angular services
    working as a bridge between the store and services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer可以实现与状态变化相关的最小应用逻辑。例如，假设用户决定取消一个订单，这需要在状态对象上重置某些字段。主要应用逻辑仍然保留在您的应用代码中（例如，在服务中），除非Redux灵感库的具体实现提供了一个专门用于具有副作用代码的位置。在本章中，我们使用ngrx库，它建议使用Angular服务与所谓的
    *effects* 结合使用，这些 *effects* 位于存储之外，可以作为存储和服务之间的桥梁。
- en: 15.1.2\. Why storing app state in a single place is important
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2\. 为什么将应用状态存储在单一位置很重要
- en: Recently, one of the authors of this book worked on a web project for a large
    car manufacturer. This was a web app that allowed a prospective buyer to configure
    a car by selecting from more than a thousand packages and options (such as model,
    interior and exterior colors, length of chassis, and so on). The app was developed
    over many years. The software modules were written using JavaScript, jQuery, Angular,
    React, and Handlebars, as well as the HTML templating engine Thymeleaf on the
    server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，本书的一位作者为一家大型汽车制造商的一个网络项目工作。这是一个允许潜在买家通过从超过一千个套餐和选项（如型号、内饰和外观颜色、底盘长度等）中进行选择来配置汽车的网络应用。该应用开发了许多年。软件模块使用JavaScript、jQuery、Angular、React和Handlebars编写，在服务器上使用HTML模板引擎Thymeleaf。
- en: From a user perspective, this was one workflow that consisted of several steps
    resulting in configuring and pricing the car based on selected options. But internally,
    the process was switching from one module to another, and each module needed to
    know what was selected in the previous step to show the available options.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这是一个由多个步骤组成的流程，最终根据所选选项配置和定价汽车。但内部，过程是从一个模块切换到另一个模块，每个模块都需要知道前一步的选择，以显示可用的选项。
- en: 'In other words, each module needed to know the current state of the app. Depending
    on the software used in any particular module, the current user selections were
    stored using one of the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个模块都需要知道应用程序的当前状态。根据任何特定模块中使用的软件，当前用户选择被存储在以下之一中：
- en: URL parameters
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 参数
- en: HTML `data*` attributes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML `data*` 属性
- en: The browser’s local and session storage
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器的本地和会话存储
- en: Angular services
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 服务
- en: The React store
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 存储
- en: New requirements came in, new JIRA tickets were created and assigned, and implementation
    would begin. Time and time again, implementing a seemingly simple new requirement
    would turn into a time-consuming and expensive task. Good luck explaining to the
    manager why showing the price in page B would take a half day even though this
    price was already known in page A, or that the state object used in page B didn’t
    expect to have the price property, and if in page A the price was a part of the
    URL, page B expected to get the current state from local storage. Rewriting it
    from scratch was not an option. It would have been so much easier if app state
    had been implemented in a uniform way and stored in a single place!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 新的要求出现了，创建了新的 JIRA 工作项并分配了任务，然后开始实施。一次又一次，看似简单的新的需求实施变成了耗时且昂贵的任务。祝你好运向经理解释为什么在页面
    B 显示价格需要半天时间，尽管这个价格已经在页面 A 中已知，或者页面 B 中使用的状态对象没有期望有价格属性，如果在页面 A 中价格是 URL 的一部分，页面
    B 期望从本地存储中获取当前状态。从头开始重写不是选项。如果应用程序状态以统一的方式实现并存储在单个位置，那就容易多了！
- en: '|  |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re starting to develop a new project, pay special attention on how app
    state is implemented, and it will help you greatly in the long run.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始开发一个新项目，请特别注意应用程序状态的实现方式，这将在长期内对你有很大帮助。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 15.2\. Introducing ngrx
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. 介绍 ngrx
- en: ngrx is a library inspired by Redux. You can think of it as an implementation
    of the Redux pattern for managing app state in Angular apps. Similarly to Redux,
    it implements a unidirectional data flow and has a store, actions, and reducers.
    It also uses RxJS’s ability to send notifications and subscribe to them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ngrx 是一个受 Redux 启发的库。你可以将其视为在 Angular 应用程序中管理应用程序状态的 Redux 模式的实现。与 Redux 类似，它实现了单向数据流，并具有
    store、actions 和 reducers。它还使用了 RxJS 的发送通知和订阅通知的能力。
- en: Large enterprise apps often implement messaging architecture on the server side,
    where one piece of software sends a message to another via some messaging server
    or a message bus. You can think of ngrx as a client-side messaging system. The
    user clicks a button, and the app sends a message (for example, dispatches an
    action). The app state changed because of this button click, and the ngrx `Store`
    sends a message to the subscriber(s), emitting the next value into an observable
    stream.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大型企业应用程序通常在服务器端实现消息架构，其中一块软件通过某个消息服务器或消息总线向另一块软件发送消息。你可以将 ngrx 视为一个客户端消息系统。用户点击一个按钮，应用程序就会发送一个消息（例如，分发一个动作）。由于这个按钮点击，应用程序的状态发生了变化，而
    ngrx 的 `Store` 向订阅者发送消息，将下一个值发射到一个可观察的流中。
- en: 'In [section 15.1](#ch15lev1sec1), we described three Redux principles:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15.1节](#ch15lev1sec1)中，我们描述了三个 Redux 原则：
- en: A single source of truth.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一真相源。
- en: State is read-only.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是只读的。
- en: State changes are made with pure functions.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态变化是通过纯函数实现的。
- en: 'In ngrx, app state is accessed with the `Store` service, which is an observable
    of state and an observer of actions. The declaration of the class `Store` in the
    store.d.ts file looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ngrx 中，应用程序状态通过 `Store` 服务访问，这是一个状态的可观察对象和动作的观察者。在 store.d.ts 文件中声明的 `Store`
    类如下所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides declaring a new principle, the ngrx architecture includes *effects*,
    which are meant for the code that communicates with other parts of the app, such
    as making HTTP requests. With ngrx selectors, you can subscribe to changes in
    a particular branch of the state object. There’s also support for routing and
    collections of entities, which can be useful in CRUD operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明一个新的原则，ngrx 架构还包括 *effects*，这些 effects 用于与应用程序的其他部分通信的代码，例如执行 HTTP 请求。使用
    ngrx selectors，你可以订阅状态对象特定分支的变化。还有对路由和实体集合的支持，这在 CRUD 操作中可能很有用。
- en: 'We’ll start our ngrx introduction with its main players: a store, actions,
    and reducers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始 ngrx 介绍，从其主要参与者：store、actions 和 reducers。
- en: 15.2.1\. Getting familiar with a store, actions, and reducers
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1. 熟悉 store、actions 和 reducers
- en: Let’s see how to use ngrx in a simple app that has two buttons that can either
    increment or decrement the value of the counter. The first version of this app
    doesn’t manage state and looks like the following listing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在具有两个按钮的简单应用程序中使用ngrx，这两个按钮可以增加或减少计数器的值。此应用程序的第一个版本不管理状态，如下所示。
- en: Listing 15.3\. The counter app without ngrx
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 没有ngrx的计数器应用程序
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Shows the counter value**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示计数器的值**'
- en: '***2* Increments the counter**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 增加计数器**'
- en: '***3* Decrements the counter**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 减少计数器**'
- en: 'You want to change this app so that the ngrx store manages the state of the
    `counter` variable, but first you need to install the ngrx store in your project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要更改此应用程序，使其ngrx存储管理`counter`变量的状态，但首先你需要在项目中安装ngrx存储：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Store` serves as a container of the state, and dispatching actions is the
    only way to update the state. The plan is to instantiate the `Store` object and
    remove the app logic (incrementing and decrementing the counter) from the component.
    Your `decrement()` and `increment()` methods will be dispatching actions on the
    `Store` instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Store`充当状态的容器，分发操作是更新状态的唯一方式。计划是实例化`Store`对象，并将应用程序逻辑（增加和减少计数器）从组件中移除。你的`decrement()`和`increment()`方法将向`Store`分发操作。'
- en: Actions are handled by the ngrx reducer, which will update the state of the
    counter. The type of your `counter` variable will change from `number` to `Observable`,
    and to get and render its emitted values in the UI, you’ll subscribe to the `Store`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 操作由ngrx reducer处理，它将更新计数器的状态。你的`counter`变量的类型将从`number`变为`Observable`，为了在UI中获取和渲染其发出的值，你需要订阅`Store`。
- en: 'The only required property in the `Action` object is `type`, and for your app,
    you’ll declare the action types as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`对象中唯一的必需属性是`type`，对于你的应用程序，你将声明操作类型如下：'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to create a reducer function for each piece of data you want
    to keep in the store. In your case, it’s just the value of the counter, so you’ll
    create a reducer with the `switch` statement for updating state based on the received
    action type, as shown in the following listing. Remember, the reducer function
    takes two arguments: state and action.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为你想要在存储中保留的每份数据创建一个reducer函数。在你的情况下，只是计数器的值，所以你会创建一个reducer，使用`switch`语句根据接收到的操作类型更新状态，如下所示。记住，reducer函数接受两个参数：状态和操作。
- en: Listing 15.4\. reducer.ts
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. reducer.ts
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The initial value of the counter (state) is zero.**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计数器（状态）的初始值是零。**'
- en: '***2* Checks the action type**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查操作类型**'
- en: '***3* Updates state by incrementing the counter**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过增加计数器来更新状态**'
- en: '***4* Updates state by decrementing the counter**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过减少计数器来更新状态**'
- en: '***5* Returns the existing state if an unknown action is provided**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果提供了未知操作，则返回现有状态**'
- en: It’s important to note that the reducer function doesn’t modify the provided
    state, but returns a new value. The state remains immutable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，reducer函数不会修改提供的状态，而是返回一个新的值。状态保持不可变。
- en: Now you need to inform the root module that you’re going to use the `counterReducer()`
    function as a reducer for your store, as shown in the following listing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要通知根模块你将使用`counterReducer()`函数作为存储的reducer，如下所示。
- en: Listing 15.5\. app.module.ts
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. app.module.ts
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Lets the store know about the reducer for the app**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 让存储知道应用程序的reducer**'
- en: In this code, you configure the app-level store to provide the object that specifies
    `counterReducer` as the name of the reducer function, and `counterState` as the
    property where this reducer should keep the state.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你配置应用程序级别的存储以提供指定`counterReducer`作为reducer函数名称的对象，以及`counterState`作为此reducer应保持状态的性质。
- en: Finally, you need to change the code of your component to dispatch either the
    action of type `INCREMENT` or `DECREMENT`, depending on which button a user clicks.
    You’ll also inject the `Store` into your component and subscribe to its observable
    that will emit a value each time the counter changes, as shown in the following
    listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要更改组件的代码以分发类型为`INCREMENT`或`DECREMENT`的操作，具体取决于用户点击哪个按钮。你还将把`Store`注入到你的组件中，并订阅其可观察对象，每次计数器变化时都会发出值，如下所示。
- en: Listing 15.6\. app.component.ts
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. app.component.ts
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Subscribes to the observable with the async pipe**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用异步管道订阅可观察对象**'
- en: '***2* Declares the reference variable for the store observable**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明存储可观察对象的引用变量**'
- en: '***3* select() emits changes in the counterState.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* select() 发射 counterState 的变化。**'
- en: '***4* Dispatches the INCREMENT action**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 分发 INCREMENT 动作**'
- en: '***5* Dispatches the DECREMENT action**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 分发 DECREMENT 动作**'
- en: 'Note that an action is an object (for example, `{type: INCREMENT}`), and in
    this app, action objects have no payload. You can also think of an action as a
    message or a command. In the next section, you’ll be defining each action as a
    class with two properties: type and payload.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，动作是一个对象（例如，`{type: INCREMENT}`），在这个应用中，动作对象没有负载。您也可以将动作视为消息或命令。在下一节中，您将定义每个动作为一个具有两个属性（类型和负载）的类。'
- en: In this component, you use the `select` operator (defined in the ngrx `Store`),
    which allows you to observe the state object. The name of its argument must match
    the name of the state object property used in the `StoreModule.forRoot()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此组件中，您使用 `select` 操作符（在 ngrx `Store` 中定义），它允许您观察状态对象。其参数的名称必须与在 `StoreModule.forRoot()`
    函数中使用的状态对象属性名称匹配。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'The `counterReducer` was assigned to the store by invoking the method `StoreModule.forRoot({counterState:
    counterReducer})` in the module. The `AppComponent` communicated with the `counterReducer`
    either by dispatching an action on the store or by using the `select` operator
    on the store.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '通过在模块中调用 `StoreModule.forRoot({counterState: counterReducer})` 方法将 `counterReducer`
    分配给存储。`AppComponent` 通过在存储上分发动作或使用存储上的 `select` 操作符与 `counterReducer` 进行通信。'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The app with the ngrx store will have the same behavior as the original one
    and will increment and decrement the counter depending on the user’s action.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 ngrx 存储的应用将具有与原始应用相同的行为，并根据用户的操作增加和减少计数器。
- en: Now let’s check whether your store is really a single source of truth. You’ll
    add a child component in the next listing that will display the current value
    of the counter received from the store, and 10 seconds after app launch, the child
    will dispatch the `INCREMENT` action.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查您的存储是否真的是单一事实来源。您将在下一个列表中添加一个子组件，该组件将显示从存储接收到的当前计数器值，并在应用启动后 10 秒，子组件将分发
    `INCREMENT` 动作。
- en: Listing 15.7\. child.component.ts
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表 15.7\. child.component.ts**'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Injects the store**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入存储**'
- en: '***2* Subscribes to the store**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 订阅存储**'
- en: '***3* In 10 seconds, dispatches the INCREMENT action**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 10 秒内，分发 INCREMENT 动作**'
- en: The only thing left is adding the `<app-child>` tag to the template of `AppComponent`.
    [Figure 15.2](#ch15fig02) shows the app after the user clicks the Increment button
    three times. Both parent and child components show the same value of the counter
    taken from the store (single source of truth). Ten seconds after the app starts,
    the `ChildComponent` dispatches the `INCREMENT` action, and both components will
    show the incremented counter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是将 `<app-child>` 标签添加到 `AppComponent` 的模板中。[图 15.2](#ch15fig02) 展示了用户点击增加按钮三次后的应用。父组件和子组件都显示了从存储中获取的相同计数器值（单一事实来源）。应用启动后
    10 秒，`ChildComponent` 分发 `INCREMENT` 动作，两个组件都将显示增加后的计数器。
- en: Figure 15.2\. Running the counter app
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**图 15.2\. 运行计数器应用**'
- en: '![](Images/15fig02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig02.jpg)'
- en: To see this app in action, open the project counter, run `npm install`, and
    then run `ng serve -o`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的实际运行情况，请打开项目 counter，运行 `npm install`，然后运行 `ng serve -o`。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The ngrx library includes the example app (see [http://mng.bz/7F9x](http://mng.bz/7F9x)),
    which allows you to maintain a book collection using Google Books API. The ngAuction
    app that comes with this chapter can also serve as an ngrx demo, although neither
    of these apps uses every API offered by ngrx.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ngrx 库包括示例应用（见 [http://mng.bz/7F9x](http://mng.bz/7F9x)），它允许您使用 Google Books
    API 维护书籍收藏。本章附带的本章 ngAuction 应用也可以作为 ngrx 的演示，尽管这两个应用都没有使用 ngrx 提供的每个 API。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The counter app is a pretty basic example, with a single reducer function. In
    practice, a store may have several reducers where each of them would be responsible
    for a portion of the state object. In the hands-on section, the new version of
    ngAuction will have several reducers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器应用是一个相当基本的示例，只有一个还原函数。在实际应用中，存储可能有多个还原器，每个还原器将负责状态对象的一部分。在实践部分，新的 ngAuction
    版本将包含多个还原器。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Eliminating the need for event bubbling**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**消除事件冒泡的需求**'
- en: Here’s a diagram you saw in [chapter 8](kindle_split_017.xhtml#ch08) in [section
    8.3.1](kindle_split_017.xhtml#ch08lev2sec3).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您在 [第 8 章](kindle_split_017.xhtml#ch08) 的 [8.3.1 节](kindle_split_017.xhtml#ch08lev2sec3)
    中看到的图表。
- en: '![](Images/f0390-01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0390-01.jpg)'
- en: A view consists of components
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 视图由组件组成
- en: Say component 7 can emit some data that’s needed in component 6\. If you use
    the common parents for intercomponent communication, you need to emit an event
    via the `@Output` property of component 7; parent component 3 would subscribe
    to this event and reemit it through its `@Output` property; and component 1 would
    subscribe to this event and, via binding, pass the payload to component 6.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设组件7可以发射一些在组件6中需要的数据。如果您使用常见的父组件进行组件间通信，您需要通过组件7的`@Output`属性发射一个事件；父组件3会订阅这个事件并通过其`@Output`属性重新发射；然后组件1会订阅这个事件，并通过绑定将有效载荷传递给组件6。
- en: Using the ngrx store eliminates the need to program this series of unfortunate
    events. Component 7 emits an action of the store, and component 6 uses a selector
    to receive it. The same, simple model of intercomponent communication works regardless
    of how many levels of component nesting exist in any particular view. The only
    thing that both components 7 and 6 need is the reference to the store object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ngrx存储消除了编写这一系列不幸事件的需要。组件7发射存储的动作，组件6使用选择器来接收它。无论在特定视图中组件嵌套的层级有多少，这种简单、相同的组件间通信模型都是适用的。组件7和6唯一需要的是存储对象的引用。
- en: This figure doesn’t give any details about what these eight components do, but
    you can assume that 1, 2, and 3 are *container components*, which include other
    components and implement app logic for interacting with their children, parents,
    and services. The rest are *presentational components* that can get data in, send
    data out, and present data on the UI. Some authors suggest that only container
    components should manage state and communicate with the store. We don’t agree
    with this, because state is not only about storing and sharing data—it’s also
    about storing the state of the UI, which is a part of any type of component.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此图没有提供关于这八个组件做什么的任何细节，但您可以假设1、2和3是*容器组件*，它们包含其他组件并实现与应用逻辑交互的子组件、父组件和服务。其余的是*表现组件*，可以接收数据、发送数据并在UI上呈现数据。一些作者建议只有容器组件应该管理状态并与存储进行通信。我们不同意这种观点，因为状态不仅仅是关于存储和共享数据——它还涉及到存储UI的状态，这是任何类型组件的一部分。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the counter example, the store managed app state represented by a number,
    but did you notice the store played yet another role? In [section 8.3.2](kindle_split_017.xhtml#ch08lev2sec4)
    in [chapter 8](kindle_split_017.xhtml#ch08), we showed you how an injectable service
    can play the role of mediator. In the counter app, the main goal of the ngrx store
    is to manage app state, but it also plays another role: serving as a mediator
    between parent and child components.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在计数器示例中，存储管理的是由数字表示的应用状态，但您注意到存储还扮演了另一个角色吗？在[第8章](kindle_split_017.xhtml#ch08)的[第8.3.2节](kindle_split_017.xhtml#ch08lev2sec4)中，我们向您展示了可注入服务如何扮演中介的角色。在计数器应用中，ngrx存储的主要目标是管理应用状态，但它还扮演了另一个角色：作为父组件和子组件之间的中介。
- en: In [chapter 8](kindle_split_017.xhtml#ch08), the mediator was a service with
    an RxJS `BehaviorSubject`, and you used components for sending and receiving data.
    With ngrx, you don’t need to manually create `BehaviorSubject`, because the `Store`
    object can be used for emitting values as well as subscribing to them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_017.xhtml#ch08)中，中介是一个带有RxJS `BehaviorSubject`的服务，您使用了组件来发送和接收数据。使用ngrx时，您不需要手动创建`BehaviorSubject`，因为`Store`对象既可以用来发射值，也可以用来订阅它们。
- en: To notify `BehaviorSubject` about the new value, you use `next()`, and to notify
    the store about the new state, you use `dispatch()`. To get the new state, subscribe
    to the observable in both cases. [Figure 15.3](#ch15fig03) compares the code of
    `EbayComponent` from [listing 8.13](kindle_split_017.xhtml#ch08ex13) in [chapter
    8](kindle_split_017.xhtml#ch08) (on the left) with `ChildComponent` that uses
    ngrx (on the right). They look similar, don’t they?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要通知`BehaviorSubject`关于新值的信息，您使用`next()`，而要通知存储关于新状态的信息，您使用`dispatch()`。在两种情况下，都要订阅可观察对象以获取新状态。[图15.3](#ch15fig03)比较了[第8章](kindle_split_017.xhtml#ch08)中的[列表8.13](kindle_split_017.xhtml#ch08ex13)中的`EbayComponent`的代码（在左侧）与使用ngrx的`ChildComponent`（在右侧）。它们看起来很相似，不是吗？
- en: Figure 15.3\. `EbayComponent` compared to `ChildComponent`
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.3. `EbayComponent`与`ChildComponent`的比较
- en: '![](Images/15fig03_alt.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig03_alt.jpg)'
- en: We can say that the `StateService` (left) and the `Store` (right) each serve
    as a single source of truth. But large non-ngrx apps with multiple injectable
    services that store different slices of state would have multiple sources of truth.
    In ngrx apps, the `Store` service always remains a single source of truth, which
    may have multiple slices of state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，`StateService`（左侧）和`Store`（右侧）各自作为单一的真实来源。但是，大型非ngrx应用中有多个可注入服务，它们存储不同的状态片段，会有多个真实来源。在ngrx应用中，`Store`服务始终是单一的真实来源，它可能有多个状态片段。
- en: Now take another look at the reducer in [listing 15.4](#ch15ex04), which was
    a pure function that didn’t need to use any external resource to update the state.
    What if the value for a counter was provided by a server? The reducer can use
    external resources because it would make the reducer *impure*, wouldn’t it? This
    is where ngrx effects come in, and we’ll discuss them next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再看看[列表15.4](#ch15ex04)中的reducer，它是一个不需要使用任何外部资源来更新状态的纯函数。如果计数器的值是由服务器提供的呢？reducer可以使用外部资源，因为它会使reducer变得*不纯*，不是吗？这就是ngrx
    effects发挥作用的地方，我们将在下一节讨论它们。
- en: 15.2.2\. Getting familiar with effects and selectors
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2\. 熟悉effect和selectors
- en: 'Reducers are *pure functions* that perform simple operations: take the state
    and action and create a new state. But you need to implement business logic somewhere,
    such as reaching out to services, making requests to servers, and so on. You need
    to implement *functions with side effects*, which is done in effect classes.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers是*纯函数*，执行简单的操作：接收状态和动作并创建一个新的状态。但是你需要在某个地方实现业务逻辑，例如调用服务、向服务器发送请求等。你需要实现*有副作用的函数*，这通常在effect类中完成。
- en: '*Effects* are injectable classes that live outside of the store and are used
    for implementing functionality that has side effects, without breaking unidirectional
    data flow. ngrx effects come in a separate package, and you need to run the following
    command to add them to your project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Effects*是存在于store之外的可注入类，用于实现具有副作用的函数，而不会破坏单向数据流。ngrx effects是一个单独的包，你需要运行以下命令将它们添加到你的项目中：'
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a component dispatches an action that requires communication with external
    resources, the action can be picked up by the `Effects` object, which will handle
    this action and dispatch another one on the reducer. For example, an effect can
    receive a `LOAD_PRODUCTS` action from the store, invoke `loadProducts()`, and,
    when the data is loaded, dispatch either of the `LOAD_PRODUCTS_SUCCESS` or `LOAD_PRODUCTS_FAILURE`
    actions. The reducer will pick it up and update state accordingly. [Figure 15.4](#ch15fig04)
    shows the ngrx flow that uses effects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件派发了一个需要与外部资源通信的动作，这个动作可以被`Effects`对象捕获，它将处理这个动作并在reducer上派发另一个动作。例如，一个effect可以从商店接收一个`LOAD_PRODUCTS`动作，调用`loadProducts()`，当数据加载完成后，派发`LOAD_PRODUCTS_SUCCESS`或`LOAD_PRODUCTS_FAILURE`动作之一。reducer将捕获它并相应地更新状态。[图15.4](#ch15fig04)展示了使用effect的ngrx数据流。
- en: Figure 15.4\. ngrx data flow with effects
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. 带有effect的ngrx数据流
- en: '![](Images/15fig04_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig04_alt.jpg)'
- en: To understand this diagram, imagine that a user clicks the Buy 100 button. The
    component would dispatch an action on the store, which can be handled by a reducer,
    an effect, or both. An effect can access external services and dispatch another
    action. In any case, a reducer is ultimately responsible for creating a new state,
    and a component can get it using a selector and update the UI accordingly (such
    as by rendering the message “Buying 100 shares”).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个图，想象一下用户点击了“购买100”按钮。组件会在商店上派发一个动作，这个动作可以被reducer、effect或两者处理。一个effect可以访问外部服务并派发另一个动作。在任何情况下，reducer最终都负责创建一个新的状态，组件可以使用selector获取它并相应地更新UI（例如，渲染“购买100股”的消息）。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We’d like to stress that even though actions can be handled in both a reducer
    and an effect, only a reducer can change the state of an app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调的是，尽管动作可以在reducer和effect中处理，但只有reducer可以改变应用的状态。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you compare the Redux and ngrx data flows shown in [figures 15.4](#ch15fig04)
    and [15.1](#ch15fig01) respectively, you’ll notice that the effects live outside
    the store. They can communicate with other Angular services, which in turn can
    communicate with external servers, if need be. Another difference in [figure 15.1](#ch15fig01)
    is that the view would use `subscribe()` to receive the latest state; 15.4 shows
    the `select()` method that can use a selector function to retrieve either the
    entire state object or its part.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较图15.4和图15.1中分别展示的Redux和ngrx数据流，你会注意到效果存在于存储之外。它们可以与其他Angular服务通信，反过来，这些服务也可以与外部服务器通信，如果需要的话。图15.1中的另一个不同之处在于，视图会使用`subscribe()`来接收最新状态；15.4展示了可以使用选择器函数检索整个状态对象或其部分的`select()`方法。
- en: In both Redux and ngrx, a component dispatches actions on the store. Redux actions
    are handled only in reducers, but in ngrx, some actions are handled in reducers,
    some in effects, and some in both. For example, if a component dispatches `LOAD_PRODUCTS`,
    a reducer can pick it up to set the state property `loading` to true, which will
    result in displaying a progress indicator. An effect can receive the same `LOAD_PRODUCTS`
    action and make an HTTP request for products.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redux和ngrx中，组件在存储上派发动作。Redux动作仅在reducer中处理，但在ngrx中，一些动作在reducer中处理，一些在效果中处理，还有一些两者都处理。例如，如果组件派发`LOAD_PRODUCTS`，reducer可以捕获它来设置状态属性`loading`为true，这将导致显示进度指示器。效果可以接收相同的`LOAD_PRODUCTS`动作并对产品进行HTTP请求。
- en: You know that to dispatch an action that should be handled by the reducer, a
    component invokes `Store.dispatch()`, but how can an effect dispatch an action?
    An effect returns an observable that wraps some payload. In your effects class,
    you’ll declare one or more class variables annotated with the `@Effect` decorator.
    Each effect will apply the `ofType` operator to ensure that it reacts to only
    the specified action type, as shown in the following listing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道要派发一个应该由reducer处理的动作，组件会调用`Store.dispatch()`，但效果如何派发动作？效果返回一个包含一些有效载荷的观察者。在你的效果类中，你将声明一个或多个用`@Effect`装饰器注解的类变量。每个效果都将应用`ofType`运算符，以确保它只对指定的动作类型做出反应，如下面的列表所示。
- en: Listing 15.8\. A fragment of a class with effects
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.8\. 带有效果的类片段
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `@Effect` decorator marks the observable property `loadProducts$`
    as a handler for the actions of type `LOAD_PRODUCTS` and invokes `getProducts()`,
    which returns an `Observable`. Then, based on the emitted value, the effect will
    dispatch another action (for example, success or failure). You’ll see how to do
    this in the next section. In general, you can think of an effect as middleware
    between the original action and the reducer, as shown in [figure 15.5](#ch15fig05).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`@Effect`装饰器将可观察属性`loadProducts$`标记为`LOAD_PRODUCTS`类型动作的处理程序，并调用`getProducts()`，它返回一个`Observable`。然后，根据发出的值，效果将派发另一个动作（例如，成功或失败）。你将在下一节中看到如何做到这一点。一般来说，你可以将效果视为原始动作和reducer之间的中间件，如图15.5所示。
- en: Figure 15.5\. Effects in the data flow
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.5\. 数据流中的效果
- en: '![](Images/15fig05_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig05_alt.jpg)'
- en: In your app module class, you need to add to the `@NgModule` decorator `EffectsModule.forRoot()`
    for the root module, or `EffectsModule.forFeature()` for a feature module.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用模块类中，你需要为根模块添加到`@NgModule`装饰器的`EffectsModule.forRoot()`，或者为功能模块添加`EffectsModule.forFeature()`。
- en: We don’t want to overwhelm you with the theory behind ngrx, so let’s continue
    developing an app that uses an ngrx store, actions with payloads, reducers, effects,
    and selectors.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想让你被ngrx背后的理论压倒，所以让我们继续开发一个使用ngrx存储、带有有效载荷的动作、reducer、效果和选择器的应用。
- en: 15.2.3\. Refactoring the mediator app with ngrx
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.3\. 使用ngrx重构中介器应用
- en: 'In this section, you’ll refactor the app created in [section 8.3.2](kindle_split_017.xhtml#ch08lev2sec4)
    in [chapter 8](kindle_split_017.xhtml#ch08). That app had a search field and two
    links, eBay and Amazon. You’ll refactor it by replacing the `SearchService` injectable
    that was maintaining app state with an ngrx store. To illustrate communication
    between effects and services, you’ll add `ProductService`, which will generate
    the search results: the products containing the entered search criterion in their
    names.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将重构第8章第8.3.2节（kindle_split_017.xhtml#ch08lev2sec4）中创建的应用。那个应用有一个搜索字段和两个链接，eBay和Amazon。你将通过用ngrx存储替换维护应用状态的`SearchService`注入式来重构它。为了说明效果和服务之间的通信，你将添加`ProductService`，它将生成搜索结果：包含输入搜索标准在其名称中的产品。
- en: 'The new version of the app is located in the mediator folder. It will use the
    following ngrx building blocks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的应用位于介质文件夹中。它将使用以下ngrx构建块：
- en: A store for storing and retrieving app state, search query, and results
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储和检索应用状态、搜索查询和结果的数据存储
- en: A reducer for handing actions of type `SEARCH` and `SEARCH_SUCCESS`
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理类型为`SEARCH`和`SEARCH_SUCCESS`的动作的reducer
- en: Effects for handling actions of type `SEARCH` and `SEARCH_SUCCESS`
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理类型为`SEARCH`和`SEARCH_SUCCESS`的动作的效果
- en: Selectors for retrieving the entire state object, search query, or search results
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检索整个状态对象、搜索查询或搜索结果的选择器
- en: '[Figure 15.6](#ch15fig06) shows the mediator app after a user enters `aaa`
    in the search field of the `SearchComponent`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.6](#ch15fig06)显示了用户在`SearchComponent`的搜索字段中输入`aaa`后的介质应用。'
- en: Figure 15.6\. The results of an `aaa` search on eBay
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.6\. 在eBay上进行的`aaa`搜索结果
- en: '![](Images/15fig06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig06.jpg)'
- en: The store state
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 店存状态
- en: 'The state object of this app will contain two properties: search query (for
    example, `aaa`) and search results (for example, five products). You’ll declare
    the type in the following listing to represent the state of your app.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用的状态对象将包含两个属性：搜索查询（例如，`aaa`）和搜索结果（例如，五个产品）。你将在以下列表中声明类型以表示你应用的状态。
- en: Listing 15.9\. The state of the mediator app
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.9\. 介质应用的状态
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Payload of the SEARCH action dispatched by SearchComponent**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* SearchComponent分发的SEARCH动作的有效负载**'
- en: '***2* Payload of SEARCH_SUCCESS dispatched by the effect after invoking ProductService.getProducts()**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在调用ProductService.getProducts()后，效果分发的SEARCH_SUCCESS的有效负载**'
- en: Actions
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动作
- en: In the counter app, actions don’t contain payloads; they increment or decrement
    the counter. This time it’s different. The `SEARCH` action can have a payload
    (such as `aaa`), and `SEARCH_SUCCESS` can have a payload as well (such as five
    products). That’s why declaring constants representing the action type isn’t enough,
    and you’ll wrap each action into a class with a constructor that has a payload
    as an argument. The actions will be declared in the file actions.ts, shown in
    the following listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在计数器应用中，动作不包含有效负载；它们增加或减少计数器。这次不同。`SEARCH`动作可以有有效负载（例如`aaa`），`SEARCH_SUCCESS`也可以有有效负载（例如五个产品）。这就是为什么仅声明表示动作类型的常量是不够的，你将把每个动作包裹在一个具有有效负载作为参数的构造函数的类中。动作将在以下列表中声明的actions.ts文件中声明。
- en: Listing 15.10\. actions.ts
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.10\. actions.ts
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Declares action types**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明动作类型**'
- en: '***2* The class representing the search action with a payload**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 代表带有有效负载的搜索动作的类**'
- en: '***3* The class representing the search-success action with a payload**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 代表带有有效负载的搜索成功动作的类**'
- en: '***4* Declares the union SearchAction type**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明联合搜索动作类型**'
- en: Note the text `[Product]` in the action definitions. In real-world apps, you
    may have more than one `SEARCH` action—one for products, one for orders, and so
    on. By prepending the action description with `[Product]`, you create a namespace
    to make the code more readable. Having namespaced actions helps in understanding
    which actions were dispatched at any given moment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意动作定义中的文本`[Product]`。在实际应用中，你可能会有多个`SEARCH`动作——一个用于产品，一个用于订单等。通过在动作描述前加上`[Product]`，你创建了一个命名空间，使代码更易于阅读。具有命名空间的动作有助于在任何给定时刻理解哪些动作被分发。
- en: The last line of actions.ts uses the TypeScript union operator described in
    [section B.11](kindle_split_026.xhtml#app02lev1sec11) in [appendix B](kindle_split_026.xhtml#app02).
    Here, you define the `SearchActions` type that will be used in the reducer’s signature,
    so the TypeScript compiler knows which actions are allowed in the reducer’s `switch`
    statement.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: actions.ts的最后一行使用了在[附录B](kindle_split_026.xhtml#app02)中[B.11](kindle_split_026.xhtml#app02lev1sec11)节描述的TypeScript联合操作符。在这里，你定义了将在reducer签名中使用的`SearchActions`类型，这样TypeScript编译器就知道在reducer的`switch`语句中允许哪些动作。
- en: The SearchComponent as action creator
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 作为动作创建者的SearchComponent
- en: The actions are declared, but someone has to create and dispatch them. In your
    app, the `SearchComponent` shown in the following listing will be creating and
    dispatching the action of type `SEARCH` after the user enters the search criterion.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 动作已声明，但有人必须创建和分发它们。在你的应用中，以下列表中显示的`SearchComponent`将在用户输入搜索条件后创建和分发类型为`SEARCH`的动作。
- en: Listing 15.11\. search.component.ts
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.11\. search.component.ts
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Subscribes to the form control’s observable**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 订阅表单控制的可观察对象**'
- en: '***2* Instantiates and dispatches an action of type SEARCH with the payload**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实例化和分发带有有效负载的SEARCH类型动作**'
- en: The dispatched action will be picked up by the reducer, which will update the
    `searchQuery` property on the state object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 分派的动作将被还原器捕获，它将更新状态对象上的 `searchQuery` 属性。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll talk about another action creator, the `SearchEffects` class, later in
    this section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节后面讨论另一个动作创建器，即 `SearchEffects` 类。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The reducer
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Reducer
- en: In the reducer shown in [listing 15.12](#ch15ex12), you declare the interface
    describing the structure of your app state and create an object that represents
    an initial state. The `reducer()` function will take the initial or current immutable
    state and, using a `switch` statement, will create and return a new state based
    on the action type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 15.12](#ch15ex12) 中显示的还原器中，你声明了一个描述你的应用程序状态结构的接口，并创建了一个表示初始状态的对象。`reducer()`
    函数将接受初始或当前不可变状态，并使用 `switch` 语句根据动作类型创建并返回一个新的状态。
- en: Listing 15.12\. reducers.ts
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.12\. reducers.ts
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Declares the structure of the state object**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明状态对象的结构**'
- en: '***2* Creates an object representing the initial state**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个表示初始状态的对象**'
- en: '***3* This action is dispatched by the component.**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这个动作由组件分派。**'
- en: '***4* Copies the existing state values into the new state object**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将现有状态值复制到新状态对象中**'
- en: '***5* Updates two state properties with the new values**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用新值更新两个状态属性**'
- en: '***6* This action will be dispatched by the effect.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 这个动作将由效果分派。**'
- en: '***7* Copies the existing state values into the new state object**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将现有状态值复制到新状态对象中**'
- en: '***8* Updates one state property with the new value**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用新值更新一个状态属性**'
- en: '***9* Returns the current state if an unexpected action was dispatched**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 如果分派了意外的动作，则返回当前状态**'
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If, in a `case` clause, you use the action type that wasn’t declared in the
    union type `SearchActions` (for example, `SEARCH22`), the TypeScript compiler
    returns an error.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个 `case` 子句中使用了未在联合类型 `SearchActions` 中声明的动作类型（例如，`SEARCH22`），TypeScript
    编译器将返回一个错误。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The more precise name for TypeScript union types is *discriminated unions*.
    If all the types in a union have a common type property, the TypeScript compiler
    can discriminate types by this property. It knows which particular type from the
    union was referred to within the `case` statement and suggests the correct type
    for the payload property.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 联合类型的更精确名称是 *区分联合*。如果一个联合中的所有类型都有一个共同的类型属性，TypeScript 编译器就可以通过这个属性来区分类型。它知道在
    `case` 语句中引用的是联合中的哪个特定类型，并为负载属性建议正确的类型。
- en: For cloning the state object and updating some of its properties, you use the
    spread operator described in [section A.7](kindle_split_025.xhtml#app01lev1sec7)
    in [appendix A](kindle_split_025.xhtml#app01). Note that state properties will
    be updated with the value of the action payload.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克隆状态对象并更新其一些属性，你使用在 [附录 A](kindle_split_025.xhtml#app01) 的 [A.7](kindle_split_025.xhtml#app01lev1sec7)
    节中描述的扩展操作符。注意，状态属性将使用动作负载的值进行更新。
- en: Effects
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Effects
- en: In this app, you’ll have one effect that will use a `ProductService` injectable
    to obtain products. To simplify the explanation, you don’t load products from
    an external server or file. Your `ProductService`, shown in the following listing,
    will generate and return an observable of five products. It uses the RxJS `delay`
    operator to emulate a one-second delay as if the products are coming from a remote
    computer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，你将有一个效果，它将使用 `ProductService` 注入式来获取产品。为了简化说明，你不会从外部服务器或文件加载产品。你的 `ProductService`，如下所示，将生成并返回五个产品的可观察对象。它使用
    RxJS 的 `delay` 操作符来模拟一秒钟的延迟，就像产品来自远程计算机一样。
- en: Listing 15.13\. product.service.ts
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.13\. product.service.ts
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* The counter concatenated to the search query is a product name.**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 连接到搜索查询的计数器是一个产品名称。**'
- en: '***2* A function to generate a product name**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个生成产品名称的函数**'
- en: '***3* Creates a five-element array using productGenerator()**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 productGenerator() 创建一个五个元素的数组**'
- en: '***4* Returns the observable of products after a one-second delay**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回一秒延迟后的产品可观察对象**'
- en: Your `SearchEffects` class will declare one effect, `loadProducts$`, that will
    dispatch the `SEARCH_RESULTS` effect having an array of products as its payload.
    You want to ensure that this effect will obtain products only if the store dispatched
    the `SEARCH` effect, so you use the ngrx operator `ofType(SEARCH)`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `SearchEffects` 类将声明一个效果，`loadProducts$`，它将分派具有产品数组作为负载的 `SEARCH_RESULTS`
    效果。你想要确保这个效果只有在存储分派了 `SEARCH` 效果时才会获取产品，所以你使用了 ngrx 操作符 `ofType(SEARCH)`。
- en: This effect extracts the payload of the action of type `SEARCH` (the search
    query) emitted by the `actions$` observable, and, using `switchMap`, will pass
    it over to the inner observable (the `getProducts()` method). Finally, the effect
    will dispatch the action of type `SEARCH_RESULTS` with the payload, all of which
    you can see in the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果从 `actions$` 可观察对象发出的类型为 `SEARCH` 的动作（搜索查询）中提取有效负载，并使用 `switchMap` 将其传递给内部可观察对象（`getProducts()`
    方法）。最后，效果将派发类型为 `SEARCH_RESULTS` 的动作，并带有有效负载，所有这些都可以在下面的列表中看到。
- en: Listing 15.14\. effects.ts
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.14\. effects.ts
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Initializes the loadProducts$ effect with the stream/observable**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用流/可观察对象初始化 loadProducts$ 效应**'
- en: '***2* Executes a search only if the store dispatched the SEARCH action**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仅当存储派发了 SEARCH 动作时执行搜索**'
- en: '***3* Extracts the payload from the action of type SEARCH**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从类型为 SEARCH 的动作中提取有效负载**'
- en: '***4* Obtains the product based on the specified search query**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 根据指定的搜索查询获取产品**'
- en: '***5* Dispatches the action of type SEARCH_SUCCESS with its payload**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用其有效负载派发类型为 SEARCH_SUCCESS 的动作**'
- en: '***6* Injects the ngrx Actions observable**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 注入 ngrx Actions 可观察对象**'
- en: '***7* Injects the ProductService**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 注入 ProductService**'
- en: In this example, you assume that `getProducts()` will always emit products,
    but you could add the `catchError()` function to the observer, where you’d emit
    the action that reports an error. You’ll see the use of `catchError()` in [listing
    15.31](#ch15ex31).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，你假设 `getProducts()` 总是会发出产品，但你可以在观察者中添加 `catchError()` 函数，在那里你会发出报告错误的动作。你将在
    [列表 15.31](#ch15ex31) 中看到 `catchError()` 的使用。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Although it’s okay to abandon unwanted results with `switchMap` while reading
    data, if you write an effect that performs the add, update, or delete operations,
    use `concatMap` instead. This will prevent possible race conditions when one request
    is in the middle of updating a record and another one comes in. With `concatMap`,
    all requests will arrive at the service one after another.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在读取数据时使用 `switchMap` 放弃不需要的结果是可以的，但如果编写执行添加、更新或删除操作的效应，请使用 `concatMap`。这将防止在更新记录的过程中一个请求正在进行更新，另一个请求到来时可能出现的竞争条件。使用
    `concatMap`，所有请求将依次到达服务。
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In some cases, you may want to create an effect that handles an action but
    doesn’t need to dispatch another one. For example, you may want to create an effect
    that merely logs the action. In such cases, you need to pass a `{dispatch: false}`
    object to the `@Effect` decorator:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '在某些情况下，你可能想创建一个处理动作但不需要派发另一个动作的效应。例如，你可能想创建一个仅记录动作的效应。在这种情况下，你需要将一个 `{dispatch:
    false}` 对象传递给 `@Effect` 装饰器：'
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Selectors
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择器
- en: In real-world apps, the state object can be represented by a tree of nested
    properties, and you may want to obtain specific slices of the store state rather
    than obtain the entire state object and manually traverse its content. Let’s see
    how app components can get the value of a specific state property by using selectors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，状态对象可以表示为嵌套属性的树，你可能只想获取存储状态的特定部分，而不是获取整个状态对象并手动遍历其内容。让我们看看应用程序组件如何通过使用选择器来获取特定状态属性的值。
- en: First, get the selector of the top-level feature state using the `createFeatureSelector()`
    method. Then, use this selector as a starting point for other more specific selectors
    using the `createSelector()` method, which returns a callback function for selecting
    a slice of state. The selectors of your app are declared in the file selectors.ts.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `createFeatureSelector()` 方法获取顶级功能状态的选择器。然后，使用此选择器作为其他更具体选择器的起点，使用 `createSelector()`
    方法，该方法返回用于选择状态切片的回调函数。你的应用程序的选择器在 selectors.ts 文件中声明。
- en: Listing 15.15\. selectors.ts
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.15\. selectors.ts
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Creates a top-level selector of the top-level state**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建顶级状态的选择器**'
- en: '***2* Creates a selector for the state property searchQuery**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建用于搜索查询状态属性的选择器**'
- en: '***3* Creates a selector for the state property searchResults**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建用于搜索结果状态属性的选择器**'
- en: 'The argument of the `createFeatureSelector()` method is the name of the reducer
    specified in the module. In the `@NgModule` decorator, you’ll have the following
    line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFeatureSelector()` 方法的参数是在模块中指定的还原器名称。在 `@NgModule` 装饰器中，你将看到以下行：'
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That’s why, to obtain the reference to this reducer, you write `createFeatureSelector
    ('myReducer');`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获取此还原器的引用，你将编写 `createFeatureSelector ('myReducer');`。
- en: 'Let’s recap what you’ve accomplished so far:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你到目前为止所取得的成就：
- en: '**1**.  You declared classes to represent the actions of types `SEARCH` and
    `SEARCH_RESULTS`.'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 你声明了表示 `SEARCH` 和 `SEARCH_RESULTS` 类型动作的类。'
- en: '**2**.  The `SearchComponent` can dispatch the action of type `SEARCH`.'
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. `SearchComponent` 可以发送类型为 `SEARCH` 的动作。'
- en: '**3**.  The reducer can handle both action types.'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 还原器可以处理两种动作类型。'
- en: '**4**.  You declared the effect that can obtain products and dispatch the action
    of type `SEARCH_RESULTS`.'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 你声明了可以获取产品和发送类型为 `SEARCH_RESULTS` 的动作的效果。'
- en: '**5**.  You declared selectors to obtain slices of the app state.'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 你声明了选择器以获取应用状态的片段。'
- en: To close the loop, you’ll use the selectors in eBay and Amazon components to
    render the search criterion and the retrieved products. The following listing
    shows only the code of the `EbayComponent` (the code of the `AmazonComponent`
    looks identical).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成循环，你将使用 eBay 和 Amazon 组件中的选择器来渲染搜索标准和检索到的产品。下面的列表只显示了 `EbayComponent` 的代码（`AmazonComponent`
    的代码看起来相同）。
- en: Listing 15.16\. ebay.component.ts
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.16\. ebay.component.ts
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Subscribes to the observable that emits the search criteria and renders
    it**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 订阅发出搜索标准的可观察对象并渲染它**'
- en: '***2* Subscribes to the observable that emits products and renders them**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 订阅发出产品并渲染它们**'
- en: '***3* Invokes the getSearchQuery() selector on the store**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在存储上调用 getSearchQuery() 选择器**'
- en: '***4* Invokes the getSearchResults() selector on the store**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在存储上调用 getSearchResults() 选择器**'
- en: '***5* Injects the store**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 注入存储**'
- en: The code of `EBayComponent` is concise and doesn’t contain any app logic. With
    ngrx, you need to write more code, but each method in your Angular component becomes
    either a command that sends an action or a selector that retrieves the data, and
    each command changes the state of your app.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`EBayComponent` 的代码简洁，不包含任何应用逻辑。使用 ngrx，你需要编写更多的代码，但你的 Angular 组件中的每个方法都变成了发送动作的命令或检索数据的选择器，每个命令都会改变你应用的状态。'
- en: There’s one more step to complete the app-ngrx communication. You need to register
    the store and effects in the app module. Your module, shown in the next listing,
    also includes route configuration, so a user can navigate between the eBay and
    Amazon components.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完成应用-ngrx 通信还有一步。你需要在应用模块中注册存储和效果。下一个列表中显示的模块还包括路由配置，因此用户可以在 eBay 和 Amazon 组件之间导航。
- en: Listing 15.17\. app.module.ts
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.17\. app.module.ts
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Configures the routes**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置路由**'
- en: '***2* Registers the store and links it to the reducer**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注册存储并将其链接到还原器**'
- en: '***3* Registers the effects**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册效果**'
- en: '***4* Enables the use of Redux DevTools**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 启用 Redux DevTools 的使用**'
- en: In the next section, we’ll show you how to monitor state with the Chrome extension
    Redux DevTools and what the `instrument()` method is for.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向你展示如何使用 Chrome 扩展 Redux DevTools 监控状态，以及 `instrument()` 方法的作用。
- en: The app component in the following listing remains the same as in the mediator
    example from [chapter 8](kindle_split_017.xhtml#ch08). [Listing 8.10](kindle_split_017.xhtml#ch08ex10)
    contains annotations, so we won’t describe it here.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的应用程序组件与第 8 章中介器示例中的相同 [chapter 8](kindle_split_017.xhtml#ch08)。[列表 8.10](kindle_split_017.xhtml#ch08ex10)
    包含注释，所以我们在这里不会描述它。
- en: Listing 15.18\. app.component.ts
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.18\. app.component.ts
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To see this app in action, run `npm install` in the project mediator, and then
    run `ng serve -o`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用的运行情况，请在项目中介器中运行 `npm install`，然后运行 `ng serve -o`。
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What else ngrx has to offer**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**ngrx 还能提供什么**'
- en: 'Your mediator app utilizes the packages `@ngrx/store` and `@ngrx/effects`,
    which can address most of your state-management needs. In the hands-on section,
    you’ll also use `@ngrx/router-store`, which offers bindings for connecting and
    monitoring Angular `Router`. There are other packages as well:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你的中介器应用使用了 `@ngrx/store` 和 `@ngrx/effects` 包，这些包可以解决你大部分的状态管理需求。在实战部分，你还将使用
    `@ngrx/router-store`，它提供了连接和监控 Angular `Router` 的绑定。还有其他一些包：
- en: '`@ngrx/entity` is an entity state adapter for managing record collections.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/entity` 是一个用于管理记录集合的实体状态适配器。'
- en: '`@ngrx/schematics` is a scaffolding library that provides blueprints for generating
    ngrx-related code.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/schematics` 是一个脚手架库，它提供了生成 ngrx 相关代码的蓝图。'
- en: Consider exploring these packages on your own. The API of all ngrx packages
    is described at [http://mng.bz/362y](http://mng.bz/362y).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑自行探索这些包。所有 ngrx 包的 API 都在 [http://mng.bz/362y](http://mng.bz/362y) 中描述。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now let’s see how to monitor app state with Redux DevTools.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 Redux DevTools 监控应用状态。
- en: 15.2.4\. Monitoring state with ngrx store DevTools
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.4\. 使用 ngrx store DevTools 监控状态
- en: 'Because you delegate state-management operations to ngrx, you need a tool to
    monitor state changes during runtime. The browser extension Redux DevTools along
    with the `@ngrx/store-devtools` package are used for the instrumentation of the
    app state. First, install `@ngrx/store-devtools`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将状态管理操作委托给 ngrx，你需要一个工具来监控运行时的状态变化。Redux DevTools 浏览器扩展程序以及 `@ngrx/store-devtools`
    包用于应用状态仪表化。首先，安装 `@ngrx/store-devtools`：
- en: '[PRE24]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Second, add the Chrome extension Redux DevTools (there is such an add-on for
    Firefox as well).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，添加 Chrome 扩展程序 Redux DevTools（Firefox 也有这样的插件）。
- en: 'Third, add the instrumentation code to the app module. For example, for instrumentation
    with the default configuration, you can add the following line to the imports
    section of the `@NgModule` decorator:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，将仪表化代码添加到应用模块中。例如，对于默认配置的仪表化，你可以在 `@NgModule` 装饰器的导入部分添加以下行：
- en: '[PRE25]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`StoreDevtoolsModule` must be added after `StoreModule`. If you want to add
    instrumentation minimizing its overhead in the production environment, you can
    use the `environment` variable as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`StoreDevtoolsModule` 必须在 `StoreModule` 之后添加。如果你想在生产环境中最小化其开销以添加仪表化，可以使用以下方式使用
    `environment` 变量：'
- en: '[PRE26]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In production, set the `logOnly` flag to `true`, which doesn’t include tools
    like dispatching and reordering actions, persisting state and actions history
    between page reloads that introduces noticeable performance overhead. You can
    find the complete list of features that `logOnly: true` turns off at [http://mng.bz/cOwC](http://mng.bz/cOwC).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '在生产环境中，将 `logOnly` 标志设置为 `true`，这不会包括诸如派发和重新排序动作、在页面重新加载之间持久化状态和动作历史等工具，这些工具会引入明显的性能开销。你可以在
    [http://mng.bz/cOwC](http://mng.bz/cOwC) 找到 `logOnly: true` 关闭的完整功能列表。'
- en: The `instrument()` method can accept the argument of type `StoreDevtoolsConfig`
    defined in the node_modules/@ngrx/store-devtools/src/config.d.ts file. The next
    code listing shows how to add instrumentation that will allow monitoring of up
    to 25 recent actions and work in log-only mode in the production environment.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`instrument()` 方法可以接受在 node_modules/@ngrx/store-devtools/src/config.d.ts 文件中定义的
    `StoreDevtoolsConfig` 类型的参数。下面的代码示例展示了如何添加仪表化，这将允许监控最多 25 个最近动作，并在生产环境中以仅日志模式工作。'
- en: Listing 15.19\. Adding instrumentation with two configuration options
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.19\. 使用两个配置选项添加仪表化
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Retains the last 25 states in the browser extension**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在浏览器扩展程序中保留最后 25 个状态**'
- en: '***2* Restricts the browser extension to logOnly mode in production**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 限制浏览器扩展程序在生产环境中仅以日志模式运行**'
- en: You can also restrict some of the features of the Chrome Redux extension by
    providing the `features` argument to the `instrument()` method. For more details
    on configuring ngrx instrumentation and supported API, see [http://mng.bz/3AXe](http://mng.bz/3AXe),
    but here we’ll show you some Chrome Redux extension screenshots to illustrate
    some of the features of ngrx store DevTools.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过向 `instrument()` 方法提供 `features` 参数来限制 Chrome Redux 扩展程序的一些功能。有关配置 ngrx
    仪表化和支持的 API 的更多详细信息，请参阅 [http://mng.bz/3AXe](http://mng.bz/3AXe)，但在这里我们将向你展示一些
    Chrome Redux 扩展程序的截图，以说明 ngrx 存储DevTools 的一些功能。
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you run your app, but the Chrome Redux panel shows you a black window with
    the message “No store found,” refresh the page in the browser.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了你的应用，但 Chrome Redux 面板显示一个带有消息“未找到存储”的黑色窗口，请在浏览器中刷新页面。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Launching the app creates the initial state in the store. [Figure 15.7](#ch15fig07)
    shows the screen after you launch the mediator app and enter `aaa` in the input
    field. The sequence of actions starts with two `init` actions that are dispatched
    internally by the packages `@ngrx/store` and `@ngrx/effects`, and you select the
    `@ngrx/store/init` action on the left and the State button at the top right. The
    state properties `searchQuery` and `searchResults` are empty. To see the app state
    after one of the search actions is dispatched, click this action.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用会在存储中创建初始状态。[图 15.7](#ch15fig07) 展示了你启动中介应用并在输入字段中输入 `aaa` 后的屏幕。动作序列从 `@ngrx/store`
    和 `@ngrx/effects` 包内部派发的两个 `init` 动作开始，你选择左侧的 `@ngrx/store/init` 动作和右上角的“状态”按钮。状态属性
    `searchQuery` 和 `searchResults` 都是空的。要查看派发搜索动作后的应用状态，请点击此动作。
- en: Figure 15.7\. The store `init` action is selected.
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.7\. 已选择存储 `init` 动作。
- en: '![](Images/15fig07_alt.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig07_alt.jpg)'
- en: Think of `init` actions as hooks that your app can subscribe to and implement
    some logic upon app launch—for example, you can check whether the user is logged
    in. If your app uses lazy-loaded modules that have their own reducers, you may
    also see the `@ngrx/store/update-reducer` action for each newly loaded module,
    and its reducer will be added to the collection of store reducers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `init` 操作视为应用程序可以订阅并在应用程序启动时实现一些逻辑的钩子——例如，你可以检查用户是否已登录。如果你的应用程序使用具有自己的reducer的懒加载模块，你也可能看到每个新加载模块的
    `@ngrx/store/update-reducer` 操作，并且其reducer将被添加到存储reducer集合中。
- en: '[Figure 15.8](#ch15fig08) shows the screen after clicking the Action button
    at the top right, and shows the type and payload of the latest action:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.8](#ch15fig08) 展示了点击右上角的操作按钮后的屏幕，并显示了最新操作的类型和负载：'
- en: '**1**.  The latest action is `"[Product] search success"`.'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 最新操作是 `"[Product] search success"`。'
- en: '**2**.  The Action tab is selected.'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 已选择操作标签页。'
- en: '**3**.  The action payload is stored in the state property `searchResults`.'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 操作负载存储在状态属性 `searchResults` 中。'
- en: '**4**.  The action type is `"[Product] search success"`.'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 操作类型是 `"[Product] search success"`。'
- en: Figure 15.8\. The Action tab view
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.8\. 操作标签页视图
- en: '![](Images/15fig08_alt.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![Images/15fig08_alt.jpg](Images/15fig08_alt.jpg)'
- en: '|  |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If your state object has many branches, by clicking `(pin)`, you can pin a certain
    slice of the state to the top while browsing actions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的状态对象有多个分支，通过点击“(pin)”，你可以在浏览操作时将某个状态片段固定在顶部。
- en: '|  |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As shown in [figure 15.9](#ch15fig09), after clicking the State button, you
    can see the current values of your state variables `searchQuery` and `searchResults`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如图15.9所示，点击状态按钮后，你可以看到你的状态变量 `searchQuery` 和 `searchResults` 的当前值：
- en: '**1**.  The latest action is `"[Product] search success"`.'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 最新操作是 `"[Product] search success"`。'
- en: '**2**.  The State tab is selected.'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 已选择状态标签页。'
- en: '**3**.  The search criterion is stored in the state property `searchQuery`.'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 搜索条件存储在状态属性 `searchQuery` 中。'
- en: '**4**.  The search results are stored in the state property `searchResults`.'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 搜索结果存储在状态属性 `searchResults` 中。'
- en: Figure 15.9\. The State tab view
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.9\. 状态标签页视图
- en: '![](Images/15fig09_alt.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Images/15fig09_alt.jpg](Images/15fig09_alt.jpg)'
- en: 'If the State tab shows the entire state object, clicking the Diff button shows
    what has changed as the result of the specific action. As shown in [figure 15.10](#ch15fig10),
    if no action is selected, the Diff tab shows the state changes made by the latest
    action:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态标签页显示整个状态对象，点击“差异”按钮将显示特定操作导致的变化。如图15.10所示，如果没有选择操作，差异标签页将显示最新操作所做的状态更改：
- en: '**1**.  The latest action is `"[Product] search success"`.'
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 最新操作是 `"[Product] search success"`。'
- en: '**2**.  The Diff tab is selected.'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 已选择差异标签页。'
- en: '**3**.  The content of the state property `searchResults` is different.'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 状态属性 `searchResults` 的内容不同。'
- en: Figure 15.10\. The Diff tab is selected.
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.10\. 已选择差异标签页。
- en: '![](Images/15fig10_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![Images/15fig10_alt.jpg](Images/15fig10_alt.jpg)'
- en: While debugging an app, developers often need to re-create a certain state of
    the app, and one way to do that is to refresh the page and repeat user actions
    by clicking buttons, selecting list items, and so on. With Redux DevTools, you
    can travel back in time and re-create a certain state without refreshing the page—you
    can jump back to the state after a certain action occurred, or you can skip an
    action.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试应用程序时，开发者经常需要重新创建应用程序的某个状态，一种方法是刷新页面并通过点击按钮、选择列表项等方式重复用户操作。使用Redux DevTools，你可以回到过去并重新创建某个状态，而无需刷新页面——你可以跳转到某个操作发生后的状态，或者跳过某个操作。
- en: 'When you select an action, as shown in [figure 15.11](#ch15fig11), you’ll see
    the Jump and Skip buttons, and then clicking Skip will strike through the selected
    action, and your running app will reflect this change. The Sweep button will be
    displayed at the top, and clicking it removes this action from the list. The Jump
    button jumps you to a specific state of the app for a selected action. Redux DevTools
    will show you the state properties at the moment, and the UI of the app will be
    rerendered accordingly:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个操作，如图15.11所示，你会看到跳转和跳过按钮，然后点击跳过将划掉所选操作，你的运行中的应用程序将反映这一变化。顶部将显示清除按钮，点击它将从列表中删除此操作。跳转按钮将跳转到所选操作的特定应用程序状态。Redux
    DevTools将显示此刻的状态属性，并且应用程序的UI将相应地重新渲染：
- en: '**1**.  The Skip button for this action has been clicked.'
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 已点击此操作的跳过按钮。'
- en: '**2**.  The State tab is selected.'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 已选择状态标签页。'
- en: '**3**.  The search query is `aaabbb`.'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 搜索查询是 `aaabbb`。'
- en: '**4**.  The state property `searchResults` shows no results for the `aaabbb`
    products.'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 状态属性 `searchResults` 对于 `aaabbb` 产品没有显示任何结果。'
- en: '**5**.  The Sweep button was not clicked.'
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 没有点击“清理”按钮。'
- en: Figure 15.11\. The [Product] search-success action is skipped
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.11\. 跳过了 [产品] 搜索成功的动作
- en: '![](Images/15fig11_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig11_alt.jpg)'
- en: We’ve shown you the main features of the ngrx store DevTools, but to understand
    this tool better, we encourage you to spend some time playing with it on your
    own.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向你展示了 ngrx 存储DevTools的主要功能，但要更好地理解这个工具，我们鼓励你花些时间自己尝试操作。
- en: 15.2.5\. Monitoring the router state
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.5\. 监控路由状态
- en: When a user navigates an app, the router renders components, updates the URL,
    and passes parameters or query strings if need be. Behind the scenes, the router
    object represents the current state of the router, and the `@ngrx/router-store`
    package allows you to keep track of the router state in the ngrx store.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航应用时，路由器渲染组件，更新 URL，并在需要时传递参数或查询字符串。在幕后，路由器对象代表路由的当前状态，而 `@ngrx/router-store`
    包允许你在 ngrx 存储中跟踪路由状态。
- en: This package doesn’t change the behavior of Angular `Router`, and you can continue
    using the `Router` API in components, but because the store should be a single
    source of truth, you may want to consider representing the router state there
    as well. At any given time, the ngrx store can give you access to such route properties
    as `url`, `params`, `queryParams`, and many others.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此包不会改变 Angular `Router` 的行为，你可以在组件中继续使用 `Router` API，但由于存储应该是单一的真实来源，你可能还想考虑在那里表示路由状态。在任何给定的时间，ngrx
    存储可以让你访问诸如 `url`、`params`、`queryParams` 等许多其他路由属性。
- en: 'As with any other state properties, you’ll need to add a reducer to the ngrx
    store, and the good news is that you don’t need to implement it in your app because
    the `routerReducer` is defined in `@ngrx/router-store`. To add router state support,
    install this package first:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '与任何其他状态属性一样，你需要在 ngrx 存储中添加一个还原器，好消息是，你不需要在应用中实现它，因为 `routerReducer` 在 `@ngrx/router-store`
    中定义。要添加路由状态支持，首先安装此包：  '
- en: '[PRE28]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After that, add `StoreRouterConnectingModule` to the `NgModule` decorator and
    add `routerReducer` to the list of reducers. `StoreRouterConnectingModule` holds
    the current router state. During navigation, before the route guards are invoked,
    the router store dispatches the action of type `ROUTER_NAVIGATION` that carries
    the `RouterStateSnapshot` object as its payload.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将 `StoreRouterConnectingModule` 添加到 `NgModule` 装饰器中，并将 `routerReducer` 添加到还原器列表中。`StoreRouterConnectingModule`
    保存当前的路由状态。在导航期间，在调用路由守卫之前，路由存储会分派类型为 `ROUTER_NAVIGATION` 的动作，该动作携带 `RouterStateSnapshot`
    对象作为其负载。
- en: 'To get access to the `routerReducer` in your app, you need to perform two steps:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取应用中的 `routerReducer`，你需要执行两个步骤：
- en: '**1**.  Give it a name by assigning a value to the property `StoreRouterConnectingModule.stateKey`.'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 通过将值分配给属性 `StoreRouterConnectingModule.stateKey` 来给它一个名称。'
- en: '**2**.  Use the value from the previous step as the name of the `routerReducer`.'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 使用上一步的值作为 `routerReducer` 的名称。'
- en: The following listing shows how the `StoreRouterConnectingModule` can be added
    to the app module. Here, you use `myRouterReducer` as the name of the `routerReducer`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何将 `StoreRouterConnectingModule` 添加到应用模块中。在这里，你使用 `myRouterReducer`
    作为 `routerReducer` 的名称。
- en: Listing 15.20\. An app module fragment
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.20\. 应用模块片段
- en: '[PRE29]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Adds routerReducer to the StoreModule**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将路由还原器添加到 StoreModule**'
- en: '***2* Stores the name of the reducer in the stateKey property**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在状态键属性中存储还原器的名称**'
- en: Now the state property `myRouterReducer` can be used to access the router state.
    The value of this property will be updated on each router navigation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，状态属性 `myRouterReducer` 可以用来访问路由状态。这个属性的值会在每次路由导航时更新。
- en: The app from [section 15.2.3](#ch15lev2sec5) didn’t include router state monitoring,
    but the source code that comes with this chapter has another app called mediator-router,
    which does monitor router state. Run this app and open the Redux DevTools panel.
    Then navigate to the Amazon route and you’ll see the `ROUTER_NAVIGATION` action
    and the `myRouterReducer` property in the app state object, as shown in [figure
    15.12](#ch15fig12).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.2.3 节](#ch15lev2sec5)中的应用没有包含路由状态监控，但本章附带源代码中还有一个名为 mediator-router 的另一个应用，它确实监控路由状态。运行此应用并打开
    Redux DevTools 面板。然后导航到 Amazon 路由，你将看到应用状态对象中的 `ROUTER_NAVIGATION` 动作和 `myRouterReducer`
    属性，如图 [15.12](#ch15fig12) 所示。'
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: By clicking the down arrow on the bottom toolbar, a QA engineer can save the
    current state of the app and send it to a developer, who can load it into the
    Redux extension (up arrow) to reproduce the scenario reported as a bug.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击底部工具栏的下箭头，QA工程师可以保存当前应用程序的状态并将其发送给开发者，开发者可以将它加载到Redux扩展（上箭头）中，以重现报告为错误的场景。
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 15.12\. The `RouterStateSnapshot` object in Redux DevTools
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.12\. Redux DevTools中的`RouterStateSnapshot`对象
- en: '![](Images/15fig12_alt.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig12_alt.jpg)'
- en: Expand the nodes of `RouterStateSnapshot`; it has lots and lots of properties.
    This object is so big that it may even crash Redux DevTools. Typically, you need
    to monitor just a small number of router state properties, and this is where the
    router state serializer comes in handy.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 展开RouterStateSnapshot的节点；它有大量的属性。这个对象如此之大，甚至可能使Redux DevTools崩溃。通常，你只需要监控少量路由状态属性，这就是路由状态序列化器派上用场的地方。
- en: To implement the serializer, define a type that will include only those properties
    of `RouterStateSnapshot` that you want to monitor. Then write a class that implements
    the `RouterStateSerializer` interface, and `@ngrx/router-store` will start using
    it. This interface requires you to implement the `serialize()` callback, where
    you should destructure the provided `RouterStateSnapshot` to extract only those
    properties you care about.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现序列化器，定义一个类型，它将只包含`RouterStateSnapshot`中你想要监控的属性。然后编写一个实现`RouterStateSerializer`接口的类，`@ngrx/router-store`将开始使用它。此接口要求你实现`serialize()`回调，在那里你应该解构提供的`RouterStateSnapshot`以提取你关心的那些属性。
- en: Some of the properties, like `url`, are available at the top level, and others,
    such as `queryParams`, are sitting under the `RouterStateSnapshot.root` property.
    The mediator-router project implements a router state serializer in the serializer.ts
    file, as shown in the following listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性，如`url`，在顶层可用，而其他属性，例如`queryParams`，位于`RouterStateSnapshot.root`属性之下。中介路由项目在`serializer.ts`文件中实现了路由状态序列化器，如下所示。
- en: Listing 15.21\. serializer.ts
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.21\. serializer.ts
- en: '[PRE30]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Defines the router state properties you want to monitor**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义要监控的路由状态属性**'
- en: '***2* Creates a class that implements RouterStateSerializer**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个实现RouterStateSerializer的类**'
- en: '***3* Uses destructuring to get only the properties you need**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用解构来获取你需要的属性**'
- en: '***4* Returns an object with the properties url and queryParams**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回包含url和queryParams属性的对象**'
- en: Now Redux DevTools will show only the values of `url` and `queryParams`. To
    get the value of the router state object, use the `select()` operator. The next
    listing shows how you do it in the mediator-router project.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Redux DevTools将只显示`url`和`queryParams`的值。要获取路由状态对象的值，使用`select()`运算符。下一个列表显示了在中介路由项目中如何实现它。
- en: Listing 15.22\. app.component.ts
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.22\. app.component.ts
- en: '[PRE31]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Extracts a router state slice**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提取路由状态切片**'
- en: If you want to handle the router state action in your effects class, create
    an effect that handles the actions of type `ROUTER_NAVIGATION`. The following
    code listing from the effects.ts file from the mediator-router project shows how
    to do it in the effect.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的效果类中处理路由状态动作，创建一个处理类型为`ROUTER_NAVIGATION`的动作的效果。以下是从中介路由项目的`effects.ts`文件中的代码片段，展示了如何在效果中实现它。
- en: Listing 15.23\. A fragment of effects.ts
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.23\. effects.ts的一个片段
- en: '[PRE32]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* This effect doesn’t dispatch its own actions.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此效果不派发自己的动作。**'
- en: '***2* Listens to the ROUTER_NAVIGATION action**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 监听ROUTER_NAVIGATION动作**'
- en: In some cases, you may want to arrange navigation inside the effects class.
    For this, shown in the following listing, you can keep using the router API without
    any help from ngrx.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能在效果类内部安排导航。为此，如下所示，你可以继续使用路由API，而不需要ngrx的帮助。
- en: Listing 15.24\. Navigating in effects
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.24\. 在effects中导航
- en: '[PRE33]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Listens to the GOTO_AMAZON action**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听GOTO_AMAZON动作**'
- en: '***2* Navigates to the /amazon route**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导航到/amazon路由**'
- en: This concludes our introduction to ngrx, but you’ll see how you use it in the
    ngAuction app in the hands-on section of this chapter.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对ngrx的介绍，但在本章的动手实践部分，你将看到如何在ngAuction应用程序中使用它。
- en: 15.3\. To ngrx or not to ngrx
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3\. 使用ngrx还是不使用ngrx
- en: Recently, one of our clients explained their needs for storing state. In their
    app, state is represented by a large object with nested arrays, and each array
    stores data rendered as a chart. The app retrieves one of the arrays, performs
    some calculations, and renders a chart. In the future, they plan to add new charts
    and arrays.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我们的一位客户解释了他们存储状态的需求。在他们应用中，状态由一个包含嵌套数组的大型对象表示，每个数组存储作为图表渲染的数据。应用检索其中一个数组，执行一些计算，并渲染图表。未来，他们计划添加新的图表和数组。
- en: The client asked whether using a singleton Angular service with `BehaviorSubject`
    would offer a less scalable solution than ngrx for this use case. He added that
    in ngrx, they could use separate arrays (state slices) with their reducers, which
    could make adding new arrays and charts easier because ngrx automatically creates
    one global state object from individual reducers.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 客户询问使用具有 `BehaviorSubject` 的单例 Angular 服务是否比 ngrx 在此用例中提供更不可扩展的解决方案。他补充说，在 ngrx
    中，他们可以使用具有其 reducer 的单独数组（状态片段），这可以使得添加新的数组和图表更容易，因为 ngrx 会自动从单个 reducer 创建一个全局状态对象。
- en: Let’s see if ngrx would help. First of all, if they needed lots of data to render
    the chart that doesn’t use the data directly, it could make sense to move computations
    to the server to avoid keeping huge objects in memory and calculating numbers
    in the browser. But what if they still wanted to implement all the data crunching
    on the client?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 ngrx 是否能有所帮助。首先，如果他们需要大量数据来渲染不直接使用数据的图表，将计算移动到服务器以避免在内存中保留大型对象并在浏览器中计算数字是有意义的。但如果是他们仍然想在客户端实现所有数据处理的呢？
- en: With the Angular service approach, the object with nested arrays would grow
    and become less maintainable. In the case of separate reducers/arrays, it would
    be easier to add them to the state and reason about the state.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 服务方法时，具有嵌套数组的对象会增长并变得难以维护。在单独的 reducer/数组的情况下，将它们添加到状态中并推理状态会更容易。
- en: But with the ngrx approach, the state object would also grow, and they’d need
    to add more reducers and selectors to handle the growth. With the Angular service
    approach, they could either add more methods for getting the state slices or could
    split the singleton into multiple services—the main one would store the data,
    and separate services (one per chart) would get and process the data from the
    main service.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用 ngrx 方法时，状态对象也会增长，他们需要添加更多的 reducer 和 selector 来处理增长。使用 Angular 服务方法时，他们可以添加更多用于获取状态片段的方法，或者将单例服务拆分为多个服务——主要服务存储数据，而单独的服务（每个图表一个）从主服务获取和处理数据。
- en: Both ngrx and service approaches can do the job and remain maintainable. If
    the app doesn’t use ngrx yet, it wouldn’t make sense to use ngrx just because
    of charts.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ngrx 和服务方法都可以完成工作并保持可维护性。如果应用尚未使用 ngrx，仅仅因为图表而使用 ngrx 是没有意义的。
- en: 15.3.1\. Comparing ngrx with Angular services
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1. 比较ngrx与Angular服务
- en: 'Okay, is there a use case where ngrx offers advantages over the Angular service
    approach? Let compare three main features of state management:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有没有什么用例表明 ngrx 在状态管理方面比 Angular 服务方法有优势？让我们比较一下状态管理的三个主要特性：
- en: 'A single source of truth could mean two things:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一事实来源可能意味着两件事：
- en: There’s only one copy of each set of data. This is easily achievable with an
    Angular service with `BehaviorSubject`.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每组数据只有一个副本。使用 Angular 服务和 `BehaviorSubject` 可以轻松实现这一点。
- en: There’s a single object that keeps all the app data. This is a unique feature
    of the Redux/ngrx approach that enables Redux DevTools. This can be a valuable
    feature for large apps with cross-module interaction and lots of shared data.
    Without a single state object, it would be nearly impossible. DevTools allows
    exporting/importing the entire state of the app if you need to reproduce a bug
    found by a user or a QA engineer. But in the real world, state changes trigger
    side effects and don’t restore the app in exactly the same state.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个对象保存了所有应用数据。这是 Redux/ngrx 方法的一个独特特性，它使得 Redux DevTools 成为可能。这对于具有跨模块交互和大量共享数据的大型应用来说是一个非常有价值的特性。如果没有单一的状态对象，几乎是不可能的。DevTools
    允许导出/导入应用整个状态，如果你需要重现用户或 QA 工程师发现的错误。但在现实世界中，状态变化会触发副作用，并且不会将应用恢复到完全相同的状态。
- en: State can be modified only by a reducer, so you can easily locate and debug
    an issue related to state. But if you use `BehaviorSubject` to keep data in your
    Angular services, you can do this as well. Without `BehaviorSubject`, it would
    be hard to identify all assignments that can modify state, but with `BehaviorSubject`,
    there’s a single place where you can put a breakpoint. Also, by applying the `map`
    operator to `BehaviorSubject`, you can handle all data modifications just like
    in a reducer.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态只能由 reducer 修改，因此你可以轻松地定位和调试与状态相关的问题。但如果你在 Angular 服务中使用 `BehaviorSubject`
    来保存数据，你也能做到这一点。没有 `BehaviorSubject`，很难识别所有可以修改状态的任务，但有了 `BehaviorSubject`，你可以在一个地方设置断点。此外，通过将
    `map` 操作符应用于 `BehaviorSubject`，你可以像在 reducer 中一样处理所有数据修改。
- en: With ngrx and specific selectors, you can produce a derived state that combines
    data from different parts of the store object, plus it can be memoized. You can
    easily do this in an Angular service as well. Define a service that injects other
    services, aggregates their values with `combineLatest` or `withLatestFrom` operators,
    and then emits the “derived” state.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ngrx 和特定的选择器，你可以生成一个派生状态，它结合了存储对象不同部分的数据，并且它可以被缓存。你同样可以在 Angular 服务中轻松做到这一点。定义一个服务，它注入其他服务，使用
    `combineLatest` 或 `withLatestFrom` 操作符聚合它们的值，然后发出“派生”状态。
- en: If you want all these features, it can be easier to start with ngrx because
    ngrx enforces them. Without enforced discipline, your singleton service that started
    with 30 lines of code can quickly turn into an unmaintainable monster with hundreds
    of lines. If you’re not sure that best practices can be enforced in your team,
    go with ngrx, which offers a well-defined structure for your app.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要所有这些功能，从 ngrx 开始可能更容易，因为 ngrx 强制执行这些功能。如果没有强制执行的纪律，你的单例服务可能很快就会从 30 行代码变成一个难以维护的怪物，拥有数百行代码。如果你不确定最佳实践是否可以在你的团队中强制执行，请选择
    ngrx，它为你的应用程序提供了一个定义良好的结构。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Instead of writing the code for creating a store, effects, actions, and so
    on, you can generate them using Angular CLI, but first install the ngrx blueprints
    (a.k.a. schematics). You can read about using `@ngrx/schematics` at [http://mng.bz/7W30](http://mng.bz/7W30).
    If your project was generated by Angular CLI 6 or newer, you can add NGRX artifacts
    to it by using the following commands:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不用编写创建 store、effects、actions 等代码，而是使用 Angular CLI 生成它们，但首先需要安装 ngrx 蓝图（也称为
    schematics）。你可以在 [http://mng.bz/7W30](http://mng.bz/7W30) 了解如何使用 `@ngrx/schematics`。如果你的项目是由
    Angular CLI 6 或更高版本生成的，你可以使用以下命令将 NGRX 元素添加到项目中：
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE34]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 15.3.2\. State mutation problems
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2\. 状态突变问题
- en: These issues do exist, but Angular has all you need to address them. In your
    projects, all Angular components use the change detection strategy `OnPush`. When
    you need to modify a component’s data, create a new instance of an object bound
    to the component’s `@Input`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题确实存在，但 Angular 提供了你所需的一切来解决它们。在你的项目中，所有 Angular 组件都使用 `OnPush` 变更检测策略。当你需要修改组件的数据时，创建一个新的对象实例并将其绑定到组件的
    `@Input`。
- en: There are cases when using the default change detection strategy makes more
    sense. For example, you may need to create a dynamic form, and its content changes
    depending on the values entered in other form controls. Control values are exposed
    as observables (as `valueChanges`), and if your component uses `OnPush`, and all
    other component properties are RxJS `Subject`s, it makes the code overly complex
    to express the logic in terms of RxJS operators.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用默认的变更检测策略更有意义。例如，你可能需要创建一个动态表单，其内容根据其他表单控件中输入的值而变化。控件值作为可观察对象（作为 `valueChanges`）公开，如果你的组件使用
    `OnPush`，并且所有其他组件属性都是 RxJS `Subject`s，那么使用 RxJS 操作符表达逻辑会使代码过于复杂。
- en: The code definitely can be complex, but often it doesn’t have any benefits over
    disabling the `OnPush` strategy and mutating a component’s state directly. Then
    don’t use `OnPush`. On rare occasions, you can even manually trigger change detection
    with `ChangeDetectorRef`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 代码确实可能很复杂，但通常它没有禁用 `OnPush` 策略并直接突变组件状态的好处。那么就别用 `OnPush`。在罕见的情况下，你甚至可以手动使用
    `ChangeDetectorRef` 触发变更检测。
- en: These techniques aren’t a replacement for the immutable ngrx state, and they
    don’t provide the same level of control over your data that ngrx does. But they
    help avoid problems caused by state mutation.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术不能替代不可变的 ngrx 状态，它们也不提供与 ngrx 相同的数据控制级别。但它们有助于避免由状态突变引起的问题。
- en: 15.3.3\. ngrx code is more difficult to read
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.3\. ngrx 代码更难阅读
- en: Actions and reducers introduce indirection and can quickly complicate your code
    if used without care. A new hire would need to spend more time to become productive
    with your app since each component can’t be understood in isolation. You may say
    the same is true for any Angular app that doesn’t use ngrx, but we would disagree
    for two reasons.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 动作和还原器引入了间接性，如果不小心使用，会迅速使你的代码变得复杂。新员工需要花费更多的时间才能使你的应用变得高效，因为每个组件都不能孤立地理解。你可能会说，任何不使用
    ngrx 的 Angular 应用也是如此，但我们对此持不同意见，原因有两个。
- en: First, components and services look pretty much the same in every Angular app,
    but every ngrx project has its own approach for implementing and organizing actions,
    reducers, store selectors, and effects. Actions can be defined as variables, classes,
    interfaces, and enums. They can be directly exposed as ES module members or grouped
    into classes. The same applies to reducers.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，组件和服务在每一个 Angular 应用中看起来几乎一样，但每个 ngrx 项目都有自己的方法来实现和组织动作、还原器、存储选择器和效果。动作可以被定义为变量、类、接口和枚举。它们可以直接作为
    ES 模块成员暴露，或者分组到类中。同样适用于还原器。
- en: Second, supporting actions and reducers requires writing additional code that
    wouldn’t exist in your app otherwise—it’s not just moving the existing app code
    from components to ngrx entities. If your components are already complex, using
    ngrx could make the code difficult to read.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，支持动作和还原器需要编写额外的代码，这些代码在你的应用中原本是不存在的——这不仅仅是将现有应用代码从组件移动到 ngrx 实体。如果你的组件已经很复杂，使用
    ngrx 可能会使代码难以阅读。
- en: 15.3.4\. The learning curve
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.4\. 学习曲线
- en: ngrx considerably steepens the learning curve. You need to learn how the packages
    `@ngrx/store` and `@ngrx/effects` work. You may also want to learn the `@ngrx/entity`
    package that helps normalize relational data. If you have experience working with
    relational databases, you know how easy it is to join data located in related
    tables. Using `@ngrx/entity` eliminates the need to create nested JavaScript objects
    (for example, a customer object with nested orders) and write complex reducers.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ngrx 显著增加了学习曲线。你需要学习 `@ngrx/store` 和 `@ngrx/effects` 包是如何工作的。你可能还想要学习 `@ngrx/entity`
    包，它有助于规范化关系数据。如果你有与关系数据库一起工作的经验，你知道如何轻松地将位于相关表中的数据连接起来。使用 `@ngrx/entity` 可以消除创建嵌套
    JavaScript 对象（例如，具有嵌套订单的客户对象）和编写复杂还原器的需求。
- en: You also need to be comfortable with the RxJS library. It’s not rocket science,
    but if you’re already in the process of learning Angular, TypeScript, and all
    the tooling, it would be wiser to postpone adding libraries that you can live
    without.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要熟悉 RxJS 库。这并不是什么火箭科学，但如果你已经在学习 Angular、TypeScript 和所有工具，那么推迟添加你可以不用的库会更明智。
- en: 15.3.5\. Conclusion
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.5\. 结论
- en: Good libraries are those that allow you to write less code. Currently, ngrx
    requires you to write lots of additional code, but we hope that future versions
    of ngrx will be simpler to implement and understand. Meanwhile, keep an eye on
    a promising state management library called NGXS (see [https://ngxs.gitbooks.io/ngxs](https://ngxs.gitbooks.io/ngxs)),
    which doesn’t require you to write as much code as ngrx and is built on TypeScript
    decorators. Another new project called ngrx-data ([http://mng.bz/h6Nc](http://mng.bz/h6Nc))
    promises to support ngrx/Redux workflows with less coding.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 好的库是那些让你写更少代码的库。目前，ngrx 需要你编写大量的额外代码，但我们希望 ngrx 的未来版本将更容易实现和理解。同时，关注一个有前途的状态管理库
    NGXS（见 [https://ngxs.gitbooks.io/ngxs](https://ngxs.gitbooks.io/ngxs)），它不需要你像
    ngrx 那样编写那么多代码，并且基于 TypeScript 装饰器。另一个名为 ngrx-data ([http://mng.bz/h6Nc](http://mng.bz/h6Nc))
    的新项目承诺以更少的编码支持 ngrx/Redux 的工作流程。
- en: Start with managing state using a singleton injectable service with `BehaviorSubject`.
    This approach may cover all your needs. Watch the video “When ngrx is an overkill”
    by Yakov Fain ([www.youtube.com/watch?v=xLTIDs0CDCM](http://www.youtube.com/watch?v=xLTIDs0CDCM)),
    where he compares two small apps that manage state with and without ngrx. It’s
    never too late to add ngrx to your app, so don’t try to prematurely solve a problem
    you’re not facing yet.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用 `BehaviorSubject` 的单例可注入服务来管理状态开始。这种方法可能满足你的所有需求。观看 Yakov Fain 的视频“当 ngrx
    是过度时”（[www.youtube.com/watch?v=xLTIDs0CDCM](http://www.youtube.com/watch?v=xLTIDs0CDCM)），其中他比较了两个使用和不使用
    ngrx 管理状态的小型应用。给你的应用添加 ngrx 从来不晚，所以不要试图过早地解决你尚未面临的问题。
- en: Now let’s see how ngrx can be used in your ngAuction app.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在你的 ngAuction 应用中使用 ngrx。
- en: '15.4\. Hands-on: Using ngrx in ngAuction'
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4\. 实践：在 ngAuction 中使用 ngrx
- en: 'The ngAuction app that comes with this chapter uses ngrx for state management.
    It’s modularized and has the root module `AppModule` and two feature modules,
    `HomeModule` and `ProductModule`. Since your feature modules are lazy loaded,
    we’ve added to each module the directory store, which in turn has its own subdirectories:
    actions, effects, and reducers, as shown in [figure 15.13](#ch15fig13). Although
    this project has three directories named store, the running app will have a single
    store with merged states from each module.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带的自带 ngAuction 应用使用 ngrx 进行状态管理。它是模块化的，具有根模块 `AppModule` 和两个功能模块，`HomeModule`
    和 `ProductModule`。由于您的功能模块是懒加载的，我们已为每个模块添加了目录存储，该存储又包含其自己的子目录：actions、effects
    和 reducers，如图15.13所示。尽管此项目有三个名为 store 的目录，但运行中的应用将有一个包含来自每个模块合并状态的单一存储。
- en: Figure 15.13\. The state branches in the app and home modules
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.13。应用和 home 模块中的状态分支
- en: '![](Images/15fig13_alt.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig13_alt.jpg)'
- en: Inside of each folder—actions, effects, and reducers—we have separate files
    related to specific slices of state. For example, you can find a separate search.ts
    file that implements a respective piece of the search functionality in each of
    those folders.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件夹中——actions、effects 和 reducers——我们都有与特定状态切片相关的单独文件。例如，您可以在这些文件夹中找到一个单独的
    search.ts 文件，它实现了每个文件夹中的相应搜索功能。
- en: App state can represent not only data (such as the latest search query or results),
    but also the state of the UI (such as the loading indicator is shown or hidden).
    You may also be interested to know the current state of the router and the URL
    displayed by the browser.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 应用状态不仅可以表示数据（例如最新的搜索查询或结果），还可以表示 UI 的状态（例如，加载指示器是否显示或隐藏）。您可能还想知道路由的当前状态和浏览器显示的
    URL。
- en: '[Figure 15.14](#ch15fig14) depicts the combined state of the running ngAuction.
    The names of reducers are shown in bold italic font, and arrows point at the state
    properties handled by each reducer. In particular, the `loading` property of the
    `products` reducer could represent the state of the progress indicator. We’ll
    also add router support using the `router` reducer.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.14](#ch15fig14) 展示了运行中的 ngAuction 的组合状态。以粗体斜体显示的还原器名称，箭头指向每个还原器处理的状态属性。特别是，`products`
    还原器的 `loading` 属性可能代表进度指示器的状态。我们还将使用 `router` 还原器添加路由支持。'
- en: Figure 15.14\. The combined state object of ngAuction
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.14。ngAuction 的组合状态对象
- en: '![](Images/15fig14_alt.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig14_alt.jpg)'
- en: The router reducer is special in that you don’t need to implement it in your
    app because it’s defined in `@ngrx/router-store`, reviewed in the next section.
    Your ngAuction has the `@ngrx/router-store` package as a dependency in package.json.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 路由还原器是特殊的，因为您不需要在您的应用中实现它，因为它在 `@ngrx/router-store` 中定义，将在下一节中介绍。您的 ngAuction
    在 package.json 中将 `@ngrx/router-store` 包作为依赖项。
- en: '[Figure 15.15](#ch15fig15) shows a screenshot from Redux DevTools after ngAuction
    has launched and a user navigates to a specific product page. Note the router
    property there. The app state in [figure 15.15](#ch15fig15) matches the state
    structure shown in [figure 15.14](#ch15fig14):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.15](#ch15fig15) 展示了 ngAuction 启动后用户导航到特定产品页面时的 Redux DevTools 截图。注意那里的路由属性。图15.15中的应用状态与图15.14中所示的状态结构相匹配：'
- en: The State tab is selected.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已选择状态选项卡。
- en: You see a `search` slice of state, a `router` slice of state, a `homePage` slice
    of state, and a `productPage` slice of state.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以看到状态的一个 `search` 切片，一个 `router` 切片，一个 `homePage` 切片和一个 `productPage` 切片。
- en: Figure 15.15\. The ngAuction state in Redux DevTools
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.15。Redux DevTools 中的 ngAuction 状态
- en: '![](Images/15fig15_alt.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig15_alt.jpg)'
- en: To run the ngAuction that comes with this chapter, you’ll need to open two terminal
    windows, one for the client and one for server. Go to the server directory and
    run `npm install` there. Then, compile the code with the `tsc` command and start
    the server with the `node build/main` command. After that, open a separate Terminal
    window in the client directory and run the `npm install` command, followed by
    `ng serve`. We recommend you keep Redux DevTools open to monitor app state changes.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章附带的自带 ngAuction，您需要打开两个终端窗口，一个用于客户端，一个用于服务器。进入服务器目录，并在那里运行 `npm install`。然后，使用
    `tsc` 命令编译代码，并使用 `node build/main` 命令启动服务器。之后，在客户端目录中打开另一个单独的终端窗口，并运行 `npm install`
    命令，然后运行 `ng serve`。我们建议您保持 Redux DevTools 打开以监控应用状态变化。
- en: '|  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To keep the length of this section relatively short, we’ll review just the code
    that implements state management in the home module and give you a brief overview
    of the router state. The state management of the product module is implemented
    in a similar fashion.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本节的长度相对较短，我们将仅回顾实现首页模块状态管理的代码，并给你一个关于路由状态的简要概述。产品模块的状态管理以类似的方式实现。
- en: '|  |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'ngAuction uses four ngrx modules: `StoreModule`, `EffectsModule`, `StoreRouterConnectingModule`,
    and `StoreDevtoolsModule`, and the package for each of these modules is included
    in the dependencies section of package.json. Let’s review the router-related code
    of the app module.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ngAuction使用四个ngrx模块：`StoreModule`、`EffectsModule`、`StoreRouterConnectingModule`和`StoreDevtoolsModule`，并且每个模块的包都包含在package.json的依赖项部分。让我们回顾应用模块中与路由相关的代码。
- en: 15.4.1\. Adding the router state support to app module
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.1\. 将路由状态支持添加到应用模块
- en: When you select a product, the router navigates to the corresponding product
    view, and the URL changes accordingly—for example, http://localhost:4200/products/1\.
    Selecting another product will change the router state, and you can bind these
    types of changes to the app state as well. The next listing shows the code fragments
    from app.module.ts focusing on the code related to router state support.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个产品时，路由会导航到相应的产品视图，URL也会相应地改变——例如，http://localhost:4200/products/1。选择另一个产品将改变路由状态，你还可以将这些类型的更改绑定到应用状态。下一个列表显示了来自app.module.ts的代码片段，重点关注与路由状态支持相关的代码。
- en: Listing 15.25\. app.module.ts
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.25\. app.module.ts
- en: '[PRE35]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Imports the store module and the reducer for the router’s state**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入store模块和路由状态的reducer**'
- en: '***2* Imports the router effects**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入路由效果**'
- en: '***3* Adds the routerReducer to the collection of app reducers**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将routerReducer添加到应用reducer集合**'
- en: '***4* Adds the router state support**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 添加路由状态支持**'
- en: '***5* Names the router state property as router**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将路由状态属性命名为router**'
- en: '***6* RouterEffects listens to router events and dispatches ngrx actions handled
    by routerReducer.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* RouterEffects监听路由事件并派发由routerReducer处理的ngrx动作。**'
- en: '|  |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The next section provides more details about the line that loads reducers, while
    reviewing the code of the home module’s index.ts file.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分提供了更多关于加载reducer的行的详细信息，同时回顾了首页模块的index.ts文件的代码。
- en: '|  |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The name of the router state within the store is defined by the property name
    (for example, `router`) mapped to the router reducer. In your app, you’ll use
    the default `routerReducer` and add it to the collection of app reducers:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在store中，路由状态的名字由映射到路由reducer的属性名（例如，`router`）定义。在你的应用中，你将使用默认的`routerReducer`并将其添加到应用reducer集合中：
- en: '[PRE36]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The value of the `stateKey` property is used to find the router state within
    the store and connect it to Redux DevTools, so that time traveling during debugging
    works. The value assigned to `stateKey` (the `router`, in your case) must match
    the property name used in the map of reducers provided to the `forRoot()` method.
    To access a particular property of the router state, you can use the ngrx `select`
    operator on the object represented by the `router` variable.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`stateKey`属性值的用途是在store中找到路由状态并将其连接到Redux DevTools，以便在调试期间进行时间旅行。分配给`stateKey`（在你的情况下是`router`）的值必须与提供给`forRoot()`方法的reducer映射中使用的属性名匹配。要访问路由状态的特定属性，你可以使用ngrx
    `select`运算符在由`router`变量表示的对象上。'
- en: Accessing the entire router state may crash Redux DevTools, which is why we
    created a custom router state serializer to keep in the store only the state properties
    you need. In the shared/services/router-state-serializer.service.ts file, we’ve
    implemented a serializer that returns an object containing only `url`, `params`,
    and `queryParams`. If we didn’t implement this serializer, the router state shown
    in [figure 15.14](#ch15fig14) would have lots of nested properties.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 访问整个路由状态可能会导致Redux DevTools崩溃，这就是我们创建自定义路由状态序列化器的原因，以保持store中只有你需要的状态属性。在shared/services/router-state-serializer.service.ts文件中，我们实现了一个序列化器，它返回一个只包含`url`、`params`和`queryParams`的对象。如果我们没有实现这个序列化器，[图15.14](#ch15fig14)中显示的路由状态将包含大量的嵌套属性。
- en: 15.4.2\. Managing state in the home module
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.2\. 在首页模块中管理状态
- en: When the home module is lazy loaded, its reducers are registered with the store,
    and its state object is merged with the root state. For this to happen, add the
    lines in the following listing to declare the store, reducer, and effects in the
    home.module.ts file
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当 home 模块被懒加载时，其 reducer 被注册到 store 中，并且其状态对象与根状态合并。为了实现这一点，请在以下列表中添加以下行到 home.module.ts
    文件中声明 store、reducer 和 effects。
- en: Listing 15.26\. A fragment from home.module.ts
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.26\. home.module.ts 的一个片段
- en: '[PRE37]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Registers the reducers for the feature home module**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为功能 home 模块注册 reducer**'
- en: '***2* Registers the effects for the feature home module**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为功能 home 模块注册 effects**'
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tip
- en: The difference between the methods `forFeature()` and `forRoot()` is that the
    latter also sets up the required providers for services from the `StoreModule`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`forFeature()` 和 `forRoot()` 方法之间的区别在于后者还设置了 `StoreModule` 中服务的所需提供者。'
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The home module has reducers in the files store/reducers/products.ts and store/reducers/categories.ts.
    Note that you import reducers not from a specific file, but from the directory
    store, and you can guess that this directory has a file named index.ts that combines
    and reexports reducers from several files. You’ll see the content of index.ts
    later in this section.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: home 模块在 store/reducers/products.ts 和 store/reducers/categories.ts 文件中有 reducer。请注意，您不是从特定文件导入
    reducer，而是从 store 目录导入，并且您可以猜测该目录有一个名为 index.ts 的文件，该文件将多个文件中的 reducer 合并并重新导出。您将在本节稍后看到
    index.ts 的内容。
- en: Actions for products
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 产品动作
- en: In ngAuction, `CategoriesComponent` serves as a container of the home view,
    which renders the category tabs and the product grid on the home view. [Figure
    15.16](#ch15fig16) shows that `"[Products] Load All"` is the first action dispatched
    by the app. Then it dispatches `"[Categories] Load"`. When the data is loaded,
    two more actions are dispatched by the effects:`"[Products] Load All Success"`
    and `"[Categories] Load Success"`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ngAuction 中，`CategoriesComponent` 作为 home 视图的容器，在 home 视图中渲染类别标签和产品网格。[图 15.16](#ch15fig16)
    显示 `"[Products] Load All"` 是应用发出的第一个动作。然后它发出 `"[Categories] Load"`。当数据加载完成后，效果会发出两个额外的动作：`"[Products]
    Load All Success"` 和 `"[Categories] Load Success"`。
- en: Figure 15.16\. Loading products from all categories
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.16\. 从所有类别加载产品
- en: '![](Images/15fig16_alt.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig16_alt.jpg)'
- en: Actions for categories are declared in the home/store/actions/categories.ts
    file, and actions for products in the home/store/actions/products.ts file. We’ll
    review only the content of home/store/actions/products.ts; the categories actions
    are declared in a similar way.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 类别动作在 home/store/actions/categories.ts 文件中声明，产品动作在 home/store/actions/products.ts
    文件中声明。我们只回顾 home/store/actions/products.ts 的内容；类别动作以类似的方式声明。
- en: 'In ngAuction, each file with actions usually consists of three logical sections:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ngAuction 中，每个包含动作的文件通常由三个逻辑部分组成：
- en: The `enum` containing string constants defining the action types. You can read
    about TypeScript enums at [http://mng.bz/sTmp](http://mng.bz/sTmp).
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含定义动作类型的字符串常量的 `enum`。您可以在 [http://mng.bz/sTmp](http://mng.bz/sTmp) 了解 TypeScript
    枚举。
- en: Classes for actions (one class per action) that implement the `Action` interface.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了 `Action` 接口的动作类（每个动作一个类）。
- en: The union type that combines all action classes. You’ll use this type in reducers
    and effects, so the TypeScript compiler can check that the action types are correct,
    such as `ProductsActionTypes.Load`.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合所有动作类的联合类型。您将在 reducer 和 effects 中使用此类型，以便 TypeScript 编译器可以检查动作类型是否正确，例如 `ProductsActionTypes.Load`。
- en: The next listing shows how actions are declared in the home/store/actions/products.ts
    file.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了在 home/store/actions/products.ts 文件中如何声明动作。
- en: Listing 15.27\. home/store/actions/products.ts
  id: totrans-492
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.27\. home/store/actions/products.ts
- en: '[PRE38]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Declares allowed action types as the enum of string constants**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将允许的动作类型声明为字符串常量的枚举**'
- en: '***2* Declares the class for the action**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明动作的类**'
- en: '***3* Declares the action type**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明动作类型**'
- en: '***4* Uses the constructor argument to declare the action payload**'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用构造函数参数声明动作有效载荷**'
- en: '***5* Declares the union type of allowed actions**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 声明允许的动作的联合类型**'
- en: As you see, some of the action classes include only the action type, and some
    include the payload as well.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一些动作类只包含动作类型，而另一些则包含有效载荷。
- en: CategoriesComponent
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CategoriesComponent
- en: The code of the `CategoriesComponent` has changed compared to the [chapter 14](kindle_split_023.xhtml#ch14)
    version. Fragments of the categories.component.ts file related to state management
    are shown in [listing 15.28](#ch15ex28). In the constructor of the `CategoriesComponent`,
    you subscribe to the route parameters. When this component receives the category
    value, it either dispatches the action to load the products of all categories
    or only the selected one.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 与第 14 章 [版本](kindle_split_023.xhtml#ch14) 相比，`CategoriesComponent` 的代码已更改。与状态管理相关的
    categories.component.ts 文件片段显示在 [列表 15.28](#ch15ex28) 中。在 `CategoriesComponent`
    的构造函数中，你订阅了路由参数。当此组件接收到分类值时，它要么分发动作以加载所有分类的产品，要么只加载所选的一个。
- en: Listing 15.28\. Fragments from categories.component.ts
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.28\. categories.component.ts 的片段
- en: '[PRE39]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Imports ngrx selectors**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 ngrx selectors**'
- en: '***2* Imports ngrx actions**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 ngrx actions**'
- en: '***3* Injects the Store object**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入 Store 对象**'
- en: '***4* Subscribes to the categories to be rendered as tabs**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅要渲染为标签的分类**'
- en: '***5* Adds the all element to the array of category names**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将所有元素添加到分类名称数组中**'
- en: '***6* Loads the selected or all categories**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 加载所选或所有分类**'
- en: '***7* Dispatches the action to load categories**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 分发动作以加载分类**'
- en: '***8* Dispatches the action to load all products**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 分发动作以加载所有产品**'
- en: '***9* Dispatches the action to load products by category**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 分发动作以按分类加载产品**'
- en: The reducer for products
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 产品还原器
- en: 'The home module has two reducers: one for products and one for categories.
    The reducers and selectors for products are shown in the following listing.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 主模块有两个还原器：一个用于产品，一个用于分类。以下列表显示了产品和分类的还原器和选择器。
- en: Listing 15.29\. home/store/reducers/products.ts
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.29\. home/store/reducers/products.ts
- en: '[PRE40]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Declares the structure of the products state**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明产品状态的结构**'
- en: '***2* The initial state has no products, and the loading flag is false.**'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始状态没有产品，加载标志为假。**'
- en: '***3* Handles the Load action**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理 Load 动作**'
- en: '***4* Updates the loading flag because the loading begins**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更新加载标志，因为加载开始**'
- en: '***5* Handles the LoadSuccess action**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 处理 LoadSuccess 动作**'
- en: '***6* The products are loaded—updates the state with data.**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 加载产品 - 使用数据更新状态。**'
- en: '***7* Handles the LoadFailure action**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 处理 LoadFailure 动作**'
- en: '***8* Removes products data, if any**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果有的话，删除产品数据**'
- en: '***9* Updates the error message**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 更新错误信息**'
- en: '***10* The accessors returning state properties**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 返回状态属性的访问器**'
- en: 'The state object for products has three properties: the array with products,
    the flag to control the loading indicator, and the text of the loading error,
    if any. When the reducer receives the action of type `Load`, it creates a new
    state object with an updated `loading` property that can be used by a component
    for showing a progress indicator.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 产品状态对象有三个属性：包含产品的数组、控制加载指示器的标志，以及如果有任何错误信息的文本。当还原器接收到类型为 `Load` 的动作时，它创建一个新的状态对象，并更新
    `loading` 属性，该属性可以被组件用于显示进度指示器。
- en: If the `LoadSuccess` action has been dispatched, it indicates that the products
    were retrieved successfully. The reducer extracts them from the action’s `payload`
    property and updates the state’s `data` and `loading` properties. The `LoadFailure`
    action indicates that the products couldn’t be retrieved, and the reducer removes
    the data (if any) from the state object, updates the error message, and turns
    off the `loading` flag.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经分发了 `LoadSuccess` 动作，则表示产品已成功检索。还原器从动作的 `payload` 属性中提取它们，并更新状态对象的 `data`
    和 `loading` 属性。`LoadFailure` 动作表示产品无法检索，还原器从状态对象中删除数据（如果有），更新错误信息，并关闭 `loading`
    标志。
- en: At the end of the reducer script for products, you see three lines with the
    functions that know how to access the data in the products state object. You define
    these functions here to keep them where the `State` interface is declared. These
    accessors are used to create selectors defined in index.ts.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品还原器脚本的末尾，你可以看到三条包含如何访问产品状态对象中数据的函数。你在这里定义这些函数，以保持它们与 `State` 接口声明在一起。这些访问器用于创建在
    index.ts 中定义的选择器。
- en: '|  |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The products reducer has no code that makes requests for data. Remember, the
    code communicating with external store parties is placed in the effects.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 产品还原器没有代码用于请求数据。记住，与外部存储方通信的代码放在了效果中。
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The role of index.ts in home reducers
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.ts 在主页还原器中的作用
- en: In general, the files named index.ts are used for reexporting multiple members
    declared in separate files. This way, if another script needs such a member, you
    import this member from a directory without the need to know the full path to
    a specific file. When reexporting members, you can give them new names and combine
    them into new types.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，名为 index.ts 的文件用于重新导出在单独文件中声明的多个成员。这样，如果另一个脚本需要这样的成员，你可以从这个目录中导入这个成员，而不需要知道特定文件的完整路径。在重新导出成员时，你可以给他们新的名称并将它们组合成新的类型。
- en: The home/store/reducers/index.ts file has the line `import * as fromProducts
    from './products';`, and to access exported members from the products.ts file,
    you can use the alias `fromProducts` as a reference—for example, `fromProducts.State`
    or `fromProducts.getData()`. With this in mind, let’s review the code of the home/store/reducers/index.ts
    file in the following listing.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: home/store/reducers/index.ts 文件中有 `import * as fromProducts from './products';`
    这一行，要访问从 products.ts 文件导出的成员，你可以使用别名 `fromProducts` 作为引用——例如，`fromProducts.State`
    或 `fromProducts.getData()`。考虑到这一点，让我们回顾以下列表中 home/store/reducers/index.ts 文件的代码。
- en: Listing 15.30\. home/store/reducers/index.ts
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.30\. home/store/reducers/index.ts
- en: '[PRE41]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Imports various exported members and gives them alias names**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入各种导出成员并给它们起别名**'
- en: '***2* Combines states from categories and products**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 结合类别和产品的状态**'
- en: '***3* Declares the State type by extending it from the root State**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过从根 State 扩展来声明 State 类型**'
- en: '***4* Declares a feature named homePage to be used with StoreModule or createFeatureSelector()**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明一个名为 homePage 的功能，用于与 StoreModule 或 createFeatureSelector() 一起使用**'
- en: '***5* Combines the reducers from categories and products**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将类别和产品的 reducers 结合起来**'
- en: This script starts with creating descriptive alias names (for example, `fromRoot`),
    so it’s easier to read the code knowing where a particular member is coming from.
    Then you declare a `HomeState` interface combining all the properties declared
    in the `State` interfaces in the reducers for both products and categories.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本从创建描述性别名名称（例如，`fromRoot`）开始，这样在知道特定成员来自哪里的情况下阅读代码就更容易了。然后你声明一个 `HomeState`
    接口，它结合了在产品类别和类别的 reducer 中声明的所有 `State` 接口的属性。
- en: The app store includes one state object that can be a complex object containing
    multiple branches. Each of these branches is created by a module reducer. When
    an action is triggered on the store, it goes through each registered reducer and
    finds the ones that have to handle this action. The reducer creates a new state
    and updates the corresponding branch of the global app state.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序商店包含一个状态对象，它可能是一个包含多个分支的复杂对象。每个分支都是由模块 reducer 创建的。当在商店上触发动作时，它会通过每个已注册的
    reducer，找到必须处理这个动作的 reducer。reducer 创建一个新的状态并更新全局应用程序状态的相应分支。
- en: Here, you create a representation of the home module branch by declaring the
    `State` type that extends the `State` root and adding a new `homePage` property
    to it. You used this property in `createFeatureSelector()` and in [listing 15.26](#ch15ex26)
    for registering the state object for the module home. When the combined app store
    is being formed, ngrx adds the `homePage` object to it.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你通过声明扩展 `State` 根并添加一个新的 `homePage` 属性来创建家模块分支的表示。你在 `createFeatureSelector()`
    和 [列表 15.26](#ch15ex26) 中使用了这个属性来注册模块家的状态对象。当组合应用程序商店时，ngrx 将 `homePage` 对象添加到其中。
- en: 'The exported `reducers` member combines the reducers for products and categories.
    Now take another look at the app module in [listing 15.25](#ch15ex25) which has
    the following line:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的 `reducers` 成员结合了产品和类别的 reducer。现在再次查看 [列表 15.25](#ch15ex25) 中的应用程序模块，它有以下一行：
- en: '[PRE42]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Initially, the store finds and invokes each module reducer, which returns the
    corresponding state object. This is how the combined app state is created. The
    following code fragment from index.ts assigns the names `categories` and `products`
    to the respective slices of state:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，商店找到并调用每个模块 reducer，它返回相应的状态对象。这就是组合应用程序状态是如何创建的。以下来自 index.ts 的代码片段将 `categories`
    和 `products` 的名称分配给状态的不同切片：
- en: '[PRE43]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At the end of the script, you declare and export all the selectors that can
    be used for retrieving slices of the home module state. Note that you use the
    state accessor functions declared in the respective reducer files.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本末尾，你声明并导出所有可以用于检索家模块状态切片的选择器。请注意，你使用在各自的 reducer 文件中声明的状态访问器函数。
- en: Effects for products
  id: totrans-552
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 产品效果
- en: 'In the home module, effects are located in the files home/store/effects/categories.ts
    and home/store/effects/products.ts, and in the following listing, we review the
    code of the latter. The `ProductsEffects` class declares three effects: `loadProducts$`,
    `loadByCategory$`, and `searchProducts$`.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在主模块中，效果位于文件 home/store/effects/categories.ts 和 home/store/effects/products.ts
    中，在下面的列表中，我们回顾了后者的代码。`ProductsEffects` 类声明了三个效果：`loadProducts$`、`loadByCategory$`
    和 `searchProducts$`。
- en: Listing 15.31\. home/store/effects/products.ts
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.31\. home/store/effects/products.ts
- en: '[PRE44]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Processes only Load actions**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅处理加载操作**'
- en: '***2* Tries to load all products**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 尝试加载所有产品**'
- en: '***3* Dispatches either LoadProductsSuccess or LoadProductsFailure**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 分发 LoadProductsSuccess 或 LoadProductsFailure**'
- en: '***4* Processes only LoadProductsByCategory actions**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 仅处理按类别加载产品操作**'
- en: '***5* Extracts the category from the payload**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从有效载荷中提取类别**'
- en: '***6* Tries to load products by provided category**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 尝试按提供的类别加载产品**'
- en: '***7* Dispatches either LoadProductsSuccess or LoadProductsFailure**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 分发 LoadProductsSuccess 或 LoadProductsFailure**'
- en: '***8* Processes only Search actions**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 仅处理搜索操作**'
- en: '***9* The function to dispatch either LoadProductsSuccess or LoadProductsFailure**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 分发 LoadProductsSuccess 或 LoadProductsFailure 的函数**'
- en: 'Note the use of the `<LoadProductsByCategory>` type annotation in the `ofType`
    operator. This is one way of declaring the type of the action payload. Declaring
    the type explicitly (as in `map((action: SearchProducts)`) is another way to do
    this.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '注意 `<LoadProductsByCategory>` 类型注解在 `ofType` 操作符中的使用。这是声明动作有效载荷类型的一种方法。显式声明类型（如
    `map((action: SearchProducts)`) 是另一种实现方式。'
- en: '[Figure 15.17](#ch15fig17) shows the state after the action of type `LoadSuccess`
    is dispatched:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15.17](#ch15fig17) 展示了分发类型为 `LoadSuccess` 的动作后的状态：'
- en: '**1**.  The search state is empty.'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  搜索状态为空。'
- en: '**2**.  The router state shows the URL and parameters.'
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  路由状态显示 URL 和参数。'
- en: '**3**.  The categories state will be populated after the load success for categories
    is dispatched.'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  在分发加载成功后，类别状态将被填充。'
- en: '**4**.  The state of products has data retrieved from the server.'
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  产品状态包含从服务器检索到的数据。'
- en: '**5**.  The `loading` flag is `false`.'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  `loading` 标志为 `false`。'
- en: '**6**.  There are no errors.'
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  没有错误。'
- en: Figure 15.17\. The state after the `LoadSuccess` action
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.17\. 分发 `LoadSuccess` 动作后的状态
- en: '![](Images/15fig17_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/15fig17_alt.jpg)'
- en: As usual, the actions dispatched by effects will be handled by the reducer,
    which will update the state with the data or error message.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，效果分发的动作将由 reducer 处理，reducer 将使用数据或错误信息更新状态。
- en: 15.4.3\. Unit-testing ngrx reducers
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.3\. 单元测试 ngrx reducer
- en: Unit-testing state-related functionality is quite simple because only the reducer
    can change app state. Remember, a reducer is a pure function, which always returns
    the same output if the provided arguments are the same.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试与状态相关的功能相当简单，因为只有 reducer 可以更改应用状态。记住，reducer 是一个纯函数，如果提供的参数相同，它总是返回相同的输出。
- en: Because every action is represented by a class, you just need to instantiate
    the action object and invoke the corresponding reducer, providing the state and
    action objects to the reducer. After that, you assert that the state property
    under test has the expected value. For example, the home module has a reducer
    for products that defines the state object in the following listing.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个动作都由一个类表示，所以你只需要实例化动作对象并调用相应的 reducer，向 reducer 提供状态和动作对象。之后，你断言测试下的状态属性具有预期的值。例如，主模块有一个用于产品的
    reducer，如下所示定义状态对象。
- en: Listing 15.32\. The products slice in the home module state
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.32\. 主模块状态中的产品切片
- en: '[PRE45]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Current products are stored here.**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当前产品存储于此。**'
- en: '***2* If this flag is true, the UI should show a progress indicator.**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果此标志为真，UI 应显示进度指示器。**'
- en: '***3* If loading fails, the error message is stored here.**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果加载失败，错误信息将存储于此。**'
- en: Let’s review the code of the home/store/reducers/products.spec.ts file, shown
    in the following listing, which uses this state object and asserts that the `loading`
    flag is properly handled by the actions `LoadProducts` and `LoadProductsSuccess`.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 home/store/reducers/products.spec.ts 文件的代码，如下所示列表，它使用此状态对象并断言 `loading`
    标志被 `LoadProducts` 和 `LoadProductsSuccess` 动作正确处理。
- en: Listing 15.33\. home/store/reducers/products.spec.ts
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.33\. home/store/reducers/products.spec.ts
- en: '[PRE46]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Instantiates the LoadProducts action**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化 LoadProducts 动作**'
- en: '***2* Instantiates the LoadProducts action**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实例化 LoadProducts 操作**'
- en: '***3* Invokes the reducer with the initial state**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用初始状态调用还原器**'
- en: '***4* Asserts that the initial value of loading is false**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 断言加载的初始值为假**'
- en: '***5* Invokes the reducer providing the current state and Load action**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 提供当前状态和 Load 动作调用还原器**'
- en: '***6* Asserts that the loading flag is true**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言加载标志为真**'
- en: '***7* Invokes the reducer providing the current state and LoadSuccess action**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 提供当前状态和 LoadSuccess 动作调用还原器**'
- en: '***8* Asserts that the loading flag is false**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 断言加载标志为假**'
- en: When you invoke the reducer with the initial state, you provide an empty object
    and cast it to the type `any`, so regardless of the provided action, the reducer
    must return a valid state. Check the code of the reducer and note the `default`
    case in the `switch` statement there. Run the `ng test` command, and Karma will
    report that it executed successfully.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用初始状态调用还原器时，你提供一个空对象并将其转换为 `any` 类型，因此无论提供的动作如何，还原器都必须返回一个有效的状态。检查还原器的代码，并注意
    `switch` 语句中的 `default` 情况。运行 `ng test` 命令，Karma 将报告它已成功执行。
- en: The [listing 15.33](#ch15ex33) spec tests whether the reducer properly handles
    the `loading` property in the state object, without worrying about the action
    payload. But if you write a test for an action that has a payload, create a stub
    object with hardcoded data to simulate the payload and invoke the corresponding
    reducer.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15.33](#ch15ex33) 规范测试是否正确处理了状态对象中的 `loading` 属性，而不必担心动作负载。但如果你为具有负载的动作编写测试，创建一个包含硬编码数据的存根对象来模拟负载，并调用相应的还原器。'
- en: This concludes our review of the ngrx code added to the home module of ngAuction.
    We encourage you to complete the code review of the product module on your own;
    its ngrx-related code is similar.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对添加到 ngAuction 主模块的 ngrx 代码的审查结束。我们鼓励您自己完成产品模块的代码审查；其与 ngrx 相关的代码类似。
- en: Summary
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The app state should be immutable.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用状态应该是不可变的。
- en: The app logic can be removed from components and placed in effects and services.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用逻辑可以从组件中移除，并放置在效果和服务中。
- en: A component’s methods should only send commands (actions) and subscribe to data
    for further rendering.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的方法应该只发送命令（动作）并订阅数据以进行进一步渲染。
- en: Although the ngrx learning curve is steep, using ngrx may result in better code
    organization, which is especially important in large apps.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然ngrx的学习曲线很陡峭，但使用ngrx可能会导致更好的代码组织，这在大型应用中尤为重要。
- en: Angular 6, 7, and beyond
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular 6, 7 及更高版本
- en: The authors started working on the first edition of this book when Angular was
    in its early alpha versions. Every new Alpha, Beta, and Release Candidate was
    full of breaking changes. Writing the second edition was easier because Angular
    became a mature and feature-complete framework. New major releases come twice
    a year, and switching from one release to another isn’t a difficult task. Every
    new release is tested against roughly 600 Angular apps used internally at Google
    to ensure backward compatibility.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 作者在 Angular 处于早期 alpha 版本时开始编写这本书的第一版。每个新的 Alpha、Beta 和 Release Candidate 都充满了破坏性变更。编写第二版更容易，因为
    Angular 成为一个成熟且功能完整的框架。新的大版本每半年发布一次，从一个版本切换到另一个版本并不困难。每个新版本都会与 Google 内部使用的约 600
    个 Angular 应用进行测试，以确保向后兼容性。
- en: 'We’d like to highlight some of the new features introduced in Angular 6 or
    planned for future releases:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想强调 Angular 6 或未来版本计划引入的一些新功能：
- en: '***Angular Elements*—** Angular is a great choice for developing single-page
    applications, but creating a widget that can be added to an existing web page
    isn’t a simple task. The Angular Elements package will allow you to create a self-bootstrapping
    Angular component that’s hosted by a custom web element (see [www.w3.org/TR/custom-elements/](http://www.w3.org/TR/custom-elements/))
    that can be used in any HTML page. Simply put, you can define new DOM elements
    and register them with the browser. At the time of writing, all major browsers
    except Internet Explorer natively support custom elements; for IE, you should
    use polyfills. Say there’s an existing web app built using JavaScript and jQuery.
    The developers of this app will be able to use Angular components (packaged as
    custom elements) in the pages of such an app. For example, if you build a price-quoter
    component, Angular Elements will generate a script that can be added to an HTML
    page, and your component can be used on an HTML page. Here’s an example:'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Angular Elements*—** Angular 是开发单页应用程序的一个很好的选择，但创建一个可以添加到现有网页的控件并不是一个简单的任务。Angular
    Elements 包允许您创建一个自启动的 Angular 组件，该组件由自定义网络元素托管（见 [www.w3.org/TR/custom-elements/](http://www.w3.org/TR/custom-elements/)），可以在任何
    HTML 页面上使用。简单来说，您可以定义新的 DOM 元素并将它们注册到浏览器中。在撰写本文时，除 Internet Explorer 外的所有主流浏览器都原生支持自定义元素；对于
    IE，您应使用 polyfills。假设有一个使用 JavaScript 和 jQuery 构建的现有网络应用程序。该应用程序的开发者将能够在该应用程序的页面上使用
    Angular 组件（打包为自定义元素）。例如，如果您构建了一个报价组件，Angular Elements 将生成一个可以添加到 HTML 页面的脚本，并且您的组件可以在
    HTML 页面上使用。以下是一个示例：'
- en: '[PRE47]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can guess, the `stockSymbol` is an `@Input` parameter of the Angular
    price-quoter component. And if this component emits custom events via its `@Output`
    properties, your web page can listen to them using the standard browser API `addEventListener()`.
    In our opinion, this killer feature will open many enterprise doors to the Angular
    framework. Angular Elements will be officially released in Angular 7.
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所猜，`stockSymbol` 是 Angular 报价组件的 `@Input` 参数。如果该组件通过其 `@Output` 属性发出自定义事件，则您的网页可以使用标准浏览器
    API `addEventListener()` 来监听它们。据我们看来，这个杀手级特性将为 Angular 框架打开许多企业之门。Angular Elements
    将在 Angular 7 中正式发布。
- en: '***Ivy renderer*—** This is the codename of a new renderer that will make the
    size of an app smaller and the compilation faster. The size of the Hello World
    app is only 7 KB minified and 3 KB gzipped. This renderer will eliminate unused
    code while building bundles, as opposed to optimizing bundles, as is currently
    done. The Ivy renderer will be introduced in Angular 8.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Ivy 渲染器*—** 这是一款新渲染器的代号，它可以使应用程序的体积更小，编译速度更快。Hello World 应用程序的大小仅为7 KB（压缩后）和3
    KB（gzip压缩后）。在构建包的过程中，Ivy 渲染器将消除未使用的代码，这与目前优化包的方式不同。Ivy 渲染器将在 Angular 8 中引入。'
- en: '***Bazel and Closure Compiler*—** Bazel is a fast build system used for nearly
    all software built at Google, including their 300+ apps written in Angular. Bazel
    makes it easier to publish Angular code that can be distributed as npm packages.
    The Closure Compiler is the bundling optimizer used to create JavaScript artifacts
    for nearly all Google web applications. The Closure Compiler consistently generates
    smaller bundles and does a better job of dead code elimination compared to Webpack
    and Rollup bundlers. By default, the Angular CLI project uses Webpack 4, which
    produces smaller bundles compared to its older versions.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Bazel 和 Closure Compiler*—** Bazel 是一个快速构建系统，用于构建谷歌几乎所有软件，包括他们用 Angular
    编写的300多个应用程序。Bazel 使发布可以作为 npm 包分发的 Angular 代码变得更加容易。Closure Compiler 是用于创建几乎所有谷歌网络应用程序的
    JavaScript 艺术品的打包优化器。与 Webpack 和 Rollup 打包器相比，Closure Compiler 生成更小的包，并且在死代码消除方面做得更好。默认情况下，Angular
    CLI 项目使用 Webpack 4，与旧版本相比，它产生的包更小。'
- en: '***Component Dev Kit (CDK)*—** This package is already used by the Angular
    Material library, which offers 30+ UI components. Angular 6 introduces the tree
    component, which is good for displaying hierarchical data. The new flexible overlay
    component automatically resizes and positions itself based on viewport size. The
    badge component can show notification markers. What if you don’t want to use Angular
    Material but want to build your own library of UI components and control page
    layouts? You can do that with CDK. CDK contains multiple subpackages, including
    overlay, layout, scrolling, table, and tree. For example, the CDK table deals
    with rows and columns but doesn’t have its own styling. Although Angular Material
    adds styles to the CDK table, you can create your own according to your company
    guidelines. CDK supports responsive web design layout, eliminating the need for
    using libraries like Flex Layout, or learning CSS Grid. Angular 7 adds virtual
    scrolling for large lists of elements by rendering only the items that fit onscreen.
    Angular 7 also adds drag-and-drop support.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件开发工具包 (CDK)*—** 此包已被 Angular Material 库使用，该库提供了 30+ 个 UI 组件。Angular 6
    引入了树形组件，适用于显示层次数据。新的灵活覆盖组件会根据视口大小自动调整大小和位置。徽章组件可以显示通知标记。如果你不想使用 Angular Material，但想构建自己的
    UI 组件库并控制页面布局，你可以使用 CDK。CDK 包含多个子包，包括覆盖、布局、滚动、表格和树。例如，CDK 表格处理行和列，但没有自己的样式。尽管
    Angular Material 为 CDK 表格添加了样式，但你可以根据公司指南创建自己的样式。CDK 支持响应式网页设计布局，消除了使用 Flex Layout
    或学习 CSS Grid 的需要。Angular 7 通过仅渲染适合屏幕的项来为大量元素列表添加虚拟滚动。Angular 7 还增加了拖放支持。'
- en: '***Angular CLI*—** The .angular-cli.json file is renamed to angular.json, and
    its structure changes. The `ng update @angular/cli` command automatically converts
    existing .angular-cli.json into angular.json. The `ng update @angular/core` command
    updates the dependencies in your project’s package.json to the latest version
    of Angular. If you need to upgrade your existing project to Angular 6, read Yakov
    Fain’s blog, “How I migrated a dozen projects to Angular 6 and then 7,” at [http://mng.bz/qZwC](http://mng.bz/qZwC).
    Upgrades from Angular 6 to 7 should not require code changes. The `ng new library
    <name>` command generates a project for creating a library instead of an app.
    This command will generate a library project with a build system and test infrastructure.
    The `ng add` command can add a package to your project, but in addition to what
    `npm install` does, it can also modify certain files in your project so you don’t
    need to do that manually. For example, the following command will install Angular
    Material, add a prebuilt theme to angular.json, add Material design icons to index.html,
    and add the `BrowserAnimationsModule` to the `@NgModule()` decorator:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Angular CLI*—** .angular-cli.json 文件已重命名为 angular.json，其结构也发生了变化。`ng update
    @angular/cli` 命令自动将现有的 .angular-cli.json 转换为 angular.json。`ng update @angular/core`
    命令更新项目中 package.json 的依赖项到 Angular 的最新版本。如果你需要将现有项目升级到 Angular 6，请阅读 Yakov Fain
    的博客，“我如何将十几个项目迁移到 Angular 6 然后到 7”，在 [http://mng.bz/qZwC](http://mng.bz/qZwC)。从
    Angular 6 升级到 7 不应需要代码更改。`ng new library <name>` 命令生成一个用于创建库而不是应用程序的项目。此命令将生成一个带有构建系统和测试基础设施的库项目。`ng
    add` 命令可以将包添加到你的项目中，除了 `npm install` 所做的之外，它还可以修改项目中的一些文件，这样你就不需要手动操作。例如，以下命令将安装
    Angular Material，将预构建主题添加到 angular.json，将 Material 设计图标添加到 index.html，并将 `BrowserAnimationsModule`
    添加到 `@NgModule()` 装饰器中：'
- en: '[PRE48]'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Schematics and* `ng update`—Angular CLI generates artifacts using a technology
    called *Schematics*, which uses code templates to generate various artifacts for
    your project. If you decide to create your own templates and have Angular CLI
    use them, Schematics will help you with this. The `ng update` command automatically
    updates your project dependencies and makes automated version fixes. With Schematics,
    you’ll be able to create your own code transformations, similar to `ng update`.
    But you’ll find some of the new prebuilt templates that come with Angular 6\.
    For example, to generate all files for a `root-nav` component that already include
    the code of a sample Angular Material navigation bar, you can run the following
    command:'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*原理图和* `ng update`——Angular CLI使用名为* Schematics* 的技术生成工件，该技术使用代码模板为您的项目生成各种工件。如果您决定创建自己的模板并让Angular
    CLI使用它们，Schematics将帮助您完成这项工作。`ng update` 命令会自动更新您的项目依赖项并执行自动版本修复。使用Schematics，您将能够创建自己的代码转换，类似于`ng
    update`。但您会发现Angular 6附带的一些新预构建模板。例如，要为已经包含示例Angular Material导航栏代码的`root-nav`组件生成所有文件，您可以运行以下命令：'
- en: '[PRE49]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We’re looking forward to all the new features that will make Angular even better!
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期待所有将使Angular变得更好的新功能！
- en: With that, we’d like to thank you for reading our book. We hope you liked it
    and will leave positive feedback so that Manning will ask us to write a new edition
    in the future.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想感谢您阅读我们的书籍。我们希望您喜欢它，并留下积极的反馈，这样Manning就会在将来邀请我们编写新版本。
