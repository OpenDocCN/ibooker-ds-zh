- en: 12 Resampling statistics and bootstrapping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 重抽样统计和自助法
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding the logic of permutation tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解排列检验的逻辑
- en: Applying permutation tests to linear models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将排列检验应用于线性模型
- en: Using bootstrapping to obtain confidence intervals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自助法获得置信区间
- en: In chapters 7, 8, and 9, we reviewed statistical methods that test hypotheses
    and estimate confidence intervals for population parameters by assuming that the
    observed data is sampled from a normal distribution or some other well-known theoretical
    distribution. But in many cases, this assumption is unwarranted. Statistical approaches
    based on randomization and resampling can be used in cases where the data is sampled
    from unknown or mixed distributions, where sample sizes are small, where outliers
    are a problem, or where devising an appropriate test based on a theoretical distribution
    is too complex and mathematically intractable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章、第8章和第9章中，我们回顾了假设观察数据来自正态分布或某些其他已知理论分布的统计方法，这些方法用于检验假设并估计总体参数的置信区间。但在许多情况下，这种假设是不合理的。基于随机化和重抽样的统计方法可以用于数据来自未知或混合分布的情况，样本量较小，异常值是一个问题，或者基于理论分布设计适当的测试过于复杂且数学上难以处理。
- en: 'In this chapter, we’ll explore two broad statistical approaches that use randomization:
    permutation tests and bootstrapping. Historically, these methods were only available
    to experienced programmers and expert statisticians. Contributed packages in R
    now make them readily available to a wider group of data analysts.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种使用随机化的广泛统计方法：排列检验和自助法。从历史上看，这些方法仅对经验丰富的程序员和专家统计学家可用。R中的贡献包现在使它们对更广泛的数据分析人员变得容易获得。
- en: We’ll also revisit problems that were initially analyzed using traditional methods
    (for example, t-tests, chi-square tests, ANOVA, and regression) and see how they
    can be approached using these robust, computer-intensive methods. To get the most
    out of section 12.2, be sure to read chapter 7 first. Chapters 8 and 9 serve as
    prerequisites for section 12.3.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将重新审视最初使用传统方法（例如，t检验、卡方检验、方差分析和回归）分析的问题，并看看它们如何使用这些稳健、计算密集型的方法来处理。要充分利用12.2节，请务必先阅读第7章。第8章和第9章作为12.3节的前提。
- en: 12.1 Permutation tests
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 排列检验
- en: '*Permutation* tests, also called *randomization* or *re-randomization* tests,
    have been around for decades, but it took the advent of high-speed computers to
    make them practically available. To understand the logic of a permutation test,
    consider a hypothetical problem: 10 subjects have been randomly assigned to one
    of two treatment conditions (A or B), and an outcome variable (score) has been
    recorded. The results of the experiment are presented in table 12.1.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*排列*检验，也称为*随机化*或*重新随机化*检验，已经存在了几十年，但直到高速计算机的出现才使其变得实用。要理解排列检验的逻辑，考虑一个假设问题：10名受试者被随机分配到两种治疗条件之一（A或B），并记录了一个结果变量（得分）。实验结果在表12.1中呈现。'
- en: Table 12.1 Hypothetical two-group problem
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 假设的双组问题
- en: '| Treatment A | Treatment B |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 治疗A | 治疗B |'
- en: '| 40 | 57 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 40 | 57 |'
- en: '| 57 | 64 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 57 | 64 |'
- en: '| 45 | 55 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 45 | 55 |'
- en: '| 55 | 62 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 55 | 62 |'
- en: '| 58 | 65 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 58 | 65 |'
- en: Figure 12.1 also displays the data. Is there enough evidence to conclude that
    the impact of the treatments differs?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1也显示了数据。是否有足够的证据得出结论，治疗的影响不同？
- en: '![](Images/CH12_F01_Kabacoff3.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F01_Kabacoff3.png)'
- en: Figure 12.1 Strip chart of the hypothetical treatment data in table 12.1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 表12.1中假设治疗数据的条形图
- en: In a parametric approach, you might assume that the data are sampled from normal
    populations with equal variances and apply a two-tailed independent-groups t-test.
    The null hypothesis is that the population mean for Treatment A is equal to the
    population mean for Treatment B. You’d calculate a t-statistic from the data and
    compare it to the theoretical distribution. If the observed t-statistic is sufficiently
    extreme, say outside the middle 95% of values in the theoretical distribution,
    you’d reject the null hypothesis and declare that the population means for the
    two groups are unequal at the 0.05 level of significance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数方法中，你可能会假设数据来自具有相同方差的正态总体，并应用双尾独立组t检验。零假设是治疗A的总体均值等于治疗B的总体均值。你会从数据中计算t统计量，并将其与理论分布进行比较。如果观察到的t统计量足够极端，比如说在理论分布中间95%的值之外，你会拒绝零假设，并宣布在0.05的显著性水平上两组的总体均值不相等。
- en: 'A permutation test takes a different approach. If the two treatments are truly
    equivalent, the label (Treatment A or Treatment B) assigned to an observed score
    is arbitrary. To test for differences between the two treatments, you could follow
    these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 置换检验采用不同的方法。如果两种治疗方法真正等效，则分配给观察到的分数的标签（治疗A或治疗B）是任意的。为了检验两种治疗方法之间的差异，你可以遵循以下步骤：
- en: Calculate the observed t-statistic, as in the parametric approach; call this
    t0.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照参数方法计算观察到的t统计量；称这个为t0。
- en: Place all 10 scores in a single group.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有10个分数放在一个单独的组中。
- en: Randomly assign 5 scores to Treatment A and 5 scores to Treatment B.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机分配5个分数给治疗A和5个分数给治疗B。
- en: Calculate and record the new observed t-statistic.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并记录新的观察到的t统计量。
- en: Repeat steps 3–4 for every possible way of assigning 5 scores to Treatment A
    and 5 scores to Treatment B. There are 252 such possible arrangements.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对将5个分数分配给治疗A和5个分数分配给治疗B的每一种可能方式重复步骤3-4。共有252种可能的排列。
- en: Arrange the 252 t-statistics in ascending order. This is the empirical distribution,
    based on (or conditioned on) the sample data.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将252个t统计量按升序排列。这是基于（或基于）样本数据的经验分布。
- en: If t0 falls outside the middle 95% of the empirical distribution, reject the
    null hypothesis that the population means for the two treatment groups are equal
    at the 0.05 level of significance.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果t0落在经验分布中间95%之外，则在0.05的显著性水平上拒绝两个处理组的总体均值相等的零假设。
- en: Notice that the same t-statistic is calculated in both the permutation and parametric
    approaches. But instead of comparing the statistic to a theoretical distribution
    to determine if it was extreme enough to reject the null hypothesis, it’s compared
    to an empirical distribution created from permutations of the observed data. This
    logic can be extended to most classical statistical tests and linear models.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在置换和参数方法中都计算了相同的t统计量。但与将统计量与理论分布比较以确定它是否足够极端以拒绝零假设不同，它是与从观察数据排列中创建的经验分布进行比较。这种逻辑可以扩展到大多数经典统计检验和线性模型。
- en: In the previous example, the empirical distribution was based on all possible
    permutations of the data. In such cases, the permutation test is called an *exact*
    test. As the sample sizes increase, the time required to form all possible permutations
    can become prohibitive. In such cases, you can use Monte Carlo simulation to sample
    from all possible permutations. Doing so provides an approximate test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，经验分布是基于数据的所有可能排列。在这种情况下，置换检验被称为*精确*检验。随着样本量的增加，形成所有可能排列所需的时间可能会变得难以承受。在这种情况下，你可以使用蒙特卡洛模拟从所有可能的排列中进行抽样。这样做提供了一个近似检验。
- en: 'If you’re uncomfortable assuming that the data is normally distributed, concerned
    about the impact of outliers, or feel that the dataset is too small for standard
    parametric approaches, a permutation test provides an excellent alternative. R
    has some of the most comprehensive and sophisticated packages currently available
    for performing permutation tests. The remainder of this section focuses on two
    contributed packages: the `coin` package and the `lmPerm` package. The `coin`
    package provides a comprehensive framework for permutation tests applied to independence
    problems, whereas the `lmPerm` package provides permutation tests for ANOVA and
    regression designs. We’ll consider each package in turn. Be sure to install them
    (`install.packages(c("coin", "lmPerm"))`) before continuing.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得假设数据是正态分布的不可靠，担心异常值的影响，或者觉得数据集太小，不适合标准参数方法，那么置换检验提供了一个极好的替代方案。R有一些目前可用的最全面和复杂的包来执行置换检验。本节剩余部分将重点介绍两个贡献包：`coin`包和`lmPerm`包。`coin`包提供了一个全面的框架，用于应用于独立性问题的置换检验，而`lmPerm`包提供了用于方差分析和回归设计的置换检验。我们将依次考虑每个包。在继续之前，请确保安装它们（`install.packages(c("coin",
    "lmPerm"))`）。
- en: Setting the random number seed
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设置随机数种子
- en: Before moving on, it’s important to remember that permutation tests use pseudo-random
    numbers to sample from all possible permutations when performing an approximate
    test. Therefore, the results will change each time the test is performed. Setting
    the random number seed in R allows you to fix the random numbers generated. This
    is particularly useful when you want to share your examples with others because
    results will always be the same if the calls are made with the same seed. Setting
    the random number seed to `1234` (that is, `set.seed(1234)`) will allow you to
    replicate the results presented in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，重要的是要记住排列检验在执行近似测试时使用伪随机数从所有可能的排列中进行抽样。因此，每次执行测试时结果都会改变。在R中设置随机数种子允许你固定生成的随机数。这在你想与他人分享示例时特别有用，因为如果使用相同的种子进行调用，结果总是会相同。将随机数种子设置为`1234`（即`set.seed(1234)`）将允许你复制本章中展示的结果。
- en: 12.2 Permutation tests with the coin package
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 使用coin包进行排列检验
- en: 'The `coin` package provides a general framework for applying permutation tests
    to independence problems. With this package, you can answer such questions these:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`coin`包提供了一个通用的框架，用于将排列检验应用于独立性问题。使用此包，你可以回答以下问题：'
- en: Are responses independent of group assignment?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应是否独立于分组分配？
- en: Are two numeric variables independent?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个数值变量是否独立？
- en: Are two categorical variables independent?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个分类变量是否独立？
- en: Using convenience functions provided in the package (see table 12.2), you can
    perform permutation test equivalents for most of the traditional statistical tests
    covered in chapter 7.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包中提供的便利函数（见表12.2），你可以执行大多数在第七章中涵盖的传统统计测试的排列检验等效。
- en: Table 12.2 `coin` functions providing permutation test alternatives to traditional
    tests
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 提供排列检验替代传统测试的`coin`函数
- en: '| Test | `coin` function |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | `coin`函数 |'
- en: '| Two- and K-sample permutation test | `oneway_test( y ~ A``)` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 双样本和K样本排列检验 | `oneway_test( y ~ A``)` |'
- en: '| Wilcoxon–Mann–Whitney rank-sum test | `wilcox_test( y ~ A )` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 威尔科克森-曼-惠特尼秩和检验 | `wilcox_test( y ~ A )` |'
- en: '| Kruskal–Wallis test | `kruskal_test( y ~ A` `)` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 克鲁斯卡尔-沃利斯检验 | `kruskal_test( y ~ A` `)` |'
- en: '| Pearson’s chi-square test | `chisq_test( A ~ B` `)` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 皮尔逊卡方检验 | `chisq_test( A ~ B` `)` |'
- en: '| Cochran–Mantel–Haenszel test | `cmh_test( A ~ B &#124; C` `)` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 科克伦-曼特尔-汉森检验 | `cmh_test( A ~ B &#124; C` `)` |'
- en: '| Linear-by-linear association test | `lbl_test( D ~ E``)` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 线性-线性关联检验 | `lbl_test( D ~ E``)` |'
- en: '| Spearman’s test | `spearman_test( y ~ x` `)` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 斯皮尔曼检验 | `spearman_test( y ~ x` `)` |'
- en: '| Friedman test | `friedman_test( y ~ A &#124; C` `)` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 弗里德曼检验 | `friedman_test( y ~ A &#124; C` `)` |'
- en: '| Wilcoxon signed-rank test | `wilcoxsign_test( y1 ~ y2` `)` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 威尔科克森符号秩检验 | `wilcoxsign_test( y1 ~ y2` `)` |'
- en: In the `coin` function column, `y` and `x` are numeric variables, `A` and `B`
    are categorical factors, `C` is a categorical blocking variable, `D` and `E` are
    ordered factors, and `y1` and `y2` are matched numeric variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`coin`函数列中，`y`和`x`是数值变量，`A`和`B`是分类因素，`C`是分类分组变量，`D`和`E`是有序因素，而`y1`和`y2`是匹配的数值变量。
- en: Each of the functions listed in table 12.2 takes the form
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2中列出的每个函数都采用以下形式
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '*`formula`* describes the relationship among variables to be tested. Examples
    are given in the table.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`formula`*描述了要测试的变量之间的关系。示例在表中给出。'
- en: '*`data`* identifies a data frame.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`data`*标识一个数据框。'
- en: '`distribution` specifies how the empirical distribution under the null hypothesis
    should be derived. Possible values are `exact`, `asymptotic`, and `approximate`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distribution`指定了在零假设下经验分布应该如何推导。可能的值是`exact`、`asymptotic`和`approximate`。'
- en: If `distribution="exact"`, the distribution under the null hypothesis is computed
    exactly (that is, from all possible permutations). The distribution can also be
    approximated by its asymptotic distribution (`distribution="asymptotic"`) or via
    Monte Carlo resampling (`distribution="approximate(nresample=n)"`), where `n`
    indicates the number of random replications used to approximate the exact distribution.
    The default is 10,000 replications. At present, `distribution="exact"` is only
    available for two-sample problems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`distribution="exact"`，则零假设下的分布是精确计算的（即，从所有可能的排列中）。分布也可以通过其渐近分布（`distribution="asymptotic"`）或通过蒙特卡洛重采样（`distribution="approximate(nresample=n)"`）来近似，其中`n`表示用于近似精确分布的随机重复次数。默认值为10,000次重复。目前，`distribution="exact"`仅适用于双样本问题。
- en: Note In the `coin` package, categorical variables and ordinal variables must
    be coded as factors and ordered factors, respectively. Additionally, the data
    must be stored in a data frame.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在`coin`包中，分类变量和有序变量必须分别编码为因子和有序因子。此外，数据必须存储在数据框中。
- en: In the remainder of this section, you’ll apply several of the permutation tests
    described in table 12.2 to problems from previous chapters. This will allow you
    to compare the results to more traditional parametric and nonparametric approaches.
    We’ll end this discussion of the `coin` package by considering advanced extensions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，你将应用表12.2中描述的几个排列检验来解决前几章的问题。这将允许你将结果与更传统的参数和非参数方法进行比较。我们将通过考虑高级扩展来结束对`coin`包的讨论。
- en: 12.2.1 Independent two-sample and k-sample tests
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 独立双样本和k样本检验
- en: To begin, let’s compare an independent samples t-test with a one-way exact test
    applied to the hypothetical data in table 12.2\. The results are given in the
    following listing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们比较一下独立样本t检验与应用于表12.2中假设数据的单因素精确检验。结果如下所示。
- en: Listing 12.1 t-test vs. one-way permutation test for the hypothetical data
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 假设数据的t检验与单因素排列检验
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The traditional t-test indicates a significant group difference (p < .05), whereas
    the exact test doesn’t (p > 0.071). With only 10 observations, l’d be more inclined
    to trust the results of the permutation test and attempt to collect more data
    before reaching a final conclusion.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 传统t检验表明存在显著的组间差异（p < .05），而精确检验则没有（p > 0.071）。只有10个观测值，我更倾向于相信排列检验的结果，并在得出最终结论之前尝试收集更多数据。
- en: Next, consider the Wilcoxon–Mann–Whitney U test. In chapter 7, we examined the
    difference in the probability of imprisonment in Southern versus non-Southern
    US states using the `wilcox.test()` function. Using an exact Wilcoxon rank-sum
    test, you’d get
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑Wilcoxon–Mann–Whitney U检验。在第7章中，我们使用`wilcox.test()`函数考察了南方与南方以外美国各州监禁概率的差异。使用精确的Wilcoxon秩和检验，你会得到
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: suggesting that incarceration is more likely in Southern states. Note that in
    the previous code, the numeric variable `So` was transformed into a factor. This
    is because the `coin` package requires that all categorical variables be coded
    as factors. Additionally, you may have noted that these results agree exactly
    with the results of the `wilcox.test()` function in chapter 7\. This is because
    `wilcox.test()` also computes an exact distribution by default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在南方各州监禁的可能性更大。注意，在前面的代码中，数值变量`So`被转换为因子。这是因为`coin`包要求所有分类变量都被编码为因子。此外，你可能已经注意到这些结果与第7章中`wilcox.test()`函数的结果完全一致。这是因为`wilcox.test()`默认情况下也计算精确分布。
- en: 'Finally, consider a k-sample test. In chapter 9, you used a one-way ANOVA to
    evaluate the impact of five drug regimens on cholesterol reduction in a sample
    of 50 patients. An approximate k-sample permutation test can be performed instead,
    using this code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑k样本检验。在第9章中，你使用单因素方差分析来评估五种药物方案对50名患者胆固醇降低的影响。可以使用此代码进行近似的k样本排列检验：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the reference distribution is based on 9,999 permutations of the data.
    The random-number seed is set so that your results will be the same as mine. There’s
    clearly a difference in response among patients in the various groups.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参考分布基于数据的9,999次排列。随机数种子被设置为使你的结果与我的相同。显然，不同组别中的患者反应存在明显差异。
- en: 12.2.2 Independence in contingency tables
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 列联表中的独立性
- en: You can use permutation tests to assess the independence of two categorical
    variables using either the `chisq_test()` or `cmh_test()` function. The latter
    function is used when data is stratified on a third categorical variable. If both
    variables are ordinal, you can use the `lbl_test()` function to test for a linear
    trend.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用排列检验通过`chisq_test()`或`cmh_test()`函数来评估两个分类变量的独立性。后者函数用于数据在第三个分类变量上分层时。如果两个变量都是有序的，你可以使用`lbl_test()`函数来测试线性趋势。
- en: In chapter 7, you applied a chi-square test to assess the relationship between
    arthritis treatment and improvement. Treatment had two levels (Placebo and Treated),
    and Improved had three levels (None, Some, and Marked). The Improved variable
    was encoded as an ordered factor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，你使用卡方检验来评估关节炎治疗与改善之间的关系。治疗有两个水平（安慰剂和治疗组），改善有三个水平（无、一些和显著）。改善变量被编码为有序因子。
- en: 'If you want to perform a permutation version of the chi-square test, you can
    use the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要执行卡方检验的排列版本，可以使用以下代码：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This gives you an approximate chi-square test based on 9,999 replications. You
    might ask why you transformed the variable `Improved` from an ordered factor to
    a categorical factor. (Good question!) If you’d left it an ordered factor, `coin()`
    would have generated a linear × linear trend test instead of a chi-square test.
    Although a trend test would be a good choice in this situation, keeping it a chi-square
    test allows you to compare the results with those in chapter 7.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了基于9999次重复的近似卡方检验。你可能会问为什么将变量`Improved`从有序因子转换为分类因子。（好问题！）如果你保留它为有序因子，`coin()`将生成线性×线性趋势检验而不是卡方检验。尽管在这种情况下趋势检验可能是一个好的选择，但保持为卡方检验允许你将结果与第7章中的结果进行比较。
- en: 12.2.3 Independence between numeric variables
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 数字变量之间的独立性
- en: 'The `spearman_test()` function provides a permutation test of the independence
    of two numeric variables. In chapter 7, we examined the correlation between illiteracy
    and murder rates for US states. You can test the association via permutation using
    the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`spearman_test()`函数提供了两个数值变量独立性的排列检验。在第7章中，我们考察了美国各州文盲率和谋杀率之间的相关性。你可以通过排列检验来测试这种关联，以下代码：'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Based on an approximate permutation test with 9,999 replications, the hypothesis
    of independence can be rejected. Note that `state.x77` is a matrix. It had to
    be converted into a data frame for use in the `coin` package.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基于约9999次重复的近似排列检验，可以拒绝独立性假设。注意，`state.x77`是一个矩阵。它必须被转换成数据框才能在`coin`包中使用。
- en: 12.2.4 Dependent two-sample and k-sample tests
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 依赖的双样本和k样本检验
- en: Dependent sample tests are used when observations in different groups have been
    matched or when repeated measures are used. For permutation tests with two paired
    groups, the `wilcoxsign_test()` function can be used. For more than two groups,
    use the `friedman_test()` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同组别的观测值已经匹配或使用了重复测量时，使用依赖样本检验。对于两个配对组的排列检验，可以使用`wilcoxsign_test()`函数。对于超过两个组的情况，使用`friedman_test()`函数。
- en: 'In chapter 7, we compared the unemployment rate for urban males aged 14–24
    (`U1`) with urban males aged 35–39 (`U2`). Because the two variables are reported
    for each of the 50 US states, you have a two-dependent groups design (`state`
    is the matching variable). You can use an exact Wilcoxon signed-rank test to see
    if unemployment rates for the two age groups are equal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们比较了14至24岁城市男性的失业率（`U1`）与35至39岁城市男性的失业率（`U2`）。由于这两个变量针对美国的每个州都有报告，你有一个两个依赖组的实验设计（`state`是匹配变量）。你可以使用精确的Wilcoxon符号秩检验来查看两个年龄组的失业率是否相等：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Based on the results, you’d conclude that the unemployment rates differ.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据结果，你会得出结论：失业率存在差异。
- en: 12.2.5 Going further
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 进一步探讨
- en: 'The `coin` package provides a general framework for testing whether one group
    of variables is independent of a second group of variables (with optional stratification
    on a blocking variable) against arbitrary alternatives, via approximate permutation
    tests. In particular, the `independence_test()` function lets you approach most
    traditional tests from a permutation perspective and create new and novel statistical
    tests for situations not covered by traditional methods. This flexibility comes
    at a price: a high level of statistical knowledge is required to use the function
    appropriately. See the vignettes that accompany the package (accessed via `vignette("coin")`)
    for further details.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`coin`包提供了一个通用的框架，用于测试一组变量是否独立于另一组变量（可选地在阻断变量上进行分层）相对于任意备择假设，通过近似排列检验。特别是，`independence_test()`函数让你可以从排列的角度接近大多数传统检验，并为传统方法未涵盖的情况创建新的和独特的统计检验。这种灵活性是有代价的：需要高水平的统计知识才能恰当地使用该函数。请参阅包附带的小册子（通过`vignette("coin")`访问）以获取更多详细信息。'
- en: In the next section, you’ll learn about the `lmPerm` package. This package provides
    a permutation approach to linear models, including regression and analysis of
    variance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解`lmPerm`包。此包提供了一种排列方法来处理线性模型，包括回归和方差分析。
- en: 12.3 Permutation tests with the lmPerm package
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用lmPerm包进行排列检验
- en: The `lmPerm` package provides support for a permutation approach to linear models.
    In particular, the `lmp()` and `aovp()` functions are the `lm()` and `aov()` functions
    modified to perform permutation tests rather than normal theory tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`lmPerm`包提供了对线性模型排列方法的支撑。特别是，`lmp()`和`aovp()`函数是经过修改的`lm()`和`aov()`函数，用于执行排列检验而不是常规理论检验。'
- en: The parameters in the `lmp()` and `aovp()` functions are similar to those in
    the `lm()` and `aov()` functions, with the addition of a `perm=` parameter. The
    `perm=` option can take the value `Exact`, `Prob`, or `SPR`. `Exact` produces
    an exact test, based on all possible permutations. `Prob` samples from all possible
    permutations. Sampling continues until the estimated standard deviation falls
    below 0.1 of the estimated p-value. The stopping rule is controlled by an optional
    `Ca` parameter. Finally, `SPR` uses a sequential probability ratio test to decide
    when to stop sampling. Note that if the number of observations is greater than
    10, `perm="Exact"` will automatically default to `perm="Prob"`. Exact tests are
    only available for small problems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`lmp()`和`aovp()`函数的参数与`lm()`和`aov()`函数的参数相似，增加了`perm=`参数。`perm=`选项可以取`Exact`、`Prob`或`SPR`的值。`Exact`基于所有可能的排列产生精确检验。`Prob`从所有可能的排列中进行抽样。抽样会继续进行，直到估计的标准差低于估计p值的0.1。停止规则由可选的`Ca`参数控制。最后，`SPR`使用顺序概率比检验来决定何时停止抽样。请注意，如果观测值的数量大于10，`perm="Exact"`将自动默认为`perm="Prob"`。精确检验仅适用于小问题。'
- en: To see how this works, you’ll apply a permutation approach to simple regression,
    polynomial regression, multiple regression, one-way analysis of variance, one-way
    analysis of covariance, and a two-way factorial design.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，您将应用排列方法于简单回归、多项式回归、多元回归、单因素方差分析、单因素协方差分析和双向因子设计。
- en: 12.3.1 Simple and polynomial regression
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 简单和多项式回归
- en: In chapter 8, you used linear regression to study the relationship between weight
    and height for a group of 15 women. Using `lmp()` instead of `lm()` generates
    the permutation test results shown in the following listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，您使用线性回归研究了15名女性的体重与身高之间的关系。使用`lmp()`而不是`lm()`会生成以下列表中的排列检验结果。
- en: Listing 12.2 Permutation tests for simple linear regression
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.2 简单线性回归的排列检验
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To fit a quadratic equation, you could use the code in this next listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要拟合一个二次方程，您可以使用下一列表中的代码。
- en: Listing 12.3 Permutation tests for polynomial regression
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.3 多项式回归的排列检验
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, it’s a simple matter to test these regressions using permutation
    tests and requires little change in the underlying code. The output is also similar
    to that produced by the `lm()` function. Note that an `Iter` column is added,
    indicating how many iterations were required to reach the stopping rule.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用排列检验测试这些回归非常简单，并且对底层代码的改变很小。输出结果也与`lm()`函数产生的结果相似。请注意，增加了一个`Iter`列，表示达到停止规则所需的迭代次数。
- en: 12.3.2 Multiple regression
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 多元回归
- en: In chapter 8, multiple regression was used to predict the murder rate based
    on population, illiteracy, income, and frost for 50 US states. Applying the `lmp()`
    function to this problem results in the following listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，使用多元回归预测了50个美国州的人口、文盲率、收入和霜冻对谋杀率的影响。将`lmp()`函数应用于此问题会产生以下列表。
- en: Listing 12.4 Permutation tests for multiple regression
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 多元回归的排列检验
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Looking back to chapter 8, both `Population` and `Illiteracy` are significant
    (p < 0.05) when normal theory is used. Based on the permutation tests, the `Population`
    variable is no longer significant. When the two approaches don’t agree, you should
    look at your data more carefully. It may be that the assumption of normality is
    untenable or that outliers are present.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第8章，当使用常规理论时，`Population`和`Illiteracy`都是显著的（p < 0.05）。基于排列检验，`Population`变量不再显著。当两种方法不一致时，您应该更仔细地查看您的数据。可能是不变性假设不可靠，或者存在异常值。
- en: 12.3.3 One-way ANOVA and ANCOVA
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 单因素方差分析和协方差分析
- en: Each of the analysis of variance designs discussed in chapter 9 can be performed
    via permutation tests. First, let’s look at the one-way ANOVA problem considered
    in section 9.1 on the impact of treatment regimens on cholesterol reduction. The
    code and results are given in the next listing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章中讨论的每个方差分析设计都可以通过排列检验来完成。首先，让我们看看第9.1节中关于治疗方案对胆固醇降低影响的单因素方差分析问题。代码和结果将在下一列表中给出。
- en: Listing 12.5 Permutation test for one-way ANOVA
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 一因素方差分析的排列检验
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The results suggest that the treatment effects are not all equal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，治疗效应并不都是相等的。
- en: This second example in this section applies a permutation test to a one-way
    analysis of covariance. The problem is from chapter 9, where you investigated
    the impact of four drug doses on the litter weights of rats, controlling for gestation
    times. The next listing shows the permutation test and results.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的第二个例子将排列检验应用于单因素协方差分析。这个问题来自第9章，其中你研究了在控制妊娠时间的情况下，四种药物剂量对大鼠窝重量的影响。下一列表显示了排列检验和结果。
- en: Listing 12.6 Permutation test for one-way ANCOVA
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.6 单因素协方差分析的排列检验
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Based on the p-values, the four drug doses don’t equally impact litter weights,
    controlling for gestation time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据p值，在控制妊娠时间的情况下，四种药物剂量对窝重量的影响并不相等。
- en: 12.3.4 Two-way ANOVA
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 双因素方差分析
- en: You’ll end this section by applying permutation tests to a factorial design.
    In chapter 9, you examined the impact of vitamin C on the tooth growth in guinea
    pigs. The two manipulated factors were dose (three levels) and delivery method
    (two levels). Ten guinea pigs were placed in each treatment combination, resulting
    in a balanced 3 × 2 factorial design. The permutation tests are provided in the
    next listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过应用排列检验来结束本节内容。在第9章中，你研究了维生素C对豚鼠牙齿生长的影响。两个操纵因素是剂量（三个水平）和递送方式（两个水平）。每个治疗组合放置了10只豚鼠，从而形成了一个平衡的3×2因子设计。排列检验将在下一列表中提供。
- en: Listing 12.7 Permutation test for two-way ANOVA
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.7 双因素方差分析的排列检验
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At the .05 level of significance, all three effects are statistically different
    from zero. At the .01 level, only the main effects are significant.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在显著性水平为0.05时，所有三个效应在统计上都与零不同。在显著性水平为0.01时，只有主效应是显著的。
- en: It’s important to note that when `aovp()` is applied to ANOVA designs, it defaults
    to unique sums of squares (also called *SAS Type III sums of squares*). Each effect
    is adjusted for every other effect. The default for parametric ANOVA designs in
    R is sequential sums of squares (*SAS Type I sums of squares*). Each effect is
    adjusted for those that appear *earlier* in the model. For balanced designs, the
    two approaches will agree, but for unbalanced designs with unequal numbers of
    observations per cell, they won’t. The greater the imbalance, the greater the
    disagreement. If desired, specifying `seqs=TRUE` in the `aovp()` function will
    produce sequential sums of squares. For more on Type I and Type III sums of squares,
    see section 9.2.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当`aovp()`应用于方差分析设计时，它默认使用唯一平方和（也称为*SAS Type III平方和*）。每个效应都会调整以适应其他每个效应。R中参数方差分析设计的默认值是顺序平方和（*SAS
    Type I平方和*）。每个效应都会调整以适应那些在模型中*出现较早*的效应。对于平衡设计，两种方法将达成一致，但对于不平衡设计，每个单元的观测数不相等，它们就不会。不平衡程度越大，不一致性越大。如果需要，在`aovp()`函数中指定`seqs=TRUE`将产生顺序平方和。有关第一类和第三类平方和的更多信息，请参阅第9.2节。
- en: 12.4 Additional comments on permutation tests
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 对排列检验的附加评论
- en: Permutation tests provide a powerful alternative to tests that rely on a knowledge
    of the underlying sampling distribution. In each of these permutation tests, you
    were able to test statistical hypotheses without recourse to the normal, t, F,
    or chi-square distributions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 排列检验为依赖于对潜在抽样分布的了解的检验提供了一个强大的替代方案。在这些排列检验中的每一个，你都能够测试统计假设，而不必依赖于正态、t、F或卡方分布。
- en: You may have noticed how closely the results of the tests based on normal theory
    agreed with the results of the permutation approach in previous sections. The
    data in these problems were well behaved, and the agreement between methods is
    a testament to how well normal-theory methods work in such cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，基于正态理论的测试结果与之前章节中排列方法的测试结果非常接近。这些问题中的数据表现良好，方法之间的一致性是对正态理论方法在这种情况下工作得有多好的证明。
- en: Permutation tests really shine in cases where the data are clearly non-normal
    (for example, highly skewed), outliers are present, samples sizes are small, or
    no parametric tests exist. But if the original sample is a poor representation
    of the population of interest, no test, including permutation tests, will improve
    the inferences generated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 排列检验在数据明显非正态（例如，高度偏斜）、存在异常值、样本量小或不存在参数检验的情况下表现得尤为出色。但如果原始样本是对感兴趣人群的糟糕代表，那么没有任何测试，包括排列检验，能够改善生成的推断。
- en: Permutation tests are primarily useful for generating p-values that can be used
    to test null hypotheses. They can help answer the question, “Does an effect exist?”
    It’s more difficult to use permutation methods to obtain confidence intervals
    and estimates of measurement precision. Fortunately, this is an area in which
    bootstrapping excels.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 排列检验主要用于生成可以用来检验零假设的p值。它们可以帮助回答“是否存在效应？”的问题。使用排列方法来获得置信区间和测量精度的估计比较困难。幸运的是，这是自助法擅长的领域。
- en: 12.5 Bootstrapping
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 自助法
- en: '*Bootstrapping* generates an empirical distribution of a test statistic or
    set of test statistics by repeated random sampling with replacement from the original
    sample. It allows you to generate confidence intervals and test statistical hypotheses
    without having to assume a specific underlying theoretical distribution.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*自助法*通过从原始样本中重复随机有放回抽样来生成一个测试统计量或一组测试统计量的经验分布。它允许你在不需要假设特定潜在理论分布的情况下生成置信区间和测试统计假设。'
- en: It’s easiest to demonstrate the logic of bootstrapping with an example. Say
    that you want to calculate the 95% confidence interval for a sample mean. Your
    sample has 10 observations, a sample mean of 40, and a sample standard deviation
    of 5\. If you’re willing to assume that the sampling distribution of the mean
    is normally distributed, the (1 – *α*/2)% confidence interval can be calculated
    using
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个例子最容易展示自助法的逻辑。比如说，你想计算样本均值的95%置信区间。你的样本有10个观测值，样本均值为40，样本标准差为5。如果你愿意假设均值的抽样分布是正态分布的，那么(1
    – *α*/2)%的置信区间可以使用以下公式计算：
- en: '![](Images/CH12_F01_Kabacoff3-EQ01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH12_F01_Kabacoff3-EQ01.png)'
- en: where *t* is the upper 1 – α/2 critical value for a *t* distribution with *n*
    – 1 degrees of freedom. For a 95% confidence interval, you have 40 – 2.262(5/3.163)
    < *µ* < 40 + 2.262 -(5/3.162) or 36.424 < *µ* < 43.577. You’d expect 95% of confidence
    intervals created in this way to surround the true population mean.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t* 是具有 *n* – 1个自由度的 *t* 分布的上1 – α/2临界值。对于95%的置信区间，你有40 – 2.262(5/3.163)
    < *µ* < 40 + 2.262 -(5/3.162) 或 36.424 < *µ* < 43.577。你预计以这种方式创建的95%置信区间将围绕真实的总体均值。
- en: 'But what if you aren’t willing to assume that the sampling distribution of
    the mean is normally distributed? You can use a bootstrapping approach instead:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不愿意假设均值的抽样分布是正态分布的怎么办？你可以使用自助法：
- en: Randomly select 10 observations from the sample, with replacement after each
    selection. Some observations may be selected more than once, and some may not
    be selected at all.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从样本中随机选择10个观测值，每次选择后进行有放回抽样。一些观测值可能被选择多次，而一些可能一次也没有被选择。
- en: Calculate and record the sample mean.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并记录样本均值。
- en: Repeat the first two steps 1,000 times.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前两步1,000次。
- en: Order the 1,000 sample means from smallest to largest.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1,000个样本均值按从小到大的顺序排列。
- en: Find the sample means representing the 2.5th and 97.5th percentiles. In this
    case, it’s the 25th number from the bottom and top. These are your 95% confidence
    limits.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到代表2.5%和97.5%百分位的样本均值。在这种情况下，这是从底部和顶部数的第25个数。这些就是你的95%置信极限。
- en: In this case, where the sample mean is likely to be normally distributed, you
    gain little from the bootstrap approach. Yet in many cases, the bootstrap approach
    is advantageous. What if you wanted confidence intervals for the sample median
    or the difference between two sample medians? There are no simple normal-theory
    formulas here, and bootstrapping is the approach of choice. If the underlying
    distributions are unknown; if outliers are a problem; if sample sizes are small;
    or if parametric approaches don’t exist, bootstrapping can often be a useful method
    of generating confidence intervals and testing hypotheses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果样本均值很可能呈正态分布，那么自助法带来的好处很少。然而，在许多情况下，自助法是有优势的。如果你想要样本中位数或两个样本中位数之差的置信区间怎么办？这里没有简单的正态理论公式，而自助法是首选的方法。如果潜在分布未知；如果异常值是一个问题；如果样本量小；或者如果参数方法不存在，自助法通常可以是一个有用的方法来生成置信区间和检验假设。
- en: 12.6 Bootstrapping with the boot package
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 使用boot包进行自助法
- en: The `boot` package provides extensive facilities for bootstrapping and related
    resampling methods. You can bootstrap a single statistic (for example, a median)
    or a vector of statistics (for example, a set of regression coefficients). Be
    sure to download and install the `boot` package before first use (`install.packages("boot")`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`boot` 包提供了广泛的用于自举和相关重采样方法的设施。您可以自举单个统计量（例如，中位数）或一组统计量（例如，回归系数集）。在使用之前，请确保下载并安装
    `boot` 包（`install.packages("boot")`）。'
- en: The bootstrapping process will seem complicated, but once you review the examples
    it should make sense.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自举过程可能看起来很复杂，但一旦您回顾了示例，它应该就会变得有意义。
- en: 'In general, bootstrapping involves three main steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，自举涉及三个主要步骤：
- en: Write a function that returns the statistic or statistics of interest. If there
    is a single statistic (for example, a median), the function should return a number.
    If there is a set of statistics (for example, a set of regression coefficients),
    the function should return a vector.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数返回感兴趣的统计量或统计量。如果有一个单个统计量（例如，中位数），则该函数应返回一个数字。如果有多个统计量（例如，回归系数集），则该函数应返回一个向量。
- en: Process this function through the `boot()` function to generate R bootstrap
    replications of the statistic(s).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `boot()` 函数处理此函数以生成统计量（s）的 R 自举重复。
- en: Use the `boot.ci()` function to obtain confidence intervals for the statistic(s)
    generated in step 2.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `boot.ci()` 函数获取步骤 2 中生成的统计量（s）的置信区间。
- en: Now to the specifics. The main bootstrapping function is `boot``()`. It has
    the format
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在具体来说。主要的自举函数是 `boot()`。其格式为
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Table 12.3 describes the parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.3 描述了参数。
- en: Table 12.3 Parameters of the `boot()` function
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.3 `boot()` 函数的参数
- en: '| Parameter | Description |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| `data` | A vector, matrix, or data frame |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `data` | 一个向量、矩阵或数据框 |'
- en: '| `statistic` | A function that produces the k statistics to be bootstrapped
    (k = 1 if bootstrapping a single statistic). The function should include an indices
    parameter that the `boot()` function can use to select cases for each replication
    (see the examples in the text). |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `statistic` | 产生要自举的 *k* 个统计量的函数（如果自举单个统计量，则 k = 1）。该函数应包含一个索引参数，`boot()`
    函数可以使用该参数为每个重复选择案例（请参阅文本中的示例）。 |'
- en: '| `R` | Number of bootstrap replicates |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `R` | 自举重复的数量 |'
- en: '| `...` | Additional parameters to be passed to the function that produces
    the statistic of interest |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `...` | 传递给产生感兴趣统计量的函数的附加参数 |'
- en: The `boot()` function calls the statistic function `R` times. Each time, it
    generates a set of random indices, with replacement, from the integers `1:nrow(data)`.
    These indices are used in the statistic function to select a sample. The statistics
    are calculated on the sample, and the results are accumulated in `bootobject`.
    Table 12.4 describes the `bootobject` structure.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`boot()` 函数调用统计函数 `R` 次。每次，它从整数 `1:nrow(data)` 中生成一组有放回的随机索引。这些索引用于统计函数以选择样本。在样本上计算统计量，并将结果累积在
    `bootobject` 中。表 12.4 描述了 `bootobject` 结构。'
- en: Table 12.4 Elements of the object returned by the `boot()` function
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.4 `boot()` 函数返回的对象的元素
- en: '| Element | Description |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 描述 |'
- en: '| `t0` | The observed values of *k* statistics applied to the original data
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `t0` | 应用到原始数据的 *k* 个统计量的观测值 |'
- en: '| `t` | An *R × k* matrix, where each row is a bootstrap replicate of the *k*
    statistics |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 一个 *R × k* 矩阵，其中每一行是 *k* 个统计量的自举重复 |'
- en: You can access these elements as `bootobject$t0` and `bootobject$t`*.*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `bootobject$t0` 和 `bootobject$t`*.* 访问这些元素。
- en: Once you generate the bootstrap samples, you can use `print()` and `plot()`
    to examine the results. If the results look reasonable, you can use the `boot.ci()`
    function to obtain confidence intervals for the statistic(s). The format is
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了自举样本，您可以使用 `print()` 和 `plot()` 来检查结果。如果结果看起来合理，您可以使用 `boot.ci()` 函数来获取统计量（s）的置信区间。格式为
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Table 12.5 gives the parameters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.5 给出了参数。
- en: Table 12.5 Parameters of the `boot.ci()` function
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.5 `boot.ci()` 函数的参数
- en: '| Parameter | Description |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| `bootobject` | The object returned by the `boot()` function. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `bootobject` | `boot()` 函数返回的对象。 |'
- en: '| `conf` | The desired confidence interval (default: `conf`=0.95) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `conf` | 所需的置信区间（默认：`conf`=0.95） |'
- en: '| `type` | The type of confidence interval returned. Possible values are `norm`,
    `basic`, `stud`, `perc`, `bca`, and `all` (default: `type="all"`) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 返回的置信区间的类型。可能的值是 `norm`、`basic`、`stud`、`perc`、`bca` 和 `all`（默认：`type="all"`）
    |'
- en: The `type` parameter specifies the method for obtaining the confidence limits.
    The `perc` method (percentile) was demonstrated in the sample mean example. `bca`
    provides an interval that makes simple adjustments for bias. I find `bca` preferable
    in most circumstances. See Mooney and Duval (1993) for an introduction to these
    methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 参数指定了获取置信限的方法。`perc` 方法（百分位法）在样本均值示例中进行了演示。`bca` 提供了一个对偏差进行简单调整的区间。我发现
    `bca` 在大多数情况下更可取。参见Mooney和Duval（1993）以了解这些方法。'
- en: In the remaining sections, we’ll look at bootstrapping a single statistic and
    a vector of statistics.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨重抽样单一统计量和一系列统计量。
- en: 12.6.1 Bootstrapping a single statistic
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.1 重抽样单一统计量
- en: The `mtcars` dataset contains information on 32 automobiles reported in the
    1974 *Motor Trend* magazine. Suppose you’re using multiple regression to predict
    miles per gallon from a car’s weight (lb/1,000) and engine displacement (cu. in.).
    In addition to the standard regression statistics, you’d like to obtain a 95%
    confidence interval for the R-squared value (the percent of variance in the response
    variable explained by the predictors). The confidence interval can be obtained
    using nonparametric bootstrapping.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`mtcars` 数据集包含了1974年《*Motor Trend*》杂志报道的32辆汽车的信息。假设你正在使用多元回归来预测汽车的油耗（每1000磅的重量和发动机排量（立方英寸））。除了标准的回归统计量之外，你希望得到R平方值（由预测变量解释的响应变量变异百分比）的95%置信区间。可以使用非参数重抽样法来获得置信区间。'
- en: 'The first task is to write a function for obtaining the R-squared value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是编写一个获取R平方值的函数：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function returns the R-squared value from a regression. The `d <-` `data[indices,]`
    statement is required for `boot``()` to be able to select samples.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数从回归中返回R平方值。`d <- data[indices,]` 语句对于 `boot()` 能够选择样本是必需的。
- en: 'You can then draw a large number of bootstrap replications (say, 1,000) with
    the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码绘制大量重抽样重复（例如，1000次）：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `boot` object can be printed using
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式打印 `boot` 对象：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: and plotted using `plot(results)`. Figure 12.2 shows the resulting graph.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用 `plot(results)` 进行绘图。图12.2显示了结果图。
- en: '![](Images/CH12_F02_Kabacoff3.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F02_Kabacoff3.png)'
- en: Figure 12.2 Distribution of bootstrapped R-squared values
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 重抽样R平方值的分布
- en: In figure 12.2, you can see that the distribution of bootstrapped R-squared
    values isn’t normally distributed. A 95% confidence interval for the R-squared
    values can be obtained using
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在图12.2中，你可以看到重抽样R平方值的分布不是正态分布的。可以使用以下方法获得R平方值的95%置信区间：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can see from this example that different approaches to generating the confidence
    intervals can lead to different intervals. In this case, the bias-adjusted interval
    is moderately different from the percentile method. In either case, the null hypothesis
    *H*[0]: R-square = 0 would be rejected because zero is outside the confidence
    limits.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '从这个例子中你可以看到，不同的生成置信区间的方法会导致不同的区间。在这种情况下，偏差调整区间与百分位法中等程度不同。在任何情况下，零假设 *H*[0]:
    R-square = 0 都会被拒绝，因为零不在置信区间内。'
- en: In this section, you estimated the confidence limits of a single statistic.
    In the next section, you’ll estimate confidence intervals for several statistics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你估计了一个单一统计量的置信限。在下一节中，你将估计多个统计量的置信区间。
- en: 12.6.2 Bootstrapping several statistics
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.2 重抽样多个统计量
- en: In the previous example, bootstrapping was used to estimate the confidence interval
    for a single statistic (R-squared). Continuing the example, let’s obtain the 95%
    confidence intervals for a vector of statistics. Specifically, let’s get confidence
    intervals for the three model regression coefficients (intercept, car weight,
    and engine displacement).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，重抽样被用来估计单一统计量（R平方）的置信区间。继续这个例子，让我们获得一系列统计量的95%置信区间。具体来说，让我们获取三个模型回归系数（截距、汽车重量和发动机排量）的置信区间。
- en: 'First, create a function that returns the vector of regression coefficients:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个返回回归系数向量的函数：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, use this function to bootstrap 1,000 replications:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此函数进行1000次重抽样：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When bootstrapping multiple statistics, add an index parameter to the `plot``()`
    and `boot.ci()` functions to indicate which column of `bootobject$t` to analyze.
    In this example, index 1 refers to the intercept, index 2 is car weight, and index
    3 is the engine displacement. To plot the results for car weight, use
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当对多个统计量进行自助法时，需要向`plot()`和`boot.ci()`函数添加一个索引参数，以指示分析`bootobject$t`的哪一列。在这个例子中，索引1代表截距，索引2是汽车重量，索引3是发动机排量。要绘制汽车重量的结果，请使用
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Figure 12.3 shows the graph.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3显示了图表。
- en: '![](Images/CH12_F03_Kabacoff3.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH12_F03_Kabacoff3.png)'
- en: Figure 12.3 Distribution of bootstrapping regression coefficients for car weight
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 汽车重量自助回归系数的分布
- en: To get the 95% confidence intervals for car weight and engine displacement,
    use
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取汽车重量和发动机排量的95%置信区间，请使用
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note The previous example resamples the entire sample of data each time. If
    you can assume that the predictor variables have fixed levels (typical in planned
    experiments), you’d do better to only resample residual terms. See Mooney and
    Duval (1993, pp. 16–17) for a simple explanation and algorithm.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：前一个例子每次都重新抽取整个数据样本。如果你可以假设预测变量具有固定水平（这在计划实验中很典型），那么你最好只重新抽取残差项。参见Mooney和Duval（1993，第16-17页）的简单解释和算法。
- en: 'Before we leave bootstrapping, it’s worth addressing two questions that come
    up often:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开自助法之前，值得解决两个经常出现的问题：
- en: How large does the original sample need to be?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始样本需要多大？
- en: How many replications are needed?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要多少次重复？
- en: There’s no simple answer to the first question. Some say that an original sample
    size of 20–30 is sufficient for good results as long as the sample is representative
    of the population. Random sampling from the population of interest is the most
    trusted method for assuring the original sample’s representativeness. With regard
    to the second question, I find that 1,000 replications are more than adequate
    in most cases. Computer power is cheap, and you can always increase the number
    of replications if desired.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题，没有简单的答案。有些人认为，只要样本能够代表总体，原始样本量在20-30之间就足够了。从感兴趣的总体中进行随机抽样是确保原始样本代表性的最可靠方法。至于第二个问题，我发现大多数情况下1000次重复就足够了。计算机能力便宜，如果你需要，总是可以增加重复次数。
- en: There are many helpful sources of information about permutation tests and bootstrapping.
    An excellent starting place is an online article by Yu (2003). Good (2006) provides
    a comprehensive overview of resampling in general and includes R code. Mooney
    and Duval (1993) provide a good, accessible introduction to bootstrapping. The
    definitive source on bootstrapping is Efron and Tibshirani (1998). Finally, there
    are a number of great online resources, including Simon (1997), Canty (2002),
    Shah (2005), and Fox (2002).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排列检验和自助法有许多有用的信息来源。一个很好的起点是Yu（2003）的一篇在线文章。Good（2006）提供了关于重抽样的全面概述，并包括R代码。Mooney和Duval（1993）提供了关于自助法的良好、易于理解的介绍。关于自助法的权威来源是Efron和Tibshirani（1998）。最后，还有一些优秀的在线资源，包括Simon（1997）、Canty（2002）、Shah（2005）和Fox（2002）。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Resampling statistics and bootstrapping are computer-intensive methods that
    allow you to test hypotheses and form confidence intervals without reference to
    a known theoretical distribution.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重抽样统计量和自助法是计算密集型方法，允许你在不参考已知理论分布的情况下测试假设和形成置信区间。
- en: They are particularly valuable when your data comes from unknown population
    distributions, when there are serious outliers, when your sample sizes are small,
    and when there are no existing parametric methods to answer the hypotheses of
    interest.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的数据来自未知的总体分布，当存在严重的异常值，当样本量小，以及当没有现有的参数方法来回答感兴趣的假设时，它们尤其有价值。
- en: They are particularly exciting because they provide an avenue for answering
    questions when your standard data assumptions are clearly untenable or when you
    have no other idea how to approach the problem.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们特别令人兴奋，因为它们提供了一种在标准数据假设显然不成立或当你没有其他方法来处理问题时回答问题的途径。
- en: However, they aren’t a panacea. They can’t turn bad data into good data. If
    your original samples aren’t representative of the population of interest or are
    too small to accurately reflect it, then these techniques won’t help.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，它们并不是万能的。它们不能将差数据变成好数据。如果你的原始样本不能代表感兴趣的总体，或者样本量太小，无法准确反映总体，那么这些技术将无济于事。
