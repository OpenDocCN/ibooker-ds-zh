- en: '7 Gashlycrumb: Looking items up in a dictionary'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 Gashlycrumb：在字典中查找项目
- en: In this chapter, we’re going to look up lines of text from an input file that
    start with the letters provided by the user. The text will come from an input
    file that will default to Edward Gorey’s “The Gashlycrumb Tinies,” an abecedarian
    book that describes various and ghastly ways in which children expire. For instance,
    figure 7.1 shows that “N is for Neville who died of ennui.”
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查找用户提供的字母开头的文本行。文本将来自默认的 Edward Gorey 的《The Gashlycrumb Tinies》，这是一本描述孩子们以各种可怕方式死亡的书。例如，图7.1显示“N是Neville，他因厌倦而死。”
- en: '![](../Images/7-1.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-1.png)'
- en: Table 7.1 N is for Neville who died of ennui.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 N是Neville，他因厌倦而死。
- en: Our gashlycrumb.py program will take one or more letters as positional arguments
    and will look up the lines of text that start with that letter from an *optional*
    input file. We will look up the letters in a *case-insensitive* fashion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 gashlycrumb.py 程序将接受一个或多个字母作为位置参数，并从可选的输入文件中查找以该字母开头的文本行。我们将以不区分大小写的方式查找字母。
- en: 'The input file will have the value for each letter on a separate line:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件将为每个字母提供一个单独的行值：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When our unfortunate user runs this program, here is what they will see:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的不幸用户运行这个程序时，他们会看到以下内容：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this exercise, you will
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Accept one or more positional arguments that we’ll call `letter`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个或多个我们称之为 `letter` 的位置参数。
- en: Accept an optional `--file` argument, which must be a readable text file. The
    default value will be `'gashlycrumb.txt'` (provided).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受一个可选的 `--file` 参数，它必须是一个可读的文本文件。默认值将是 `'gashlycrumb.txt'`（提供）。
- en: Read the file, find the first letter of each line, and build a data structure
    that associates the letter to the line of text. (We’ll only be using files where
    each line starts with a single, unique letter. This program would fail with any
    other format of text.)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件，找到每行的第一个字母，并构建一个将字母与文本行关联的数据结构。（我们只会使用每行以单个唯一字母开头的文件。这个程序在其他任何文本格式中都会失败。）
- en: For each `letter` provided by the user, either print the line of text for the
    `letter` if present, or print a message if it isn’t.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户提供的每个 `letter`，如果存在，则打印该 `letter` 的文本行，或者如果没有，则打印一条消息。
- en: Learn how to “pretty-print” a data structure.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何“美化打印”一个数据结构。
- en: 'You can draw from several previous programs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从几个之前的程序中借鉴：
- en: '| From chapter 2 you know how to get the first letter of a bit of text.From
    chapter 4 you know how to build a dictionary and look up a value.From chapter
    6 you know how to accept a file input argument and read it line by line. | ![](../Images/7-unnumb-1.png)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从第2章你知道如何获取一段文本的第一个字母。从第4章你知道如何构建一个字典并查找值。从第6章你知道如何接受一个文件输入参数并逐行读取。 | ![图片](../Images/7-unnumb-1.png)
    |'
- en: Now you’ll put all those skills together to recite morbid poetry!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将把这些技能结合起来，背诵一些令人毛骨悚然的诗歌！
- en: 7.1 Writing gashlycrumb.py
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 编写 gashlycrumb.py
- en: 'Before you begin writing, I encourage you to run the tests with `make` `test`
    or `pytest` `-xv` `test.py` in the 07_gashlycrumb directory. The first test should
    fail:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写之前，我鼓励你运行 07_gashlycrumb 目录中的测试，使用 `make test` 或 `pytest -xv test.py`。第一个测试应该失败：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is just a reminder that the first thing you need to do is create the file
    called gashlycrumb.py. You can do this however you like, such as by running `new.py`
    `gashlycrumb.py` in the 07_gashlycrumb directory, by copying the template/template.py
    file, or by just starting a new file from scratch. Run your tests again, and you
    should pass the first test and possibly the second if your program produces a
    usage statement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个提醒，你需要做的第一件事是创建一个名为 gashlycrumb.py 的文件。你可以按你喜欢的方式做，比如在 07_gashlycrumb 目录中运行
    `new.py gashlycrumb.py`，通过复制模板/template.py 文件，或者从头开始创建一个新文件。再次运行你的测试，你应该通过第一个测试，如果你的程序产生了用法声明，可能还会通过第二个测试。
- en: 'Next, let’s get the arguments straight. Modify your program’s parameters in
    the `get_args()` function so that it will produce the following usage statement
    when the program is run with no arguments or with the `-h` or `--help` flags:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们明确一下参数。修改你的程序在 `get_args()` 函数中的参数，以便在没有任何参数或使用 `-h` 或 `--help` 标志运行程序时产生以下用法声明：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① letter is a required positional argument that accepts one or more values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ① `letter` 是一个必需的位置参数，接受一个或多个值。
- en: ② The -h and --help arguments are created automatically by argparse.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ② `-h` 和 `--help` 参数是由 argparse 自动创建的。
- en: ③ The -f or --file argument is an option with a default value of gashlycrumb.txt.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `-f` 或 `--file` 参数是一个具有默认值 `gashlycrumb.txt` 的选项。
- en: Figure 7.2 shows a string diagram of how the program will work.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2显示了程序将如何工作的字符串图。
- en: '![](../Images/7-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-2.png)'
- en: Table 7.2 Our program will accept some letter(s) and possibly a file. It will
    then look up the line(s) of the file starting with the given letter(s).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.2我们的程序将接受一些字母（s）和可能一个文件。然后它将查找以给定字母（s）开头的文件行。
- en: 'In the `main()` function, start off by echoing each of the `letter` arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，首先回显每个`letter`参数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Try running it to make sure it works:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行它以确保它工作：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, read the file line by line using a `for` loop:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`for`循环逐行读取文件：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that I’m using `end=''''` with `print()` so that it won’t print the newline
    that’s already attached to each `line` of the file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在`print()`中使用`end=''`，这样它就不会打印文件中每行已经附加的换行符：
- en: 'Try running it to ensure you can read the input file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行它以确保您能够读取输入文件：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the alternate.txt file too:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也使用alternate.txt文件：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If your program is provided a `--file` argument that does not exist, it should
    exit with an error and message. Note that if you declare the parameter in `get_args()`
    using `type=argparse.FileType(''rt'')` as we did in the previous chapter, this
    error should be produced automatically by `argparse`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序提供了一个不存在的`--file`参数，它应该带错误消息退出。注意，如果您在`get_args()`中声明参数时使用`type=argparse.FileType('rt')`，就像我们在上一章中做的那样，这个错误应该由`argparse`自动生成：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now think about how you can use the first letter of each `line` to create an
    entry in a `dict`. Use `print()` to look at your dictionary. Figure out how to
    check if the given `letter` is *in* (wink, wink, nudge, nudge) your dictionary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何使用每行的第一个字母在`dict`中创建一个条目。使用`print()`查看您的字典。弄清楚如何检查给定的`letter`是否*在*（眨眼，眨眼，暗示，暗示）您的字典中。
- en: '| If your program is given a value that does not exist in the list of first
    characters on the lines from the input file (when searched without regard to case),
    you should print a message: | ![](../Images/7-unnumb-2.png) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 如果程序接收到一个在输入文件行首字符列表中不存在的值（在搜索时不区分大小写），应打印一条消息：| ![图片](../Images/7-unnumb-2.png)
    |'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the given `letter` is in the dictionary, print the value for it (see figure
    7.3):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的`letter`在字典中，打印其值（见图7.3）：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/7-3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-3.png)'
- en: Table 7.3 We need to create a dictionary where the first letter of each line
    is the key and the line is the value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3我们需要创建一个字典，其中每行的第一个字母是键，行本身是值。
- en: Run the test suite to ensure your program meets all the requirements. Read the
    errors closely and fix your program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试套件以确保您的程序满足所有要求。仔细阅读错误并修复您的程序。
- en: 'Here are some hints:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: Start with new.py and remove everything but the positional `letter` and optional
    `--file` parameters.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从new.py开始，删除除了位置`letter`和可选的`--file`参数之外的所有内容。
- en: Use `type=argparse.FileType('rt')` to validate the `--file` argument.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type=argparse.FileType('rt')`来验证`--file`参数。
- en: Use `nargs='+'` to define the positional argument `letter` so it will require
    one or more values.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nargs='+'`来定义位置参数`letter`，使其需要一个或多个值。
- en: A dictionary is a natural data structure for associating a value like the letter
    “A” to a phrase like “A is for Amy who fell down the stairs.” Create a new, empty
    `dict`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典是一种将像字母“A”这样的值与像“A is for Amy who fell down the stairs.”这样的短语关联的自然数据结构。创建一个新的空`dict`。
- en: Once you have an open file handle, you can read the file line by line with a
    `for` loop.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您有一个打开的文件句柄，您可以使用`for`循环逐行读取文件。
- en: Each line of text is a string. How can you get the first character of a string?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行文本都是一个字符串。您如何获取字符串的第一个字符？
- en: Create an entry in your dictionary using the first character as the key and
    the line itself as the value.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第一个字符作为键和行本身作为值在字典中创建一个条目。
- en: Iterate through each `letter` argument. How can you check that a given value
    is `in` the dictionary?
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历每个`letter`参数。您如何检查给定的值是否在字典中？
- en: 'No skipping ahead to the solution until you have written your own version!
    If you peek, you will die a horrible death: stampeded by kittens.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在您编写自己的版本之前不要跳到解决方案！如果您偷看，您将遭受可怕的死亡：被小猫踩踏。
- en: 7.2 Solution
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2解决方案
- en: 'I really hope you looked at Gorey’s artwork for his book. Now let’s talk about
    how to build a dictionary from a file input:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的希望您看了戈雷为其书籍创作的艺术作品。现在让我们谈谈如何从文件输入构建字典：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① A positional argument called letter uses nargs='+' to indicate that one or
    more values are required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ①名为letter的位置参数使用nargs='+'来指示需要一个或多个值。
- en: ② The optional --file argument must be a readable file because of type=argparse.FileType('rt').
    The default value is gashlycrumb.txt, which I know exists.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ② 由于`type=argparse.FileType('rt')`，可选的--file参数必须是一个可读的文件。默认值是gashlycrumb.txt，我知道它存在。
- en: ③ Create an empty dictionary to hold the lookup table.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个空字典来存储查找表。
- en: ④ Iterate through each line of the args.file, which will be an open file handle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 遍历`args.file`中的每一行，这将是一个打开的文件句柄。
- en: ⑤ Uppercase the first character of the line to use as the key into the lookup
    table and set the value to be the line stripped of whitespace on the right side.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将行的第一个字符转换为大写，用作查找表的键，并将值设置为右侧移除空白字符的行。
- en: ⑥ Use a for loop to iterate over each letter in args.letter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 使用`for`循环遍历`args.letter`中的每个字母。
- en: ⑦ Check if the letter is in the lookup dictionary, using letter.upper() to disregard
    case.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 使用`letter.upper()`来忽略大小写，检查字母是否在查找字典中。
- en: ⑧ If so, print the line of text from the lookup for the letter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 如果是，打印出查找表中该字母的文本行。
- en: ⑨ Otherwise, print a message saying the letter is unknown.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 否则，打印一条消息说该字母是未知的。
- en: 7.3 Discussion
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 讨论部分
- en: Did the frightful paws of the kittens hurt much? Let’s talk about how I solved
    this problem. Remember, mine is just one of many possible solutions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 小猫的可怕爪子伤害得厉害吗？让我们谈谈我是如何解决这个问题。记住，我的只是许多可能的解决方案之一。
- en: 7.3.1 Handling the arguments
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 处理参数
- en: I prefer to have all the logic for parsing and validating the command-line arguments
    in the `get_args()` function. In particular, `argparse` can do a fine job of verifying
    tedious things, such as an argument being an existing, readable text file, which
    is why I use `type=argparse.FileType('rt')` for that argument. If the user doesn’t
    supply a valid argument, `argparse` will throw an error, printing a helpful message
    along with the short usage statement, and will exit with an error code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在`get_args()`函数中处理解析和验证命令行参数的逻辑。特别是`argparse`可以很好地验证繁琐的事情，例如确保一个参数是一个现有且可读的文本文件，这就是为什么我使用`type=argparse.FileType('rt')`来处理这个参数。如果用户没有提供有效的参数，`argparse`将抛出一个错误，打印一条有用的消息以及简短的用法说明，并以错误代码退出。
- en: 'By the time I get to the line `args` `=` `get_args()`, I know that I have one
    or more “letter” arguments and a valid, open file handle in the `args.file` slot.
    In the REPL, I can use `open` to get a file handle, which I usually like to call
    `fh`. For copyright purposes, I’ll use my alternate text:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我到达`args` `=` `get_args()`这一行时，我知道我有一个或多个“字母”参数，以及一个有效的、打开的文件句柄在`args.file`槽中。在REPL中，我可以用`open`来获取文件句柄，我通常喜欢将其称为`fh`。出于版权目的，我将使用我的备用文本：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 7.3.2 Reading the input file
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 读取输入文件
- en: 'We want to use a dictionary where the keys are the first letters of each line
    and the values are the lines themselves. That means we need to start by creating
    a new, empty dictionary, either by using the `dict()` function or by setting a
    variable equal to an empty set of curly brackets (`{}`). Let’s call the variable
    `lookup`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用一个字典，其中键是每行的第一个字母，值是行本身。这意味着我们需要首先创建一个新的空字典，无论是使用`dict()`函数还是将变量设置为空花括号集合（`{}`）。让我们称这个变量为`lookup`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can use a `for` loop to read each `line` of text. From the Crow’s Nest program
    in chapter 2, you know we can use `line[0].upper()` to get the first letter of
    `line` and uppercase it. We can use that as the key into `lookup`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个`for`循环来读取文本的每一行。从第2章的Crow’s Nest程序中，你知道我们可以使用`line[0].upper()`来获取`line`的第一个字母并将其转换为大写。我们可以用这个作为`lookup`的键。
- en: 'Each `line` of text ends with a newline that I’d like to remove. The `str.rstrip()`
    method will strip whitespace from the right side of the `line` ("rstrip" = *right
    strip*). The result of that will be the value for my `lookup`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行的文本都以换行符结束，我想移除它。`str.rstrip()`方法将从`line`的右侧移除空白字符（"rstrip" = *right strip*）。这将是我`lookup`的值：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s look at the resulting `lookup` dictionary. We can `print()` it from the
    program or type `lookup` in the REPL, but it’s going to be hard to read. I encourage
    you to try it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果`lookup`字典。我们可以从程序中`print()`它或在REPL中输入`lookup`，但它将很难阅读。我鼓励你试试看。
- en: 'Luckily there is a lovely module called `pprint` to “pretty-print” data structures.
    Here is how you can import the `pprint()` function from the `pprint` module with
    the alias `pp`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个叫做`pprint`的可爱模块可以“美化打印”数据结构。以下是如何从`pprint`模块导入`pprint()`函数并使用别名`pp`：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Figure 7.4 illustrates how this works.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4展示了这是如何工作的。
- en: '![](../Images/7-4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-4.png)'
- en: Table 7.4 We can specify exactly which functions to import from a module and
    even give the function an alias.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.4 我们可以指定从模块中导入的确切函数，甚至给函数一个别名。
- en: 'Now let’s take a peek at the `lookup` table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 `lookup` 表：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hey, that looks like a handy data structure. Hooray for us! Please don’t discount
    the value of using lots of `print()` calls when you are trying to write and understand
    a program, and of using the `pprint()` function whenever you need to see a complex
    data structure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，这看起来像是一个方便的数据结构。为我们欢呼！当你试图编写和理解程序时，请不要低估使用大量 `print()` 调用的价值，以及当你需要查看复杂数据结构时使用
    `pprint()` 函数的价值。
- en: 7.3.3 Using a dictionary comprehension
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用字典推导式
- en: 'In chapter 4 you saw that you can use a list comprehension to build a list
    by putting a `for` loop inside `[]`. If we change the brackets to curlies (`{}`),
    we create a dictionary comprehension:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，你看到了你可以使用列表推导式通过在 `[]` 内放置 `for` 循环来构建列表。如果我们把括号改为花括号 `{}`，我们就可以创建一个字典推导式：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See in figure 7.5 how we can rearrange three lines of our `for` loop into a
    single line of code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.5 中看看我们如何将 `for` 循环的三行代码重组成一行代码。
- en: '![](../Images/7-5.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-5.png)'
- en: Table 7.5 The `for` loop we used to build a dictionary can be written using
    a dictionary comprehension.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.5 我们用来构建字典的 `for` 循环可以用字典推导式来写。
- en: If you print the `lookup` table again, you should see the same output as before.
    It may seem like showing off to write one line of code instead of three, but it
    really does make a good deal of sense to write compact, idiomatic code. More code
    always means more chances for bugs, so I usually try to write code that is as
    simple as possible (but no simpler).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次打印 `lookup` 表，你应该看到之前相同的输出。写一行代码而不是三行代码可能看起来像是在炫耀，但紧凑、惯用的代码确实很有意义。代码越多，出错的机会就越多，所以我通常尽量编写尽可能简单的代码（但不要过于简单）。
- en: 7.3.4 Dictionary lookups
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 字典查找
- en: '| Now that I have a `lookup` table, I can ask whether some value is `in` the
    keys. I know the letters are in uppercase, and since the user could give me a
    lowercase letter, I use `letter.upper()` to only compare that case: | ![](../Images/7-unnumb-3.png)
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 现在我有一个 `lookup` 表，我可以询问某个值是否在键中。我知道字母是大写的，而且由于用户可能会给我一个小写的字母，我使用 `letter.upper()`
    来仅比较这种情况：| ![图片](../Images/7-unnumb-3.png) |'
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the letter is found, I can print the line of text for that letter; otherwise,
    I can print a message saying that I don’t know that letter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了字母，我可以打印该字母的文本行；否则，我可以打印一条消息，说明我不知道那个字母：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An even shorter way to write that would be to use the `dict.get()` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dict.get()` 方法可以更简洁地写这个：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① lookup.get() will return the value for letter.upper() or the warning about
    a value not being found in our lookup.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ① `lookup.get()` 将返回 `letter.upper()` 对应的值，或者在我们的查找中找不到值的警告。
- en: 7.4 Going further
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 进一步学习
- en: Write a phonebook that reads a file and creates a dictionary from the names
    of your friends and their email or phone numbers.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个电话簿程序，该程序读取文件并从你朋友的姓名和他们的电子邮件或电话号码创建一个字典。
- en: Create a program that uses a dictionary to count the number of times you see
    each word in a document.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个程序，使用字典来计算你在文档中看到每个单词的次数。
- en: 'Write an interactive version of the program that takes input directly from
    the user. Use `while` `True` to set up an infinite loop and keep using the `input()`
    function to get the user’s next `letter`:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个交互式版本的程序，该程序直接从用户那里获取输入。使用 `while` `True` 设置无限循环，并继续使用 `input()` 函数来获取用户的下一个
    `letter`：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Interactive programs are fun to write, but how would you go about testing them?
    In chapter 17 I’ll show you one way to do this.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写交互式程序很有趣，但你是如何测试它们的呢？在第 17 章中，我会向你展示一种这样做的方法。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: A dictionary comprehension is a way to build a dictionary in a one-line `for`
    loop.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典推导式是一种在单行 `for` 循环中构建字典的方法。
- en: Defining file input arguments using `argparse.FileType` saves you time and code.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `argparse.FileType` 定义文件输入参数可以节省你时间和代码。
- en: Python’s `pprint` module is used to pretty-print complex data structures.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `pprint` 模块用于格式化打印复杂的数据结构。
