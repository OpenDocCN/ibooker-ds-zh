- en: 11 Animated social media share links
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 动画社交媒体分享链接
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the OOCSS, SMACSS, and BEM architecture patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OOCSS、SMACSS和BEM架构模式
- en: Scoping CSS when working with components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用组件时范围化CSS
- en: Working with social media icons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与社交媒体图标一起工作
- en: Creating CSS transitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建CSS过渡效果
- en: Using JavaScript to overcome CSS limitations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaScript克服CSS限制
- en: One of the core reasons why the internet was created was to share and distribute
    information. One way we do this today is through social media. In this chapter,
    we’ll style and animate some links that can be used to share a web page via email
    or social media.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网被创建的核心原因之一是为了分享和分发信息。我们今天做这件事的一种方式是通过社交媒体。在本章中，我们将样式化和动画化一些可以用于通过电子邮件或社交媒体分享网页的链接。
- en: As in the previous chapters, we’ll be using HTML and CSS for this project without
    any frameworks. We chose this approach to focus on the CSS itself without the
    complexity and intricacies of using external packages. But many applications in
    the wild do use frameworks, some of which include the concept of the component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们将在这个项目中使用HTML和CSS，而不使用任何框架。我们选择这种方法是为了专注于CSS本身，而不必处理使用外部包的复杂性和复杂性。但许多实际应用确实使用了框架，其中一些包括组件的概念。
- en: A common reason to turn a piece of functionality into a component is to reuse
    the piece of code or element in multiple places in applications. With reusability
    comes the possibility of naming collisions. Some systems automatically restrict
    the scope of the CSS of the component to itself, preventing any possible collision
    between component styles. But many systems don’t restrict the scope, leaving it
    up to the developer to organize the code to prevent changing the styles in another
    component when styling a new one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个功能部分转换为组件的常见原因是为了在应用程序的多个地方重用代码或元素。随着可重用性的出现，可能会出现命名冲突。一些系统自动限制组件CSS的范围，防止任何可能的冲突。但许多系统不限制范围，将其留给开发者组织代码以防止在为新组件样式化时更改另一个组件的样式。
- en: Regardless of the framework and how it does (or doesn’t) handle CSS scoping,
    we have a variety of architecture options to help us organize and standardize
    our styles. Before we dive into this chapter’s project, let’s take a quick look
    at some CSS architecture options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论框架如何处理（或未处理）CSS范围，我们都有各种架构选项来帮助我们组织和标准化我们的样式。在我们深入本章的项目之前，让我们快速了解一下一些CSS架构选项。
- en: 11.1 Working with CSS architecture
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 与CSS架构一起工作
- en: Some of the most popular CSS architecture methodologies are OOCSS, SMACSS, and
    BEM. We’ll be using BEM in this chapter, but we’ll take a look at all three options
    so that we’ll understand the high-level differences among them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的CSS架构方法之一是OOCSS、SMACSS和BEM。我们将在本章中使用BEM，但我们将查看所有三个选项，以便我们了解它们之间的高层次差异。
- en: 11.1.1 OOCSS
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 OOCSS
- en: 'Introduced at Web Directions North in Denver by Nicolle Sullivan, OOCSS (Object-Oriented
    CSS; [https://github.com/stubbornella/oocss/wiki](https://github.com/stubbornella/oocss/wiki))
    aims to help developers create CSS that’s fast, maintainable, and standards-based.
    Sullivan describes the *Object* part of OOCSS as “a repeating visual pattern,
    that can be abstracted into an independent snippet of HTML, CSS, and possibly
    JavaScript. That object can then be reused throughout a site”—in other words,
    what we might think of today as a component or widget. To achieve this reusability,
    OOCSS follows two main principles:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由Nicolle Sullivan在丹佛的Web Directions North介绍，OOCSS（面向对象CSS；[https://github.com/stubbornella/oocss/wiki](https://github.com/stubbornella/oocss/wiki)）旨在帮助开发者创建快速、可维护和基于标准的CSS。Sullivan将OOCSS的*对象*部分描述为“一个重复的视觉模式，可以抽象成一个独立的HTML、CSS和可能的JavaScript片段。该对象可以在整个网站上重复使用”——换句话说，这就是我们今天可能认为的组件或小工具。为了实现这种可重用性，OOCSS遵循两个主要原则：
- en: '*Separate structure and skin*—Keeps visual features (background, borders, and
    so on, sometimes referred to as the theme) in their own classes, which can be
    mixed and matched with objects to create a variety of elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分离结构和皮肤*——将视觉特性（背景、边框等，有时被称为主题）保留在其自己的类中，这些类可以与对象混合匹配以创建各种元素。'
- en: '*Separate container and content*—By refraining from using location-dependent
    styles, we can ensure that the objects look the same no matter where they’re placed
    in the application or on the website.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分离容器和内容*——通过避免使用位置依赖的样式，我们可以确保对象无论在应用程序或网站上的哪个位置看起来都一样。'
- en: 11.1.2 SMACSS
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 SMACSS
- en: 'Developed by Jonathan Snook, SMACSS (Scalable and Modular Architecture for
    CSS; [http://smacss.com](http://smacss.com)), organizes CSS rules into five categories:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由Jonathan Snook开发，SMACSS（CSS的可伸缩和模块化架构；[http://smacss.com](http://smacss.com)）将CSS规则组织为五个类别：
- en: '*Base*—The defaults applied by using element, descendent, or child selectors
    and pseudo-classes'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基础*—使用元素、后代或子选择器和伪类应用默认值'
- en: '*Layout*—Used to lay elements out on the page, such as headers, articles, and
    footers'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*布局*—用于在页面上布局元素，例如标题、文章和页脚'
- en: '*Module*—More discrete parts of the layout, such as carousels, cards, and navigation
    bars'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块*—布局的更多离散部分，例如轮播图、卡片和导航栏'
- en: '*State*—Something that augments or overrides other styles, such as an error
    state or the state of a menu (open or closed)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*状态*—增强或覆盖其他样式的东西，例如错误状态或菜单的状态（打开或关闭）'
- en: '*Theme*—Defines the look and feel; doesn’t have to be separated in its own
    classes if it’s the only theme for the page or project'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主题*—定义外观和感觉；如果它是页面或项目的唯一主题，则不需要将其分开成自己的类'
- en: 11.1.3 BEM
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 BEM
- en: 'Developed by a company named Yandex, BEM (Block Element Modifier; [https://en.bem.info/methodology](https://en.bem.info/methodology))
    is a component-based architecture that aims to break the user interface into independent,
    reusable blocks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由名为Yandex的公司开发，BEM（块、元素、修饰符；[https://en.bem.info/methodology](https://en.bem.info/methodology)）是一种基于组件的架构，旨在将用户界面分解为独立的、可重用的块：
- en: '*Block*'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*块*'
- en: Describes the block’s purpose.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述块的目的。
- en: An example would be a class name for an element, such as `header`.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，一个元素的类名，如`header`。
- en: '*Element*'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元素*'
- en: Describes the element’s purpose.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述元素的目的。
- en: The class name is the block name followed by two underscores and the element,
    such as `header__text`.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名是块名后跟两个下划线和元素，例如`header__text`。
- en: '*Modifier*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修饰符*'
- en: Describes the appearance, state, and behavior.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述外观、状态和行为。
- en: 'The class pattern is `block-name_modifier-name` (example: `header_mobile`)
    or `block-name__element-name_modifier-name` (example: `header__menu_open`).'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模式为`block-name_modifier-name`（例如：`header_mobile`）或`block-name__element-name_modifier-name`（例如：`header__menu_open`）。
- en: Choosing an architectural approach for CSS is a team-dependent task. The needs
    of the project, the size and experience of the team, and the libraries and frameworks
    being used are factors to consider. No one-size-fits-all approach exists, so the
    decision needs to be made by the team. Because of BEM’s component-based nature,
    we’ll use it in this chapter to scope and style our social media share links.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 选择CSS的架构方法是团队依赖的任务。项目的需求、团队的大小和经验，以及正在使用的库和框架都是需要考虑的因素。没有一种适合所有情况的解决方案，因此决策需要由团队做出。由于BEM的基于组件的特性，我们将在此章节中使用它来定义和样式化我们的社交媒体分享链接。
- en: 11.2 Setting up
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 设置
- en: Now that we’ve chosen our methodology, which dictates the naming convention
    we’ll use for the project, let’s take a look at what we’ll be building. We’ll
    style a Share button that, when clicked, opens a set of links that let the user
    share the page via email or to Facebook, LinkedIn, or Twitter. Then we’ll use
    transitions to animate opening and closing the share options and the hover/focus
    effects of the individual links. Figure 11.1 shows our goal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了我们的方法论，它决定了我们将为项目使用的命名约定，让我们看看我们将要构建的内容。我们将样式化一个分享按钮，当点击时，会打开一组链接，允许用户通过电子邮件或Facebook、LinkedIn或Twitter分享页面。然后我们将使用过渡来动画化打开和关闭分享选项以及单个链接的悬停/聚焦效果。图11.1显示了我们的目标。
- en: '![](../Images/11-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-01.png)'
- en: Figure 11.1 Goal
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 目标
- en: Our starting HTML (listing 11.1) consists of a container for our component,
    a Share button, and a menu that lets users choose how to share the page. The code
    includes a linked JavaScript file, which makes our component usable via keyboard
    navigation and triggers showing/hiding the links inside the component when the
    Share button is clicked. As we’ll see in section 11.6, a few limitations apply
    to animating elements with CSS alone, so we’ll rely on a couple of lines of JavaScript
    to support our CSS. We’ll look at JavaScript in more detail later in the chapter
    (also in section 11.6); first, we’ll focus on our HTML and CSS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们起始的HTML（列表11.1）包括我们的组件容器、一个分享按钮和一个允许用户选择如何分享页面的菜单。代码包括一个链接的JavaScript文件，这使得我们的组件可以通过键盘导航使用，并在点击分享按钮时触发显示/隐藏组件内的链接。正如我们将在11.6节中看到的，仅使用CSS对元素进行动画有一些限制，因此我们将依赖几行JavaScript来支持我们的CSS。我们将在本章的后面部分（也在11.6节中）更详细地了解JavaScript；首先，我们将专注于我们的HTML和CSS。
- en: Listing 11.1 Starting HTML
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.1 起始HTML
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Component container
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ① 组件容器
- en: ② Share button to open and close the list of social media links
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ② 分享按钮以打开和关闭社交媒体链接列表
- en: ③ Media menu
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 媒体菜单
- en: ④ Menu item
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 菜单项
- en: ⑤ First link is a mailto to share via email rather than social media.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 首个链接是一个通过电子邮件分享而不是社交媒体的 mailto 链接。
- en: ⑥ Media icon
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 媒体图标
- en: ⑦ Link to share via social media
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 通过社交媒体分享的链接
- en: ⑧ Script used for keyboard interactions and supplementing CSS
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 用于键盘交互和补充 CSS 的脚本
- en: 'We also have some basic starter CSS applied to the `main` element to move the
    component away from the edge of the screen: `main` `{` `margin:` `48px;` `}`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应用了一些基本的起始 CSS 到 `main` 元素上，以便将组件从屏幕边缘移开：`main` `{` `margin:` `48px;` `}`.
- en: You can find all the starter code (HTML, CSS, and JavaScript) on GitHub at [http://mng.bz/KeR4](http://mng.bz/KeR4)
    or CodePen at [https://codepen.io/michaelgearon/pen/YzZzpWj](https://codepen.io/michaelgearon/pen/YzZzpWj).
    Our starting point looks like figure 11.2.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到所有起始代码（HTML、CSS 和 JavaScript），网址为 [http://mng.bz/KeR4](http://mng.bz/KeR4)
    或 CodePen，网址为 [https://codepen.io/michaelgearon/pen/YzZzpWj](https://codepen.io/michaelgearon/pen/YzZzpWj)。我们的起点看起来像图
    11.2。
- en: '![](../Images/11-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![11-02.png]'
- en: Figure 11.2 Starting point
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 起点
- en: As you can see, the icons have been provided, but let’s discuss where and how
    we got them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，图标已经提供，但让我们讨论我们是从哪里以及如何获得它们的。
- en: 11.3 Sourcing icons
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 图标来源
- en: 'Any time we use iconography from someone else’s brand, we need to answer the
    following questions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用他人品牌的图标时，我们需要回答以下问题：
- en: Are we authorized to use the icon?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有权使用该图标？
- en: Are there any restrictions on how the icon can be used?
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标的用途是否有任何限制？
- en: When we use social media icons, those brands are being represented in our work,
    so we must follow their guidelines on when, how, and in what context we can use
    the brand. When we use icons that don’t represent a brand (such as the icons we
    used for the `mailto` link and Share button), unless we created the icon ourselves,
    we’re subject to copyright laws, just as we would be for any other piece of media
    (image, sound, video, and so on) that we use in our projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用社交媒体图标时，这些品牌在我们的作品中被代表，因此我们必须遵循他们关于何时、如何以及在何种情境下可以使用品牌的指南。当我们使用不代表品牌的图标（例如我们用于
    `mailto` 链接和分享按钮的图标）时，除非我们亲自创建了该图标，否则我们将受到版权法的约束，就像我们会对我们项目中使用的任何其他媒体（图像、声音、视频等）一样。
- en: NOTE We’re not lawyers, and we don’t intend to offer legal advice in this chapter.
    When in doubt, contact a legal professional.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们不是律师，我们无意在本章中提供法律建议。如有疑问，请联系法律专业人士。
- en: 11.3.1 Media icons
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 媒体图标
- en: An effective way to find how a branded icon can be used is to look for that
    brand’s guide by doing a web search for terms such as *style guide* and *brand
    guide*. Many social media outlets have specific instructions on how the brand
    can be represented, including icon and logo downloads. Table 11.1 lists the social
    media platforms we included in our component and the links to their brand information.
    For this project, we sourced our social media icons directly from the respective
    brand guides.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 找到品牌图标如何使用的一个有效方法是，通过在网络上搜索诸如 *风格指南* 和 *品牌指南* 等术语来查找该品牌的指南。许多社交媒体平台都有关于如何代表品牌的特定说明，包括图标和标志的下载。表
    11.1 列出了我们组件中包含的社交媒体平台及其品牌信息链接。对于这个项目，我们直接从相应的品牌指南中获取了社交媒体图标。
- en: Table 11.1 Social media brand resources
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 社交媒体品牌资源
- en: '| Brand | Icon | Link to assets |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 品牌 | 图标 | 资产链接 |'
- en: '| Facebook | ![](../Images/icon_facebook.png) | [http://mng.bz/9Dza](http://mng.bz/9Dza)
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Facebook | ![Facebook 图标](../Images/icon_facebook.png) | [http://mng.bz/9Dza](http://mng.bz/9Dza)
    |'
- en: '| LinkedIn | ![](../Images/icon_linkedIn.png) | [https://brand.linkedin.com/downloads](https://brand.linkedin.com/downloads)
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 领英 | ![领英图标](../Images/icon_linkedIn.png) | [https://brand.linkedin.com/downloads](https://brand.linkedin.com/downloads)
    |'
- en: '| Twitter | ![](../Images/icon_twitter.png) | [http://mng.bz/jPry](http://mng.bz/jPry)
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Twitter | ![Twitter 图标](../Images/icon_twitter.png) | [http://mng.bz/jPry](http://mng.bz/jPry)
    |'
- en: 11.3.2 Icon libraries
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 图标库
- en: Looking for icons can be a bit tedious, especially in large projects, so it’s
    common practice to use icon fonts and libraries, which also are subject to terms
    of use. Each library and icon font has its own rules about where and how icons
    can be used. Some also require attribution. Therefore, we must be aware of any
    rules we need to follow while sourcing our icons.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找图标可能有点繁琐，尤其是在大型项目中，因此使用图标字体和库是常见的做法，这些库也受使用条款的约束。每个库和图标字体都有自己的规则，关于图标可以在哪里以及如何使用。一些还要求署名。因此，我们必须在寻找图标时意识到我们需要遵循的任何规则。
- en: For this project, we sourced our non-brand-related icons from Material Symbols
    ([https://fonts.google.com/icons](https://fonts.google.com/icons)). Because we
    needed only two—share ![](../Images/icon_share_E.png) and email @—we downloaded
    the individual SVGs and included them in our icon folder rather than importing
    the entire library into the project. The icons have been provided in the starter
    code, so we’re ready to start styling.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们从 Material Symbols ([https://fonts.google.com/icons](https://fonts.google.com/icons))
    获取了非品牌相关的图标。因为我们只需要两个——分享 ![](../Images/icon_share_E.png) 和电子邮件 @——所以我们下载了单个 SVG
    并将它们包含在我们的图标文件夹中，而不是将整个库导入到项目中。图标已包含在启动代码中，因此我们准备好开始样式化。
- en: 11.4 Styling the block
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 样式化块
- en: Because we’re using BEM for our naming convention, our block name will be `"share"`.
    Therefore, the container `<div>` that wraps the entire component will have a class
    of `share`. This block name will be included in all future classes that use the
    BEM naming convention (section 11.1.3), which scopes our CSS to that component
    and helps prevent any styling collisions between our component and any other parts
    of the application it may be used in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 BEM 作为命名约定，我们的块名称将是 `"share"`。因此，包裹整个组件的 `<div>` 容器将具有 `share` 类。这个块名称将包含在所有未来使用
    BEM 命名约定的类中（第 11.1.3 节），这使我们的 CSS 作用域限于该组件，并有助于防止我们的组件与应用程序中可能使用的任何其他部分的样式冲突。
- en: As shown in listing 11.2, we define the `font-family`, `background`, and `border-radius`
    for the block. We also give the component a `display` value of `inline-flex`.
    `inline-flex` works the same way as `flex` but makes the element an inline-level
    element rather than a block-level element. By making our component behave like
    an inline element (the same as links, spans, buttons, and so on), we give it the
    greatest versatility in terms of placement in an application. Furthermore, buttons
    are inline elements by default, and when closed, what’s presented is essentially
    a button, so we’ll give our component the same flow behavior as a button.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 11.2 所示，我们为块定义了 `font-family`、`background` 和 `border-radius`。我们还给组件一个 `display`
    值为 `inline-flex`。`inline-flex` 与 `flex` 的工作方式相同，但使元素成为内联级元素而不是块级元素。通过使我们的组件表现得像内联元素（与链接、span、按钮等相同），我们在应用程序中的放置方面提供了最大的灵活性。此外，按钮默认是内联元素，当关闭时，呈现的实际上是按钮，因此我们将我们的组件赋予与按钮相同的流程行为。
- en: Note To find out how Flexbox works and discover its associated properties, check
    out chapter 6.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解 Flexbox 的工作原理以及其相关属性，请查看第 6 章。
- en: Listing 11.2 Styling the container
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 样式化容器
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Yellow
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ① 黄色
- en: With the block styled (figure 11.3), let’s address the individual elements inside
    the block.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 块样式化后（图 11.3），让我们解决块内的单个元素。
- en: '![](../Images/11-03.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-03.png)'
- en: Figure 11.3 Styled container block
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 样式化容器块
- en: 11.5 Styling the elements
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 样式化元素
- en: 'Our block has three descendent elements, all of which we want to style:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的块有三个后代元素，我们希望对它们进行样式化：
- en: The Share button
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享按钮
- en: The menu containing the list of links
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含链接列表的菜单
- en: The individual links inside the menu
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单内的单个链接
- en: Let’s start with the Share button and work our way down the list.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分享按钮开始，并按列表顺序进行。
- en: 11.5.1 Share button
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 分享按钮
- en: The class name given to the button will include the block name followed by two
    underscores and then the element. In our case, we’ll call this element `button`,
    so our class name will be `share__button.` By prefixing our class name with `share__`,
    we ensure that the only button we’ll be styling is the one within our block.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给按钮的类名将包括块名称，后跟两个下划线，然后是元素。在我们的例子中，我们将这个元素称为 `button`，因此我们的类名将是 `share__button`。通过在类名前缀加上
    `share__`，我们确保我们将会样式的按钮仅是我们块内的那个。
- en: We want to override the defaults provided by the browser and align the icon
    and text within the button (listing 11.3). We remove the background and border,
    adjust the font size and padding, and curve our corners.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要覆盖浏览器提供的默认值，并在按钮内对齐图标和文本（列表 11.3）。我们移除了背景和边框，调整了字体大小和填充，并使角落呈曲线。
- en: To align the icon and text, we give the button a `display` value of `flex` and
    then use `align-items` to align the icon and text vertically. To add whitespace
    between the icon and text, we use the `gap` property.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对齐图标和文本，我们给按钮一个 `display` 值为 `flex`，然后使用 `align-items` 来垂直对齐图标和文本。为了在图标和文本之间添加空白，我们使用
    `gap` 属性。
- en: Listing 11.3 Styling the Share button
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 样式化分享按钮
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 11.4 shows our output.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 展示了我们的输出。
- en: '![](../Images/11-04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-04.png)'
- en: Figure 11.4 Styled Share button
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 样式化分享按钮
- en: Next, let’s handle the hover and focus styles. We use the `:hover` and `:focus-visible`
    pseudo-classes to change the cursor style conditionally and add a black outline
    to the button. Then we offset the outline by `-5px` so that the outline places
    itself 5-pixels inside the button rather than on the outer edge.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理悬停和聚焦样式。我们使用 `:hover` 和 `:focus-visible` 伪类来有条件地更改光标样式，并为按钮添加黑色轮廓。然后我们将轮廓偏移
    `-5px`，这样轮廓就会放置在按钮内部 5 像素处，而不是外部边缘。
- en: The `outline-offset` property allows us to control where the outline is placed.
    Positive numbers move the outline farther out or away from the element; negative
    numbers inset the outline. The following listing shows our hover and focus CSS.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`outline-offset` 属性允许我们控制轮廓的位置。正数将轮廓移得更远或远离元素；负数将轮廓内嵌。以下列表显示了我们的悬停和聚焦 CSS。'
- en: Listing 11.4 Share button hover and focus CSS
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 分享按钮悬停和聚焦 CSS
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 11.5 shows our button being hovered over with a mouse.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 展示了鼠标悬停在按钮上的情况。
- en: '![](../Images/11-05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-05.png)'
- en: Figure 11.5 Share-button hover
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 分享按钮悬停
- en: 11.5.2 Share menu
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 分享菜单
- en: To style the menu and its items, we want to remove the bullets and then place
    the elements in a row beside the Share button. To remove the bullets, we give
    the list items a `list-style` value of `none`. Then we give the menu a `display`
    property value of `flex`. Finally, we remove the default margin and padding that
    the browser applies to the menu item automatically. The following listing shows
    our CSS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了样式化菜单及其项，我们想要移除项目符号，并将元素放置在分享按钮旁边的一行中。为了移除项目符号，我们给列表项一个 `list-style` 值为 `none`。然后我们给菜单一个
    `display` 属性值为 `flex`。最后，我们移除了浏览器自动应用到菜单项上的默认边距和填充。以下列表显示了我们的 CSS。
- en: Listing 11.5 Share menu and menu items
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 分享菜单和菜单项
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we look at our output (figure 11.6), we notice that we need some space
    between the edge of our container and our elements. We’ll handle this task while
    styling the individual links.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看输出（图 11.6）时，我们注意到我们需要在容器边缘和元素之间留出一些空间。我们将在样式化单个链接时处理这个任务。
- en: '![](../Images/11-06.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-06.png)'
- en: Figure 11.6 Styled menu
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 样式化菜单
- en: 11.5.3 Share links
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.3 分享链接
- en: To make sure that the links have a circle border on hover (rather than an ellipse),
    we set both their `height` and `width` to 48 pixels. Next, we curve their corners.
    This step also resolves our spacing problem because, as we see in listing 11.6,
    we’ve set the icon `height` and `width` to `24`. Because we’re making the links
    48 pixels in both height and width, when the links are centered, we’ll have 12
    pixels of whitespace between each icon and the edge of its link.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保链接在悬停时有一个圆形边框（而不是椭圆形），我们将它们的 `height` 和 `width` 都设置为 48 像素。接下来，我们弯曲它们的角落。这一步也解决了我们的间距问题，因为我们看到在列表
    11.6 中，我们已将图标 `height` 和 `width` 设置为 `24`。因为我们使链接在高度和宽度上都是 48 像素，所以当链接居中时，我们将在每个图标和其链接的边缘之间有
    12 像素的空白。
- en: Listing 11.6 List Item HTML
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 列表项 HTML
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We also give the links a transparent border. Borders take up space, so to prevent
    the content from shifting on hover or focus when we expose the border, we add
    a transparent border by default and then color it when we want to show it. This
    approach ensures that the space needed for the border is allotted and prevents
    the content succeeding the element from shifting when the border is exposed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还给了链接一个透明的边框。边框会占用空间，因此为了防止在悬停或聚焦时内容移动，我们默认添加一个透明的边框，然后在需要显示时上色。这种方法确保了边框所需的空间被分配，并在边框显示时防止元素后面的内容移动。
- en: To center the icon in the middle of the circle, we use `flex`, justifying the
    content and aligning the items to the center. Our CSS looks like the following
    listing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在圆圈中间居中图标，我们使用 `flex`，使内容居中并使项目对齐。我们的 CSS 如下所示。
- en: Listing 11.7 Styling the links
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 链接样式
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With our links styled (figure 11.7), we can style the links for the hover and
    focus states.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的链接样式化（图 11.7）后，我们可以为悬停和聚焦状态样式化链接。
- en: '![](../Images/11-07.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-07.png)'
- en: Figure 11.7 Styled share links
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 样式化分享链接
- en: 11.5.4 scale()
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.4 scale()
- en: On hover and focus, we’re going to expose the border by changing its color from
    transparent to black. When we set the border on the links, we used the `border`
    shorthand property, which allows us to define the style, border width, and border
    color in one declaration. Because we’re changing only the color, we’ll use `border-color`
    rather than the `border` shorthand. By using `border-color`, we can edit the border’s
    color without worrying about the rest of the already defined properties.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在悬停和聚焦时，我们将通过将颜色从透明变为黑色来显示边框。当我们设置链接的边框时，我们使用了`border`简写属性，它允许我们在一个声明中定义样式、边框宽度和边框颜色。因为我们只改变颜色，所以我们将使用`border-color`而不是`border`简写。通过使用`border-color`，我们可以编辑边框的颜色，而不用担心其他已经定义的属性。
- en: Next, we’ll use the `scale()` function to increase the size of the icon to make
    it look as though it’s magnified. In chapter 2, while expanding the loader bars,
    we used `scaleY()` to grow and shrink the bar vertically. In this project, we
    want our links to grow proportionally, so we’ll use `scale()`. When passed a single
    parameter, this function grows the element (both horizontally and vertically)
    proportionally by the same amount.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`scale()`函数来增加图标的大小，使其看起来像是被放大了。在第2章中，当我们扩展加载条时，我们使用了`scaleY()`来垂直增长和缩小条。在这个项目中，我们希望链接按比例增长，所以我们将使用`scale()`。当传递单个参数时，这个函数会按相同比例水平垂直地增长元素。
- en: The `scale()` function is the shorthand for combining `scaleX()` and `scaleY()`.
    If only one value is passed, the `scale()` amount is applied both vertically and
    horizontally. If two parameters are passed, the first parameter defines horizontal
    scale, and the second defines vertical scale.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale()`函数是`scaleX()`和`scaleY()`的组合简写。如果只传递一个值，`scale()`的量将同时应用于垂直和水平。如果传递两个参数，第一个参数定义水平缩放，第二个定义垂直缩放。'
- en: On hover or focus, we want the links to be 25% larger than when they’re not
    being interacted with, so we’ll give our function a single parameter of `1.25`
    and apply it to the `transform` property. Our CSS looks like the following listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在悬停或聚焦时，我们希望链接的大小比未交互时大25%，所以我们将函数的单个参数设置为`1.25`并应用于`transform`属性。我们的CSS看起来如下所示。
- en: Listing 11.8 Styling the links on hover and focus
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 悬停和聚焦时链接的样式
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the styles applied, our links grow on hover (figure 11.8), but because
    now the link is taller than the container, gaps at the top and bottom of the link
    don’t have the yellow background.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应用了样式后，我们的链接在悬停时增长（如图11.8所示），但由于现在链接比容器高，链接的上下间隙没有黄色背景。
- en: '![](../Images/11-08.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-08.png)'
- en: Figure 11.8 Link on hover
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 链接悬停效果
- en: To create our magnification effect, we want the entire link to remain yellow.
    We could add a yellow background to the link, which would accomplish that task,
    but the background needs to be yellow because the block’s background color is
    yellow. If we changed the background color of the container, we’d want the link’s
    background color to change as well. To make sure that the colors stay in sync,
    we could use a custom property (CSS variable) or make the element inherit the
    color from its parent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的放大效果，我们希望整个链接保持黄色。我们可以给链接添加一个黄色背景，这样就能完成这个任务，但背景需要是黄色，因为块的背景颜色是黄色。如果我们改变了容器的背景颜色，我们希望链接的背景颜色也改变。为了确保颜色保持同步，我们可以使用自定义属性（CSS变量）或使元素从其父级继承颜色。
- en: 11.5.5 The inherit property value
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.5 继承属性值
- en: The `background-color` property isn’t inherited by default. We want to explicitly
    instruct the link to inherit the background color. To this inheritance from its
    parent, we can set the `background-color` property value for the link to `inherit`.
    Inheritance, however, goes up only to the parent. In our case, the element that
    controls the background color is the link’s great-grandparent, as shown in figure
    11.9.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`background-color`属性不会继承。我们希望明确指示链接继承背景颜色。为此，我们可以将链接的`background-color`属性值设置为`inherit`。然而，继承只到父级。在我们的例子中，控制背景颜色的元素是链接的曾祖父母，如图11.9所示。
- en: '![](../Images/11-09.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-09.png)'
- en: Figure 11.9 Ancestors of the media links
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 媒体链接的祖先
- en: We need to make the `link`, `menu`, and `menu-item` rules inherit the `background-color`
    to make it trickle down to the link. After we give all three elements a `background-color`
    value of `inherit` (figure 11.10), we notice that although we’ve fixed the gaps
    in the link being hovered over, we’ve lost the curve on the right side of the
    component.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让 `link`、`menu` 和 `menu-item` 规则继承 `background-color`，以便它能够传递到链接上。在我们给所有三个元素赋予
    `background-color` 值为 `inherit`（图 11.10）之后，我们注意到，尽管我们修复了悬停链接中的间隙，但我们却失去了组件右侧的曲线。
- en: '![](../Images/11-10.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-10.png)'
- en: Figure 11.10 Inherited `background-color`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 继承的 `background-color`
- en: We lost our curve because, like `background-color`, `border-radius` isn’t inherited.
    To fix the problem, we apply the same logic that we used for `background-color`.
    Listing 11.9 shows our edited CSS. Notice that the `border-radius` of the link
    wasn’t edited. We want to keep the link’s shape as a circle, so we keep the `border-radius:`
    `50%` declaration on the link.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们失去了曲线，因为和 `background-color` 一样，`border-radius` 也不会被继承。为了解决这个问题，我们应用了与 `background-color`
    相同的逻辑。列表 11.9 展示了我们的编辑后的 CSS。注意，链接的 `border-radius` 没有被编辑。我们希望保持链接的形状为圆形，所以我们在链接上保留了
    `border-radius:` `50%` 声明。
- en: Listing 11.9 Inheriting property values
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.9 继承属性值
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Makes the link a circle
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使链接成为圆形
- en: Although inheriting values in this manner can be a bit cumbersome, it allows
    us to make sure that the color is controlled from one place. This approach benefits
    maintainability in case we decide to change the background’s color, and it sets
    us up to expand our component to support multiple themes. Another option would
    be to use a custom property for our color.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以这种方式继承值可能有点繁琐，但它确保了颜色可以从一个地方控制。如果我们决定更改背景的颜色，这种方法有利于维护性。它还为我们扩展组件以支持多个主题奠定了基础。另一个选择是使用自定义属性来设置颜色。
- en: With the `border-radius` and `background-color` inherited, our hover and focus
    styles are complete (figure 11.11), but the change when we hover over the link
    is abrupt. Let’s animate the size change.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `border-radius` 和 `background-color` 继承之后，我们的悬停和焦点样式就完成了（图 11.11），但当我们悬停在链接上时，变化是突然的。让我们动画化大小变化。
- en: '![](../Images/11-11.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-11.png)'
- en: Figure 11.11 Share-link hover effect
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 分享链接悬停效果
- en: 11.6 Animating the component
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 动画化组件
- en: In chapter 2, we used keyframes to create animation, which allowed us to define
    steps for our animation. For our hover state, we already have our start and end
    states defined. We’re transitioning from one state (not hovered or focused) to
    another (hovered or focused), whose styles are already defined in rules. So instead
    of using an animation, we’re going to use a transition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们使用关键帧创建动画，这允许我们定义动画的步骤。对于我们的悬停状态，我们已经定义了起始和结束状态。我们正在从一种状态（未悬停或聚焦）过渡到另一种状态（悬停或聚焦），其样式已经在规则中定义。因此，我们不是使用动画，而是使用过渡。
- en: 11.6.1 Creating a transition
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.1 创建过渡
- en: A transition doesn’t require a keyframe but still allows us to animate the change
    of styles from one state to another. The `transition` property allows us to define
    which property changes should be animated, as well as the duration and timing
    function. By adding `transition:` `transform` `ease-in-out` `250ms;` to our `.share__link`
    rules, we tell the browser to animate the size change of our link (listing 11.10).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡不需要关键帧，但仍允许我们动画化从一种状态到另一种状态的样式变化。`transition` 属性允许我们定义哪些属性变化应该被动画化，以及持续时间和时间函数。通过将
    `transition:` `transform` `ease-in-out` `250ms;` 添加到我们的 `.share__link` 规则中，我们告诉浏览器动画化链接的大小变化（列表
    11.10）。
- en: 'To choose the amount of time the transition needs to take, we choose something
    relatively fast: 250 milliseconds. We want to keep the animation slow enough to
    be visible but fast enough to be snappy. If we make the transition too slow, our
    project will look laggy and distract users from performing the task they’re trying
    to accomplish (sharing the content).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择过渡需要的时间长度，我们选择相对较快的：250 毫秒。我们希望动画足够慢以可见，但足够快以迅速。如果我们使过渡太慢，我们的项目看起来会滞后，并使用户从他们试图完成的任务（分享内容）中分心。
- en: Listing 11.10 Transitioning the link size change
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.10 链接大小变化的过渡
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note You may notice that after adding the transition, the outline gets chopped
    off on hover. The reason is that JavaScript drives the opening and closing of
    the component and toggles overflow and visibility. We go into detail on what the
    JavaScript is doing in section 11.6.2\. Clicking the Share button toggles this
    behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能会注意到在添加过渡后，悬停时轮廓被截断。原因是 JavaScript 驱动组件的打开和关闭，并切换溢出和可见性。我们将在 11.6.2 节中详细介绍
    JavaScript 正在做什么。点击分享按钮会切换这种行为。
- en: In our transition, we specifically tell the browser to animate the changes that
    occur on the `transform` property, but we don’t have a `transform` property in
    our `.share__ link:link,` `.share__link:visited` rule. When we run the code, however,
    we notice that our size change is animated and that the code works. This behavior
    occurs because, when not defined, `scale()` equals `scale(1)` by default. Therefore,
    we’re animating going from `scale(1)` to `scale(1.25)` when we hover or focus
    the link and then animating the scale back to `scale(1)` when we move away from
    the link.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的过渡中，我们特别告诉浏览器要动画化 `transform` 属性上发生的更改，但在我们的 `.share__ link:link,` `.share__link:visited`
    规则中我们没有 `transform` 属性。然而，当我们运行代码时，我们注意到我们的尺寸变化是动画化的，并且代码是有效的。这种行为发生是因为，当未定义时，`scale()`
    默认等于 `scale(1)`。因此，当我们将鼠标悬停或聚焦到链接上时，我们正在从 `scale(1)` 动画到 `scale(1.25)`，然后当我们从链接移开时，我们再次将缩放动画回
    `scale(1)`。
- en: Next, we’re going to animate hiding and exposing the links when the button is
    clicked.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将动画化当按钮被点击时隐藏和显示链接。
- en: 11.6.2 Opening and closing the component
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.2 打开和关闭组件
- en: Remember that our goal is for the component to hide our menu of links by default
    and expose it only when the Share button is clicked (figure 11.12).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的目标是使组件默认隐藏我们的链接菜单，并且仅在点击分享按钮时显示（图 11.12）。
- en: '![](../Images/11-12.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-12.png)'
- en: Figure 11.12 Closed and expanded states
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 关闭和展开状态
- en: The first thing we need to do is hide the menu items by default. To achieve
    this task, we’ll give the `menu` a `width` of `0` and hide the `overflow`, as
    shown in listing 11.11.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是默认隐藏菜单项。为了完成这个任务，我们将给 `menu` 设置 `width` 为 `0` 并隐藏 `overflow`，如列表
    11.11 所示。
- en: Listing 11.11 Hiding the menu
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.11 隐藏菜单
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Makes the width of the menu equal to 0
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将菜单的宽度设置为 0
- en: ② Hides the overflow so that the links within are also hidden
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ② 隐藏溢出，以便链接内部也被隐藏
- en: With our menu hidden (figure 11.13), we need to toggle exposing and hiding the
    menu when the Share button is clicked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜单隐藏（图 11.13）后，我们需要在点击分享按钮时切换显示和隐藏菜单。
- en: '![](../Images/11-13.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-13.png)'
- en: Figure 11.13 Hidden menu
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 隐藏菜单
- en: Our JavaScript handles part of the behavior for us. At the beginning of this
    chapter, we mentioned that we’ll need some JavaScript for this project. When we
    open the JavaScript file, we notice that it contains a lot of code (listing 11.12).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JavaScript 为我们处理了部分行为。在本章开头，我们提到我们需要为这个项目编写一些 JavaScript。当我们打开 JavaScript
    文件时，我们注意到它包含大量的代码（列表 11.12）。
- en: Listing 11.12 JavaScript file
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.12 JavaScript 文件
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Adds event listeners to the Share button for clicks and keypresses to open
    and close the menu via both keyboard and mouse
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为分享按钮添加点击和按键监听器，通过键盘和鼠标打开和关闭菜单
- en: ② Adds event listens to the links for clicks and keypresses to handle keyboard
    navigation within the menu
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为链接添加事件监听器，以处理菜单内的点击和按键导航
- en: ③ Adds event listeners to the menu to know when transitions start and end
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 为菜单添加事件监听器，以知道何时开始和结束过渡
- en: ④ Handles keyboard up- and down-arrow functionality or the Share button
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 处理键盘上下箭头功能或分享按钮
- en: ⑤ Handles keypress on links for keyboard navigation within the menu, including
    exiting the menu
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 处理链接上的按键，以在菜单内进行键盘导航，包括退出菜单
- en: ⑥ Prevents tab from navigating between the links because on tab, we want to
    return focus to the Share button rather than go to the next link
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 阻止使用制表符在链接之间导航，因为在制表符上，我们希望将焦点返回到分享按钮而不是转到下一个链接
- en: ⑦ Opens and closes the menu
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 打开和关闭菜单
- en: ⑧ When next is defined, moves the focus to the specific item by index; otherwise,
    cycles through the links, returning to the top when the user reaches the last
    item in the menu
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 当定义了下一个链接时，通过索引将焦点移至特定项目；否则，遍历链接，当用户到达菜单中的最后一个项目时返回顶部
- en: ⑨ Moves focus to the previous link and returns the user to the bottom of the
    list when they reach the first item in the menu
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 当用户在菜单中到达第一个项目时，将焦点移至上一个链接并返回列表底部
- en: ⑩ Navigates the user when the action is keyboard-triggered and not the default
    click or keypress; used when the user presses the spacebar on a menu item
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 当动作由键盘触发而不是默认点击或按键时导航用户；当用户在菜单项上按下空格键时使用
- en: ⑪ Hides overflow when the menu is closing
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 当菜单关闭时隐藏溢出
- en: ⑫ If open, shows overflow to allow the magnified icon to expand outside the
    container
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 如果打开，显示溢出以允许放大图标扩展到容器外
- en: Most of the code handles keyboard accessibility for the component, and listing
    11.13 shows the parts that are relevant to the button click. When the page loads,
    we default the component to being closed and find the element’s container, which
    we assign to the `container` variable. Then we add event listeners to the button
    so that when the button is clicked, the `toggleMenu()` function is triggered.
    When the button is clicked, we change the `expanded` variable to its inverse.
    If the setting was `true`, it becomes `false`, and vice versa. Finally, we add
    or remove the `share_expanded` class. `classList.toggle()` adds the class if it’s
    not present and removes it if it is.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码处理组件的键盘可访问性，列表 11.13 展示了与按钮点击相关的部分。当页面加载时，我们将组件默认设置为关闭状态，并找到元素的容器，将其分配给
    `container` 变量。然后我们给按钮添加事件监听器，以便当按钮被点击时，触发 `toggleMenu()` 函数。当按钮被点击时，我们改变 `expanded`
    变量的值为其相反数。如果设置是 `true`，则变为 `false`，反之亦然。最后，我们添加或移除 `share_expanded` 类。`classList.toggle()`
    如果类不存在则添加该类，如果存在则移除。
- en: Listing 11.13 Opening and closing the menu (JavaScript)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.13 打开和关闭菜单（JavaScript）
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Defines a variable to hold our current state
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个变量来保存我们的当前状态
- en: ② Defines a variable for our HTML container element
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ② 定义一个变量用于我们的 HTML 容器元素
- en: ③ Defines what happens when the button is clicked
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义按钮点击时发生的情况
- en: ④ Toggles the expanded variable value
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 切换 `expanded` 变量的值
- en: ⑤ Handles adding and removing share_expanded
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 处理添加和移除 share_expanded
- en: Note Because this book is about CSS, the JavaScript is included in the starter
    code. If you’re following along, you don’t need to make any edits to the JavaScript
    to make it work.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 因为这本书是关于 CSS 的，所以 JavaScript 包含在启动代码中。如果你在跟随，你不需要对 JavaScript 进行任何编辑以使其工作。
- en: All put together, this code adds the `share_expanded` class to the container
    when the Share button is clicked. If `share_expanded` is already open, the code
    removes it. We had hidden our menu items, but now we’ll show them when the `share_expanded`
    class is present.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这段代码在点击分享按钮时将 `share_expanded` 类添加到容器中。如果 `share_expanded` 已经打开，代码将移除它。我们之前隐藏了菜单项，但现在当
    `share_expanded` 类存在时，我们将显示它们。
- en: Note Remember that we decided to use BEM for our class-name convention. Our
    class name has only one underscore because `expanded` is our modifier. We use
    a modifier because we’re changing (modifying) the style based on the state (open/closed).
    We have the block (`share`) and the modifier (`expanded`); therefore, our class
    name is `block_modifier` or `share_expanded`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 记住我们决定使用 BEM 作为我们的类名约定。我们的类名只有一个下划线，因为 `expanded` 是我们的修饰符。我们使用修饰符是因为我们根据状态（打开/关闭）改变（修改）样式。我们有块（`share`）和修饰符（`expanded`）；因此，我们的类名是
    `block_modifier` 或 `share_expanded`。
- en: To show the links when the component is marked as `expanded`, we must increase
    the width of the menu, as shown in listing 11.14\. We also add a little horizontal
    padding to create some room around the menu.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件标记为 `expanded` 时显示链接，我们必须增加菜单的宽度，如列表 11.14 所示。我们还添加了一些水平填充，以在菜单周围留出一些空间。
- en: To calculate the width of the menu, we multiply the number of links by their
    width. The link’s width is 48 pixels (which we hard-set) plus the border (1 pixel
    on each side). Therefore, the menu’s width is `width` = 4 ×(48 + 2) = `200px`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算菜单的宽度，我们将链接的数量乘以它们的宽度。链接的宽度是 48 像素（我们硬设置为这个值）加上边框（每边 1 像素）。因此，菜单的宽度是 `width`
    = 4 ×(48 + 2) = `200px`。
- en: Listing 11.14 Showing the menu
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.14 显示菜单
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After clicking the button and hovering over the first link, we see that our
    link no longer expands outside the menu (figure 11.14). We also see that after
    we hover over the links and close the menu, our menu items continue to display
    until we hover over them again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮并在第一个链接上悬停后，我们看到我们的链接不再在菜单外扩展（图 11.14）。我们还看到，在我们悬停在链接上并关闭菜单后，我们的菜单项继续显示，直到我们再次悬停在其上。
- en: '![](../Images/11-14.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-14.png)'
- en: Figure 11.14 Expanded component on click
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 点击时扩展的组件
- en: Remember that our JavaScript triggers when transitions start and end and is
    responsible for controlling our overflow. Although we’ve already animated the
    style changes for hovering over the individual menu items, we haven’t added the
    transition for opening and closing the menu yet. When we add that transition,
    overflow will be set correctly when the transition activates and finishes, making
    these problems go away.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的JavaScript在过渡开始和结束时触发，并负责控制我们的溢出。虽然我们已经在悬停单个菜单项时动画化了样式变化，但我们还没有添加打开和关闭菜单的过渡。当我们添加这个过渡时，当过渡激活并完成时，溢出将被正确设置，这些问题就会消失。
- en: The next task we need to accomplish is to maintain the button outline that’s
    usually present on hover when the component is open. Because we already have a
    rule to add the border on hover and focus, we’re going to edit the rule to trigger
    when the component is open. By reusing the rule, we ensure that the styles will
    be consistent in the hover and focus states and when the list is visible. To add
    the condition, we add the `.share_ expanded` `.share__button` selector to the
    rule, as shown in the following listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成的下一个任务是保持组件打开时通常在悬停时出现的按钮轮廓。因为我们已经有了一个在悬停和聚焦时添加边框的规则，我们将编辑这个规则以在组件打开时触发。通过重用规则，我们确保在悬停、聚焦状态以及列表可见时样式的一致性。为了添加条件，我们在规则中添加了`.share_
    expanded` `.share__button`选择器，如下所示。
- en: Listing 11.15 Adding button border to Share button when list is displayed
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.15 在列表显示时添加按钮边框到分享按钮
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the selector added, our button keeps its border after the component is
    expanded (figure 11.15); and when the component is closed and not focused or hovered,
    the border stays absent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 添加选择器后，组件展开后我们的按钮仍然保留边框（如图11.15所示）；当组件关闭且未聚焦或悬停时，边框保持不存在。
- en: '![](../Images/11-15.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-15.png)'
- en: Figure 11.15 Maintaining the Share-button border when list is displayed
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 在列表显示时保持分享按钮边框
- en: 11.6.3 Animating the menu
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6.3 动画菜单
- en: Now that we’ve set our styles for both the open and closed states, let’s animate
    the showing and hiding of the menu. We want the link list to expand from the left,
    as depicted in figure 11.16.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为打开和关闭状态设置了样式，让我们来动画化菜单的显示和隐藏。我们希望链接列表从左侧展开，如图11.16所示。
- en: '![](../Images/11-16.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-16.png)'
- en: Figure 11.16 Breakdown of opening animation
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 打开动画分解
- en: When the menu closes, we’ll want to perform the inverse of the opening animation,
    retracting the menu and hiding the link. We’ll do the same for the magnification
    effect on the links, using a transition. We don’t need to use keyframes because
    the animation is going to be performed only once (when the button is clicked)
    and we already have the two states defined.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当菜单关闭时，我们将执行打开动画的反向操作，撤回菜单并隐藏链接。我们还将使用过渡执行链接的放大效果。我们不需要使用关键帧，因为动画只会在按钮点击时执行一次，并且我们已经定义了两种状态。
- en: 'We’ll add the `transition` declaration to the menu as follows: `transition:`
    `width` `250ms` `ease-in-out`. Again, we want to keep the transition snappy, so
    we give it a duration of 250 milliseconds.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加以下`transition`声明到菜单中：`transition:` `width` `250ms` `ease-in-out`。再次强调，我们希望过渡迅速，所以我们给它250毫秒的持续时间。
- en: After we add the transition, we realize that icons are becoming visible before
    they should. Figure 11.17 breaks down the effect.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 添加过渡后，我们发现图标在应该出现之前就变得可见了。图11.17分解了这种效果。
- en: '![](../Images/11-17.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11-17.png)'
- en: Figure 11.17 Icons displaying too soon
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 图标显示过早
- en: Even if we change the transition to transition all properties instead of only
    `width`, the same problem occurs. The cause is overflow. When the menu is closed,
    we want the menu’s overflow to be hidden; when it’s open, we want it to be visible.
    But overflow can’t be changed gradually, like width. It’s either visible or it’s
    not. There’s no in-between state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将过渡改为转换所有属性而不是仅`width`，同样的问题仍然会发生。原因是溢出。当菜单关闭时，我们希望菜单的溢出被隐藏；当它打开时，我们希望它可见。但是溢出不能像宽度一样逐渐改变。它要么可见，要么不可见，没有中间状态。
- en: When opening the menu, we want to wait until the transition is done before we
    change `overflow` to `visible`. When we close, we want the overflow to be hidden
    immediately. This task is where we turn to JavaScript to support our CSS. We’ll
    remove `overflow:` `visible` from our `.share_expanded` `.share__menu` class and
    handle adding it via JavaScript.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开菜单时，我们希望在将 `overflow` 更改为 `visible` 之前等待过渡完成。当我们关闭时，我们希望溢出立即隐藏。这项任务是我们转向
    JavaScript 以支持我们的 CSS 的地方。我们将从 `.share_expanded` `.share__menu` 类中移除 `overflow:`
    `visible`，并通过 JavaScript 处理添加。
- en: Listing 11.16 singles out the relevant JavaScript for handling the overflow.
    The magic lies in the `transitionstart` and `transitionend` event listeners. Attached
    to the menu, they listen for when the transition is triggered and when it’s done
    performing the change. When the event happens, they trigger their functions to
    handle the overflow for the menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 突出了处理溢出的相关 JavaScript。魔法在于 `transitionstart` 和 `transitionend` 事件监听器。它们附加到菜单上，监听过渡何时被触发以及何时完成变更。当事件发生时，它们触发其函数来处理菜单的溢出。
- en: Listing 11.16 JavaScript for handling overflow
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.16 处理溢出的 JavaScript
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Triggers when the transition starts
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当过渡开始时触发
- en: ② If in the process of closing, hides the menu’s overflow
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果正在关闭过程中，隐藏菜单的溢出
- en: ③ Triggers when the transition ends
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 当过渡结束时触发
- en: ④ If just opened, shows the overflow
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果刚刚打开，显示溢出
- en: Note As we mention earlier in the chapter, the JavaScript is included in the
    starter code. If you’re following along, you don’t need to edit the JavaScript;
    it should work.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如我们本章前面提到的，JavaScript 包含在启动代码中。如果您正在跟随，您不需要编辑 JavaScript；它应该可以工作。
- en: The next listing shows the CSS that makes the animation work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了使动画工作的 CSS。
- en: Listing 11.17 Updated CSS for open and close animation
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.17 更新后的用于打开和关闭动画的 CSS
- en: '[PRE16]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Adds the animation
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ① 添加动画
- en: With these last edits made to make the animation smooth, we’ve finished our
    animated social media share component. The final product is shown in figure 11.18.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些最后的编辑以使动画平滑，我们已经完成了我们的动画社交媒体分享组件。最终产品如图 11.18 所示。
- en: '![](../Images/11-18.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11-18.png)'
- en: Figure 11.18 Final product
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 最终产品
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We have several ways to organize CSS. Three common patterns are OOCSS, SMACSS,
    and BEM.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有几种方法来组织 CSS。三种常见的模式是 OOCSS、SMACSS 和 BEM。
- en: Icons are subject to copyright, so follow brand guidelines when using social
    media icons.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标受版权保护，因此在使用社交媒体图标时请遵循品牌指南。
- en: We can make elements displayed via Flexbox behave like inline-level elements
    by using `inline-flex`. `inline-flex` uses the same properties as `flex`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `inline-flex` 使通过 Flexbox 显示的元素表现得像内联级元素。`inline-flex` 使用与 `flex` 相同的属性。
- en: The position of an outline can be controlled via `outline-offset`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外观的定位可以通过 `outline-offset` 控制。
- en: The `scale()` function allows us to grow or shrink an element proportionally.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale()` 函数允许我们按比例放大或缩小元素。'
- en: The `inherit` property value allows us to inherit values from the parent element
    that generally wouldn’t be inherited.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inherit` 属性值允许我们从父元素继承通常不会继承的值。'
- en: Transitions don’t require keyframes but still allow us to animate CSS changes
    from one state to another.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡不需要关键帧，但仍允许我们从一个状态到另一个状态动画化 CSS 变更。
- en: The `overflow` property allows us to control whether elements that extend beyond
    their container are displayed or hidden.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overflow` 属性允许我们控制超出其容器范围的元素是显示还是隐藏。'
- en: When using JavaScript to extend our transitions’ functionality, we can use the
    `ontransitionstart` and `ontransitionend` event listeners to trigger JavaScript
    change in response to the transition’s life cycle.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 JavaScript 来扩展我们的过渡功能时，我们可以使用 `ontransitionstart` 和 `ontransitionend` 事件监听器来触发
    JavaScript 变更以响应过渡的生命周期。
