- en: 11 Knowledge graph completion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 知识图谱补全
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing heterogeneous graphs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍异构图
- en: Explaining knowledge graph embeddings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释知识图谱嵌入
- en: Describing knowledge graph completion workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述知识图谱补全工作流程
- en: Examining knowledge graph completion results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查知识图谱补全结果
- en: Chapter 10 was an introduction to link prediction and completion techniques.
    The difference between link prediction and completion is that the first is a workflow
    to predict future links, while the latter deals with predicting missing links.
    However, in practice, link prediction and completion workflows are very similar.
    What wasn’t explicitly mentioned is that the link prediction features used in
    chapter 10 do not differentiate between various node or relationship types. For
    example, the number of common neighbors does not differentiate between different
    relationship or node types. Therefore, the link prediction features used in chapter
    10 work best with monopartite or *homogeneous* graphs. A monopartite or homogenous
    graph consists of a single node and relationship type. The visualization in figure
    11.1 depicts a homogeneous graph that consists of a single node type `Stream`
    and a single relationship type `SHARED_AUDIENCE`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第10章介绍了链接预测和补全技术。链接预测和补全之间的区别在于前者是一个预测未来链接的工作流程，而后者是处理预测缺失链接。然而，在实践中，链接预测和补全的工作流程非常相似。没有明确提到的是，第10章中使用的链接预测特征没有区分不同的节点或关系类型。例如，共同邻居的数量不会区分不同的关系或节点类型。因此，第10章中使用的链接预测特征最适合单部分或*同质*图。单部分或同质图由单个节点和关系类型组成。图11.1中的可视化展示了一个由单个节点类型`Stream`和单个关系类型`SHARED_AUDIENCE`组成的同质图。
- en: '![11-01](../../OEBPS/Images/11-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![11-01](../../OEBPS/Images/11-01.png)'
- en: Figure 11.1 Homogeneous graph consisting of `Stream` nodes and `SHARED_AUDIENCE`
    relationships
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 由`Stream`节点和`SHARED_AUDIENCE`关系组成的同质图
- en: Suppose you work at a large pharmaceutical company as a data scientist. You
    have been tasked with predicting additional use cases for existing drugs the company
    produces. The strategy of identifying new use cases for existing approved drugs
    is called *drug repurposing*. The oldest example of drug repurposing is for acetylsalicylic
    acid, better known as *aspirin*. It was initially used in 1899 as an analgesic
    to relieve pain. Later, it was repurposed to be used as an antiplatelet aggregation
    drug. An antiplatelet drug decreases the ability of blood clots to form (Vane,
    1971). Aspirin was later repurposed again, as it has been shown that daily administration
    of aspirin can help prevent the development of cancers, particularly colorectal
    cancer (Rüschoff et al., 1998; Rothwell et al., 2011). Despite the potential of
    drug repurposing, it’s crucial to remember it can be a prolonged process, taking
    many years to get the drug accepted due to costly and time-consuming clinical
    trials, and it’s not as simple as a data scientist predicting a new connection
    and instantly moving the product to production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家大型制药公司担任数据科学家。你被分配了一个任务，即预测公司生产的现有药物的新用例。为现有批准药物识别新用例的策略被称为*药物再利用*。药物再利用的最古老例子是乙酰水杨酸，更广为人知的是*阿司匹林*。它最初在1899年被用作镇痛剂来缓解疼痛。后来，它被重新定位为抗血小板聚集药物。抗血小板药物可以降低血凝块形成的可能性（Vane，1971）。阿司匹林后来再次被重新定位，因为研究表明，每天服用阿司匹林可以帮助预防癌症的发展，尤其是结直肠癌（Rüschoff等人，1998；Rothwell等人，2011）。尽管药物再利用具有潜力，但必须记住，它可能是一个漫长的过程，需要多年时间才能通过成本高昂且耗时的临床试验来获得药物的批准，而且这并不像数据科学家预测一个新的连接并立即将产品推向生产那样简单。
- en: It is very likely that, as a data scientist, you don’t have a biomedical background
    and, therefore, cannot manually pick new potential use cases based on domain expertise.
    What are your options? You can model known connections between drugs and diseases
    as a bipartite graph.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名数据科学家，你很可能没有生物医学背景，因此不能根据领域专业知识手动挑选新的潜在用例。你的选择有哪些？你可以将药物和疾病之间的已知联系建模为双部分图。
- en: Figure 11.2 shows a bipartite network of approved drugs and diseases. The relationships
    indicate existing applications of drugs for treating conditions. For example,
    aspirin can be used to treat headaches, Kawasaki disease, coronary artery disease,
    and hypertension.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2显示了批准的药物和疾病的双部分网络。这些关系表示药物在治疗条件方面的现有应用。例如，阿司匹林可以用来治疗头痛、川崎病、冠状动脉疾病和高血压。
- en: '![11-02](../../OEBPS/Images/11-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![11-02](../../OEBPS/Images/11-02.png)'
- en: Figure 11.2 Bipartite network of existing drugs and known treatments
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 现有药物和已知治疗的二分网络
- en: You could create a drug repurposing workflow by first determining similar drugs.
    The similarity between drugs is frequently calculated based on their chemical
    structure and the overlap of diseases they treat (Luo et al., 2016). Once similar
    drugs have been identified, you can use that information to predict or recommend
    new applications for existing drugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先确定相似药物来创建药物再利用工作流程。药物的相似性通常基于它们的化学结构和它们治疗的疾病重叠（Luo等，2016年）。一旦确定了相似药物，你可以使用这些信息来预测或推荐现有药物的新应用。
- en: 'The drug repurposing workflow shown in figure 11.3 has two steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3中所示的药物再利用工作流程有两个步骤：
- en: Identifying similar relationships
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别相似关系
- en: Recommending new drug applications based on drug similarity
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于药物相似性推荐新药应用
- en: '![11-03](../../OEBPS/Images/11-03.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![11-03](../../OEBPS/Images/11-03.png)'
- en: Figure 11.3 Predicting new drug applications based on drug similarity
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 基于药物相似性预测新药应用
- en: The first step is to identify similar drugs. For this exercise, one idea could
    be that the more common diseases are that two drugs treat, the higher the drug
    similarity between the two will be. There are several approaches you could take
    to infer the similarity relationship. You could use the Jaccard similarity coefficient,
    described in chapter 7, to calculate the drug similarity. Another idea would be
    to use a node embedding model like node2vec, presented in chapter 9, to calculate
    node embeddings and compare drugs using the cosine similarity of node embeddings.
    Finally, you could also borrow some of the link prediction features described
    in chapter 10 to calculate drug similarity. Using any of the mentioned approaches,
    you would create a similarity relationship with some sort of score between pairs
    of drugs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定相似药物。对于这个练习，一个想法可能是，两种药物治疗的常见疾病越多，它们之间的药物相似性就越高。你可以采取几种方法来推断相似关系。你可以使用第7章中描述的Jaccard相似系数来计算药物相似性。另一个想法是使用第9章中介绍的node2vec等节点嵌入模型来计算节点嵌入，并使用节点嵌入的余弦相似度来比较药物。最后，你也可以借鉴第10章中描述的一些链接预测特征来计算药物相似性。使用任何提到的方法，你都会在药物对之间创建某种形式的得分相似关系。
- en: In the second step, you could recommend new drug applications based on the calculated
    similarity relationships. In the example in figure 11.3, aspirin and eplerenone
    are tagged as similar drugs. Therefore, you could predict potential applications
    for eplerenone by examining which conditions drugs like aspirin treat. In this
    example, you might predict that eplerenone potentially could be used to treat
    Kawasaki disease and headaches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，你可以根据计算出的相似关系推荐新的药物应用。在图11.3的例子中，阿司匹林和依普利酮被标记为相似药物。因此，你可以通过检查阿司匹林等药物治疗的疾病来预测依普利酮的潜在应用。在这个例子中，你可能会预测依普利酮可能被用于治疗川崎病和头痛。
- en: Note Remember, the link prediction workflow only suggests the priority of evaluating
    new applications, while the domain experts then decide and potentially conduct
    clinical trials to determine new drug applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：记住，链接预测工作流程仅建议评估新应用的优先级，而领域专家随后决定并可能进行临床试验以确定新的药物应用。
- en: The described drug repurposing workflow is valid; however, with this approach,
    you would overlook a lot of existing biomedical knowledge. There is a lot of data
    about genes, biological processes, anatomy, and other biomedical information you
    could incorporate into your graph and, consequently, into drug repurposing analysis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的药物再利用工作流程是有效的；然而，采用这种方法，你会忽略很多现有的生物医学知识。关于基因、生物过程、解剖学以及其他生物医学信息的大量数据，你可以将其纳入你的图中，并因此纳入药物再利用分析中。
- en: Medical researchers have accrued a lot of knowledge over the years. There are
    many official medical databases you can borrow information from to construct a
    biomedical graph. For example, the graph schema in figure 11.4 contains several
    types of nodes, spanning from drugs to diseases to genes to side effects and many
    others. Additionally, there are several types of relationships present. Sometimes,
    multiple types of relationships are available between particular types of nodes.
    In figure 11.4, you can observe that a drug can either upregulate or downregulate
    a gene.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 医学研究人员多年来积累了大量知识。你可以从许多官方医学数据库中借用信息来构建生物医学图。例如，图 11.4 中的图架构包含多种类型的节点，从药物到疾病，再到基因和副作用，以及其他许多内容。此外，还存在多种类型的关系。有时，特定类型的节点之间可能存在多种类型的关系。在图
    11.4 中，你可以观察到一种药物可以上调或下调一个基因。
- en: '![11-04](../../OEBPS/Images/11-04.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![11-04](../../OEBPS/Images/11-04.png)'
- en: Figure 11.4 Example schema of a complex biomedical graph
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 复杂生物医学图的示例架构
- en: A complex biomedical graph is an example of a *heterogeneous graph*, where multiple
    node and relationship types are present. In a drug repurposing workflow, you could
    use all the available information in a biomedical graph to predict new `TREATS`
    relationships. However, since the graph schema is more complicated, it requires
    a different approach to feature engineering than those we’ve discussed. If you
    were inclined to perform a manual feature engineering workflow like the one described
    in chapter 10, you would need to find a way to encode various node and relationship
    types. For example, the number of common neighbors used in chapter 10 does not
    differentiate between various node and relationship types. A disease can upregulate
    or downregulate a gene, and you want to somehow encode them differently. Therefore,
    manual feature engineering would likely be tedious and labor intensive, while
    requiring domain expertise. While node embedding algorithms like the node2vec
    algorithm remove the need for manual feature engineering, they are not designed
    to differentiate between various node and relationship types. Luckily, you are
    not the first person to run into this problem. The solution to avoid manual feature
    engineering while having a model that differentiates between various node and
    relationship types is to use *knowledge graph embedding* models. Unlike node embedding
    models, knowledge graph embedding models encode nodes as well as relationships
    in the embedding space. The added benefit of encoding relationships in the embedding
    space is that the embedding model can learn to differentiate between different
    relationship types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂生物医学图是异构图的例子，其中存在多种节点和关系类型。在药物再利用工作流程中，你可以使用生物医学图中的所有可用信息来预测新的 `TREATS` 关系。然而，由于图架构更为复杂，它需要与我们所讨论的不同特征工程方法。如果你倾向于执行类似于第
    10 章中描述的手动特征工程工作流程，你需要找到一种方法来编码各种节点和关系类型。例如，第 10 章中使用的共同邻居数量并不能区分不同的节点和关系类型。一种疾病可以上调或下调一个基因，而你希望以某种方式将它们区分开来。因此，手动特征工程可能会很繁琐且劳动密集，同时需要领域专业知识。虽然节点嵌入算法（如
    node2vec 算法）消除了手动特征工程的需求，但它们并未设计用于区分不同的节点和关系类型。幸运的是，你不是第一个遇到这个问题的人。避免手动特征工程同时拥有能够区分不同节点和关系类型的模型的方法是使用
    *知识图谱嵌入* 模型。与节点嵌入模型不同，知识图谱嵌入模型在嵌入空间中编码节点以及关系。在嵌入空间中编码关系的额外好处是，嵌入模型可以学习区分不同的关系类型。
- en: 11.1 Knowledge graph embedding model
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 知识图谱嵌入模型
- en: As mentioned, the key difference between node embeddings and knowledge graph
    embedding models is that the latter embeds relationships as well as nodes. Before
    delving into theory, you need to familiarize yourself with knowledge graph embedding
    terminology.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，节点嵌入与知识图谱嵌入模型之间的关键区别在于后者不仅嵌入节点，还嵌入关系。在深入理论之前，你需要熟悉知识图谱嵌入术语。
- en: 11.1.1 Triple
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 三元组
- en: Knowledge graph embedding models use *triples* to describe graphs. A triple
    consists of two nodes, known as a *head* (h) and *tail* (t), and a labeled-directed
    relationship (r).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 知识图谱嵌入模型使用 *三元组* 来描述图。一个三元组由两个节点组成，称为 *头节点*（h）和 *尾节点*（t），以及一个带标签的有向关系（r）。
- en: Figure 11.5 shows a visualization of a sample graph on the left side and a triple
    representation of the same graph on the right. A triple consists of two nodes,
    a head (h) and tail (t), and a directed labeled relationship (r). The head node
    is the source or start node of the relationship, while the target or end node
    is marked as the tail node. In the example in figure 11.5, Ana is considered the
    head, while Paris is the tail node. The idea behind knowledge graph embeddings
    is to support heterogeneous graphs and differentiate between various types of
    relationships. Therefore, the relation label in a triple defines its type. The
    relation label in figure 11.5 is `LIVES_IN.`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5展示了左侧一个样本图的视觉化和右侧相同图的三角表示。一个三角由两个节点组成，一个头节点（h）和一个尾节点（t），以及一个有向标签关系（r）。头节点是关系的源节点或起始节点，而目标节点或结束节点被标记为尾节点。在图11.5的例子中，Ana被认为是头节点，而巴黎是尾节点。知识图嵌入背后的理念是支持异构图并区分不同类型的关系。因此，三角中的关系标签定义了其类型。图11.5中的关系标签是`LIVES_IN.`。
- en: '![11-05](../../OEBPS/Images/11-05.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![11-05](../../OEBPS/Images/11-05.png)'
- en: Figure 11.5 Triple representation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 三角表示
- en: Exercise 11.1
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.1
- en: Construct two triples to define your location. The first triple should contain
    information about the city you live in, while the second triple should connect
    your city to the country it belongs to. Choose the relation labels you find the
    most appropriate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构造两个三角来定义你的位置。第一个三角应包含关于你居住的城市的信息，而第二个三角应将你的城市与其所属的国家连接起来。选择你认为最合适的标签关系。
- en: Note The triple is defined to differentiate between various relationship types
    or labels. However, there is no explicit definition of node labels. Therefore,
    the knowledge graph embedding models do not explicitly differentiate between different
    node types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：三角被定义为区分不同关系类型或标签。然而，没有对节点标签的明确定义。因此，知识图嵌入模型没有明确区分不同的节点类型。
- en: 11.1.2 TransE
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 TransE
- en: '*TransE* (Bordes et al., 2013) is one of the earliest and most intuitive knowledge
    graph embedding models. The objective of the TransE method is to calculate low-dimensional
    vector representations, also known as *embeddings*, for all the nodes and relationships
    in the graph. The TransE method is frequently used to demonstrate knowledge graph
    embeddings, as it is simple to illustrate and relatively cheap to calculate.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*TransE*（Bordes等人，2013年）是最早且最直观的知识图嵌入模型之一。TransE方法的目标是为图中的所有节点和关系计算低维向量表示，也称为*嵌入*。TransE方法常用于展示知识图嵌入，因为它易于说明且相对容易计算。'
- en: Figure 11.6 shows the concept of encoding nodes and relationships in the embedding
    space. The key idea behind the TransE method is to encode nodes and relationships
    in the embedding space so that the embedding of the head plus relation should
    be close to the tail. In figure 11.6, you can observe that the embedding of the
    head node plus the embedding of the relationship is precisely equal to the embedding
    of the tail node.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6展示了在嵌入空间中编码节点和关系的概念。TransE方法背后的关键思想是在嵌入空间中编码节点和关系，使得头节点的嵌入加上关系的嵌入应该接近尾节点的嵌入。在图11.6中，你可以观察到头节点的嵌入加上关系的嵌入恰好等于尾节点的嵌入。
- en: '![11-06](../../OEBPS/Images/11-06.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![11-06](../../OEBPS/Images/11-06.png)'
- en: Figure 11.6 TransE encoding intuition
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 TransE编码直觉
- en: The TransE method tries to produce embeddings so that for every triple in the
    training set, it minimizes the distance between the sum of the head and the relationship
    to the tail embedding. This optimization score can be written as `h` `+` `r` `≈`
    `t`, as shown in figure 11.7\. On the other hand, if a relationship between the
    head and tail node does not exist, then the sum of head and relation embedding
    should not be close to the tail (`h` `+` `r` `!=` `t`). You can read more about
    the mathematical implementation in the original article (Bordes et al., 2013).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TransE方法试图生成嵌入，使得对于训练集中的每个三角，它最小化头节点和关系嵌入与尾节点嵌入之间的距离。这种优化分数可以写成`h` `+` `r` `≈`
    `t`，如图11.7所示。另一方面，如果头节点和尾节点之间不存在关系，那么头节点和关系嵌入的加和不应接近尾节点（`h` `+` `r` `!=` `t`）。你可以在原始文章（Bordes等人，2013年）中了解更多关于数学实现的细节。
- en: '![11-07](../../OEBPS/Images/11-07.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![11-07](../../OEBPS/Images/11-07.png)'
- en: Figure 11.7 TransE optimization metric
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 TransE优化指标
- en: 11.1.3 TransE limitations
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 TransE局限性
- en: While TransE implementation is simple and intuitive, it has some drawbacks.
    There are three categories of relationships you will use to evaluate the TransE
    method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 TransE 的实现简单直观，但它有一些缺点。你将使用三类关系来评估 TransE 方法。
- en: The first category of relationships is the *symmetric* relations. The triple
    data structure does not allow undirected relationships; however, a category of
    relationships could be treated as undirected. The undirected relationships are
    referred to as *symmetric* within the field of knowledge graph embedding models.
    Some example triple symmetric relationships are
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的第一类是 *对称* 关系。三元数据结构不允许无向关系；然而，一类关系可以被视为无向的。在知识图谱嵌入模型领域，无向关系被称为 *对称* 关系。一些对称关系的例子包括
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If Tomaž is a sibling of Blaž, then Blaž is also a sibling of Tomaž. There is
    no way around this simple fact. The question is, can TransE encode symmetric relationships?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Tomaž 是 Blaž 的兄弟姐妹，那么 Blaž 也是 Tomaž 的兄弟姐妹。这个简单的事实无法回避。问题是，TransE 是否可以编码对称关系？
- en: The TransE method produces a vector representation for each relationship type.
    Therefore, the `SIBLING` vector representation in figure 11.8 has the same direction
    in both instances. The problem is that a vector representation of the same relationship
    type cannot point in the opposite direction. One `SIBLING` vector points from
    the head to the tail node. However, the second `SIBLING` vector starts from the
    second node and has the same direction as the first `SIBLING` vector. Therefore,
    the second `SIBLING` vector does not and cannot point back to the first node.
    Consequently, TransE does not support symmetric relationships from a theoretical
    point of view.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: TransE 方法为每种关系类型生成一个向量表示。因此，图 11.8 中的 `SIBLING` 向量表示在两个实例中方向相同。问题是，相同类型的关系的向量表示不能指向相反方向。一个
    `SIBLING` 向量从头节点指向尾节点。然而，第二个 `SIBLING` 向量从第二个节点开始，方向与第一个 `SIBLING` 向量相同。因此，第二个
    `SIBLING` 向量不能也不能指向第一个节点。因此，从理论上看，TransE 不支持对称关系。
- en: '![11-08](../../OEBPS/Images/11-08.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![11-08](../../OEBPS/Images/11-08.png)'
- en: Figure 11.8 Encoding symmetric relationships with TransE
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 使用 TransE 编码对称关系
- en: 'The second category of relationships you will evaluate is the *composition*
    relations. One example of the composition relation is the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你将评估的第二类关系是 *组合* 关系。组合关系的一个例子如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A composition relationship can be constructed by combining two or more relationships.
    In the example in figure 11.9, the `FATHER` relationship can be composed by adding
    the `MOTHER` and `SPOUSE` relationships. You can observe that one can fit the
    relationship vectors to fit this graph pattern. Therefore, the TransE method supports
    composite relations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 组合关系可以通过组合两个或多个关系来构建。在图 11.9 的例子中，`FATHER` 关系可以通过添加 `MOTHER` 和 `SPOUSE` 关系来组合。你可以观察到，可以调整关系向量以适应这种图模式。因此，TransE
    方法支持组合关系。
- en: '![11-09](../../OEBPS/Images/11-09.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![11-09](../../OEBPS/Images/11-09.png)'
- en: Figure 11.9 Encoding composition relationships with TransE
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 使用 TransE 编码组合关系
- en: The last category is the *1-to-N* relationships. Essentially, this scenario
    happens when a node has the same relationship to multiple other nodes. Some examples
    of 1-to-N relations are
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类关系是 *1 到 N* 的关系。本质上，这种情况发生在节点与多个其他节点有相同关系时。1 到 N 关系的例子包括
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only way TransE could encode that Surya is friends with both Jane and Rajiv
    is if the vector representation of Jane and Rajiv is equal. Having the identical
    vector representation for Jane and Rajiv does not make sense, as they are different
    entities in the graph and, therefore, should have different embeddings. The only
    other solution would be that the `FRIEND` relationship vector would have different
    directions, as shown in figure 11.10\. However, the TransE method implements only
    a single vector representation for a given relationship type. Consequently, the
    TransE method does not support 1-to-N relationships.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TransE 能够编码 Surya 与 Jane 和 Rajiv 都是朋友的关系的唯一方式是 Jane 和 Rajiv 的向量表示相等。Jane 和 Rajiv
    有相同的向量表示在逻辑上是不合理的，因为它们在图中是不同的实体，因此应该有不同的嵌入。另一个解决方案将是 `FRIEND` 关系向量有不同的方向，如图 11.10
    所示。然而，TransE 方法仅实现给定关系类型的单个向量表示。因此，TransE 方法不支持 1 到 N 的关系。
- en: '![11-10](../../OEBPS/Images/11-10.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![11-10](../../OEBPS/Images/11-10.png)'
- en: Figure 11.10 Encoding 1-to-N relationships with TransE
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 使用 TransE 编码 1 到 N 的关系
- en: 11.2 Knowledge graph completion
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 知识图谱补全
- en: Now that you have gained a theoretical background in knowledge graph embeddings,
    you can continue with your task of predicting new applications for existing drugs.
    Imagine you work at a large pharmaceutical company that produces aspirin. Aspirin
    is a mass-produced drug, and therefore, a new application could rake in a lot
    of revenue. The idea is to use existing biomedical knowledge to predict new applications.
    You have determined that the best course of action would be to apply *knowledge
    graph completion* techniques to find new potential drug applications, also known
    as *drug repurposing*. Knowledge graph completion can be thought of as multiclass
    link prediction, where you predict new links and their types. You will train a
    knowledge graph embedding model to encode nodes and relationships in the biomedical
    graph and then use those embeddings to identify new potential applications for
    aspirin.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了知识图谱嵌入的理论背景，你可以继续进行预测现有药物新应用的任务。想象一下，你在一家大型制药公司工作，该公司生产阿司匹林。阿司匹林是一种大规模生产的药物，因此，一个新的应用可能会带来大量的收入。这个想法是利用现有的生物医学知识来预测新的应用。你已经确定，最佳的行动方案是应用**知识图谱补全**技术来寻找新的潜在药物应用，也称为**药物再利用**。知识图谱补全可以被视为多类链接预测，其中你预测新的链接及其类型。你将训练一个知识图谱嵌入模型来编码生物医学图中的节点和关系，然后使用这些嵌入来识别阿司匹林的新潜在应用。
- en: The drug repurposing workflow is shown in figure 11.11\. The basis of the whole
    flow is a rich and complex biomedical knowledge graph that contains existing drugs;
    their treatments; and other biomedical entities, like genes and pathways. As you
    are working for a large company, other great people at the company have already
    mapped and constructed the required biomedical graph. Next, you need to feed the
    biomedical graph into a knowledge graph embedding model. Since you won’t need
    to perform any graph transformations or manipulations, you can skip using a graph
    database altogether. While multiple Python libraries feature knowledge graph embedding
    models, I prefer *PyKEEN* (Ali et al., 2021) due to its simplicity and easy-to-use
    interface. Additionally, PyKEEN implements more than 40 different knowledge graph
    embedding models along with out-of-the-box support for hyperparameter optimization.
    Finally, you will use a built-in PyKEEN method to predict new applications for
    aspirin. You need to install the PyKEEN and pandas libraries, as shown in listing
    11.11, to follow along with the code examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 药物再利用工作流程如图 11.11 所示。整个流程的基础是一个丰富而复杂的生物医学知识图谱，其中包含现有的药物；它们的疗法；以及其他生物医学实体，如基因和通路。由于你为一家大型公司工作，公司里的其他优秀人士已经绘制并构建了所需的生物医学图。接下来，你需要将生物医学图输入到知识图谱嵌入模型中。由于你不需要执行任何图转换或操作，你可以完全跳过使用图数据库。虽然多个
    Python 库都提供了知识图谱嵌入模型，但我更喜欢 *PyKEEN*（Ali 等人，2021），因为它简单易用。此外，PyKEEN 实现了超过 40 种不同的知识图谱嵌入模型，并提供了开箱即用的超参数优化支持。最后，你将使用
    PyKEEN 内置的方法来预测阿司匹林的新应用。你需要安装 PyKEEN 和 pandas 库，如列表 11.11 所示，以跟随代码示例。
- en: '![11-11](../../OEBPS/Images/11-11.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![11-11](../../OEBPS/Images/11-11.png)'
- en: Figure 11.11 Drug repurposing workflow
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 药物再利用工作流程
- en: Listing 11.1 Installing PyKEEN
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 安装 PyKEEN
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the code is available as a Jupyter notebook ([http://mng.bz/zXNQ](http://mng.bz/zXNQ)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都作为 Jupyter 笔记本提供([http://mng.bz/zXNQ](http://mng.bz/zXNQ))。
- en: 11.2.1 Hetionet
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 Hetionet
- en: Your coworkers have prepared a subset of the Hetionet dataset (Himmelstein et
    al., 2017) to use. The original Hetionet dataset contains 47,031 nodes (11 types)
    and 2,250,197 relationships (24 types).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你的同事已经准备了一个 Hetionet 数据集的子集（Himmelstein 等人，2017）供使用。原始 Hetionet 数据集包含 47,031
    个节点（11 种类型）和 2,250,197 个关系（24 种类型）。
- en: The graph schema of the Hetionet dataset is presented in figure 11.12\. The
    graph contains various entities, like genes, pathways, compounds, and diseases.
    Additionally, there are 24 different types of relationships present in the graph.
    Explaining all the medical terminology behind medical entities and their relationships
    could take a whole book. The most important relationship for a drug repurposing
    workflow is the `TREATS` relationship that starts from the `Compound` node and
    ends at the `Disease` node. Essentially, the `TREATS` relationship encapsulates
    existing approved drug treatments. You will use knowledge graph completion techniques
    to predict new `TREATS` relationships originating from the aspirin or acetylsalicylic
    acid node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Hetionet 数据集的图架构在图 11.12 中展示。图中包含各种实体，如基因、通路、化合物和疾病。此外，图中还有 24 种不同类型的关系。解释所有医疗实体及其关系的医学术语可能需要一本书的篇幅。对于药物重新定位工作流程来说，最重要的关系是
    `TREATS` 关系，它从 `Compound` 节点开始，以 `Disease` 节点结束。本质上，`TREATS` 关系封装了现有的批准药物治疗方法。你将使用知识图谱补全技术来预测从阿司匹林或乙酰水杨酸节点起源的新
    `TREATS` 关系。
- en: '![11-12](../../OEBPS/Images/11-12.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![11-12](../../OEBPS/Images/11-12.png)'
- en: 'Figure 11.12 Hetionet schema (Source: Himmelstein et al. Licensed under CC
    BY 4.0)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 Hetionet 架构（来源：Himmelstein 等人。根据 CC BY 4.0 许可）
- en: You will use a subset of the Hetionet dataset in this example. The subset has
    the schema shown in figure 11.13.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将使用 Hetionet 数据集的一个子集。该子集的架构如图 11.13 所示。
- en: '![11-13](../../OEBPS/Images/11-13.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![11-13](../../OEBPS/Images/11-13.png)'
- en: Figure 11.13 Graph schema of the Hetionet subset that will be used in the drug
    repurposing workflow
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 将用于药物重新定位工作流程的 Hetionet 子集的图架构
- en: Figure 11.13 presents a subset of the Hetionet dataset you will use in the drug
    repurposing workflow. The given subset contains 22,634 nodes (3 types) and 561,716
    relationships (12 types). The graph contains existing approved drug treatments
    that can be found under the `TREATS` relationship, along with some additional
    information about how compounds and diseases interact with genes. The genes can
    also interact with other genes. The subset of the Hetionet dataset is available
    on GitHub ([http:// mng.bz/ddww](http://mng.bz/ddww)) and has the structure shown
    in table 11.1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 展示了你在药物重新定位工作流程中将使用的 Hetionet 数据集的一个子集。给定的子集包含 22,634 个节点（3 种类型）和 561,716
    条关系（12 种类型）。图中包含了在 `TREATS` 关系下可以找到的现有批准的药物治疗方法，以及一些关于化合物和疾病如何与基因相互作用的附加信息。基因也可以与其他基因相互作用。Hetionet
    数据集的子集可在 GitHub 上找到（[http:// mng.bz/ddww](http://mng.bz/ddww)），其结构如表 11.1 所示。
- en: Table 11.1 Structure of the Hetionet relationship CSV file
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 Hetionet 关系 CSV 文件的结构
- en: '| `source_name` | `source_label` | `target_name` | `target_label` | type |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `source_name` | `source_label` | `target_name` | `target_label` | type |'
- en: '| SERPINF2 | Gene | KLK13 | Gene | interacts |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| SERPINF2 | 基因 | KLK13 | 基因 | 相互作用 |'
- en: '| SERPINF2 | Gene | SSR1 | Gene | interacts |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| SERPINF2 | 基因 | SSR1 | 基因 | 相互作用 |'
- en: '| SERPINF2 | Gene | TGM2 | Gene | interacts |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| SERPINF2 | 基因 | TGM2 | 基因 | 相互作用 |'
- en: '| SERPINF2 | Gene | UBC | Gene | interacts |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| SERPINF2 | 基因 | UBC | 基因 | 相互作用 |'
- en: '| SERPINF2 | Gene | SERPINB12 | Gene | interacts |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| SERPINF2 | 基因 | SERPINB12 | 基因 | 相互作用 |'
- en: You will use the pandas library to load the CSV file from GitHub, shown in listing
    11.13, which first imports the pandas library. Next, it uses the built-in `read_csv`
    method to load the Hetionet dataset from GitHub.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 pandas 库从 GitHub 加载 CSV 文件，如列表 11.13 所示，首先导入 pandas 库。然后，它使用内置的 `read_csv`
    方法从 GitHub 加载 Hetionet 数据集。
- en: Listing 11.2 Loading the Hetionet subset as a pandas dataframe
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 将 Hetionet 子集作为 pandas 数据框加载
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 11.2.2 Dataset split
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 数据集拆分
- en: As with all machine learning workflows, you need to perform a test-train dataset
    split. You can feed a graph structure to PyKEEN with a list of triples, as shown
    in the following listing. Remember, the triple data object consists of head, label,
    and tail elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有机器学习工作流程一样，你需要执行测试-训练数据集拆分。你可以将图结构作为三元组列表输入 PyKEEN，如下所示。记住，三元组数据对象由头、标签和尾元素组成。
- en: Listing 11.3 Inputting triples to PyKEEN
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 向 PyKEEN 输入三元组
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `TriplesFactory` is a PyKEEN class designed to store triples used for training
    and evaluating the model. The code in listing 11.3 uses the `from_labeled_triples`
    method to input a list of triples from the pandas dataframe. The `data` dataframe
    contains additional information about node labels, which you need to filter out.
    Therefore, the code in listing 11.3 specifies using columns `source_name`, `type`,
    and `target_ name` as triples. Now that the triples are loaded into PyKEEN, you
    can perform a dataset split with the following code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TriplesFactory`是PyKEEN类，用于存储用于训练和评估模型的三元组。列表11.3中的代码使用`from_labeled_triples`方法从pandas
    dataframe输入三元组列表。`data` dataframe包含有关节点标签的附加信息，您需要过滤掉这些信息。因此，列表11.3中的代码指定使用`source_name`、`type`和`target_name`列作为三元组。现在，三元组已加载到PyKEEN中，您可以使用以下代码进行数据集分割。'
- en: Listing 11.4 Splitting the dataset into train, test, and validation sets
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 将数据集分割为训练集、测试集和验证集
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dataset split is performed with the `split` method, as demonstrated in listing
    11.4\. While the primary goal is to predict new `treats` relationships, the dataset,
    including all data splits, contains all available relationships, such as `interacts`,
    `upregulates`, and more, to provide as much relevant information to the model
    as possible. The method takes in an array of three values as a parameter that
    defines the ratio of the training, testing, and validation sets. The first value
    defines the ratio of the training set, the second value represents the testing
    set ratio, and the final number specifies the size of the validation set. The
    third value can be omitted, as it can be calculated from the first two.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集的分割是通过`split`方法进行的，如列表11.4所示。虽然主要目标是预测新的`treats`关系，但包括所有数据分割的数据集包含所有可用的关系，例如`interacts`、`upregulates`等，以便尽可能地为模型提供相关信息。该方法接受一个包含三个值的数组作为参数，该参数定义了训练集、测试集和验证集的比例。第一个值定义了训练集的比例，第二个值表示测试集的比例，最后一个数字指定了验证集的大小。第三个值可以省略，因为它可以从前两个值中计算得出。
- en: 11.2.3 Train a PairRE model
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 训练PairRE模型
- en: While the TransE model is great for an introduction to knowledge graph embedding
    models, it has its limitations. For example, a single drug can be used to treat
    multiple diseases. However, as mentioned in the TransE introduction, the TransE
    method cannot encode 1-to-N relationships, making it a lousy model for biomedical
    knowledge graphs. Therefore, you will use a later and better model called *PairRE*
    (Chao et al., 2020). PairRE is capable of encoding symmetry, composition, and
    1-to-N relationships, which makes it a great model to use for biomedical knowledge
    graphs. I encourage you to read the article at [https://arxiv.org/abs/2011.03798](https://arxiv.org/abs/2011.03798)
    if you are interested in details of the mathematical implementation. The following
    code trains the PairRE model based on the subset of the Hetionet dataset you were
    provided.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TransE模型对于知识图嵌入模型的入门非常出色，但它有其局限性。例如，一种药物可以用来治疗多种疾病。然而，如TransE介绍中提到的，TransE方法无法编码1-to-N关系，这使得它不适合生物医学知识图。因此，您将使用一个更晚且更好的模型，称为*PairRE*（Chao
    et al., 2020）。PairRE能够编码对称性、组合性和1-to-N关系，这使得它非常适合用于生物医学知识图。如果您对数学实现的细节感兴趣，请阅读[https://arxiv.org/abs/2011.03798](https://arxiv.org/abs/2011.03798)上的文章。以下代码基于您提供的Hetionet数据集的子集训练PairRE模型。
- en: Listing 11.5 Training a PairRE model
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 训练PairRE模型
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Specifies the PairRE model
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定PairRE模型
- en: ❷ Defines the stopping strategy
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义停止策略
- en: ❸ The random seed is set for reproducibility.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置随机种子以确保可重复性。
- en: The PairRE model can be trained with a single function, as shown in listing
    11.5\. The training, testing, and validation sets are loaded via separate arguments.
    You can select the model with the `model` argument; there are more than 40 models
    you can pick from. Check the documentation ([http://mng.bz/rj2y](http://mng.bz/rj2y))
    for a complete list of available models. The `early` value for the stopper argument
    evaluates the model every 10 epochs by default. Using the stopper option with
    the `early` value, the training pipeline stops the training if the model accuracy
    does not improve with additional epochs. Finally, the `random_seed` parameter
    is used to ensure result reproducibility. The complete list of available pipeline
    parameters is available in the official documentation ([http://mng.bz/0K86](http://mng.bz/0K86)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PairRE模型可以通过单个函数进行训练，如列表11.5所示。训练、测试和验证集通过单独的参数加载。您可以使用`model`参数选择模型；您可以选择超过40种模型。请检查文档（[http://mng.bz/rj2y](http://mng.bz/rj2y)）以获取可用模型的完整列表。`stopper`参数的`early`值默认情况下每10个epoch评估模型一次。使用带有`early`值的`stopper`选项，如果模型精度在额外的epoch中没有提高，训练管道将停止训练。最后，`random_seed`参数用于确保结果的可重复性。完整的可用管道参数列表可在官方文档（[http://mng.bz/0K86](http://mng.bz/0K86)）中找到。
- en: Note The training can be performed on either CPU or GPU devices. However, the
    training will be faster if you have a GPU device available. If you don’t have
    a local GPU available, you can always try out free cloud environments, like the
    Google Colab.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：训练可以在CPU或GPU设备上执行。然而，如果您有可用的GPU设备，训练将更快。如果您没有本地GPU可用，您始终可以尝试使用免费云环境，例如Google
    Colab。
- en: 11.2.4 Drug application predictions
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 药物应用预测
- en: With the PairRE model trained, you can predict new applications for acetylsalicylic
    acid, better known as aspirin. The PyKEEN library offers a `predict_target` function,
    which allows you to input the head and relation of a triple and output the predictions
    for the tail node. In your example, you input `acetylsalicylic` `acid` as the
    head and `treats` as the relation element, as shown in the following listing.
    The output of the most probable `tail` nodes is given in a pandas dataframe structure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练好PairRE模型后，您可以预测乙酰水杨酸（即阿司匹林）的新应用。PyKEEN库提供了一个`predict_target`函数，允许您输入三元组的头和关系，并输出尾节点的预测。在您的示例中，您将`acetylsalicylic`
    `acid`作为头，将`treats`作为关系元素输入，如下所示。最可能的`tail`节点输出以pandas数据框结构给出。
- en: Listing 11.6 Predicting new use cases for acetylsalicylic acid
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.6 预测乙酰水杨酸的新用例
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Table 11.2 shows the resulting predicted use cases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2显示了预测出的结果用例。
- en: Table 11.2 The top five predictions for acetylsalicylic acid
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 乙酰水杨酸的前五项预测
- en: '| `tail_id` | `tail_label` | `score` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `tail_id` | `tail_label` | `score` |'
- en: '| 19,912 | Systemic lupus erythematosus | −9.228726 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 19,912 | 系统性红斑狼疮 | −9.228726 |'
- en: '| 19,827 | Breast cancer | −9.510363 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 19,827 | 乳腺癌 | −9.510363 |'
- en: '| 19,913 | Systemic scleroderma | −9.543921 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 19,913 | 系统性硬化症 | −9.543921 |'
- en: '| 19,887 | Pancreatic cancer | −9.711681 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 19,887 | 胰腺癌 | −9.711681 |'
- en: '| 19,919 | Type 1 diabetes mellitus | −9.731101 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 19,919 | 1型糖尿病 | −9.731101 |'
- en: Predictions with a `score` value closer to zero are more probable. Your model
    predicted that aspirin potentially could be used to treat systemic lupus erythematosus,
    systemic scleroderma, and some forms of cancer. These predictions can be used
    to recommend a clinical trial for a particular drug use case. The clinical trials
    must be carefully planned, as they take a long time and are incredibly costly
    (Schlander et al., 2021). Therefore, it is essential to produce as accurate recommendations
    as possible, as the cost of clinical trials can reach more than a billion dollars.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分数值接近零的预测更可能。您的模型预测阿司匹林可能被用于治疗系统性红斑狼疮、系统性硬化症和某些类型的癌症。这些预测可用于推荐特定药物用例的临床试验。临床试验必须精心规划，因为它们耗时很长且成本极高（Schlander等，2021年）。因此，尽可能产生准确的建议至关重要，因为临床试验的成本可能超过十亿美元。
- en: Exercise 11.2
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.2
- en: Predict potential new applications for `Caffeine` with the `predict_target`
    function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`predict_target`函数预测`咖啡因`的潜在新应用。
- en: 11.2.5 Explaining predictions
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 解释预测
- en: After the predictions have been made, you can search the medical literature
    for supporting or invalidating research. Again, the importance of including a
    domain expert in the process cannot be overstated, as they play a critical role
    in interpreting both the results and relevant medical literature. For example,
    if you search for a combination of aspirin and pancreatic cancer, you can find
    some articles that might validate your predictions (Sun et al., 2019). Given that
    the Hetionet article was published in 2017, it probably does not contain new medical
    information from 2019\. Hetionet is an aging resource that was restricted to fewer
    than 200 diseases. In practice, pharmaceutical and other companies use various
    text-mining systems deployed at scale to extract knowledge from various medical
    research articles and trials to keep their biomedical graphs updated with all
    the latest available information (Bachman et al., 2022).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预测完成后，您可以在医学文献中搜索支持或反驳的研究。再次强调，在过程中包括领域专家的重要性不容忽视，因为他们对解释结果和相关的医学文献都起着关键作用。例如，如果您搜索阿司匹林和胰腺癌的组合，您可能会找到一些可能验证您预测的文章（Sun
    等人，2019 年）。鉴于 Hetionet 文章是在 2017 年发表的，它可能不包含 2019 年的新医学信息。Hetionet 是一个逐渐老化的资源，仅限于不到
    200 种疾病。在实践中，制药和其他公司使用各种大规模部署的文本挖掘系统从各种医学研究文章和试验中提取知识，以保持其生物医学图更新至所有最新可用信息（Bachman
    等人，2022 年）。
- en: Having supporting evidence for your predictions shows that the method of using
    knowledge graph embedding models for knowledge graph completion can yield great
    results. Suppose you found no supporting literature for your predictions. In that
    case, you could present existing biomedical connections to domain experts and
    let them decide whether they hold any merit. Even though you didn’t need a graph
    database for the drug repurposing workflow, it would still be great for explaining
    predictions. Luckily, your coworkers at the large pharmaceutical company have
    you covered, or in reality, the authors of the Hetionet have made it available
    through a read-only Neo4j Browser interface. The Hetionet browser interface is
    available at [https://neo4j.het.io/browser/](https://neo4j.het.io/browser/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您的预测有支持证据表明，使用知识图嵌入模型进行知识图补全的方法可以产生很好的结果。假设您没有找到支持您预测的文献。在这种情况下，您可以将现有的生物医学连接展示给领域专家，让他们决定这些连接是否有价值。尽管您不需要图数据库进行药物再利用工作流程，但它仍然可以很好地解释预测。幸运的是，您在大型制药公司的同事已经为您解决了这个问题，或者更确切地说，Hetionet
    的作者已经通过只读 Neo4j 浏览器界面使其可用。Hetionet 浏览器界面可在 [https://neo4j.het.io/browser/](https://neo4j.het.io/browser/)
    找到。
- en: The following Cypher query will visualize the first 25 paths between acetylsalicylic
    acid and pancreatic cancer that are up to three hops away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Cypher 查询将可视化乙酰水杨酸与胰腺癌之间距离不超过三个跳的第一条 25 条路径。
- en: Listing 11.7 Predicting new potential use cases for acetylsalicylic acid
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 预测乙酰水杨酸的新潜在用途
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Cypher statement in listing 11.7 produces the visualization in figure 11.14\.
    On the left side of the figure, you will see `acetylsalicylic` `acid`, while `prostate`
    `cancer` is on the right. Acetylsalicylic acid can be used to palliate osteoarthritis
    and gout. Interestingly, osteoarthritis associates with genes similar to those
    of prostate cancer. In any case, a domain expert can evaluate existing connections
    and make up their own mind. There are 1,716 distinct paths with a length of up
    to three hops between acetylsalicylic acid and pancreatic cancer. Therefore, it
    is hard to visualize them all in a single image, and a domain expert could prioritize
    connections based on node or relationship types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 中的 Cypher 语句生成了图 11.14 中的可视化。在图的左侧，您将看到 `乙酰水杨酸`，而 `前列腺癌` 在右侧。乙酰水杨酸可用于缓解骨关节炎和痛风。有趣的是，骨关节炎与类似前列腺癌的基因相关。无论如何，领域专家可以评估现有连接并形成自己的观点。乙酰水杨酸与胰腺癌之间有
    1,716 条不同的路径，长度不超过三个跳。因此，很难在单个图像中可视化所有这些路径，领域专家可以根据节点或关系类型优先考虑连接。
- en: '![11-14](../../OEBPS/Images/11-14.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![11-14](../../OEBPS/Images/11-14.png)'
- en: Figure 11.14 Existing connections between acetylsalicylic acid and pancreatic
    cancer
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 乙酰水杨酸与胰腺癌之间的现有连接
- en: Exercise 11.3
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.3
- en: Visualize the first 25 paths with a length of up to three hops between acetylsalicylic
    acid and autistic disorder. Use the existing Neo4j version of the Hetionet graph,
    which is available through Neo4j Browser at [https://neo4j.het.io/browser/](https://neo4j.het.io/browser/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化水杨酸和自闭症之间最多三跳的25条路径。使用现有的Neo4j版本的Hetionet图，该图可通过Neo4j浏览器在[https://neo4j.het.io/browser/](https://neo4j.het.io/browser/)访问。
- en: 11.3 Solutions to exercises
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 练习的解决方案
- en: One possible solution to exercise 11.1 is as follows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.1的一个可能解决方案如下。
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The solution to exercise 11.2 is as follows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.2的解决方案如下。
- en: Listing 11.8 Predicting new use cases for caffeine
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 预测咖啡因的新用途
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The solution to exercise 11.3 is as follows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.3的解决方案如下。
- en: Listing 11.9 Visualizing the first 25 paths with a length of up to three hops
    between acetylsalicylic acid and autistic disorder
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 可视化水杨酸和自闭症之间最多三跳的25条路径
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A heterogeneous or multipartite graph consists of multiple node and relationship
    types. There could also be numerous relationship types between two entity types.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异构图或多部分图由多种节点和关系类型组成。两个实体类型之间也可能存在多种关系类型。
- en: A triple data object is used to represent directed graphs, where multiple relationship
    types are present.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元数据对象用于表示存在多种关系类型的有向图。
- en: A triple data object consists of head, relation, and tail elements.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元数据对象由头元素、关系元素和尾元素组成。
- en: Knowledge graph embedding models encode nodes and relationships in the embedding
    space, as opposed to node embedding models that only encode nodes.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知识图谱嵌入模型在嵌入空间中编码节点和关系，这与仅编码节点的节点嵌入模型不同。
- en: Knowledge graph embedding models try to calculate embedding in such a way that
    for every existing triple, the sum of embeddings of head and relation are close
    to the embedding of the tail node.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知识图谱嵌入模型试图以这种方式计算嵌入，即对于每个现有的三元组，头节点和关系嵌入的总和接近尾节点的嵌入。
- en: Knowledge graph embedding models are evaluated from a theoretical perspective
    if they can encode symmetry, inverse, composite, and 1-to-N relationships.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果知识图谱嵌入模型能够编码对称性、逆关系、复合关系和1对N关系，则从理论角度评估知识图谱嵌入模型。
- en: PairRE models can encode all four categories (symmetry, inverse, composite,
    and 1-to-N) of different relationships.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PairRE模型可以编码所有四种关系类别（对称性、逆关系、复合关系和1对N关系）。
- en: Knowledge graph completion can be thought of as a multiclass link prediction
    problem, where you are predicting new links and their type.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将知识图谱补全视为一个多类链接预测问题，其中你正在预测新的链接及其类型。
- en: In a drug repurposing workflow, the predictions must be evaluated by domain
    experts and then go through clinical trials to be approved. Knowledge graph completion
    is only used to prioritize the most likely candidates.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在药物再利用的工作流程中，预测必须由领域专家评估，然后通过临床试验才能获得批准。知识图谱补全仅用于优先考虑最有可能的候选者。
