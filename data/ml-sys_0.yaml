- en: Part 1\. Fundamentals of reactive machine learning
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分\. 反应式机器学习基础
- en: 'Reactive machine learning brings together several different areas of technology,
    and this part of the book is all about making sure you’re sufficiently oriented
    in all of them. Throughout this book, you’ll be looking at and building machine
    learning systems, starting with [chapter 1](kindle_split_011.html#ch01). If you
    don’t have experience with machine learning, it’s important to be familiar with
    some of the basics of how it works. You’ll also get a flavor for all of the problems
    with how machine learning systems are often built in the real world. With this
    knowledge in hand, you’ll be ready for another big topic: reactive systems design.
    Applying the techniques of reactive systems design to the challenges of building
    machine learning systems is the core topic of this book.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式机器学习结合了几个不同的技术领域，这本书的这一部分是确保你在所有这些领域都有足够的了解。在整个书中，你将查看和构建机器学习系统，从[第1章](kindle_split_011.html#ch01)开始。如果你没有机器学习经验，了解一些它如何工作的基础知识是很重要的。你还将了解机器学习系统在现实世界中构建时遇到的所有问题。有了这些知识，你将准备好学习另一个重要主题：反应式系统设计。将反应式系统设计的技巧应用于构建机器学习系统的挑战是本书的核心主题。
- en: 'After you’ve had an overview of *what* you’re going to do in this book, [chapter
    2](kindle_split_012.html#ch02) focuses on *how* you’ll do it. The chapter introduces
    three technologies that you’ll use throughout the book: the Scala programming
    language, the Akka toolkit, and the Spark data-processing library. These are powerful
    technologies that you can only begin to learn in a single chapter. The rest of
    the book will go deeper into how to use them to solve real problems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对本书将要做什么有一个概述之后，[第2章](kindle_split_012.html#ch02)将专注于*如何*去做。本章介绍了你将在整本书中使用的三种技术：Scala编程语言、Akka工具包和Spark数据处理库。这些是强大的技术，你只能在单章中开始学习。本书的其余部分将更深入地探讨如何使用它们来解决实际问题。
- en: Chapter 1\. Learning reactive machine learning
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章\. 学习反应式机器学习
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing the components of machine learning systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍机器学习系统的组件
- en: Understanding the reactive systems design paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解反应式系统设计范式
- en: The reactive approach to building machine learning systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建机器学习系统的反应式方法
- en: This book is all about how to build *machine learning systems*, which are sets
    of software components capable of learning from data and making predictions about
    the future. This chapter discusses the challenges of building machine learning
    systems and offers some approaches to overcoming those challenges. The example
    we’ll look at is of a startup that tries to build a machine learning system from
    the ground up and finds it very, very hard.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书全部关于如何构建*机器学习系统*，这些系统是一系列能够从数据中学习并预测未来的软件组件。本章讨论了构建机器学习系统所面临的挑战，并提供了一些克服这些挑战的方法。我们将研究的例子是一个从头开始尝试构建机器学习系统的初创公司，发现这非常、非常困难。
- en: If you’ve never built a machine learning system before, you may find it challenging
    and a bit confusing. My goal is to take some of the pain and mystery out of this
    process. I won’t be able to teach you everything there is to know about the techniques
    of machine learning; that would take a mountain of books. Instead, we’ll focus
    on how to build a system that can put the power of machine learning to use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未构建过机器学习系统，你可能会觉得这很有挑战性，也有些令人困惑。我的目标是减少这个过程的一些痛苦和神秘感。我无法教你关于机器学习技术的一切知识；那需要一大堆书籍。相反，我们将专注于如何构建一个能够利用机器学习力量的系统。
- en: I’ll introduce you to a fundamentally new and better way of building machine
    learning systems called *reactive machine learning*. Reactive machine learning
    represents the marriage of ideas from reactive systems and the unique challenges
    of machine learning. By understanding the principles that govern these systems,
    you’ll see how to build systems that are more capable, both as software and as
    predictive systems. This chapter will introduce you to the motivating ideas behind
    this approach, laying a foundation for the techniques you’ll learn in the rest
    of the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你介绍一种全新的、更好的构建机器学习系统的方法，称为*反应式机器学习*。反应式机器学习代表了反应式系统和机器学习独特挑战的结合。通过理解这些系统所遵循的原则，你将了解如何构建在软件和预测系统方面都更强大的系统。本章将介绍这种方法的动机思想，为你在本书其余部分学习的技术打下基础。
- en: 1.1\. An example machine learning system
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 一个机器学习系统的例子
- en: Consider the following scenario. Sniffable is “Facebook for dogs.” It’s a startup
    based out of a dog-filled loft in New York. Using the Sniffable app, dog owners
    post pictures of their dogs, and other dog owners like, share, and comment on
    those pictures. The network was growing well, and the team felt there might be
    a meteoric opportunity here. But if Sniffable was really going to take off, it
    was clear that they’d have to build more than just the standard social-networking
    features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景。Sniffable是“狗狗的Facebook”。它是一家位于纽约充满狗狗的阁楼中的初创公司。使用Sniffable应用程序，狗主人发布他们狗狗的照片，其他狗主人会点赞、分享和评论这些照片。这个网络正在良好地增长，团队觉得这里可能有一个爆炸性的机会。但如果Sniffable真的要起飞，很明显，他们必须构建的不仅仅是标准的社交网络功能。
- en: 1.1.1\. Building a prototype system
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 构建原型系统
- en: Sniffable users, called *sniffers*, are all about promoting their specific dog.
    Many sniffers hope that their dog will achieve canine celebrity status. The team
    had an idea that what sniffers really wanted were tools to help make their posts,
    called *pupdates*, more viral. Their initial concept for the new feature was a
    sort of competitive intelligence tool for the canine equivalent of stage moms,
    internally known as *den mothers*. The belief was that den mothers were taking
    many pictures of their dogs and were trying to figure out which picture would
    get the biggest response on Sniffable. The team intended the new tool to predict
    the number of likes a given pupdate might get, based on the hashtags used. They
    named the tool *Pooch Predictor*. It was their hope that it would engage the den
    mothers, help them create viral content, and grow the Sniffable network as a whole.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可嗅闻的用户，被称为*嗅探者*，他们的一切都是为了推广他们特定的狗。许多嗅探者希望他们的狗能够达到犬类名人的地位。团队有一个想法，那就是嗅探者真正想要的是帮助他们的帖子，称为*pupdates*，更具病毒性的工具。他们为新功能设计的初步概念是一种针对犬类舞台妈妈的竞争情报工具，内部称为*犬窝妈妈*。他们相信犬窝妈妈们拍摄了很多关于他们狗的照片，并试图找出哪张照片会在Sniffable上获得最大的反响。团队打算用这个新工具预测某个pupdate可能会获得的点赞数，基于使用的标签。他们把这个工具命名为*Pooch
    Predictor*。他们希望这个工具能够吸引犬窝妈妈们，帮助他们创造病毒性内容，并整体上扩大Sniffable网络。
- en: The team turned to their lone data scientist to get this product off the ground.
    The initial spec for the minimal viable product was pretty fuzzy, and the data
    scientist was already a pretty busy guy—he was the entire data science department,
    after all. Over the course of several weeks, he stitched together a system that
    looked something like [figure 1.1](#ch01fig01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 团队转向他们唯一的数据科学家，以启动这个产品。最小可行产品的初步规格相当模糊，而数据科学家已经非常忙碌——毕竟，他是整个数据科学部门。在接下来的几周里，他构建了一个看起来像[图1.1](#ch01fig01)的系统。
- en: Figure 1.1\. Pooch Predictor 1.0 architecture
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1. Pooch Predictor 1.0架构
- en: '![](01fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![01fig01_alt.jpg](01fig01_alt.jpg)'
- en: The app already sent all raw user-interaction data to the application’s relational
    database, so the data scientist decided to start building his model with that
    data. He wrote a simple script that dumped the data he wanted to flat files. Then
    he processed that interaction data using a different script to produce derived
    representations of the data, the features, and the concepts. This script produced
    a structured representation of a pupdate, the number of likes it got, and other
    relevant data such as the hashtags associated with the post. Again, this script
    just dumped its output to flat files. Then he ran his model-learning algorithm
    over his files to produce a model that predicted likes on posts, given the hashtags
    and other data about the post.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经将所有原始用户交互数据发送到应用程序的关系数据库中，因此数据科学家决定从这些数据开始构建他的模型。他编写了一个简单的脚本来将所需的数据导出到平面文件。然后，他使用另一个脚本处理这些交互数据，以产生数据的派生表示，即特征和概念。这个脚本产生了一个pupdate的结构化表示，它获得的点赞数，以及其他相关数据，如与帖子相关的标签。同样，这个脚本只是将输出导出到平面文件。然后，他在文件上运行他的模型学习算法，以产生一个模型，该模型根据标签和其他关于帖子的数据预测点赞数。
- en: The team was thoroughly amazed by this prototype of a predictive product, and
    they pushed it through the engineering roadmap to get it out the door as soon
    as possible. They assigned a junior engineer the job of taking the data scientist’s
    prototype and getting it running as a part of the overall system. The engineer
    decided to embed the data scientist’s model directly into the app’s post-creation
    code. That made it easy to display the predicted number of likes in the app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 团队对这个预测产品的原型感到非常惊讶，他们推动它通过工程路线图，尽快将其推出。他们指派一位初级工程师负责将数据科学家的原型整合到整个系统中运行。工程师决定直接将数据科学家的模型嵌入到应用程序的创建后代码中。这使得在应用程序中显示预测的点赞数变得容易。
- en: A few weeks after Pooch Predictor went live, the data scientist happened to
    notice that the predictions weren’t changing much, so he asked the engineer about
    the retraining frequency of the modeling pipeline. The engineer had no idea what
    the data scientist was talking about. They eventually figured out that the data
    scientist had intended his scripts to be run on a daily basis over the latest
    data from the system. Every day there should be a new model in the system to replace
    the old one. These new requirements changed how the system needed to be constructed,
    resulting in the architecture shown in [figure 1.2](#ch01fig02).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pooch Predictor上线几周后，数据科学家偶然注意到预测结果变化不大，于是他询问工程师关于建模管道的重新训练频率。工程师对数据科学家所说的内容毫无头绪。他们最终弄清楚数据科学家原本打算让他的脚本每天基于系统最新的数据运行。每天系统中都应该有一个新的模型来替换旧的模型。这些新的要求改变了系统构建的方式，导致了[图1.2](#ch01fig02)所示的架构。
- en: Figure 1.2\. Pooch Predictor 1.1 architecture
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2. Pooch Predictor 1.1架构
- en: '![](01fig02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2](01fig02.jpg)'
- en: In this version of Pooch Predictor, the scripts were run on a nightly basis,
    scheduled by cron. They still dumped their intermediate results to files, but
    now they needed to insert their models into the application’s database. And now
    the backend server was responsible for producing the predictions displayed in
    the app. It would pull the model out of the database and use it to provide predictions
    to the app’s users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的Pooch Predictor中，脚本每晚通过cron计划运行。它们仍然将中间结果输出到文件中，但现在它们需要将模型插入到应用程序的数据库中。现在后端服务器负责生成应用程序中显示的预测。它会从数据库中提取模型，并使用它为应用程序的用户提供预测。
- en: This new system was definitely better than the initial version, but in its first
    several months of operation, the team discovered several pain points with it.
    First of all, Pooch Predictor wasn’t very reliable. Often something would change
    in the database, and one of the queries would fail. Other times there would be
    high load on the server, and the modeling job would fail. This was happening more
    and more as both the size of the social network and the size of the dataset used
    by the modeling system increased. One time, the server that was supposed to be
    running the data-processing job failed, and all the relevant data was lost. These
    sorts of failures were hard to detect without building up a more sophisticated
    monitoring and alerting infrastructure. But even if someone did detect a failure
    in the system, there wasn’t much that could be done other than kick off the job
    again and hope it succeeded this time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新系统无疑比初始版本要好，但在其运营的前几个月里，团队发现了几个与之相关的痛点。首先，Pooch Predictor并不非常可靠。经常数据库中会有变化，导致某个查询失败。有时服务器负载很高，建模任务会失败。随着社交网络和建模系统所使用的数据集规模的增加，这种情况越来越多。有一次，应该运行数据处理任务的服务器失败了，所有相关数据都丢失了。这种类型的故障在没有建立更复杂的监控和警报基础设施的情况下很难检测到。即使有人检测到系统中的故障，除了再次启动任务并希望这次成功之外，也没有什么可以做的。
- en: Besides these big system-level failures, the data scientist started to find
    other problems in Pooch Predictor. Once he got at the data, he realized that some
    of the features weren’t being correctly extracted from the raw data. It was also
    really hard to understand how a change to the features that were being extracted
    would impact modeling performance, so he felt a little blocked from making improvements
    to the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些大的系统级故障之外，数据科学家开始在Pooch Predictor中找到其他问题。一旦他获得了数据，他就意识到一些特征没有被正确地从原始数据中提取出来。要理解提取的特征的变化如何影响建模性能也非常困难，因此他感觉在改进系统方面有些受阻。
- en: There was also a major issue that ended up involving the entire team. For a
    period of a couple of weeks, the team saw their interaction rates steadily trend
    down with no real explanation. Then someone noticed a problem with Pooch Predictor
    while testing on the live version of the app. For the pupdates of users who were
    based outside the United States, Pooch Predictor would always predict a negative
    number of likes. In forums around the internet, disgruntled users were voicing
    their rage at having the adorableness of their particular dog insulted by the
    Pooch Predictor feature. Once the Sniffable team detected the issue, they were
    able to quickly figure out that it was a problem with the modeling system’s location-based
    features. The data scientist and engineer came up with a fix, and the issue went
    away, but only after having their credibility seriously damaged among sniffers
    located abroad.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重大问题涉及到整个团队。在接下来的几周里，团队看到他们的互动率稳步下降，但没有找到任何合理的解释。然后有人在测试应用的实时版本时注意到了 Pooch
    Predictor 的问题。对于基于美国以外的用户，Pooch Predictor 总是预测一个负数的点赞数。在互联网上的论坛中，愤怒的用户表达了对他们的爱犬被
    Pooch Predictor 功能侮辱的不满。一旦 Sniffable 团队检测到这个问题，他们能够迅速找出这是建模系统基于位置的功能问题。数据科学家和工程师提出了一个解决方案，问题得以解决，但他们的信誉在国外嗅探器中受到了严重损害。
- en: Shortly after that, Pooch Predictor ran into more problems. It started with
    the data scientist implementing more feature-extraction functionality in an attempt
    to improve modeling performance. To do that, he got the engineer’s help to send
    more data from the user app back to the application database. On the day the new
    functionality rolled out, the team saw immediate issues. For one thing, the app
    slowed down dramatically. Posting was now a very laborious process—each button
    tap seemed to take several seconds to register. Sniffers became seriously irritated
    with these issues. Things went from bad to worse when Pooch Predictor began to
    cause yet more problems with posting. It turned out that the new functionality
    caused exceptions to be thrown on the server, which led to pupdates being dropped.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后不久，Pooch Predictor 遇到了更多问题。这一切始于数据科学家为了提高建模性能而尝试实现更多的特征提取功能。为了做到这一点，他得到了工程师的帮助，将更多来自用户应用的数据发送回应用程序数据库。在新功能推出当天，团队立即发现了问题。首先，应用速度大幅下降。现在发布内容成了一个极其费力的过程——每个按钮点击似乎需要几秒钟才能注册。嗅探器对这些问题感到非常烦恼。当
    Pooch Predictor 开始在发布方面引起更多问题时，情况变得更糟。结果发现，新功能导致服务器抛出异常，这导致 pupdates 被丢弃。
- en: 'At this point, it was all hands on deck in a furious effort to put out this
    fire. They realized that there were two major issues with the new functionality:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，大家都在全力以赴地扑灭这场大火。他们意识到新功能存在两个主要问题：
- en: Sending the data from the app back to the server required a transaction. When
    the data scientist and engineer added more data to the total amount of data being
    collected for modeling, this transaction took way too long to maintain reasonable
    responsiveness within the app.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用中的数据发送回服务器需要事务处理。当数据科学家和工程师将更多数据添加到用于建模的数据总量中时，这个事务处理过程耗时过长，无法在应用中保持合理的响应速度。
- en: The prediction functionality within the server that supported the app didn’t
    handle the new features properly. The server would throw an exception every time
    the prediction functionality saw any of the new features that had been added in
    another part of the application.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持该应用的服务器内的预测功能没有正确处理新特性。每当预测功能看到应用另一部分添加的新特性时，服务器都会抛出异常。
- en: After understanding where things had gone wrong, the team quickly rolled back
    all of the new functionality and restored the app to a normal operational state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解问题出在哪里之后，团队迅速回滚了所有新功能，并将应用恢复到正常操作状态。
- en: 1.1.2\. Building a better system
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 构建一个更好的系统
- en: 'Everyone on the team agreed that something was wrong with the way they were
    building their machine learning system. They held a retrospective to figure out
    what went wrong and determine how they were going to do better in the future.
    The outcome was the following vision for what a Pooch Predictor replacement needed
    to look like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 团队中的每个人都认为他们在构建机器学习系统的方式上出了问题。他们举行了一次回顾会议，以找出问题所在，并确定未来如何做得更好。结果是以下关于 Pooch
    Predictor 替代品的愿景：
- en: The Sniffable app must remain responsive, regardless of any other problems with
    the predictive system.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论预测系统存在任何其他问题，Sniffable应用都必须保持响应。
- en: The predictive system must be considerably less tightly coupled to the rest
    of the systems.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测系统必须与系统其他部分的耦合程度大大降低。
- en: The predictive system must behave predictably regardless of high load or errors
    in the system itself.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论系统负载高或系统本身存在错误，预测系统都必须表现出可预测的行为。
- en: It should be easier for different developers to make changes to the predictive
    system without breaking things.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该让不同的开发者更容易地对预测系统进行更改，而不会破坏系统。
- en: The code must use different programming idioms that ensure better performance
    when used consistently.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码必须使用不同的编程风格，以确保在持续使用时性能更佳。
- en: The predictive system must measure its modeling performance better.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测系统必须更好地衡量其建模性能。
- en: The predictive system should support evolution and change.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测系统应该支持演变和变化。
- en: The predictive system should support online experimentation.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测系统应该支持在线实验。
- en: It should be easy for humans to supervise the predictive system and rapidly
    correct any rogue behavior.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该让人类能够监督预测系统，并迅速纠正任何异常行为。
- en: 1.2\. Reactive machine learning
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 反应式机器学习
- en: In the previous example, it seems like the Sniffable team missed something big,
    right? They built what initially looked like a useful machine learning system
    that added value to their core product. But all the issues they experienced in
    getting there obviously had a cost. Production issues with their machine learning
    system frequently pulled the team away from work on improvements to the capability
    of the system. Even though they had a bunch of smart people in the room thinking
    hard about how to predict the dynamics of dog-based social networking, their system
    repeatedly failed at its mission.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，Sniffable团队似乎错过了什么重要的事情，对吧？他们构建了一个最初看起来很有用的机器学习系统，为他们的核心产品增加了价值。但他们在实现过程中遇到的所有问题显然都有代价。他们机器学习系统的生产问题经常使团队从改进系统功能的工作中分心。尽管房间里有一群聪明的人正在努力思考如何预测基于狗的社会网络的动态，但他们的系统反复未能完成其任务。
- en: 1.2.1\. Machine learning
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 机器学习
- en: Building machine learning systems that do what they’re supposed to do is *hard*,
    but not impossible. In our example story, the data scientist knew how to *do*
    machine learning. Pooch Predictor totally worked on his laptop; it made predictions
    from data. But the data scientist wasn’t thinking of machine learning as an *application*—he
    only understood machine learning as a *technique*. Pooch Predictor didn’t consistently
    produce trustable, accurate predictions. It was a failure both as a predictive
    system and as a piece of software.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构建能够完成预期任务的机器学习系统是**困难的**，但并非不可能。在我们的示例故事中，数据科学家知道如何**做**机器学习。Pooch Predictor在他的笔记本电脑上完全工作；它从数据中做出预测。但数据科学家并没有将机器学习视为**应用**——他只理解机器学习作为一种**技术**。Pooch
    Predictor并没有持续地产生可信、准确的预测。它作为一个预测系统和软件都失败了。
- en: This book will show you how to build machine learning systems that are just
    as awesome as the best web and mobile applications. But understanding how to build
    these systems will require you to think of machine learning as an application,
    and not merely as a technique. The systems that we’ll build won’t fail at their
    missions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将向您展示如何构建与最佳Web和移动应用一样出色的机器学习系统。但理解如何构建这些系统需要您将机器学习视为应用，而不仅仅是技术。我们将构建的系统不会在其任务上失败。
- en: In the next section, we’ll get into the reactive approach to building machine
    learning systems. But first I want to clarify what a machine learning system is
    and how it differs from merely using machine learning as a technique. To do so,
    I’ll have to introduce some terminology. If you have experience with machine learning,
    some of this might seem basic, but bear with me. Terms related to machine learning
    can be pretty inconsistently defined and used, so I want to be explicit about
    what we’re talking about.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨构建机器学习系统的反应式方法。但首先，我想明确什么是机器学习系统，以及它与仅仅将机器学习作为一种技术使用有何不同。为此，我必须介绍一些术语。如果你有机器学习的经验，其中一些可能看起来很基础，但请耐心听我说。与机器学习相关的术语定义和使用可能相当不一致，所以我想要明确我们正在讨论的内容。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Functionality vs. implementation**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能性与实现**'
- en: This brief introduction is only focused on ensuring that you’re sufficiently
    oriented in terms of the *functionality* of a machine learning system. This book
    is focused on the *implementation* of machine learning systems, not on the fundamentals
    of machine learning itself. Should you find yourself needing a better introduction
    to the techniques and algorithms used in machine learning, I recommend reading
    *Real-World Machine Learning* by Henrik Brink, Joseph W. Richards, and Mark Fetherolf
    (Manning, 2016).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这简短的介绍仅关注确保你在机器学习系统*功能*方面有足够的定位。本书专注于机器学习系统的*实现*，而不是机器学习本身的原理。如果你发现自己需要更好的机器学习技术和算法的介绍，我推荐阅读Henrik
    Brink、Joseph W. Richards和Mark Fetherolf合著的《Real-World Machine Learning》（Manning，2016）。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At its simplest, machine learning is a technique for learning from and making
    predictions on data. At a minimum, to *do* machine learning, you must take some
    data, learn a model, and use that model to make predictions. Using this definition,
    we can imagine an even cruder form of the Pooch Predictor example. It could be
    a program that queries the application database for the most popular breed of
    dog (French Bulldogs, it turns out) and tells the app to say that all posts containing
    a French Bulldog will get a lot of likes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，机器学习是一种从数据中学习和进行预测的技术。至少，要*进行*机器学习，你必须获取一些数据，学习一个模型，并使用该模型进行预测。使用这个定义，我们可以想象一个更粗糙的Pooch
    Predictor示例。这可能是一个程序，它会查询应用程序数据库中最受欢迎的狗品种（结果证明是法国斗牛犬），并告诉应用程序说，所有包含法国斗牛犬的帖子都会获得很多点赞。
- en: That minimal definition of machine learning leaves out a lot of relevant detail.
    Most real-world machine learning systems need to do a lot more than just that.
    They usually need to have all the components, or phases, shown in [figure 1.3](#ch01fig03).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对机器学习的最小定义省略了很多相关的细节。大多数现实世界的机器学习系统需要做的不仅仅是这些。它们通常需要所有显示在[图1.3](#ch01fig03)中的组件或阶段。
- en: Figure 1.3\. Phases of machine learning
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 机器学习的阶段
- en: '![](01fig03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3](01fig03.jpg)'
- en: Starting at the beginning, a machine learning system must collect data from
    the outside world. In the Pooch Predictor example, the team was trying to skip
    this concern by using the data that their application already had. No doubt about
    it, that approach was quick, but it tightly coupled the Sniffable application
    data model to the Pooch Predictor data model. How to collect and persist data
    for a machine learning system is a large and important topic, so I’ll spend all
    of [chapter 3](kindle_split_014.html#ch03) showing you how to set up your system
    for success.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，机器学习系统必须从外部世界收集数据。在Pooch Predictor示例中，团队试图通过使用他们应用程序已有的数据来跳过这个担忧。毫无疑问，这种方法很快，但它将Sniffable应用程序数据模型与Pooch
    Predictor数据模型紧密耦合。如何收集和持久化机器学习系统的数据是一个大而重要的主题，所以我将在[第3章](kindle_split_014.html#ch03)中展示如何设置你的系统以取得成功。
- en: Once the system has data in it, that data is rarely ready to send off to a machine
    learning algorithm. Most machine learning algorithms are applied to derived representations
    of the raw data, called *instances*. [Figure 1.4](#ch01fig04) shows the parts
    of an instance in a common syntax (LIBSVM).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统中有数据，这些数据很少准备好发送到机器学习算法。大多数机器学习算法都是应用于原始数据的派生表示，称为*实例*。[图1.4](#ch01fig04)展示了实例的各个部分在一个常见的语法（LIBSVM）中。
- en: Figure 1.4\. The structure of an instance
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.4\. 实例的结构
- en: '![](01fig04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4](01fig04.jpg)'
- en: Many different syntaxes can be used to express instances, so we’re not going
    to worry too much about the specifics of any particular syntax. However they’re
    expressed, instances are always made up of the same components.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多不同的语法来表达实例，所以我们不会太担心任何特定语法的具体细节。然而无论它们如何表达，实例总是由相同的组件组成。
- en: '*Features* are meaningful data points derived from raw data related to the
    entity being predicted on, at the time you’re trying to make a prediction. A Sniffable
    example of a feature would be the number of friends a given dog has. In [figure
    1.4](#ch01fig04), features are expressed using a unique ID field and feature value.
    Feature number 978, which might represent the sniffer’s proportion of friends
    that are male dogs, has a value of 0.24\. Typically, a machine learning system
    will extract many features from the raw data available to it. The feature values
    for a given instance are collectively called a *feature vector*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*特征*是从与预测实体相关的原始数据中提取的有意义的数据点，在尝试进行预测时。一个可嗅探的特征的例子是给定狗的朋友数量。在[图1.4](#ch01fig04)中，特征使用唯一的ID字段和特征值来表示。特征编号978可能代表嗅探者男性狗朋友的比例，其值为0.24。通常，机器学习系统将从其可用的原始数据中提取许多特征。给定实例的特征值集称为*特征向量*。'
- en: A *concept* is the thing that the system is trying to predict. In the context
    of Pooch Predictor, a concept would be the number of likes a given post receives.
    When a concept is *discrete* (not continuous), it can be called a *class label*,
    and you’ll often see just the word *label* used in the relevant parts of machine
    learning libraries, such as MLlib, which we’ll use in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*概念*是系统试图预测的东西。在Pooch Predictor的上下文中，一个概念将是给定帖子收到的点赞数。当一个概念是*离散的*（非连续的）时，它可以被称为*类别标签*，你经常会在机器学习库的相关部分看到仅使用单词*标签*，例如我们将在本书中使用的MLlib。'
- en: Only some sorts of machine learning problems involve having concepts available
    in the form of class labels. This sort of machine learning context is known as
    *supervised learning*, and most of the material in this book is focused on this
    type of machine learning problem, although reactive machine learning could be
    applied to unsupervised learning problems as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只有某些类型的机器学习问题涉及到以类别标签的形式提供概念。这种机器学习环境被称为*监督学习*，本书的大部分内容都集中在这种机器学习问题上，尽管反应式机器学习也可以应用于无监督学习问题。
- en: Defining and implementing the best features and concepts to represent the problem
    you’re trying to solve make up an enormous portion of the work of real-world machine
    learning. From an application perspective, these tasks are the beginning of your
    data pipeline. Constructing pipelines that do this job reliably, consistently,
    and scalably requires a principled approach to application architecture and programming
    style. [Chapter 4](kindle_split_015.html#ch04) is devoted to discussing the reactive
    approach to this part of machine learning systems under the banner of feature
    generation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和实现最佳特征和概念来表示你试图解决的问题，构成了现实世界机器学习工作中很大一部分。从应用的角度来看，这些任务是你的数据管道的开始。构建可靠、一致且可扩展地完成这项工作的管道需要一种原则性的应用架构和编程风格。第4章（[kindle_split_015.html#ch04](https://wiki.example.org/kindle_split_015.html#ch04)）致力于讨论在特征生成方面机器学习系统中的反应式方法。
- en: Using the data prepared as just described, you’re now ready to learn a model.
    You can think of a *model* as a program that maps from features to predicted concepts,
    as shown in the simple Scala implementation in the following listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用刚刚描述的数据准备，你现在可以开始学习一个模型了。你可以将*模型*想象成一个将特征映射到预测概念的程序，如下面的简单Scala实现所示。
- en: Listing 1.1\. A simple model
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.1. 一个简单的模型
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Learning models occurs during the latter half of the data pipeline. A model
    produced by Pooch Predictor would be a program that takes as input the feature
    representation of the hashtag data and returns the predicted number of likes that
    a given pupdate might receive, as shown in the following listing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模型学习发生在数据管道的后半部分。Pooch Predictor生成的模型将是一个程序，它接受作为输入的标签数据的特征表示，并返回给定更新可能收到的预测点赞数，如下面的列表所示。
- en: Listing 1.2\. A Pooch Predictor model
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.2. Pooch Predictor模型
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: During this same phase of the pipeline, you’ll need to begin to address several
    different types of uncertainty that crop up in model building. As a result, the
    model-learning phase of the pipeline is concerned with more than just learning
    models. In [chapter 5](kindle_split_016.html#ch05), I discuss the various concerns
    that you’ll need to consider in the model-learning subsystem of a machine learning
    system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的这个相同阶段，你需要开始处理在模型构建中出现的几种不同类型的未知因素。因此，管道中的模型学习阶段不仅涉及学习模型。在第5章（[kindle_split_016.html#ch05](https://wiki.example.org/kindle_split_016.html#ch05)）中，我讨论了在机器学习系统的模型学习子系统中你需要考虑的各种问题。
- en: 'Next, you’ll need to take this model and make it useful by publishing it. *Model
    publishing* means making the model program available outside of the context it
    was learned in, so that it can make predictions on data it hasn’t seen before.
    It’s easy to gloss over the difficulties that come up in this part of a machine
    learning system, and the Sniffable team largely skipped it in their original implementation.
    They didn’t even set up their system to retrain the model on a regular basis.
    Their next approach at implementing model retraining also ran into difficulty,
    causing their models to be out of sync with their feature extractors. There are
    better ways of doing this (hint: think immutability), and I discuss them in [chapter
    6](kindle_split_017.html#ch06).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要通过发布它来使这个模型变得有用。*模型发布*意味着使模型程序在它被学习到的环境中可用，以便它可以在之前未见过的数据上进行预测。很容易忽略机器学习系统这一部分的困难，Sniffable团队在他们的原始实现中很大程度上跳过了这部分。他们甚至没有设置系统定期重新训练模型。他们实施模型重新训练的下一个方法也遇到了困难，导致他们的模型与特征提取器不同步。有更好的方法来做这件事（提示：考虑不可变性），我在[第6章](kindle_split_017.html#ch06)中讨论了它们。
- en: Finally, you’ll need to implement functionality for your learned model to be
    used in predicting concepts from new instances, which I call *responding* later
    in the book. This is ultimately where the rubber meets the road in a machine learning
    system, and in the Pooch Predictor system it was frequently where the car burst
    into flames. Given that team Sniffable had never really built a machine learning
    system like this before, it’s not surprising that there were some pain points
    where their ideas met harsh reality. Some of their problems stemmed from treating
    their predictive system like a transaction business application that needed to
    record a purchase. An approach that relies on strong consistency guarantees doesn’t
    work for modern distributed systems, and it’s out of sync with the pervasive and
    intrinsic uncertainty in a machine learning system. Other problems the Sniffable
    team experienced had to do with not thinking about their system in dynamic terms.
    machine learning systems must evolve, and they must support parallel tracks for
    that evolution through experimentation capabilities. Finally, there wasn’t much
    functionality to support handling requests for predictions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要实现功能，以便你的学习模型能够用于从新的实例中预测概念，这在本书稍后我称之为*响应*。这是机器学习系统中真正考验其性能的地方，在Pooch预测系统中，它经常是汽车突然起火的地方。鉴于Sniffable团队之前从未真正构建过这样的机器学习系统，他们遇到一些痛点并不奇怪，这些痛点源于他们的想法与残酷的现实相遇。他们的一些问题源于将他们的预测系统视为需要记录购买的交易业务应用程序。依赖于强一致性保证的方法不适用于现代分布式系统，并且与机器学习系统中普遍存在的内在不确定性不一致。Sniffable团队遇到的其他问题与没有从动态角度考虑他们的系统有关。机器学习系统必须发展，并且它们必须通过实验能力支持这种发展的并行路径。最后，没有太多功能来支持处理预测请求。
- en: The Sniffable team wasn’t unusual in their haphazard approach to architecture.
    Many machine learning systems look a lot like the architecture in [figure 1.5](#ch01fig05).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Sniffable团队在架构方面的随意方法并不罕见。许多机器学习系统看起来与图1.5中的架构非常相似。
- en: Figure 1.5\. A simplistic machine learning system
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5. 一个简单的机器学习系统
- en: '![](01fig05_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5](01fig05_alt.jpg)'
- en: There’s nothing wrong with starting with something so simple. But this approach
    lacks many system components that will eventually be needed, and the ones that
    are implemented have poor component boundaries. Moreover, not a lot of thought
    was given to the various properties this system must have, should it ever serve
    more than a few users. It is, in a word, naive.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从如此简单的事物开始并没有什么不妥。但这种方法缺少了许多最终将需要的系统组件，并且已实现的组件边界不佳。此外，对于这个系统必须具备的各种属性，并没有给予太多的思考，如果它要为超过几个用户服务的话。总之，这是一种天真（naive）的做法。
- en: This book introduces an approach to building machine learning systems that is
    anything but naive. The approach is based on a lot of real-world experiences with
    the challenges of machine learning systems. The sorts of systems that we’ll look
    at in this book are non-trivial and often have complex architectures. At a general
    level, they will conform to the approach shown in [figure 1.6](#ch01fig06).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本书介绍了一种构建机器学习系统的方法，这种方法绝对不是天真的。这种方法基于许多与机器学习系统挑战相关的现实世界经验。本书中我们将要查看的系统不是微不足道的，通常具有复杂的架构。在一般层面上，它们将符合图1.6中所示的方法。
- en: Figure 1.6\. A reactive machine learning system
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6. 一个反应性机器学习系统
- en: '![](01fig06_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig06_alt](01fig06_alt.jpg)'
- en: It may not be obvious why we need to build machine learning systems using such
    a complex architecture, but I beg your patience. In each chapter, I’ll show you
    what challenges this portion of the system must address and how a more reactive
    approach to machine learning will work better. To do that, I should probably give
    you more background on what reactive systems are.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要使用如此复杂的架构来构建机器学习系统可能并不明显，但我请求你的耐心。在每一章中，我都会向你展示系统这一部分必须解决的问题，以及更反应性的机器学习方法将如何更好地工作。为了做到这一点，我可能需要给你更多关于反应性系统是什么的背景信息。
- en: 1.2.2\. Reactive systems
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2. 反应性系统
- en: Now that you understand a bit more about what machine learning systems are,
    I want to give you an overview of some of the ideas and approaches that we’ll
    use to build successful ones. We’ll begin with the *reactive systems paradigm*.
    Reactive systems are defined by four traits and three strategies. The paradigm
    as a whole is a way of codifying an approach to building systems that can serve
    modern user expectations for things like interactivity and availability.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对机器学习系统有了更多的了解，我想给你概述一下我们将使用的一些想法和方法，我们将构建成功的系统。我们将从**反应性系统范式**开始。反应性系统由四个特征和三个策略定义。这个范式整体上是一种将构建能够满足现代用户对交互性和可用性等事物期望的方法编码化的方式。
- en: Traits of reactive systems
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反应性系统的特征
- en: Reactive systems privilege four traits (see [figure 1.7](#ch01fig07)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性系统优先考虑四个特征（见[图1.7](#ch01fig07)）。
- en: Figure 1.7\. The traits of reactive systems
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7. 反应性系统的特征
- en: '![](01fig07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig07](01fig07.jpg)'
- en: '![](responsive.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片responsive](responsive.jpg)'
- en: First and most importantly, reactive systems are *responsive*, meaning they
    consistently return timely responses to users. Responsiveness is the crucial foundation
    upon which all future development efforts will be built. If a system doesn’t respond
    to its users, then it’s useless. Think of the Sniffable team causing a massive
    slowdown in the Sniffable app due to the poor responsiveness of their machine
    learning system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，也是最重要的，反应性系统是**响应性**的，这意味着它们会持续地及时对用户做出响应。响应性是所有未来开发努力的基础。如果一个系统不对用户做出响应，那么它就是无用的。想想Sniffable团队由于他们的机器学习系统响应性差，导致Sniffable应用出现大规模减速的情况。
- en: '![](resilient.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片resilient](resilient.jpg)'
- en: Supporting that goal of responsiveness, reactive systems must be *resilient*;
    they need to maintain responsiveness in the face of failure. Whether the cause
    is failed hardware, human error, or design flaws, software always breaks, as the
    Sniffable team has discovered. Providing some sort of acceptable response even
    when things don’t go as planned is a key part of ensuring that users view a system
    as being responsive. It doesn’t matter that an app is very fast when it’s not
    broken if it’s broken half the time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持响应性的目标，反应性系统必须是**健壮**的；它们需要在面对失败时保持响应性。无论原因是硬件故障、人为错误还是设计缺陷，软件总是会出现问题，正如Sniffable团队所发现的。即使在事情没有按计划进行的情况下，提供某种可接受的反应也是确保用户将系统视为响应性的关键部分。如果应用程序在损坏一半的时候运行得非常快，那么它就无关紧要了。
- en: '![](elastic.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片elastic](elastic.jpg)'
- en: Reactive systems must also be *elastic*; they need to remain responsive despite
    varying loads. The idea of elasticity isn’t exactly the same as scalability, although
    the two are similar. Elastic systems should respond to increases *or* decreases
    in load. The Sniffable team saw this when their traffic ramped up and the Pooch
    Predictor system couldn’t keep up with the load. That’s exactly what a lack of
    elasticity looks like.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 反应性系统也必须是**弹性**的；即使在负载变化的情况下，它们也需要保持响应性。弹性的概念与可扩展性并不完全相同，尽管两者相似。弹性系统应该对负载的增加或减少做出响应。Sniffable团队在他们的流量激增时看到了这一点，当时Pooch
    Predictor系统无法跟上负载。这正是缺乏弹性的样子。
- en: '![](message-driven.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片message-driven](message-driven.jpg)'
- en: Finally, reactive systems are *message-driven*; they communicate via asynchronous,
    non-blocking *message passing*. The message-passing approach is in contrast with
    direct intraprocess communication or other forms of tight coupling. It’s easy
    to understand how a more explicit approach to ensuring loose coupling might solve
    some of the issues in the Sniffable example. A loosely coupled system organized
    around message passing can make it easier to detect failure or issues with load.
    Moreover, a design with this trait helps contain any of the effects of errors
    to just messages about bad news, rather than flaming production issues that need
    to be immediately addressed, as they were in Pooch Predictor.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反应式系统是**消息驱动的**；它们通过异步、非阻塞的**消息传递**进行通信。与直接进程内通信或其他紧密耦合形式相比，消息传递方法更容易理解。如何确保松散耦合的更明确的方法可能解决
    Sniffable 示例中的一些问题。围绕消息传递组织松散耦合的系统可以更容易地检测到故障或负载问题。此外，具有这种特性的设计有助于将错误的影响仅限于关于坏消息的消息，而不是像
    Pooch Predictor 那样需要立即解决的燃烧生产问题。
- en: The reactive approach could certainly be applied to the problems the Sniffable
    team were having with their machine learning system. The four principles represent
    a coherent and complete approach to system design that makes for fundamentally
    better systems. Such systems fulfill their requirements better than naively designed
    systems, and they’re more fun to work on. After all, who wants to fight fires
    when you could be shipping awesome new machine learning functionality to loyal
    sniffers?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式方法当然可以应用于 Sniffable 团队在与他们的机器学习系统遇到的问题。这四个原则代表了一种连贯且完整的方法，可以构建出根本更好的系统。这样的系统比盲目设计的系统更好地满足其要求，并且它们更有趣。毕竟，谁愿意在可以发送令人惊叹的新机器学习功能给忠诚的嗅探者时去灭火呢？
- en: These traits certainly sound nice, but they’re not much of a plan. How do you
    build a system that actually has these traits? Message passing is part of the
    answer, but it’s not the whole story. machine learning systems, as you’ve seen,
    can be difficult to get right. They have unique challenges that will likely need
    unique solutions that don’t appear in traditional business applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性听起来确实很吸引人，但它们并不是一个很好的计划。你如何构建一个真正具有这些特性的系统？消息传递是答案的一部分，但不是全部。正如你所看到的，机器学习系统可能很难正确实现。它们具有独特的挑战，可能需要独特的解决方案，这些解决方案在传统的商业应用中并不常见。
- en: Reactive strategies
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反应式策略
- en: A key part of how we’ll build a reactive machine learning system in this book
    is by using the three reactive strategies illustrated in [figure 1.8](#ch01fig08).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书构建反应式机器学习系统的关键部分是使用图 1.8 中展示的三个反应式策略。
- en: Figure 1.8\. Reactive strategies
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.8\. 反应式策略
- en: '![](01fig08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig08.jpg)'
- en: '![](replication.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](replication.jpg)'
- en: First, reactive systems use *replication*. They have the same component executing
    in more than one place at the same time. More generally, this means that data,
    whether at rest or in motion, should be redundantly stored or processed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，反应式系统使用**复制**。它们在同一时间在多个地方执行相同的组件。更普遍地说，这意味着数据，无论是静止的还是运动的，都应该进行冗余存储或处理。
- en: In the Sniffable example, there was a time when the server that ran the model-learning
    job failed, and no model was learned. Clearly, replication could have helped here.
    Had there been two or more model-learning jobs, the failure of one job would have
    had less impact. Replication may sound wasteful, but it’s the beginning of a solution.
    As you’ll see in [chapters 4](kindle_split_015.html#ch04) and [5](kindle_split_016.html#ch05),
    you can build replication into your modeling pipelines using Spark. Rather than
    requiring you to always have two pipelines executing, Spark gives you automatic,
    fine-grained replication so that the system can recover from failure. This book
    focuses on the use of higher-level tools like Spark to manage the challenges of
    distributed systems. By relying on these tools, you can easily use replication
    in every component of your machine learning system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sniffable 示例中，曾经有一段时间，运行模型学习作业的服务器失败了，没有学习到任何模型。显然，复制可以在这里有所帮助。如果有两个或更多的模型学习作业，一个作业的失败影响就会小得多。复制可能听起来很浪费，但它是一个解决方案的开始。正如你将在第
    [4](kindle_split_015.html#ch04) 章和第 [5](kindle_split_016.html#ch05) 章中看到的，你可以使用
    Spark 将复制构建到你的建模管道中。Spark 并不要求你始终有两个管道在执行，它提供了自动、细粒度的复制，以便系统可以从故障中恢复。本书重点介绍使用像
    Spark 这样的高级工具来管理分布式系统的挑战。通过依赖这些工具，你可以轻松地将复制用于你的机器学习系统的每个组件。
- en: '![](containment.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](containment.jpg)'
- en: Next, reactive systems use *containment* to prevent the failure of any single
    component of the system from affecting any other component. The term *containment*
    might get you thinking about specific technologies like Docker and rkt, but this
    strategy isn’t about any one implementation. Containment can be implemented using
    many different systems, including homegrown ones. The point is to prevent the
    sort of cascading failure we saw in Pooch Predictor, and to do so at a structural
    level.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，反应式系统使用*隔离*来防止系统任何单个组件的故障影响其他组件。术语*隔离*可能会让你想到像Docker和rkt这样的特定技术，但这一策略并非关于任何一种实现。隔离可以通过许多不同的系统实现，包括自制的系统。关键是要防止我们在Pooch
    Predictor中看到的级联故障，并在结构层面上做到这一点。
- en: Consider the issue with Pooch Predictor where the model and the features were
    out of sync, resulting in exceptions during model serving. This was only a problem
    because the model-serving functionality wasn’t sufficiently contained. Had the
    model been deployed as a contained service communicating with the Sniffable application
    server via message passing, there would have been no way for this failure to propagate
    as it did. [Figure 1.9](#ch01fig09) shows an example of this architecture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Pooch Predictor中模型和特征不同步的问题，导致在模型服务期间出现异常。这仅仅是因为模型服务功能没有得到足够的隔离。如果模型被部署为一个隔离的服务，通过消息传递与Sniffable应用程序服务器通信，那么这种故障就不会像现在这样传播。[图1.9](#ch01fig09)展示了这种架构的一个例子。
- en: Figure 1.9\. A contained model-serving architecture
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9. 一个隔离的模型服务架构
- en: '![](01fig09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig09](01fig09.jpg)'
- en: '![](supervision.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片supervision](supervision.jpg)'
- en: Lastly, reactive systems rely on the strategy of *supervision* to organize components.
    When implementing systems using this strategy, you explicitly identify the components
    that could fail and make sure that some other component is responsible for their
    lifecycles. The strategy of supervision gives you a point of control, where you
    can ensure that the reactive traits are being achieved by the true runtime behavior
    of your system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反应式系统依赖于*监督*策略来组织组件。当使用这种策略实现系统时，你明确标识可能失败的组件，并确保有其他组件负责它们的生命周期。监督策略为你提供了一个控制点，你可以确保通过系统的真实运行时行为实现反应性特质。
- en: The Pooch Predictor system had no system-level supervision. This unfortunate
    omission left the Sniffable team scrambling whenever something went wrong with
    the system. A better approach would have been to build supervision directly into
    the system itself, along the lines of [figure 1.10](#ch01fig10).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Pooch Predictor系统没有系统级监督。这个不幸的遗漏使得Sniffable团队在系统出现问题时手忙脚乱。更好的方法是将监督直接构建到系统本身中，就像[图1.10](#ch01fig10)中展示的那样。
- en: Figure 1.10\. A supervisory architecture
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.10. 一个监督架构
- en: '![](01fig10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片01fig10](01fig10.jpg)'
- en: In this structure, the published models are observed by the model supervisor.
    Should their behavior deviate from acceptable bounds, the supervisor would stop
    sending them messages requesting predictions. In fact, the model supervisor could
    even completely destroy a model it knows to be bad, making the system potentially
    self-healing. I’ll begin discussing how you can implement model supervision in
    [chapters 6](kindle_split_017.html#ch06) and [7](kindle_split_018.html#ch07),
    and we’ll continue exploring powerful applications of the strategy of supervision
    throughout the remainder of the book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，发布的模型被模型监督器观察。如果它们的行为超出可接受的界限，监督器将停止发送请求预测的消息。实际上，模型监督器甚至可以完全销毁它知道是坏模型，使系统可能实现自我修复。我将在[第6章](kindle_split_017.html#ch06)和[第7章](kindle_split_018.html#ch07)中开始讨论如何实现模型监督，并且我们将在本书的剩余部分继续探索监督策略的强大应用。
- en: 1.2.3\. Making machine learning systems reactive
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3. 使机器学习系统具有反应性
- en: With some understanding about reactive systems, I can begin discussing how we
    can apply these ideas to machine learning systems. In a reactive machine learning
    system, we still want our system to have all the same traits as a reactive system,
    and we can use all the same strategies. But we can do more to address the unique
    characteristics of a machine learning system. So far, I’ve explained a lot of
    infrastructural concerns, but I haven’t yet shown you how this enables new *predictive*
    capabilities. Ultimately, a reactive machine learning system gives you the ability
    to deliver value through ever better predictions. That’s why reactive machine
    learning is worth understanding and applying.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在对反应式系统有一定了解之后，我可以开始讨论如何将这些想法应用于机器学习系统。在一个反应式机器学习系统中，我们仍然希望我们的系统具有与反应式系统相同的所有特性，并且可以使用所有相同的策略。但我们可以做更多的事情来应对机器学习系统的独特特性。到目前为止，我已经解释了很多基础设施问题，但还没有向你展示这是如何使新的*预测*能力成为可能的。最终，一个反应式机器学习系统赋予你通过不断改进的预测来创造价值的能力。这就是为什么反应式机器学习值得理解和应用。
- en: 'The reactive machine learning approach is based on two key insights into the
    characteristics of data in a machine learning system: it is uncertain, and it
    is effectively infinite. From those two insights, four strategies emerge, shown
    in [figure 1.11](#ch01fig11), that will help us build a reactive machine learning
    system.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式机器学习方法基于对机器学习系统中数据特性的两个关键洞察：它是不确定的，并且实际上是无限的。从这两个洞察中，产生了四种策略，如图1.11所示，这些策略将帮助我们构建一个反应式机器学习系统。
- en: '![](infinite-data.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![无限数据](infinite-data.jpg)'
- en: Figure 1.11\. Reactive machine learning data and strategies
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.11. 反应式机器学习数据和策略
- en: '![](01fig11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![01fig11.jpg](01fig11.jpg)'
- en: To begin, let’s think about how much data the Pooch Predictor system might need
    to process. Ideally, with its new machine learning capabilities, Sniffable will
    take off and see tons of traffic. But even if that doesn’t happen, there’s still
    no way of knowing how many possible pupdates users might want to consider and
    thus send to the Pooch Predictor system. Imagine having to predict every possible
    post that a sniffer might make on Sniffable. Some posts would have big dogs; others,
    small ones. Some posts would use filters, and others would be more natural. Some
    would be rich in hashtags, and some wouldn’t have any annotations. Once you consider
    the impact of arbitrary parameters on feature values, the range of possible data
    representations becomes literally *infinite*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下Pooch Predictor系统可能需要处理多少数据。理想情况下，凭借其新的机器学习能力，Sniffable将起飞并看到大量的流量。但即使那样没有发生，也无法知道用户可能想要考虑并因此发送到Pooch
    Predictor系统的可能pupdates数量。想象一下，你必须预测Sniffable上可能发布的每一个可能的帖子。一些帖子会有大狗；另一些，小狗。一些帖子会使用过滤器，而另一些则更自然。一些帖子会包含丰富的标签，而另一些则没有任何注释。一旦你考虑了任意参数对特征值的影响，可能的数据表示范围实际上就变成了*无限*。
- en: It doesn’t matter precisely how much raw data Pooch Predictor ingests. We’ll
    always assume that the amount of data is too much for one thread or one server.
    But rather than give up in the face of this unbounded scope, reactive machine
    learning employs two strategies to manage infinite data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论Pooch Predictor系统需要处理多少原始数据都没有关系。我们始终假设数据量对于单个线程或单个服务器来说太多。但面对这种无界范围，反应式机器学习采用两种策略来管理无限数据。
- en: '![](laziness.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![懒惰](laziness.jpg)'
- en: First, it relies on *laziness*, also known as *delay of execution*, to separate
    the composition of functions to execute from their actual execution. Rather than
    being a bad habit, laziness is a powerful evaluation strategy that can greatly
    improve the design of data-intensive applications.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它依赖于*懒惰*，也称为*延迟执行*，将函数的组成与其实际执行分离。懒惰并非坏习惯，而是一种强大的评估策略，可以极大地提高数据密集型应用程序的设计。
- en: By using laziness in the implementation of your machine learning system, you’ll
    find that it’s much easier to conceive of the data flow in terms of *infinite
    streams* than *finite batches*. This switch can have huge benefits for the responsiveness
    and utility of your system. I show how laziness can be used to build machine learning
    pipelines in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在机器学习系统的实现中使用懒惰，你会发现，用*无限流*来构想数据流比用*有限批次*要容易得多。这种转换可以为系统的响应性和实用性带来巨大的好处。我在[第4章](kindle_split_015.html#ch04)中展示了如何使用懒惰来构建机器学习管道。
- en: '![](pure-functions.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![纯函数](pure-functions.jpg)'
- en: Similarly, reactive machine learning systems deal with infinite data by expressing
    transformations as *pure functions*. What does it mean for a function to be pure?
    First, evaluating the function must not result in some sort of side effect, such
    as changing the state of a variable or performing I/O. Additionally, the function
    must always return the same value when given the same arguments. This latter property
    is referred to as *referential transparency*. Writing machine learning code that
    maintains this property can make implementations of mathematical transformations
    look and behave quite similarly to their expression in math.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，反应式机器学习系统通过将转换表示为*纯函数*来处理无限数据。一个函数要成为纯函数意味着什么？首先，评估函数时不能产生某种副作用，例如改变变量的状态或执行I/O操作。此外，当给定相同的参数时，函数必须始终返回相同的值。这个后者的特性被称为*引用透明性*。编写保持这一特性的机器学习代码可以使数学变换的实现看起来和表现与数学表达式非常相似。
- en: Pure functions are a foundational concept in a style of programming known as
    *functional programming*, which we’ll use throughout this book. At its heart,
    functional programming is all about computing with functions. In functional code,
    functions can be passed to other functions as arguments. Such functions are called
    *higher-order functions*, and we’ll use this idiom throughout the code examples
    in this book. Functional programming idioms like higher-order functions are a
    key part of what makes reactive tools like Scala and Spark so powerful.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是称为*函数式编程*的编程风格中的基础概念，我们将在这本书中一直使用它。在本质上，函数式编程完全是关于使用函数进行计算。在函数式代码中，函数可以作为参数传递给其他函数。这样的函数被称为*高阶函数*，我们将在本书的代码示例中一直使用这个习语。像高阶函数这样的函数式编程习语是使Scala和Spark等反应式工具如此强大的关键部分。
- en: The emphasis on the use of functional programming in this book isn’t merely
    stylistic. Functional programming is one of the most powerful tools for taming
    complicated systems that need to reason about data, especially infinite data.
    The recent increase in the popularity of functional programming has been largely
    driven by its application to building big data infrastructure. Using the techniques
    of functional programming, we’ll be able to get our system right *and* scale it
    to the next level. As I discuss in [chapters 4](kindle_split_015.html#ch04) and
    [6](kindle_split_017.html#ch06), pure functions can offer real solutions to the
    problems of implementing feature extraction and prediction functionality.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本书对函数式编程的强调并不仅仅是风格上的。函数式编程是驯服需要关于数据进行推理的复杂系统（特别是无限数据）的最强大工具之一。函数式编程最近流行度的增加在很大程度上是由其在大数据基础设施中的应用所驱动的。使用函数式编程的技术，我们将能够正确地构建我们的系统，并将其扩展到下一个级别。正如我在第[4章](kindle_split_015.html#ch04)和[6章](kindle_split_017.html#ch06)中讨论的那样，纯函数可以为实现特征提取和预测功能的问题提供真正的解决方案。
- en: '![](uncertain-data.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![不确定数据](uncertain-data.jpg)'
- en: Next, let’s consider what Pooch Predictor knew about what was going on with
    Sniffable and its users. It had records of sniffers creating, viewing, and liking
    pupdates. This knowledge came from the main application database. As we saw, the
    app would sometimes lose sniffers’ efforts to like a particular pupdate, due to
    operational issues, and this loss of data changed the concept that Pooch Predictor
    was built to learn. Similarly, Pooch Predictor’s view of what feature values were
    seen at a given time was often impeded by bugs in its code or in the main app’s
    code. This is all because *uncertainty* is intrinsic and pervasive in a machine
    learning system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑Pooch Predictor对Sniffable及其用户所发生的事情的了解。它有关于嗅探器创建、查看和喜欢pupdates的记录。这些知识来自主应用程序数据库。正如我们所见，由于操作问题，应用程序有时会丢失嗅探器对特定pupdate的点赞努力，这种数据丢失改变了Pooch
    Predictor旨在学习的概念。同样，Pooch Predictor对在给定时间看到的特征值的看法常常受到其代码或主应用程序代码中的错误阻碍。这一切都是因为*不确定性*在机器学习系统中是内在的且普遍存在的。
- en: 'Machine learning models and the predictions they make are always approximate
    and only useful in the aggregate. It wasn’t like Pooch Predictor knew *exactly*
    how many likes a given pupdate might get. Even before making a prediction, a machine
    learning system must deal with the uncertainty of the real world outside of the
    machine learning system. For example, do sniffers using the hashtag #adorabull
    mean the same thing as sniffers using the hashtag #adorable, or should those be
    viewed as different features?'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '机器学习模型及其做出的预测总是近似的，并且只有在总体上才有用。Pooch Predictor 并不知道一个特定的 pupdate 可能会获得多少个赞。即使在做出预测之前，机器学习系统也必须处理机器学习系统外部的现实世界的不确定性。例如，使用
    #adorabull 标签的嗅探者和使用 #adorable 标签的嗅探者是否意味着相同的事情，或者这些应该被视为不同的特征？'
- en: 'A truly reactive machine learning system incorporates this uncertainty into
    the design of the system and uses two strategies to manage it: *immutable facts*
    and *possible worlds*. It may sound strange to use facts to manage uncertainty,
    but that’s exactly what we’re going to do. Consider the location that a sniffer
    is posting a pupdate from. One way of recording this location data for later use
    in geographic features is to record the exact location reported by the app, as
    in [table 1.1](#ch01table01).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正反应灵敏的机器学习系统会将这种不确定性纳入系统设计，并使用两种策略来管理它：**不可变事实**和**可能世界**。使用事实来管理不确定性听起来可能很奇怪，但这正是我们要做的。考虑一个嗅探者从哪里发布
    pupdate 的位置。记录这种位置数据以便以后在地理特征中使用的一种方法是将应用程序报告的确切位置记录下来，如[表 1.1](#ch01table01)所示。
- en: Table 1.1\. Pupdate location data model
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1\. Pupdate 位置数据模型
- en: '| pupdate_id | Location |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| pupdate_id | 位置 |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 123 | Washington Square Park |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 123 | 华盛顿广场公园 |'
- en: But the location determined by the app at the time of the pupdate was uncertain;
    it was just the result of a sensor reading on a phone, which has a very coarse
    level of precision. The sniffer may or may not have been in Washington Square
    Park. Moreover, if a future feature tries to capture the distinct differences
    between East and West Greenwich Village, this data model will give a precise but
    potentially inaccurate view of how far to the east or west this pupdate came from.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 pupdate 时刻应用程序确定的位置是不确定的；它只是手机上传感器读取的结果，其精度非常粗糙。嗅探者可能或可能不在华盛顿广场公园。此外，如果未来的功能试图捕捉东格林威治村和西格林威治村之间的独特差异，这个数据模型将给出精确但可能不准确的观点，即这个
    pupdate 从东或西方向有多远。
- en: A richer, more accurate way of recording this data is to use the raw location
    reading and the expected radius of uncertainty, as shown in [table 1.2](#ch01table02).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记录这些数据的一种更丰富、更准确的方法是使用原始位置读取和预期的不确定半径，如[表 1.2](#ch01table02)所示。
- en: Table 1.2\. Revised pupdate location data model
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.2\. 修订后的 pupdate 位置数据模型
- en: '| pupdate_id | Latitude | Longitude | Radius |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| pupdate_id | 纬度 | 经度 | 半径 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 123 | 40.730811 | -73.997472 | 1.0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 123 | 40.730811 | -73.997472 | 1.0 |'
- en: '![](immutable-facts.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](immutable-facts.jpg)'
- en: This revised data model can now represent *immutable facts*. This data can be
    written once and never modified; it is written in stone. The use of immutable
    facts allows us to reason about uncertain views of the world at specific points
    in time. This is crucial for creating accurate instances and many other important
    data transformations in a machine learning system. Having a complete record of
    all facts that occur over the lifetime of the system also enables important machine
    learning, like model experimentation and automatic model validation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修订后的数据模型现在可以表示**不可变的事实**。这些数据一旦写入就永远不会修改；它们是刻在石头上的。不可变事实的使用允许我们在特定时间点对世界的不确定观点进行推理。这对于在机器学习系统中创建准确的实例以及许多其他重要的数据转换至关重要。拥有系统整个生命周期中发生的所有事实的完整记录，也使得重要的机器学习，如模型实验和自动模型验证成为可能。
- en: 'To understand the other strategy for dealing with uncertainty, let’s consider
    a fairly simple question: how many likes will pupdates about French Bulldogs get
    in the next hour? To answer this question, let’s break it down into pieces.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解处理不确定性的另一种策略，让我们考虑一个相当简单的问题：关于法国斗牛犬的 pupdate 在下一个小时内会获得多少个赞？为了回答这个问题，让我们将其分解成几个部分。
- en: First, how many pupdates will be submitted in the next hour? There are multiple
    ways of answering this question. We could just take the historical average rate—say,
    6,500\. But the number of pupdates submitted varies over time, so we could also
    fit a line to the data that looks something like [figure 1.12](#ch01fig12). Using
    this model, we might expect 7,250 pupdates in the next hour.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下一个小时内会有多少次更新提交？回答这个问题有多种方式。我们可以简单地取历史平均速率——比如说，6,500次。但是，提交的更新数量随时间变化，因此我们也可以将一条线拟合到数据上，看起来像[图1.12](#ch01fig12)。使用这个模型，我们可能预计下一个小时会有7,250次更新。
- en: Figure 1.12\. Model of likes by hour
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.12.每小时点赞模型
- en: '![](01fig12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig12.jpg)'
- en: Beyond that, we need to know how many likes these pupdates will receive. Again,
    we could take a historical average, which would give us 23 likes per pupdate in
    this case. Or we could use a model. That model would have to be applied to some
    recent sample of data to get an idea of the likes that recent traffic has been
    getting. The result of this model is that the average pupdate will receive 28
    likes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还需要知道这些更新将获得多少点赞。同样，我们可以取历史平均数，在这种情况下，每更新将获得23个点赞。或者我们可以使用一个模型。这个模型必须应用于一些最近的数据样本，以了解最近流量获得的点赞情况。这个模型的结果是，平均每次更新将获得28个点赞。
- en: Now, we need to combine this information in some way. [Table 1.3](#ch01table03)
    shows the predictions we could use in our final prediction.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要以某种方式结合这些信息。[表1.3](#ch01table03)显示了我们可以用于最终预测的预测值。
- en: Table 1.3\. Possible prediction values
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.3.可能的预测值
- en: '| Model type | Pupdates | Likes/Pupdate |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 模型类型 | 更新次数 | 每更新点赞数 |'
- en: '| --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Historical | 6,500 | 23 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 历史数据 | 6,500 | 23 |'
- en: '| Machine-learned | 7,250 | 28 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 机器学习模型 | 7,250 | 28 |'
- en: '![](possible-worlds.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](possible-worlds.jpg)'
- en: We could decide to answer that the expected number of likes in the next hour
    is 6,500 × 23 = 149,500 using the historical values. Or we could decide to use
    the machine-learned model and get a value of 7,250 × 28 = 203,300\. We could even
    decide to combine the historical number of pupdates with the model-based prediction
    of likes per pupdate to get 6,500 × 28 = 182,000. These different views of our
    uncertain data can be thought of as *possible worlds*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以决定使用历史值来回答下一个小时预期的点赞数是6,500乘以23等于149,500。或者我们可以决定使用机器学习模型，得到一个值为7,250乘以28等于203,300。我们甚至可以决定将历史更新次数与基于模型的每更新点赞数预测相结合，得到6,500乘以28等于182,000。这些对我们不确定数据的不同看法可以被视为*可能的世界*。
- en: We don’t know which of these worlds we will ultimately find ourselves in during
    the next hour of traffic on Sniffable, but we can make decisions with this information,
    such as ensuring that the servers are prepared to handle more than 200,000 likes
    in the next hour. Possible worlds will form the basis for the queries we’ll make
    of all the uncertain data that is present in our machine learning system. There
    are limits to the applicability of this strategy, because infinite data can produce
    infinite possible worlds. But by building our data models and queries with the
    concept of possible alternative worlds, we’ll be able to more effectively reason
    about the real range of potential outcomes in our system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道在Sniffable的交通中，我们最终会在哪个世界中度过接下来的一个小时，但我们可以利用这些信息做出决策，例如确保服务器准备好在接下来的一个小时处理超过20万次点赞。可能的世界将成为我们查询机器学习系统中所有不确定数据的依据。这种策略的应用范围有限，因为无限的数据可以产生无限的可能世界。但通过构建我们的数据模型和查询，以可能替代世界的概念为基础，我们将能够更有效地推理系统中的潜在结果范围。
- en: Using all the strategies that I’ve discussed, it’s easy to imagine the Sniffable
    team refactoring the Pooch Predictor system into something much more powerful.
    The reactive machine learning approach makes it possible to build a machine learning
    system that has fewer problems and allows for evolution and improvement. It’s
    definitely a different approach than we saw in the original Pooch Predictor example,
    and this approach is grounded on a firmer footing. Reactive machine learning unites
    ideas from distributed systems, functional programming, uncertain data, and other
    fields in a coherent, pragmatic approach to building real-world machine learning
    systems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我讨论的所有策略，可以很容易地想象Sniffable团队将Pooch预测器系统重构为一个功能更强大的系统。反应式机器学习方法使得构建一个问题更少、允许进化和改进的机器学习系统成为可能。这确实与我们在原始Pooch预测器示例中看到的方法不同，这种方法建立在更坚实的基础之上。反应式机器学习将分布式系统、函数式编程、不确定数据和其他领域中的思想统一在构建现实世界机器学习系统的一种连贯、实用方法中。
- en: 1.2.4\. When not to use reactive machine learning
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4. 不应使用反应式机器学习的情况
- en: It’s fair to ask whether all machine learning systems should be built using
    the reactive approach. The answer is no.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 合理地询问是否所有机器学习系统都应该使用反应式方法构建。答案是：不。
- en: During the design and implementation of a machine learning system, it’s beneficial
    to consider the principles of reactive machine learning. Machine learning problems
    by definition have to do with reasoning about uncertainty. Thinking in terms of
    immutable facts and pure functions is a useful perspective for implementing any
    sort of application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习系统的设计和实现过程中，考虑反应式机器学习的原则是有益的。根据定义，机器学习问题必须与处理不确定性有关。以不可变事实和纯函数为前提进行思考是实现任何类型应用程序的有用视角。
- en: 'But the approach discussed in this book is a way to easily build sophisticated
    systems, and some machine learning systems don’t need to be sophisticated. Some
    systems won’t benefit from using a message-passing semantic that assumes several
    independently executing processes. A research prototype is a perfect example of
    a machine learning system that doesn’t need the powerful capabilities of a reactive
    machine learning system. When you’re building a temporary system, I recommend
    bending or breaking all the rules I lay out in this book. The prudent approach
    to building potentially disposable machine learning systems is to make far more
    extreme compromises than in the reactive approach. If you’re building such a temporary
    system, see my guide to building machine learning systems at hackathons: [http://mng.bz/981c](http://mng.bz/981c).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但本书中讨论的方法是一种轻松构建复杂系统的方式，并且一些机器学习系统不需要非常复杂。一些系统可能不会从使用假设几个独立执行进程的消息传递语义中受益。一个研究原型是机器学习系统不需要反应式机器学习系统强大功能的完美例子。当你构建一个临时系统时，我建议打破或违反我在本书中提出的所有规则。构建可能被丢弃的机器学习系统的谨慎方法是比反应式方法做出更多极端的妥协。如果你正在构建这样的临时系统，请参阅我在黑客马拉松中构建机器学习系统的指南：[http://mng.bz/981c](http://mng.bz/981c)。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Even simple machine learning systems can fail.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是简单的机器学习系统也可能失败。
- en: Machine learning should be viewed as an application, not as a technique.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习应该被视为一个应用，而不是一种技术。
- en: 'A machine learning system is composed of five components, or phases:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个机器学习系统由五个组件或阶段组成：
- en: The data-collection component ingests data from the outside world into the machine
    learning system.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据收集组件将外部世界的数据摄入到机器学习系统中。
- en: 'The data-transformation component transforms raw data into useful derived representations
    of that data: features and concepts.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换组件将原始数据转换为有用的派生数据表示：特征和概念。
- en: The model-learning component learns models from the features and concepts.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型学习组件从特征和概念中学习模型。
- en: The model-publishing component makes a model available to make predictions.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型发布组件使模型可用于进行预测。
- en: The model-serving component connects models to requests for predictions.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型服务组件将模型与预测请求连接起来。
- en: 'The reactive systems design paradigm is a coherent approach to building better
    systems:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式系统设计范式是构建更好系统的一种连贯方法：
- en: Reactive systems are responsive, resilient, elastic, and message-driven.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式系统是响应的、弹性的、可伸缩的，并且以消息驱动。
- en: Reactive systems use the strategies of replication, containment, and supervision
    as concrete approaches for maintaining the reactive traits.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式系统使用复制、隔离和监督策略作为维护反应式特性的具体方法。
- en: 'Reactive machine learning is an extension of the reactive systems approach
    that addresses the specific challenges of building machine learning systems:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式机器学习是反应式系统方法的一个扩展，它解决了构建机器学习系统的特定挑战：
- en: Data in a machine learning system is effectively infinite. Laziness, or delay
    of execution, is a way of conceiving of infinite flows of data, rather than finite
    batches. Pure functions without side effects help manage infinite data by ensuring
    that functions behave predictably, regardless of context.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习系统中的数据实际上是无限的。惰性，或执行延迟，是构思无限数据流的方式，而不是有限批次。无副作用的纯函数通过确保函数在无论何种情况下都表现出可预测性来帮助管理无限数据。
- en: Uncertainty is intrinsic and pervasive in the data of a machine learning system.
    Writing all data in the form of immutable facts makes it easier to reason about
    views of uncertain data at points in time. Different views of uncertain data can
    be thought of as possible worlds that can be queried across.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不确定性是机器学习系统中数据固有的和普遍存在的。将所有数据以不可变事实的形式写入，使得在时间点对不确定数据的视图进行推理变得更容易。不确定数据的不同视图可以被视为可以查询的可能世界。
- en: In the next chapter, I’ll introduce some of the technologies and techniques
    used to build reactive machine learning systems. You’ll see how reactive programming
    techniques allow you to deal with complex system dynamics without complex code.
    I’ll also introduce two powerful frameworks, Akka and Spark, that you can use
    to build incredibly sophisticated reactive systems easily and quickly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将介绍一些用于构建反应式机器学习系统的技术和技巧。您将看到反应式编程技术如何让您在不编写复杂代码的情况下处理复杂的系统动态。我还会介绍两个强大的框架，Akka
    和 Spark，您可以使用它们轻松快速地构建极其复杂的反应式系统。
- en: Chapter 2\. Using reactive tools
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章\. 使用反应式工具
- en: '*This chapter covers*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Managing uncertainty with Scala
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Scala 管理不确定性
- en: Implementing supervision and fault tolerance with Akka
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Akka 实现监督和容错
- en: Using Spark and MLlib as frameworks for distributed machine learning pipelines
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Spark 和 MLlib 作为分布式机器学习管道的框架使用
- en: 'To get ready to build full-scale reactive machine learning systems, you need
    to get familiar with a few tools from the Scala ecosystem: Scala itself, Akka,
    and Spark. In this book, we’ll write applications in Scala because it provides
    excellent support for functional programming and has been used successfully in
    building reactive systems of all kinds. Sometimes, you’ll find that Akka can be
    useful as a tool for providing resilience and elasticity through its implementation
    of the actor model. Other times, you’ll want to use Spark to build large-scale
    pipeline jobs like feature extraction and model learning. In this chapter, you’ll
    just start to get familiar with these tools, and beginning with [chapter 3](kindle_split_014.html#ch03),
    I’ll show you how they can be used to build the various components of a reactive
    machine learning system.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备好构建全规模的反应式机器学习系统，您需要熟悉 Scala 生态系统中的几个工具：Scala 本身、Akka 和 Spark。在这本书中，我们将使用
    Scala 编写应用程序，因为它为函数式编程提供了出色的支持，并且已经在构建各种类型的反应式系统中取得了成功。有时，您会发现 Akka 可以作为提供弹性和弹性的工具，这是通过其实施的演员模型实现的。其他时候，您可能想使用
    Spark 来构建大规模的管道作业，如特征提取和模型学习。在这一章中，您将开始熟悉这些工具，从[第 3 章](kindle_split_014.html#ch03)开始，我将向您展示如何使用它们构建反应式机器学习系统的各个组件。
- en: These aren’t the only tools that you could use to build a reactive machine learning
    system. Reactive machine learning is a set of ideas, not a specific implementation.
    But the technologies shown in this chapter are all very useful for reactive machine
    learning, in large part because they were designed with strong support for reactive
    techniques. Even though I’m going to introduce you to the specifics of how these
    tools work, you can definitely apply these approaches to systems built in other
    languages using other tools.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是构建反应式机器学习系统可以使用的唯一工具。反应式机器学习是一套思想，而不是一个特定的实现。但本章中展示的技术对于反应式机器学习非常有用，在很大程度上是因为它们在设计时对反应式技术的支持非常强大。尽管我将向您介绍这些工具如何工作的具体细节，但您绝对可以将这些方法应用于使用其他语言和工具构建的系统。
- en: 'I’ll introduce you to this book’s toolchain in the context of one of the world’s
    most crucial problems: finding the next breakout pop star. *Howlywood Star* is
    a canine reality singing competition. Each week, unknown dogs from around the
    country sing in front of a panel of three judges. Then, the viewers at home vote
    on which dog has what it takes to be the next Howlywood Star. This voting mechanic
    is key to the runaway success of the show. The audience tunes in each week as
    much for the competition as for the singing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在解决世界上一个最关键问题的背景下向你介绍这本书的工具链：寻找下一个爆红流行歌星。*Howlywood Star*是一个犬类现实歌唱竞赛。每周，来自全国各地的未知犬只将在三位评委面前唱歌。然后，在家中的观众投票决定哪只狗具备成为下一个Howlywood
    Star的潜质。这种投票机制是节目取得巨大成功的关键。观众每周都会观看比赛，就像观看歌唱表演一样。
- en: A suite of sophisticated apps support this audience participation dynamic, and
    they’re what you’ll focus on in this chapter. You’ll work primarily on the challenges
    of handling the voting functionality. There will be some tricky scenarios resulting
    from the popularity and unpredictability of the competition. Once you’ve addressed
    today’s votes, we’ll try to predict things about future voting patterns using
    machine learning.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一套复杂的应用支持这种观众参与动态，你将在本章中关注这些应用。你将主要处理处理投票功能性的挑战。由于比赛的流行和不可预测性，将出现一些棘手的情况。一旦你处理完今天的投票，我们将尝试使用机器学习预测未来的投票模式。
- en: 2.1\. Scala, a reactive language
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. Scala，一种响应式语言
- en: In this book, all the examples are in Scala. If you haven’t used Scala before,
    don’t worry. If you’re competent in Java or a similar mainstream language, you
    can quickly learn enough Scala to begin to build powerful machine learning systems.
    It’s true that Scala is a large and rich language that could take you quite a
    while to master. But you’ll mostly be using the power of Scala, without having
    to write terribly sophisticated code yourself. Rather than try to introduce you
    to all the amazing features in Scala, this section focuses on the features of
    the language that support reactive programming and reasoning about uncertainty.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，所有的示例都是用Scala编写的。如果你之前没有使用过Scala，不要担心。如果你熟悉Java或类似的通用语言，你可以快速学习足够的Scala知识，开始构建强大的机器学习系统。确实，Scala是一个庞大且丰富的语言，可能需要相当长的时间才能掌握。但大多数情况下，你将利用Scala的强大功能，而不必自己编写非常复杂的代码。而不是试图向你介绍Scala中所有令人惊叹的特性，这一节将专注于支持响应式编程和不确定性推理的语言特性。
- en: To get started with Scala programming, you’ll build some of the pieces of the
    voting application for *Howlywood Star*. The application’s architecture is shown
    in [figure 2.1](#ch02fig01).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始学习Scala编程，你将构建*Howlywood Star*投票应用的一些组件。该应用的架构如图[2.1](#ch02fig01)所示。
- en: Figure 2.1\. Howlywood Star voting application architecture
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. Howlywood Star投票应用架构
- en: '![](02fig01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![02fig01.jpg](02fig01.jpg)'
- en: Various user-facing mobile and web apps are responsible for sending votes from
    the global *Howlywood Star* audience to backend servers. The servers are responsible
    for receiving these votes and forwarding them on to the application database.
    Other visualization apps are then responsible for querying that database and presenting
    the current results. These apps range from sophisticated internal-analytics dashboards
    to simple public-facing mobile apps like the one shown in [figure 2.2](#ch02fig02).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 各种面向用户的移动和Web应用负责将全球*Howlywood Star*观众的投票发送到后端服务器。服务器负责接收这些投票并将它们转发到应用数据库。然后，其他可视化应用负责查询该数据库并展示当前结果。这些应用从复杂的内部分析仪表板到简单的面向公众的移动应用（如图[2.2](#ch02fig02)所示）不等。
- en: Figure 2.2\. Voting results mobile app
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 投票结果移动应用
- en: '![](02fig02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![02fig02.jpg](02fig02.jpg)'
- en: 'This system is very simple, but even a system as simple as this has hidden
    complexity. Consider the following questions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统非常简单，但即使是如此简单的系统也隐藏着复杂的部分。考虑以下问题：
- en: How long will it take to record each vote?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录每一票需要多长时间？
- en: What will the server be doing while it waits for each vote to be persisted?
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器在等待每一票被持久化期间会做什么？
- en: How can the visualization apps be kept as fresh as possible?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使可视化应用保持尽可能的新鲜？
- en: What will happen if load increases dramatically?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果负载急剧增加会发生什么？
- en: '*Howlywood Star’*s popularity has recently been exploding thanks to a lot of
    interest on social media. This voting app needs to be ready for the frenzy of
    attention that the upcoming Season 2 is expected to produce. When the audience
    latches on to the next breakout star, it’s reasonable to expect that the voting
    app will be slammed with traffic.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*Howlywood Star* 的受欢迎程度最近因社交媒体上的大量关注而急剧上升。这个投票应用必须为即将到来的第二季度的狂热关注做好准备。当观众锁定下一个爆红明星时，合理地预期投票应用将面临巨大的流量。'
- en: But you can’t know in advance how big that traffic spike will be. There’s a
    certain amount of intrinsic uncertainty in trying to predict the future like that.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但你无法提前知道流量峰值会有多大。试图预测未来会有一定程度的内在不确定性。
- en: '![](uncertain-data.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](uncertain-data.jpg)'
- en: Nevertheless, the voting app will have to be ready for that uncertain future.
    Thankfully, Scala has tools for handling uncertainty and reacting appropriately.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，投票应用必须为那个不确定的未来做好准备。幸运的是，Scala 有处理不确定性和适当反应的工具。
- en: 2.1.1\. Reacting to uncertainty in Scala
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 在 Scala 中应对不确定性
- en: Before we get into discussions of more-complex distributed systems, let’s discuss
    some basic techniques you can use to manage uncertainty in Scala. Let’s begin
    with some fairly naive code that will allow you to begin to explore the richness
    of Scala. Your initial implementation won’t represent production-grade Scala code,
    but rather will be a basic exploration of how different object types work in Scala.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论更复杂的分布式系统之前，让我们讨论一些基本技术，你可以使用这些技术来管理 Scala 中的不确定性。让我们从一些相当简单的代码开始，这将帮助你开始探索
    Scala 的丰富性。你的初始实现不会代表生产级别的 Scala 代码，而是一个基本的探索，了解 Scala 中不同对象类型是如何工作的。
- en: In the following listing, you create a simple collection of Howlers and the
    number of votes they currently have. Then, you try to retrieve the vote counts
    for a popular Howler.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，你创建了一个简单的 Howlers 集合及其当前拥有的投票数。然后，你尝试检索一个受欢迎的 Howler 的投票数。
- en: Listing 2.1\. A map of votes
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 投票地图
- en: '[PRE2]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* The collection of votes received thus far**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 到目前为止收到的投票集合**'
- en: '***2* An option that must be “unwrapped” to get the vote count**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 必须“展开”以获取投票数的选项**'
- en: This trivial example demonstrates Scala’s concept of an `Option` type. In this
    example, the language will allow you to pass any string key to the map of votes,
    but it doesn’t know whether anyone has voted for nom nom until executing the lookup.
    `Option` types can be viewed as a way of encoding the intrinsic uncertainty in
    an operation. They close over the possibility that a given operation may return
    a value, `Some` of a given type, or `None`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了 Scala 的 `Option` 类型概念。在这个例子中，语言允许你向投票地图传递任何字符串键，但它不知道是否有人为 nom nom
    投过票，直到执行查找。`Option` 类型可以被视为在操作中编码内在不确定性的方式。它们涵盖了给定操作可能返回值、给定类型的 `Some` 或 `None`
    的可能性。
- en: Because Scala has already told you that there’s some uncertainty around the
    contents of the vote map, you can now write code that handles the different possibilities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Scala 已经告诉你投票地图的内容存在一些不确定性，你现在可以编写处理不同可能性的代码。
- en: Listing 2.2\. Handling no votes using pattern matching
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 使用模式匹配处理无投票
- en: '[PRE3]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* A function that handles the possibility that no one may have voted for
    a given dog yet**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理可能还没有人为某个特定狗投票的情况的函数**'
- en: '***2* A pattern-match expression to handle the two possibilities**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于处理两种可能性的模式匹配表达式**'
- en: '***3* Returns 105**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回 105**'
- en: '***4* Returns 0**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回 0**'
- en: '![](possible-worlds.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](possible-worlds.jpg)'
- en: 'This simple helper function uses *pattern matching* to express the two possibilities:
    either you’ve received votes for a given Howler or you haven’t. In the latter
    case, that means the correct number of votes is 0\. This allows the type of the
    votes values to both be `Int`, even though no one has yet voted for Indiana. Pattern
    matching is a language feature used to encode what the possible values are that
    a given operation could produce. In this case, you’re expressing the possible
    cases that the value returned by the `get` operation could match to. Pattern matching
    is a common and useful technique in idiomatic Scala, which we’ll use throughout
    the book.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的辅助函数使用*模式匹配*来表示两种可能性：要么你收到了某个Howler的投票，要么你没有。在后一种情况下，这意味着正确的投票数是0。这允许投票值的类型都是`Int`，即使没有人还为印第安纳州投票。模式匹配是一种语言特性，用于编码给定操作可能产生的可能值。在这种情况下，你正在表达`get`操作返回的值可能匹配的可能情况。模式匹配是Scala中常见且有用的技术，我们将在整本书中使用它。
- en: Of course, this very simple form of uncertainty is so common that Scala gives
    you facilities to address it within the collection. The helper function in [listing
    2.2](#ch02ex02) can be eliminated by setting a default value on the votes map.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种非常简单的形式的不确定性非常普遍，Scala为你提供了在集合内处理它的工具。在[列表2.2](#ch02ex02)中的辅助函数可以通过在投票映射上设置默认值来消除。
- en: Listing 2.3\. Setting default values on maps
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. 在映射上设置默认值
- en: '[PRE4]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 2.1.2\. The uncertainty of time
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 时间的不可确定性
- en: Building on this line of thinking, let’s consider a more relevant form of uncertainty.
    If the count of votes were stored on a different server than the one you’re on,
    then it would take time to retrieve those votes. The following listing approximates
    that idea using a random delay.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种思考方式，让我们考虑一种更相关的形式的不确定性。如果投票计数存储在你所在的服务器之外，那么检索这些投票将需要时间。以下列表使用随机延迟来近似这个想法。
- en: Listing 2.4\. A remote “database”
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 一个远程“数据库”
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* A function that retrieves the votes, but with varying amounts of delay**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个检索投票的函数，但带有不同的延迟量**'
- en: '***2* Always returns 52, eventually**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 最终总是返回52**'
- en: This sort of uncertainty is a big problem for the vote visualization app. Its
    server will be doing nothing, just waiting, while that call is processed. You
    can imagine that won’t help in the quest to achieve responsiveness at all times.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不确定性对于投票可视化应用来说是一个大问题。它的服务器将什么也不做，只是等待，直到调用被处理。你可以想象这根本无法帮助实现始终如一的反应性。
- en: The source of this performance problem is that the call to `getRemoteVotes`
    is *synchronous*. The solution to this problem is to use a *future*, which will
    ensure that this call is no longer made in a synchronous, blocking fashion. Using
    a future, you’ll be able to return immediately from a remote call like this and
    collect the result later, once the call has completed. The following listing shows
    how this can be done to answer the question “Which Howler is currently the most
    popular?”
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个性能问题的根源在于对`getRemoteVotes`的调用是*同步的*。解决这个问题的方法是使用*未来*，这将确保这个调用不再以同步、阻塞的方式执行。使用未来，你将能够立即从这样的远程调用中返回，并在调用完成后收集结果。以下列表展示了如何做到这一点，以回答“目前哪个Howler最受欢迎？”这个问题。
- en: Listing 2.5\. Futures-based remote calls
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. 基于未来的远程调用
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* A function that returns a future of the count of votes**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个返回投票计数未来的函数**'
- en: '***2* The creation of each of these futures returns immediately rather than
    blocking on the remote call.**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个这些未来的创建都会立即返回，而不是在远程调用上阻塞。**'
- en: '***3* This syntax is called a for expression.**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这种语法称为for表达式。**'
- en: '***4* A future that will eventually contain the maximum number of votes**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个最终将包含最大投票数的未来**'
- en: '***5* This will execute once all values in the for expression have been retrieved.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 这将在for表达式中所有值都被检索后执行。**'
- en: '***6* Prints “The top dog currently has 105 votes.”**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 打印“目前最受欢迎的狗有105票。”**'
- en: In this implementation, the three calls to the remote vote count collection
    are processed concurrently. Creation of a future doesn’t block on the remote call,
    waiting for completion of the work. Instead, the creation of the future returns
    immediately, allowing for the later concurrent processing. Using futures to abstract
    over time is a foundational technique that you’ll use repeatedly to scale up your
    reactive machine learning systems for handling huge amounts of data and complex
    operational behavior.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，对远程投票计数收集的三个调用是并发处理的。创建未来的操作不会在远程调用上阻塞，等待工作完成。相反，未来的创建会立即返回，允许后续的并发处理。使用未来来抽象时间是一个基础技术，你将反复使用它来扩展你的响应式机器学习系统，以处理大量数据和复杂的操作行为。
- en: The response time of a given request to a remote data source might, on average,
    be quite small. But with large amounts of data, it’s effectively guaranteed that
    some response times won’t be close to the average. This is an outcome of basic
    statistics. In a normally distributed dataset, there will be outliers. And in
    aggregation operations, like the maximum votes calculation in [listing 2.5](#ch02ex05),
    the average request latency has no effect on the total latency. Instead, the total
    latency is entirely determined by the single slowest request, as shown in [figure
    2.3](#ch02fig03).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对远程数据源的一个给定请求的响应时间可能平均来说相当小。但随着数据量的增加，实际上可以保证某些响应时间不会接近平均值。这是基本统计学的结果。在正态分布的数据集中，会有异常值。在聚合操作中，如[列表
    2.5](#ch02ex05)中的最大投票计算，平均请求延迟对总延迟没有影响。相反，总延迟完全由单个最慢请求决定，如图[图 2.3](#ch02fig03)所示。
- en: Figure 2.3\. Distribution of request times
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 请求时间分布
- en: '![](02fig03.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3](02fig03.jpg)'
- en: The amount of time it takes for that slowest request is often called the *tail
    latency*. It’s a very real problem in large-scale data-processing systems of all
    kinds, including machine learning systems. But now that you know tail latency
    is a problem, you can use reactive programming techniques to manage it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 那个最慢请求所需的时间通常被称为 *尾部延迟*。这是各种大规模数据处理系统（包括机器学习系统）中一个非常现实的问题。但现在你知道尾部延迟是一个问题，你可以使用响应式编程技术来管理它。
- en: Listing 2.6\. Futures-based timeouts
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 基于未来的超时
- en: '[PRE7]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Amount of time allowed before returning a value**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 允许返回值之前的时间量**'
- en: '***2* Historical average number of votes**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 历史平均投票数**'
- en: '***3* A future that will complete with the average number of votes after the
    timeout duration**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个在超时后完成平均投票数的未来**'
- en: '***4* A function to return the actual number of votes or the default, should
    the remote call timeout**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个函数，在远程调用超时时返回实际投票数或默认值**'
- en: In this implementation, you accept that life isn’t perfect, and some remote
    calls may exhibit unacceptable latency. Rather than pass that latency on to the
    user, you choose to return a degraded response, the historical average number
    of votes. That number isn’t literally accurate, but in this case it’s better than
    returning nothing at all. In a real system, you may have several options for what
    to return as a degraded response. For example, you may have another application
    to look this value up in, such as a cache. That cache’s value may have gotten
    stale, but that degraded value might be more useful than nothing at all. In other
    cases, you may want to encode retry logic. It’s up to you to figure out what’s
    best for your application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，你接受现实并不完美，一些远程调用可能会表现出不可接受的延迟。与其将这种延迟传递给用户，你选择返回降级响应，即历史平均投票数。这个数字并不完全准确，但在这个情况下，它比什么也不返回要好。在真实系统中，你可能有多种选择来返回降级响应。例如，你可能有一个其他应用程序来查找这个值，比如缓存。那个缓存中的值可能已经过时，但这个降级值可能比什么也没有更有用。在其他情况下，你可能想要编码重试逻辑。这取决于你决定什么最适合你的应用程序。
- en: '![](responsive.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![响应式系统](responsive.jpg)'
- en: You may not like planning to fail some of the time, and if so, I can understand
    your misgivings. As engineers, we’re used to building systems that return perfectly
    correct answers every time. But in machine learning systems, uncertainty is pervasive
    and intrinsic. It turns out that the same is true of distributed systems as well.
    If we want our systems to be reactive and responsive, we’re going to have to use
    tactics like these *some* of the time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不喜欢有时计划失败，如果这样，我可以理解你的疑虑。作为工程师，我们习惯于构建每次都能返回完全正确答案的系统。但在机器学习系统中，不确定性是普遍和固有的。结果发现，分布式系统也是如此。如果我们想让我们的系统具有反应性和响应性，我们有时将不得不使用这些策略。
- en: As you’ll see in [chapter 5](kindle_split_016.html#ch05) and beyond, there are
    several machine learning–specific scenarios where we need to fall back in some
    way on a less-than-perfect response. Prudent risk-mitigation tactics like these
    will help us tame some of the complexity of our machine learning system.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在[第5章](kindle_split_016.html#ch05)及以后看到的那样，有几个机器学习特定的场景，我们需要以某种方式退回到一个不太完美的响应。像这样的谨慎风险缓解策略将帮助我们驯服我们机器学习系统的一些复杂性。
- en: 2.2\. Akka, a reactive toolkit
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. Akka，一个反应式工具包
- en: The next tool I’m going to introduce is Akka. It’s an important tool to understand
    because it gives you reusable components to construct elastic and resilient systems.
    As you saw in [chapter 1](kindle_split_011.html#ch01), it can be easy to build
    a machine learning system that doesn’t hold up to the real-world challenges of
    scale and failure. Akka and the ideas behind it provide solutions to some of those
    problems.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我接下来要介绍的工具是Akka。了解它非常重要，因为它为你提供了可重用的组件来构建弹性且具有弹性的系统。正如你在[第1章](kindle_split_011.html#ch01)中看到的，构建一个无法应对真实世界规模和失败挑战的机器学习系统可能很容易。Akka及其背后的理念为这些问题提供了一些解决方案。
- en: But first, I’ll spend some time familiarizing you with the basics of Akka usage.
    Compared to the Akka material later in the book, this section is introductory
    and mostly intended to give you some context and understanding of *how* Akka does
    what it does. Once you’re comfortable with how systems built on Akka achieve their
    guarantees, then we can move on to using Akka primarily as a dependent library
    that powers higher-level abstractions. Don’t worry if some of Akka remains a mystery
    to you. We’ll only be using Akka for some parts of this book. It’s a powerful
    and complex toolkit; this section only scratches the surface of what it can do.
    The main goal here is to develop a mental model of how an Akka system honors its
    guarantees. But before you can understand how Akka works, you need to understand
    how actors work.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我会花些时间让你熟悉Akka的基本用法。与书中后面的Akka材料相比，本节是入门级的，主要目的是给你提供一些背景和了解Akka是如何工作的。一旦你熟悉了基于Akka构建的系统如何实现其保证，我们就可以继续使用Akka作为主要依赖库，为高级抽象提供动力。不用担心Akka中的一些内容对你来说仍然是神秘的。我们只会在这本书的某些部分使用Akka。它是一个强大且复杂的工具包；本节只是触及了它所能做到的一小部分。这里的主要目标是建立一个心理模型，了解Akka系统是如何履行其保证的。但在你理解Akka是如何工作之前，你需要了解行为者是如何工作的。
- en: 2.2.1\. The actor model
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 行为者模型
- en: 'The actor model is a way of thinking of the world that identifies each thing
    as an actor. What’s an actor? An actor is a pretty simple thing. In response to
    a message it receives, it can only do three things:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 行为者模型是一种看待世界的方式，它将每一件事物都视为一个行为者。什么是行为者？行为者是一个非常简单的东西。在接收到一条消息后，它只能做三件事：
- en: Send messages
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送消息
- en: Create new actors
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的行为者
- en: Decide how to behave when it receives its next message
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定在接收到下一条消息时如何表现
- en: That may sound limiting, but it’s quite useful.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些限制，但实际上非常有用。
- en: '![](message-driven.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](message-driven.jpg)'
- en: First, let’s consider communicating via sending messages. You saw this communication
    style in action in the Sniffable example from [chapter 1](kindle_split_011.html#ch01).
    I proposed that the model service would have been better able to contain its failure
    had it communicated with the main app via message passing, illustrated in [figure
    2.4](#ch02fig04).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑通过发送消息进行沟通。你在[第1章](kindle_split_011.html#ch01)的Sniffable示例中看到了这种沟通方式。我提出，如果模型服务通过消息传递与主应用进行通信，它将更好地能够控制其失败，如图2.4所示。
- en: Figure 2.4\. A contained model-serving architecture
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 一个封装的模型服务架构
- en: '![](02fig04.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig04.jpg)'
- en: '![](containment.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](containment.jpg)'
- en: Message passing in itself gives a system some of the benefits of a full actor
    system. That’s because message passing is an effective approach to implementing
    containment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递本身就能给系统带来一些完整actor系统的益处。这是因为消息传递是实现封装的有效方法。
- en: By implementing strong boundaries that can only be crossed via messages, actors
    (or services that behave like actors) can’t contaminate other components of the
    system when they fail. In a large system refactoring, often a good place to start
    is by separating out components so they only communicate via message passing.
    That would have been a good next step for the developers of the Pooch Predictor
    system from [chapter 1](kindle_split_011.html#ch01). Well-contained components
    of a machine learning system are easier to operate and improve on the journey
    to reactivity.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施只能通过消息跨越的强大边界，当actor（或像actor一样行为的服务）失败时，它们不能污染系统的其他组件。在大规模系统重构中，通常一个好的开始是分离组件，使它们只能通过消息传递进行通信。对于第一章中Pooch
    Predictor系统的开发者来说，那将是一个很好的下一步。机器学习系统的良好封装组件更容易操作，并在向反应性进军的道路上进行改进。
- en: '![](supervision.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](supervision.jpg)'
- en: Next, actors may also have the power to create new actors. That’s important
    for things like creating a supervisory hierarchy. You’ll see several examples
    of supervisory hierarchies in this book, with Akka actors and other related concepts.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，actor也可能拥有创建新actor的能力。这对于创建监督层次结构等重要事情来说很重要。你将在本书中看到几个关于监督层次结构的例子，包括Akka
    actor和其他相关概念。
- en: You also saw this on a larger scale in the Sniffable example from [chapter 1](kindle_split_011.html#ch01).
    In that section, I proposed that the system as a whole would benefit from a supervisory
    hierarchy, shown again in [figure 2.5](#ch02fig05).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第一章的Sniffable示例中也看到了这一点。在那个部分，我提出整个系统将受益于一个监督层次结构，如图2.5所示。
- en: Figure 2.5\. A supervisory architecture
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 一个监督架构
- en: '![](02fig05.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig05.jpg)'
- en: '![](resilient.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](resilient.jpg)'
- en: In this architecture, the supervisor has the complete power of life and death
    over supervised services. That’s exactly how things work in the actor model. The
    benefits of supervision are similar to the benefits of containment in this context.
    By building the concept of failure into the architecture, you now how have system-level
    solutions for inevitable failures.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，监督者对被监督服务拥有生死大权。这正是actor模型中的工作方式。监督的好处与这种环境下的封装好处相似。通过将故障概念构建到架构中，你现在拥有了针对不可避免故障的系统级解决方案。
- en: 'Lastly, actors can do something you haven’t seen before: they can change their
    behavior. After receiving a given message, an actor will decide to do something
    different the next time it receives a message. This means that actors are stateful,
    a bit like objects in imperative object-oriented programming (as in Java, Python,
    and so on). Most of the code you’ve seen thus far has hewed to a functional programming
    style that tries to avoid explicit state manipulation. But components of the system
    like remote services have a current state, and you’ll find the actor model a useful
    approach to reasoning about that state. The actor model has a coherent concept
    of how to encapsulate that state while providing a method of interacting with
    the outside world. That doesn’t mean you’ll throw out all the advantages of immutable
    facts and pure functions. Only code that needs to deal with state will be stateful.
    But a fully reactive machine learning system has many components with many different
    needs. Thankfully, Scala is a robust and pragmatic language that privileges the
    benefits of immutability and purity but allows you to handle state when necessary.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，actor可以做你以前没见过的事情：它们可以改变自己的行为。在接收到给定消息后，actor将决定在下次收到消息时做不同的事情。这意味着actor是有状态的，有点像命令式面向对象编程（如Java、Python等）中的对象。到目前为止，你看到的代码大多遵循尝试避免显式状态操作的函数式编程风格。但系统中的组件，如远程服务，有当前状态，你会发现actor模型是推理该状态的有用方法。actor模型有一个关于如何封装该状态并提供与外界交互方法的一致概念。但这并不意味着你会放弃所有不可变事实和纯函数的优势。只有需要处理状态的代码才会是有状态的。但一个完全反应性的机器学习系统有许多具有许多不同需求的组件。幸运的是，Scala是一种强大且实用的语言，它优先考虑不可变性和纯函数的优势，但在必要时允许你处理状态。
- en: 2.2.2\. Ensuring resilience with Akka
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 使用Akka确保弹性
- en: 'That’s enough theory; let’s put the actor model to work with a real problem:
    ensuring reliable records of votes on *Howlywood Star*. You’re still within the
    same overall *Howlywood Star* voting system originally shown in [figure 2.1](#ch02fig01).
    But now you’re concerned specifically with writing received votes from the API
    servers in the remote vote database. This is obviously a pretty common software
    development scenario, so I’m going to complicate it slightly. In this scenario,
    a Chihuahua was put in charge of maintaining the database, and it did a really
    bad job. Sometimes the database will record the vote, and other times the database
    will just poop itself by throwing an exception. This fundamental unreliability
    means you’ll need to implement the actor hierarchy shown in [figure 2.6](#ch02fig06).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了；让我们用一个真实的问题来应用演员模型：确保在 *Howlywood Star* 上的投票记录的可靠性。你仍然处于之前在 [图 2.1](#ch02fig01)
    中展示的相同的 *Howlywood Star* 投票系统。但现在你特别关注从远程投票数据库中的 API 服务器写入接收到的投票。这显然是一个相当常见的软件开发场景，所以我将稍微复杂化它。在这个场景中，一只吉娃娃被指派负责维护数据库，但它做得非常糟糕。有时数据库会记录投票，而有时数据库会因为抛出异常而“自己拉屎”。这种基本的不可靠性意味着你需要实现
    [图 2.6](#ch02fig06) 中所示的演员层次结构。
- en: Figure 2.6\. Vote-writing actor hierarchy
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. 投票写入演员层次结构
- en: '![](02fig06.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig06.jpg)'
- en: All remote resources like databases have a certain level of unreliability, but
    this one is worse than most. The database fails to record a write every other
    time a vote is sent across.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所有远程资源，如数据库，都有一定的不可靠性，但这个比大多数都要糟糕。每次投票发送时，数据库都会有一半的时间无法记录写入操作。
- en: Listing 2.7\. An unreliable database
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. 不可靠的数据库
- en: '[PRE8]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* A simple object used to represent a database**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用于表示数据库的简单对象**'
- en: '***2* A hash map to hold the votes**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 用于存储投票的哈希表**'
- en: '***3* This will throw an exception half the time.**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这将有一半的时间抛出异常。**'
- en: '***4* A pattern-matching expression is used to destructure the map entry into
    a key and a value.**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用模式匹配表达式将映射条目解构为键和值。**'
- en: '|  |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Mutable objects**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变对象**'
- en: '[Listing 2.7](#ch02ex07) uses a `var`, a mutable object. Mutable objects are
    used very infrequently in idiomatic Scala code. In this example, the use of mutability
    is just to simplify this example. It’s not necessary to use mutability here, and
    we’ll generally avoid the use of `var` in this book in favor of immutable objects.
    But Scala gives us the choice between using mutable and immutable data, which
    can be helpful for exploring the trade-offs of the relevant design choices.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.7](#ch02ex07) 使用了一个 `var`，一个可变对象。在惯用的 Scala 代码中，可变对象使用得非常少。在这个例子中，使用可变性的目的只是为了简化这个例子。在这里使用可变性是不必要的，我们在这本书中通常会避免使用
    `var`，而是选择不可变对象。但 Scala 给我们提供了使用可变和不可变数据的选择，这有助于探索相关设计选择的权衡。'
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If I’ve said it once, I’ve said it a hundred times: you just can’t trust purse
    dogs with crucial systems administration tasks—they don’t have the focus. Database
    administration is clearly a job for a Mastiff.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我说过一次，我就说过一百次：你绝对不能把关键的系统管理任务交给看家狗——它们没有专注力。数据库管理显然是牧羊犬的工作。
- en: This situation is a mess. You want to record instances of votes in this database.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况一团糟。你想要在这个数据库中记录投票的实例。
- en: Listing 2.8\. A vote case class
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 投票案例类
- en: '[PRE9]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But that Chihuahua has made all this much harder. Some of the votes will get
    lost by the database. Worse, if you don’t protect your vote-writing code, it will
    fail on the first exception it receives.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但那只吉娃娃让这一切变得更加困难。一些投票会被数据库丢失。更糟糕的是，如果你不保护你的投票写入代码，它会在接收到第一个异常时失败。
- en: '![](resilient.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](resilient.jpg)'
- en: I do have some good news, though. Voting on *Howlywood Star* is a large-scale
    data-processing application. Any individual vote isn’t that important. You’ve
    been told by management that losing some of these votes is totally acceptable
    and even expected. What’s crucial is that the voting application remain responsive
    in the face of underlying failures.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我有一些好消息。在 *Howlywood Star* 上的投票是一个大规模数据处理应用。任何单个投票并不那么重要。管理层告诉你，丢失一些这些投票是完全可以接受的，甚至是可以预期的。关键的是，投票应用在面对底层故障时仍然保持响应。
- en: '![](infinite-data.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](infinite-data.jpg)'
- en: When you move on to building large-scale machine learning systems, you’ll see
    similar situations. The value of any one feature or instance won’t be that great,
    because you’ll be processing large aggregates to learn models and make predictions.
    Sometimes data can be discarded. Remember, you assume that data is effectively
    *infinite* in a reactive machine learning system.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续构建大规模机器学习系统时，你会看到类似的情况。任何一个特征或实例的价值都不会很大，因为你将处理大量的聚合数据来学习模型和做出预测。有时数据可以被丢弃。记住，你假设在反应式机器学习系统中数据实际上是*无限的*。
- en: In fact, this technique of judicious prioritization and sacrificing data will
    come together into an incredibly useful reactive programming technique called
    the *circuit breaker* pattern, which I discuss later in the book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这种权衡优先级和牺牲数据的技巧将结合成一个非常有用的反应式编程技术，称为*断路器*模式，我将在本书的后面讨论。
- en: Let’s see how you can fulfill the limited scope of your mission even with your
    unreliable vote database. Using Akka, create a vote writer as an actor.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看即使在不可靠的投票数据库中，你如何完成你有限的使命。使用Akka，创建一个作为actor的投票写入器。
- en: Listing 2.9\. A vote-writing actor
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9\. 一个投票写入actor
- en: '[PRE10]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* A simple actor that receives votes and writes them to the database**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个简单的actor，接收投票并将它们写入数据库**'
- en: '***2* The method that will receive messages to the actor**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将接收actor消息的方法**'
- en: Now create another actor to supervise this actor, as shown in the following
    listing. It will be responsible for handling failures by the `VoteWriter` due
    to the unreliable database. This supervisory actor should merely recover from
    errors and not worry about any data that might have been lost.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建另一个actor来监督这个actor，如下所示。它将负责处理由于不可靠的数据库导致的`VoteWriter`的故障。这个监督actor只需从错误中恢复，而不必担心可能丢失的任何数据。
- en: Listing 2.10\. A supervisory actor
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.10\. 一个监督actor
- en: '[PRE11]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* A supervisory actor instantiated with a Props, a configuration object
    for an actor**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Props和一个actor的配置对象实例化的监督actor**'
- en: '***2* Supervision strategy the supervisory actor will use for the VoteWriter**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 监督actor将为VoteWriter使用的监督策略**'
- en: '***3* The strategy is to restart in the event of failure; this will clear any
    internal state in the actor.**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 策略是在失败时重启；这将清除actor中的任何内部状态。**'
- en: '***4* Creates the writer actor in the given context**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在给定上下文中创建writer actor**'
- en: '***5* Passes all messages through to the supervised VoteWriter actor**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将所有消息传递给被监督的VoteWriter actor**'
- en: Note that you use `Restart`, which is an Akka `Directive`, a convenient building
    block provided by the Akka toolkit. [Listing 2.11](#ch02ex11) shows how all these
    can be brought together. First, you create a new actor system for the application.
    Next you connect to your database. Then, you construct your actor hierarchy of
    a `VoteWriter` supervised by a `WriterSupervisor`. With all these elements in
    place, you can now send votes to the database using your actor system. This app
    ends with printing the number of votes that the database has.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你使用了`Restart`，这是Akka的`Directive`，是Akka工具包提供的一个方便的构建块。[列表2.11](#ch02ex11)展示了如何将这些元素组合在一起。首先，为应用程序创建一个新的actor系统。然后连接到你的数据库。然后，构建由`WriterSupervisor`监督的`VoteWriter`actor层次结构。在所有这些元素就绪后，你现在可以使用actor系统向数据库发送投票。这个应用程序以打印数据库中的投票数量结束。
- en: Listing 2.11\. Full voting app
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 完整投票应用程序
- en: '[PRE12]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Instantiates a new actor system**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化一个新的actor系统**'
- en: '***2* Connects to the database**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 连接到数据库**'
- en: '***3* Creates a Props configuration object for the VoteWriter**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为VoteWriter创建一个Props配置对象**'
- en: '***4* Creates a Props for the WriterSupervisor**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为WriterSupervisor创建一个Props**'
- en: '***5* Creates actors from the Props objects**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从Props对象创建actor**'
- en: '***6* Sending messages in Akka is done using the ! method.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在Akka中使用!方法发送消息。**'
- en: 'This approach definitely achieves some resilience in the face of failure. Moreover,
    it shows how you can build the possibility of failure into the application structure
    from the most trivial of beginnings. But you’re probably not satisfied with this
    solution:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在面临失败时确实实现了一定的弹性。此外，它展示了你如何从最简单的基础开始构建失败的可能性。但你可能对这个解决方案不满意：
- en: The database uses mutability.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库使用可变性。
- en: The app can and does lose data.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以并且确实会丢失数据。
- en: Explicitly building this actor hierarchy required you to think a lot about exactly
    how the underlying database might fail.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式构建这个actor层次结构需要你深入思考底层数据库可能出现的故障情况。
- en: Recording data in a database sounds like a common problem that someone else
    has probably already solved.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中记录数据听起来像是一个别人可能已经解决的问题。
- en: 'If you see these issues as deficiencies in this design, you’re 100% right.
    This simple example isn’t the ideal way to record your data in a database. All
    of [chapter 3](kindle_split_014.html#ch03) is dedicated to a better approach to
    collecting and persisting data. There, I’ll build on the approach you’ve seen
    in this chapter as a guide for how we want to interact with databases. We’ll still
    use Akka actors, but we’ll get to zoom up to a higher level of abstraction that
    keeps the focus on our application logic and not on low-level failure-handling
    concerns. The Akka toolkit is extremely powerful, and many libraries and frameworks
    make excellent use of it to build reactivity into applications. The next section
    introduces one of the best of those frameworks: Spark.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为这些问题是设计中的缺陷，那么您100%是对的。这个简单的示例并不是在数据库中记录数据的理想方式。第[3章](kindle_split_014.html#ch03)的全部内容都是致力于收集和持久化数据的一种更好的方法。在那里，我将基于本章中您所看到的方法，作为我们如何与数据库交互的指南。我们仍然会使用Akka
    actors，但我们将提升到一个更高层次的抽象，这样就可以将重点放在我们的应用程序逻辑上，而不是在低级故障处理问题上。Akka工具包非常强大，许多库和框架都很好地利用它来构建应用程序的反应性。下一节将介绍这些最佳框架之一：Spark。
- en: 2.3\. Spark, a reactive big data framework
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. Spark，一个反应式大数据框架
- en: 'Spark is the last tool we’ll consider in this chapter. It’s a framework for
    large-scale data processing, written in Scala. There are lots of reasons to use
    Spark to process large amounts of data:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Spark是本章我们将考虑的最后一个工具。它是一个用Scala编写的用于大规模数据处理的框架。有许多原因使用Spark来处理大量数据：
- en: It’s an incredibly fast data-processing engine.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个极快的数据处理引擎。
- en: It can handle enormous amounts of data when used on a cluster.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在集群上使用时，它可以处理大量数据。
- en: It’s easy to use, thanks to an elegant, functional API.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于优雅的函数式API，它易于使用。
- en: It has libraries that support common use cases like data analysis, graph analytics,
    and machine learning.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有支持常见用例的库，如数据分析、图分析和机器学习。
- en: 'We’ll use Spark in [chapters 4](kindle_split_015.html#ch04) and [5](kindle_split_016.html#ch05)
    to build out one of the core components of a machine learning system: the feature-generation
    and model-learning pipeline. Spark is the textbook example of a reactive system,
    and later chapters explain much of the how and why of Spark’s reactivity. But
    before we get into that deeper exploration of Spark, I want to get you started
    with a simple example problem: predicting the future.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](kindle_split_015.html#ch04)和[第5章](kindle_split_016.html#ch05)中使用Spark来构建机器学习系统的一个核心组件：特征生成和模型学习管道。Spark是反应式系统的教科书示例，后续章节将解释Spark反应性的许多如何和为什么。但在我们深入探索Spark之前，我想用一个简单的示例问题让您开始：预测未来。
- en: The Spark framework is one of several high-level tools that we’ll use in this
    book to build reactive machine learning systems. In this example, we’ll tackle
    the problem of predicting the number of votes that the *Howlywood Star* systems
    will receive in the hours leading up to the close of voting. Historically, the
    last few hours of voting in a week are the most intense in terms of load, so the
    *Howlywood Star* engineering team wants to plan for the upcoming season’s traffic
    spikes. You have at your disposal some historical files that describe basic data
    about the voting activity over time, and with that and Spark you can build a model
    to predict the number of votes that will be cast over time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Spark框架是我们将在本书中使用的几个高级工具之一，用于构建反应式机器学习系统。在这个例子中，我们将解决预测在投票截止前几小时内*Howlywood
    Star*系统将收到的投票数量的问题。从历史上看，一周投票的最后几个小时在负载方面是最紧张的，所以*Howlywood Star*工程团队希望为即将到来的赛季的流量峰值做好准备。您有一些描述投票活动基本数据的历史文件，以及Spark，您可以使用这些文件构建一个模型来预测随时间推移将投下的投票数量。
- en: First, you’ll need to do some basic setup to begin building a Spark app. Specifically,
    you’ll create a configuration object to hold all your settings, and a context
    object that defines a specific execution context from those settings.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要做一些基本设置才能开始构建Spark应用。具体来说，您将创建一个配置对象来保存所有设置，以及一个上下文对象，该对象定义了从这些设置中特定的执行上下文。
- en: Listing 2.12\. Basic Spark setup
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12\. 基本Spark设置
- en: '[PRE13]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* A session for your app**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为您的应用设置会话**'
- en: '***2* Imports serializers for primitive datatypes in your session**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在您的会话中导入原始数据类型的序列化器**'
- en: The `SparkSession` object you create here is used as your connection between
    regular Scala code and objects managed by Spark, potentially on a cluster. The
    next listings show how a `SparkSession` can be used to deal with things like I/O
    operations.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里创建的 `SparkSession` 对象用作你与 Spark 管理的对象之间的连接，这些对象可能位于集群上。接下来的列表显示了如何使用 `SparkSession`
    来处理诸如 I/O 操作等问题。
- en: These setup steps give you a lot of options that are particularly relevant when
    you’re scaling up to massive clusters. But for the moment, most of those capabilities
    are irrelevant, so we’ll ignore them. In [chapter 4](kindle_split_015.html#ch04)
    and beyond, we’ll dig deeper into taking advantage of the rich possibilities Spark
    offers. For the moment, we’ll take advantage of the simplicity of the API to get
    started with a minimum of boilerplate.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置步骤为你提供了许多选项，当你扩展到大型集群时尤其相关。但就目前而言，大多数这些功能都是不相关的，所以我们将忽略它们。在[第 4 章](kindle_split_015.html#ch04)及以后，我们将更深入地探讨如何利用
    Spark 提供的丰富可能性。目前，我们将利用 API 的简单性，以最少的样板代码开始。
- en: Load the data for the two datasets that you’ll use to build the model.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 加载你将用于构建模型的两个数据集的数据。
- en: Listing 2.13\. Handling the data path
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.13\. 处理数据路径
- en: '[PRE14]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* The path to where you put the example files from the repo**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将存储库中的示例文件放置的路径**'
- en: '***2* Where you want to write the modeling outputs of this pipeline**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你想将此管道的建模输出写入的位置**'
- en: '***3* Creates a unique path per execution to make rerunning simpler**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为每次执行创建一个唯一的路径，以便重新运行更简单**'
- en: In a model-learning pipeline, the data used to learn the model is called the
    *training set*. The data used to evaluate the learned model is called the *test
    set*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型学习管道中，用于学习模型的数据称为 *训练集*。用于评估学习模型的称为 *测试集*。
- en: One important detail to note about these datasets is that the training data
    comes from older shows than the testing data. In dealing with time series data
    like this, it’s always important to cleanly separate the *in-sample* data used
    for training from the *out-of-sample* data used for testing. If you fail to do
    that, then your testing data no longer represents an expectation of the model’s
    behavior when released on truly new data. In this case, I’ve prepared the data
    for you, so there’s no danger of you committing this data-handling error, unless
    you mix up the training and testing sets.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些数据集的一个重要细节是，训练数据来自比测试数据更早的节目。在处理此类时间序列数据时，始终重要的是要清楚地分离用于训练的 *样本内* 数据和用于测试的
    *样本外* 数据。如果你未能做到这一点，那么你的测试数据就不再代表模型在真正新数据上发布时的行为预期。在这种情况下，我已经为你准备好了数据，所以你不会犯这种数据处理错误，除非你混淆了训练集和测试集。
- en: Next, you need to load these files into Spark’s in-memory representation of
    datasets, called *resilient distributed datasets* (RDDs). RDDs are Spark’s core
    abstraction. They provide enormous amounts of data in memory, spread across a
    cluster without you having to explicitly implement that distribution. In fact,
    RDDs can even handle what happens when some data disappears due to cluster nodes
    failing, again without you having to concern yourself with handling this failure.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将这些文件加载到 Spark 的数据集内存表示中，称为 *弹性分布式数据集*（RDDs）。RDDs 是 Spark 的核心抽象。它们在内存中提供大量数据，分布在集群上，而你无需显式实现这种分布。实际上，RDDs
    甚至可以处理由于集群节点故障导致某些数据消失的情况，而你无需担心处理这种故障。
- en: First, you’ll load the data using a Spark utility for loading data. Then, you’ll
    pass a function as an argument to the data.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将使用 Spark 的数据加载实用程序加载数据。然后，你将一个函数作为参数传递给数据。
- en: Listing 2.14\. Loading training and testing data
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.14\. 加载训练和测试数据
- en: '[PRE15]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Loads the data from a file. Common data formats are supported, including
    machine learning–specific ones.**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从文件中加载数据。支持常见的数据格式，包括机器学习特定的格式。**'
- en: '***2* The map function applies a higher-order function to the RDD.**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 映射函数将高阶函数应用于 RDD。**'
- en: '***3* A LabeledPoint is a machine learning–specific type designed to encode
    an instance consisting of a feature vector and a concept.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* LabeledPoint 是一种专门为机器学习设计的类型，用于编码由特征向量和概念组成的实例。**'
- en: '***4* The cache method tells Spark you intend to reuse this data, so keep it
    in memory if possible.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 缓存方法告诉 Spark 你打算重用这些数据，因此如果可能的话，请将其保留在内存中。**'
- en: '***5* Same code as the training set, repeated for the testing set, shown for
    clarity**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 与训练集相同的代码，重复用于测试集，以清晰展示**'
- en: '![](pure-functions.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](pure-functions.jpg)'
- en: There are a few things worth calling out in this small code listing. First,
    it uses a higher-order pure function.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小代码列表中，有几件事情值得指出。首先，它使用了一个高阶纯函数。
- en: '|  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Functions that can be passed as arguments to other functions are known as *higher-order
    functions*. Using them is a pervasive technique in Scala programming and Spark
    applications.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 可以作为其他函数参数传递的函数被称为*高阶函数*。在Scala编程和Spark应用中使用它们是一种普遍的技术。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This is the standard pattern you’ll use to interact with Spark RDDs. Spark uses
    this functional programming model whereby you pass functions to the data as a
    way of distributing data-processing workloads across a cluster. This isn’t merely
    a syntax; Spark will literally serialize this function and send it to all the
    nodes storing the data in the RDD. Shifting from *sending data to functions* to
    *sending functions to data* is one of the changes you make when using big data
    stacks like Hadoop and Spark.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与Spark RDDs交互的标准模式。Spark使用这种函数式编程模型，其中你将函数传递给数据，作为在集群中分配数据处理工作负载的方式。这不仅仅是一种语法；Spark实际上会序列化这个函数并将其发送到存储RDD中数据的所有节点。从*将数据发送到函数*到*将函数发送到数据*的转变，是使用像Hadoop和Spark这样的大数据堆栈时所做的改变之一。
- en: '![](laziness.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![懒散.jpg](laziness.jpg)'
- en: Also, although it may not be clear, all the preceding Spark code is lazy. No
    data is read at the time that these commands are issued. Recapping from [chapter
    1](kindle_split_011.html#ch01), laziness is the intentional delay of execution.
    Ensuring the best possible performance in executing your data-processing task
    is a key part of Spark’s strategy. By waiting until the last moment to evaluate,
    Spark can make informed choices about what data to process and where to send it.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管可能不太明显，所有前面的Spark代码都是懒加载的。在发出这些命令时不会读取任何数据。回顾[第1章](kindle_split_011.html#ch01)，懒加载是有意延迟执行。确保在执行数据处理任务时获得最佳性能是Spark策略的关键部分。通过等待最后一刻才进行评估，Spark可以做出明智的选择，决定处理哪些数据以及将数据发送到何处。
- en: Having loaded the data, you can now learn a linear model for the data using
    one of MLlib’s learning algorithms. The following listing uses linear regression
    to derive that linear model.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据后，你现在可以使用MLlib的学习算法之一来学习数据的线性模型。以下列表使用线性回归推导出线性模型。
- en: Listing 2.15\. Training a model
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.15\. 训练模型
- en: '[PRE16]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Max number of iterations the algorithm should run for**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 算法应该运行的迭代次数的最大值**'
- en: '***2* The model learned on the training set**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在训练集上学习到的模型**'
- en: At this point, you’ve merely learned a model—you have no idea whether that model
    is good enough for the critical problem of predicting future canine singing sensations.
    You can’t use it to make predictions within the live system.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你仅仅学习了一个模型——你不知道这个模型是否足够好，足以解决预测未来犬类歌唱感的关键问题。你无法在实时系统中使用它进行预测。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Linear regression**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性回归**'
- en: 'For those unfamiliar with linear models, they’re simply a statistical technique
    for finding the line that most closely tracks all the data points. We won’t get
    into the details of different model-learning algorithms until [chapter 5](kindle_split_016.html#ch05).
    If you’re interested in linear regression specifically, Wikipedia has a good introduction:
    [https://en.wikipedia.org/wiki/Linear_regression](https://en.wikipedia.org/wiki/Linear_regression).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉线性模型的人来说，它们只是寻找最接近所有数据点的线的统计技术。我们不会在[第5章](kindle_split_016.html#ch05)中详细介绍不同的模型学习算法。如果你对线性回归特别感兴趣，维基百科有一个很好的介绍：[https://en.wikipedia.org/wiki/Linear_regression](https://en.wikipedia.org/wiki/Linear_regression)。
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To understand how useful this model is, you should now evaluate it on data that
    it hasn’t seen—the testing set.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个模型有多有用，你现在应该使用它尚未见过的数据——测试集来评估它。
- en: Listing 2.16\. Testing a model
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.16\. 测试模型
- en: '[PRE17]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Another higher-order function, this uses pattern matching to destructure
    the LabeledPoints in the testing set.**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 另一个高阶函数，它使用模式匹配来解构测试集中的LabeledPoints。**'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Destructuring**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**解构**'
- en: Destructuring is a common technique in Scala and other functional programming
    languages. It’s the inverse operation of instantiating a data structure. When
    used with pattern matching, it provides a convenient syntax for giving names to
    the pieces of a data structure.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是Scala和其他函数式编程语言中的一种常见技术。它是实例化数据结构的逆操作。当与模式匹配一起使用时，它提供了一种方便的语法，用于给数据结构的部分命名。
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you’ve applied this model to new data, you can use more utilities from
    MLlib to report on the performance of the model.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将此模型应用于新数据，你可以使用 MLlib 的更多实用工具来报告模型的性能。
- en: Listing 2.17\. Model metrics
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.17\. 模型指标
- en: '[PRE18]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* A metrics object that can calculate various performance statistics**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个可以计算各种性能统计的指标对象**'
- en: '***2* The precision of the model on the testing set**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模型在测试集上的精确度**'
- en: '***3* The recall of the model on the testing set**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 模型在测试集上的召回率**'
- en: '***4* Prints performance statistics to the console**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将性能统计信息打印到控制台**'
- en: Finally, you can save this model to disk.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将此模型保存到磁盘。
- en: Listing 2.18\. Saving a model
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.18\. 保存模型
- en: '[PRE19]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to save learned models is a tricky topic once you get into it. I discuss
    it more in [chapters 6](kindle_split_017.html#ch06) and [7](kindle_split_018.html#ch07).
    For the moment, having a saved version of the model on disk will be sufficient.
    It would be useful if you wanted to use this model on other data in the future.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦深入研究，如何保存学习模型是一个棘手的话题。我在第 6 章（kindle_split_017.html#ch06）和第 7 章（kindle_split_018.html#ch07）中对此进行了更多讨论。目前，在磁盘上保存模型的版本将足够。如果你将来想在其他数据上使用此模型，这将很有用。
- en: The model could now be used to predict future vote counts. Given a feature vector,
    the model could be used to predict the expected number of votes. The *Howlywood
    Star* engineering team could plan around the possibility of peak load getting
    as high as the predicted value from the model.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用该模型来预测未来的投票数。给定一个特征向量，可以使用该模型来预测预期的投票数。*Howlywood Star* 工程团队可以围绕模型预测的峰值负载可能达到的预测值来制定计划。
- en: 'That prediction may or may not be correct, but it’s still useful for planning
    purposes. The metrics reported, the precision and the recall, give you some view
    into how much you can trust the predictions of the model. Later in the book, I
    discuss more-sophisticated approaches to modeling, and these approaches require
    you to reason more about the performance of learned models. But those approaches
    build on the process you’ve seen here: training a model and then evaluating it
    on a test set to see how it will perform. You’ll even see how you can combine
    model metrics like these with reactive techniques to make machine learning systems
    that do some of this work for you.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 该预测可能正确也可能不正确，但对于规划目的仍然很有用。报告的指标，即精确度和召回率，让你对可以信任模型预测的程度有所了解。本书后面将讨论更复杂的建模方法，这些方法需要你对学习模型的性能进行更多推理。但这些方法建立在你在本节中看到的过程中：训练一个模型，然后在测试集上评估它以查看其性能。你甚至将看到如何将这些模型指标与反应式技术相结合，以创建为你完成一些工作的机器学习系统。
- en: Predicting the future is definitely hard work, but building the pipeline to
    do it is quite easy if you use the right tools. With the techniques shown in this
    chapter, the *Howlywood Star* team was able to build out a pretty impressive backend
    for a canine reality show. Using Spark, they were able to predict absurdly high
    levels of viewer engagement, leading to massive load on the voting system, and
    plan accordingly. But they weren’t able to predict the breakout success of Tail-Chaser
    Swift, the winner of Season 2\. Who could? That season, the audience loved poodles.
    They got to vote on every song, dance, and trick that the aspiring Howlywood Stars
    had to offer, thanks to a reactive system supporting the apps that they love.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 预测未来绝对是一项艰巨的工作，但如果你使用正确的工具，构建执行这项工作的管道相当简单。使用本章中展示的技术，*Howlywood Star* 团队能够构建一个相当令人印象深刻的犬类现实秀的后端。使用
    Spark，他们能够预测观众参与度的极端高水平，导致投票系统负载巨大，并相应地进行规划。但他们无法预测 Tail-Chaser Swift 在第二季的成功突破。谁能呢？那个赛季，观众喜欢贵宾犬。他们可以为他们喜爱的应用程序支持的每个歌曲、舞蹈和技巧投票，多亏了支持这些应用程序的反应式系统。
- en: '|  |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Resources**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源**'
- en: 'This chapter has been a quick, shallow introduction to some incredibly complicated
    and powerful technologies. If you want to learn more about any of these three
    technologies, Manning has several relevant books for you:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了某些极其复杂且强大的技术。如果你想了解更多关于这些三种技术中的任何一种，Manning 有几本相关的书籍供你选择：
- en: '*Scala*—*Functional Programming in Scala*: [www.manning.com/books/functional-programming-in-scala](http://www.manning.com/books/functional-programming-in-scala);
    *Scala in Action*: [www.manning.com/books/scala-in-action](http://www.manning.com/books/scala-in-action);
    *Scala in Depth*: [www.manning.com/books/scala-in-depth](http://www.manning.com/books/scala-in-depth)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Scala*—*Scala中的函数式编程*：[www.manning.com/books/functional-programming-in-scala](http://www.manning.com/books/functional-programming-in-scala)；*Scala实战*：[www.manning.com/books/scala-in-action](http://www.manning.com/books/scala-in-action)；*Scala深入解析*：[www.manning.com/books/scala-in-depth](http://www.manning.com/books/scala-in-depth)'
- en: '*Akka*—*Akka in Action*: [www.manning.com/books/akka-in-action](http://www.manning.com/books/akka-in-action)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Akka*—*Akka实战*：[www.manning.com/books/akka-in-action](http://www.manning.com/books/akka-in-action)'
- en: '*Spark*—*Spark in Action*: [www.manning.com/books/spark-in-action](http://www.manning.com/books/spark-in-action)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spark*—*Spark实战*：[www.manning.com/books/spark-in-action](http://www.manning.com/books/spark-in-action)'
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Scala gives you constructs to help you reason about uncertainty:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala为您提供帮助您推理不确定性的结构：
- en: Options abstract over the uncertainty of something being present or not.
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项抽象了某物存在或不存在的可能性。
- en: Futures abstract over the uncertainty of actions, which take time.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Futures抽象了需要时间执行的动作的不确定性。
- en: Futures give you the ability to implement timeouts, which help ensure responsiveness
    through bounding response times.
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Futures让您能够实现超时，这有助于通过限制响应时间来确保响应性。
- en: 'With Akka, you can build protections against failure into the structure of
    your application using the power of the actor model:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Akka，您可以使用actor模型的力量将故障保护构建到应用程序的结构中：
- en: Communication via message passing helps you keep system components contained.
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过消息传递进行通信有助于您将系统组件保持在一个范围内。
- en: Supervisory hierarchies can help ensure resilience of components.
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督层次结构可以帮助确保组件的弹性。
- en: One of the best ways to use the power of the actor model is in libraries that
    use it behind the scenes, instead of doing much of the definition of the actor
    system directly in your code.
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用actor模型力量的最佳方式之一是在幕后使用它的库，而不是直接在代码中大量定义actor系统。
- en: 'Spark gives you reasonable components to build data-processing pipelines:'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark为您提供构建数据处理管道的合理组件：
- en: Spark pipelines are constructed using pure functions and immutable transformations.
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark管道使用纯函数和不可变转换构建。
- en: Spark uses laziness to ensure efficient, reliable execution.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spark使用惰性来确保高效、可靠的执行。
- en: MLlib provides useful tools for building and evaluating models with a minimum
    of code.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MLlib提供了构建和评估模型的有用工具，代码量最少。
- en: In the next chapter, we’ll begin building out a real, large-scale machine learning
    system. I’ll show you how to address the intrinsic uncertainty of real-world data
    in your data model. Also, I’ll show how to use an immutable database of facts
    to achieve horizontal scalability. As part of that, I’ll introduce a distributed
    database called Couchbase. Finally, I’ll show how you can use reactive programming
    idioms to handle the uncertainties of processing time and failure.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建一个真实的大规模机器学习系统。我会向您展示如何在数据模型中处理现实世界数据的内在不确定性。此外，我会展示如何使用不可变的事实数据库实现水平扩展。作为其中的一部分，我会介绍一个名为Couchbase的分布式数据库。最后，我会展示您如何使用反应式编程惯用用法来处理处理时间和故障的不确定性。
