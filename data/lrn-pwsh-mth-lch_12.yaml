- en: 12 Filtering and comparisons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 过滤和比较
- en: 'Up to this point, you’ve been working with whatever output the shell gave you:
    all the processes, filesystem objects, and various Azure commands. But this type
    of output isn’t always going to be what you want. Often you’ll want to narrow
    down the results to a few items that specifically interest you, such as getting
    processes or files that match a pattern. That’s what you’ll learn to do in this
    chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在处理 shell 提供的任何输出：所有进程、文件系统对象和各种 Azure 命令。但这类输出并不总是你想要的。通常，你希望将结果缩小到几个特定感兴趣的项目，例如获取匹配特定模式的进程或文件。这就是你将在本章中学到的内容。
- en: 12.1 Making the shell give you just what you need
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 让 shell 只给你你需要的内容
- en: The shell offers two broad models for narrowing results, and they’re both referred
    to as *filtering*. In the first model, you try to instruct the cmdlet that’s retrieving
    information for you to retrieve only what you’ve specified. In the second model
    (discussed in section 12.5), which takes an iterative approach, you take everything
    the cmdlet gives you and use a second cmdlet to filter out the things you don’t
    want.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: shell 提供了两种广泛的结果缩小模型，它们都被称为 *过滤*。在第一种模型中，你试图指示为你检索信息的 cmdlet 只检索你指定的内容。在第二种模型（在第
    12.5 节中讨论），它采用迭代方法，你接受 cmdlet 提供的所有内容，并使用第二个 cmdlet 过滤掉你不需要的内容。
- en: 'Ideally, you’ll use the first model, which we call *filter left*, as much as
    possible. It may be as simple as telling the cmdlet what you’re after. For example,
    with `Get-Process`, you can tell it which process names you want:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应尽可能多地使用我们称之为 *过滤左侧* 的第一种模型。这可能只是告诉 cmdlet 你想要什么。例如，使用 `Get-Process`，你可以告诉它你想要哪些进程名称：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But if you want `Get-Process` to return only the processes with more than 1
    GB of memory, regardless of their names, you can’t tell the cmdlet to do that
    for you, because it doesn’t offer any parameters to specify that information.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想让 `Get-Process` 只返回内存超过 1 GB 的进程，而不考虑它们的名称，你不能告诉 cmdlet 为你完成这个任务，因为它没有提供任何参数来指定该信息。
- en: Similarly, if you’re using the `Get-ChildItem`, it includes the `-Path` parameter,
    which supports wildcards. Although you could get all files and filter using `Where-Object`,
    we don’t recommend it. Once again, this technique is ideal because the cmdlet
    has to retrieve only matching objects. We call this the *filter left*, sometimes
    referred to as *early filtering*, technique.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你使用的是 `Get-ChildItem`，它包括 `-Path` 参数，支持通配符。虽然你可以获取所有文件并使用 `Where-Object`
    进行过滤，但我们不推荐这样做。再次强调，这种技术之所以理想，是因为 cmdlet 只需要检索匹配的对象。我们称之为 *过滤左侧* 技术或称为 *早期过滤*
    技术。
- en: 12.2 Filtering left
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 过滤左侧
- en: '*Filter left* means putting your filtering criteria as far to the left, or
    toward the beginning, of the command line as possible. The earlier you can filter
    out unwanted objects, the less work the remaining cmdlets on the command line
    will have to do, and possibly less unnecessary information may have to be transmitted
    across the network to your computer.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*过滤左侧* 意味着尽可能将过滤条件放在命令行的左侧或开头。你越早过滤掉不需要的对象，剩余的命令行上的 cmdlet 就需要做的工作就越少，并且可能需要传输到计算机的网络上的不必要信息就越少。'
- en: The downside of the filter-left technique is that every single cmdlet can implement
    its own means of specifying filtering, and every cmdlet will have varying abilities
    to perform filtering. With `Get-Process`, for example, you can filter only on
    the `Name` or `Id` property of the processes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤左侧技术的缺点是每个单独的 cmdlet 都可以实现自己的指定过滤方式，并且每个 cmdlet 在执行过滤方面的能力都不同。例如，使用 `Get-Process`，你只能根据进程的
    `Name` 或 `Id` 属性进行过滤。
- en: When you’re not able to get a cmdlet to do all the filtering you need, you can
    turn to a PowerShell Core cmdlet called `Where-Object` (which has the alias `where`).
    This uses a generic syntax, and you can use it to filter any kind of object after
    you’ve retrieved it and put it into the pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法让 cmdlet 完成所有需要的过滤时，你可以转向一个名为 `Where-Object` 的 PowerShell Core cmdlet（别名为
    `where`）。它使用通用语法，你可以在将对象检索并放入管道后使用它来过滤任何类型的对象。
- en: To use `Where-Object`, you need to learn how to tell the shell what you want
    to filter, and that involves using the shell’s comparison operators.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Where-Object`，你需要学习如何告诉 shell 你想要过滤的内容，这涉及到使用 shell 的比较运算符。
- en: 12.3 Using comparison operators
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用比较运算符
- en: 'In computers, a *comparison* always takes two objects or values and tests their
    relationship to one another. You might be testing whether they’re equal, or whether
    one is greater than another, or whether one of them matches a text pattern of
    some kind. You indicate the kind of relationship you want to test by using a *comparison
    operator*. The result of the test in simple operations results in a Boolean value:
    `True` or `False`. Put another way, either the tested relationship is as you specified,
    or it isn’t.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，一个 *比较* 总是涉及两个对象或值，并测试它们之间的关系。你可能正在测试它们是否相等，或者一个是否大于另一个，或者它们是否匹配某种文本模式。你通过使用
    *比较运算符* 来表示你想要测试的关系类型。简单操作中的测试结果会产生一个布尔值：`True` 或 `False`。换句话说，测试的关系要么是你指定的那样，要么不是。
- en: 'PowerShell uses the following comparison operators. Note that when comparing
    text strings, these aren’t case sensitive; an uppercase letter is seen as equal
    to a lowercase letter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 使用以下比较运算符。请注意，当比较文本字符串时，这些运算符不是大小写敏感的；大写字母被视为与小写字母相等：
- en: '`-eq`—Equality, as in `5` `-eq` `5` (which is `True`) or `"hello"` `-eq` `"help"`
    (which is `False`)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eq`—相等，例如 `5` `-eq` `5`（这是 `True`）或 `"hello"` `-eq` `"help"`（这是 `False`）'
- en: '`-ne`—Not equal to, as in `10` `-ne` `5` (which is `True`) or `"help"` `-ne`
    `"help"` (which is `False`, because they are, in fact, equal, and we’re testing
    to see if they’re unequal)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ne`—不等于，例如 `10` `-ne` `5`（这是 `True`）或 `"help"` `-ne` `"help"`（这是 `False`，因为实际上它们是相等的，而我们正在测试它们是否不相等）'
- en: '`-ge` and `-le`—Greater than or equal to, and less than or equal to, as in
    `10` `-ge` `5` (`True`) or `(Get-Date)` `-le` `''2020-12-02''` (which will depend
    on when you run this, and shows how dates can be compared)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge` 和 `-le`—大于或等于，以及小于或等于，例如 `10` `-ge` `5`（这是 `True`）或 `(Get-Date)` `-le`
    `''2020-12-02''`（这取决于你何时运行它，并展示了如何比较日期）'
- en: '`-gt` and `-lt`—Greater than and less than, as in `10` `-lt` `10` (`False`)
    or `100` `-gt` `10` (`True`)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt` 和 `-lt`—大于和小于，例如 `10` `-lt` `10`（这是 `False`）或 `100` `-gt` `10`（这是 `True`）'
- en: 'For string comparisons, you can also use a separate set of case-sensitive operators
    if needed: `-ceq`, `-cne`, `-cgt`, `-clt`, `-cge`, `-cle`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串比较，如果需要，你也可以使用一组单独的大小写敏感运算符：`-ceq`、`-cne`、`-cgt`、`-clt`、`-cge`、`-cle`。
- en: 'If you want to compare more than one thing at once, you can use the logical
    operators `-and` and `-or`. Each takes a subexpression on either side, and we
    usually enclose them in parentheses to make the line easier to read:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要同时比较多个事物，你可以使用逻辑运算符 `-and` 和 `-or`。每个运算符都包含其一边的一个子表达式，我们通常将它们括起来以使行更容易阅读：
- en: '`(5` `-gt` `10)` `-and` `(10` `-gt` `100)` is `False`, because one or both
    subexpressions are `False`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(5` `-gt` `10)` `-and` `(10` `-gt` `100)` 是 `False`，因为一个或两个子表达式是 `False`。'
- en: '`(5` `-gt` `10)` `-or` `(10` `-lt` `100)` is `True`, because at least one subexpression
    is `True`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(5` `-gt` `10)` `-or` `(10` `-lt` `100)` 是 `True`，因为至少有一个子表达式是 `True`。'
- en: 'In addition, the logical `-not` operator reverses `True` and `False`. This
    can be useful when you’re dealing with a variable or a property that already contains
    `True` or `False`, and you want to test for the opposite condition. For example,
    if you want to test whether a process isn’t responding, you could do the following
    (you’ll use `$_` as a placeholder for a process object):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，逻辑 `-not` 运算符会反转 `True` 和 `False`。当你处理一个已经包含 `True` 或 `False` 的变量或属性，并想要测试相反条件时，这可能很有用。例如，如果你想测试一个进程是否没有响应，你可以这样做（你将使用
    `$_` 作为进程对象的占位符）：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'PowerShell defines `$False` and `$True` to represent the `False` and `True`
    Boolean values. Another way to write that comparison is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 定义了 `$False` 和 `$True` 来表示 `False` 和 `True` 布尔值。另一种写这种比较的方法如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Because `Responding` normally contains `True` or `False`, the `-not` reverses
    `False` to `True`. If the process isn’t responding (meaning `Responding` is `False`),
    your comparison will return `True`, indicating that the process is “not responding.”
    We prefer the second technique because it reads, in English, more like what we’re
    testing for: “I want to see if the process isn’t responding.” You’ll sometimes
    see the `-not` operator abbreviated as an exclamation mark (`!`).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Responding` 通常包含 `True` 或 `False`，所以 `-not` 将 `False` 反转为 `True`。如果进程没有响应（意味着
    `Responding` 是 `False`），你的比较将返回 `True`，表示进程“没有响应”。我们更喜欢第二种技术，因为它在英语中读起来更像我们正在测试的内容：“我想看看进程是否没有响应。”你有时会看到
    `-not` 运算符被缩写为感叹号 (`!`)。
- en: 'A couple of other comparison operators are useful when you need to compare
    strings of text:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要比较文本字符串时，一些其他的比较运算符也很有用：
- en: '`-like`—Accepts `*, ?,` and `[]` as wildcards, so you can compare to see if
    `"Hello"` `-like` `"*ll*"` (that would be `True`). The reverse is `-notlike`,
    and both are case insensitive; use `-clike` and `-cnotlike` for case-sensitive
    comparisons. You can find the other available wildcards in the `about_Wildcards`
    help file.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-like`——接受`*, ?,`和`[]`作为通配符，因此你可以比较以查看`"Hello"` `-like` `"*ll*"`（这将返回`True`）。相反的是`-notlike`，两者都不区分大小写；使用`-clike`和`-cnotlike`进行大小写敏感的比较。你可以在`about_Wildcards`帮助文件中找到其他可用的通配符。'
- en: '`-match`—Makes a comparison between a string of text and a regular expression
    pattern. Its logical opposite is `-notmatch`, and as you might expect, `-cmatch`
    and `-cnotmatch` provide case-sensitive versions. Regular expressions are covered
    in a later chapter of this book.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-match`——在文本字符串和正则表达式模式之间进行比较。它的逻辑对立面是`-notmatch`，正如你所期望的，`-cmatch`和`-cnotmatch`提供了大小写敏感的版本。正则表达式将在本书的后续章节中介绍。'
- en: The neat thing about the shell is that you can run almost all of these tests
    right at the command line (the exception is the one using the `$_` placeholder—it
    won’t work by itself, but you’ll see where it will work in the next section).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于壳（shell）的整洁之处在于，你几乎可以在命令行中直接运行所有这些测试（例外是使用`$_`占位符的测试——它单独使用时不会工作，但你在下一节中会看到它在哪里会工作）。
- en: Try it Now Go ahead and try any—or all—of these comparisons. Type them on a
    line—for example, `5 -eq 5`—press Enter, and see what you get.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 好吧，尝试这些比较中的任何一个——或者全部——。在一行上输入它们——例如，`5 -eq 5`——按Enter键，看看你得到什么。
- en: You can find the other available comparison operators in the `about_Comparison
    _Operators` help file, and you’ll learn about a few of the other ones in chapter
    25.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`about_Comparison_Operators`帮助文件中找到其他可用的比较运算符，你将在第25章中了解其中的一些。
- en: 12.4 Filtering objects out of the pipeline
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 从管道中过滤对象
- en: Once you’ve written a comparison, where do you use it? Well, you can use it
    with the shell’s generic filtering cmdlet, `Where-Object`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了一个比较，你将在哪里使用它？嗯，你可以使用shell的通用过滤cmdlet，`Where-Object`。
- en: For example, do you want to get rid of all processes but the ones using more
    than 100 MB of memory (`WorkingSet`)?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你想删除所有进程，但保留使用超过100 MB内存（`WorkingSet`）的进程吗？
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `-FilterScript` parameter is positional, which means you’ll often see this
    typed without it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`-FilterScript`参数是位置参数，这意味着你通常会看到它没有指定就输入：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you get used to reading that aloud, it sounds sensible: “where `WorkingSet`
    greater than 100 MB.” Here’s how it works: when you pipe objects to `Where-Object`,
    it examines each one of them using its filter. It places one object at a time
    into the `$_` placeholder and then runs the comparison to see whether it’s `True`
    or `False`. If it’s `False`, the object is dropped from the pipeline. If the comparison
    is `True`, the object is piped out of `Where-Object` to the next cmdlet in the
    pipeline. In this case, the next cmdlet is `Out-Default`, which is always at the
    end of the pipeline (as we discussed in chapter 11) and which kicks off the formatting
    process to display your output.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于大声朗读这些内容，听起来是有道理的：“`WorkingSet`大于100 MB的地方。”这是它的工作原理：当你将对象通过管道传递给`Where-Object`时，它会使用其过滤器检查每一个对象。它一次将一个对象放入`$_`占位符中，然后运行比较以查看它是`True`还是`False`。如果是`False`，对象将从管道中丢弃。如果比较是`True`，对象将从`Where-Object`中流出，传递到管道中的下一个cmdlet。在这种情况下，下一个cmdlet是`Out-Default`，它总是位于管道的末尾（正如我们在第11章中讨论的那样），并且它启动了格式化过程以显示你的输出。
- en: 'That `$_` placeholder is a special creature: you’ve seen it used before (in
    chapter 10), and you’ll see it in one or two more contexts. You can use this placeholder
    only in the specific places where PowerShell looks for it, and this happens to
    be one of those places. As you learned in chapter 10, the period tells the shell
    that you’re not comparing the entire object, but rather just one of its properties,
    `WorkingSet`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`$_`占位符是一个特殊的实体：你之前已经见过它被使用过（在第10章中），你还会在另一个或两个上下文中看到它。你只能在使用PowerShell查找它的特定位置使用此占位符，这恰好是那些位置之一。正如你在第10章中学到的，点号告诉shell你并不是在比较整个对象，而是在比较它的一个属性，`WorkingSet`。
- en: 'We hope you’re starting to see where `Get-Member` comes in handy. It gives
    you a quick and easy way to discover the properties of an object, which lets you
    turn around and use those properties in a comparison like this one. Always keep
    in mind that the column headers in PowerShell’s final output don’t always reflect
    the property names. For example, run `Get-Process`, and you’ll see a column like
    `PM(MB)`. Run `Get-Process` `|` `Get-Member`, and you’ll see that the actual property
    name is `PM`. That’s an important distinction: always verify property names by
    using `Get-Member`; don’t use a `Format-` cmdlet.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能开始看到 `Get-Member` 的用途。它为你提供了一个快速简单的方式来发现对象属性，这让你可以转过来在比较中使用这些属性，就像这样。始终记住，PowerShell
    最终输出中的列标题并不总是反映属性名称。例如，运行 `Get-Process`，你会看到一个像 `PM(MB)` 这样的列。运行 `Get-Process`
    `|` `Get-Member`，你会看到实际的属性名是 `PM`。这是一个重要的区别：始终通过使用 `Get-Member` 来验证属性名称；不要使用 `Format-`
    命令。
- en: Above and beyond
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: PowerShell v3 introduced a new “simplified” syntax for `Where-Object`. You can
    use it only when you’re doing a single comparison; if you need to compare multiple
    items, you still have to use the original syntax, which is what you’ve seen in
    this section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell v3 引入了一种新的“简化”语法用于 `Where-Object`。你只能在执行单个比较时使用它；如果你需要比较多个项目，你仍然必须使用原始语法，这就是你在本节中看到的语法。
- en: 'Folks debate whether or not this simplified syntax is helpful. It looks something
    like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 人们争论这种简化的语法是否有帮助。它看起来可能像这样：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Obviously, that’s a bit easier to read: it dispenses with the curly brackets
    `{}` and doesn’t require the use of the awkward-looking `$_` placeholder. But
    this new syntax doesn’t mean you can forget about the old syntax, which you still
    need for more-complex comparisons:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这更容易阅读：它省略了花括号 `{}`，并且不需要使用看起来尴尬的 `$_` 占位符。但这个新语法并不意味着你可以忘记旧语法，你仍然需要它来进行更复杂的比较：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What’s more, there are years’ worth of examples out on the internet that all
    use the old syntax, which means you have to know it to use them. You also have
    to know the new syntax, because it will now start cropping up in developers’ examples.
    Having to know two sets of syntax isn’t exactly “simplified,” but at least you
    know what’s what.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，互联网上有数年的示例，所有这些示例都使用旧语法，这意味着你必须知道它才能使用它们。你还必须知道新语法，因为现在它将开始在开发者的示例中出现。需要知道两套语法并不完全是“简化”，但至少你知道是什么。
- en: 12.5 Using the iterative command-line model
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 使用迭代命令行模型
- en: We want to go on a brief tangent with you now to talk about what we call the
    PowerShell iterative command-line model. The idea behind this model is that you
    don’t need to construct these large, complex command lines all at once and entirely
    from scratch. Start small.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想和你简要地谈谈我们所说的 PowerShell 迭代命令行模型。这个模型背后的想法是，你不需要一次性从头开始构建这些大型、复杂的命令行。从小处着手。
- en: 'Let’s say you want to measure the amount of virtual memory being used by the
    10 most virtual-memory-hungry processes. But if PowerShell itself is one of those
    processes, you don’t want it included in the calculation. Let’s take a quick inventory
    of what you need to do:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测量使用虚拟内存最多的 10 个进程的虚拟内存量。但如果 PowerShell 本身是这些进程之一，你不想将其包括在计算中。让我们快速盘点一下你需要做什么：
- en: Get processes.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取进程。
- en: Get rid of everything that’s PowerShell.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有 PowerShell 相关的内容。
- en: Sort the processes by virtual memory.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按虚拟内存对进程进行排序。
- en: Keep only the top 10 or bottom 10, depending on how you sort them.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据排序结果，只保留前 10 个或后 10 个。
- en: Add up the virtual memory for whatever is left.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的虚拟内存加起来。
- en: We believe you know how to do the first three steps. The fourth is accomplished
    using your old friend, `Select-Object`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信你知道如何完成前三个步骤。第四步是通过使用你的老朋友 `Select-Object` 来实现的。
- en: Try it Now Take a moment and read the help for `Select-Object`. Can you find
    any parameters that would enable you to keep only the first or last object in
    a collection?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。花点时间阅读 `Select-Object` 的帮助。你能找到任何参数，使你能够只保留集合中的第一个或最后一个对象吗？
- en: We hope you found the answer. Finally, you need to add up the virtual memory.
    This is where you need to find a new cmdlet, probably by doing a wildcard search
    with `Get-Command` or `Help`. You might try the `Add` keyword, or the `Sum` keyword,
    or even the `Measure` keyword.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你已经找到了答案。最后，你需要将虚拟内存加起来。这是你需要找到一个新命令的地方，可能通过使用 `Get-Command` 或 `Help` 进行通配符搜索。你可以尝试使用
    `Add` 关键字，或者 `Sum` 关键字，甚至 `Measure` 关键字。
- en: Try it Now See if you can find a command that would measure the total of a numeric
    property like virtual memory. Use `Help` or `Get-Command` with the `*` wildcard.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。看看你是否能找到一个可以测量类似虚拟内存这样的数值属性的命令。使用 `Help` 或 `Get-Command` 与 `*` 通配符。
- en: As you’re trying these little tasks (and not reading ahead for the answer),
    you’re making yourself into a PowerShell expert. Once you think you have the answer,
    you might start in on the iterative approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试这些小任务（并且不提前阅读答案）时，你正在将自己变成 PowerShell 专家。一旦你认为你找到了答案，你可能会开始尝试迭代方法。
- en: 'To start, you need to get processes. That’s easy enough:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要获取进程。这很简单：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Try it Now Follow along in the shell and run these commands. After each, examine
    the output, and see if you can predict what you need to change for the next iteration
    of the command.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。在 shell 中跟随并运行这些命令。在每个命令之后，检查输出，看看你是否可以预测出你需要在下一个命令迭代中更改的内容。
- en: Next, you need to filter out what you don’t want. Remember, *filter left* means
    you want to get the filter as close to the beginning of the command line as possible.
    In this case, you’ll use `Where-Object` to do the filtering, because you want
    it to be the next cmdlet in the pipeline. That’s not as good as having the filtering
    occur on the first cmdlet, but it’s better than filtering later on down the pipeline.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要过滤掉你不需要的内容。记住，*filter left* 意味着你希望将过滤器尽可能靠近命令行的开头。在这种情况下，你将使用 `Where-Object`
    来进行过滤，因为你希望它是管道中的下一个 cmdlet。这不如在第一个 cmdlet 上进行过滤好，但比在管道的后面过滤要好。
- en: 'In the shell, press the up arrow on the keyboard to recall your last command,
    and then add the next command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中，按键盘上的上箭头键来回忆你的上一个命令，然后添加下一个命令：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’re not sure if it’s `pwsh` or `pwsh.exe`, so you use a wildcard comparison
    to cover all your bases. Any process that isn’t like those names will remain in
    the pipeline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你不确定是 `pwsh` 还是 `pwsh.exe`，所以你使用通配符比较来覆盖所有可能性。任何不与这些名称相似的进程都将保留在管道中。
- en: 'Run that to test it, and then press the up arrow again to add the next bit:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令来测试它，然后再次按上箭头键来添加下一个部分：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pressing Enter lets you check your work, and the up arrow lets you add the
    next piece of the puzzle:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Enter 键让你检查你的工作，上箭头键让你添加下一个部分：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Had you sorted in the default ascending order, you would have wanted to keep
    the `-last` `10` before adding this last bit:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按默认的升序排序，你会在添加这部分之前保留 `-last` `10`：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We hope you were able to figure out at least the name of that last cmdlet, if
    not the exact syntax used here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能至少找出那个最后一个 cmdlet 的名称，如果不是这里使用的确切语法。
- en: This model—running a command, examining the results, recalling it, and modifying
    it for another try—is what differentiates PowerShell from more traditional scripting
    languages. Because PowerShell is a command-line shell, you get those immediate
    results, as well as the ability to quickly and easily modify your command if the
    results aren’t what you expect. You should also be seeing the power you have when
    you combine even the handful of cmdlets you’ve learned up to this point in the
    book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型——运行命令、检查结果、回忆它，并修改它以进行另一次尝试——是 PowerShell 与更传统的脚本语言区别开来的地方。因为 PowerShell
    是一个命令行 shell，你可以立即获得结果，以及如果结果不是你所期望的，可以快速轻松地修改你的命令。你也应该看到，当你将你在本书中到目前为止学到的 cmdlet
    中的几个 cmdlet 结合起来时，你拥有的力量。
- en: 12.6 Common points of confusion
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 常见混淆点
- en: Anytime we introduce `Where-Object` in a class, we usually come across two main
    sticking points. We tried to hit those concepts hard in the preceding discussion,
    but if you have any doubts, we’ll clear them up now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候我们在类中引入 `Where-Object`，我们通常会遇到两个主要难点。我们试图在前面的讨论中深入探讨这些概念，但如果你有任何疑问，我们现在会澄清。
- en: 12.6.1 Filter left, please
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.1 请左过滤
- en: You want your filtering criteria to go *as close to the beginning of the command
    line as possible*. If you can accomplish the filtering you need in the first cmdlet,
    do so; if not, try to filter in the second cmdlet so that the subsequent cmdlets
    have as little work to do as possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的过滤条件尽可能靠近命令行的开头。如果你可以在第一个 cmdlet 中完成所需的过滤，就那样做；如果不能，尝试在第二个 cmdlet 中过滤，以便后续的
    cmdlet 有尽可能少的工作要做。
- en: Also, try to accomplish filtering as close to the source of the data as possible.
    For example, if you’re querying processes from a remote computer and need to use
    `Where-Object`—as we did in one of this chapter’s examples—consider using PowerShell
    remoting to have the filtering occur on the remote computer, rather than bringing
    all of the objects to your computer and filtering them there. You’ll tackle remoting
    in chapter 13, and we mention this idea of filtering at the source again there.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽量在数据源附近进行过滤。例如，如果你从远程计算机查询进程并需要使用 `Where-Object`——就像我们在本章的一个示例中所做的那样——考虑使用
    PowerShell 远程，以便在远程计算机上进行过滤，而不是将所有对象带到你的计算机上并在那里过滤它们。你将在第 13 章处理远程，我们将在那里再次提到在源处过滤的想法。
- en: 12.6.2 When $_ is allowed
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6.2 当 $_ 被允许时
- en: The special `$_` placeholder is valid only in the places where PowerShell knows
    to look for it. When it’s valid, it contains one object at a time from the ones
    that were piped into that cmdlet. Keep in mind that what’s in the pipeline can
    and will change throughout the pipeline, as various cmdlets execute and produce
    output.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的 `$_` 占位符仅在 PowerShell 知道查找它的位置有效。当它有效时，它每次包含从被管道传输到该 cmdlet 的对象中的一个。请记住，管道中的内容可以在管道的各个阶段发生变化，因为各种
    cmdlet 执行并产生输出。
- en: 'Also be careful of nested pipelines—the ones that occur inside a parenthetical
    command. For example, the following can be tricky to figure out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意嵌套管道——那些发生在括号命令内部的管道。例如，以下内容可能难以理解：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s walk through that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来：
- en: You start with `Get-Process`, but that isn’t the first command that will execute.
    Because of the parentheses, `Get-Content` will execute first.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从 `Get-Process` 开始，但这不是第一个要执行的命令。由于括号的存在，`Get-Content` 将首先执行。
- en: '`Get-Content` is piping its output—which consists of simple `String` objects—to
    `Where-Object`. That `Where-Object` is inside the parentheses, and within its
    filter, `$`_ represents the `String` objects piped in from `Get-Content`. Only
    those strings that don’t end in *daemon* will be retained and output by `Where-Object`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Content` 正在将输出——由简单的 `String` 对象组成——传输到 `Where-Object`。那个 `Where-Object`
    在括号内，在其过滤器中，`$`_ 代表从 `Get-Content` 管道传输进来的 `String` 对象。只有那些不以 *daemon* 结尾的字符串将被保留并由
    `Where-Object` 输出。'
- en: The output of `Where-Object` becomes the result of the parenthetical command,
    because `Where-Object` was the last cmdlet inside the parentheses. Therefore,
    all of the names that don’t end in *daemon* will be sent to the `-Name` parameter
    of `Get-Process`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Where-Object` 的输出成为括号命令的结果，因为 `Where-Object` 是括号内的最后一个 cmdlet。因此，所有不以 *daemon*
    结尾的名称都将发送到 `Get-Process` 的 `-Name` 参数。'
- en: Now `Get-Process` executes, and the `Process` objects it produces will be piped
    to `Where-Object`. That instance of `Where-Object` will put one service at a time
    into its `$`_ placeholder, and it will keep only those services whose `WorkingSet`
    property is greater than `128KB`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 `Get-Process` 执行，它产生的 `Process` 对象将被传输到 `Where-Object`。那个 `Where-Object`
    实例将每次将一个服务放入其 `$`_ 占位符中，并且它只保留那些 `WorkingSet` 属性大于 `128KB` 的服务。
- en: Sometimes we feel like our eyes are crossing with all the braces and curly braces,
    periods, and parentheses, but that’s how PowerShell works, and if you can train
    yourself to walk through the command carefully, you’ll be able to figure out what
    it’s doing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们觉得眼睛都交叉了，因为有所有的花括号、大括号、句点和括号，但这就是 PowerShell 的工作方式，如果你能训练自己仔细地遍历命令，你就能弄清楚它在做什么。
- en: 12.7 Lab
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.7 实验室
- en: 'Remember that `Where-Object` isn’t the only way to filter, and it isn’t even
    the one you should turn to first. We’ve kept this chapter brief to allow you more
    time to work on the hands-on examples. Keeping in mind the principle of *filter
    left*, try to accomplish the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Where-Object` 不是过滤的唯一方式，甚至也不是你应该首先考虑的方式。我们保持这一章节简短，以便你有更多时间来实际操作。考虑到 *filter
    left* 原则，尝试完成以下任务：
- en: Get the commands from the `PSReadLine` module.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `PSReadLine` 模块获取命令。
- en: Get the commands using the verb `Get` from the `PSReadLine` module.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `PSReadLine` 模块获取使用动词 `Get` 的命令。
- en: Display all files under /usr/bin that are larger than 5 MB.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 /usr/bin 下所有大于 5 MB 的文件。
- en: Find all modules on the PowerShell Gallery that start with `PS` and the author
    starts with Microsoft.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 PowerShell 画廊中以 `PS` 开头且作者以 Microsoft 开头的所有模块。
- en: 'Get the files in the current directory where the `LastWriteTime` is in the
    last week. (Hint: `(Get-Date).AddDays(-7)` will give you the date from a week
    ago.)'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前目录中 `LastWriteTime` 在上周的文件。（提示：（`Get-Date).AddDays(-7`）将给出上周的日期。）
- en: Display a list of all processes running with either the name `pwsh` *or* the
    name `bash`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示所有以名称 `pwsh` 或名称 `bash` 运行的进程列表。
- en: 12.8 Lab answers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.8 实验答案
- en: '`Get-Command -Module PSReadLine`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command -Module PSReadLine`'
- en: '`Get-Command Get-* -Module PSReadLine`'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command Get-* -Module PSReadLine`'
- en: '`Get-ChildItem /usr/bin/* | Where-Object {$_.length –gt 5MB}`'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem /usr/bin/* | Where-Object {$_.length –gt 5MB}`'
- en: '`Find-Module -Name PS* | Where-Object {$_.Author -like ''Microsoft*''}`'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Find-Module -Name PS* | Where-Object {$_.Author -like ''Microsoft*''}`'
- en: '`Get-ChildItem | where-object LastWriteTime -ge (get-date).AddDays(-7)`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem | where-object LastWriteTime -ge (get-date).AddDays(-7)`'
- en: '`Get-Process -Name pwsh,bash`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Process -Name pwsh,bash`'
- en: 12.9 Further exploration
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.9 进一步探索
- en: Practice makes perfect, so try filtering some of the output from the cmdlets
    you’ve already learned about, such as `Get-ChildItem`, `Get-Process`, and even
    `Get-Command`. For example, you might try to filter the output of `Get-Command`
    to show only cmdlets. Or use `Test-Connection` to ping several computers or websites
    (such as google.com or facebook.com), and show the results only from computers
    that didn’t respond. We’re not suggesting that you need to use `Where-Object`
    in every case, but you should practice using it when it’s appropriate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 熟能生巧，所以尝试过滤你已经学习过的 cmdlet 的输出，例如 `Get-ChildItem`、`Get-Process`，甚至是 `Get-Command`。例如，你可能尝试过滤
    `Get-Command` 的输出，只显示 cmdlet。或者使用 `Test-Connection` 来ping几个计算机或网站（如google.com或facebook.com），并只显示未响应的计算机的结果。我们并不是建议你在每种情况下都需要使用
    `Where-Object`，但你应该在适当的时候练习使用它。
