- en: 3 Introduction to JSX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 JSX 简介
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding JSX and its benefits
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JSX 及其优势
- en: Using JSX to implement custom components faster and easier
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSX 更快、更轻松地实现自定义组件
- en: React and JSX gotchas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 和 JSX 的陷阱
- en: JavaScript XML (JSX) is a syntax extension to JavaScript. It’s one of the things
    that make React great, but it was also one of the more controversial elements
    of React when it was introduced back in the day.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript XML (JSX) 是 JavaScript 的语法扩展。它是让 React 变得出色的因素之一，但在它当初被引入时，也是 React
    中更具争议性的元素之一。
- en: 'This is an example of using JSX in JavaScript:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 JavaScript 中使用 JSX 的示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'JSX is the element that appears between the angle brackets: <a href="//react
    .dev">React</a>. It’s not a string, not a template literal, and not HTML. It’s
    a JavaScript object that is created with the syntax extension called JSX. It makes
    creating React elements much faster and more compact and makes reading React elements
    much easier. The latter advantage is at least as important as the former.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是出现在尖括号之间的元素：<a href="//react .dev">React</a>。它不是一个字符串，不是一个模板字面量，也不是 HTML。它是一个使用称为
    JSX 的语法扩展创建的 JavaScript 对象。它使得创建 React 元素更快、更紧凑，并且使得阅读 React 元素更容易。后者的优势至少与前者一样重要。
- en: JSX is made for developers only. By itself, it doesn’t do anything to make better
    or faster web applications. JSX is converted to the same code you get when not
    using JSX.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是为开发者准备的。仅凭自身，它不会做任何事情来使 Web 应用程序更好或更快。JSX 转换为不使用 JSX 时得到的相同代码。
- en: Although JSX isn’t a requirement, it’s universally accepted as the only way
    to write React components. You may find a few teams out there not using JSX, but
    they are by far the minority.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSX不是必需的，但它被普遍接受为编写 React 组件的唯一方式。你可能会发现一些团队不使用 JSX，但它们绝对是少数。
- en: In this chapter, we’ll dive a bit more into the reasons for using JSX in the
    first place, then discuss all the different parts of applying JSX in practice,
    and, finally, cover some tricks that you need to pay attention to when using JSX.
    Along the way, we’ll also briefly discuss converting JSX to JavaScript, called
    *transpiling*, which you may remember from chapter 2\. Luckily, transpiling isn’t
    something you have to worry too much about.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨最初使用 JSX 的原因，然后讨论在实践应用 JSX 的所有不同部分，最后介绍一些在使用 JSX 时需要注意的技巧。在这个过程中，我们还将简要讨论将
    JSX 转换为 JavaScript，称为 *transpiling*，你可能还记得第 2 章的内容。幸运的是，transpiling 并不是你需要过多担心的事情。
- en: Note The source code for the examples in this chapter is available at [https://rq2e.com/ch03](https://rq2e.com/ch03).
    But as you learned in chapter 2, you can instantiate all the examples directly
    from the command line using a single command.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章示例的源代码可在 [https://rq2e.com/ch03](https://rq2e.com/ch03) 获取。但正如你在第 2 章中学到的，你可以使用单个命令直接从命令行实例化所有示例。
- en: 3.1 Why do we use JSX?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 我们为什么使用 JSX？
- en: 'JSX is a JavaScript extension that provides syntactic sugar (i.e., making it
    easier to type, but otherwise functionally equivalent) for function calls and
    object construction, particularly a replacement for React.createElement(). It
    may look like a template engine or HTML, but it isn’t. JSX produces React elements
    while allowing you to harness the full power of JavaScript. JSX is a great way
    to write React components and includes the following benefits:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是一个 JavaScript 扩展，为函数调用和对象构造提供了语法糖（即，使输入更简单，但功能上等效），尤其是 React.createElement()
    的替代品。它看起来像模板引擎或 HTML，但它不是。JSX 生成 React 元素，同时让你充分利用 JavaScript 的全部功能。JSX 是编写 React
    组件的绝佳方式，并具有以下优势：
- en: '*Improved developer experience*—Code is easier to read because it’s more eloquent,
    thanks to an XML-like syntax that’s better at representing nested declarative
    structures.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*改进的开发者体验*—由于具有更优雅的、类似于 XML 的语法，代码更容易阅读，这有助于表示嵌套声明性结构。'
- en: '*Better error messages*—React assumes that you use JSX and reports helpful
    error messages as if you are. If you’re not, the error messages will be somewhat
    misleading by referring to a different syntax than you actually use.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更好的错误信息*—React 假设你使用 JSX，并报告有用的错误信息，就像你真的在使用 JSX 一样。如果你没有使用 JSX，错误信息可能会有些误导，因为它会引用与你实际使用的语法不同的语法。'
- en: '*Faster code*—When converting JSX to JavaScript, the transpiler optimizes the
    code on the fly, making the resulting JavaScript execute faster than you could
    normally type by hand.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更快的代码*—当将 JSX 转换为 JavaScript 时，编译器会即时优化代码，使得生成的 JavaScript 执行速度比手动输入更快。'
- en: '*More productive team members*—Casual developers (e.g., designers) can modify
    code more easily because JSX looks like HTML, which is already familiar to them.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更高效的团队成员*——休闲开发者（例如，设计师）可以更容易地修改代码，因为 JSX 看起来像 HTML，这对他们来说已经很熟悉了。'
- en: '*Fewer syntax errors*—Developers have less code to type, which means they make
    fewer mistakes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*更少的语法错误*——开发者需要输入的代码更少，这意味着他们犯的错误也更少。'
- en: Although JSX isn’t required for React, it fits in nicely, and we highly recommended
    it, as do React’s creators. You’ll have a hard time finding any team in the real
    world that uses React without JSX. While we can’t say that *all* recent React
    projects in the world use JSX, we’re pretty confident that *almost all* do.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSX不是React的必需品，但它非常适合，我们强烈推荐它，正如React的创造者所做的那样。你很难在现实世界中找到一个不使用JSX的React团队。虽然我们无法说世界上所有的最新React项目都使用JSX，但我们相当确信几乎所有的项目都使用。
- en: 3.1.1 Before and after JSX
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 JSX 之前和之后
- en: 'To demonstrate the eloquence of JSX, this is the snippet required to create
    an element with a few custom components followed by a link:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示JSX的优雅，这是创建一个包含一些自定义组件和链接的元素的代码片段：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That’s identical to the following snippet implemented without the benefit of
    JSX:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下没有JSX优势的代码片段相同：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can probably all agree that the JSX version is much easier to understand
    at a glance. It looks like HTML, which is very easy to read, and it’s partially
    identical to the HTML output that will be rendered, except for the custom components,
    of course.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能都会同意 JSX 版本一眼就能看懂。它看起来像 HTML，非常容易阅读，并且部分上与将要渲染的 HTML 输出相同，当然，除了自定义组件之外。
- en: 3.1.2 Keeping HTML and JavaScript together
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 将 HTML 和 JavaScript 一起使用
- en: In essence, JSX is a small language with an XML-like syntax. It has changed
    the way people write user interface (UI) components. Previously, developers wrote
    HTML—and JavaScript code for controllers and views—in an MVC-like manner, jumping
    between various files. That stemmed from the separation of concerns in the early
    days. This approach served the web well when it consisted of static HTML, a little
    CSS, and a tiny bit of JavaScript to make text blink.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JSX 是一种具有类似 XML 语法的简单语言。它改变了人们编写用户界面（UI）组件的方式。以前，开发者以类似 MVC 的方式编写 HTML
    以及控制器和视图的 JavaScript 代码，在各个文件之间跳转。这源于早期关注点分离的理念。当网站只由静态 HTML、一点 CSS 和一点使文本闪烁的
    JavaScript 组成时，这种方法很好地服务于网络。
- en: This is no longer the case; today, we build highly interactive UIs, and JavaScript
    and HTML are tightly coupled to implement various pieces of functionality. This
    violates the principle of separation of concerns, which is a fundamental principle
    sought after in most software development. This principle is about separating
    unrelated items, but keeping related items together. If you seek to obey this
    principle, you should break your code down in such a way that every bit in isolation
    performs one and only one concern, and these “bits” can then be used in different
    connections. If you split your template and your view logic, but they only work
    if combined, then you have needlessly separated two items that belong together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况已经不再存在；如今，我们构建高度交互的用户界面（UIs），JavaScript 和 HTML 紧密耦合以实现各种功能。这违反了关注点分离的原则，这是大多数软件开发中追求的基本原则。这个原则是关于分离无关项，但将相关项放在一起。如果你寻求遵守这个原则，你应该将你的代码分解成这样的方式，即每个单独的部分只执行一个关注点，而这些“部分”可以用于不同的连接。如果你将模板和视图逻辑分开，但它们只有在结合使用时才能工作，那么你就无谓地分离了本应属于一起的两个项目。
- en: React fixes this invalidated principle by bringing together the description
    of the UI and the JavaScript logic; and with JSX, the code looks like HTML and
    is easier to read and write. If for no other reason, we would use React and JSX
    for this new approach to writing UIs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: React 通过将 UI 的描述和 JavaScript 逻辑结合在一起来修复这个被否定的原则；并且通过 JSX，代码看起来像 HTML，更容易阅读和编写。如果不是为了其他原因，我们也会使用
    React 和 JSX 来实现编写 UI 的新方法。
- en: JSX is compiled by various transformers (tools) into standard ECMAScript (see
    figure 3.1). You probably know that JavaScript is ECMAScript too, but JSX isn’t
    part of the specification and doesn’t have any defined semantics. That means that
    if you try to compile JavaScript with embedded JSX in a normal JavaScript compiler
    without transpiling the JSX first, you’ll get errors. JSX isn’t valid JavaScript
    on its own and can’t be compiled directly by a JavaScript compiler.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JSX被各种转换器（工具）编译成标准的ECMAScript（见图3.1）。你可能知道JavaScript也是ECMAScript，但JSX不是规范的一部分，也没有任何定义的语义。这意味着，如果你尝试在没有先转译JSX的情况下，使用普通的JavaScript编译器编译包含嵌入式JSX的JavaScript，你会得到错误。JSX本身不是有效的JavaScript，不能直接由JavaScript编译器编译。
- en: '![03-01](../Images/03-01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../Images/03-01.png)'
- en: Figure 3.1 JSX is transpiled into regular JavaScript.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 JSX被转换为常规JavaScript。
- en: Note We call it *transpiling* rather than *compiling* because we translate it
    from one source language (JSX) into another source language (JavaScript). The
    resulting JavaScript will then, in turn, be interpreted by a “real” compiler that
    runs the code. Transpiling is merely converting syntax rather than interpreting
    the code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们称之为“transpiling”（转译）而不是“compiling”（编译），因为我们将其从一种源语言（JSX）翻译成另一种源语言（JavaScript）。生成的JavaScript随后将由一个“真正的”编译器来解释执行。转译仅仅是转换语法，而不是解释代码。
- en: When your browser executes your React application, your browser will only see
    the React.createElement statements required to generate the structure that you
    need. It’s only in the editor that the JSX exists. The transpiler converts your
    files with JSX in them to pure JavaScript with React.createElement()s all over
    the place to save you the trouble.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的浏览器执行你的React应用程序时，你的浏览器只会看到生成所需结构的React.createElement语句。只有在你使用的编辑器中才会存在JSX。转译器将包含JSX的文件转换为纯JavaScript，其中到处都是React.createElement()，以节省你的麻烦。
- en: 'You may wonder why you should bother with JSX at all. Considering how counterintuitive
    JSX code looks to begin with for new developers, it’s no surprise that a few developers
    are turned off by this amazing technology. As an example, this bit of JavaScript
    has JSX in the middle of it, mixing in angle brackets where they normally would
    never exist:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么你应该费心去使用JSX。考虑到对于新开发者来说，JSX代码一开始看起来多么反直觉，一些开发者因此对这个令人惊叹的技术感到厌烦，这并不奇怪。例如，这段JavaScript代码中间有JSX，将尖括号混入通常不会存在的地方：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But what makes JSX amazing are the shortcuts to React.createElement(NAME, ...).
    Instead of writing that function call over and over, you can instead use <NAME
    />. And as mentioned earlier, the less you type, the fewer mistakes you make.
    With JSX, developer experience is the primary concern, that is, making it easier
    for developers to create components and applications faster and with fewer errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但使JSX变得惊人的是React.createElement(NAME, ...)的快捷方式。你不必反复编写这个函数调用，而是可以使用<NAME />。如前所述，你输入的越少，犯的错误就越少。在JSX中，开发者体验是首要关注的问题，也就是说，使开发者能够更快、更少错误地创建组件和应用程序。
- en: The main reason to use JSX is that many people find code with angle brackets
    (<>) easier to read than code with a lot of React.createElement() statements.
    Once you get into the habit of thinking about <NAME /> not as XML but as an alias
    to JavaScript code, you’ll get over the perceived weirdness of JSX syntax. Knowing
    and using JSX can make a big difference when you’re developing React components
    and, subsequently, React-powered applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSX的主要原因在于许多人发现带有尖括号（<>）的代码比带有大量React.createElement()语句的代码更容易阅读。一旦你习惯了将<NAME
    />视为不是XML而是JavaScript代码的别名，你就会克服JSX语法的直观上的怪异感。了解并使用JSX在开发React组件以及随后的React应用程序时可以带来很大的差异。
- en: As mentioned earlier, JSX needs to be transpiled into regular JavaScript before
    browsers can execute the code. In most setups, you’ll never have to worry about
    this, but we’ll discuss some transpilers in section 3.3 if you need to do it on
    your own. For now, we’ll dig in to fully understand JSX.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JSX需要在浏览器执行代码之前转换为常规JavaScript。在大多数设置中，你根本不必担心这一点，但如果需要自己进行转换，我们将在第3.3节中讨论一些转译器。现在，我们将深入探讨以充分理解JSX。
- en: 3.2 Understanding JSX
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 理解JSX
- en: Let’s explore how to work with JSX. You can read this section and keep it bookmarked
    for your reference, or (if you prefer to have some of the code examples running
    on your computer) start working on the examples using the create-react-app (CRA)
    templates listed throughout. With CRA, you get JSX transpiling “for free,” so
    you don’t have to worry about setting it up yourself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用 JSX。你可以阅读本节并将其添加到书签以供参考，或者（如果你更喜欢在计算机上运行一些代码示例）开始使用 create-react-app
    (CRA) 模板中的示例进行工作。使用 CRA，你可以“免费”获得 JSX 转译，因此你不必担心自己设置它。
- en: 3.2.1 Creating elements with JSX
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 使用 JSX 创建元素
- en: Creating React elements with JSX is straightforward. See table 3.1 for some
    examples of the JavaScript that you’ve previously used and its JSX equivalent.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 创建 React 元素非常简单。参见表 3.1 了解一些你之前使用的 JavaScript 代码及其 JSX 等价物。
- en: Table 3.1 JavaScript code versus JSX
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 JavaScript 代码与 JSX 的比较
- en: '| JavaScript | JSX equivalent |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript | JSX 等价物 |'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In the JSX code, the attributes and their values (e.g., size={6}) come from
    the second argument of createElement(). We’ll focus on working with properties
    later in this chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSX 代码中，属性及其值（例如，size={6}）来自 createElement() 的第二个参数。我们将在本章后面专注于处理属性。
- en: For now, let’s look at an example of JSX elements without properties. Here is
    one of our early examples from the previous chapter, upgraded to the recommended
    structure using a custom App component. It’s just an h1 element with the text
    “Hello world!” where the word “world” is set as italic, as shown next.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个没有属性的 JSX 元素示例。这是我们从上一章早期的一个例子，升级到使用自定义 App 组件的推荐结构。它只是一个包含文本“Hello
    world!”的 h1 元素，其中“world”一词被设置为斜体，如下所示。
- en: Listing 3.1 Emphasized greeting without JSX
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 无 JSX 的强调问候
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing this with JSX is so much simpler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX 实现这一点要简单得多。
- en: Listing 3.2 Emphasized greeting with JSX
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 使用 JSX 的强调问候
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can even store objects created with JSX syntax in variables because JSX
    is just a syntactic improvement of React.createElement(). This example stores
    the reference to the generated element in a variable before returning it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将使用 JSX 语法创建的对象存储在变量中，因为 JSX 只是 React.createElement() 的语法改进。此示例在返回之前将生成的元素引用存储在变量中：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is completely identical to line 4 in listing 3.2; it just uses an extra
    variable before returning.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这与列表 3.2 中的第 4 行完全相同；它只是在返回之前使用了一个额外的变量。
- en: 3.2.2 Using JSX with custom components
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 使用 JSX 与自定义组件
- en: The previous example used the <h1> JSX tag, which is also a standard HTML tag
    name. When working with custom components, you apply the same syntax. The only
    difference is that the component class name must start with a capital letter,
    as in <Title />.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子使用了 `<h1>` JSX 标签，它也是一个标准的 HTML 标签名。当与自定义组件一起使用时，你应用相同的语法。唯一的区别是组件类名必须以大写字母开头，如
    `<Title />`。
- en: Listing 3.3 shows a more advanced iteration of our three-link application from
    chapter 2, rewritten in JSX. In this case, you create a new component class and
    use JSX to create an element from it. Remember our Link example from the previous
    chapter? The code looked like the following without JSX (converted to the recommended
    App structure).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 展示了我们从第 2 章中提到的三个链接应用的更高级迭代，现在用 JSX 重新编写。在这种情况下，你创建一个新的组件类，并使用 JSX 从它创建一个元素。还记得我们之前章节中的
    Link 示例吗？没有 JSX 的代码如下所示（转换为推荐的 App 结构）。
- en: Listing 3.3 Three identical links without JSX
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 无 JSX 的三个相同链接
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using JSX, this now becomes listing 3.4\. If you run this in the browser, you
    get the exact same result as we did in figure 2.13 in chapter 2, which we show
    again in figure 3.2.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSX，现在变成了列表 3.4。如果你在浏览器中运行它，你会得到与我们在第 2 章图 2.13 中得到的结果完全相同，我们再次在图 3.2 中展示。
- en: '![03-02](../Images/03-02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../Images/03-02.png)'
- en: Figure 3.2 Three identical links in our application but now written using JSX
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 应用程序中的三个相同链接，但现在使用 JSX 编写
- en: Listing 3.4 Three identical links with JSX
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 使用 JSX 的三个相同链接
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Creates a component named Link that can later be instantiated by using the
    JSX notation <Link />
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为 Link 的组件，该组件可以使用 JSX 表记 <Link /> 实例化
- en: ❷ Opening parenthesis that starts the returned multiline JSX expression
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 开始返回多行 JSX 表达式的开括号
- en: ❸ React fragments are elements just like any other and can be rendered using
    JSX.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ React 片段就像任何其他元素一样，可以使用 JSX 渲染。
- en: ❹ Three identical instances of the Link component
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Link 组件的三个相同实例
- en: ❺ Closing parenthesis that completes the returned multiline JSX expression
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 完成返回多行 JSX 表达式的闭括号
- en: 'Repository: rq03-jsx-links'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-jsx-links
- en: 'This example can be seen in repository rq03-jsx-links. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在仓库 rq03-jsx-links 中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，在你的浏览器中直接查看应用程序的实际运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq03-jsx-links](https://rq2e.com/rq03-jsx-links)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-jsx-links](https://rq2e.com/rq03-jsx-links)'
- en: 3.2.3 Multiline JSX objects
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 多行 JSX 对象
- en: 'You might have noticed the parentheses around the returned multiline JSX object
    in listing 3.4\. You have to include these parentheses if you start a multiline
    JSX object on a separate line after, for example, a return. This is the way to
    create multiline JSX objects when not starting on the same line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到列表 3.4 中返回的多行 JSX 对象周围的括号。如果你在例如返回之后在单独的一行上开始多行 JSX 对象，你必须包括这些括号。这是在不从同一行开始时创建多行
    JSX 对象的方式：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can start your root element on the same line as return and
    avoid the parentheses. For example, this is valid as well:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以从与返回相同的行开始你的根元素，并避免括号。例如，这也是有效的：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A downside of this second approach is the reduced visibility of the opening
    <main> tag. It may be easy to miss in the code. The choice is up to you. We’ll
    exclusively use the former style of using parentheses around multiline JSX content
    for consistency.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第二种方法的缺点是减少了打开 <main> 标签的可见性。在代码中可能会很容易错过。选择权在你。我们将仅使用在多行 JSX 内容周围使用括号的前一种样式，以确保一致性。
- en: 'Note that the exact same thing goes for any other use of multiline JSX objects,
    for example, when you save them in a variable. We’ll also be using parentheses
    there:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于任何其他多行 JSX 对象的使用，例如，当你在变量中保存它们时，情况也是完全相同的。我们也会在那里使用括号：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3.2.4 Outputting variables in JSX
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 在 JSX 中输出变量
- en: When you compose components, you want them to be smart enough to change the
    view based on some code. For example, it would be useful if a date component uses
    the current date and time, and not just a hardcoded value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你组合组件时，你希望它们足够智能，能够根据某些代码改变视图。例如，如果日期组件使用当前日期和时间，而不是硬编码的值，这将非常有用。
- en: 'When working with JavaScript-only React, you have to use string template literals
    (i.e., backticks) to mix strings with variables—or, even worse, concatenation.
    For example, to use a variable in a string context in a DateTimeNow component
    without JSX, you would write this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用仅 JavaScript 的 React 时，你必须使用字符串模板字面量（即反引号）来混合字符串和变量——或者更糟糕的是，连接。例如，要在没有 JSX
    的 DateTimeNow 组件的字符串上下文中使用变量，你会编写以下代码：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In JSX, you can use curly brace {} notation to output variables dynamically,
    which reduces code complexity substantially:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSX 中，你可以使用花括号 {} 符号动态输出变量，这大大减少了代码的复杂性：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you reference a variable that is a React element (optionally created using
    JSX), you can directly insert that other bit of JSX in the current context:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你引用的是一个 React 元素（可选地使用 JSX 创建），你可以在当前上下文中直接插入那部分 JSX：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is equivalent to directly inserting the element:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于直接插入元素：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The inserted variables can also be properties, not just locally defined variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的变量也可以是属性，而不仅仅是本地定义的变量：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also invoke methods of your component that you create yourself. That
    is a common practice to isolate bits of functionality, as shown in the next listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以调用你自己创建的组件的方法。这是一个常见的做法，用于隔离功能块，如下一列表所示。
- en: Listing 3.5 ButtonList using a method
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 使用方法的 ButtonList
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Defines the getButton method that takes an argument text, which will be the
    label on the button
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义了 getButton 方法，该方法接受一个参数 text，它将是按钮上的标签
- en: ❷ Our button depends on another property passed to our component.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的按钮依赖于传递给我们的组件的另一个属性。
- en: ❸ Invokes our method to get a button inserted with the proper text
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用我们的方法以插入带有正确文本的按钮
- en: 'The example in listing 3.5 is overly simplified, of course, as most of the
    time, you would probably be using an extra component for such a use case. However,
    there are situations where component methods do come in handy. The purpose of
    this example is to show that you can invoke component methods directly in JSX.
    For example, you can execute arbitrary JavaScript expressions inside the curly
    braces, such as formatting a date directly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5中的示例当然过于简化，因为在大多数情况下，你可能需要为这样的用例使用额外的组件。然而，确实存在一些情况下，组件方法会派上用场。这个示例的目的是展示你可以在JSX中直接调用组件方法。例如，你可以在花括号内执行任意的JavaScript表达式，例如直接格式化日期：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now let’s rewrite our emphasized greeting to store the italicized word in a
    variable first, before outputting it, in the next listing. Then, we’ll move on
    to discuss how you work with properties in JSX in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将强调的问候语重写，首先将斜体字存储在一个变量中，然后再输出，在下一个列表中。然后，我们将继续讨论在下一节中如何处理JSX中的属性。
- en: Listing 3.6 Emphasized greeting using JSX and a variable
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用JSX和变量强调问候语
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 3.2.5 Working with properties in JSX
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 在JSX中处理属性
- en: We touched on this topic earlier, when we introduced JSX. Element properties
    are defined using attribute syntax. That is, you use key1=value1 key2=value2...
    notation inside the JSX tag to define both HTML attributes and React component
    properties. This is similar to attribute syntax in HTML/XML.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在介绍JSX时已经提到了这个话题。元素属性使用属性语法定义。也就是说，你使用key1=value1 key2=value2...的表示法在JSX标签内定义HTML属性和React组件属性。这与HTML/XML中的属性语法类似。
- en: 'In other words, if you need to pass properties, write them in JSX as you would
    in normal HTML. You render standard HTML attributes by setting element properties
    (discussed in section 2.3) on a React element with an HTML tag. For example, this
    code sets a standard HTML attribute href for anchor element <a>:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你需要传递属性，就像在正常HTML中一样，在JSX中写入它们。你通过在React元素上设置具有HTML标签的元素属性（在第2.3节中讨论）来渲染标准HTML属性。例如，此代码为锚元素<a>设置了一个标准的HTML属性href：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You use the exact same method to set properties on custom components. If we
    had our Link component from the previous chapter, we could use it in JSX as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用完全相同的方法来设置自定义组件的属性。如果我们有上一章中的Link组件，我们可以在JSX中使用它，如下所示：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using hardcoded values for attributes isn’t all that flexible, of course. If
    you want to reuse the Link component, then the href must change to reflect a different
    address each time. This is called dynamically setting values versus hardcoding
    them. So, next, we’ll go a step further and consider a component that can use
    dynamically generated values for attributes. Those values can come from component
    properties (this.props). After that, everything’s easy. All you need to do is
    use curly braces ({}) inside angle braces (<>) to pass dynamic values of properties
    to elements.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用硬编码的值来设置属性并不灵活。如果你想重用Link组件，那么href必须改变以反映每次不同的地址。这被称为动态设置值与硬编码。因此，接下来，我们将更进一步，考虑一个可以使用动态生成的属性值的组件。这些值可以来自组件属性（this.props）。在那之后，一切都很简单。你所需要做的就是使用花括号({})在尖括号(<>）内传递属性的动态值到元素。
- en: 'For example, suppose you’re building a component that will be used to link
    to user accounts. You need some attributes on your <a> tag, but href and title
    must be different for each component and not hardcoded. Let’s create a dynamic
    component ProfileLink that renders a link with properties url and label for href
    and title, respectively. You pass the properties to <a> using {}:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在构建一个将被用于链接到用户账户的组件。你的<a>标签需要一些属性，但href和title对于每个组件都必须不同，不能是硬编码的。让我们创建一个动态组件ProfileLink，它渲染一个带有属性url和label的链接，分别对应href和title。你使用{}将属性传递给<a>：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Where do the property values come from? They’re defined when ProfileLink is
    created—that is, in the component that creates ProfileLink, aka its parent. For
    example, this is how the values for url and label are passed when a ProfileLink
    instance is created, which results in rendering the <a> tag with those values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值从何而来？它们是在创建ProfileLink时定义的——也就是说，在创建ProfileLink的组件中，也就是它的父组件中。例如，当创建ProfileLink实例时，url和label的值就是这样传递的，这导致渲染带有这些值的<a>标签：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From the previous chapter, you’ll remember that when rendering standard elements
    (<h>, <p>, <div>, <a>, etc.), React will render any and all properties even if
    they don’t have any semantic meaning in HTML. That’s not specific for JSX, that’s
    just default React behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，你会记得当渲染标准元素（如 <h>、<p>、<div>、<a> 等）时，React 会渲染任何和所有属性，即使它们在 HTML 中没有任何语义意义。这不仅仅是对
    JSX 的特定，这只是 React 的默认行为。
- en: 'If you have an object with properties that you want to render on an element,
    you can render each of them one by one as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个你想在元素上渲染的属性的对象，你可以按如下方式逐个渲染它们：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This works great and is a safe solution. However, if you have an object with
    values, and you want to render *all of them*, you can do so using the spread operator
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，是一个安全的解决方案。然而，如果你有一个包含值的对象，并且你想渲染 *所有这些值*，你可以使用扩展运算符如下所示：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that this will render *every* property of the post object, regardless of
    whether that makes sense or not. Only use this process when you’re sure that the
    object only has the properties that you need or at least sure that any excess
    properties are ignored.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将渲染 *每个* post 对象的属性，无论这是否有意义。只有当你确定对象只包含你需要的属性，或者至少确定任何多余的属性都会被忽略时，才使用此过程。
- en: 'This will even allow you to render all the properties passed to a component
    to another element inside that component by spreading this.props:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至允许你通过扩展 this.props 来将传递给组件的所有属性渲染到该组件内的另一个元素中：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a bit dangerous though, as it allows the parent component to pass in
    arbitrary values that would supersede any values that you passed to it. If this.props
    contained a value property, it would override the value property that you set
    in the component before the spread. Be extra careful when spreading objects and
    in particular when spreading all props passed to a component. We’ll get back to
    the spreading operator in the next chapter and cover some other common examples
    of its use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做很方便，但它允许父组件传递任意值，这些值会覆盖你之前在组件中设置的任何值。如果 this.props 包含一个 value 属性，它将覆盖你在扩展之前设置的
    value 属性。在扩展对象时，尤其是扩展传递给组件的所有属性时，要格外小心。我们将在下一章回到扩展运算符，并介绍一些其他常见的使用示例。
- en: 'The special property: children'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊属性：children
- en: If you think back to the previous chapter, we introduced the special property
    children, which only looks like a property inside a custom component, not from
    the outside. When using JSX, the children property becomes a lot neater to use.
    In the example with child nodes in chapter 2, it looked like the tree structure
    shown in figure 3.3.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下上一章，我们介绍了特殊属性“children”，它只看起来像是一个自定义组件内部的属性，而不是从外部。当使用 JSX 时，children
    属性的使用变得更加整洁。在第 2 章的示例中，它看起来就像图 3.3 所示的树结构。
- en: '![03-03](../Images/03-03.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![03-03](../Images/03-03.png)'
- en: Figure 3.3 The component tree when we use child nodes as link content
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 使用子节点作为链接内容时的组件树
- en: Let’s reimplement this one in JSX. We know all the things we need to do, so
    let’s go ahead and do them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 JSX 中重新实现这个功能。我们知道所有需要做的事情，所以让我们继续做吧。
- en: Listing 3.7 Link list with child nodes in JSX
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 使用 JSX 的带有子节点的链接列表
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ We still use the url property as we did before and also just use this.props.children
    as if it was any other property.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们仍然使用 url 属性，就像之前一样，并且就像使用任何其他属性一样使用 this.props.children。
- en: ❷ Note how elegantly these child nodes are added in JSX. It looks just like
    the rest of the code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 注意这些子节点在 JSX 中的优雅添加方式。它看起来就像代码的其他部分一样。
- en: 'Repository: rq03-children'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-children
- en: 'This example can be seen in repository rq03-children. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在 rq03-children 仓库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq03-children](https://rq2e.com/rq03-children)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-children](https://rq2e.com/rq03-children)'
- en: 'The difference between using properties and child nodes suddenly becomes a
    lot more obvious. We could have passed the link content in as a property, but
    it would have looked pretty bad. If we used the regular property approach, it
    would have looked like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性和子节点之间的区别突然变得非常明显。我们本可以将链接内容作为属性传递，但看起来会很糟糕。如果我们使用常规属性方法，它看起来会是这样：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But when we use the children approach, it becomes
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们使用子元素方法时，它变成了
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We definitely know what we prefer—the latter approach.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定知道我们更喜欢后者这种方法。
- en: 3.2.6 Branching in JSX
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.6 JSX 中的分支
- en: 'Branching is always important in coding. For example, if the user is logged
    in, show their account information; otherwise, show a login form. Because JSX
    is just JavaScript, we can basically use the exact same constructs that we do
    in regular coding to create branching in our components. That being said, some
    patterns have emerged that most developers follow about how to use branching in
    React components using JSX:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 分支在编码中始终很重要。例如，如果用户已登录，显示他们的账户信息；否则，显示登录表单。因为 JSX 只是 JavaScript，我们可以基本上使用与常规编码中完全相同的结构来在我们的组件中创建分支。也就是说，关于如何在
    JSX 中使用分支来创建 React 组件，已经出现了一些大多数开发者遵循的模式：
- en: Use early return for rendering nothing.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提前返回来渲染无内容。
- en: Use the ternary operator for rendering alternative elements.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三元运算符来渲染替代元素。
- en: Use the logical AND operator (&&) for rendering optional elements.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑 AND 运算符（&&）来渲染可选元素。
- en: Use object maps for rendering between many different elements.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象映射来在许多不同的元素之间进行渲染。
- en: Use extra components for more complex branching.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用额外的组件来实现更复杂的分支。
- en: We’ll go through each of these in the next subsections to explain how we use
    branching in JSX and custom React components.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中逐一解释我们如何在 JSX 和自定义 React 组件中使用分支。
- en: Using early return for rendering nothing
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提前返回来渲染无内容
- en: Imagine you have a component that renders something relevant only when a certain
    condition is true. For example, imagine a countdown component that renders a value
    only when the number of remaining seconds is larger than 0.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个组件，只有当某个条件为真时才会渲染相关内容。例如，想象一个倒计时组件，只有当剩余秒数大于 0 时才会渲染一个值。
- en: If a component doesn’t render anything, we can simply return null from the component.
    However, to optimize our components, we try to do this as early as possible to
    short-circuit the execution. The purpose is to branch out to the easiest case
    as quickly as we can to avoid doing extra calculations or creating JSX objects
    where we don’t need them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件不渲染任何内容，我们可以简单地从组件中返回 null。然而，为了优化我们的组件，我们尽量尽早这样做，以避免执行额外的计算或创建不需要的 JSX
    对象。目的是尽快分支到最简单的情况，以避免进行额外的计算或创建不需要的 JSX 对象。
- en: 'We could create our Countdown component like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样创建我们的倒计时组件：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There’s nothing inherently wrong with this—it works and it’s fully functional.
    But you’ll see many developers use the approach of aborting early if the component
    renders nothing. We can detect this case of rendering nothing before calculating
    the number of seconds and minutes and before creating the JSX object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身并没有什么错误——它工作得很好，并且完全功能化。但你会看到许多开发者使用提前终止的方法，如果组件不渲染任何内容。我们可以在计算秒数和分钟数以及创建
    JSX 对象之前检测到这种情况：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we also use the fact that when we return from inside an if block, we don’t
    need an else block. The else is implicit in that anything after the if block is
    only visited if the condition failed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也利用了这样一个事实：当我们从 if 块内部返回时，我们不需要 else 块。else 是隐含的，即 if 块之后的内容只有在条件失败时才会被访问。
- en: Using ternary for alternatives
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符进行替代
- en: Another very common case in React components is to render different elements
    based on whether some condition is true or false. For instance, let’s imagine
    a shopping cart in which we want to display the items if there are any items,
    but display a message saying there are no items when no items are in the cart.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 组件中，另一个非常常见的案例是根据某些条件是否为真或假来渲染不同的元素。例如，让我们想象一个购物车，我们希望在购物车中有项目时显示这些项目，当购物车中没有项目时，显示一条消息说没有项目。
- en: 'We could do this in JSX by using a variable and assigning it different values
    via a regular if/else statement block. However, that’s a bit lengthy, and it’s
    a lot more common in React to use the ternary operator. Where the if/else construct
    is a statement, the ternary operator is an expression and can thus be used inline
    directly in JSX:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 JSX 中通过使用变量并通过常规的 if/else 语句块分配不同的值来实现这一点。然而，这有点长，在 React 中使用三元运算符更为常见。if/else
    构造是一个语句，而三元运算符是一个表达式，因此可以直接在 JSX 中内联使用：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Using this, we can create our shopping cart component from before:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以创建之前提到的购物车组件：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using logical operators for optional rendering
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符进行可选渲染
- en: Another common pattern is the need to optionally render an element if a condition
    is true, but render nothing if not true. As an example, we want to display a little
    checkmark next to a username if the user is a verified user, but nothing for the
    unverified plebeians. We can do this using *logical* AND and the fact that logical
    operators short-circuit by returning as soon as the truthiness of the entire expression
    is known. So, when doing a && b, JavaScript returns a if a is *falsy* or b if
    a is *truthy*. If a is truthy, it doesn’t matter what b is; it will be returned
    regardless. Combine this with the fact that React renders false as the empty string
    (more on that later).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的模式是需要根据条件是否为真有条件地渲染一个元素，如果不为真则不渲染。作为一个例子，我们想在用户是已验证用户时在用户名旁边显示一个小勾号，但对于未验证的平民则不显示。我们可以使用
    *逻辑* AND 以及逻辑运算符短路的事实来实现这一点，即一旦整个表达式的真实性已知，就会立即返回。所以，当进行 a && b 时，JavaScript 会返回
    a 如果 a 是 *假值* 或 b 如果 a 是 *真值*。如果 a 是真值，b 是什么无关紧要；它将无论如何返回。结合 React 将 false 渲染为空字符串的事实（稍后详细介绍）。
- en: Truthiness
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 真实感
- en: In JavaScript, a *truthy* value translates to true when evaluated as a Boolean.
    For example, in an if statement
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，一个 *真实值* 在作为布尔值评估时转换为 true。例如，在一个 if 语句中
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'the value is truthy if it’s not falsy. That is literally the official definition,
    not kidding. There are only six falsy values:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不是假值，则该值是真实的。这实际上是官方定义，不是开玩笑。只有六个假值：
- en: 'false'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'false'
- en: '0'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0'
- en: '"" (empty string)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '""（空字符串）'
- en: 'null'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'null'
- en: Undefined
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Undefined
- en: NaN (not a number)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NaN（不是一个数字）
- en: 'We can use this to render conditional elements, by making our logical AND operator
    return false if the user isn’t verified, and a React element if the user is verified:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来渲染条件元素，通过使我们的逻辑 AND 运算符在用户未验证时返回 false，如果用户已验证，则返回一个 React 元素：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You’ll encounter this pattern often in React components, so it’s a good one
    to know.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 React 组件中经常会遇到这种模式，所以了解它是很好的。
- en: Using objects for switching
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象进行切换
- en: So far, we’ve dealt with the case of rendering either an element or nothing,
    or rendering one element or another, but what if we want to render more than two
    types of elements based on a condition? For this scenario, we want to render an
    icon based on some blog post status. If the post is in the draft state, we render
    a draft icon. If the post is in the published state, we render a published icon.
    And, if the post is in any other state (which we happen to know to be just the
    deleted state), we render a trash icon.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了渲染一个元素或无、或渲染一个元素或另一个元素的情况，但如果我们想根据条件渲染超过两种类型的元素怎么办？对于这种情况，我们想根据一些博客文章的状态渲染一个图标。如果文章处于草稿状态，我们渲染草稿图标。如果文章处于已发布状态，我们渲染已发布图标。而且，如果文章处于任何其他状态（我们碰巧知道这只是已删除状态），我们渲染垃圾图标。
- en: 'Well, we could nest ternaries in order to first check if status === "draft";
    then, if not, check if status === "published"; and, if not, assume that it must
    be deleted:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们可以嵌套三元运算符，首先检查 status === "draft"；然后，如果不等于，检查 status === "published"；如果不等于，假设它必须是已删除的：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This would work, but it’s not very pretty. Another alternative is to use a
    switch statement and simply return the different values in each case. But a more
    declarative approach here is to use an object with properties for the different
    cases resolving the different outcomes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这会起作用，但看起来并不美观。另一个选择是使用 switch 语句，并在每个情况下简单地返回不同的值。但在这里使用一个具有不同情况属性的声明式方法，以解决不同的结果：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That’s rather short and neat, no? However, note that this doesn’t handle the
    situation in which the status is none of those things. Before, the component would
    render the trash icon if the status was neither draft nor published, but now,
    it will only render the trash icon if the status is deleted.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简洁，不是吗？然而，请注意，这并没有处理状态不是那些情况的情况。以前，如果状态既不是草稿也不是已发布，组件会渲染垃圾图标，但现在，只有当状态是已删除时，它才会渲染垃圾图标。
- en: 'To handle the case when the status is any other unexpected value, we need to
    add a logical OR at the end so that if the object indexing resolves to nothing,
    we still render an alternative. Let’s say we just render the trash icon in any
    unknown case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理状态为任何其他意外值的情况，我们需要在末尾添加一个逻辑 OR，以便如果对象索引解析为空，我们仍然可以渲染一个替代项。比如说，我们可以在任何未知情况下只渲染垃圾图标：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This pattern is probably less common in React, but you’ll still see it for simple
    cases like those we’ve discussed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在 React 中可能不太常见，但你仍然会看到我们讨论过的简单情况。
- en: Using extra components for complex branching
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外的组件进行复杂分支
- en: The preceding scenarios only cover some simple branching cases. What do you
    do if your component has more complicated logic than that?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上述场景仅涵盖了一些简单的分支情况。如果您的组件逻辑比这更复杂，您会怎么做？
- en: 'Let’s say we have a shopping cart component like before with some buttons at
    the bottom. We have to implement the following business logic as dictated by a
    customer:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个像之前那样的购物车组件，底部有一些按钮。我们必须根据客户的要求实现以下业务逻辑：
- en: If the user is logged in, there will be just a Checkout button.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录，则只显示一个结账按钮。
- en: If the user isn’t logged in, there will be a Login button as well as a Checkout
    as Guest button.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户未登录，将同时显示一个登录按钮以及一个以访客身份结账的按钮。
- en: If any item is out of stock or if the cart is empty, the Checkout or the Checkout
    as Guest button will be disabled.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何商品缺货或购物车为空，结账或以访客身份结账的按钮将被禁用。
- en: If the user is logged in but hasn’t added a credit card yet, show an Add Credit
    Card button instead.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录但尚未添加信用卡，则显示一个添加信用卡按钮。
- en: If the user is logged in, has a credit card on file, and has entered an address,
    show a One-Click Buy button next to the Checkout button. This button will be disabled
    according to the same logic as the Checkout button.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录，有文件中的信用卡，并且已输入地址，则在结账按钮旁边显示一个一键购买按钮。此按钮将根据与结账按钮相同的逻辑禁用。
- en: Now, let’s implement all of this with the tricks that you’ve learned so far.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用您迄今为止学到的技巧来实现所有这些。
- en: Listing 3.8 Complex shopping cart
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 复杂的购物车
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ First ternary operator
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个三元运算符
- en: ❷ Second ternary operator
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第二个三元运算符
- en: ❸ Repeated logic for disabled button
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 禁用按钮的重复逻辑
- en: ❹ Logical AND to optionally render a button
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 可选渲染的逻辑AND
- en: 'Repository: rq03-cart-single'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-cart-single
- en: 'This example can be seen in repository rq03-cart-single. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq03-cart-single仓库中看到。您可以通过基于相关模板创建一个新应用来使用该仓库：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，在浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq03-cart-single](https://rq2e.com/rq03-cart-single)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-cart-single](https://rq2e.com/rq03-cart-single)'
- en: Okay, that seems to cover everything. However, this is getting a bit complicated
    with the nested conditionals and duplicated attributes. For such a complex case,
    it’s often a good idea to split things into multiple components that deal with
    each of the different cases one by one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这似乎涵盖了所有内容。然而，由于嵌套条件和重复属性，这变得有点复杂。对于这种情况，通常将事物拆分为多个组件，每个组件逐一处理不同的情况是个好主意。
- en: Here, we can create new components <UserButtons /> and <GuestButtons />. At
    the top level, we can select which of these components to use and then add the
    necessary extra checks and conditionals inside each of these.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以创建新的组件<UserButtons />和<GuestButtons />。在顶层，我们可以选择使用这些组件中的哪一个，然后在每个组件内部添加必要的额外检查和条件。
- en: Listing 3.9 Simplified multicomponent shopping cart
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 简化的多组件购物车
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Ternary operators
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 三元运算符
- en: ❷ Logical AND for optional rendering
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可选渲染的逻辑AND
- en: ❸ Ternary operators
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 三元运算符
- en: 'Repository: rq03-cart-multi'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-cart-multi
- en: 'This example can be seen in repository rq03-cart-multi. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq03-cart-multi仓库中看到。您可以通过基于相关模板创建一个新应用来使用该仓库：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，在浏览器中直接查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq03-cart-multi](https://rq2e.com/rq03-cart-multi)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-cart-multi](https://rq2e.com/rq03-cart-multi)'
- en: This works the same as before with exactly the same complexity, but each component
    is much simpler, and you can easily understand each component on its own by reading
    through the code. You could even take it an extra step and split the <UserButtons>
    component into two for the “has credit card” and “doesn’t have credit card” situations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的工作方式相同，具有完全相同的复杂性，但每个组件都简单得多，您可以通过阅读代码轻松理解每个组件。您甚至可以更进一步，将<UserButtons>组件拆分为两个，分别处理“有信用卡”和“没有信用卡”的情况。
- en: We must, of course, acknowledge that more components means more code, and more
    code means more memory and CPU usage (in general), so this latter example is slightly
    more resource intensive than the former. In most applications, this difference
    is negligible though, and code quality often trumps such minor optimizations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然必须承认，更多的组件意味着更多的代码，更多的代码意味着更多的内存和 CPU 使用（通常），所以这个后者的例子比前者稍微消耗更多的资源。然而，在大多数应用程序中，这种差异是可以忽略不计的，代码质量通常胜过这种微小的优化。
- en: 3.2.7 Comments in JSX
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.7 JSX 中的注释
- en: 'Because JSX is written inside of JavaScript, you can use regular JavaScript
    comments outside the JSX elements as normal:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 JSX 是在 JavaScript 中编写的，所以你可以在 JSX 元素外部使用常规 JavaScript 注释，就像平常一样：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, if you have very long segments of JSX code, you might want to add comments
    inline inside the JSX. If you want to do that, you can’t always use a regular
    JavaScript comment directly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有非常长的 JSX 代码段，你可能想在 JSX 内部添加行内注释。如果你想这样做，你并不总是可以直接使用常规 JavaScript 注释。
- en: 'To add JSX comments between tags, you can wrap standard JavaScript comments
    using /**/ or // in {}, like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要在标签之间添加 JSX 注释，你可以使用 /**/ 或 // 将标准 JavaScript 注释包裹在 {} 中，如下所示：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can also use JavaScript comments directly using either /**/ or // inside
    tags:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在标签内直接使用 JavaScript 注释，无论是 /**/ 还是 //：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Note that when you use a regular single-line comment between tags inside curly
    brackets, you need to have a newline character before you end the curly brackets.
    The following code would fail:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你使用常规单行注释在花括号内的标签之间时，你需要在结束花括号之前有一个换行符。以下代码会失败：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This would result in a compiler error because the ending curly bracket is considered
    part of the comment, so the opening curly bracket doesn’t have a matching ending
    bracket, which causes a parser error.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致编译错误，因为结束的花括号被认为是注释的一部分，所以没有匹配的结束括号，这会导致解析错误。
- en: 3.2.8 Lists of JSX objects
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.8 JSX 对象列表
- en: 'A common tactic in React elements is to map an array of elements to an array
    of JSX objects to be returned in a component. Let’s say we want to create a component
    to render a drop-down list. We want to pass the list of options in the drop-down
    as an array of strings to a new <Select /> component. We want to be able to do
    the following in our application:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 元素中，一个常见的策略是将元素数组映射到 JSX 对象数组，以便在组件中返回。假设我们想要创建一个渲染下拉列表的组件。我们希望将下拉列表中的选项列表作为字符串数组传递给新的
    <Select /> 组件。我们希望在应用程序中能够做到以下操作：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Then our Select component should correctly render a <select> with <option> elements
    in HTML. How would we go about doing that? The naive way is to simply map the
    elements from strings to JSX objects using declarative programming, as shown in
    the next listing.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的 Select 组件应该能够正确渲染一个包含 <option> 元素的 <select> 标签。我们该如何做到这一点呢？简单的方法是将元素从字符串映射到
    JSX 对象，使用声明式编程，如下一列表所示。
- en: Listing 3.10 Naive implementation of select
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 select 的简单实现
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ For every element in the items array
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于 items 数组中的每个元素
- en: ❷ Returns a JSX element
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个 JSX 元素
- en: 'Repository: rq03-naive-select'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-naive-select
- en: 'This example can be seen in repository rq03-naive-select. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq03-naive-select 中看到。你可以通过创建一个基于相关模板的新应用程序来使用该仓库：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq03-naive-select](https://rq2e.com/rq03-naive-select)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-naive-select](https://rq2e.com/rq03-naive-select)'
- en: 'This is a pretty decent attempt at solving this. However, if we run this in
    the browser, we’ll get a warning:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对解决这个问题的一个相当不错的尝试。然而，如果我们在这个浏览器中运行它，我们会得到一个警告：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The application works, but we get this warning about a missing key property.
    The usage of the key property is a bit advanced at this stage in our React learning,
    but it’s used by React to track if the same element moves around in the rendered
    DOM. If the same element moves around, React will reuse the same element, but
    if React doesn’t know whether it’s the same element or not, React will delete
    all the old elements and recreate completely new elements every time the list
    renders.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行正常，但我们得到了关于缺少 key 属性的警告。在当前我们学习 React 的这个阶段，key 属性的使用有点高级，但它是 React 用于跟踪渲染
    DOM 中相同元素是否移动的。如果相同元素移动，React 会重用该元素，但如果 React 不知道它是否是相同的元素，React 将在每次列表渲染时删除所有旧元素并完全重新创建新元素。
- en: For the purposes of this example, we can just use the item value as the key
    property on the root element returned inside the mapped array. This results in
    the code shown in the next listing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本例的目的，我们只需使用映射数组中返回的根元素上的item值作为key属性。这导致了下一列表中显示的代码。
- en: Listing 3.11 Correct implementation of select
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 select的正确实现
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ We’ve added a key property to the <option> element.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们已经为<option>元素添加了key属性。
- en: 'Repository: rq03-correct-select'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq03-correct-select
- en: 'This example can be seen in repository rq03-correct-select. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在rq03-correct-select存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站浏览代码，直接在浏览器中查看应用的实际效果，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq03-correct-select](https://rq2e.com/rq03-correct-select)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-correct-select](https://rq2e.com/rq03-correct-select)'
- en: This key property is an internal React property that will never be rendered
    to the DOM. It’s recommended that the key property is some unique identifier for
    the element in question and not just the index of the element in the array (if
    elements move around in the array, the indexes change even though the elements
    don’t, so proper element reuse is circumvented).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键属性是一个内部的React属性，它永远不会被渲染到DOM中。建议将key属性设置为元素的唯一标识符，而不仅仅是数组中元素的索引（如果元素在数组中移动，索引会改变，即使元素本身没有改变，这也会绕过适当的元素重用）。
- en: Keys must be unique. If you render a list with non-unique keys, you’ll get a
    different warning in the console about duplicate keys.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Keys必须是唯一的。如果您渲染了一个具有非唯一键的列表，您将在控制台中获得有关重复键的不同警告。
- en: Note Keys are local to the individual array, so they only have to be unique
    within each array, not between all arrays in your application or even your component.
    Different arrays of JSX objects can have duplicate keys between them as long as
    no single array has duplicate keys inside it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Keys是局部于单个数组的，因此它们只需在数组内部是唯一的，而不是在您的应用程序的所有数组之间，甚至不是在您的组件之间。不同的JSX对象数组之间可以有重复的键，只要没有任何单个数组内部有重复的键。
- en: As mentioned, this is a fairly complicated feature of React to understand at
    this point, so, for now, just be aware that if you get a warning in the console
    about a missing key property or duplicate keys, this is the reason.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是React在此阶段理解的一个相当复杂的功能，所以，现在只需知道，如果在控制台中收到有关缺少key属性或重复键的警告，这就是原因。
- en: 3.2.9 Fragments in JSX
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.9 JSX中的片段
- en: 'We’ve already covered JSX fragments a few times. They’re used to export multiple
    elements at the same level in a situation where only a single element is allowed.
    We’ve previously done something like this to include both a heading and a link:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次介绍了JSX片段。它们用于在只允许单个元素的情况下，在相同级别导出多个元素。我们之前已经做了类似的事情来包含标题和链接：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'However, from React 16.2 (and Babel 7) forward, a shorter syntax is also allowed.
    Now you don’t even have to import the Fragment component:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从React 16.2（和Babel 7）开始，也允许使用更短的语法。现在您甚至不需要导入Fragment组件：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This new shorthand syntax uses a seemingly empty tag to render fragments. This
    syntax with <></> can’t take any attributes or properties, however. The only property
    you might want to apply to this would be key because you’re rendering a list of
    elements, where each element has more than a single JSX element at the root.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的简写语法使用看似空的标签来渲染片段。然而，这种<></>语法不能接受任何属性或属性。您可能想要应用的唯一属性可能是key，因为您正在渲染一个元素列表，其中每个元素在根级别有多个JSX元素。
- en: 'A classic scenario for this is a definition list. It’s defined in HTML like
    this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个经典场景是定义列表。它在HTML中的定义如下：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, each entry requires two sibling elements in the list to render
    (<dt> and <dd>).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个条目都需要列表中的两个兄弟元素来渲染（<dt>和<dd>）。
- en: For example, if we create an application to render three dog breeds with a little
    description about each, we need to map our dog breed names and definitions to
    two elements. We do that by wrapping them in a fragment, but because we need the
    fragment to have a key property, we have to use the literal Fragment component
    and, unfortunately, can’t use the shorthand syntax mentioned previously. Let’s
    implement this in the following listing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们创建一个应用程序来渲染三种狗品种及其简要描述，我们需要将我们的狗品种名称和定义映射到两个元素。我们通过将它们包裹在片段中来实现这一点，但由于我们需要片段具有键属性，我们必须使用字面量片段组件，并且不幸的是，不能使用之前提到的简写语法。让我们在下面的列表中实现这一点。
- en: Listing 3.12 Definition list of dog breeds
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 狗品种的定义列表
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ❶ Uses destructuring to easily access the properties of the list item
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用解构来轻松访问列表项的属性
- en: ❷ Because we need a key property, we have to use the proper Fragment component.
    Note that we just use the breed as the key, as that uniquely identifies each element
    in the array.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 因为我们需要一个关键属性，所以我们必须使用适当的片段组件。请注意，我们只是使用品种作为键，因为这样可以唯一地标识数组中的每个元素。
- en: 'Repository: rq03-dog-breeds'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq03-dog-breeds
- en: 'This example can be seen in repository rq03-dog-breeds. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq03-dog-breeds存储库中看到。你可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在你的浏览器中查看应用程序的运行情况，或者将源代码作为zip文件下载：
- en: '[https://rq2e.com/rq03-dog-breeds](https://rq2e.com/rq03-dog-breeds)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-dog-breeds](https://rq2e.com/rq03-dog-breeds)'
- en: If we run this in the browser, we get a nice definition list exactly as we wanted
    to, as you can see in figure 3.4\. Using fragments with keys isn’t as much of
    an edge case as it might seem, so this is very useful to know already at this
    stage.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中运行这个程序，我们会得到一个非常好的定义列表，正如你在图3.4中看到的那样。使用带有键的片段并不像看起来那么边缘情况，所以在这个阶段了解这一点是非常有用的。
- en: '![03-04](../Images/03-04.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![03-04](../Images/03-04.png)'
- en: Figure 3.4 A definition list of a curated subset of dog breeds and their primary
    description
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 狗品种及其主要描述的精选子集的定义列表
- en: 'You’ve now had a taste of JSX and its benefits. The rest of this chapter is
    dedicated to JSX tools and potential traps to avoid—that’s right: tools and gotchas.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经尝到了JSX及其优势的滋味。本章的其余部分将致力于JSX工具和潜在陷阱的避免——没错：工具和陷阱。
- en: Before we can continue, you must understand that for any JSX project to function
    properly, JSX needs to be compiled. Browsers can’t run JSX directly—they can run
    only JavaScript—so you need to take the JSX and transpile it to normal JavaScript
    (refer to figure 3.1). Fortunately, that task is a lot less complicated than it
    sounds.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你必须理解，为了使任何JSX项目正常工作，JSX需要被编译。浏览器不能直接运行JSX——它们只能运行JavaScript——所以你需要将JSX转换为普通JavaScript（参见图3.1）。幸运的是，这项任务比听起来要简单得多。
- en: 3.3 How to transpile JSX
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 如何转换JSX
- en: For all the projects and examples in this book, you don’t need to set up your
    own transpiler (or most other things in your technology stack). The same is true
    for most projects you’ll encounter out in the wild, because existing projects
    already have a working pipeline, and new projects can be based on the best practice
    documentation provided by whatever framework you desire to work with.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的所有项目和示例，你不需要设置自己的转换器（或技术堆栈中的大多数其他东西）。对于你将在野外遇到的许多项目也是如此，因为现有项目已经有一个工作流程，而新项目可以基于你想要工作的框架提供的最佳实践文档。
- en: 'However, if you want to set up a React project from scratch, you can, and that
    would include setting up a JSX transpiler. The most popular tool out there to
    do JSX transpiling is Babel, but there are alternatives you might want to look
    at as well. Some of the alternatives can be part of a larger package of build
    tools that make your whole setup easier to maintain or simply be drop-in replacements
    for Babel. Alternatives include SWC, Sucrase, and esbuild. Please consult their
    various documentation for details on how to use them:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想从头开始设置React项目，你可以这样做，这包括设置JSX转换器。目前最流行的JSX转换工具是Babel，但还有一些你可能想要考虑的替代方案。一些替代方案可以是构建工具包的一部分，使你的整个设置更容易维护，或者简单地作为Babel的替代品。替代方案包括SWC、Sucrase和esbuild。请查阅它们的各种文档以了解如何使用它们：
- en: 'Babel: [https://babeljs.io/](https://babeljs.io/)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Babel: [https://babeljs.io/](https://babeljs.io/)'
- en: 'SWC: [https://swc.rs/](https://swc.rs/)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SWC: [https://swc.rs/](https://swc.rs/)'
- en: 'Sucrase: [https://sucrase.io/](https://sucrase.io/)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sucrase: [https://sucrase.io/](https://sucrase.io/)'
- en: 'esbuild: [https://esbuild.github.io/](https://esbuild.github.io/)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'esbuild: [https://esbuild.github.io/](https://esbuild.github.io/)'
- en: We strongly recommend that you don’t spend too much time creating a JSX transpiler
    setup yourself. The good folks at React have created CRA for us, which will serve
    almost all our needs in this book. You might want to look into custom setups in
    your own projects, but for this book, you’ll be covered by the setups provided
    by our selection of great tools.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您不要花太多时间自己创建一个 JSX 编译器设置。React 中的好人已经为我们创建了 CRA，它将满足本书中几乎所有的需求。您可能想在您自己的项目中查看自定义设置，但就本书而言，您将受到我们精选的强大工具提供的设置的覆盖。
- en: 3.4 React and JSX gotchas
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 React 和 JSX 的注意事项
- en: 'This section covers some edge cases and oddities that you should be aware of
    when you use JSX:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了您在使用 JSX 时应该注意的一些边缘情况和奇怪之处：
- en: Self-closing tags are required for leaf nodes.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叶子节点需要自闭合标签。
- en: Special characters are written literally.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊字符以文本形式书写。
- en: String conversion is a bit peculiar.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串转换有点特别。
- en: The style attribute is an object.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: style 属性是一个对象。
- en: Some attributes have reserved names and must be renamed.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些属性有保留的名称，必须重命名。
- en: Multiword attributes are in camelCase.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多词属性使用驼峰式命名法。
- en: Boolean attributes are handled differently than in HTML.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔属性的处理方式与 HTML 不同。
- en: Some whitespace is collapsed (but not all).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些空白被折叠（但并非全部）。
- en: You can add data- attributes where desired.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在需要的地方添加 data- 属性。
- en: 3.4.1 Self-closing elements
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 自闭合元素
- en: 'JSX requires you to have a closing slash (/) either in the closing tag or,
    if you don’t have any children, at the end of that single tag. For example, this
    is correct:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 要求您在关闭标签中包含一个斜杠 (/)，如果没有子元素，则在单个标签的末尾。例如，这是正确的：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following is *not* correct, because both nodes are missing an end tag:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不正确的，因为两个节点都缺少结束标签：
- en: '[PRE71]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You might know that HTML is more fault tolerant. Browsers will ignore the missing
    slash or end element and render the element just fine without it. Go ahead: try
    to create an HTML file with just <button>Press me and see for yourself that this
    renders the button just fine!'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道 HTML 更具容错性。浏览器会忽略缺少的斜杠或结束标签，并在没有它们的情况下正常渲染元素。试试看：创建一个只包含 <button>Press
    me</button> 的 HTML 文件，您会看到这个按钮渲染得很好！
- en: 3.4.2 Special characters
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 特殊字符
- en: 'HTML entities are codes that display special characters such as copyright symbols,
    em dashes, quotation marks, and so on. Here are some examples:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 实体是显示特殊字符（如版权符号、破折号、引号等）的代码。以下是一些示例：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can render those codes as any string in text content inside a node or as
    an attribute to a node. For example, this is static JSX (text defined in code
    without variables or properties):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些代码作为节点内的任何字符串文本内容或作为节点的属性来渲染。例如，这是一个静态 JSX（在代码中定义的文本，没有变量或属性）：
- en: '[PRE73]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'But if you want to dynamically output HTML entities (from a variable or a property),
    all you’ll get is the direct output (i.e., &copy;&mdash;&ldquo;), not the special
    characters. Thus, the following code won’t work:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您想动态输出 HTML 实体（来自变量或属性），您将得到的是直接输出（即，&copy;&mdash;&ldquo;），而不是特殊字符。因此，以下代码将不起作用：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'React/JSX will auto-escape the dangerous HTML, which is convenient in terms
    of security (security by default rocks!). To output special characters, you need
    to use one of these approaches:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: React/JSX 会自动转义危险的 HTML，这在安全性方面很方便（默认的安全性很棒！）。要输出特殊字符，您需要使用以下方法之一：
- en: Copy the special character directly into your source code. Just make sure you
    use a UTF-8 character set. This is the recommended method to deal with special
    characters.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特殊字符直接复制到您的源代码中。只需确保您使用 UTF-8 字符集。这是处理特殊字符的推荐方法。
- en: Escape the special character with \u, and use its Unicode number (use a website
    such as [fileformat.info](http://fileformat.info) to look it up).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 \u 转义特殊字符，并使用其 Unicode 编号（可以使用类似 [fileformat.info](http://fileformat.info)
    的网站来查找）。
- en: Convert from a character code to a character number with String.fromCharCode(charCodeNumber).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 String.fromCharCode(charCodeNumber) 将字符代码转换为字符编号。
- en: Use the special property dangerouslySetInnerHTML to set the inner HTML (this
    is dangerous and not recommended).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊的属性 dangerouslySetInnerHTML 来设置内联 HTML（这是危险的，不推荐使用）。
- en: 'To illustrate the last approach (as a last resort—when all else fails on the
    Titanic, run for the boats!), look at this code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明最后一种方法（作为最后的手段——当泰坦尼克号上所有其他方法都失败时，就跑向救生艇！），看看以下代码：
- en: '[PRE75]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Obviously, the React team has a sense of humor to name a property dangerouslySetInnerHTML.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，React团队在给属性命名时很有幽默感，将其命名为dangerouslySetInnerHTML。
- en: 3.4.3 String conversion
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 字符串转换
- en: 'When React outputs the value of your variable (or your expression in general),
    what is it rendered as? It can only render as one of two things: either a string,
    which becomes the string content between elements, or an element, which then just
    becomes an element as if it was rendered directly. But how are “things” converted
    to a string, if they’re not an element? Well, React is a bit peculiar here as
    it depends on the type of the expression that you’re rendering. Take a look at
    table 3.2 to understand the possibilities for the different primitive values in
    JavaScript.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当React输出你的变量（或你的一般表达式）的值时，它会被渲染成什么样子？它只能渲染成两种东西之一：要么是一个字符串，它成为元素之间的字符串内容，要么是一个元素，它就变成了一个元素，就像它被直接渲染一样。但是，如果它们不是元素，"事物"是如何被转换成字符串的呢？嗯，React在这里有点特别，因为它取决于你正在渲染的表达式的类型。看看表3.2，了解JavaScript中不同原始值的可能性。
- en: Table 3.2 React rendering different types
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 React渲染不同类型
- en: '| Type | Output |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 输出 |'
- en: '| "string" | "string" |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| "string" | "string" |'
- en: '| "" | "" |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| "" | "" |'
- en: '| 3.4 | "3.4" |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 3.4 | "3.4" |'
- en: '| 0 | "0" |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 0 | "0" |'
- en: '| NaN | "NaN" |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| NaN | "NaN" |'
- en: '| Number.POSITIVE_INFINITY | "Infinity" |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| Number.POSITIVE_INFINITY | "Infinity" |'
- en: '| Number.NEGATIVE_INFINITY | "-Infinity" |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| Number.NEGATIVE_INFINITY | "-Infinity" |'
- en: '| true | "true" |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| true | "true" |'
- en: '| false | "" |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| false | "" |'
- en: '| undefined | "" |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| undefined | "" |'
- en: '| null | "" |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| null | "" |'
- en: There are a few surprises there. Most importantly, false becomes the empty string,
    but true becomes "true". So, four of the falsy values (empty string, false, null,
    and undefined) all become the empty string.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些惊喜。最重要的是，假值变成了空字符串，但真值变成了"true"。所以，四个假值（空字符串、假、null和undefined）都变成了空字符串。
- en: But what about 0, which is also falsy? Well, it becomes 0. It would be weird
    if you couldn’t render a 0 in your components, so that’s kind of necessary. Finally,
    NaN is also just "NaN", and not the empty string. This is generally to help you
    debug your calculations better—if you see a *NaN*, you know you made an error
    somewhere, but if you just see nothing, you might not find it as quickly.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但是0呢，它也是假的？嗯，它变成了0。如果你在你的组件中无法渲染一个0，那就有点奇怪了，所以这有点必要。最后，NaN也仅仅是"NaN"，而不是空字符串。这通常是为了帮助你更好地调试计算——如果你看到*NaN*，你就知道你在某个地方犯了错误，但如果你只是看到什么都没有，你可能不会那么快找到它。
- en: 'This fact—that false renders nothing, but 0 renders something—especially matters
    when using logical AND to render optional elements as we discussed earlier. You
    might be used to doing things like this in JavaScript:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实——假值渲染无内容，但0渲染内容——特别是在使用逻辑AND渲染可选元素时非常重要，正如我们之前讨论的那样。你可能习惯在JavaScript中这样做：
- en: '[PRE76]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we just use items.length as the condition for our if statement because
    we know that 0 is falsy anyway, so we don’t have to say items.length > 0—the truthiness
    of the statement is the same.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是使用items.length作为if语句的条件，因为我们知道0本身就是假的，所以我们不必说items.length > 0——语句的真假性是一样的。
- en: 'You shouldn’t do that in JSX though. Let’s say you want to render a Checkout
    button in your shopping cart if it contains at least one item, but you want to
    render nothing when there are no items in the cart:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你在JSX中不应该这样做。假设你想要在购物车中至少有一个商品时渲染一个结账按钮，但没有商品时什么也不渲染：
- en: '[PRE77]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ❶ Don’t do this because using array length as a condition directly in a logical
    AND expression leads to problems.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要这样做，因为直接在逻辑AND表达式中使用数组长度作为条件会导致问题。
- en: This works as long as there are more than 0 items in the cart. But what happens
    when there are 0 items? The logical AND expression highlighted in the annotation
    short-circuits and returns the first falsy value as it is. In addition, because
    the length of the array is 0, the resulting value of the expression is suddenly
    0, which renders as "0" in the document, as shown previously in table 3.2\. So,
    if you used the code just shown, your empty shopping cart would suddenly display
    a "0" in the bottom of the component, to the utter confusion of everyone.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 只要购物车中有超过0件商品，这个功能就会正常工作。但是当购物车中没有商品时会发生什么呢？在注释中突出显示的逻辑AND表达式会短路并返回第一个假值。此外，由于数组的长度为0，表达式的结果突然变为0，在文档中渲染为"0"，如前表3.2中所示。所以，如果你使用了刚才显示的代码，你的空购物车会在组件底部突然显示一个"0"，让所有人都感到困惑。
- en: 'To implement this correctly, always compare the length of the array to be greater
    than 0 to ensure the type is Boolean. Even better, you can store that comparison
    in another variable, making the code even simpler to read:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确实现，始终比较要比较的数组的长度是否大于 0，以确保类型是布尔型。更好的是，你可以将这个比较存储在另一个变量中，使代码更容易阅读：
- en: '[PRE78]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ Stores the comparison in a variable guaranteed to be of type Boolean
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将比较存储在保证为布尔类型的变量中
- en: ❷ Uses that variable to conditionally render your optional element
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用该变量有条件地渲染你的可选元素
- en: It’s not that uncommon to forget this when you’re developing, so spotting rogue
    0’s throughout your application is definitely possible. They are almost always
    the result of this type of expression.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中忘记这一点并不罕见，所以在你整个应用程序中找到零散的 0 是完全可能的。它们几乎总是这种表达式的结果。
- en: 3.4.4 The style attribute
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 style 属性
- en: 'The style attribute in JSX works differently than in plain HTML. With JSX,
    instead of a string, you need to pass a JavaScript object, and CSS properties
    need to be in camelCase. For example:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 中的 style 属性在用法上与纯 HTML 不同。使用 JSX 时，你需要传递一个 JavaScript 对象，而不是字符串，CSS 属性需要使用驼峰式命名。例如：
- en: background-image becomes backgroundImage.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: background-image 变成了 backgroundImage。
- en: font-size becomes fontSize.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: font-size 变成了 fontSize。
- en: font-family becomes fontFamily.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: font-family 变成了 fontFamily。
- en: You can save the JavaScript object in a variable or render it inline with double
    curly braces ({{...}}). The double braces are needed because one set is for JSX,
    and the other is for the JavaScript object literal.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 JavaScript 对象存储在变量中，或者使用双大括号（{{...}}）内联渲染。双大括号是必需的，因为一组用于 JSX，另一组用于 JavaScript
    对象字面量。
- en: 'Suppose you have an object with this font size:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个具有此字体大小的对象：
- en: '[PRE79]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In your JSX, you can use the smallFontSize object as
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 JSX 中，你可以使用 smallFontSize 对象作为
- en: '[PRE80]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'or settle for a larger font (30 point) by passing the values directly without
    an extra variable:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过直接传递值（30点字体大小）而不使用额外变量来接受更大的字体：
- en: '[PRE81]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let’s look at another example of passing styles directly. This time, you’re
    setting a red border on a <span>:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个直接传递样式的例子。这次，你正在为一个 <span> 设置红色边框：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Alternatively, the following border value will also work and do the same thing:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下边框值也将起作用并执行相同的功能：
- en: '[PRE83]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The main reason styles aren’t CSS strings but JavaScript objects is so that
    React can work with them more quickly when it applies changes to views.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不是 CSS 字符串而是 JavaScript 对象的主要原因是为了让 React 在应用更改到视图时能够更快地与之交互。
- en: '3.4.5 Reserved names: class and for'
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 保留名称：class 和 for
- en: React (and JSX) accepts any attribute that is a standard HTML attribute, except
    class and for. Those names are reserved words in JavaScript/ECMAScript (for creating
    classes and for loops, respectively), and JSX is converted into regular JavaScript.
    So, just like you can’t create a variable named for or any other reserved word,
    you can’t create attributes with these names (not directly, anyway).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: React（和 JSX）接受任何标准 HTML 属性，除了 class 和 for。这些名称是 JavaScript/ECMAScript 的保留字（分别用于创建类和
    for 循环），JSX 被转换为常规 JavaScript。所以，就像你不能创建名为 for 或其他保留字的变量一样，你不能创建具有这些名称的属性（至少不能直接创建）。
- en: 'Instead, you can use className and htmlFor, respectively. For example, if you
    want to apply a class name of "hidden" to an element, you have to use the className
    attribute:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 className 和 htmlFor，分别。例如，如果你想将 "hidden" 类名应用于一个元素，你必须使用 className
    属性：
- en: '[PRE84]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If you need to create a label for a form element, use htmlFor:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为表单元素创建一个标签，请使用 htmlFor：
- en: '[PRE85]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Both of these are pretty easy to remember because you’ll get compiler errors
    if you forget.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都很容易记住，因为如果你忘记了，你会得到编译器错误。
- en: 3.4.6 Multiword attributes
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 多词属性
- en: In the same vein as the two reserved names mentioned in the previous section,
    other HTML attributes are renamed in React as well. Some of them make sense, but
    others less so.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一小节中提到的两个保留名称一样，React 也将其他 HTML 属性重命名。其中一些是有意义的，但其他一些则不太有。
- en: Any attribute made up of more than one English word is renamed to camelCase-style
    naming. This makes sense for scalable vector graphics (SVG) attributes using a
    hyphen such as clip-path or fill-opacity. We can’t use hyphenated attributes directly
    in JSX, so these are renamed to clipPath and fillOpacity, respectively.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由多个英文单词组成的任何属性都被重命名为 camelCase-style 命名。这对于使用连字符（如 clip-path 或 fill-opacity）的可伸缩矢量图形（SVG）属性是有意义的。我们无法直接在
    JSX 中使用连字符属性，因此这些属性被分别重命名为 clipPath 和 fillOpacity。
- en: However, the same goes for HTML attributes that don’t use a hyphen but are all
    lowercase normally, which can be quite confusing. If you enter
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于不使用连字符但通常全部为小写的 HTML 属性，也是如此，这可能会相当令人困惑。如果您输入
- en: '[PRE86]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: in JSX, it doesn’t work because, while the attribute is called autoplay (and
    can be all lowercase in HTML), you have to use camelCase and call it autoPlay
    in React. This can be a bit frustrating. This goes for a huge number of properties
    that you often use in HTML.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSX 中，这不起作用，因为虽然属性名为 autoplay（在 HTML 中可以是全部小写），但在 React 中您必须使用驼峰式命名法，将其称为
    autoPlay。这可能会有些令人沮丧。这适用于您在 HTML 中经常使用的许多属性。
- en: Instead of warning you about skipping these properties, React merely filters
    them out silently. So, you might never know that you typed it wrong until you
    realize that your video isn’t autoplaying (because of autoPlay rather than autoplay),
    your iframe doesn’t allow full screen (because of allowFullscreen rather than
    allowfullscreen), or your input field doesn’t have a maximum of characters allowed
    (because of maxLength rather than maxlength).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: React 不会警告您跳过这些属性，而是默默地过滤掉它们。因此，您可能永远不知道您输入错误，直到您意识到您的视频没有自动播放（因为使用了 autoPlay
    而不是 autoplay），您的 iframe 不允许全屏（因为使用了 allowFullscreen 而不是 allowfullscreen），或者您的输入字段没有允许的最大字符数（因为使用了
    maxLength 而不是 maxlength）。
- en: 3.4.7 Boolean attribute values
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7 布尔属性值
- en: 'Some attributes (e.g., disabled, required, checked, autoFocus, and readOnly)
    are specific only to form elements. The most important thing to remember here
    is that the attribute value must be set as a JavaScript expression (i.e., inside
    {}) and not set as a string. For example, use {false} to enable the input:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性（例如 disabled、required、checked、autoFocus 和 readOnly）仅适用于表单元素。在这里要记住的最重要的事情是，属性值必须设置为
    JavaScript 表达式（即在 {} 内部），而不是作为字符串设置。例如，使用 {false} 来启用输入：
- en: '[PRE87]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'But don’t use a "false" value because it’ll pass the truthy check (a non-empty
    string is truthy in JavaScript, as you hopefully remember from section 3.2.6).
    This is because the string "false" isn’t any of the six falsy values; it’s actually
    a non-empty string, which is truthy and results in the value true. React will
    render the input as disabled (disabled will be set to true):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要使用 "false" 值，因为它会通过真值检查（在 JavaScript 中，一个非空字符串是真值，您可能还记得第 3.2.6 节中的内容）。这是因为字符串
    "false" 不是六个假值之一；它实际上是一个非空字符串，是真值，并导致值 true。React 将渲染输入为禁用状态（disabled 将被设置为 true）：
- en: '[PRE88]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If you omit a value after a property, React will set the value to true:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在属性之后省略了值，React 将将值设置为 true：
- en: '[PRE89]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is equivalent to manually setting the value to true, so just use the preceding
    code rather than using required={true}.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于手动将值设置为 true，所以只需使用前面的代码，而不是使用 required={true}。
- en: 'For many of these attributes in HTML, completely excluding the value means
    setting the value to false, so if you want to set a value specifically to true
    or false, simply include it without a value or omit it. If you want to set a value
    based on the contents of a variable, use an expression:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTML 中的许多这些属性，完全省略值意味着将值设置为 false，因此如果您想将值明确设置为 true 或 false，只需包含它而不带值或省略它。如果您想根据变量的内容设置值，请使用表达式：
- en: '[PRE90]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note Notice the multiword problem mentioned before. This Boolean attribute in
    React is called readOnly and not readonly as you know it from HTML.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 注意之前提到的多词问题。在 React 中，这个布尔属性被称为 readOnly，而不是您从 HTML 中所知道的 readonly。
- en: Custom component with Boolean properties
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 带有布尔属性的定制组件
- en: The same thing is true when you create your own components. If you have a custom
    component and want to accept a Boolean property, you can just use a property from
    this.props as if it was a Boolean, and React will make sure to set it to true,
    if specified when used.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建自己的组件时，情况也是如此。如果您有一个自定义组件并且想要接受布尔属性，您只需将 this.props 中的一个属性当作布尔值使用即可，React
    将确保在指定时将其设置为 true。
- en: For example, we can create an alert component that will display an alert message
    to the user. This message is either an error or a warning. To control the level
    of the alert, we add a Boolean flag, isError, and if true, we include a warning-sign
    emoji around the message. We’ll then use this component to display two different
    alerts in our application—one as an error and the other as a warning, as shown
    in listing 3.13\. If we run this in the browser, we see how the two messages are
    correctly displayed (see figure 3.5).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个警报组件，该组件将向用户显示警报消息。这个消息要么是错误，要么是警告。为了控制警报级别，我们添加一个布尔标志isError，如果为真，则在消息周围包含一个警告符号表情符号。然后我们将使用这个组件在我们的应用程序中显示两个不同的警报，一个作为错误，另一个作为警告，如列表3.13所示。如果我们在这个浏览器中运行它，我们可以看到两条消息是如何正确显示的（见图3.5）。
- en: '![03-05](../Images/03-05.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![03-05](../Images/03-05.png)'
- en: Figure 3.5 The first message is just a warning, but the second is definitely
    an error.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 第一条信息只是一个警告，但第二条肯定是一个错误。
- en: Listing 3.13 Passing and accepting Boolean properties in JSX
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 在JSX中传递和接受布尔属性
- en: '[PRE91]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ❶ Sets the isError property to true simply by including it in the JSX without
    a value
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过在JSX中包含它而不指定值来将isError属性设置为true
- en: 'Repository: rq03-alert'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-alert
- en: 'This example can be seen in repository rq03-alert. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq03-alert仓库中看到。你可以通过基于相关模板创建一个新的应用程序来使用该仓库：
- en: '[PRE92]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq03-alert](https://rq2e.com/rq03-alert)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-alert](https://rq2e.com/rq03-alert)'
- en: 3.4.8 Whitespace
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.8 空白
- en: If you want to add whitespace between components—for example, if you’re adding
    a bold word inside a sentence—you have to be very careful about how you place
    your newline characters. Let’s say you want to write a headline with an emphasized
    word in the middle, for example, "All corgis are awesome" but "corgis" must be
    in italics. You could do this in JSX as shown in the next listing.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在组件之间添加空白——例如，如果你想在句子中添加一个粗体词——你必须非常小心地放置你的换行符。假设你想要写一个带有中间强调词的标题，例如，“所有柯基都很棒”，但“柯基”必须用斜体表示。你可以在JSX中像下面这样操作。
- en: Listing 3.14 Naive implementation of a partially emphasized message
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 部分强调信息的简单实现
- en: '[PRE93]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ❶ Some plain text
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一些普通文本
- en: ❷ Then a JSX node
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 然后是一个JSX节点
- en: ❸ Then some more plain text
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 然后是一些更多的普通文本
- en: 'Repository: rq03-bad-whitespace'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-bad-whitespace
- en: 'This example can be seen in repository rq03-bad-whitespace. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq03-bad-whitespace仓库中看到。你可以通过基于相关模板创建一个新的应用程序来使用该仓库：
- en: '[PRE94]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq03-bad-whitespace](https://rq2e.com/rq03-bad-whitespace)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-bad-whitespace](https://rq2e.com/rq03-bad-whitespace)'
- en: This seems pretty reasonable, no? Let’s run this app with CRA and watch it in
    the browser. You can see the result in figure 3.6.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当合理，不是吗？让我们用CRA运行这个应用程序，并在浏览器中观察它。你可以在图3.6中看到结果。
- en: '![03-06](../Images/03-06.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![03-06](../Images/03-06.png)'
- en: Figure 3.6 Emphasized message with improper whitespace
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 不当空格的强调信息
- en: That’s clearly wrong. The space around the word *“corgis”* just collapsed. What
    happened? Normally, newline characters and tabs are ignored as whitespace in JSX.
    When we had JSX as
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。单词“柯基”周围的空格刚刚消失了。发生了什么？通常，在JSX中，换行符和制表符被视为空白被忽略。当我们有JSX时
- en: '[PRE95]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: earlier in the chapter, we didn’t actually want spaces between the elements
    <main> and <h1>. We just formatted it on multiple lines because it looks pretty—not
    because we want a lot of extra whitespace rendered in the browser. So, if there
    is whitespace between elements in JSX that include newline characters, all the
    whitespace is collapsed. It doesn’t matter if you have an extra normal space at
    the end of the plain-text line in listing 3.14\. If there is a newline character
    between the elements, all whitespace is collapsed.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们实际上并不想在 <main> 和 <h1> 元素之间添加空格。我们只是将其格式化为多行，因为这样看起来很漂亮——并不是因为我们想在浏览器中渲染大量的额外空白。所以，如果
    JSX 中的元素之间有包含换行符的空白，所有空白都会被压缩。如果你在列表 3.14 的纯文本行末尾有额外的普通空格，这并不重要。如果元素之间有换行符，所有空白都会被压缩。
- en: 'So, how could we do this correctly? There are two ways to make sure spaces
    are rendered:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何正确地做到这一点呢？有两种方法可以确保空格被渲染：
- en: Don’t use newline characters at all between the elements.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元素之间完全不要使用换行符。
- en: Add spaces as expressions in the code.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中将空格作为表达式添加。
- en: The latter sounds a bit complex and doesn’t look all that good, but can be necessary.
    Let’s see the first solution—no newline characters—in practice.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 后者听起来有点复杂，看起来也不是很好，但可能是必要的。让我们看看第一个解决方案——没有换行符——在实际中的应用。
- en: Listing 3.15 Partially emphasized message without newline characters
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.15 没有换行符的部分强调消息
- en: '[PRE96]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: ❶ Newlines appear before and after the heading.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在标题前后出现换行符。
- en: ❷ No newline characters appear inside the heading.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 标题内部没有出现换行符。
- en: Note that we can have newline characters before and after the message (because
    the whitespace here can be collapsed—we don’t care about it). We just don’t want
    newline characters in places where we want actual space characters to be inserted.
    Now let’s look at space expressions in the next listing.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在消息前后有换行符（因为这里的空白可以被压缩——我们不在乎它）。我们只是不希望在需要插入实际空格字符的地方出现换行符。现在让我们看看下一个列表中的空格表达式。
- en: Listing 3.16 Partially emphasized message with space expressions
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 带有空格表达式的部分强调消息
- en: '[PRE97]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ❶ Spaces inserted as expressions
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为表达式的插入空格
- en: Here, we add spaces using curly brackets. This will force the JSX engine to
    include the spaces as actual elements and not treat them as part of the negligible
    whitespace that normally exists between elements. You’ll often see developers
    append such space-as-expressions at the end of the line before the newline character,
    as shown next.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用花括号添加空格。这将强制 JSX 引擎将空格作为实际元素包含，而不是将它们视为元素之间通常存在的可忽略的空白部分。你经常会看到开发者在换行符之前在行尾附加这样的空格表达式，如下所示。
- en: Listing 3.17 Partially emphasized message with fewer lines
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 带有较少行的部分强调消息
- en: '[PRE98]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: ❶ Space expressions appended at the end of the lines
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在行尾附加空格表达式
- en: 'Repository: rq03-good-whitespace'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq03-good-whitespace
- en: 'This example can be seen in repository rq03-good-whitespace. You can use that
    repository by creating a new app based on the associated template:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在仓库 rq03-good-whitespace 中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE99]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的运行情况，或者下载源代码的 zip 文件：
- en: '[https://rq2e.com/rq03-good-whitespace](https://rq2e.com/rq03-good-whitespace)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq03-good-whitespace](https://rq2e.com/rq03-good-whitespace)'
- en: Both of the preceding listings will render our message correctly in the browser—a
    message that no one can contest, as shown in figure 3.7.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个列表都将正确地在浏览器中渲染我们的消息——一个无人可以质疑的消息，如图 3.7 所示。
- en: '![03-07](../Images/03-07.png)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![03-07](../Images/03-07.png)'
- en: Figure 3.7 All corgis are now correctly rendered as awesome.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 所有柯基犬现在都正确地渲染为很棒。
- en: 3.4.9 data- attributes
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.9 data- 属性
- en: Sometimes, you want to pass additional data using DOM nodes. While you shouldn’t
    use your DOM as a database or local storage, sometimes that’s necessary when you
    want to pass variables to third-party libraries. If you need to create custom
    attributes and get them rendered, use the data- prefix.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您想通过 DOM 节点传递额外的数据。虽然您不应该将您的 DOM 用作数据库或本地存储，但在您想将变量传递给第三方库时，有时这是必要的。如果您需要创建自定义属性并将它们渲染，请使用
    data- 前缀。
- en: 'For example, this is a valid custom data-object-id attribute that React will
    render in the view (HTML will be the same as this JSX):'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个有效的自定义 data-object-id 属性，React 将在视图中渲染（HTML 将与这个 JSX 相同）：
- en: '[PRE100]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 3.5 Quiz
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 小测验
- en: To output a JavaScript variable in JSX, which of the following do you use? =,
    <%= %>, {}, or <?= ?>
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在JSX中输出一个JavaScript变量，你应该使用以下哪个？=, <%= %>, {}, 或 <?= ?>？
- en: The class attribute isn’t allowed in JSX. *True* or *false*?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JSX中不允许使用class属性。*正确*还是*错误*？
- en: The default value for an attribute without a value is false. *True* or *false*?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有值的属性的默认值是false。*正确*还是*错误*？
- en: The inline style attribute in JSX is a JavaScript object and not a string like
    other attributes. *True* or *false*?
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSX中的内联style属性是一个JavaScript对象，而不是像其他属性那样是一个字符串。*正确*还是*错误*？
- en: If you need to have if/else logic in JSX, you can use it inside {}. For example,
    class={if (!this.props.isAdmin) return 'hide'} is valid JSX code. *True* or *false*?
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要在JSX中实现if/else逻辑，你可以在{}中使用它。例如，class={if (!this.props.isAdmin) return 'hide'}是有效的JSX代码。*正确*还是*错误*？
- en: Quiz answers
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问答答案
- en: You use {} for variables and expressions.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用{}来表示变量和表达式。
- en: '*True*. class is a reserved JavaScript statement. For this reason, you use
    className in JSX.'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。class是一个保留的JavaScript语句。因此，在JSX中你使用className。'
- en: '*False*. The default value for a property with no value specified is true.'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。未指定值的属性的默认值是true。'
- en: '*True*. style is an object for performance reasons.'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*正确*。style是为了性能原因而是一个对象。'
- en: '*False*. First, class isn’t the proper attribute name; it’s className. Then,
    instead of if return (which isn’t valid JavaScript anyway in this context), you
    should use a ternary operator or logical expressions. You could do it like this:
    className={this.props.isAdmin || ''hide''}.'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*错误*。首先，class不是正确的属性名；它是className。然后，而不是if return（在这个上下文中，if return本身就不是有效的JavaScript），你应该使用三元运算符或逻辑表达式。你可以这样做：className={this.props.isAdmin
    || ''hide''}。'
- en: Summary
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JSX is just syntactic sugar for React methods such as React.createElement.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX只是React方法（如React.createElement）的语法糖。
- en: You should use className and htmlFor instead of the standard HTML class and
    for attributes.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用className和forHtmlFor而不是标准的HTML class和for属性。
- en: The style attribute takes a JavaScript object, not a string like normal HTML.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: style属性接受一个JavaScript对象，而不是像正常HTML那样接受一个字符串。
- en: Ternary and logical operators are the best ways to implement if/else statements.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元运算符和逻辑运算符是实现if/else语句的最佳方式。
- en: Outputting variables, comments, and HTML entities is easy and straightforward.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出变量、注释和HTML实体既简单又直接。
- en: Several multiword HTML and SVG attributes are renamed in React, so pay attention
    to these special attributes, and remember to verify whether your attributes correctly
    make it into the HTML document.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中，一些多词HTML和SVG属性被重命名了，所以请注意这些特殊属性，并记得验证你的属性是否正确地进入了HTML文档。
- en: JSX needs to be transpiled into JavaScript before it can run in the browser,
    but you rarely have to worry about that. However, if you find it necessary, a
    number of tools are available, including Babel, which is the most popular tool
    at the time of writing.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX需要在浏览器中运行之前将其转换为JavaScript，但你很少需要担心这一点。然而，如果你发现这是必要的，有许多工具可用，包括Babel，这是撰写本文时的最受欢迎的工具。
