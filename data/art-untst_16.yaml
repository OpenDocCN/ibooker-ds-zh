- en: 12 Working with legacy code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 与遗留代码一起工作
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining common problems with legacy code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查遗留代码的常见问题
- en: Deciding where to begin writing tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定从哪里开始编写测试
- en: I once consulted for a large development shop that produced billing software.
    They had over 10,000 developers and mixed .NET, Java, and C++ in products, subproducts,
    and intertwined projects. The software had existed in one form or another for
    over five years, and most of the developers were tasked with maintaining and building
    on top of existing functionality.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经为一家大型软件开发公司提供咨询服务，该公司生产计费软件。他们有超过10,000名开发者，在产品、子产品和相互交织的项目中混合使用.NET、Java和C++。该软件以某种形式存在了超过五年，大多数开发者都被分配去维护和构建在现有功能之上的代码。
- en: 'My job was to help several divisions (using all languages) learn TDD techniques.
    For about 90% of the developers I worked with, this never became a reality for
    several reasons, some of which were a result of legacy code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我的任务是帮助几个部门（使用所有语言）学习TDD技术。对于我合作的大约90%的开发者来说，由于几个原因，这从未成为现实，其中一些原因是遗留代码：
- en: It was difficult to write tests against existing code.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对现有代码编写测试很困难。
- en: It was next to impossible to refactor the existing code (or there wasn’t enough
    time to do it).
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构现有代码几乎是不可能的（或者没有足够的时间来做）。
- en: Some people didn’t want to change their designs.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些人不希望改变他们的设计。
- en: Tooling (or a lack of tooling) was getting in the way.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具（或工具不足）阻碍了进程。
- en: It was difficult to determine where to begin.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定从哪里开始很难。
- en: Anyone who’s ever tried to add tests to an existing system knows that most such
    systems are almost impossible to write tests for. They were usually written without
    proper places (called *seams*) in the software to allow extensions or replacements
    to existing components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试向现有系统添加测试的人都知道，大多数这样的系统几乎不可能编写测试。它们通常在没有适当位置（称为*接口*）的情况下编写，以允许扩展或替换现有组件。
- en: 'There are two problems that need to be addressed when dealing with legacy code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理遗留代码时，需要解决两个问题：
- en: There’s so much work, where should you start to add tests? Where should you
    focus your efforts?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有这么多工作要做，你应该从哪里开始添加测试？你应该把精力集中在哪里？
- en: How can you safely refactor your code if it has no tests to begin with?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码一开始就没有测试，你如何安全地进行重构？
- en: This chapter will tackle these tough questions associated with approaching legacy
    codebases by listing techniques, references, and tools that can help.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将列出技术、参考和工具，以帮助解决通过接近遗留代码库所关联的难题。
- en: 12.1 Where do you start adding tests?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 你从哪里开始添加测试？
- en: 'Assuming you have existing code inside components, you’ll need to create a
    priority list of components for which testing makes the most sense. There are
    several factors to consider that can affect each component’s priority:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经在组件内部有现有的代码，你需要为那些测试最有意义的组件创建一个优先级列表。有几个因素需要考虑，这些因素会影响每个组件的优先级：
- en: '*Logical complexity*—This refers to the amount of logic in the component, such
    as nested `if`s, switch cases, or recursion. Such complexity is also called *cyclomatic
    complexity*, and you can use various tools to check it automatically.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑复杂性*—这指的是组件中的逻辑量，例如嵌套的`if`语句、switch情况或递归。这种复杂性也称为*循环复杂性*，你可以使用各种工具自动检查它。'
- en: '*Dependency level*—This refers to the number of dependencies in the component.
    How many dependencies do you have to break in order to bring this class under
    test? Does it communicate with an outside email component, perhaps, or does it
    call a static log method somewhere?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖级别*—这指的是组件中的依赖项数量。你需要打破多少个依赖项才能将这个类纳入测试？它是否与外部的电子邮件组件通信，或者是否在某个地方调用静态日志方法？'
- en: '*Priority*—This is the component’s general priority in the project.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先级*—这是组件在项目中的总体优先级。'
- en: You can give each component a rating for these factors, from 1 (low priority)
    to 10 (high priority). Table 12.1 shows classes with ratings for these factors.
    I call this a *test-feasibility table*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个组件根据这些因素进行评分，从1（低优先级）到10（高优先级）。表12.1显示了具有这些因素评分的类。我称之为*测试可行性表*。
- en: Table 12.1 A simple test-feasibility table
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 简单的测试可行性表
- en: '| Component | Logical complexity | Dependency level | Priority | Notes |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 逻辑复杂性 | 依赖级别 | 优先级 | 备注 |'
- en: '| `Utils` | 6 | 1 | 5 | This utility class has few dependencies but contains
    a lot of logic. It will be easy to test, and it provides lots of value. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `Utils` | 6 | 1 | 5 | 这个实用类依赖项很少，但包含大量逻辑。它将很容易进行测试，并且提供了很多价值。|'
- en: '| `Person` | 2 | 1 | 1 | This is a data-holder class with little logic and
    no dependencies. There’s little real value in testing this. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Person` | 2 | 1 | 1 | 这是一个逻辑简单且无依赖的数据持有类。测试它的实际价值很小。|'
- en: '| `TextParser` | 8 | 4 | 6 | This class has lots of logic and lots of dependencies.
    To top it off, it’s part of a high-priority task in the project. Testing this
    will provide lots of value but will also be hard and time consuming. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `TextParser` | 8 | 4 | 6 | 这个类逻辑复杂且依赖性多。更糟糕的是，它是项目中的一个高优先级任务的一部分。测试它将提供很多价值，但也会很困难且耗时。'
- en: '| `ConfigManager` | 1 | 6 | 1 | This class holds configuration data and reads
    files from disk. It has little logic but many dependencies. Testing it will provide
    little value to the project and will also be hard and time consuming. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `ConfigManager` | 1 | 6 | 1 | 这个类持有配置数据，并从磁盘读取文件。它逻辑简单但依赖性很多。测试它对项目的价值很小，而且也会很困难且耗时。'
- en: From the data in table 12.1, you can create a diagram like the one shown in
    figure 12.1, which graphs your components by the amount of value to the project
    and number of dependencies. You can safely ignore items that are below your designated
    threshold of logic (which I usually set at 2 or 3), so `Person` and `ConfigManager`
    can be ignored. You’re left with only the top two components in figure 12.1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从表12.1中的数据，你可以创建一个类似于图12.1所示的图表，该图表通过项目价值和依赖数量来绘制你的组件。你可以安全地忽略低于你设定的逻辑阈值（我通常设定为2或3）的项目，因此可以忽略`Person`和`ConfigManager`。你只剩下图12.1中排名前两位的组件。
- en: '![12-01](../Images/12-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![12-01](../Images/12-01.png)'
- en: Figure 12.1 Mapping components for test feasibility
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 测试可行性组件映射
- en: 'There are two basic ways to look at the graph and decide what you’d like to
    test first (see figure 12.2):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基本方法来查看图表并决定你想先测试什么（见图12.2）：
- en: Choose the one that’s more complex and easier to test (top left).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择更复杂但更容易测试的（左上角）。
- en: Choose the one that’s more complex and harder to test (top right).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择更复杂且更难测试的（右上角）。
- en: '![12-02](../Images/12-02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![12-02](../Images/12-02.png)'
- en: Figure 12.2 Easy, hard, and irrelevant component mapping based on logic and
    dependencies
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 基于逻辑和依赖关系的简单、困难和无关组件映射
- en: The question now is what path you should take. Should you start with the easy
    stuff or the hard stuff?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是你应该选择哪条路径。你应该从简单的事情开始，还是从困难的事情开始？
- en: 12.2 Choosing a selection strategy
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 选择选择策略
- en: As the previous section explained, you can start with the components that are
    easy to test or the ones that are hard to test (because they *have many dependencies).
    Each strategy presents* different challenges.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以从容易测试的组件开始，或者从难以测试的组件开始（因为它们*有很多依赖关系）。每种策略都带来了不同的挑战。
- en: 12.2.1 Pros and cons of the easy-first strategy
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 简单优先策略的优缺点
- en: Starting out with the components that have fewer dependencies will make writing
    the tests initially much quicker and easier. But there’s a catch, as figure 12.3
    demonstrates.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从依赖性较少的组件开始，将使最初编写测试变得更快、更容易。但正如图12.3所展示的，这里有一个陷阱。
- en: '![12-03](../Images/12-03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![12-03](../Images/12-03.png)'
- en: Figure 12.3 When starting with the easy components, the time required to test
    components increases more and more until the hardest components are done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 当从简单的组件开始时，测试组件所需的时间会越来越多，直到最困难的组件完成。
- en: Figure 12.3 shows how long it takes to bring components under test during the
    lifetime of the project. Initially it’s easy to write tests, but as time goes
    by, you’re left with components that are increasingly harder and harder to test,
    with the particularly tough ones waiting for you at the end of the project cycle,
    just when everyone is stressed about pushing a product out the door.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3显示了在整个项目生命周期中，将组件纳入测试所需的时间。最初编写测试很容易，但随着时间的推移，你将面临越来越难以测试的组件，特别是那些特别困难的组件，它们会在项目周期的末尾等待你，那时每个人都正忙于推动产品上市。
- en: If your team is relatively new to unit testing techniques, it’s worth starting
    with the easy components. As time goes by, the team will learn the techniques
    needed to deal with the more complex components and dependencies. For such a team,
    it may be wise to initially avoid all components over a specific number of dependencies
    (with four being a reasonable limit).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的团队相对较新，对单元测试技术不太熟悉，从简单的组件开始是值得的。随着时间的推移，团队将学会处理更复杂组件和依赖关系所需的技术。对于这样的团队，最初避免所有超过特定数量依赖关系的组件（4个是一个合理的限制）可能是明智的。
- en: 12.2.2 Pros and cons of the hard-first strategy
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 硬件优先策略的优缺点
- en: Starting with the more difficult components may seem like a losing proposition
    initially, but it has an upside as long as your team has experience with unit
    testing techniques. Figure 12.4 shows the average time to write a test for a single
    component over the lifetime of the project, if you start testing the components
    with the most dependencies first.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，从更困难的组件开始可能看起来像是一个失败的选择，但只要你的团队有单元测试技术的经验，它就有优点。图 12.4 显示了在整个项目生命周期中，如果你首先测试具有最多依赖项的组件，编写单个组件测试的平均时间。
- en: '![12-04](../Images/12-04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![12-04](../Images/12-04.png)'
- en: Figure 12.4 When you use a hard-first strategy, the time required to test components
    is initially high, but then decreases as more dependencies are refactored away.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 当你使用硬件优先策略时，测试组件所需的时间最初很高，但随着更多依赖项的重构而降低。
- en: With this strategy, you could be spending a day or more to get even the simplest
    tests going on the more complex components. But notice the quick decline in the
    time required to write the tests relative to the slow incline in figure 12.3\.
    Every time you bring a component under test and refactor it to make it more testable,
    you may also be solving testability issues for the dependencies it uses or for
    other components. Because that component has lots of dependencies, refactoring
    it can improve things for other parts of the system. That’s the reason for the
    quick decline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，你可能会花费一天或更长时间才能在更复杂的组件上启动最简单的测试。但请注意，相对于图 12.3 中的缓慢上升，编写测试所需的时间迅速下降。每次你将一个组件置于测试状态并重构它以使其更具可测试性时，你也可能解决了它所使用的依赖项或其他组件的可测试性问题。因为这个组件有很多依赖项，重构它可以改善系统的其他部分。这就是快速下降的原因。
- en: The hard-first strategy is only possible if your team has experience in unit
    testing techniques, because it’s harder to implement. If your team does have experience,
    use the priority aspect of components to choose whether to start with the hard
    or easy components. You might want to choose a mix, but it’s important that you
    know in advance how much effort will be involved and what the possible consequences
    are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件优先策略只有在你的团队有单元测试技术经验的情况下才可行，因为它的实现更困难。如果你的团队确实有经验，请使用组件的优先级方面来决定是否从硬件或软件组件开始。你可能想要选择混合策略，但重要的是你事先知道将涉及多少工作量以及可能的后果是什么。
- en: 12.3 Writing integration tests before refactoring
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 在重构之前编写集成测试
- en: If you do plan to refactor your code for testability (so you can write unit
    tests), a practical way to make sure you don’t break anything during the refactoring
    phase is to write integration-style tests against your production system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实计划重构代码以提高可测试性（以便可以编写单元测试），确保在重构阶段不会破坏任何东西的一个实用方法是针对你的生产系统编写集成风格的测试。
- en: I consulted on a large legacy project, working with a developer who needed to
    work on an XML configuration manager. The project had no tests and was hardly
    testable. It was also a C++ project, so we couldn’t use a tool to easily isolate
    components from dependencies without refactoring the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个大型遗留项目中提供咨询，与一个需要处理 XML 配置管理器的开发者合作。该项目没有测试，几乎不可测试。它也是一个 C++ 项目，所以我们不能在不重构代码的情况下使用工具轻松地将组件从依赖中隔离出来。
- en: The developer needed to add another value attribute into the XML file and be
    able to read and change it through the existing configuration component. We ended
    up writing a couple of integration tests that used the real system to save and
    load configuration data and that asserted on the values the configuration component
    was retrieving and writing to the file. Those tests set the “original” working
    behavior of the configuration manager as our base of work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者需要在 XML 文件中添加另一个值属性，并且能够通过现有的配置组件读取和更改它。我们最终编写了一些集成测试，这些测试使用了真实系统来保存和加载配置数据，并断言配置组件检索和写入文件中的值。这些测试设定了配置管理器的“原始”工作行为作为我们的工作基础。
- en: Next, we wrote an integration test that showed that once the component was reading
    the file, it contained no attribute in memory with the name we were trying to
    add. We proved that the feature was missing, and we now had a test that would
    pass once we added the new attribute to the XML file and correctly wrote to it
    from the component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写了一个集成测试，表明一旦组件开始读取文件，它就不会在内存中包含我们试图添加的名称的属性。我们证明了该功能缺失，现在我们有一个测试，一旦我们将新属性添加到
    XML 文件中并从组件中正确写入，它就会通过。
- en: Once we wrote the code that saved and loaded the extra attribute, we ran the
    three integration tests (two tests for the original base implementation and a
    new one that tried to read the new attribute). All three passed, so we knew that
    we hadn’t broken existing functionality while adding the new functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了保存和加载额外属性的代码，我们就运行了三个集成测试（两个针对原始基实现，一个尝试读取新属性）。所有三个都通过了，所以我们知道在添加新功能的同时没有破坏现有功能。
- en: 'As you can see, the process is relatively simple:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个过程相对简单：
- en: Add one or more integration tests (no mocks or stubs) to the system to prove
    the original system works as needed.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向系统中添加一个或多个集成测试（无模拟或存根），以证明原始系统按需工作。
- en: Refactor or add a failing test for the feature you’re trying to add to the system.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您想要添加到系统中的功能进行重构或添加一个失败的测试。
- en: Refactor and change the system in small chunks, and run the integration tests
    as often as you can, to see if you break something.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小块重构和改变系统，尽可能频繁地运行集成测试，以查看你是否破坏了某些东西。
- en: Sometimes, integration tests may seem easier to write than unit tests, because
    you don’t need to understand the internal structure of the code or where to inject
    various dependencies. But making those tests run on your local system may prove
    annoying or time consuming because you have to make sure every little thing the
    system needs is in place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，集成测试可能比单元测试更容易编写，因为你不需要了解代码的内部结构或在哪里注入各种依赖项。但是，在本地系统上运行这些测试可能会很烦人或耗时，因为你必须确保系统需要的每一件小事都到位。
- en: The trick is to work on the parts of the system that you need to fix or add
    features to. Don’t focus on the other parts. That way, the system grows in the
    right places, leaving other bridges to be crossed when you get to them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于专注于需要修复或添加功能的系统部分。不要关注其他部分。这样，系统就会在正确的位置增长，留待以后解决其他问题。
- en: As you continue adding more and more tests, you can refactor the system and
    add more unit tests to it, growing it into a more maintainable and testable system.
    This takes time (sometimes months and months), but it’s worth it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续添加越来越多的测试，你可以重构系统并添加更多的单元测试，使其成为一个更易于维护和测试的系统。这需要时间（有时是几个月甚至更长时间），但这是值得的。
- en: Chapter 7 of *Unit Testing Principles, Practices, and Patterns* by Vladimir
    Khorikov (Manning, 2020) contains an in-depth example of such refactoring. Refer
    to that book for more details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 《*单元测试原则、实践和模式*》第七章，由弗拉基米尔·科里科夫（Manning，2020）所著，包含了一个此类重构的深入示例。更多细节请参阅该书。
- en: 12.3.1 Read Michael Feathers’ book on legacy code
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 阅读迈克尔·费瑟斯的《遗留代码》书籍
- en: '*Working Effectively with Legacy Code* by Michael Feathers (Pearson, 2004)
    is another valuable source that deals with the issues you’ll encounter with legacy
    code. It shows many refactoring techniques and gotchas in depth that this book
    doesn’t attempt to cover. It’s worth its weight in gold. Get it.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·费瑟斯的《*与遗留代码有效工作*》（Pearson，2004）是另一个非常有价值的资源，它处理了你在遗留代码中会遇到的问题。它深入展示了这本书没有尝试涵盖的许多重构技术和陷阱。它价值连城。去获取它吧。
- en: 12.3.2 Use CodeScene to investigate your production code
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用CodeScene调查你的生产代码
- en: Another tool called CodeScene allows you to discover lots of technical debt
    and hidden issues in legacy code, among many other things. It is a commercial
    tool, and while I have not personally used it, I've heard great things. You can
    learn more about it at [https://codescene.com/](https://codescene.com/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为CodeScene的工具可以帮助你发现遗留代码中的许多技术债务和隐藏问题，以及其他许多事情。这是一个商业工具，虽然我本人没有使用过它，但我听说了很多好话。你可以在[https://codescene.com/](https://codescene.com/)了解更多信息。
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Before starting to write tests for legacy code, it’s important to map out the
    various components according to their number of dependencies, their amount of
    logic, and each component’s general priority in the project. A component’s logical
    complexity (or cyclomatic complexity) refers to the amount of logic in the component,
    such as nested `if`s, switch cases, or recursion.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始为遗留代码编写测试之前，根据组件的依赖关系数量、逻辑量以及每个组件在项目中的总体优先级，对各种组件进行规划非常重要。组件的逻辑复杂性（或圈复杂度）指的是组件中的逻辑量，例如嵌套的`if`语句、switch情况或递归。
- en: Once you have that information, you can choose the components to work on based
    on how easy or how hard it will be to get them under test.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你有了这些信息，你可以根据将组件置于测试之下是容易还是困难来选择要工作的组件。
- en: If your team has little or no experience in unit testing, it’s a good idea to
    start with the easy components and let the team’s confidence grow as they add
    more and more tests to the system.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的团队在单元测试方面经验很少或没有经验，从容易的部分开始是一个好主意，随着他们向系统中添加越来越多的测试，团队的信心也会逐渐增长。
- en: If your team is experienced, getting the hard components under test first can
    help you get through the rest of the system more quickly.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的团队经验丰富，首先测试困难的部分可以帮助你更快地完成整个系统的其余部分。
- en: Before a large-scale refactoring, write integration tests that will sustain
    that refactoring mostly unchanged. After the refactoring is completed, replace
    most of these integration tests with smaller and more maintainable unit tests.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行大规模重构之前，编写将主要保持不变的集成测试。重构完成后，用更小、更易于维护的单元测试替换这些集成测试中的大部分。
