- en: '10 Persistence is good: Databases'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 持之以恒是好的：数据库
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Persisting data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化数据
- en: Database systems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库系统
- en: Database structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库结构
- en: Modeling data with SQLAlchemy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 模型数据
- en: You’ve shown a great deal of persistence in getting this far, and I hope the
    journey has been rewarding and held your interest. As satisfying as sticking with
    something is, that kind of persistence isn’t what this chapter covers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你在达到这一步的过程中展现出了极大的毅力，我希望这段旅程是令人满意的，并且引起了你的兴趣。尽管坚持做某件事是令人满意的，但这种毅力并不是本章要讨论的内容。
- en: This chapter is about persisting application data over time. You don’t run the
    applications you use forever, and despite the stability of computer systems, they
    are shut down and restarted periodically.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于随时间持久化应用程序数据。你不会永远运行你使用的应用程序，尽管计算机系统很稳定，但它们会定期关闭和重启。
- en: Imagine using a complex spreadsheet and having to re-enter all the data every
    time you restarted the application or powered on the computer. Even with the enormous
    processing power of a computer, it would hardly be a helpful device if there was
    no way to save and restore the information entered into it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下使用一个复杂的电子表格，每次重启应用程序或打开电脑时都必须重新输入所有数据。即使有电脑巨大的处理能力，如果没有保存和恢复输入信息的方法，它几乎不会是一个有用的设备。
- en: 10.1 The other half
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 另一半
- en: As a developer, it’s easy to think of the application code you’re creating as
    the primary product of your efforts. But, in reality, your cool, essential application
    with all its well-thought-out features and functions is only half the story. The
    other, equally important half is the data that your application helps the user
    work with. Modifying, transforming, and providing insights into the data in which
    your users are interested is the raw material an application works with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，很容易将你正在创建的应用程序代码视为你努力的最重要的产品。但事实上，你那酷炫、关键的应用程序，以及所有精心设计的特性和功能，只是故事的一半。另一半，同样重要的是，你的应用程序帮助用户工作的数据。修改、转换以及对用户感兴趣的数据提供见解是应用程序工作的原材料。
- en: 10.1.1 Maintaining information over time
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 随时间维护信息
- en: A filesystem saves data to a storage medium independent of electrical power.
    Most personal computer systems maintain filesystems on either mechanical or solid-state
    drives. These storage devices have filesystem structures layered over them by
    the operating system of the computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统将数据保存到独立于电力的存储介质中。大多数个人计算机系统在机械或固态驱动器上维护文件系统。这些存储设备由计算机的操作系统在其上分层构建文件系统结构。
- en: The filesystem provides a hierarchically organized mechanism to save and retrieve
    files from the storage device. As far as the filesystem is concerned, a file is
    a sequence of data bytes connected to a file name existing somewhere in the hierarchy.
    In addition, the filesystem can create, modify, and delete files and maintains
    housekeeping metadata about the files, such as read, write, and executable status.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统提供了一个分层组织的机制来保存和从存储设备检索文件。就文件系统而言，一个文件是一系列数据字节，这些字节连接到一个文件名，该文件名存在于层次结构中的某个位置。此外，文件系统可以创建、修改和删除文件，并维护有关文件的家务元数据，例如读取、写入和可执行状态。
- en: Application programs give meaning to the data in a file. For example, when a
    photo-viewing application opens a JPEG image file, the user sees a picture. The
    photo application can interpret the contents of the file and generate the expected
    visual results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序程序为文件中的数据赋予意义。例如，当照片查看应用程序打开一个 JPEG 图像文件时，用户会看到一个图片。照片应用程序可以解释文件的内容并生成预期的视觉结果。
- en: If a user were to open the same JPEG image file with a text editor, they would
    see a block of largely incomprehensible data. Most of the files in a filesystem
    are like this; their content makes sense only to the applications that can read
    and interpret them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户用文本编辑器打开相同的 JPEG 图像文件，他们会看到一大块难以理解的数据。文件系统中的大多数文件都是这样的；它们的内容只有能够读取和解释它们的程序才能理解。
- en: The MyBlog application needs to save, modify, and recall content to display
    to users. The content saved to the filesystem is in a format understood by the
    application. The MyBlog application already saves registered user information
    to the filesystem using a database. This chapter is a tangential topic away from
    the MyBlog application to take a closer look at databases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序需要保存、修改和召回要显示给用户的内容。保存到文件系统的内容是应用程序可以理解的格式。MyBlog 应用程序已经使用数据库将注册用户信息保存到文件系统中。本章是一个从
    MyBlog 应用程序出发的旁枝末节，以便更仔细地查看数据库。
- en: 10.2 Accessing data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 访问数据
- en: Before diving directly into database systems, let’s talk about storing data
    in general. To do so, we’ll use customer orders for products, something everyone
    who’s made online purchases is familiar with. Later, we’ll use this idea to illustrate
    some issues when storing data in filesystems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接深入研究数据库系统之前，让我们先谈谈一般的数据存储。为此，我们将使用产品订单，这是所有进行过在线购物的人都很熟悉的事情。稍后，我们将使用这个想法来说明在文件系统中存储数据时的一些问题。
- en: To begin with, imagine an online store that only sells a single product to many
    customers. Each customer might create multiple orders for that single product.
    To make the data relatively easy to present on the pages of this book, we’ll keep
    the amount of information very low—the customer’s name, their address, the product
    name, and the quantity in the order.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，想象一个只向许多客户销售单一产品的在线商店。每位客户可能为该单一产品创建多个订单。为了使数据相对容易地展示在这本书的页面上，我们将保持信息量非常低——客户的姓名、他们的地址、产品名称和订单中的数量。
- en: A common format for data in a filesystem is the comma-separated value format
    or CSV. A CSV file is easy to understand and has the advantage of being human-readable
    and accessible by computer systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统中数据的一种常见格式是逗号分隔值格式或CSV。CSV文件易于理解，并且具有可由计算机系统读取和访问的优点。
- en: A CSV file is a simple text file in which each line of text is a record of data
    ending in a newline character. A comma character separates the data elements in
    each line of text. The first line of text in a CSV file often contains the names
    of each comma-separated field in the remaining rows in the text file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件是一种简单的文本文件，其中每行文本都是一个以换行符结束的数据记录。逗号字符分隔每行文本中的数据元素。CSV文件的文本第一行通常包含剩余文本文件中每行逗号分隔字段的名称。
- en: A CSV file contains no information about the data type for each element in a
    record, everything is just text. An application reads the CSV file and splits
    each comma-separated line of text into fields of text data. The imaginary company
    selling only one product to each customer could save all their customers’ information
    and their orders in a single CSV file. Figure 10.1 shows one possible way the
    data could be saved.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件不包含关于记录中每个元素数据类型的任何信息，一切只是文本。应用程序读取CSV文件并将每行以逗号分隔的文本拆分为文本数据字段。想象一家只向每位客户销售一种产品的公司，它可以将其所有客户信息和订单保存在单个CSV文件中。图10.1显示了数据可能保存的一种可能方式。
- en: '![](../../OEBPS/Images/CH10_F01_Farrell.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F01_Farrell.png)'
- en: Figure 10.1 The CSV file structure containing all the company orders and the
    data for those orders
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 包含所有公司订单及其订单数据的CSV文件结构
- en: This CSV file is sufficient to represent the customers, their shipping address,
    and their orders. The first field contains the customer’s name, the second their
    address, the third their zip code, the fourth field is the product name, and the
    last field is the number of products in the order. Because the company only sells
    a single product, this could work.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此CSV文件足以表示客户、他们的送货地址和他们的订单。第一个字段包含客户姓名，第二个字段包含他们的地址，第三个字段包含他们的邮政编码，第四个字段是产品名称，最后一个字段是订单中的产品数量。因为公司只销售一种产品，所以这可以工作。
- en: Even in this example, you might notice a potential problem. There’s redundant
    data in the file. For example, customers and their addresses are represented multiple
    times for each separate order, as in the case of the orders for Joe and Mary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个例子中，你也可能注意到一个潜在的问题。文件中有冗余数据。例如，对于Joe和Mary的订单，客户及其地址在每个单独的订单中多次表示。
- en: The same data stored multiple times can be a problem if the customer Joe wants
    to start using his full name, Joseph. To accommodate this, the company would have
    to update all the records in the file related to Joe. This kind of update is prone
    to error, particularly if the file has become very large. Making a mistake and
    missing one or more of the Joe records would create two sets of customer records,
    one for Joe and another for Joseph.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户Joe想开始使用他的全名Joseph，那么多次存储相同的数据可能会成为一个问题。为了适应这种情况，公司必须更新与Joe相关的所有文件记录。这种更新容易出错，尤其是如果文件变得非常大。犯了一个错误，遗漏了一个或多个Joe记录，就会创建两组客户记录，一组是Joe的，另一组是Joseph的。
- en: We could resolve the problem by removing the redundancy and having only one
    record for each customer and representing multiple orders in that same record.
    You could create more comma-separated fields containing the quantities, but because
    there’s no way to know how many orders a customer will create, it would be difficult
    for an application reading the CSV file to know how many order fields to expect.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移除冗余，并为每个客户只保留一条记录，并在该记录中表示多个订单来解决这个问题。你可以创建包含数量的更多逗号分隔字段，但由于无法知道客户将创建多少订单，因此应用程序在读取CSV文件时很难知道期望多少个订单字段。
- en: We could pack multiple product and quantity fields into the single order field,
    but we’d need to use a delimiter distinct from a comma to separate the values.
    So, instead, we use the pipe character (vertical bar, |) to separate orders and
    the hyphen character (-) to separate the product from the quantity. Doing this
    allows you to maintain multiple orders per record so that an application can still
    parse the lines of text in the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个产品和数量字段打包到单个订单字段中，但我们需要使用与逗号不同的分隔符来分隔值。因此，我们使用管道字符（竖线，|）来分隔订单，使用连字符字符（-）来分隔产品与数量。这样做可以让你在每条记录中维护多个订单，以便应用程序仍然可以解析文件中的文本行。
- en: Implementing this idea creates a CSV with all the data for multiple orders contained
    in one line of the file. Figure 10.2 shows the file with this structural change.
    The order information is still one comma-separated data item, but it will need
    to be parsed specifically to get the order data items.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实施这个想法会在文件的一行中包含所有多个订单的数据，创建一个CSV文件。图10.2显示了具有这种结构变化的文件。订单信息仍然是逗号分隔的数据项，但需要特别解析以获取订单数据项。
- en: '![](../../OEBPS/Images/CH10_F02_Farrell.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F02_Farrell.png)'
- en: Figure 10.2 The CSV file restructured to reduce data redundancy
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 CSV文件重构以减少数据冗余](../../OEBPS/Images/CH10_F02_Farrell.png)'
- en: This implementation reduces the redundancy in the file as well as its size.
    Reducing the redundancy comes at the cost of increased processing when reading
    and interpreting the data in this CSV file. The application will have to parse
    for the comma, the pipe, and the dash character delimiters in the order field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现减少了文件中的冗余以及其大小。减少冗余的代价是在读取和解释这个CSV文件中的数据时增加了处理量。应用程序将不得不在订单字段中解析逗号、管道和连字符字符分隔符的顺序。
- en: Suppose our imaginary company decides to sell multiple products, and customers
    can ship an order to any address they want. Now customer orders need to contain
    the shipping address information, which needs its own delimiters within the field
    to stay distinct. Figure 10.3 illustrates this additional complication to the
    CSV file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的虚构公司决定销售多个产品，并且客户可以将订单发送到他们想要的任何地址。现在客户订单需要包含送货地址信息，该信息需要在字段内使用自己的分隔符以保持其独特性。图10.3说明了CSV文件中这个额外复杂性的示例。
- en: '![](../../OEBPS/Images/CH10_F03_Farrell.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F03_Farrell.png)'
- en: Figure 10.3 The CSV file restructured to accommodate multiple products and shipping
    addresses
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 CSV文件重构以适应多个产品和送货地址](../../OEBPS/Images/CH10_F03_Farrell.png)'
- en: Adding more delimiters could work, but it’s getting silly with multiple data
    items to parse in the orders field. This approach also doesn’t scale well, as
    adding more products makes the orders field even more complicated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 添加更多分隔符可能可行，但在订单字段中解析多个数据项时，这会变得很荒谬。这种方法也不太适合扩展，因为添加更多产品会使订单字段变得更加复杂。
- en: Resolving this problem means recognizing the logical divisions between the data
    elements to be stored. For example, a customer can ship multiple orders to different
    shipping addresses, and each order can contain multiple products and quantities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题意味着要识别出需要存储的数据元素之间的逻辑划分。例如，一个客户可以向不同的送货地址发送多个订单，并且每个订单可以包含多个产品和数量。
- en: Each customer can have multiple orders, but each order is related to only a
    single customer. Similarly, each address can be related to multiple orders, but
    each order will ship to only a single address.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户可以有多个订单，但每个订单只与一个客户相关。同样，每个地址可以与多个订单相关，但每个订单只会发送到单个地址。
- en: Orders and products are a little more challenging. An order can contain multiple
    products, and a product can be part of multiple orders. To resolve this, we invent
    the concept of an order having an item. An item relates to an order and a product,
    providing this two-way connection. An item might also contain the quantity of
    products the item represents.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 订单和产品稍微有点挑战性。一个订单可以包含多个产品，一个产品可以是多个订单的一部分。为了解决这个问题，我们发明了订单有一个项目的概念。项目与订单和产品相关联，提供了这种双向连接。项目还可能包含代表的产品数量。
- en: 'We can break the data into separate CSV files along these logical lines, essentially
    where we’ve added additional delimiters in the text. Taking this action creates
    five CSV files: customer, address, product, order, and item. The five CSV files
    separate the data along logical lines. Unfortunately, there’s no way to connect
    a customer to an order, an order to an address, or an item to either an order
    or a product.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据这些逻辑线将数据分解成单独的CSV文件，本质上是在文本中添加了额外的分隔符。采取这一行动创建了五个CSV文件：客户、地址、产品、订单和项目。这五个CSV文件根据逻辑线分离数据。不幸的是，没有方法可以将客户连接到订单，订单连接到地址，或将项目连接到订单或产品。
- en: To connect the data, we need to create relationships between the rows of data
    in the files. We can do this by creating a unique identifying value for each row
    in every CSV file. At a minimum, the row identifier only needs to be unique across
    the rows in an individual CSV file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接数据，我们需要在文件中的数据行之间创建关系。我们可以通过为每个CSV文件中的每一行创建一个唯一的标识值来实现这一点。至少，行标识符只需要在单个CSV文件中的行之间是唯一的。
- en: We’ll add another column at the beginning of each row and assign an integer
    value incremented for each row. The integer value uniquely identifies each row
    of data in a single CSV file, but there are still no relationships between CSV
    files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每行的开头添加另一列，并为每行分配一个递增的整数值。这个整数值唯一地标识了单个CSV文件中的每行数据，但CSV文件之间仍然没有关系。
- en: To create relationships, we add the unique identifier from one record in a CSV
    file to another to indicate the relationship between the two. We’ll add the unique
    identifier as a new value to all the rows in the order CSV file that relate to
    that customer to create this relationship. This kind of relationship is called
    one-to-many.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建关系，我们将一个CSV文件中的一个记录的唯一标识符添加到另一个记录中，以指示两个记录之间的关系。我们将唯一标识符作为新值添加到与该客户相关的订单CSV文件的所有行中，以创建这种关系。这种关系被称为一对一。
- en: There’s also another relationship we must establish. Each order can consist
    of multiple products, and each product can relate to multiple orders. A relationship
    like this is called a many-to-many. Conceptually, this is a many-to-one relationship
    combined with a one-to-many and is implemented by creating relationship associations.
    This is how the concept of an order item, as mentioned earlier, is implemented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须建立另一种关系。每个订单可以包含多个产品，每个产品可以与多个订单相关联。这种关系被称为多对多。从概念上讲，这是一种多对一关系与一对多关系的组合，并通过创建关系关联来实现。这就是前面提到的订单项概念是如何实现的。
- en: To do this, we’ll create an item CSV file that contains the unique IDs from
    both the order and product CSV files for each item. In this way, an order can
    connect to multiple items and multiple products.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将创建一个包含每个项目的订单和产品CSV文件中唯一ID的项CSV文件。这样，一个订单可以连接到多个项目和多个产品。
- en: Figure 10.4 shows the five CSV files, their contents, and the relationships
    between them. Each file has a unique ID value as the first field in each row of
    data. The structure shows the `Customer`, `Product`, and `Address` files have
    no redundant data. It also shows the `Order` and `Item` files contain primarily
    relationship data, aside from the unique ID and the `qty` value in the `Item`
    file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4显示了五个CSV文件、它们的内容和它们之间的关系。每个文件的数据行都以一个唯一的ID值作为首字段。这种结构显示“客户”、“产品”和“地址”文件没有冗余数据。它还显示“订单”和“项目”文件主要包含关系数据，除了“项目”文件中的唯一ID和“数量”值之外。
- en: '![](../../OEBPS/Images/CH10_F04_Farrell.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F04_Farrell.png)'
- en: Figure 10.4 The CSV files eliminate data redundancy and allow for multiple products
    and addresses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 CSV文件消除了数据冗余，并允许有多个产品和地址。
- en: Because of the structure and contents of the CSV files, our imaginary company
    could continue to add new customers, new products to sell, and new shipping addresses,
    all without creating unsustainable redundant information. The program in `examples/CH_10/examples/01/main.py`
    uses this information to create simple invoice PDF files for all the orders in
    the system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSV文件的结构和内容，我们的假设公司可以继续添加新的客户、新产品销售和新配送地址，而无需创建不可持续的重叠信息。`examples/CH_10/examples/01/main.py`程序中的程序使用这些信息为系统中的所有订单创建简单的发票PDF文件。
- en: The program, available in the code repository, works by reading all the CSV
    files into memory and creating a `Transactions` container class to hold the information.
    Next, the orders in the `Transactions` class are inserted into the transaction
    information fields in a Jinja2 template. The resulting rendered HTML is converted
    to a PDF file, as shown in figure 10.5.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可在代码仓库中找到的程序通过将所有CSV文件读入内存并创建一个`Transactions`容器类来存储信息来工作。接下来，将`Transactions`类中的订单插入到Jinja2模板的交易信息字段中。生成的渲染HTML被转换为PDF文件，如图10.5所示。
- en: These ideas and their implementation work but have significant limitations.
    Because the CSV files are read into memory, the number of customers, products,
    and orders are limited to the amount of memory the application has available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法及其实现是有效的，但存在重大限制。由于CSV文件被读入内存，客户、产品和订单的数量限制在应用程序可用的内存量。
- en: '![](../../OEBPS/Images/CH10_F05_Farrell.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F05_Farrell.png)'
- en: Figure 10.5 The PDF invoice generated by the `examples/CH_10/examples/01/main.py`
    program
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 由`examples/CH_10/examples/01/main.py`程序生成的PDF发票
- en: The example program has only one use, to create a set of order invoices for
    all the orders in the system. There is no facility to search for an order, customer,
    or product. Any additional use cases our imaginary company might want, like searching
    or reporting, require more programming development.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序只有一个用途，即为系统中的所有订单创建一组订单发票。没有搜索订单、客户或产品的功能。我们假设的公司可能需要的任何其他用途，如搜索或报告，都需要更多的编程开发。
- en: Our imaginary company would likely want to have multiple users—both customers
    and employees—interacting with the data. Coordinating multiple access must be
    handled by the application so the data stays consistent and uncorrupted. If multiple
    applications access the CSV files, this presents another level of complexity to
    coordinate that access, keep the data synchronized and current in all applications,
    and prevent the files from becoming corrupted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设的公司可能希望有多个用户——包括客户和员工——与数据交互。协调多个访问必须由应用程序处理，以确保数据的一致性和完整性。如果多个应用程序访问CSV文件，这将增加另一个层次的复杂性来协调访问，确保所有应用程序中的数据同步和最新，并防止文件损坏。
- en: There’s also no standardized way to use the CSV files. The CSV files are shared
    easily enough, but anyone wanting to use them would need detailed knowledge of
    the structure of the files and the relationships implied by that structure. They’d
    also have to maintain that structure if they wanted to modify the data contents.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有标准化的方式来使用CSV文件。CSV文件很容易共享，但任何想要使用它们的人都需要详细了解文件的结构以及该结构所暗示的关系。如果他们想要修改数据内容，他们还必须维护这种结构。
- en: For any application written in any language to work with the data, it would
    have to handle the intention of the CSV files specifically. In addition, any changes
    in the structure of the CSV files would necessitate changes to the software to
    be aware of those changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何用任何语言编写的应用程序，要处理数据，它必须专门处理CSV文件的目的。此外，CSV文件结构的任何变化都要求软件进行更改，以便意识到这些变化。
- en: Many of our imaginary company’s data shortcomings have to do with explicit management
    of the data and detailed programming to implement how to access and maintain the
    data. One solution to the problem is to move the data to a database system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设的公司数据不足之处很多，都与数据的具体管理和详细的编程实现有关，即如何访问和维护数据。解决这个问题的方法之一是将数据移至数据库系统。
- en: 10.3 Database systems
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 数据库系统
- en: Database systems allow you to persist data as well as the relationships between
    that data. One common type of database is the relational database management system,
    or RDBMS. RDBMS systems provide the functionality to create, read, update, and
    delete tables stored within them. These tables are analogous to the two-dimensional
    tables represented by the CSV files used in the previous example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库系统允许您持久化数据以及这些数据之间的关系。一种常见类型的数据库是关系数据库管理系统，或RDBMS。RDBMS系统提供了创建、读取、更新和删除存储在其内部的表的功能。这些表与之前示例中使用的CSV文件所表示的两维表类似。
- en: RDBMS systems also have the functionality to create and update the relationships
    between tables by connecting unique ID values across table boundaries. One of
    the advantages of a database system over using files to persist information is
    that creating, updating, and maintaining the data is handled by the database,
    not by your application code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS系统还具有通过连接跨越表边界的唯一ID值来创建和更新表之间关系的功能。与使用文件来持久化信息相比，数据库系统的一个优点是创建、更新和维护数据是由数据库而不是您的应用程序代码来处理的。
- en: 10.3.1 Tables
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 表
- en: Tables represent the data that a database maintains. Conceptually, tables in
    a database are two-dimensional collections of rows and columns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表代表数据库维护的数据。从概念上讲，数据库中的表是行和列的两维集合。
- en: Like the CSV files presented previously, the rows are the individual records
    and the columns are the fields within a row. Unlike a CSV file where the columns
    are strings separated by a delimiter, the columns in database tables have defined
    data types. The data types supported depend on the particular database, but data
    types of text, integer, real (decimal numbers), and blob (binary objects) are
    generally supported.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前展示的CSV文件类似，行是单个记录，列是行内的字段。与CSV文件中列由分隔符分隔的字符串不同，数据库表中的列具有定义好的数据类型。支持的数据类型取决于特定的数据库，但文本、整数、实数（十进制数）和blob（二进制对象）的数据类型通常都支持。
- en: Tables in a database can be represented graphically as part of an entity relationship
    diagram, or ERD. Rather than show the rows and columns that make up a table, the
    column and data-type information for a record are shown.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的表可以图形化地表示为实体关系图（ERD）的一部分。而不是显示组成表的行和列，记录的列和数据类型信息被展示出来。
- en: The ERD diagram header is the capitalized table name. The following rows contain
    specific information about each column, like the name of the column and its data
    type. The PK is shorthand for the primary key (the unique identifier for the table)
    and indicates that the `customer_id` is the primary key for the `Customer` table.
    Figure 10.6 shows a visual definition of the `Customer` database table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ERD图标题是大写的表名。以下行包含关于每个列的特定信息，如列名和数据类型。PK是主键（表的唯一标识符）的简称，表示`customer_id`是`Customer`表的主键。图10.6展示了`Customer`数据库表的视觉定义。
- en: '![](../../OEBPS/Images/CH10_F06_Farrell.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F06_Farrell.png)'
- en: Figure 10.6 The ERD diagram for the Customer table showing the field names and
    data types
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 显示字段名称和数据类型的客户表ERD图
- en: The order CSV file contained nothing but unique ID values—one for the row unique
    ID and two others to connect to the customer and address CSV file rows. The new
    FK abbreviation in figure 10.7 is shorthand for foreign key. A foreign key creates
    a relationship between two tables by referencing the primary key of another table.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 订单CSV文件只包含唯一的ID值——一个用于行唯一ID，另外两个用于连接客户和地址CSV文件行。图10.7中的新FK缩写是外键的简称。外键通过引用另一个表的主键来在两个表之间创建关系。
- en: '![](../../OEBPS/Images/CH10_F07_Farrell.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F07_Farrell.png)'
- en: Figure 10.7 The `Order` table contains a primary key and two foreign keys referencing
    other tables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 `Order` 表包含一个主键和两个外键，这些外键引用其他表。
- en: 10.3.2 Relationships
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 关系
- en: As important as storing and modifying data is to any application, the relationships
    between the data are just as important. The updated CSV files for our imaginary
    company enabled you to reduce the data redundancy of the original single CSV file.
    Reducing data redundancy is one important aspect of database normalization.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和修改数据对于任何应用程序来说都至关重要，但数据之间的关系同样重要。我们虚构公司的更新后的CSV文件使您能够减少原始单个CSV文件的数据冗余。减少数据冗余是数据库规范化的重要方面之一。
- en: The separation of distinct data into multiple tables indicates the need to reconnect
    related data. RDBMS systems establish relationships between multiple tables with
    the use of primary and foreign keys.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同的数据分开到多个表中表明需要重新连接相关数据。RDBMS系统使用主键和外键在多个表之间建立关系。
- en: The primary key in a database table is a column in a row (a record) whose value
    is unique across the entire table. It’s often the case that the primary key column
    exists for the sole purpose of providing this unique ID value and contains no
    information about the record itself.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表中的主键是行（记录）中的一个列，其值在整个表中是唯一的。通常，主键列的存在只是为了提供这个唯一的ID值，并且不包含关于记录本身的信息。
- en: It’s not always necessary to create a distinct primary key field. If a column
    of useful data is unique across a table, that column can be the primary key. For
    example, suppose a table containing information about people included their social
    security numbers. In this case, the social security number should be unique for
    every record in the table and could be the primary key.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是需要创建一个独立的主键字段。如果一个有用的数据列在整个表中是唯一的，那么该列可以成为主键。例如，假设有一个包含人员信息的表，其中包含他们的社会保障号码。在这种情况下，社会保障号码应该对表中的每个记录都是唯一的，并且可以成为主键。
- en: Tip Even if a column in a table contains data that’s unique enough to be used
    as the primary key, it’s often easier and more future-proof to create a distinct
    primary key column that’s not dependent on the uniqueness of the data in the table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：即使一个表中的列包含足够独特的数据可以用作主键，但通常创建一个不依赖于表中数据唯一性的独立主键列更容易且更具未来性。
- en: Most RDBMS systems have the functionality to create auto-incrementing integer
    values when new rows are inserted into a table. These make convenient primary
    key values that are assured to be unique across the table as new records are inserted
    into the table and the value increments.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关系型数据库管理系统（RDBMS）系统都有在向表中插入新行时创建自动递增整数值的功能。这些值作为方便的主键值，确保在向表中插入新记录并增加值时在整个表中是唯一的。
- en: UUID primary keys
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UUID主键
- en: Another option to create primary key values is to use UUID (universally unique
    identifier) values. A primary key with a UUID value is not only unique across
    the table but unique across all tables in all databases. Having a universally
    unique primary key can be helpful as the structure and use of the database change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建主键值的另一种选择是使用UUID（通用唯一标识符）值。具有UUID值的键不仅在整个表中是唯一的，而且在所有数据库的所有表中都是唯一的。当数据库的结构和使用方式发生变化时，具有通用唯一主键可能会有所帮助。
- en: As conditions and requirements change over time, database structures are updated
    to meet the needs of those requirements. One example might be merging two tables.
    In this situation, all of the records from both should exist in the merged table,
    and each record still needs a unique primary key.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着条件和要求的变化，数据库结构会更新以满足这些需求。一个例子可能是合并两个表。在这种情况下，两个表的所有记录都应该存在于合并后的表中，并且每个记录仍然需要一个唯一的键。
- en: If both source tables were created with auto-incrementing integer primary key
    values, merging the tables likely creates primary key conflicts. If the primary
    key values are changed to resolve the conflict, any relationships depending on
    a foreign key that points to the original primary key value are broken. A considerable
    amount of effort is necessary to fix this kind of problem.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个源表都是使用自动递增的整数主键值创建的，那么合并表很可能会创建主键冲突。如果更改主键值以解决冲突，那么依赖于指向原始主键值的任何外键关系都将被破坏。解决这个问题需要相当多的努力。
- en: However, if the primary key values are UUID values, then merging the tables
    presents no conflicts because the definition of a UUID value is that it’s unique
    everywhere. Any foreign key that references a UUID primary key still works with
    the merged table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果主键值是UUID值，那么合并表就不会产生冲突，因为UUID值的定义是它在任何地方都是唯一的。任何引用UUID主键的外键仍然与合并表一起工作。
- en: 'Another interesting, perhaps small advantage of using UUID-based primary keys
    is “security through obscurity.” For example, in a web application for our imaginary
    company, they might have a URL like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于UUID的主键的另一个有趣、可能较小的优势是“通过隐蔽性来提高安全性”。例如，在我们的虚构公司的一个网络应用程序中，他们可能有一个这样的URL：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Someone might guess that the last part of that URL is an auto-incrementing primary
    key for a particular order in a database. Therefore, they could change the last
    value in the URL and see every order in the system, which might reveal more information
    than you’d like.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会猜测URL的最后部分是数据库中特定订单的自动递增主键。因此，他们可以更改URL中的最后一个值，查看系统中的每个订单，这可能会揭示比您希望更多的信息。
- en: 'However, if the database used UUID primary key values, the URL might look like
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果数据库使用UUID主键值，URL可能看起来像这样：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the last part of the URL that references a particular order in the orders
    collection is a UUID value with the hyphen (`-`) characters stripped out. Now
    it’s essentially impossible for someone to guess an order primary key value that
    would work. It’s not really a security step, just a side effect of using UUID
    primary keys.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在URL中引用特定订单的最后一部分是一个没有连字符（`-`）的UUID值。现在基本上不可能有人猜测出一个有效的订单主键值。这并不是一个真正的安全步骤，只是使用UUID主键的一个副作用。
- en: Using a UUID as the primary key in database tables does increase the storage
    cost, as UUID values are larger than integers. They might also adversely affect
    the performance of the database in a small way. The cost versus value question
    needs to be considered when deciding whether to use UUID values as primary keys.
    The MyBlog application database uses UUID primary keys, not so much because of
    any requirements for MyBlog functionality but to present the implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库表中使用UUID作为主键会增加存储成本，因为UUID值比整数大。它们也可能以小的方式影响数据库的性能。在决定是否使用UUID值作为主键时，需要考虑成本与价值的问题。MyBlog应用程序数据库使用UUID主键，这不仅是因为MyBlog功能的要求，而是为了展示实现方式。
- en: One-to-many
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多
- en: In our imaginary company, a one-to-many relationship exists between customers
    and orders. To establish a one-to-many relationship, the unique `customer_id`
    value from the customer table is also present as a column of data in the order
    table as `customer_ id`. The `customer_id` value is a foreign key relating to
    the customer table. Any number of order records can have the same `customer_id`
    foreign key value, creating the one-to-many relationship.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的假设公司中，客户和订单之间存在一对多关系。为了建立一对多关系，客户表中的唯一`customer_id`值也作为订单表中的数据列`customer_id`存在。`customer_id`值是关联到客户表的外键。任何数量的订单记录都可以有相同的`customer_id`外键值，从而创建一对多关系。
- en: When creating a foreign key in a table, part of the definition given to the
    database engine is to what table the foreign key relates. The foreign key tells
    the database engine there’s a relationship and helps it provide the functionality
    to use that relationship.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在表中创建外键时，提供给数据库引擎的定义部分是外键关联到哪个表。外键告诉数据库引擎存在关系，并帮助它提供使用该关系的功能。
- en: Many-to-many
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多
- en: Our imaginary company also establishes a many-to-many relationship. Establishing
    a many-to-many relationship is more involved and, in some ways, can be thought
    of as a one-to-many relationship connected to a many-to-one relationship. Creating
    this requires an association table that acts as the many parts between the two
    just mentioned.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设的公司也建立了一种多对多的关系。建立多对多的关系更为复杂，从某些方面来说，可以将其视为一个与多对一关系相连的一对多关系。创建这种关系需要一张关联表，作为上述两个提到的部分之间的多个部分。
- en: The `Item` table creates the association between the `Order` and `Product` tables.
    The `Item` table has a foreign key to the `Order` table `order_id` field and a
    foreign key to the `Product` table `product_id` field.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`表创建了`Order`和`Product`表之间的关联。`Item`表有一个指向`Order`表`order_id`字段的外键，以及一个指向`Product`表`product_id`字段的外键。'
- en: 10.3.3 Transaction database
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 事务数据库
- en: 'The transaction database you’ll create uses a naming convention for the tables
    and the columns within those tables. The tables are named using singular nouns
    for what they contain: customer, product, and so on.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要创建的事务数据库为表和表中的列使用命名约定。表名使用单数名词来表示它们包含的内容：客户、产品等。
- en: The naming convention seems counterintuitive because a table has multiple records,
    and a plural version of the noun might seem more fitting. However, the table is
    defined in terms of one row of data and the data types and meanings of the record’s
    columns. How the table is accessed can return one or more records, but the table
    itself is configured based on a single record.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定似乎不符合直觉，因为一张表有多个记录，名词的复数形式可能看起来更合适。然而，表是根据单行数据定义的，以及记录列的数据类型和含义。如何访问表可以返回一个或多个记录，但表本身是基于单条记录配置的。
- en: Additionally, it can get surprisingly awkward to use plurals when naming tables.
    For example, try to define a person in a database table. The plural version would
    be a table named `people`, with possibly a primary key of `people_id`, which seems
    inelegant. Renaming the primary key to `person_id` works better, but now there
    is a cognitive disconnect between the table name and the primary key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在命名表时使用复数可能会显得非常尴尬。例如，尝试在数据库表中定义一个人。复数形式将是名为 `people` 的表，可能有一个主键 `people_id`，这看起来并不优雅。将主键重命名为
    `person_id` 会更好，但现在表名和主键之间存在认知上的脱节。
- en: The primary key columns are named using a convention of the table name appended
    with `_id`. Although seemingly redundant and wordy as the primary key name, it’s
    apparent that the column with such a name is a foreign key when used in another
    table.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主键列的命名采用表名后缀 `_id` 的约定。尽管作为主键名称似乎冗余且冗长，但很明显，当在另一张表中使用时，具有此类名称的列是外键。
- en: Tip The naming convention used in this example database is by no means the definitive
    one to use. As has been mentioned, naming things is hard, and it’s no different
    with databases. There are many conventions about how to name things in databases,
    and the right one comes down to comfort for you and your team.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例数据库中使用的命名约定绝非唯一可用的 definitive one。正如所提到的，给事物命名是困难的，数据库也不例外。关于如何在数据库中命名事物有许多约定，而正确的选择取决于你和你团队的舒适度。
- en: Figure 10.8 represents the transaction database table’s structure and the relationships
    between them using common database ERD notation and symbols. Notice how the connection
    between tables goes from primary key in one table to foreign key in another.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 使用常见的数据库ERD符号和表示法展示了事务数据库表的结构以及它们之间的关系。注意表之间的连接是如何从一张表的主键到另一张表的外键的。
- en: The connecting lines are all variations of one-to-many relationships. The existence
    of the `Item` table creates the one-to-many and many-to-many relationship between
    the `Order`  `Item`  `Product` tables. Figure 10.8 presents the complete ERD
    diagram for the company database. Creating, updating, and interacting with the
    data in an RDBMS system uses the Structured Query Language (SQL) that most RDBMS
    systems provide.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 连接线都是一对多关系的变体。`Item` 表的存在在 `Order`、`Item` 和 `Product` 表之间创建了一对多和多多关系。图10.8展示了公司数据库的完整ERD图。在RDBMS系统中创建、更新和交互数据使用的是大多数RDBMS系统提供的结构化查询语言（SQL）。
- en: '![](../../OEBPS/Images/CH10_F08_Farrell.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F08_Farrell.png)'
- en: Figure 10.8 The complete ERD for the transaction database of our imaginary company
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 我们想象中的公司事务数据库的完整ERD
- en: '10.3.4 Structured query language: SQL'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 结构化查询语言：SQL
- en: Accessing the functionality of a database is standardized so any programming
    language that has a library available to connect to the database can use it. This
    standardization makes the database much easier to share between applications than
    a proprietary system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数据库的功能是标准化的，因此任何具有连接到数据库库的编程语言都可以使用它。这种标准化使得数据库比专有系统更容易在应用程序之间共享。
- en: Much of the standardized functionality of RDBMS systems is exposed to the user
    by using Structured Query Language, or SQL. SQL interacts with an RDBMS system
    as a declarative programming language. A declarative language lets you express
    what you want a computer system to do and not explicitly instruct the system on
    how to do it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: RDBMS系统的许多标准化功能都是通过使用结构化查询语言（Structured Query Language，简称SQL）向用户暴露的。SQL与RDBMS系统作为声明性编程语言进行交互。声明性语言允许你表达你希望计算机系统做什么，而不是明确指示系统如何去做。
- en: One way to think about this would be to go to a bakery and ask for a cake. You
    expect the baker will hand you a cake, not ask for a recipe to make a cake.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的一种思考方式是去面包店要点蛋糕。你期望面包师会给你蛋糕，而不是要求你提供制作蛋糕的食谱。
- en: Getting data
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据
- en: You’ll be creating the transaction database later in this chapter, but here
    I’ll show some SQL queries to access data. This SQL statement
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章的后面创建事务数据库，但在这里我会展示一些 SQL 查询来访问数据。这个 SQL 语句
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'returns these results:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SQL command keywords are in uppercase, which is just a convention. The statement
    asks the database to return all rows from the customer table. The asterisk (`*`)
    character is a wildcard to get all columns for each row returned. The semicolon
    (`;`) character at the end of the SQL statement is the terminator for the command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 命令关键字是大写的，这只是一个约定。该语句要求数据库返回客户表中的所有行。星号 (`*`) 字符是一个通配符，用于获取每行返回的所有列。SQL
    语句末尾的分号 (`;`) 字符是命令的终止符。
- en: 'This SQL query asks for only the names in the customer database sorted in descending
    alphabetical order:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 查询要求按降序字母顺序排序客户数据库中的名称：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'SQL also provides functions that transform and act on the data. The statement
    below returns the number of customers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 还提供了转换和作用于数据的函数。下面的语句返回了客户数量：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `COUNT` function returns the total number of results produced by the query
    and assigns that value to an alias—'`Total Customers`'—used as the column heading
    for the results output.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`COUNT` 函数返回查询产生的总结果数，并将该值分配给别名—`''Total Customers''`—用作结果输出的列标题。'
- en: Using relationships
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关系
- en: 'Because the tables in the transaction database represent normalized data without
    redundancies, making interesting queries requires using relationships. In this
    SQL statement, the customers, all the addresses used for their orders, and the
    number of times they’ve used an address for an order are returned and sorted alphabetically
    by name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事务数据库中的表代表了没有冗余的规范化数据，所以进行有趣的查询需要使用关系。在这个 SQL 语句中，返回了客户、他们所有用于订单的地址以及他们使用地址进行订单的次数，并按名称字母顺序排序：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the SQL statement spans multiple lines, which works fine as the statement
    isn’t completed until the final termination character (`;`). As before, only some
    values from the tables are returned, but those values span multiple tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，SQL 语句跨越了多行，这没问题，因为语句只有在最后的终止字符（`;`）处才完成。和之前一样，只返回了表中的某些值，但这些值跨越了多个表。
- en: Initially, the query starts at the customer table and assigns it to an alias
    shorthand used in other parts of the query to reduce ambiguity. To get the customer
    address used with each order, the query needs to use the relationships between
    the customer, order, and address tables. Using the `JOIN` keyword achieves this.
    It tells the database how to connect one table to another using the primary key
    from one to the foreign key of another.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，查询从客户表开始，并将其分配给查询其他部分使用的别名简写，以减少歧义。为了获取每个订单使用的客户地址，查询需要使用客户、订单和地址表之间的关系。使用
    `JOIN` 关键字实现这一点。它告诉数据库如何使用一个表的主键连接到另一个表的外键。
- en: The primary key from one table must equal the foreign key of the other for that
    row to be part of the results. The code that follows the `ON` keyword provides
    the condition to be met to include the data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表的主键必须等于另一个表的对应行的外键，这样该行才能成为结果的一部分。跟随 `ON` 关键字的代码提供了包含数据的条件。
- en: Notice the `'order'` table is in single quotes in the first `JOIN` statement.
    The single quotes are necessary because the word order is an SQL keyword; placing
    it in single quotes tells SQL to interpret `'order'` as the table name rather
    than a keyword.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一个 `JOIN` 语句中，`'order'` 表使用了单引号。单引号是必要的，因为单词 order 是一个 SQL 关键字；将其放在单引号中告诉
    SQL 将 `'order'` 解释为表名而不是关键字。
- en: The text `GROUP BY a.street` tells SQL to aggregate the results based on identical
    street values. The results returned indicate this. For example, Joe has two orders
    but used the same address for both. Mary also has two orders but used a different
    address for each one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文本 `GROUP BY a.street` 告诉 SQL 根据相同的街道值聚合结果。返回的结果表明了这一点。例如，Joe 有两个订单但使用了相同的地址。Mary
    也有两个订单但每个订单使用了不同的地址。
- en: 'The SQL used to build invoices for all the orders of our imaginary company
    is written like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们虚构公司所有订单的发票所使用的 SQL 语句如下所示：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And returns these results:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回以下结果：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This SQL query joins all the tables in the transaction database to re-create
    the redundant data for customers, orders, addresses, products, and items.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 SQL 查询将事务数据库中的所有表连接起来，重新创建客户、订单、地址、产品和项目的冗余数据。
- en: 10.4 SQLite as the database
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 SQLite 作为数据库
- en: Before we get to creating and using a database with SQLAlchemy, let’s talk about
    the particular database we’ll use for the transaction database and MyBlog in general.
    In chapter 8, we used SQLite to persist data. For the transaction database and
    the rest of the MyBlog development, we’ll continue to use SQLite.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 SQLAlchemy 创建和使用数据库之前，让我们谈谈我们将用于事务数据库和 MyBlog 的特定数据库。在第 8 章中，我们使用了 SQLite
    来持久化数据。对于事务数据库和 MyBlog 的其余开发，我们将继续使用 SQLite。
- en: The decision to use SQLite was based on a few considerations. The SQLite website
    states that SQLite is likely one of the most widely used database systems globally
    if you look at the numbers and types of systems that use it. It’s also small,
    fast, full-featured, and completely serves the needs of the MyBlog application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLite 的决定基于几个考虑因素。SQLite 网站指出，如果你查看使用 SQLite 的系统和类型数量，SQLite 很可能是在全球范围内使用最广泛的数据库系统之一。它体积小、速度快、功能齐全，完全满足
    MyBlog 应用程序的需求。
- en: The other, and probably more relevant consideration regarding this book, is
    that SQLite runs as an in-process database, which means that it runs as a module
    pulled into the application like any other Python module. There’s no need to install,
    configure, and maintain a database server like MySQL, PostgreSQL, or SQL Server
    to build and learn with the MyBlog development process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个，可能更相关的考虑因素是关于本书的，那就是 SQLite 作为进程内数据库运行，这意味着它像任何其他 Python 模块一样被拉入应用程序中。无需安装、配置和维护像
    MySQL、PostgreSQL 或 SQL Server 这样的数据库服务器，就可以使用 MyBlog 开发过程进行构建和学习。
- en: Tip Database servers like MySQL, PostgreSQL, and SQL Server are powerful, capable
    systems that could easily handle the needs of the MyBlog application. However,
    it would take time and book real estate to help readers get those systems up and
    running.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：数据库服务器如 MySQL、PostgreSQL 和 SQL Server 是功能强大的系统，可以轻松处理 MyBlog 应用程序的需求。然而，帮助读者启动这些系统需要时间和书籍空间。
- en: Lastly, the use of SQLAlchemy helps to abstract away the underlying database
    and lets you focus on development and database concepts rather than a particular
    database implementation. Should your needs with MyBlog outgrow what SQLite can
    do for you, replacing it with another database system is easier because of the
    abstraction that SQLAlchemy provides.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 SQLAlchemy 有助于抽象化底层数据库，让你能够专注于开发和数据库概念，而不是特定的数据库实现。如果你的 MyBlog 需求超过了 SQLite
    可以为你提供的，由于 SQLAlchemy 提供的抽象，替换它为另一个数据库系统会更容易。
- en: 10.5 SQLAlchemy
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 SQLAlchemy
- en: SQLAlchemy is a popular and powerful database access library for Python that
    provides an object-relational mapper (ORM). One of the benefits of working with
    Python is that it’s an object-oriented language, and everything in Python is an
    object. Working with data as Python objects feels more natural and more Pythonic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 是一个流行的、强大的 Python 数据库访问库，它提供了一个对象关系映射器（ORM）。与 Python 一起工作的一个好处是它是一种面向对象的语言，Python
    中的所有内容都是对象。将数据作为 Python 对象处理感觉更自然，也更符合 Python 风格。
- en: Python can access database systems using SQL directly, and this is a viable
    approach. Most Python database libraries that support SQL return lists of tuples
    or dictionaries containing the results of the SQL statement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以直接使用 SQL 访问数据库系统，这是一种可行的方案。大多数支持 SQL 的 Python 数据库库返回包含 SQL 语句结果的元组列表或字典。
- en: The SQL statement illustrating how to get the data to create invoices for orders
    shows the data, but all relationship information is lost. Using this data would
    require software to glean the hierarchal relationships in `Order`  `Item`  `Product`.
    The disconnect between objects and flat data is known as object-relational impedance
    mismatch, and it’s a problem the SQLAlchemy ORM solves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何获取创建订单发票所需数据的 SQL 语句显示了数据，但所有关系信息都丢失了。使用这些数据将需要软件来提取 `Order`  `Item` 
    `Product` 的层次关系。对象和平面数据之间的脱节被称为对象关系阻抗不匹配，这是 SQLAlchemy ORM 解决的问题。
- en: 10.5.1 Benefits
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 优点
- en: Using SQLAlchemy to access a database allows you to think about objects and
    methods rather than SQL and result sets. For the most part, you don’t need to
    know SQL to work with the underlying database. Instead, SQLAlchemy builds the
    necessary SQL statement to map the resulting data to Python objects and vice versa.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 访问数据库允许你考虑对象和方法，而不是 SQL 和结果集。在大多数情况下，你不需要了解 SQL 就可以与底层数据库一起工作。相反，SQLAlchemy
    构建必要的 SQL 语句，将结果数据映射到 Python 对象，反之亦然。
- en: Most RDBMS databases support SQL; however, they often add proprietary functionality
    to their implementation. Aside from specific use cases, SQLAlchemy abstracts these
    differences away and works at a higher level.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关系型数据库管理系统（RDBMS）数据库支持 SQL；然而，它们通常在其实现中添加专有功能。除了特定用例之外，SQLAlchemy 抽象了这些差异，并在更高层次上工作。
- en: Another advantage SQLAlchemy provides is protecting your application from SQL
    injection attacks. For example, if your application adds user-supplied information
    to use with database queries, your application is vulnerable to this kind of attack.
    The XKCD comic in figure 10.9 shows this nicely.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供的另一个优点是保护您的应用程序免受 SQL 注入攻击。例如，如果您的应用程序将用户提供的信息添加到与数据库查询一起使用，则您的应用程序容易受到此类攻击。图
    10.9 中的 XKCD 漫画很好地展示了这一点。
- en: '![](../../OEBPS/Images/CH10_F09_Farrell.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH10_F09_Farrell.png)'
- en: Figure 10.9 Exploits of a Mom (Source: xkcd.com. Licensed under CC BY-NC 2.5)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 妈妈的恶作剧（来源：xkcd.com，许可协议为 CC BY-NC 2.5）
- en: 10.6 Modeling the database
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 建模数据库
- en: Connecting the database to SQLAlchemy requires modeling the table structures
    with Python class definitions. The models map the table record structure, the
    field data types, and the relationships between tables to Python class definitions.
    Instances of these Python classes are created by calling methods on the classes,
    which SQLAlchemy translates to SQL statements.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据库连接到 SQLAlchemy 需要使用 Python 类定义来建模表结构。这些模型将表记录结构、字段数据类型以及表之间的关系映射到 Python
    类定义。通过在类上调用方法创建这些 Python 类的实例，SQLAlchemy 将这些方法调用转换为 SQL 语句。
- en: Because the ultimate goal is to use SQLAlchemy with the MyBlog application,
    we’ll use `Flask` and the `flask_sqlalchemy` modules to help define the classes.
    The `flask_sqlalchemy` module provides convenience features and definitions, but
    the classes defined here could just as easily have been defined with the SQLAlchemy
    module alone.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最终目标是使用 SQLAlchemy 与 MyBlog 应用程序一起使用，所以我们将使用 `Flask` 和 `flask_sqlalchemy`
    模块来帮助定义类。`flask_sqlalchemy` 模块提供了便利功能和定义，但这里定义的类也可以仅使用 SQLAlchemy 模块来定义。
- en: 10.6.1 Defining the classes
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 定义类
- en: The `examples/CH_10/examples/02/main.py` program imports a `models.py` module.
    The `models.py` module contains all of the code to create the database object,
    model the tables, and populate the database with data from the CSV files of `examples/01`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/CH_10/examples/02/main.py` 程序导入了一个 `models.py` 模块。该 `models.py` 模块包含了创建数据库对象、建模表格以及用来自
    `examples/01` 的 CSV 文件中的数据填充数据库的所有代码。'
- en: The database connection
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接
- en: 'All of the classes to be defined inherit from a common SQLAlchemy-provided
    database object. The database object is created in this way prior to defining
    the classes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有要定义的类都继承自 SQLAlchemy 提供的通用数据库对象。在定义类之前以这种方式创建数据库对象：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Creates the Flask instance
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建 Flask 实例
- en: ② Configures SQLAlchemy to use SQLite and where to create the database file
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置 SQLAlchemy 使用 SQLite 并指定创建数据库文件的路径
- en: ③ Turns off an unnecessary default configuration that generates a warning
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 关闭了一个不必要的默认配置，该配置会生成警告
- en: ④ Creates the SQLAlchemy database object, in this case with autoflush turned
    off, which helps make DB operations more atomic at the point of issuing a commit()
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建 SQLAlchemy 数据库对象，在这种情况下，关闭了自动刷新，这有助于在提交()时使数据库操作更原子化
- en: The intent of this code is to create the `db` object instance used to define
    the table models. The database itself is stored in the single `transaction.sqlite`
    file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是创建用于定义表模型的 `db` 对象实例。数据库本身存储在单个 `transaction.sqlite` 文件中。
- en: Modeling the tables
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 建模表格
- en: The transaction database ERD shown previously is a good guide to creating the
    class definitions needed to access the database with SQLAlchemy. The class definitions
    define the database tables to be created, the column names within a record, and
    their data types.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的事务数据库 ERD 是创建用于通过 SQLAlchemy 访问数据库所需的类定义的良好指南。类定义定义了要创建的数据库表、记录内的列名以及它们的数据类型。
- en: 'There are also fields defined that don’t exist in the database but are created
    and maintained by SQLAlchemy when instances of the models are created. These extra
    fields provide useful functionality when working with the model instances, particularly
    for relationships between tables—for example, the `orders` attribute defined next
    in the `Customer` model. SQLAlchemy maintains a Python list of all the orders
    associated with a `Customer` instance. Let’s look at the `Customer` and `Order`
    class definitions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还定义了一些字段，这些字段在数据库中不存在，但由SQLAlchemy在创建模型实例时创建和维护。这些额外字段在处理模型实例时提供了有用的功能，尤其是在处理表之间的关系时——例如，在`Customer`模型中定义的下一个`orders`属性。SQLAlchemy维护了一个与`Customer`实例关联的所有订单的Python列表。让我们看看`Customer`和`Order`类的定义：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Creates the class, inheriting from the db instance Model class
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建类，从db实例Model类继承
- en: ② Associates the class definition with the customer database table
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将类定义与客户数据库表关联
- en: ③ Creates the customer_id column as an integer type and as the primary_key
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建客户_id列，类型为整数，并作为主键
- en: ④ Creates the name column as a string
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建name列作为字符串
- en: ⑤ Creates the attribute orders, connecting a customer to all their orders
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建属性orders，将客户与其所有订单连接起来
- en: ⑥ Creates the class, inheriting from the db instance Model class
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建类，从db实例Model类继承
- en: ⑦ Associates the class definition with the order database table
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将类定义与订单数据库表关联
- en: ⑧ Creates the order_id column as an integer type and as the primary_key
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 创建订单_id列，类型为整数，并作为主键
- en: ⑨ Creates the customer_id as an integer and as the ForeignKey to the customer
    table and customer_id field
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 创建customer_id作为整数，并作为外键指向客户表和customer_id字段
- en: ⑩ Creates the address_id as an integer and as the ForeignKey to the address
    table and address_id field
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 创建address_id作为整数，并作为外键指向地址表和address_id字段
- en: Quite a lot is happening in these class definitions. By inheriting from the
    `db.Model` class, the `Customer` and `Order` classes get SQLAlchemy functionality,
    allowing the classes to interact with the underlying database.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类定义中发生了很多事情。通过从`db.Model`类继承，`Customer`和`Order`类获得了SQLAlchemy功能，允许这些类与底层数据库交互。
- en: The `customer_id` column is defined as an integer and as the primary key. By
    doing this, the `customer_id` field is initialized by an auto-incrementing function
    every time a new `Customer` instance is added to the database. The same happens
    for the `order_id` field in the `Order` class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_id`列被定义为整数并作为主键。通过这样做，每次向数据库添加新的`Customer`实例时，`customer_id`字段都由一个自动递增的函数初始化。对于`Order`类中的`order_id`字段也是如此。'
- en: The `name` column is a simple string that maps to whatever database type best
    supports Python string-type variables. Because SQLite is the underlying database,
    that type is `TEXT`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`列是一个简单的字符串，映射到最佳支持Python字符串类型变量的数据库类型。因为SQLite是底层数据库，所以该类型是`TEXT`。'
- en: The `Customer` class attribute `orders` is interesting and useful. It does not
    define a column in the database customer table at all. Instead, it creates an
    attribute maintained by SQLAlchemy that is available to you as a developer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer`类的属性`orders`很有趣且很有用。它根本不在数据库客户表中定义一个列。相反，它创建了一个由SQLAlchemy维护的属性，该属性作为开发人员可用。'
- en: The `orders` attribute uses the relationship established by the `customer_id`
    foreign key created in the `Order` class. A `Customer` instance has an `orders`
    attribute that is a Python list of the `Order` instances associated with the customer.
    The odd-looking `backref` parameter passed to `db.relationship(...)` creates a
    SQLAlchemy-maintained attribute named `customer` in the `Order` class definition
    that points back to the `Customer` instance to which the order relates. Figure
    10.10 presents a visual representation of this SQLAlchemy-maintained list of orders
    in the customer instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`orders`属性使用`Order`类中创建的`customer_id`外键建立的关系。`Customer`实例有一个`orders`属性，它是与客户关联的`Order`实例的Python列表。看起来奇怪的`backref`参数传递给`db.relationship(...)`在`Order`类定义中创建了一个由SQLAlchemy维护的属性，名为`customer`，它指向与订单相关的`Customer`实例。图10.10展示了在客户实例中SQLAlchemy维护的订单列表的视觉表示。'
- en: '![](../../OEBPS/Images/CH10_F10_Farrell.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH10_F10_Farrell.png)'
- en: Figure 10.10 The one-to-many relationship between a customer and their orders
    is a Python list.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 客户与其订单之间的一对多关系是一个Python列表。
- en: 'The `orders` attribute lets you write Python code like this when you have a
    `Customer` instance:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个`Customer`实例时，`orders`属性允许你编写如下Python代码：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The relationships and the attributes created and maintained by SQLAlchemy are
    very useful when printing out order invoices. The rest of the SQLAlchemy model
    definitions follow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印订单发票时，SQLAlchemy创建和维护的关系和属性非常有用。其余的SQLAlchemy模型定义如下：
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Creates the class, inheriting from the db instance Model class
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建类，从`db`实例`Model`类继承
- en: ② Associates the class with the item database table
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将类与项目数据库表关联
- en: ③ Creates the order_id as an integer and as the ForeignKey to the order table
    and order_id field
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建`order_id`作为整数，并将其作为`order`表和`order_id`字段的`ForeignKey`
- en: ④ Creates the product_id as an integer and as the ForeignKey to the product
    table and product_id field
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建`product_id`作为整数，并将其作为`product`表的`ForeignKey`以及`product_id`字段
- en: ⑤ Creates the qty field to track the quantity of product for this item
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建跟踪此项目产品数量的`qty`字段
- en: ⑥ Creates the instance-only attribute order, connecting an order to this item
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建仅实例属性顺序，将一个订单连接到这个项目
- en: ⑦ Creates the instance-only attribute product, connecting a product to this
    item
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建仅实例属性`product`，将一个产品连接到这个项目
- en: The `Item` class definition creates the many-to-many association relationship
    between an order, the items in that order, and the products related to the items.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`类定义创建了订单、该订单中的项目以及与项目相关产品的多对多关联关系。'
- en: 10.7 Creating and using the database
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 创建和使用数据库
- en: 'Once the SQLAlchemy models are defined, the database can be created. This line
    of Python code creates the database:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了SQLAlchemy模型，就可以创建数据库。以下Python代码行创建数据库：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the `transaction.sqlite` SQLite database file defined earlier doesn’t exist,
    it’s created with table structures defined by the models, and those tables will
    be empty. However, if the `transaction.sqlite` database file does exist, the code
    won’t re-create it; it will just connect to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前定义的`transaction.sqlite` SQLite数据库文件不存在，它将使用模型定义的表结构创建，并且那些表将是空的。然而，如果`transaction.sqlite`数据库文件已经存在，代码将不会重新创建它；它只会连接到它。
- en: It’s essential to recognize that any changes made to the SQLAlchemy models won’t
    appear in the database if the database already exists. You can delete and re-create
    the database, and it will match the updated models, which is fine in this case
    but an unreasonable action most of the time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，如果数据库已经存在，对SQLAlchemy模型所做的任何更改都不会出现在数据库中。您可以删除并重新创建数据库，它将匹配更新的模型，这在这种情况下是可以接受的，但在大多数情况下是不合理的操作。
- en: Tip With an existing database, you’ll need to use SQL statements, or other database
    migration tools, to modify the database to match the updated SQLAlchemy models.
    As a working developer, it’s not common to create a database from scratch. The
    more frequent activity is modifying an existing database to add new features and
    functionality to it. Python tools like Alembic ([https://pypi.org/project/alembic/](https://pypi.org/project/alembic/))
    are useful for this kind of activity with SQLAlchemy.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：对于现有的数据库，您需要使用SQL语句或其他数据库迁移工具来修改数据库以匹配更新的SQLAlchemy模型。作为一名工作开发者，从头创建数据库并不常见。更常见的是修改现有数据库以添加新功能和功能。Python工具如Alembic（[https://pypi.org/project/alembic/](https://pypi.org/project/alembic/））对于此类活动与SQLAlchemy非常有用。
- en: 10.7.1 Adding data
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.1 添加数据
- en: 'Even though creating and populating a database from scratch isn’t an everyday
    activity for a developer, we’ll look at it in the `examples/CH_10/examples/02/models.py`
    to see how SQLAlchemy creates and inserts database table records. The program’s
    goal in `examples/CH_10/examples/02/main.py` is to replicate the behavior of `examples/CH_10/examples/01/main.py`
    but use a database instead of CSV tables. To do so means parsing the CSV files
    and inserting the data into the database using SQLAlchemy. The `models.py` module
    contains the SQLAlchemy models and the statement to create the database. It also
    has a custom function to read the CSV files and load them into the database tables
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从头开始创建和填充数据库对于开发者来说不是日常活动，我们仍将在`examples/CH_10/examples/02/models.py`中查看，以了解SQLAlchemy如何创建和插入数据库表记录。`examples/CH_10/examples/02/main.py`中的程序目标是复制`examples/CH_10/examples/01/main.py`的行为，但使用数据库而不是CSV表。这样做意味着解析CSV文件并使用SQLAlchemy将数据插入数据库。`models.py`模块包含SQLAlchemy模型和创建数据库的语句。它还有一个自定义函数，用于读取CSV文件并将它们加载到数据库表中，如下所示：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Loads all of the CSV files into variables that are rows of dictionaries
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将所有CSV文件加载到变量中，这些变量是字典的行
- en: ② Uses a context manager to control when the objects are committed (or not)
    to the database
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用上下文管理器来控制对象何时（或不）提交到数据库
- en: ③ Creates Customer instances and adds them to the database session
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建客户实例并将它们添加到数据库会话中
- en: ④ Creates Address instances and adds them to the database session
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建地址实例并将它们添加到数据库会话中
- en: ⑤ Creates Product instances and adds them to the database session
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建产品实例并将它们添加到数据库会话中
- en: ⑥ Commits the session to the database, assigning unique IDs to all the objects
    in that session and persisting them in the database
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 将会话提交到数据库，为该会话中的所有对象分配唯一的 ID 并将它们持久化到数据库中
- en: ⑦ Creates an orders map to help connect orders, items, customers, and products
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建一个订单映射以帮助连接订单、项目、客户和产品
- en: ⑧ Iterates over the items
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 遍历项目
- en: ⑨ Finds the order to which the current item is related
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 找到与当前项目相关的订单
- en: ⑩ Finds the customer to which the found order is related. The second statement
    is an SQLAlchemy query to get the customer instance
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 找到与找到的订单相关的客户。第二个语句是一个 SQLAlchemy 查询，用于获取客户实例
- en: ⑪ Finds the address to which the found order is related. The second statement
    is an SQLAlchemy query to get the address instance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 找到与找到的订单相关的地址。第二个语句是一个 SQLAlchemy 查询，用于获取地址实例。
- en: ⑫ Assigns the customer and address to the order only if they don’t already exist
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 仅当客户和地址不存在时，才将客户和地址分配给订单
- en: ⑬ Finds the product instance to relate to the item, assigns it to the item,
    and then appends the item to the order
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 找到与项目相关联的产品实例，将其分配给项目，然后将项目追加到订单中
- en: ⑭ Adds all the initialized orders to the session and commits the session to
    the database, persisting the orders and items
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 将所有初始化的订单添加到会话中，并将会话提交到数据库，以持久化订单和项目
- en: There is quite a lot happening in this code. The gist is to read the CSV files
    and use the data to create instances of the corresponding SQLAlchemy models. Then
    use the SQLAlchemy-maintained attributes to develop the relationships between
    the instances.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中发生了很多事情。核心是读取 CSV 文件并使用数据来创建相应的 SQLAlchemy 模型的实例。然后使用 SQLAlchemy 维护的属性来开发实例之间的关系。
- en: Creating the `customer`, `address`, and `product` instances and then persisting
    them to the database with the `session.commit()` statement generates the unique
    ID primary key value for each record. The primary key values are used later to
    establish relationships when creating the orders and their associated items.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `customer`、`address` 和 `product` 实例，然后使用 `session.commit()` 语句将它们持久化到数据库中，为每条记录生成唯一的
    ID 主键值。这些主键值在创建订单及其相关项目时用于建立关系。
- en: 10.7.2 Using the data
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7.2 使用数据
- en: 'The `examples/CH_10/examples/02/main.py` program demonstrates using the `transaction.sqlite`
    database to generate the invoice PDF files for all the orders:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/CH_10/examples/02/main.py` 程序演示了使用 `transaction.sqlite` 数据库为所有订单生成发票
    PDF 文件：'
- en: '[PRE15]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Imports functionality from the models.py module. Notice that only the SQLAlchemy
    Order definition is used.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 models.py 模块导入功能。注意，只使用了 SQLAlchemy 的 Order 定义。
- en: ② Passes a single Order instance to the create_invoice function
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将单个订单实例传递给 create_invoice 函数
- en: ③ Passes the single order instance to the Jinja template as the context parameter
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将单个订单实例传递给 Jinja 模板作为上下文参数
- en: ④ Calls the load_database function defined in the models.py module to populate
    the database
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 调用 models.py 模块中定义的 load_database 函数以填充数据库
- en: ⑤ With a database session, queries the database for all orders, iterates over
    them, and passes the single instances to the create_invoice function
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库会话，查询数据库中的所有订单，遍历它们，并将单个实例传递给 create_invoice 函数
- en: 'The bulk of this program creates the invoice PDF files from the single SQLAlchemy
    `Order` instance passed to it. Because of the relationships established by the
    models, everything necessary to print an invoice is connected to the `Order` instance.
    The Jinja template uses the order context parameter to fill in the dynamic parts
    of the template:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的大部分工作是从传递给它的单个 SQLAlchemy `Order` 实例创建发票 PDF 文件。由于模型中建立的关系，打印发票所需的一切都与 `Order`
    实例相关联。Jinja 模板使用订单上下文参数来填充模板的动态部分：
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Uses the order instance customer attribute to get the customer’s name
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用订单实例的客户属性来获取客户的名字
- en: ② Uses the order instance address attribute to get the address to which the
    order was shipped
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用订单实例的地址属性来获取订单发货的地址
- en: ③ Prints out the order’s unique ID value
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印出订单的唯一 ID 值
- en: ④ Uses the order instance items collection to print out the item information
    in a table
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用订单实例的项目集合以表格形式打印出项目信息
- en: Creating models for the tables with one-to-many relationships between the tables,
    SQLAlchemy provides attributes to access the data hierarchically rather than in
    a flat, two-dimensional way. The models, and the object instances created from
    them, allow you to consider the data in Pythonic terms rather than manage relationships
    yourself and jump from list to dictionary and back.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '对于具有表之间一对一关系的表创建模型，SQLAlchemy 提供了以分层方式访问数据而不是以扁平、二维方式访问数据的属性。这些模型以及从它们创建的对象实例允许你以
    Pythonic 的方式考虑数据，而不是自己管理关系，并在列表和字典之间跳转。 '
- en: Our imaginary company and its simple data requirements allowed us to see how
    databases can greatly enhance merely persisting data. By adding relationships
    to the data structure, the storage of interrelated data is greatly simplified
    and functionality is improved.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设的公司及其简单的数据需求使我们能够看到数据库如何极大地增强仅仅持续数据的能力。通过向数据结构添加关系，相关数据的存储大大简化，功能也得到了提升。
- en: 10.8 Closing thoughts
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.8 总结性思考
- en: You’ve taken a microscopic view of database systems to gain knowledge about
    what they do, how they do it, and why they’re useful. Database systems give you
    access to powerful functionality and using SQLAlchemy to interact with those systems
    lets you think about them in Pythonic terms. In addition, using tools like SQLAlchemy
    helps you stay in the single Python domain rather than make mental context switches
    between SQL and Python domains. It’s certainly possible to work in the latter,
    but it’s more productive to work in the former.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从微观的角度了解了数据库系统，以了解它们的功能、工作方式以及为什么它们是有用的。数据库系统为你提供了访问强大功能的方法，而使用 SQLAlchemy
    与这些系统交互让你能够以 Pythonic 的方式思考。此外，使用像 SQLAlchemy 这样的工具可以帮助你保持在单个 Python 领域内，而不是在
    SQL 和 Python 领域之间进行心理上下文切换。当然，在后者中工作也是可能的，但前者更有效率。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Persisting data over time usually means saving it to a long-term storage device,
    like the hard- or solid-state drive system attached to a computer. Files provide
    a simple solution but present some disadvantages.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移持续数据通常意味着将其保存到长期存储设备中，例如连接到计算机的硬盘或固态驱动器系统。文件提供了一个简单的解决方案，但存在一些缺点。
- en: Database systems give applications a way to persist data in a structured way
    and establish relationships between that data. Relational database management
    systems (RDBMS) are applications that provide storage for structured, related
    data.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库系统为应用程序提供了一种以结构化方式持续数据并建立数据之间关系的方法。关系数据库管理系统（RDBMS）是提供结构化、相关数据存储的应用程序。
- en: Data storage is important to any application, but the relationships between
    data groups are equally important. The support for one-to-many and many-to-many
    relationships (among others) dramatically increases the utility of modern database
    systems.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储对任何应用程序都很重要，但数据组之间的关系同样重要。对一对一和多对多关系（以及其他关系）的支持极大地提高了现代数据库系统的实用性。
- en: The Python SQLAlchemy module bridges the gap between the tables with rows of
    data in a database system to a more object-oriented access method in a Python
    application.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python SQLAlchemy 模块在数据库系统中具有行数据的表与 Python 应用程序中更面向对象访问方法之间架起了一座桥梁。
