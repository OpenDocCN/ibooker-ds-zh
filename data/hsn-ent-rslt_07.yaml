- en: Chapter 7\. Clustering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章\. 聚类
- en: 'So far, we have considered the resolution of entities between two independent
    data sources: a smaller primary dataset that defines a target population to be
    matched and a much larger secondary dataset. We have also assumed that the entities
    in the primary dataset are present only once and there are no duplicates. Therefore,
    we have not sought to compare the entities in the primary dataset with each other.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑了两个独立数据源之间的实体解析：一个定义了要匹配的目标人群的较小的主数据集和一个规模更大的次要数据集。我们还假设主数据集中的实体仅出现一次，并且没有重复项。因此，我们没有试图将主数据集中的实体与彼此进行比较。
- en: For example, in [Chapter 5](ch05.html#chapter_5), we resolved UK MPs, as listed
    in Wikipedia, against PSCs of UK companies according to Companies House. We assumed
    that each MP would be present only once in the Wikipedia list but that they could
    have significant control over more than one company, i.e., a single Wikipedia
    entity could match against multiple PSC entities. For instance, the MP named in
    Wikipedia as Geoffrey Clifton-Brown is likely to be the same individual as the
    person with the same name listed as having significant control over the company
    with reference number 09199367\. The same applies to the companies with references
    02303726 and 13420433.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第五章](ch05.html#chapter_5)中，我们根据公司注册处的记录解析了维基百科上列出的英国议员与英国公司的实际控制人。我们假设每位议员在维基百科列表中只出现一次，但他们可能对多家公司具有重大控制权，即，单个维基百科实体可以与多个实际控制人实体匹配。例如，维基百科上名为
    Geoffrey Clifton-Brown 的议员很可能与控制公司的同名人士相同，其参考编号为 09199367。对参考编号为 02303726 和 13420433
    的公司也同样适用。
- en: We can represent these entity relationships as a simple network with the similarly
    named individuals represented as *nodes* and the three pairwise comparisons between
    them represented as *edges*, as shown in [Figure 7-1](#fig-7-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些实体关系表示为一个简单的网络，其中类似命名的个人表示为 *节点*，它们之间的三对比较表示为 *边*，如[图 7-1](#fig-7-1)所示。
- en: Note that we didn’t evaluate the pairwise equivalence of the three named individuals
    in the PSC data with each other—we were seeking only to identify links to the
    primary Wikipedia entity. But in the process we have, by association, concluded
    that all three PSC entries are likely to refer to the same single real-world individual.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有评估 PSC 数据中的三个具名个体之间的成对等价性——我们只是试图识别与主要维基百科实体的链接。但在此过程中，我们通过关联得出结论，所有三个
    PSC 条目很可能指的是同一个现实世界的个体。
- en: '![](assets/hoer_0701.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0701.png)'
- en: Figure 7-1\. Simple person match cluster
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. 简单的个人匹配聚类
- en: In practice we are often faced with multiple data sources to resolve, as well
    as potential duplication within a single source. To produce a resolved view of
    an entity, we need to gather together all the pair-matched records, grouping them
    under a single uniquely identifiable reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们经常面临着多个需要解析的数据源，以及单个源中的潜在重复项。为了生成一个实体的解析视图，我们需要收集所有成对匹配的记录，并将它们分组到一个单一的可唯一标识的参考下。
- en: This process of assembling a collection of examples is called *clustering*.
    The clustering process doesn’t attempt to determine which example (if any) is
    correct but simply to identify the collection as a discrete bounded set whose
    members all have similar characteristics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个收集示例的过程称为 *聚类*。聚类过程不试图确定哪个示例（如果有的话）是正确的，而只是识别该集合作为一个离散的有界集合，其成员都具有相似的特征。
- en: In this chapter, we will examine how to employ basic clustering techniques to
    group entities together based on pairwise comparisons. We will reuse the PSC dataset
    we acquired in [Chapter 5](ch05.html#chapter_5), but first, let’s shrink the problem
    to a small scale so that we can understand the steps we need to take.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用基本的聚类技术根据成对比较将实体分组在一起。我们将重用我们在[第五章](ch05.html#chapter_5)中获得的实际控制人数据集，但首先，让我们将问题缩小到一个小规模，以便我们可以理解需要采取的步骤。
- en: Simple Exact Match Clustering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的精确匹配聚类
- en: First, let’s consider a simple dataset of first names, last names, and year
    of birth, as shown in [Table 7-1](#table-7-1). This table contains an exact duplicate
    (IDs 0 and 1) along with several other similar records.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个简单的数据集，其中包含名、姓和出生年份，如[表 7-1](#table-7-1)所示。该表包含一个精确重复（ID 0 和 1）以及其他几个相似的记录。
- en: Table 7-1\. Simple clustering example dataset
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. 简单聚类示例数据集
- en: '| **ID** | **First name** | **Last name** | **Year of birth** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **名** | **姓** | **出生年份** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | Michael | Shearer | 1970 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | Michael | Shearer | 1970 |'
- en: '| 1 | Michael | Shearer | 1970 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Michael | Shearer | 1970 |'
- en: '| 2 | Mike | Shearer | 1970 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Mike | Shearer | 1970 |'
- en: '| 3 | Michael | Shearer | 1971 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Michael | Shearer | 1971 |'
- en: '| 4 | Michelle | Shearer | 1971 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Michelle | Shearer | 1971 |'
- en: '| 5 | Mike | Sheare | 1971 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Mike | Sheare | 1971 |'
- en: Does each ID represent a separate entity or do they refer to the same person?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ID是否代表一个单独的实体，还是它们指的是同一个人？
- en: Based on the limited information we have, we can, for example, group by exact
    equivalence of first name and last name but not year of birth.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们拥有的有限信息，我们可以例如按照名字和姓氏的精确等价性进行分组，但不包括出生年份。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us four clusters. The entities associated with IDs 0, 1, and 3 are
    grouped together in cluster 0 as they have the exact same name spellings, whereas
    IDs 2, 4, and 5 have a unique spelling variation and are therefore assigned their
    own individual cluster, as we can see in [Figure 7-2](#fig-7-2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们得到了四个群集。与ID 0、1和3关联的实体被分组在群集0中，因为它们具有完全相同的名称拼写，而ID 2、4和5具有唯一的拼写变体，因此分配了它们自己的个体群集，正如我们在[图7-2](#fig-7-2)中所见。
- en: '![](assets/hoer_0702.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0702.png)'
- en: Figure 7-2\. Simple exact match cluster table
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. 简单精确匹配群集表格
- en: Approximate Match Clustering
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似匹配聚类
- en: Now let’s consider what happens to our cluster groupings if we include approximate
    name matching, as introduced in [Chapter 3](ch03.html#chapter_3). We can no longer
    use a simple `groupby` function to calculate our clusters, so we need to work
    through the comparison steps ourselves. This is a helpful exercise to illustrate
    the combined challenge that comes with comparing records within, and across, large
    datasets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如果我们包括近似名称匹配会发生什么，就像在[第三章](ch03.html#chapter_3)介绍的那样。我们不能再简单地使用`groupby`函数来计算我们的群集，因此我们需要逐步完成比较步骤。这是一个有用的练习，用来说明在大数据集内部和跨数据集之间比较记录所面临的综合挑战。
- en: 'Our first step is to generate a table with all the potential combinations of
    record comparisons. We want to compare the record ID 0 with each of the other
    records and then the record ID 1 with the remainder, but without duplicating the
    comparison with ID 0 again (directionality isn’t important in pairwise comparisons).
    In total we have 15 comparisons: 5 for ID 0 against its peers, 4 for ID 1, and
    so on.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是生成一个表格，其中包含所有可能的记录比较组合。我们希望将记录ID 0与每个其他记录进行比较，然后将记录ID 1与剩余记录进行比较，但不再重复与ID
    0的比较（在成对比较中方向并不重要）。总共我们有15次比较：ID 0对其同行有5次，ID 1对其同行有4次，依此类推。
- en: 'From our simple base table we can use the itertools package we introduced in
    [Chapter 3](ch03.html#chapter_3) to generate a DataFrame with composite columns
    A and B, each containing a list of the attributes to be compared drawn from our
    simple table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的简单基础表格开始，我们可以使用我们在[第三章](ch03.html#chapter_3)介绍的itertools包生成一个DataFrame，其中包含复合列A和B，每个列包含从我们的简单表格中提取的要比较的属性列表：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Figure 7-3](#fig-7-3) shows the first few rows of the DataFrame.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-3](#fig-7-3)展示了DataFrame的前几行。'
- en: '![](assets/hoer_0703.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0703.png)'
- en: Figure 7-3\. Sample rows of composite match combinations
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3\. 复合匹配组合的示例行
- en: 'Next, we need to create the multilevel index columns to hold the individual
    attribute values under the A and B headings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建多级索引列，以保存A和B标题下的各个属性值：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can split out the attributes and recombine the resulting columns, with
    their associated index labels, back to a single DataFrame:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以分离属性并重新组合生成的列及其相关索引标签，形成单个DataFrame：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first few expanded rows are shown in [Figure 7-4](#fig-7-4).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首几行展开如[图7-4](#fig-7-4)所示。
- en: '![](assets/hoer_0704.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0704.png)'
- en: Figure 7-4\. Sample rows of approximate match combinations
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4\. 近似匹配组合的示例行
- en: 'Now that we have our attributes prepared for pairwise evaluation, we can use
    the Jaro-Winkler similarity function introduced in [Chapter 3](ch03.html#chapter_3)
    to approximately compare the first names and last names between the A and B values.
    If both match, say with an equivalence score greater than 0.9, then we declare
    an overall match:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行成对评估的属性，我们可以使用在[第三章](ch03.html#chapter_3)介绍的Jaro-Winkler相似度函数大致比较A和B值之间的名字和姓氏。如果两者匹配，比如等价分数大于0.9，那么我们声明它们整体匹配：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting matches are listed in [Figure 7-5](#fig-7-5). We can see that
    record ID 0 matches exactly with ID 1 and ID 3 on rows 0 and 2, respectively.
    A match is also declared on row 3 between ID 0 and ID 4 as there is sufficient
    similarity between “Michael” and “Michelle.” Note that rows 6, 7, and 12 also
    record direct matches between the remaining combinations of IDs 1, 3, and 4 independent
    of ID 0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果匹配列在[图7-5](#fig-7-5)中。我们可以看到记录ID 0在行0和2中与ID 1和ID 3完全匹配。在行3中，ID 0和ID 4之间也宣布了一次匹配，因为“Michael”和“Michelle”之间有足够的相似性。请注意，行6、7和12还记录了ID
    0以外的ID 1、3和4之间的直接匹配。
- en: ID 2 also matches to ID 5 on row 11 with “Shearer” and “Sheare” being sufficiently
    similar.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ID 2也在行11中与ID 5匹配，“Shearer”和“Sheare”足够相似。
- en: '![](assets/hoer_0705.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0705.png)'
- en: Figure 7-5\. Approximate match table
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-5。近似匹配表
- en: From these results we can manually identify two clusters, the first comprising
    IDs 0, 1, 3, and 4 and the second IDs 2 and 5.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些结果，我们可以手动识别两个聚类，第一个包括ID 0、1、3和4，第二个包括ID 2和5。
- en: However, we are now faced with a problem. We have allowed nonexact matches to
    cluster as a single entity. What attribute values should we now use to describe
    that resolved entity? For the first cluster, comprising IDs 0, 1, 3, and 4, should
    the first name be “Michael” or “Michelle”? IDs 0, 1, and 3 have the first name
    as “Michael” but ID 4 has it listed as “Michelle.” Is the correct year of birth
    1970 or 1971?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们现在面临一个问题。我们允许非精确匹配作为单一实体进行聚类。现在我们应该使用哪些属性值来描述这个解决的实体？对于第一个聚类，包括ID 0、1、3和4，名字应该是“Michael”还是“Michelle”？ID
    0、1和3的名字是“Michael”，但ID 4的名字是“Michelle”。正确的出生年份是1970还是1971？
- en: For the second cluster, we face the same year of birth dilemma and the question
    of whether we should use “Sheare” or “Shearer”—it’s not clear. This challenge,
    of selecting the most representative values, sometimes known as *canonicalization*,
    is a field of active study but beyond the scope of this book.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个聚类，我们面临相同的出生年份困境，以及是否应该使用“Sheare”还是“Shearer”的问题——这一点不太清楚。选择最具代表性值的挑战，有时被称为*规范化*，是一个积极研究的领域，但超出了本书的范围。
- en: Even with this simple example we can see a number of challenges and trade-offs
    we need to consider when clustering entities together. First, the number of pairwise
    comparisons grows very rapidly with number of records to be clustered. For a table
    of n rows there are n × (n–1)/2 combinations. If approximate matches are included,
    the resulting computational burden is significant and may be time-consuming to
    compute. Second, and most challenging, is how to settle on a single set of attributes
    to define a cluster when individual entities within the cluster have differing
    attribute values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，我们也可以看到在将实体聚类在一起时需要考虑的许多挑战和权衡。首先，随着要进行聚类的记录数量增加，成对比较的数量增长非常迅速。对于一个n行的表格，有n
    × (n–1)/2种组合。如果包括近似匹配，那么产生的计算负担是显著的，可能需要大量时间来计算。其次，最具挑战性的是，在聚类中的个体实体具有不同的属性值时，如何确定一个单一的属性集来定义一个聚类。
- en: Now that we have introduced some of the challenges associated with clustering,
    let’s return to the PSC dataset to consider a larger-scale example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些与聚类相关的挑战，让我们回到PSC数据集，考虑一个更大规模的例子。
- en: Sample Problem
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样本问题
- en: Returning to our example from [Chapter 5](ch05.html#chapter_5), let’s imagine
    we wish to examine the concentration of control over UK companies, identifying
    individuals with influence over several companies. To do this, we need to cluster
    all the matching individual owner entities in the PSC dataset. Further, knowing
    the variable data quality of PSC entries, let’s consider that we want to incorporate
    approximate matches in our calculations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在[第5章](ch05.html#chapter_5)中的例子，假设我们希望研究对英国公司的控制集中度，识别对几家公司有影响力的个人。为此，我们需要对PSC数据集中的所有匹配个人所有者实体进行聚类。此外，考虑到PSC条目的数据质量不一，我们要考虑将近似匹配纳入我们的计算中。
- en: With approximately 11.5 million entries in our PSC dataset, the total number
    of comparisons we need to make is over 66 trillion. We have our work cut out here!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的PSC数据集中约有1150万条记录，我们需要进行的总比较次数超过66万亿次。我们有大量工作要做！
- en: Data Acquisition
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据采集
- en: 'Let’s start by picking up the raw data we downloaded in [Chapter 5](ch05.html#chapter_5).
    We’ll use a wider range of attributes for matching in this chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们在[第5章](ch05.html#chapter_5)中下载的原始数据开始。在本章中，我们将使用更广泛的属性范围进行匹配：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Data Standardization
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据标准化
- en: 'Now that we have our raw data, our next step is to standardize and, for simplicity,
    rename the attributes. We also drop any records where the year or month of birth
    is missing because we’ll use these as blocking values to help reduce the number
    of comparisons we need to make:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了原始数据，下一步是标准化，并为简单起见重命名属性。我们还会删除任何缺少出生年份或月份的记录，因为我们将使用这些作为阻塞值来帮助减少我们需要进行的比较数量：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Record Blocking and Attribute Comparison
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录阻塞和属性比较
- en: As before, we use the Splink framework to perform the comparisons, with exact
    equivalence on year, month, and last name as prediction blocking rules, i.e.,
    we only compare records against each other if there are exact matches between
    the year, month, and last name fields. Clearly, this is a trade-off as we will
    potentially miss some matches with last name inconsistencies or spelling mistakes,
    for example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们使用 Splink 框架执行比较，对年、月和姓氏的精确等价性作为预测阻塞规则，即仅当年、月和姓氏字段之间存在精确匹配时才将记录与其他记录进行比较。显然，这是一种权衡，因为我们可能会错过一些具有姓氏不一致或拼写错误的匹配，例如。
- en: Note that for this single source example we set the `link_type` to `dedupe_only`
    instead of `link_only`. Splink supports `dedupe_only`, `link_only`, and `link_and_dedupe`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这个单一来源示例，我们将 `link_type` 设置为 `dedupe_only` 而不是 `link_only`。Splink 支持 `dedupe_only`、`link_only`
    和 `link_and_dedupe`。
- en: 'We also specify a convergence tolerance for the EM algorithm and set a maximum
    number of iterations to run (even if convergence has not been reached):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为 EM 算法指定了收敛容差，并设置了最大迭代次数（即使尚未达到收敛）：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Data Analysis
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据分析
- en: 'As before, it’s useful to have a look at the data distribution of our comparison
    attributes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，查看我们比较属性的数据分布是很有用的：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see in [Figure 7-6](#fig-7-6), we have the expected distribution of
    first, middle, and last names. In [Figure 7-7](#fig-7-7), we can also see that
    the distribution of title and nationality is skewed toward a small number of common
    values. [Figure 7-8](#fig-7-8) shows month of birth is fairly evenly distributed
    across the year, whereas year of birth is somewhat skewed toward the 1980s.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[图7-6](#fig-7-6)中看到的，我们有着预期的名、中间名和姓的分布。在[图7-7](#fig-7-7)中，我们还可以看到头衔和国籍的分布偏向于少数常见值。[图7-8](#fig-7-8)显示，出生月份在一年中分布相对均匀，而出生年份在某种程度上偏向于1980年代。
- en: '![](assets/hoer_0706.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0706.png)'
- en: Figure 7-6\. First name, middle name, and last name distribution
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 名字、中间名和姓氏分布
- en: '![](assets/hoer_0707.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0707.png)'
- en: Figure 7-7\. Title and nationality distribution
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7\. 头衔和国籍分布
- en: '![](assets/hoer_0708.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0708.png)'
- en: Figure 7-8\. Year and month of birth distribution
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. 出生年月分布
- en: Expectation-Maximization Blocking Rules
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望最大化阻塞规则
- en: Given the very high number of potential combinations, we need to specify the 
    blocking rules for the EM algorithm as tightly as we can to allow the process
    to complete in a reasonable timeframe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于潜在组合数量非常之高，我们需要尽可能严格地指定 EM 算法的阻塞规则，以便使流程能够在合理的时间内完成。
- en: 'We can test the volume of comparisons that a given blocking rule will generate
    using the `count_num_comparisons_from_blocking` function; for example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `count_num_comparisons_from_blocking` 函数测试给定阻塞规则将生成的比较数量；例如：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that every attribute comparison level must pass the blocking rules
    (i.e., not be blocked) in at least one of the estimate parameter steps so that
    *m* and *u* values can be generated for that attribute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个属性比较级别必须通过阻塞规则（即不被阻塞）中的至少一个估计参数步骤，以便为该属性生成 *m* 和 *u* 值。
- en: The count of comparisons that would be generated for several combinations of
    attribute blocking rules is given in [Table 7-2](#table-7-2).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了几种属性阻塞规则组合的比较计数，在[表7-2](#table-7-2)中。
- en: Table 7-2\. Blocking rule comparison count
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2\. 阻塞规则比较计数
- en: '| Pair | Attribute combination blocking rule | Count of comparisons |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 对 | 属性组合阻塞规则 | 比较计数 |'
- en: '| --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `l.Lastname = r.Lastname and` `l.Month = r.Month and`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 | `l.Lastname = r.Lastname and` `l.Month = r.Month and`'
- en: '`l.Title = r.Title and`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Title = r.Title and`'
- en: '`l.Nationality = r.Nationality` | 777.4M |'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Nationality = r.Nationality` | 7774 万 |'
- en: '| `l.Firstname = r.Firstname and` `l.Year = r.Year and`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| `l.Firstname = r.Firstname and` `l.Year = r.Year and`'
- en: '`l.Middlename = r.Middlename` | 69.7M |'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Middlename = r.Middlename` | 6970 万 |'
- en: '| 2 | `l.Lastname = r.Lastname and` `l.Middlename = r.Middlename` | 119.9M
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `l.Lastname = r.Lastname and` `l.Middlename = r.Middlename` | 1199 万
    |'
- en: '| `l.Firstname = r.Firstname and` `l.Month = r.Month and`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| `l.Firstname = r.Firstname and` `l.Month = r.Month and`'
- en: '`l.Year = r.Year and`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Year = r.Year and`'
- en: '`l.Title = r.Title and`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Title = r.Title and`'
- en: '`l.Nationality = r.Nationality` | 281M |'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`l.Nationality = r.Nationality` | 281M |'
- en: We can see that the first pair of blocking rules requires evaluation of a large
    number of comparisons, whereas the second pair allows estimation of parameters
    for all the attributes but with a smaller overall comparison count.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，第一对阻塞规则需要评估大量的比较，而第二对规则允许对所有属性进行参数估计，但整体比较次数较少。
- en: First name, middle name, and last name equivalences are the most discriminating
    in reducing the comparison volumes, followed by year of birth and to a lesser
    extent month of birth. Nationality and title are not particularly helpful due
    to limited cardinality of their values, as we saw in [Figure 7-6](#fig-7-6).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 名字、中间名和姓氏等价是减少比较量最具歧视性的因素，其次是出生年份，月份的影响较小。由于国籍和头衔值的基数有限，它们并不特别有帮助，正如我们在[图7-6](#fig-7-6)中看到的那样。
- en: 'We can employ these blocking rules as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用这些阻塞规则：  '
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Computation Time
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算时间
- en: Even with these more optimized blocking rules, the execution of the expectation-maximization
    algorithm on a large dataset may take some time, especially if you’re running
    on a modest machine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 即使采用了这些更优化的阻塞规则，在大数据集上执行期望最大化算法可能需要一些时间，特别是如果在性能适中的机器上运行的话。
- en: 'Alternatively, if you want to skip the training step you can simply load the
    pretrained model using:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想跳过训练步骤，可以简单地加载预训练模型：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Match Classification and Clustering
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配分类与聚类
- en: 'Once the EM step (see [Chapter 4](ch04.html#chapter_4)) is completed, we have
    a trained model to assess the similarity between the record pairs in our single
    dataset. Remember that these pairs are selected using the prediction blocking
    rules (in this case, exact last name, year, and month of birth). The threshold
    for predicting a match is set at 0.9:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 EM 步骤（见[第四章](ch04.html#chapter_4)）后，我们就有了一个训练好的模型，用于评估我们单一数据集中记录对的相似性。请记住，这些对是通过预测阻塞规则选择的（在本例中是确切的姓氏、出生年份和月份）。预测匹配的阈值设置为0.9：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Following pairwise prediction, Splink offers a clustering function to group
    entity pairs together when the match probability to a shared entity exceeds a
    specified threshold. Note that the clustering threshold is applied to the full
    set of pairwise combinations, not the subset that exceeds the 0.9 prediction threshold;
    i.e., records that fell below the equivalence threshold in all their comparisons,
    and thus were not paired at all, will still be present in the output, assigned
    to their own cluster:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行成对预测之后，Splink 提供了一个聚类函数，用于在匹配概率超过指定阈值的共享实体对中将它们分组在一起。请注意，聚类阈值应用于完整的成对组合集合，而不是超过0.9预测阈值的子集；即，所有比较中都未达到等价阈值的记录仍将出现在输出中，被分配到它们自己的群集中。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The resulting dataset of records, labeled with their parent cluster, can easily
    be converted to a DataFrame, the first few rows of which (sanitized to remove
    names and year and month of birth) are shown in [Figure 7-9](#fig-7-9).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的结果数据集，标记有其父类群，可以轻松转换为 DataFrame，其中的前几行（经过消除姓名和出生年月信息后）显示在[图7-9](#fig-7-9)中。
- en: '![](assets/hoer_0709.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0709.png)'
- en: Figure 7-9\. Sample rows
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-9\. 示例行
- en: 'We can then group these rows by `cluster_id`, retaining all the different attribute
    values from each source record in a list under the associated column. In our case,
    no variation is expected on last name, month, or year of birth as we generated
    our predictions using exact equivalence of these attributes as our blocking rules.
    This gives us approximately 6.8 million unique clusters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以根据 `cluster_id` 将这些行分组，保留来自每个源记录的所有不同属性值列表。在我们的情况下，预测使用这些属性的确切等价作为我们的阻塞规则，我们不希望在姓氏、月份或年份上有任何变化。这给我们带来了大约680万个唯一的群集：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To illustrate the attribute variation we see within a cluster, we can select
    a subset of clusters where we have differing first names, titles, and nationalities.
    For ease of manual examination, we limit ourselves to clusters compromising exactly
    six records:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们在一个群集中看到的属性变化，我们可以选择一些具有不同名字、头衔和国籍的群集子集。为了方便手动检查，我们限制自己仅检查包含确切六条记录的群集：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the resulting sanitized table, shown in [Figure 7-10](#fig-7-10), we can
    see a selection of these clusters in tabular form.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过消除姓名和出生年月信息后的结果表格中，我们可以在[图7-10](#fig-7-10)中以表格形式看到一些选定的群集。
- en: '![](assets/hoer_0710.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0710.png)'
- en: Figure 7-10\. Sample rows showing attribution variation in clusters of size
    six
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10\. 显示大小为六的簇中归属变化的样本行
- en: Cluster Visualization
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 簇可视化
- en: 'Now that we have our PSCs clustered together, we can perform a count of the
    number of companies each entity controls and then plot the distribution of these
    values in a histogram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的 PSC 聚集在一起，我们可以统计每个实体控制的公司数量，然后在直方图中绘制这些值的分布：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Figure 7-11](#fig-7-11) shows the resulting plot, which allows us to begin
    to answer our sample question—how concentrated is the control of UK companies?
    We can see that the majority of individuals control only a single company, with
    a smaller, but still very significant, number having influence over between 2
    and 10 firms. After that, the count falls dramatically until our data suggests
    that we have a handful of individuals with influence over more than 1,000 companies.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](#fig-7-11) 显示了结果图，允许我们开始回答我们的样本问题——英国公司控制的集中度有多高？我们可以看到，大多数个人只控制一家公司，较小但仍非常重要的数字控制着2到10家公司的影响力。之后，数量急剧下降，直到我们的数据表明，我们有一些个人对1000多家公司有影响力。'
- en: '![](assets/hoer_0711.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0711.png)'
- en: Figure 7-11\. Histogram distribution of significant company control
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-11\. 显著公司控制的直方图分布
- en: If, like me, you think the significant control of over 1,000 companies sounds
    a little unlikely, then it’s time we examine our clustering results in a little
    more detail to see what may be going on. To get a feel for the issues, let’s look
    at the subset of clusters formed from exactly six records.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，认为对1000多家公司进行显著控制听起来有些不太可能，那么现在是时候我们更详细地检查我们的簇结果，看看可能发生了什么。为了了解问题，让我们看看由恰好六条记录组成的簇的子集。
- en: Cluster Analysis
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 簇分析
- en: 'Splink provides us with a cluster studio dashboard, which we can interact with
    to explore the clusters we have generated to understand how they have been formed.
    The dashboard is persisted as an HTML page that we can display within the Jupyter
    environment as a Python inline frame (`IFrame`):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Splink 为我们提供了一个簇工作室仪表板，我们可以与之互动，探索我们生成的簇，以了解它们是如何形成的。仪表板以 HTML 页面形式持久保存，我们可以在
    Jupyter 环境中显示它，作为 Python 内联框架（`IFrame`）：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Figure 7-12](#fig-7-12) shows an example of the studio dashboard.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-12](#fig-7-12) 显示了一个工作室仪表板的示例。'
- en: '![](assets/hoer_0712.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0712.png)'
- en: Figure 7-12\. Splink cluster studio dashboard
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-12\. Splink 簇工作室仪表板
- en: 'Let’s consider an example cluster, reference: 766724.^([1](ch07.html#id538)) Remember
    that all the nodes in this cluster share the exact matches on the same last name,
    month, and year of birth due to the blocking rules.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例簇，参考：766724.^([1](ch07.html#id538)) 请记住，由于阻断规则，所有节点在此簇中都在同一姓氏、出生月份和出生年份上完全匹配。
- en: The cluster studio provides a graph view of each cluster with the nodes labeled
    with their assigned unique identifier and linked together with edges associated
    with each of the pairwise comparisons that exceeded the set threshold. This is
    shown in [Figure 7-13](#fig-7-13).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 簇工作室提供了每个簇的图形视图，节点用其分配的唯一标识符标记，并通过与超过设定阈值的每对比较相关的边连接在一起。这在 [图 7-13](#fig-7-13)
    中显示。
- en: '![](assets/hoer_0713.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0713.png)'
- en: Figure 7-13\. Example cluster
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-13\. 示例簇
- en: In this example, we can see that not all of the nodes are connected to each
    other. In fact, between the 6 nodes we have only 9 connected edges out of a possible
    15\. There are clearly two fully interconnected mini-clusters, linked together
    through node 766724. Let’s look at this in more detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到并不是所有节点都相互连接。实际上，在这6个节点之间，我们只有9条连接边，而可能有15条。显然有两个完全互联的迷你簇，通过节点
    766724 连接在一起。让我们详细看看这个问题。
- en: The cluster studio also provides a tabular view of the nodes so that we can
    examine the attributes in more detail, as shown sanitized in [Figure 7-14](#fig-7-14).
    We have sanitized the `Firstname` column—in this case, the first and third rows
    have the same spelling, which is slightly different from the other four rows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 簇工作室还提供了节点的表格视图，以便我们更详细地检查属性，如 [图 7-14](#fig-7-14) 所示。我们已对 `Firstname` 列进行了清理——在这种情况下，第一行和第三行的拼写相同，与其他四行略有不同。
- en: '![](assets/hoer_0714.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0714.png)'
- en: Figure 7-14\. Example cluster nodes
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-14\. 示例簇节点
- en: The top mini-cluster of nodes 8261597, 4524351, and 766724 all have the same
    `Nationality` and are also missing a `Middlename`. The second mini-cluster of
    nodes 766724, 5702850, 4711461, and 9502305 all have exactly matching `Firstname`
    values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 8261597、4524351 和 766724 的顶级迷你集群都具有相同的 `Nationality`，并且也缺少 `Middlename`。第二个迷你集群的节点
    766724、5702850、4711461 和 9502305 具有完全匹配的 `Firstname` 值。
- en: The sanitized tabular edge view, shown in [Figure 7-15](#fig-7-15), gives us
    the match weights and associated probabilities for these pairwise comparisons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 7-15](#fig-7-15) 中显示的经过清理的表边视图，为我们提供了这些成对比较的匹配权重和相关概率。
- en: '![](assets/hoer_0715.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0715.png)'
- en: Figure 7-15\. Example cluster edges
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-15\. 示例集群边缘
- en: If we increase our match threshold to filter out edges with a match weight threshold
    below 3.4, we break the two lowest scoring pairwise links. As seen in [Figure 7-16](#fig-7-16),
    our second mini-cluster remains intact but our first mini-cluster has broken apart,
    with nodes 8261597 and 4524351 now separate due to their different first name
    spelling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将匹配阈值提高到 3.4 以下的边缘进行过滤，我们会打破两个得分最低的成对链接。如图 [7-16](#fig-7-16) 所示，我们的第二个迷你集群保持完整，但我们的第一个迷你集群已经分裂，节点
    8261597 和 4524351 现在因为他们不同的名字拼写而分开。
- en: '![](assets/hoer_0716.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0716.png)'
- en: Figure 7-16\. Example clusters—high match threshold
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-16\. 示例集群 — 高匹配阈值
- en: Further increasing the match weight threshold to 8.7 breaks our first mini-cluster
    completely as the lack of `Middlename` becomes a deciding negative factor. This
    is shown in [Figure 7-17](#fig-7-17).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步增加匹配权重阈值到 8.7 完全打破我们的第一个迷你集群，因为缺少 `Middlename` 成为一个决定性的负面因素。如 [图 7-17](#fig-7-17)
    所示。
- en: '![](assets/hoer_0717.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0717.png)'
- en: Figure 7-17\. Example clusters—higher match threshold
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-17\. 示例集群 — 更高的匹配阈值
- en: Increasing the match weight to a very high threshold of 9.4 causes node 766724
    to break apart due to its slightly different first name spelling, as shown in
    [Figure 7-18](#fig-7-18).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将匹配权重增加到非常高的阈值 9.4 导致节点 766724 因其稍有不同的名字拼写而分裂，如 [图 7-18](#fig-7-18) 所示。
- en: '![](assets/hoer_0718.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_0718.png)'
- en: Figure 7-18\. Example clusters—highest match threshold
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-18\. 示例集群 — 最高匹配阈值
- en: As we can see, the size and density of our clusters is highly dependent upon
    the thresholds we set for grouping pairwise comparisons together.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们的集群的大小和密度高度依赖于我们为将成对比较分组设置的阈值。
- en: The Companies House website gives us access to information on the address associated
    with these PSC records. Company numbers 8261597, 4711461, and 4524351 were all
    registered by an individual giving the same address, as were 5702850 and 9502305\.
    This gives us more confidence that this cluster does indeed represent one individual.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 公司注册局网站为我们提供了与这些 PSC 记录关联的地址信息。公司编号 8261597、4711461 和 4524351 都由同一地址的个人注册，以及公司编号
    5702850 和 9502305。这使我们更有信心，这个集群确实代表了一个个人。
- en: A wider review suggests that our first pass at assessing the concentration of
    control over UK companies was perhaps too optimistic. Setting our match and clustering
    thresholds at 0.9 has erred toward overlinking, resulting in larger clusters with
    weaker associations. This may go some way to explain the rather dubious assessment
    of several individuals with significant control of more than 1,000 companies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛的审查表明，我们对评估英国公司控制集中度的第一步可能过于乐观了。将我们的匹配和聚类阈值设置在 0.9，导致过度连接，产生了具有较弱关联的更大的集群。这可能在一定程度上解释了对控制超过
    1,000 家公司的几个个人的相当可疑评估。
- en: I hope that working through this sample problem has illustrated that entity
    resolution with messy real-world data is not an exact science. There is no single
    right answer, and judgment is needed to set the matching thresholds to the optimum
    values for the outcomes you are seeking to achieve.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望通过处理这个示例问题，说明了在处理混乱的真实世界数据时，实体解析并不是一门精确的科学。没有一个单一的正确答案，需要判断来设置匹配阈值，以达到你所追求的结果的最佳值。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how entity resolution within and across multiple
    datasets can produce a large number of pairwise comparisons. We learned how to
    select and evaluate blocking rules to reduce these combinations to a more practical
    volume to allow us to train and then run our matching algorithm in a reasonable
    timeframe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到如何在多个数据集内和跨数据集之间进行实体解析，这产生了大量的成对比较。我们学习了如何选择和评估阻塞规则，以减少这些组合到一个更实际的数量，使我们能够在合理的时间范围内训练和运行我们的匹配算法。
- en: Using approximate matching and probabilistic entity resolution, we were able
    to generate clusters from pairwise comparisons, allowing for variations in some
    of the attributes. However, we were left with the canonicalization challenge of
    how to decide which attribute values to use to describe our unified entity.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用近似匹配和概率实体解析，我们能够从成对比较中生成集群，允许某些属性的变化。然而，我们面临着归一化的挑战，即如何决定使用哪些属性值来描述我们的统一实体。
- en: We also learned how to use graph visualizations to help us understand our clusters.
    We saw how cluster size and composition is strongly influenced by our choice of
    match threshold and that the risks of over- or underlinking need to be balanced
    in the context of a particular dataset and desired outcome.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用图形可视化来帮助我们理解我们的集群。我们看到集群的大小和组成在很大程度上受到我们选择的匹配阈值的影响，并且在特定数据集和期望的结果背景下，需要平衡过度连接或欠连接的风险。
- en: '^([1](ch07.html#id538-marker)) Note: If you are following along with your own
    notebook and PSC dataset, your cluster references may vary.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#id538-marker)) 注意：如果您正在使用自己的笔记本和PSC数据集进行跟进，您的集群引用可能会有所不同。
